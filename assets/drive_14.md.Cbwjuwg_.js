import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-bf06eb13"]]),N=JSON.parse('[{"question":"**Coding Problem: Prefix Trie (Autocomplete System)** # Problem Statement You are tasked with implementing a simplified version of an autocomplete system using a prefix trie (also known as a prefix tree). The system should allow you to efficiently insert words and find all words that start with a given prefix. You must implement two functions: - `insert(word)`: Inserts a word into the trie. - `find_words_with_prefix(prefix)`: Returns a list of all words in the trie that start with the given prefix. # Input - `word`: A string to be inserted into the trie. - `prefix`: A prefix string to search for in the trie. # Output - For the `find_words_with_prefix(prefix)` function, return a list of strings representing all words in the trie that start with the given prefix. # Constraints - The input words will consist only of lowercase English letters. - The maximum number of words that can be inserted into the trie is 10,000. - The length of each word will not exceed 100 characters. - The function `find_words_with_prefix(prefix)` should be efficient, with an average time complexity better than O(n) per prefix search, where n is the number of words in the trie. # Example ```python autocomplete = Trie() autocomplete.insert(\\"hello\\") autocomplete.insert(\\"hell\\") autocomplete.insert(\\"helicopter\\") autocomplete.insert(\\"help\\") autocomplete.insert(\\"healthy\\") print(autocomplete.find_words_with_prefix(\\"he\\")) # Output: [\'hello\', \'hell\', \'helicopter\', \'help\', \'healthy\'] print(autocomplete.find_words_with_prefix(\\"hel\\")) # Output: [\'hello\', \'hell\', \'helicopter\', \'help\'] print(autocomplete.find_words_with_prefix(\\"hea\\")) # Output: [\'healthy\'] print(autocomplete.find_words_with_prefix(\\"ho\\")) # Output: [] ``` # Implementation Details 1. Define a `TrieNode` class that contains a dictionary for child nodes and a boolean flag indicating the end of a word. 2. Create a `Trie` class that contains the root of the Trie and implements the `insert` and `find_words_with_prefix` methods. 3. Implement the `insert` method to add words to the Trie character by character. 4. Implement the `find_words_with_prefix` method to traverse the Trie from the root based on the given prefix and collect all the words that start with that prefix. # Template ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def find_words_with_prefix(self, prefix: str): def dfs(node, prefix, words): if node.is_end_of_word: words.append(prefix) for char, child in node.children.items(): dfs(child, prefix + char, words) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] words = [] dfs(node, prefix, words) return words # Example usage autocomplete = Trie() autocomplete.insert(\\"hello\\") autocomplete.insert(\\"hell\\") autocomplete.insert(\\"helicopter\\") autocomplete.insert(\\"help\\") autocomplete.insert(\\"healthy\\") print(autocomplete.find_words_with_prefix(\\"he\\")) # Output: [\'hello\', \'hell\', \'helicopter\', \'help\', \'healthy\'] print(autocomplete.find_words_with_prefix(\\"hel\\")) # Output: [\'hello\', \'hell\', \'helicopter\', \'help\'] print(autocomplete.find_words_with_prefix(\\"hea\\")) # Output: [\'healthy\'] print(autocomplete.find_words_with_prefix(\\"ho\\")) # Output: [] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def find_words_with_prefix(self, prefix: str): def dfs(node, prefix, words): if node.is_end_of_word: words.append(prefix) for char, child in node.children.items(): dfs(child, prefix + char, words) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] words = [] dfs(node, prefix, words) return words"},{"question":"# Check for Duplicates in a Stream Write a function to determine if there are any duplicates in a stream of integers. The function will receive a list of integers that may contain duplicate values. Your goal is to identify if at least one number appears more than once in the list. Function Specification **Function**: `has_duplicates(nums: List[int]) -> bool` **Input**: - A list of integers, `nums`, where each integer can range from -10^7 to 10^7. - The length of the list, `len(nums)`, varies from 0 to 10^6. **Output**: - A single boolean value: `True` if any number appears more than once in the list, `False` otherwise. Examples ```python >>> has_duplicates([1, 2, 3, 4, 5]) False >>> has_duplicates([1, 2, 3, 4, 1]) True >>> has_duplicates([5, 5, 5, 5, 5]) True >>> has_duplicates([]) False ``` Constraints 1. The function should operate in linear time. 2. Use only a constant amount of extra space, excluding the input list. Hint - Consider using data structures that can efficiently track seen values to achieve the desired time complexity.","solution":"def has_duplicates(nums): Determine if there are any duplicates in a stream of integers. :param nums: List[int] - List of integers :return: bool - True if any number appears more than once, False otherwise seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"# Question # Evaluating Polish Notation Expression Write a Python function that evaluates an arithmetic expression given in Polish notation (prefix notation). In Polish notation, operators precede their operands. The function should handle the four basic arithmetic operators: addition, subtraction, multiplication, and division. Function Signature ```python def evaluate_polish_notation(expression: List[str]) -> float: Parameters: expression (List[str]): A list of strings representing the Polish notation expression. Returns: result (float): The result of evaluating the expression. ``` Input * A list `expression` containing a valid Polish notation expression. * Operators: `+`, `-`, `*`, `/` * Each operand is a real number (positive, negative, integer, or floating point). Output * A float representing the result of evaluating the given Polish notation expression. Example ```python >>> evaluate_polish_notation([\\"+\\", \\"4\\", \\"*\\", \\"3\\", \\"2\\"]) 10.0 >>> evaluate_polish_notation([\\"-\\", \\"/\\", \\"10\\", \\"5\\", \\"3\\"]) -1.0 >>> evaluate_polish_notation([\\"*\\", \\"+\\", \\"1\\", \\"2\\", \\"3\\"]) 9.0 ``` Constraints * The input list will always represent a valid Polish notation expression. * Each operation will have the correct number of operands. * Division by zero will not occur in the input. # Implementation Requirements 1. Use a stack-based approach to evaluate the expression. 2. Ensure the function is optimized for performance and can handle large input lists efficiently. 3. Write at least three test cases to validate the correctness of your implementation.","solution":"def evaluate_polish_notation(expression): stack = [] # Reverse the expression list to process from right to left for token in reversed(expression): if token in \\"+-*/\\": op1 = stack.pop() op2 = stack.pop() if token == \'+\': result = op1 + op2 elif token == \'-\': result = op1 - op2 elif token == \'*\': result = op1 * op2 elif token == \'/\': result = op1 / op2 stack.append(result) else: stack.append(float(token)) return stack.pop()"},{"question":"# Problem Statement: You are given an array of integers representing the heights of buildings along a street, and you need to determine the amount of water that will be trapped after a heavy rain. The water trapped between two buildings is determined by the shorter of the two heights and must account for any other buildings in between. Your task is to implement the function `calculate_trapped_water` which efficiently computes the total amount of trapped water. # Function Signature: ```python def calculate_trapped_water(heights: list[int]) -> int: pass ``` # Input: - `heights`: A list of integers `heights` representing the heights of buildings along the street (0 <= len(heights) <= 10^6), where each height is a non-negative integer (0 <= heights[i] <= 10^4). # Output: - An integer representing the total amount of trapped water. # Example: ```python heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(calculate_trapped_water(heights)) # Output: 6 ``` # Constraints: - Time complexity should be O(n). - Space complexity should be O(n). # Additional Notes: - Your solution should handle edge cases like empty arrays, arrays with no space for trapping water (e.g., arrays that are strictly increasing or decreasing), and arrays with varying building heights. - Ensure the solution efficiently calculates the trapped water even for large input sizes. # Algorithm Guidance: - Consider using a two-pointer approach to solve the problem in linear time. - Optionally, you may use precomputed arrays for left and right max heights to aid in the calculation.","solution":"def calculate_trapped_water(heights: list[int]) -> int: Calculate the total amount of water trapped between buildings after raining. Args: heights (list of int): List of non-negative integers representing building heights. Returns: int: Total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Matrix Rotation **Context**: You are working on a program for image processing and need to rotate images. Represent the image as a square matrix of integers where each integer represents a pixel. Your task is to rotate the image by 90 degrees clockwise. **Task**: Implement a function `rotate_matrix_90_clockwise` that takes a square matrix as input, rotates it by 90 degrees to the right (clockwise), and returns the rotated matrix. **Function Signature**: ```python def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass ``` **Input**: * `matrix`: A square matrix (list of lists) of integers, where each sub-list represents a row in the matrix, and all rows have the same length. **Output**: * A new square matrix (list of lists) representing the original matrix rotated by 90 degrees clockwise. **Constraints**: * The input matrix is always a square matrix (n x n) where 1 <= n <= 1000. * Each element in the matrix is an integer, and elements can be both positive and negative. **Example**: ```python # Example matrix (3x3) matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Expected rotated matrix (90 degrees clockwise) # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_matrix_90_clockwise(matrix)) ``` # Guidelines: 1. Do not use any built-in matrix rotation functions; implement the rotation algorithm manually. 2. Ensure your function handles matrices of various sizes, ranging from 1x1 to 1000x1000. 3. Test your solution with different matrices to ensure accuracy and handle potential edge cases, like single-element matrices or matrices with negative integers.","solution":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): The input square matrix. Returns: List[List[int]]: The matrix rotated by 90 degrees clockwise. n = len(matrix) rotated = [] for col in range(n): new_row = [] for row in range(n-1, -1, -1): new_row.append(matrix[row][col]) rotated.append(new_row) return rotated"},{"question":"# Problem Statement: You are provided with a function that determines if a given integer is a perfect square by using a direct mathematical check. Your task is to implement a new function named `perfect_squares_in_range(start: int, end: int) -> List[int]` that generates all perfect square numbers within a given inclusive range `[start, end]`. # Requirements: 1. If `start` is greater than `end`, return an empty list. 2. Ensure the function handles edge cases like negative ranges appropriately. 3. Optimize the function to avoid unnecessary computations for non-relevant values. # Function Signature: ```python def perfect_squares_in_range(start: int, end: int) -> List[int]: pass ``` # Input Format: * `start`: An integer representing the beginning of the range. * `end`: An integer representing the end of the range. # Output Format: * A list of integers representing perfect squares within the specified range. # Example: ```python # Example 1 start = 1 end = 16 # Perfect squares in range: [1, 4, 9, 16] print(perfect_squares_in_range(start, end)) # Example 2 start = 5 end = 30 # Perfect squares in range: [9, 16, 25] print(perfect_squares_in_range(start, end)) # Example 3 start = 20 end = 25 # Perfect squares in range: [25] print(perfect_squares_in_range(start, end)) ``` # Constraints: * `start` and `end` can be any integer within the range of 32-bit signed integers.","solution":"import math from typing import List def perfect_squares_in_range(start: int, end: int) -> List[int]: Returns a list of all perfect square numbers within the given inclusive range [start, end]. if start > end: return [] if end < 0: return [] start_root = math.ceil(math.sqrt(max(0, start))) end_root = math.floor(math.sqrt(end)) return [i**2 for i in range(start_root, end_root+1)]"},{"question":"# Problem Overview You are given two strings, `s` and `t`. Your task is to write a function that determines if `s` can be converted to `t` by performing any number of character replacements in `s` such that every character in `s` maps to exactly one character in `t` and vice versa. # Function Signature ```python def is_isomorphic(s: str, t: str) -> bool: pass ``` # Input * `s`: A string consisting of lowercase English letters. * `t`: A string consisting of lowercase English letters. # Output Return `True` if `s` can be converted to `t` under the conditions described above. Otherwise, return `False`. # Constraints 1. 0 <= len(s), len(t) <= 10^4 2. Both strings have the same length. # Examples ```python # Example 1 print(is_isomorphic(\\"egg\\", \\"add\\")) # Expected Output: True # Example 2 print(is_isomorphic(\\"foo\\", \\"bar\\")) # Expected Output: False # Example 3 print(is_isomorphic(\\"paper\\", \\"title\\")) # Expected Output: True # Example 4 print(is_isomorphic(\\"ab\\", \\"aa\\")) # Expected Output: False ``` # Notes - Two strings s and t are isomorphic if the characters in s can be replaced to get t, given that no two characters may map to the same character but one character may not replace two different characters. - Your solution should efficiently handle strings close to the upper limit of the constraint.","solution":"def is_isomorphic(s: str, t: str) -> bool: Returns whether the string s can be converted to the string t by replacing characters, ensuring that each character in s maps to exactly one character in t and each character in t is mapped by exactly one character in s. if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False mapping_s_to_t[char_s] = char_t mapping_t_to_s[char_t] = char_s return True"},{"question":"# Coding Question **Context**: A weather forecasting system uses a sequence of temperature readings to predict future conditions. The system needs a function to calculate statistical measures from temperature recordings. **Objective**: Write a function `calculate_temperature_statistics(temperatures: List[int]) -> Tuple[int, float, int]` that computes some key statistics from a list of temperature readings. # Criteria: 1. **Input**: * A list of integers `temperatures` representing daily temperature readings. 2. **Output**: * A tuple containing: * The highest temperature. * The average temperature (rounded to one decimal place). * The lowest temperature. 3. **Constraints**: * Your function should handle an empty list gracefully by returning a tuple of `(0, 0.0, 0)`. 4. **Performance**: * Ensure that the statistical calculations are performed efficiently even for large lists. # Example: ```python def calculate_temperature_statistics(temperatures: List[int]) -> Tuple[int, float, int]: # Your implementation here print(calculate_temperature_statistics([30, 25, 20, 29, 31])) # Expected: (31, 27.0, 20) print(calculate_temperature_statistics([])) # Expected: (0, 0.0, 0) ``` Write your function to solve this problem, ensuring correctness, efficiency, and proper handling of edge cases.","solution":"from typing import List, Tuple def calculate_temperature_statistics(temperatures: List[int]) -> Tuple[int, float, int]: Returns the highest temperature, average temperature (rounded to one decimal place), and lowest temperature from a list of temperature readings. if not temperatures: return (0, 0.0, 0) highest = max(temperatures) average = round(sum(temperatures) / len(temperatures), 1) lowest = min(temperatures) return (highest, average, lowest)"},{"question":"# Coding Assessment Question Problem Statement Create an efficient function to determine if a given integer is a power of three. An integer `num` is a power of three if there exists an integer `k` such that `num == 3^k`. Task Implement a function `is_power_of_three(num: int) -> bool` that returns `True` if `num` is a power of three, otherwise it returns `False`. Input * `num` (int): The integer to check. `-10^9 <= num <= 10^9`. You should handle the following constraints: * `num` must be an integer. If it is not, raise a `TypeError`. Output * Returns a boolean indicating whether the integer is a power of three. Example ```python >>> is_power_of_three(27) True >>> is_power_of_three(1) True >>> is_power_of_three(0) False >>> is_power_of_three(-3) False >>> is_power_of_three(10) False ``` Additional Information * The function must raise `TypeError` if the input is not an integer. Edge Cases * `is_power_of_three(0)` should return `False` as 0 is not a power of three. * `is_power_of_three(1)` should return `True` as 1 == 3^0. * `is_power_of_three(-3)` should return `False` because powers of three cannot be negative. Constraints * `-10^9 <= num <= 10^9`","solution":"def is_power_of_three(num): Determine if a given integer is a power of three. Returns True if num is a power of three, else False. Raises TypeError if the input is not an integer. if not isinstance(num, int): raise TypeError(\\"Input must be an integer\\") if num <= 0: return False while num % 3 == 0: num //= 3 return num == 1"},{"question":"# Data Analysis & Visualization You have been provided with a CSV file containing information about various movies. Your task is to implement a function that reads this CSV file, processes the data, and generates a bar chart visualizing the number of movies released each year within a specified range. Task: Implement a function `plot_movie_releases(file_path: str, start_year: int, end_year: int) -> None` that reads the CSV file, processes the data, and plots a bar chart showing the count of movie releases for each year within the given range. Requirements: 1. **Input:** * `file_path` (string): The path to the CSV file containing movie data. * `start_year` (integer): The start year for the range. * `end_year` (integer): The end year for the range. 2. **Output:** None. The function should display a bar chart. 3. The CSV file will have at least the following columns: * `Title` (string) - The title of the movie. * `Release Year` (integer) - The year the movie was released. 4. Ensure the function handles the following edge cases: * Missing or invalid data in the `Release Year` column. * No movies present in the specified year range. 5. Use appropriate libraries (e.g., `pandas` for data manipulation and `matplotlib` for plotting). Example CSV Structure: ``` Title,Release Year Movie A,2000 Movie B,2001 Movie C,2002 ... ``` Example: ```python plot_movie_releases(\'movies.csv\', 2000, 2010) ``` This should read the data from `movies.csv`, process it, and generate a bar chart displaying the number of movie releases for each year from 2000 to 2010. Note: Ensure the bar chart is clearly labeled, with appropriate titles and axis labels. Handle any data anomalies or inconsistencies gracefully.","solution":"import pandas as pd import matplotlib.pyplot as plt def plot_movie_releases(file_path: str, start_year: int, end_year: int) -> None: Reads a CSV file containing movie data, processes the data, and plots a bar chart showing the number of movies released each year within the specified range. Parameters: - file_path (str): Path to the CSV file containing movie data. - start_year (int): The start year for the range. - end_year (int): The end year for the range. Returns: - None. Displays a matplotlib bar chart. # Read the CSV file try: df = pd.read_csv(file_path) except Exception as e: print(f\\"Error reading the CSV file: {e}\\") return # Verify that the necessary columns are present if \'Release Year\' not in df.columns: print(\\"The CSV file does not have the required \'Release Year\' column.\\") return # Filter out rows with invalid or missing \'Release Year\' df = df[pd.to_numeric(df[\'Release Year\'], errors=\'coerce\').notnull()] df[\'Release Year\'] = df[\'Release Year\'].astype(int) # Filter data to include only the specified year range df_filtered = df[(df[\'Release Year\'] >= start_year) & (df[\'Release Year\'] <= end_year)] # Group by \'Release Year\' and count the number of movies movie_counts = df_filtered[\'Release Year\'].value_counts().sort_index() # Generate the years range and ensure every year has a count years_range = range(start_year, end_year + 1) counts = [movie_counts.get(year, 0) for year in years_range] # Plot the bar chart plt.figure(figsize=(10, 6)) plt.bar(years_range, counts, color=\'skyblue\') plt.xlabel(\'Year\') plt.ylabel(\'Number of Movies\') plt.title(\'Number of Movie Releases per Year\') plt.xticks(years_range, rotation=45) plt.tight_layout() plt.show()"},{"question":"# String Formatting and Validation You need to implement a function that formats a given string by reversing the order of the words and ensures the input validation as per the given requirements. Requirements: 1. **Input**: A string `sentence` consisting of words separated by single spaces. 2. **Output**: A string with the words in the reversed order, separated by single spaces. **Function Signature:** ```python def reverse_words(sentence: str) -> str: ``` Constraints: 1. If the input is not a string, the function should raise a `TypeError` with the message `\\"Input must be a string\\"`. 2. If the input string is empty, or contains only spaces, raise a `ValueError` with the message `\\"Input cannot be empty or only spaces\\"`. 3. The input string should not contain leading or trailing spaces. # Example Usage: - Example 1: ```python >>> reverse_words(\\"hello world\\") \'world hello\' ``` - Example 2: ```python >>> reverse_words(\\"this is a test\\") \'test a is this\' ``` # Additional Examples: - Input: `reverse_words(\\"coding is fun\\")` - Output: `\'fun is coding\'` - Input: `reverse_words(\\"Python is awesome\\")` - Output: `\'awesome is Python\'` Note: - Ensure to address the constraints and handle edge cases where inputs are not valid. - The function should efficiently handle the word reversal to maintain performance even with larger sentences.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Parameters: sentence (str): The sentence to reverse. Returns: str: The sentence with the words in reversed order. Raises: TypeError: If the input is not a string. ValueError: If the input string is empty or only contains spaces. if not isinstance(sentence, str): raise TypeError(\\"Input must be a string\\") if sentence.strip() == \\"\\": raise ValueError(\\"Input cannot be empty or only spaces\\") words = sentence.split() reversed_words = \\" \\".join(reversed(words)) return reversed_words"},{"question":"# Question: You are tasked with improving a sorting algorithm for a special case of integer sequences. Your goal is to implement a function that sorts an array of integers where each integer appears at most twice. The function must run in O(n log n) time complexity and be able to handle arrays of large size efficiently. Function Signature ```python def sort_special_array(arr: List[int]) -> List[int]: pass ``` # Input: - A list of integers `arr` (1 ≤ len(arr) ≤ 10^6), where each integer appears at most twice. # Output: - A sorted list of integers. # Constraints: - The list will contain integers with possible repetitions, but no integer will repeat more than twice. - The integers can be negative, zero, or positive. - You must optimize to handle the largest input sizes efficiently. # Performance Requirements: - The solution should execute within a reasonable time frame for the maximum input size. # Examples: - `sort_special_array([4, 2, 4, 1, 7, 1, 2, 9]) -> [1, 1, 2, 2, 4, 4, 7, 9]` - `sort_special_array([5, 3, 3, 8, 5, -1, 0, 0]) -> [-1, 0, 0, 3, 3, 5, 5, 8]` - `sort_special_array([10, 2, 9, 2]) -> [2, 2, 9, 10]` # Additional Context: The task is similar to sorting a regular array but with the added simplification that no element appears more than twice, which potentially simplifies handling duplicates. The typical sorting algorithms are applicable in this context, but make sure to choose one that efficiently handles the given constraints and input size.","solution":"def sort_special_array(arr): Sorts an array of integers where each integer appears at most twice. :param arr: List of integers :return: Sorted list of integers return sorted(arr)"},{"question":"**Question: \\"Simulating Population Growth with the Logistic Equation\\"** **Context**: Population dynamics can be modeled using differential equations, such as the logistic growth model, which describes how populations grow rapidly when small but slow their growth as they approach a maximum sustainable population size. You\'re tasked with implementing a function to simulate population growth over time using the Euler method. **Task**: Implement the function `logistic_growth_simulation` to estimate population size at discrete intervals using the Euler method. # Function Signature: ```python def logistic_growth_simulation(initial_population: float, time_span: float, step_size: float, carrying_capacity: float, growth_rate: float) -> np.ndarray: ``` # Input: - `initial_population` (float): The initial size of the population (P at t=0). Must be positive. - `time_span` (float): The total time for which the simulation runs. Must be positive. - `step_size` (float): The increment of time for each step in the simulation. Must be positive. - `carrying_capacity` (float): The maximum sustainable population size. Must be positive. - `growth_rate` (float): The intrinsic growth rate of the population. Must be positive. # Output: - Return a numpy array containing the estimated population sizes at each timestep. # Constraints: - The differential equation modeling the population growth is `dP/dt = r * P * (1 - P / K)` (Where `P` is the population size, `r` is the growth rate, and `K` is the carrying capacity). # Requirements: - Use the Euler method to solve for the population sizes over the given time span. - Handle edge cases like non-positive `initial_population`, `time_span`, `step_size`, `carrying_capacity`, and `growth_rate`. # Example: ```python # Example input initial_population = 50.0 time_span = 10.0 step_size = 0.5 carrying_capacity = 500.0 growth_rate = 0.1 # Call the function population_estimations = logistic_growth_simulation(initial_population, time_span, step_size, carrying_capacity, growth_rate) ``` In this example, with a `step_size` small enough, the array `population_estimations` should return values showing the population size starting at 50 and approaching 500 over the 10 time units as the population grows and stabilizes. Note: Your solution should demonstrate an understanding of the logistic growth model and the Euler method. Your simulation should correctly reflect population changes at each timestep, providing an estimate in line with the provided parameters.","solution":"import numpy as np def logistic_growth_simulation(initial_population: float, time_span: float, step_size: float, carrying_capacity: float, growth_rate: float) -> np.ndarray: Simulates population growth using the Euler method for the logistic growth equation. # Number of time steps num_steps = int(time_span / step_size) + 1 # Initialize array to store population sizes population = np.zeros(num_steps) # Set initial population size population[0] = initial_population # Euler method to simulate population growth for t in range(1, num_steps): current_population = population[t-1] population_change = growth_rate * current_population * (1 - current_population / carrying_capacity) population[t] = current_population + step_size * population_change return population"},{"question":"# String Permutation Finder You are tasked with writing a function that generates all possible permutations of a given string. Each permutation must be a unique rearrangement of the characters in the string. Implement the following function: 1. `string_permutations(s: str) -> List[str]`: Generates all unique permutations of the input string `s` and returns them as a list of strings. # Expected Input and Output - The function takes a single string `s` as input. - **Input constraint**: The string length is between 1 and 8 characters. - The function should return a list of strings containing all unique permutations of the input string `s`. # Example Suppose you have the following inputs: Example 1: - Input: `\\"abc\\"` - Expected Output: `[\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]` Example 2: - Input: `\\"aab\\"` - Expected Output: `[\\"aab\\", \\"aba\\", \\"baa\\"]` # Constraints: - Ensure the result does not contain duplicate permutations. - Optimize the solution to handle the upper constraint efficiently. - Avoid using global variables to ensure the function is self-contained. Implement the function ensuring it adheres to the above specifications and handles the given constraints effectively.","solution":"from typing import List from itertools import permutations def string_permutations(s: str) -> List[str]: Generates all unique permutations of the input string `s`. :param s: Input string :return: List of unique permutations of the input string perm_set = set(permutations(s)) perm_list = [\'\'.join(perm) for perm in perm_set] return sorted(perm_list)"},{"question":"# Problem Statement You are required to write a Python function that simulates a pill-taking process over a number of days, and calculate the probability that a person will never have taken more than one pill of the same type in a single day. Each day, the person takes either a blue pill or a red pill. # Function Signature Your task is to implement the following function: ```python def pill_probability(D: int) -> float: This function returns the probability that a person will never have taken more than one pill of the same type in a single day, over D days. :param D: The number of days. :type D: int :return: The probability as a floating point number. :rtype: float Example: >>> pill_probability(1) 1.0 >>> pill_probability(2) 0.6666666666666666 pass ``` # Input * A single integer `D` representing the number of days (where 1 <= D <= 1000). # Output * A single floating-point number representing the probability that a person will never have taken more than one pill of the same type on any day. # Constraints * The input `D` will always be a positive integer up to 1000. # Example ```python >>> pill_probability(1) 1.0 >>> pill_probability(2) 0.6666666666666666 >>> pill_probability(3) 0.5 ``` # Additional Information * The person can take a blue or red pill every day. * The probability is based on the assumption that the pill of the same type should not be taken consecutively on any day.","solution":"def pill_probability(D): Returns the probability that a person will never have taken more than one pill of the same type in a single day, over D days. :param D: The number of days. :type D: int :return: The probability as a floating point number. :rtype: float Example: >>> pill_probability(1) 1.0 >>> pill_probability(2) 0.6666666666666666 if D == 1: return 1.0 return 2 / (D + 1)"},{"question":"**Question: Optimized Merge Sort for Linked List** **Context:** Bob is developing a system that handles large datasets represented as linked lists. Sorting these linked lists efficiently is critical for his application’s performance. While Merge Sort works well with linked lists due to its divide-and-conquer approach and ease of managing pointers, Bob wants to ensure the implementation is optimized for both space and time. **Task:** Your task is to implement an optimized Merge Sort algorithm specifically for singly linked lists with the following specifications: 1. Utilize the \\"fast and slow pointer\\" technique to find the middle of the linked list efficiently. 2. Implement an in-place merge function to minimize the additional space overhead. **Function Signature:** ```python def merge_sort_linked_list(head: ListNode) -> ListNode: pass ``` **Input:** - `head` (a ListNode): The head node of a singly linked list to be sorted. **Output:** - A ListNode representing the head of the sorted linked list. **Constraints:** - The linked list may contain up to (10^6) elements. - Elements within the linked list are comparable (e.g., integers or floating-point numbers). **Definitions:** ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next ``` **Examples:** 1. Given a linked list represented as `1 -> 4 -> 2 -> 8 -> 5`, calling `merge_sort_linked_list(head)` should return a linked list in sorted order: `1 -> 2 -> 4 -> 5 -> 8`. 2. Given a linked list represented as `-3 -> 10 -> 0 -> -45 -> 5`, calling `merge_sort_linked_list(head)` should return: `-45 -> -3 -> 0 -> 5 -> 10`. 3. Given a linked list represented as `4 -> 3 -> 2 -> 1`, calling `merge_sort_linked_list(head)` should return: `1 -> 2 -> 3 -> 4`. 4. Given a single element linked list represented as `7`, calling `merge_sort_linked_list(head)` should return: `7`. **Additional Notes:** 1. Implement the \\"fast and slow pointer\\" technique to split the linked list. 2. Ensure that the merge operation efficiently handles linked list nodes in-place. 3. The solution should be optimized to handle large linked lists efficiently. --- This new question fits with the style, complexity, and scope of the given sample question. It involves a similar level of understanding of sorting algorithms and data structures, specifically tailored to linked lists, ensuring a complementary and coherent set.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: Sorts a linked list using merge sort algorithm. Args: head (ListNode): The head of the singly linked list to be sorted. Returns: ListNode: The head of the sorted linked list. if not head or not head.next: return head # Helper function to split the linked list into two halves def split(head): slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next # Split the linked list prev.next = None return head, slow # Helper function to merge two sorted linked lists def merge(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next # Recursive merge sort def merge_sort(head): if not head or not head.next: return head left, right = split(head) left = merge_sort(left) right = merge_sort(right) return merge(left, right) return merge_sort(head)"},{"question":"# Genetic Algorithm for Function Optimization As a software developer in a high-tech R&D team, you have been tasked with implementing a genetic algorithm (GA) for optimizing a given mathematical function. Genetic algorithms are a class of optimization techniques based on principles of natural selection and genetics. Your goal is to create a GA that can find the global optimum of the provided mathematical function. Requirements: 1. **Representation of Individuals**: - Implement the function `initialize_population(pop_size, gene_length, min_val, max_val)` that generates and returns an initial population of individuals, where each individual is represented as a list of genes (floating point numbers). 2. **Fitness Evaluation**: - Implement the function `evaluate_population(population, fitness_function)` that calculates and assigns a fitness score to each individual in the population based on their ability to optimize the given `fitness_function`. 3. **Selection**: - Implement the function `selection(population, fitness_scores)` that selects individuals based on their fitness scores for reproduction. 4. **Crossover**: - Implement the function `crossover(parent1, parent2, crossover_rate)` that combines two parent individuals to produce offspring using a given `crossover_rate`. 5. **Mutation**: - Implement the function `mutate(individual, mutation_rate, min_val, max_val)` that randomly alters an individual\'s genes based on a given `mutation_rate`. 6. **Complete the Genetic Algorithm**: - Inside the `genetic_algorithm` function, combine the functions `initialize_population`, `evaluate_population`, `selection`, `crossover`, and `mutate` to perform the genetic algorithm optimization over multiple generations. # Inputs and Outputs **Function**: `initialize_population` - **Input**: - `pop_size` (int): number of individuals in the population. - `gene_length` (int): length of the gene representing an individual. - `min_val` (float): minimum value for a gene. - `max_val` (float): maximum value for a gene. - **Output**: - A list of individuals, where each individual is a list of genes. **Function**: `evaluate_population` - **Input**: - `population` (list): list of individuals. - `fitness_function` (function): function to evaluate individual fitness. - **Output**: - A list of fitness scores corresponding to the population individuals. **Function**: `selection` - **Input**: - `population` (list): list of individuals. - `fitness_scores` (list): list of fitness scores of individuals. - **Output**: - A list of selected individuals for reproduction. **Function**: `crossover` - **Input**: - `parent1` (list): first parent individual. - `parent2` (list): second parent individual. - `crossover_rate` (float): probability of crossover occurring between parents. - **Output**: - A list representing the offspring produced by crossover. **Function**: `mutate` - **Input**: - `individual` (list): individual to mutate. - `mutation_rate` (float): probability of mutation occurring for each gene. - `min_val` (float): minimum value for a gene. - `max_val` (float): maximum value for a gene. - **Output**: - A mutated individual. **Function**: `genetic_algorithm` - **Input**: - `fitness_function` (function): function to evaluate fitness. - `pop_size` (int): number of individuals in the population. - `gene_length` (int): length of the gene representing an individual. - `min_val` (float): minimum value for a gene. - `max_val` (float): maximum value for a gene. - `crossover_rate` (float): probability of crossover. - `mutation_rate` (float): probability of mutation. - `generations` (int): number of generations to evolve the population. - **Output**: - The best individual found by the GA at the end of the evolution. # Performance Requirements: - The algorithm should efficiently handle the provided population size and gene lengths. - Ensure algorithm convergence within the specified number of generations. - Optimize performance where feasible to handle more complex optimization tasks effectively.","solution":"import random def initialize_population(pop_size, gene_length, min_val, max_val): Generates an initial population of individuals. return [[random.uniform(min_val, max_val) for _ in range(gene_length)] for _ in range(pop_size)] def evaluate_population(population, fitness_function): Calculates and assigns a fitness score to each individual in the population. return [fitness_function(ind) for ind in population] def selection(population, fitness_scores): Selects individuals based on their fitness scores for reproduction. total_fitness = sum(fitness_scores) probabilities = [score / total_fitness for score in fitness_scores] selected = random.choices(population, probabilities, k=len(population)) return selected def crossover(parent1, parent2, crossover_rate): Combines two parent individuals to produce offspring using a given crossover rate. if random.random() < crossover_rate: crossover_point = random.randint(1, len(parent1) - 1) return parent1[:crossover_point] + parent2[crossover_point:] return parent1 def mutate(individual, mutation_rate, min_val, max_val): Randomly alters an individual\'s genes based on a given mutation rate. return [ gene if random.random() > mutation_rate else random.uniform(min_val, max_val) for gene in individual ] def genetic_algorithm(fitness_function, pop_size, gene_length, min_val, max_val, crossover_rate, mutation_rate, generations): Performs the genetic algorithm optimization over multiple generations. population = initialize_population(pop_size, gene_length, min_val, max_val) for gen in range(generations): fitness_scores = evaluate_population(population, fitness_function) new_population = selection(population, fitness_scores) next_generation = [] for i in range(0, pop_size, 2): parent1, parent2 = new_population[i], new_population[(i + 1) % pop_size] child1 = mutate(crossover(parent1, parent2, crossover_rate), mutation_rate, min_val, max_val) child2 = mutate(crossover(parent2, parent1, crossover_rate), mutation_rate, min_val, max_val) next_generation.extend([child1, child2]) population = next_generation[:pop_size] fitness_scores = evaluate_population(population, fitness_function) best_individual = population[fitness_scores.index(max(fitness_scores))] return best_individual def fitness_function_example(individual): Example fitness function: Sum of genes. return sum(individual)"},{"question":"# Advanced Problem: Finding the Missing Number in an Arithmetic Progression Scenario You are building a function to identify the missing number in an arithmetic progression (AP). An arithmetic progression is a sequence of numbers in which the difference of any two successive members is a constant. Given a list of numbers where exactly one number is missing from the sequence, your task is to identify and return the missing number. Requirements * **Function Signature**: Implement the function `find_missing_number(arr: List[int]) -> int`. * **Input**: - `arr` (List[int]): A list of integers representing an incomplete arithmetic progression. The list is sorted in ascending order. * **Output**: - Return the missing number from the arithmetic progression. Constraints 1. The length of `arr` is at least 2 and up to 10^5. 2. The array contains at least one missing element, but no duplicates. 3. The common difference of the sequence will be a non-zero integer. 4. The elements in the array are within the range of `-10^9` to `10^9`. Performance Requirements - Your solution should run efficiently even for the largest values in the input range. - Aim for a time complexity of O(log n). Example ```python def find_missing_number(arr: List[int]) -> int: # Implement the function # Example usage: arr = [1, 3, 7, 9, 11] # Expected output: 5 print(find_missing_number(arr)) ``` Remember to handle edge cases, optimize for performance, and ensure your code is robust and well-documented. The missing number should be found with a focus on optimizing time complexity.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in an arithmetic progression. The function uses binary search for an optimal O(log n) time complexity. n = len(arr) # Calculate the expected common difference total_diff = arr[-1] - arr[0] d = total_diff // n # Common difference (integer division) left, right = 0, n - 1 while left <= right: mid = (left + right) // 2 # Check the expected value at midpoint expected_mid_value = arr[0] + mid * d if arr[mid] == expected_mid_value: left = mid + 1 else: right = mid - 1 # At the end of while loop, `left` should point to the location of the missing number return arr[0] + left * d"},{"question":"# Question: Validate and Clean Email Addresses In many applications, validating and cleaning up user-provided email addresses is a crucial step to ensure that the data you work with is accurate and consistent. An email address is considered valid if it meets the standard email format guidelines and does not contain any leading or trailing spaces. Task Implement a function `validate_and_clean_emails` that takes a list of email addresses and returns a list containing only the valid email addresses, cleaned of any leading or trailing spaces. Function Signature ```python def validate_and_clean_emails(email_list: list[str]) -> list[str]: ``` Input * `email_list`: A list of strings where each string is a potentially valid email address. Output * Returns a list of cleaned and validated email addresses. Constraints * Each entry in the `email_list` list is a string. * The list can contain empty strings or improperly formatted email addresses. * The returned list should retain the order of the valid email addresses as they appear in the input list. Examples ```python >>> validate_and_clean_emails([\' example@example.com \', \'invalid-email\', \'john.doe@gmail.com\', \' jane.doe@domain.org\']) [\'example@example.com\', \'john.doe@gmail.com\', \'jane.doe@domain.org\'] >>> validate_and_clean_emails([\'\', \'user@domain.com \', \' user@domain\', \'valid@valid.com\']) [\'user@domain.com\', \'valid@valid.com\'] >>> validate_and_clean_emails([\' invalid@invalid\', \'valid@domain \', \'@invalid.test\', \' valid@example.com \']) [\'valid@domain\', \'valid@example.com\'] ``` Notes * An email is considered valid if it follows the general format `local-part@domain` (there should be exactly one `@` symbol). * There should be at least one character before and after the `@` symbol. * No leading or trailing spaces should be present in the cleaned email addresses. * The function should be case-insensitive and consider only structural validity according to the format rules specified.","solution":"import re def validate_and_clean_emails(email_list): Validates and cleans a list of email addresses. Args: email_list: A list of strings representing email addresses. Returns: A list of valid and cleaned email addresses. def is_valid_email(email): # Regex pattern to validate standard email format pattern = r\'^[^@s]+@[^@s]+.[^@s]+\' return re.match(pattern, email) is not None cleaned_emails = [email.strip() for email in email_list] valid_emails = [email for email in cleaned_emails if is_valid_email(email)] return valid_emails"},{"question":"# Question: Implement Multi-task Logistic Regression You are required to implement a multi-task logistic regression model that can handle multiple classification tasks simultaneously. The model should be able to predict the class for each task independently, sharing a common base model structure. Step 1: Implement the Multi-task Logistic Regression 1. **Function Signature**: ```python import numpy as np class MultiTaskLogisticRegression: def __init__(self, num_tasks: int, num_features: int, lr: float = 0.01, epochs: int = 1000): Initialize the multi-task logistic regression model. :param num_tasks: Integer, number of classification tasks. :param num_features: Integer, number of features in the input data. :param lr: Float, learning rate for the optimization. :param epochs: Integer, number of epochs for the training process. def _sigmoid(self, z: np.ndarray) -> np.ndarray: Apply the sigmoid function. def _loss(self, y_true: np.ndarray, y_pred: np.ndarray) -> float: Calculate the loss using cross-entropy. def _train_task(self, X: np.ndarray, y: np.ndarray, W: np.ndarray, b: float) -> (np.ndarray, float): Train a single task and update weights and bias. def fit(self, X_list: [np.ndarray], y_list: [np.ndarray]): Train the multi-task logistic regression model. :param X_list: List of numpy arrays. Each array is of shape (m, n) with m samples and n features. :param y_list: List of numpy arrays. Each array is of shape (m,) with the class labels for each task. def predict(self, X: np.ndarray) -> [np.ndarray]: Predict the class labels for the given input data. :param X: Numpy array of shape (m, n) with the input data. :return: List of numpy arrays. Each array is of shape (m,) with the predicted class labels for each task. ``` 2. **Inputs**: - `X_list`: List of numpy arrays, each of shape (m, n) representing the input data for each task. - `y_list`: List of numpy arrays, each of shape (m,) representing the class labels for each task. - `num_tasks`: Integer, number of classification tasks. - `num_features`: Integer, number of features in the input data. - `lr`: Float, learning rate for the gradient descent optimization. - `epochs`: Integer, number of epochs for training. 3. **Outputs**: - `predictions`: List of numpy arrays, each of shape (m,) with the predicted class labels for each task. 4. **Procedure**: - Implement the sigmoid function for logistic regression. - Calculate the cross-entropy loss function for logistic regression. - Train each task using gradient descent to optimize the weights and biases. - Ensure that the model appropriately fits the multi-task scenario where each task shares a common model structure but can be independently optimized. - The `predict` method should compute the predictions for each task using the trained weights and biases. Step 2: Performance Evaluation 1. Verify your multi-task logistic regression by training it on a synthetic dataset or any publicly available multi-task dataset. 2. Evaluate the performance by comparing the predicted class labels with the true class labels. 3. Present the accuracy of the model for each task. ```python # Example usage: # Assuming X_list and y_list are pre-defined data for multiple tasks num_tasks = len(X_list) num_features = X_list[0].shape[1] model = MultiTaskLogisticRegression(num_tasks, num_features, lr=0.01, epochs=1000) model.fit(X_list, y_list) predictions = model.predict(X_list[0]) accuracy = np.mean(predictions[0] == y_list[0]) print(f\\"Accuracy for task 1: {accuracy * 100:.2f}%\\") ``` **Note**: Ensure that your implementation avoids using high-level libraries (such as `scikit-learn`) for core logistic regression operations, but you can use `numpy` for matrix operations and handling arrays.","solution":"import numpy as np class MultiTaskLogisticRegression: def __init__(self, num_tasks: int, num_features: int, lr: float = 0.01, epochs: int = 1000): Initialize the multi-task logistic regression model. :param num_tasks: Integer, number of classification tasks. :param num_features: Integer, number of features in the input data. :param lr: Float, learning rate for the optimization. :param epochs: Integer, number of epochs for the training process. self.num_tasks = num_tasks self.num_features = num_features self.lr = lr self.epochs = epochs # Initialize weights and biases for each task self.W = [np.zeros(num_features) for _ in range(num_tasks)] self.b = [0.0 for _ in range(num_tasks)] def _sigmoid(self, z: np.ndarray) -> np.ndarray: Apply the sigmoid function. return 1 / (1 + np.exp(-z)) def _loss(self, y_true: np.ndarray, y_pred: np.ndarray) -> float: Calculate the loss using cross-entropy. m = y_true.shape[0] return -1/m * np.sum(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred)) def _train_task(self, X: np.ndarray, y: np.ndarray, W: np.ndarray, b: float) -> (np.ndarray, float): Train a single task and update weights and bias. m = X.shape[0] for _ in range(self.epochs): z = np.dot(X, W) + b a = self._sigmoid(z) dz = a - y dW = 1/m * np.dot(X.T, dz) db = 1/m * np.sum(dz) W -= self.lr * dW b -= self.lr * db return W, b def fit(self, X_list: [np.ndarray], y_list: [np.ndarray]): Train the multi-task logistic regression model. :param X_list: List of numpy arrays. Each array is of shape (m, n) with m samples and n features. :param y_list: List of numpy arrays. Each array is of shape (m,) with the class labels for each task. for task in range(self.num_tasks): self.W[task], self.b[task] = self._train_task(X_list[task], y_list[task], self.W[task], self.b[task]) def predict(self, X: np.ndarray) -> [np.ndarray]: Predict the class labels for the given input data. :param X: Numpy array of shape (m, n) with the input data. :return: List of numpy arrays. Each array is of shape (m,) with the predicted class labels for each task. predictions = [] for task in range(self.num_tasks): z = np.dot(X, self.W[task]) + self.b[task] a = self._sigmoid(z) predictions.append((a >= 0.5).astype(int)) return predictions"},{"question":"# Question: Advanced String Manipulation - Unique Substrings Context: Given a string \\"s\\" of length \\"n\\", we want to explore advanced string manipulation techniques to extract unique substrings of varying lengths. Task: Implement the following methods that extend the string manipulation capabilities: 1. `count_unique_substrings(k)`: Count the number of unique substrings of length k. 2. `longest_palindromic_substring()`: Find and return the longest palindromic substring. 3. `substring_anagram_check(p)`: Check if any substring of length equal to string p (a given pattern) exists in the main string \\"s\\" that is an anagram of p, and return True/False. Implementation Details: - **count_unique_substrings(k)**: - Input: `k` (length of the substrings). - Output: Integer representing the number of unique substrings of length k. - **longest_palindromic_substring()**: - Input: None. - Output: String representing the longest palindromic substring. - **substring_anagram_check(p)**: - Input: `p` (pattern string). - Output: Boolean indicating the existence of any anagram of p as a substring in s. Constraints: - The input string \\"s\\" will have at most 10000 characters. - The length of the string `p` will be at most 1000 characters. Example: ```python s = \\"abracadabra\\" # Requirements print(count_unique_substrings(3)) # Output: 7 (unique substrings of length 3: \'abr\', \'bra\', \'rac\', \'aca\', \'cad\', \'ada\', \'dab\') print(longest_palindromic_substring()) # Output: \\"aca\\" p = \\"abc\\" print(substring_anagram_check(p)) # Output: True (anagram \'bac\' exists as substring) p = \\"xyz\\" print(substring_anagram_check(p)) # Output: False (no anagram of \'xyz\' exists as substring) ``` --- Ensure to adhere to the string manipulation principles and constraints while implementing the methods, and strive for optimal efficiency where possible. This question aims to test proficiency with string algorithms, familiarity with palindromes and anagram checks, and the ability to manage and optimize unique substring searches.","solution":"def count_unique_substrings(s, k): Count the number of unique substrings of length k in the string s. if k > len(s) or k == 0: return 0 unique_substrings = set() for i in range(len(s) - k + 1): unique_substrings.add(s[i:i+k]) return len(unique_substrings) def longest_palindromic_substring(s): Find and return the longest palindromic substring in s. n = len(s) if n == 0: return \\"\\" def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(n): # Odd length palindromes substr1 = expand_around_center(i, i) if len(substr1) > len(longest): longest = substr1 # Even length palindromes substr2 = expand_around_center(i, i + 1) if len(substr2) > len(longest): longest = substr2 return longest def substring_anagram_check(s, p): Check if any substring of s that is an anagram of p exists and return True/False. from collections import Counter s_len, p_len = len(s), len(p) if p_len > s_len: return False p_counter = Counter(p) window_counter = Counter() for i in range(s_len): # Add one more letter from the right to the window window_counter[s[i]] += 1 # Remove one letter from the left if window is larger than p_len if i >= p_len: if window_counter[s[i - p_len]] == 1: del window_counter[s[i - p_len]] else: window_counter[s[i - p_len]] -= 1 # Compare window with p if window_counter == p_counter: return True return False"},{"question":"# AVL Tree Implementation and Balance Check You are asked to implement an AVL Tree, which is a self-balancing binary search tree, and include methods for inserting elements and checking if the tree remains balanced after every insertion. Implement a class `AVLTree` with the following methods: 1. **Constructor**: Initializes an empty AVL tree. 2. **`insert`:** Inserts a value into the AVL tree and balances the tree if necessary. 3. **`is_balanced`:** Checks if the AVL tree is balanced and returns a boolean value. Requirements: - The insertion operation should ensure the tree remains balanced by performing necessary rotations. - The `is_balanced` method should return `True` if, at every node, the height difference between the left and right subtrees is at most 1, `False` otherwise. - Provide utility functions like rotations (left, right) and height calculations as required. # Implementation Details: ```python class AVLTreeNode: def __init__(self, key: int, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AVLTree: def __init__(self) -> None: Initializes an empty AVL Tree. self.root = None def insert(self, key: int) -> None: Inserts a key into the AVL tree and balances it. Parameters: key (int): The key to insert into the tree. self.root = self._insert(self.root, key) def is_balanced(self) -> bool: Checks if the AVL tree is balanced. Returns: bool: True if the tree is balanced, False otherwise. return self._is_balanced(self.root) # Helper methods. def _insert(self, node, key): Recursively inserts a key into the subtree rooted at node. # Your implementation goes here for insertion and balancing. pass def _is_balanced(self, node) -> bool: Recursively checks if the subtree rooted at node is balanced. # Your implementation goes here for balance checking. pass def _height(self, node) -> int: Returns the height of the node. if not node: return 0 return node.height def _right_rotate(self, y): # Your implementation for right rotation of the subtree. pass def _left_rotate(self, x): # Your implementation for left rotation of the subtree. pass def _balance_factor(self, node): Returns the balance factor of the node. if not node: return 0 return self._height(node.left) - self._height(node.right) def _update_height(self, node): Updates the height of the node. if node: node.height = 1 + max(self._height(node.left), self._height(node.right)) ``` Example Use: ```python tree = AVLTree() elements = [10, 20, 30, 40, 50, 25] for elem in elements: tree.insert(elem) print(tree.is_balanced()) # Should print True each time as the tree maintains balance ``` # Constraints: - The values to insert will be unique integers in the range of 1 to 10^6. - The number of insert operations (n) will be in the range 1 <= n <= 10^4. # Performance: - Ensure that insertion operations run in O(log n) time. - Ensure that balance checking runs in O(1) time due to maintained heights at each node.","solution":"class AVLTreeNode: def __init__(self, key: int, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AVLTree: def __init__(self) -> None: Initializes an empty AVL Tree. self.root = None def insert(self, key: int) -> None: Inserts a key into the AVL tree and balances it. Parameters: key (int): The key to insert into the tree. self.root = self._insert(self.root, key) def is_balanced(self) -> bool: Checks if the AVL tree is balanced. Returns: bool: True if the tree is balanced, False otherwise. return self._is_balanced(self.root) # Helper methods. def _insert(self, node, key): Recursively inserts a key into the subtree rooted at node. if not node: return AVLTreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node = self._rebalance(node) return node def _is_balanced(self, node) -> bool: Recursively checks if the subtree rooted at node is balanced. if node is None: return True left_height = self._height(node.left) right_height = self._height(node.right) balance_factor = abs(left_height - right_height) return (balance_factor <= 1) and self._is_balanced(node.left) and self._is_balanced(node.right) def _height(self, node) -> int: Returns the height of the node. if not node: return 0 return node.height def _right_rotate(self, y): Right rotation of the subtree rooted at y. x = y.left T2 = x.right x.right = y y.left = T2 self._update_height(y) self._update_height(x) return x def _left_rotate(self, x): Left rotation of the subtree rooted at x. y = x.right T2 = y.left y.left = x x.right = T2 self._update_height(x) self._update_height(y) return y def _balance_factor(self, node): Returns the balance factor of the node. if not node: return 0 return self._height(node.left) - self._height(node.right) def _update_height(self, node): Updates the height of the node. if node: node.height = 1 + max(self._height(node.left), self._height(node.right)) def _rebalance(self, node): Rebalance the subtree rooted at node if necessary. self._update_height(node) balance_factor = self._balance_factor(node) # Left heavy if balance_factor > 1: if self._balance_factor(node.left) < 0: node.left = self._left_rotate(node.left) node = self._right_rotate(node) # Right heavy elif balance_factor < -1: if self._balance_factor(node.right) > 0: node.right = self._right_rotate(node.right) node = self._left_rotate(node) return node"},{"question":"**Context**: You are asked to design a function that evaluates a series of transactions to detect any fraudulent activities based on a set of rules. Any transaction that meets one or more criteria is deemed suspicious. The rules are as follows: 1. The transaction amount exceeds a specified threshold. 2. The transaction originates from a prohibited country. 3. The transaction contains a note indicating possible fraud (e.g., keywords like \\"fraud\\", \\"scam\\", \\"suspicious\\"). Each transaction is represented as a dictionary with the following keys: \'amount\', \'country\', and \'note\'. **Task**: Write a function `detect_fraudulent_transactions` that takes a list of transactions and analyzes them according to the specified rules. The function should print each suspicious transaction, along with which rules it violated, and a summary count of all suspicious transactions. If any fraudulent transactions are detected, terminate the program with a non-zero status code indicating the number of suspicious transactions. **Function Signature**: ```python def detect_fraudulent_transactions(transactions: List[Dict[str, str]], amount_threshold: float, prohibited_countries: List[str], fraud_keywords: List[str]) -> None: ``` **Input**: - `transactions`: A list of dictionaries, each representing a transaction with the keys \'amount\' (float), \'country\' (string), and \'note\' (string). - `amount_threshold`: A float representing the transaction amount threshold above which transactions are considered suspicious. - `prohibited_countries`: A list of strings representing countries from which transactions are not allowed. - `fraud_keywords`: A list of strings representing suspicious keywords to be checked in the transaction notes. **Output**: - Print each suspicious transaction along with the specific rules it violated. - Exit the program with a non-zero status code indicating the number of suspicious transactions found, or zero if all transactions are valid. **Examples**: ```python transactions = [ {\\"amount\\": 12000.0, \\"country\\": \\"CountryA\\", \\"note\\": \\"Transfer\\"}, {\\"amount\\": 5000.0, \\"country\\": \\"CountryB\\", \\"note\\": \\"suspicious activity\\"}, {\\"amount\\": 15000.0, \\"country\\": \\"CountryC\\", \\"note\\": \\"investment\\"}, {\\"amount\\": 3000.0, \\"country\\": \\"CountryD\\", \\"note\\": \\"fraudulent transfer\\"} ] amount_threshold = 10000.0 prohibited_countries = [\\"CountryC\\", \\"CountryD\\"] fraud_keywords = [\\"fraud\\", \\"scam\\", \\"suspicious\\"] detect_fraudulent_transactions(transactions, amount_threshold, prohibited_countries, fraud_keywords) ``` Expected Output: ``` 1 transactions exceed the amount threshold: {\'amount\': 12000.0, \'country\': \'CountryA\', \'note\': \'Transfer\'} 2 transactions contain fraud keywords: {\'amount\': 5000.0, \'country\': \'CountryB\', \'note\': \'suspicious activity\'} {\'amount\': 3000.0, \'country\': \'CountryD\', \'note\': \'fraudulent transfer\'} 1 transactions originate from prohibited countries: {\'amount\': 15000.0, \'country\': \'CountryC\', \'note\': \'investment\'} 3 ``` Note: The program should exit with status code `3`. **Constraints**: - Transactions may contain any ASCII characters in the notes. - It is guaranteed that the input list `transactions` is not empty. - Amounts are given as positive floating-point numbers.","solution":"from typing import List, Dict import sys def detect_fraudulent_transactions(transactions: List[Dict[str, str]], amount_threshold: float, prohibited_countries: List[str], fraud_keywords: List[str]) -> None: def is_suspicious(transaction: Dict[str, str]) -> Dict[str, bool]: suspicious_flags = { \\"amount\\": float(transaction[\'amount\']) > amount_threshold, \\"country\\": transaction[\'country\'] in prohibited_countries, \\"note\\": any(keyword in transaction[\'note\'] for keyword in fraud_keywords) } return suspicious_flags suspicious_transactions = [] for transaction in transactions: flags = is_suspicious(transaction) if any(flags.values()): suspicious_transactions.append((transaction, flags)) if suspicious_transactions: count_amount_violations = sum(1 for _, flags in suspicious_transactions if flags[\\"amount\\"]) count_country_violations = sum(1 for _, flags in suspicious_transactions if flags[\\"country\\"]) count_note_violations = sum(1 for _, flags in suspicious_transactions if flags[\\"note\\"]) if count_amount_violations: print(f\\"{count_amount_violations} transactions exceed the amount threshold:\\") for transaction, flags in suspicious_transactions: if flags[\\"amount\\"]: print(transaction) if count_country_violations: print(f\\"{count_country_violations} transactions originate from prohibited countries:\\") for transaction, flags in suspicious_transactions: if flags[\\"country\\"]: print(transaction) if count_note_violations: print(f\\"{count_note_violations} transactions contain fraud keywords:\\") for transaction, flags in suspicious_transactions: if flags[\\"note\\"]: print(transaction) sys.exit(len(suspicious_transactions)) else: sys.exit(0)"},{"question":"# Coding Assessment Question You are tasked with writing a function that simulates a basic email validator. The function should check whether a given email address string follows the standard format of a valid email. Specifically, the email must follow these rules: 1. **Input**: * A single string representing the email address to be validated. 2. **Behavior**: * The email must follow the general pattern `local-part@domain-part`. * The `local-part` may contain: - Uppercase and lowercase letters (`A-Z`, `a-z`) - Digits (`0-9`) - Special characters (`!#%&\'*+-/=?^_`{|}~`) - Periods (.) provided that they are not the first or last character and do not appear consecutively. * The `domain-part` must conform to: - One or more labels separated by periods (.) - Each label must start and end with a letter or digit. - Labels may contain hyphens (`-`) but cannot begin or end with hyphens. - The last label must be at least 2 characters long (e.g., \\"com\\", \\"org\\"). 3. **Output**: * Return `True` if the email address is valid. * Return `False` if the email address is invalid. 4. **Constraints**: * You may not use regular expressions. Here is an example function signature to help you get started: ```python def is_valid_email(email: str) -> bool: pass ``` **Example Inputs and Outputs**: - `is_valid_email(\\"test.email@domain.com\\")` should return `True`. - `is_valid_email(\\"test.email@domain..com\\")` should return `False`. - `is_valid_email(\\"test..email@domain.com\\")` should return `False`. - `is_valid_email(\\"test.email@-domain.com\\")` should return `False`. - `is_valid_email(\\"test.email@domain\\")` should return `False`. Write the `is_valid_email` function according to the stated requirements.","solution":"def is_valid_email(email: str) -> bool: def is_valid_local(local): if local.startswith(\\".\\") or local.endswith(\\".\\") or \\"..\\" in local: return False valid_chars = \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#%&\'*+-/=?^_`{|}~.\\" for char in local: if char not in valid_chars: return False return True def is_valid_domain(domain): parts = domain.split(\\".\\") if len(parts) < 2: return False for part in parts: if not part or not part[0].isalnum() or not part[-1].isalnum(): return False if \\"--\\" in part or \\"..\\" in part: return False for char in part: if not (char.isalnum() or char == \'-\'): return False return len(parts[-1]) >= 2 if \\"@\\" not in email or email.count(\\"@\\") != 1: return False local, domain = email.split(\\"@\\") if not local or not domain: return False return is_valid_local(local) and is_valid_domain(domain)"},{"question":"# Question: Subarray Sum Equals K In this challenge, you are required to write a function that finds the number of continuous subarrays whose sum equals to a given integer `k`. This problem will help you demonstrate your ability to work with arrays, hash maps, and subarray techniques. **Task:** Write a function called `subarray_sum_equals_k` that takes a list of integers and an integer `k`, and returns the number of continuous subarrays that sum up to `k`. The function signature should be: ```python def subarray_sum_equals_k(nums: List[int], k: int) -> int: pass ``` **Input Format:** - A list of integers, `nums`, which may contain both positive and negative numbers. - An integer `k` which can be any value within the bounds of the integer range. **Output Format:** - An integer representing the number of continuous subarrays that sum to `k`. **Constraints:** - The length of the list `nums` is between 1 and 20,000. - Each integer in the list is between -10^7 and 10^7. - The value of `k` is between -10^7 and 10^7. **Performance Requirement:** - Your solution should strive to achieve a time complexity of O(n). **Example:** ```python >>> subarray_sum_equals_k([1, 1, 1], 2) 2 >>> subarray_sum_equals_k([1, 2, 3], 3) 2 >>> subarray_sum_equals_k([1, -1, 0], 0) 3 >>> subarray_sum_equals_k([], 0) 0 ``` **Context:** Consider a scenario where you are analyzing a large dataset of financial transactions, and you need to determine the number of periods (subarrays) where the sum of transactions matches a specific target figure for auditing purposes. Your efficient solution is crucial for handling large datasets within permissible time limits. Demonstrate your problem-solving skills and understanding of array manipulation and efficient algorithm design by completing the `subarray_sum_equals_k` function. Good luck!","solution":"from typing import List def subarray_sum_equals_k(nums: List[int], k: int) -> int: count = 0 sum_so_far = 0 sums_map = {0: 1} # To handle cases where the subarray starts from the beginning for num in nums: sum_so_far += num # Check if there is a previous prefix sum that we can subtract to get k if (sum_so_far - k) in sums_map: count += sums_map[sum_so_far - k] # Add/update the current sum_so_far in our map if sum_so_far in sums_map: sums_map[sum_so_far] += 1 else: sums_map[sum_so_far] = 1 return count"},{"question":"# Coding Assessment Question Scenario You are a developer working with strings that represent file paths. These paths follow a UNIX-like filesystem structure, where directories are separated by forward slashes (`/`). Your task is to implement a function that normalizes paths by resolving special segments like `..` (parent directory) and `.` (current directory) to simplify the path as much as possible. Task Write a function that takes a string representing an absolute path and returns its simplified, canonical form. Function Signature ```python def simplify_path(path: str) -> str: ``` Input * A string `path` representing the absolute path. Output * A string representing the simplified canonical path. Constraints * The path is a non-empty string consisting of `/`, lowercase and uppercase English letters, and digits. * The path will always start with a `/`. * The path will not contain any sequences of multiple concurrent `/`. * The canonical path should not have any trailing `/` unless it is the root `/`. Example ```python assert simplify_path(\\"/home/\\") == \\"/home\\" assert simplify_path(\\"/../\\") == \\"/\\" assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" assert simplify_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" ``` Notes * Consider edge cases such as paths with multiple consecutive slashes, paths that try to traverse above the root directory using `..`, and paths that include the current directory reference `.`. * Your solution should handle these correctly and return a simplified path that accurately represents the same location in the filesystem.","solution":"def simplify_path(path: str) -> str: Simplifies a given UNIX-like file system path. segments = path.split(\'/\') stack = [] for segment in segments: if segment == \'..\': if stack: stack.pop() elif segment and segment != \'.\': stack.append(segment) return \'/\' + \'/\'.join(stack)"},{"question":"# Question You need to implement a simplified version of the Dijkstra\'s algorithm to find the shortest path in a weighted graph with positive integer weights. # Problem Statement: Implement a method `shortest_path` that computes the shortest paths from a source vertex to all other vertices in a given graph using Dijkstra\'s algorithm. # Input and Output: **Input**: - An integer `n` (1 ≤ `n` ≤ 1000) representing the number of vertices. - A list of edges `edges`, where each edge is represented as a tuple `(u, v, w)` indicating an edge from vertex `u` to vertex `v` with weight `w` (1 ≤ `w` ≤ 1000). - An integer `source` representing the source vertex. **Output**: - A list of integers representing the shortest distances from the source to each of the vertices (from vertex 0 to vertex n-1). If a vertex is not reachable from the source, the distance should be infinity (`float(\'inf\')`). # Constraints: - The graph is directed and may contain cycles. - Weights are positive integers. # Example: ```python Example 1: Input: n = 5, edges = [(0, 1, 10), (0, 2, 3), (1, 2, 1), (2, 1, 4), (2, 3, 2), (3, 4, 7), (1, 4, 10)], source = 0 Output: [0, 7, 3, 5, 12] Example 2: Input: n = 3, edges = [(0, 1, 1), (1, 2, 3)], source = 0 Output: [0, 1, 4] Example 3: Input: n = 3, edges = [(0, 1, 1), (1, 2, 3)], source = 1 Output: [float(\'inf\'), 0, 3] ``` # Instructions: - Implement `shortest_path(n, edges, source)` method. - Use a priority queue (min-heap) for efficient retrieval of the minimum distance vertex. - Handle edge cases such as disconnected graphs. - Ensure that you effectively use data structures to achieve a time complexity of O((V + E) log V), where V is the number of vertices and E is the number of edges. Here\'s the Python function signature to get you started: ```python from heapq import heappop, heappush from collections import defaultdict def shortest_path(n, edges, source): # Your code here pass # Example usage: # n = 5 # edges = [(0, 1, 10), (0, 2, 3), (1, 2, 1), (2, 1, 4), (2, 3, 2), (3, 4, 7), (1, 4, 10)] # source = 0 # print(shortest_path(n, edges, source)) # Output: [0, 7, 3, 5, 12] ```","solution":"from heapq import heappop, heappush from collections import defaultdict import sys def shortest_path(n, edges, source): Computes the shortest paths from a source vertex to all other vertices in a weighted graph. :param n: Number of vertices (1 ≤ n ≤ 1000) :param edges: List of edges (tuples) where each tuple is (u, v, w) :param source: Source vertex :return: List of shortest distances from source to each vertex. If unreachable, distance is float(\'inf\'). # Create adjacency list graph representation graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Initialize distances with infinity distances = [float(\'inf\')] * n distances[source] = 0 # Priority queue to get the minimum distance vertex pq = [(0, source)] while pq: current_distance, u = heappop(pq) # For each neighboring vertex v of u for v, weight in graph[u]: distance = current_distance + weight # If a shorter path to v is found if distance < distances[v]: distances[v] = distance heappush(pq, (distance, v)) return distances"},{"question":"# Coding Question: Rotating a 2D Matrix by 90 Degrees Context: Rotating a 2-dimensional square matrix by 90 degrees is a common operation in image processing, puzzles, and games like the Rubik\'s cube. Such transformations are also relevant in computer graphics and pattern detection. Given a square matrix, the task is to rotate it 90 degrees clockwise. Task: Write a function `rotate_matrix` that takes a square matrix (2D list) and rotates it 90 degrees clockwise in-place and returns the transformed matrix. Input: * `matrix` (List[List[int]]): A square matrix of size ( n times n ). Output: * List[List[int]]: The matrix rotated 90 degrees clockwise. Constraints: * ( 1 leq n leq 1000 ) * Each element in the matrix is an integer in the range [0, 1000]. Requirements: * The solution should perform the rotation in-place. * Time complexity should be ( O(n^2) ). * Space complexity should be ( O(1) ) beyond the input matrix itself. Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` Example: Input: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Explanation: The matrix is rotated 90 degrees clockwise. The first row becomes the first column in reverse order, the second row becomes the second column in reverse order, and so on. # Notes: 1. You may perform the rotation by first transposing the matrix and then reversing each row. 2. Ensure that the transformation is done in-place without using extra space for another matrix. Provide a detailed implementation ensuring optimal space and time utilization while performing the matrix rotation.","solution":"def rotate_matrix(matrix): Rotates a n x n 2D matrix 90 degrees clockwise in-place. Args: matrix (List[List[int]]): A square matrix to be rotated Returns: List[List[int]]: The rotated matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Question: Analyze Polygon Area Calculations As a geometric programmer, you need to analyze the given polygon to compute its area using various methods. You are provided with certain utility functions, and your task is to build upon them to deliver the required functionalities. Your Task 1. Implement a function `area_of_triangle` that calculates the area of a triangle formed by three distinct points. 2. Implement a function `polygon_area` that computes the area of a convex polygon given its vertices in a specific order. Function Signatures ```python def area_of_triangle(point1: tuple[float, float], point2: tuple[float, float], point3: tuple[float, float]) -> float | ValueError: pass def polygon_area(vertices: list[tuple[float, float]]) -> float | ValueError: pass ``` # Parameters * **point1, point2, point3 (tuple[float, float])**: Coordinates of the triangle\'s vertices. * **vertices (list[tuple[float, float]])**: A list of tuples representing the vertices of the polygon in counter-clockwise order. # Returns For both functions: * The area as a float value or a ValueError indicating invalid input. # Examples ```python # Example for area_of_triangle area_of_triangle((0, 0), (4, 0), (2, 3)) # Expected: 6.0 # Example for polygon_area polygon_area([(0, 0), (4, 0), (4, 3), (0, 3)]) # Expected: 12.0 ``` # Constraints * The number of vertices should be at least 3. * Ensure to handle cases where points might form a zero-area triangle or polygon. * Utilize basic geometric formulas to ensure consistency and correctness. # Hints 1. Use the formula for the area of a triangle given its vertices: [ text{Area} = frac{1}{2} left| x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) right| ] 2. For the polygon area, you can use the shoelace formula (Gauss\'s area formula for polygons). # Background Understanding the basic principles of geometry and how to calculate areas using vertices coordinates will be crucial. The provided examples will assist in verifying the correctness of your implementations.","solution":"def area_of_triangle(point1, point2, point3): Calculate the area of a triangle given its vertices using the formula: Area = |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)| / 2 x1, y1 = point1 x2, y2 = point2 x3, y3 = point3 area = abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2 if area == 0: raise ValueError(\\"The points do not form a valid triangle\\") return area def polygon_area(vertices): Calculate the area of a convex polygon using the shoelace formula. if len(vertices) < 3: raise ValueError(\\"At least 3 vertices are required to form a polygon.\\") n = len(vertices) area = 0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += x1 * y2 - y1 * x2 area = abs(area) / 2 if area == 0: raise ValueError(\\"The vertices do not form a valid polygon\\") return area"},{"question":"# Question: Implement a Movie Rating Prediction System Using Collaborative Filtering Your task is to implement a function that predicts movie ratings for users based on historical ratings data using collaborative filtering (CF). The function should use a simple user-based CF approach where the similarity between users is measured by the Pearson correlation coefficient. It should then predict the rating for a specific user for a specific movie. Function Specifications 1. **Function Signature** ```python def movie_rating_prediction( user_movie_ratings: dict, target_user: int, target_movie: int ) -> float: ``` 2. **Input** - `user_movie_ratings`: A dictionary where keys are user IDs and values are nested dictionaries. Each nested dictionary represents movie ratings by the user, with movie IDs as keys and ratings as values (e.g., `{1: {101: 5, 102: 3}, 2: {101: 4, 103: 2}}`). - `target_user`: The user ID for whom the movie rating is to be predicted. - `target_movie`: The movie ID for which the rating is to be predicted. 3. **Output** - A float value representing the predicted rating for the `target_movie` by the `target_user`. Constraints - `user_movie_ratings` dictionary will contain at least 3 users and at least 2 ratings per user. - Each user will rate between 1 and 5 for movies (integer values). - The `target_user` will have rated at least one movie but not necessarily the `target_movie`. - All user IDs and movie IDs are positive integers. - The function should handle cases where the target movie has few ratings using mean adjustments. Performance Requirements - The implementation should efficiently handle up to 500 users each rating up to 100 movies. Edge Cases to Consider - Users with no common movies rated should be handled by predicting the average rating for that movie. - Return a rating rounded to the nearest half-star (0.5). Example ```python # Given user-movie ratings user_movie_ratings = { 1: {101: 5, 102: 3, 103: 2}, 2: {101: 4, 103: 2, 104: 5}, 3: {102: 2, 103: 4, 105: 3} } # Target user and movie for prediction target_user = 1 target_movie = 104 # Call the function predicted_rating = movie_rating_prediction(user_movie_ratings, target_user, target_movie) # Expected output print(predicted_rating) # Example: 4.0 (assuming the computed rating after calculations) ```","solution":"from scipy.stats import pearsonr import numpy as np def movie_rating_prediction(user_movie_ratings, target_user, target_movie): def pearson_correlation(user1, user2): common_movies = set(user_movie_ratings[user1]) & set(user_movie_ratings[user2]) if len(common_movies) < 2: return 0 user1_ratings = [user_movie_ratings[user1][movie] for movie in common_movies] user2_ratings = [user_movie_ratings[user2][movie] for movie in common_movies] return pearsonr(user1_ratings, user2_ratings)[0] def weighted_rating(user, movie): weights = [] ratings = [] for other_user in user_movie_ratings: if other_user != user and movie in user_movie_ratings[other_user]: similarity = pearson_correlation(user, other_user) weights.append(similarity) ratings.append(user_movie_ratings[other_user][movie]) if not weights: return np.mean([rating for ratings in user_movie_ratings.values() for rating in ratings.values()]) weighted_sum = sum(w * r for w, r in zip(weights, ratings)) normalized_sum = sum(abs(w) for w in weights) return weighted_sum / normalized_sum if normalized_sum != 0 else np.mean(ratings) predicted_rating = weighted_rating(target_user, target_movie) return round(predicted_rating * 2) / 2"},{"question":"# Problem Statement Implement a `CharacterCounter` class that allows you to count the frequency of each character in a given text and then retrieve the k most common characters. # Requirements 1. **Function to Implement**: - `__init__(self, text: str)` - Initialize the class with a given text. - `most_common(self, k: int) -> List[Tuple[str, int]]` - Return the k most common characters and their frequencies in the order of most to least frequent. 2. **Input**: - Text as a string, which can contain letters, digits, and special characters. - An integer `k` representing the number of most common characters to return. 3. **Output**: - A list of tuples, each containing a character and its frequency. 4. **Performance**: - Frequency counting should operate in (O(n)) time complexity where (n) is the length of the text. - Finding the most common characters should operate in (O(m log m)) time complexity where (m) is the number of unique characters. 5. **Constraints**: - The length of the input text will not exceed 10^6. - The value of `k` will be such that (1 leq k leq m). # Example ```python cc = CharacterCounter(\\"aabbbcccc\\") print(cc.most_common(2)) # Output: [(\'c\', 4), (\'b\', 3)] cc = CharacterCounter(\\"hello world\\") print(cc.most_common(3)) # Output: [(\'l\', 3), (\'o\', 2), (\'h\', 1)] ``` # Notes - You can use Python\'s built-in modules such as `collections.Counter` to simplify frequency counting. - Ensure that the characters with the same frequency are ordered by their first occurrence in the text. - Handle potential edge cases, such as the text being empty or having fewer unique characters than `k`.","solution":"from collections import Counter from typing import List, Tuple class CharacterCounter: def __init__(self, text: str): self.text = text self.char_count = Counter(text) def most_common(self, k: int) -> List[Tuple[str, int]]: # Get k most common characters with their frequencies return self.char_count.most_common(k)"},{"question":"# Question: Matrix Transposition and Multiplication You are asked to implement two functions: one that performs the transposition of a matrix and another that multiplies two matrices. Your task is to write these functions and use them together to compute the product of a matrix and its transpose. Function Signatures ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: def multiply_matrices(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: ``` Input * `matrix` (for transpose_matrix): A 2D list representing the matrix to be transposed. * `matrix1` and `matrix2` (for multiply_matrices): Two 2D lists representing the matrices to be multiplied. Output * Returns a 2D list which is the transpose of the input matrix for the `transpose_matrix` function. * Returns a 2D list which is the product of the two input matrices for the `multiply_matrices` function. Constraints * The inner lists (rows) of each matrix in `matrix1` and `matrix2` should have the same length. * Both `matrix1` and `matrix2` must have dimensions that allow matrix multiplication (i.e., the number of columns in `matrix1` should be equal to the number of rows in `matrix2`). * If the dimensions do not satisfy the multiplication condition, raise a `ValueError`. * The input matrices may contain both positive and negative integers. Example ```python matrix = [ [1, 2, 3], [4, 5, 6] ] # The transpose of matrix is: # [ # [1, 4], # [2, 5], # [3, 6] # ] print(transpose_matrix(matrix)) matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [5, 6], [7, 8] ] # The product of matrix1 and matrix2 is: # [ # [19, 22], # [43, 50] # ] print(multiply_matrices(matrix1, matrix2)) # Using transpose and multiply functions together: # The product of matrix and its transpose should be: # [ # [14, 32], # [32, 77] # ] matrix_transpose = transpose_matrix(matrix) print(multiply_matrices(matrix, matrix_transpose)) ``` Note * For matrix transposition, switch rows with columns. * For matrix multiplication, use the standard matrix multiplication algorithm: sum the product of rows from the first matrix with columns from the second matrix. * Handle edge cases such as empty matrices or incompatible dimensions by raising appropriate errors.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the input matrix. return [list(row) for row in zip(*matrix)] def multiply_matrices(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: Returns the product of two matrices. if not matrix1 or not matrix2 or len(matrix1[0]) != len(matrix2): raise ValueError(\\"Incompatible dimensions for matrix multiplication.\\") num_rows_matrix1 = len(matrix1) num_columns_matrix1 = len(matrix1[0]) num_columns_matrix2 = len(matrix2[0]) # Initialize result matrix with zeros result = [[0 for _ in range(num_columns_matrix2)] for _ in range(num_rows_matrix1)] for i in range(num_rows_matrix1): for j in range(num_columns_matrix2): for k in range(num_columns_matrix1): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# Question: You need to implement a function that determines if it is possible to jump to the last index of an array. You are given an array of non-negative integers where each element represents the maximum number of steps you can take forward from that position. Initially, you are at the first index of the array, and you want to see if you can reach the last index. # Requirements: - Write a function `can_jump(nums: List[int]) -> bool` that returns `True` if you can reach the last index, otherwise returns `False`. - Your solution should aim for O(n) time complexity, where n is the length of the array. # Constraints: - The length of the array will be between 1 and 10000. - Each element in the array will be between 0 and 100. # Input Example: ```python nums = [2, 3, 1, 1, 4] ``` # Expected Output: ```python True ``` # Explanation: - Starting from the first index (nums[0] = 2), you can jump to index 1 or 2. - From index 1 (nums[1] = 3), you can jump to index 2, 3, or 4. - You reach the last index at position 4. # Implementation: Implement the `can_jump` function to determine if the last index is reachable from the first index. ```python from typing import List def can_jump(nums: List[int]) -> bool: n = len(nums) max_reach = 0 for i in range(n): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) if max_reach >= n - 1: return True return False ``` Your task: - Implement the function `can_jump` as described. - Ensure the function performs efficiently even with the maximum input size.","solution":"from typing import List def can_jump(nums: List[int]) -> bool: Determines if it is possible to reach the last index of the array given the maximum steps you can move forward from each position. Args: nums (List[int]): A list of non-negative integers representing the maximum number of steps you can take forward from each position. Returns: bool: True if you can reach the last index, False otherwise. n = len(nums) max_reach = 0 for i in range(n): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) if max_reach >= n - 1: return True return False"},{"question":"# Coding Challenge: Implement a File Compression Algorithm Using Huffman Coding Context File compression is an important aspect of data storage and transmission. Huffman Coding is a popular algorithm used for lossless data compression. It assigns variable-length codes to input characters, with shorter codes assigned to more frequent characters. Task Implement the Huffman Coding algorithm to compress and decompress a given input string. Your solution should include the following key methods: 1. **`build_frequency_table`** - Creates a frequency table from the input string. 2. **`build_huffman_tree`** - Builds the Huffman tree based on the frequency table. 3. **`build_codes_table`** - Constructs a table mapping characters to their Huffman codes. 4. **`encode`** - Encodes the input string using the Huffman codes. 5. **`decode`** - Decodes the compressed string back to the original input. Requirements 1. **Function Signatures**: - `build_frequency_table`: `(data: str) -> dict` - `build_huffman_tree`: `(frequency_table: dict) -> Node` - `build_codes_table`: `(root: Node) -> dict` - `encode`: `(data: str) -> str` - `decode`: `(encoded_data: str, root: Node) -> str` 2. **Input/Output**: - Input: A string of text. - Output: Compressed binary string (for encode), and decompressed original string (for decode). 3. **Performance**: - Ensure efficiency in tree construction and traversal. 4. **Constraints**: - Input string length is a positive integer not exceeding 1000. - The input string consists of characters from the ASCII table. Example ```python data = \\"this is an example for huffman encoding\\" huffman = HuffmanCoding() compressed_data = huffman.encode(data) print(f\\"Encoded Data: {compressed_data}\\") decompressed_data = huffman.decode(compressed_data, huffman.root) print(f\\"Decoded Data: {decompressed_data}\\") # Output expected: # Encoded Data: 110101101111010101101011011101001110011... # Decoded Data: this is an example for huffman encoding ``` ```python class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None class HuffmanCoding: def __init__(self): self.codes = {} self.root = None def build_frequency_table(self, data: str) -> dict: frequency_table = {} for char in data: if char in frequency_table: frequency_table[char] += 1 else: frequency_table[char] = 1 return frequency_table def build_huffman_tree(self, frequency_table: dict) -> Node: import heapq heap = [Node(char, freq) for char, freq in frequency_table.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = Node(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) return heap[0] def build_codes_table(self, root: Node) -> dict: def build_codes_recursive(node, current_code): if node is None: return if node.char is not None: self.codes[node.char] = current_code build_codes_recursive(node.left, f\\"{current_code}0\\") build_codes_recursive(node.right, f\\"{current_code}1\\") self.codes = {} build_codes_recursive(root, \\"\\") return self.codes def encode(self, data: str) -> str: frequency_table = self.build_frequency_table(data) self.root = self.build_huffman_tree(frequency_table) self.build_codes_table(self.root) encoded_output = \'\'.join([self.codes[char] for char in data]) return encoded_output def decode(self, encoded_data: str, root: Node) -> str: decoded_output = [] current_node = root for bit in encoded_data: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decoded_output.append(current_node.char) current_node = root return \'\'.join(decoded_output) if __name__ == \\"__main__\\": data = \\"this is an example for huffman encoding\\" huffman = HuffmanCoding() compressed_data = huffman.encode(data) print(f\\"Encoded Data: {compressed_data}\\") decompressed_data = huffman.decode(compressed_data, huffman.root) print(f\\"Decoded Data: {decompressed_data}\\") ```","solution":"class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq class HuffmanCoding: def __init__(self): self.codes = {} self.root = None def build_frequency_table(self, data: str) -> dict: frequency_table = {} for char in data: if char in frequency_table: frequency_table[char] += 1 else: frequency_table[char] = 1 return frequency_table def build_huffman_tree(self, frequency_table: dict) -> Node: import heapq heap = [Node(char, freq) for char, freq in frequency_table.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = Node(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) return heap[0] def build_codes_table(self, root: Node) -> dict: def build_codes_recursive(node, current_code): if node is None: return if node.char is not None: self.codes[node.char] = current_code build_codes_recursive(node.left, f\\"{current_code}0\\") build_codes_recursive(node.right, f\\"{current_code}1\\") self.codes = {} build_codes_recursive(root, \\"\\") return self.codes def encode(self, data: str) -> str: frequency_table = self.build_frequency_table(data) self.root = self.build_huffman_tree(frequency_table) self.build_codes_table(self.root) encoded_output = \'\'.join([self.codes[char] for char in data]) return encoded_output def decode(self, encoded_data: str, root: Node) -> str: decoded_output = [] current_node = root for bit in encoded_data: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decoded_output.append(current_node.char) current_node = root return \'\'.join(decoded_output) if __name__ == \\"__main__\\": data = \\"this is an example for huffman encoding\\" huffman = HuffmanCoding() compressed_data = huffman.encode(data) print(f\\"Encoded Data: {compressed_data}\\") decompressed_data = huffman.decode(compressed_data, huffman.root) print(f\\"Decoded Data: {decompressed_data}\\")"},{"question":"# Notification System Background You are building a notification system for an application that needs to send out alerts based on different criteria. Notifications can have varying levels of priority and need to be fetched in order based on their priority and timestamp. Task Implement a class `NotificationManager` that manages the creation and retrieval of notifications. The notifications should be stored and retrieved following priority and timestamp order. Requirements 1. Define a class `Notification` with the following attributes: * `message` (str): The notification message. * `priority` (int): Priority level of the notification (lower number indicates higher priority). * `timestamp` (int): A unique identifier of when the notification was created (a simulated timestamp for this task). 2. Implement the class `NotificationManager` with methods to add and fetch notifications: * Method `add_notification(message: str, priority: int, timestamp: int)`: Adds a new notification. * Method `get_notifications(limit: int)` retrieves up to `limit` notifications sorted by priority and then by timestamp. Function Signature ```python class Notification: def __init__(self, message: str, priority: int, timestamp: int): pass class NotificationManager: def __init__(self): pass def add_notification(self, message: str, priority: int, timestamp: int): pass def get_notifications(self, limit: int) -> List[Notification]: pass ``` Parameters * `message` (str): The content of the notification. * `priority` (int): The priority level of the notification. * `timestamp` (int): The simulated timestamp for when the notification was created. * `limit` (int): The maximum number of notifications to retrieve. Constraints * Notifications with a lower `priority` number should be considered higher priority. * If two notifications have the same priority, the one with the earlier `timestamp` should come first. * All input parameters will be valid and within reasonable boundaries for testing purposes. Example Usage ```python manager = NotificationManager() manager.add_notification(\\"Server down\\", 1, 1001) manager.add_notification(\\"Database error\\", 2, 1002) manager.add_notification(\\"Server recovered\\", 1, 1003) notifications = manager.get_notifications(2) for n in notifications: print(f\\"Priority: {n.priority}, Timestamp: {n.timestamp}, Message: {n.message}\\") # Output: # Priority: 1, Timestamp: 1001, Message: Server down # Priority: 1, Timestamp: 1003, Message: Server recovered ```","solution":"from typing import List class Notification: def __init__(self, message: str, priority: int, timestamp: int): self.message = message self.priority = priority self.timestamp = timestamp class NotificationManager: def __init__(self): self.notifications = [] def add_notification(self, message: str, priority: int, timestamp: int): notification = Notification(message, priority, timestamp) self.notifications.append(notification) def get_notifications(self, limit: int) -> List[Notification]: sorted_notifications = sorted(self.notifications, key=lambda n: (n.priority, n.timestamp)) return sorted_notifications[:limit]"},{"question":"# Problem Statement Write a function to determine if a given string is a scrambled version of another string. Two strings are considered scrambled versions of each other if one string can be transformed into the other by using the following operation any number of times: - Swap any non-empty substring\'s left and right children. # Function Signature ```python def is_scramble(s1: str, s2: str) -> bool: ... ``` # Input * A string `s1`. * A string `s2`. # Output * A boolean value indicating whether `s2` is a scrambled version of `s1`. # Constraints * 1 <= len(s1), len(s2) <= 30 * `s1` and `s2` are of the same length and consist of lowercase letters. # Examples Example 1 Input: `s1 = \\"great\\"`, `s2 = \\"rgeat\\"` Output: `True` Explanation: One possible series of transformations is: 1. Swap the \\"gr\\" and \\"eat\\" to get \\"rgeat\\". Example 2 Input: `s1 = \\"abcde\\"`, `s2 = \\"caebd\\"` Output: `False` Explanation: There is no way to transform \\"abcde\\" into \\"caebd\\" using the allowed operation. # Notes * You may assume that the function receives strings `s1` and `s2` of equal length. * Implement efficient checking with recursive and memoization techniques. * Consider edge cases such as strings with repeated characters and scenarios where `s1` equals `s2`. # Hint You can use dynamic programming to store results of subproblems and avoid recomputation, which will help to optimize the solution for larger strings within the given constraint.","solution":"def is_scramble(s1: str, s2: str) -> bool: from functools import lru_cache @lru_cache(None) def check(s1, s2): if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (check(s1[:i], s2[:i]) and check(s1[i:], s2[i:])) or (check(s1[:i], s2[-i:]) and check(s1[i:], s2[:-i])): return True return False return check(s1, s2)"},{"question":"# Problem Statement You are tasked with implementing a function to find the smallest substring in a given string `s` that contains all the distinct characters in `s`. The function should be efficient with respect to both time and space complexity. # Objective Write a function `smallest_substring_with_all_chars(s: str) -> str` that finds the smallest substring containing all distinct characters of `s`. # Input * **`s`**: A string consisting of lowercase alphabetic characters only (1 leq |s| leq 10^5). # Output A string representing the smallest substring of `s` that contains all the distinct characters in `s`. If there are multiple substrings of the same minimal length, return any one of them. # Example ```python s = \\"abcda\\" output = smallest_substring_with_all_chars(s) print(output) # Possible output: \\"abcd\\" or \\"bcda\\" s = \\"abac\\" output = smallest_substring_with_all_chars(s) print(output) # Possible output: \\"abac\\" or \\"bac\\" ``` # Constraints * The implementation must handle the upper limits of `|s|` within a reasonable time frame. * You should ensure the space complexity is also kept under control, considering the potential size of the input string. # Notes * A good starting point is to identify all distinct characters in `s`. * Try using a sliding window approach to dynamically find the smallest substring as you iterate over the string. * Think about maintaining a count of current characters within the window to facilitate quick checks for completeness. Good luck!","solution":"def smallest_substring_with_all_chars(s: str) -> str: from collections import defaultdict, Counter # Find all distinct characters in the input string distinct_chars = set(s) num_distinct = len(distinct_chars) # Use a sliding window approach left = 0 min_len = float(\'inf\') min_substring = \\"\\" char_count = defaultdict(int) formed = 0 # Expand the window by extending the right boundary for right in range(len(s)): char_count[s[right]] += 1 if char_count[s[right]] == 1: formed += 1 # Try to contract the window from the left until it is no longer valid while formed == num_distinct: # Update the answer if this window is smaller if (right - left + 1) < min_len: min_len = right - left + 1 min_substring = s[left:right + 1] # Contract from the left char_count[s[left]] -= 1 if char_count[s[left]] == 0: formed -= 1 left += 1 return min_substring"},{"question":"# Scenario You are tasked with designing a function to generate a circular matrix of integers. A circular matrix consists of elements that increment sequentially in a clockwise spiral pattern starting from the outermost layer towards the center. # Requirements 1. **Implementation of Circular Matrix Generation** - Write a function `generate_circular_matrix` that generates a square matrix given a specified dimension. - The matrix should contain elements such that they start from 1 and increment in a clockwise spiral pattern. # Input - `n` (int): The dimension (number of rows and columns) of the square matrix. # Output - numpy array (2D): Generated n x n matrix with elements arranged in a clockwise spiral pattern. # Constraints - 1 ≤ n ≤ 100 # Function Signature ```python def generate_circular_matrix(n: int) -> np.ndarray: pass ``` # Sample Input and Output ```python >>> import numpy as np >>> generate_circular_matrix(3) array([[1, 2, 3], [8, 9, 4], [7, 6, 5]]) >>> generate_circular_matrix(4) array([[ 1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]) >>> generate_circular_matrix(1) array([[1]]) ``` # Instructions 1. **Edge Cases**: Consider the scenario when `n = 1`. 2. **Increment Order**: Ensure the integers start from 1 and increment by 1 in a spiral pattern. 3. **Clockwise Traversal**: The traversal direction should change appropriately (right, down, left, up).","solution":"import numpy as np def generate_circular_matrix(n: int) -> np.ndarray: matrix = np.zeros((n, n), dtype=int) top, bottom, left, right = 0, n - 1, 0, n - 1 num = 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Traverse from bottom to top for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"# Coding Assessment Question **Problem Statement:** You are given a list of strings representing mathematical expressions in postfix notation (also known as Reverse Polish notation). Your task is to evaluate each expression and return the results as a list of integers. Postfix notation is a mathematical notation in which every operator follows all of its operands, e.g., the expression `2 3 +` evaluates to `5`. Write a function `evaluate_postfix_expressions` that takes a list of strings (expressions) as input, evaluates each postfix expression, and returns a list of results as integers. You should implement the function such that it correctly handles the following operators: `+`, `-`, `*`, `/` (where `/` represents integer division). **Function Signature:** ```python def evaluate_postfix_expressions(expressions: list[str]) -> list[int]: pass ``` **Input:** - `expressions`: A list of strings `expressions`, where each string represents a postfix mathematical expression (1 <= len(expressions) <= 1000, 1 <= len(expressions[i]) <= 100). **Output:** - Returns a list of integers representing the evaluated results of the input postfix expressions. **Examples:** ```python expressions = [\'2 3 +\', \'5 1 2 + 4 * + 3 -\', \'7 8 + 3 2 + /\'] print(evaluate_postfix_expressions(expressions)) # Output: [5, 14, 3] expressions = [\'4 13 5 / +\', \'10 6 9 3 + -11 * / * 17 + 5 +\'] print(evaluate_postfix_expressions(expressions)) # Output: [6, 22] ``` **Constraints:** - The input expressions will be valid postfix expressions and will not contain invalid characters. - You should handle integer division by truncating towards zero. - Each expression can contain multiple whitespace-separated tokens (operands or operators). - Division by zero will not occur in the provided input.","solution":"def evaluate_postfix_expressions(expressions): def evaluate_postfix(expression): stack = [] tokens = expression.split() for token in tokens: if token.isdigit() or (token[0] == \'-\' and token[1:].isdigit()): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': # Ensure integer division truncates towards zero stack.append(int(a / b)) return stack[0] result = [] for expr in expressions: result.append(evaluate_postfix(expr)) return result"},{"question":"# Problem: Sum of Subsequence with Specified Length Context: You are developing a functionality that deals with subsequences of lists. Specifically, you need to determine the maximum possible sum of any subsequences of a given length in a list of integers. This is particularly useful for certain combinatorial optimization problems. Function Signature: ```python def max_sum_subsequence(nums: list[int], k: int) -> int: ``` Description: Implement a function `max_sum_subsequence` that computes the maximum sum of any subsequence of length `k` from a given list of integers. A subsequence is a sequence that can be derived from the list by deleting some or no elements without changing the order of the remaining elements. Input: * `nums`: A list of integers. * `k`: An integer representing the length of the subsequence. Output: * Returns an integer representing the maximum sum of any subsequence of length `k`. Constraints: * The list `nums` can contain up to `10^5` elements. * The integer values in `nums` can range between `-10^6` and `10^6`. * The value of `k` will be between `1` and the length of `nums`. Examples: ```python nums1 = [4, 3, 1, 2] k1 = 2 assert max_sum_subsequence(nums1, k1) == 7 nums2 = [-1, -2, -3, -4] k2 = 2 assert max_sum_subsequence(nums2, k2) == -3 nums3 = [5, 1, 2, 10, 7] k3 = 3 assert max_sum_subsequence(nums3, k3) == 22 nums4 = [1, 2, 3, 4, 5] k4 = 5 assert max_sum_subsequence(nums4, k4) == 15 nums5 = [8, 2, 3, 5, -1] k5 = 4 assert max_sum_subsequence(nums5, k5) == 18 nums6 = [-5, -3, -2, -8, -1] k6 = 1 assert max_sum_subsequence(nums6, k6) == -1 ``` Requirements: Make sure to handle cases where the input list contains negative numbers efficiently and strive for an optimal solution in terms of time complexity.","solution":"def max_sum_subsequence(nums: list[int], k: int) -> int: Returns the maximum sum of any subsequence of length k from the given list of integers. # Sort the list in descending order nums_sorted = sorted(nums, reverse=True) # Take the first k elements from the sorted list return sum(nums_sorted[:k])"},{"question":"# String Permutation Checker Given two strings, write a function that determines if one string is a permutation of the other. A permutation of a string is another string that contains the same characters, only the order of characters can be different. **Function Signature**: ```python def is_permutation(str1: str, str2: str) -> bool: ``` # Input * `str1`: A string containing only lowercase letters (1 ≤ length ≤ 100,000). * `str2`: A string containing only lowercase letters (1 ≤ length ≤ 100,000). # Output * Returns `True` if `str1` is a permutation of `str2`, otherwise returns `False`. # Constraints * The function should be efficient in terms of time and space complexity. * Both strings will contain only lowercase English letters (\'a\'-\'z\'). # Example ```python assert is_permutation(\\"abc\\", \\"cab\\") == True assert is_permutation(\\"hello\\", \\"bello\\") == False assert is_permutation(\\"listen\\", \\"silent\\") == True ``` # Performance Your implementation should be able to handle large strings up to the given length constraints efficiently. **Hints**: 1. Sorting both strings and comparing can solve the problem but can be inefficient for large inputs. 2. Consider using a frequency count approach for optimized time complexity. 3. Consider edge cases such as when the strings have different lengths.","solution":"from collections import Counter def is_permutation(str1: str, str2: str) -> bool: Determines if one string is a permutation of the other. # If lengths are different, they cannot be permutations if len(str1) != len(str2): return False # Use Counter to count the frequencies of characters in both strings return Counter(str1) == Counter(str2)"},{"question":"# Social Network Analyzer Objective Design a `SocialNetworkAnalyzer` application that allows users to analyze social network data. The analyzer should help in calculating the shortest path between two users, finding all friends of a user, determining the degree of connection, and identifying if a user is an influencer. Instructions 1. **Class Definition**: Write a class `SocialNetworkAnalyzer` that: - Maintains an adjacency list to represent connections between users. - Provides methods to add connections, find friends of a user, calculate the shortest path between two users, and determine if a user is an influencer. 2. **Class Methods**: - `add_connection(user1: str, user2: str) -> None`: Adds a bidirectional connection between `user1` and `user2`. - `get_friends(user: str) -> list[str]`: Returns a list of friends for the given `user`. - `shortest_path(user1: str, user2: str) -> list[str]`: Returns the shortest path between `user1` and `user2` as a list of users. - `degree_of_connection(user: str) -> int`: Returns the degree of connection for the given `user`. - `is_influencer(user: str, threshold: int) -> bool`: Checks if the `user` has connections greater than the given `threshold`. 3. **Validation**: - Ensure that users are represented as unique strings. - Validate that connections cannot be made with oneself. - Handle cases where users have no connections. # Example Here\'s an example of how your `SocialNetworkAnalyzer` can be used: ```python analyzer = SocialNetworkAnalyzer() analyzer.add_connection(\'Alice\', \'Bob\') analyzer.add_connection(\'Alice\', \'Charlie\') analyzer.add_connection(\'Bob\', \'Charlie\') analyzer.add_connection(\'Charlie\', \'David\') print(\\"Friends of Alice:\\", analyzer.get_friends(\'Alice\')) print(\\"Shortest path between Alice and David:\\", analyzer.shortest_path(\'Alice\', \'David\')) print(\\"Degree of connection for Alice:\\", analyzer.degree_of_connection(\'Alice\')) print(\\"Is Charlie an influencer with threshold 2?\\", analyzer.is_influencer(\'Charlie\', 2)) ``` Constraints - Assume the maximum number of users in the social network is 10,000. - The maximum number of connections a single user can have is 1,000. - Always ensure that the user exists in the network before performing any operation on them.","solution":"from collections import deque class SocialNetworkAnalyzer: def __init__(self): self.adj_list = {} def add_connection(self, user1: str, user2: str) -> None: if user1 == user2: raise ValueError(\\"A user cannot connect to oneself.\\") if user1 not in self.adj_list: self.adj_list[user1] = [] if user2 not in self.adj_list: self.adj_list[user2] = [] if user2 not in self.adj_list[user1]: self.adj_list[user1].append(user2) if user1 not in self.adj_list[user2]: self.adj_list[user2].append(user1) def get_friends(self, user: str) -> list[str]: return self.adj_list.get(user, []) def shortest_path(self, user1: str, user2: str) -> list[str]: if user1 not in self.adj_list or user2 not in self.adj_list: return [] visited = {user: False for user in self.adj_list} queue = deque([(user1, [user1])]) while queue: current_user, path = queue.popleft() if current_user == user2: return path for friend in self.adj_list[current_user]: if not visited[friend]: visited[friend] = True queue.append((friend, path + [friend])) return [] def degree_of_connection(self, user: str) -> int: if user not in self.adj_list: return 0 return len(self.adj_list[user]) def is_influencer(self, user: str, threshold: int) -> bool: return self.degree_of_connection(user) > threshold"},{"question":"Task Question Creation for Coding Assessment # New Question # Problem Statement: Scenario: A game developer is working on a grid-based puzzle game. One of the core mechanics involves determining if a player can slide from one cell to another following certain movement rules. The player can slide from their current cell to an adjacent cell in the same row or column as long as the destination cell has the same or a higher value. Your task is to help the game developer by writing an algorithm that determines if there is a valid sliding path from a specified starting cell to a target cell on an `MxN` grid. # Function Signature: ```python def can_slide_from_to(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: pass ``` # Input: 1. **grid** (List[List[int]]): A 2D list of integers representing the grid. 2. **start** (Tuple[int, int]): The starting cell coordinates as a tuple `(row, col)`. 3. **target** (Tuple[int, int]): The target cell coordinates as a tuple `(row, col)`. # Output: - **can_reach** (bool): Returns `True` if the player can slide from the start to the target cell following the movement rules, otherwise returns `False`. # Constraints: - The grid dimensions are `MxN`, where 1 <= M, N <= 1000. - The grid contains non-negative integers. - The start and target coordinates are within the grid bounds. - Movement is only allowed to adjacent cells (up, down, left, or right). # Requirements: - The function should handle large grids efficiently. - Use appropriate data structures to optimize the sliding path search. - Proper error handling for invalid inputs is required. # Example: ```python grid = [ [1, 2, 2], [3, 2, 4], [2, 3, 3] ] print(can_slide_from_to(grid, (0, 0), (2, 2))) # Expected output: True print(can_slide_from_to(grid, (0, 0), (0, 2))) # Expected output: True print(can_slide_from_to(grid, (0, 0), (1, 0))) # Expected output: True print(can_slide_from_to(grid, (2, 2), (0, 0))) # Expected output: False ``` Additional Information: - The player can only move to an adjacent cell (left, right, up, down) and can only slide to cells that have a value equal to or higher than the current cell. - Use a breadth-first search or depth-first search algorithm to find the path. **Note**: Consider edge cases where the start and target are the same cell or when the grid contains uniform values. Ensure the function handles grids of varying dimensions efficiently.","solution":"from typing import List, Tuple from collections import deque def can_slide_from_to(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: def is_valid(r, c): return 0 <= r < len(grid) and 0 <= c < len(grid[0]) def bfs(start, target): if start == target: return True queue = deque([start]) visited = set([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: current = queue.popleft() r, c = current for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in visited and grid[nr][nc] >= grid[r][c]: if (nr, nc) == target: return True queue.append((nr, nc)) visited.add((nr, nc)) return False return bfs(start, target)"},{"question":"# Coding Question Context You are working on an e-commerce platform where users can apply discount codes to their shopping carts. Each discount code has a limited number of uses, and once the limit is reached, the discount code becomes invalid. Implement a function that simulates users applying a list of discount codes and returns the result of each application attempt. Objective Write a function `apply_discount_codes` that takes two parameters: an integer representing the total number of discount codes available, and a list of strings representing user attempts to apply discount codes. Each string is in the format \\"CODE-x\\" where \\"CODE\\" is the discount code and \\"x\\" is the identifier for the attempt. Function Signature ```python def apply_discount_codes(total_codes: int, attempts: list[str]) -> list[str]: ``` Input * `total_codes`: an integer representing the total number of discount codes available. Constraints: 1 <= total_codes <= 100. * `attempts`: a list of strings representing user attempts to apply discount codes. Constraints: 1 <= len(attempts) <= 1000 and each attempt is a non-empty string in the format \\"CODE-x\\". Output * A list of strings where each string is either \\"SUCCESS: CODE-x\\" if the discount code was applied successfully, or \\"FAILURE: CODE-x\\" if the discount code is invalid or has already been used up. Examples ```python >>> apply_discount_codes(3, [\\"DISCOUNT-1\\", \\"DISCOUNT-2\\", \\"DISCOUNT-3\\", \\"DISCOUNT-1\\", \\"SALE-1\\"]) [\'SUCCESS: DISCOUNT-1\', \'SUCCESS: DISCOUNT-2\', \'SUCCESS: DISCOUNT-3\', \'FAILURE: DISCOUNT-1\', \'SUCCESS: SALE-1\'] >>> apply_discount_codes(2, [\\"OFFER-1\\", \\"OFFER-2\\", \\"OFFER-3\\"]) [\'SUCCESS: OFFER-1\', \'SUCCESS: OFFER-2\', \'FAILURE: OFFER-3\'] >>> apply_discount_codes(1, [\\"PROMO-1\\", \\"PROMO-2\\", \\"PROMO-3\\", \\"PROMO-1\\"]) [\'SUCCESS: PROMO-1\', \'FAILURE: PROMO-2\', \'FAILURE: PROMO-3\', \'FAILURE: PROMO-1\'] >>> apply_discount_codes(4, [\\"CODE-1\\", \\"CODE-2\\", \\"CODE-3\\", \\"CODE-4\\", \\"CODE-5\\"]) [\'SUCCESS: CODE-1\', \'SUCCESS: CODE-2\', \'SUCCESS: CODE-3\', \'SUCCESS: CODE-4\', \'FAILURE: CODE-5\'] ``` Constraints * Assume that each discount code is unique and case-sensitive. * The total number of successful applications across different codes should not exceed `total_codes`. Notes 1. Handle invalid formats gracefully, although they are not expected in the input. 2. Ensure the function efficiently manages the state of available discount codes and processes each attempt in the order received.","solution":"def apply_discount_codes(total_codes: int, attempts: list[str]) -> list[str]: Apply the discount codes from the attempts list, respecting the total number of allowed uses. :param total_codes: Total number of discount codes available. :param attempts: List of strings representing user attempts to apply discount codes. :return: List of strings indicating whether each attempt is a success or failure. code_usage = {} results = [] successful_applications = 0 for attempt in attempts: code = attempt.split(\'-\')[0] if code_usage.get(code, 0) < total_codes: code_usage[code] = code_usage.get(code, 0) + 1 results.append(f\'SUCCESS: {attempt}\') successful_applications += 1 else: results.append(f\'FAILURE: {attempt}\') return results"},{"question":"# Problem Statement You are tasked with writing a function that, given a list of integers, returns a new list where the elements are the cumulative sum of the original list. The cumulative sum of a list at index `i` is the sum of all elements from the start of the list up to index `i` (inclusive). # Function Signature ```python def cumulative_sum(numbers: List[int]) -> List[int]: Calculate the cumulative sum of a list of integers. Args: numbers - A list of integers for which the cumulative sum needs to be calculated. Returns: A list of integers representing the cumulative sum. pass ``` # Input - `numbers`: A list of integers. The list can contain both positive and negative integers, and the elements can be as large as 10^9. # Output - A list of integers where each element is the cumulative sum up to that index. # Constraints - The input list can contain up to 10^5 elements. # Performance Requirements - The solution should efficiently compute the cumulative sum with a time complexity of O(n), where `n` is the length of the input list. # Example Given the input list: ```python numbers = [1, 2, 3, 4, 5] ``` The output should be: ```python [1, 3, 6, 10, 15] ``` Given the input list: ```python numbers = [-1, -2, -3, -4, -5] ``` The output should be: ```python [-1, -3, -6, -10, -15] ``` Given the input list: ```python numbers = [3, -3, 3, -3, 3] ``` The output should be: ```python [3, 0, 3, 0, 3] ``` # Edge Cases - An empty list should return an empty list. - Lists with a mix of large positive and negative integers should be handled correctly. - Lists with only one element should return a list with that single element. Make sure your implementation is robust and handles all specified edge cases correctly. You should write your own tests to validate the correctness of your solution.","solution":"from typing import List def cumulative_sum(numbers: List[int]) -> List[int]: Calculate the cumulative sum of a list of integers. Args: numbers - A list of integers for which the cumulative sum needs to be calculated. Returns: A list of integers representing the cumulative sum. result = [] current_sum = 0 for number in numbers: current_sum += number result.append(current_sum) return result"},{"question":"# Problem Statement In computer science, a palindrome is a string that reads the same backward as forward. Write a function that takes a list of strings and returns the count of palindromes from the list. The function signature is: ```python def count_palindromes(strings: List[str]) -> int: pass ``` # Input - `strings`: A list of strings with the following constraints: - The length of `strings` is between `1` and `1000`. - Each string in the list has a length between `1` and `100`. # Output - The function should return an integer, representing the count of palindromes in the list. # Example ```python strings = [\\"radar\\", \\"hello\\", \\"level\\", \\"world\\", \\"deed\\"] print(count_palindromes(strings)) # Output: 3 ``` # Constraints - Palindrome detection must be case-insensitive. - An empty string is considered a palindrome. # Additional Notes - Consider edge cases such as strings with varying cases (e.g., \\"RaceCar\\"). - Optimize the function to handle the upper limits of the input constraints efficiently.","solution":"from typing import List def count_palindromes(strings: List[str]) -> int: Counts the number of palindrome strings in the given list. Parameters: strings (List[str]): A list of strings. Returns: int: The number of palindromes in the list. def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. s = s.lower() return s == s[::-1] return sum(1 for s in strings if is_palindrome(s))"},{"question":"# Coding Assessment Question **Scenario**: You have been assigned the task of enhancing the existing `Tree` class with additional functionalities to manage a binary search tree (BST). Specifically, you are required to add methods for: 1. Inserting a node. 2. Deleting a node. 3. Performing in-order traversal to print the BST. 4. Finding the height of the BST. **Requirements**: 1. **Binary Search Tree Representation**: Extend the `Tree` class to support a BST with node insertion and deletion functionalities. 2. **In-order Traversal**: Implement `inorder_traversal` to print the elements of the tree in ascending order. 3. **Height Calculation**: Implement `calculate_height` to determine the height of the tree. 4. **Edge Case Handling**: Handle edge cases such as an empty tree, deleting a non-existing node, and ensuring tree properties are maintained during insertion and deletion. **Function Implementation**: 1. **insert_node(value: int) -> None** - Parameter: - `value`: The integer value to be inserted into the BST. - Inserts the specified value into the tree while maintaining BST properties. 2. **delete_node(value: int) -> None** - Parameter: - `value`: The integer value of the node to be deleted from the BST. - Deletes the specified node from the tree while maintaining BST properties. 3. **inorder_traversal(node: Optional[TreeNode]) -> List[int]** - Parameter: - `node`: The root node of the BST. - Returns a list of elements in the tree in ascending order. 4. **calculate_height(node: Optional[TreeNode]) -> int** - Parameter: - `node`: The root node of the BST. - Returns the height of the tree. **Input & Output**: ```python # Example usage of the Tree class class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class Tree: def __init__(self): self.root = None def insert_node(self, value): # Method to insert a node maintaining BST properties pass def delete_node(self, value): # Method to delete a node maintaining BST properties pass def inorder_traversal(self, node): # Method to perform in-order traversal and return a list of node values pass def calculate_height(self, node): # Method to calculate the height of the tree pass # Creating a binary search tree and performing operations bst = Tree() bst.insert_node(10) bst.insert_node(5) bst.insert_node(20) bst.insert_node(3) bst.insert_node(7) print(bst.inorder_traversal(bst.root)) # Output: [3, 5, 7, 10, 20] print(bst.calculate_height(bst.root)) # Output: 2 bst.delete_node(10) print(bst.inorder_traversal(bst.root)) # Output: [3, 5, 7, 20] print(bst.calculate_height(bst.root)) # Output: 2 ``` **Constraints**: - The tree can contain up to 1000 nodes. - Node values can range from -10^4 to 10^4. - Ensure that edge cases such as inserting into an empty tree, deleting nodes that do not exist, and calculating the height of an empty tree are correctly handled. Validate your solution with various test scenarios to ensure its accuracy and robustness.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class Tree: def __init__(self): self.root = None def insert_node(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_node(self.root, value) def _insert_node(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_node(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_node(node.right, value) def delete_node(self, value): self.root = self._delete_node(self.root, value) def _delete_node(self, node, value): if node is None: return node if value < node.value: node.left = self._delete_node(node.left, value) elif value > node.value: node.right = self._delete_node(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.value = temp.value node.right = self._delete_node(node.right, temp.value) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder_traversal(self, node): result = [] self._inorder_traversal(node, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) def calculate_height(self, node): if node is None: return -1 else: left_height = self.calculate_height(node.left) right_height = self.calculate_height(node.right) return 1 + max(left_height, right_height)"},{"question":"**Scenario**: You are required to implement a text editor that supports basic text manipulation operations. Unlike typical editors, this editor must handle a unique operation that deals with a specific character. **Problem Statement**: Write a class `TextEditor` that provides methods to: 1. Add text to the editor. 2. Remove a given number of characters from the end of the current text. 3. Count the occurrences of a given character in the current text. The operations should allow you to build and manipulate the text efficiently. **Class Signature**: ```python class TextEditor: def __init__(self): pass def add_text(self, text: str) -> None: pass def remove_text(self, count: int) -> None: pass def count_character(self, char: str) -> int: pass ``` **Input**: - `add_text(self, text: str)`: Adds the given text to the current text. - `remove_text(self, count: int)`: Removes the specified number of characters from the end of the current text. - `count_character(self, char: str)`: Returns the number of times the given character appears in the current text. **Constraints**: 1. The input texts consist of lowercase and uppercase English letters and spaces. 2. 0 <= count <= length of the current text. 3. `char` is a single lowercase or uppercase English letter. # Example: ```python # Example usage editor = TextEditor() editor.add_text(\\"hello world\\") editor.remove_text(5) print(editor.count_character(\'o\')) # Output: 1 editor.add_text(\\" goodnight moon\\") print(editor.count_character(\'o\')) # Output: 4 ``` **Explanation**: - Initially, the text is \\"hello world\\". - After removing 5 characters, the text becomes \\"hello \\". - Counting the character \'o\' results in 1. - Adding \\" goodnight moon\\" to the current text changes it to \\"hello goodnight moon\\". - Now counting the character \'o\' results in 4.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" def add_text(self, text: str) -> None: self.text += text def remove_text(self, count: int) -> None: self.text = self.text[:-count] def count_character(self, char: str) -> int: return self.text.count(char)"},{"question":"# Question: Implement a Custom String Reverser with Undo Operation Design a custom string manipulator class that supports the following operations: - `append(val: str) -> None`: Adds a string to the end. - `reversestr(start: int, end: int) -> None`: Reverses the substring from index `start` to `end` (both inclusive). - `undo() -> None`: Undoes the last `reversestr` operation. - `is_empty() -> bool`: Checks if the string is empty. - `__repr__() -> str`: Returns a string representation of the current state of the string. Function Signature: ```python class StringReverser: def __init__(self: StringReverser, initial_string: str = \\"\\") -> None: pass def append(self: StringReverser, val: str) -> None: pass def reversestr(self: StringReverser, start: int, end: int) -> None: pass def undo(self: StringReverser) -> None: pass def is_empty(self: StringReverser) -> bool: pass def __repr__(self: StringReverser) -> str: pass ``` # Constraints: - Ensure that the `undo` operation can be called only once after the last `reversestr` operation. - If no `reversestr` operation has been performed, calling `undo` should have no effect. # Example: ```python sr = StringReverser(\\"hello\\") sr.append(\\" world\\") print(sr) # Output: \\"hello world\\" sr.reversestr(6, 10) print(sr) # Output: \\"hello dlrow\\" sr.undo() print(sr) # Output: \\"hello world\\" print(sr.is_empty()) # Output: False ```","solution":"class StringReverser: def __init__(self, initial_string: str = \\"\\") -> None: self._string = initial_string self._history = [] def append(self, val: str) -> None: self._string += val def reversestr(self, start: int, end: int) -> None: if start < 0 or end >= len(self._string) or start > end: raise ValueError(\\"Invalid start or end index\\") self._history.append((start, end, self._string[start:end+1])) substr_reversed = self._string[start:end+1][::-1] self._string = self._string[:start] + substr_reversed + self._string[end+1:] def undo(self) -> None: if self._history: start, end, original_substring = self._history.pop() self._string = self._string[:start] + original_substring + self._string[end+1:] def is_empty(self) -> bool: return len(self._string) == 0 def __repr__(self) -> str: return self._string"},{"question":"# **Finding the Longest Upward Subsequence with Constraints** **Scenario:** You are developing a feature for a stock trading application. One of the key computations needed is finding the longest upward subsequence (i.e., a subsequence where each subsequent number is larger than the previous one) within a list of stock prices. However, due to real-world constraints, the subsequence must also have no repeated prices. **Task:** Implement the `longest_upward_subsequence` function. This function should find the longest upward subsequence in a list of integers representing stock prices, making sure that the subsequence contains no duplicates. The function should then return the found subsequence. **Specifications:** # **Function Signature:** ```python def longest_upward_subsequence(prices: list) -> list: ``` # **Input:** - `prices`: List of integers representing stock prices. (1 ≤ len(prices) ≤ 10^3, 1 ≤ prices[i] ≤ 10^5) # **Output:** - List of integers representing the longest subsequence where each element is greater than the previous and contains no duplicates. If there are multiple subsequences of equal maximum length, return any one of them. # **Constraints:** - The algorithm should be efficient in both time and space. - The function should handle edge cases such as extreme values and duplicate prices. **Example:** ```python >>> longest_upward_subsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> longest_upward_subsequence([50, 3, 10, 7, 40, 80]) [3, 10, 40, 80] >>> longest_upward_subsequence([100, 101, 102, 102, 102, 103, 104]) [100, 101, 102, 103, 104] ``` *Note: In the first example, [3, 10, 20] is a longest upward subsequence. In the second example, [3, 10, 40, 80] is one possible answer.* **Hints:** - Utilize dynamic programming or a modified version of the Longest Increasing Subsequence (LIS) algorithm. - Keep track of used prices to avoid duplicates in the subsequence.","solution":"def longest_upward_subsequence(prices: list) -> list: n = len(prices) if n == 0: return [] # Create an array to store the longest subsequence ending at each position dp = [[] for _ in range(n)] dp[0] = [prices[0]] max_len = 1 last_index = 0 for i in range(1, n): for j in range(i): if prices[i] > prices[j] and prices[i] not in dp[j]: if len(dp[j]) + 1 > len(dp[i]): dp[i] = dp[j] + [prices[i]] if len(dp[i]) > max_len: max_len = len(dp[i]) last_index = i if not dp[i]: # no better subsequence found in the inner loop dp[i] = [prices[i]] return dp[last_index]"},{"question":"# Coding Assessment Question Context You are tasked with writing a function to determine the longest contiguous subarray that sums to a given target. This kind of problem is common in algorithmic challenges involving array manipulation and sliding window techniques. Problem Statement Write a function `longest_subarray_sum(arr: List[int], target: int) -> int` that finds the length of the longest contiguous subarray which sums to the given target. Function Signature ```python def longest_subarray_sum(arr: List[int], target: int) -> int: # Your code here ``` Input - `arr`: A list of integers, representing the array of numbers. (1 ≤ len(arr) ≤ 10^5, -10^4 ≤ arr[i] ≤ 10^4) - `target`: An integer representing the desired sum of the subarray. (-10^9 ≤ target ≤ 10^9) Output - An integer which is the length of the longest contiguous subarray that sums to the target. If there is no such subarray, return 0. Example ```python assert longest_subarray_sum([1, -1, 5, -2, 3], 3) == 4 assert longest_subarray_sum([-2, -1, 2, 1], 1) == 2 assert longest_subarray_sum([1, 2, 3, 4, 5], 15) == 5 assert longest_subarray_sum([1, 2, 3], 7) == 0 assert longest_subarray_sum([], 0) == 0 # edge case ``` Constraints - Ensure the function handles large arrays efficiently. - Handle both positive and negative integers within the array. - Consider edge cases where the input array may be empty. Hints - Think about utilizing a dictionary to keep track of the cumulative sum and its indices. - Use the sliding window technique or prefix sum approach to optimize the solution. - Pay attention to time complexity to ensure it performs well under maximum constraints.","solution":"from typing import List def longest_subarray_sum(arr: List[int], target: int) -> int: prefix_sum_map = {} prefix_sum = 0 max_len = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum == target: max_len = i + 1 if (prefix_sum - target) in prefix_sum_map: max_len = max(max_len, i - prefix_sum_map[prefix_sum - target]) if prefix_sum not in prefix_sum_map: prefix_sum_map[prefix_sum] = i return max_len"},{"question":"# Problem Statement **Question 2:** You are given a list of integers representing the stock prices of a company in sequential days. Implement a class `StockAnalyzer` that includes methods to analyze trends and patterns in the stock prices. 1. `max_profit(self) -> int` This method should calculate the maximum profit that could be achieved from exactly one transaction (buy one day and sell on a later day). If no profit can be achieved, return 0. **Input**: - No input (other than `self`). **Output**: - (int): The maximum profit. If no profit can be achieved, return 0. 2. `longest_increasing_subsequence(self) -> list[int]` This method should find the longest increasing subsequence of stock prices. A subsequence is derived from removing some or no elements without changing the order of the remaining elements. **Input**: - No input (other than `self`). **Output**: - (list[int]): The longest increasing subsequence of stock prices. # Constraints * The number of days (length of the list) is up to 10^5. * Stock prices range between 1 and 10^9. * The longest increasing subsequence method must work in O(n log n) time complexity. # Example: ```python # Example usage of the methods: sa = StockAnalyzer([7, 1, 5, 3, 6, 4]) # Method: max_profit() print(sa.max_profit()) # Output should be 5 (Buy at 1 and sell at 6) # Method: longest_increasing_subsequence() print(sa.longest_increasing_subsequence()) # Output should be [1, 3, 6] ``` You need to implement the `StockAnalyzer` class and ensure that all the provided examples work correctly.","solution":"class StockAnalyzer: def __init__(self, prices): self.prices = prices def max_profit(self) -> int: if not self.prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in self.prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def longest_increasing_subsequence(self) -> list[int]: from bisect import bisect_left if not self.prices: return [] subseq = [] for price in self.prices: pos = bisect_left(subseq, price) if pos < len(subseq): subseq[pos] = price else: subseq.append(price) # Reconstruct the longest increasing subsequence from the determined positions lis = [] current_min = float(\'inf\') for i in range(len(subseq) - 1, -1, -1): if subseq[i] < current_min: lis.append(subseq[i]) current_min = subseq[i] return lis[::-1]"},{"question":"# Problem Statement You are tasked with developing a file system management tool that simulates basic file operations on a simplified virtual file system. Your task is to extend the capabilities of the `VirtualFileSystem` class provided, specifically focusing on adding functionality to: 1. Create a new file with a given name and content. 2. Read the content of an existing file. 3. Delete an existing file. 4. Rename an existing file. # Task Requirements 1. Implement four new methods in the `VirtualFileSystem` class: * `create_file(self, file_name: str, content: str) -> bool`: Creates a new file with the given `file_name` and fills it with `content`. If the file already exists, it should return `False` and not overwrite the existing file. If successfully created, return `True`. * `read_file(self, file_name: str) -> str`: Returns the content of the file with the given `file_name`. If the file does not exist, return an empty string. * `delete_file(self, file_name: str) -> bool`: Deletes the file with the given `file_name`. If the file does not exist, return `False`. If successfully deleted, return `True`. * `rename_file(self, old_name: str, new_name: str) -> bool`: Renames a file from `old_name` to `new_name`. If a file with `new_name` already exists or `old_name` does not exist, return `False`. Otherwise, return `True`. # Input - The file names are strings containing only alphanumeric characters and have a maximum length of 100 characters. - The file content is a string and can have a maximum length of 10^4 characters. # Output - For `create_file`, return a boolean. - For `read_file`, return a string. - For `delete_file`, return a boolean. - For `rename_file`, return a boolean. # Constraints 1. There can be up to `10^5` files in the virtual file system. # Example ```python vfs = VirtualFileSystem() # Example usage: print(vfs.create_file(\'file1\', \'Hello, World!\')) # Output: True print(vfs.read_file(\'file1\')) # Output: \'Hello, World!\' print(vfs.create_file(\'file1\', \'New Content\')) # Output: False print(vfs.delete_file(\'file1\')) # Output: True print(vfs.read_file(\'file1\')) # Output: \'\' print(vfs.create_file(\'file2\', \'Another file\')) # Output: True print(vfs.rename_file(\'file2\', \'file3\')) # Output: True print(vfs.read_file(\'file3\')) # Output: \'Another file\' print(vfs.rename_file(\'file3\', \'file4\')) # Output: True print(vfs.create_file(\'file4\', \'Duplicate\')) # Output: False ``` Implement the methods in such a way that they are efficient and handle the constraints mentioned.","solution":"class VirtualFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str, content: str) -> bool: if file_name in self.files: return False self.files[file_name] = content return True def read_file(self, file_name: str) -> str: return self.files.get(file_name, \\"\\") def delete_file(self, file_name: str) -> bool: if file_name in self.files: del self.files[file_name] return True return False def rename_file(self, old_name: str, new_name: str) -> bool: if old_name not in self.files or new_name in self.files: return False self.files[new_name] = self.files.pop(old_name) return True"},{"question":"Implement a Class for a Stack with Max Operation Design a stack data structure that supports the following operations: 1. Push an integer onto the stack. 2. Pop an integer from the stack. 3. Retrieve the maximum element in the stack. Implement the class `MaxStack` with the following methods: ```python class MaxStack: def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> int: pass def max(self) -> int: pass ``` # Constraints - All operations `push`, `pop`, and `max` must be O(1). - You may assume that all operations are valid (for example, no `pop` or `max` operations will be called on an empty stack). - Do not use any Python built-in structures like `list`, `deque`, etc., for implementing the stack. # Example ```python stack = MaxStack() stack.push(3) stack.push(5) assert stack.max() == 5 # Max is 5 stack.push(2) stack.push(1) assert stack.max() == 5 # Max is still 5 stack.pop() assert stack.max() == 5 # Max is still 5 stack.pop() assert stack.max() == 3 # Max is now 3 ``` # Additional Notes - Ensure that your implementation accurately keeps track of the maximum element in the stack through all operations. - Consider using an auxiliary stack to help manage the maximum values efficiently.","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if self.stack: popped_value = self.stack.pop() if popped_value == self.max_stack[-1]: self.max_stack.pop() return popped_value def max(self) -> int: if self.max_stack: return self.max_stack[-1]"},{"question":"Coding Assessment Question # Context: You are helping an intelligent robot navigate through a grid to collect the maximum number of energy cells. The robot can only move right or down from any given cell, and certain cells in the grid have been marked as impassable due to obstacles. # Problem: The robot starts at the top-left corner of the grid and wants to reach the bottom-right corner. Each cell in the grid can either contain an energy cell (represented by a positive integer in the grid), an obstacle (represented by a -1), or be empty (represented by a 0). Implement a function to find the maximum number of energy cells the robot can collect while navigating from the top-left to the bottom-right corner of the grid. # Function Signature: ```python def max_energy_collection(grid: List[List[int]]) -> int: ``` Input: - **grid**: A 2D list where each element is an integer representing the grid as described above. Output: - An integer representing the maximum number of energy cells the robot can collect on its way to the bottom-right corner. - If it is impossible for the robot to reach the bottom-right corner, return -1. Constraints: - `1 ≤ len(grid), len(grid[0]) ≤ 100` - `-1 ≤ grid[i][j] ≤ 100` # Example: ```python # Input grid = [ [0, 1, -1], [1, 0, 0], [1, 1, 1] ] # Output 4 ``` ```python # Input grid = [ [1, -1, 3], [2, 0, -1], [4, -1, 1] ] # Output -1 ``` # Guidelines: * Utilize a dynamic programming approach to solve the problem efficiently. * Create a 2D array to keep track of the maximum energy cells collected up to each cell, taking into account obstacles. * If an obstacle blocks the path, or if there is no valid path to reach the bottom-right corner, return -1.","solution":"from typing import List def max_energy_collection(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) # If the start or end is an obstacle, collection is impossible if grid[0][0] == -1 or grid[rows-1][cols-1] == -1: return -1 # Initialize a dp array to store the maximum energy cells collected up to each cell dp = [[-1 for _ in range(cols)] for _ in range(rows)] dp[0][0] = grid[0][0] if grid[0][0] != -1 else -1 # Fill the dp array for i in range(rows): for j in range(cols): if grid[i][j] == -1: # Obstacle dp[i][j] = -1 continue # If top cell is reachable, update dp value if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) # If left cell is reachable, update dp value if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) # Return the maximum energy collected at the bottom-right corner if reachable return dp[rows-1][cols-1] if dp[rows-1][cols-1] != -1 else -1"},{"question":"# K-Means Clustering Implementation Implement a k-means clustering algorithm from scratch. Given a dataset of points in a 2D space and a specified number of clusters k, your task is to assign each point to one of the k clusters by minimizing the Euclidean distance between points and their corresponding cluster centroids. # Input Format * An integer k, representing the number of clusters (1 ≤ k ≤ 10). * A 2D list of floats `points`, where each sublist contains two float values representing the x and y coordinates of a point in 2D space. The number of points (n) will be an integer such that (1 ≤ n ≤ 1000). # Output Format * A dictionary where the keys are the cluster indices (0 to k-1) and the values are lists of points (each point is represented as a 2-tuple) that belong to the corresponding cluster. # Constraints * Use the Euclidean distance to compute the distance between points and cluster centroids. * Randomly initialize the centroids for the k clusters. * Iterate until the centroids stabilize (i.e., when the assignments no longer change). * Do not use any built-in clustering functions; implement the algorithm from scratch. # Performance Requirements * Ensure the implementation efficiently handles the upper limits of the constraints. # Example ```python import random def k_means_clustering(k, points): def euclidean_distance(point1, point2): return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5 # Randomly initialize centroids centroids = random.sample(points, k) previous_assignments = None while True: # Assign points to the nearest centroid assignments = [[] for _ in range(k)] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_index = distances.index(min(distances)) assignments[closest_index].append(point) # Update centroids new_centroids = [] for cluster in assignments: if cluster: # Avoid division by zero new_centroid = (sum(x for x, y in cluster) / len(cluster), sum(y for x, y in cluster) / len(cluster)) new_centroids.append(new_centroid) else: # In case of an empty cluster, reinitialize centroid randomly new_centroids.append(random.choice(points)) if assignments == previous_assignments: break previous_assignments = assignments centroids = new_centroids # Returning a dictionary with clusters return {i: assignments[i] for i in range(k)} # Test case k = 2 points = [[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [5.0, 6.0], [8.0, 9.0]] clusters = k_means_clustering(k, points) print(clusters) # Output should look like {0: [(1.0, 2.0), (2.0, 3.0)], 1: [(3.0, 4.0), (5.0, 6.0), (8.0, 9.0)]} ``` Note: - Handle edge cases such as potential empty clusters by reinitializing centroids appropriately. - Ensure the function is robust to different initializations and converges correctly.","solution":"import random def k_means_clustering(k, points): def euclidean_distance(point1, point2): return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5 # Randomly initialize centroids centroids = random.sample(points, k) previous_assignments = None while True: # Assign points to the nearest centroid assignments = [[] for _ in range(k)] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_index = distances.index(min(distances)) assignments[closest_index].append(point) # Update centroids new_centroids = [] for cluster in assignments: if cluster: # Avoid division by zero new_centroid = (sum(x for x, y in cluster) / len(cluster), sum(y for x, y in cluster) / len(cluster)) new_centroids.append(new_centroid) else: # In case of an empty cluster, reinitialize centroid randomly new_centroids.append(random.choice(points)) if assignments == previous_assignments: break previous_assignments = assignments centroids = new_centroids # Returning a dictionary with clusters return {i: assignments[i] for i in range(k)}"},{"question":"# Question: Implement a String Palindrome Checker with Case Sensitivity Control You are tasked with implementing a system that checks if a given string is a palindrome. The system should support case sensitivity configuration. Functions to Implement: 1. **Is Palindrome Case Sensitive** - Checks if the given string is a palindrome considering case sensitivity. - **Input**: `s: str` - **Output**: `bool` 2. **Is Palindrome Case Insensitive** - Checks if the given string is a palindrome without considering case sensitivity. - **Input**: `s: str` - **Output**: `bool` 3. **Palindrome Checker** - Determines if the given string is a palindrome based on the specified case sensitivity. - **Input**: `s: str, case_sensitive: bool` - **Output**: `bool` **Constraints**: - The string `s` will only contain printable ASCII characters. **Example:** Input: ```python s = \\"Madam\\" case_sensitive = False ``` Output: ```python True # \\"Madam\\" is considered a palindrome ignoring case ``` Input: ```python s = \\"Madam\\" case_sensitive = True ``` Output: ```python False # \\"Madam\\" is not a palindrome considering case sensitivity ``` **Implementation:** Implement the following functions: ```python def is_palindrome_case_sensitive(s: str) -> bool: pass def is_palindrome_case_insensitive(s: str) -> bool: pass def palindrome_checker(s: str, case_sensitive: bool) -> bool: pass ```","solution":"def is_palindrome_case_sensitive(s: str) -> bool: Checks if the given string is a palindrome considering case sensitivity. # Compare the string with its reverse return s == s[::-1] def is_palindrome_case_insensitive(s: str) -> bool: Checks if the given string is a palindrome without considering case sensitivity. # Convert the string to lower case and compare with its reverse s = s.lower() return s == s[::-1] def palindrome_checker(s: str, case_sensitive: bool) -> bool: Determines if the given string is a palindrome based on the specified case sensitivity. if case_sensitive: return is_palindrome_case_sensitive(s) else: return is_palindrome_case_insensitive(s)"},{"question":"# Reverse Words in a String Scenario In an effort to enhance text processing capabilities in messaging applications, you are tasked with implementing a function to reverse the words in a string. This feature is meant to help users read text in reverse order, assisting in cryptographic and language learning applications. Problem Statement Write a function `reverse_words` that reverses the order of words in a given string. A word is defined as a sequence of non-space characters. The input string may contain leading or trailing spaces, and there may be multiple spaces between words. The output string should have the words in reverse order, with a single space separating them, and no leading or trailing spaces. Function Signature ```python def reverse_words(s: str) -> str: ``` Input - `s` (str): A string containing words separated by spaces. Output - Returns a string with the words in reverse order, separated by a single space. Examples ```python assert reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" assert reverse_words(\\" hello world \\") == \\"world hello\\" assert reverse_words(\\"a good example\\") == \\"example good a\\" assert reverse_words(\\" \\") == \\"\\" assert reverse_words(\\"oneWord\\") == \\"oneWord\\" ``` Constraints - The input string can contain any printable ASCII characters. - The length of the string `s` can be up to 10,000 characters. Performance Requirements - The function should handle strings efficiently with a time complexity of O(n), where n is the length of the input string. Notes - Ensure to handle edge cases with different amounts of spaces between words and at the beginning or end of the string. - Consider using Python\'s built-in string functions to streamline the implementation. --- This additional question keeps in line with the provided question\'s format, presentation, and complexity by focusing on string manipulation—another fundamental concept in programming. The problem is clearly stated, the function signature is provided, and constraints are specified to ensure the question is similarly challenging and relevant.","solution":"def reverse_words(s: str) -> str: Reverse the order of words in the given string s. Words are defined as sequences of non-space characters. The output string should have words in reverse order, separated by a single space and no leading or trailing spaces. words = s.split() # splits the string by spaces into a list of words reversed_words = words[::-1] # reverse the list of words result = \\" \\".join(reversed_words) # joins the words back together with a single space separator return result"},{"question":"# Coding Assessment: Matrix Multiplication Implementation **Objective**: Implement the core function for matrix multiplication that returns the product of two matrices. # Problem Given two matrices, write a function `matrix_multiply` that takes in these matrices and returns their product. # Function Signature ```python def matrix_multiply(matrix_a: np.ndarray, matrix_b: np.ndarray) -> np.ndarray: Compute the product of two matrices. Args: matrix_a (np.ndarray): The first input matrix. matrix_b (np.ndarray): The second input matrix. Returns: np.ndarray: The product matrix resulting from multiplying matrix_a with matrix_b. pass ``` # Input * `matrix_a`: A numpy array of shape (m, n) where `m` is the number of rows and `n` is the number of columns. * `matrix_b`: A numpy array of shape (n, p) where `n` is the number of rows and `p` is the number of columns. # Output * A numpy array of shape (m, p) representing the product matrix from multiplying `matrix_a` with `matrix_b`. # Constraints * 1 ≤ m, n, p ≤ 100 # Example ```python import numpy as np matrix_a = np.array([[1, 2], [3, 4]]) matrix_b = np.array([[2, 0], [1, 2]]) result = matrix_multiply(matrix_a, matrix_b) print(result) # Expected output: [[4, 4], [10, 8]] ``` # Instructions 1. Implement the function `matrix_multiply` using efficient matrix multiplication operations. 2. Ensure that your function handles potential edge cases, like incompatible matrix dimensions. 3. Pay attention to the computational efficiency and optimize where possible. 4. Test your function with various cases to ensure accuracy. # Notes * Utilize functions from numpy to handle matrix operations efficiently. * Validate the input shapes and dimensions inside your function to ensure robustness. * Ensure the input matrices are compatible for matrix multiplication based on their dimensions.","solution":"import numpy as np def matrix_multiply(matrix_a: np.ndarray, matrix_b: np.ndarray) -> np.ndarray: Compute the product of two matrices. Args: matrix_a (np.ndarray): The first input matrix. matrix_b (np.ndarray): The second input matrix. Returns: np.ndarray: The product matrix resulting from multiplying matrix_a with matrix_b. # Check if the number of columns in matrix_a matches the number of rows in matrix_b if matrix_a.shape[1] != matrix_b.shape[0]: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Use numpy\'s dot product function to multiply the matrices return np.dot(matrix_a, matrix_b)"},{"question":"# Data Processing Pipeline Challenge You are given a data processing pipeline that transforms raw sales data into insightful metrics for a retail company. The last step of the pipeline needs enhancement to calculate the gross profit and add it to the final dataset. **Task**: Extend the `calculate_metrics` function to compute the gross profit for each record. Gross profit is defined as the difference between `revenue` and `cost_of_goods_sold`. # Function Signature ```python def calculate_metrics(sales_data: list) -> list: Enhance the pipeline to calculate the gross profit for each sales record. Args: sales_data (list): A list of dictionaries, each containing: - \\"item\\": The item sold. - \\"revenue\\": Revenue from the sale. - \\"cost_of_goods_sold\\": Cost of goods sold. - \\"date\\": Date of the sale. Returns: list: A list of dictionaries, each containing all the original fields, plus: - \\"gross_profit\\": Gross profit from the sale. ``` # Requirements 1. **Input**: - `sales_data` (list): A list of sales dictionaries, where each dictionary has keys `item`, `revenue`, `cost_of_goods_sold`, and `date`. 2. **Output**: - A list of sales dictionaries, augmented with a new key `gross_profit`, representing the gross profit for each sale. # Instructions 1. Calculate `gross_profit` for each record as `revenue - cost_of_goods_sold`. 2. Ensure all input fields are present in the output records. 3. Handle and log any inconsistencies or missing data gracefully. 4. Return the enriched list of sales data. 5. Optimize for performance, ensuring that the additional calculations do not significantly impact overall runtime. # Constraints - The input list may have up to 100,000 records. - Each record is guaranteed to have non-negative `revenue` and `cost_of_goods_sold`. # Performance - Aim for an O(n) time complexity where n is the number of sales records. - Minimize the memory overhead by avoiding the creation of unnecessary intermediate data structures. # Example ```python >>> sales_data = [ {\\"item\\": \\"laptop\\", \\"revenue\\": 1200, \\"cost_of_goods_sold\\": 800, \\"date\\": \\"2023-01-01\\"}, {\\"item\\": \\"smartphone\\", \\"revenue\\": 800, \\"cost_of_goods_sold\\": 300, \\"date\\": \\"2023-01-02\\"} ] >>> calculate_metrics(sales_data) [ {\\"item\\": \\"laptop\\", \\"revenue\\": 1200, \\"cost_of_goods_sold\\": 800, \\"date\\": \\"2023-01-01\\", \\"gross_profit\\": 400}, {\\"item\\": \\"smartphone\\", \\"revenue\\": 800, \\"cost_of_goods_sold\\": 300, \\"date\\": \\"2023-01-02\\", \\"gross_profit\\": 500} ] ``` Ensure your solution is robust and can handle real-world data nuances.","solution":"def calculate_metrics(sales_data): Enhance the pipeline to calculate the gross profit for each sales record. Args: sales_data (list): A list of dictionaries, each containing: - \\"item\\": The item sold. - \\"revenue\\": Revenue from the sale. - \\"cost_of_goods_sold\\": Cost of goods sold. - \\"date\\": Date of the sale. Returns: list: A list of dictionaries, each containing all the original fields, plus: - \\"gross_profit\\": Gross profit from the sale. for record in sales_data: record[\'gross_profit\'] = record[\'revenue\'] - record[\'cost_of_goods_sold\'] return sales_data"},{"question":"# String Parsing: Valid Parentheses Sequence Context: You are building a simple parser to validate sequences of parentheses. This functionality is important in ensuring that expressions have properly matched and nested parentheses, which is a common requirement in many programming languages and mathematical expressions. Objective: Write a function `is_valid_parentheses(sequence: str) -> bool` that determines if a given sequence of parentheses is valid. Guidelines: 1. **Input**: - A string `sequence` containing only the characters `(` and `)`. 2. **Output**: - A boolean value: `True` if the sequence is valid, `False` otherwise. 3. **Constraints**: - A valid sequence means every opening parenthesis `(` has a corresponding closing parenthesis `)` and they are correctly nested. - Assume the input sequence is non-empty. 4. **Performance**: - Aim for O(n) time complexity where n is the length of the `sequence`. Implementation: Use a stack-based approach to ensure that parentheses are correctly matched and nested. Thoroughly test your function with various edge cases and typical use cases to ensure correctness. Examples: ```python assert is_valid_parentheses(\\"()\\") == True assert is_valid_parentheses(\\"()()\\") == True assert is_valid_parentheses(\\"(())\\") == True assert is_valid_parentheses(\\"(()\\") == False assert is_valid_parentheses(\\")(\\") == False assert is_valid_parentheses(\\"(()))(\\") == False ``` --- This question asks to verify the validity of a parentheses sequence, ensuring it maintains a consistent style, length, complexity, and topic alignment with the original problem. The primary skill tested here is a basic understanding of stack operations, which is a common theme in coding assessments.","solution":"def is_valid_parentheses(sequence: str) -> bool: Determines if a given sequence of parentheses is valid. A sequence of parentheses is valid if every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested. Args: sequence (str): A string containing only \')\' and \'(\' characters. Returns: bool: True if the sequence is valid, False otherwise. stack = [] for char in sequence: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() return len(stack) == 0"},{"question":"Given the following matrix and a set of operations that can be performed on it: ```python import numpy as np class MatrixOperations: def __init__(self, matrix: np.ndarray): self.matrix = matrix def add_row(self, row: np.ndarray) -> None: Adds a row to the bottom of the matrix. if self.matrix.shape[1] != row.shape[0]: raise ValueError(\\"Row length must match the number of columns in the matrix.\\") self.matrix = np.vstack([self.matrix, row]) def add_column(self, col: np.ndarray) -> None: Adds a column to the right of the matrix. if self.matrix.shape[0] != col.shape[0]: raise ValueError(\\"Column length must match the number of rows in the matrix.\\") self.matrix = np.hstack([self.matrix, col.reshape(-1, 1)]) def remove_row(self, index: int) -> None: Removes a row by index. if index < 0 or index >= self.matrix.shape[0]: raise ValueError(\\"Row index out of bounds.\\") self.matrix = np.delete(self.matrix, index, axis=0) def transpose_matrix(self) -> np.ndarray: Returns the transposed version of the matrix. return self.matrix.T ``` # Task Implement the following functions to perform additional operations on the matrix: - `remove_column(self, index: int) -> None` - `multiply_by_scalar(self, scalar: float) -> None` **Input**: - `index`: An integer representing the index of the column to be removed. - `scalar`: A float representing the scalar by which the matrix will be multiplied. **Output**: - `remove_column`: Modifies `self.matrix` by removing the specified column. - `multiply_by_scalar`: Modifies `self.matrix` by multiplying all elements by the given scalar. **Constraints**: - Assume the matrix is a NumPy 2D array. - The `index` should be a valid column index; otherwise, raise a ValueError. - Multiplying by a scalar should affect all elements of the matrix. # Example ```python initial_matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) matrix_ops = MatrixOperations(initial_matrix) matrix_ops.remove_column(1) print(matrix_ops.matrix) # Output: [[1, 3], [4, 6], [7, 9]] matrix_ops.multiply_by_scalar(2) print(matrix_ops.matrix) # Output: [[2, 6], [8, 12], [14, 18]] matrix_ops.add_row(np.array([10, 11])) print(matrix_ops.matrix) # Output: [[2, 6], [8, 12], [14, 18], [10, 11]] matrix_ops.add_column(np.array([20, 21, 22, 23])) print(matrix_ops.matrix) # Output: [[2, 6, 20], [8, 12, 21], [14, 18, 22], [10, 11, 23]] ``` Implement the `remove_column` and `multiply_by_scalar` methods to complete the matrix operations as specified.","solution":"import numpy as np class MatrixOperations: def __init__(self, matrix: np.ndarray): self.matrix = matrix def add_row(self, row: np.ndarray) -> None: Adds a row to the bottom of the matrix. if self.matrix.shape[1] != row.shape[0]: raise ValueError(\\"Row length must match the number of columns in the matrix.\\") self.matrix = np.vstack([self.matrix, row]) def add_column(self, col: np.ndarray) -> None: Adds a column to the right of the matrix. if self.matrix.shape[0] != col.shape[0]: raise ValueError(\\"Column length must match the number of rows in the matrix.\\") self.matrix = np.hstack([self.matrix, col.reshape(-1, 1)]) def remove_row(self, index: int) -> None: Removes a row by index. if index < 0 or index >= self.matrix.shape[0]: raise ValueError(\\"Row index out of bounds.\\") self.matrix = np.delete(self.matrix, index, axis=0) def transpose_matrix(self) -> np.ndarray: Returns the transposed version of the matrix. return self.matrix.T def remove_column(self, index: int) -> None: Removes a column by index. if index < 0 or index >= self.matrix.shape[1]: raise ValueError(\\"Column index out of bounds.\\") self.matrix = np.delete(self.matrix, index, axis=1) def multiply_by_scalar(self, scalar: float) -> None: Multiplies all elements of the matrix by a scalar. self.matrix = self.matrix * scalar"},{"question":"# Scenario You are tasked with creating a command-line utility to compress and decompress files using the gzip format. The utility should be able to handle both compression and decompression based on user input. # Task Write a Python function `gzip_utility` that takes two parameters: 1. `operation`: A string that is either `\\"compress\\"` or `\\"decompress\\"`. 2. `filename`: The name of the input file to compress or decompress. The function should: 1. If the `operation` is `\\"compress\\"`, compress the specified file using gzip and create a new file with the same name appended with `.gz`. 2. If the `operation` is `\\"decompress\\"`, decompress the specified `.gz` file and create a new file without the `.gz` extension. # Input * `operation`: A string that is either `\\"compress\\"` or `\\"decompress\\"`. * `filename`: A string representing the name of the file to compress or decompress. # Output None. The function should create the compressed or decompressed file on the disk. # Constraints * The input file for compression must exist and be a regular file. * The input file for decompression must exist and have a `.gz` extension. * Handle exceptions such as file not found, permission denied, and invalid operations gracefully. * The function should ensure the creation of the output file without overwriting existing files with the same name. # Example ```python import gzip import shutil def gzip_utility(operation: str, filename: str): if operation == \\"compress\\": with open(filename, \'rb\') as f_in: with gzip.open(filename + \'.gz\', \'wb\') as f_out: shutil.copyfileobj(f_in, f_out) elif operation == \\"decompress\\": if filename.endswith(\'.gz\'): with gzip.open(filename, \'rb\') as f_in: with open(filename[:-3], \'wb\') as f_out: shutil.copyfileobj(f_in, f_out) else: print(\\"Invalid operation. Use \'compress\' or \'decompress\'.\\") # Example of usage: # Compress a file named \\"example.txt\\" gzip_utility(\'compress\', \'example.txt\') # Decompress a file named \\"example.txt.gz\\" gzip_utility(\'decompress\', \'example.txt.gz\') ``` The function should reliably compress or decompress the files as specified.","solution":"import gzip import shutil import os def gzip_utility(operation: str, filename: str): Compresses or decompresses files using the gzip format based on the specified operation. Parameters: operation (str): The operation to perform (\'compress\' or \'decompress\'). filename (str): The name of the file to compress or decompress. Returns: None. The function creates the compressed or decompressed file on the disk. try: if operation == \\"compress\\": if not os.path.isfile(filename): raise FileNotFoundError(f\\"The file \'{filename}\' does not exist or is not a regular file.\\") with open(filename, \'rb\') as f_in: with gzip.open(filename + \'.gz\', \'wb\') as f_out: shutil.copyfileobj(f_in, f_out) elif operation == \\"decompress\\": if not filename.endswith(\'.gz\'): raise ValueError(\\"The file to decompress must have a \'.gz\' extension.\\") with gzip.open(filename, \'rb\') as f_in: with open(filename[:-3], \'wb\') as f_out: shutil.copyfileobj(f_in, f_out) else: raise ValueError(\\"Invalid operation. Use \'compress\' or \'decompress\'.\\") except FileNotFoundError as fnf_error: print(fnf_error) except PermissionError as perm_error: print(perm_error) except Exception as error: print(f\\"An error occurred: {error}\\")"},{"question":"# Context You are working with a binary search tree (BST) implementation in Python. Your task is to enhance the functionality of this BST. One important aspect of binary search trees is their balance, which ensures that operations like insertion, deletion, and search are efficient. # Task Implement a function `find_lowest_common_ancestor(self, node1: int, node2: int) -> Optional[int]` within the `BST` class that finds the lowest common ancestor (LCA) of two given nodes in the BST. The LCA of two nodes in a BST is defined as the lowest node that has both nodes as descendants. # Function Signature ```python class BST: def find_lowest_common_ancestor(self, node1: int, node2: int) -> Optional[int]: # Your code here ``` # Input * Two integers `node1` and `node2` representing the values of two nodes in the BST that are guaranteed to exist. # Output * The function returns an integer representing the value of the lowest common ancestor or `None` if the ancestor is not found. # Constraints * The values of the nodes (val) in the BST are unique. * The BST comprises at least two nodes. * The value of the nodes are in the range [1, 1000]. # Example ```python >>> bst = BST([20, 10, 30, 5, 15, 25, 35]) >>> bst.find_lowest_common_ancestor(5, 15) 10 >>> bst = BST([20, 10, 30, 5, 15, 25, 35]) >>> bst.find_lowest_common_ancestor(5, 35) 20 >>> bst = BST([20, 10, 30, 5, 15, 25, 35]) >>> bst.find_lowest_common_ancestor(25, 35) 30 ``` # Notes * You can assume that both nodes are present in the BST. * The function should handle cases where the nodes are direct descendants of the LCA or situated deeper in the tree.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self, values): self.root = None for value in values: self.insert(value) def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def find_lowest_common_ancestor(self, node1, node2): return self._find_lca(self.root, node1, node2) def _find_lca(self, node, node1, node2): if not node: return None if node1 < node.val and node2 < node.val: return self._find_lca(node.left, node1, node2) if node1 > node.val and node2 > node.val: return self._find_lca(node.right, node1, node2) return node.val"},{"question":"# Coding Question Context You\'re developing a banking application that needs to process numerous financial transactions daily. The transactions involve various account operations, such as deposits, withdrawals, and transfers. Your task is to implement a feature that ensures all transactions are processed efficiently and correctly, maintaining the integrity of the account balances. Task Write a function `process_transactions` that takes a list of transactions and updates the account balances accordingly. Each transaction must be applied sequentially, handling any potential issues like insufficient funds gracefully. Function Signature ```python def process_transactions(transactions: List[Dict[str, Any]], accounts: Dict[str, float]) -> None: pass ``` Requirements 1. **Input**: * `transactions` (List[Dict[str, Any]]): A list of transactions where each transaction is represented as a dictionary with the following keys: - `\\"type\\"` (str): The type of the transaction, which can be \\"deposit\\", \\"withdrawal\\", or \\"transfer\\". - `\\"account\\"` (str): The account ID to which the transaction applies for deposits and withdrawals. - `\\"amount\\"` (float): The amount of money to be deposited or withdrawn. - For transfers, the dictionary also includes: - `\\"to_account\\"` (str): The account ID to which money is being transferred. * `accounts` (Dict[str, float]): A dictionary with account IDs as keys and their corresponding balances as values. 2. **Output**: None 3. **Constraints**: * Ensure account balances are never negative after any transaction. * Log an appropriate message if a transaction fails due to insufficient funds. * Handle potential edge cases, such as missing accounts or invalid transaction types. * Maintain data integrity and ensure that all transactions are processed atomically. 4. **Performance**: * Aim for linear time complexity relative to the number of transactions. * Ensure the solution is scalable for a large number of concurrent transactions. Example: ```python if __name__ == \\"__main__\\": transactions = [ {\\"type\\": \\"deposit\\", \\"account\\": \\"A1\\", \\"amount\\": 100.0}, {\\"type\\": \\"withdrawal\\", \\"account\\": \\"A1\\", \\"amount\\": 50.0}, {\\"type\\": \\"transfer\\", \\"account\\": \\"A1\\", \\"to_account\\": \\"A2\\", \\"amount\\": 30.0}, ] accounts = {\\"A1\\": 100.0, \\"A2\\": 50.0} process_transactions(transactions, accounts) print(accounts) # Expected output: {\\"A1\\": 20.0, \\"A2\\": 80.0} ``` Notes: * Ensure logging or printing of transaction status for debugging and tracking purposes. * Design the function to be extensible for additional transaction types in the future. * Write clean and maintainable code with adequate comments.","solution":"from typing import List, Dict, Any def process_transactions(transactions: List[Dict[str, Any]], accounts: Dict[str, float]) -> None: Processes the list of transactions and updates the account balances accordingly. Parameters: transactions (List[Dict[str, Any]]): A list of transactions. accounts (Dict[str, float]): A dictionary of account balances. for transaction in transactions: t_type = transaction[\'type\'] account = transaction.get(\'account\') amount = transaction[\'amount\'] if t_type == \'deposit\': accounts[account] = accounts.get(account, 0) + amount elif t_type == \'withdrawal\': if accounts.get(account, 0) >= amount: accounts[account] -= amount else: print(f\\"Insufficient funds for withdrawal from account {account}\\") elif t_type == \'transfer\': to_account = transaction[\'to_account\'] if accounts.get(account, 0) >= amount: accounts[account] -= amount accounts[to_account] = accounts.get(to_account, 0) + amount else: print(f\\"Insufficient funds for transfer from account {account} to {to_account}\\") else: print(f\\"Invalid transaction type: {t_type}\\")"},{"question":"# Question: (Minimum Path Sum in a Grid) Implement a function that, given a 2D grid of integers where each cell represents a cost, returns the minimum path sum from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. **Function Signature:** ```python def min_path_sum(grid: List[List[int]]) -> int: ``` **Input:** * A 2D list of integers `grid` where each element is a positive integer and the dimensions of the grid (m x n) satisfy (1 ≤ m, n ≤ 100). **Output:** * An integer representing the minimum path sum from the top-left to the bottom-right corner of the grid. **Example:** ```python >>> grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] >>> min_path_sum(grid) 7 ``` **Constraints:** * The value of each cell in the grid is a positive integer. * The input grid will always have at least one row and one column. **Guidelines:** * Use a dynamic programming approach to solve the problem efficiently. * Ensure you handle edge cases such as grids with only one row or one column. * Your solution should run efficiently within the given constraints, particularly for larger grids. **Scenario:** You are developing a route optimization feature for a navigation software. You need to ensure the software can find the least costly path through a grid-based map, where each cell represents a toll cost. Providing users with the minimum toll cost path from their starting point to their destination is crucial for improving the software\'s usability and efficiency.","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid of integers where each cell represents a cost. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first cell with its own value for i in range(m): for j in range(n): if i == 0 and j == 0: continue # skip the starting cell elif i == 0: # first row, can only come from the left grid[i][j] += grid[i][j-1] elif j == 0: # first column, can only come from above grid[i][j] += grid[i-1][j] else: # normal cell, take the min value from top or left grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"# Problem: Minimal Path Sum in a Grid Given a 2D grid of integers where each cell represents the cost to enter that cell, implement a function to find the minimal path sum from the top-left corner to the bottom-right corner by only moving right or down. **Input Format** - The first input line contains two integers ( m ) and ( n ) (1 ≤ m, n ≤ 200), representing the number of rows and columns in the grid. - The next ( m ) lines each contain ( n ) integers ( grid[i][j] ) (0 ≤ grid[i][j] ≤ 1000), representing the cost grid. **Output Format** - Return the minimal path sum from the top-left corner to the bottom-right corner. **Constraints** - You may only move right or down at any point in time. - The function should handle up to 200 rows and 200 columns efficiently given the constraints. **Example** *Input:* ``` 3 3 1 3 1 1 5 1 4 2 1 ``` *Output:* ``` 7 ``` **Detailed Requirements** 1. Use dynamic programming to achieve an efficient solution to this problem. 2. Initialize a 2D array `dp` where `dp[i][j]` represents the minimal path sum to reach cell ( (i, j) ). 3. Fill the `dp` array by iterating through the grid and calculating the minimal path sum for each cell based on the minimal path sums of the previous cells (top and left). 4. Return the value in `dp[m-1][n-1]` as it represents the minimal path sum to reach the bottom-right corner of the grid.","solution":"def minimal_path_sum(grid): Returns the minimal path sum from top-left to bottom-right in a grid. :param grid: List[List[int]] where each element represents the cost to enter the cell. :return: int minimal path sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the top-left cell with the value from the grid dp[0][0] = grid[0][0] # Initialize the first row, only way to reach a cell is from left for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column, only way to reach a cell is from above for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"# Problem Statement You are given a 2D grid of integers, where each integer represents the height of that cell. The Pacific Ocean touches the left and top edges of the grid, and the Atlantic Ocean touches the right and bottom edges. Consider if water can flow from one cell to another if and only if the height of the next cell is equal to or lower. Water can flow from cell (r, c) to cell (r+1, c), (r-1, c), (r, c+1), or (r, c-1) if the next cell’s height is equal or lower. Your task is to find all cells where water can flow to both the Pacific and Atlantic Oceans. # Input * A 2D grid of integers `heights` where `heights[r][c]` represents the height at row r and column c. * For example: ```python heights = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] ``` # Output * A list of lists, where each inner list represents the coordinates `[r, c]` of cells that can flow to both oceans. Coordinates can be in any order. * For example: ```python [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` # Constraints * The grid\'s dimensions are `m x n` where `1 <= m, n <= 200`. * The height of each cell is between `1` and `10,000`. # Function Signature ```python def pacific_atlantic(heights: list[list[int]]) -> list[list[int]]: ``` # Example Given the input `heights`: ```python heights = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] ``` The output should be: ```python [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` # Notes * Ensure to explore cells in any valid path where water can flow from the current cell to either the left, top or right, bottom edges for Pacific and Atlantic respectively. * Avoid unnecessary re-computation by keeping track of visited cells for both oceans. * Aim for an efficient solution that minimizes redundancy in exploration.","solution":"def pacific_atlantic(heights): if not heights or not heights[0]: return [] rows, cols = len(heights), len(heights[0]) pacific_reachable = set() atlantic_reachable = set() def dfs(r, c, reachable_set, prev_height): if ((r, c) in reachable_set or r < 0 or c < 0 or r >= rows or c >= cols or heights[r][c] < prev_height): return reachable_set.add((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, reachable_set, heights[r][c]) for col in range(cols): dfs(0, col, pacific_reachable, heights[0][col]) dfs(rows - 1, col, atlantic_reachable, heights[rows - 1][col]) for row in range(rows): dfs(row, 0, pacific_reachable, heights[row][0]) dfs(row, cols - 1, atlantic_reachable, heights[row][cols - 1]) return [[r, c] for r, c in pacific_reachable & atlantic_reachable]"},{"question":"# Problem Statement You are given a list of integers. Your task is to compute whether there exists a contiguous subarray (of at least length one) which sums to zero. If such a subarray exists, return `True`. Otherwise, return `False`. Input - A single list `arr` consisting of `n` integers (-10^5 ≤ arr[i] ≤ 10^5). The length of the list can be up to 10^5. Output - Return a boolean value `True` if there exists a contiguous subarray which sums to zero, otherwise, return `False`. Example ```python >>> has_zero_sum_subarray([3, 4, -7, 1, 2, -6]) True >>> has_zero_sum_subarray([1, 2, 3, -3]) True >>> has_zero_sum_subarray([1, 2, 3, 4, 5]) False ``` Constraints - The array can contain both positive and negative integers. - The length of the array `n` will not exceed 10^5. Requirements - The implementation should run in linear time O(n). Additional Notes To solve this problem, use a hash set to keep track of the cumulative sums as you iterate through the array. If at any point, the cumulative sum is zero or it has been seen before in the hash set, a zero-sum subarray exists.","solution":"def has_zero_sum_subarray(arr): Returns True if there exists a contiguous subarray which sums to zero, otherwise False. seen_sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in seen_sums: return True seen_sums.add(current_sum) return False"},{"question":"# Coding Question: Maximum Length of Subarray with Sum Equals k You are given an array of integers and an integer `k`. Your task is to find the maximum length of a subarray that sums up to `k`. Implement the function `max_subarray_length(nums: list[int], k: int) -> int` which returns the maximum length of such a subarray. If there’s no subarray with sum equal to `k`, return `0`. Input - `nums`: A list of integers, where `0 <= len(nums) <= 10^5` and `-10^5 <= nums[i] <= 10^5`. - `k`: An integer, `-10^5 <= k <= 10^5`. Output - Return an integer representing the maximum length of a subarray that sums to `k`. If no such subarray exists, return `0`. Constraints - Consider edge cases such as: empty arrays, arrays with all positive or all negative elements, and arrays where the sum cannot reach `k`. Examples ```python >>> max_subarray_length([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_length([-2, -1, 2, 1], 1) 2 >>> max_subarray_length([1, 2, 3, 4, 5], 15) 5 >>> max_subarray_length([1, 2, 3, 4, 5], 16) 0 >>> max_subarray_length([], 1) 0 >>> max_subarray_length([1, 2, 3, 4, 5], -1) 0 ``` Performance Considerations The function should be efficient with a linear runtime complexity of O(n), where n is the length of the input array. Ensure that the solution can handle large inputs gracefully. Detailed Explanation: 1. Initialize a dictionary to store the cumulative sum at each index. 2. Traverse through the array, maintaining the cumulative sum. 3. For each cumulative sum, check if the difference between the cumulative sum and `k` has been seen before to determine the length of a subarray that sums to `k`. 4. Update the dictionary with the current cumulative sum and its index if it\'s not already present. 5. Return the maximum length found. This approach ensures that the function can efficiently find the maximum length of a subarray summing to `k` using a single pass through the array, leveraging a hash map for quick lookups.","solution":"def max_subarray_length(nums, k): Finds the maximum length of a subarray that sums to k. # Dictionary to store the first occurrence of a particular cumulative sum sum_indices = {0: -1} curr_sum = 0 max_length = 0 for i, num in enumerate(nums): curr_sum += num if curr_sum - k in sum_indices: max_length = max(max_length, i - sum_indices[curr_sum - k]) if curr_sum not in sum_indices: sum_indices[curr_sum] = i return max_length"},{"question":"Problem Statement You are required to write a function that determines the number of valid parentheses combinations that can be generated using `n` pairs of parentheses. # Function Signature: ```python def count_valid_parentheses_combinations(n: int) -> int: ``` # Input * `n` - An integer with the constraint 1 ≤ n ≤ 15. # Output * Return the number of unique and valid combinations of `n` pairs of parentheses. # Example ```python >>> count_valid_parentheses_combinations(3) 5 >>> count_valid_parentheses_combinations(4) 14 ``` # Explanation For `n = 3`, the valid combinations are: 1. \\"((()))\\" 2. \\"(()())\\" 3. \\"(())()\\" 4. \\"()(())\\" 5. \\"()()()\\" For `n = 4`, the valid combinations are: 1. \\"(((())))\\" 2. \\"((()()))\\" 3. \\"((())())\\" 4. \\"((()))()\\" 5. \\"(()(()))\\" 6. \\"(()()())\\" 7. \\"(()())()\\" 8. \\"(())(())\\" 9. \\"(())()()\\" 10. \\"()((()))\\" 11. \\"()(()())\\" 12. \\"()(())()\\" 13. \\"()()(())\\" 14. \\"()()()()\\" # Constraints 1. Ensure that the function efficiently computes the result for all integers in the given range. 2. Focus on generating only valid combinations where every opening parenthesis has a corresponding closing parenthesis.","solution":"def count_valid_parentheses_combinations(n: int) -> int: Function to determine the number of valid parentheses combinations using n pairs of parentheses. This is determined by calculating the nth Catalan number. :param n: an integer representing the number of pairs of parentheses. :return: number of unique and valid combinations of n pairs of parentheses. # The nth Catalan number can be calculated using the formula: # C(n) = (2n)! / ((n + 1)! * n!) # Importing factorial function from math module from math import factorial # Function to calculate nth Catalan number def catalan_number(n): return factorial(2 * n) // (factorial(n + 1) * factorial(n)) # Return the nth Catalan number return catalan_number(n)"},{"question":"# Problem Statement You are given a `m x n` grid named `grid`, where each cell in the grid can have one of three values: - `0` represents an empty cell, - `1` represents a fresh orange, - `2` represents a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Your task is to determine the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`. Function Signature ```python from typing import List def orangesRotting(grid: List[List[int]]) -> int: pass ``` Input * `grid` (List[List[int]]): The `m x n` dimensional grid containing the cells. Output * Returns an integer which is the minimum number of minutes that must elapse until no cell has a fresh orange, or `-1` if it is impossible. Constraints * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 10` * `grid[i][j]` is `0`, `1`, or `2`. Example ```python # Example 1 grid = [ [2, 1, 1], [1, 1, 0], [0, 1, 1] ] assert orangesRotting(grid) == 4 # Example 2 grid = [ [2, 1, 1], [0, 1, 1], [1, 0, 1] ] assert orangesRotting(grid) == -1 # Example 3 grid = [ [0, 2] ] assert orangesRotting(grid) == 0 ``` Notes * Handle grid edge cases such as when there\'s only one cell. * Ensure to check the entire grid to see if all fresh oranges can be eventually rotten. * The process stops when there are no more fresh oranges to rot or no further rotten spreads.","solution":"from typing import List from collections import deque def orangesRotting(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) queue = deque() fresh_count = 0 # Initialize the queue with all the rotten oranges and count fresh ones for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) elif grid[r][c] == 1: fresh_count += 1 if fresh_count == 0: return 0 minute_passed = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c, minute_passed = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 2 fresh_count -= 1 queue.append((nr, nc, minute_passed + 1)) return minute_passed if fresh_count == 0 else -1"},{"question":"# Fast Fourier Transform for Audio Signal Processing Context Signal processing is a common task in many applications, including audio analysis. The Fast Fourier Transform (FFT) is an efficient algorithm to compute the Discrete Fourier Transform (DFT) and its inverse. FFT is widely used for various tasks such as filtering, spectral analysis, and convolution. Task You are required to implement a function `compute_fft` that performs FFT on a given one-dimensional audio signal and its inverse. Specifically, the function should compute the FFT of the input signal, manipulate its frequency components, and then compute the inverse FFT to transform it back to the time domain. Your task is to write a function `compute_fft` that takes the following inputs: 1. `audio_signal`: One-dimensional NumPy array representing the audio signal. 2. `frequency_cutoff`: Frequency above which (in Hz) the signal components should be attenuated. 3. `sampling_rate`: Sampling rate of the audio signal (in Hz). The function should return a one-dimensional NumPy array of the same length as `audio_signal`, representing the processed audio signal. Input - `audio_signal`: 1D NumPy array of shape `(n,)` representing the audio signal. - `frequency_cutoff`: Float value representing the cutoff frequency in Hz. - `sampling_rate`: Integer representing the sampling rate of the audio signal in Hz. Output - 1D NumPy array of shape `(n,)` representing the processed audio signal in the time domain after applying FFT and inverse FFT. Constraints - The length of `audio_signal` is a power of 2. - `frequency_cutoff` is a positive float value. - `sampling_rate` is a positive integer. Performance Requirements - The function should efficiently handle audio signals of length up to `2^14` (16384 samples) within a reasonable time frame (~3 seconds). # Example ```python import numpy as np from scipy.fft import fft, ifft def compute_fft(audio_signal: np.ndarray, frequency_cutoff: float, sampling_rate: int) -> np.ndarray: # Compute FFT of the input signal transformed_signal = fft(audio_signal) n = len(audio_signal) freqs = np.fft.fftfreq(n, 1 / sampling_rate) # Zero out frequency components above the cutoff transformed_signal[np.abs(freqs) > frequency_cutoff] = 0 # Compute the inverse FFT to get the filtered audio signal back in time domain filtered_signal = ifft(transformed_signal) # Return the real part of the inverse FFT result return np.real(filtered_signal) # Example usage: audio_signal = np.array([0, 1, 0, -1, 0, 1, 0, -1], dtype=np.float32) frequency_cutoff = 1.0 sampling_rate = 4 processed_audio = compute_fft(audio_signal, frequency_cutoff, sampling_rate) print(np.round(processed_audio, 2)) ``` This question will allow candidates to demonstrate their understanding of both signal processing and algorithm implementation, specifically the efficient use of FFT.","solution":"import numpy as np from scipy.fft import fft, ifft def compute_fft(audio_signal: np.ndarray, frequency_cutoff: float, sampling_rate: int) -> np.ndarray: Compute FFT, filter frequency components above frequency_cutoff, and return inverse FFT. Parameters: audio_signal (np.ndarray): Input 1D audio signal. frequency_cutoff (float): Frequency cutoff in Hz. sampling_rate (int): Sampling rate in Hz. Returns: np.ndarray: Processed 1D audio signal. # Compute FFT of the input signal transformed_signal = fft(audio_signal) n = len(audio_signal) freqs = np.fft.fftfreq(n, 1 / sampling_rate) # Zero out frequency components above the cutoff transformed_signal[np.abs(freqs) > frequency_cutoff] = 0 # Compute the inverse FFT to get the filtered audio signal back in time domain filtered_signal = ifft(transformed_signal) # Return the real part of the inverse FFT result return np.real(filtered_signal)"},{"question":"# Question You are given a `k x n` matrix `mat` and an integer `col_idx`. Your task is to implement the function `remove_column` to delete the column at index `col_idx` from the matrix `mat`. # Constraints 1. The `col_idx` must be a valid index within the column range of `mat`. 2. The matrix `mat` can have any number of rows but must have at least one column. # Function Signature ```python def remove_column(mat: np.ndarray, col_idx: int) -> np.ndarray: ... ``` # Input Format - `mat`: A 2D numpy array of shape (k, n) - `col_idx`: An integer representing the index of the column to be removed # Output Format - A 2D numpy array with the specified column removed. # Example ```python import numpy as np matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) output = remove_column(matrix, 1) print(output) # Expected: # array([[1, 3], # [4, 6], # [7, 9]]) ``` # Additional Requirements: 1. Raise a `ValueError` if the `col_idx` is not a valid column index in `mat`. 2. Retain the original order of the remaining columns.","solution":"import numpy as np def remove_column(mat: np.ndarray, col_idx: int) -> np.ndarray: Remove the column at index col_idx from the matrix mat. Parameters: mat (np.ndarray): A 2D numpy array of shape (k, n). col_idx (int): An integer representing the index of the column to be removed. Returns: np.ndarray: A 2D numpy array with the specified column removed. Raises: ValueError: If the col_idx is not a valid column index in mat. if col_idx < 0 or col_idx >= mat.shape[1]: raise ValueError(\\"Invalid column index\\") return np.delete(mat, col_idx, axis=1)"},{"question":"# Problem Statement You are tasked with developing a feature for a text processing application that requires counting the frequency of each word in a given document. The document is represented as a single string containing words separated by spaces. For simplicity, assume that words are case-insensitive and the string contains only alphabetic characters and spaces. Your goal is to implement a function `word_count` that takes a string and returns a dictionary where the keys are unique words (in lowercase) from the input string, and the values are their corresponding frequencies. # Requirements 1. Implement the `word_count(document: str) -> dict[str, int]` function. 2. Ensure the function is efficient and can handle large input strings. 3. The words in the output dictionary should be in lowercase. # Input Format * A string `document` containing words separated by spaces. # Output Format * A dictionary where the keys are lowercase words and the values are their frequencies. # Constraints * The input string `document` will have a length up to 1,000,000 characters. * The words are composed of alphabetic characters only. # Example ```python # Input document = \\"Hello world this is a test This is only a test\\" # Output output_dict = { \\"hello\\": 1, \\"world\\": 1, \\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 2, \\"only\\": 1 } ``` Implement the function `word_count` that meets the above requirements.","solution":"def word_count(document: str) -> dict: Takes a document string and returns a dictionary where the keys are unique words (in lowercase) from the input string, and the values are their corresponding frequencies. # Split the document into words words = document.lower().split() # Count the frequency of each word word_freq = {} for word in words: if word in word_freq: word_freq[word] += 1 else: word_freq[word] = 1 return word_freq"},{"question":"# Programming Language Syntax Validator You are tasked with creating a function to validate a given string of programming language syntax. The string can contain parentheses (`()`) and braces (`{}`). The function should determine if the input string has correctly nested and closed parentheses and braces. Function Signature ```python def validate_syntax(syntax: str) -> bool: Validate if the input syntax has correctly nested and closed parentheses and braces. :param syntax: String containing the syntax with parentheses and braces :return: Boolean value True if syntax is valid, False otherwise. ``` Input - `syntax (str)`: A string containing only the characters `(`, `)`, `{`, `}`, possibly mixed with any other characters. Output - `bool`: `True` if the input string has correctly nested and closed parentheses and braces, `False` otherwise. Constraints 1. The string\'s length can be up to 1000 characters. 2. Consider only `(`, `)`, `{`, `}` for validation; ignore all other characters. Performance - The function should run efficiently, ideally with a time complexity of O(n), where n is the length of the input string. Example ```python >>> validate_syntax(\\"(a + b) * {c / d}\\") True >>> validate_syntax(\\"((a + b) * {c / d}\\") False >>> validate_syntax(\\"a + b) * {c / d}\\") False >>> validate_syntax(\\"({a + b} * {c / d})\\") True >>> validate_syntax(\\"({a + b} * {c / [d}])\\") False ``` Additional Notes - Ensure to test for various edge cases such as empty strings, strings with no parentheses or braces, and strings with nested parentheses and braces. - Focus on validating the nested structure rather than the correctness of the expression itself.","solution":"def validate_syntax(syntax: str) -> bool: Validate if the input syntax has correctly nested and closed parentheses and braces. :param syntax: String containing the syntax with parentheses and braces :return: Boolean value True if syntax is valid, False otherwise. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\'} for char in syntax: if char in \\"({\\": stack.append(char) elif char in \\")}\\": if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"# Problem Statement: You are provided with a binary tree class and its in-order traversal method. You are required to extend the binary tree class with the following functionalities: 1. **find_height()**: Implement a method to find the height of the binary tree. The height of a binary tree is the number of edges in the longest path from the root to a leaf node. 2. **zigzag_traversal()**: Implement a method that returns a list of node values in zigzag level order traversal of the binary tree. Zigzag level order traversal is a breadth-first traversal where the nodes at each level are alternatively traversed from left to right and from right to left. # Expected Input and Output Formats: * For `find_height()`: * **Input**: No input parameters. * **Output**: Returns an integer representing the height of the binary tree. * For `zigzag_traversal()`: * **Input**: No input parameters. * **Output**: Returns a list of integers representing the node values in zigzag level order. # Constraints: 1. Assume the binary tree does not contain duplicate values. 2. The number of nodes in the tree can be up to `N = 10^4`. # Example: ```python bt = BinaryTree() bt.insert(10) bt.insert(5) bt.insert(15) bt.insert(3) bt.insert(7) bt.insert(13) bt.insert(18) print(bt.find_height()) # 2 (height of the tree) print(bt.zigzag_traversal()) # [10, 15, 5, 3, 7, 13, 18] ``` # Solution Template: You may start with the provided code snippet and extend the class as described in the task. ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def in_order_traversal(self): return self._in_order_traversal(self.root, []) def _in_order_traversal(self, root, result): if root: self._in_order_traversal(root.left, result) result.append(root.val) self._in_order_traversal(root.right, result) return result def find_height(self): # Implement the method to find the height of the binary tree pass def zigzag_traversal(self): # Implement the method to return zigzag level order traversal pass ``` ```python # You can run your tests here bt = BinaryTree() bt.insert(10) bt.insert(5) bt.insert(15) bt.insert(3) bt.insert(7) bt.insert(13) bt.insert(18) print(bt.find_height()) # Expected: 2 print(bt.zigzag_traversal()) # Expected: [10, 15, 5, 3, 7, 13, 18] ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def in_order_traversal(self): return self._in_order_traversal(self.root, []) def _in_order_traversal(self, root, result): if root: self._in_order_traversal(root.left, result) result.append(root.val) self._in_order_traversal(root.right, result) return result def find_height(self): return self._find_height(self.root) def _find_height(self, node): if node is None: return -1 left_height = self._find_height(node.left) right_height = self._find_height(node.right) return 1 + max(left_height, right_height) def zigzag_traversal(self): if not self.root: return [] result, temp, stack, flag = [], [], [self.root], 1 while stack: for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) result += temp[::flag] temp = [] flag *= -1 return result"},{"question":"# Description: Consider an array of integers where the elements are sorted in ascending order. You need to find the pair of elements that add up to a target integer. Your solution should use a binary search approach to achieve a time complexity better than O(n^2). # Task: Implement a function `find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int]` that: 1. Accepts a sorted list of integers `nums` and an integer `target`. 2. Returns a tuple of two integers from the list that add up to the `target`. 3. If no such pair exists, return an empty tuple. 4. Your implementation should have a time complexity of O(n log n). # Constraints: - The list `nums` contains only integers. - Elements of `nums` are sorted in non-decreasing order. - You may assume each input would have exactly one solution. # Inputs: - `nums` (List of integers): The sorted list of integers. - `target` (Integer): The target sum to achieve. # Output: - Returns a tuple of two integers which are elements of the list `nums` that add up to `target`. # Example Usage: ```python >>> find_pair_with_sum([1, 2, 3, 4, 6], 6) (2, 4) >>> find_pair_with_sum([2, 4, 8, 12], 10) (2, 8) >>> find_pair_with_sum([-3, 0, 2, 4], 1) (-3, 4) >>> find_pair_with_sum([1, 2, 3], 7) () ``` # Note: - Ensure that your solution employs binary search to achieve the desired time complexity. ```python def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int]: def binary_search(nums: list[int], start: int, end: int, key: int) -> int: left, right = start, end while left <= right: mid = (left + right) // 2 if nums[mid] == key: return mid elif nums[mid] < key: left = mid + 1 else: right = mid - 1 return -1 for i in range(len(nums)): complement = target - nums[i] j = binary_search(nums, i + 1, len(nums) - 1, complement) if j != -1: return (nums[i], nums[j]) return () ```","solution":"def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int]: def binary_search(nums: list[int], start: int, end: int, key: int) -> int: left, right = start, end while left <= right: mid = (left + right) // 2 if nums[mid] == key: return mid elif nums[mid] < key: left = mid + 1 else: right = mid - 1 return -1 for i in range(len(nums)): complement = target - nums[i] j = binary_search(nums, i + 1, len(nums) - 1, complement) if j != -1: return (nums[i], nums[j]) return ()"},{"question":"# Binary Tree Level Order Traversal **Context**: In many applications, processing data level-by-level in a hierarchical structure like a binary tree is essential. This problem involves traversing a binary tree level-by-level and extracting its values. **Problem Statement**: Implement a function `level_order_traversal` that takes the root node of a binary tree and returns a list of lists, where each list contains the values of the nodes at that level of the tree. **Function Signature**: ```python class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right from typing import List, Optional def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Performs level-order traversal on a binary tree. :param root: the root node of the binary tree. :return: a list of lists, each containing the values of the nodes at that level. ``` **Input**: - `root`: The root node of the binary tree (can be `None` if the tree is empty). **Output**: - A list of lists, each containing the values of the nodes at that level of the binary tree. **Constraints**: - The number of nodes in the tree is between 0 and 10^4. - Node values are integers. **Examples**: ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(level_order_traversal(root)) # Output: [[3], [9, 20], [15, 7]] root = TreeNode(1) print(level_order_traversal(root)) # Output: [[1]] root = None print(level_order_traversal(root)) # Output: [] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) print(level_order_traversal(root)) # Output: [[1], [2, 3], [4, 5]] ``` **Key Considerations**: - Ensure that the algorithm handles the edge case of an empty tree (i.e., root is `None`). - The solution should efficiently handle trees of varying shapes and sizes within the given constraints.","solution":"class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right from typing import List, Optional from collections import deque def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Coding Assessment Question Context You are working with geospatial data, and you need to implement functions to calculate distances on Earth\'s surface. The Earth is approximated as a sphere with a radius of 6,371 kilometers. You will use the Haversine formula to compute the shortest distance between two points given their latitude and longitude. Task Write a function `haversine_distance(coords1: tuple[float, float], coords2: tuple[float, float]) -> float` that: 1. Computes the great-circle distance between two points on the Earth\'s surface using their latitude and longitude coordinates. Input - `coords1`: Tuple containing the latitude and longitude of the first point in degrees (latitude1, longitude1). - `coords2`: Tuple containing the latitude and longitude of the second point in degrees (latitude2, longitude2). Output - The distance between the two points in kilometers as a float. Constraints - Latitude values will be between -90 and 90 degrees. - Longitude values will be between -180 and 180 degrees. - Input coordinates are well-formed floats. Performance Requirements - Utilize efficient numerical operations to compute the distance considering the constraints. - Ensure the code handles up to 10⁶ distance calculations within a reasonable execution time. Example ```python coords1 = (36.12, -86.67) # Nashville, TN coords2 = (33.94, -118.40) # Los Angeles, CA result = haversine_distance(coords1, coords2) print(result) # Expected output: Approx 2887.26 (depending on the precise implementation details) ``` Notes - Convert latitude and longitude from degrees to radians before applying the Haversine formula. - Use the formula: ``` a = sin²(Δφ/2) + cos(φ1) * cos(φ2) * sin²(Δλ/2) c = 2 * atan2(√a, √(1−a)) d = R * c ``` where `φ` represents latitude, `λ` represents longitude, `Δφ` is the difference in latitude, `Δλ` is the difference in longitude, and `R` is the Earth\'s radius (6,371 km).","solution":"import math def haversine_distance(coords1, coords2): Calculate the Haversine distance between two points on the Earth\'s surface. Parameters: coords1 (tuple): Tuple containing latitude and longitude in degrees (latitude1, longitude1) coords2 (tuple): Tuple containing latitude and longitude in degrees (latitude2, longitude2) Returns: float: Distance between the two points in kilometers # Radius of the Earth in kilometers R = 6371.0 # Unpack coordinates lat1, lon1 = coords1 lat2, lon2 = coords2 # Convert latitude and longitude from degrees to radians lat1_rad = math.radians(lat1) lon1_rad = math.radians(lon1) lat2_rad = math.radians(lat2) lon2_rad = math.radians(lon2) # Compute the differences in coordinates delta_lat = lat2_rad - lat1_rad delta_lon = lon2_rad - lon1_rad # Apply the Haversine formula a = math.sin(delta_lat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Calculate the distance distance = R * c return distance"},{"question":"# Problem Statement You are tasked with implementing a function `find_arithmetic_triplet` that checks if there exists an arithmetic triplet in an array of integers. An arithmetic triplet consists of three elements (a, b, c) such that (a), (b), and (c) are in arithmetic sequence: (b - a = c - b). # Input - A list of integers `nums` where ( -10^4 leq text{nums}[i] leq 10^4 ). # Output - A boolean `True` if there exists at least one arithmetic triplet in the array, otherwise `False`. # Constraints 1. The length of the array will be between 1 and 1000 inclusive. # Examples ```python find_arithmetic_triplet([1, 5, 9, 3, 7]) # Output: True # Explanation: 1, 5, 9 form an arithmetic triplet with common difference of 4. find_arithmetic_triplet([2, 4, 6, 8]) # Output: True # Explanation: Multiple triplets exist including (2, 4, 6) and (4, 6, 8) with common difference of 2. find_arithmetic_triplet([1, 2, 4]) # Output: False # Explanation: No three elements form an arithmetic sequence. find_arithmetic_triplet([10]) # Output: False # Explanation: The array is too small to contain a triplet. ``` # Performance Requirements Ensure that your solution runs efficiently within the given constraints. The expected time complexity is (O(n^2)) or better.","solution":"def find_arithmetic_triplet(nums): Check if there exists an arithmetic triplet in the array `nums`. An arithmetic triplet (a, b, c) satisfies the conditions: - a, b, c are distinct elements in nums - b - a == c - b Params: nums: List[int]: The input list of integers Returns: bool: True if there exists at least one arithmetic triplet, otherwise False n = len(nums) if n < 3: return False nums_set = set(nums) for i in range(n): for j in range(i + 1, n): diff = nums[j] - nums[i] third_element = nums[j] + diff if third_element in nums_set: return True return False"},{"question":"# Coding Challenge: Binary Tree Path Sum Scenario: You work as a software developer for a company that processes large datasets. One common data structure used for storing hierarchical data is a binary tree. One of the tasks you\'re given revolves around calculating the sum of all values in the paths from the root to the leaves of a binary tree. Task: Implement a function that computes the sum of all the paths from the root to the leaf nodes in a given binary tree. You need to calculate the total sum where each path sum is the concatenation of node values from root to leaf treated as single numbers. Input: * A binary tree where each node has a value represented as an integer. Output: * An integer representing the total sum of all path values from root to leaf. Constraints: * The tree has at least one node and no more than 10^3 nodes. * Node values are non-negative integers. Example: Input: ``` 1 / 2 3 / 4 5 ``` Output: ``` 262 (Path sums: 124 + 125 + 13) ``` Implementation Details: - Define a function `sum_path_numbers(root: TreeNode) -> int` to perform the task. - Use Depth-First Search (DFS) to explore all paths from root to leaf. - Convert each path to a number and sum these numbers. - Ensure your function adheres to the provided input and output formats. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_path_numbers(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0) # Example usage: if __name__ == \\"__main__\\": # Create the tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) print(sum_path_numbers(root)) # Output: 262 ``` This problem tests your understanding of tree traversal algorithms, recursive function calls, and basic arithmetic operations. It requires efficient traversal and computation of path sums which is fundamental in working with tree-related data structures.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_path_numbers(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"String Manipulation and Analysis You are given a skeleton code to manipulate and analyze strings to solve different text-based problems. Your task is to enhance the given functions with additional features. You should also provide an analysis of the changes and improvements made, highlighting the impact on readability, efficiency, and potential use cases. # Task Requirements: 1. **Palindromic Substrings**: * Implement a function to find and count all palindromic substrings in a given string. * Compare the efficiency of brute-force vs optimized solution (e.g., expand around center). 2. **String Compression**: * Add a function to compress a string using the counts of repeated characters (e.g., \\"aabcccccaaa\\" becomes \\"a2b1c5a3\\"). * Ensure the function returns the original string if the compressed string is not smaller. 3. **Anagram Grouping**: * Implement a function to group a list of strings into anagrams. * Compare different methods for grouping, such as sorting characters vs using character counts. 4. **Longest Substring Without Repeating Characters**: * Enhance the function to find the longest substring without repeating characters using both sliding window and optimized sliding window techniques. * Analyze the performance of both methods. # Input and Output Formats: - **Input**: - For Palindromic Substrings: A single string. - For String Compression: A single string. - For Anagram Grouping: A list of strings. - For Longest Substring Without Repeating Characters: A single string. - **Output**: - For Palindromic Substrings: Total count of palindromic substrings. - For String Compression: Compressed string or original string if compression is not effective. - For Anagram Grouping: List of lists, where each sublist contains anagrams grouped together. - For Longest Substring Without Repeating Characters: Length of longest substring without repeating characters. # Constraints: - You may assume input strings contain only lowercase letters for simplicity. - Ensure that your solutions are efficient to handle long strings and large lists. # Scenario: Your company is developing a text processing and analysis tool. The input datasets are various text documents that need to be processed to extract insights, compress data, and categorize similar segments. Your program should accurately and efficiently manipulate the strings as per specified tasks. # Code Skeleton: ```python class StringManipulationEnhanced: def __init__(self, input_str: str = \\"\\", input_list: list = []) -> None: # Initialization logic with provided input. pass def count_palindromic_substrings(self) -> int: # Implement counting of palindromic substrings. pass def string_compress(self) -> str: # Implement string compression. pass def group_anagrams(self) -> list: # Implement anagram grouping. pass def longest_substr_without_repeating(self) -> int: # Implement finding longest substring without repeating characters. pass def example_string_manipulation() -> None: # Provide a usage example, including comparisons of different implementations. pass if __name__ == \\"__main__\\": example_string_manipulation() ``` # Explanation of Results Observed: - **Palindromic Substrings**: Show the count of palindromic substrings found both using brute-force and optimized approach. Highlight the improved performance with the optimized method. - **String Compression**: Demonstrate the cases where compression is effective and ineffective (returns original string). - **Anagram Grouping**: Provide examples of grouped anagrams, comparing performance of different grouping methods. - **Longest Substr Without Repeating Characters**: Display the length of the longest substring without repeating characters and compare efficiency of both sliding window methods. # Summary: Summarize the enhancements made, showcasing their value in terms of readability, efficiency, and practical application scenarios in text processing.","solution":"class StringManipulationEnhanced: def __init__(self, input_str: str = \\"\\", input_list: list = []) -> None: self.input_str = input_str self.input_list = input_list def count_palindromic_substrings(self) -> int: s = self.input_str n = len(s) def expand_around_center(left: int, right: int) -> int: count = 0 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count count = 0 for i in range(n): count += expand_around_center(i, i) # Odd length palindromes count += expand_around_center(i, i + 1) # Even length palindromes return count def string_compress(self) -> str: s = self.input_str if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s def group_anagrams(self) -> list: from collections import defaultdict anagrams = defaultdict(list) for word in self.input_list: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values()) def longest_substr_without_repeating(self) -> int: s = self.input_str n = len(s) if n == 0: return 0 max_len = 0 char_map = {} left = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_len = max(max_len, right - left + 1) return max_len def example_string_manipulation() -> None: sma = StringManipulationEnhanced(\\"aabcccccaaa\\") print(sma.count_palindromic_substrings()) # Outputs number of palindromic substrings print(sma.string_compress()) # Outputs the compressed string or original string sma = StringManipulationEnhanced(input_list=[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) print(sma.group_anagrams()) # Outputs grouped anagrams sma = StringManipulationEnhanced(\\"pwwkew\\") print(sma.longest_substr_without_repeating()) # Outputs length of longest substring without repeating characters if __name__ == \\"__main__\\": example_string_manipulation()"},{"question":"# Problem Description You need to write a function that, given a string, returns the character that appears the most frequently. In the case of a tie (where multiple characters have the same highest frequency), return the character that comes first in lexicographical order. # Function Signature ```python def most_frequent_char(s: str) -> str: Function to return the most frequently occurring character in the string. Args: s (str): The input string. Returns: str: The character that appears most frequently in the string. Example: >>> most_frequent_char(\\"samplestring\\") \'s\' # \'s\' appears 2 times which is the highest frequency >>> most_frequent_char(\\"equalize\\") \'e\' # Both \'e\' and \'a\' appear twice, but \'e\' comes first lexicographically >>> most_frequent_char(\\"aabbcc\\") \'a\' # \'a\', \'b\', and \'c\' all appear twice, but \'a\' comes first lexicographically ``` # Constraints * `s` is a non-empty string. * The length of `s` does not exceed 10^4. * The string contains only lowercase English letters. # Requirements: 1. The function should handle cases where multiple characters have the same maximum frequency. 2. Performance should be optimized for strings close to the maximum length. # Implementation Goals * Aim for a time complexity of O(n), where n is the length of the string. * Use data structures that facilitate efficient counting and comparison. # Example Scenarios * For the input `\\"samplestring\\"`, the result should be `\'s\'`, as it appears most frequently (twice). * For the input `\\"equalize\\"`, the result should be `\'e\'`, as both `\'e\'` and `\'a\'` appear twice, but `\'e\'` is lexicographically smaller. * For the input `\\"aabbcc\\"`, the result should be `\'a\'`, as `\'a\'`, `\'b\'`, and `\'c\'` all appear twice, but `\'a\'` comes first lexicographically. # Further Considerations * How does your implementation handle large strings efficiently? * How do you ensure that the correct character is returned in the case of a tie?","solution":"def most_frequent_char(s: str) -> str: Function to return the most frequently occurring character in the string. Args: s (str): The input string. Returns: str: The character that appears most frequently in the string. # Dictionary to store frequency of each character frequency_dict = {} # Fill the dictionary with frequency counts for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 # Find the highest frequency max_frequency = max(frequency_dict.values()) # Find the lexicographically smallest character with the highest frequency most_frequent_chars = [char for char, freq in frequency_dict.items() if freq == max_frequency] result = min(most_frequent_chars) return result"},{"question":"# Finding Maximum XOR of a Pair in an Array Given an array of non-negative integers, write a function that returns the maximum XOR value of any two elements in the array. Function Signature ```python def find_max_xor(nums: list) -> int: pass ``` Input * `nums` (list of int): A list of non-negative integers. Output * `int`: The maximum XOR value between any two elements in the array. Constraints * 2 ≤ `len(nums)` ≤ 10^5 * 0 ≤ `nums[i]` ≤ 10^9 Example ```python print(find_max_xor([3, 10, 5, 25, 2, 8])) # should output 28 print(find_max_xor([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70])) # should output 127 print(find_max_xor([8, 1, 2, 12, 7, 6])) # should output 15 ``` Explanation The function should calculate the maximum XOR value that can be obtained by XORing any two different elements from the array. XOR (exclusive or) is a bitwise operator that returns 1 if the bits are different and 0 if they are the same. To efficiently find the maximum XOR, consider using a Trie (prefix tree) structure. This helps in comparing binary representations of numbers to quickly identify the pair that maximizes the XOR value. # Constraints & Guidelines * Ensure the function efficiently handles large arrays up to the size limit. * Consider both time and space complexity to optimize performance. * Properly handle edge cases like arrays with consecutive similar numbers.","solution":"class TrieNode: def __init__(self): self.children = {} def find_max_xor(nums): # Create Trie data structure def insert(num): node = trie for bit in range(31, -1, -1): # 32 bits for a non-negative integer cur_bit = (num >> bit) & 1 if cur_bit not in node.children: node.children[cur_bit] = TrieNode() node = node.children[cur_bit] def find_max(current_num): node = trie max_xor = 0 for bit in range(31, -1, -1): opposite_bit = 1 - ((current_num >> bit) & 1) if opposite_bit in node.children: max_xor = (max_xor << 1) | 1 node = node.children[opposite_bit] else: max_xor = (max_xor << 1) node = node.children[1 - opposite_bit] return max_xor # Initialize the Trie trie = TrieNode() max_xor = 0 # Insert the first number to the Trie insert(nums[0]) # Iterate over the remaining numbers and find the max XOR for i in range(1, len(nums)): current_num = nums[i] max_xor = max(max_xor, find_max(current_num)) insert(current_num) return max_xor"},{"question":"# Square Root Calculation Scenario You are required to implement a function that calculates the square root of a given non-negative integer with high precision. The result must be accurate up to three decimal places. This task is crucial for mathematical computations and various scientific applications. Your implementation must handle edge cases and invalid input types carefully. Function Signature ```python def precise_sqrt(n: int) -> str: ``` Input - `n` (int): A non-negative integer. Output - Return the square root of `n` as a string formatted to three decimal places. Constraints - `n` should be a non-negative integer. - If `n` is negative, raise a `ValueError` with the message `\\"the value of n must be non-negative\\"`. - If `n` is not an integer, raise a `TypeError`. Examples ```python >>> precise_sqrt(4) \'2.000\' >>> precise_sqrt(9) \'3.000\' >>> precise_sqrt(2) \'1.414\' >>> precise_sqrt(16) \'4.000\' >>> precise_sqrt(10) \'3.162\' >>> precise_sqrt(-1) Traceback (most recent call last): ... ValueError: the value of n must be non-negative >>> precise_sqrt(9.5) Traceback (most recent call last): ... TypeError: <class \'float\'> >>> precise_sqrt(\'25\') Traceback (most recent call last): ... TypeError: <class \'str\'> ``` **Notes**: - You may use Python\'s built-in `math.sqrt` function. - Ensure your solution is well-documented and robust against edge cases. Task Implement the `precise_sqrt` function as specified. Validate inputs thoroughly and ensure the result is accurate to three decimal places.","solution":"import math def precise_sqrt(n: int) -> str: Returns the square root of a non-negative integer n, formatted to three decimal places. if not isinstance(n, int): raise TypeError(f\\"{type(n)}\\") if n < 0: raise ValueError(\\"the value of n must be non-negative\\") sqrt_value = math.sqrt(n) return f\\"{sqrt_value:.3f}\\""},{"question":"# Problem Statement You are developing a scheduling application which helps users to find free slots in a day to schedule meetings. The application should be able to take into account multiple schedules for different users and find common free time slots when everyone is available. # Tasks 1. **Merge Schedules**: Implement a function `merge_schedules(schedules: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]` that takes a list of schedules for different users and merges them to find the common free time slots. 2. **Available Slots**: Implement a function `available_slots(merged_schedule: List[Tuple[int, int]], work_day: Tuple[int, int]) -> List[Tuple[int, int]]` that takes the merged schedule and the work day duration (e.g., 9:00 AM to 5:00 PM represented as (9, 17)) and returns the list of available time slots during the work day. # Input and Output Formats - **Input for Merge Schedules**: - A list of schedules, where each schedule is a list of tuples. Each tuple represents a meeting with a start and end time in 24-hour format without \\":\\" (e.g., (9, 11) for 9:00 AM to 11:00 AM). - **Output for Merge Schedules**: - A list of tuples representing the merged schedule where all meetings are consolidated. - **Input for Available Slots**: - The merged schedule as a list of tuples, and the work day as a tuple of start and end time. - **Output for Available Slots**: - A list of tuples representing the available time slots during the work day when all users are free. # Performance Requirements - The functions should efficiently manage and merge schedules, considering overlapping and contiguous meetings. - The performance should handle schedules of up to 100 users, each with up to 100 meetings. # Example - **Merge Schedules** ```python schedules = [ [(9, 10), (12, 14)], # User 1\'s meetings [(10, 11), (13, 15)], # User 2\'s meetings [(11, 12)] # User 3\'s meetings ] output = merge_schedules(schedules) print(output) # Output: [(9, 11), (11, 12), (12, 15)] ``` - **Available Slots** ```python merged_schedule = [(9, 11), (11, 12), (12, 15)] work_day = (9, 17) output = available_slots(merged_schedule, work_day) print(output) # Output: [(15, 17)] ``` # Constraints - The input schedules list will have a length between 1 and 100. - Each schedule (list of tuples) will have a length between 1 and 100. - Meeting times will be within the work day bounds but can overlap. - Schedules are assumed to be sorted and non-overlapping for individual users but need to be merged with other users\' schedules. # Tests Write tests to ensure your implementation works correctly: - Test with schedules that do not overlap at all. - Test with completely overlapping schedules. - Test with schedules with contiguous meetings. - Test with very large schedules within the specified constraints. - Test with edge cases like single meetings or no meetings. This question will test your ability to handle list merging, interval management, and finding gaps within a given range efficiently.","solution":"from typing import List, Tuple def merge_schedules(schedules: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]: Merges multiple schedules into a consolidated list of meetings. merged = [] # Flatten the list of schedules all_meetings = [meeting for schedule in schedules for meeting in schedule] # Sort meetings by start time all_meetings.sort() for meeting in all_meetings: if not merged or merged[-1][1] < meeting[0]: merged.append(meeting) else: # Merge overlapping intervals merged[-1] = (merged[-1][0], max(merged[-1][1], meeting[1])) return merged def available_slots(merged_schedule: List[Tuple[int, int]], work_day: Tuple[int, int]) -> List[Tuple[int, int]]: Finds available time slots within the work day given the merged schedule. free_slots = [] start, end = work_day # Initialize the end time of the last meeting last_end = start for meeting in merged_schedule: if last_end < meeting[0]: free_slots.append((last_end, meeting[0])) last_end = max(last_end, meeting[1]) if last_end < end: free_slots.append((last_end, end)) return free_slots"},{"question":"# Problem Statement You are required to implement a feature for a software application that simulates a simple e-commerce shopping cart. The shopping cart should allow users to add items, remove items, view the total cost, and apply a discount code. The system should handle typical tasks expected of a shopping cart in an online store. Implement a class `ShoppingCart` with the following methods: # Methods: - `add_item(name: str, price: float, quantity: int) -> None`: Adds the specified quantity of an item to the cart. If the item already exists, update its quantity. - `remove_item(name: str) -> None`: Removes a specified item from the cart. If the item does not exist, do nothing. - `get_total() -> float`: Returns the total cost of all items in the cart, taking into account their quantities. - `apply_discount(code: str) -> None`: Applies a discount to the total cost. There are two types of discounts: `FLAT10` which subtracts 10 currency units from the total cost, and `PERC20` which gives a 20% discount on the total cost. If an invalid code is provided, it should raise a `ValueError` with a descriptive error message. # Constraints: - The `price` of an item should be a positive float. - The `quantity` of an item should be a positive integer. - The shopping cart can hold multiple items, each identified uniquely by `name`. - The discount code, if applied, should only be applicable once. Multiple discount codes cannot be stacked. # Requirements: 1. The class should maintain accurate records of items and their quantities. 2. The `get_total` method should return the total price correctly, even after items are added, removed, or a discount is applied. 3. Attempting to apply an invalid discount code should raise a `ValueError` with an appropriate message. # Example Usage: ```python >>> cart = ShoppingCart() >>> cart.add_item(\\"T-shirt\\", 20.0, 2) >>> cart.add_item(\\"Jeans\\", 40.0, 1) >>> cart.get_total() 80.0 >>> cart.apply_discount(\\"FLAT10\\") >>> cart.get_total() 70.0 >>> cart.apply_discount(\\"PERC20\\") Traceback (most recent call last): ... ValueError: Discount code already applied or invalid. ``` # Error Scenarios: ```python >>> cart = ShoppingCart() >>> cart.apply_discount(\\"INVALID\\") Traceback (most recent call last): ... ValueError: Invalid discount code provided: \'INVALID\'. Valid codes are \'FLAT10\' and \'PERC20\' ```","solution":"class ShoppingCart: def __init__(self): self.items = {} self.discount_applied = None def add_item(self, name: str, price: float, quantity: int) -> None: if price <= 0 or quantity <= 0: raise ValueError(\\"Price and quantity must be positive.\\") if name in self.items: self.items[name][\'quantity\'] += quantity else: self.items[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name: str) -> None: if name in self.items: del self.items[name] def get_total(self) -> float: total = sum(item[\'price\'] * item[\'quantity\'] for item in self.items.values()) if self.discount_applied == \\"FLAT10\\": total -= 10 elif self.discount_applied == \\"PERC20\\": total *= 0.8 return total if total >= 0 else 0 def apply_discount(self, code: str) -> None: if code == \\"FLAT10\\" or code == \\"PERC20\\": if self.discount_applied is not None: raise ValueError(\\"Discount code already applied or invalid.\\") self.discount_applied = code else: raise ValueError(\\"Invalid discount code provided: \'{}\'. Valid codes are \'FLAT10\' and \'PERC20\'\\".format(code))"},{"question":"# Context: In the realm of competitive programming, efficient data manipulation is crucial. You are tasked with implementing a specific kind of matrix operation often used in algorithms dealing with graphs and dynamic programming. # Task: Implement the `transpose` operation on a given square matrix. The transpose of a matrix is an operator which flips a matrix over its diagonal, that is, it switches the row and column indices of the matrix by producing another matrix. # Specification: 1. **Function Name**: `transpose` 2. **Parameters**: * `matrix` (List[List[int]]): A square matrix (list of lists) of integers. 3. **Returns**: A new square matrix (list of lists) representing the transpose of the given matrix. 4. **Constraints**: * The matrix dimensions will always be `n x n`, where 1 ≤ n ≤ 1000. * Each element in the matrix will be between `-10^9` and `10^9`, inclusive. 5. **Input/Output**: * Example: ```python transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ``` Should return: ```python [[1, 4, 7], [2, 5, 8], [3, 6, 9]] ``` # Performance Requirements: The function should perform in O(n^2) time complexity, where n is the size of the dimension of the matrix. # Edge Cases: Consider smallest and largest possible matrices, including matrices with negative and zero values. # Example Usage: ```python def transpose(matrix: List[List[int]]) -> List[List[int]]: >>> transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose([[1, -2], [-3, 4]]) [[1, -3], [-2, 4]] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix))] # Write your code here. ``` Test your function meticulously, ensuring that it handles various sizes and values of matrices correctly and efficiently.","solution":"def transpose(matrix): Function to transpose a given square matrix. Parameters: matrix (List[List[int]]): A square matrix (list of lists) of integers. Returns: List[List[int]]: A new square matrix representing the transpose of the given matrix. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)]"},{"question":"# Problem Statement: You have been tasked to develop a function that processes a dataset of employee information to calculate and output the average salary by department while also ensuring the data quality by handling missing or corrupt entries. Implement a Python function `calculate_average_salary(csv_filename: str) -> dict` that: 1. Reads a CSV file containing employee data with the columns \\"EmployeeID\\", \\"Name\\", \\"Department\\", and \\"Salary\\". 2. Handles missing or corrupt entries in the data: - If \\"Department\\" or \\"Salary\\" is missing, that entry should be ignored. - If \\"Salary\\" is not a number, that entry should be ignored. 3. Calculates the average salary for each department. 4. Returns a dictionary with department names as keys and their corresponding average salaries as values. Constraints * The CSV file is expected to have a header row. * The function should handle cases where the CSV file might not contain any valid data for calculation gracefully. * Ensure that decimal precision is maintained in the calculated averages. * The function should not modify the input file. Inputs and Outputs * **Input**: `csv_filename` (str) - the name of the input CSV file containing employee data. * **Output**: dict - a dictionary where the keys are department names and the values are the average salaries of those departments. Example: Given a CSV file named \\"employees.csv\\" with the following content: ``` EmployeeID,Name,Department,Salary 1,John Doe,Engineering,75000 2,Jane Smith,Marketing,60000 3,,,50000 4,James Brown,Engineering,85000 5,Emily Davis,Marketing,70000 6,Michael Johnson,Engineering,not_a_number 7,Jessica Wilson,HR,65000 ``` Calling `calculate_average_salary(\\"employees.csv\\")` should return: ```python { \\"Engineering\\": 80000.0, \\"Marketing\\": 65000.0, \\"HR\\": 65000.0 } ``` Those entries with missing \\"Department\\" or invalid \\"Salary\\" values are ignored in the calculations.","solution":"import csv def calculate_average_salary(csv_filename: str) -> dict: department_salary = {} department_count = {} with open(csv_filename, mode=\'r\') as file: csv_reader = csv.DictReader(file) for row in csv_reader: department = row.get(\'Department\') salary = row.get(\'Salary\') if not department or not salary: continue try: salary = float(salary) except ValueError: continue if department not in department_salary: department_salary[department] = 0 department_count[department] = 0 department_salary[department] += salary department_count[department] += 1 average_salary_by_department = {dept: department_salary[dept] / department_count[dept] for dept in department_salary} return average_salary_by_department"},{"question":"# Question: Compute the Nth Square Pyramidal Number Square pyramidal numbers represent the number of stacked squares in a pyramid with a square base. The Nth square pyramidal number is calculated using the formula: [ P_n = frac{n(n + 1)(2n + 1)}{6} ] Task Write a function `square_pyramidal_number(n: int) -> int` that returns the Nth square pyramidal number. Function Signature ```python def square_pyramidal_number(n: int) -> int: pass ``` Input - `n` (int): The position of the square pyramidal number to generate. Must be a non-negative integer. Output - (int): The Nth square pyramidal number. Constraints - `0 <= n <= 10^5` (Ensure handling for large values efficiently) - Raise a `ValueError` for any input value of `n` that is negative. Examples ```python >>> square_pyramidal_number(1) 1 >>> square_pyramidal_number(2) 5 >>> square_pyramidal_number(3) 14 >>> square_pyramidal_number(-1) Traceback (most recent call last): ... ValueError: param `n` must be non-negative ``` Performance Requirements Your function should operate in constant time, O(1).","solution":"def square_pyramidal_number(n: int) -> int: Computes the Nth square pyramidal number. Parameters: n (int): The position of the square pyramidal number to generate. Must be a non-negative integer. Returns: int: The Nth square pyramidal number. Raises: ValueError: If n is negative. if n < 0: raise ValueError(\\"param `n` must be non-negative\\") # Calculate the Nth square pyramidal number using the formula return (n * (n + 1) * (2 * n + 1)) // 6"},{"question":"# Evaluate and Optimize a Given Sorting Algorithm You are given an implementation of a non-standard sorting algorithm in Python. Your task is to analyze its performance on various datasets and optimize its efficiency. Additionally, you need to ensure that the optimized algorithm provides the correct sorted order for any given input. # Task 1. Analyze the provided sorting algorithm in terms of time and space complexity. 2. Implement an optimized version of the algorithm to reduce its time complexity while maintaining the same functionality. Below is the initial implementation to analyze: ```python def custom_sort(arr): for i in range(len(arr)): for j in range(i + 1, len(arr)): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr ``` Function Signature ```python def optimized_sort(arr: list) -> list: Optimized version of custom_sort to sort the input list more efficiently. ``` Input - **arr** (List of integers): The list that needs to be sorted. Output - **List of integers**: The sorted list in non-decreasing order. Constraints: - The input list can contain up to 10^5 elements. - Input elements can be any integer values (positive, negative, or zero). # Example 1. Sorting with the original algorithm: ```python arr = [64, 25, 12, 22, 11] sorted_arr = custom_sort(arr) print(sorted_arr) # Output: [11, 12, 22, 25, 64] ``` 2. Sorting with the optimized algorithm: ```python arr = [64, 25, 12, 22, 11] sorted_arr = optimized_sort(arr) print(sorted_arr) # Expected Output: [11, 12, 22, 25, 64] ``` # Explanation - The provided custom_sort function uses a simple double-loop strategy resulting in O(n^2) time complexity, making it inefficient for large datasets. - Your objective is to replace or optimize this with a more efficient sorting algorithm like Merge Sort, Quick Sort, or any other algorithm with O(n log n) complexity. # Additional Notes - Consider edge cases like an empty list, a list with one element, and a list with already sorted elements. - Your solution should be both efficient and robust, handling large inputs appropriately without compromising correctness. Good luck!","solution":"def optimized_sort(arr): Optimized version of custom_sort to sort the input list more efficiently. Uses the Timsort algorithm which is used by Python\'s built-in sorted() function and list.sort() method, with an average and worst-case time complexity of O(n log n). return sorted(arr)"},{"question":"Word Ladder Implementation # Background: A word ladder is a puzzle where you transform one word into another by changing one letter at a time, with each intermediate word being a valid dictionary word. Your task is to develop a Python program that finds the shortest transformation sequence from a start word to an end word. # Task: Implement the word ladder problem using a Breadth-First Search (BFS) algorithm. # Requirements: 1. Implement a function `word_ladder` that finds the shortest path (word ladder) from the start word to the end word. 2. The function should take three arguments: `begin_word`, `end_word`, and a list of valid words `word_list`. 3. Return the sequence of words representing the shortest path from `begin_word` to `end_word`, inclusive. # Algorithm Implementation: 1. **Word Ladder Function**: * This function should initialize a queue for BFS and a set for visited words. * At each step, it should generate all possible valid transformations of the current word by changing one letter at a time. * It should check if the transformation matches the `end_word`. * The function should return the list of words representing the transformation path once it reaches the `end_word`. # Function Definitions: ```python from collections import deque def word_ladder(begin_word: str, end_word: str, word_list: list) -> list: word_set = set(word_list) if end_word not in word_set: return [] queue = deque([[begin_word]]) visited = set([begin_word]) while queue: path = queue.popleft() current_word = path[-1] if current_word == end_word: return path for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i + 1:] if next_word in word_set and next_word not in visited: queue.append(path + [next_word]) visited.add(next_word) return [] ``` # Input/Output: * **Input**: Strings `begin_word`, `end_word`, and a list of strings `word_list`. * Example: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] ``` * **Output**: List of strings representing the shortest transformation. * Example Output: ```python [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] ``` # Constraints: * Each word in the input contains only lowercase English letters. * The length of `begin_word` and `end_word` is the same. * All words in the input list `word_list` are the same length as `begin_word` and `end_word`. * You may assume there is always a valid sequence.","solution":"from collections import deque def word_ladder(begin_word: str, end_word: str, word_list: list) -> list: word_set = set(word_list) if end_word not in word_set: return [] queue = deque([[begin_word]]) visited = set([begin_word]) while queue: path = queue.popleft() current_word = path[-1] if current_word == end_word: return path for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i + 1:] if next_word in word_set and next_word not in visited: queue.append(path + [next_word]) visited.add(next_word) return []"},{"question":"# Problem Description You are asked to implement a function that allows the manipulation of a social network represented as an undirected graph. Each user in the network is a node, and each friendship is an edge between two nodes. You need to add new friendships and determine the maximum degree of separation between any two users. # Objective Implement the following function: ```python def add_friendships_and_find_max_degree(n: int, friendship_pairs: list[tuple[int, int]], new_friendships: list[tuple[int, int]]) -> int: Adds new friendship pairs to the existing network and finds the maximum degree of separation between any two users. Parameters: n (int): The number of users in the social network. friendship_pairs (list of tuples): A list containing existing friendships where each tuple (a, b) represents a friendship between user a and user b. new_friendships (list of tuples): A list containing new friendship pairs to be added to the network. Returns: int: The maximum degree of separation between any two users in the social network. ``` # Input * `n`: an integer representing the number of users in the social network, labeled from 0 to n-1. * `friendship_pairs`: a list of tuples, where each tuple consists of two integers representing an existing friendship between user `a` and user `b`. * `new_friendships`: a list of tuples, where each tuple consists of two integers representing a new friendship to be added between user `a` and user `b`. # Output * An integer representing the maximum degree of separation between any two users in the social network. # Constraints * `1 <= n <= 10^3` * `1 <= len(friendship_pairs), len(new_friendships) <= 10^5` * `0 <= a, b < n` * `a != b` * There is at most one existing friendship between any pair of users. # Example ```python # Number of users in the social network user_count = 5 # Existing friendships current_friends = [(0, 1), (1, 2), (2, 3)] # New friendships to add new_friends = [(3, 4), (1, 3)] # Function call result = add_friendships_and_find_max_degree(user_count, current_friends, new_friends) # Expected output # 3 ``` Implement the `add_friendships_and_find_max_degree` function to complete the task.","solution":"from collections import deque def add_friendships_and_find_max_degree(n: int, friendship_pairs: list[tuple[int, int]], new_friendships: list[tuple[int, int]]) -> int: # Create adjacency list for the graph adjacency_list = {i: [] for i in range(n)} # Add existing friendships to the graph for a, b in friendship_pairs: adjacency_list[a].append(b) adjacency_list[b].append(a) # Add new friendships to the graph for a, b in new_friendships: adjacency_list[a].append(b) adjacency_list[b].append(a) def bfs(source): distances = [-1] * n distances[source] = 0 queue = deque([source]) while queue: current = queue.popleft() for neighbor in adjacency_list[current]: if distances[neighbor] == -1: distances[neighbor] = distances[current] + 1 queue.append(neighbor) return max(distances) max_distance = 0 # Find maximum degree of separation for each node for node in range(n): max_distance = max(max_distance, bfs(node)) return max_distance"},{"question":"# Cluster Point Detection You are required to implement a Python function that identifies and counts the distinct clusters in a 2D grid of points, using the Depth-First Search (DFS) algorithm. Each cluster is defined as a group of contiguous points (horizontally or vertically connected). # Objective Write a function `count_clusters` that takes a 2D grid of booleans representing points (`True` indicates a point and `False` indicates empty space) and returns the number of distinct clusters. # Input and Output * **Inputs**: * `grid: List[List[bool]]` - A 2D list of booleans representing the grid of points. * **Output**: * `int` - The number of distinct clusters in the input grid. # Constraints * The grid can be of size `m x n` where `1 <= m, n <= 50`. * Each element of the grid is either `True` or `False`. # Guidelines 1. Implement the function using Depth-First Search (DFS) to explore connected components. 2. Ensure your function handles edge cases, such as all elements being `False` or `True`. # Function Signature ```python from typing import List def count_clusters(grid: List[List[bool]]) -> int: # Your code here ``` # Example ```python def count_clusters(grid: List[List[bool]]) -> int: def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or not grid[i][j]: return grid[i][j] = False # Mark the current point as visited # Explore all four possible directions dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]: # If a point is found, we found a new cluster count += 1 dfs(i, j) return count # Test cases print(count_clusters([ [True, False, False, True], [False, True, True, False], [False, False, True, False], [True, False, False, True] ])) # Output: 5 ``` # Scenario Suppose you are working on a geographic information system that detects isolated areas or clusters of vegetation in satellite images. Implementing this clustering algorithm can help quickly identify and count distinct vegetative regions within a grid, aiding ecological studies and resource allocation.","solution":"from typing import List def count_clusters(grid: List[List[bool]]) -> int: Count the number of distinct clusters of True values in the grid. A cluster is defined as contiguous True values connected horizontally or vertically. def dfs(i, j): Depth-First Search to mark all connected True values starting from (i, j) if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or not grid[i][j]: return grid[i][j] = False # Mark the current point as visited # Explore all four possible directions dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]: # If a point is found, we found a new cluster count += 1 dfs(i, j) return count"},{"question":"# Coding Question **Objective**: Write a function to find the maximum product of two distinct elements in a list. # Problem Statement You are given a list of integers. You need to write a function `max_product_of_two(lst: List[int]) -> int` that finds and returns the maximum product of two distinct elements present in the list. # Input Format - A list of integers. - Example: `[3, 5, -2, 9, 7]` # Output Format - A single integer representing the maximum product of two distinct elements. - Example: `63` # Constraints - The list will contain at least two integers. - The integers can be positive, negative, or zero. # Example ```python assert max_product_of_two([3, 5, -2, 9, 7]) == 63 assert max_product_of_two([-10, -3, 5, 6]) == 30 assert max_product_of_two([1, 2, 3, 4]) == 12 ``` # Requirements - Your solution should be efficient, preferably with a time complexity of O(n), where n is the number of elements in the list. - Consider edge cases, such as lists with both negative and positive numbers, and lists with zeros.","solution":"from typing import List def max_product_of_two(lst: List[int]) -> int: Finds and returns the maximum product of two distinct elements in the list. if len(lst) < 2: raise ValueError(\\"List must contain at least two elements.\\") max1, max2 = float(\'-inf\'), float(\'-inf\') min1, min2 = float(\'inf\'), float(\'inf\') for num in lst: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2)"},{"question":"# Coding Assessment Question Write a function `circular_shift_string` that takes two arguments: a string `s` and an integer `k`, and returns the string after performing a circular shift of `k` positions to the right. The circular shift means that characters displaced from the end of the string are wrapped around to the beginning. # Inputs * `s`: A string consisting of alphanumeric characters and spaces. * `k`: A non-negative integer representing the number of positions to shift. # Outputs * A string that has been circularly shifted. # Constraints * The string length will be between 1 and 1000 inclusive. * 0 ≤ k ≤ 10^9. # Example ```python s = \\"hello\\" k = 2 # Expected output: \\"lohel\\" ``` # Implementation You need to complete the implementation of the `circular_shift_string` function: ```python def circular_shift_string(s, k): # Ensure k is within the range of the length of the string k = k % len(s) # Perform the circular shift return s[-k:] + s[:-k] ``` Test your implementation with multiple cases to ensure correctness.","solution":"def circular_shift_string(s, k): Performs a circular shift of the string s by k positions to the right. Parameters: s (str): The input string to be shifted. k (int): The number of positions to shift the string. Returns: str: The circularly shifted string. # Ensure k is within the range of the length of the string k = k % len(s) # Perform the circular shift return s[-k:] + s[:-k]"},{"question":"# Context In numerical computing, understanding the behavior of basic operations on different data types is crucial. Floating-point numbers can sometimes lead to precision issues, and one must be cautious while performing equality checks. # Problem Statement Write a function `approximately_equal(a: float, b: float, tol: float) -> bool` that checks if two floating-point numbers `a` and `b` are approximately equal to each other within a given tolerance `tol`. If the absolute difference between `a` and `b` is less than or equal to `tol`, then they are considered approximately equal. # Input - `a`: a floating-point number. - `b`: a floating-point number. - `tol`: a non-negative floating-point number representing the tolerance. # Output - A boolean value indicating whether the numbers are approximately equal. # Constraints - The values of `a` and `b` will be in the range of -10^6 to 10^6. - The tolerance `tol` will be in the range of 0 to 10^6. - You must ensure the function handles edge cases such as very small or very large numbers appropriately using an epsilon-based approach if necessary. # Example ```python >>> approximately_equal(1.00001, 1.00002, 0.0001) True >>> approximately_equal(1.00001, 1.0002, 0.0001) False >>> approximately_equal(-1.00001, -1.00002, 0.0001) True >>> approximately_equal(1000000.1, 1000000.2, 0.01) False ``` # Notes - Consider using the built-in `abs()` function to compute the absolute difference. ```python def approximately_equal(a: float, b: float, tol: float) -> bool: return abs(a - b) <= tol ```","solution":"def approximately_equal(a: float, b: float, tol: float) -> bool: Checks if two floating-point numbers `a` and `b` are approximately equal within a given tolerance `tol`. Parameters: a (float): The first floating-point number. b (float): The second floating-point number. tol (float): The tolerance within which the numbers are considered approximately equal. Returns: bool: True if the absolute difference between `a` and `b` is less than or equal to `tol`, otherwise False. return abs(a - b) <= tol"},{"question":"# Problem Description You are given an integer array. Your task is to implement a function that modifies the array such that every element at an odd index is replaced by the sum of itself and the element at the previous even index. Elements at even indices remain unchanged. # Input and Output Format * **Input**: You will be given a single array of integers. * `nums`: an array of integers. * **Output**: Return the modified array. # Constraints * The length of the array is in the range `[1, 1000]`. * The values in the array are in the range `[-1000, 1000]`. # Implementation Requirements * Implement the function `modify_array(nums: List[int]) -> List[int]`. # Example ```python from typing import List def modify_array(nums: List[int]) -> List[int]: for i in range(1, len(nums), 2): nums[i] += nums[i - 1] return nums # Example to test the implementation nums = [1, 2, 3, 4, 5, 6] modified_array = modify_array(nums) print(\\"Modified Array is: \\", modified_array) ``` # Explanation Given the array: ``` [1, 2, 3, 4, 5, 6] ``` The resulting array should be: ``` [1, 3, 3, 7, 5, 11] ``` Here, the element at index 1 (2) is replaced by 1 + 2 = 3, element at index 3 (4) is replaced by 3 + 4 = 7, and element at index 5 (6) is replaced by 5 + 6 = 11.","solution":"from typing import List def modify_array(nums: List[int]) -> List[int]: Modifies the array such that every element at an odd index is replaced by the sum of itself and the element at the previous even index. for i in range(1, len(nums), 2): nums[i] += nums[i - 1] return nums"},{"question":"Question You have been provided with a class `BinarySearchTree` that represents a binary search tree (BST). A BST is a binary tree where each node has a value, and for any node with value `X`, its left subtree only contains nodes with values less than `X`, and its right subtree only contains nodes with values greater than `X`. Your task is to implement a method `find_kth_smallest` in the `BinarySearchTree` class. This method should return the k-th smallest element in the BST. Assume that k is always valid, i.e., 1 ≤ k ≤ total number of nodes in the BST. # Function Signature ```python def find_kth_smallest(self, k: int) -> int: ``` # Parameters - `k`: An integer representing the position of the smallest element to find (1-based index). # Returns - The value of the k-th smallest element in the BST. # Constraints - The BST may contain positive, negative, or zero integer values. - There are no duplicate elements in the BST. - You may assume that the tree has at least one node. # Example Usage ```python bst = BinarySearchTree() bst.insert(20).insert(10).insert(30).insert(5).insert(15).insert(25).insert(35) assert bst.find_kth_smallest(1) == 5 assert bst.find_kth_smallest(3) == 15 assert bst.find_kth_smallest(5) == 25 ``` # Edge Cases to Consider - Finding the 1st smallest element. - Finding the k-th smallest element where k is equal to the number of nodes in the BST. - Handling BST with single node.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) return self else: self._insert_rec(self.root, key) return self def _insert_rec(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_rec(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_rec(node.right, key) def find_kth_smallest(self, k: int) -> int: # Helper function to perform inorder traversal def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Get the inorder traversal sequence inorder_sequence = inorder_traversal(self.root) # Return the k-th smallest element (1-based index) return inorder_sequence[k - 1]"},{"question":"Coding Question # Problem You are provided with a string `s` consisting of only lowercase English letters. Implement a function `most_frequent_character(s: str) -> str` to find and return the most frequent character in the string. If there are multiple characters with the same highest frequency, return the one that appears first when traversing the string from left to right. # Input * A string `s` where `1 <= len(s) <= 10^5`. # Output * A single character representing the most frequent character in the string. If there are ties, return the one that appears first in the string. # Constraints * The function should run efficiently and handle the worst-case scenario within the time limits. # Examples 1. Input: `s = \\"aabbbcc\\"` Output: `b` (Character `b` has the highest frequency of 3.) 2. Input: `s = \\"abcabc\\"` Output: `a` (Characters `a`, `b`, and `c` all have the same frequency of 2, but `a` appears first.) # Notes * Consider edge cases such as a string with all unique characters or a string where all characters are the same. # Implementation Requirements * The function must handle the input string and constraints efficiently. * Avoid using additional data structures that significantly increase the space complexity. # Solution Approach To solve this problem, you can traverse the string to count the occurrences of each character, then determine the most frequent character while ensuring the first-appearance rule is respected in case of ties.","solution":"def most_frequent_character(s: str) -> str: from collections import defaultdict # Dictionary to store the frequency of characters frequency = defaultdict(int) # Traverse the string and count the occurrences for char in s: frequency[char] += 1 # To track the most frequent character and its count max_count = -1 max_char = \'\' # Traverse the string again to find the first most frequent character for char in s: if frequency[char] > max_count: max_count = frequency[char] max_char = char return max_char"},{"question":"# **Coding Assessment Question:** # Context: You need to develop a system that processes and filters messages based on certain criteria. This involves reading messages from a data source, filtering them based on given rules, and returning the filtered list for further actions. # Question: Implement a Python function that, given a list of messages and a list of user-defined keywords, filters the messages to only include those that contain at least one of the keywords. Your implementation should account for case insensitivity and should handle any potential issues with message data (e.g., missing text). # Function Signature: ```python def filter_messages(messages: List[str], keywords: List[str]) -> List[str]: ``` # Inputs: - **messages** (List[str]): A list of string messages to be filtered. - **keywords** (List[str]): A list of keywords to filter the messages by. # Outputs: - **List[str]**: A list of messages that contain at least one of the keywords, comparing in a case-insensitive manner. # Constraints: - Messages and keywords will contain alphabetical characters and spaces only. - Handle null or empty messages gracefully by excluding them from the output. - Ensure the filtering process is case insensitive. # Example: ```python print(filter_messages([ \\"The weather today is sunny.\\", \\"I love programming in Python!\\", \\"Yesterday was a rainy day.\\", \\"\\" ], [\\"sunny\\", \\"python\\"])) # Expected Output Example: # [ # \\"The weather today is sunny.\\", # \\"I love programming in Python!\\" # ] ``` # Note: - Ensure your solution can process messages efficiently even if some messages are empty or null. - The order of messages in the output list should correlate with the order in the input list, retaining only the relevant messages. - Document any assumptions and ensure your code adheres to best practices for both readability and maintainability.","solution":"from typing import List def filter_messages(messages: List[str], keywords: List[str]) -> List[str]: Filters messages to only include those that contain at least one of the keywords. The filtering is case-insensitive and handles empty messages gracefully. :param messages: List of string messages to be filtered. :param keywords: List of keywords to filter the messages by. :return: A list of messages that contain at least one of the keywords. # Prepare the keywords for case insensitive comparison keywords = [keyword.lower() for keyword in keywords] filtered_messages = [] for message in messages: if not message: continue # Check if message contains any of the keywords if any(keyword in message.lower() for keyword in keywords): filtered_messages.append(message) return filtered_messages"},{"question":"# Minimum Cost Path in a Grid Given a grid of size `m x n` where each cell contains a non-negative integer representing the cost to traverse that cell, find a path from the top-left corner to the bottom-right corner which minimizes the total cost. You can only move right or down from a cell. # Objective: Implement a function to find the minimum cost to traverse the grid. # Context: Imagine you are planning a trip across a city represented as a grid, where each cell\'s value represents the travel cost for that area. You want to find the cheapest travel route from the starting point (top-left corner) to your destination (bottom-right corner). # Function Signature: ```python def min_path_cost(grid: List[List[int]]) -> int: pass ``` # Input: - `grid`: A list of lists of integers representing the cost grid. # Output: - Returns an integer representing the minimum cost to travel from the top-left corner to the bottom-right corner. # Constraints: - `1 <= m, n <= 100` - Each integer in the grid is non-negative and does not exceed 1000. - The grid is guaranteed to be non-empty. # Performance Requirements: - The solution should ideally run in O(m * n) time complexity. - Use additional space efficiently, aiming for O(m * n) space complexity. # Scenario: ```python # Let\'s assume we have the following cost grid: # [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] # Example test case: print(min_path_cost(grid)) # 7 (Path: 1 -> 3 -> 1 -> 1 -> 1) ``` # Hints: 1. Utilize dynamic programming to keep track of the minimum cost to reach each cell. 2. At each cell, determine the minimum cost by considering the costs from the cell above and the cell to the left.","solution":"from typing import List def min_path_cost(grid: List[List[int]]) -> int: Returns the minimum cost to travel from the top-left to the bottom-right corner of the grid. The movement is only allowed right or down from a cell. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) cost = [[0] * n for _ in range(m)] cost[0][0] = grid[0][0] for i in range(1, m): cost[i][0] = cost[i-1][0] + grid[i][0] for j in range(1, n): cost[0][j] = cost[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[m-1][n-1]"},{"question":"# Problem Statement You are given a string containing only letters, digits, and the symbols \'-\' and \'_\'. Your task is to write a function that checks whether the given string is a valid identifier in Python. In Python, a valid identifier must: - Start with a letter (a-z, A-Z) or an underscore (_). - Contain only letters, digits (0-9), or underscores (_). Objective Implement a function `is_valid_identifier` that checks if the given string is a valid Python identifier. Function Signature ```python def is_valid_identifier(s: str) -> bool: pass ``` Input * `s` (str): The input string to check. (1 <= len(s) <= 100) Output * A boolean value `True` if the string is a valid identifier, `False` otherwise. Example ```python assert is_valid_identifier(\\"variable_name\\") == True assert is_valid_identifier(\\"2nd_variable\\") == False assert is_valid_identifier(\\"_privateVar1\\") == True assert is_valid_identifier(\\"var-name\\") == False assert is_valid_identifier(\\"normalVar\\") == True assert is_valid_identifier(\\"_123\\") == True ``` # Requirements 1. The solution must accurately validate the string based on Python\'s identifier rules. 2. The solution should handle edge cases, such as strings containing invalid characters or starting with invalid characters. 3. Ensure the implementation is efficient and clear.","solution":"def is_valid_identifier(s: str) -> bool: Checks if the given string is a valid identifier in Python. A valid identifier must: - Start with a letter (a-z, A-Z) or an underscore (_) - Contain only letters, digits (0-9), or underscores (_) Parameters: s (str): The input string to check Returns: bool: True if the string is a valid identifier, False otherwise if not s: return False # The first character must be a letter or an underscore if not (s[0].isalpha() or s[0] == \'_\'): return False # The rest of the string must be alphanumeric or underscores for char in s[1:]: if not (char.isalnum() or char == \'_\'): return False return True"},{"question":"# Prime Path Finder Background A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your task is to create a feature for a number analysis tool that determines the shortest path between two given prime numbers by changing one digit at a time, ensuring each intermediate number is also a prime. Task Write a function `prime_shortest_path` that takes two 4-digit prime numbers and returns the minimum number of steps required to convert the first prime number into the second prime number. Each step must result in a valid 4-digit prime number. Function Signature ```python def prime_shortest_path(start_prime: int, end_prime: int) -> int: pass ``` Input * `start_prime` (integer): The starting 4-digit prime number. * `end_prime` (integer): The target 4-digit prime number. Output * Return the minimum number of steps required to convert `start_prime` into `end_prime`. * If it is not possible to convert `start_prime` into `end_prime`, return -1. Constraints * Both `start_prime` and `end_prime` are 4-digit prime numbers. * A step consists of changing exactly one digit, ensuring the result is still a 4-digit prime number. * The function must handle the transformation efficiently given the potential number of 4-digit prime numbers. Example ```python >>> prime_shortest_path(1033, 8179) 6 >>> prime_shortest_path(1373, 8017) 7 >>> prime_shortest_path(1033, 1033) 0 >>> prime_shortest_path(1033, 9991) -1 ``` Implement the function such that it identifies the shortest transformation path between the given prime numbers, if it exists. Handle the processes of prime validation and digit transformation efficiently to ensure optimal performance.","solution":"from collections import deque from itertools import permutations def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def get_all_primes(): primes = [] for num in range(1000, 10000): if is_prime(num): primes.append(num) return primes def prime_neighbors(prime): neighbors = [] str_prime = str(prime) for i in range(4): for digit in \'0123456789\': if digit != str_prime[i]: new_prime = str_prime[:i] + digit + str_prime[i+1:] new_prime = int(new_prime) if is_prime(new_prime): neighbors.append(new_prime) return neighbors def prime_shortest_path(start_prime, end_prime): if start_prime == end_prime: return 0 primes = get_all_primes() primes_set = set(primes) queue = deque([(start_prime, 0)]) visited = set() visited.add(start_prime) while queue: current_prime, steps = queue.popleft() for neighbor in prime_neighbors(current_prime): if neighbor == end_prime: return steps + 1 if neighbor not in visited and neighbor in primes_set: visited.add(neighbor) queue.append((neighbor, steps + 1)) return -1"},{"question":"# Question: Shortest Path in a Weighted Graph You are given a weighted undirected graph with **n** vertices representing cities numbered from 0 to n-1 and edges representing roads with specific weights indicating the distance between cities. Your task is to implement a method to find the shortest path from a given source city to all other cities using Dijkstra\'s Algorithm. Scenario: City Navigation System Imagine you are working on a navigation system for a city. The graph\'s vertices represent the cities, and the edges represent roads with distances. Your goal is to calculate the shortest paths from the main starting city (source vertex) to all other cities for efficient navigation. # Function Signature ```python def dijkstra_shortest_paths(n, edges, source): Computes the shortest path from the source to all other nodes using Dijkstra\'s Algorithm. Parameters: n (int) : Number of vertices in the graph. edges (list of tuple): Each tuple (u, v, w) represents an edge between vertex u and vertex v with distance w. source (int): The source vertex in the graph. Returns: list: The list of minimum distances from the source to each vertex. If a vertex is not reachable, return float(\'inf\') for that vertex. pass ``` # Input - **n**: An integer, the number of vertices in the graph. - **edges**: A list of tuples where each tuple `(u, v, w)` indicates an undirected edge between vertex `u` and vertex `v` with distance `w`. - **source**: An integer representing the source vertex. # Output - The function should return a list of integers where each integer at index `i` indicates the shortest distance from the source vertex to vertex `i`. If vertex `i` is not reachable from the source, the distance should be `float(\'inf\')`. # Example ```python # Example input n = 5 edges = [(0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 1), (2, 3, 5), (3, 4, 3)] source = 0 # Example output print(dijkstra_shortest_paths(n, edges, source)) # Expected output: [0, 3, 1, 4, 7] ``` # Constraints 1. (2 leq n leq 1000) 2. (1 leq text{number of edges} leq 10000) 3. (0 leq u, v < n) 4. (1 leq w leq 10000) # Notes 1. Ensure to handle edge cases such as disconnected graphs and vertices with no outgoing edges. 2. You can assume that the input graph is valid and distances are positive. Implement the `dijkstra_shortest_paths` function that returns the shortest distances from the source vertex to all other vertices in the graph.","solution":"import heapq def dijkstra_shortest_paths(n, edges, source): Computes the shortest path from the source to all other nodes using Dijkstra\'s Algorithm. Parameters: n (int) : Number of vertices in the graph. edges (list of tuple): Each tuple (u, v, w) represents an edge between vertex u and vertex v with distance w. source (int): The source vertex in the graph. Returns: list: The list of minimum distances from the source to each vertex. If a vertex is not reachable, return float(\'inf\') for that vertex. # Construct the adjacency list from the edges list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Initialize distances with infinity distances = [float(\'inf\')] * n distances[source] = 0 # Priority queue to explore the minimum distance node first priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Vigenère Cipher: Encrypt and Decrypt You are tasked with implementing the Vigenère cipher, which is a method of encrypting and decrypting text using a series of different Caesar ciphers based on the letters of a keyword. For optimal security, the keyword should be repeated to match the length of the plaintext or ciphertext. Function Specifications: 1. **Encrypt Function**: ```python def vigenere_encrypt(keyword: str, plaintext: str) -> str: Encrypts the plaintext using the Vigenère cipher. :param keyword: The keyword used for encryption. :param plaintext: The plaintext to be encrypted. :return: The ciphertext as a string. ``` 2. **Decrypt Function**: ```python def vigenere_decrypt(keyword: str, ciphertext: str) -> str: Decrypts the ciphertext using the Vigenère cipher. :param keyword: The keyword used for decryption. :param ciphertext: The ciphertext to be decrypted. :return: The plaintext as a string. ``` Requirements - Both the keyword and plaintext/ciphertext should be treated as case-insensitive. - Spaces and other non-alphabet characters should be ignored in the encryption/decryption process. - The functions must maintain the input format (strings without spaces or special characters). Constraints - Assume the keyword and plaintext/ciphertext are composed of alphabetic characters only. - The length of the plaintext/ciphertext to be encrypted/decrypted will be less than 10,000 characters. Example Usage ```python def test_vigenere_cipher() -> None: keyword = \\"KEYWORD\\" plaintext = \\"HELLOVIGENERE\\" encrypted = vigenere_encrypt(keyword, plaintext) decrypted = vigenere_decrypt(keyword, encrypted) assert decrypted == plaintext, f\\"Expected: {plaintext}, Got: {decrypted}\\" if __name__ == \\"__main__\\": test_vigenere_cipher() ``` # Explanation: - For encryption, align each character of the plaintext with the corresponding character of the keyword (repeated as necessary). - Convert each pair of characters to their respective ordinal values, calculate the cipher ordinal by shifting the plaintext character by the keyword character\'s position in the alphabet, then convert back to characters. - For decryption, reverse the process by shifting the ciphertext character back by the keyword character\'s position. This integrates encryption/decryption skills using a keyword-based shifting mechanism, comparable to but distinct from the Running Key Cipher.","solution":"def vigenere_encrypt(keyword: str, plaintext: str) -> str: Encrypts the plaintext using the Vigenère cipher. :param keyword: The keyword used for encryption. :param plaintext: The plaintext to be encrypted. :return: The ciphertext as a string. keyword = keyword.upper() plaintext = plaintext.upper() keyword_repeated = (keyword * ((len(plaintext) // len(keyword)) + 1))[:len(plaintext)] ciphertext = \\"\\" for p_letter, k_letter in zip(plaintext, keyword_repeated): shift = ord(k_letter) - ord(\'A\') encrypted_letter = chr(((ord(p_letter) - ord(\'A\') + shift) % 26) + ord(\'A\')) ciphertext += encrypted_letter return ciphertext def vigenere_decrypt(keyword: str, ciphertext: str) -> str: Decrypts the ciphertext using the Vigenère cipher. :param keyword: The keyword used for decryption. :param ciphertext: The ciphertext to be decrypted. :return: The plaintext as a string. keyword = keyword.upper() ciphertext = ciphertext.upper() keyword_repeated = (keyword * ((len(ciphertext) // len(keyword)) + 1))[:len(ciphertext)] plaintext = \\"\\" for c_letter, k_letter in zip(ciphertext, keyword_repeated): shift = ord(k_letter) - ord(\'A\') decrypted_letter = chr(((ord(c_letter) - ord(\'A\') - shift + 26) % 26) + ord(\'A\')) plaintext += decrypted_letter return plaintext"},{"question":"# Automated Shopping Cart System Context: You have been tasked with implementing an automated shopping cart system for an e-commerce platform. The system needs to handle various operations such as adding items, removing items, and calculating the total cost. Each item has a unique ID, price, and quantity in stock. The primary focus of the task is on the cart\'s operations and ensuring the system maintains the correct state for items in stock. Requirements: 1. Implement the `ShoppingCart` class with the following functionalities: * **`add_item(item_id: int, quantity: int) -> None`**: Adds a specified quantity of the item to the cart. If the item already exists, increase its quantity in the cart. * **`remove_item(item_id: int, quantity: int) -> None`**: Removes a specified quantity of the item from the cart. If the quantity becomes zero or less, remove the item from the cart entirely. * **`get_total_cost() -> float`**: Returns the total cost of all items currently in the cart. 2. Ensure the cart does not exceed the available stock for any item in the inventory. 3. Create an in-memory inventory system to keep track of items and their quantities. 4. The operations must handle invalid cases gracefully, such as trying to add or remove quantities larger than available stock. Implementation: Implement the `ShoppingCart` class and ensure it correctly interacts with the inventory. The inventory should be a dictionary where the key is the item ID and the value is a tuple containing the price and the available quantity. # Class Signature: ```python class ShoppingCart: def __init__(self, inventory: dict[int, tuple[float, int]]): self.inventory = inventory self.cart = {} def add_item(self, item_id: int, quantity: int) -> None: pass def remove_item(self, item_id: int, quantity: int) -> None: pass def get_total_cost(self) -> float: pass ``` # Input/Output Specifications: * **Input**: * `item_id` (int): The unique identifier of the item. * `quantity` (int): The quantity of the item to add or remove. Must be a non-negative integer. * `inventory` (dict[int, tuple[float, int]]): Dictionary mapping item IDs to a tuple containing the price and available quantity. * **Output**: * `add_item` and `remove_item` methods do not return any value. * `get_total_cost` returns the total cost of the items in the cart, rounded to two decimal places. # Constraints: * Item IDs are assumed to be positive integers. * Quantities for add and remove operations must be valid non-negative integers. * Inventory should be pre-populated with at least one item for testing purposes. # Examples: ```python inventory = { 1: (10.0, 5), # Item ID 1 has a price of 10.0 and 5 units in stock 2: (20.0, 2), # Item ID 2 has a price of 20.0 and 2 units in stock } cart = ShoppingCart(inventory) cart.add_item(1, 3) # Add 3 units of item ID 1 assert cart.get_total_cost() == 30.00 cart.add_item(2, 1) # Add 1 unit of item ID 2 assert cart.get_total_cost() == 50.00 cart.remove_item(1, 1) # Remove 1 unit of item ID 1 assert cart.get_total_cost() == 40.00 ```","solution":"class ShoppingCart: def __init__(self, inventory: dict[int, tuple[float, int]]): self.inventory = inventory # Inventory mapping item_id to (price, available_quantity) self.cart = {} # Cart mapping item_id to quantity in cart def add_item(self, item_id: int, quantity: int) -> None: if item_id not in self.inventory: raise ValueError(\\"Item ID not found in inventory\\") price, available_quantity = self.inventory[item_id] current_quantity = self.cart.get(item_id, 0) if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") if current_quantity + quantity > available_quantity: raise ValueError(\\"Not enough stock available\\") self.cart[item_id] = current_quantity + quantity def remove_item(self, item_id: int, quantity: int) -> None: if item_id not in self.cart: raise ValueError(\\"Item not in cart\\") if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") current_quantity = self.cart[item_id] if quantity >= current_quantity: del self.cart[item_id] else: self.cart[item_id] = current_quantity - quantity def get_total_cost(self) -> float: total_cost = 0.0 for item_id, quantity in self.cart.items(): price = self.inventory[item_id][0] total_cost += price * quantity return round(total_cost, 2)"},{"question":"You are required to define a function that formats and extracts specific details from a list of dictionary objects where each dictionary represents data about an employee. The function should also handle missing or incorrect data gracefully. 1. **Data Extraction**: - Extract the employee\'s full name, employee ID, and department. - If the employee\'s department is missing, replace it with \\"Unknown\\". - If any employee record is missing a field or is incomplete, skip that record without causing an error. 2. **Formatting**: - Construct a string representation that includes the full name, employee ID, and department in a predefined format. - Ensure that all extracted data is correctly capitalized (e.g., first name and last name should start with an uppercase letter). Write the function `process_employee_data` with the following signature: ```python from typing import List, Dict def process_employee_data(employee_list: List[Dict[str, str]]) -> List[str]: # Your implementation here ``` # Input: - `employee_list` (List[Dict[str, str]]): A list of dictionaries where each dictionary holds information about an employee with keys like `first_name`, `last_name`, `employee_id`, and `department`. # Output: - Returns a list of strings, where each string represents one employee\'s data in the format: \\"Employee: [Full Name], ID: [Employee ID], Dept: [Department]\\". # Constraints: - Ensure proper capitalization of the full name. - Handle cases where required fields are missing by skipping those records. - Avoid raising exceptions for missing or incomplete records. # Example: ```python employees = [ {\\"first_name\\": \\"john\\", \\"last_name\\": \\"doe\\", \\"employee_id\\": \\"1234\\", \\"department\\": \\"engineering\\"}, {\\"first_name\\": None, \\"last_name\\": \\"smith\\", \\"employee_id\\": \\"5678\\"}, {\\"first_name\\": \\"jane\\", \\"last_name\\": \\"doe\\", \\"employee_id\\": \\"91011\\"}, {\\"first_name\\": \\"susan\\", \\"last_name\\": \\"ray\\", \\"employee_id\\": \\"12131\\", \\"department\\": \\"marketing\\"} ] result = process_employee_data(employees) print(result) ``` This code should output a list of strings in the following format: ```python [ \\"Employee: John Doe, ID: 1234, Dept: Engineering\\", \\"Employee: Jane Doe, ID: 91011, Dept: Unknown\\", \\"Employee: Susan Ray, ID: 12131, Dept: Marketing\\" ] ```","solution":"from typing import List, Dict def process_employee_data(employee_list: List[Dict[str, str]]) -> List[str]: formatted_employee_data = [] for employee in employee_list: try: first_name = employee[\\"first_name\\"].capitalize() last_name = employee[\\"last_name\\"].capitalize() full_name = f\\"{first_name} {last_name}\\" employee_id = employee[\\"employee_id\\"] department = employee.get(\\"department\\", \\"Unknown\\").capitalize() formatted_string = f\\"Employee: {full_name}, ID: {employee_id}, Dept: {department}\\" formatted_employee_data.append(formatted_string) except (KeyError, TypeError, AttributeError): continue # Skip incomplete or incorrect data return formatted_employee_data"},{"question":"# Coding Assessment Question: Spherical Geometry Calculations Scenario You are developing software for a scientific research institution that deals with spherical objects. Your task is to create functions that compute the surface area and volume of a sphere given its radius. This will assist the researchers in quickly obtaining these geometric properties for their data analysis. Objective Write two functions: `calculate_sphere_surface_area` and `calculate_sphere_volume` to compute the surface area and volume of a sphere, respectively. Function Specifications: # Function 1 * **Name**: `calculate_sphere_surface_area` * **Input**: A single parameter, `radius`, which is a float representing the radius of the sphere. * **Output**: A float representing the surface area of the sphere. * **Constraints**: - The radius must be a positive number. If not, raise a `ValueError` with the message \\"Radius must be positive.\\" # Function 2 * **Name**: `calculate_sphere_volume` * **Input**: A single parameter, `radius`, which is a float representing the radius of the sphere. * **Output**: A float representing the volume of the sphere. * **Constraints**: - The radius must be a positive number. If not, raise a `ValueError` with the message \\"Radius must be positive.\\" Performance Requirement: - Both functions should run in constant time ( O(1) ). Example: ```python import math def calculate_sphere_surface_area(radius: float) -> float: if radius <= 0: raise ValueError(\\"Radius must be positive.\\") return 4 * math.pi * (radius ** 2) def calculate_sphere_volume(radius: float) -> float: if radius <= 0: raise ValueError(\\"Radius must be positive.\\") return (4/3) * math.pi * (radius ** 3) ``` Tests: ```python # Test cases for `calculate_sphere_surface_area` assert abs(calculate_sphere_surface_area(5) - 314.1592653589793) < 1e-9 assert abs(calculate_sphere_surface_area(10) - 1256.6370614359173) < 1e-9 try: calculate_sphere_surface_area(-1) except ValueError as e: assert str(e) == \\"Radius must be positive.\\" # Test cases for `calculate_sphere_volume` assert abs(calculate_sphere_volume(5) - 523.5987755982989) < 1e-9 assert abs(calculate_sphere_volume(10) - 4188.790204786391) < 1e-9 try: calculate_sphere_volume(-1) except ValueError as e: assert str(e) == \\"Radius must be positive.\\" ``` Ensure your code adheres to the specifications and passes all the test cases specified.","solution":"import math def calculate_sphere_surface_area(radius: float) -> float: Calculate the surface area of a sphere with a given radius. :param radius: Radius of the sphere :return: Surface area of the sphere :raises ValueError: if the radius is not positive if radius <= 0: raise ValueError(\\"Radius must be positive.\\") return 4 * math.pi * (radius ** 2) def calculate_sphere_volume(radius: float) -> float: Calculate the volume of a sphere with a given radius. :param radius: Radius of the sphere :return: Volume of the sphere :raises ValueError: if the radius is not positive if radius <= 0: raise ValueError(\\"Radius must be positive.\\") return (4/3) * math.pi * (radius ** 3)"},{"question":"# Problem Statement Write a function that determines the number of distinct ways to climb a staircase that has `n` steps, where you can take 1, 2, or 3 steps at a time. The function should return the total number of distinct ways to reach the top. # Function Signature ```python def staircase_ways(n: int) -> int: Calculate the number of distinct ways to reach the top of a staircase with n steps, taking 1, 2, or 3 steps at a time. :param n: The total number of steps in the staircase. :return: The number of distinct ways to reach the top. ``` # Input Format * `n` (int): The total number of steps in the staircase. # Output Format * An integer representing the number of distinct ways to reach the top of the staircase. # Constraints * `0 <= n <= 30` # Example ```python staircase_ways(4) # Expected output: 7 ``` # Explanation For `n = 4`, the distinct ways to reach the top are: * (1, 1, 1, 1) * (1, 1, 2) * (1, 2, 1) * (2, 1, 1) * (2, 2) * (1, 3) * (3, 1)","solution":"def staircase_ways(n): Calculate the number of distinct ways to reach the top of a staircase with n steps, taking 1, 2, or 3 steps at a time. :param n: The total number of steps in the staircase. :return: The number of distinct ways to reach the top. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Initialize an array to store results of subproblems dp = [0] * (n + 1) # Base cases dp[0] = 1 dp[1] = 1 dp[2] = 2 # Fill the dp array in bottom-up fashion for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"# Coding Question: Implement the following function to mirror a binary tree in place. 1. **Function to mirror the binary tree**: Implement a method `mirror` to generate the mirror image of the binary tree in place. In a mirrored binary tree, the left and right children of all non-leaf nodes are swapped. ```python class TreeNode: def __init__(self, val:int=0, left:\'TreeNode\'=None, right:\'TreeNode\'=None): self.val = val self.left = left self.right = right def mirror(self) -> None: Mirror the binary tree in place. This method modifies the tree such that the left and right children of all nodes are swapped. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> root.mirror() >>> root.left.val == 3 and root.right.val == 2 True >>> root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5, TreeNode(6))) >>> root.mirror() >>> root.left.val == 5 and root.right.val == 2 True >>> root.left.left.val == 6 and root.right.left.val == 3 True # Your implementation here ``` # Constraints: * The tree node values are integers. * The tree may be unbalanced. * The maximum depth of the tree is not greater than 1000. # Examples: ```python root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(5))), TreeNode(3)) root.mirror() # Before mirroring: After mirroring: # 1 1 # / / # 2 3 -> 3 2 # / # 4 4 # / # 5 5 ``` # Additional Notes: * Ensure the method correctly handles trees with only one node and empty subtrees (`null` nodes). * The implementation should be efficient in both time and space complexity for large trees.","solution":"class TreeNode: def __init__(self, val:int=0, left:\'TreeNode\'=None, right:\'TreeNode\'=None): self.val = val self.left = left self.right = right def mirror(self) -> None: Mirror the binary tree in place. This method modifies the tree such that the left and right children of all nodes are swapped. if self is None: return # Swap the left and right children self.left, self.right = self.right, self.left # Recursively apply mirror to left and right subtrees if they exist if self.left: self.left.mirror() if self.right: self.right.mirror()"},{"question":"# Question: Shortest Path in a Maze Scenario You have been asked to find the shortest path in a maze represented as a grid. The maze is composed of \'0\'s and \'1\'s, where \'0\' represents an open cell and \'1\' represents a blocked cell. You can move up, down, left, or right. Task Implement a function `shortest_path(maze: List[List[int]]) -> int` that returns the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1). If there is no path, return -1. Input * `maze` (List[List[int]]): A 2D list indicating the maze structure. Constraints: 1 ≤ len(maze), len(maze[0]) ≤ 100. Each element in the grid can be either 0 or 1. Output * Returns an integer representing the length of the shortest path. If no path exists, return -1. Example ```python >>> maze = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [1, 0, 0, 0], ... [1, 1, 1, 0] ... ] >>> shortest_path(maze) 7 >>> maze = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path(maze) -1 ``` Constraints * Ensure the function handles cases where either the starting or ending cell is blocked. * Utilize efficient algorithms such as Breadth-First Search (BFS) for pathfinding to ensure performance within the given constraints. Additional Notes * Take into account edge cases such as the smallest possible grid (1x1). * Handle scenarios where the maze is entirely blocked or the starting/ending positions are blocked.","solution":"from collections import deque from typing import List def shortest_path(maze: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1). If there is no path, returns -1. n = len(maze) m = len(maze[0]) # Check if the start or end is blocked if maze[0][0] == 1 or maze[n-1][m-1] == 1: return -1 # Initialize queues for BFS queue = deque([(0, 0, 1)]) # (row, column, distance) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # Mark the start as visited maze[0][0] = 1 while queue: row, col, dist = queue.popleft() # If we reached the bottom-right corner if row == n - 1 and col == m - 1: return dist for dr, dc in directions: newRow, newCol = row + dr, col + dc # If the new position is within bounds and is not visited if 0 <= newRow < n and 0 <= newCol < m and maze[newRow][newCol] == 0: queue.append((newRow, newCol, dist + 1)) # Mark as visited maze[newRow][newCol] = 1 # If there\'s no path return -1"},{"question":"# Coding Assessment Question Context: Working with data often involves transforming and validating strings. A common operation is checking if a string is a valid palindrome sentence, ignoring non-alphabetic characters and case. Palindromes are strings that read the same backward as forward. Problem: Given a sentence, write a function that checks if the sentence is a valid palindrome. Your task is to implement a function `is_palindrome` that returns `True` if the input sentence is a palindrome, and `False` otherwise. Function Signature: ```python def is_palindrome(sentence: str) -> bool: pass ``` Input: * `sentence`: A string containing any characters. Output: * A boolean value: `True` if the sentence is a palindrome and `False` otherwise. Constraints: * The input sentence will contain between 1 and 1,000 characters. * Ignore non-alphabetic characters and consider only the alphabetic characters for palindrome validation. * Treat uppercase and lowercase letters as the same. Example: ```python sentence = \\"A man, a plan, a canal, Panama\\" is_palindrome(sentence) # Output: True sentence = \\"Race Car!\\" is_palindrome(sentence) # Output: True sentence = \\"Hello, World!\\" is_palindrome(sentence) # Output: False ``` Instructions: 1. Implement the `is_palindrome` function. 2. Write your code considering edge cases (e.g., single character, empty input after filtering). 3. Ensure performance efficiency given the constraints. Note: You may use helper functions to clean the input and to check the palindrome condition.","solution":"def is_palindrome(sentence: str) -> bool: Given a sentence, return True if it is a palindrome, False otherwise. A valid palindrome sentence ignores non-alphabetic characters and is case-insensitive. # Filter out non-alphabetic characters and convert to lowercase filtered_sentence = \'\'.join(filter(str.isalpha, sentence)).lower() # Check if the filtered sentence reads the same backward return filtered_sentence == filtered_sentence[::-1]"},{"question":"# Coding Assessment Question Scenario: You are working as a software architect at a large technology firm. Your team is building a multi-tenant system where each tenant has its own set of user roles and permissions. To manage these roles efficiently, you need to build a system that can derive the entire hierarchy of roles for a tenant given a set of direct inheritance relationships. Goals: Write a Python function `role_hierarchy` that takes the number of roles and their direct inheritance relationships and returns a dictionary representing the complete role hierarchy for each role. Function Signature: ```python def role_hierarchy(n: int, inheritance: list[tuple[int, int]]) -> dict[int, set[int]]: pass ``` Input: - `n (int)`: The number of roles, represented as nodes in the graph. - `inheritance (list[tuple[int, int]])`: A list of tuples where each tuple (u, v) signifies that role u inherits from role v. Output: - `dict[int, set[int]]`: A dictionary where the key is a role and the value is a set of roles that are directly or indirectly inherited by that role. Example: ```python n = 5 inheritance = [(2, 3), (3, 1), (4, 2), (4, 3), (5, 4)] print(role_hierarchy(n, inheritance)) # Output: {1: set(), 2: {1, 3}, 3: {1}, 4: {1, 2, 3}, 5: {1, 2, 3, 4}} ``` Constraints: - The number of roles will not exceed 1000. - Each role may inherit from multiple other roles but the total number of inheritance relationships will not exceed 10,000. Performance Requirements: - The solution must efficiently handle the constraints on the number of roles (vertices) and inheritance relationships (edges) as specified.","solution":"def role_hierarchy(n: int, inheritance: list[tuple[int, int]]) -> dict[int, set[int]]: # Initialize result dictionary with each role having an empty set hierarchy = {i: set() for i in range(1, n + 1)} # Build an adjacency list for roles adj_list = {i: [] for i in range(1, n + 1)} for u, v in inheritance: adj_list[u].append(v) # Helper function to perform DFS and find all inherited roles def dfs(role, visited): for parent in adj_list[role]: if parent not in visited: visited.add(parent) hierarchy[role].add(parent) # Visit the parent node recursively dfs(parent, visited) # Add the inherited roles of the parent to the current role\'s hierarchy hierarchy[role].update(hierarchy[parent]) # Compute the complete hierarchy for each role for role in range(1, n + 1): dfs(role, set()) return hierarchy"},{"question":"# Scenario: You are developing a software module for an online exam system, specifically tailoring it to handle timed exams. This requires managing and scheduling exams such that each student\'s exam starts and ends precisely at the designated time. # Task: Implement a class named `TimedExam` that handles student exam timings in Python. The class should support starting an exam, checking the time remaining, and ending the exam while adhering to the constraints and conditions mentioned below. # Requirements: 1. The class should be instantiated with the exam duration in minutes. 2. Implement the following methods: - `start_exam(start_time: str) -> None`: Starts the exam at the provided start time in \\"HH:MM\\" format. - `time_remaining(current_time: str) -> int`: Returns the remaining time in minutes given the current time in \\"HH:MM\\" format. - `end_exam(current_time: str) -> bool`: Ends the exam and returns `True` if the exam successfully ended within the scheduled duration, or `False` if the exam period has already expired. 3. Handle edge cases where the `start_time` or `current_time` inputs are invalid or improperly formatted. # Expected Input and Output: * **Input:** - `start_time` (str): The time when the exam starts in \\"HH:MM\\" format. - `current_time` (str): The current time in \\"HH:MM\\" format when checking time remaining or ending the exam. * **Output:** - `time_remaining`: Returns an integer representing the minutes left. - `end_exam`: Returns a boolean indicating if the exam ended successfully within the designated duration. # Constraints: * Exam durations will not exceed 1440 minutes (24 hours). * The `start_time` and `current_time` must be valid 24-hour times in \\"HH:MM\\" format. # Examples: ```python exam = TimedExam(60) exam.start_exam(\\"14:00\\") print(exam.time_remaining(\\"14:30\\")) # Expected Output: 30 print(exam.time_remaining(\\"15:00\\")) # Expected Output: 0 print(exam.time_remaining(\\"15:10\\")) # Expected Output: -10 print(exam.end_exam(\\"15:05\\")) # Expected Output: False exam.start_exam(\\"13:50\\") print(exam.end_exam(\\"14:45\\")) # Expected Output: True ``` # Hints: - Use datetime operations to calculate the time differences. - Validate the time format to ensure it follows \\"HH:MM\\" 24-hour format and raise appropriate exceptions if it does not.","solution":"import datetime class TimedExam: def __init__(self, duration_minutes: int): self.duration = datetime.timedelta(minutes=duration_minutes) self.start_time = None def _validate_time_format(self, time_str: str): try: datetime.datetime.strptime(time_str, \\"%H:%M\\") except ValueError: raise ValueError(\\"Time format should be HH:MM\\") def start_exam(self, start_time: str): self._validate_time_format(start_time) self.start_time = datetime.datetime.strptime(start_time, \\"%H:%M\\") def time_remaining(self, current_time: str) -> int: self._validate_time_format(current_time) if self.start_time is None: raise RuntimeError(\\"Exam has not started yet\\") current = datetime.datetime.strptime(current_time, \\"%H:%M\\") time_elapsed = current - self.start_time remaining_time = self.duration - time_elapsed return int(remaining_time.total_seconds() // 60) def end_exam(self, current_time: str) -> bool: remaining = self.time_remaining(current_time) return remaining >= 0"},{"question":"# String Permutation Checker You are tasked with creating a function to check if two given strings are permutations of each other. This exercise will assess your understanding of data structures, such as dictionaries or arrays, and your ability to implement efficient string manipulation algorithms in Python. Function Signature: ```python def are_permutations(s1: str, s2: str) -> bool: ``` Input: - Two strings `s1` and `s2`. Output: - A boolean value `True` if `s1` and `s2` are permutations of each other, `False` otherwise. Constraints: - The input strings will only contain ASCII characters. - The length of each string will not exceed 100,000 characters. Error Handling: - If any of the inputs are not strings, raise a `TypeError` with the message: \\"Both parameters s1 and s2 must be strings.\\" Performance Requirements: - Your implementation should be able to handle the maximum input size efficiently. Example: ```python >>> are_permutations(\\"abc\\", \\"cab\\") True >>> are_permutations(\\"hello\\", \\"billion\\") False >>> are_permutations(\\"anagram\\", \\"nagaram\\") True >>> are_permutations(\\"rat\\", \\"car\\") False >>> are_permutations(\\"aabbcc\\", \\"baccab\\") True ```","solution":"def are_permutations(s1: str, s2: str) -> bool: Determines if two given strings are permutations of each other. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 and s2 are permutations of each other, False otherwise. Raises: TypeError: If any input is not a string. if not isinstance(s1, str) or not isinstance(s2, str): raise TypeError(\\"Both parameters s1 and s2 must be strings.\\") # If lengths are not equal, they cannot be permutations if len(s1) != len(s2): return False # Use sorted approach for simplicity return sorted(s1) == sorted(s2)"},{"question":"# Problem Statement **Title**: Reorganizing a List by Frequency You need to implement a function `frequency_sort` that takes a list of integers and returns a new list where the integers are sorted by their frequency in descending order. If two integers have the same frequency, they should appear in ascending order. Function Signature ```python def frequency_sort(lst: list[int]) -> list[int]: ``` Input - `lst` (list of ints): A list of integers which may contain duplicates. The list will contain at most 100 elements. Output - Returns a list of integers sorted by their frequency in descending order. If two integers have the same frequency, they should appear in ascending order. Constraints - All the integers in the input list will be between -1,000 and 1,000. Examples ```python assert frequency_sort([4, 5, 6, 5, 4, 3]) == [4, 4, 5, 5, 3, 6] assert frequency_sort([1, 2, 1, 2, 1, 3]) == [1, 1, 1, 2, 2, 3] assert frequency_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert frequency_sort([-1, -1, -2, -2, -2, 0]) == [-2, -2, -2, -1, -1, 0] ``` Notes - You can use any sorting algorithm that respects the constraints and efficiently organizes the numbers by their frequency. - You may find it useful to use collections like dictionaries or `collections.Counter` to count occurrences of each element in the list. - Make sure to return a new list that meets the sorting requirements.","solution":"from collections import Counter def frequency_sort(lst: list[int]) -> list[int]: Sorts the list by the frequency of the elements in descending order. If two elements have the same frequency, they should appear in ascending order. count = Counter(lst) # Sort by frequency first (descending) and then by element value (ascending) sorted_lst = sorted(lst, key=lambda x: (-count[x], x)) return sorted_lst"},{"question":"# Coding Question Problem Statement Implement a modified version of the binary search algorithm that, besides finding the target value, also counts the number of comparisons made during the search. You are required to implement both a recursive and an iterative version of this modified binary search algorithm. Requirements 1. **Recursive Version**: - Input: A sorted list of integers `nums` and an integer `target`. - Output: A tuple `(index, comparison_count)` where `index` is the position of the `target` in `nums` (or `-1` if `target` is not found), and `comparison_count` is the number of comparisons made during the search. 2. **Iterative Version**: - Input: A sorted list of integers `nums` and an integer `target`. - Output: A tuple `(index, comparison_count)` where `index` is the position of the `target` in `nums` (or `-1` if `target` is not found), and `comparison_count` is the number of comparisons made during the search. 3. **Constraints**: - The length of `nums` is between `0` and `10^6`. - Each integer in `nums` and the `target` can range from `-10^6` to `10^6`. 4. **Performance**: - Solutions should be efficient and handle the maximum input size comfortably. Example ```python # Recursive Version assert binary_search_recursive_count([1, 2, 3, 4, 5, 6, 7], 5) == (4, 3) assert binary_search_recursive_count([1, 2, 3, 4, 5, 6, 7], 8) == (-1, 3) # Iterative Version assert binary_search_iterative_count([1, 2, 3, 4, 5, 6, 7], 5) == (4, 3) assert binary_search_iterative_count([1, 2, 3, 4, 5, 6, 7], 8) == (-1, 3) ``` Implementation Details Please implement the following two functions: ```python def binary_search_recursive_count(nums: List[int], target: int, left: int = 0, right: int = None, count: int = 0) -> Tuple[int, int]: Perform binary search using a recursive method. Returns: (index, comparison_count): Tuple containing the index of the target and the number of comparisons. # Your code here def binary_search_iterative_count(nums: List[int], target: int) -> Tuple[int, int]: Perform binary search using an iterative method. Returns: (index, comparison_count): Tuple containing the index of the target and the number of comparisons. # Your code here ```","solution":"from typing import List, Tuple def binary_search_recursive_count(nums: List[int], target: int, left: int = 0, right: int = None, count: int = 0) -> Tuple[int, int]: if right is None: right = len(nums) - 1 if left > right: return -1, count mid = (left + right) // 2 count += 1 if nums[mid] == target: return mid, count elif nums[mid] < target: return binary_search_recursive_count(nums, target, mid + 1, right, count) else: return binary_search_recursive_count(nums, target, left, mid - 1, count) def binary_search_iterative_count(nums: List[int], target: int) -> Tuple[int, int]: left, right = 0, len(nums) - 1 count = 0 while left <= right: mid = (left + right) // 2 count += 1 if nums[mid] == target: return mid, count elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1, count"},{"question":"# Problem Statement Write a function to implement the Merge Sort algorithm. The function should take a list of integers and return a new list that is sorted in ascending order. Illustrate a thorough understanding of the Divide and Conquer paradigm by implementing a recursive approach. # Guidelines 1. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: ``` 2. **Parameters**: - `arr`: A list of integers to be sorted. 3. **Returns**: - A new list of integers sorted in ascending order. 4. **Constraints**: - The input list may be empty or contain up to (10^5) integers. - Implement the merge operation correctly to handle duplicate values and negative integers. # Example ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] ``` # Notes - Use helper functions where necessary to maintain code clarity. - Ensure that the algorithm handles large inputs efficiently. - The solution should avoid modifying the input list and instead return a new sorted list. - Pay attention to the computational complexity and aim for (O(n log n)) performance. Implement the function and ensure it consistently handles corner cases and large datasets effectively.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Implements the merge sort algorithm to sort a list in ascending order. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A new list of integers sorted in ascending order. def merge(left: List[int], right: List[int]) -> List[int]: Helper function to merge two sorted halves. Parameters: left (List[int]): The left half of the list. right (List[int]): The right half of the list. Returns: List[int]: A merged and sorted list consisting of both halves. result = [] i = j = 0 # Merge the left and right parts while maintaining order while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Append remaining elements (if any) while i < len(left): result.append(left[i]) i += 1 while j < len(right): result.append(right[j]) j += 1 return result # Base case: a list of single element or empty list is already sorted if len(arr) <= 1: return arr # Divide the array into two parts mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"# Product of Array Except Self You are given an array of integers. Write a function to calculate the product of all the elements of the array except for the current element, without using division and in O(n) time complexity. # Task Write a function `product_except_self(nums)` that takes a list of integers and returns a list where each element is the product of all the elements of the input list except for the current element. # Input * `nums`: A list of integers. # Output * The function should return a list of integers representing the products as described. # Constraints 1. The length of the input list `nums` will be at least 2 and will not exceed `10^5`. 2. Each element of `nums` is an integer in the range `[-10^3, 10^3]`. # Example Assume the input list is: ```text [1, 2, 3, 4] ``` Explanation: * For the first element, 2 * 3 * 4 = 24 * For the second element, 1 * 3 * 4 = 12 * For the third element, 1 * 2 * 4 = 8 * For the fourth element, 1 * 2 * 3 = 6 The function should return: ```text [24, 12, 8, 6] ``` **Function signature:** ```python def product_except_self(nums: list[int]) -> list[int]: pass ```","solution":"def product_except_self(nums): Returns an array such that each element at index i of the array is the product of all the elements in the original array except for the element at index i. length = len(nums) # Initialize the answer array with 1s. answer = [1] * length # Calculate left-hand products for each element left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Calculate right-hand products and multiply with corresponding left-hand product right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"# Coding Challenge: Linked List Cycle Detection Problem Statement Given a linked list, your task is to determine if the list has a cycle in it. A linked list is said to have a cycle if any node is visited more than once during a traversal. Write a function: `has_cycle(head: ListNode) -> bool`: Determines if the linked list has a cycle. Specifications - **Input**: A variable `head`, which is the head of the linked list. - **Output**: A boolean value indicating whether the linked list has a cycle (True) or not (False). Constraints - The linked list length is arbitrary but can contain up to 10^4 nodes. - A linked list node is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Example Consider the following scenarios: 1. A linked list: 1 -> 2 -> 3 -> 4 -> 2 (cycle created with node 2). Calling `has_cycle(head)` should return `True`. 2. A linked list: 1 -> 2 -> 3 -> 4 -> None. Calling `has_cycle(head)` should return `False`. Solution Outline 1. Use two pointers, \\"slow\\" and \\"fast\\". The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. 2. If there is no cycle, the fast pointer will eventually reach the end of the list. 3. If there is a cycle, the fast pointer will eventually catch up to the slow pointer. Function Signature ```python def has_cycle(head: ListNode) -> bool: pass ``` **Note**: Ensure your solution handles all edge cases such as empty list, single-node list, and list with multiple nodes pointing to the same cycle. Optimize for performance considering the constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Determines if the linked list has a cycle. :param head: head node of the linked list :return: True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Binary Search Tree Insert In this exercise, you will implement the `binary_search_tree_insert` function, which adds a given value to a binary search tree (BST) and returns the updated tree. The function takes as input the root of the BST and the value to insert. The implementation should ensure that the BST properties are maintained after insertion. Function Signature ```python class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def binary_search_tree_insert(root: TreeNode, value: int) -> TreeNode: ``` Input: - `root`: The root node of an existing binary search tree. - `value`: An integer value to insert into the tree. Output: - The root node of the updated binary search tree. Constraints: 1. The tree must maintain its binary search tree properties following the insertion: - The left subtree of a node contains only nodes with keys less than the node’s key. - The right subtree of a node contains only nodes with keys greater than the node’s key. - Both the left and right subtrees must also be binary search trees. 2. If the tree is empty (i.e. the root is `None`), the new value should become the root of the tree. 3. Assume all values in the tree are unique. # Example Usage: ```python # Helper function to print the tree in-order def in_order_traversal(node: TreeNode): return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) if node else [] # Example 1: Insert into an empty tree root = None value = 5 new_root = binary_search_tree_insert(root, value) print(in_order_traversal(new_root)) # Expected output: [5] # Example 2: Insert into a tree with multiple elements root = TreeNode(10, TreeNode(5), TreeNode(15)) value = 12 new_root = binary_search_tree_insert(root, value) print(in_order_traversal(new_root)) # Expected output: [5, 10, 12, 15] # Example 3: Insert into a tree maintaining BST properties root = TreeNode(20, TreeNode(10), TreeNode(30)) value = 25 new_root = binary_search_tree_insert(root, value) print(in_order_traversal(new_root)) # Expected output: [10, 20, 25, 30] ``` # Implementation Notes: Your function should traverse the tree starting from the root, find the appropriate place to insert the new value while maintaining BST properties, and return the updated root node. Ensure to: - Include base cases to handle insertion in empty subtrees. - Avoid inserting duplicate values by constraints. - Provide clear and succinct code with comments explaining key steps.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def binary_search_tree_insert(root: TreeNode, value: int) -> TreeNode: Inserts a value into the BST and returns the updated tree root. if root is None: return TreeNode(value) if value < root.val: root.left = binary_search_tree_insert(root.left, value) elif value > root.val: root.right = binary_search_tree_insert(root.right, value) return root # Helper function for unit tests to check the structure of the BST def in_order_traversal(node: TreeNode): return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) if node else []"},{"question":"# Elevator Scheduling Algorithm You are developing an elevator scheduling algorithm for a skyscraper. The building has `N` floors, numbered `0` through `N-1`. The elevator is initially at floor `0`, and you are given a list of requests where each request is represented as a tuple with the starting floor and the destination floor. Your task is to determine the order in which the elevator should fulfill the requests to minimize the total distance traveled while ensuring that all requests are fulfilled. # Input Format - `N`: An integer representing the total number of floors in the building. - `requests`: A list of tuples, where each tuple contains two integers representing the starting floor and the destination floor of a request. # Output Format - Return a list of integers representing the sequence of floors the elevator visits to fulfill all the requests, starting from floor `0`. # Constraints - `2 <= N <= 100` - `1 <= len(requests) <= 100` - All floors and requests are valid (`0 <= start, dest < N`). # Example ```python N = 10 requests = [(3, 7), (1, 5), (9, 2), (4, 8)] # Example Output sequence = elevator_schedule(N, requests) # sequence could be [0, 1, 3, 5, 7, 4, 8, 9, 2] ``` Your task is to implement the function `elevator_schedule` that returns the optimal sequence of floors. # Implementation ```python def elevator_schedule(N, requests): # Your code here ``` Note: You can use any approach you deem appropriate to schedule the elevator efficiently, including but not limited to greedy algorithms, heuristic-based sorting, or other optimization techniques. The goal is to minimize total distance traveled by the elevator while fulfilling all requests.","solution":"def elevator_schedule(N, requests): Determines the order in which the elevator should fulfill the requests to minimize the total distance traveled. Args: - N: An integer representing the total number of floors in the building. - requests: A list of tuples, where each tuple contains two integers representing the starting floor and the destination floor of a request. Returns: - A list of integers representing the sequence of floors the elevator visits to fulfill all the requests, starting from floor `0`. # Starting from floor 0 current_floor = 0 # To keep track of the sequence of floors sequence = [current_floor] # Combine starting and destination floors into a single list and sort them floors_to_visit = set() for start, dest in requests: floors_to_visit.add(start) floors_to_visit.add(dest) # Convert to list and sort for simpler processing floors_to_visit = list(floors_to_visit) floors_to_visit.sort() # Move upwards first, then downwards for floor in floors_to_visit: sequence.append(floor) return sequence"},{"question":"# Problem Statement Develop a function that returns the maximum depth (or height) of a binary tree. This problem will test your understanding of tree data structures and depth-first search algorithms. # Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` # Input - A binary tree root node `root` (class `TreeNode` is defined below). The definition of `TreeNode` is provided as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` - Constraints: The number of nodes in the tree is in the range `[0, 10^4]`, and each node\'s value is in the range `[-10^5, 10^5]`. # Output - Return an integer representing the maximum depth of the tree. # Example ```python # Example 1: # Input: # 3 # / # 9 20 # / # 15 7 # # Output: 3 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) assert max_depth(root) == 3 # Example 2: # Input: # # 1 # # 2 # # Output: 2 root = TreeNode(1) root.right = TreeNode(2) assert max_depth(root) == 2 ``` # Explanation - The depth of the binary tree is defined as the number of edges from the root node to the deepest leaf node. - For an empty tree, the depth is 0. - For the tree with only one node, the depth is 1. - You need to implement a function that uses a depth-first search approach (either iterative using a stack or recursive) to determine the maximum depth of the tree. # Notes - Make sure the function handles edge cases such as an empty tree and single-node tree correctly. - Pay attention to the efficiency of your solution, as the number of nodes can be fairly large.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth (or height) of a binary tree. if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Problem Statement: You are provided with a class, `BinarySearchTree`, that implements a simple Binary Search Tree (BST). Your task is to extend this class with the following functionalities: 1. **find_kth_smallest(k)**: Implement a method to find the k-th smallest element in the BST. If k is out of bounds, return `-1`. 2. **is_balanced()**: Implement a method to check whether the BST is height-balanced. A height-balanced BST is a binary tree in which the depth of the two subtrees of every node never differs by more than one. The method should return `True` if the tree is balanced and `False` otherwise. # Expected Input and Output Formats: * For `find_kth_smallest(k)`: * **Input**: * `k` (int): The k-th position. * **Output**: * Returns an integer representing the k-th smallest element in the BST or `-1` if k is out of bounds. * For `is_balanced()`: * **Output**: * Returns either `True` or `False`. # Constraints: 1. Each node in the BST contains unique integers. 2. The number of nodes in the BST can be up to `N = 10^4`. # Example: ```python bst = BinarySearchTree() bst.insert(4) bst.insert(2) bst.insert(6) bst.insert(1) bst.insert(3) bst.insert(5) bst.insert(7) print(bst.find_kth_smallest(3)) # 3 print(bst.is_balanced()) # True bst.insert(0) bst.insert(-1) print(bst.is_balanced()) # False ``` # Solution Template: You may extend the class `BinarySearchTree` provided below. ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def inorder_traversal(self): return self._inorder_traversal(self.root, []) def _inorder_traversal(self, root, result): if root is not None: self._inorder_traversal(root.left, result) result.append(root.val) self._inorder_traversal(root.right, result) return result def find_kth_smallest(self, k): # Implement finding k-th smallest element pass def is_balanced(self): # Implement balance checking pass bst = BinarySearchTree() bst.insert(4) bst.insert(2) bst.insert(6) bst.insert(1) bst.insert(3) bst.insert(5) bst.insert(7) print(bst.find_kth_smallest(3)) # Expected: 3 print(bst.is_balanced()) # Expected: True bst.insert(0) bst.insert(-1) print(bst.is_balanced()) # Expected: False ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def inorder_traversal(self): return self._inorder_traversal(self.root, []) def _inorder_traversal(self, root, result): if root is not None: self._inorder_traversal(root.left, result) result.append(root.val) self._inorder_traversal(root.right, result) return result def find_kth_smallest(self, k): inorder_result = self.inorder_traversal() if k <= 0 or k > len(inorder_result): return -1 return inorder_result[k - 1] def is_balanced(self): def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, balance = height_and_balance(self.root) return balance"},{"question":"Question: Sum of Divisors Write a function that calculates the sum of all positive divisors of a given non-negative integer. Your function should be efficient and handle large inputs within reasonable time limits. # Function Signature ```python def sum_of_divisors(number: int) -> int: pass ``` # Input - An integer `number` (0 ≤ number ≤ 10^9). # Output - An integer representing the sum of all positive divisors of `number`. # Constraints - The function should raise a `ValueError` if `number` is negative. # Example ```python assert sum_of_divisors(0) == 0 assert sum_of_divisors(1) == 1 assert sum_of_divisors(6) == 12 assert sum_of_divisors(28) == 56 assert sum_of_divisors(100) == 217 try: sum_of_divisors(-1) except ValueError: print(\\"ValueError caught as expected\\") ``` # Notes - The sum of divisors includes the number itself (e.g., divisors of 28 are 1, 2, 4, 7, 14, 28). - Handle edge cases, such as very small and very large numbers, to ensure your function is robust. - Consider optimizations to avoid checking every number up to `number`, leveraging mathematical properties to reduce the number of checks. - Implement an efficient approach to handle large numbers in reasonable time. Explore the problem to deepen your understanding of divisors and optimization techniques in integer factorization.","solution":"def sum_of_divisors(number: int) -> int: Return the sum of all positive divisors of the given number. :param number: A non-negative integer. :return: Sum of all positive divisors of the given number. :raises ValueError: If the input number is negative. if number < 0: raise ValueError(\\"The number must be non-negative.\\") if number == 0: return 0 total = 0 sqrt_num = int(number**0.5) for i in range(1, sqrt_num + 1): if number % i == 0: total += i if i != number // i: total += number // i return total"},{"question":"# Question: Implementing Unique Words Counter in a Text Your task is to implement a function that processes a list of text paragraphs and returns a dictionary containing the count of unique words per paragraph. A word is defined as a sequence of alphanumeric characters. Words are case-insensitive, i.e., \'Hello\' and \'hello\' should be considered the same word. # Function Signature ```python def count_unique_words(paragraphs: List[str]) -> List[Dict[str, int]]: Count unique words in each paragraph from a list of paragraphs. :param paragraphs: List[str] - A list of strings where each string represents a paragraph of text. :return: List[Dict[str, int]] - A list of dictionaries where each dictionary contains unique words as keys and their counts as values for the corresponding paragraph. >>> count_unique_words([\\"Hello world\\", \\"Hello hello world\\"]) [{\'hello\': 1, \'world\': 1}, {\'hello\': 2, \'world\': 1}] >>> count_unique_words([\\"Python is great!\\", \\"I love Python. Python is awesome!\\"]) [{\'python\': 1, \'is\': 1, \'great\': 1}, {\'i\': 1, \'love\': 1, \'python\': 2, \'is\': 1, \'awesome\': 1}] ``` # Input - `paragraphs`: A list of strings, where each string contains a paragraph of text. # Output - A list of dictionaries, where each dictionary contains words as keys and their counts as values for the corresponding paragraph. # Constraints - Each paragraph will contain at most 10,000 characters. - The input list will contain at most 1,000 paragraphs. # Example ```python paragraphs = [\\"Hello world\\", \\"Hello hello world\\"] output = count_unique_words(paragraphs) # Expected output: [{\'hello\': 1, \'world\': 1}, {\'hello\': 2, \'world\': 1}] ``` # Notes: - Ensure that words are counted in a case-insensitive manner. - Punctuation and special characters should be ignored when extracting words. - Use regular expressions or string methods to process the text and extract words. ```python from typing import List, Dict import re from collections import defaultdict def count_unique_words(paragraphs: List[str]) -> List[Dict[str, int]]: results = [] for paragraph in paragraphs: word_count = defaultdict(int) words = re.findall(r\'bw+b\', paragraph.lower()) for word in words: word_count[word] += 1 results.append(dict(word_count)) return results ```","solution":"from typing import List, Dict import re from collections import defaultdict def count_unique_words(paragraphs: List[str]) -> List[Dict[str, int]]: results = [] for paragraph in paragraphs: word_count = defaultdict(int) # Using regex to extract words and convert them to lowercase words = re.findall(r\'bw+b\', paragraph.lower()) for word in words: word_count[word] += 1 results.append(dict(word_count)) return results"},{"question":"# Coding Assessment Question Context Huffman coding is a popular algorithm for lossless data compression. It uses variable-length codes to represent characters, with shorter codes assigned to more frequent characters. Your task is to implement a basic version of Huffman coding to encode a given string and decode it back to its original form. Task Implement a class `HuffmanCoding` with two methods: 1. `encode(data: str) -> str`: Encodes the input string `data` using Huffman coding and returns the encoded binary string. 2. `decode(encoded_data: str) -> str`: Decodes the input binary string `encoded_data` back to the original string. Class Signature ```python class HuffmanCoding: def encode(self, data: str) -> str: pass def decode(self, encoded_data: str) -> str: pass ``` Input * `data`: A string which represents the input data to be compressed (for the `encode` method). * `encoded_data`: A binary string representing the Huffman encoded data (for the `decode` method). Output * The `encode` method returns a binary string which is the Huffman code for `data`. * The `decode` method returns the original string that was encoded into `encoded_data`. Example ```python hc = HuffmanCoding() encoded = hc.encode(\\"huffman coding is fun\\") original = hc.decode(encoded) print(encoded) # Output might look something like: \'111011000101...\' print(original) # Output: \'huffman coding is fun\' ``` Constraints * The input string `data` length should not exceed (10^5) characters. * The characters in the input string `data` will be standard ASCII characters. Performance Requirements * Ensure your implementation is efficient. The encoding and decoding process should run with a time complexity of (O(n log n)), where (n) is the length of `data`. * The space complexity should be manageable, with the space needed to store the Huffman tree and the encoded string being the primary considerations.","solution":"import heapq from collections import defaultdict, Counter class HuffmanCoding: def build_huffman_tree(self, frequency): heap = [[weight, [char, \\"\\"]] for char, weight in frequency.items()] heapq.heapify(heap) while len(heap) > 1: low = heapq.heappop(heap) high = heapq.heappop(heap) for pair in low[1:]: pair[1] = \'0\' + pair[1] for pair in high[1:]: pair[1] = \'1\' + pair[1] heapq.heappush(heap, [low[0] + high[0]] + low[1:] + high[1:]) return sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[-1]), p)) def encode(self, data: str) -> str: if not data: return \\"\\" frequency = Counter(data) huffman_tree = self.build_huffman_tree(frequency) self.huff_code = {char: code for char, code in huffman_tree} encoded_data = \'\'.join(self.huff_code[char] for char in data) return encoded_data def decode(self, encoded_data: str) -> str: if not encoded_data: return \\"\\" decoded_str = [] current_code = \\"\\" reverse_huff_code = {v: k for k, v in self.huff_code.items()} for bit in encoded_data: current_code += bit if current_code in reverse_huff_code: decoded_str.append(reverse_huff_code[current_code]) current_code = \\"\\" return \'\'.join(decoded_str) # Example Usage # hc = HuffmanCoding() # encoded = hc.encode(\\"huffman coding is fun\\") # original = hc.decode(encoded) # print(encoded) # Output might look something like: \'111011000101...\' # print(original) # Output: \'huffman coding is fun\'"},{"question":"Binary Search Tree Operations You are required to implement basic operations on a Binary Search Tree (BST) using your preferred programming language (e.g., Python). A BST is a tree data structure in which each node has at most two children, referred to as the left child and the right child. For each node, the left child has a value less than or equal to its parent node, and the right child has a value greater than its parent node. Problem Statement Write a class `BinarySearchTree` that supports the following operations: 1. Insert a value into the BST. 2. Check if a value exists in the BST. 3. Perform an in-order traversal of the BST. Requirements: 1. **Insert a value**: - Method name: `insert` - Input: An integer value to be inserted. - Output: None. 2. **Check existence of a value**: - Method name: `exists` - Input: An integer value to be checked. - Output: A boolean indicating if the value exists in the BST. 3. **In-order traversal**: - Method name: `in_order_traversal` - Input: None. - Output: A list of values representing the in-order traversal of the BST. Class structure: ```python class BinarySearchTree: def __init__(self): # Initialize your BST here pass def insert(self, value): # Insert value into the BST pass def exists(self, value): # Check if value exists in the BST pass def in_order_traversal(self): # Perform in-order traversal of the BST pass ``` Example Usage: ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(7) print(bst.exists(7)) # Output: True print(bst.exists(3)) # Output: False print(bst.in_order_traversal()) # Output: [2, 5, 7, 10, 15] ``` Constraints: - The values for insertion will be unique and always integers. - The BST will not exceed 10,000 nodes. - Methods should execute in efficient time complexity: average O(log n) for insert and exists, O(n) for traversal. Hints: - Use recursive functions to help with insertion and search operations. - Implement a nested class for the tree nodes if needed. - Ensure your in-order traversal returns values sorted in ascending order.","solution":"class BinarySearchTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = self.Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, current_node, value): if value <= current_node.value: if current_node.left: self._insert_recursive(current_node.left, value) else: current_node.left = self.Node(value) else: if current_node.right: self._insert_recursive(current_node.right, value) else: current_node.right = self.Node(value) def exists(self, value): return self._exists_recursive(self.root, value) def _exists_recursive(self, current_node, value): if not current_node: return False if value == current_node.value: return True elif value < current_node.value: return self._exists_recursive(current_node.left, value) else: return self._exists_recursive(current_node.right, value) def in_order_traversal(self): result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, current_node, result): if current_node: self._in_order_recursive(current_node.left, result) result.append(current_node.value) self._in_order_recursive(current_node.right, result)"},{"question":"Coding Assessment Question # Context As part of a network security system, you need to monitor and analyze packet transmissions over the network. One crucial aspect is to detect and flag unusual patterns in the network traffic. You decide to analyze the number of packets sent over a given time window and identify any significant spikes. # Task Implement a data structure and a function to efficiently track the number of packets sent within a sliding time window and identify any intervals where the packet count exceeds a given threshold. # Function Specifications **Function 1: Sliding Window Packet Tracker** - **Function Name**: `PacketTracker` - **Methods**: - `__init__(self, window_size: int)`: Initializes the tracker with a specified `window_size` (in seconds). - `add_packet(self, timestamp: float)`: Adds a packet with the given `timestamp` (in seconds since epoch). - `count_packets(self) -> int`: Returns the number of packets within the current time window. - `check_threshold(self, threshold: int) -> bool`: Checks if the number of packets within the current time window exceeds the given `threshold`. # Constraints - The `timestamp` input can be assumed to be in chronological order. - Aim for efficient handling of packet tracking, especially when the window contains many packets. # Performance Requirements - The `add_packet` and `count_packets` methods should aim for constant time complexity. - The `check_threshold` method should also operate efficiently within the constraints of a sliding window. # Example Usage ```python tracker = PacketTracker(window_size=60) # 60-second sliding window packets = [ 1620000100.0, # Packet at 1620000100.0 seconds 1620000120.0, # Packet at 1620000120.0 seconds 1620000150.0, # Packet at 1620000150.0 seconds 1620000165.0, # Packet at 1620000165.0 seconds 1620000200.0 # Packet at 1620000200.0 seconds ] for packet in packets: tracker.add_packet(packet) print(tracker.count_packets()) # Output based on the time window from the last packet timestamp print(tracker.check_threshold(2)) # Output: True if there are more than 2 packets within the last 60 seconds ``` # Notes - Ensure to handle edge cases such as adding a packet in the past which is no longer within the sliding window. - The timestamps are in Unix epoch time, so make sure to appropriately handle floating-point precision. - The sliding window must dynamically update as new packets are added, removing those that fall outside the current window.","solution":"from collections import deque import time class PacketTracker: def __init__(self, window_size: int): self.window_size = window_size self.packets = deque() def add_packet(self, timestamp: float): # Add the packet timestamp to the deque self.packets.append(timestamp) # Remove outdated packets current_time = time.time() while self.packets and self.packets[0] < current_time - self.window_size: self.packets.popleft() def count_packets(self) -> int: current_time = time.time() # Remove outdated packets while self.packets and self.packets[0] < current_time - self.window_size: self.packets.popleft() return len(self.packets) def check_threshold(self, threshold: int) -> bool: return self.count_packets() > threshold"},{"question":"# Problem Statement You have been asked to implement a feature for generating Fibonacci sequences in a software application. This feature should allow the user to request a sequence of Fibonacci numbers up to the nth number, where n is provided as input. The sequence starts from 0 and 1. Furthermore, your implementation must effectively handle large values of n by utilizing efficient algorithms to minimize computational overhead. Implement a function `fibonacci_sequence(n: int) -> List[int]` that performs the following: # Input: - `n` (int): The number of Fibonacci numbers to generate. # Output: - Return a list of integers representing the Fibonacci sequence up to the nth number. # Constraints: - 0 <= n <= 100000 - The function should handle edge cases where n is 0 or 1. - The function should efficiently handle large values of n by utilizing an iterative approach rather than a recursive one. # Requirements: 1. The returned sequence must start with 0 and 1, continuing up to the nth number in the Fibonacci sequence. 2. The function must efficiently compute the sequence for large values of n without resulting in excessive memory or computation time. # Example Usage: ```python >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Edge Cases: ```python >>> fibonacci_sequence(-1) Traceback (most recent call last): ... ValueError: The input should be a non-negative integer. >>> fibonacci_sequence(100000) # Expected to return a very large list of Fibonacci numbers efficiently. ``` # Note: - If the input n is negative, raise a `ValueError` with a descriptive error message. # Hints: - Consider using an iterative approach to avoid the high overhead associated with recursive solutions. - Use memoization techniques or iterative computation to handle large values of n efficiently.","solution":"def fibonacci_sequence(n): Returns a list containing the Fibonacci sequence up to the nth number. if n < 0: raise ValueError(\\"The input should be a non-negative integer.\\") if n == 0: return [] if n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Coding Assessment Question Context You work for a company that manages a large fleet of delivery vehicles. The company wants to optimize fuel consumption by predicting the fuel efficiency of its vehicles based on various parameters such as engine size, weight, and type of transmission. One way to achieve this is by using a k-Nearest Neighbors (k-NN) regression algorithm, which predicts the fuel efficiency of a vehicle based on the average fuel efficiencies of its k-nearest vehicles in the feature space. Task Write a function `predict_fuel_efficiency` that, given historical data about vehicles, their features, and a prediction point, computes the predicted fuel efficiency using k-Nearest Neighbors regression. # Function Signature ```python import numpy as np def predict_fuel_efficiency( x_train: np.ndarray, y_train: np.ndarray, prediction_point: np.ndarray, k: int ) -> float: Predicts the fuel efficiency of a vehicle based on historical data using k-Nearest Neighbors regression. Args: x_train: 2D ndarray of shape (m, n) representing the features of m historical vehicles. y_train: 1D ndarray of shape (m,) representing the fuel efficiencies of m historical vehicles (in miles per gallon). prediction_point: 1D ndarray of shape (n,) representing the features of the vehicle to be predicted. k: Integer representing the number of nearest neighbors to use for prediction. Returns: float: The predicted fuel efficiency of the vehicle at the prediction point. ``` # Input and Output Format - **Input**: - `x_train` : An array of shape `(m, n)` where `m` represents the number of training samples and `n` represents the number of features. Each row corresponds to the features of one vehicle. - `y_train` : An array of shape `(m,)` containing the historical fuel efficiencies corresponding to each vehicle in `x_train`. - `prediction_point` : An array of shape `(n,)`, representing the feature values of the vehicle you want to predict the fuel efficiency for. - `k` : An integer representing the number of nearest neighbors to use for the prediction. - **Output**: A float value representing the predicted fuel efficiency for the given `prediction_point`. # Constraints - Assume `1 <= m <= 10^6` and `1 <= n <= 100`. - The features and fuel efficiencies are non-negative floats. - `k` is a positive integer and `k <= m`. # Example ```python x_train = np.array([ [1.6, 1200, 1], [2.0, 1500, 1], [2.5, 1700, 0], [3.0, 2000, 0] ]) y_train = np.array([35, 30, 25, 22]) prediction_point = np.array([2.2, 1600, 1]) k = 2 predicted_efficiency = predict_fuel_efficiency(x_train, y_train, prediction_point, k) print(predicted_efficiency) # Expected output: a float value representing the predicted fuel efficiency ``` # Notes - You will need to use NumPy for efficient numerical operations. - Ensure that the average fuel efficiency calculation correctly uses the k-nearest neighbors from the training data. - Consider edge cases such as when all k-nearest neighbors are exactly equidistant from the prediction point. Hints 1. Calculate the Euclidean distance between the prediction point and each point in the training data to find the k-nearest neighbors. 2. Use the fuel efficiencies of the k-nearest neighbors to compute the average fuel efficiency.","solution":"import numpy as np def predict_fuel_efficiency( x_train: np.ndarray, y_train: np.ndarray, prediction_point: np.ndarray, k: int ) -> float: Predicts the fuel efficiency of a vehicle based on historical data using k-Nearest Neighbors regression. Args: x_train: 2D ndarray of shape (m, n) representing the features of m historical vehicles. y_train: 1D ndarray of shape (m,) representing the fuel efficiencies of m historical vehicles (in miles per gallon). prediction_point: 1D ndarray of shape (n,) representing the features of the vehicle to be predicted. k: Integer representing the number of nearest neighbors to use for prediction. Returns: float: The predicted fuel efficiency of the vehicle at the prediction point. # Compute Euclidean distances from prediction_point to all points in x_train distances = np.linalg.norm(x_train - prediction_point, axis=1) # Get the indices of the k smallest distances nearest_indices = np.argsort(distances)[:k] # Predict fuel efficiency by averaging the y_train values of the k nearest neighbors predicted_efficiency = np.mean(y_train[nearest_indices]) return predicted_efficiency"},{"question":"# Question Context Handling polynomials is a fundamental task in algebra and computer science. Implementing polynomial arithmetic operations is essential for various applications such as numerical methods and computer graphics. Problem Statement You are given two lists of integers representing the coefficients of two polynomials. The coefficients are ordered from the constant term to the highest degree term. Write a function that computes the product of these two polynomials and returns the coefficients of the resulting polynomial. # Function Signature ```python def polynomial_multiplication(poly1: list[int], poly2: list[int]) -> list[int]: Multiplies two polynomials represented by their coefficients. :param poly1: A list of integers representing the first polynomial\'s coefficients. :param poly2: A list of integers representing the second polynomial\'s coefficients. :return: A list of integers representing the coefficients of the resulting polynomial after multiplication. Example: >>> polynomial_multiplication([1, 2, 3], [4, 5]) [4, 13, 22, 15] ``` # Constraints: * The coefficients in the input lists can be negative, zero, or positive integers. * The input lists are guaranteed to be non-empty. * The output list should also contain the coefficients in the order from the constant term to the highest degree term. # Requirements: 1. **Function Implementation:** Correctly compute the coefficients of the product polynomial. 2. **Edge Case Handling:** Properly handle cases where one or more input polynomials have a single term. 3. **Input Validation:** Ensure that the input format is correct and handle incorrect formats gracefully. 4. **Performance:** Optimize the multiplication process to avoid unnecessary computations and ensure it scales well with the length of input lists. # Example: ```python >>> polynomial_multiplication([2], [3, 4]) [6, 8] >>> polynomial_multiplication([1, 0, -1], [1, 1]) [1, 1, -1, -1] ``` # Additional Notes: * Be careful with the indexing while calculating products of coefficients from both polynomials. * The degree of the resultant polynomial will be the sum of the degrees of the input polynomials.","solution":"def polynomial_multiplication(poly1, poly2): Multiplies two polynomials represented by their coefficients. :param poly1: A list of integers representing the first polynomial\'s coefficients. :param poly2: A list of integers representing the second polynomial\'s coefficients. :return: A list of integers representing the coefficients of the resulting polynomial after multiplication. # Initialize a result list with zeros of the required length result_length = len(poly1) + len(poly2) - 1 result = [0] * result_length # Perform the multiplication for i in range(len(poly1)): for j in range(len(poly2)): result[i + j] += poly1[i] * poly2[j] return result"},{"question":"# Scenario A software company is developing a new feature that allows users to create and manage events in a calendar. As part of this feature, they want to ensure that no two events overlap in time. Your task is to write a function that checks if a new event can be added to the calendar without causing any conflicts. # Objective Write a function `can_add_event` that determines if a new time interval can be added to a list of existing intervals without overlapping with any of them. # Specification **Function Signature**: ```python def can_add_event(intervals: List[Tuple[int, int]], new_interval: Tuple[int, int]) -> bool: pass ``` **Inputs**: * `intervals` (List[Tuple[int, int]]): A list of tuples where each tuple represents an existing time interval with a start and end time. The intervals are inclusive of their start time and exclusive of their end time. * `new_interval` (Tuple[int, int]): A tuple representing the new interval to be added, with a start time and end time. **Output**: * Returns a boolean value. Return `True` if the new interval can be added without overlapping any of the existing ones; otherwise, return `False`. # Constraints: * Each interval is represented by two integers: a start time and an end time. * `1 <= len(intervals) <= 10^5` * `0 <= intervals[i][0] < intervals[i][1] <= 10^9` * `0 <= new_interval[0] < new_interval[1] <= 10^9` # Example Usage: ```python print(can_add_event([(1, 5), (6, 10)], (5, 6))) # Expected Output: True print(can_add_event([(1, 3), (5, 8)], (4, 6))) # Expected Output: False print(can_add_event([], (2, 4))) # Expected Output: True print(can_add_event([(10, 20)], (15, 25))) # Expected Output: False ``` # Notes: - Consider edge cases where the new interval starts or ends exactly at the start or end time of an existing interval. - Optimize the function to handle the upper limits of the constraints efficiently.","solution":"from typing import List, Tuple def can_add_event(intervals: List[Tuple[int, int]], new_interval: Tuple[int, int]) -> bool: new_start, new_end = new_interval for start, end in intervals: if not (new_end <= start or new_start >= end): return False return True"},{"question":"# Problem Statement: Binomial Coefficient Using Dynamic Programming The binomial coefficient C(n, k) is the number of ways to choose a subset of k elements from a set of n elements without regard to the order of the elements. It is often read as \\"n choose k\\" and is given by the formula: [ C(n, k) = frac{n!}{k!(n - k)!} ] You are required to implement a function to compute the binomial coefficient using dynamic programming to efficiently handle larger values of n and k. # Implementation Details You need to define the following function within a class `BinomialCoefficient`: 1. **binomial_coefficient**: ```python def binomial_coefficient(self, n: int, k: int) -> int ``` - Computes the binomial coefficient C(n, k) using dynamic programming. - `n`: Total number of elements. - `k`: Number of elements to choose. - Returns the binomial coefficient for the given values of n and k. # Example Usage ```python bc = BinomialCoefficient() print(bc.binomial_coefficient(5, 2)) # Output: 10 print(bc.binomial_coefficient(10, 3)) # Output: 120 print(bc.binomial_coefficient(0, 0)) # Output: 1 print(bc.binomial_coefficient(100, 50)) # Should efficiently compute a large binomial coefficient ``` # Constraints - (0 leq k leq n leq 10^3) # Dynamic Programming Approach To compute the binomial coefficient efficiently, follow these steps: 1. Initialize a 2D array `C[n+1][k+1]` where `C[i][j]` will store the binomial coefficient C(i, j). 2. Populate the array using the following recursive relations: - Base Case: ( C(i, 0) = 1 text{ for all } i ) - Base Case: ( C(i, i) = 1 text{ for all } i ) - Recursive Case: ( C(i, j) = C(i-1, j-1) + C(i-1, j) ) # Implementation Implement the dynamic programming approach in the `binomial_coefficient` function and ensure that your solution efficiently handles the given constraints.","solution":"class BinomialCoefficient: def binomial_coefficient(self, n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using dynamic programming. if k > n: return 0 if k == 0 or k == n: return 1 # Initialize a 2D array to store computed values C = [[0] * (k + 1) for _ in range(n + 1)] # Calculate value for every entry for i in range(n + 1): for j in range(min(i, k) + 1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k]"},{"question":"# Introduction Tic-Tac-Toe is a classic two-player game played on a 3x3 grid. Players take turns marking a space in the grid with X or O. The first player to get three of their marks in a row (vertically, horizontally, or diagonally) wins. If all nine spaces are filled without a winner, the game is a draw. # Task Write a function named `check_tictactoe(board: List[List[str]]) -> str` that determines the status of a given Tic-Tac-Toe game board. # Requirements * **Function Signature**: `def check_tictactoe(board: List[List[str]]) -> str:` * **Input**: A 3x3 list of lists containing the characters \'X\', \'O\', or an empty string. * **Output**: A string: - Return `\'X\'` if player X has won. - Return `\'O\'` if player O has won. - Return `\'Draw\'` if the game is a draw. - Return `\'Pending\'` if the game is not yet complete. # Constraints 1. The input board will always be a 3x3 list of lists. 2. Board cells can contain \'X\', \'O\', or an empty string (\\"\\"). 3. Assume the input board is valid and players have taken alternate turns starting with \'X\'. # Examples ```python >>> check_tictactoe([ ... [\'X\', \'O\', \'X\'], ... [\'O\', \'X\', \'O\'], ... [\'O\', \'X\', \'X\'] ... ]) \'X\' >>> check_tictactoe([ ... [\'X\', \'O\', \'O\'], ... [\'O\', \'X\', \'X\'], ... [\'X\', \'O\', \'O\'] ... ]) \'Draw\' >>> check_tictactoe([ ... [\'X\', \'O\', \'\'], ... [\'O\', \'X\', \'\'], ... [\'\', \'\', \'\'] ... ]) \'Pending\' >>> check_tictactoe([ ... [\'X\', \'O\', \'O\'], ... [\'O\', \'X\', \'X\'], ... [\'O\', \'X\', \'X\'] ... ]) \'O\' ``` # Additional Notes * Test your function thoroughly with various board states. * Consider edge cases such as incomplete games and scenarios where no player wins. * The function should properly handle both completed and incomplete game boards.","solution":"from typing import List def check_tictactoe(board: List[List[str]]) -> str: # Check rows and columns for a win for i in range(3): if board[i][0] == board[i][1] == board[i][2] and board[i][0] != \'\': return board[i][0] if board[0][i] == board[1][i] == board[2][i] and board[0][i] != \'\': return board[0][i] # Check diagonals for a win if board[0][0] == board[1][1] == board[2][2] and board[0][0] != \'\': return board[0][0] if board[0][2] == board[1][1] == board[2][0] and board[0][2] != \'\': return board[0][2] # Check for pending or draw for row in board: if \'\' in row: return \'Pending\' return \'Draw\'"},{"question":"# Scenario You are developing a system to evaluate math expressions represented as strings. The expressions consist of non-negative integers and the basic arithmetic operators: addition (+) and multiplication (*). Operator precedence must be taken into account: multiplication has higher precedence than addition. For example, \\"2+3*4\\" should be evaluated as 2 + (3 * 4) = 14. # Task Write a function `evaluate_expression(expression: str) -> int` that takes a string representing a mathematical expression and returns its evaluated result as an integer. # Constraints * The input string will only contain non-negative integers (0-9) and the operators \'+\' and \'*\'. * All operations are to be performed with proper precedence. * The input string will be a valid expression. # Input and Output Formats * Input: A string `expression` representing the mathematical expression. * Output: An integer representing the result of the evaluated expression. # Example Input ```python >>> evaluate_expression(\\"2+3*4\\") 14 ``` ```python >>> evaluate_expression(\\"7+2*2\\") 11 ``` ```python >>> evaluate_expression(\\"1+2*3+4\\") 11 ``` # Edge Cases 1. Single number: ```python >>> evaluate_expression(\\"7\\") 7 ``` 2. Single addition: ```python >>> evaluate_expression(\\"2+3\\") 5 ``` 3. Single multiplication: ```python >>> evaluate_expression(\\"4*5\\") 20 ``` 4. Multiple additions and multiplications: ```python >>> evaluate_expression(\\"2*3+4*5\\") 26 # (2*3) + (4*5) ``` 5. Complex expression mixing additions and multiplications: ```python >>> evaluate_expression(\\"3+2*2+3*3\\") 16 # 3 + (2*2) + (3*3) ``` Ensure your function handles these scenarios correctly.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of non-negative integers and the operators \'+\' and \'*\', considering operator precedence. def tokenize(expr): tokens = [] num = 0 for char in expr: if char.isdigit(): num = num * 10 + int(char) else: tokens.append(num) tokens.append(char) num = 0 tokens.append(num) return tokens tokens = tokenize(expression) num_stack = [] op_stack = [] precedence = {\'+\': 1, \'*\': 2} def apply_operator(ops, values): right = values.pop() left = values.pop() op = ops.pop() if op == \'+\': values.append(left + right) elif op == \'*\': values.append(left * right) for token in tokens: if isinstance(token, int): num_stack.append(token) else: while (op_stack and precedence[op_stack[-1]] >= precedence[token]): apply_operator(op_stack, num_stack) op_stack.append(token) while op_stack: apply_operator(op_stack, num_stack) return num_stack.pop()"},{"question":"# Problem Statement You are tasked with implementing a WordDictionary class that supports adding new words and finding words with dot (`.`) as a wildcard character that can match any single letter. # Requirements 1. **Initialization:** - Initialize the `WordDictionary`. 2. **Operations:** - **addWord(word)**: Adds a word into the data structure. - **search(word)**: Returns `True` if the word (with support for wildcard `.`) is in the data structure. # Input Format - A sequence of operations and their values. # Output Format - For an **addWord** operation, return nothing. - For a **search** operation, return `True` or `False`. # Constraints - All words are strings consisting of lowercase letters and the dot character. - The dot character `.` represents any one lowercase letter. - Operations are provided in the form of a list of tuples, where each tuple contains the operation name and necessary parameters. - The length of all provided words is non-negative and does not exceed 50. # Example ```python # Sequence of operations operations = [ (\\"addWord\\", \\"bad\\"), (\\"addWord\\", \\"dad\\"), (\\"addWord\\", \\"mad\\"), (\\"search\\", \\"pad\\"), # False (\\"search\\", \\"bad\\"), # True (\\"search\\", \\".ad\\"), # True (\\"search\\", \\"b..\\"), # True ] word_dictionary = WordDictionary() for operation in operations: if operation[0] == \\"addWord\\": word_dictionary.addWord(operation[1]) elif operation[0] == \\"search\\": print(word_dictionary.search(operation[1])) # Output as per the comment ``` # Boilerplate Code Implement the required methods in the provided class: ```python class WordDictionary: def __init__(self) -> None: # Initialize any data structures needed ... def addWord(self, word: str) -> None: # Adds a word into the data structure ... def search(self, word: str) -> bool: # Returns True if the word with support for wildcard is in the data structure ... ```","solution":"class WordDictionary: def __init__(self) -> None: self.trie = {} def addWord(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True # Mark the end of a word def search(self, word: str) -> bool: def dfs(node, i): if i == len(word): return \'#\' in node if word[i] == \'.\': for key in node: if key != \'#\' and dfs(node[key], i + 1): return True return False return word[i] in node and dfs(node[word[i]], i + 1) return dfs(self.trie, 0)"},{"question":"Distance Calculation between Two Points in a 2D Plane In this exercise, you are tasked with implementing a function to calculate the Euclidean distance between two points in a 2D plane. Each point is represented as a tuple of two integers, representing the x and y coordinates. # Function Signature ```python def calculate_distance(point1: tuple, point2: tuple) -> float: pass ``` # Input * `point1` (tuple): A tuple of two integers (x1, y1) representing the coordinates of the first point. * `point2` (tuple): A tuple of two integers (x2, y2) representing the coordinates of the second point. # Output * **Returns** (float): The Euclidean distance between the two points. # Constraints * The coordinates of the points should be valid integers. * The function should handle large integer values efficiently. # Examples ```python >>> calculate_distance((0, 0), (3, 4)) 5.0 >>> calculate_distance((1, 1), (4, 5)) 5.0 >>> calculate_distance((2, 3), (2, 3)) 0.0 >>> calculate_distance((-1, -1), (2, 3)) 5.0 ``` # Guidelines 1. **Euclidean Distance Formula**: Utilize the formula `sqrt((x2-x1)^2 + (y2-y1)^2)` to compute the distance. 2. **Handling Edge Cases**: Ensure your function handles cases where the points are the same, which should return a distance of `0.0`. **Tasks**: 1. Implement the `calculate_distance` function based on the provided specifications. 2. Ensure your implementation is efficient and handles edge cases correctly. --- This question complements the initial question set by challenging the candidate to implement basic mathematical computations involving tuples and floating-point arithmetic in Python.","solution":"import math def calculate_distance(point1: tuple, point2: tuple) -> float: Calculate the Euclidean distance between two points in a 2D plane. Parameters: point1 (tuple): A tuple containing the x and y coordinates of the first point (x1, y1). point2 (tuple): A tuple containing the x and y coordinates of the second point (x2, y2). Returns: float: The Euclidean distance between the two points. x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)"},{"question":"# Problem Statement You are tasked with writing a function that simulates the behavior of an ATM machine. The function will manage deposits, withdrawals, and balance inquiries. It should handle multiple transactions while ensuring that overdraft does not occur. Function Signature ```python def atm_simulation(commands: list) -> list: ``` Input - `commands` (list of tuples): Each tuple contains two elements. - The first element is a string representing the command, which can be one of `\\"DEPOSIT\\"`, `\\"WITHDRAW\\"`, or `\\"BALANCE\\"`. - The second element is an integer representing the amount for `\\"DEPOSIT\\"` and `\\"WITHDRAW\\"` commands. For the `\\"BALANCE\\"` command, this will be ignored and can be any integer. Output - `list`: A list of integers representing the results of `\\"BALANCE\\"` commands, in the order they were issued. Constraints - The initial balance is 0. - Each `DEPOSIT` and `WITHDRAW` amount is a positive integer. - The function should ensure that no withdrawal leads to a negative balance. Ignore such withdrawal transactions. # Examples ```python assert atm_simulation([(\\"DEPOSIT\\", 100), (\\"BALANCE\\", 0), (\\"WITHDRAW\\", 50), (\\"BALANCE\\", 0), (\\"WITHDRAW\\", 100), (\\"BALANCE\\", 0)]) == [100, 50, 50] assert atm_simulation([(\\"DEPOSIT\\", 200), (\\"WITHDRAW\\", 100), (\\"BALANCE\\", 0), (\\"WITHDRAW\\", 50), (\\"BALANCE\\", 0), (\\"WITHDRAW\\", 60), (\\"BALANCE\\", 0)]) == [100, 50, 50] assert atm_simulation([(\\"BALANCE\\", 0)]) == [0] assert atm_simulation([(\\"WITHDRAW\\", 50), (\\"BALANCE\\", 0), (\\"DEPOSIT\\", 50), (\\"WITHDRAW\\", 30), (\\"BALANCE\\", 0)]) == [0, 20] ``` # Error Cases - Since the inputs are guaranteed to follow the described format and constraints, no explicit error handling is necessary. # Explanation Your task is to implement the given function such that it accurately maintains the balance of the ATM based on a sequence of transactions while respecting the overdraft constraint. Track and return the results of balance inquiries in the order they are received.","solution":"def atm_simulation(commands): balance = 0 results = [] for command, amount in commands: if command == \\"DEPOSIT\\": balance += amount elif command == \\"WITHDRAW\\": if balance >= amount: balance -= amount elif command == \\"BALANCE\\": results.append(balance) return results"},{"question":"# Problem Statement You are given a positive integer `n`. Your task is to write a function `super_digit(n: int) -> int` that computes the \\"super digit\\" of `n`. The \\"super digit\\" is calculated as follows: 1. If the number `n` has only one digit, then that digit is the super digit. 2. Otherwise, the super digit of `n` is the super digit of the sum of its digits. # Function Signature ```python def super_digit(n: int) -> int: pass ``` # Input - `n` (1 ≤ n ≤ 10^100000): a very large integer represented as a string. # Output - An integer representing the super digit of `n`. # Examples ```python >>> super_digit(\'148\') 4+8=12 → 1+2=3 3 >>> super_digit(\'9875\') 9+8+7+5=29 → 2+9=11 → 1+1=2 2 >>> super_digit(\'123456789\') 1+2+3+4+5+6+7+8+9=45 → 4+5=9 9 >>> super_digit(\'1\') 1 1 >>> super_digit(\'9999\') 9+9+9+9=36 → 3+6=9 9 ``` # Constraints - The input `n` can be a very large number represented as a string. - Consider both time and space complexities in your implementation. # Implementation Details - You should recursively sum the digits until a single digit is obtained. - Efficiently handle large sums without converting the entire number back and forth repeatedly.","solution":"def super_digit(n: str) -> int: Returns the super digit of the given large integer represented as a string. :param n: A large integer represented as a string. :return: The super digit of n. if len(n) == 1: return int(n) digit_sum = sum(int(digit) for digit in n) return super_digit(str(digit_sum))"},{"question":"# Question: Currency Exchange Function You are tasked with implementing a function to convert an amount of money from one currency to another using given exchange rates. Function: `currency_exchange(amount: float, source_currency: str, target_currency: str, exchange_rates: dict) -> float` Implement a function that takes an input amount in the source currency and converts it to the target currency using the provided exchange rates. **Inputs:** - `amount (float)`: A floating-point number representing the amount of money in the source currency. - `source_currency (str)`: A string representing the source currency code (e.g., \\"USD\\"). - `target_currency (str)`: A string representing the target currency code (e.g., \\"EUR\\"). - `exchange_rates (dict)`: A dictionary containing exchange rates with currency codes as keys and their corresponding rates relative to a common base currency as values. **Outputs:** - `float`: The equivalent amount in the target currency, rounded to two decimal places. **Constraints:** - The input amount must be greater than or equal to 0. - The currency codes must be valid three-letter ISO currency codes. - The exchange rates dictionary must contain valid rates for both the source and target currencies. Input Examples: - `amount: 100.0`, `source_currency: \\"USD\\"`, `target_currency: \\"EUR\\"`, `exchange_rates: {\\"USD\\": 1.0, \\"EUR\\": 0.85}` - `amount: 50.0`, `source_currency: \\"GBP\\"`, `target_currency: \\"JPY\\"`, `exchange_rates: {\\"GBP\\": 1.4, \\"JPY\\": 110.0}` Output Examples: - `85.00` - `3928.57` Requirements 1. You must handle edge cases, such as invalid currency codes or missing exchange rates. 2. Ensure precision in floating-point arithmetic to avoid errors in conversion. 3. Implement proper error conditions where inputs do not meet expected formats or ranges. Examples Example 1: ```python >>> currency_exchange(100.0, \\"USD\\", \\"EUR\\", {\\"USD\\": 1.0, \\"EUR\\": 0.85}) 85.00 >>> currency_exchange(50.0, \\"GBP\\", \\"JPY\\", {\\"GBP\\": 1.4, \\"JPY\\": 110.0}) 3928.57 ``` Write the implementation of the function ensuring it fulfills the requirements and handles all edge cases appropriately.","solution":"def currency_exchange(amount: float, source_currency: str, target_currency: str, exchange_rates: dict) -> float: Converts an amount from source currency to target currency using given exchange rates. Parameters: amount (float): The amount of money in the source currency. source_currency (str): The source currency code. target_currency (str): The target currency code. exchange_rates (dict): A dictionary containing exchange rates. Returns: float: The equivalent amount in the target currency, rounded to two decimal places. # Validate inputs if amount < 0: raise ValueError(\\"Amount must be greater than or equal to 0.\\") if source_currency not in exchange_rates or target_currency not in exchange_rates: raise ValueError(\\"Invalid currency code or exchange rate not available.\\") # Convert source amount to base currency using source exchange rate base_currency_amount = amount / exchange_rates[source_currency] # Convert base currency amount to target currency using target exchange rate target_amount = base_currency_amount * exchange_rates[target_currency] # Return the target amount rounded to two decimal places return round(target_amount, 2)"},{"question":"# Knapsack Problem with Integer Weights **Context**: The Knapsack problem is a classic optimization problem that involves selecting a subset of items to maximize the total value without exceeding the capacity of the knapsack. It has applications in resource allocation, financial modeling, and decision making. **Objective**: Implement a function that solves the 0/1 Knapsack problem using dynamic programming. **Function Signature**: ```python def knapsack(weights: List[int], values: List[int], capacity: int) -> int: pass ``` **Input**: - `weights`: A list of integers representing the weights of each item. - `values`: A list of integers representing the values of each item. - `capacity`: An integer representing the maximum capacity of the knapsack. **Output**: - An integer representing the maximum total value that can be achieved without exceeding the knapsack\'s capacity. **Constraints**: - The length of `weights` and `values` is the same and will be between 1 and 1000. - Each weight and value is a positive integer, and the capacity of the knapsack is a positive integer and will be in the range 1 to 5000. **Requirements**: - Use dynamic programming to solve the problem efficiently. - Ensure the function returns the correct maximum total value. **Example**: ```python weights = [2, 3, 4, 5] values = [3, 4, 5, 6] capacity = 5 assert knapsack(weights, values, capacity) == 7 ``` **Explanation**: - Items: [ (weight: 2, value: 3), (weight: 3, value: 4), (weight: 4, value: 5), (weight: 5, value: 6) ] - Capacity: 5 - The optimal selection is the first and second items (weights 2 and 3), with a total value of 3 + 4 = 7. Implement the function `knapsack` to correctly determine the maximum value that can be achieved within the given capacity using dynamic programming.","solution":"from typing import List def knapsack(weights: List[int], values: List[int], capacity: int) -> int: Solves the 0/1 Knapsack problem using dynamic programming. Arguments: weights -- A list of integers representing the weights of each item. values -- A list of integers representing the values of each item. capacity -- An integer representing the maximum capacity of the knapsack. Returns: An integer representing the maximum total value that can be achieved without exceeding the knapsack\'s capacity. num_items = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(num_items + 1)] for i in range(1, num_items + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[num_items][capacity]"},{"question":"# Sorting a Linked List In this exercise, you will implement the `merge_sort_linked_list` function to sort a singly linked list using the merge sort algorithm. This algorithm should efficiently sort the list in ascending order by splitting the list into smaller lists and then merging them. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: ``` Input: - `head`: The head of a singly linked list to be sorted. Output: - The head of a new singly linked list that is sorted in ascending order. Constraints: 1. The function should work for linked lists containing integers. 2. The linked list can be of any length, including zero. 3. Your implementation should operate in O(n log n) time complexity. Performance Requirements: - Efficiently handle the merging of two sorted halves of the linked list. - Split the linked list into halves without creating new nodes (in-place splitting). - Ensure the space complexity remains as low as possible, ideally O(1) additional space. # Example Usage: ```python # Helper function to create a linked list from a list def create_linked_list(arr): head = ListNode(arr[0]) if arr else None current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head # Helper function to print a linked list def print_linked_list(head): current = head while current: print(current.value, end=\\" -> \\" if current.next else \\"n\\") current = current.next # Example 1: Already sorted list head = create_linked_list([1, 2, 3, 4, 5]) sorted_head = merge_sort_linked_list(head) print_linked_list(sorted_head) # Expected output: 1 -> 2 -> 3 -> 4 -> 5 # Example 2: Reverse order list head = create_linked_list([5, 4, 3, 2, 1]) sorted_head = merge_sort_linked_list(head) print_linked_list(sorted_head) # Expected output: 1 -> 2 -> 3 -> 4 -> 5 # Example 3: Random order list head = create_linked_list([4, 2, 5, 1, 3]) sorted_head = merge_sort_linked_list(head) print_linked_list(sorted_head) # Expected output: 1 -> 2 -> 3 -> 4 -> 5 ``` # Implementation Notes: Your function should correctly split the linked list into two halves, recursively sort each half, and then merge the sorted halves back together. Ensure to: - Include necessary helper functions within the `merge_sort_linked_list` function for splitting and merging lists. - Manage the pointers carefully to avoid memory issues or infinite loops. - Provide a clear and well-commented code for readability and maintainability.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def find_middle(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow def merge_lists(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next def merge_sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head middle = find_middle(head) next_to_middle = middle.next middle.next = None left_side = merge_sort_linked_list(head) right_side = merge_sort_linked_list(next_to_middle) sorted_list = merge_lists(left_side, right_side) return sorted_list"},{"question":"# Query an Employee Database - Average Salary by Department **Scenario**: As a data analyst for a mid-size company, you are often tasked with generating reports on various metrics related to employee performance and compensation. One common report is the average salary within each department. **Problem**: Implement the function `calculate_average_salary_by_department(employees: List[Dict[str, str]]) -> Dict[str, float]` that calculates the average salary for each department. The function takes a list of dictionaries representing employees and their attributes and returns a dictionary where keys are department names and values are the average salary for that department, rounded to two decimal places. **Input**: * `employees`: A list of dictionaries, where each dictionary contains the following keys: - `name` (string): The name of the employee. - `department` (string): The department the employee belongs to. - `salary` (float): The salary of the employee. **Output**: * A dictionary where each key is a department name (string) and the corresponding value is the average salary (float, rounded to two decimal places) of employees in that department. **Constraints**: * The input list will contain at least one employee. * Employees list will contain no more than 1000 entries. * Each employee has a unique name and belongs to exactly one department. **Example**: ```python employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000.0}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000.0}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\", \\"salary\\": 50000.0}, {\\"name\\": \\"David\\", \\"department\\": \\"Executive\\", \\"salary\\": 150000.0}, {\\"name\\": \\"Eve\\", \\"department\\": \\"HR\\", \\"salary\\": 60000.0}, ] result = calculate_average_salary_by_department(employees) print(result) # Output should be {\'Engineering\': 105000.0, \'HR\': 55000.0, \'Executive\': 150000.0} ``` **Requirements**: * Your code should be efficient and easy to read. * Ensure the result is accurate to two decimal places for the average salaries.","solution":"from typing import List, Dict def calculate_average_salary_by_department(employees: List[Dict[str, any]]) -> Dict[str, float]: Calculate the average salary for each department. Args: employees (List[Dict[str, any]]): List of dictionaries representing employees. Returns: Dict[str, float]: A dictionary where keys are department names and values are the average salary, rounded to two decimal places. department_salaries = {} for employee in employees: dept = employee[\\"department\\"] salary = float(employee[\\"salary\\"]) if dept not in department_salaries: department_salaries[dept] = [] department_salaries[dept].append(salary) average_salary_by_department = {} for dept, salaries in department_salaries.items(): average_salary = sum(salaries) / len(salaries) average_salary_by_department[dept] = round(average_salary, 2) return average_salary_by_department"},{"question":"# Coding Question: Implement a Moving Average from Data Stream Write a function `MovingAverage` that calculates the moving average of the last `k` elements from a stream of integers. The moving average is the sum of the last `k` integers in the stream divided by `k`. **Class Signature**: ```python class MovingAverage: def __init__(self, size: int): Initializes the MovingAverage with the size k. def next(self, val: int) -> float: Returns the moving average after inserting the new value. ``` **Input**: - The `__init__` method initializes the object with an integer `size` representing the size of the moving window. - The `next` method is called repeatedly with a single integer, adding it to the stream and returning the current moving average. **Output**: - The `next` method returns a float representing the current moving average of the last `k` elements from the stream. **Constraints**: - The window size `k` will be a positive integer and not exceed 10^4. - The stream of integers will be given one element at a time. **Example**: ```python m = MovingAverage(3) print(m.next(1)) # Returns 1.0 = 1 / 1 print(m.next(10)) # Returns 5.5 = (1 + 10) / 2 print(m.next(3)) # Returns 4.66667 = (1 + 10 + 3) / 3 print(m.next(5)) # Returns 6.0 = (10 + 3 + 5) / 3 ``` **Considerations**: - Ensure that the `next` method works efficiently even with large streams of data. - Handle edge cases like the window size equal to 1, stream having fewer elements than the window size, and continuous increasing stream length. - Implement the solution without causing a memory overflow for long streams.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque() self.total = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.total -= self.queue.popleft() self.queue.append(val) self.total += val return self.total / len(self.queue)"},{"question":"# Question You are tasked with extending a matrix manipulation library to perform advanced matrix operations. Currently, the library supports basic operations such as matrix addition, subtraction, and multiplication. # Requirements Write a new method `eigen_decomposition` in the given `Matrix` class. This method should: 1. **Calculate the eigenvalues and eigenvectors** of a given square matrix. 2. **Confirm Symmetry**: Ensure the matrix is symmetric (i.e., `A == A.T`) before performing the decomposition. 3. **Handle exceptions** gracefully if the matrix is not symmetric or decomposable. # Function Signature ```python def eigen_decomposition(self) -> Tuple[np.ndarray, np.ndarray]: Perform eigen-decomposition of a symmetric matrix. Returns: A tuple (eigenvalues, eigenvectors), where: - eigenvalues: A 1D numpy array containing the eigenvalues of the matrix. - eigenvectors: A 2D numpy array, where each column is an eigenvector corresponding to an eigenvalue. Example: >>> mat = Matrix(np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])) >>> eigvals, eigvecs = mat.eigen_decomposition() >>> eigvals # doctest: +ELLIPSIS array([0.59..., 2.00..., 3.41...]) >>> eigvecs # doctest: +ELLIPSIS array([[-0.5..., 0.707..., 0.5...], [ 0.707..., 0.000..., -0.707...], [ 0.5..., 0.707..., 0.5...]]) pass ``` # Constraints 1. The input matrix must be symmetric. 2. Use numpy\'s linear algebra module to compute eigenvalues and eigenvectors (i.e., `numpy.linalg.eigh`). 3. Raise a `ValueError` if the matrix is not symmetric. # Input No arguments are passed to the method. The method operates on the instance’s matrix attribute. # Output * A tuple `(eigenvalues, eigenvectors)`, where: - `eigenvalues` is a 1D numpy array containing the eigenvalues of the matrix. - `eigenvectors` is a 2D numpy array, where each column is a corresponding eigenvector. # Assumptions 1. The input matrix is always a square numpy array. 2. The matrix attribute in the `Matrix` class is correctly initialized before calling the method. # Scenarios The implementation will be evaluated on its ability to: 1. Correctly compute eigenvalues and eigenvectors for symmetric matrices. 2. Ensure the matrix symmetry check is accurate and efficient. 3. Handle non-symmetric matrices by raising appropriate exceptions.","solution":"import numpy as np class Matrix: def __init__(self, data: np.ndarray): self.data = data def eigen_decomposition(self) -> tuple: Perform eigen-decomposition of a symmetric matrix. Returns: A tuple (eigenvalues, eigenvectors), where: - eigenvalues: A 1D numpy array containing the eigenvalues of the matrix. - eigenvectors: A 2D numpy array, where each column is an eigenvector corresponding to an eigenvalue. Raises: ValueError if the matrix is not symmetric. if not np.allclose(self.data, self.data.T): raise ValueError(\\"Matrix must be symmetric.\\") eigenvalues, eigenvectors = np.linalg.eigh(self.data) return eigenvalues, eigenvectors"},{"question":"**Context:** A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. In this problem, you need to find the largest prime number that is smaller than a given number `n`. **Question:** Write a function `largest_prime_below(n: int) -> int` that returns the largest prime number less than the given integer `n`. If there is no prime number less than `n`, the function should return `-1`. **Expected Input and Output:** * **Input:** An integer `n`. For example `15`. * **Output:** The largest prime number less than `n`. For instance, the input `15` should return `13`. **Function Signature:** ```python def largest_prime_below(n: int) -> int: pass ``` **Constraints:** - (2 leq n leq 10^6) **Example:** - Input: `30` - Output: `29` - Input: `3` - Output: `2` - Input: `2` - Output: `-1` **Note:** Your solution should efficiently handle large values of `n` up to (10^6).","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def largest_prime_below(n: int) -> int: Returns the largest prime number less than the given integer `n`. If there is no prime less than `n`, returns -1. for i in range(n - 1, 1, -1): if is_prime(i): return i return -1"},{"question":"# Scenario You\'re working on a text editor with built-in features to help programmers write clean and correct code. One feature you\'d like to add is the ability to detect mismatched brackets, parentheses, and curly braces. This feature will help users quickly identify and correct mistakes related to unbalanced syntax in their code snippets. # Task Implement a function `check_balance(code: str) -> bool` that verifies if all types of brackets (`()`, `[]`, `{}`) in a given string of code are correctly balanced. # Input * `code` (str): A single string representing a snippet of code. # Output * (bool): Return `True` if all the brackets in the code are correctly balanced, `False` otherwise. # Examples ```python check_balance(\\"if (a[b] == {c}) return true;\\") # Expected Output: True check_balance(\\"for (int i = 0; i < n; i++) { cout << i; }\\") # Expected Output: True check_balance(\\"while (x[i] > 10 { do_something(); }\\") # Expected Output: False check_balance(\\"function foo() { if (x > y { return [1,2,3]; }\\") # Expected Output: False ``` # Constraints * The code string only contains printable ASCII characters including spaces and standard programming punctuation. * The length of the code does not exceed 1000 characters. # Performance Requirements Ensure that your implementation can efficiently handle the upper limit of the input size, and correctly identify unbalanced brackets using an appropriate data structure. # Additional Notes - Pay special attention to correctly handling nested brackets. - You may assume that the input code does not contain multi-line comments or strings that include brackets that should be ignored.","solution":"def check_balance(code: str) -> bool: Verifies if all types of brackets (`()`, `[]`, `{}`) in a given string of code are correctly balanced. stack = [] matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in code: if char in \'([{\': stack.append(char) elif char in \')]}\': if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"# Sum of All Unique Subsequences Context In many programming problems, you need to work with subsequences of arrays. A subsequence is derived from an array by deleting some or no elements without changing the order of the remaining elements. This problem will test your ability to generate all possible subsequences and further use them to compute desired results. Problem Statement Implement a Python function `sum_of_unique_subsequences(arr: list) -> int` that calculates the sum of all unique elements present in every possible subsequence of the given array `arr`. Function Signature: ```python def sum_of_unique_subsequences(arr: list) -> int: pass ``` Input: - `arr` (list): a list of integers (1 ≤ len(arr) ≤ 20, 1 ≤ arr[i] ≤ 100). Output: - An integer representing the sum of all unique elements considering all subsequences of the array. Constraints: - The input list `arr` may contain duplicates. - Ensure that each unique element is counted only once regardless of how many subsequences it appears in. Examples: ```python >>> sum_of_unique_subsequences([1, 2, 3]) 6 >>> sum_of_unique_subsequences([1, 2, 2, 3]) 6 >>> sum_of_unique_subsequences([5, 5, 5]) 5 >>> sum_of_unique_subsequences([1, 3, 1, 3, 5]) 9 ``` Use the provided test cases to validate your solution. Explanation: 1. For the array `[1, 2, 3]`: - All unique elements: {1, 2, 3} - Sum of unique elements: 1 + 2 + 3 = 6 2. For the array `[1, 2, 2, 3]`: - All unique elements: {1, 2, 3} - Sum of unique elements: 1 + 2 + 3 = 6 3. For the array `[5, 5, 5]`: - All unique elements: {5} - Sum of unique elements: 5 4. For the array `[1, 3, 1, 3, 5]`: - All unique elements: {1, 3, 5} - Sum of unique elements: 1 + 3 + 5 = 9","solution":"def sum_of_unique_subsequences(arr): Calculates the sum of all unique elements present in every possible subsequence of the array. unique_elements = set(arr) return sum(unique_elements)"},{"question":"# Minimum Insertions to Form a Palindrome Assessment Question You are developing a feature for a text editing application that helps users create palindromic strings from given texts by making the minimum number of insertions. A string is a palindrome if it reads the same forward and backward. Your task is to find the fewest number of insertions needed to convert a given string into a palindrome. Task: Write a function `min_insertions_to_palindrome(input_string: str) -> int` that takes a single argument as input: - `input_string` (str): The string that you need to transform into a palindrome with the minimum number of insertions. The function should return an integer corresponding to the minimum number of insertions required to make the given string a palindrome. Input: - It is guaranteed that the input string will only contain lower-case alphabets and its length will be at most 1000. Output: - Return an integer representing the minimum number of insertions needed. Examples: ```python >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"deed\\") 0 >>> min_insertions_to_palindrome(\\"abcdefg\\") 6 ``` Constraints: - The function should handle edge cases such as already palindromic strings or strings with no characters efficiently. - Performance should be optimized for input string length up to 1000 characters. # Explanation of Examples: - In the first example, \\"ab\\" can be transformed into \\"aba\\" with 1 insertion. - In the second example, \\"a\\" is already a palindrome, so no insertions are needed. - In the third example, \\"race\\" can be transformed into \\"ecarace\\" or \\"racecar\\" with 3 insertions. - In the fourth example, \\"deed\\" is already a palindrome, so no insertions are needed. - In the fifth example, \\"abcdefg\\" can be transformed into \\"gfedcbabcdefg\\" with 6 insertions. Ensure your solution handles various scenarios, including strings that are already palindromes and those requiring significant modifications.","solution":"def min_insertions_to_palindrome(input_string: str) -> int: Returns the minimum number of insertions needed to transform the input string into a palindrome. def longest_common_subsequence(s1: str, s2: str) -> int: len1, len2 = len(s1), len(s2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len1][len2] reversed_string = input_string[::-1] lcs_length = longest_common_subsequence(input_string, reversed_string) return len(input_string) - lcs_length"},{"question":"# Question: Advanced List Operations: Find Unique Intersection You are given two lists of integers, `list_a` and `list_b`. Your task is to find the unique intersection of these two lists. The unique intersection is defined as the set of elements that appear in both lists, but only as many times as they appear in the list where they are less frequent. Task Write a function `unique_intersection` that computes the unique intersection of two lists and returns it as a list of integers. Expected Input and Output Your function should have the following signature: ```python def unique_intersection(list_a: list[int], list_b: list[int]) -> list[int]: pass ``` **Input**: - Two lists of integers `list_a` and `list_b`, where each integer represents an element in the list. **Output**: - A list of integers representing the unique intersection of the given lists. Constraints * `1 <= len(list_a), len(list_b) <= 10^4` * `-10^5 <= element <= 10^5` Example ```python list_a = [1, 2, 2, 3, 4, 4, 4] list_b = [2, 2, 2, 3, 3, 4, 4, 5] # Expected Output: # [2, 2, 3, 4, 4] ``` Explanation In this example, - The element `2` appears twice in both lists, so it is included twice in the result. - The element `3` appears once in the list_a and twice in list_b, so it is included once in the result. - The element `4` appears thrice in list_a and twice in list_b, so it is included twice in the result. Context Finding intersections with constraints like frequency counts pertains to advanced list operations that commonly arise in data cleaning and preprocessing tasks, as well as in competitive programming scenarios. This problem tests your ability to efficiently manage and manipulate lists with possibly large inputs.","solution":"from collections import Counter from typing import List def unique_intersection(list_a: List[int], list_b: List[int]) -> List[int]: counter_a = Counter(list_a) counter_b = Counter(list_b) result = [] for element in counter_a: if element in counter_b: min_count = min(counter_a[element], counter_b[element]) result.extend([element] * min_count) return result"},{"question":"# Problem Statement Given a string representing a large number, you need to determine the most frequently occurring digit and its frequency. If there are multiple digits with the same maximum frequency, return the smallest digit among them and its frequency. Write a function `most_frequent_digit(number_str: str) -> Tuple[str, int]` which takes in a string `number_str` representing a number and returns a tuple containing the most frequently occurring digit and its frequency. # Function Signature ```python def most_frequent_digit(number_str: str) -> Tuple[str, int]: pass ``` # Input: - `number_str` (str): A string of digits (0-9) representing a number. # Output: - A tuple containing two elements: - The most frequently occurring digit (str). - The frequency of that digit (int). # Constraints: - 1 ≤ len(number_str) ≤ 10^6 # Example ```python most_frequent_digit(\\"12345678901234567890\\") -> (\'1\', 2) ``` ```python most_frequent_digit(\\"5553331122\\") -> (\'1\', 2) ``` ```python most_frequent_digit(\\"98765432109876543210\\") -> (\'0\', 2) ``` # Notes: - Ensure the function handles edge cases, such as strings with all digits having the same frequency. - Strings can be very long, so consider performance optimization. - Test cases will include strings with mixed frequencies and edge cases to validate correctness and efficiency.","solution":"from typing import Tuple from collections import Counter def most_frequent_digit(number_str: str) -> Tuple[str, int]: Returns the most frequently occurring digit and its frequency. If multiple digits have the same highest frequency, returns the smallest digit among them. digit_count = Counter(number_str) max_frequency = max(digit_count.values()) most_frequent_digits = [digit for digit, count in digit_count.items() if count == max_frequency] smallest_digit = min(most_frequent_digits) return smallest_digit, max_frequency"},{"question":"# Coding Assessment: First Missing Positive Integer Context Finding the first missing positive integer from an unsorted array is a classic computer science problem. This problem tests your understanding of array manipulation, in-place algorithms, and time-space optimization. Problem Statement Given an unsorted integer array `nums`, write a function `first_missing_positive(nums: List[int]) -> int` that returns the smallest positive integer that does not appear in the array. This problem is inspired by similar challenges that require efficient data handling and algorithmic techniques to solve within linear time and constant space. Function Signature ```python def first_missing_positive(nums: List[int]) -> int: ``` Inputs - `nums`: A list of integers (can be negative, zero, or positive). Outputs - Return the smallest positive integer not present in the list as an integer. Constraints - The elements in `nums` are in the range of `[-2^31, 2^31-1]`. - The length of `nums` can be up to `10^5`. Performance Requirements - The solution should run in O(n) time, where n is the length of `nums`. - The solution should use constant extra space, O(1). Example ```python nums = [3, 4, -1, 1] print(first_missing_positive(nums)) # Output should be 2 nums = [1, 2, 0] print(first_missing_positive(nums)) # Output should be 3 nums = [7, 8, 9, 11, 12] print(first_missing_positive(nums)) # Output should be 1 ``` Hint - Consider using indexing to determine the presence of integers by rearranging the elements in the array. - You might want to place each positive integer x in the position x-1 if possible. Notes - Pay careful attention to handling numbers outside the range of interest (negative numbers, zeros, and numbers greater than the length of the array). - Be mindful of the constraints and ensure your solution adheres to the defined performance criteria.","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Question: Longest Increasing Subsequence in a Matrix You are required to find the longest increasing subsequence in a given integer matrix. The subsequence must be formed by moving up, down, left, or right from a cell in the matrix to an adjacent cell. The goal is to optimize the process using dynamic programming. Problem Statement Given an `m x n` matrix of integers, implement an algorithm to find the length of the longest increasing subsequence. A subsequence is a sequence of numbers collected by moving to adjacent cells. Two cells are considered adjacent if they share a common edge. Implement the following function: ```python def longest_increasing_path(matrix: List[List[int]]) -> int: Find the length of the longest increasing path in the given matrix. :param matrix: A 2D list of integers representing the matrix. :return: An integer representing the length of the longest increasing path. pass ``` Input * The `matrix` parameter is a 2D list of integers of size m x n (1 ≤ m, n ≤ 200). Output * Return an integer representing the length of the longest increasing path. Example Suppose the input matrix is as follows: ``` [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] ``` The function call `longest_increasing_path(matrix)` should return `4`, as the longest increasing path can be `1 -> 2 -> 6 -> 9`. Constraints - The input matrix contains integer values between -1,000,000 and 1,000,000. - The length of the longest path will always be at least 1 since a single cell is a valid path by itself. Guidelines * You are encouraged to use memoization to store the results of previously computed paths to avoid redundant calculations. * The implementation should be optimized for performance, ensuring that the solution runs within a reasonable time frame for the given constraints. * Ensure that the solution is robust and handles edge cases, such as matrices with uniform values or the smallest possible input size.","solution":"def longest_increasing_path(matrix): Find the length of the longest increasing path in the given matrix. :param matrix: A 2D list of integers representing the matrix. :return: An integer representing the length of the longest increasing path. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) memo = [[-1] * cols for _ in range(rows)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) memo[x][y] = max_length return max_length max_path = 0 for r in range(rows): for c in range(cols): max_path = max(max_path, dfs(r, c)) return max_path"},{"question":"# Problem Statement You are given a string consisting of lowercase alphabets and special characters (`@`, `#`, ``, `%`, `&`, `*`). Your task is to write a function `split_alphabets_special(s: str) -> Tuple[str, str]` that takes this string and returns a tuple of two strings. The first string should contain all the alphabets in the order they appear, and the second string should contain all the special characters in the order they appear. # Function Signature ```python def split_alphabets_special(s: str) -> Tuple[str, str]: pass ``` # Input - `s`: A string consisting of lowercase alphabets (`a` to `z`) and special characters (`@`, `#`, ``, `%`, `&`, `*`). The length of the string will be between 1 and 10^5 (inclusive). # Output - A tuple of two strings: - The first string contains all the alphabets from the input string in the same order. - The second string contains all the special characters from the input string in the same order. # Constraints - The string will contain only lowercase alphabets and the special characters mentioned. # Example ```python assert split_alphabets_special(\\"a@bc#de%f&g*\\") == (\\"abcdefg\\", \\"@#%&*\\") assert split_alphabets_special(\\"@#%&*\\") == (\\"\\", \\"@#%&*\\") assert split_alphabets_special(\\"abcdef\\") == (\\"abcdef\\", \\"\\") assert split_alphabets_special(\\"abc\\") == (\\"abc\\", \\"\\") ``` # Additional Information - Ensure that the function processes the string in a single pass, if possible. - The solution should handle edge cases, such as strings consisting entirely of special characters or entirely of alphabets. **Note**: Do not modify the function signature, and ensure your solution passes the provided test cases.","solution":"from typing import Tuple def split_alphabets_special(s: str) -> Tuple[str, str]: alphabets = [] special_chars = [] for char in s: if char.isalpha(): alphabets.append(char) else: special_chars.append(char) return (\\"\\".join(alphabets), \\"\\".join(special_chars))"},{"question":"# Coding Task: Implement Depth-First Search with Cycle Detection Scenario You are asked to implement a depth-first search (DFS) algorithm to traverse a directed graph. Additionally, the algorithm needs to detect cycles within the graph. Task Implement a function `dfs_with_cycle_detection` in Python to perform a depth-first search on a directed graph while simultaneously checking for cycles. Function Signature ```python def dfs_with_cycle_detection(graph: dict) -> bool: Perform depth-first search on a directed graph and detect if there are any cycles. Args: - graph (dict): A dictionary representing the adjacency list of the graph. Keys are node identifiers, values are lists of adjacent nodes. Returns: - bool: True if a cycle is detected, False otherwise. pass ``` # Input * `graph`: A dictionary where keys are node identifiers (e.g., integers or strings) and values are lists of nodes that the key node has directed edges to. # Output * Return `True` if a cycle is detected in the graph, `False` otherwise. # Constraints * The graph will have between `1` and `100` nodes. * Nodes will have unique identifiers. # Example ```python graph = { 1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: [] } cycle_present = dfs_with_cycle_detection(graph) print(cycle_present) # Expected output: False ``` ```python graph_with_cycle = { 1: [2], 2: [3], 3: [1] } cycle_present = dfs_with_cycle_detection(graph_with_cycle) print(cycle_present) # Expected output: True ``` # Notes 1. Ensure your function is efficient and can handle the upper limits of the constraints. 2. Handle edge cases such as disconnected nodes or nodes with no outgoing edges. 3. Provide appropriate documentation and comments within your code to explain the logic and approach.","solution":"def dfs_with_cycle_detection(graph): Perform depth-first search on a directed graph and detect if there are any cycles. Args: - graph (dict): A dictionary representing the adjacency list of the graph. Keys are node identifiers, values are lists of adjacent nodes. Returns: - bool: True if a cycle is detected, False otherwise. WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} def dfs(node): if color[node] == GRAY: return True if color[node] == BLACK: return False color[node] = GRAY for neighbor in graph[node]: if dfs(neighbor): return True color[node] = BLACK return False for node in graph: if color[node] == WHITE: if dfs(node): return True return False # Example usage: # graph_with_cycle = { # 1: [2], # 2: [3], # 3: [1] # } # cycle_present = dfs_with_cycle_detection(graph_with_cycle) # print(cycle_present) # Expected output: True"},{"question":"# Problem Statement Given a list of integers representing the heights of a series of buildings, write a function to determine the maximum area of a rectangle formed by any two buildings and the water trapped between them. The heights of the buildings are given in a list, where the width of each building is 1 unit. # Function Signature ```python def max_water_area(heights: list[int]) -> int: pass ``` # Input - `heights`: A list of integers where each element represents the height of a building. The list will have at least two elements and at most 1000 elements. # Output - Return a single integer representing the maximum rectangular water area trapped between two buildings. # Constraints - Each height value will be non-negative and at most 10^4. # Example ```python heights = [1, 8, 6, 2, 5, 4, 8, 3, 7] output = max_water_area(heights) # Expected output: 49 ``` # Implementation Details - Implement the `max_water_area` function using a two-pointer approach. - Iterate from both ends of the list to find the optimal pair of buildings that can trap the maximum amount of water.","solution":"def max_water_area(heights: list[int]) -> int: This function returns the maximum area of water that can be trapped between two buildings. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) # Move the pointer that points to the shorter building if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Problem Statement You are required to find the next lexicographically greater permutation for a given string of lowercase English letters. If no such permutation exists (the string is the highest possible permutation), return the smallest permutation (i.e., sorted in ascending order). # Function Specification Input * The function will receive a single string `s`, where: * s (1 ≤ len(s) ≤ 100) Output * The function should return the next lexicographically greater permutation of the input string, or the smallest permutation if the next permutation does not exist. # Requirements * Implement an efficient solution to generate the next permutation. * You can assume that the input string contains only lowercase English letters. # Function Signatures ```python def next_permutation(s: str) -> str: pass ``` # Example ```python assert next_permutation(\\"abc\\") == \\"acb\\" assert next_permutation(\\"cba\\") == \\"abc\\" assert next_permutation(\\"bca\\") == \\"cab\\" assert next_permutation(\\"ab\\") == \\"ba\\" assert next_permutation(\\"zzzzzz\\") == \\"zzzzzz\\" ``` # Constraints * Focus on time and space efficiency in your implementation. * Make sure to correctly handle edge cases such as strings where all characters are the same or when the string is already the highest permutation. # Hint - Use the algorithm for finding the next lexicographical permutation which involves identifying the pivot, swapping elements, and reversing a substring. - Consider using step-by-step debugging to prevent common mistakes, such as incorrect element swapping or not handling edge cases.","solution":"def next_permutation(s: str) -> str: Returns the next lexicographical permutation of the input string. If no such permutation exists, returns the smallest permutation (sorted in ascending order). s = list(s) n = len(s) # Step 1: Find the largest index k such that s[k] < s[k + 1]. If no such index exists, the permutation is the last permutation. k = -1 for i in range(n - 1): if s[i] < s[i + 1]: k = i if k == -1: # The string is in descending order s.sort() return \'\'.join(s) # Step 2: Find the largest index l greater than k such that s[k] < s[l]. l = -1 for i in range(n): if s[k] < s[i]: l = i # Step 3: Swap the value of s[k] with that of s[l]. s[k], s[l] = s[l], s[k] # Step 4: Reverse the sequence from s[k + 1] up to and including the final element s[n - 1]. s = s[:k + 1] + s[k + 1:][::-1] return \'\'.join(s)"},{"question":"# Problem Statement You have been given an array of `N` integers. Your task is to preprocess the array to efficiently query the sum of elements in any given subarray. You need to implement functions for: 1. **Prefix Sum Array Construction** for storing prefix sums. 2. **Subarray Sum Query** to find the sum of elements in a specified subarray using the prefix sum array. # Functions to Implement You need to implement the following two functions: 1. `construct_prefix_sum(arr: List[int]) -> List[int]`: - **Input**: - `arr`: A list of integers representing the original array. - **Output**: A list of integers representing the prefix sum array. 2. `subarray_sum_query(prefix_sum: List[int], left: int, right: int) -> int`: - **Input**: - `prefix_sum`: A list of integers representing the prefix sum array. - `left`: An integer denoting the starting index of the subarray. - `right`: An integer denoting the ending index of the subarray. - **Output**: An integer representing the sum of elements in the specified subarray `[left, right]`. # Example ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] prefix_sum = construct_prefix_sum(arr) print(\\"Sum of elements in subarray [1, 5] is:\\", subarray_sum_query(prefix_sum, 1, 5)) # Output: 20 print(\\"Sum of elements in subarray [0, 9] is:\\", subarray_sum_query(prefix_sum, 0, 9)) # Output: 55 print(\\"Sum of elements in subarray [3, 7] is:\\", subarray_sum_query(prefix_sum, 3, 7)) # Output: 30 ``` # Constraints - Ensure that the prefix sum array is correctly constructed. - Handle cases where the indices provided for the query are out of bounds. - The array will have `N` elements where `1 <= N <= 10^5`.","solution":"from typing import List def construct_prefix_sum(arr: List[int]) -> List[int]: Constructs and returns the prefix sum array given an input array. prefix_sum = [0] * len(arr) if len(arr) > 0: prefix_sum[0] = arr[0] for i in range(1, len(arr)): prefix_sum[i] = prefix_sum[i - 1] + arr[i] return prefix_sum def subarray_sum_query(prefix_sum: List[int], left: int, right: int) -> int: Returns the sum of elements in the specified subarray [left, right] using the prefix sum array. if left == 0: return prefix_sum[right] return prefix_sum[right] - prefix_sum[left - 1]"},{"question":"Distance Unit Conversion Enhancement You are tasked with enhancing a distance unit converter used in various scientific and engineering applications. This converter should support more units and provide helpful information about each unit. Requirements: 1. **Extend Unit Support**: Add support for additional distance units: \\"mile\\" (1 mile = 1609.34 meters) and \\"nautical mile\\" (1 nautical mile = 1852 meters). 2. **Unit Details Function**: Implement a function `unit_details(unit: str) -> str` that returns a string description of the given unit. It should include the full name and commonly used context. For unsupported units, raise a ValueError with a descriptive error message. # Input Specifications: 1. `distance_conversion(value: float, from_type: str, to_type: str) -> float`: This function converts distance from one unit to another. 2. `unit_details(unit: str) -> str`: This function provides details about the given distance unit. # Output Specifications: 1. `distance_conversion` should return the converted value. 2. `unit_details` should return a string description of the unit. # Constraints: 1. The units provided must be valid; otherwise, raise a `ValueError`. 2. Ensure the descriptions are clear and informative. # Scenarios and Examples: 1. **Converting Units**: - `distance_conversion(1, \\"mile\\", \\"meter\\")` should return `1609.34`. - `distance_conversion(1, \\"nautical mile\\", \\"kilometer\\")` should return `1.852`. 2. **Unit Details**: - `unit_details(\\"mile\\")` should return a string like \\"Mile: A unit of distance used in the United States and the United Kingdom.\\" - `unit_details(\\"nautical mile\\")` should return a string like \\"Nautical Mile: A unit of distance used in marine and air navigation.\\" # Boilerplate Code ```python from typing import NamedTuple class FromTo(NamedTuple): from_factor: float to_factor: float DISTANCE_CONVERSION = { \\"meter\\": FromTo(1, 1), \\"kilometer\\": FromTo(1000, 0.001), \\"centimeter\\": FromTo(0.01, 100), \\"millimeter\\": FromTo(0.001, 1000), \\"micrometer\\": FromTo(1e-6, 1e6), \\"nanometer\\": FromTo(1e-9, 1e9), \\"mile\\": FromTo(1609.34, 0.000621371), \\"nautical mile\\": FromTo(1852, 0.000539957), # extend with new units } def distance_conversion(value: float, from_type: str, to_type: str) -> float: if from_type not in DISTANCE_CONVERSION: raise ValueError( f\\"Invalid \'from_type\' value: {from_type!r}. Supported values are:n\\" + \\", \\".join(DISTANCE_CONVERSION) ) if to_type not in DISTANCE_CONVERSION: raise ValueError( f\\"Invalid \'to_type\' value: {to_type!r}. Supported values are:n\\" + \\", \\".join(DISTANCE_CONVERSION) ) return ( value * DISTANCE_CONVERSION[from_type].from_factor / DISTANCE_CONVERSION[to_type].from_factor ) def unit_details(unit: str) -> str: details = { \\"meter\\": \\"Meter: The base unit of length in the International System of Units (SI).\\", \\"kilometer\\": \\"Kilometer: A unit of length equal to 1000 meters, commonly used to measure distances between geographical locations.\\", \\"centimeter\\": \\"Centimeter: A unit of length equal to one hundredth of a meter, commonly used in measurements of small objects.\\", \\"millimeter\\": \\"Millimeter: A unit of length equal to one thousandth of a meter, commonly used in engineering and manufacturing.\\", \\"micrometer\\": \\"Micrometer: A unit of length equal to one millionth of a meter, used in scientific measurements.\\", \\"nanometer\\": \\"Nanometer: A unit of length equal to one billionth of a meter, used in nanotechnology and biology.\\", \\"mile\\": \\"Mile: A unit of distance used in the United States and the United Kingdom.\\", \\"nautical mile\\": \\"Nautical Mile: A unit of distance used in marine and air navigation.\\", } if unit not in details: raise ValueError(f\\"Unsupported unit: {unit!r}. Supported units are:n\\" + \', \'.join(details.keys())) return details[unit] if __name__ == \\"__main__\\": import doctest # Write doctests for distance_conversion and unit_details doctest.testmod() ```","solution":"from typing import NamedTuple class FromTo(NamedTuple): from_factor: float to_factor: float DISTANCE_CONVERSION = { \\"meter\\": FromTo(1, 1), \\"kilometer\\": FromTo(1000, 0.001), \\"centimeter\\": FromTo(0.01, 100), \\"millimeter\\": FromTo(0.001, 1000), \\"micrometer\\": FromTo(1e-6, 1e6), \\"nanometer\\": FromTo(1e-9, 1e9), \\"mile\\": FromTo(1609.34, 0.000621371), \\"nautical mile\\": FromTo(1852, 0.000539957), } def distance_conversion(value: float, from_type: str, to_type: str) -> float: if from_type not in DISTANCE_CONVERSION: raise ValueError( f\\"Invalid \'from_type\' value: {from_type!r}. Supported values are:n\\" + \\", \\".join(DISTANCE_CONVERSION) ) if to_type not in DISTANCE_CONVERSION: raise ValueError( f\\"Invalid \'to_type\' value: {to_type!r}. Supported values are:n\\" + \\", \\".join(DISTANCE_CONVERSION) ) return ( value * DISTANCE_CONVERSION[from_type].from_factor / DISTANCE_CONVERSION[to_type].from_factor ) def unit_details(unit: str) -> str: details = { \\"meter\\": \\"Meter: The base unit of length in the International System of Units (SI).\\", \\"kilometer\\": \\"Kilometer: A unit of length equal to 1000 meters, commonly used to measure distances between geographical locations.\\", \\"centimeter\\": \\"Centimeter: A unit of length equal to one hundredth of a meter, commonly used in measurements of small objects.\\", \\"millimeter\\": \\"Millimeter: A unit of length equal to one thousandth of a meter, commonly used in engineering and manufacturing.\\", \\"micrometer\\": \\"Micrometer: A unit of length equal to one millionth of a meter, used in scientific measurements.\\", \\"nanometer\\": \\"Nanometer: A unit of length equal to one billionth of a meter, used in nanotechnology and biology.\\", \\"mile\\": \\"Mile: A unit of distance used in the United States and the United Kingdom.\\", \\"nautical mile\\": \\"Nautical Mile: A unit of distance used in marine and air navigation.\\", } if unit not in details: raise ValueError(f\\"Unsupported unit: {unit!r}. Supported units are:n\\" + \', \'.join(details.keys())) return details[unit]"},{"question":"# Problem Statement: You are provided with a string consisting of lowercase letters and digits. Your task is to create a function that encrypts the string using a simple letter-shifting technique combined with digit inversion. The encryption rules are as follows: - Each letter in the string should be shifted by one position in the alphabet. For instance, \'a\' becomes \'b\', and \'z\' becomes \'a\'. - Each digit in the string should be inverted. For instance, \'0\' becomes \'9\', \'1\' becomes \'8\', ..., and \'9\' becomes \'0\'. Write a function named `encrypt_string(input_string: str) -> str` that takes a string `input_string` and returns the encrypted string based on the rules described. # Input: - `input_string` (1 ≤ len(input_string) ≤ 100): A string consisting of lowercase letters and digits. # Output: - A string that is the result of applying the described encryption technique on `input_string`. # Example: ```python encrypt_string(\\"abc123\\") # Output: # \\"bcd876\\" ``` # Constraints: - Ensure that your function efficiently processes the encryption for the maximum input length. - Take into account the wrap-around behavior for letters (\'z\' should become \'a\') and digits (\'0\' should become \'9\').","solution":"def encrypt_string(input_string: str) -> str: Encrypt the input string using letter shifting and digit inversion rules. Parameters: input_string (str): The string to be encrypted, consisting of lowercase letters and digits. Returns: str: The encrypted string. encrypted = [] for char in input_string: if char.isdigit(): # Invert the digit encrypted.append(str(9 - int(char))) elif char.isalpha(): # Shift the letter if char == \'z\': encrypted.append(\'a\') else: encrypted.append(chr(ord(char) + 1)) return \'\'.join(encrypted)"},{"question":"# Question: Matrix Diagonal Sum Create a function that computes the sum of the elements on the main diagonal of a square matrix. The main diagonal of a matrix consists of the elements that run from the top left to the bottom right corner. **Function Signature:** ```python def diagonal_sum(matrix: List[List[int]]) -> int: ``` **Input:** * A list of lists `matrix` representing an `n x n` square matrix where `1 <= n <= 100`. Each element in the matrix is an integer. **Output:** * An integer representing the sum of the elements on the main diagonal. **Example:** ```python >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> diagonal_sum([[5, -2, 3], [1, 4, -6], [2, 8, 0]]) 9 >>> diagonal_sum([[10]]) 10 >>> diagonal_sum([[6, 7], [8, 9]]) 15 ``` **Explanation:** 1. The main diagonal of the first matrix contains the elements [1, 5, 9]. Their sum is 1 + 5 + 9 = 15. 2. The main diagonal of the second matrix contains the elements [5, 4, 0]. Their sum is 5 + 4 + 0 = 9. 3. The main diagonal of the single-element matrix contains the element [10]. Its sum is 10. 4. The main diagonal of the fourth matrix contains the elements [6, 9]. Their sum is 6 + 9 = 15. **Constraints:** * Ensure to handle matrices up to the given constraint efficiently.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: Computes the sum of the elements on the main diagonal of a square matrix. n = len(matrix) return sum(matrix[i][i] for i in range(n))"},{"question":"# Task: Build a Trie for Autocomplete Functionality # Problem Statement You are tasked with implementing a Trie (Prefix Tree) to serve as the underlying data structure for an autocomplete feature in a text editor. The Trie should allow for the efficient insertion of words, searching for words with a common prefix, and retrieving the top N auto-complete suggestions based on their frequency of usage. Requirements 1. **Trie Node**: - Each node should store: - A dictionary mapping from characters to child nodes. - A boolean indicating if it\'s the end of a word. - An integer for tracking the frequency of word usage. 2. **Trie Operations**: - **Insertion**: - Insert a word into the Trie and update its frequency. - **Search Prefix**: - Search for a word or words with the given prefix. - **Top N Suggestions**: - Retrieve the top N words by their frequency that share the given prefix. 3. **Edge Cases**: - Handle the insertion of duplicate words (increase frequency on duplicate insertion). - Handle cases where the prefix is not found in the Trie. - Ensure performance scales with a large number of words. Implementation Details - Implement the `TrieNode` class for initializing trie nodes. - Implement the `Trie` class with the following methods: - `insert(word: str) -> None`: Inserts a word into the Trie and updates its frequency. - `search_prefix(prefix: str) -> List[str]`: Searches for words with the given prefix and returns them. - `top_n_suggestions(prefix: str, n: int) -> List[str]`: Retrieves the top N words by frequency that share the given prefix. Constraints - Words consist of lowercase alphabets (\'a\' to \'z\') and are non-empty. - The parameter `n` for `top_n_suggestions` is a non-negative integer. - Words\' frequency starts at 1 upon first insertion and increases with each subsequent insertion of the same word. # Example Usage ```python autocomplete = Trie() # Insertion autocomplete.insert(\\"apple\\") autocomplete.insert(\\"app\\") autocomplete.insert(\\"application\\") autocomplete.insert(\\"app\\") autocomplete.insert(\\"apple\\") # Search Prefix assert autocomplete.search_prefix(\\"app\\") == [\\"app\\", \\"apple\\", \\"application\\"] assert autocomplete.search_prefix(\\"banana\\") == [] # Top N Suggestions assert autocomplete.top_n_suggestions(\\"app\\", 2) == [\\"app\\", \\"apple\\"] assert autocomplete.top_n_suggestions(\\"app\\", 3) == [\\"app\\", \\"apple\\", \\"application\\"] # Insert more to change frequency autocomplete.insert(\\"application\\") autocomplete.insert(\\"application\\") # Top N Suggestions after frequency changes assert autocomplete.top_n_suggestions(\\"app\\", 1) == [\\"application\\"] assert autocomplete.top_n_suggestions(\\"app\\", 3) == [\\"application\\", \\"app\\", \\"apple\\"] ``` Ensure that your implementation adheres to the given requirements and efficiently supports autocomplete functionality accounting for word frequency.","solution":"from collections import defaultdict from heapq import nlargest class TrieNode: def __init__(self): self.children = defaultdict(TrieNode) self.is_end_of_word = False self.frequency = 0 class Trie: def __init__(self): self.root = TrieNode() self.word_frequencies = defaultdict(int) def insert(self, word: str) -> None: current = self.root for char in word: current = current.children[char] current.is_end_of_word = True current.frequency += 1 self.word_frequencies[word] += 1 def search_prefix(self, prefix: str) -> list: current = self.root for char in prefix: if char in current.children: current = current.children[char] else: return [] return self._find_words_from_node(current, prefix) def _find_words_from_node(self, node, prefix): words = [] if node.is_end_of_word: words.append(prefix) for char, child_node in node.children.items(): words.extend(self._find_words_from_node(child_node, prefix + char)) return words def top_n_suggestions(self, prefix: str, n: int) -> list: words_with_prefix = self.search_prefix(prefix) words_with_frequencies = [(word, self.word_frequencies[word]) for word in words_with_prefix] top_n = nlargest(n, words_with_frequencies, key=lambda x: x[1]) return [word for word, _ in top_n]"},{"question":"# Question: Implement a Binary Search Tree with Find, Insert, and Delete Operations **Scenario**: You are given a class representing a binary search tree (BST). Your task is to implement methods to find, insert, and delete nodes within this BST. These operations are fundamental for maintaining dynamic sets of items with quick lookup, addition, and removal capabilities. Write three methods `find`, `insert`, and `delete` within the `BinarySearchTree` class. Each method should perform the respective operation efficiently, adhering to the properties of a BST. Method Signatures: ```python def find(self, key: int) -> bool: Find a node with the specified key in the BST. Parameters: key: (int) The key to be searched in the BST. Returns: bool: True if the key is found, otherwise False. pass def insert(self, key: int) -> None: Insert a node with the specified key into the BST. Parameters: key: (int) The key of the node to be inserted. Returns: None pass def delete(self, key: int) -> None: Delete a node with the specified key from the BST. Parameters: key: (int) The key of the node to be deleted. Returns: None pass ``` Input and Output Format * **Input**: * For `find`, `insert`, and `delete`, input is an integer key that corresponds to the node in the BST. * **Output**: * For `find`, return `True` if the node with the given key is found, otherwise `False`. * For `insert` and `delete`, no return value is required. Constraints and Limitations * Assume the BST may contain up to `10^4` nodes. * Handle cases where the BST is initially empty. * Ensure that duplicate keys are not inserted into the BST. Example ```python # Create a binary search tree bst = BinarySearchTree() # Insert nodes into the BST bst.insert(50) bst.insert(30) bst.insert(20) bst.insert(40) bst.insert(70) bst.insert(60) bst.insert(80) # Find nodes in the BST print(bst.find(50)) # Output: True print(bst.find(25)) # Output: False # Delete nodes from the BST bst.delete(20) print(bst.find(20)) # Output: False bst.delete(30) print(bst.find(30)) # Output: False bst.delete(50) print(bst.find(50)) # Output: False ```","solution":"class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def find(self, key: int) -> bool: def _find(root, key): if root is None: return False if root.val == key: return True elif key < root.val: return _find(root.left, key) else: return _find(root.right, key) return _find(self.root, key) def insert(self, key: int) -> None: def _insert(root, key): if root is None: return TreeNode(key) if key < root.val: root.left = _insert(root.left, key) elif key > root.val: root.right = _insert(root.right, key) # No need to insert duplicate keys return root self.root = _insert(self.root, key) def delete(self, key: int) -> None: def _minValueNode(node): current = node while current.left is not None: current = current.left return current def _delete(root, key): if root is None: return root if key < root.val: root.left = _delete(root.left, key) elif key > root.val: root.right = _delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = _minValueNode(root.right) root.val = temp.val root.right = _delete(root.right, temp.val) return root self.root = _delete(self.root, key)"},{"question":"# Question: Binary Tree Level Order Traversal Context You are required to implement a function that performs a level order traversal (Breadth-First Search) of a binary tree and returns the values at each level as separate lists. Function Signature ```python def level_order_traversal(root: TreeNode) -> list: # Detailed implementation goes here ``` Input - `root` (TreeNode): The root node of the binary tree. The TreeNode structure is defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Output - Returns a list of lists, with each inner list containing the node values at each level of the tree. Constraints - The function should handle binary trees of any size, including an empty tree (where `root` is `None`). - Each node value is an integer. Performance Requirements - Time Complexity: O(n), where n is the number of nodes in the tree. - Space Complexity: O(n) Example Scenarios - Example 1: * Input: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) ``` * Output: [[1], [2, 3], [4, 5, 6, 7]] - Example 2: * Input: ```python root = TreeNode(1) root.left = TreeNode(2) ``` * Output: [[1], [2]] Instructions 1. Write a function `level_order_traversal` that performs a level order traversal of the binary tree starting from the root node. 2. Return the node values at each level as separate lists. 3. Ensure that the function is robust against edge cases like an empty tree or a tree with a single node. 4. Test the function with various inputs to ensure correctness.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root: TreeNode) -> list: if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.pop(0) level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Problem Statement: Balanced Stock Portfolio Calculation You are developing a tool that helps investors balance their stock portfolios. Your tool should calculate a \\"balance score\\" for each stock based on its performance attributes and predefined criteria. The goal is to assist investors in identifying stocks that contribute to a well-balanced portfolio. # Requirements 1. **Function Implementation**: Implement the function `calculate_balance_score(portfolio_data: list[list[float]], criteria: list[tuple[float, str]]) -> list[list[float]]` 2. **Input**: * `portfolio_data` - A list of lists of float values representing stock performance metrics. Each sublist corresponds to a stock, and the elements in the sublist represent different attributes (e.g., return, risk, dividend yield). * `criteria` - A list of tuples where each tuple consists of two elements: - A float representing the ideal value for the corresponding attribute. - A string that specifies whether a higher value (\'high\') or lower value (\'low\') is better for that attribute. 3. **Output**: * Returns the `portfolio_data` list with an additional column appended, representing the calculated balance score for each stock. # Constraints 1. Each sublist in `portfolio_data` has the same length as `criteria`. 2. All values in `portfolio_data` are non-negative floats. 3. Each tuple in `criteria` contains a float and a string (\'high\' or \'low\'). # Example ```python portfolio_data = [ [12.5, 8.0, 3.1], [14.7, 6.5, 2.8], [10.2, 9.1, 4.0], [11.8, 7.5, 3.0] ] criteria = [(13.0, \'high\'), (7.0, \'low\'), (3.0, \'high\')] result = calculate_balance_score(portfolio_data, criteria) print(result) # Expected Output: # [ # [12.5, 8.0, 3.1, 2.38], # [14.7, 6.5, 2.8, 1.45], # [10.2, 9.1, 4.0, 3.3], # [11.8, 7.5, 3.0, 1.68] # ] ``` # Requirements 1. Your solution should efficiently calculate the balance score based on the provided criteria. 2. Ensure that the calculation accounts for both \'high\' and \'low\' preferable values as specified in the criteria. 3. Calculate the balance score as the sum of the absolute differences between the actual and ideal values for each attribute, normalized by the criterion\'s importance. # Calculation Tips 1. For each attribute in a stock, determine the absolute difference between the actual value and the ideal value. 2. Adjust the difference based on whether a higher or lower value is preferable according to the criteria. 3. Sum these adjusted differences to get the final balance score for each stock. 4. Append the balance score to each stock\'s data in `portfolio_data`. # Additional Example: ```python portfolio_data = [ [15.0, 5.5, 4.2], [13.8, 7.2, 3.8], [12.1, 8.3, 4.5] ] criteria = [(14.0, \'high\'), (6.0, \'low\'), (4.0, \'high\')] result = calculate_balance_score(portfolio_data, criteria) print(result) # Expected Output: # [ # [15.0, 5.5, 4.2, 1.2], # [13.8, 7.2, 3.8, 2.0], # [12.1, 8.3, 4.5, 2.4] # ] ```","solution":"def calculate_balance_score(portfolio_data, criteria): Calculate the balance score for each stock based on the performance attributes and predefined criteria. Args: - portfolio_data (list[list[float]]): List of stocks, each stock is a list of performance metrics. - criteria (list[tuple[float, str]]): List of tuples where each tuple consists of a target value and a preference (\'high\' or \'low\'). Returns: - list[list[float]]: Updated portfolio_data with an additional balance score for each stock. for stock in portfolio_data: balance_score = 0 for index, (actual_value, (ideal_value, preference)) in enumerate(zip(stock, criteria)): if preference == \'high\': score = abs(ideal_value - actual_value) / ideal_value else: # preference == \'low\' score = abs(actual_value - ideal_value) / ideal_value balance_score += score stock.append(balance_score) return portfolio_data"},{"question":"# Binary Search Tree Iterator In this task, you need to implement an iterator for a Binary Search Tree (BST). The iterator should provide the functionality to traverse the BST in ascending order with `O(1)` space complexity (excluding the stack space for recursion or iteration). Objective Create a class `BSTIterator` with the following methods: * `__init__(self, root: Optional[TreeNode]) -> None`: Initializes the iterator with the root of the BST. * `next(self) -> int`: Returns the next smallest number in the BST. * `hasNext(self) -> bool`: Returns whether the next smallest number is available. Input * `root`: The root node of the BST. Output * `next()`: Gets the next smallest number in the BST. * `hasNext()`: Returns `True` if there is a next number, otherwise returns `False`. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * `-10^5 <= Node.val <= 10^5` Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: # Construct BST root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) print(iterator.next()) # 3 print(iterator.next()) # 7 print(iterator.hasNext()) # True print(iterator.next()) # 9 print(iterator.hasNext()) # True print(iterator.next()) # 15 print(iterator.hasNext()) # True print(iterator.next()) # 20 print(iterator.hasNext()) # False ``` Requirements * Implement the `BSTIterator` class ensuring optimal space complexity. * Traverse the BST in an increasing order. * The iterator should be implemented without using additional memory for storing all the values of the BST. Implement your solution below: ```python class BSTIterator: def __init__(self, root: Optional[TreeNode]) -> None: self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode) -> None: self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"# Scenario You are a developer at a company that specializes in data visualization. Your task is to create a program that efficiently identifies the k smallest elements in a large dataset for real-time graphing purposes. Given the constraints on time and space, you need to implement a solution that can handle high volumes of data quickly and efficiently. # Coding Task Implement a function `k_smallest_elements` that accepts an unsorted list of integers and an integer k, and returns the k smallest elements in the list in ascending order. # Constraints 1. **Inputs**: - `data`: List of integers, 1 ≤ len(data) ≤ 10^6, -10^9 ≤ elements within data ≤ 10^9. - `k`: Integer, 1 ≤ k ≤ len(data). 2. **Outputs**: - Return a list of k integers, representing the k smallest elements from the input list in ascending order. # Example ```python def k_smallest_elements(data: list, k: int) -> list: # Implementation required here # Test Cases assert k_smallest_elements([5, 3, 8, 2, 9, 1], 3) == [1, 2, 3] assert k_smallest_elements([30, 20, 10, 40, 50], 2) == [10, 20] assert k_smallest_elements([-10, -30, -20, 10, 0], 4) == [-30, -20, -10, 0] assert k_smallest_elements([1], 1) == [1] assert k_smallest_elements([7, 7, 7, 7, 7], 3) == [7, 7, 7] ``` # Additional Requirements 1. **Efficiency**: Ensure the solution can handle the upper limits of the input sizes efficiently using appropriate algorithms like Heap or Quickselect. 2. **Edge Cases**: - Handle cases with duplicate elements correctly. - Ensure that the function can manage very large and very small integer inputs within the given constraints. Write clean, efficient, and well-commented code to ensure clarity and maintainability.","solution":"import heapq def k_smallest_elements(data: list, k: int) -> list: Returns the k smallest elements from the list \'data\' in ascending order. if k == 0 or not data: return [] # Use a heap to efficiently find the k smallest elements k_smallest = heapq.nsmallest(k, data) return sorted(k_smallest)"},{"question":"# Problem Statement A self-powering number is a four-digit number that equals the sum of its digits each raised to the power of the number itself. For example, 9474 is a self-powering number because ( 9^4 + 4^4 + 7^4 + 4^4 = 9474 ). Write a function `find_self_powering_numbers()` that returns a list of all self-powering numbers within the range of four-digit numbers. Function Signature ```python def find_self_powering_numbers() -> List[int]: pass ``` Output - A list of integers, each representing a self-powering number. Example ```python >>> find_self_powering_numbers() [1634, 8208, 9474] ``` # Requirements 1. Create a helper function to calculate if a number is self-powering. 2. Implement efficient calculations to test all four-digit numbers. 3. Ensure that the function returns results sorted in ascending order.","solution":"from typing import List def is_self_powering_number(num: int) -> bool: Check if a number is a self-powering number. digits = [int(d) for d in str(num)] power_sum = sum(d ** len(digits) for d in digits) return power_sum == num def find_self_powering_numbers() -> List[int]: Find all self-powering numbers within the range of four-digit numbers. result = [] for num in range(1000, 10000): if is_self_powering_number(num): result.append(num) return result"},{"question":"# Breadth-First Search (BFS) for Shortest Path in a Binary Tree **Background**: Given a binary tree, implement an algorithm to find the shortest path from the root node to any given target leaf node. A binary tree is defined as a data structure in which each node has at most two children, referred to as the left child and the right child. **Objective**: You need to implement a function to find the shortest path from the root to a target leaf node using the Breadth-First Search (BFS) algorithm. The path should be returned as a list of node values. # Requirements 1. **find_shortest_path(root, target)**: This function should return the list of node values representing the shortest path from the root to the target leaf node using BFS. If the target node is not found in the tree, it should return an empty list. **Function Signature**: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_shortest_path(root, target): pass ``` # Input and Output **Find Shortest Path** * **Input**: `root` - the root node of the tree, `target` - the value of the target leaf node. * **Output**: A list of integers representing the node values from the root to the target leaf node. # Constraints 1. The node values in the binary tree are unique. 2. The `target` value is guaranteed to be in one of the leaf nodes. 3. The maximum number of nodes in the binary tree does not exceed 10,000. # Example ```python # Tree structure: # 1 # / # 2 3 # / / # 4 5 6 # / # 7 8 >>> root = TreeNode(1, ... TreeNode(2, ... TreeNode(4, ... TreeNode(7), ... TreeNode(8)), ... None), ... TreeNode(3, ... TreeNode(5), ... TreeNode(6))) >>> find_shortest_path(root, 7) [1, 2, 4, 7] >>> find_shortest_path(root, 5) [1, 3, 5] >>> find_shortest_path(root, 6) [1, 3, 6] >>> find_shortest_path(root, 10) [] ``` Complete the implementation of the `find_shortest_path` function to meet these requirements.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_shortest_path(root, target): if not root: return [] from collections import deque # Use a deque for BFS. Queue will store tuples of (node, path). queue = deque([(root, [root.value])]) while queue: node, path = queue.popleft() # If we find the target leaf node, return the path. if node.value == target: return path # Check the children and add them to the queue with updated paths. if node.left: queue.append((node.left, path + [node.left.value])) if node.right: queue.append((node.right, path + [node.right.value])) return [] # This line should ideally never be reached due to the given constraint."},{"question":"# Parents-Children Tree Relationship Context You are given a tree structure represented as a list of tuples, where each tuple represents a parent-child relationship. Your task is to build a function that verifies specific parent-child relationships based on the tree data. Task Description 1. **Build the Tree Structure**: Write a function that parses the list of tuples into a tree structure where each node keeps track of its parent and children. 2. **Relationship Verification**: Extend the function to verify if a given node is a child of another node. Function Signature: ```python def verify_relationship(tree_data: list, parent: int, child: int) -> bool: Verify if one node is a child of another in a given tree. :param tree_data: list of tuples (parent, child) representing the tree\'s structure :param parent: an integer representing the parent node :param child: an integer representing the child node :return: boolean indicating whether the child is under the given parent Examples: >>> verify_relationship([(1, 2), (1, 3), (2, 4), (2, 5)], 1, 4) True >>> verify_relationship([(1, 2), (1, 3), (2, 4), (2, 5)], 2, 3) False >>> verify_relationship([(1, 2), (1, 3), (2, 4), (2, 5)], 3, 1) False >>> verify_relationship([(1, 2), (1, 3), (2, 4), (2, 5)], 1, 1) False ``` Constraints: * The input list will contain tuples of integers where each tuple indicates a direct parent-child relationship. * Each node in the tree has unique integer identifiers. * The input list should form a valid tree, meaning there will be no cycles, and there is exactly one root. * Both parent and child input values are guaranteed to be present in the tree data. Additional Requirements: * Optimize the function to handle the tree traversal and relationship verification efficiently. * If the parent and child input values are the same, the function should return False.","solution":"def verify_relationship(tree_data: list, parent: int, child: int) -> bool: Verify if one node is a child of another in a given tree. :param tree_data: list of tuples (parent, child) representing the tree\'s structure :param parent: an integer representing the parent node :param child: an integer representing the child node :return: boolean indicating whether the child is under the given parent if parent == child: return False # Build a dictionary where each key is a parent and value is the list of children tree = {} for p, c in tree_data: if p in tree: tree[p].append(c) else: tree[p] = [c] # Helper function to perform DFS search def is_child(current_node, target): if current_node not in tree: return False if target in tree[current_node]: return True for child in tree[current_node]: if is_child(child, target): return True return False return is_child(parent, child)"},{"question":"# Question: Implement Tarjan\'s Algorithm to Find Strongly Connected Components **Background:** Tarjan\'s Algorithm is used to find all Strongly Connected Components (SCCs) in a directed graph. A strongly connected component is a maximal subgraph where every vertex is reachable from every other vertex within the subgraph. **Task:** Implement Tarjan\'s Algorithm in Python to find and return all SCCs of a directed graph. The algorithm uses depth-first search (DFS) and recursiveness to identify the strongly connected components. **Function Signature:** ```python class TarjanSCC: def __init__(self, num_of_nodes: int) -> None: # Initialization function def add_edge(self, u_node: int, v_node: int) -> None: # Adds a directed edge to the graph def tarjan_scc(self) -> list[list[int]]: # Executes Tarjan\'s Algorithm and returns a list of SCCs ``` **Expected Input and Output Formats:** - `__init__: TarjanSCC(n)`: initializes a graph with `n` nodes. - `add_edge(u_node: int, v_node: int)`: adds a directed edge from `u_node` to `v_node`. - `tarjan_scc() -> list[list[int]]`: executes Tarjan\'s Algorithm and returns a list of SCCs, where each SCC is represented as a list of node indices. **Constraints:** 1. The graph may have one or more strongly connected components. 2. The number of nodes `n` will be between 2 and 1000. 3. The number of edges `m` will be between 1 and 10000. **Performance Requirements:** The solution should handle graphs up to the given limits efficiently, utilizing O(V + E) time complexity. **Example:** ```python g = TarjanSCC(8) for u, v in [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 5), (5, 6), (6, 4), (6, 7)]: g.add_edge(u, v) sccs = g.tarjan_scc() print(sccs) # Expected output: [[2, 1, 0], [3], [6, 5, 4], [7]] ``` Implement the missing methods in the `TarjanSCC` class to complete Tarjan\'s Algorithm and ensure that it correctly identifies and returns all strongly connected components in the graph.","solution":"class TarjanSCC: def __init__(self, num_of_nodes: int) -> None: self.num_of_nodes = num_of_nodes self.graph = [[] for _ in range(num_of_nodes)] self.index = 0 self.indexes = [-1] * num_of_nodes self.low_links = [-1] * num_of_nodes self.on_stack = [False] * num_of_nodes self.stack = [] self.sccs = [] def add_edge(self, u_node: int, v_node: int) -> None: self.graph[u_node].append(v_node) def tarjan_scc(self) -> list[list[int]]: for i in range(self.num_of_nodes): if self.indexes[i] == -1: self._strongconnect(i) return self.sccs def _strongconnect(self, node: int) -> None: self.indexes[node] = self.low_links[node] = self.index self.index += 1 self.stack.append(node) self.on_stack[node] = True for neighbor in self.graph[node]: if self.indexes[neighbor] == -1: self._strongconnect(neighbor) self.low_links[node] = min(self.low_links[node], self.low_links[neighbor]) elif self.on_stack[neighbor]: self.low_links[node] = min(self.low_links[node], self.indexes[neighbor]) if self.low_links[node] == self.indexes[node]: scc = [] while True: w = self.stack.pop() self.on_stack[w] = False scc.append(w) if w == node: break self.sccs.append(scc)"},{"question":"Scenario You have been contracted to design an automated grading system for coding assignments. The system should be able to evaluate the accuracy of student submissions by comparing them to the expected outputs. A specific requirement is to implement a function that calculates the similarity between two strings using the Levenshtein distance. This measurement will help in assessing how closely a student\'s answer matches the correct answer, accounting for minor typographical errors. Problem Statement Write a function `levenshtein_distance` that, given two strings, calculates and returns the minimum number of single-character deletions, insertions, or substitutions required to transform one string into the other. # Function Signature ```python def levenshtein_distance(str1: str, str2: str) -> int: ``` # Input * Two strings `str1` and `str2` representing the student\'s answer and the correct answer respectively. # Output * An integer representing the Levenshtein distance between the two strings. # Constraints * 1 <= len(str1), len(str2) <= 1000 * str1 and str2 consist of printable ASCII characters. # Example ```python str1 = \\"kitten\\" str2 = \\"sitting\\" result = levenshtein_distance(str1, str2) # This should return 3, as \\"kitten\\" can be transformed into \\"sitting\\" by: # - Substituting \'k\' with \'s\' # - Substituting \'e\' with \'i\' # - Inserting \'g\' at the end str1 = \\"flaw\\" str2 = \\"lawn\\" result = levenshtein_distance(str1, str2) # This should return 2, as \\"flaw\\" can be transformed into \\"lawn\\" by: # - Deleting \'f\' # - Substituting \'a\' with \'o\' ``` # Additional Information * The Levenshtein distance (also known as edit distance) quantifies how dissimilar two strings are by counting the minimum number of operations required to transform one string into the other. * The algorithm should handle edge cases efficiently, such as when one or both strings are empty, and optimally for long strings of up to 1000 characters. * The solution should consider the time complexity and strive for an optimized approach to ensure performance remains acceptable for the given constraints.","solution":"def levenshtein_distance(str1: str, str2: str) -> int: m, n = len(str1), len(str2) # Initialize the table with zeros dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: when one of the strings is empty for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: cost = 0 else: cost = 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution # The answer is in the bottom-right corner of the matrix return dp[m][n]"},{"question":"# Sum of Elements Divisible by K Problem Statement You are given an array of `n` integers and an integer value `k`. Your task is to return the sum of all elements in the array that are divisible by `k`. Function Signature ```python def sum_divisible_by_k(arr: List[int], k: int) -> int: ``` Input * `arr`: A list of integers `a0, a1, ..., an-1` where `abs(ai) <= 10^6`. This represents the list of integers. * `k`: An integer `1 <= k <= 10^6`. This represents the divisor. Output * Return an integer which is the sum of all elements in `arr` that are divisible by `k`. Constraints * The length of `arr` will be between `1` and `10^6`. Example ```python sum_divisible_by_k([1, 2, 3, 4, 5, 6], 2) # returns 12 sum_divisible_by_k([-10, -20, 15, 25], 5) # returns 10 sum_divisible_by_k([3, 7, 14, 18, 21], 7) # returns 42 sum_divisible_by_k([5], 5) # returns 5 sum_divisible_by_k([1, 2, 3], 10) # returns 0 ``` Explanation * The function `sum_divisible_by_k([1, 2, 3, 4, 5, 6], 2)` returns `12` because the elements divisible by `2` are `[2, 4, 6]` and their sum is `12`. * The function `sum_divisible_by_k([-10, -20, 15, 25], 5)` returns `10` because the elements divisible by `5` are `[-10, -20, 15, 25]` and their sum is `10`. Instructions 1. Iterate through each element in the array. 2. Check if the element is divisible by `k` without any remainder. 3. If true, add the element to the sum. 4. Return the final sum of all such elements.","solution":"from typing import List def sum_divisible_by_k(arr: List[int], k: int) -> int: Returns the sum of all elements in the array that are divisible by k. return sum(x for x in arr if x % k == 0)"},{"question":"# Question Context: As a part of a data processing pipeline, you need to handle and process large datasets that are divided and stored across multiple servers. Efficiently locating and extracting subsets of this data is crucial for maintaining overall system performance. # Coding Task: Implement a function `merge_sorted_arrays_and_find_median` which takes as input a list of lists where each inner list is sorted in ascending order. You need to merge these sorted arrays and find the median of the combined dataset. # Input: * A list of lists where each inner list is sorted in ascending order. # Output: * A float representing the median of the combined data from all lists. # Constraints: * Each list contains integers and is sorted in non-decreasing order. * The total number of elements across all lists will be at least 1. * The combined number of elements is guaranteed to be odd, ensuring a singular median element. # Performance Requirements: * Your solution should effectively merge the lists and find the median, with desirable efficiency in terms of both time and space complexity, typically aiming for a complexity around O(n log k) where n is the number of elements and k is the number of lists. # Example Scenario: Consider the following example scenario for a better understanding: ```python def merge_sorted_arrays_and_find_median(arrays: List[List[int]]) -> float: # Your implementation here pass # Example: arrays = [ [1, 3, 5], [2, 4, 6], [0, 8, 9] ] # The combined sorted array is [0, 1, 2, 3, 4, 5, 6, 8, 9] # The median of the combined array is 4 print(merge_sorted_arrays_and_find_median(arrays)) # Output: 4.0 ```","solution":"from heapq import merge from typing import List def merge_sorted_arrays_and_find_median(arrays: List[List[int]]) -> float: Merges multiple sorted arrays and finds the median of the combined sorted array. :param arrays: A list of lists where each inner list is sorted in ascending order. :return: The median of the combined sorted data. combined = list(merge(*arrays)) length = len(combined) median = combined[length // 2] return float(median)"},{"question":"# Task Overview: You are given a list of integers which represents the weights of different items. Your task is to check whether it\'s possible to partition the list into two subsets such that the sum of the weights of the items in both subsets is equal. # Function Signature: ```python def can_partition(items: list[int]) -> bool: Determine if the list of integers can be partitioned into two subsets with equal sum. Parameters: items (list[int]): A list of integers representing the weights. Returns: bool: True if the list can be partitioned into two subsets with equal sum, False otherwise. ``` # Input: - `items`: A list of integers. Each integer represents the weight of an item and is guaranteed to be non-negative. # Output: - A boolean value `True` if the list can be partitioned into two subsets with equal sum, `False` otherwise. # Constraints: - The input list will have at most 100 integers. - Each integer in the list will be at most 1000. # Examples: ```python >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1, 1, 1, 1, 1, 1]) True ``` # Explanation: 1. **First Example:** The list is `[1, 5, 11, 5]`. It can be partitioned into `[1, 5, 5]` and `[11]` both with sum `11`. Therefore, the output is `True`. 2. **Second Example:** The list is `[1, 2, 3, 5]`. It cannot be partitioned into subsets with equal sum. Therefore, the output is `False`. 3. **Third Example:** The list is `[1, 1, 1, 1, 1, 1]`. It can be partitioned into `[1, 1, 1]` and `[1, 1, 1]` both with sum `3`. Therefore, the output is `True`. # Additional Notes: To solve this problem, consider dynamic programming approaches that involve finding subsets sums. You need to check if there is a subset whose sum equals half of the total sum of the items. If such a subset exists, the remaining elements will naturally form the other subset with the same sum. Proper handling of various edge cases such as empty lists and lists with all similar items must be considered.","solution":"def can_partition(items: list[int]) -> bool: Determine if the list of integers can be partitioned into two subsets with equal sum. Parameters: items (list[int]): A list of integers representing the weights. Returns: bool: True if the list can be partitioned into two subsets with equal sum, False otherwise. total_sum = sum(items) # If the total sum is odd, it\'s not possible to partition it into two equal subsets. if total_sum % 2 != 0: return False # Find subset with sum equal to half of the total sum. target = total_sum // 2 n = len(items) # Initialize a DP array where dp[i] will be True if a subset sum of i is possible with the given items. dp = [False] * (target + 1) dp[0] = True # Zero sum is always possible with an empty subset. for item in items: for i in range(target, item - 1, -1): dp[i] = dp[i] or dp[i - item] return dp[target]"},{"question":"# Coding Assessment Question: Scenario: You have been hired by a company developing a social media platform with various features, including text analysis and suggestions. One of your goals is to implement a system that checks whether a given post is a duplicate of any existing post in the database. Two posts are considered duplicates if one is a permutation of the other, disregarding spaces and punctuation. Task: Write a function `is_duplicate_post` that: 1. Accepts a string `new_post` and a list of string `existing_posts`. 2. Normalizes the `new_post` and each post in `existing_posts` by removing spaces and punctuation, and converting all characters to lowercase. 3. Checks whether any of the normalized `existing_posts` is a permutation of the normalized `new_post`. 4. Returns a boolean value indicating whether the `new_post` is a duplicate. Constraints: * The length of `new_post` and each post in `existing_post` will be between 1 and 1000. * The list `existing_posts` can contain up to 10^4 posts. Function Signature: ```python def is_duplicate_post(new_post: str, existing_posts: List[str]) -> bool: pass ``` Input: * `new_post`: A string representing the new social media post. * `existing_posts`: A list of strings representing the database of existing posts. Output: * A boolean value indicating whether the `new_post` is a duplicate. Performance Requirements: * The implementation should handle the given constraints efficiently, both in terms of time and space complexity. Example: ```python new_post = \\"Hello World!\\" existing_posts = [\\"!world hello\\", \\"Hi there\\", \\"Hello!\\"] result = is_duplicate_post(new_post, existing_posts) print(result) ``` Expected Output: ```python True ``` Note: * You may use any pre-defined libraries or functions for string manipulation available in your coding environment. * Ensure your function is self-contained and imports any necessary modules. * Consider edge cases such as empty strings or posts comprised entirely of punctuation.","solution":"import string from typing import List def normalize_post(post: str) -> str: Normalizes the post by removing spaces, punctuation and converting to lowercase. return \'\'.join(char for char in post.lower() if char not in string.whitespace + string.punctuation) def is_duplicate_post(new_post: str, existing_posts: List[str]) -> bool: Checks if new_post is a duplicate of any posts in existing_posts based on normalization. normalized_new_post = sorted(normalize_post(new_post)) for post in existing_posts: if sorted(normalize_post(post)) == normalized_new_post: return True return False"},{"question":"# Task Scheduler Function Write a function in Python called `schedule_task` that accepts the following parameters: 1. `task_duration` (int): The duration of the task in minutes. 2. `start_time` (str): The starting time of the task in \\"HH:MM\\" 24-hour format. 3. `end_time` (str): The end time by which the task must be completed, also in \\"HH:MM\\" 24-hour format. The function should return a list of tuples where each tuple represents a time slot (start and end time) during which the task can be scheduled without overlapping the end time. Each time slot should also maintain the task duration specified. # Constraints: * Assume `start_time` and `end_time` are on the same day. * If it\'s impossible to schedule the task within the given time frame, return an empty list. # Inputs: * `task_duration`: a positive integer representing duration of the task in minutes. * `start_time`: a string in \\"HH:MM\\" 24-hour format. * `end_time`: a string in \\"HH:MM\\" 24-hour format. # Outputs: * A list of tuples, where each tuple consists of two strings representing the start and end times of the valid time slots. # Example: ```python print(schedule_task(30, \\"09:00\\", \\"12:00\\")) ``` Should return: ```python [ (\\"09:00\\", \\"09:30\\"), (\\"09:30\\", \\"10:00\\"), (\\"10:00\\", \\"10:30\\"), (\\"10:30\\", \\"11:00\\"), (\\"11:00\\", \\"11:30\\"), (\\"11:30\\", \\"12:00\\") ] ``` If it\'s impossible to schedule the task, for instance: ```python print(schedule_task(90, \\"09:00\\", \\"10:00\\")) ``` Should return: ```python [] ``` # Hints: * Use Python\'s `datetime` module to handle time calculations. * Ensure the calculated end time of each slot doesn\'t exceed the given end time. * Convert times to minutes for easier arithmetic and then back to \\"HH:MM\\" format when constructing the result.","solution":"from datetime import datetime, timedelta def schedule_task(task_duration, start_time, end_time): Returns a list of tuples where each tuple represents a time slot (start and end time) during which the task can be scheduled to fit within the provided time frame. def convert_to_minutes(time_str): Convert HH:MM time format to minutes since midnight. time = datetime.strptime(time_str, \\"%H:%M\\") return time.hour * 60 + time.minute def convert_to_hhmm(minutes): Convert minutes since midnight to HH:MM time format. hours = minutes // 60 mins = minutes % 60 return f\\"{hours:02}:{mins:02}\\" start_minutes = convert_to_minutes(start_time) end_minutes = convert_to_minutes(end_time) slots = [] current_start = start_minutes while current_start + task_duration <= end_minutes: current_end = current_start + task_duration slots.append((convert_to_hhmm(current_start), convert_to_hhmm(current_end))) current_start += task_duration return slots"},{"question":"Question # Scenario You need to assist a data analyst in identifying patterns of prime numbers within specific numerical ranges. In particular, you are required to determine the number of prime pairs (twin primes) within a given range that satisfy a certain condition. # Problem Statement A twin prime is a pair of prime numbers that have a difference of 2 (e.g., 3 and 5, 11 and 13). You need to write a function that, given an integer ( n ), returns the total number of twin prime pairs ((p, p+2)) such that both ( p ) and ( p + 2 ) are prime and less than ( n ). # Function Signature ```python def count_twin_primes(n: int) -> int: ``` # Input * An integer, `n`, representing the upper bound (exclusive) for the prime numbers (2 ≤ n ≤ 1,000,000). # Output * An integer representing the number of twin prime pairs where both primes are less than the given limit. # Example ```python >>> count_twin_primes(10) 2 >>> count_twin_primes(25) 4 >>> count_twin_primes(100) 8 ``` # Constraints * The solution should efficiently handle large input values up to 1,000,000. * Ensure the implementation accounts for the properties of prime numbers and avoids redundant calculations. # Implementation Reminder * Use an efficient algorithm to determine prime numbers (e.g., Sieve of Eratosthenes). * Pay attention to edge cases and ensure the function works correctly for the lower bounds of the input range.","solution":"def count_twin_primes(n: int) -> int: Returns the count of twin prime pairs (p, p+2) where both primes are less than n. if n < 3: return 0 sieve = [True] * n sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False twin_prime_count = 0 for p in range(2, n - 2): if sieve[p] and sieve[p + 2]: twin_prime_count += 1 return twin_prime_count"},{"question":"Scenario You are contracted by a logistics company to develop a function that helps them optimize their truck load scheduling. The task is to calculate the maximum value of goods that can be transported given the capacity and a list of items with specific weights and values. Function Specification # Function Name `knapsack` # Inputs - `capacity` (int): the maximum weight capacity of the truck. - `items` (List[Tuple[int, int]]): a list of tuples where each tuple contains the weight and value of an item. # Output - An integer representing the maximum value of goods that can be transported without exceeding the capacity. # Constraints - `0 <= capacity <= 10000` - `1 <= len(items) <= 1000` - `1 <= weight, value <= 1000` for each item # Example Cases Example 1 ```python items = [(1, 1), (3, 4), (4, 5), (5, 7)] capacity = 7 assert knapsack(capacity, items) == 9 ``` Example 2 ```python items = [(2, 3), (3, 4), (4, 5), (5, 8)] capacity = 5 assert knapsack(capacity, items) == 8 ``` Example 3 ```python items = [(6, 50), (4, 40), (3, 30), (5, 10)] capacity = 10 assert knapsack(capacity, items) == 90 ``` Example 4 ```python items = [(2, 10), (3, 20), (4, 30), (5, 50)] capacity = 5 assert knapsack(capacity, items) == 50 ``` Notes - This problem is a typical \\"0/1 Knapsack Problem\\" which is a classic dynamic programming problem. - Ensure the function handles the edge cases correctly such as when the capacity is zero or when no items can be taken due to their weights. - The function must be optimized for performance given the constraints.","solution":"def knapsack(capacity, items): Calculate the maximum value of items that can be included in the knapsack without exceeding the capacity. Parameters: capacity (int): The maximum weight capacity of the knapsack. items (List[Tuple[int, int]]): A list of tuples where each tuple contains the weight and value of an item. Returns: int: The maximum value of items that can be included in the knapsack. n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): weight, value = items[i - 1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Problem Statement Write a function that determines if two provided trees are mirroring each other. In other words, for two binary trees, the left subtree of one tree should be the mirror of the right subtree of the other tree and vice versa. # Function Specification **Function Name**: `are_mirror_trees` **Input**: * `tree1` (TreeNode): The root node of the first binary tree. * `tree2` (TreeNode): The root node of the second binary tree. **Output**: * `bool`: Returns `True` if the two trees are mirroring each other, otherwise returns `False`. # Constraints * Both input trees consist of nodes containing integer values. * The number of nodes in both trees will not exceed 1000. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Trees tree1 = TreeNode(1) tree1.left = TreeNode(2) tree1.right = TreeNode(3) tree1.left.left = TreeNode(4) tree1.left.right = TreeNode(5) tree2 = TreeNode(1) tree2.right = TreeNode(2) tree2.left = TreeNode(3) tree2.right.right = TreeNode(4) tree2.right.left = TreeNode(5) print(are_mirror_trees(tree1, tree2)) # Output: True ``` # Function Description Ensure your function works optimally for large trees and handles edge cases such as: * Both trees being empty. * Only one tree being empty. * Trees with different structures but same node values. # Implementation Note Recursively compare the left subtree of one tree with the right subtree of the other to determine if they are mirrors.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_mirror_trees(tree1, tree2): Determines if two provided trees are mirroring each other. if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.val == tree2.val and are_mirror_trees(tree1.left, tree2.right) and are_mirror_trees(tree1.right, tree2.left))"},{"question":"# Coding Assessment Question You are provided with a Python function that checks whether a given string is a valid palindrome by considering alphanumeric characters and ignoring cases. # Task Write a Python function that performs the following: 1. Reads a list of strings. 2. For each string, determines if it is a valid palindrome using the provided function. 3. Separate the palindromic strings from the non-palindromic ones. 4. Return a dictionary with two keys: \\"palindromes\\" and \\"non_palindromes\\", where each key maps to a list of strings that correspond to its category. # Provided Function ```python def is_palindrome(s: str) -> bool: s = \'\'.join(c.lower() for c in s if c.isalnum()) return s == s[::-1] ``` # Requirements: 1. **Input**: A list of strings. 2. **Output**: A dictionary with \\"palindromes\\" and \\"non_palindromes\\" as keys. 3. **Constraints**: * Each string in the input list can be up to 1,000,000 characters long. * The input list can contain up to 100,000 strings. * The input list can be empty. In such a case, both keys in the dictionary should map to empty lists. # Performance: * The function must handle large inputs efficiently, optimizing both time and space complexity. Examples: ```python # Provided function: def is_palindrome(s: str) -> bool: s = \'\'.join(c.lower() for c in s if c.isalnum()) return s == s[::-1] # Example 1: input_list = [\\"A man, a plan, a canal: Panama\\", \\"race a car\\", \\" \\"] categorize_palindromes(input_list) # Output: {\\"palindromes\\": [\\"A man, a plan, a canal: Panama\\", \\" \\"], \\"non_palindromes\\": [\\"race a car\\"]} # Example 2: input_list = [\\"madam\\", \\"step on no pets\\", \\"hello\\", \\"world\\"] categorize_palindromes(input_list) # Output: {\\"palindromes\\": [\\"madam\\", \\"step on no pets\\"], \\"non_palindromes\\": [\\"hello\\", \\"world\\"]} # Example 3: input_list = [] categorize_palindromes(input_list) # Output: {\\"palindromes\\": [], \\"non_palindromes\\": []} ``` Write the `categorize_palindromes` function following the guidelines above.","solution":"def categorize_palindromes(strings): def is_palindrome(s: str) -> bool: s = \'\'.join(c.lower() for c in s if c.isalnum()) return s == s[::-1] palindromes = [] non_palindromes = [] for string in strings: if is_palindrome(string): palindromes.append(string) else: non_palindromes.append(string) return {\\"palindromes\\": palindromes, \\"non_palindromes\\": non_palindromes}"},{"question":"# Problem Statement You are given an array of integers that represents the heights of a series of vertical lines drawn on a Cartesian plane at equally spaced intervals. Your task is to write a function `max_water_area` that calculates the maximum amount of water that can be contained between any two lines. The width between each pair of lines is constant and equal to the difference in their indices. The amount of water that can be contained between two lines is determined by the shorter of the two lines, multiplied by the distance between them. Input - A list of integers representing the heights of the lines. Output - An integer representing the maximum water area. Constraints - The list contains at least 2 and at most 100,000 integers. - Each integer height is a non-negative value not exceeding 10,000. Function Signature ```python def max_water_area(heights: List[int]) -> int: ``` Example Suppose the given array of heights is: ```text [1, 8, 6, 2, 5, 4, 8, 3, 7] ``` Here is the maximum water area computation: - Between lines at indices 1 (height 8) and 8 (height 7), the water area is 49 (min(8,7) * (8-1)). - Several other combinations are possible, but none yields a larger area than this. Therefore, the output should be: ```text 49 ``` Requirements - Implement the function in Python. - Ensure the function efficiently handles the input size constraints. - Use an optimal approach to achieve the desired result within a reasonable time complexity.","solution":"from typing import List def max_water_area(heights: List[int]) -> int: Calculates the maximum water area that can be contained between two lines in the heights array. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) # Move the pointer that points to the shorter line if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"**String Permutations Counter** You are tasked with creating a function that counts all the unique permutations of a given string. The function should return the number of distinct permutations that can be made from the characters of the string. # Problem Statement Write a function `count_permutations(s: str) -> int` that takes a string and returns the count of unique permutations of the characters in the string. # Function Signature ```python def count_permutations(s: str) -> int: ``` # Input * `s`: A string of lowercase English letters (`1 <= len(s) <= 10`). # Output * An integer representing the number of unique permutations of the input string. # Constraints 1. The string will only contain lowercase English letters. 2. Ensure that the function handles strings with repeated characters correctly. # Performance Considerations 1. Consider the factorial growth of permutations as string length increases. 2. Handle strings with repeated characters efficiently to avoid redundant computations. # Examples ```python >>> count_permutations(\\"abc\\") 6 >>> count_permutations(\\"aab\\") 3 >>> count_permutations(\\"aaa\\") 1 >>> count_permutations(\\"abcd\\") 24 >>> count_permutations(\\"aabb\\") 6 ``` # Requirements 1. If the input string contains only unique characters, the number of permutations should be equal to the factorial of the length of the string. 2. Handle repeated characters by dividing the factorial of the length of the string by the factorial of the counts of each character. 3. Ensure the function can handle edge cases, such as strings with all identical characters. This new question is designed to challenge the understanding of combinatorics and permutations, aligning with the complexity and scope of the original question set.","solution":"from math import factorial from collections import Counter def count_permutations(s: str) -> int: Returns the count of unique permutations of the input string s. n = len(s) if n == 0: return 0 freq_count = Counter(s) denominator = 1 for count in freq_count.values(): denominator *= factorial(count) return factorial(n) // denominator"},{"question":"**Task**: Implement a function `find_minimum_spanning_tree(graph: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]` that takes a connected, undirected graph represented as a list of edges, where each edge is defined by a tuple (u, v, w) signifying an edge between node u and node v with weight w. The function should return a list of tuples representing the edges in the Minimum Spanning Tree (MST) of the graph using **Kruskal\'s Algorithm**. **Requirements**: - Implement **Kruskal\'s Algorithm** to find the MST of the given graph. - Use the **Union-Find** (disjoint-set) data structure to efficiently manage the merging of sets. **Input/Output Specification**: - **Input**: `graph` - A list of tuples, where each tuple (u, v, w) represents an edge in the graph with u and v being the nodes and w being the weight of the edge. - **Output**: A list of tuples representing the edges included in the MST of the input graph. The output list should contain tuples (u, v, w) sorted in increasing order of weights. - **Constraints**: - The graph is connected, ensuring there\'s at least one valid MST. - Node identifiers are non-negative integers. - If there are multiple edges with the same weight, their order in the output does not matter as long as the resulting edges form a valid MST. **Performance**: Your implementation should be efficient, ideally running in O(E log E) time, where E is the number of edges in the graph. **Scenario**: Given an input graph, you need to: - Sort the edges in non-decreasing order of their weights. - Use the Union-Find data structure to detect cycles and manage connected components. - Add edges to the MST until it includes exactly (V-1) edges, where V is the number of vertices in the graph. **Edge Cases**: - Graphs with multiple edges between the same pair of nodes. - Graphs with very few nodes or edges. - Graphs where all edges have the same weight. Implement and thoroughly test the `find_minimum_spanning_tree` function to ensure it correctly identifies the MST for various graph configurations, including edge cases. ```python def find_minimum_spanning_tree(graph: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: # Helper functions can be defined within this block, such as find and union for the union-find data structure. # ToDo: Implement the function based on the description. # Sort edges by weight. # Initialize Union-Find structures. # Construct MST by adding edges one by one, checking for cycles using Union-Find. # Return the list of edges in the MST. pass # Example usage: # graph = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] # print(find_minimum_spanning_tree(graph)) # Expected Output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)] ```","solution":"from typing import List, Tuple def find_minimum_spanning_tree(graph: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Function to find minimum spanning tree using Kruskal\'s algorithm. Parameters: graph (List[Tuple[int, int, int]]): A list of tuples where each tuple represents an edge (u, v, w) Returns: List[Tuple[int, int, int]]: A list of tuples representing the edges in the Minimum Spanning Tree (MST). # Helper function to find the root of node x def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] # Helper function to unite two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Sort edges by weight edges = sorted(graph, key=lambda edge: edge[2]) # Initialize Union-Find structure parent = {} rank = {} for u, v, _ in edges: if u not in parent: parent[u] = u rank[u] = 0 if v not in parent: parent[v] = v rank[v] = 0 # Kruskal\'s algorithm mst = [] for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst.append((u, v, w)) return mst # Example: # graph = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] # print(find_minimum_spanning_tree(graph)) # Expected Output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)]"},{"question":"# Context You are developing software for a library system that lends out books to users. Each book has a title, author, and a collection of tags representing genres or features like \\"fiction,\\" \\"history,\\" or \\"bestseller.\\" Users may have preferences for certain tags when borrowing books. Your task is to develop a system that recommends books based on preferred tags and their relevance. # Task Implement a function `recommend_books` that takes the following steps to recommend books: 1. **Tag Matching**: Determine the relevance of each book to the user based on tag preferences. 2. **Relevance Score**: Calculate a relevance score for each book by counting how many of the user\'s preferred tags it contains. 3. **Sort and Return**: Sort the books in descending order of their relevance score and return the list of books with their scores. # Function Signature ```python def recommend_books(books: list[dict], preferences: list[str]) -> list[tuple]: Recommend books based on user\'s tag preferences. Parameters: - books: A list of dictionaries where each dictionary represents a book with \'title\', \'author\', and \'tags\'. - preferences: A list of strings representing the user\'s preferred tags. Returns: - A list of tuples where each tuple contains the book\'s title, author, and its relevance score. Example: >>> books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"tags\\": [\\"fiction\\", \\"bestseller\\"]}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"tags\\": [\\"history\\", \\"biography\\"]}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"tags\\": [\\"fiction\\", \\"history\\"]}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author D\\", \\"tags\\": [\\"science\\", \\"fiction\\"]} ] >>> preferences = [\\"fiction\\", \\"science\\"] >>> recommend_books(books, preferences) [(\'Book D\', \'Author D\', 2), (\'Book A\', \'Author A\', 1), (\'Book C\', \'Author C\', 1), (\'Book B\', \'Author B\', 0)] ``` # Input Constraints - Each book\'s `tags` list will contain at most 10 tags. - The `preferences` list will contain at most 5 tags. - The number of books will not exceed 100. # Performance Requirements - The implementation should aim for efficient retrieval and sorting of books based on relevance, considering potential large datasets. # Example ```python books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"tags\\": [\\"fiction\\", \\"bestseller\\"]}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"tags\\": [\\"history\\", \\"biography\\"]}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"tags\\": [\\"fiction\\", \\"history\\"]}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author D\\", \\"tags\\": [\\"science\\", \\"fiction\\"]} ] preferences = [\\"fiction\\", \\"science\\"] recommended_books = recommend_books(books, preferences) print(recommended_books) # Output: [(\'Book D\', \'Author D\', 2), (\'Book A\', \'Author A\', 1), (\'Book C\', \'Author C\', 1), (\'Book B\', \'Author B\', 0)] ```","solution":"def recommend_books(books, preferences): Recommend books based on user\'s tag preferences. Parameters: - books: A list of dictionaries where each dictionary represents a book with \'title\', \'author\', and \'tags\'. - preferences: A list of strings representing the user\'s preferred tags. Returns: - A list of tuples where each tuple contains the book\'s title, author, and its relevance score. recommendations = [] for book in books: relevance_score = sum(tag in preferences for tag in book[\'tags\']) recommendations.append((book[\'title\'], book[\'author\'], relevance_score)) recommendations.sort(key=lambda x: x[2], reverse=True) return recommendations"},{"question":"# Question: Employee Time Tracking System You are tasked with enhancing an existing employee time tracking system to improve its functionality and user experience. The current system tracks employee clock-in and clock-out times but lacks several key features. Your Task Extend the employee time tracking system to implement the following features: 1. **Input Validation**: Ensure that all provided times are in a valid 24-hour format (`HH:MM`). 2. **Error Handling**: Provide clear error messages for: - Invalid time format. - Clock-out time earlier than clock-in time. 3. **Overtime Calculation**: Calculate the amount of overtime worked in hours if the total working time exceeds 8 hours. 4. **Detailed Unit Tests**: Implement unit tests to cover normal, edge, and error scenarios. Function Signature ```python def track_time(clock_in: str, clock_out: str) -> dict[str, float]: ``` Input - `clock_in`: The clock-in time in \'HH:MM\' format. - `clock_out`: The clock-out time in \'HH:MM\' format. Output - A dictionary containing: - `\'total_time\'`: Total time worked (in hours). - `\'overtime\'`: Overtime worked (in hours), if any. Constraints - Time should be in valid 24-hour format. - Clock-out time must be later than clock-in time. Examples ```python assert track_time(\\"09:00\\", \\"17:00\\") == {\'total_time\': 8.0, \'overtime\': 0.0} assert track_time(\\"08:00\\", \\"18:30\\") == {\'total_time\': 10.5, \'overtime\': 2.5} assert track_time(\\"07:45\\", \\"19:00\\") == {\'total_time\': 11.25, \'overtime\': 3.25} # Error Scenarios try: track_time(\\"09:60\\", \\"17:00\\") except ValueError as e: assert str(e) == \\"Invalid time format, please use HH:MM\\" try: track_time(\\"09:00\\", \\"07:00\\") except ValueError as e: assert str(e) == \\"Clock-out time cannot be earlier than clock-in time\\" try: track_time(\\"24:00\\", \\"07:00\\") except ValueError as e: assert str(e) == \\"Invalid time format, please use HH:MM\\" ``` Enhance the time tracking function\'s robustness to handle invalid formats and calculate precise working hours and overtime accurately. Implement comprehensive unit tests to ensure all scenarios are covered.","solution":"def track_time(clock_in: str, clock_out: str) -> dict[str, float]: from datetime import datetime def is_valid_time_format(time_str: str) -> bool: try: datetime.strptime(time_str, \\"%H:%M\\") return True except ValueError: return False if not is_valid_time_format(clock_in) or not is_valid_time_format(clock_out): raise ValueError(\\"Invalid time format, please use HH:MM\\") clock_in_time = datetime.strptime(clock_in, \'%H:%M\') clock_out_time = datetime.strptime(clock_out, \'%H:%M\') if clock_out_time <= clock_in_time: raise ValueError(\\"Clock-out time cannot be earlier than or equal to clock-in time\\") total_time_delta = clock_out_time - clock_in_time total_hours = total_time_delta.total_seconds() / 3600 overtime_hours = max(0, total_hours - 8) return { \'total_time\': round(total_hours, 2), \'overtime\': round(overtime_hours, 2) }"},{"question":"# Question You have been given a half-completed implementation of a **Priority Queue** in Python. Your task is to complete the implementation by adding a method called `remove_lowest_priority`. This method should remove and return the element with the lowest priority from the priority queue. If there are multiple elements with the same lowest priority, remove any one of them. **Function Signature**: ```python def remove_lowest_priority(self) -> T | None: pass ``` # Instructions 1. **Function Details**: - **Input**: None - **Output**: Returns the element with the lowest priority. If the priority queue is empty, return `None`. - **Constraints**: - The method should correctly adjust the heap structure after removing the element. 2. **Examples**: ```python # Example 1 pq = PriorityQueue() pq.insert(\'A\', 3) pq.insert(\'B\', 1) pq.insert(\'C\', 2) assert pq.remove_lowest_priority() == \'B\' # B has the lowest priority (1) assert pq.remove_lowest_priority() == \'C\' # C has the next lowest priority (2) assert pq.remove_lowest_priority() == \'A\' # A has the remaining priority (3) assert pq.remove_lowest_priority() is None # Priority queue is now empty # Example 2 pq = PriorityQueue() pq.insert(\'X\', 10) pq.insert(\'Y\', 5) pq.insert(\'Z\', 5) removed_element = pq.remove_lowest_priority() assert removed_element == \'Y\' or removed_element == \'Z\' # Either Y or Z because both have the same lowest priority (5) assert pq.remove_lowest_priority() == \'X\' # X has the next lowest priority (10) assert pq.remove_lowest_priority() is None # Priority queue is now empty ``` 3. **Guidelines**: - Ensure the underlying heap or priority queue structure remains valid after an element is removed. - Ensure that your implementation does not affect the existing functionalities of the priority queue. # Additional Notes: - Focus on achieving the correct functionality within the specified constraints. - Handle edge cases such as when the priority queue is empty. # Code to Implement ```python class PriorityQueue(Generic[T]): ... def remove_lowest_priority(self) -> T | None: # Your code here pass ... ```","solution":"import heapq from typing import List, Tuple, TypeVar, Generic, Optional T = TypeVar(\'T\') class PriorityQueue(Generic[T]): def __init__(self): self.heap: List[Tuple[int, T]] = [] def insert(self, element: T, priority: int): heapq.heappush(self.heap, (priority, element)) def remove_lowest_priority(self) -> Optional[T]: if not self.heap: return None lowest_priority_element = heapq.heappop(self.heap) return lowest_priority_element[1]"},{"question":"# Coding Question: Implement a Customizable Binary Search Tree with Enhanced Traversal Methods **Context**: Binary Search Trees (BST) are fundamental data structures used to maintain a sorted collection of values and allow efficient insertion, deletion, and search operations. Enhanced traversal methods can provide additional ways to access and manipulate the data stored in these trees. **Challenge**: Your task is to implement a `CustomBST` class that represents a Binary Search Tree with extended traversal methods. This class should support dynamic adjustments to its traversal orders and provide additional traversal functionalities such as level-order traversal and reverse in-order traversal. **Function Signature**: ```python class CustomBST: def __init__(self) -> None: pass def insert(self, value: int) -> None: pass def delete(self, value: int) -> None: pass def search(self, value: int) -> bool: pass def inorder_traversal(self) -> list[int]: pass def preorder_traversal(self) -> list[int]: pass def postorder_traversal(self) -> list[int]: pass def level_order_traversal(self) -> list[int]: pass def reverse_inorder_traversal(self) -> list[int]: pass ``` **Detailed Requirements**: 1. **Initialization**: - The constructor should initialize an empty Binary Search Tree. 2. **Insertion**: - Implement the `insert` method to add a value to the BST maintaining its properties. 3. **Deletion**: - Implement the `delete` method to remove a value from the BST if it exists while maintaining the BST properties. 4. **Search**: - Implement the `search` method to determine if a value exists in the BST. 5. **In-order Traversal**: - Implement the `inorder_traversal` method to return a list of values representing the in-order traversal of the BST. 6. **Pre-order Traversal**: - Implement the `preorder_traversal` method to return a list of values representing the pre-order traversal of the BST. 7. **Post-order Traversal**: - Implement the `postorder_traversal` method to return a list of values representing the post-order traversal of the BST. 8. **Level-order Traversal**: - Implement the `level_order_traversal` method to return a list of values representing the level-order traversal of the BST. 9. **Reverse In-order Traversal**: - Implement the `reverse_inorder_traversal` method to return a list of values representing the reverse in-order traversal (right, root, left) of the BST. **Constraints**: - Values in the BST are unique integers within the range `[-10^5, 10^5]`. - Methods should operate efficiently even with large numbers of nodes (up to `10^4`). **Performance Requirements**: - The `insert`, `delete`, and `search` methods should have average time complexity of O(log n) for balanced trees. - The traversal methods should operate in O(n) time, where n is the number of nodes in the BST. **Example**: ```python >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.insert(7) >>> tree.insert(2) >>> tree.insert(4) >>> tree.insert(6) >>> tree.insert(8) >>> print(tree.inorder_traversal()) [2, 3, 4, 5, 6, 7, 8] >>> print(tree.level_order_traversal()) [5, 3, 7, 2, 4, 6, 8] >>> tree.delete(4) >>> print(tree.inorder_traversal()) [2, 3, 5, 6, 7, 8] >>> print(tree.reverse_inorder_traversal()) [8, 7, 6, 5, 3, 2] ```","solution":"class CustomBST: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value): def _insert(root, value): if root is None: return CustomBST.Node(value) if value < root.value: root.left = _insert(root.left, value) else: root.right = _insert(root.right, value) return root self.root = _insert(self.root, value) def delete(self, value): def _min_value_node(node): current = node while current.left is not None: current = current.left return current def _delete(root, value): if root is None: return root if value < root.value: root.left = _delete(root.left, value) elif value > root.value: root.right = _delete(root.right, value) else: if root.left is None: return root.right elif root.right is None: return root.left temp = _min_value_node(root.right) root.value = temp.value root.right = _delete(root.right, temp.value) return root self.root = _delete(self.root, value) def search(self, value): def _search(root, value): if root is None or root.value == value: return root is not None if value < root.value: return _search(root.left, value) return _search(root.right, value) return _search(self.root, value) def inorder_traversal(self): result = [] def _inorder(root): if root: _inorder(root.left) result.append(root.value) _inorder(root.right) _inorder(self.root) return result def preorder_traversal(self): result = [] def _preorder(root): if root: result.append(root.value) _preorder(root.left) _preorder(root.right) _preorder(self.root) return result def postorder_traversal(self): result = [] def _postorder(root): if root: _postorder(root.left) _postorder(root.right) result.append(root.value) _postorder(self.root) return result def level_order_traversal(self): result = [] if not self.root: return result queue = [self.root] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def reverse_inorder_traversal(self): result = [] def _reverse_inorder(root): if root: _reverse_inorder(root.right) result.append(root.value) _reverse_inorder(root.left) _reverse_inorder(self.root) return result"},{"question":"# Question Write a function that parses a string consisting of comma-separated integers and returns a list of those integers. The function should handle various edge cases such as empty strings, negative integers, and strings with extra commas or spaces. The function should also validate the input to ensure all parts of the string are valid integers. Function Signature ```python def parse_int_list(int_string: str) -> list[int]: pass ``` Input - `int_string` (str): A string containing integers separated by commas. The string may contain leading and trailing spaces, may include negative numbers, and may have extra spaces around commas and numbers. Output - Returns a list of integers parsed from the input string. Constraints - The input string will be a length `0 <= len(int_string) <= 200`. - The function should raise a ValueError with an appropriate message for invalid inputs (e.g., when the input contains non-integer values, or if the string format is invalid). Example ```python >>> parse_int_list(\\"1, 2, 3\\") [1, 2, 3] >>> parse_int_list(\\"10, -20, 30\\") [10, -20, 30] >>> parse_int_list(\\" 10, 20, 30 \\") [10, 20, 30] >>> parse_int_list(\\"1,2, ,3\\") Traceback (most recent call last): ... ValueError: Invalid input: empty element found >>> parse_int_list(\\"\\") [] >>> parse_int_list(\\"12, x, 7\\") Traceback (most recent call last): ... ValueError: Non-integer value found in input ``` Additional tests: ```python >>> parse_int_list(\\"100, 200, 300, 400\\") [100, 200, 300, 400] >>> parse_int_list(\\" 0 , -1 , 2 , -3 \\") [0, -1, 2, -3] >>> parse_int_list(\\"1,,2\\") Traceback (most recent call last): ... ValueError: Invalid input: consecutive commas >>> parse_int_list(\\" \\") [] >>> parse_int_list(\\"5G\\") Traceback (most recent call last): ... ValueError: Non-integer value found in input ``` The function should be robust and capable of handling all edge cases gracefully, providing clear error messages where necessary.","solution":"def parse_int_list(int_string: str) -> list[int]: if int_string.strip() == \\"\\": return [] elements = int_string.split(\',\') results = [] for element in elements: element = element.strip() if element == \\"\\": raise ValueError(\\"Invalid input: empty element found\\") try: results.append(int(element)) except ValueError: raise ValueError(\\"Non-integer value found in input\\") return results"},{"question":"# Coding Assessment Question Context and Scenario: You have been tasked with developing a feature for a social media platform where user activities are logged based on timestamps. These logs are sorted by time in ascending order. To manage these logs, you need to implement algorithms that allow efficient retrieval of activities occurring within a specific time interval, as well as adding new activity logs while maintaining the sort order. Task: 1. **Function 1: Range Retrieval** Write a function `range_retrieval(logs, start_time, end_time)` that retrieves all activity logs within a specified time range `[start_time, end_time]`. The function should return a list of logs that fall within the given time range, inclusively. ```python def range_retrieval(logs: list[tuple[int, str]], start_time: int, end_time: int) -> list[tuple[int, str]]: Retrieve logs within the specified time range. :param logs: A list of tuples, where each tuple contains (timestamp, activity). The list is sorted by timestamp in ascending order. :param start_time: The start of the time range. :param end_time: The end of the time range. :return: A list of tuples representing activity logs within the specified time range. pass ``` **Example:** ```python logs = [(1, \'login\'), (3, \'post\'), (5, \'logout\'), (7, \'login\'), (10, \'post\')] result = range_retrieval(logs, 3, 7) print(result) # Output: [(3, \'post\'), (5, \'logout\'), (7, \'login\')] ``` 2. **Function 2: Sorted Log Insertion** Write a function `sorted_log_insertion(logs, log)` that inserts a new `log` into the sorted list of logs `logs` while maintaining the chronological order. The log is represented as a tuple `(timestamp, activity)`. ```python def sorted_log_insertion(logs: list[tuple[int, str]], log: tuple[int, str]) -> None: Insert a log into the sorted log list while maintaining sort order. :param logs: A list of tuples, where each tuple contains (timestamp, activity). The list is sorted by timestamp in ascending order. :param log: A tuple containing (timestamp, activity) to be inserted. pass ``` **Example:** ```python logs = [(1, \'login\'), (3, \'post\'), (5, \'logout\'), (7, \'login\')] new_log = (4, \'comment\') sorted_log_insertion(logs, new_log) print(logs) # Output: [(1, \'login\'), (3, \'post\'), (4, \'comment\'), (5, \'logout\'), (7, \'login\')] ``` Constraints: - Timestamps are positive integers. - Each activity log is distinct. - Your implementation should ensure the `logs` list remains sorted after insertion. - You should handle edge cases such as an empty list, a single-element list, and a new log with a timestamp that is outside the range of current logs. - You are not allowed to use Python’s built-in `bisect` module functions directly in your implementation, use the provided code snippets for any required functionalities. Performance Requirements: - Your solution should efficiently handle large datasets up to ( 10^6 ) elements for both range retrieval and insertion functions. - Ensure that the range retrieval runs in linear time and the log insertion runs within logarithmic time complexity.","solution":"def range_retrieval(logs, start_time, end_time): Retrieve logs within the specified time range. :param logs: A list of tuples, where each tuple contains (timestamp, activity). The list is sorted by timestamp in ascending order. :param start_time: The start of the time range. :param end_time: The end of the time range. :return: A list of tuples representing activity logs within the specified time range. result = [] for log in logs: if start_time <= log[0] <= end_time: result.append(log) elif log[0] > end_time: break return result def sorted_log_insertion(logs, log): Insert a log into the sorted log list while maintaining sort order. :param logs: A list of tuples, where each tuple contains (timestamp, activity). The list is sorted by timestamp in ascending order. :param log: A tuple containing (timestamp, activity) to be inserted. if not logs: logs.append(log) return left, right = 0, len(logs) - 1 while left <= right: mid = (left + right) // 2 if logs[mid][0] < log[0]: left = mid + 1 else: right = mid - 1 logs.insert(left, log)"},{"question":"# Context: In numerical computing and scientific simulations, it is often necessary to determine whether a given matrix is diagonally dominant. This property is crucial, for example, in ensuring the convergence of various iterative methods for solving linear systems, such as the Jacobi or Gauss-Seidel methods. # Problem Statement: You need to implement a function `is_diagonally_dominant` that checks if a given square matrix is diagonally dominant. A square matrix is diagonally dominant if for every row of the matrix, the absolute value of the diagonal element in that row is greater than or equal to the sum of the absolute values of all the other (non-diagonal) elements in that row. # Function Signature: ```python def is_diagonally_dominant(matrix: List[List[float]]) -> bool: ``` # Input: - `matrix`: a list of lists of floats representing a square matrix. # Output: - Returns boolean `True` if the matrix is diagonally dominant, `False` otherwise. # Constraints: - The input `matrix` will always be square, but its size can vary. - Ensure to handle floating-point arithmetic correctly. - Matrix dimensions: Up to 1000 x 1000. # Example: ```python >>> is_diagonally_dominant([ [3, -2, 1], [1, -4, 2], [1, 2, -5] ]) True >>> is_diagonally_dominant([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) False >>> is_diagonally_dominant([ [10, 1, 2], [3, 11, 4], [5, 6, 15] ]) True ``` # Additional Information: A matrix ( A ) is diagonally dominant if: [ |A[i][i]| geq sum_{j neq i} |A[i][j]| ] for every index ( i ). You can use the following helper function as part of your implementation to calculate the sum of the absolute values of the non-diagonal elements in a given row: ```python def sum_abs_non_diagonal(row: List[float], diag_index: int) -> float: return sum(abs(row[j]) for j in range(len(row)) if j != diag_index) ```","solution":"from typing import List def sum_abs_non_diagonal(row: List[float], diag_index: int) -> float: return sum(abs(row[j]) for j in range(len(row)) if j != diag_index) def is_diagonally_dominant(matrix: List[List[float]]) -> bool: n = len(matrix) for i in range(n): diag_element = abs(matrix[i][i]) non_diag_sum = sum_abs_non_diagonal(matrix[i], i) if diag_element < non_diag_sum: return False return True"},{"question":"# Coding Question: **Sum of Subarray Minimums** Given an array of integers `arr`, find the sum of the minimum values in all possible contiguous subarrays of `arr`. Task: Write a function `sum_of_subarray_mins(arr: List[int]) -> int` that returns the sum of the minimum values in all possible contiguous subarrays of `arr`. Function Signature: ```python def sum_of_subarray_mins(arr: List[int]) -> int: ``` Input: - `arr`: A list of integers where `1 <= len(arr) <= 30000` and `1 <= arr[i] <= 30000`. Output: - An integer representing the sum of the minimum values in all possible contiguous subarrays of `arr`. The result should be returned modulo 10^9 + 7. Constraints: - It is guaranteed that the array contains at least one element. - The final result should be computed under modulo 10^9 + 7 to handle large outputs. Example: ```python assert sum_of_subarray_mins([3,1,2,4]) == 17 assert sum_of_subarray_mins([11,81,94,43,3]) == 444 ``` Hints: - Consider using a monotonic stack to efficiently compute the contribution of each element as the minimum in various subarrays. - Think about the number of subarrays in which each element is the minimum and sum their contributions. # Explanation: 1. **Example 1**: For the array `[3,1,2,4]`, the possible contiguous subarrays and their minimums are: - `[3]` -> 3 - `[3,1]` -> 1 - `[3,1,2]` -> 1 - `[3,1,2,4]` -> 1 - `[1]` -> 1 - `[1,2]` -> 1 - `[1,2,4]` -> 1 - `[2]` -> 2 - `[2,4]` -> 2 - `[4]` -> 4 - Summing these results: 3 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 2 + 4 = 17 2. **Example 2**: For the array `[11,81,94,43,3]`, the possible contiguous subarrays and their minimums give a total sum of 444 when computed as described. The challenge is in efficiently calculating these sums, particularly given the potential size of the input array. The use of a stack helps manage this by tracking the indices of array elements as they relate to the minimum values over different subarray spans.","solution":"from typing import List def sum_of_subarray_mins(arr: List[int]) -> int: MOD = 10**9 + 7 n = len(arr) stack = [] prev_less = [-1] * n next_less = [n] * n # Calculate previous less element index for each element for i in range(n): while stack and arr[stack[-1]] > arr[i]: stack.pop() if stack: prev_less[i] = stack[-1] stack.append(i) stack = [] # Calculate next less element index for each element for i in range(n): while stack and arr[stack[-1]] > arr[i]: idx = stack.pop() next_less[idx] = i stack.append(i) # Calculate the sum of subarray minimums result = 0 for i in range(n): result = (result + arr[i] * (i - prev_less[i]) * (next_less[i] - i)) % MOD return result"},{"question":"# Recipe Finder and Aggregator You are tasked with developing a Python function to enhance a project that interacts with a public recipes API to search for recipes based on an ingredient and save the top 3 recipes locally in a text file. Your goal is to write a function named `fetch_recipes` that performs the following operations: 1. **Search for Recipes**: Fetch recipes based on the given ingredient using a public recipe API. 2. **Save Recipes Locally**: Write the top 3 recipes, including their titles and URLs, to a specified text file. 3. **Fetch Recipe Details**: Retrieve and display the details (ingredients list and instructions) of the highest-rated recipe among the top 3. # Function Signature ```python def fetch_recipes(api_key: str, ingredient: str, file_path: str) -> str: Fetches recipes based on an ingredient, saves top 3 recipes locally, and retrieves details of the highest-rated recipe. Parameters: - api_key (str): Your API key for accessing the recipes API. - ingredient (str): The ingredient to search for in recipes. - file_path (str): The path to the text file where the top 3 recipes will be saved. Returns: - str: The details of the highest-rated recipe among the top 3. ``` # Requirements 1. Use a public recipes API to search for recipes: - Example API URL: `\\"https://api.spoonacular.com/recipes/findByIngredients\\"` - Required parameters: `api_key (your API key)`, `ingredients (the ingredient to search for)` - Sort the results based on ratings or relevance. 2. Save the top 3 recipes to the specified text file: - Write each recipe\'s title and URL in the text file. - If fewer than 3 recipes are found, save all the available results. 3. Query for detailed information on the highest-rated recipe among the top 3: - Example API URL: `\\"https://api.spoonacular.com/recipes/{id}/information\\"` - Required parameters: `api_key (your API key)`, `id (the recipe ID)` 4. Return the details of the highest-rated recipe, including the ingredients list and cooking instructions. # Constraints - Handle network errors gracefully, providing meaningful error messages. - Ensure the file path is valid and has the necessary write permissions. - The function should handle edge cases like missing keys in API responses or an insufficient number of recipes. # Example ```python recipe_details = fetch_recipes(\\"YOUR_API_KEY\\", \\"tomato\\", \\"recipes.txt\\") print(recipe_details) # Expected output: Details of the highest-rated recipe including ingredients list and instructions ```","solution":"import requests def fetch_recipes(api_key: str, ingredient: str, file_path: str) -> str: Fetches recipes based on an ingredient, saves top 3 recipes locally, and retrieves details of the highest-rated recipe. Parameters: - api_key (str): Your API key for accessing the recipes API. - ingredient (str): The ingredient to search for in recipes. - file_path (str): The path to the text file where the top 3 recipes will be saved. Returns: - str: The details of the highest-rated recipe among the top 3. try: # Step 1: Search for Recipes search_url = \\"https://api.spoonacular.com/recipes/findByIngredients\\" params = { \\"apiKey\\": api_key, \\"ingredients\\": ingredient, \\"number\\": 3, \\"ranking\\": 2 # Sort by maximizing used ingredients } response = requests.get(search_url, params=params) response.raise_for_status() # Check for HTTP errors recipes = response.json() if not recipes: return \\"No recipes found.\\" # Step 2: Save top 3 recipes locally with open(file_path, \'w\') as file: for recipe in recipes: file.write(f\\"{recipe[\'title\']}: https://spoonacular.com/recipe/{recipe[\'id\']}n\\") # Step 3: Fetch details of the highest-rated recipe # Assuming the first recipe in the sorted list is the highest-rated highest_rated_recipe_id = recipes[0][\'id\'] details_url = f\\"https://api.spoonacular.com/recipes/{highest_rated_recipe_id}/information\\" details_params = { \\"apiKey\\": api_key } details_response = requests.get(details_url, params=details_params) details_response.raise_for_status() # Check for HTTP errors recipe_details = details_response.json() ingredients = \', \'.join([ingredient[\'name\'] for ingredient in recipe_details[\'extendedIngredients\']]) instructions = recipe_details[\'instructions\'] return f\\"Title: {recipe_details[\'title\']}nIngredients: {ingredients}nInstructions: {instructions}\\" except requests.exceptions.RequestException as e: return f\\"An error occurred while fetching recipes: {str(e)}\\""},{"question":"# Coding Assessment Question Context You have been tasked with helping to implement a feature for managing a library\'s book catalog. The catalog needs to support efficient book lookups by their ISBN numbers. One of the key requirements is that all ISBN numbers in the catalog must be unique. Problem Statement Write a Python function `validate_isbn_list(isbn_list: list) -> bool` that checks if a given list of ISBN numbers contains only unique entries. Input Format * A list of strings where each string represents an ISBN number. For example, `[\'978-3-16-148410-0\', \'0-316-11623-5\']`. Output Format * Return a boolean value: `True` if all ISBN numbers in the list are unique, `False` otherwise. Constraints * The list will contain between 1 and 10^6 ISBN numbers. * Each ISBN number is represented as a string and conforms to the standard ISBN-10 or ISBN-13 formats. Examples ```python >>> validate_isbn_list([\'978-3-16-148410-0\', \'0-316-11623-5\', \'978-0-596-52068-7\']) True >>> validate_isbn_list([\'978-3-16-148410-0\', \'0-316-11623-5\', \'0-316-11623-5\']) False >>> validate_isbn_list([\'0-387-95082-3\']) True ``` Performance Requirements * The expected time complexity should be O(N). * The expected space complexity should be O(N). Implementation Notes * You should handle edge cases where the input list has no ISBN numbers. * Consider using a set data structure to efficiently check for duplicates.","solution":"def validate_isbn_list(isbn_list): Checks if a given list of ISBN numbers contains only unique entries. Args: isbn_list (list): A list of strings where each string represents an ISBN number. Returns: bool: True if all ISBN numbers in the list are unique, False otherwise. seen = set() for isbn in isbn_list: if isbn in seen: return False seen.add(isbn) return True"},{"question":"# Question: Implementing and Visualizing Moving Average Filter Context You have been provided with a code base to analyze the behavior of signal processing filters. The task is to implement a Moving Average (MA) filter and visualize its frequency and phase response using the provided framework. Task 1. Implement a custom Moving Average filter class that adheres to the `FilterType` Protocol. The class must have: - An `__init__` method to initialize the window size. - A `process()` method that takes a single sample as input and returns the filtered sample. 2. Use the `show_frequency_response()` and `show_phase_response()` functions to visualize your Moving Average filter for a given sample rate. Requirements * **Filter Specification**: You will implement a Moving Average filter with a specified window size. * **Input/Output**: - The MA filter class will take an integer window size as input. - The `process()` method will output the averaged value for each sample. * **Constraints**: - Sample rate for visualization: 48000 Hz. - Length of input signal for visualization: 512 samples. * **Performance**: - The implementation must handle signals efficiently. - The plot should be clear and cover the frequency range effectively. # Example ```python class MovingAverageFilter: def __init__(self, window_size: int) -> None: self.window_size = window_size self.buffer = [0] * window_size def process(self, sample: float) -> float: self.buffer.pop(0) self.buffer.append(sample) return sum(self.buffer) / self.window_size # Window size of the moving average filter window_size = 5 ma_filter = MovingAverageFilter(window_size) show_frequency_response(ma_filter, 48000) show_phase_response(ma_filter, 48000) ```","solution":"class MovingAverageFilter: def __init__(self, window_size: int) -> None: Initialize the Moving Average Filter with a specific window size. :param window_size: The size of the moving window. self.window_size = window_size self.buffer = [] def process(self, sample: float) -> float: Process a new sample and return the moving average. :param sample: The new sample to process. :return: The moving average value. self.buffer.append(sample) if len(self.buffer) > self.window_size: self.buffer.pop(0) return sum(self.buffer) / len(self.buffer)"},{"question":"**Scenario**: You are working with a biology research team that studies the spread of a virus in a two-dimensional grid representing a petri dish. Each cell in the grid can be either infected (1) or healthy (0), and the virus spreads to the neighboring healthy cells in the next step. **Problem**: Given a 2D grid of integers where `1` represents an infected cell, and `0` represents a healthy cell, simulate the spread of the virus until no more cells can be infected. The virus spreads to the adjacent cells in the cardinal directions (up, down, left, right) each step. Calculate the number of steps required for the entire grid to become infected. If it\'s impossible for the virus to spread to some parts of the grid, return -1. # Function Signature ```python def virus_spread(grid: List[List[int]]) -> int: pass ``` # Input Format * `grid` (List[List[int]]): A 2D list of integers representing the petri dish grid. # Output Format * **Return** (int): The number of steps required for the virus to spread across the entire grid or -1 if it\'s impossible. # Constraints * The grid will have at least one cell and no more than 1000x1000 cells. * Use efficient algorithms to ensure the solution can handle the upper limit of the constraints. # Example ```python # Example 1 grid = [ [0, 1, 0], [0, 0, 0], [0, 0, 1], ] print(virus_spread(grid)) # Expected output: 2 # Example 2 grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0], ] print(virus_spread(grid)) # Expected output: 2 # Example 3 grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] print(virus_spread(grid)) # Expected output: 1 ``` # Additional Requirements 1. **Handle edge cases**: Ensure that the function correctly handles scenarios where there are no infected cells initially or where some cells are unreachable. 2. **Performance considerations**: Efficiently manage memory and computational complexity to accommodate large grids. 3. **Testing**: Prepare unit tests to validate the solution against typical, edge, and extreme cases.","solution":"from collections import deque from typing import List def virus_spread(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) queue = deque() uninfected = 0 # Initialize the queue with all infected positions for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c)) else: uninfected += 1 # If there are no uninfected cells to begin with if uninfected == 0: return 0 # Four direction vectors for navigating the grid directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] steps = 0 # Perform BFS to infect all cells while queue: steps += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0: grid[nx][ny] = 1 queue.append((nx, ny)) uninfected -= 1 # If there are no more uninfected cells left to infect if uninfected == 0: return steps # If there are still uninfected cells after the BFS return -1"},{"question":"# Problem Statement **Temperature Conversion Utility** You are given a function template `convert_temperature(value: float, input_unit: str, output_unit: str) -> float`. This function converts a temperature from one unit to another, based on the provided input and output units. The function should support the following temperature units: 1. **Celsius** (`C`) 2. **Fahrenheit** (`F`) 3. **Kelvin** (`K`) The conversion formulas are as follows: - From Celsius to Fahrenheit: [ F = (C cdot 1.8) + 32 ] - From Celsius to Kelvin: [ K = C + 273.15 ] - From Fahrenheit to Celsius: [ C = (F - 32) / 1.8 ] - From Fahrenheit to Kelvin: [ K = (F + 459.67) / 1.8 ] - From Kelvin to Celsius: [ C = K - 273.15 ] - From Kelvin to Fahrenheit: [ F = (K cdot 1.8) - 459.67 ] **Function Signature:** ```python def convert_temperature(value: float, input_unit: str, output_unit: str) -> float: pass ``` # Expected Input and Output Formats * **Input**: The function accepts: - `value` (float): The temperature value that needs to be converted. - `input_unit` (str): A string representing the unit of the input temperature. - `output_unit` (str): A string representing the unit of the desired output temperature. * **Output**: The function returns: - A float representing the converted temperature value. * **Constraints**: - The `input_unit` and `output_unit` can only be one of `C`, `F`, or `K`. - Raise a `ValueError` with the message `\\"Invalid input unit\\"` if `input_unit` is not `C`, `F`, or `K`. - Raise a `ValueError` with the message `\\"Invalid output unit\\"` if `output_unit` is not `C`, `F`, or `K`. # Examples 1. **Example 1**: - Input: `value=100, input_unit=\'C\', output_unit=\'F\'` - Output: `212.0` 2. **Example 2**: - Input: `value=32, input_unit=\'F\', output_unit=\'C\'` - Output: `0.0` 3. **Example 3**: - Input: `value=0, input_unit=\'C\', output_unit=\'K\'` - Output: `273.15` 4. **Example 4**: - Input: `value=300, input_unit=\'K\', output_unit=\'F\'` - Output: `80.33000000000004` Implement the function `convert_temperature(value: float, input_unit: str, output_unit: str) -> float` to fit the description above and pass all the test cases.","solution":"def convert_temperature(value: float, input_unit: str, output_unit: str) -> float: Converts the given temperature value from one unit to another. Args: value (float): The temperature value to be converted. input_unit (str): The unit of the input temperature. Can be \'C\', \'F\', or \'K\'. output_unit (str): The unit of the output temperature. Can be \'C\', \'F\', or \'K\'. Returns: float: The converted temperature value. Raises: ValueError: If input_unit or output_unit is not valid. # Check for valid units valid_units = {\'C\', \'F\', \'K\'} if input_unit not in valid_units: raise ValueError(\\"Invalid input unit\\") if output_unit not in valid_units: raise ValueError(\\"Invalid output unit\\") # Conversion logic temp_in_celsius = value if input_unit == \'F\': temp_in_celsius = (value - 32) / 1.8 elif input_unit == \'K\': temp_in_celsius = value - 273.15 if output_unit == \'C\': return temp_in_celsius elif output_unit == \'F\': return temp_in_celsius * 1.8 + 32 elif output_unit == \'K\': return temp_in_celsius + 273.15"},{"question":"# Genetic Algorithm: Optimization # Scenario You are required to implement a simplified genetic algorithm to solve an optimization problem. The objective is to maximize a given fitness function over a binary search space. # Task Write a Python function `genetic_algorithm` that performs a genetic algorithm to maximize a given binary fitness function. The algorithm should perform selection, crossover, mutation, and evolution over a specified number of generations. # Function Signature ```python def genetic_algorithm( fitness_function: Callable[[List[int]], float], num_bits: int, population_size: int, generations: int, crossover_rate: float, mutation_rate: float ) -> Tuple[List[int], float] ``` # Input 1. `fitness_function` (Callable[[List[int]], float]): A function that takes a binary list and returns a fitness score. 2. `num_bits` (int): The number of bits in each individual. 3. `population_size` (int): The size of the population. 4. `generations` (int): Number of generations to evolve the population. 5. `crossover_rate` (float): Probability of crossover between two parents (0.0 ≤ crossover_rate ≤ 1.0). 6. `mutation_rate` (float): Probability of a bit mutation in an individual (0.0 ≤ mutation_rate ≤ 1.0). # Output * Returns a `Tuple` containing the best individual (as a list of bits) and its fitness score (float). # Constraints 1. `num_bits` > 0 2. `population_size` > 1 3. `generations` > 0 4. 0.0 ≤ `crossover_rate` ≤ 1.0 5. 0.0 ≤ `mutation_rate` ≤ 1.0 # Details and Components 1. **Initialization**: Generate the initial population randomly. 2. **Fitness Calculation**: Evaluate each individual using the provided fitness function. 3. **Selection**: Implement tournament selection (or any other selection method). 4. **Crossover**: Perform single-point crossover based on the crossover rate. 5. **Mutation**: Mutate each bit of an individual based on the mutation rate. 6. **Evolution**: Evolve the population over the specified number of generations and return the best individual and its fitness score. # Example ```python def sample_fitness_function(individual: List[int]) -> float: # The fitness function simply sums the bits of the individual return sum(individual) # Optimize the fitness function over binary individuals with 10 bits, # population size 20, evolving for 50 generations, with crossover rate 0.7 # and mutation rate 0.01 best_individual, best_fitness = genetic_algorithm( sample_fitness_function, num_bits=10, population_size=20, generations=50, crossover_rate=0.7, mutation_rate=0.01 ) print(f\\"Best individual: {best_individual}\\") print(f\\"Best fitness: {best_fitness}\\") # An expected best individual could be [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] with a fitness score of 10 ``` # Notes * Ensure that the genetic algorithm operates under typical randomness in crossover and mutation operations. * The algorithm should effectively balance exploration and exploitation to find an optimal solution. * Implementations may vary, but fundamental genetic algorithm concepts should be followed.","solution":"import random from typing import List, Callable, Tuple def genetic_algorithm( fitness_function: Callable[[List[int]], float], num_bits: int, population_size: int, generations: int, crossover_rate: float, mutation_rate: float ) -> Tuple[List[int], float]: def create_individual() -> List[int]: return [random.randint(0, 1) for _ in range(num_bits)] def mutate(individual: List[int], mutation_rate: float) -> List[int]: return [bit if random.random() > mutation_rate else 1 - bit for bit in individual] def crossover(parent1: List[int], parent2: List[int], crossover_rate: float) -> Tuple[List[int], List[int]]: if random.random() < crossover_rate: point = random.randint(1, num_bits - 1) return (parent1[:point] + parent2[point:], parent2[:point] + parent1[point:]) else: return (parent1, parent2) def tournament_selection(population: List[List[int]], k: int = 3) -> List[int]: selected = random.sample(population, k) selected = sorted(selected, key=lambda ind: fitness_function(ind), reverse=True) return selected[0] # Initialize population population = [create_individual() for _ in range(population_size)] best_individual = None best_fitness = float(\'-inf\') for _ in range(generations): next_generation = [] # Evaluate current population and find the best individual for individual in population: fitness = fitness_function(individual) if fitness > best_fitness: best_fitness = fitness best_individual = individual # Create next generation while len(next_generation) < population_size: parent1 = tournament_selection(population) parent2 = tournament_selection(population) child1, child2 = crossover(parent1, parent2, crossover_rate) next_generation.extend([mutate(child1, mutation_rate), mutate(child2, mutation_rate)]) population = next_generation[:population_size] return best_individual, best_fitness"},{"question":"# Coding Assessment Question Machine Learning Model Evaluation **Scenario**: You have been working on a machine learning model that predicts house prices based on various features. The model was trained and tested on historical data, but now you need to improve its evaluation pipeline to make it more robust, accurate, and informative. Requirements: You are required to enhance the evaluation process to include the following features: 1. **Cross-Validation**: Implement k-fold cross-validation to assess the model\'s performance more reliably. 2. **Feature Importance Analysis**: Integrate a method to calculate and display the importance of each feature used in the model. 3. **Custom Evaluation Metrics**: Add functionality to evaluate the model using custom metrics beyond standard accuracy or mean squared error, such as Mean Absolute Error (MAE) and Root Mean Squared Error (RMSE). Implementation Details: 1. **Cross-Validation**: - Implement a function to perform k-fold cross-validation, where `k` is a hyperparameter. - Ensure that each fold is used as a validation set once and the remaining folds as the training set. 2. **Feature Importance Analysis**: - Calculate the importance of each feature in the model using methods such as feature coefficients (for linear models) or feature_importances_ attribute (for tree-based models). - Display the feature importance in a clear and interpretable format (e.g., as a list or a bar chart). 3. **Custom Evaluation Metrics**: - Implement functions to compute MAE and RMSE. - Integrate these custom metrics into the evaluation pipeline and ensure they are included in the cross-validation output. Constraints: - The dataset will be provided as a pandas DataFrame, where the target variable column is named \'price\'. - The model will be a scikit-learn compatible estimator (e.g., LinearRegression, RandomForestRegressor). - The feature set can contain both numerical and categorical variables, which will need appropriate preprocessing. Function Signatures: ```python def cross_validation(model, X: pd.DataFrame, y: pd.Series, k: int = 5) -> dict: Perform k-fold cross-validation and return the evaluation metrics for each fold. pass def feature_importance_analysis(model, X: pd.DataFrame, y: pd.Series) -> dict: Calculate and return the importance of each feature. pass def custom_evaluation_metrics(y_true: pd.Series, y_pred: pd.Series) -> dict: Calculate and return custom evaluation metrics (MAE, RMSE) for the model predictions. pass # Modify the existing evaluate_model() function to integrate the new features. def evaluate_model(model, X: pd.DataFrame, y: pd.Series) -> tuple: pass ``` You should appropriately use `cross_validation()`, `feature_importance_analysis()`, and `custom_evaluation_metrics()` within the `evaluate_model()` function to provide a comprehensive evaluation of the machine learning model.","solution":"import numpy as np import pandas as pd from sklearn.model_selection import KFold from sklearn.metrics import mean_absolute_error, mean_squared_error import matplotlib.pyplot as plt def cross_validation(model, X: pd.DataFrame, y: pd.Series, k: int = 5) -> dict: Perform k-fold cross-validation and return the evaluation metrics for each fold. kf = KFold(n_splits=k, shuffle=True, random_state=1) metrics = {\'MAE\': [], \'RMSE\': []} for train_index, test_index in kf.split(X): X_train, X_test = X.iloc[train_index], X.iloc[test_index] y_train, y_test = y.iloc[train_index], y.iloc[test_index] model.fit(X_train, y_train) y_pred = model.predict(X_test) mae = mean_absolute_error(y_test, y_pred) rmse = np.sqrt(mean_squared_error(y_test, y_pred)) metrics[\'MAE\'].append(mae) metrics[\'RMSE\'].append(rmse) return metrics def feature_importance_analysis(model, X: pd.DataFrame, y: pd.Series) -> dict: Calculate and return the importance of each feature. model.fit(X, y) if hasattr(model, \'feature_importances_\'): importances = model.feature_importances_ elif hasattr(model, \'coef_\'): importances = model.coef_ else: raise ValueError(\\"Model does not have feature_importances_ or coef_ attributes\\") feature_importance = {feature: importance for feature, importance in zip(X.columns, importances)} # Optionally, plot the feature importance plt.figure(figsize=(10, 6)) plt.barh(list(feature_importance.keys()), list(feature_importance.values())) plt.xlabel(\\"Feature Importance\\") plt.ylabel(\\"Feature\\") plt.title(\\"Feature Importance Analysis\\") plt.show() return feature_importance def custom_evaluation_metrics(y_true: pd.Series, y_pred: pd.Series) -> dict: Calculate and return custom evaluation metrics (MAE, RMSE) for the model predictions. mae = mean_absolute_error(y_true, y_pred) rmse = np.sqrt(mean_squared_error(y_true, y_pred)) return {\'MAE\': mae, \'RMSE\': rmse} def evaluate_model(model, X: pd.DataFrame, y: pd.Series) -> tuple: Comprehensive evaluation of the machine learning model using cross-validation, feature importance analysis, and custom evaluation metrics. # Perform cross-validation cv_metrics = cross_validation(model, X, y, k=5) # Perform feature importance analysis feature_importance = feature_importance_analysis(model, X, y) # Fit the model on the entire dataset model.fit(X, y) y_pred = model.predict(X) # Compute custom evaluation metrics custom_metrics = custom_evaluation_metrics(y, y_pred) return cv_metrics, feature_importance, custom_metrics"},{"question":"# Context: You are given a list of names and you need to pair them off randomly to form teams. Each team should consist of two members. If the number of names is odd, the last team should consist of three members. The order of teams and the order of members within each team does not matter as long as teams are formed randomly. # Task: **Implement** the team formation mechanism described below. # Function Definition: 1. **form_teams**(`names: list[str]`) -> `list[list[str]]`: - **Input**: A list of strings `names` where each string represents a name. - **Output**: A list of lists, where each inner list represents a team formed by pairing two names. If there is an odd number of names, the last team will contain three names. # Constraints: - Each name in the input list is a non-empty string consisting of alphabetic characters. - There should be no duplicate names in the list. - For reproducibility in testing, you should shuffle the list of names using `random.shuffle(names)` within the `form_teams` function. # Example: ```python import random def form_teams(names: list[str]) -> list[list[str]]: # Your implementation here pass if __name__ == \\"__main__\\": random.seed(1) names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\", \\"Grace\\"] teams = form_teams(names) print(teams) ``` **Example Usage**: ```python random.seed(1) names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\", \\"Grace\\"] teams = form_teams(names) # teams => [[\'Eve\', \'Alice\'], [\'Grace\', \'Charlie\'], [\'Frank\', \'David\', \'Bob\']] ``` # Explanation: The example demonstrates the function `form_teams` which takes a list of names as input and forms teams randomly. Given the seed value of 1, the resulting teams are `[[\'Eve\', \'Alice\'], [\'Grace\', \'Charlie\'], [\'Frank\', \'David\', \'Bob\']]`. The example shows how to shuffle and pair names while handling an odd number of names by placing the last three names in one team.","solution":"import random def form_teams(names: list[str]) -> list[list[str]]: Forms teams by pairing names randomly. If the number of names is odd, the last team will have 3 members. :param names: List of names to be paired :return: List of teams random.shuffle(names) teams = [] i = 0 while i < len(names) - 1: if len(names) % 2 != 0 and i == len(names) - 3: teams.append(names[i:i+3]) break else: teams.append(names[i:i+2]) i += 2 return teams"},{"question":"# Task: Implement a function named `currency_conversion` to convert between different currency units. The function should support the following units: - United States Dollar (USD) - Euro (EUR) - British Pound (GBP) - Indian Rupee (INR) - Japanese Yen (JPY) - Australian Dollar (AUD) # Requirements: - The function should take three parameters: - `amount` (float): the numeric value in the source currency. - `from_currency` (str): the currency unit of the input value. - `to_currency` (str): the currency unit of the desired output value. - The function should return the converted value as a float. - Use the following predefined exchange rates for conversion: - USD to EUR: 0.85, GBP: 0.75, INR: 74.0, JPY: 110.0, AUD: 1.35 - EUR to USD: 1.18, GBP: 0.88, INR: 87.0, JPY: 129.0, AUD: 1.59 - GBP to USD: 1.33, EUR: 1.13, INR: 99.0, JPY: 146.0, AUD: 1.80 - INR to USD: 0.013, EUR: 0.011, GBP: 0.010, JPY: 1.47, AUD: 0.018 - JPY to USD: 0.0091, EUR: 0.0078, GBP: 0.0068, INR: 0.68, AUD: 0.012 - AUD to USD: 0.74, EUR: 0.63, GBP: 0.56, INR: 55.0, JPY: 82.0 # Constraint: - If an invalid currency unit is provided, the function should raise a `ValueError` with a descriptive error message listing acceptable units. # Examples: ```python >>> currency_conversion(100, \'USD\', \'EUR\') 85.0 >>> currency_conversion(50, \'GBP\', \'JPY\') 7300.0 >>> currency_conversion(2000, \'INR\', \'AUD\') 36.0 >>> currency_conversion(100, \'USD\', \'invalid_unit\') Traceback (most recent call last): ... ValueError: Invalid \'to_currency\' value: \'invalid_unit\'. Conversion currencies are: USD, EUR, GBP, INR, JPY, AUD. ```","solution":"def currency_conversion(amount, from_currency, to_currency): Converts a currency amount between specified units. :param amount: float, the numeric value in the source currency :param from_currency: str, the currency unit of the input value :param to_currency: str, the currency unit of the desired output value :return: float, the converted value in the desired currency valid_currencies = {\\"USD\\", \\"EUR\\", \\"GBP\\", \\"INR\\", \\"JPY\\", \\"AUD\\"} exchange_rates = { \'USD\': {\'EUR\': 0.85, \'GBP\': 0.75, \'INR\': 74.0, \'JPY\': 110.0, \'AUD\': 1.35}, \'EUR\': {\'USD\': 1.18, \'GBP\': 0.88, \'INR\': 87.0, \'JPY\': 129.0, \'AUD\': 1.59}, \'GBP\': {\'USD\': 1.33, \'EUR\': 1.13, \'INR\': 99.0, \'JPY\': 146.0, \'AUD\': 1.80}, \'INR\': {\'USD\': 0.013, \'EUR\': 0.011, \'GBP\': 0.010, \'JPY\': 1.47, \'AUD\': 0.018}, \'JPY\': {\'USD\': 0.0091, \'EUR\': 0.0078, \'GBP\': 0.0068, \'INR\': 0.68, \'AUD\': 0.012}, \'AUD\': {\'USD\': 0.74, \'EUR\': 0.63, \'GBP\': 0.56, \'INR\': 55.0, \'JPY\': 82.0}, } if from_currency not in valid_currencies: raise ValueError(f\\"Invalid \'from_currency\' value: \'{from_currency}\'. Conversion currencies are: USD, EUR, GBP, INR, JPY, AUD.\\") if to_currency not in valid_currencies: raise ValueError(f\\"Invalid \'to_currency\' value: \'{to_currency}\'. Conversion currencies are: USD, EUR, GBP, INR, JPY, AUD.\\") if from_currency == to_currency: return amount converted_amount = amount * exchange_rates[from_currency][to_currency] return converted_amount"},{"question":"# Recursive Tree Traversal Challenge **Context**: You are tasked with implementing a function to traverse a binary tree in a specific order. The function should return the values of the tree nodes in a zigzag level-order traversal (often called \\"spiral order\\"). In this traversal, the nodes\' values are returned in an alternating left-to-right and right-to-left level order. # Tree Node Definition A TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Function Implementation Implement a function named `zigzag_level_order` that accepts a single parameter: 1. `root` (TreeNode|None): The root node of the binary tree to traverse. The function should perform the following: 1. Validate the input to ensure the root is not `None`. 2. Traverse the tree in zigzag (spiral) level-order: * Use a queue to traverse each level of the tree. * Alternate the direction of traversal for each level, starting with left-to-right. 3. Return a list of lists, where each sublist contains the node values at each level of the tree, traversed in zigzag order. **Specifications**: - If the root is `None`, return an empty list. - Utilize Breadth-First Search (BFS) to achieve the level-order traversal. - Ensure the traversal alternates between left-to-right and right-to-left at each level. **Constraints**: - Assume the tree can have up to 10^4 nodes. - The tree node values are integers and can be negative or positive. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def zigzag_level_order(root: TreeNode | None) -> list: # Your implementation here ``` **Test Cases**: 1. Given the binary tree: ``` 3 / 9 20 / 15 7 ``` `zigzag_level_order(root)` should return `[[3], [20, 9], [15, 7]]` 2. Given the binary tree: ``` 1 / 2 3 / / 4 5 6 7 ``` `zigzag_level_order(root)` should return `[[1], [3, 2], [4, 5, 6, 7]]` 3. `zigzag_level_order(None)` should return `[]` 4. Given the binary tree: ``` 42 ``` `zigzag_level_order(root)` should return `[[42]]` **Notes**: - Use the provided code snippet for base implementation. - Make sure to handle all edge cases as specified.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def zigzag_level_order(root: TreeNode | None) -> list: if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"**Matrix Path Finder** You need to implement a function `matrix_path` that takes a 2D list of integers representing a matrix and two pairs of coordinates, `start` and `end`. Your task is to determine whether there is a path from the `start` position to the `end` position, such that you can only move up, down, left, or right, and can only travel through cells with the value 1. # Function Signature ```python def matrix_path(matrix: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> bool: ``` # Parameters * `matrix` (List[List[int]]): A 2D list representing the matrix (1 <= len(matrix) <= 100, 1 <= len(matrix[0]) <= 100). Each cell in the matrix will hold either a 0 or 1. * `start` (Tuple[int, int]): A tuple representing the starting coordinates (0 <= start[0] < len(matrix), 0 <= start[1] < len(matrix[0])). * `end` (Tuple[int, int]): A tuple representing the ending coordinates (0 <= end[0] < len(matrix), 0 <= end[1] < len(matrix[0])). # Output * bool: A boolean value indicating whether there is a path from `start` to `end`. # Constraints * You can only move in the four cardinal directions (up, down, left, right). * You can only travel through cells that contain the value 1. * If `start` or `end` is out of bounds or not a 1, return `False`. # Examples ```python >>> matrix_path([ ... [1, 0, 1, 1], ... [1, 1, 0, 1], ... [0, 1, 1, 1] ... ], (0, 0), (2, 3)) True >>> matrix_path([ ... [1, 0, 1, 1], ... [1, 0, 0, 1], ... [0, 1, 1, 1] ... ], (0, 0), (2, 3)) False >>> matrix_path([ ... [1, 0], ... [0, 1] ... ], (0, 0), (1, 1)) False ``` # Requirements 1. You must implement the function without using any global variables. 2. You should handle invalid inputs gracefully by returning `False`. 3. Use a suitable pathfinding algorithm (e.g., Breadth-First Search) to determine if a path exists. # Tips 1. Ensure that you check for validity of the `start` and `end` positions before beginning the search. 2. Consider edge cases such as a matrix full of zeros, or where `start` or `end` positions are not traversable. 3. Optimize for performance within the provided constraints.","solution":"def matrix_path(matrix, start, end): from collections import deque def is_valid(x, y): return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] == 1 if not is_valid(start[0], start[1]) or not is_valid(end[0], end[1]): return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() if (x, y) == end: return True for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"# Question: Implement a Differentiated Prime Sequence Generator Your task is to create a function that generates a sequence of the first \'n\' prime numbers, but with a twist. Each generated prime number should be increased by 1 if it is an odd number or decreased by 1 if it is an even number. Function Signature ```python def differentiated_prime_sequence(n: int) -> list[int]: Generate a sequence of the first \'n\' primes with the specified transformation. :param n: An integer representing the number of primes to generate in the sequence. :return: A list of integers representing the transformed prime sequence. ``` Input/Output Examples 1. **Input**: `differentiated_prime_sequence(5)` - **Output**: `[2, 4, 5, 8, 6]` - **Explanation**: - The first 5 prime numbers are `[2, 3, 5, 7, 11]`. - Apply the transformation: - 2 is even, so 2 - 1 = 1 - 3 is odd, so 3 + 1 = 4 - 5 is odd, so 5 + 1 = 6 - 7 is odd, so 7 + 1 = 8 - 11 is odd, so 11 + 1 = 12 - The transformed sequence is `[1, 4, 6, 8, 12]`. 2. **Input**: `differentiated_prime_sequence(3)` - **Output**: `[2, 4, 6]` - **Explanation**: - The first 3 prime numbers are `[2, 3, 5]`. - Apply the transformation: - 2 is even, so 2 - 1 = 1 - 3 is odd, so 3 + 1 = 4 - 5 is odd, so 5 + 1 = 6 - The transformed sequence is `[1, 4, 6]`. 3. **Input**: `differentiated_prime_sequence(1)` - **Output**: `[2]` - **Explanation**: - The first prime number is `[2]`. - Apply the transformation: - 2 is even, so 2 - 1 = 1 - The transformed sequence is `[1]`. Constraints and Limitations - The input `n` will be a positive integer (`1 <= n <= 1000`). - Performance should be optimized for higher values of `n`. - The function should handle edge cases where `n` is 1 or very large efficiently. # Additional Notes - You may use any efficient algorithm to generate prime numbers. - The transformation to each prime in the sequence should be efficient and follow the specified rules.","solution":"def differentiated_prime_sequence(n: int) -> list[int]: Generate a sequence of the first \'n\' primes with the specified transformation. :param n: An integer representing the number of primes to generate in the sequence. :return: A list of integers representing the transformed prime sequence. if n <= 0: return [] def is_prime(num): Check if a number is a prime number if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Generate first \'n\' primes primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 # Apply the transformation transformed_primes = [] for prime in primes: if prime % 2 == 0: transformed_primes.append(prime - 1) else: transformed_primes.append(prime + 1) return transformed_primes"},{"question":"# Fibonacci Sequence Variant Overview You\'re developing a feature in a mathematics application that requires generating a custom variant of the Fibonacci sequence. Instead of the traditional sequence where each number is the sum of the two preceding ones, this variant involves a specific base case list and uses a dynamic step size for summing the terms. Problem Statement Implement a function `custom_fibonacci(base: list, n: int) -> list` that generates a custom Fibonacci sequence. The sequence should start with the given `base` list and each subsequent number should be the sum of the previous `k` numbers, where `k` is the length of the `base` list. The function should return the first `n` numbers of this sequence. Input - `base`: A list of integers representing the base case of the sequence. The length of `base` will be at least 1. - `n`: An integer representing the total number of terms to be generated in the sequence. Output - A list of integers containing the first `n` numbers of the custom Fibonacci sequence. Constraints - All integers in `base` will be non-negative. - The length of `base` will be at least 1 and at most 20. - The value of `n` will be at least 1 and at most 100. - The individual terms of the sequence will not exceed the limit of a 64-bit integer. Example ```python base = [1, 2, 3] n = 7 output = [1, 2, 3, 6, 11, 20, 37] assert custom_fibonacci([1, 2, 3], 7) == [1, 2, 3, 6, 11, 20, 37] ``` ```python base = [0, 1] n = 10 output = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] assert custom_fibonacci([0, 1], 10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` ```python base = [3, 2, 1] n = 6 output = [3, 2, 1, 6, 9, 16] assert custom_fibonacci([3, 2, 1], 6) == [3, 2, 1, 6, 9, 16] ``` Notes - Handle the scenario where `n` is less than the length of the `base` list by truncating the result accordingly. - Ensure to optimize the function for large values of `n` while maintaining clarity and correctness in the solution.","solution":"def custom_fibonacci(base, n): Generates a custom Fibonacci sequence. Args: - base: A list of integers that serves as the base case for the sequence. - n: An integer representing the total number of terms to be generated. Returns: - A list of integers containing the first n numbers of the custom Fibonacci sequence. k = len(base) if n <= k: return base[:n] res = base[:] for i in range(k, n): next_value = sum(res[-k:]) res.append(next_value) return res"},{"question":"# Coding Question: Efficient String Rotation Validator **Problem Statement:** You are given two strings, `s1` and `s2`. Your task is to determine if `s2` is a rotation of `s1`. A string rotation is defined as a string that can be obtained by cyclically shifting the characters of the string. For example, \\"waterbottle\\" is a rotation of \\"erbottlewat\\". To solve this problem, you cannot use the direct string rotation checking methods provided by the language libraries. Instead, you need to apply a thoughtful concatenation technique. **Hint:** A string `s2` is a rotation of `s1` if and only if `s2` is a substring of `s1 + s1`. **Input:** - Two strings `s1` and `s2`. **Output:** - A boolean value indicating whether `s2` is a rotation of `s1`. **Constraints:** - The strings consist of printable ASCII characters. - 1 ≤ length of `s1`, `s2` ≤ 1000. - Both `s1` and `s2` have the same length. **Example 1:** ```python s1 = \\"waterbottle\\" s2 = \\"erbottlewat\\" ``` **Output:** ```python True ``` **Example 2:** ```python s1 = \\"hello\\" s2 = \\"lohel\\" ``` **Output:** ```python True ``` **Example 3:** ```python s1 = \\"hello\\" s2 = \\"ohlle\\" ``` **Output:** ```python False ``` **Function Signature:** ```python def is_rotation(s1: str, s2: str) -> bool: pass ``` **Implementation:** Implement the function `is_rotation` to check if one string is a rotation of the other using efficient techniques without relying on direct string rotation methods provided by the language libraries. **Example Execution:** ```python >>> is_rotation(\\"abcd\\", \\"dabc\\") True >>> is_rotation(\\"abcd\\", \\"dcba\\") False ```","solution":"def is_rotation(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1. Args: s1 (str): The original string. s2 (str): The string to check as a rotation of s1. Returns: bool: True if s2 is a rotation of s1, False otherwise. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"# Problem Statement You are asked to implement a function that evaluates a postfix (Reverse Polish Notation) expression. A postfix expression is a mathematical notation in which every operator follows all of its operands. This format does not need any parentheses as long as operators have a fixed number of operands. # Requirements 1. **Evaluation**: Parse the input string and evaluate the postfix expression using a stack-based approach. 2. **Support**: The function should support the four basic arithmetic operations: addition, subtraction, multiplication, and division. # Input * A string representing a valid postfix expression. All tokens in the expression are separated by a single space. # Output * A float or integer result of evaluating the postfix expression. # Constraints 1. The input will be a valid postfix expression containing non-negative integers and the \'+\', \'-\', \'*\', \'/\' operators. 2. Division should be treated as integer division if the operands are integers, and floating-point division if any operand is a float. 3. You may assume that the input expression will not result in division by zero. 4. The input string length will not exceed 1000 characters. # Example **Input**: ``` \\"5 1 2 + 4 * + 3 -\\" ``` **Output**: ``` 14 ``` # Explanation - The given postfix expression can be broken down as follows: ``` Step 1: \\"5 1 2\\" Step 2: Push 5 onto the stack Step 3: Push 1 onto the stack Step 4: Push 2 onto the stack Step 5: \\"1 2 +\\" -> Pop 2 and 1 from the stack, compute 1 + 2 = 3, push 3 onto the stack Step 6: \\"5 3 4\\" Step 7: Push 4 onto the stack Step 8: \\"3 4 *\\" -> Pop 4 and 3 from the stack, compute 3 * 4 = 12, push 12 onto the stack Step 9: \\"5 12\\" Step 10: \\"5 12 +\\" -> Pop 12 and 5 from the stack, compute 5 + 12 = 17, push 17 onto the stack Step 11: \\"17 3 -\\" -> Pop 3 and 17 from the stack, compute 17 - 3 = 14, push 14 onto the stack - The final result is 14. # Function Signature ```python def evaluate_postfix(expression: str) -> float: pass ``` # Note 1. Implement the stack operations manually, without relying on any specific stack libraries. 2. Handle edge cases such as empty input strings gracefully. 3. Ensure your implementation is efficient and follows best practices for handling mathematical expressions using stacks.","solution":"def evaluate_postfix(expression: str) -> float: stack = [] operators = {\'+\', \'-\', \'*\', \'/\'} if not expression: return 0 tokens = expression.split() for token in tokens: if token in operators: b = stack.pop() a = stack.pop() if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': result = a / b if isinstance(a, float) or isinstance(b, float) else int(a / b) stack.append(result) else: stack.append(float(token) if \'.\' in token else int(token)) return stack[0]"},{"question":"# Scenario: You are working on an inventory management system for a warehouse. The warehouse needs to keep track of inventory changes as products are stored and retrieved. You are tasked with writing a function that processes a list of transactions and returns the final count of each product in the warehouse. # Implement the Function: **Function Signature**: ```python def update_inventory(transactions: List[str]) -> Dict[str, int]: pass ``` **Input**: * A list of transactions (`transactions`: List[str]), where each transaction is represented as a string. Each string contains an action (\\"store\\" or \\"retrieve\\"), a product name, and a quantity. **Output**: * A dictionary where the keys are product names, and the values are the final counts of those products in the warehouse. **Constraints**: * Each transaction will be formatted as \\"action product_name quantity\\" (e.g., \\"store apples 50\\"). * The quantity will be a positive integer. * Product names will be unique strings. * It is guaranteed that the quantity of products retrieved will not exceed the quantity stored. # Example: **Input**: ```python transactions = [ \\"store apples 50\\", \\"store oranges 100\\", \\"retrieve apples 10\\", \\"store apples 30\\", \\"retrieve oranges 50\\" ] ``` **Output**: ```python { \\"apples\\": 70, \\"oranges\\": 50 } ``` **Explanation**: - Start with no inventory. - Store 50 apples. - Store 100 oranges. - Retrieve 10 apples, leaving 40 on hand. - Store 30 more apples, now 70 in total. - Retrieve 50 oranges, leaving 50 on hand. # Tips: * Initialize a dictionary to keep track of product counts. * Iterate over each transaction, parsing the action, product name, and quantity. * Update the dictionary accordingly, incrementing for \\"store\\" and decrementing for \\"retrieve\\" actions. * Ensure that the final dictionary accurately reflects the total counts after all transactions are processed. # Constraints: * You can assume that transactions list is non-empty. * The total number of products will not exceed 1000.","solution":"from typing import List, Dict def update_inventory(transactions: List[str]) -> Dict[str, int]: inventory = {} for transaction in transactions: action, product, quantity = transaction.split() quantity = int(quantity) if action == \\"store\\": if product in inventory: inventory[product] += quantity else: inventory[product] = quantity elif action == \\"retrieve\\": if product in inventory: inventory[product] -= quantity else: raise ValueError(f\\"Attempt to retrieve a non-existent product: {product}\\") return inventory"},{"question":"# Coding Assessment Question # Manipulating Complex Data Structures You are tasked with writing a function that analyzes the relationships between entities stored in a dictionary. Each key in the dictionary represents an entity, and the value is a list of other entities it is related to. The goal is to determine the entities that are indirectly related through a chain of relations. Here are the steps you need to follow: 1. Write a function that takes a dictionary where keys are entity names (strings) and values are lists of related entities (also strings). The function should return a dictionary where each key is an entity, and the value is a list of all entities that are reachable directly or indirectly from it. 2. Handle exceptions for cases where the input dictionary contains duplicate relations or invalid entities by raising relevant Python exceptions. Function Specifications 1. **find_all_related_entities** - **Input**: A dictionary where keys are strings and values are lists of strings. - **Output**: A dictionary where each key is an entity, and the value is a list of reachable entities from that key. - **Constraints**: - The input dictionary should not have any circular relation causing an infinite loop. - All entities must be strings. - Handle potential type errors and edge cases gracefully. - **Performance Requirements**: - Implementations should have a time complexity of O(n + m), where n is the number of entities and m is the number of relations. Example ```python def find_all_related_entities(data): # Your solution here # Example Usage data = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [], \\"E\\": [\\"F\\"], \\"F\\": [] } print(find_all_related_entities(data)) # Output: { # \\"A\\": [\\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"], # \\"B\\": [\\"C\\", \\"D\\", \\"E\\", \\"F\\"], # \\"C\\": [\\"E\\", \\"F\\"], # \\"D\\": [], # \\"E\\": [\\"F\\"], # \\"F\\": [] # } ``` Ensure your solution follows the given specifications and handles all edge cases effectively.","solution":"def find_all_related_entities(data): from collections import defaultdict, deque # Helper function to perform a BFS to find all reachable entities from a given node def bfs(start, graph): visited = set() queue = deque([start]) result = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) result.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) result.remove(start) # Remove the starting node itself from the result return result # Validate the input dictionary if not isinstance(data, dict): raise TypeError(\\"Input must be a dictionary\\") graph = defaultdict(list) for key, values in data.items(): if not isinstance(key, str) or not all(isinstance(val, str) for val in values): raise TypeError(\\"All keys and values must be strings\\") if key in values: raise ValueError(f\\"Entity {key} contains itself as a relation, which is not allowed\\") graph[key] = values result = {} for entity in graph: result[entity] = bfs(entity, graph) return result"},{"question":"# Coding Exercise: Unique Integer Finder **Objective**: Using the concepts demonstrated in algorithms and data structures, implement a function that finds the first non-repeating integer in a list of integers. # Specification: 1. Write a function `find_first_unique_number(numbers: list[int]) -> int` that processes the given list of integers to identify and return the first unique number in the list. If no unique number exists, return `-1`. 2. Implement additional internal functions if needed to support the main function. 3. Ensure that your solution handles edge cases such as an empty list or a list with no unique integers. # Function Signature: ```python def find_first_unique_number(numbers: list[int]) -> int: Find the first unique integer in a list of integers. Parameters: numbers (list[int]): The list of integers. Returns: int: The first unique integer in the list, or -1 if no unique integer exists. pass ``` # Constraints: * The list `numbers` can have up to `10^5` elements. * Integers in the list can range from `-10^9` to `10^9`. # Examples: ```python >>> find_first_unique_number([4, 5, 1, 2, 0, 4]) 5 >>> find_first_unique_number([7, 7, 7, 8, 8, 9]) 9 >>> find_first_unique_number([1, 2, 2, 1, 3, 4, 4]) 3 >>> find_first_unique_number([1, 1, 1, 1, 1]) -1 >>> find_first_unique_number([]) -1 ``` # Context: In applications where it is important to quickly identify unique elements, this function will help in efficiently determining the first non-repeating integer from a list. This can be particularly useful in scenarios such as stream processing or real-time data analysis.","solution":"def find_first_unique_number(numbers: list[int]) -> int: from collections import Counter if not numbers: return -1 # Count the occurrence of each number counts = Counter(numbers) # Find the first unique number by checking the count for number in numbers: if counts[number] == 1: return number return -1"},{"question":"# Problem Statement You are working on developing a simple text editor. One of the operations that needs to be supported is the ability to count the number of words in a given text. A word is defined as a sequence of non-space characters separated by one or more spaces. Write a function `count_words` that takes a string and returns the number of words in the string. # Function Signature ```python def count_words(text: str) -> int: ``` # Input - `text`: A string containing the text to be analyzed. # Output - An integer representing the number of words in the input string. # Constraints - The length of `text` will be between `0` and `10^5`. - The input string will contain only printable ASCII characters. # Examples 1. `count_words(\\"Hello, world!\\")` should return `2`. 2. `count_words(\\" Leading spaces\\")` should return `2`. 3. `count_words(\\"Trailing spaces \\")` should return `2`. 4. `count_words(\\" Multiple spaces between words \\")` should return `4`. 5. `count_words(\\"\\")` should return `0`. # Notes - Consecutive spaces should be treated as a single space when counting words. - Leading and trailing spaces should be ignored. - Ensure your function is efficient and can handle large inputs within the specified constraints. # Hints 1. Use the built-in `split` method in Python, which splits a string by whitespace by default, automatically handling multiple spaces. 2. Consider edge cases such as empty strings or strings containing only spaces.","solution":"def count_words(text: str) -> int: Returns the number of words in the given text. A word is defined as a sequence of non-space characters. Parameters: text (str): The input text to count words from. Returns: int: The number of words in the input text. if not text: return 0 words = text.split() return len(words)"},{"question":"# Problem Statement: You are tasked with implementing a system that efficiently handles a large number of user requests by designing a Least Recently Used (LRU) Cache. The challenge involves designing and implementing the following functionalities: 1. **LRU Cache Initialization**: Create a class that initializes an LRU cache with a specified capacity. 2. **Cache Operations**: Implement two main operations: `get` and `put`. - `get(key)`: Retrieve the value of the key if it exists in the cache, otherwise return -1. - `put(key, value)`: Insert or update the value if the key already exists. If the cache reaches its capacity, it should invalidate the least recently used item before inserting the new one. 3. **Efficient Data Structure**: Ensure that each operation runs in O(1) time complexity. # Function Signature: ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` # Input: * `capacity`: An integer representing the maximum number of items the cache can hold (1 <= capacity <= 10^5). * `key`: An integer representing the key to access the cache (~1 <= key <= 10^9~). * `value`: An integer representing the value to store in the cache (~1 <= value <= 10^9~). # Output: * Return the value associated with the given key for the `get` operation. * Return None for the `put` operation. # Constraints: * Ensure the solution is designed to handle a high volume of cache operations efficiently. * Optimize space usage to store the cache data effectively within the given capacity. # Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` # Note: Implement the LRU Cache using your data structures of choice (e.g., LinkedHashMap, deque, or custom implementation). Ensure edge cases, performance bottlenecks, and error scenarios are handled appropriately. This problem challenges your understanding of data structure design, efficient algorithm implementation, and the ability to optimize for both time and space complexities.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 value = self.cache.pop(key) self.cache[key] = value # Insert it again so it\'s the most recently used return value def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # Remove the first item (least recently used) self.cache[key] = value"},{"question":"# Financial Portfolio Evaluation To further your grasp on financial modeling and data manipulation, you are to create a function to evaluate the performance of a stock portfolio. The function will calculate the total portfolio value and return a comprehensive assessment based on individual stock values, quantities held, and the percentage of change in each stock\'s price. # Function Signature ```python def portfolio_evaluation(stock_quantities: dict, stock_prices: dict, percentage_changes: dict) -> dict: ``` # Parameters - `stock_quantities` (dict): A dictionary containing stock tickers (str) as keys and quantities (int) of each stock held as values. - `stock_prices` (dict): A dictionary containing stock tickers (str) as keys and current stock prices (float) as values. - `percentage_changes` (dict): A dictionary containing stock tickers (str) as keys and the percentage change (float) in each stock\'s price since it was last evaluated. # Returns - `dict`: A dictionary with the following keys and values: - \'total_value\' (float): The total value of the portfolio based on current prices. - \'individual_values\' (dict): A dictionary where each key is a stock ticker (str) and each value is the current value (float) of the stocks held for that ticker. - \'percentage_changes\' (dict): A dictionary where each key is a stock ticker (str) and each value is the percentage change in value (float) since the last evaluation. # Constraints - Stock tickers will be strings with alphanumeric characters only. - Quantities of stocks will be non-negative integers. - Prices of stocks will be non-negative floats. - Percentage changes can be negative, zero, or positive floats. - Ensure that all dictionaries passed as parameters have matching keys. # Usage Example ```python >>> stock_quantities = {\\"AAPL\\": 10, \\"TSLA\\": 5, \\"GOOGL\\": 2} >>> stock_prices = {\\"AAPL\\": 150.0, \\"TSLA\\": 720.5, \\"GOOGL\\": 2800.0} >>> percentage_changes = {\\"AAPL\\": 5.0, \\"TSLA\\": -2.0, \\"GOOGL\\": 1.2} >>> portfolio_evaluation(stock_quantities, stock_prices, percentage_changes) { \'total_value\': 15920.0, \'individual_values\': {\\"AAPL\\": 1500.0, \\"TSLA\\": 3602.5, \\"GOOGL\\": 5600.0}, \'percentage_changes\': {\\"AAPL\\": 5.0, \\"TSLA\\": -2.0, \\"GOOGL\\": 1.2} } ``` Implement the function ensuring accurate calculations and usability for financial analysis.","solution":"def portfolio_evaluation(stock_quantities: dict, stock_prices: dict, percentage_changes: dict) -> dict: Evaluates the performance of a stock portfolio. Parameters: stock_quantities (dict): Dictionary of stock tickers and quantities held. stock_prices (dict): Dictionary of stock tickers and current stock prices. percentage_changes (dict): Dictionary of stock tickers and percentage change in stock prices. Returns: dict: Dictionary containing total value, individual stock values, and percentage changes. total_value = 0 individual_values = {} for ticker in stock_quantities: quantity = stock_quantities[ticker] price = stock_prices[ticker] value = quantity * price individual_values[ticker] = value total_value += value return { \'total_value\': total_value, \'individual_values\': individual_values, \'percentage_changes\': percentage_changes }"},{"question":"# Question: You are to develop a program that simulates a simplified traffic light control system for a single intersection. **Objective:** Write two functions, `simulate_traffic_light` and `next_signal`. 1. `simulate_traffic_light(initial_state: str, k: int) -> str`: - Simulates the traffic light signals given an initial state and the number of signal changes, `k`. - The traffic light signals follow this sequence cyclically: \\"Red\\", \\"Green\\", \\"Yellow\\". - The function should return the state of the traffic light after `k` signal changes from the initial state. 2. `next_signal(current_state: str) -> str`: - Determines the next state in the traffic light sequence given the current state. - Returns the subsequent signal in the cycle. **Constraints:** - The initial state will be one of \\"Red\\", \\"Green\\", or \\"Yellow\\". - `k` will be a non-negative integer. - The function should efficiently calculate the result even for large `k` values, up to 10^9. **Input and Output:** - For simulate_traffic_light: - **Input**: A string representing the initial state and an integer `k` for the number of signal changes. - **Output**: A string representing the traffic light state after `k` changes. - For next_signal: - **Input**: A string representing the current state. - **Output**: A string representing the subsequent state in the traffic light sequence. **Examples:** 1. **Simulate Traffic Light Example:** ```python >>> simulate_traffic_light(\\"Red\\", 5) \'Green\' ``` 2. **Next Signal Example:** ```python >>> next_signal(\\"Yellow\\") \'Red\' ``` **Function Signatures:** ```python def simulate_traffic_light(initial_state: str, k: int) -> str: pass def next_signal(current_state: str) -> str: pass ``` **Performance Requirements:** - The `simulate_traffic_light` solution should handle large values of `k` (up to 10^9) efficiently, leveraging the cyclic nature of the traffic light sequence.","solution":"def simulate_traffic_light(initial_state: str, k: int) -> str: Simulates the traffic light signals given an initial state and the number of signal changes, `k`. The traffic light signals follow this sequence cyclically: \\"Red\\", \\"Green\\", \\"Yellow\\". The function returns the state of the traffic light after `k` signal changes from the initial state. states = [\\"Red\\", \\"Green\\", \\"Yellow\\"] current_index = states.index(initial_state) new_index = (current_index + k) % len(states) return states[new_index] def next_signal(current_state: str) -> str: Determines the next state in the traffic light sequence given the current state. Returns the subsequent signal in the cycle. states = [\\"Red\\", \\"Green\\", \\"Yellow\\"] current_index = states.index(current_state) next_index = (current_index + 1) % len(states) return states[next_index]"},{"question":"**Graph Traversal and Path Finding** # Problem Statement Given an undirected graph represented by an adjacency matrix, determine if there exists a path between two specified nodes and find the shortest path using Breadth-First Search (BFS). Write a function `find_shortest_path(graph: List[List[int]], start: int, end: int) -> Union[List[int], str]` that determines the shortest path between the `start` node and the `end` node. If no path exists, return the string \\"No Path Available\\". # Input Format - `graph` (List[List[int]]): An adjacency matrix representing the undirected graph, where `graph[i][j]` is `1` if there is an edge between node `i` and node `j`, and `0` otherwise (0 ≤ i, j < n, n ≤ 100). - `start` (int): The starting node (0 ≤ start < n). - `end` (int): The destination node (0 ≤ end < n). # Output Format - Return the shortest path as a list of node indices from the `start` node to the `end` node. - If no path exists, return the string \\"No Path Available\\". # Constraints - Assume the graph is connected and contains no negative weight cycles. - Node indices are zero-based. # Example ```python def find_shortest_path(graph: List[List[int]], start: int, end: int) -> Union[List[int], str]: # Your implementation here pass # Example usage: graph = [ [0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 1], [0, 0, 1, 0, 1], [1, 0, 1, 1, 0] ] print(find_shortest_path(graph, 0, 3)) # Output: [0, 4, 3] or [0, 4, 2, 3] print(find_shortest_path(graph, 3, 4)) # Output: [3, 4] print(find_shortest_path(graph, 1, 4)) # Output: [1, 2, 4] print(find_shortest_path(graph, 2, 0)) # Output: [2, 1, 0] ``` # Hints 1. Utilize a queue to implement BFS and keep track of the nodes visited. 2. Maintain a dictionary or list to reconstruct the path from the start node to the end node. 3. Check all nodes from the start node by marking them as visited to avoid cycles. # Additional Notes - Ensure your function handles edge cases, such as when the graph is fully connected or sparsely connected. - Your implementation should be as efficient as possible given the constraints.","solution":"from typing import List, Union from collections import deque, defaultdict def find_shortest_path(graph: List[List[int]], start: int, end: int) -> Union[List[int], str]: Determine the shortest path between start and end nodes using BFS. Parameters: - graph: adjacency matrix representing the undirected graph - start: starting node - end: destination node Returns: - the shortest path as a list of node indices if a path exists - \\"No Path Available\\" if no path exists if start == end: return [start] n = len(graph) visited = [False] * n parent = [-1] * n queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in range(n): if graph[current][neighbor] == 1 and not visited[neighbor]: visited[neighbor] = True parent[neighbor] = current queue.append(neighbor) if neighbor == end: path = [] while neighbor != -1: path.insert(0, neighbor) neighbor = parent[neighbor] return path return \\"No Path Available\\""},{"question":"# Question: Maximum Sum Path in a Binary Tree Given a binary tree, write a Python function to find the maximum sum path between any two nodes in the tree. A path may start and end at any node in the tree, and it must contain at least one node. Function Signature: ```python def max_sum_path(root: Node) -> int: pass ``` Input: - `root`: The root node of the binary tree, which can be `None` for an empty tree. Output: - An integer representing the maximum sum path between any two nodes. Constraints: - The tree can be empty, in which case the maximum sum is 0. - Each node contains an integer value which might be negative or positive. - You must achieve (O(n)) time complexity where (n) is the number of nodes in the tree. # Example: ```python # Example 1: # Construct the following binary tree # 10 # / # 2 10 # / # 20 1 -25 # / # 3 4 root = Node(10) root.left = Node(2) root.right = Node(10) root.left.left = Node(20) root.left.right = Node(1) root.right.right = Node(-25) root.right.right.left = Node(3) root.right.right.right = Node(4) assert max_sum_path(root) == 42 # Example 2: # Construct the following binary tree # -10 # / # 9 20 # / # 15 7 root = Node(-10) root.left = Node(9) root.right = Node(20) root.right.left = Node(15) root.right.right = Node(7) assert max_sum_path(root) == 42 ``` # Notes: - You may define additional helper functions if necessary. - Make sure to handle edge cases like an empty tree or trees with only one node.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None def max_sum_path(root): def find_max_sum(node): nonlocal max_sum if node is None: return 0 # Recursively calculate the maximum sum on the left and right subtrees left_sum = max(0, find_max_sum(node.left)) right_sum = max(0, find_max_sum(node.right)) # Update the global maximum sum with the maximum sum path through the current node local_max_sum = node.data + left_sum + right_sum max_sum = max(max_sum, local_max_sum) # Return the maximum sum path including the current node return node.data + max(left_sum, right_sum) max_sum = float(\'-inf\') find_max_sum(root) return 0 if root is None else max_sum"},{"question":"# Question: String Rotation Checker Scenario: String manipulation is a common task in various programming challenges. One specific operation involves determining if one string is a rotation of another string. This can be useful in real-world applications such as password checks, data normalization, and cyclic sequence detection. Task: Write a function `is_rotation(str1: str, str2: str) -> bool` that checks if `str1` is a rotation of `str2`. Implement a helper function `visualize_rotation_check(str1: str, str2: str) -> str` to visualize the process of checking rotations. Function Specifications: 1. `is_rotation(str1: str, str2: str) -> bool` - **Input**: Two strings `str1` and `str2`. - **Output**: A boolean value that indicates whether `str1` is a rotation of `str2`. 2. `visualize_rotation_check(str1: str, str2: str) -> str` - **Input**: Two strings `str1` and `str2`. - **Output**: A formatted string showing the details of the rotation check process. Examples: ```python >>> print(visualize_rotation_check(\\"waterbottle\\", \\"erbottlewat\\")) Original Strings: str1 = waterbottle str2 = erbottlewat Rotation Check: True >>> print(visualize_rotation_check(\\"waterbottle\\", \\"bottlewater\\")) Original Strings: str1 = waterbottle str2 = bottlewater Rotation Check: True >>> print(visualize_rotation_check(\\"waterbottle\\", \\"elttobretaw\\")) Original Strings: str1 = waterbottle str2 = elttobretaw Rotation Check: False >>> print(visualize_rotation_check(\\"rotation\\", \\"tationro\\")) Original Strings: str1 = rotation str2 = tationro Rotation Check: True >>> print(visualize_rotation_check(\\"rotation\\", \\"tationroa\\")) Original Strings: str1 = rotation str2 = tationroa Rotation Check: False ``` Constraints: - Strings are case-sensitive. - Use only basic string manipulation and checks; avoid using any specialized Python libraries for rotation checks. Performance Requirements: - Ensure the solution has a time complexity of O(N), where N is the length of the strings.","solution":"def is_rotation(str1: str, str2: str) -> bool: Checks if str1 is a rotation of str2. if len(str1) != len(str2): return False return str2 in (str1 + str1) def visualize_rotation_check(str1: str, str2: str) -> str: Provides a visual representation of the rotation check process. result = is_rotation(str1, str2) return f\\"Original Strings:nstr1 = {str1}nstr2 = {str2}nRotation Check:n{result}\\""},{"question":"# Knight\'s Path with Minimum Moves: You are given a function definition for finding the shortest path a knight can take on a chessboard from a starting position to an ending position, avoiding certain forbidden cells. Write a function `knight_shortest_path(n: int, start: Tuple[int, int], end: Tuple[int, int], obstacles: List[Tuple[int, int]]) -> int` to solve this problem. **Function Definition:** ```python def knight_shortest_path(n: int, start: Tuple[int, int], end: Tuple[int, int], obstacles: List[Tuple[int, int]]) -> int: # Your code here ``` **Input:** - `n` (int): The size of the board (`n x n`). - `start` (Tuple[int, int]): The starting cell `(x_start, y_start)` where the knight begins. - `end` (Tuple[int, int]): The target cell `(x_end, y_end)` where the knight needs to reach. - `obstacles` (List[Tuple[int, int]]): A list of tuples indicating the cells where the knight cannot step. **Output:** - Returns an integer representing the minimum number of moves the knight needs to reach the target cell `end` from the starting cell `start`. If it is impossible to reach the target, return `-1`. **Constraints:** - The knight\'s possible movements are: (±2, ±1) and (±1, ±2). - `0 < n <= 8`. - `0 <= len(obstacles) < n*n`. - The start and end positions are always within bounds and never coincide with the obstacles. **Example:** ```python start = (0, 0) end = (7, 7) obstacles = [(1, 2), (2, 3), (5, 6)] print(knight_shortest_path(8, start, end, obstacles)) # Output: # 6 ``` **Explanation:** - The knight starts at (0, 0) and follows the shortest path avoiding the obstacles to reach (7, 7) in the minimum number of moves. - Since the function seeks the shortest path, the returned integer is the count of moves required. Write the function considering that the knight needs to find the shortest path while avoiding the obstacles. Handle edge cases and ensure the solution completes within reasonable time limits for the given constraints.","solution":"from collections import deque def knight_shortest_path(n: int, start: tuple, end: tuple, obstacles: list) -> int: if start == end: return 0 knight_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] obstacles_set = set(obstacles) def is_valid(x, y): return 0 <= x < n and 0 <= y < n and (x, y) not in obstacles_set queue = deque([(start[0], start[1], 0)]) visited = set([start]) while queue: x, y, moves = queue.popleft() for dx, dy in knight_moves: next_x, next_y = x + dx, y + dy if (next_x, next_y) == end: return moves + 1 if is_valid(next_x, next_y) and (next_x, next_y) not in visited: visited.add((next_x, next_y)) queue.append((next_x, next_y, moves + 1)) return -1"},{"question":"Coding Assessment Question Context You are working on an analytics dashboard for an e-commerce platform. One of the features of this dashboard is to provide insights about the products sold, including identifying the most popular products based on sales data. The company applies different weights to purchases based on factors like user ratings and quantity sold to determine the popularity of products. Task Write a function `find_most_popular_product` that, given sales data about products, calculates the weighted popularity of each product and returns the product with the highest weighted popularity. # Function Signature ```python def find_most_popular_product( sales_data: List[Tuple[int, int, float]], ) -> int: Finds the most popular product based on sales data with weighted popularity. Args: sales_data: A list of tuples where each tuple contains three elements: (product_id, quantity_sold, user_rating). - product_id: An integer representing the product identifier. - quantity_sold: An integer representing the number of units sold. - user_rating: A float representing the average user rating of the product. Returns: int: The product ID of the most popular product based on the calculated weighted popularity. ``` # Input and Output Format - **Input**: - `sales_data` : A list of tuples with each tuple containing: - product_id (int): The identifier of the product. - quantity_sold (int): The quantity sold of the product. - user_rating (float): The average user rating of the product. - **Output**: An integer representing the product_id of the most popular product based on the weighted popularity. If there is a tie, return the smallest product_id among the tied products. # Constraints - Assume `1 <= len(sales_data) <= 10^6`. - Assume `1 <= product_id <= 10^9`. - Assume `1 <= quantity_sold <= 10^4`. - Assume `0 <= user_rating <= 5.0` and it\'s a float value with at most two decimal places. # Example ```python sales_data = [ (1001, 500, 4.5), (1002, 800, 4.2), (1003, 300, 4.8), (1004, 800, 4.1) ] print(find_most_popular_product(sales_data)) # Expected output: 1002 ``` # Notes - The weighted popularity of a product can be calculated by multiplying the `quantity_sold` by the `user_rating`. - Consider edge cases, such as when multiple products have the same weighted popularity. - Ensure the solution is optimized for large input sizes. Hints 1. Use a dictionary to accumulate the weighted popularity of each product. 2. Iterate through the dictionary to find the product with the highest weighted popularity. 3. Handle ties by returning the smallest product_id.","solution":"def find_most_popular_product(sales_data): from collections import defaultdict # Dictionary to store the weighted popularity of each product popularity = defaultdict(float) # Calculate weighted popularity for each product for product_id, quantity_sold, user_rating in sales_data: weighted_popularity = quantity_sold * user_rating popularity[product_id] += weighted_popularity # Find the product with the highest weighted popularity most_popular_product_id = None highest_popularity = 0 for product_id, total_weighted_popularity in popularity.items(): if (most_popular_product_id is None or total_weighted_popularity > highest_popularity or (total_weighted_popularity == highest_popularity and product_id < most_popular_product_id)): most_popular_product_id = product_id highest_popularity = total_weighted_popularity return most_popular_product_id"},{"question":"**Context**: As a software developer for an online retail platform, you are tasked with analyzing sales trends. One way to do this is by identifying patterns in daily sales figures. A valuable pattern to detect is whether the sales figures form a \\"zigzag\\" pattern, where each number is either strictly greater than or strictly less than the ones adjacent to it. **Task**: Write a function `is_zigzag` that determines whether the given list of integers forms a zigzag pattern. A sequence is considered a zigzag if each element is either greater than or less than its adjacent elements. # Function Signature ```python def is_zigzag(arr: List[int]) -> bool: pass ``` # Input * `arr`: A list of integers. # Output * Returns `True` if the list forms a zigzag pattern, otherwise `False`. # Constraints * 0 ≤ len(arr) ≤ 10^6 * Elements in the array can be any integer # Performance Requirement * The implementation should have a time complexity of (O(n)) and space complexity of (O(1)). # Example ```python assert is_zigzag([1, 3, 2, 4, 3]) == True assert is_zigzag([1, 2, 3, 4, 5]) == False assert is_zigzag([5, 1, 2, 3]) == False assert is_zigzag([5]) == True assert is_zigzag([]) == True ``` Implement the `is_zigzag` function such that it efficiently checks if the given input `arr` forms a zigzag pattern.","solution":"from typing import List def is_zigzag(arr: List[int]) -> bool: Determines whether the given list of integers forms a zigzag pattern. n = len(arr) if n < 2: return True for i in range(1, n - 1): if not ((arr[i-1] < arr[i] > arr[i+1]) or (arr[i-1] > arr[i] < arr[i+1])): return False return True"},{"question":"# Context: In a grid-based game, players can move in four possible directions (up, down, left, right) to navigate from a starting location to an objective location. Given a grid with some cells blocked, preventing movement through them, you need to determine the shortest path from the start to the objective. # Objective: Write a function `shortest_path(grid: List[List[int]], start: Tuple[int, int], objective: Tuple[int, int]) -> int` that calculates the minimum number of moves required to reach the objective from the start position. # Input: - A 2D list of integers `grid` (0 <= grid[i][j] <= 1) where 0 represents a free cell and 1 represents a blocked cell. - A tuple `start` (x, y), representing the starting coordinates in the grid. - A tuple `objective` (x, y), representing the objective coordinates in the grid. # Output: - An integer representing the minimum number of moves required to reach the objective from the start, or -1 if the objective is unreachable. # Constraints: - Assume the grid has at least one row and one column, and the start and objective are within the grid boundaries. - Movement is allowed only in four directions: up, down, left, right. - You cannot move into cells that are blocked (grid value of 1). # Function Signature: ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], objective: Tuple[int, int]) -> int: ``` # Examples: 1. `shortest_path([[0, 0, 0], [1, 1, 0], [0, 0, 0]], (0, 0), (2, 2)) -> 4` 2. `shortest_path([[0, 1], [1, 0]], (0, 0), (1, 1)) -> -1` # Explanation: Your task is to determine the minimum number of moves required to navigate to the objective from the start position, avoiding blocked cells. If the objective is unreachable, return -1. Use an efficient algorithm to ensure optimal performance, particularly for larger grids. # Notes: - Use a breadth-first search (BFS) approach to find the shortest path since it efficiently handles the constraints and ensures the shortest path is found in unweighted grids. - Consider edge cases where starting or objective positions are blocked or where the objective is immediately adjacent to the start. Create your implementation and describe the logic used to ensure correct, efficient, and optimized performance.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], objective: Tuple[int, int]) -> int: Determines the shortest path from start to objective in a grid avoiding blocked cells. Uses breadth-first search (BFS) for unweighted grid traversal. Args: grid (List[List[int]]): 2D grid representing the game board where 0 is free and 1 is blocked. start (Tuple[int, int]): Starting coordinates (x, y) in the grid. objective (Tuple[int, int]): Objective coordinates (x, y) in the grid. Returns: int: Minimum number of moves to reach the objective from start, or -1 if unreachable. if not grid or grid[start[0]][start[1]] == 1 or grid[objective[0]][objective[1]] == 1: return -1 moves = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up rows, cols = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) while queue: x, y, distance = queue.popleft() if (x, y) == objective: return distance for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1"},{"question":"# Coding Question: Genetic Algorithm for Function Optimization **Scenario**: You are a software engineer working on an optimization problem where you need to find the optimal parameters for a given function using a genetic algorithm. The function represents some performance metric in your application that you want to maximize. Write a function `genetic_optimization` that takes an initial population, a function to optimize, bounds for the parameters, and parameters for the genetic algorithm to find the optimal solution. Function Signature ```python def genetic_optimization( initial_population: list, fitness_function: callable, bounds: tuple, population_size: int, mutation_rate: float, generations: int, selection_rate: float = 0.5 ) -> tuple: Args: - initial_population (list): List of tuples representing the starting population. - fitness_function (callable): Function to optimize f(x1, x2, ...). - bounds (tuple): Tuple of tuples representing the bounds for each parameter ((min_x1, max_x1), (min_x2, max_x2), ...). - population_size (int): The size of the population for each generation. - mutation_rate (float): The rate at which mutations occur in the population. - generations (int): Number of generations to run the genetic algorithm. - selection_rate (float): The proportion of the best candidates to be selected for the next generation (default 0.5). Returns: - tuple: The best solution (x1, x2, ...) found. ``` Inputs - `initial_population`: A list of tuples representing the initial population. - `fitness_function`: A function that takes a tuple of parameters (x1, x2, ...) and returns a float score to be maximized. - `bounds`: A tuple of tuples representing the bounds for each parameter ((min_x1, max_x1), (min_x2, max_x2), ...). - `population_size`: An integer representing the size of the population for each generation. - `mutation_rate`: A float representing the rate at which mutations occur in the new population. - `generations`: An integer representing the number of generations to run the genetic algorithm. - `selection_rate`: A float representing the proportion of the best candidates to be selected for the next generation (default: 0.5). Outputs - A tuple (x1, x2, ...) representing the best solution found. Constraints - The algorithm should respect the bounds for the parameters. - Use uniform crossover for generating the next population. - The mutation should randomly modify the value of a parameter within its specified bounds. - Terminate after the specified number of generations and return the best solution found. # Examples ```python def fitness_function(params): x, y = params return -(x ** 2 + y ** 2) + 4 # Example with bounds initial_population = [(2, 3), (1, 1), (-2, -3), (1, -2), (0, 0)] bounds = ((-5, 5), (-5, 5)) # Parameters: initial_population, fitness_function, bounds, population_size, mutation_rate, generations print(genetic_optimization(initial_population, fitness_function, bounds, population_size=10, mutation_rate=0.1, generations=100)) ``` # Notes - The fitness function should be maximized. - Ensure individuals respect the given bounds while undergoing mutation and crossover. - Selection rate determines how many of the best individuals are carried forward to the next generation.","solution":"import random def genetic_optimization( initial_population, fitness_function, bounds, population_size, mutation_rate, generations, selection_rate=0.5): def select_best(population, fitnesses): selected_indices = sorted(range(len(fitnesses)), key=lambda i: fitnesses[i], reverse=True) num_selected = int(selection_rate * len(population)) selected_indices = selected_indices[:num_selected] return [population[i] for i in selected_indices] def crossover(parent1, parent2): child = [] for p1, p2 in zip(parent1, parent2): if random.random() < 0.5: child.append(p1) else: child.append(p2) return tuple(child) def mutate(individual): mutated = list(individual) for i in range(len(individual)): if random.random() < mutation_rate: mutated[i] = random.uniform(bounds[i][0], bounds[i][1]) return tuple(mutated) population = initial_population for generation in range(generations): fitnesses = [fitness_function(individual) for individual in population] new_population = select_best(population, fitnesses) while len(new_population) < population_size: parent1 = random.choice(new_population) parent2 = random.choice(new_population) child = crossover(parent1, parent2) child = mutate(child) new_population.append(child) population = new_population best_fitness_index = max(range(len(population)), key=lambda i: fitness_function(population[i])) return population[best_fitness_index]"},{"question":"# Problem Description You are given a non-empty list of integers representing the heights of bar graphs. Write a function that computes the maximum rectangular area possible in these bar graphs, where the width of each bar is 1 unit. Each bar’s height is given in the list. # Function Signature ```python def largest_rectangle_area(heights: list) -> int: pass ``` # Input * A list of integers `heights` representing the bar heights, where 0 < len(heights) <= 10^5 and 0 <= heights[i] <= 10^4. # Output * Return an integer representing the maximum rectangular area that can be formed within the bounds of the provided bar heights. # Constraints * The solution must have a time complexity of O(N). * The function should handle edge cases such as a list with all identical heights efficiently. * Ensure the solution is optimized for both time and space complexity given the constraints. # Examples ```python assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 assert largest_rectangle_area([2, 4]) == 4 assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 assert largest_rectangle_area([1, 3, 2, 1, 2]) == 5 assert largest_rectangle_area([2, 1, 2]) == 3 assert largest_rectangle_area([1]) == 1 ``` # Notes * Consider using a stack-based approach to maintain a record of bar heights and their indices to efficiently compute the maximum rectangular area. * Pay attention to the complexity when evaluating boundary cases such as the smallest and largest possible input sizes.","solution":"def largest_rectangle_area(heights: list) -> int: stack = [] max_area = 0 heights.append(0) # Append 0 to heights to flush remaining heights in stack at the end for i, h in enumerate(heights): while stack and heights[i] < heights[stack[-1]]: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area"},{"question":"# Question: Implement k-Means Clustering and Hierarchical Clustering You are provided with a dataset represented as a NumPy array. Write code to implement k-Means Clustering and Hierarchical Clustering to group the data points into clusters. Requirements: 1. Implement the `k_means_clustering()` function that performs k-Means Clustering. 2. Implement the `hierarchical_clustering()` function that performs Agglomerative Hierarchical Clustering. 3. The functions should take the dataset and the desired number of clusters as input. Function Signature: ```python def k_means_clustering(data: np.ndarray, num_clusters: int) -> np.ndarray: def hierarchical_clustering(data: np.ndarray, num_clusters: int) -> np.ndarray: ``` Input: - `data`: 2D NumPy array of shape `(n_samples, n_features)` - `num_clusters`: Integer, desired number of clusters Output: - 1D NumPy array of shape `(n_samples,)` representing the cluster labels for each data point Constraints: - `num_clusters` should be less than or equal to the number of `samples`. Example: ```python data = np.array([[1, 2], [1, 4], [1, 0], [4, 2], [4, 4], [4, 0]]) # Perform k-Means Clustering kmeans_labels = k_means_clustering(data, 2) print(kmeans_labels) # Perform Hierarchical Clustering hierarchical_labels = hierarchical_clustering(data, 2) print(hierarchical_labels) ``` Note: Handle all possible edge cases and optimize your code for performance.","solution":"import numpy as np from sklearn.cluster import KMeans, AgglomerativeClustering def k_means_clustering(data: np.ndarray, num_clusters: int) -> np.ndarray: Performs k-Means Clustering on the given dataset. kmeans = KMeans(n_clusters=num_clusters, random_state=0) kmeans.fit(data) return kmeans.labels_ def hierarchical_clustering(data: np.ndarray, num_clusters: int) -> np.ndarray: Performs Agglomerative Hierarchical Clustering on the given dataset. clustering = AgglomerativeClustering(n_clusters=num_clusters) clustering.fit(data) return clustering.labels_"},{"question":"# Coding Question: Calculating Moving Average of a List You need to implement a function that calculates the moving average of a list of numbers. The moving average is a type of finite impulse response filter. Depending on the specified window size, the function should return a new list where each element is the average of the previous elements within the defined window. Implement the function `moving_average(data: List[float], window_size: int) -> List[float]` that calculates the moving average using the following specifications: Input/Output Specifications * **Input**: A list of floating-point numbers `data` and an integer `window_size` representing the size of the window over which the average is computed. * **Output**: A list of floating-point numbers representing the moving averages. Constraints and Considerations * The function should raise a `ValueError` if `window_size` is less than or equal to zero or greater than the length of the data list. * Handle invalid input types gracefully by raising a `TypeError`. * Ensure the returned list has the same number of elements as the input list. Extend the start of the list as needed by averaging available elements. Example ```python >>> moving_average([1, 2, 3, 4, 5], 3) [1.0, 1.5, 2.0, 3.0, 4.0] >>> moving_average([10, 20, 30, 40, 50], 2) [10.0, 15.0, 25.0, 35.0, 45.0] >>> moving_average([1, 2], 3) Traceback (most recent call last): ... ValueError: window_size must be between 1 and the length of the data list ``` Solution ```python from typing import List def moving_average(data: List[float], window_size: int) -> List[float]: if not all(isinstance(num, (int, float)) for num in data): raise TypeError(\\"data must be a list of numbers\\") if not isinstance(window_size, int): raise TypeError(\\"window_size must be an integer\\") if window_size <= 0 or window_size > len(data): raise ValueError(\'window_size must be between 1 and the length of the data list\') averages = [] for i in range(len(data)): window_elements = data[max(0, i - window_size + 1):i+1] averages.append(sum(window_elements) / len(window_elements)) return averages # Example usage print(moving_average([1, 2, 3, 4, 5], 3)) # Output: [1.0, 1.5, 2.0, 3.0, 4.0] print(moving_average([10, 20, 30, 40, 50], 2)) # Output: [10.0, 15.0, 25.0, 35.0, 45.0] ```","solution":"from typing import List def moving_average(data: List[float], window_size: int) -> List[float]: if not all(isinstance(num, (int, float)) for num in data): raise TypeError(\\"data must be a list of numbers\\") if not isinstance(window_size, int): raise TypeError(\\"window_size must be an integer\\") if window_size <= 0 or window_size > len(data): raise ValueError(\'window_size must be between 1 and the length of the data list\') averages = [] for i in range(len(data)): window_elements = data[max(0, i - window_size + 1):i+1] averages.append(sum(window_elements) / len(window_elements)) return averages"},{"question":"# Task You are tasked with implementing a function that finds the mode(s) (most frequently occurred element(s)) in a given list of integers. The function should return a list of the mode(s) in ascending order. If there are multiple modes with the same frequency, all of them should be included in the result. # Function Signature ```python def find_modes(arr: List[int]) -> List[int]: ... ``` # Input - `arr` (type `List[int]`): A list of integers. # Output - A list of integers representing the mode(s) of the input list in ascending order. # Constraints: - The input list\'s length will not exceed 10^5. - All integers in the input list will be between -10^6 and 10^6. # Example ```python >>> find_modes([1, 2, 2, 3, 3, 3, 4]) [3] >>> find_modes([1, 1, 2, 2, 3]) [1, 2] >>> find_modes([1]) [1] ``` # Considerations: - If the input list is empty, return an empty list. - Ensure the function is efficient and can handle large inputs. - Consider edge cases like having multiple modes with the same frequency or all elements being unique.","solution":"from collections import Counter from typing import List def find_modes(arr: List[int]) -> List[int]: Finds and returns the mode(s) of the input list in ascending order. Parameters: arr (List[int]): A list of integers Returns: List[int]: A list of mode(s) in ascending order if not arr: return [] # Count the frequency of each element freq = Counter(arr) # Find the maximum frequency max_freq = max(freq.values()) # Extract elements that have the maximum frequency modes = [num for num, count in freq.items() if count == max_freq] # Sort the modes in ascending order modes.sort() return modes"},{"question":"# Problem Statement You are given a list of strings that represent file names. Write a function `count_extensions` that counts the frequency of each file extension and returns a dictionary with the extensions as keys and their respective counts as values. Function Signature ```python def count_extensions(file_names: list[str]) -> dict[str, int]: ``` Input - `file_names` (list[str]): A list of strings representing file names, where `1 <= len(file_names) <= 100` and each file name string is non-empty and has a valid extension. Output - A dictionary with file extensions as keys and their counts as values. Constraints - Each file name contains one and only one dot (`.`) which separates the file name from the extension. - Assume all file names are in lower case. - Extensions may differ in length and can comprise only letters. # Example ```python file_names = [ \\"document.txt\\", \\"notes.doc\\", \\"image.jpeg\\", \\"file.pdf\\", \\"presentation.ppt\\", \\"archive.zip\\", \\"script.py\\", \\"spreadsheet.xlsx\\", \\"photo.png\\", \\"webpage.html\\", \\"data.csv\\", \\"notes.doc\\", \\"file.pdf\\" ] print(count_extensions(file_names)) # Output should be: # { # \'txt\': 1, # \'doc\': 2, # \'jpeg\': 1, # \'pdf\': 2, # \'ppt\': 1, # \'zip\': 1, # \'py\': 1, # \'xlsx\': 1, # \'png\': 1, # \'html\': 1, # \'csv\': 1 # } ``` # Additional Notes - Make sure to handle different file extensions correctly even if some of them appear multiple times. - The function should efficiently count and store the frequency of each unique file extension. - Test your function with varying lengths and frequencies of file extensions to ensure accuracy.","solution":"def count_extensions(file_names): This function takes a list of file names and returns a dictionary containing the count of each file extension. Args: file_names (list): List of strings representing file names. Returns: dict: A dictionary where keys are file extensions and values are their respective counts. extension_count = {} for name in file_names: extension = name.split(\'.\')[-1] if extension in extension_count: extension_count[extension] += 1 else: extension_count[extension] = 1 return extension_count"},{"question":"# Coding Assessment Question You are tasked with implementing a function that simulates a basic calculator capable of evaluating simple mathematical expressions. The expressions will include the four basic arithmetic operators: addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). Your calculator should respect the order of operations (parentheses have the highest precedence, followed by multiplication and division, and finally addition and subtraction). You must implement the function `evaluate_expression(expression: str) -> float` which takes a string mathematical expression and returns its floating-point value. **Function Signature**: ```python def evaluate_expression(expression: str) -> float: pass ``` # Input * A string `expression` that represents a mathematical expression. The expression can include: - Non-negative integers - Decimal numbers - Parentheses for grouping - Whitespace that should be ignored * The length of the expression string will be between `1` and `100`. # Output * Return the calculated value as a float. # Example ```python assert abs(evaluate_expression(\\"3 + 2 * 2\\") - 7.0) < 1e-9 assert abs(evaluate_expression(\\" 3/2 \\") - 1.5) < 1e-9 assert abs(evaluate_expression(\\" (2 + 3) * 4.5 \\") - 22.5) < 1e-9 ``` # Constraints * The function should handle division by zero by raising a `ZeroDivisionError`. # Performance Requirements * Your solution must run efficiently within the provided constraints and handle various operator precedence correctly. # Explanation Provide comments within your code explaining the steps or approaches taken, particularly around: * Parsing the input expression into operands and operators * Handling operator precedence using a stack * Managing parentheses correctly * Dealing with potential division by zero Good luck!","solution":"def evaluate_expression(expression: str) -> float: def apply_operator(operators, values): Apply the operator at the top of the operators stack to the top two values in the values stack. operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': if right == 0: raise ZeroDivisionError(\\"Division by zero\\") values.append(left / right) def precedence(op): Define operator precedence. if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def parse_expression(expression): Parse the input expression into tokens (numbers, operators, and parentheses). tokens = [] num = \'\' for char in expression.replace(\' \', \'\'): if char.isdigit() or char == \'.\': num += char else: if num: tokens.append(float(num)) num = \'\' tokens.append(char) if num: tokens.append(float(num)) return tokens tokens = parse_expression(expression) operators = [] values = [] i = 0 while i < len(tokens): token = tokens[i] if isinstance(token, float): values.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() # Remove left parenthesis else: # operator while operators and precedence(operators[-1]) >= precedence(token): apply_operator(operators, values) operators.append(token) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"# Sorting Words by Length & Alphabetical Order As a software engineer at a text processing company, you are tasked with developing a feature that sorts a list of words based on their lengths and alphabetically within the same length. Your task is to implement this functionality such that it is efficient and handles large datasets of words. Task: Write a Python function `sort_words` that accepts a list of words (strings) and returns a new list with the words sorted first by their lengths in ascending order and then alphabetically within the same length. Function Signature: ```python def sort_words(words: List[str]) -> List[str]: ``` Input: * `words` - A list of words as strings (0 <= len(words) <= 10^5). Each word contains only lowercase alphabetic characters and has a length between 1 and 100 characters. Output: * A list of words sorted by length and then alphabetically within each length. Constraints: * Ensure the sorting is efficiently handled given the input size. * The words in the result should be in the same order of appearance for words of the same length. * Handle up to 10^5 words efficiently. Example: ```python >>> sort_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"]) [\'fig\', \'date\', \'apple\', \'grape\', \'banana\', \'cherry\'] >>> sort_words([\\"dog\\", \\"cat\\", \\"elephant\\", \\"tiger\\", \\"rat\\", \\"lion\\"]) [\'cat\', \'dog\', \'rat\', \'lion\', \'tiger\', \'elephant\'] ``` # Scenario: Imagine this function will integrate into a content curation application where words need to be formatted and displayed neatly in a sorted manner based on user preferences. The ability to effectively handle large datasets ensures smooth and efficient processing of text data.","solution":"from typing import List def sort_words(words: List[str]) -> List[str]: Sorts a list of words first by their lengths in ascending order, and then alphabetically within the same length. return sorted(words, key=lambda word: (len(word), word))"},{"question":"# Meeting Room Scheduler You have been tasked with developing a meeting room scheduler for an office. The objective is to determine the minimum number of meeting rooms required to accommodate all the meetings without conflicts. Each meeting has a start and end time, and two meetings overlap if one meeting starts before the other one ends. Function Signature ```python def min_meeting_rooms(meetings: List[Tuple[int, int]]) -> int: This function calculates the minimum number of meeting rooms required to accommodate all given meetings. :param meetings: A list of tuples where each tuple consists of two integers, the start and end times of a meeting. :return: Integer value representing the minimum number of meeting rooms required. ``` Input 1. **meetings**: A list of tuples, each containing two integers. The first integer represents the start time of a meeting, and the second integer represents the end time. Output * An integer that represents the minimum number of meeting rooms required to accommodate all the given meetings. Constraints * The start and end times are in the format of a 24-hour clock. * The function should handle cases where a meeting starts at the same time another meeting ends without causing a conflict. Example ```python # Example meeting times representation meetings_schedule = [(0, 30), (5, 10), (15, 20)] assert min_meeting_rooms(meetings_schedule) == 2 meetings_schedule = [(7, 10), (2, 4)] assert min_meeting_rooms(meetings_schedule) == 1 ``` Notes * Consider using a min-heap to efficiently track end times of ongoing meetings. * Ensure to sort the meeting times initially, either by start or end time, as appropriate for your solution. * The time complexity should ideally be (O(n log n)) due to sorting and efficient heap operations.","solution":"from typing import List, Tuple import heapq def min_meeting_rooms(meetings: List[Tuple[int, int]]) -> int: if not meetings: return 0 # Sort the meetings by start time meetings.sort(key=lambda x: x[0]) # Use a min heap to track the end time of meetings min_heap = [] # Add the first meeting\'s end time to the heap heapq.heappush(min_heap, meetings[0][1]) # Iterate through the remaining meetings for meeting in meetings[1:]: # If the earliest ending meeting is finished, remove it from the heap if meeting[0] >= min_heap[0]: heapq.heappop(min_heap) # Push the current meeting\'s end time onto the heap heapq.heappush(min_heap, meeting[1]) # The size of the heap will be the number of meeting rooms required return len(min_heap)"},{"question":"# Coding Assessment Question Context A palindromic number reads the same both ways (left to right and right to left). For example, 121 is a palindromic number, but 123 is not. Given an integer (n), your task is to implement a function to find the largest palindromic number made from the product of two integers less than (n). Task Write a function `largest_palindromic_number(n: int) -> int` that returns the largest palindromic number that is a product of two integers, both less than (n). Input * An integer (n) where (10 leq n leq 10000). Output * An integer representing the largest palindromic number which is a product of two integers both less than (n). Constraints * The function should be optimized to handle the upper limit efficiently. * Consider edge cases such as when (n) is very small (e.g., (n = 10)). Example ```python def largest_palindromic_number(n: int) -> int: # Implementation here pass # Example Usage print(largest_palindromic_number(100)) # Output: 9009 (91 * 99) print(largest_palindromic_number(1000)) # Output: 906609 (913 * 993) ``` # Requirements * Implement a helper function to check if a number is palindromic. * Utilize this helper function to find the largest palindromic number made from the product of two integers, both less than the given limit. * Return the largest palindromic number found.","solution":"def is_palindrome(number: int) -> bool: Checks if a given number is a palindrome. return str(number) == str(number)[::-1] def largest_palindromic_number(n: int) -> int: Returns the largest palindromic number that is a product of two integers both less than n. max_palindrome = 0 for i in range(n-1, 0, -1): for j in range(i, 0, -1): product = i * j if product <= max_palindrome: break if is_palindrome(product): max_palindrome = product return max_palindrome"},{"question":"# Simulated Annealing for Integer Optimization You are provided with an integer optimization problem that can be solved using the Simulated Annealing algorithm. Your task is to implement a function that uses Simulated Annealing to find the global minimum of a given quadratic equation. Function Signature ```python def simulated_annealing(func, bounds, initial_temp, cooling_rate): ``` Input - **func**: The objective function, represented as a lambda function for a quadratic equation of the form ( ax^2 + bx + c ) where `a`, `b`, and `c` are constants. - **bounds**: A tuple of integers (lower_bound, upper_bound) representing the search space for the integer `x`. - **initial_temp**: A positive float representing the initial temperature. - **cooling_rate**: A float between 0 and 1 representing the rate at which the temperature decreases. Output - Returns an integer which is the global minimum found within the given bounds. Implementation Requirements: 1. **Initialization**: Start with a random integer within the bounds as the current solution. 2. **Energy Function**: Evaluate the objective function at the current solution to determine its \\"energy\\". 3. **Neighbor Solution**: Generate a neighboring solution by making a small random modification to the current solution. 4. **Acceptance Probability**: Calculate the acceptance probability of the neighbor solution based on the current temperature and energy difference. 5. **Cooling Schedule**: Gradually decrease the temperature using the cooling rate. 6. **Termination Condition**: Stop the algorithm when the temperature falls below a certain threshold or after a fixed number of iterations. Constraints - The bounds will ensure that the search space includes at least one valid integer. - The initial temperature and cooling rate will be positive and non-zero. # Example ```python # Example quadratic function func = lambda x: 3*x**2 - 12*x + 20 # Bounds for the integer search space bounds = (-10, 10) # Initial temperature and cooling rate initial_temp = 100.0 cooling_rate = 0.95 # Find the global minimum min_x = simulated_annealing(func, bounds, initial_temp, cooling_rate) print(min_x) # e.g., -3 or 2 (one of the values at which the global minimum occurs for 3x^2 - 12x + 20) ``` You are required to implement the full Simulated Annealing process for this integer optimization problem accurately as described.","solution":"import random import math def simulated_annealing(func, bounds, initial_temp, cooling_rate): Uses Simulated Annealing to find the global minimum of a given quadratic equation. # Initialize solution current_solution = random.randint(bounds[0], bounds[1]) current_energy = func(current_solution) # Initialize temperature temperature = initial_temp # While the system is still hot while temperature > 1e-5: # Generate neighbor solution neighbor_solution = current_solution + random.choice([-1, 1]) # small change neighbor if neighbor_solution < bounds[0] or neighbor_solution > bounds[1]: continue neighbor_energy = func(neighbor_solution) # Acceptance probability if neighbor_energy < current_energy: current_solution = neighbor_solution current_energy = neighbor_energy else: acceptance_probability = math.exp((current_energy - neighbor_energy) / temperature) if acceptance_probability > random.random(): current_solution = neighbor_solution current_energy = neighbor_energy # Cool the system temperature *= cooling_rate return current_solution"},{"question":"# Coding Assessment Question: Palindrome Permutation Checker A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Write a function that determines if a given string is a permutation of a palindrome. # Requirements - Implement the `char_frequency(s: str) -> dict` function to build a frequency dictionary of the characters in the input string (ignoring spaces and case). - Implement the `can_form_palindrome(freq_dict: dict) -> bool` function to check if the given character frequency dictionary can form a palindrome. - Create the main function `is_permutation_of_palindrome(s: str) -> bool` that returns True if the input string is a permutation of a palindrome, and False otherwise. # Input - A single string `s` containing only alphabetic characters and spaces. # Output - Boolean value: True if the input string can be rearranged to form a palindrome, False otherwise. # Function Signatures ```python def char_frequency(s: str) -> dict: pass def can_form_palindrome(freq_dict: dict) -> bool: pass def is_permutation_of_palindrome(s: str) -> bool: pass ``` # Constraints - The input string will have a length of at least 1 and at most 1000 characters. - Spaces should be ignored in palindrome checking. # Example ```python input_string1 = \\"Tact Coa\\" print(is_permutation_of_palindrome(input_string1)) # Output: True (permutations: \\"tacocat\\", \\"atcocta\\", etc.) input_string2 = \\"Hello World\\" print(is_permutation_of_palindrome(input_string2)) # Output: False ``` # Explanation - In the first example, \\"Tact Coa\\" can be rearranged to \\"tacocat\\" which is a palindrome. - In the second example, \\"Hello World\\" cannot be rearranged into a palindrome.","solution":"def char_frequency(s: str) -> dict: This function builds a frequency dictionary of the characters in the input string, ignoring spaces and case. freq_dict = {} for char in s.replace(\\" \\", \\"\\").lower(): if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict def can_form_palindrome(freq_dict: dict) -> bool: This function checks if the given character frequency dictionary can form a palindrome. odd_count = 0 for count in freq_dict.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True def is_permutation_of_palindrome(s: str) -> bool: This function returns True if the input string is a permutation of a palindrome, and False otherwise. freq_dict = char_frequency(s) return can_form_palindrome(freq_dict)"},{"question":"# Matrix Diagonal Traverse Problem Description Given an m x n matrix, return an array of all the elements of the matrix in a diagonal order. The diagonal order is defined such that for each diagonal, elements are accessed starting from the right to the left and top to the bottom. Function Signature ```python def findDiagonalOrder(matrix: List[List[int]]) -> List[int]: pass ``` Input * `matrix` (List[List[int]]): a 2D list representing the matrix. (1 <= len(matrix), len(matrix[0]) <= 1000) Output * Return a list of integers representing the elements of the matrix in diagonal traversal order. Constraints * The matrix contains only integer elements. Example ```python assert findDiagonalOrder([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [1, 2, 4, 7, 5, 3, 6, 8, 9] assert findDiagonalOrder([ [1, 2], [3, 4] ]) == [1, 2, 3, 4] ``` Hints * Notice how the direction switches after reaching the borders of the matrix. * Use a flag to indicate the direction of traversal (up-right or down-left). * Modify the row and column indices based on the current direction and switch direction appropriately when a border is reached.","solution":"from typing import List def findDiagonalOrder(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] up = True row, col = 0, 0 while len(result) < m * n: result.append(matrix[row][col]) if up: if col == n - 1: row += 1 up = False elif row == 0: col += 1 up = False else: row -= 1 col += 1 else: if row == m - 1: col += 1 up = True elif col == 0: row += 1 up = True else: row += 1 col -= 1 return result"},{"question":"# Problem Statement Scenario You are developing a data analysis tool that processes lists of numbers. One common operation required is to determine the k-th smallest element in a list, where k is a given positive integer. Task Write a function `kth_smallest_element` which takes a list of integers and a positive integer `k` as input, and returns the k-th smallest element in the list. Input Format * A list of integers `nums` (1 ≤ length of `nums` ≤ 10^5). * A single positive integer `k` (1 ≤ `k` ≤ length of `nums`). Output Format * A single integer representing the k-th smallest element in the list. Constraints * All integers in the list will be distinct. * The list can be very large, so consider efficient sorting or selection algorithms for optimal performance. Example ```python kth_smallest_element([7, 10, 4, 3, 20, 15], 3) # Output: 7 kth_smallest_element([50, 30, 20, 10, 40], 1) # Output: 10 kth_smallest_element([5, 8, 12, 7, 19, 1], 5) # Output: 12 kth_smallest_element([3, 2, 1], 2) # Output: 2 ``` Notes * You may consider using efficient selection algorithms such as the QuickSelect algorithm to achieve linear time complexity on average. * Ensure your implementation can handle lists that are relatively large efficiently.","solution":"def kth_smallest_element(nums, k): Returns the k-th smallest element in the list of nums. Args: nums: List[int] -- a list of integers where all elements are distinct. k: int -- a positive integer (1 ≤ k ≤ length of nums). Returns: int -- the k-th smallest element in the list. def quickselect(l, r, k_smallest): Helper function to perform the QuickSelect. Args: l: int -- the starting index of the part of the list to perform quickselect on. r: int -- the ending index of the part of the list to perform quickselect on. k_smallest: int -- the k-th smallest index to find in the list. Returns: int -- the k-th smallest element in the list segment. if l == r: return nums[l] pivot_index = partition(l, r) # The pivot is in its final sorted position if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(l, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, r, k_smallest) def partition(l, r): Partition the list by taking the last element as pivot. Args: l: int -- the starting index of the part of the list to partition. r: int -- the ending index of the part of the list to partition. Returns: int -- the partition index where the pivot element is placed. pivot = nums[r] i = l for j in range(l, r): if nums[j] < pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[r] = nums[r], nums[i] return i return quickselect(0, len(nums) - 1, k - 1)"},{"question":"# Question A company wants to evaluate its employees\' efficiency based on their email response times. You are tasked with writing a function that organizes the email response times and identifies the employee with the quickest average response time over a given period. **Function Signature**: ```python def quickest_responder(times: List[Tuple[int, int]]) -> int: Finds the employee ID with the fastest average email response time. Parameters: times (List[Tuple[int, int]]): A list where each element is a tuple containing an employee ID and their email response time in minutes. Returns: int: The ID of the employee with the fastest average response time. Raises: ValueError: If the list \'times\' is empty. ``` **Input**: * `times`: A list of tuples where each tuple contains two integers. The first integer is the employee ID, and the second integer is the email response time in minutes. The list may contain multiple entries for the same employee. **Output**: * Returns an integer representing the ID of the employee with the quickest average response time. **Constraints**: * The `times` list contains at least one tuple. * Each tuple contains valid integers for both employee ID and response time. * There are no ties in the average response times (i.e., each employee has a unique average response time). **Example**: ```python assert quickest_responder([(1, 15), (2, 10), (1, 20), (2, 5)]) == 2 assert quickest_responder([(4, 30), (3, 40), (4, 25), (3, 35), (4, 30)]) == 4 assert quickest_responder([(5, 50)]) == 5 ``` **Notes**: * Calculate the average response time for each employee based on the given data. * Ensure to handle a list with a single entry. * Validate that the input list is not empty, and if it is, raise a `ValueError`. * Your solution should be efficient and handle a reasonable amount of data input.","solution":"from typing import List, Tuple def quickest_responder(times: List[Tuple[int, int]]) -> int: Finds the employee ID with the fastest average email response time. Parameters: times (List[Tuple[int, int]]): A list where each element is a tuple containing an employee ID and their email response time in minutes. Returns: int: The ID of the employee with the fastest average response time. Raises: ValueError: If the list \'times\' is empty. if not times: raise ValueError(\\"The input list cannot be empty\\") # Create a dictionary to store cumulative response times and count of emails per employee response_data = {} for emp_id, response_time in times: if emp_id in response_data: response_data[emp_id][\'total_time\'] += response_time response_data[emp_id][\'count\'] += 1 else: response_data[emp_id] = {\'total_time\': response_time, \'count\': 1} # Compute the average response times average_response_times = {emp_id: data[\'total_time\'] / data[\'count\'] for emp_id, data in response_data.items()} # Find the employee ID with the smallest average response time quickest_employee = min(average_response_times, key=average_response_times.get) return quickest_employee"},{"question":"# Question: Building an Interactive Command-Line To-Do Application Context You are asked to develop an interactive command-line to-do application in Python that allows users to manage their tasks efficiently. The application should handle adding, viewing, editing, and deleting tasks, as well as saving and loading tasks from a file. Requirements 1. **ToDo Application Class (`ToDoApp`)**: - Should contain a list to store tasks. - Must support adding, viewing, editing, and deleting tasks. - Should enable saving tasks to a file and loading tasks from a file. 2. **Command-Line Interaction**: - Implement methods in the `ToDoApp` class to handle user commands for adding, viewing, editing, and deleting tasks. - Ensure the application provides clear instructions and feedback to the user. 3. **File Handling for Persistence**: - Implement functionality to save the current list of tasks to a file. - Implement functionality to load tasks from a file when the application starts. Implementation Details - **Input Format**: - The user will interact via command-line inputs. - Task descriptions are strings; task IDs are integers allocated by the system. - **Output Format**: - Display the list of tasks. - Success or error messages for each action. - **Constraints**: - Ensure tasks with unique IDs. - Provide edge-case handling if the file is not found or cannot be read. Function Signature ```python class ToDoApp: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, description: str) -> None: pass # Implement adding a new task with a unique ID def view_tasks(self) -> str: pass # Return a formatted string of all tasks def edit_task(self, task_id: int, new_description: str) -> None: pass # Implement editing the description of a specific task def delete_task(self, task_id: int) -> None: pass # Implement deleting a specific task def save_tasks(self, filename: str) -> None: pass # Implement saving tasks to a file def load_tasks(self, filename: str) -> None: pass # Implement loading tasks from a file # Example Usage: # app = ToDoApp() # app.add_task(\\"Buy groceries\\") # app.add_task(\\"Schedule meeting\\") # print(app.view_tasks()) # app.edit_task(1, \\"Buy groceries and cook dinner\\") # app.delete_task(2) # app.save_tasks(\\"tasks.txt\\") # app.load_tasks(\\"tasks.txt\\") ``` Performance Requirements - The application should handle basic file operations efficiently. - Ensure easy interaction through command-line inputs and validate user inputs appropriately.","solution":"import json class ToDoApp: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, description: str) -> None: Adds a new task to the list with a unique ID and given description. task = {\\"id\\": self.next_id, \\"description\\": description} self.tasks.append(task) self.next_id += 1 def view_tasks(self) -> str: Returns a formatted string of all tasks. if not self.tasks: return \\"No tasks available.\\" formatted_tasks = [\\"Tasks:\\"] for task in self.tasks: formatted_tasks.append(f\\"{task[\'id\']}: {task[\'description\']}\\") return \\"n\\".join(formatted_tasks) def edit_task(self, task_id: int, new_description: str) -> None: Edits the description of the task with the given ID. for task in self.tasks: if task[\\"id\\"] == task_id: task[\\"description\\"] = new_description return raise ValueError(f\\"Task with ID {task_id} not found.\\") def delete_task(self, task_id: int) -> None: Deletes the task with the given ID. for task in self.tasks: if task[\\"id\\"] == task_id: self.tasks.remove(task) return raise ValueError(f\\"Task with ID {task_id} not found.\\") def save_tasks(self, filename: str) -> None: Saves the tasks to a file in JSON format. with open(filename, \'w\') as f: json.dump({\\"next_id\\": self.next_id, \\"tasks\\": self.tasks}, f) def load_tasks(self, filename: str) -> None: Loads the tasks from a file in JSON format. try: with open(filename, \'r\') as f: data = json.load(f) self.next_id = data[\\"next_id\\"] self.tasks = data[\\"tasks\\"] except FileNotFoundError: raise FileNotFoundError(f\\"File {filename} not found.\\")"},{"question":"# Coding Challenge: Longest Substring Without Repeating Characters Context String manipulation and optimization tasks are common in software engineering. This problem involves finding the longest substring within a given string that contains no repeating characters. A naive approach might involve examining all possible substrings, but an optimized solution is necessary for handling large datasets efficiently, maintaining O(n) time complexity. Task Write a function `length_of_longest_substring(s: str) -> int` which returns an integer representing the length of the longest substring without repeating characters. Input * A single string `s` which can include letters, digits, and special characters. Output * An integer representing the length of the longest substring without repeating characters. Constraints * The input string `s` will have a length in the range from 0 to 10^5. * Time complexity must not exceed O(n). Performance Requirement Your solution should efficiently handle strings up to the length of 10^5. Example ```python >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"aA1!aA1!\\") 4 ``` Problem Solving Strategy 1. Utilize a sliding window approach with two pointers to maintain the current substring. 2. Use a hashmap to store the characters and their latest indexes, allowing for quick updates and checks. Good luck, and ensure your solution is efficient and robust against all edge cases!","solution":"def length_of_longest_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. Args: s (str): Input string. Returns: int: Length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem Description You are tasked to develop a system for tracking and merging intervals. An interval is defined by a start and an end boundary and represents a continuous, closed range of values. # Function Requirements 1. **Function Name**: `merge_intervals` - **Input**: - `intervals` (List[Tuple[int, int]]): A list of intervals represented as tuples, where each tuple contains two integers, the start and end values of the interval. - **Output**: - `merged_intervals` (List[Tuple[int, int]]): A list of non-overlapping, merged intervals sorted by their start boundaries. # Constraints - The intervals are unsorted and can have overlaps. - The start value of an interval is always less than or equal to the end value. - There can be empty intervals (i.e., the list can be empty). # Performance Requirements - The function should have O(n log n) time complexity, where n is the number of intervals, primarily due to the sorting step. # Example ```python intervals = [(1, 3), (2, 6), (8, 10), (15, 18)] merged_intervals = merge_intervals(intervals) print(merged_intervals) # Output: [(1, 6), (8, 10), (15, 18)] intervals = [(1, 4), (4, 5)] merged_intervals = merge_intervals(intervals) print(merged_intervals) # Output: [(1, 5)] ``` # Task Write the `merge_intervals` function to achieve the above requirements. You can use helper functions if necessary. ```python from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # Sort intervals by start value intervals.sort() merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # Overlap condition current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) return merged_intervals # Example Usage intervals = [(1, 3), (2, 6), (8, 10), (15, 18)] print(merge_intervals(intervals)) # Output: [(1, 6), (8, 10), (15, 18)] intervals = [(1, 4), (4, 5)] print(merge_intervals(intervals)) # Output: [(1, 5)] ```","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # Sort intervals by start value intervals.sort() merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # Overlap condition current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"**Scenario**: A social media application tracks user interactions in terms of likes and comments. Each post can receive multiple likes and comments, and the data is stored in a dictionary where each key is a post ID and its value is a list of tuples. Each tuple contains a timestamp and the interaction type (\'like\' or \'comment\'). The app needs an efficient way to filter and retrieve posts based on interaction type within a specified time range. **Problem**: Write a function `filter_interactions` that filters interactions by type and time range. **Function Signature**: ```python def filter_interactions(posts: Dict[int, List[Tuple[int, str]]], interaction_type: str, start_time: int, end_time: int) -> Dict[int, List[int]]: Filters interactions by type and time range. Parameters: posts (Dict[int, List[Tuple[int, str]]]): A dictionary where keys are post IDs and values are lists of (timestamp, interaction_type) tuples. interaction_type (str): The type of interaction to filter by (\'like\' or \'comment\'). start_time (int): The start of the time range (inclusive). end_time (int): The end of the time range (inclusive). Returns: Dict[int, List[int]]: A dictionary where keys are post IDs and values are lists of timestamps for interactions that match the criteria. ``` # Input - `posts`: A dictionary where keys are post IDs (integers) and values are lists of tuples. Each tuple contains two elements: an integer timestamp and a string interaction type (\'like\' or \'comment\'). - `interaction_type`: A string that is either \'like\' or \'comment\'. - `start_time`: An integer representing the start of the time range (inclusive). - `end_time`: An integer representing the end of the time range (inclusive). # Output - A dictionary where keys are the post IDs, and the values are lists of timestamps of the interactions that are of the specified `interaction_type` and fall within the `start_time` and `end_time` # Constraints - The dictionary `posts` is guaranteed to have at least one post. - The `interaction_type` will always be either \'like\' or \'comment\'. - Start and end times are given as valid integer timestamps. # Example ```python posts = { 1: [(1617645600, \'like\'), (1617645800, \'comment\'), (1617645900, \'like\')], 2: [(1617645700, \'comment\'), (1617645800, \'comment\')], 3: [(1617646000, \'like\')], } interaction_type = \'like\' start_time = 1617645600 end_time = 1617645900 result = filter_interactions(posts, interaction_type, start_time, end_time) print(result) # Output should be: {1: [1617645600, 1617645900]} ``` # Additional Notes - The function should efficiently handle scenarios where posts have varying numbers of interactions or no interactions of the specified type. - The implementation should account for edge cases such as no interactions in the specified time range or invalid `interaction_type`.","solution":"from typing import Dict, List, Tuple def filter_interactions(posts: Dict[int, List[Tuple[int, str]]], interaction_type: str, start_time: int, end_time: int) -> Dict[int, List[int]]: Filters interactions by type and time range. Parameters: posts (Dict[int, List[Tuple[int, str]]]): A dictionary where keys are post IDs and values are lists of (timestamp, interaction_type) tuples. interaction_type (str): The type of interaction to filter by (\'like\' or \'comment\'). start_time (int): The start of the time range (inclusive). end_time (int): The end of the time range (inclusive). Returns: Dict[int, List[int]]: A dictionary where keys are post IDs and values are lists of timestamps for interactions that match the criteria. filtered_posts = {} for post_id, interactions in posts.items(): filtered_timestamps = [ timestamp for timestamp, type_ in interactions if type_ == interaction_type and start_time <= timestamp <= end_time ] if filtered_timestamps: filtered_posts[post_id] = filtered_timestamps return filtered_posts"},{"question":"# Balanced Brackets Sequence In this task, you will write a function to determine the number of ways to form a balanced sequence of brackets with exactly `n` opening brackets (`\'(\'`) and `n` closing brackets (`\')\'`). A sequence of brackets is considered balanced if every opening bracket has a corresponding closing bracket and the brackets are properly nested. Write a function `balanced_bracket_sequences` **Function Signature**: ```python def balanced_bracket_sequences(n: int) -> int: ``` **Input**: - An integer `n`: The number of pairs of brackets to be used in the sequence. **Output**: - An integer representing the number of unique balanced sequences of `n` pairs of brackets. Constraints: - You can assume `n` is at least `1` and at most `15`. Example ```python print(balanced_bracket_sequences(1)) # expected output: 1 (only \\"()\\") print(balanced_bracket_sequences(2)) # expected output: 2 (\\"(())\\" and \\"()()\\") ``` Hints: - This is a classic problem related to Catalan numbers. - The n-th Catalan number can be used to compute the result. - Alternatively, you can use dynamic programming to iteratively build the sequences.","solution":"def balanced_bracket_sequences(n: int) -> int: Returns the number of unique balanced sequences of n pairs of brackets. # Catalan number formula to compute the number of balanced bracket sequences # C(n) = (2n)! / ((n+1)! * n!) from math import factorial def catalan_number(n): return factorial(2 * n) // (factorial(n + 1) * factorial(n)) return catalan_number(n)"},{"question":"# Context You are required to implement a data structure that manages item priorities in a similar manner to a Priority Queue. This data structure should allow insertion, deletion, lookup of the highest-priority item, and updating the priority of an existing item. # Problem Statement Implement a `PriorityQueue` class that supports the following methods: - `insert(self, item, priority)`: Inserts an item with its associated priority. - `extract_max(self)`: Removes and returns the item with the highest priority. Raises a `KeyError` if the queue is empty. - `get_max(self)`: Returns the item with the highest priority without removing it. Raises a `KeyError` if the queue is empty. - `change_priority(self, item, new_priority)`: Changes the priority of the given item. Raises a `KeyError` if the item is not found. # Requirements 1. The Priority Queue must efficiently support dynamic priority updates. 2. Your implementation should use a binary heap (max-heap) for efficiently handling priorities. 3. Duplicate items are not allowed in the queue. 4. Assume priorities are integers, and higher values have higher priority. # Constraints - Aim for an average time complexity of O(log n) for insertion, extraction, and priority update operations. - Use Python\'s built-in `heapq` module as a starting point, but customize it to maintain a max-heap. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python import heapq class PriorityQueue: def __init__(self): # Initialize your data structure self.heap = [] self.item_map = {} def insert(self, item, priority): # Insert item with its priority if item in self.item_map: raise KeyError(\\"Item already exists.\\") heapq.heappush(self.heap, (-priority, item)) self.item_map[item] = -priority def extract_max(self): # Extract and return the item with the highest priority if not self.heap: raise KeyError(\\"Priority queue is empty.\\") _, item = heapq.heappop(self.heap) del self.item_map[item] return item def get_max(self): # Get the item with the highest priority without extraction if not self.heap: raise KeyError(\\"Priority queue is empty.\\") return self.heap[0][1] def change_priority(self, item, new_priority): # Change the priority of the given item if item not in self.item_map: raise KeyError(\\"Item not found.\\") old_priority = self.item_map[item] self.heap.remove((old_priority, item)) heapq.heapify(self.heap) self.insert(item, new_priority) ``` # Example Usage ```python pq = PriorityQueue() pq.insert(\\"task1\\", 5) pq.insert(\\"task2\\", 3) pq.insert(\\"task3\\", 9) print(pq.get_max()) # Output: \\"task3\\" pq.change_priority(\\"task1\\", 10) print(pq.extract_max()) # Output: \\"task1\\" print(pq.get_max()) # Output: \\"task3\\" ```","solution":"import heapq class PriorityQueue: def __init__(self): # Initialize your data structure self.heap = [] self.item_map = {} def insert(self, item, priority): # Insert item with its priority if item in self.item_map: raise KeyError(\\"Item already exists.\\") heapq.heappush(self.heap, (-priority, item)) self.item_map[item] = -priority def extract_max(self): # Extract and return the item with the highest priority if not self.heap: raise KeyError(\\"Priority queue is empty.\\") while self.heap: priority, item = heapq.heappop(self.heap) if self.item_map.get(item) == priority: del self.item_map[item] return item def get_max(self): # Get the item with the highest priority without extraction if not self.heap: raise KeyError(\\"Priority queue is empty.\\") while self.heap: priority, item = self.heap[0] if self.item_map.get(item) == priority: return item heapq.heappop(self.heap) # Remove outdated entry def change_priority(self, item, new_priority): # Change the priority of the given item if item not in self.item_map: raise KeyError(\\"Item not found.\\") current_priority = self.item_map[item] self.item_map[item] = -new_priority heapq.heappush(self.heap, (-new_priority, item))"},{"question":"# Longest Common Subsequence Problem Statement You are given two sequences A and B. Your task is to find the length of their longest common subsequence (LCS). A common subsequence is a sequence that appears in both sequences in the same order, but not necessarily consecutively. Function Signature ```python def longest_common_subsequence(A: str, B: str) -> int: Compute the length of the Longest Common Subsequence (LCS) of two given sequences. Args: A (str): The first sequence. B (str): The second sequence. Returns: int: The length of the Longest Common Subsequence. Example: A = \\"AGGTAB\\" B = \\"GXTXAYB\\" longest_common_subsequence(A, B) -> 4 ``` Constraints * 1 <= len(A), len(B) <= 1000 * Each character in the sequences A and B is a letter from the alphabet (uppercase or lowercase). Implementation Details * Employ dynamic programming to construct a table that contains the lengths of LCSs of prefixes of the sequences. * Ensure your solution efficiently handles the input sizes. * Initialize the table with base conditions and iteratively fill it based on the relation between the elements of the sequences. Example Input ```python A = \\"AGGTAB\\" B = \\"GXTXAYB\\" ``` Expected Output ```python 4 ```","solution":"def longest_common_subsequence(A: str, B: str) -> int: Compute the length of the Longest Common Subsequence (LCS) of two given sequences. Args: A (str): The first sequence. B (str): The second sequence. Returns: int: The length of the Longest Common Subsequence. n = len(A) m = len(B) # Create a 2D array to store lengths of longest common subsequence. L = [[0] * (m + 1) for i in range(n + 1)] # Building the matrix in bottom-up way for i in range(n + 1): for j in range(m + 1): if i == 0 or j == 0: L[i][j] = 0 elif A[i - 1] == B[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) # L[n][m] contains the length of LCS for A[0..n-1], B[0..m-1] return L[n][m]"},{"question":"# Task You are given an implementation of a HashMap (a type of associative array or dictionary). You need to implement a method that can find the longest sequence of consecutive keys in this HashMap. The sequence should be based on the integer keys and consider only consecutive integer values. # Function Signature ```python class HashMap: # ... (existing methods) def longest_consecutive_sequence(self) -> int: Find the length of the longest sequence of consecutive integer keys in the HashMap. Returns: int: Length of the longest sequence of consecutive integer keys. Example Usage: >>> hashmap = HashMap() >>> hashmap.put(1, \'one\') >>> hashmap.put(3, \'three\') >>> hashmap.put(2, \'two\') >>> hashmap.put(4, \'four\') >>> hashmap.longest_consecutive_sequence() 4 >>> hashmap.put(100, \'hundred\') >>> hashmap.put(101, \'hundred and one\') >>> hashmap.put(102, \'hundred and two\') >>> hashmap.longest_consecutive_sequence() 4 pass ``` # Specifications 1. Implement the `longest_consecutive_sequence` method that finds the length of the longest sequence of consecutive keys in the HashMap. 2. Ensure that the method efficiently handles the given constraints and size of HashMap. # Input - The HashMap will already have integer keys and associated values. # Output - The method should return an integer representing the length of the longest sequence of consecutive keys. # Example 1. Create a new HashMap and add key-value pairs: ```python hashmap = HashMap() hashmap.put(1, \'one\') hashmap.put(3, \'three\') hashmap.put(2, \'two\') hashmap.put(4, \'four\') ``` 2. Find the longest sequence of consecutive keys: ```python longest_sequence = hashmap.longest_consecutive_sequence() assert longest_sequence == 4 ``` 3. Add more key-value pairs and check again: ```python hashmap.put(100, \'hundred\') hashmap.put(101, \'hundred and one\') hashmap.put(102, \'hundred and two\') longest_sequence = hashmap.longest_consecutive_sequence() assert longest_sequence == 4 ``` # Constraints - The keys of the HashMap are all integers. - The size of the HashMap can be reasonably large but it should fit within memory limits. - Performance considerations should be made to handle typical operations in O(N) time complexity. This maintains a similar style, complexity, and scope as the provided example while focusing on a different aspect of data structures and algorithms (HashMap operations and sequence finding).","solution":"class HashMap: def __init__(self): self.map = {} def put(self, key, value): self.map[key] = value def longest_consecutive_sequence(self): if not self.map: return 0 keys = set(self.map.keys()) longest_sequence = 0 for key in keys: if key - 1 not in keys: # check if it\'s the start of a sequence current_length = 1 current_key = key while current_key + 1 in keys: current_key += 1 current_length += 1 longest_sequence = max(longest_sequence, current_length) return longest_sequence"},{"question":"# Coding Question: Dynamic Programming - Longest Mountain in Array Context: A \\"mountain\\" sequence in an array is defined as a sequence of elements that starts with a strictly increasing part, reaches a peak, and then follows a strictly decreasing part. The length of a mountain is the number of elements included in the sequence. Given an array, we need to find the length of the longest mountain. Task: Write a function `longest_mountain` that takes a list of integers and returns the length of the longest mountain in the array. If there is no mountain, return 0. Input: * `arr` (List[int]): A list of integers representing the array. Output: * int: The length of the longest mountain. Constraints: * The length of the list will be between 1 and 30000. * Each element in the list is an integer in the range [-100000, 100000]. Function Signature: ```python def longest_mountain(arr: List[int]) -> int: pass ``` Example: Input: ```python arr = [2, 1, 4, 7, 3, 2, 5] ``` Output: ```python 5 ``` Explanation: The longest mountain is [1, 4, 7, 3, 2], which has length 5. Input: ```python arr = [2, 2, 2] ``` Output: ```python 0 ``` Explanation: There is no mountain in this array. # Notes: 1. A mountain must be at least 3 elements long and should include one peak. 2. Consecutive identical elements do not form a mountain as the sequence must strictly increase or decrease. 3. Consider edge cases such as no mountains and single-element mountains. # Solution Approach: 1. Iterate through the array to identify potential peaks (elements that are greater than their neighbors). 2. Expand left and right pointers from the peak to find the entire mountain sequence. 3. Track the maximum length among all identified mountains. Ensure your method has an optimal solution possibly in `O(n)` time complexity.","solution":"def longest_mountain(arr): if not arr or len(arr) < 3: return 0 max_length = 0 n = len(arr) for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: # We\'ve found a peak left = i - 1 right = i + 1 # Move left pointer back while elements are in increasing order while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Move right pointer forward while elements are in decreasing order while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the current mountain length current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are developing a navigation system that needs to calculate the shortest path between two points on a grid. The grid contains obstacles, and you can only move vertically or horizontally (no diagonal moves). Given a start position and a target position, your task is to determine the minimum number of moves required to reach the target, avoiding obstacles. # Problem Statement Write a function `shortest_path` that takes a grid, a starting position, and a target position and returns the minimum number of moves needed to reach the target. If the target is unreachable, return `-1`. # Function Signature ```python def shortest_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int: ``` # Input - `grid`: A list of lists of integers where `0` represents an open cell and `1` represents an obstacle. - `start`: A tuple `(x, y)` representing the starting position. - `end`: A tuple `(x, y)` representing the target position. # Output - An integer representing the minimum number of moves required to reach the target, or `-1` if the target is unreachable. # Constraints - `1 ≤ len(grid) ≤ 100` - `1 ≤ len(grid[0]) ≤ 100` - `0 ≤ start[0], start[1], end[0], end[1] < len(grid)` - The grid will contain at least one open cell. - start and end positions are always open cells. # Examples 1. ``` grid = [ [0, 0, 0, 1, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) shortest_path(grid, start, end) ``` should return `8`. 2. ``` grid = [ [0, 1], [1, 0] ] start = (0, 0) end = (1, 1) shortest_path(grid, start, end) ``` should return `-1`. 3. ``` grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] start = (0, 0) end = (2, 2) shortest_path(grid, start, end) ``` should return `4`. # Notes - Use Breadth-First Search (BFS) to explore the shortest path in the grid since it finds the shortest path in an unweighted grid effectively. - Mark visited cells to avoid revisiting and to prevent infinite loops. - If the target cell is reached, return the number of moves taken to get there. If not, after exploring all possible moves, return `-1`. # Hints 1. Utilize a queue to implement the BFS algorithm. 2. Track the number of moves with each step in the BFS. 3. Check boundary conditions to ensure moves are valid and within grid limits.","solution":"from collections import deque def shortest_path(grid, start, end): Returns the minimum number of moves required to reach the target or -1 if unreachable. rows = len(grid) cols = len(grid[0]) if start == end: return 0 def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == end: return dist + 1 if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Context You are constructing a function that generates all possible subsets of a given set of distinct integers. This problem involves using the concept of backtracking to systematically explore all possible combinations and generate the power set. # Task Implement the `power_set` function so it returns a list of all possible subsets of the input list of integers. Each subset should be represented as a list, sorted in ascending order. The resulting list of subsets should also be sorted lexicographically. # Function Signature ```python def power_set(data: list) -> list: pass ``` # Input * `data` (list): A list of distinct integers where the size can range from 0 to 20 elements. # Output * A list of lists, where each inner list is a subset of the input list, sorted in ascending order. The outer list of subsets should be sorted lexicographically. # Constraints * The input list contains distinct integers only. * Ensure that your function handles edge cases like empty input lists gracefully. # Examples ```python print(power_set([1, 2, 3])) # Output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] print(power_set([])) # Output: [[]] print(power_set([5])) # Output: [[], [5]] print(power_set([3, 1, 2])) # Output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] ``` # Performance Requirements The function should operate efficiently to generate all subsets for input lists up to 20 elements. # Additional Instructions * Ensure your implementation is purely in Python and does not depend on any external libraries. * Include inline comments to document the main steps of your algorithm. * Consider using a recursive approach with backtracking to generate the subsets.","solution":"def power_set(data): Generate all subsets of a given list of distinct integers, sorted lexicographically. def backtrack(start, path): # Append the current subset result.append(path) # Try to generate subsets that include each of the remaining elements for i in range(start, len(data)): backtrack(i + 1, path + [data[i]]) result = [] data.sort() # Ensure the input list is sorted backtrack(0, []) return result"},{"question":"# Problem Statement You are tasked with implementing a `PriorityQueue` class using a binary heap in Python. The priority queue should support the following operations efficiently: * `insert(item, priority)`: Inserts an item with a given priority into the queue. * `extract_min()`: Removes and returns the item with the lowest priority. Raises an `IndexError` if the queue is empty. * `is_empty()`: Returns `True` if the queue is empty, `False` otherwise. * `peek_min()`: Returns the item with the lowest priority without removing it. Raises an `IndexError` if the queue is empty. * `decrease_priority(item, new_priority)`: Decreases the priority of a given item. # Input/Output Format * The `PriorityQueue` class does not take any input during instantiation. * Operations include `insert(item: T, priority: int) -> None`, `extract_min() -> T`, `is_empty() -> bool`, `peek_min() -> T`, and `decrease_priority(item: T, new_priority: int) -> None`. # Constraints * The `decrease_priority` operation will only be called with an `item` that already exists in the priority queue. * You must correctly adjust the positions of the elements in the binary heap to maintain the heap property after every insertion, extraction, or priority decrease. * Handling the scenario where `extract_min` or `peek_min` operations are called on an empty queue by raising an appropriate exception is required. # Example Usage ```python pq = PriorityQueue() pq.insert(\'task1\', 3) pq.insert(\'task2\', 1) pq.insert(\'task3\', 2) print(pq.peek_min()) # Output: \'task2\' print(pq.extract_min()) # Output: \'task2\' pq.decrease_priority(\'task1\', 0) print(pq.peek_min()) # Output: \'task1\' print(pq.extract_min()) # Output: \'task1\' print(pq.is_empty()) # Output: False pq.extract_min() print(pq.is_empty()) # Output: True ``` Implement the class `PriorityQueue` in Python by completing the following definitions.","solution":"class PriorityQueue: def __init__(self): self.heap = [] self.positions = {} def is_empty(self): return not self.heap def insert(self, item, priority): self.heap.append((priority, item)) self.positions[item] = len(self.heap) - 1 self._bubble_up(len(self.heap) - 1) def extract_min(self): if self.is_empty(): raise IndexError(\\"extract_min from empty priority queue\\") smallest = self.heap[0] if len(self.heap) > 1: self.heap[0] = self.heap.pop() self.positions[self.heap[0][1]] = 0 self._bubble_down(0) else: self.heap.pop() del self.positions[smallest[1]] return smallest[1] def peek_min(self): if self.is_empty(): raise IndexError(\\"peek_min from empty priority queue\\") return self.heap[0][1] def decrease_priority(self, item, new_priority): index = self.positions[item] old_priority, _ = self.heap[index] if new_priority < old_priority: self.heap[index] = (new_priority, item) self._bubble_up(index) def _bubble_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index][0] < self.heap[parent][0]: self._swap(index, parent) self._bubble_up(parent) def _bubble_down(self, index): left = 2 * index + 1 right = 2 * index + 2 smallest = index if left < len(self.heap) and self.heap[left][0] < self.heap[smallest][0]: smallest = left if right < len(self.heap) and self.heap[right][0] < self.heap[smallest][0]: smallest = right if smallest != index: self._swap(index, smallest) self._bubble_down(smallest) def _swap(self, i, j): self.positions[self.heap[i][1]], self.positions[self.heap[j][1]] = self.positions[self.heap[j][1]], self.positions[self.heap[i][1]] self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"# Question: **Context**: Arrays can be rotated cyclically, and one common operation is to determine the minimum element in a rotated sorted array. Your task is to find the minimum element in a rotated sorted array using an efficient algorithm. **Objective**: Implement a function `find_min_in_rotated_array` that takes in a list of integers representing a rotated sorted array and returns the minimum element in the array. **Function Signature**: ```python def find_min_in_rotated_array(nums: List[int]) -> int: pass ``` # Input: * **nums**: List of integers representing the rotated sorted array. # Output: * Returns an integer representing the minimum element in the array. # Constraints: * The input list will have at least 1 and at most 10^5 elements. * All elements in the list are unique. * The array was originally sorted in ascending order before being rotated. # Example: ```python nums = [4, 5, 6, 7, 0, 1, 2] result = find_min_in_rotated_array(nums) print(result) # Expected: 0 nums = [1] result = find_min_in_rotated_array(nums) print(result) # Expected: 1 nums = [2, 3, 4, 5, 1] result = find_min_in_rotated_array(nums) print(result) # Expected: 1 ``` # Notes: * Aim for an algorithm with O(log n) time complexity, leveraging the properties of the rotated sorted array. * Ensure your implementation handles edge cases, such as arrays that are not rotated and arrays containing a single element.","solution":"from typing import List def find_min_in_rotated_array(nums: List[int]) -> int: Finds the minimum element in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: # The minimum value is in the right half left = mid + 1 else: # The minimum value is in the left half including mid right = mid return nums[left]"},{"question":"# Problem Statement You are developing a text analysis tool that can process and summarize natural language text. This program aims to help users quickly understand the key points of lengthy documents. # Requirements Implement a Python function `summarize_text` that takes a single parameter, `text: str`, representing the input text document. The function should: 1. Split the text into sentences. 2. Calculate the frequency of each word. 3. Determine the significance of each sentence based on word frequencies. 4. Return the top N sentences that best summarize the input text, where N is a given integer. # Constraints * Use a simple word frequency approach to calculate sentence significance. * Ignore case differences (e.g., \\"Word\\" and \\"word\\" should be treated as the same). * Exclude common stop words (e.g., \\"and\\", \\"the\\", \\"is\\"). * Assume the input text will contain at least one sentence. * Assume sentences are separated by one of the following punctuation marks: `.`, `!`, `?`. # Input and Output Formats * **Input**: * `text: str`: A string representing the input text document. * `N: int`: An integer representing the number of sentences to return in the summary. * **Output**: * `List[str]`: A list of top N sentences that summarize the input text. # Performance Requirements * Ensure the function can handle texts with up to 10,000 words efficiently. * Minimize processing time and memory usage by using appropriate data structures and algorithms. # Example ```python def summarize_text(text: str, N: int) -> list[str]: # Your implementation here # Example usage summary = summarize_text(\\"Your input document text goes here.\\", 3) print(summary) ``` # Notes * You may use any built-in Python libraries and modules (e.g., `re`, `nltk`). * Implement reasonable error handling practices to deal with edge cases and invalid input. * You can define additional helper functions as needed to ensure code clarity and modularity.","solution":"import re from collections import Counter from typing import List def summarize_text(text: str, N: int) -> List[str]: # Tokenize the text into sentences based on punctuation sentences = re.split(r\'(?<=[.!?]) +\', text) # Define a set of common stop words stop_words = set([ \\"i\\", \\"me\\", \\"my\\", \\"myself\\", \\"we\\", \\"our\\", \\"ours\\", \\"ourselves\\", \\"you\\", \\"your\\", \\"yours\\", \\"yourself\\", \\"yourselves\\", \\"he\\", \\"him\\", \\"his\\", \\"himself\\", \\"she\\", \\"her\\", \\"hers\\", \\"herself\\", \\"it\\", \\"its\\", \\"itself\\", \\"they\\", \\"them\\", \\"their\\", \\"theirs\\", \\"themselves\\", \\"what\\", \\"which\\", \\"who\\", \\"whom\\", \\"this\\", \\"that\\", \\"these\\", \\"those\\", \\"am\\", \\"is\\", \\"are\\", \\"was\\", \\"were\\", \\"be\\", \\"been\\", \\"being\\", \\"have\\", \\"has\\", \\"had\\", \\"having\\", \\"do\\", \\"does\\", \\"did\\", \\"doing\\", \\"a\\", \\"an\\", \\"the\\", \\"and\\", \\"but\\", \\"if\\", \\"or\\", \\"because\\", \\"as\\", \\"until\\", \\"while\\", \\"of\\", \\"at\\", \\"by\\", \\"for\\", \\"with\\", \\"about\\", \\"against\\", \\"between\\", \\"into\\", \\"through\\", \\"during\\", \\"before\\", \\"after\\", \\"above\\", \\"below\\", \\"to\\", \\"from\\", \\"up\\", \\"down\\", \\"in\\", \\"out\\", \\"on\\", \\"off\\", \\"over\\", \\"under\\", \\"again\\", \\"further\\", \\"then\\", \\"once\\", \\"here\\", \\"there\\", \\"when\\", \\"where\\", \\"why\\", \\"how\\", \\"all\\", \\"any\\", \\"both\\", \\"each\\", \\"few\\", \\"more\\", \\"most\\", \\"other\\", \\"some\\", \\"such\\", \\"no\\", \\"nor\\", \\"not\\", \\"only\\", \\"own\\", \\"same\\", \\"so\\", \\"than\\", \\"too\\", \\"very\\", \\"s\\", \\"t\\", \\"can\\", \\"will\\", \\"just\\", \\"don\\", \\"should\\", \\"now\\" ]) # Normalize the text to lowercase and remove non-alphabetic characters words = re.findall(r\'bw+b\', text.lower()) # Filter stop words filtered_words = [word for word in words if word not in stop_words] # Calculate word frequencies word_frequencies = Counter(filtered_words) # Calculate the significance of each sentence sentence_scores = [] for sentence in sentences: sentence_word_list = re.findall(r\'bw+b\', sentence.lower()) sentence_score = sum(word_frequencies[word] for word in sentence_word_list if word in word_frequencies) sentence_scores.append((sentence_score, sentence)) # Sort sentences by their scores in descending order sorted_sentences = sorted(sentence_scores, key=lambda x: x[0], reverse=True) # Return the top N sentences top_sentences = [sentence for score, sentence in sorted_sentences[:N]] return top_sentences"},{"question":"# Tree Traversal Verification Challenge Background: Tree data structures are a fundamental concept in computer science. They have numerous applications, including representing hierarchical data, managing sorted lists of data, and facilitating search operations. One particular aspect of trees is their traversal techniques, which include in-order, pre-order, and post-order traversals. Objective: Write a function `verify_traversals(in_order: list[int], pre_order: list[int], post_order: list[int]) -> bool` to verify that the given in-order, pre-order, and post-order traversal lists correspond to the same binary tree. Requirements: * Implement the function using the following signature: ```python def verify_traversals(in_order: list[int], pre_order: list[int], post_order: list[int]) -> bool: ``` * The function should return `True` if the three traversal lists are valid outputs of traversing the same binary tree, and `False` otherwise. Input and Output: * **Input**: Three lists of integers `in_order`, `pre_order`, and `post_order`, representing in-order, pre-order, and post-order traversals of a binary tree. * **Output**: A boolean value `True` or `False` indicating if the lists can form the same binary tree. Constraints: * The number of elements in each traversal list from 1 to 10^4. * All elements in the lists are unique integers. Example: ```python print(verify_traversals([4, 2, 5, 1, 6, 3, 7], [1, 2, 4, 5, 3, 6, 7], [4, 5, 2, 6, 7, 3, 1])) # Expected output: True print(verify_traversals([4, 2, 5, 1, 6, 3, 7], [1, 2, 4, 5, 6, 3, 7], [4, 5, 2, 6, 7, 3, 1])) # Expected output: False print(verify_traversals([2, 1], [1, 2], [2, 1])) # Expected output: True ``` Hint: To approach this problem: * Understand how to build a binary tree from given traversal orders. * Use properties of tree traversal to reconstruct and verify the binary tree. * Keep in mind that due to the unique nature of elements within the traversal lists, different traversal sequences can be reconstructed uniquely into a binary tree. Note: The main task is to check the consistency among the three traversal lists by theoretically building the binary tree without implementing the entire tree construction explicitly.","solution":"def verify_traversals(in_order, pre_order, post_order): if not in_order or not pre_order or not post_order: return in_order == pre_order == post_order == [] if len(in_order) != len(pre_order) or len(in_order) != len(post_order): return False def build_tree_from_in_pre(pre_order, in_order_map, pre_start, pre_end, in_start, in_end): if pre_start > pre_end or in_start > in_end: return None, pre_start - 1 root_value = pre_order[pre_start] root_index_in_order = in_order_map[root_value] left_tree_size = root_index_in_order - in_start left_subtree, left_end_index = build_tree_from_in_pre(pre_order, in_order_map, pre_start + 1, pre_start + left_tree_size, in_start, root_index_in_order - 1) right_subtree, right_end_index = build_tree_from_in_pre(pre_order, in_order_map, pre_start + left_tree_size + 1, pre_end, root_index_in_order + 1, in_end) return root_value, right_end_index in_order_map = {value: idx for idx, value in enumerate(in_order)} root_val, pre_end_index = build_tree_from_in_pre(pre_order, in_order_map, 0, len(pre_order) - 1, 0, len(in_order) - 1) def get_post_order_from_in_pre(pre_order, in_order_map, pre_start, pre_end, in_start, in_end): if pre_start > pre_end or in_start > in_end: return [] root_value = pre_order[pre_start] root_index_in_order = in_order_map[root_value] left_tree_size = root_index_in_order - in_start left_subtree_post_order = get_post_order_from_in_pre(pre_order, in_order_map, pre_start + 1, pre_start + left_tree_size, in_start, root_index_in_order - 1) right_subtree_post_order = get_post_order_from_in_pre(pre_order, in_order_map, pre_start + left_tree_size + 1, pre_end, root_index_in_order + 1, in_end) return left_subtree_post_order + right_subtree_post_order + [root_value] derived_post_order = get_post_order_from_in_pre(pre_order, in_order_map, 0, len(pre_order) - 1, 0, len(in_order) - 1) return derived_post_order == post_order"},{"question":"# Coding Assessment Question Objective Write a function that takes a single integer as input and returns a list of all prime numbers up to and including that integer. Background A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Common algorithms to find prime numbers include the Sieve of Eratosthenes and trial division. Task Implement the function `find_primes(n: int) -> List[int]` that: 1. Determines all prime numbers up to and including `n`. 2. Returns a list of these prime numbers in ascending order. Specifications * **Input**: A single integer `n`. * **Output**: A list of integers representing the prime numbers up to and including `n`. Example ```python >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] ``` Constraints 1. The input integer `n` should be a non-negative integer (i.e., `n >= 0`). 2. The function should handle input values up to `10^5` efficiently. Additional Notes * You can use the Sieve of Eratosthenes algorithm or any other efficient algorithm to solve this problem. * Ensure that your implementation is optimized for performance, particularly for large input values.","solution":"from typing import List def find_primes(n: int) -> List[int]: Returns a list of all prime numbers up to and including n. Uses the Sieve of Eratosthenes algorithm for efficient prime number generation. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for i in range(start * start, n + 1, start): sieve[i] = False return [num for num in range(2, n + 1) if sieve[num]]"},{"question":"# Problem Statement You are to implement a function that normalizes a list of numerical values. Normalization is a process that adjusts the values in a dataset to a common scale, typically within the range [0, 1], without distorting the differences in the ranges of values. # The context A data analysis company wants to incorporate a function that normalizes datasets as part of their preprocessing pipeline. This function is vital for ensuring that different features contribute equally during data analysis and machine learning model training. # Function Specification Implement the `normalize_list` function that scales the elements of a list so that they lie within the range [0, 1]. Function Signature ```python def normalize_list(values: list) -> list: pass ``` Inputs * `values`: A list of integers or floats. Outputs * A list of floats where each value from the input list is scaled to the range [0, 1]. Constraints * Ensure `values` is a non-empty list of integers or floats. * Do not modify the input list. * Handle the case where all values in the list are the same. # Example ```python result = normalize_list([1, 2, 3, 4, 5]) print(result) # Expected output: [0.0, 0.25, 0.5, 0.75, 1.0] ``` # Hints * The formula for normalization is: ( text{normalized value} = frac{x - min(x)}{max(x) - min(x)} ) * Ensure to handle edge cases where the list might contain all identical values by returning a list of zeros.","solution":"def normalize_list(values): Normalizes a list of integers or floats to the range [0, 1]. Args: values (list): A list of integers or floats. Returns: list: A list of floats where each value is scaled to the range [0, 1]. min_val = min(values) max_val = max(values) if min_val == max_val: # If all values are the same, return a list of zeros return [0.0] * len(values) return [(x - min_val) / (max_val - min_val) for x in values]"},{"question":"# Problem: Unique Elements in a Sorted List You are given a sorted list of integers, where some elements may appear more than once. Implement a function `find_unique_elements` that receives a sorted list of integers and returns a new list containing all unique integers from the provided list, preserving the original order. Input: * A sorted list of integers `numbers` (1 <= len(numbers) <= 10^5, -10^9 <= numbers[i] <= 10^9) Output: * A list of unique integers. Requirements: * Your solution should efficiently process the input list. * Aim to minimize auxiliary space utilization while maintaining out-of-place insertion in the resulting list. Example: ```python >>> find_unique_elements([1, 1, 2, 3, 3, 4, 5, 5, 6]) [1, 2, 3, 4, 5, 6] >>> find_unique_elements([1, 2, 2, 3, 4, 4, 4, 5, 5]) [1, 2, 3, 4, 5] >>> find_unique_elements([-3, -2, -2, -1, 0, 1, 1, 2]) [-3, -2, -1, 0, 1, 2] ``` Constraints: * The input list is guaranteed to be sorted in non-decreasing order. * Your implementation should be able to handle both positive and negative integers.","solution":"def find_unique_elements(numbers): Given a sorted list of integers, return a new list containing all unique integers from the provided list, preserving the original order. if not numbers: return [] unique_elements = [numbers[0]] for i in range(1, len(numbers)): if numbers[i] != numbers[i - 1]: unique_elements.append(numbers[i]) return unique_elements"},{"question":"# Question: Find the First and Last Position of an Element in a Sorted Array Context: You are given a sorted array of integers and a target value. Your task is to find the starting and ending position of the target value in the array. Implement an efficient algorithm to find these positions using binary search rather than a linear scan. Requirements: 1. Implement a function `find_first_and_last_position(nums: list[int], target: int) -> list[int]` that returns a list of two integers: the starting and ending position of the target in the array. 2. If the target is not found in the array, return `[-1, -1]`. 3. The function should handle the case where there are duplicates of the target value. Input: - `nums`: A sorted list of integers. Example: `[5, 7, 7, 8, 8, 10]` - `target`: An integer representing the element whose positions are to be found. Example: `8` Output: - A list of two integers representing the starting and ending positions of the target. If the target is not found, return `[-1, -1]`. Constraints: - The length of the array will not exceed `1000`. - The elements of the array can be both positive and negative. - The target value will be provided always as an integer. Performance Requirements: - Time complexity should be O(log n). - Space complexity should be O(1). Example: ```python nums = [5, 7, 7, 8, 8, 10] target = 8 find_first_and_last_position(nums, target) # Output should be [3, 4] nums = [5, 7, 7, 8, 8, 10] target = 6 find_first_and_last_position(nums, target) # Output should be [-1, -1] ``` Scenario: Consider you are searching for the range of specific transactions (amounts) that happened on certain days within a sorted log. This function allows you to efficiently find the first and last occurrence of a specific transaction amount quickly without scanning the entire list. Write your implementation in Python and ensure it handles edge cases as outlined.","solution":"def find_first_and_last_position(nums, target): Finds the first and last position of the target in a sorted array. :param nums: List of sorted integers. :param target: Target integer. :return: List of starting and ending position of target in nums. def binary_search_left(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid return left def binary_search_right(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid return left left_index = binary_search_left(nums, target) right_index = binary_search_right(nums, target) - 1 if left_index <= right_index and 0 <= left_index < len(nums) and nums[left_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"Question: Implement a Circular Array Rotation Function Your task is to implement a function that performs a circular rotation on an array of integers. When the array is rotated to the right, the last element moves to the first position, shifting all other elements to the right. The function should apply the rotation a given number of times. # Function Signature ```python def circular_array_rotation(arr: List[int], k: int) -> List[int]: Given a list of integers, returns the list after performing the circular rotation k times. Args: arr: List[int] - A list of integers. k: int - The number of times to rotate the array. Returns: List[int] - The list after performing the circular rotation. ``` # Input * A list arr containing integers. * An integer k representing the number of times the array should be rotated to the right. # Output * A list containing the integers after performing the circular rotation k times. # Constraints * 0 <= len(arr) <= 10^6 * 0 <= k <= 10^6 * -10^9 <= arr[i] <= 10^9 # Example ```python >>> circular_array_rotation([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_array_rotation([1, 2, 3], 4) [3, 1, 2] >>> circular_array_rotation([], 3) [] ``` # Performance Requirements * The solution should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input list. # Notes * Ensure to handle edge cases, such as empty lists. * In case k is greater than the length of arr, the rotation count should be reduced by using k % len(arr). * The rotation should maintain the order of elements and avoid unnecessary computations. # Additional Context Imagine you\'re working on a data manipulation library where one common operation is to rotate elements in a dataset efficiently. This function would be part of that library, ensuring that rotations of large datasets can be performed quickly and accurately. Implement this function to optimize for large inputs and varying rotation counts.","solution":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Given a list of integers, returns the list after performing the circular rotation k times. Args: arr: List[int] - A list of integers. k: int - The number of times to rotate the array. Returns: List[int] - The list after performing the circular rotation. if not arr or k == 0: return arr n = len(arr) k = k % n # In case k is greater than the length of arr return arr[-k:] + arr[:-k]"},{"question":"# Coding Assessment Question Scenario You are tasked with generating a multiplication table up to a given number `n`. However, instead of printing the traditional table format, you need to produce a list of lists, where each inner list represents a row of the table. For example, a 3x3 multiplication table would look like: [[1, 2, 3], [2, 4, 6], [3, 6, 9]] The task is to implement a function that returns this structure for a given `n`. Problem Statement Implement a function, `generate_multiplication_table(n: int) -> List[List[int]]`, which returns a multiplication table as a list of lists for the given input `n`. Constraints * `1 <= n <= 20` Input * An integer `n` representing the size of the multiplication table. Output * A list of lists representing the `n x n` multiplication table. Example ```python def generate_multiplication_table(n: int) -> List[List[int]]: # Your implementation here # Example Usages: print(generate_multiplication_table(3)) # Output: # [[1, 2, 3], # [2, 4, 6], # [3, 6, 9]] print(generate_multiplication_table(5)) # Output: # [[1, 2, 3, 4, 5], # [2, 4, 6, 8, 10], # [3, 6, 9, 12, 15], # [4, 8, 12, 16, 20], # [5, 10, 15, 20, 25]] ``` Requirements Ensure that the implementation is both correct and efficient given the constraints.","solution":"from typing import List def generate_multiplication_table(n: int) -> List[List[int]]: Generates an n x n multiplication table in the form of a list of lists. :param n: The size of the multiplication table :return: A list of lists representing the multiplication table return [[(i+1) * (j+1) for j in range(n)] for i in range(n)]"},{"question":"# Coding Assessment Question **Scenario**: You are contributing to a financial management application that requires processing stock data from various stock exchanges. The app needs to fetch real-time data to keep track of stock prices, opening and closing prices, and trading volumes. **Task**: Implement a function `get_stock_prices` that retrieves stock data for a list of stock symbols from a specified stock exchange API and returns a dictionary with the symbol as the key and a nested dictionary containing the stock\'s current price, opening price, closing price, and volume. **Function Signature**: ```python def get_stock_prices(symbols: list, api_key: str) -> dict: Fetches stock data for the given list of symbols from the stock exchange API and returns a dictionary with the stock information. Args: symbols (list): List of stock symbols to fetch data for. api_key (str): API key for authentication with the stock exchange API. Returns: dict: Dictionary where keys are stock symbols and values are dictionaries with stock data (current price, opening price, closing price, and volume). ``` **Example**: ```python symbols = [\'AAPL\', \'GOOGL\', \'MSFT\'] api_key = \'your_api_key_here\' stock_data = get_stock_prices(symbols, api_key) for symbol, data in stock_data.items(): print(f\\"Stock: {symbol}\\") print(f\\"Current Price: {data[\'current_price\']}\\") print(f\\"Opening Price: {data[\'opening_price\']}\\") print(f\\"Closing Price: {data[\'closing_price\']}\\") print(f\\"Volume: {data[\'volume\']}n\\") ``` **Constraints**: 1. Your function must: - Use the provided API endpoint `https://example-stock-exchange-api.com`. - Handle any potential errors due to network issues, invalid symbols, or incorrect API key. - Adhere to a timeout of 10 seconds for HTTP requests. - Use environment variables or secure storage for handling sensitive information like API keys. 2. Implement the function to efficiently handle multiple stock symbols without overwhelming the API. **Performance Boundaries**: - Ensure that your function can process up to 50 stock symbols in a single API call without significant performance degradation. **Additional Notes**: - You can use libraries like `requests` for your HTTP requests. - Properly structure and comment your code for readability and maintainability. - Consider retry logic for transient errors.","solution":"import requests from requests.exceptions import RequestException def get_stock_prices(symbols, api_key): Fetches stock data for the given list of symbols from the stock exchange API and returns a dictionary with the stock information. Args: symbols (list): List of stock symbols to fetch data for. api_key (str): API key for authentication with the stock exchange API. Returns: dict: Dictionary where keys are stock symbols and values are dictionaries with stock data (current price, opening price, closing price, and volume). base_url = \'https://example-stock-exchange-api.com\' timeout = 10 headers = {\'Authorization\': f\'Bearer {api_key}\'} stock_data = {} try: response = requests.post(f\'{base_url}/stocks\', json={\\"symbols\\": symbols}, headers=headers, timeout=timeout) response.raise_for_status() data = response.json() for symbol_info in data: symbol = symbol_info[\'symbol\'] stock_data[symbol] = { \'current_price\': symbol_info[\'current_price\'], \'opening_price\': symbol_info[\'opening_price\'], \'closing_price\': symbol_info[\'closing_price\'], \'volume\': symbol_info[\'volume\'] } except RequestException as e: print(f\\"An error occurred: {e}\\") return stock_data"},{"question":"# Progressive Tax Calculation You are required to implement a function `calculate_tax()` that computes the tax owed based on a progressive tax system. The tax brackets and corresponding rates are given as inputs. # Problem Statement Given a list of tuples representing tax brackets and associated rates, and a specific income, implement the function `calculate_tax(income, tax_brackets)` that returns the total tax owed. Each tuple in `tax_brackets` represents the (income limit, rate) where the rate is applied to the portion of the income within that bracket. # Implementation Details * **Function Signature**: ```python def calculate_tax(income: float, tax_brackets: list[tuple[float, float]]) -> float: ``` * **Input**: - `income` (float): The total income for which tax needs to be calculated. - `tax_brackets` (list of tuples): Each tuple represents (income limit, rate) where: - `income limit` (float) is the upper income limit for that tax bracket. - `rate` (float) is the tax rate to be applied for that bracket. The tax brackets are given in ascending order and apply progressively (i.e., if the tuple is (5000, 0.1), the next tuple is (20000, 0.2), it means that the first 5000 of income is taxed at 10%, and income exceeding 5000 but below 20000 is taxed at 20%, etc.) * **Output**: - The total tax owed (float). * **Constraints**: - The input `income` will always be a non-negative number. - The list `tax_brackets` will contain at least one bracket. - Ensure to handle edge cases where income falls within different brackets appropriately. # Example 1. **Input**: ```python income = 25000 tax_brackets = [(10000, 0.1), (20000, 0.2), (30000, 0.3)] ``` **Output**: ```python 4500.0 ``` **Explanation**: - The first 10,000 is taxed at 10% = 1000. - The next 10,001 to 20,000 (10,000) is taxed at 20% = 2000. - The remaining income, 20,001 to 25,000 (5000) is taxed at 30% = 1500. - Total tax = 1000 + 2000 + 1500 = 4500. 2. **Input**: ```python income = 6000 tax_brackets = [(5000, 0.05), (10000, 0.15)] ``` **Output**: ```python 550.0 ``` **Explanation**: - The first 5000 is taxed at 5% = 250. - The next 1000 is taxed at 15% = 150. - Total tax = 250 + 150 = 400. # Additional Notes - Ensure your code follows the specified function signature. - The tax is computed progressively, meaning each bracket\'s rate applies only to the income within that limit. - This problem tests your ability to work with lists, tuples, and progressive calculations.","solution":"def calculate_tax(income: float, tax_brackets: list[tuple[float, float]]) -> float: total_tax = 0.0 previous_limit = 0.0 for i, (limit, rate) in enumerate(tax_brackets): if income > limit: total_tax += (limit - previous_limit) * rate previous_limit = limit else: total_tax += (income - previous_limit) * rate return total_tax return total_tax"},{"question":"# Problem Statement Develop a program that identifies the first missing positive integer in a given list. The goal is to write an efficient solution that runs in linear time and constant space, i.e., `O(n)` time complexity and `O(1)` extra space. You must implement a function that rearranges the list in place and returns the smallest missing positive integer. # Function Signature ```python def firstMissingPositive(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of integers where `1 <= len(nums) <= 10^5` and the integers can be both positive and negative. # Output * The function should return an integer, which is the smallest missing positive integer. # Example ```python assert firstMissingPositive([1, 2, 0]) == 3 assert firstMissingPositive([3, 4, -1, 1]) == 2 assert firstMissingPositive([7, 8, 9, 11, 12]) == 1 ``` # Constraints * Your solution should rearrange the input list in place. * You are not allowed to use additional data structures like sets or dictionaries. * The time complexity of your solution should be O(n). # Notes * Consider edge cases where the input list could be empty or contain only negative numbers. * Think about utilizing the indices of the list to keep track of the elements. --- This question is designed to test the candidate\'s understanding of in-place array manipulation and their ability to devise efficient algorithms that make use of clever index-based tricks.","solution":"from typing import List def firstMissingPositive(nums: List[int]) -> int: n = len(nums) # Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap numbers to their right places nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first number missing for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Problem Statement You are given a string `s` containing only the characters `\'(\'` and `\')\'`. The goal is to determine the minimum number of parentheses that need to be added to make the string valid. A string of parentheses is considered valid if every opening parenthesis has a corresponding closing parenthesis and the pairs of parentheses are properly nested. Write a function `min_add_to_make_valid(s: str) -> int` which: - **Input**: * `s`: a string consisting of characters `\'(\'` and `\')\'` only. For example, `\\"())\\"`. - **Output**: * Return the minimum number of parentheses needed to make the input string valid. **Constraints**: - `1 <= len(s) <= 1000` **Example**: ```python s = \\"())\\" assert min_add_to_make_valid(s) == 1 s = \\"(((\\" assert min_add_to_make_valid(s) == 3 s = \\"()\\" assert min_add_to_make_valid(s) == 0 s = \\"()))((\\" assert min_add_to_make_valid(s) == 4 ``` **Scenarios**: - For a string where parentheses are already balanced and valid, no additions are needed. - For a string with several unmatched opening or closing parentheses, counting and balancing is required. - Ensure efficient handling of long strings with a mixture of valid and invalid parentheses sequences. Use a stack or a counter-based approach to achieve an optimal solution. This problem evaluates understanding of stack data structures and balancing algorithms, common in parsing or expression validation tasks.","solution":"def min_add_to_make_valid(s: str) -> int: open_count = 0 balance = 0 for char in s: if char == \'(\': open_count += 1 else: # char == \')\' if open_count > 0: open_count -= 1 else: balance += 1 return balance + open_count # balance accounts for excess \')\', open_count accounts for excess \'(\'"},{"question":"# Employee Hierarchy Export Given an organizational hierarchy represented as a dictionary where each key is an employee\'s name and the corresponding value is their manager\'s name, write a function to generate a listing of employees at each level of the hierarchy. In this hierarchy: - The employee with no manager (represented by `None`) is the root. - Each employee reports directly to only one manager. Your task is to produce an output where each level of the hierarchy is listed out with the employees at that level. The root (top-level) employee is considered to be at level 0, direct subordinates are at level 1, their subordinates at level 2, and so on. Function Specification **Function**: `employee_levels(hierarchy: dict) -> dict` **Input**: - A dictionary where the keys are strings representing employee names and the values are strings or `None` representing their manager\'s name. **Output**: - A dictionary where the keys are integers representing hierarchy levels starting from 0, and the values are lists of strings representing employee names at that level. Examples ```python >>> hierarchy = { ... \'Alice\': \'Bob\', ... \'Bob\': \'Cathy\', ... \'Cathy\': None, ... \'David\': \'Alice\', ... \'Eve\': \'Alice\', ... \'Frank\': \'David\' ... } >>> employee_levels(hierarchy) {0: [\'Cathy\'], 1: [\'Bob\'], 2: [\'Alice\'], 3: [\'David\', \'Eve\'], 4: [\'Frank\']} ``` Constraints 1. All employees will have a unique name. 2. The hierarchy will be a valid singly connected tree (no cycles or disjoint sections). 3. Ensure that your solution works efficiently with up to 10^4 employees. ---","solution":"def employee_levels(hierarchy): Returns a dictionary where keys are hierarchy levels and values are lists of employees at those levels. from collections import defaultdict, deque # Find the root of the hierarchy (employee with no manager) root = None employees = defaultdict(list) for employee, manager in hierarchy.items(): if manager is None: root = employee else: employees[manager].append(employee) # BFS to traverse the hierarchy and populate levels levels = defaultdict(list) queue = deque([(root, 0)]) while queue: current, level = queue.popleft() levels[level].append(current) for subordinate in employees[current]: queue.append((subordinate, level + 1)) return dict(levels)"},{"question":"# Objective Create a function that converts a given sentence into its Morse code representation while maintaining accurate spacing and character differentiation. # Question Write a Python function `to_morse_code` that converts a given sentence to its Morse code equivalent. The conversion should follow these rules: * Convert each letter to its corresponding Morse code symbol. * Each Morse code symbol should be separated by a single space. * Words in the input sentence should be separated by three spaces in the Morse code output. * Preserve the original capitalization. * Ignore any punctuation in the sentence. **Function Signature:** ```python def to_morse_code(sentence: str) -> str: pass ``` # Input * A single string `sentence`, representing the sentence to convert to Morse code. The sentence may contain letters, numbers, and punctuation. # Output * A string representing the Morse code conversion of the input sentence. # Constraints * The input sentence will be a maximum of 100 characters long. * Only English letters and standard punctuation will be present in the input sentence. # Example ```python assert to_morse_code(\\"Hello World!\\") == \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" assert to_morse_code(\\"SOS!\\") == \\"... --- ...\\" assert to_morse_code(\\"This is a test.\\") == \\"- .... .. ... .. ... .- - . ... -\\" ``` # Notes * The Morse code representation for each character should be as follows: ```plaintext A: .- N: -. 0: ----- B: -... O: --- 1: .---- C: -.-. P: .--. 2: ..--- D: -.. Q: --.- 3: ...-- E: . R: .-. 4: ....- F: ..-. S: ... 5: ..... G: --. T: - 6: -.... H: .... U: ..- 7: --... I: .. V: ...- 8: ---.. J: .--- W: .-- 9: ----. K: -.- X: -..- L: .-.. Y: -.-- M: -- Z: --.. ``` * Ensure that the function handles various edge cases such as empty input strings, strings with only punctuation, and strings with mixed casing. ```python def to_morse_code(sentence: str) -> str: MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } sentence = sentence.upper() words = sentence.split() morse_words = [] for word in words: morse_chars = [MORSE_CODE_DICT[char] for char in word if char in MORSE_CODE_DICT] morse_words.append(\' \'.join(morse_chars)) return \' \'.join(morse_words) ```","solution":"def to_morse_code(sentence: str) -> str: MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } sentence = sentence.upper() words = sentence.split() morse_words = [] for word in words: morse_chars = [MORSE_CODE_DICT[char] for char in word if char in MORSE_CODE_DICT] morse_words.append(\' \'.join(morse_chars)) return \' \'.join(morse_words)"},{"question":"# Coding Question: Implement a Function to Detect a Cycle in a Linked List **Objective**: Implement a function to detect if there is a cycle in a `LinkedList`. # Problem Statement: You are provided with a `LinkedList` class that supports appending new integers. Your task is to implement the method `has_cycle()` that detects if the linked list contains a cycle (a sequence of nodes where the last node points back to one of the previous nodes). # Function Signature: ```python def has_cycle(self) -> bool: # Your code goes here ``` # Constraints: - **Input**: The linked list class as provided, containing any ordering or duplicate integers. - **Output**: The method should return `True` if a cycle is detected, and `False` otherwise. - **Performance Requirement**: Aim for O(n) time complexity and O(1) space complexity. - **Edge Cases**: - An empty linked list should return `False`. - A linked list with no cycle should return `False`. # Example: ```python # Example Usage linked_list = LinkedList() linked_list.extend([1, 2, 3, 4]) # Creating a cycle for testing node = linked_list.head while node.next: node = node.next node.next = linked_list.head.next # 4 -> 2 print(linked_list.has_cycle()) # Expected Output: True # Without a cycle linked_list = LinkedList() linked_list.extend([1, 2, 3, 4]) print(linked_list.has_cycle()) # Expected Output: False ``` # Scenario: You are developing a system that processes and analyzes sequences of data streams. Critical to your system\'s performance is ensuring that data structures like linked lists used for handling sequences do not contain cycles, which could cause infinite loops and crashes. Therefore, detecting cycles efficiently is pivotal to maintaining system integrity. # Additional Notes: You are only allowed to modify the `LinkedList` class to add the `has_cycle` method. Consider using Floyd\'s Tortoise and Hare algorithm for optimal performance, balancing between time and space complexity.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def has_cycle(self) -> bool: Uses Floyd\'s Tortoise and Hare algorithm to check if the linked list contains a cycle. slow_p = self.head fast_p = self.head while slow_p and fast_p and fast_p.next: slow_p = slow_p.next fast_p = fast_p.next.next if slow_p == fast_p: return True return False def extend(self, values): for value in values: self.append(value)"},{"question":"# Question: Implementing a Simple Social Network Graph Analysis Social network analysis often involves understanding the structure and dynamics of relationships between individuals. Given an undirected graph representation of a social network, where nodes represent users and edges represent friendships, implement a function to identify if the graph is connected, and if not, find all disconnected components. Implement the function `analyze_social_network(graph)` that determines connectivity and identifies all the disconnected components. **Input**: - `graph` (dict of lists): An adjacency list representation of a social network, where keys are user IDs and values are lists of user IDs representing friendships. **Output**: - `is_connected` (bool): True if the graph is connected, otherwise False. - `components` (list of sets): List of sets, where each set contains the user IDs of a disconnected component. **Constraints**: - The graph is undirected, meaning if there is an edge from node A to node B, then B is also in the list of A\'s friends. - The graph may have up to 1000 nodes to ensure feasible run-time within typical computational limits. - User IDs are positive integers. **Performance Requirements**: - Ensure the function executes efficiently within seconds for the upper limit of graph size. - Optimize the traversal to ensure minimal computational and storage overhead, respecting O(n + m) time complexity, where n is the number of nodes, and m is the number of edges. **Implementation Details**: - Utilize Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the graph. - Implement utility functions like `explore_component` to identify all nodes in a component starting from a given node. - Use iterative approaches for DFS/BFS to avoid recursion limit issues in Python. Example: ```python def analyze_social_network(graph): def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.add(current) stack.extend(graph[current] - visited) visited = set() all_nodes = set(graph.keys()) components = [] while all_nodes: node = all_nodes.pop() component = set() dfs(node, visited, component) components.append(component) all_nodes -= component is_connected = len(components) == 1 return is_connected, components # Example Usage: if __name__ == \\"__main__\\": social_network = { 1: {2, 3}, 2: {1, 3}, 3: {1, 2}, 4: {5}, 5: {4} } is_connected, components = analyze_social_network(social_network) print(f\\"Is connected: {is_connected}\\") print(f\\"Components: {components}\\") ``` **Hints**: - Begin by creating a `dfs` function that marks nodes as visited and adds them to the current component. - Use a loop to start a new DFS each time an unvisited node is found, ensuring all components are identified. - The function should return both the connectivity status and the list of components in an easily interpretable format.","solution":"def analyze_social_network(graph): def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.add(current) stack.extend(graph[current] - visited) visited = set() all_nodes = set(graph.keys()) components = [] while all_nodes: node = all_nodes.pop() component = set() dfs(node, visited, component) components.append(component) all_nodes -= component is_connected = len(components) == 1 return is_connected, components"},{"question":"# Coding Assessment Question You are provided with a list of strings where each string consists of alphabetical characters. Your task is to implement a function to encode each string in the list using a basic Caesar cipher and then decode it back to validate the encoding. # Task Write a Python function that does the following: 1. Encodes each string in the list using a Caesar cipher with a given shift value. 2. Decodes each encoded string back to its original form using the same shift value. 3. Compares the original and decoded strings to verify that the encoding and decoding worked correctly. 4. If all strings are correctly encoded and decoded, return the string \\"Successful Encoding\\". 5. If any string does not match after decoding, return the string \\"Encoding Error\\". # Requirements 1. **Input**: A list of strings and an integer shift value for the Caesar cipher. 2. **Output**: A string message as specified above. 3. **Constraints**: * The Caesar cipher should handle both uppercase and lowercase letters and preserve the case. * The list input can be empty. In such a case, the function should return the string \\"Empty list provided\\". * The shift value is a non-negative integer that can be greater than 26. # Performance: * The function must efficiently handle lists with up to 100,000 strings, each having up to 500 characters. Examples: ```python # Example 1: input_list = [\\"abc\\", \\"DEF\\", \\"HelloWorld\\"] shift_value = 3 validate_caesar_cipher(input_list, shift_value) # Output: \\"Successful Encoding\\" # Example 2: input_list = [\\"xyz\\", \\"ABC\\"] shift_value = 2 validate_caesar_cipher(input_list, shift_value) # Output: \\"Successful Encoding\\" # Example 3: input_list = [] shift_value = 5 validate_caesar_cipher(input_list, shift_value) # Output: \\"Empty list provided\\" ``` ```python # Example Implementation of the Function: def validate_caesar_cipher(strings, shift): if not strings: return \\"Empty list provided\\" def caesar_cipher(text, shift): result = [] for char in text: if char.isalpha(): offset = 65 if char.isupper() else 97 result.append(chr((ord(char) - offset + shift) % 26 + offset)) else: result.append(char) return \'\'.join(result) encoded_strings = [caesar_cipher(s, shift) for s in strings] decoded_strings = [caesar_cipher(s, -shift) for s in encoded_strings] if strings == decoded_strings: return \\"Successful Encoding\\" else: return \\"Encoding Error\\" ```","solution":"def validate_caesar_cipher(strings, shift): if not strings: return \\"Empty list provided\\" def caesar_cipher(text, shift): result = [] for char in text: if char.isalpha(): offset = 65 if char.isupper() else 97 result.append(chr((ord(char) - offset + shift) % 26 + offset)) else: result.append(char) return \'\'.join(result) encoded_strings = [caesar_cipher(s, shift) for s in strings] decoded_strings = [caesar_cipher(s, -shift) for s in encoded_strings] if strings == decoded_strings: return \\"Successful Encoding\\" else: return \\"Encoding Error\\""},{"question":"# Sum of Unique Items in Array You are tasked with developing a function that computes the sum of the unique elements in an array of integers. An element is considered unique if it appears exactly once in the array. Write a function `sum_of_unique_elements(arr: list) -> int` that returns the sum of all unique elements in the input list. # Input - `arr` (1 ≤ len(arr) ≤ 10^4, -10^4 ≤ arr[i] ≤ 10^4) - the list of integers where each integer is within the specified range. # Output - The function should return an integer representing the sum of unique elements in the list. # Constraints - The length of the list will be an integer within the range [1, 10^4]. - The integers in the list will be within the range [-10^4, 10^4]. # Examples ```python >>> sum_of_unique_elements([1, 2, 3, 2]) 4 >>> sum_of_unique_elements([1, 1, 1, 1, 2, 2, 2, 2]) 0 >>> sum_of_unique_elements([5, -1, -1, 2, 3, -3]) 7 >>> sum_of_unique_elements([7]) 7 ``` # Guidelines - Consider using a dictionary to count the occurrences of each element in the array. - Traverse the array to compute the sum only of the elements that appear exactly once. - Ensure the function handles both positive and negative integers correctly. - Optimize the implementation to handle the upper limits of the input size within reasonable time.","solution":"def sum_of_unique_elements(arr): Computes the sum of the unique elements in an array of integers. An element is considered unique if it appears exactly once in the array. Parameters: arr (list): A list of integers. Returns: int: The sum of unique elements. element_count = {} # Count occurrences of each element for elem in arr: if elem in element_count: element_count[elem] += 1 else: element_count[elem] = 1 # Sum only the elements that appear exactly once unique_sum = sum(elem for elem, count in element_count.items() if count == 1) return unique_sum"},{"question":"# Context You are developing a command-line tool that processes JSON files and extracts specific information based on user-defined criteria. This tool needs to handle a variety of JSON structures and provide meaningful error messages when the required information is not found. # Task Write a function `extract_json_info` that takes a JSON string and a list of keys as input, and returns a dictionary containing the values associated with those keys. If a key is not found in the JSON, the function should include an error message indicating the missing key. # Function Signature ```python def extract_json_info(json_str: str, keys: list) -> dict: Extract specific values from a JSON string based on given keys. Args: json_str (str): A JSON string to be processed. keys (list): A list of keys to extract values for. Returns: dict: A dictionary containing the extracted values or error messages. pass ``` # Input and Output Formats * **Input**: * A JSON string (valid JSON format). * A list of keys (strings) to extract values for. * **Output**: * A dictionary where the keys are the input keys and values are the corresponding values from the JSON, or an error message if the key is not found. # Constraints * The `json_str` is a valid JSON string. * The `keys` list is non-empty. # Example Assume we are given the following JSON string and list of keys: ```python json_str = \'{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}\' keys = [\\"name\\", \\"city\\", \\"country\\"] ``` A call to `extract_json_info` with the provided inputs should return: ```python { \\"name\\": \\"Alice\\", \\"city\\": \\"Wonderland\\", \\"country\\": \\"Error: key not found\\" } ``` # Requirements 1. Implement the `extract_json_info` function. 2. Ensure the function provides clear and accurate messages for missing keys. ```python import json def extract_json_info(json_str: str, keys: list) -> dict: results = {} try: data = json.loads(json_str) except json.JSONDecodeError: return {\\"error\\": \\"Invalid JSON string\\"} for key in keys: if key in data: results[key] = data[key] else: results[key] = \\"Error: key not found\\" return results # Example invocation json_str = \'{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}\' keys = [\\"name\\", \\"city\\", \\"country\\"] print(extract_json_info(json_str, keys)) ``` # Performance Requirements The function should be efficient and able to handle large and nested JSON structures within a reasonable timeframe. The solution should be robust against various JSON formats while providing meaningful error messages for missing keys.","solution":"import json def extract_json_info(json_str: str, keys: list) -> dict: results = {} try: data = json.loads(json_str) except json.JSONDecodeError: return {\\"error\\": \\"Invalid JSON string\\"} for key in keys: if key in data: results[key] = data[key] else: results[key] = \\"Error: key not found\\" return results"},{"question":"# Problem Statement Implement the following tasks involving string manipulation and pattern matching in Python: 1. **Find the Longest Palindromic Substring**: Write a function to find the longest palindromic substring in a given string. - **Input**: A single string `s`. - **Output**: The longest palindromic substring within the given string. - **Examples**: ```python >>> longest_palindromic_substring(\\"babad\\") \'bab\' >>> longest_palindromic_substring(\\"cbbd\\") \'bb\' >>> longest_palindromic_substring(\\"a\\") \'a\' >>> longest_palindromic_substring(\\"ac\\") \'a\' >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \'geeksskeeg\' ``` 2. **Count Substring Occurrences**: Write a function to count how many times a substring occurs within a string. - **Input**: Two strings `s` and `sub`, where `s` is the main string and `sub` is the substring. - **Output**: An integer representing the number of times `sub` occurs in `s`. - **Examples**: ```python >>> count_substring_occurrences(\\"abababa\\", \\"aba\\") 3 >>> count_substring_occurrences(\\"aaaa\\", \\"aa\\") 3 >>> count_substring_occurrences(\\"hello world\\", \\"world\\") 1 >>> count_substring_occurrences(\\"abc\\", \\"def\\") 0 >>> count_substring_occurrences(\\"mississippi\\", \\"issi\\") 2 ``` Constraints - The input strings will have a maximum length of 1000 characters. - Substrings are case-sensitive. - The solution should be optimized to handle the upper limits efficiently. Write Python functions for each of the above tasks and provide a comprehensive test suite to validate your solution.","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. if not s: return \\"\\" n = len(s) longest_start = 0 max_len = 1 def expand_around_center(left, right): nonlocal longest_start, max_len while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 current_len = right - left - 1 if current_len > max_len: longest_start = left + 1 max_len = current_len for i in range(n): # Odd length palindrome expand_around_center(i, i) # Even length palindrome expand_around_center(i, i + 1) return s[longest_start : longest_start + max_len] def count_substring_occurrences(s, sub): Returns the number of times the substring sub occurs in the string s. if not s or not sub: return 0 count = 0 start = 0 while start < len(s): start = s.find(sub, start) if start == -1: break count += 1 start += 1 return count"},{"question":"# Problem Statement You are given an undirected, weighted graph to represent a network of cities connected by roads. Each city is connected to every other city by one direct road. Your task is to implement an algorithm that finds the minimum spanning tree (MST) of this graph using Prim\'s algorithm. # Context In computer science, the minimum spanning tree of a graph is a subset of its edges that connects all the vertices with the minimal total edge weight. This concept is particularly useful in designing network topologies, such as telecommunications or road networks, to minimize overall costs. # Function Signature ```python def prims_algorithm(graph: List[List[int]]) -> List[Tuple[int, int, int]]: ``` # Input - `graph`: A 2D list of integers where `graph[i][j]` represents the weight of the edge between city `i` and city `j`. - The graph is symmetric, meaning `graph[i][j] == graph[j][i]` and no city is connected to itself (`graph[i][i] == 0`). - The number of cities can range from 2 to 100. # Output - A list of tuples `[(i, j, weight), ...]` representing the edges in the minimum spanning tree. Each tuple contains two integers `i` and `j` denoting the indices of the connected cities, and an integer `weight` for the edge\'s weight. - The first element of each tuple should be the smaller index, i.e., if `i > j`, return `(j, i, weight)`. # Constraints - The input graph will always have at least two cities. - The graph weights are guaranteed to be non-negative. # Example ```python graph = [ [0, 2, 3, 5], [2, 0, 4, 6], [3, 4, 0, 1], [5, 6, 1, 0], ] result = prims_algorithm(graph) print(result) # Should output: [(0, 1, 2), (1, 2, 4), (2, 3, 1)] # Note: The output represents a series of edges in the format (city1, city2, weight). # The above-expected output assumes a specific order which must be adhered to. ``` # Specifications 1. Ensure the algorithm runs efficiently even for the upper limit of cities. 2. Implement error handling for exceptional cases such as empty graphs or improper input formats. 3. Optimize for readability and clarity in the implementation to highlight the use of Prim\'s algorithm.","solution":"import heapq from typing import List, Tuple def prims_algorithm(graph: List[List[int]]) -> List[Tuple[int, int, int]]: n = len(graph) if n == 0: return [] visited = [False] * n min_heap = [(0, 0, 0)] # (weight, start_vertex, end_vertex) mst_edges = [] heapq.heapify(min_heap) while min_heap and len(mst_edges) < n - 1: weight, u, v = heapq.heappop(min_heap) if visited[v]: continue visited[v] = True if u != v: mst_edges.append((min(u, v), max(u, v), weight)) for to, w in enumerate(graph[v]): if not visited[to] and w > 0: heapq.heappush(min_heap, (w, v, to)) return mst_edges"},{"question":"# Scenario: You are given a dataset of celestial bodies, each characterized by its mass and velocity. For a scientific analysis, you need to compute the kinetic energy of each celestial body, given by the formula ( KE = frac{1}{2} m v^2 ), where ( m ) is the mass and ( v ) is the velocity of the celestial body. # Task: Write a function that calculates the kinetic energy of each celestial body in the given dataset. The function should handle datasets represented as an array of dictionaries, where each dictionary contains the mass and velocity of a celestial body. # Function Signature: ```python def calculate_kinetic_energies(data: List[Dict[str, float]]) -> List[float]: pass ``` # Input: - `data`: A list of dictionaries, each containing two key-value pairs: - `\'mass\'`: A floating-point number representing the mass of the celestial body. - `\'velocity\'`: A floating-point number representing the velocity of the celestial body. # Output: - Returns a list of floating-point numbers, where each element is the kinetic energy (in joules) of the corresponding celestial body in the input list. # Constraints: - Handle datasets containing up to ( 10^6 ) celestial bodies efficiently. - All masses and velocities will be non-negative. - Ensure that the function can handle edge cases with extremely large or small values gracefully. # Example: ```python >>> data = [ ... {\'mass\': 5.0, \'velocity\': 3.0}, ... {\'mass\': 2.0, \'velocity\': 4.0}, ... {\'mass\': 1.5, \'velocity\': 2.5} ... ] >>> calculate_kinetic_energies(data) [22.5, 16.0, 4.6875] ``` # Notes: - Focus on accuracy and efficiency when computing the kinetic energies. - Use appropriate data structures and algorithms to handle large datasets while maintaining performance. - You may assume the input parameters are always valid and lead to a well-defined output.","solution":"from typing import List, Dict def calculate_kinetic_energies(data: List[Dict[str, float]]) -> List[float]: Calculates the kinetic energy of each celestial body in the dataset. Args: data: A list of dictionaries, each containing mass and velocity of the celestial body. Returns: A list of kinetic energies of the corresponding celestial bodies. kinetic_energies = [] for body in data: mass = body[\'mass\'] velocity = body[\'velocity\'] kinetic_energy = 0.5 * mass * velocity ** 2 kinetic_energies.append(kinetic_energy) return kinetic_energies"},{"question":"# Single Number Finder Given a list of integers where every element appears exactly twice except for one element which appears exactly once, design an efficient algorithm to find that single element. Implement this functionality in a single efficient function. # Requirements 1. Implement the function `find_single_number` that takes a list of integers `nums` as input and returns the single integer that appears only once. 2. Optimize the solution for both time and space complexity, aiming for linear time complexity with constant space. 3. Do not use extra data structures like hash maps or sets to achieve the goal. # Input and Output Specifications * **Input**: A list `nums` of `n` integers (`n >= 1`), where every element appears exactly twice except for one. * **Output**: An integer that appears only once in the input list. # Function Signature ```python def find_single_number(nums: list[int]) -> int: ``` # Constraints * The input list contains both negative and positive integers. * The list will always have at least one element. * All numbers in the list, except one, will appear exactly twice. # Examples 1. `find_single_number([2, 2, 1])` - Expected Output: `1` 2. `find_single_number([4, 1, 2, 1, 2])` - Expected Output: `4` 3. `find_single_number([1])` - Expected Output: `1` 4. `find_single_number([0, 0, 11, 11, 22, 7, 22, 51, 51, 7, 3, 9, 3])` - Expected Output: `9` # Instructions 1. Implement the function `find_single_number` as specified. 2. Ensure the function handles the provided examples and additional edge cases efficiently. 3. The function should be tested for minimal execution time and memory usage, particularly adhering to the constant space constraint.","solution":"def find_single_number(nums: list[int]) -> int: Returns the single integer that appears only once in the list, where every other integer appears exactly twice. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question: Implement a Priority Queue Using a Min-Heap Your task is to implement a `PriorityQueue` class using a min-heap. The min-heap should be represented using a list, and you need to support the following operations: 1. `push`: Insert an element into the priority queue. 2. `pop`: Remove and return the smallest element from the priority queue. 3. `peek`: Return the smallest element without removing it. 4. `__len__`: Return the number of elements in the priority queue. **Function Signature**: ```python class PriorityQueue: def __init__(self): self.heap = [] def push(self, value: int): pass def pop(self) -> int: pass def peek(self) -> int: pass def __len__(self) -> int: pass ``` **Input**: - The `push` method: takes an integer `value` to be inserted into the priority queue. - The `pop` method: takes no input. - The `peek` method: takes no input. - The `__len__` method: takes no input. **Output**: - The `push` method: returns nothing. - The `pop` method: returns the smallest integer from the priority queue. - The `peek` method: returns the smallest integer without removing it. - The `__len__` method: returns the number of elements in the priority queue. **Constraints**: - You must use a min-heap data structure represented by a list. - Ensure that all operations are efficient, with a time complexity of O(log n) for `push` and `pop`, and O(1) for `peek` and `__len__`. Example: ```python pq = PriorityQueue() pq.push(5) pq.push(3) pq.push(8) print(pq.peek()) # Output: 3 print(len(pq)) # Output: 3 print(pq.pop()) # Output: 3 print(pq.pop()) # Output: 5 print(len(pq)) # Output: 1 ``` You need to implement the helper functions `_heapify_up` and `_heapify_down` to maintain the heap property after insertions and deletions. # Note - Make sure your implementation correctly maintains the heap property after each insertion and deletion. - You should handle edge cases such as popping from an empty priority queue gracefully by raising an appropriate exception.","solution":"class PriorityQueue: def __init__(self): self.heap = [] def push(self, value: int): self.heap.append(value) self._heapify_up(len(self.heap) - 1) def pop(self) -> int: if not self.heap: raise IndexError(\\"pop from empty priority queue\\") # Swap the root with the last element self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0] smallest = self.heap.pop() self._heapify_down(0) return smallest def peek(self) -> int: if not self.heap: raise IndexError(\\"peek from empty priority queue\\") return self.heap[0] def __len__(self) -> int: return len(self.heap) def _heapify_up(self, index): # While we haven\'t reached the root and the heap property is violated while index > 0: parent_index = (index - 1) // 2 if self.heap[index] < self.heap[parent_index]: # Swap with parent self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] index = parent_index else: break def _heapify_down(self, index): length = len(self.heap) while index < length: left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < length and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < length and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] index = smallest else: break"},{"question":"# Coding Assessment Question Context You are asked to implement a library utility function that process and validates ISBN-13 codes. The ISBN-13 (International Standard Book Number) is a 13-digit code used to uniquely identify books, and it includes a checksum for error detection. Objective Your task is to write a function that validates if a given ISBN-13 code is correct or not. The algorithm to check the validity involves computing a checksum digit using the first 12 digits and comparing it to the 13th digit. Details 1. Implement the function `validate_isbn13(isbn: str) -> bool` which takes a single string as input and returns a boolean indicating whether the ISBN-13 code is valid. 2. The function should first ensure that the input consists of exactly 13 digits. 3. The ISBN-13 checksum calculation follows these steps: - Take the first 12 digits of the ISBN. - Multiply each digit alternately by 1 and 3, and then sum the results. - Take modulo 10 of the sum. - If the result is 0, then the checksum digit is 0; otherwise, it is 10 minus the result. 4. Compare the calculated checksum digit with the 13th digit of the ISBN. Requirements 1. If the input does not consist of exactly 13 digits, the function should raise a `ValueError`. 2. If the ISBN is valid, return `True`. Otherwise, return `False`. Constraints * The input will always be a string. Examples ```python def validate_isbn13(isbn: str) -> bool: # Your implementation here pass # Example usage and results assert validate_isbn13(\\"9780316066525\\") == True # Valid ISBN-13 assert validate_isbn13(\\"9780316066524\\") == False # Invalid ISBN-13 assert validate_isbn13(\\"978031606652\\") # should raise ValueError due to incorrect length assert validate_isbn13(\\"9780316066525\\") == True # Correct checksum validation ``` Notes: * Strings containing characters other than digits are considered invalid. * The calculation of the checksum digit includes specific weight multipliers (1 and 3) and a modulo operation. * The function should raise appropriate errors for input validation and ensure accurate comparisons for correctness.","solution":"def validate_isbn13(isbn: str) -> bool: Validates if the given ISBN-13 code is correct. Parameters: isbn (str): The ISBN-13 code as a string. Returns: bool: True if the ISBN-13 is valid, False otherwise. Raises: ValueError: If the input is not exactly 13 digits. if len(isbn) != 13 or not isbn.isdigit(): raise ValueError(\\"ISBN must be exactly 13 digits\\") total = 0 for i in range(12): digit = int(isbn[i]) if i % 2 == 0: total += digit * 1 else: total += digit * 3 checksum = total % 10 if checksum != 0: checksum = 10 - checksum return checksum == int(isbn[12]) # Example usage assert validate_isbn13(\\"9780316066525\\") == True assert validate_isbn13(\\"9780316066524\\") == False try: validate_isbn13(\\"978031606652\\") # This should raise a ValueError except ValueError as ve: assert str(ve) == \\"ISBN must be exactly 13 digits\\""},{"question":"# Scenario You are developing a platform that helps users manage their tasks and goals more effectively. One of the critical features of the platform is a calendar service that allows users to schedule appointments, tasks, and events. To ensure a smooth user experience, the system must be capable of efficiently managing and querying time intervals. # Task Your task is to implement a class called `Calendar` that manages a collection of non-overlapping time intervals. The class should support adding new intervals, checking for conflicts, and merging intervals when they overlap. **Class Structure**: - `__init__()`: Initializes an empty calendar. - `add_interval(start: int, end: int) -> bool`: Adds a new interval [start, end) to the calendar if it does not overlap with existing intervals. Returns `True` if the interval was added successfully, otherwise `False`. - `merge_intervals() -> None`: Merges all overlapping and adjacent intervals in the calendar. **Input and Output Formats**: - Intervals are given as pairs of integers where `start` < `end`. - The `add_interval` method should return `True` if the interval was added without conflict, otherwise `False`. - The `merge_intervals` method should modify the calendar in-place. **Constraints**: - Time intervals are defined in integer units. - The intervals are half-open, i.e., they include the `start` but exclude the `end`. # Steps to Complete 1. Implement the `Calendar` class with the required methods. 2. Ensure that `add_interval` correctly handles conflicts and does not allow overlapping intervals. 3. Implement `merge_intervals` to merge overlapping and adjacent intervals in the calendar. **Example Usage**: ```python calendar = Calendar() # Adding intervals assert calendar.add_interval(1, 5) == True assert calendar.add_interval(6, 10) == True assert calendar.add_interval(5, 6) == True # Adjacent, but should not overlap # Attempting to add overlapping interval assert calendar.add_interval(4, 7) == False # Overlaps with interval [1, 5] # Merging intervals calendar.merge_intervals() # After merging, intervals should be [[1, 5], [5, 10]] # Adding an interval that fits within the merged intervals assert calendar.add_interval(10, 15) == True ``` Implement the `Calendar` class based on the requirements described above.","solution":"class Calendar: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> bool: for interval in self.intervals: if not (end <= interval[0] or start >= interval[1]): return False self.intervals.append([start, end]) self.intervals.sort() return True def merge_intervals(self) -> None: if not self.intervals: return self.intervals.sort() merged_intervals = [self.intervals[0]] for current in self.intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: last[1] = max(last[1], current[1]) else: merged_intervals.append(current) self.intervals = merged_intervals def get_intervals(self): return self.intervals"},{"question":"# Question: Count Distinct Substrings Using Trie You need to write a program that counts the number of distinct substrings in a given string using a Trie data structure. This problem will test your ability to implement specific data structures and understand string manipulation. Function Signature ```python def count_distinct_substrings(s: str) -> int: pass ``` Inputs - **s** (str): A string consisting of lowercase English letters. ( 1 leq text{len}(s) leq 1000 ). Outputs - **int**: The number of distinct substrings in the given string. # Examples ```python assert count_distinct_substrings(\'abc\') == 6 assert count_distinct_substrings(\'aaa\') == 3 assert count_distinct_substrings(\'ababa\') == 9 assert count_distinct_substrings(\'xyz\') == 6 ``` # Constraints 1. Consider substrings of length 1 to ( n ) inclusive. 2. The input string will only contain lowercase English letters. 3. Your implementation should be efficient enough to handle the upper limit of ( n ). # Guidelines 1. Use a Trie (prefix tree) to store all substrings and count them. 2. Handle input validation appropriately within the constraints provided. 3. Minimize both time and space complexity to ensure the solution\'s efficiency. # Notes Write a fully-functional script that adheres to the given constraints and requirements, focusing on using the Trie data structure to achieve the task.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_substring = False class Trie: def __init__(self): self.root = TrieNode() def add(self, word): Adds a word to the Trie. Returns True if the word added is distinct (not already in the Trie), otherwise False. node = self.root is_new_word = False for char in word: if char not in node.children: node.children[char] = TrieNode() is_new_word = True # this part of the word is new node = node.children[char] node.is_end_of_substring = True return is_new_word def count_distinct_substrings(s): Returns the number of distinct substrings of the given string s. trie = Trie() distinct_count = 0 # Add all substrings of s to the Trie for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring = s[i:j] if trie.add(substring): distinct_count += 1 return distinct_count"},{"question":"# Question: Implement a Simple Recurrent Neural Network (RNN) for Text Sequence Prediction Context You are tasked with creating a basic Recurrent Neural Network (RNN) to predict the next character in a sequence of text. The focus will be on implementing the forward and backward passes through the network as well as training routine using backpropagation through time (BPTT). Task Implement the following functions within a Python class `SimpleRNN`: 1. `forward(self, inputs, hidden_state)`: - Compute the forward pass of the RNN for a sequence of inputs. - Input: - `inputs`: List of integers representing the input characters (e.g., indices in a vocabulary). - `hidden_state`: 1D numpy array representing the initial hidden state. - Output: - `outputs`: List of 1D numpy arrays representing the output at each time step. - `hidden_state`: 1D numpy array representing the final hidden state. 2. `backward(self, d_outputs, hidden_states, cached_inputs)`: - Compute the backward pass of the RNN, calculating gradients for all parameters. - Input: - `d_outputs`: List of 1D numpy arrays representing the gradients of the loss with respect to the outputs. - `hidden_states`: List of 1D numpy arrays representing the hidden states at each time step. - `cached_inputs`: List of integers representing the input characters cached during the forward pass. - Output: None. It should update the model parameters. 3. `train(self, input_text, seq_length, epochs, learning_rate)`: - Implement a training routine for the RNN using BPTT. - Input: - `input_text`: String containing the entire text data for training. - `seq_length`: Integer, number of characters in each training sequence. - `epochs`: Integer, number of training epochs. - `learning_rate`: Float, learning rate for gradient descent. - Output: None. It should update the model parameters. Constraints - You can use `numpy` for matrix operations but avoid using libraries like TensorFlow, Keras, or PyTorch. - Assume the characters in the text are encoded as integers ranging from 0 to the size of the vocabulary minus one. - Ensure you properly handle sequence boundary conditions during training. # Solution Outline ```python import numpy as np class SimpleRNN: def __init__(self, vocab_size, hidden_size): self.vocab_size = vocab_size self.hidden_size = hidden_size self.W_xh = np.random.randn(vocab_size, hidden_size) * 0.01 # Input to hidden self.W_hh = np.random.randn(hidden_size, hidden_size) * 0.01 # Hidden to hidden self.W_hy = np.random.randn(hidden_size, vocab_size) * 0.01 # Hidden to output self.b_h = np.zeros((hidden_size, 1)) self.b_y = np.zeros((vocab_size, 1)) def forward(self, inputs, hidden_state): outputs, hidden_states = [], [] for x in inputs: x_one_hot = np.zeros((self.vocab_size, 1)) x_one_hot[x] = 1 hidden_state = np.tanh(np.dot(self.W_xh.T, x_one_hot) + np.dot(self.W_hh, hidden_state) + self.b_h) output = np.dot(self.W_hy.T, hidden_state) + self.b_y outputs.append(output) hidden_states.append(hidden_state) return outputs, hidden_state def backward(self, d_outputs, hidden_states, cached_inputs): dW_xh, dW_hh, dW_hy = np.zeros_like(self.W_xh), np.zeros_like(self.W_hh), np.zeros_like(self.W_hy) db_h, db_y = np.zeros_like(self.b_h), np.zeros_like(self.b_y) dh_next = np.zeros_like(hidden_states[0]) for t in reversed(range(len(cached_inputs))): x_one_hot = np.zeros((self.vocab_size, 1)) x_one_hot[cached_inputs[t]] = 1 dy = d_outputs[t] - x_one_hot dW_hy += np.dot(hidden_states[t], dy.T) db_y += dy dh = np.dot(self.W_hy, dy) + dh_next dtanh = (1 - hidden_states[t] ** 2) * dh db_h += dtanh dW_hh += np.dot(hidden_states[t-1], dtanh.T) dW_xh += np.dot(x_one_hot, dtanh.T) dh_next = np.dot(self.W_hh, dtanh) for dparam in [dW_xh, dW_hh, dW_hy, db_h, db_y]: np.clip(dparam, -5, 5, out=dparam) self.W_xh -= learning_rate * dW_xh self.W_hh -= learning_rate * dW_hh self.W_hy -= learning_rate * dW_hy self.b_h -= learning_rate * db_h self.b_y -= learning_rate * db_y def train(self, input_text, seq_length, epochs, learning_rate): input_indices = [ord(char) - ord(\'a\') for char in input_text] for epoch in range(epochs): for i in range(0, len(input_text) - seq_length, seq_length): inputs = input_indices[i:i+seq_length] targets = input_indices[i+1:i+seq_length+1] hidden_state = np.zeros((self.hidden_size, 1)) outputs, hidden_state = self.forward(inputs, hidden_state) loss = sum((outputs - targets)**2) / seq_length d_outputs = outputs - targets self.backward(d_outputs, hidden_states, inputs) print(f\'Epoch {epoch}, Loss: {loss}\') # Sample usage: text = \\"hello\\" rnn = SimpleRNN(vocab_size=26, hidden_size=100) rnn.train(input_text=text, seq_length=4, epochs=100, learning_rate=0.01) ```","solution":"import numpy as np class SimpleRNN: def __init__(self, vocab_size, hidden_size): self.vocab_size = vocab_size self.hidden_size = hidden_size self.W_xh = np.random.randn(vocab_size, hidden_size) * 0.01 # Input to hidden self.W_hh = np.random.randn(hidden_size, hidden_size) * 0.01 # Hidden to hidden self.W_hy = np.random.randn(hidden_size, vocab_size) * 0.01 # Hidden to output self.b_h = np.zeros((hidden_size, 1)) self.b_y = np.zeros((vocab_size, 1)) def forward(self, inputs, hidden_state): outputs, hidden_states = [], [] for x in inputs: x_one_hot = np.zeros((self.vocab_size, 1)) x_one_hot[x] = 1 hidden_state = np.tanh(np.dot(self.W_xh.T, x_one_hot) + np.dot(self.W_hh, hidden_state) + self.b_h) output = np.dot(self.W_hy.T, hidden_state) + self.b_y outputs.append(output) hidden_states.append(hidden_state) return outputs, hidden_state def backward(self, d_outputs, hidden_states, cached_inputs, learning_rate): dW_xh, dW_hh, dW_hy = np.zeros_like(self.W_xh), np.zeros_like(self.W_hh), np.zeros_like(self.W_hy) db_h, db_y = np.zeros_like(self.b_h), np.zeros_like(self.b_y) dh_next = np.zeros_like(hidden_states[0]) for t in reversed(range(len(cached_inputs))): x_one_hot = np.zeros((self.vocab_size, 1)) x_one_hot[cached_inputs[t]] = 1 dy = d_outputs[t] dW_hy += np.dot(hidden_states[t], dy.T) db_y += dy dh = np.dot(self.W_hy, dy) + dh_next dtanh = (1 - hidden_states[t] ** 2) * dh db_h += dtanh if t != 0: dW_hh += np.dot(hidden_states[t-1], dtanh.T) dW_xh += np.dot(x_one_hot, dtanh.T) dh_next = np.dot(self.W_hh, dtanh) for dparam in [dW_xh, dW_hh, dW_hy, db_h, db_y]: np.clip(dparam, -5, 5, out=dparam) self.W_xh -= learning_rate * dW_xh self.W_hh -= learning_rate * dW_hh self.W_hy -= learning_rate * dW_hy self.b_h -= learning_rate * db_h self.b_y -= learning_rate * db_y def train(self, input_text, seq_length, epochs, learning_rate): input_indices = [ord(char) - ord(\'a\') for char in input_text] for epoch in range(epochs): for i in range(0, len(input_indices) - seq_length, seq_length): inputs = input_indices[i:i+seq_length] targets = input_indices[i+1:i+seq_length+1] hidden_state = np.zeros((self.hidden_size, 1)) outputs, hidden_state = self.forward(inputs, hidden_state) loss = sum((outputs[t] - np.eye(self.vocab_size)[targets[t]].reshape(-1, 1))**2 for t in range(seq_length)) / seq_length d_outputs = [outputs[t] - np.eye(self.vocab_size)[targets[t]].reshape(-1, 1) for t in range(seq_length)] hidden_states = [hidden_state for _ in range(seq_length)] # Normally, the hidden states should be collected at each step self.backward(d_outputs, hidden_states, inputs, learning_rate) print(f\'Epoch {epoch+1}, Loss: {loss}\') # Sample usage: text = \\"hello\\" rnn = SimpleRNN(vocab_size=26, hidden_size=100) rnn.train(input_text=text, seq_length=4, epochs=10, learning_rate=0.01)"},{"question":"# Question: Validate and Optimize Fibonacci Number Calculation You are given a function `fibonacci_number` that calculates the nth Fibonacci number using the recursive approach. The current implementation is inefficient for larger values of n due to its exponential time complexity. Additionally, the function lacks input validation. Your task is to re-implement the `fibonacci_number` function to: 1. Optimize the calculation by using an iterative approach or memoization. 2. Validate that the input n is a non-negative integer. 3. Return an appropriate error message if invalid data is encountered. # Function Signature ```python def fibonacci_number(n: int) -> int | str: pass ``` # Input * `n`: An integer representing the position in the Fibonacci sequence (n >= 0). # Output * An integer representing the nth Fibonacci number. * Return an error message if the input is invalid. # Constraints * `0 <= n <= 10^6` # Example ```python >>> fibonacci_number(10) 55 >>> fibonacci_number(0) 0 >>> fibonacci_number(1) 1 >>> fibonacci_number(-5) \'Error: Input must be a non-negative integer\' >>> fibonacci_number(3.5) \'Error: Input must be a non-negative integer\' >>> fibonacci_number(\'a\') \'Error: Input must be a non-negative integer\' ``` Note - Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ... - The 0th Fibonacci number is 0. - The 1st Fibonacci number is 1. - The nth Fibonacci number is the sum of the (n-1)th and (n-2)th Fibonacci numbers (for n >= 2).","solution":"def fibonacci_number(n): Returns the nth Fibonacci number. If the input is not a non-negative integer, returns an error message. if not isinstance(n, int) or n < 0: return \'Error: Input must be a non-negative integer\' if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement Create a function `group_strings_by_length` that takes a list of strings and returns a dictionary grouping the strings by their lengths. The keys in the dictionary will be the lengths of strings, and the values will be lists of strings of that length, sorted in lexicographical order. # Input * A list of strings (not necessarily distinct), e.g., `[\\"apple\\", \\"boy\\", \\"cat\\", \\"ax\\"]`. # Output * A dictionary where the keys are integers representing string lengths and the values are lists of strings of that length, sorted in lexicographical order, e.g., `{3: [\\"ax\\", \\"boy\\", \\"cat\\"], 5: [\\"apple\\"]}`. # Constraints 1. The input list will have at most `10^5` elements. 2. Each string will have a length between 1 and 100. 3. The total length of all strings combined will not exceed `10^6`. # Examples ```python >>> group_strings_by_length([\\"apple\\", \\"boy\\", \\"cat\\", \\"ax\\"]) {2: [\\"ax\\"], 3: [\\"boy\\", \\"cat\\"], 5: [\\"apple\\"]} >>> group_strings_by_length([\\"abc\\", \\"de\\", \\"fghij\\", \\"klmno\\", \\"pq\\"]) {2: [\\"de\\", \\"pq\\"], 3: [\\"abc\\"], 5: [\\"fghij\\", \\"klmno\\"]} >>> group_strings_by_length([\\"a\\", \\"b\\", \\"c\\"]) {1: [\\"a\\", \\"b\\", \\"c\\"]} ``` # Notes - The output dictionary should have the string lengths as keys. - Each list in the dictionary should be sorted in lexicographical order. - The keys should appear in ascending order. # Instructions Implement the function `group_strings_by_length` to solve the specified problem: ```python def group_strings_by_length(strings: list) -> dict: Given a list of strings, return a dictionary grouping the strings by their lengths. The values should be lists of lexicographically sorted strings. # Your code here ```","solution":"def group_strings_by_length(strings): from collections import defaultdict result = defaultdict(list) # Group strings by length for string in strings: result[len(string)].append(string) # Sort each group lexicographically for length in result: result[length].sort() return dict(result)"},{"question":"# Trie Data Structure Enhancement You are given the basic implementation of a Trie (Prefix Tree) data structure. Your task is to enhance this data structure to add the following functionalities: 1. **Delete Word**: Add a method `delete(word: str) -> bool` which removes the specified word from the Trie if it exists. The method returns `True` if the word was successfully deleted, and `False` if the word does not exist in the Trie. 2. **Count Words With Prefix**: Add a method `count_words_with_prefix(prefix: str) -> int` which returns the number of words in the Trie that have the specified prefix. Input and Output Formats * **Input**: * For the `delete` method: * `word` - a string representing the word to remove from the Trie. * For the `count_words_with_prefix` method: * `prefix` - a string representing the prefix to check in the Trie. * **Output**: * For the `delete` method: * Returns `True` if the word was successfully deleted. * Returns `False` if the word does not exist. * For the `count_words_with_prefix` method: * An integer representing the number of words with the given prefix in the Trie. Constraints * The Trie can store a large number (reasonable upper bounds) of words and characters. * The words and prefixes are composed of lowercase English letters. Performance Requirements * Ensure that the delete operation and prefix count queries remain efficient, ideally with a reasonable time complexity relative to the length of the word or prefix being processed. # Example ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"application\\") trie.insert(\\"apply\\") print(trie.delete(\\"app\\")) # Output: True print(trie.delete(\\"app\\")) # Output: False print(trie.count_words_with_prefix(\\"app\\")) # Output: 3 print(trie.count_words_with_prefix(\\"ban\\")) # Output: 0 ``` # Implementation Enhance the provided `Trie` class by implementing the `delete` and `count_words_with_prefix` methods as described. Ensure that the methods work efficiently with the existing structure of the Trie.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.word_count_with_prefix = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word_count_with_prefix += 1 node.is_end_of_word = True def delete(self, word: str) -> bool: if not self._search(self.root, word): return False self._delete(self.root, word, 0) return True def _delete(self, node, word, depth): if depth == len(word): if not node.is_end_of_word: return False node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char not in node.children or not self._delete(node.children[char], word, depth + 1): return False node.children[char].word_count_with_prefix -= 1 if node.children[char].word_count_with_prefix == 0: del node.children[char] return not node.is_end_of_word and len(node.children) == 0 def count_words_with_prefix(self, prefix: str) -> int: node = self.root for char in prefix: if char not in node.children: return 0 node = node.children[char] return node.word_count_with_prefix if node else 0 def _search(self, node, word): for char in word: if char not in node.children: return False node = node.children[char] return node != None and node.is_end_of_word"},{"question":"# Determine the Type of a Quadrilateral Scenario You are working on a geometry library that helps users classify different quadrilaterals. The library should be able to distinguish between various types of quadrilaterals such as squares, rectangles, and rhombuses based on the length of their sides and angles. Task Your task is to implement a function that determines the type of a quadrilateral given the lengths of its sides and its angles. The function should classify the quadrilateral as one of the following types: Square, Rectangle, Rhombus, or Other. Function 1. **Function `classify_quadrilateral`:** - **Input**: Four integers `a`, `b`, `c`, `d` representing the lengths of the sides, and four integers `A`, `B`, `C`, `D` representing the angles in degrees. - All side lengths are expressed in positive integers. - Angles are expressed in integers and range between 0 and 180 degrees. - **Output**: A string that indicates the type of the quadrilateral: \\"Square\\", \\"Rectangle\\", \\"Rhombus\\", or \\"Other\\". You need to implement the function as described below. ```python def classify_quadrilateral(a: int, b: int, c: int, d: int, A: int, B: int, C: int, D: int) -> str: Classify the quadrilateral based on side lengths and angles. Parameters: - a (int): Length of side a - b (int): Length of side b - c (int): Length of side c - d (int): Length of side d - A (int): Angle between sides a and b - B (int): Angle between sides b and c - C (int): Angle between sides c and d - D (int): Angle between sides d and a Returns: - str: Type of the quadrilateral (\'Square\', \'Rectangle\', \'Rhombus\', \'Other\') # Your code here ``` Examples ```python # Example for classify_quadrilateral print(classify_quadrilateral(4, 4, 4, 4, 90, 90, 90, 90)) # \\"Square\\" print(classify_quadrilateral(4, 4, 4, 4, 100, 80, 100, 80)) # \\"Rhombus\\" print(classify_quadrilateral(4, 6, 4, 6, 90, 90, 90, 90)) # \\"Rectangle\\" print(classify_quadrilateral(4, 5, 6, 7, 90, 90, 60, 120)) # \\"Other\\" ``` Constraints * Ensure that your function handles edge cases and errors gracefully. * Assume that input values provided are always valid (no need to check for negative or zero lengths). **Note:** For a quadrilateral to be classified as any specific type: - **Square**: All sides are equal, and all angles are 90 degrees. - **Rectangle**: Opposite sides are equal, and all angles are 90 degrees. - **Rhombus**: All sides are equal, and angles are not necessarily 90 degrees.","solution":"def classify_quadrilateral(a: int, b: int, c: int, d: int, A: int, B: int, C: int, D: int) -> str: if a == b == c == d: if A == B == C == D == 90: return \\"Square\\" else: return \\"Rhombus\\" if a == c and b == d: if A == B == C == D == 90: return \\"Rectangle\\" return \\"Other\\""},{"question":"**Context**: You are developing a `MaxHeap` class that extends a basic `Heap` class to maintain the properties of a max heap. Your task is to implement methods to remove the maximum element and to increase the priority of a given key. **Objective**: Implement a class `MaxHeap` that inherits from `Heap` and provides functionality to remove the maximum element and to increase the priority of an existing key. # Requirements: 1. **Class Hierarchy**: Your `MaxHeap` should inherit from `Heap`. 2. **Remove Maximum**: Implement a method to remove and return the maximum element from the heap. 3. **Increase Priority**: Implement a method to increase the priority of an existing key: * If the new priority is greater than the current priority, adjust the heap to maintain the max-heap property. 4. **Methods to Implement**: * `remove_max`: Remove and return the maximum element from the heap. * `increase_priority`: Increase the priority of a given key and reheapify if necessary. # Define Class Structure ```python class MaxHeap(Heap): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # Define additional properties if needed def remove_max(self): Remove and return the maximum element from the heap. # Implement max removal logic def increase_priority(self, key, new_priority): Increase the priority of the given key. # Implement increase priority logic ``` # Instructions 1. **Initialize**: On initialization, it should take the same parameters as the base class. 2. **Remove and Return Maximum**: Implement the `remove_max` method to: * Remove the root element (maximum). * Replace the root with the last element and reheapify downwards. 3. **Increase Priority**: Implement the `increase_priority` method to: * Locate the key and confirm the new priority is greater. * Set the priority to the new value and reheapify upwards. # Constraints * `key` is always a string. * `priority` is a non-negative integer. * Initial heap can contain any number of items. # Example ```python # Example usage max_heap = MaxHeap([(\'a\', 1), (\'b\', 2), (\'c\', 3)]) max_heap.insert(\'d\', 4) print(max_heap.remove_max()) # Should return (\'d\', 4) max_heap.insert(\'e\', 5) max_heap.increase_priority(\'a\', 6) # \'a\' now has the highest priority print(max_heap.remove_max()) # Should return (\'a\', 6) ```","solution":"class Heap: def __init__(self): self.heap = [] self.key_index_map = {} def insert(self, key, priority): self.heap.append((priority, key)) self.key_index_map[key] = len(self.heap) - 1 self._heapify_up(len(self.heap) - 1) def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index][0] > self.heap[parent_index][0]: self._swap(index, parent_index) self._heapify_up(parent_index) def _heapify_down(self, index): child_index = 2 * index + 1 if child_index >= len(self.heap): return # Check if the right child exists and is larger than the left child if child_index + 1 < len(self.heap) and self.heap[child_index + 1][0] > self.heap[child_index][0]: child_index += 1 # Swap if child is greater than parent (max-heap condition) if self.heap[child_index][0] > self.heap[index][0]: self._swap(index, child_index) self._heapify_down(child_index) def _swap(self, i, j): self.key_index_map[self.heap[i][1]] = j self.key_index_map[self.heap[j][1]] = i self.heap[i], self.heap[j] = self.heap[j], self.heap[i] class MaxHeap(Heap): def __init__(self): super().__init__() def remove_max(self): if len(self.heap) == 0: return None max_element = self.heap[0] last_element = self.heap.pop() if len(self.heap) > 0: self.heap[0] = last_element self.key_index_map[self.heap[0][1]] = 0 self._heapify_down(0) del self.key_index_map[max_element[1]] return max_element[1], max_element[0] def increase_priority(self, key, new_priority): if key not in self.key_index_map: return False index = self.key_index_map[key] if new_priority <= self.heap[index][0]: return False self.heap[index] = (new_priority, key) self._heapify_up(index) return True"},{"question":"# Coding Question You are given the task of implementing a simple inventory management system for a small retail store. The system should be capable of adding new items, updating existing items, removing items, and displaying the current inventory. Objective Develop a program that efficiently manages the inventory by implementing the following functionalities: 1. **Add New Items**: - Implement a function `add_item` that takes the item name, quantity, and price, and adds it to the inventory. - Ensure that the item name is unique within the inventory. 2. **Update Existing Items**: - Implement a function `update_item` that takes the item name, quantity, and price, and updates the respective item in the inventory. 3. **Remove Items**: - Implement a function `remove_item` that takes the item name and removes it from the inventory. 4. **Display Inventory**: - Implement a function `display_inventory` that prints the current inventory in a tabular format, sorted alphabetically by item name. Function Implementations - **add_item(inventory: dict[str, dict[str, Union[int, float]]], item_name: str, quantity: int, price: float) -> None**: - Input: A dictionary representing the inventory, item name, quantity, and price. - Output: Adds the item to the inventory with the specified quantity and price. Raises a `ValueError` if the item already exists. - **update_item(inventory: dict[str, dict[str, Union[int, float]]], item_name: str, quantity: int, price: float) -> None**: - Input: A dictionary representing the inventory, item name, quantity, and price. - Output: Updates the item in the inventory with the specified quantity and price. - **remove_item(inventory: dict[str, dict[str, Union[int, float]]], item_name: str) -> None**: - Input: A dictionary representing the inventory, item name. - Output: Removes the item from the inventory. Raises a `KeyError` if the item does not exist. - **display_inventory(inventory: dict[str, dict[str, Union[int, float]]]) -> None**: - Input: A dictionary representing the inventory. - Output: Prints the inventory with headers \\"Name\\", \\"Quantity\\", and \\"Price\\" sorted alphabetically by item name. Example ```python inventory = {} add_item(inventory, \\"Apple\\", 30, 0.50) add_item(inventory, \\"Banana\\", 20, 0.20) update_item(inventory, \\"Apple\\", 40, 0.55) remove_item(inventory, \\"Banana\\") display_inventory(inventory) ``` Output: ``` Name Quantity Price Apple 40 0.55 ``` Your implementation should ensure robust error handling and input validation to provide a seamless experience for the user.","solution":"def add_item(inventory, item_name, quantity, price): Adds a new item to the inventory. if item_name in inventory: raise ValueError(f\\"Item \'{item_name}\' already exists in the inventory.\\") inventory[item_name] = {\'quantity\': quantity, \'price\': price} def update_item(inventory, item_name, quantity, price): Updates an existing item in the inventory. if item_name not in inventory: raise KeyError(f\\"Item \'{item_name}\' does not exist in the inventory.\\") inventory[item_name] = {\'quantity\': quantity, \'price\': price} def remove_item(inventory, item_name): Removes an item from the inventory. if item_name not in inventory: raise KeyError(f\\"Item \'{item_name}\' does not exist in the inventory.\\") del inventory[item_name] def display_inventory(inventory): Displays the current inventory in a tabular format, sorted alphabetically by item name. print(f\\"{\'Name\':<15} {\'Quantity\':<10} {\'Price\':<10}\\") for item_name in sorted(inventory.keys()): item = inventory[item_name] print(f\\"{item_name:<15} {item[\'quantity\']:<10} {item[\'price\']:<10.2f}\\")"},{"question":"# Problem: Merge Sorted Arrays with Deduplication You are given two sorted arrays of integers and you need to merge them into a single sorted array without any duplicates. Function: `merge_and_deduplicate(arr1: List[int], arr2: List[int]) -> List[int]` Merges the two sorted arrays and removes any duplicate elements. **Parameters**: * `arr1`: A sorted list of integers. * `arr2`: A sorted list of integers. **Returns**: * A sorted list of integers containing unique elements from both `arr1` and `arr2`. Constraints: * Both `arr1` and `arr2` can be of different lengths, including zero. * Both `arr1` and `arr2` are sorted in non-decreasing order. * The function should handle the merging and deduplication in O(m + n) time, where m and n are the lengths of `arr1` and `arr2` respectively. * Elements in the input arrays and output list can be any integer within the range of a 32-bit signed integer. # Example: ```python arr1 = [1, 2, 4, 5] arr2 = [2, 3, 5, 6] merged_unique_array = merge_and_deduplicate(arr1, arr2) print(merged_unique_array) # Expected Output: [1, 2, 3, 4, 5, 6] arr1 = [] arr2 = [1, 1, 2, 2] merged_unique_array = merge_and_deduplicate(arr1, arr2) print(merged_unique_array) # Expected Output: [1, 2] arr1 = [4, 5, 6] arr2 = [] merged_unique_array = merge_and_deduplicate(arr1, arr2) print(merged_unique_array) # Expected Output: [4, 5, 6] arr1 = [1, 2, 3] arr2 = [3, 4, 5] merged_unique_array = merge_and_deduplicate(arr1, arr2) print(merged_unique_array) # Expected Output: [1, 2, 3, 4, 5] ``` Consider edge cases, such as: * Arrays with the same elements * One or both arrays being empty * Arrays without any overlapping elements * Arrays with duplicated numbers within themselves and across each other","solution":"def merge_and_deduplicate(arr1, arr2): Merges two sorted arrays and removes any duplicates. Parameters: arr1 (list): A sorted list of integers. arr2 (list): A sorted list of integers. Returns: list: A sorted list of integers containing unique elements from both `arr1` and `arr2`. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 elif arr1[i] > arr2[j]: if not merged or merged[-1] != arr2[j]: merged.append(arr2[j]) j += 1 else: if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 j += 1 while i < len(arr1): if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 while j < len(arr2): if not merged or merged[-1] != arr2[j]: merged.append(arr2[j]) j += 1 return merged"},{"question":"# Sum of Product of Digits of Two Numbers You are tasked with implementing a function that calculates the sum of the products of each pair of digits from two given integers. This problem will test your ability to manipulate digits and perform arithmetic operations efficiently within Python. Function Signature ```python def sum_of_product_of_digits(num1: int, num2: int) -> int: ``` Input * `num1` - An integer which can be positive, negative, or zero. * `num2` - An integer which can be positive, negative, or zero. Output * Returns an integer that is the sum of the products of each possible pair of digits, one from `num1` and one from `num2`. Constraints * The function should only accept integer inputs; if an input is non-integral, raise a `TypeError`. * The implementation should handle positive and negative integers, zero, and ensure the return value adheres to the same sign. * The function should efficiently manage large integers, where `num1` and `num2` can have a large number of digits. # Example Scenarios ```python >>> sum_of_product_of_digits(12, 34) 21 >>> sum_of_product_of_digits(-12, 34) 21 >>> sum_of_product_of_digits(0, 123) 0 >>> sum_of_product_of_digits(-5, -5) 25 >>> sum_of_product_of_digits(\'12\', \'34\') Traceback (most recent call last): ... TypeError: sum_of_product_of_digits() only accepts integers ``` # Guidelines 1. Extract the digits of `num1` and `num2`, ensuring to handle the signs appropriately. 2. Compute the product for each pair of digits from extracted digits of `num1` and `num2`. 3. Sum all the computed products and return the result. 4. Ensure the input validation appropriately raises `TypeError` for non-integer inputs. 5. Optimize the implementation for clarity and performance, especially for cases with large digit counts. Happy coding!","solution":"def sum_of_product_of_digits(num1: int, num2: int) -> int: Returns the sum of the products of each pair of digits, one from num1 and one from num2. if not isinstance(num1, int) or not isinstance(num2, int): raise TypeError(\\"sum_of_product_of_digits() only accepts integers\\") def digits(n): return [int(d) for d in str(abs(n))] digits1 = digits(num1) digits2 = digits(num2) sum_product = 0 for d1 in digits1: for d2 in digits2: sum_product += d1 * d2 return sum_product"},{"question":"# Problem Statement: You are tasked with creating a system to manage student scores for various assignments in a course. Given a list of students with their respective scores for multiple assignments, you need to write a Python function that computes and returns the average score for each student. # Task: Write a function `compute_student_averages()` that takes one argument: - `student_scores` (dict): A dictionary where each key is a student\'s name (string) and each value is a list of integers representing the scores the student received on different assignments. The function should return a dictionary where each key is a student\'s name and each value is the average score (float) of that student, rounded to two decimal places. Constraints: - Each student has at least one assignment score. - Scores are non-negative integers. - Student names are unique. Example: ```python def compute_student_averages(student_scores: dict[str, list[int]]) -> dict[str, float]: pass # Your implementation here # Example Test Cases: print(compute_student_averages({\'Alice\': [85, 92, 88], \'Bob\': [78, 81, 89], \'Charlie\': [95, 90, 92]})) # {\'Alice\': 88.33, \'Bob\': 82.67, \'Charlie\': 92.33} print(compute_student_averages({\'Jordan\': [70, 80, 90], \'Alex\': [88, 87, 91]})) # {\'Jordan\': 80.0, \'Alex\': 88.67} ``` # Requirements: - Implement error handling for an empty list of scores. - Calculate the average correctly, ensuring each average is rounded to two decimal places.","solution":"def compute_student_averages(student_scores: dict) -> dict: Computes and returns the average score for each student. Args: student_scores (dict): A dictionary where each key is a student\'s name (string) and each value is a list of integers representing the scores the student received on different assignments. Returns: dict: A dictionary where each key is a student\'s name and each value is the average score (float) of that student, rounded to two decimal places. averages = {} for student, scores in student_scores.items(): if not scores: raise ValueError(f\\"No scores provided for student {student}\\") averages[student] = round(sum(scores) / len(scores), 2) return averages"},{"question":"# Question Scenario You are tasked with creating a command-line utility that performs basic text processing operations. This tool should be able to read a file with a list of sentences, process the text data to remove any special characters, and count the frequency of each word in the cleaned text. The utility should then output the words and their frequencies in descending order of frequency. Task Write a Python function `process_text_file` that takes the path to a text file as input, processes the text, and returns a dictionary with words as keys and their frequency counts as values, ordered by frequency in descending order. Function Specification ```python def process_text_file(file_path): Processes the text file to remove special characters and count word frequencies. Args: file_path (str): The path to the text file to be processed. Returns: dict: A dictionary where keys are words and values are their frequency, sorted in descending order. ``` Constraints - The text file contains sentences with words separated by spaces and may include punctuation marks. - You must remove all punctuation marks and convert all words to lowercase to ensure proper counting. - Words should only contain letters and numbers. - The function should handle text files with sizes up to 10 MB efficiently. - Ignore any non-alphanumeric characters while processing. Example Consider a text file `example.txt` with the following content: ``` Hello World! This is a test. Hello, world? ``` Executing the function `process_text_file(\'example.txt\')` should return: ```python { \'hello\': 2, \'world\': 2, \'this\': 1, \'is\': 1, \'a\': 1, \'test\': 1 } ``` Performance Requirements - The function should ensure efficient processing for large text files up to 10 MB. - Memory usage should be optimized for typical personal computer capabilities.","solution":"import re from collections import Counter def process_text_file(file_path): Processes the text file to remove special characters and count word frequencies. Args: file_path (str): The path to the text file to be processed. Returns: dict: A dictionary where keys are words and values are their frequency, sorted in descending order. with open(file_path, \'r\', encoding=\'utf-8\') as file: text = file.read() # Remove all non-alphanumeric characters and convert to lowercase text = re.sub(r\'[^a-zA-Z0-9s]\', \'\', text).lower() words = text.split() word_counts = Counter(words) # Sort by frequency in descending order word_counts = dict(sorted(word_counts.items(), key=lambda item: item[1], reverse=True)) return word_counts"},{"question":"# Genetic Sequence Alignment Genetic researchers often need to compare DNA sequences to identify similarities and differences that could indicate functional, structural, or evolutionary relationships. One common computational method for comparing sequences is to find the Longest Common Subsequence (LCS). The LCS problem can be solved using dynamic programming. Write a function `longest_common_subsequence(seq1: str, seq2: str) -> str` that takes two DNA sequences and returns their longest common subsequence. **Requirements:** 1. Implement the function using dynamic programming. 2. The function should return the LCS as a string. 3. If there are multiple LCSs of the same length, return any one of them. 4. Consider sequences of varying lengths, including edge cases where one or both are empty strings. **Input:** * `seq1` (str): A DNA sequence consisting of characters \'A\', \'C\', \'G\', and \'T\'. * `seq2` (str): Another DNA sequence consisting of characters \'A\', \'C\', \'G\', and \'T\'. **Output:** * (str): The longest common subsequence. **Constraints:** * The length of each sequence is at most 1000 characters. * Handle potential edge cases where one or both sequences are empty. **Example:** ```python # Example usage: print(longest_common_subsequence(\\"ACGT\\", \\"ACGT\\")) # Output: \\"ACGT\\" print(longest_common_subsequence(\\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\", \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\")) # Output: \\"GTCGTCGGAAGCCGGCCGAA\\" ``` Implement your function carefully to ensure it scales with the given constraints and handles all outlined specifications effectively.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> str: Returns the longest common subsequence (LCS) of two given DNA sequences. m, n = len(seq1), len(seq2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Building the dp array for i in range(m): for j in range(n): if seq1[i] == seq2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) # Reconstructing the LCS from the dp array lcs = [] x, y = m, n while x > 0 and y > 0: if dp[x][y] == dp[x - 1][y]: x -= 1 elif dp[x][y] == dp[x][y - 1]: y -= 1 else: lcs.append(seq1[x - 1]) x -= 1 y -= 1 return \'\'.join(reversed(lcs))"},{"question":"# Question: Implement the Leaky ReLU Activation Function In this task, you will implement the Leaky Rectified Linear Unit (Leaky ReLU) activation function. The Leaky ReLU function is commonly used in neural networks to allow a small, non-zero gradient when the unit is not active. Mathematically, the Leaky ReLU function `f` for a given input `x` and parameter `alpha` is defined as: ``` f(x) = x, if x >= 0 f(x) = alpha * x, if x < 0 ``` Your task is to write a function that takes an array of real numbers and applies the Leaky ReLU function to each element of this array. Function Signature ```python def custom_leaky_relu(vector: List[float], alpha: float) -> List[float]: pass ``` Input - `vector` (List[float]): A list of K real numbers. - `alpha` (float): A small non-negative real number used as a hyper-parameter for the Leaky ReLU function. Output - A list of K real numbers after applying the Leaky ReLU function. Constraints - The length of the vector can be between 1 and (10^6). - The value of each element in the vector is a real number that fits in the standard floating-point precision. - Alpha is a non-negative real number, typically between 0 and 1. Examples ```python >>> custom_leaky_relu([2.3, 0.6, -2, -3.8], 0.01) [2.3, 0.6, -0.02, -0.038] >>> custom_leaky_relu([-9.2, -0.3, 0.45, -4.56], 0.02) [-0.184, -0.006, 0.45, -0.0912] ``` Notes - Be aware of numerical precision and operations, particularly for small values of `alpha`. - Handle edge cases such as very large/small values correctly. - Ensure your solution is optimized for large `vector` sizes up to (10^6) entries. - The parameter `alpha` is usually a small positive value like 0.01 or 0.02.","solution":"from typing import List def custom_leaky_relu(vector: List[float], alpha: float) -> List[float]: Apply the Leaky ReLU function to each element of the input vector. Parameters: vector (List[float]): A list of real numbers. alpha (float): A small non-negative real number used as a hyper-parameter for the Leaky ReLU function. Returns: List[float]: A list of real numbers after applying the Leaky ReLU function. return [x if x >= 0 else alpha * x for x in vector]"},{"question":"# Objective Write a function to locate the cycle in a given linked list, if it exists, and identify the node where the cycle begins. # Specifications * **Function Name**: find_cycle_start * **Input**: * `head` (ListNode): The head node of the linked list. * **Output**: * (ListNode): The node where the cycle starts; if there\'s no cycle, return `None`. # Constraints * The number of nodes in the linked list will not exceed 10^4. * Each node will have a unique Node ID (which can be used for comparison). # Data Structure Definition ```python class ListNode: def __init__(self, x): self.val = x self.next = None ``` # Example ```python def find_cycle_start(head: ListNode) -> ListNode: # Your implementation goes here # Example Usage # Creating a linked list with a cycle node_a = ListNode(3) node_b = ListNode(2) node_c = ListNode(0) node_d = ListNode(-4) node_a.next = node_b node_b.next = node_c node_c.next = node_d node_d.next = node_b # Cycle starts at node_b print(find_cycle_start(node_a)) # Output: node_b # Creating a linked list without a cycle node_x = ListNode(1) node_y = ListNode(9) node_z = ListNode(8) node_x.next = node_y node_y.next = node_z print(find_cycle_start(node_x)) # Output: None ``` # Additional Notes 1. Use Floyd\'s Tortoise and Hare algorithm to detect the cycle and find the start node. 2. Ensure the function handles edge cases such as empty linked lists and single-node lists without cycles.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: ListNode) -> ListNode: if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, now find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"# Problem Statement Write a function that takes a list of integers as input and returns the length of the longest contiguous subarray with an equal number of 0s and 1s. The function should be optimized to handle large input sizes efficiently. # Function Signature ```python def longest_balanced_subarray(arr: List[int]) -> int: ``` # Input * `arr` (1 <= len(arr) <= 10^5): A list of integers where each integer is either 0 or 1. # Output * Returns an integer representing the length of the longest contiguous subarray with equal numbers of 0s and 1s. # Explanation * This task assesses your ability to handle large arrays and efficiently determine subarray properties using concepts such as prefix sums and hash maps. * The function should manage all edge cases and large inputs without significant performance degradation. # Example ```python >>> longest_balanced_subarray([0, 1, 0, 1, 0, 1]) 6 >>> longest_balanced_subarray([0, 1, 1, 0, 1, 0, 0]) 6 >>> longest_balanced_subarray([0, 0, 1, 1, 0]) 4 ``` # Constraints * The function must be optimized for large input sizes, operating with time complexity better than O(n^2) where possible. # Hints * Utilize prefix sums to keep track of the difference between the counts of 0s and 1s. * Employ a hash map to quickly look up previous occurrences of the same difference.","solution":"def longest_balanced_subarray(arr): Returns the length of the longest contiguous subarray with equal numbers of 0s and 1s. # Convert all 0s to -1 for easier calculations arr = [-1 if x == 0 else 1 for x in arr] # This dictionary will store the first occurrence of each prefix sum sum_index_map = {} max_len = 0 prefix_sum = 0 for i in range(len(arr)): prefix_sum += arr[i] # If prefix sum is 0, we found a balanced subarray from start to i if prefix_sum == 0: max_len = i + 1 if prefix_sum in sum_index_map: max_len = max(max_len, i - sum_index_map[prefix_sum]) else: sum_index_map[prefix_sum] = i return max_len"},{"question":"# Array Manipulation and Query You are asked to perform operations on an array based on a series of queries. The goal is to ensure efficient handling of the operations while adhering to the constraints. # Objectives: - Implement a function `process_queries()` that takes an integer array `arr` and a list of queries `queries`. Each query modifies the array in a specific way or retrieves information from it. # Query Types: 1. `1 x y`: Increment the element at index `x` by `y`. 2. `2 x`: Retrieve and return the value of the element at index `x`. 3. `3 l r`: Compute and return the sum of elements in the inclusive range `[l, r]`. # Function Signature: ```python def process_queries(arr: list, queries: list) -> list: pass ``` # Input: - An integer array `arr` with up to 100,000 elements and integer values. - A list of queries `queries` where each query is a tuple indicating the operation and its parameters. # Output: - A list containing the results of all type `2` and `3` queries in the order they appear. # Constraints: - The array elements and query values are within the range of 32-bit signed integers. - The number of queries can be up to 100,000. - There is always at least one query of type `2` or `3`. # Example: ```python arr = [0, 1, 2, 3, 4] queries = [(1, 1, 3), (2, 1), (3, 0, 3), (1, 0, -1), (2, 0)] result = process_queries(arr, queries) # Expected Output: # [4, 9, -1] ``` # Notes: - **Optimization**: For the query type `3`, consider using a prefix sum array or another efficient approach to ensure optimal performance. - Ensure that your implementation handles updates and retrieve operations efficiently. Submit your implementation of `process_queries()` along with a few test cases demonstrating its correctness and efficiency.","solution":"def process_queries(arr, queries): prefix_sum = [0] * (len(arr) + 1) def update_prefix_sum(): for i in range(1, len(arr) + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] update_prefix_sum() results = [] for query in queries: if query[0] == 1: x, y = query[1], query[2] arr[x] += y update_prefix_sum() elif query[0] == 2: x = query[1] results.append(arr[x]) elif query[0] == 3: l, r = query[1], query[2] sum_range = prefix_sum[r + 1] - prefix_sum[l] results.append(sum_range) return results"},{"question":"# Problem Statement You are given a list of unsorted integers `arr` and an integer `k`. Your task is to implement a function `quickselect` that finds the `k`-th smallest element in the list using the Quickselect algorithm (a selection algorithm to find the kth smallest element in an unordered list). # Function Signature ```python def quickselect(arr: list[int], k: int) -> int: pass ``` # Input * `arr` (list[int]): The unsorted list of integers. * `k` (int): The position (1-based index) of the smallest element you wish to find in the list. # Output * An integer representing the `k`-th smallest element in the list. # Constraints * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i] <= 10^9` * `1 <= k <= len(arr)` # Example ```python arr = [10, 4, 5, 8, 6, 11, 26] print(quickselect(arr, 3)) # Output: 6 arr = [3, 2, 1, 5, 4] print(quickselect(arr, 1)) # Output: 1 arr = [7, 10, 4, 3, 20, 15] print(quickselect(arr, 4)) # Output: 10 ``` # Explanation - In the first example, the sorted array is `[4, 5, 6, 8, 10, 11, 26]`, and the 3rd smallest element is `6`. - In the second example, the sorted array is `[1, 2, 3, 4, 5]`, and the 1st smallest element is `1`. - In the third example, the sorted array is `[3, 4, 7, 10, 15, 20]`, and the 4th smallest element is `10`. Implement the `quickselect` function to efficiently find and return the `k`-th smallest element in the list.","solution":"def quickselect(arr: list[int], k: int) -> int: Returns the k-th smallest element in the list using the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): Returns the k-th smallest element of the list within left..right. if left == right: # If the list contains only one element, return arr[left] # return that element # select a random pivot_index between pivot_index = left + (right - left) // 2 # find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) # the pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] # go left elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) # go right else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"# Maze Path Finder: **Question:** Given a `n x n` grid representing a maze, find the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, n-1)` avoiding all obstacles. Write a function `shortest_path(maze: List[List[int]]) -> List[Tuple[int, int]]` to solve this problem. **Function Definition:** ```python def shortest_path(maze: List[List[int]]) -> List[Tuple[int, int]]: # Your code here ``` **Input:** - `maze` (List[List[int]]): A 2D list representing the maze, where `0` indicates an open cell and `1` indicates an obstacle. **Output:** - Returns a list of tuples representing the coordinates of the shortest path from `(0, 0)` to `(n-1, n-1)` inclusive. If there\'s no path, return an empty list. **Constraints:** - The maze is square-shaped with `n` x `n` dimensions. - `0 < n <= 10`. - It is guaranteed that both the starting cell `(0, 0)` and the ending cell `(n-1, n-1)` are open (i.e., `0`). **Example:** ```python maze = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0] ] print(shortest_path(maze)) # Output (one possible shortest path): # [(0, 0), (0, 1), (1, 1), (2, 0), (2, 1), (2, 2), (3, 2), (3, 3)] ``` **Explanation:** - The function should navigate through the open cells (`0`s) and avoid the obstacles (`1`s) to find the shortest path from the top-left corner to the bottom-right corner of the maze. - The returned path is a sequence of cell coordinates that denotes the moves required to reach the destination. Develop your function in a way that it handles different configurations of obstacles efficiently, ensuring it finds the shortest path or determines there is no path within practical time limits for the given constraints.","solution":"from collections import deque from typing import List, Tuple def shortest_path(maze: List[List[int]]) -> List[Tuple[int, int]]: n = len(maze) if n == 0: return [] # Directions for right, down, left, up movements directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue for BFS queue = deque([(0, 0, [(0, 0)])]) visited = set((0, 0)) while queue: x, y, path = queue.popleft() if (x, y) == (n-1, n-1): return path for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and maze[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + [(nx, ny)])) return []"},{"question":"# Question **Context**: In the field of competitive programming, understanding the concept of prime numbers and their applications is crucial. Prime numbers play a significant role in various algorithms and problem-solving techniques. **Task**: You are tasked with writing a function that finds the largest prime factor of a given number. The function should be efficient, especially for larger values of the input. **Function Signature**: ```python def largest_prime_factor(num: int) -> int: pass ``` **Input**: * An integer `num` such that ( num geq 2 ). **Output**: * An integer that represents the largest prime factor of the given number. **Constraints**: 1. ( 2 leq num leq 10^12 ). **Requirements**: 1. Your implementation should handle invalid inputs gracefully, raising appropriate errors. 2. Optimize performance to handle the upper limit of the constraints effectively. **Example**: ```python >>> largest_prime_factor(17) 17 >>> largest_prime_factor(56) 7 >>> largest_prime_factor(77) 11 ``` Explanation: 1. The number `17` is a prime number itself, so its largest prime factor is `17`. 2. The number `56` has prime factors `2, 2, 2, 7`; the largest prime factor is `7`. 3. The number `77` has prime factors `7, 11`; the largest prime factor is `11`. **Edge cases to consider**: * Handling non-integer and negative inputs. * Ensuring the function efficiently finds prime factors for very large input values. **Hints**: - Utilize the concept of prime factorization and trial division. - Consider optimization techniques like the Sieve of Eratosthenes or Pollard\'s rho algorithm for handling very large numbers.","solution":"def largest_prime_factor(num: int) -> int: Returns the largest prime factor of the given number. if not isinstance(num, int) or num < 2: raise ValueError(\\"Input must be an integer greater than or equal to 2.\\") def _max_prime_factor(n): max_prime = -1 # Divide n by 2 to remove all even factors while n % 2 == 0: max_prime = 2 n //= 2 # Remove any odd factors for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: max_prime = i n //= i # If n is still greater than 2, then it must be a prime number if n > 2: max_prime = n return max_prime return _max_prime_factor(num)"},{"question":"# Coding Assessment Question: Multi-Restaurant Order Processing System **Context:** You are developing an order management system for a food delivery service that collaborates with multiple restaurants. Each restaurant has its own menu, and the system must efficiently manage orders placed by customers, ensuring accurate processing and distribution to the respective restaurants. # Task: Implement a suite of functions to handle restaurant menus, customer orders, and order distribution. # Specifications: 1. **Function 1: Storing the Restaurant Menus** ```python def store_menu(restaurant_name: str, menu: dict[str, float]): ``` - **Input**: `restaurant_name` (str) - Name of the restaurant; `menu` (dict[str, float]) - Dictionary mapping dish names to their prices. - **Output**: None - **Constraints**: - Restaurant names are unique. - If a menu for the restaurant already exists, it should be updated. - Dish names are unique within a restaurant\'s menu. 2. **Function 2: Placing an Order** ```python def place_order(restaurant_name: str, order_items: dict[str, int]) -> float: ``` - **Input**: `restaurant_name` (str) - Name of the restaurant; `order_items` (dict[str, int]) - Dictionary mapping dish names to the quantity ordered. - **Output**: Total cost of the order (float). - **Constraints**: - Order must only contain items that exist in the restaurant\'s menu. - If the restaurant or any dish in the order does not exist, raise an appropriate error. 3. **Function 3: Fetching All Orders for a Restaurant** ```python def fetch_orders(restaurant_name: str) -> list[dict[str, int]]: ``` - **Input**: `restaurant_name` (str) - Name of the restaurant. - **Output**: List of orders, where each order is represented as a dictionary of dish names to quantities. - **Constraints**: - If the restaurant does not exist, return an empty list. # Example Usage: ```python # Define restaurant menus store_menu(\\"Pizza Place\\", {\\"Margherita\\": 8.99, \\"Pepperoni\\": 9.99, \\"Hawaiian\\": 10.99}) store_menu(\\"Burger Joint\\", {\\"Cheeseburger\\": 6.99, \\"Vegan Burger\\": 7.99}) # Place orders total_cost_1 = place_order(\\"Pizza Place\\", {\\"Margherita\\": 2, \\"Pepperoni\\": 1}) print(total_cost_1) # Output: 27.97 total_cost_2 = place_order(\\"Burger Joint\\", {\\"Cheeseburger\\": 3}) print(total_cost_2) # Output: 20.97 # Fetch all orders for a restaurant orders_pizza_place = fetch_orders(\\"Pizza Place\\") print(orders_pizza_place) # Output: [{\'Margherita\': 2, \'Pepperoni\': 1}] orders_burger_joint = fetch_orders(\\"Burger Joint\\") print(orders_burger_joint) # Output: [{\'Cheeseburger\': 3}] ``` # Performance Requirements: - Solutions should aim for optimal performance, particularly for managing large menus and high volume of orders. - Ensure all errors are handled gracefully, such as non-existent restaurants or dishes. # Testing: - Write unit tests to validate your implementation against various scenarios, including edge cases and typical workflows. - Verify the correctness of total cost calculations and the accuracy of orders fetched per restaurant. Good luck!","solution":"restaurant_menus = {} restaurant_orders = {} def store_menu(restaurant_name: str, menu: dict): restaurant_menus[restaurant_name] = menu restaurant_orders[restaurant_name] = [] def place_order(restaurant_name: str, order_items: dict) -> float: if restaurant_name not in restaurant_menus: raise ValueError(\\"Restaurant does not exist\\") menu = restaurant_menus[restaurant_name] total_cost = 0.0 for item, quantity in order_items.items(): if item not in menu: raise ValueError(f\\"Item \'{item}\' does not exist in the menu of {restaurant_name}\\") total_cost += menu[item] * quantity restaurant_orders[restaurant_name].append(order_items) return total_cost def fetch_orders(restaurant_name: str) -> list: if restaurant_name not in restaurant_orders: return [] return restaurant_orders[restaurant_name]"},{"question":"# Question: Employee Salary Adjustment System You are tasked with designing a utility function to adjust employee salaries based on performance metrics. The function takes in a list of tuples, where each tuple represents an employee\'s current salary and their performance rating. The performance rating is an integer between 1 and 5. The function will apply a salary adjustment based on the performance rating: - Performance rating 1 decreases the salary by 5% - Performance rating 2 leaves the salary unchanged - Performance rating 3 increases the salary by 5% - Performance rating 4 increases the salary by 10% - Performance rating 5 increases the salary by 20% Function Signature: ```python def adjust_salaries(employees: list) -> list: Adjusts employee salaries based on their performance ratings. Args: employees (list): A list of tuples where each tuple contains an employee\'s current salary (float) and their performance rating (int). Returns: list: A new list of adjusted salaries (floats) in the same order as the input list. Raises: ValueError: If any performance rating is not between 1 and 5 (inclusive). ``` Input & Output Formats: - **Input**: A list of tuples. Each tuple contains: - a float representing the employee’s current salary - an integer representing the employee’s performance rating (1-5). - **Output**: A list of floats representing the adjusted salaries. Constraints: - The list of employees will contain at least one entry. - Salaries are positive numbers. - Performance ratings are integers between 1 and 5, inclusive. - If a rating is outside this range, raise a `ValueError` with the message \\"Invalid performance rating.\\" Sample Usage: ```python employees = [ (50000.0, 3), (60000.0, 5), (45000.0, 2), (52000.0, 4), (48000.0, 1) ] adjusted_salaries = adjust_salaries(employees) print(adjusted_salaries) # Expected output: [52500.0, 72000.0, 45000.0, 57200.0, 45600.0] ``` **Notes**: Each adjustment should be calculated independently and in sequence based on the given performance ratings. The results should directly correspond to the input order.","solution":"def adjust_salaries(employees: list) -> list: Adjusts employee salaries based on their performance ratings. Args: employees (list): A list of tuples where each tuple contains an employee\'s current salary (float) and their performance rating (int). Returns: list: A new list of adjusted salaries (floats) in the same order as the input list. Raises: ValueError: If any performance rating is not between 1 and 5 (inclusive). adjusted_salaries = [] adjustment_factors = { 1: -0.05, 2: 0.0, 3: 0.05, 4: 0.10, 5: 0.20 } for salary, rating in employees: if rating not in adjustment_factors: raise ValueError(\\"Invalid performance rating\\") adjustment = salary * adjustment_factors[rating] adjusted_salary = salary + adjustment adjusted_salaries.append(adjusted_salary) return adjusted_salaries"},{"question":"# Maximal Consecutive Ones Length **Problem Statement**: You are tasked with writing a function that computes the maximum length of consecutive `1`s in a binary list. Your function should iterate through the list and determine the longest sequence of continuous `1`s. **Function Signature**: ```python def max_consecutive_ones(binary_list: list) -> int: pass ``` **Requirements**: 1. The function should iterate through the binary list and count the maximum number of consecutive `1`s. 2. If the list is empty, the function should return `0`. 3. The function should properly handle lists containing only `0`s. 4. The binary list will only contain integers `0` and `1`. **Input**: * `binary_list` (list): A list of integers that contains only `0` and `1`. **Output**: * `int`: The length of the longest sequence of consecutive `1`s. **Constraints**: * The length of `binary_list` will be in the range [0, 10^5]. **Examples**: ```python >>> max_consecutive_ones([1, 1, 0, 1, 1, 1]) 3 >>> max_consecutive_ones([1, 0, 1, 0, 1]) 1 >>> max_consecutive_ones([0, 0, 0, 0]) 0 >>> max_consecutive_ones([]) 0 >>> max_consecutive_ones([1, 1, 1, 1, 1, 1]) 6 >>> max_consecutive_ones([1]) 1 ``` **Note**: - Ensure the function is efficient, considering the constraints provided.","solution":"def max_consecutive_ones(binary_list): Returns the maximum length of consecutive 1s in the binary list. :param binary_list: List[int] - A list of binary integers (0 and 1) :return: int - The length of the longest sequence of consecutive 1s max_count = 0 current_count = 0 for num in binary_list: if num == 1: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count"},{"question":"Context A software company wants you to help them analyze user activity logs from their application. Each log entry contains a timestamp and a user action. Your task is to create a function that processes these logs to identify patterns and perform specific analyses. Requirements Write a function, `process_activity_logs`, based on the following specifications: # Function: process_activity_logs **Input**: - `logs`: A list of tuples where each tuple contains: - A string representing a timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". - A string representing a user action (e.g., \\"login\\", \\"logout\\", \\"purchase\\"). **Output**: - Returns a dictionary where the keys are user actions and the values are lists of timestamps (in ascending order) when those actions occurred. **Constraints**: - The `logs` list can contain up to 10,000 log entries. - Timestamps are provided in a 24-hour format and are guaranteed to be valid. - Each user action is a non-empty string. Example Usage ```python logs = [ (\\"2023-10-21 12:05:00\\", \\"login\\"), (\\"2023-10-21 12:10:00\\", \\"purchase\\"), (\\"2023-10-21 12:15:00\\", \\"logout\\"), (\\"2023-10-21 12:20:00\\", \\"login\\"), (\\"2023-10-21 12:25:00\\", \\"purchase\\") ] result = { \\"login\\": [\\"2023-10-21 12:05:00\\", \\"2023-10-21 12:20:00\\"], \\"purchase\\": [\\"2023-10-21 12:10:00\\", \\"2023-10-21 12:25:00\\"], \\"logout\\": [\\"2023-10-21 12:15:00\\"] } assert process_activity_logs(logs) == result ``` Make sure to handle edge cases and maintain proper ordering of the timestamps.","solution":"def process_activity_logs(logs): Processes user activity logs to categorize timestamps by user actions. Parameters: logs (list of tuples): Each tuple contains a timestamp (str) and a user action (str). Returns: dict: Dictionary where keys are user actions and values are lists of timestamps (in ascending order) when those actions occurred. from collections import defaultdict # Initialize a dictionary to store lists of timestamps for each action action_dict = defaultdict(list) # Populate the dictionary with timestamps for each action for timestamp, action in logs: action_dict[action].append(timestamp) # Sort the timestamps for each action for action in action_dict: action_dict[action].sort() return dict(action_dict)"},{"question":"# Question: Anomaly Detection using k-Nearest Neighbors As part of a machine learning project, you are tasked with developing an anomaly detection system using the k-Nearest Neighbors (k-NN) algorithm. Your goal is to implement a function that detects anomalies in a dataset and returns the indices of the detected anomalies. # Function Requirements k-Nearest Neighbors Anomaly Detection: - **Function Name**: `knn_anomaly_detection` - **Parameters**: - `data` (ndarray): A 2D NumPy array of shape (n_samples, n_features) representing the dataset. - `k` (int): The number of nearest neighbors to consider. - `threshold` (float): The distance threshold above which a sample is considered an anomaly. - **Returns**: - A 1D NumPy array of indices representing the samples detected as anomalies. # Constraints - `data` array will always be non-empty and contain real numbers. - `k` will always be a positive integer, with `k < n_samples`. - `threshold` will always be a positive float. - Use only NumPy and SciPy libraries; any other dependency will cause the solution to be rejected. # Performance Requirements - The function should be optimized to handle up to `n_samples = 10000` and `n_features = 100` efficiently. # Example Given the `data` as shown below: ```python data = np.array([[1.0, 2.0], [1.1, 2.1], [1.2, 2.2], [10.0, 10.0], [10.1, 10.1]]) k = 2 threshold = 5.0 ``` **Example Call**: ```python anomalies = knn_anomaly_detection(data, k, threshold) ``` **Example Output**: ```python array([3, 4]) ``` Write your implementation for the `knn_anomaly_detection` function.","solution":"import numpy as np from scipy.spatial import distance def knn_anomaly_detection(data, k, threshold): Detect anomalies using k-Nearest Neighbors. Parameters: - data (ndarray): A 2D NumPy array of shape (n_samples, n_features). - k (int): The number of nearest neighbors to consider. - threshold (float): The distance threshold above which a sample is considered an anomaly. Returns: - A 1D NumPy array of indices representing the samples detected as anomalies. n_samples = data.shape[0] anomalies = [] # Compute distances between each point and all other points dist_matrix = distance.cdist(data, data, \'euclidean\') for i in range(n_samples): # Sort distances for the current point and exclude the zero distance (self-distance) sorted_dists = np.sort(dist_matrix[i])[1:k+1] # If the average distance to the k nearest neighbors exceeds the threshold, mark it as an anomaly if np.mean(sorted_dists) > threshold: anomalies.append(i) return np.array(anomalies)"},{"question":"Scenario You are working with time-series data from a weather station that records temperature readings every hour. Your task is to identify and analyze periods of constant temperature. Specifically, you need to find the longest sequence of consecutive hourly readings where the temperature remains the same, and return the length of this sequence along with the temperature value during that period. # Question Write a function `longest_constant_temperature` that accepts a list of temperature readings and performs the following tasks: 1. Find the longest sequence of consecutive hourly readings where the temperature remains constant. 2. Return the temperature value and the length of this sequence. # Input * A list of integers representing temperature readings (e.g., `[30, 30, 28, 28, 28, 32, 32, 32, 32, 25, 25]`). # Output * A tuple where the first element is an integer representing the temperature value and the second element is an integer representing the length of the longest sequence of constant temperature. # Constraints 1. The list will contain up to (10^5) elements. 2. Each temperature reading is an integer between (-100) and (100). # Example ```python longest_constant_temperature([30, 30, 28, 28, 28, 32, 32, 32, 32, 25, 25]) # Output: (32, 4) longest_constant_temperature([15, 15, 15, 18, 18, 22]) # Output: (15, 3) longest_constant_temperature([25]) # Output: (25, 1) ``` # Notes * If there are multiple sequences with the same longest length, return the temperature of the first occurring sequence. * The function must handle empty lists by raising a `ValueError`. # Function Signature ```python def longest_constant_temperature(readings: list) -> tuple: pass ```","solution":"def longest_constant_temperature(readings): if not readings: raise ValueError(\\"The list of readings must not be empty\\") max_length = 1 current_length = 1 max_temp = readings[0] current_temp = readings[0] for i in range(1, len(readings)): if readings[i] == current_temp: current_length += 1 else: if current_length > max_length: max_length = current_length max_temp = current_temp current_temp = readings[i] current_length = 1 if current_length > max_length: max_length = current_length max_temp = current_temp return (max_temp, max_length)"},{"question":"# List Intersection **Objective**: Implement a function that finds the intersection of two lists, returning the common elements without duplicates. **Function Signature**: ```python def find_intersection(list1: list, list2: list) -> list: Finds the intersection of two lists, returning a list of unique common elements. Args: list1 (list): The first list of elements. list2 (list): The second list of elements. Returns: list: A list containing unique elements present in both lists. ``` **Input**: - Two lists, `list1` and `list2`, each containing elements (0 ≤ len(list1), len(list2) ≤ 10^5). **Output**: - A list containing the unique elements that are present in both `list1` and `list2`. **Constraints**: - Lists can contain any data type (but elements will be comparable). - Elements in the output list should be unique and appear in the order they first appeared in `list1`. **Example**: ```python list1 = [1, 2, 2, 3, 4] list2 = [3, 4, 4, 5] result = find_intersection(list1, list2) # Expected Output: [3, 4] ``` **Scenario**: You are developing a feature in a data analysis tool that requires comparing two datasets and identifying common entries. This function will aid in filtering out the entries present in both datasets without duplications, ensuring the returned list maintains the order of appearance from the first dataset. **Performance Requirement**: - The solution should efficiently handle the input size up to the specified limit within a reasonable runtime and memory usage. **Testing**: 1. Given two lists with multiple duplicate values to ensure duplicates are properly removed. 2. Lists containing different data types to check type handling. 3. Lists that have no common elements to return an empty list. 4. Large lists to test performance within constraints.","solution":"def find_intersection(list1, list2): Finds the intersection of two lists, returning a list of unique common elements. Args: list1 (list): The first list of elements. list2 (list): The second list of elements. Returns: list: A list containing unique elements present in both lists. set2 = set(list2) # Convert list2 to a set for O(1) lookups seen = set() # To track seen elements to ensure no duplicates in result result = [] for item in list1: if item in set2 and item not in seen: result.append(item) seen.add(item) return result"},{"question":"# Coding Assessment Question **Scenario**: In the realm of data structures, arrays and linked lists are fundamental components used to store collections of data. Efficiently manipulating these data structures to perform various operations is crucial for developing robust applications. Performing operations like merging arrays, rotating arrays, reversing linked lists, and detecting loops in linked lists are common tasks in many programming challenges. **Problem Statement**: You are required to implement multiple operations on arrays and singly linked lists. Design the following functions in Python: 1. `rotate_array(arr: list, k: int) -> list`: This function rotates the given array `arr` to the right by `k` steps. 2. `merge_sorted_arrays(arr1: list, arr2: list) -> list`: This function merges two sorted arrays `arr1` and `arr2` into a single sorted array. 3. `reverse_linked_list(head: ListNode) -> ListNode`: This function reverses a singly linked list. 4. `detect_loop(head: ListNode) -> bool`: This function checks if there is a loop in a singly linked list. # Function Signatures ```python def rotate_array(arr: list, k: int) -> list: pass def merge_sorted_arrays(arr1: list, arr2: list) -> list: pass class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: pass def detect_loop(head: ListNode) -> bool: pass ``` # Input and Output Format * **Input**: * `arr` (list): An array to be rotated. * `k` (int): The number of steps to rotate the array to the right. * `arr1` (list): A sorted array. * `arr2` (list): Another sorted array. * `head` (ListNode): The head node of a singly linked list. * **Output**: * `rotate_array` returns a list after rotating the array to the right by `k` steps. * `merge_sorted_arrays` returns a list containing elements from both arrays, sorted in non-decreasing order. * `reverse_linked_list` returns the head node of the reversed linked list. * `detect_loop` returns a boolean indicating whether there is a loop in the singly linked list. # Constraints * `arr` can be any list of integers, with length between 0 and 10^4. * 0 ≤ `k` < 10^4. * Both `arr1` and `arr2` are sorted and can have lengths between 0 and 10^4. * `head` can be `None` or a linked list with length between 0 and 10^4. # Example ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] # Example for linked list operations: # Initial List: 1 -> 2 -> 3 -> 4 -> 5 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) reversed_head = reverse_linked_list(head) # Reversed List: 5 -> 4 -> 3 -> 2 -> 1 loop_head = ListNode(1) loop_head.next = ListNode(2) loop_head.next.next = ListNode(3) loop_head.next.next.next = loop_head # Creates a loop assert detect_loop(loop_head) == True no_loop_head = ListNode(1) no_loop_head.next = ListNode(2) no_loop_head.next.next = ListNode(3) assert detect_loop(no_loop_head) == False ``` Implement these functions ensuring to handle edge cases such as empty lists and single element lists.","solution":"def rotate_array(arr: list, k: int) -> list: n = len(arr) k = k % n if n else 0 return arr[-k:] + arr[:-k] def merge_sorted_arrays(arr1: list, arr2: list) -> list: merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None curr = head while curr is not None: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev def detect_loop(head: ListNode) -> bool: slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# **Find the Largest Number in a List** Write a function `find_largest_number(number_list: list[int]) -> int` that finds and returns the largest number in a given list of integers. For this task: 1. **Input:** - `number_list`: A list containing integers. 2. **Output:** - A single integer which is the largest number in the `number_list`. 3. **Constraints:** - `number_list` contains at least one integer. - All elements in `number_list` are valid integers. 4. **Handling Errors:** - If `number_list` contains non-integer elements, raise a `ValueError` with the message `\\"All elements in number_list must be integers\\"`. # Example Usage ```python >>> find_largest_number([3, 1, 4, 1, 5, 9]) 9 >>> find_largest_number([-7, -1, -3, -4, -2]) -1 >>> find_largest_number([10]) 10 >>> find_largest_number([\\"a\\", 2, 3]) Traceback (most recent call last): ... ValueError: All elements in number_list must be integers ``` Note that you should handle possible edge cases and ensure the function is efficient for larger input sizes.","solution":"def find_largest_number(number_list: list[int]) -> int: Returns the largest number in the given list of integers. Parameters: - number_list: list of integers Returns: - int: The largest integer in the list Raises: - ValueError: If any element in number_list is not an integer if not all(isinstance(item, int) for item in number_list): raise ValueError(\\"All elements in number_list must be integers\\") return max(number_list)"},{"question":"# Context An online platform aims to assist users in managing their daily tasks by organizing them into different priority levels. Users can add tasks with varying levels of priority and the system needs to find and report the three highest priority tasks. # Problem Statement Write a function `top_three_tasks(tasks: List[Tuple[str, int]]) -> List[str]` that takes in a list of tasks, where each task is represented as a tuple containing the task description and its priority level. The function should return a list containing the descriptions of the top three tasks with the highest priority. If there are fewer than three tasks, return the descriptions of all tasks sorted by priority. # Function Signature ```python def top_three_tasks(tasks: List[Tuple[str, int]]) -> List[str]: pass ``` # Input 1. `tasks` - a list of tuples, where each tuple consists of: - A string `task_desc` - the description of the task. - An integer `priority` - the priority of the task. # Output * A list of strings, each representing the description of the tasks with the highest priorities. The list should contain at most three elements. # Examples 1. `top_three_tasks([(\\"Task A\\", 2), (\\"Task B\\", 5), (\\"Task C\\", 3)])` should return `[\\"Task B\\", \\"Task C\\", \\"Task A\\"]`. 2. `top_three_tasks([(\\"Go for a walk\\", 1)])` should return `[\\"Go for a walk\\"]`. 3. `top_three_tasks([(\\"Task A\\", 1), (\\"Task B\\", 2), (\\"Task C\\", 3), (\\"Task D\\", 4)])` should return `[\\"Task D\\", \\"Task C\\", \\"Task B\\"]`. 4. `top_three_tasks([(\\"Read book\\", 2), (\\"Write code\\", 2), (\\"Test code\\", 2)])` should return `[\\"Read book\\", \\"Write code\\", \\"Test code\\"]`. # Constraints * Each task description will be a non-empty string with a maximum length of 100 characters. * The priority will be an integer value between 1 and 1000. * The length of the `tasks` list will be between 1 and 1000. # Notes * If two tasks have the same priority, they are returned in the same order as they appear in the input list. * Your solution should efficiently handle the sorting and retrieval of tasks to meet the specified constraints.","solution":"from typing import List, Tuple def top_three_tasks(tasks: List[Tuple[str, int]]) -> List[str]: # Sort tasks by priority in descending order, and then by the original order of appearance sorted_tasks = sorted(tasks, key=lambda x: x[1], reverse=True) # Extract only the top three tasks (if there are at least three) top_tasks = sorted_tasks[:3] # Return the descriptions of the top three tasks return [task[0] for task in top_tasks]"},{"question":"# Problem Context Working with data structures such as stacks is fundamental in understanding how to manage collections of elements, particularly for tasks that involve a Last-In-First-Out (LIFO) order. You are required to implement a stack and perform operations to reverse a string effectively. # Problem Statement Write a Python class `StringReverser` that uses a stack to reverse a given string. The class should implement functionality for basic stack operations and use those operations to reverse the input string. # Class Structure ```python class StringReverser: def __init__(self): Initialize an empty stack. def push(self, item: str) -> None: Push an item onto the stack. def pop(self) -> str: Pop an item off the stack. def reverse_string(self, s: str) -> str: Reverse the input string using the stack. ``` # Input - `s` (str): The string to be reversed. # Output - A string: The reversed string. # Constraints 1. The string can contain any printable ASCII characters. 2. The length of the input string `s` will not exceed 1000 characters. # Example ```python reverser = StringReverser() assert reverser.reverse_string(\\"hello\\") == \\"olleh\\" assert reverser.reverse_string(\\"12345\\") == \\"54321\\" assert reverser.reverse_string(\\"Stack\\") == \\"kcatS\\" ``` # Notes Ensure to implement the stack operations properly within the class and utilize them in the `reverse_string` method to demonstrate a clear understanding of the LIFO principle in stack operations.","solution":"class StringReverser: def __init__(self): Initialize an empty stack. self.stack = [] def push(self, item: str) -> None: Push an item onto the stack. self.stack.append(item) def pop(self) -> str: Pop an item off the stack. return self.stack.pop() if self.stack else None def reverse_string(self, s: str) -> str: Reverse the input string using the stack. for char in s: self.push(char) reversed_str = \\"\\" while self.stack: reversed_str += self.pop() return reversed_str"},{"question":"# Binary Search Tree (BST) Range Sum You are given a Binary Search Tree (BST) and two integers, `low` and `high`. Your task is to implement a function that computes the sum of all the node values in the BST that lie within the inclusive range `[low, high]`. Your implementation should make efficient use of the properties of the BST to avoid unnecessary traversal of nodes. 1. **`range_sum_BST(root: TreeNode, low: int, high: int) -> int`**: - Input: - `root`: the root node of the BST. - `low`: the lower bound of the range. - `high`: the upper bound of the range. - Output: - Return the sum of all node values in the BST that lie within the range `[low, high]`. # Constraints - The number of nodes in the BST is in the range [1, 10^4]. - `-10^4 ≤ Node.val ≤ 10^4`. - All TreeNode values are unique. - `root` is a valid BST. # Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) low = 7 high = 15 print(range_sum_BST(root, low, high)) # Output: 32 (7 + 10 + 15) ``` # Notes - Use the properties of a Binary Search Tree to optimize your traversal. - Plan and implement your function to handle edge cases, such as when `low` or `high` doesn\'t match any node values. - You may define additional helper functions if needed to achieve a clean and efficient solution. Ensure your implementation passes different test cases, including edge cases like a single node or a full range scan.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_BST(root: TreeNode, low: int, high: int) -> int: if not root: return 0 total_sum = 0 if low <= root.val <= high: total_sum += root.val if root.val > low: total_sum += range_sum_BST(root.left, low, high) if root.val < high: total_sum += range_sum_BST(root.right, low, high) return total_sum"},{"question":"# Context: You are working on a text processing system that needs to maintain the integrity of data formatting. One of the common tasks is to transform text by removing any leading and trailing whitespace characters, while ensuring that words within the text are separated by a single space. Additionally, multiple spaces between words should be reduced to a single space. Your task is to create a function that performs these transformations. # Problem Statement: Write a function `clean_text(text: str) -> str` that takes a string as input, removes any leading and trailing whitespace characters, and ensures that there is only one space between words within the text. If the input is not a string, the function should raise a `TypeError`. Input and Output Formats: * **Input**: A single argument `text` which is a string. * **Output**: A string with no leading or trailing whitespace and single spaces between words. Constraints and Limitations: * The input can be any string, including empty strings. * You should consider edge cases and validate the input. Example: ```python >>> clean_text(\\" Hello World \\") \'Hello World\' >>> clean_text(\\"Multiple spaces here\\") \'Multiple spaces here\' >>> clean_text(\\" Trailing and leading \\") \'Trailing and leading\' >>> clean_text(\\" \\") \'\' >>> clean_text(\\"\\") \'\' >>> clean_text(123) Traceback (most recent call last): ... TypeError: Input must be a string >>> clean_text([\\"a\\", \\"b\\"]) Traceback (most recent call last): ... TypeError: Input must be a string ``` # Performance Requirements: * The solution should ideally run in linear time complexity O(n) relative to the length of the input string due to scanning and transformations.","solution":"def clean_text(text): Cleans the input text by removing leading and trailing whitespace characters and ensuring that words within the text are separated by a single space. Raises a TypeError if the input is not a string. Parameters: - text (str): The input text to clean Returns: - str: The cleaned text if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") # Split the text by whitespace and rejoin with single space cleaned_text = \' \'.join(text.split()) return cleaned_text"},{"question":"# Task Write a function `double_pendulum_motion` that simulates the motion of a double pendulum system. The function should estimate the positions of the two pendulums over a specified duration using numerical integration. The angles of both pendulums from the vertical should be initialized at specified values. # Requirements 1. The double pendulum consists of two masses connected by rods of fixed lengths. The rods are massless and pivoted without friction. 2. The function must accept the following parameters: - `theta1`: initial angle of the first pendulum (in radians). - `theta2`: initial angle of the second pendulum (in radians). - `length1`: length of the rod of the first pendulum. - `length2`: length of the rod of the second pendulum. - `mass1`: mass of the first pendulum. - `mass2`: mass of the second pendulum. - `g`: acceleration due to gravity (default value: 9.81 m/s²). - `t0`: start time of the simulation (default: 0 seconds). - `tf`: end time of the simulation. - `dt`: time step for numerical integration. 3. The function should return the time series data for the angles `theta1` and `theta2` over the simulation period. 4. Implement the method using the Runge-Kutta 4th order (RK4) for numerical integration. 5. Use the following equations of motion for the double pendulum system: [ begin{align*} frac{d^2 theta_1}{dt^2} &= frac{-g(2m_1 + m_2)sin(theta_1) - m_2gsin(theta_1 - 2theta_2) - 2sin(theta_1 - theta_2)m_2(dot{theta_2}^2L2 + dot{theta_1}^2L1cos(theta_1 - theta_2))}{L1(2m_1 + m_2 - m_2cos(2theta_1 - 2theta_2))} frac{d^2 theta_2}{dt^2} &= frac{2sin(theta_1 - theta_2)(dot{theta_1}^2L1(m_1 + m_2) + g(m_1 + m_2)cos(theta_1) + dot{theta_2}^2L2m_2cos(theta_1 - theta_2))}{L2(2m_1 + m_2 - m_2cos(2theta_1 - 2theta_2))} end{align*} ] # Function Signature ```python def double_pendulum_motion(theta1: float, theta2: float, length1: float, length2: float, mass1: float, mass2: float, g: float = 9.81, t0: float = 0.0, tf: float, dt: float) -> (list, list): Simulate the motion of a double pendulum and return the time series data for the angles. Args: theta1: initial angle of the first pendulum (in radians). theta2: initial angle of the second pendulum (in radians). length1: length of the rod of the first pendulum. length2: length of the rod of the second pendulum. mass1: mass of the first pendulum. mass2: mass of the second pendulum. g: acceleration due to gravity (default 9.81). t0: start time of the simulation (default 0 seconds). tf: end time of the simulation. dt: time step for numerical integration. Returns: A tuple containing two lists: - The angles theta1 over time. - The angles theta2 over time. Example: >>> theta1_series, theta2_series = double_pendulum_motion(0.1, 0.2, 1.0, 1.0, 1.0, 1.0, tf=10, dt=0.01) >>> len(theta1_series) 1001 >>> len(theta2_series) 1001 >>> round(theta1_series[-1], 4) -0.2114 >>> round(theta2_series[-1], 4) -1.3785 pass ``` **Note**: Ensure the function handles edge cases and provides a stable and accurate representation of the double pendulum motion over time.","solution":"import numpy as np def double_pendulum_motion(theta1, theta2, length1, length2, mass1, mass2, g=9.81, t0=0.0, tf=10.0, dt=0.01): Simulate the motion of a double pendulum and return the time series data for the angles. Args: theta1: initial angle of the first pendulum (in radians). theta2: initial angle of the second pendulum (in radians). length1: length of the rod of the first pendulum. length2: length of the rod of the second pendulum. mass1: mass of the first pendulum. mass2: mass of the second pendulum. g: acceleration due to gravity (default 9.81). t0: start time of the simulation (default 0 seconds). tf: end time of the simulation. dt: time step for numerical integration. Returns: A tuple containing two lists: - The angles theta1 over time. - The angles theta2 over time. def derivatives(state, t): theta1, z1, theta2, z2 = state delta = theta2 - theta1 den1 = (mass1 + mass2) * length1 - mass2 * length1 * np.cos(delta) * np.cos(delta) den2 = (length2 / length1) * den1 dz1dt = ((mass2 * length1 * z1 * z1 * np.sin(delta) * np.cos(delta) + mass2 * g * np.sin(theta2) * np.cos(delta) + mass2 * length2 * z2 * z2 * np.sin(delta) - (mass1 + mass2) * g * np.sin(theta1)) / den1) dz2dt = ((-mass2 * length2 * z2 * z2 * np.sin(delta) * np.cos(delta) + (mass1 + mass2) * g * np.sin(theta1) * np.cos(delta) - (mass1 + mass2) * length1 * z1 * z1 * np.sin(delta) - (mass2 + (mass1 + mass2) * g * np.sin(theta2))) / den2) return np.array([z1, dz1dt, z2, dz2dt]) def rk4_step(state, t, dt): k1 = dt * derivatives(state, t) k2 = dt * derivatives(state + 0.5 * k1, t + 0.5 * dt) k3 = dt * derivatives(state + 0.5 * k2, t + 0.5 * dt) k4 = dt * derivatives(state + k3, t + dt) return state + (k1 + 2 * k2 + 2 * k3 + k4) / 6 t_values = np.arange(t0, tf + dt, dt) theta1_values = [] theta2_values = [] state = np.array([theta1, 0, theta2, 0]) for t in t_values: theta1_values.append(state[0]) theta2_values.append(state[2]) state = rk4_step(state, t, dt) return theta1_values, theta2_values"},{"question":"# Question: Bookstore Inventory Management You are responsible for managing the inventory of a bookstore. You need to implement two functionalities: one to add new books to the inventory and another to search for books based on certain criteria. Function 1: `add_book_to_inventory(inventory: list, book: dict) -> None` Implement a function that adds a new book to the inventory. Each book is represented by a dictionary with specific attributes. **Inputs:** * `inventory (list)`: A list of dictionaries where each dictionary represents a book. * `book (dict)`: A dictionary with the following keys: - `title (str)`: The title of the book. - `author (str)`: The author of the book. - `genre (str)`: The genre of the book. - `year (int)`: The year the book was published. **Outputs:** * `None`: No return value, the book is added to the inventory list. **Constraints:** * All books have unique titles. * Each attribute in the book dictionary is mandatory and must be in the correct format. Input Example: ```python inventory = [] book = {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949} ``` Output Example: ```python # The inventory will be updated to: [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949}] ``` Function 2: `search_books(inventory: list, search_criteria: dict) -> list` Implement a function that searches for books in the inventory based on given criteria. The criteria will be provided as a dictionary. **Inputs:** * `inventory (list)`: A list of dictionaries representing the books in the inventory. * `search_criteria (dict)`: A dictionary where the keys are the attributes to search by (`title`, `author`, `genre`, or `year`) and the values are the values to match. **Outputs:** * `list`: A list of dictionaries representing the books that match the search criteria. **Constraints:** * All keys in `search_criteria` must be valid book attribute keys. * Matching should be case-insensitive for string attributes and exact match for year. * If `search_criteria` is empty, return all books in the inventory. Input Example: ```python inventory = [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Classic\\", \\"year\\": 1925} ] search_criteria = {\\"author\\": \\"George Orwell\\"} ``` Output Example: ```python [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949} ] ``` # Requirements 1. Ensure the functions handle edge cases such as adding books with missing attributes or searching with invalid criteria. 2. The search function should return results efficiently, even with large inventories. 3. Implement proper validation for adding books to avoid duplicates based on titles. Examples Example 1: ```python >>> inventory = [] >>> add_book_to_inventory(inventory, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949}) >>> inventory [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949}] ``` Example 2: ```python >>> inventory = [ ... {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949}, ... {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Classic\\", \\"year\\": 1925} ... ] >>> search_books(inventory, {\\"genre\\": \\"Classic\\"}) [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Classic\\", \\"year\\": 1925}] ```","solution":"def add_book_to_inventory(inventory, book): Adds a new book to the inventory. :param inventory: List of dictionaries representing the books in the inventory. :param book: A dictionary with keys \'title\', \'author\', \'genre\', and \'year\'. # Check if a book with the same title already exists for item in inventory: if item[\'title\'].lower() == book[\'title\'].lower(): raise ValueError(\\"A book with this title already exists in the inventory.\\") # Add the new book to the inventory inventory.append(book) def search_books(inventory, search_criteria): Searches for books in the inventory based on the given criteria. :param inventory: List of dictionaries representing the books in the inventory. :param search_criteria: A dictionary with the search attributes and their values. :return: List of dictionaries representing the books that match the search criteria. results = [] for book in inventory: match = True for key, value in search_criteria.items(): if isinstance(value, str): if book[key].lower() != value.lower(): match = False break else: if book[key] != value: match = False break if match: results.append(book) return results"},{"question":"# Array Transformation – Value Shifter Context You are developing a data processing library that can effectively handle various transformations on numerical data stored in arrays. One commonly needed transformation is shifting all elements of an array either to the left or right by a specified number of positions, wrapping around elements as necessary. Problem Statement You need to implement a function to shift the elements of an array either to the left or right by a specified number of positions. # Task Implement a function `shift_array(arr: list[int], direction: str, positions: int) -> list[int]` that shifts the elements of the array in the specified direction by the specified number of positions. Parameters: * `arr` (list of int): A list of integers representing the array to be transformed. * `direction` (str): A string either \\"left\\" or \\"right\\" indicating the direction to shift the elements. * `positions` (int): An integer specifying the number of positions to shift the elements. The value will always be a non-negative integer. Expected Output: * A list of integers representing the array after being shifted in the specified direction by the specified number of positions. # Constraints: 1. The array `arr` will not be empty and will contain at most 10^5 elements. 2. The integer `positions` will be within the range of [0, length of the array). 3. Handling of arrays with a single element returns the same array. Usage Example ```python shift_array([1, 2, 3, 4, 5], \\"left\\", 2) # Output: [3, 4, 5, 1, 2] shift_array([1, 2, 3, 4, 5], \\"right\\", 1) # Output: [5, 1, 2, 3, 4] shift_array([10, 20, 30, 40, 50], \\"left\\", 5) # Output: [10, 20, 30, 40, 50] shift_array([7], \\"right\\", 3) # Output: [7] ``` # Implementation Notes: 1. Ensure your solution is efficient and can handle the upper limit of array size within a reasonable time frame. 2. Consider edge cases such as shifting by 0 positions or the number of positions equal to the length of the array.","solution":"def shift_array(arr, direction, positions): Shifts the elements of the array either to the left or right by the specified positions. Wraps around elements as necessary. :param arr: List of integers :param direction: A string either \\"left\\" or \\"right\\" indicating the direction to shift :param positions: An integer specifying the number of positions to shift :return: List of integers representing the shifted array length = len(arr) if positions == 0 or positions == length: return arr if direction == \'left\': return arr[positions:] + arr[:positions] elif direction == \'right\': return arr[-positions:] + arr[:-positions] else: raise ValueError(\\"The direction must be either \'left\' or \'right\'\\")"},{"question":"Compressed String Manipulation You are tasked with creating a `CompressedString` class that performs basic string manipulation on a compressed format. The compressed string format is a type of run-length encoding where sequences of the same character are stored as the character followed by its count. Requirements: 1. Implement a method `compress` which takes a regular string and returns its compressed form. 2. Implement a method `decompress` which takes a compressed string and returns the original string. 3. Implement error handling for invalid compressed formats (e.g., missing counts, non-numeric counts). # Constraints: - You may assume the input strings for compression will only contain lowercase ASCII letters. - The compressed format will be strictly followed for decompression. - Performance requirements are relaxed and should handle strings up to 1MB efficiently. Function Signatures: ```python class CompressedString: def compress(self, data: str) -> str: Compresses a text string into its compressed format. Args: data (str): Input text string consisting of lowercase ASCII letters. Returns: str: Compressed representation of the input string. def decompress(self, compressed_str: str) -> str: Decompresses a compressed string back to its original form. Args: compressed_str (str): Compressed string format. Returns: str: Original text string. Raises: ValueError: If the input compressed_str has an invalid format. ``` # Example Usage: ```python compressed_string = CompressedString() compressed_str = compressed_string.compress(\\"aaabccdddd\\") print(compressed_str) # Expected: \'a3b1c2d4\' original_str = compressed_string.decompress(\'a3b1c2d4\') print(original_str) # Expected: \'aaabccdddd\' ``` # Additional Notes: - Consider edge cases like empty strings, strings of varying lengths, and strings without repetitions. - Pay attention to the format of the compressed string during decompression. - Include appropriate doctests or unit tests to verify the correctness of your implementation. ```python # Example Implementation for Testing (This is not part of the question, just an illustration for the question writer): class CompressedString: def compress(self, data: str) -> str: if not data: return \'\' compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i-1]: count += 1 else: compressed.append(data[i-1] + str(count)) count = 1 compressed.append(data[-1] + str(count)) # Append the last grouped character return \'\'.join(compressed) def decompress(self, compressed_str: str) -> str: import re matches = re.findall(r\'([a-z])(d+)\', compressed_str) if not matches: raise ValueError(\\"Invalid compressed string format\\") decompressed = [] for char, count in matches: decompressed.append(char * int(count)) return \'\'.join(decompressed) # Example Usage: compressed_string = CompressedString() compressed_str = compressed_string.compress(\\"aaabccdddd\\") print(compressed_str) # Expected: \'a3b1c2d4\' original_str = compressed_string.decompress(\'a3b1c2d4\') print(original_str) # Expected: \'aaabccdddd\' ```","solution":"import re class CompressedString: def compress(self, data: str) -> str: if not data: return \'\' compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i-1]: count += 1 else: compressed.append(data[i-1] + str(count)) count = 1 compressed.append(data[-1] + str(count)) # Append the last grouped character return \'\'.join(compressed) def decompress(self, compressed_str: str) -> str: matches = re.findall(r\'([a-z])(d+)\', compressed_str) if \'\'.join(char + count for char, count in matches) != compressed_str: raise ValueError(\\"Invalid compressed string format\\") decompressed = [] for char, count in matches: decompressed.append(char * int(count)) return \'\'.join(decompressed)"},{"question":"# Question: Analyzing and Correcting Inverted Binary Trees Given a binary tree, an inversion operation means that you swap the left and right child of each node in the binary tree. Implement the function `invert_binary_tree` that takes the root node of a binary tree and returns the root node of the inverted binary tree. Function Signature ```python def invert_binary_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: ``` Parameters - `root`: Optional[TreeNode] - A nullable root node of a binary tree. Returns - Optional[TreeNode]: the root node of the inverted binary tree. Constraints 1. The number of nodes in the tree is in the range [0, 1000]. 2. Each node\'s value is an integer. Examples ```python # Given binary tree: # 4 # / # 2 7 # / / # 1 3 6 9 # # After inversion: # 4 # / # 7 2 # / / # 9 6 3 1 # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: if root is None: return None # Recursive approach to invert the tree left = invert_binary_tree(root.left) right = invert_binary_tree(root.right) root.left, root.right = right, left return root # Example Usage tree = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) inverted_tree = invert_binary_tree(tree) # Print tree function to display the binary tree in level order # Assuming a function that prints the tree in a level order manner def print_tree_level_order(root: TreeNode): if not root: return queue = [root] while queue: level_size = len(queue) current_level = [] for i in range(level_size): node = queue.pop(0) if node: current_level.append(node.val) queue.append(node.left) queue.append(node.right) else: current_level.append(None) print(current_level) print_tree_level_order(inverted_tree) # Expected Output: [4, 7, 2, 9, 6, 3, 1] ``` Notes: * Pay special attention to null references and edge cases such as empty trees. * Consider iterative solutions and depth/breadth-first traversal methods. * Optimize the function for both time and space complexity where possible.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: if root is None: return None # Recursive approach to invert the tree left = invert_binary_tree(root.left) right = invert_binary_tree(root.right) root.left, root.right = right, left return root"},{"question":"# Coding Assessment Question Implement the `min_operations` function which is supposed to calculate the minimum number of operations required to transform a given string `start` into another string `end` by performing only character insertions, deletions, or substitutions. # Inputs - `start`: A string representing the initial state. - `end`: A string representing the target end state. # Outputs - An integer indicating the minimum number of operations needed to transform the `start` string into the `end` string using the allowed operations. # Constraints - Both `start` and `end` will have a length between 1 and 100 inclusive. - Operations allowed are insertions, deletions, or substitutions of characters. # Example ```python start = \\"kitten\\" end = \\"sitting\\" # Minimum operations needed: 3 # Explanation: # - Substitute \'k\' with \'s\' # - Substitute \'e\' with \'i\' # - Insert \'g\' at the end ``` # Implementation You need to complete the implementation of the `min_operations` function: ```python def min_operations(start, end): len_start = len(start) len_end = len(end) dp = [[0] * (len_end + 1) for _ in range(len_start + 1)] for i in range(len_start + 1): for j in range(len_end + 1): if i == 0: dp[i][j] = j # If start is empty, insert all of end\'s characters elif j == 0: dp[i][j] = i # If end is empty, remove all of start\'s characters elif start[i - 1] == end[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove character from start dp[i][j - 1], # Insert character in start dp[i - 1][j - 1]) # Replace character in start return dp[len_start][len_end] ``` Test your implementation with multiple cases to ensure correctness.","solution":"def min_operations(start, end): Calculate the minimum number of operations required to transform the string `start` into the string `end` by performing only character insertions, deletions, or substitutions. len_start = len(start) len_end = len(end) # DP table initialization dp = [[0] * (len_end + 1) for _ in range(len_start + 1)] for i in range(len_start + 1): for j in range(len_end + 1): if i == 0: dp[i][j] = j # If start is empty, insert all of end\'s characters elif j == 0: dp[i][j] = i # If end is empty, remove all of start\'s characters elif start[i - 1] == end[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove character from start dp[i][j - 1], # Insert character in start dp[i - 1][j - 1]) # Replace character in start return dp[len_start][len_end]"},{"question":"# Coding Assessment Question Context You are tasked with building a backup system for a critical data server. To ensure the data is safely copied without duplication, you need to track each file\'s unique size and confirm if any file sizes appear more than once within a given set. Your goal is to implement a function that determines if any file size is duplicated in the list. Task Implement a function `contains_duplicate_file_sizes(file_sizes: List[int]) -> bool` that accepts a list of integers representing the sizes of various files in bytes and returns a boolean indicating whether any file size appears more than once in the list. Input - `file_sizes`: A list of integer values, each representing the size of a file in bytes. Output - Return `True` if any file size appears more than once in the list. Otherwise, return `False`. Constraints - The list of file sizes can contain up to 10<sup>4</sup> elements. - Each file size is a non-negative integer less than or equal to 10<sup>9</sup> bytes. Example ```python def contains_duplicate_file_sizes(file_sizes: List[int]) -> bool: pass # Example Usage file_sizes = [1024, 2048, 4096, 1024] assert contains_duplicate_file_sizes(file_sizes) == True file_sizes = [12345, 67890, 13579] assert contains_duplicate_file_sizes(file_sizes) == False ``` Requirements - Ensure your solution is optimized for performance, even for the largest input sizes. - Handle edge cases such as an empty list or a list with a single file size appropriately. - Implement your solution using an efficient algorithm, preferably with a time complexity of O(n).","solution":"from typing import List def contains_duplicate_file_sizes(file_sizes: List[int]) -> bool: Checks if there are any duplicate file sizes in the list. Parameters: file_sizes (List[int]): A list of integers representing the sizes of various files in bytes. Returns: bool: True if any file size appears more than once, otherwise False. seen_sizes = set() for size in file_sizes: if size in seen_sizes: return True seen_sizes.add(size) return False"},{"question":"# Problem Statement You are given two sorted arrays that represent digits of two large numbers. Your task is to implement a function that multiplies these two large numbers and returns the result as an array of digits. # Function Signature: ```python def multiply_large_numbers(num1: List[int], num2: List[int]) -> List[int]: ``` # Input: - `num1`: A list of integers where each integer represents a digit of a non-negative number. The list is sorted in the same order as the digits of the number. - `num2`: A list of integers where each integer represents a digit of a non-negative number. The list is sorted in the same order as the digits of the number. # Output: - Returns a list of integers where each integer represents a digit of the product of the two numbers. # Constraints: - The length of `num1` is between 1 and 1000. - The length of `num2` is between 1 and 1000. - Each digit in the input lists is between 0 and 9. - Leading zeros in the output are not allowed unless the entire result is zero. # Example: ```python num1 = [1, 2, 3] num2 = [4, 5, 6] result = multiply_large_numbers(num1, num2) print(result) # Example expected output: [5, 6, 0, 8, 8] ``` # Notes: - Do not convert the input arrays into integer types for multiplication as this can lead to inefficiencies and overflow issues for very large numbers. - Implement the multiplication process manually, similar to how you would perform it by hand, by considering the placement of any carried-over values and appropriately summing partial results. - Handle edge cases where the input may contain zeros. By solving this problem, you are expected to demonstrate your understanding of multiplication of large numbers, array manipulations, and attention to detail with edge cases.","solution":"from typing import List def multiply_large_numbers(num1: List[int], num2: List[int]) -> List[int]: if not num1 or not num2: return [0] # Initialize the result array with zeros, length of num1 + length of num2 result = [0] * (len(num1) + len(num2)) # Reverse the numbers to multiply from the least significant digit num1 = num1[::-1] num2 = num2[::-1] # Perform the multiplication for i in range(len(num1)): for j in range(len(num2)): result[i + j] += num1[i] * num2[j] result[i + j + 1] += result[i + j] // 10 # Carry over result[i + j] %= 10 # Keep only a single digit in the current place # Remove any leading zeros in the result while len(result) > 1 and result[-1] == 0: result.pop() # Reverse the result to get the final number result = result[::-1] return result"},{"question":"# Problem Description You need to write a function `find_longest_subarray` that takes a list of integers and identifies the longest contiguous subarray where the sum of the subarray’s elements is divisible by `k`. If there are multiple subarrays with the same maximum length, the function should return any one of them. # Input Format - A list of integers `nums` (-10^5 <= nums[i] <= 10^5) - An integer `k` (1 <= k <= 10^5) # Output Format - A list of integers representing the longest subarray where the sum of the elements is divisible by `k`. # Constraints - The input list can have negative numbers. - The input list length can vary, with 1 <= len(nums) <= 10^6. - Ensure the solution is optimized for large inputs. # Performance Requirements - The solution should aim for O(n) time complexity. - Use O(n) additional space if necessary. # Example Scenarios 1. **Example 1:** - Input: nums = [3, 1, 4, 1, 5, 9, 2, 6, 5], k = 5 - Output: [4, 1, 5] (or any other valid longest subarray) 2. **Example 2:** - Input: nums = [2, -2, 2, -2, 2], k = 2 - Output: [2, -2, 2, -2] 3. **Example 3:** - Input: nums = [1, 2, 3], k = 6 - Output: [1, 2, 3] # Edge Cases 1. **Single Element List Divisible:** - Input: nums = [10], k = 5 - Output: [10] 2. **Single Element List Not Divisible:** - Input: nums = [1], k = 2 - Output: [] 3. **All Zeroes:** - Input: nums = [0, 0, 0], k = 1 - Output: [0, 0, 0] # Function Signature ```python def find_longest_subarray(nums: list, k: int) -> list: pass ``` # Write the function `find_longest_subarray` to solve the problem:","solution":"def find_longest_subarray(nums, k): Finds the longest contiguous subarray where the sum of the subarray\'s elements is divisible by k. # Dictionary to store the first occurrence of a particular mod value mod_dict = {0: -1} max_len = 0 end_index = -1 cumulative_sum = 0 for i, num in enumerate(nums): cumulative_sum += num mod_value = cumulative_sum % k if mod_value in mod_dict: # If we have seen this mod value before, calculate the subarray length current_len = i - mod_dict[mod_value] if current_len > max_len: max_len = current_len end_index = i else: # Store the index of the first occurrence of this mod value mod_dict[mod_value] = i if max_len == 0: return [] start_index = end_index - max_len + 1 return nums[start_index:end_index + 1]"},{"question":"# Problem Statement You have been tasked with developing a utility for managing a large dataset of user activity log entries. Each log entry captures an event by a user at a specific timestamp. Your job is to write a function `max_user_activity` that calculates the maximum number of active users within a sliding 1-hour window (3600 seconds). # Function Signature ```python def max_user_activity( timestamps: List[int] # A list of timestamps representing user activity logs in seconds. ) -> int: pass ``` # Input - A list of integer timestamps representing activity logs, where each entry is the number of seconds since an arbitrary reference point. # Output - Returns an integer, which is the maximum number of user activities recorded within any 1-hour interval. # Constraints - The input list will have at least one timestamp and can have up to 100,000 log entries. - All timestamps are non-negative integers. - If the list is empty, return 0. # Example ```python >>> max_user_activity([0, 1000, 1500, 3600, 7200, 10800]) 3 >>> max_user_activity([100, 200, 300, 400, 500, 600, 700, 800, 900]) 9 >>> max_user_activity([100, 3700]) 1 >>> max_user_activity([]) 0 ``` # Note - In the first example, the maximum activity of 3 users occurs in the interval [0, 3600] due to the timestamps 0, 1000, and 1500. - In the second example, all timestamps fall within a 1-hour interval if starting at 100, thus the maximum activity is 9. - For the third example, no two timestamps fall within the same 1-hour window, so the maximum activity in any 1-hour is 1. - If the list is empty, the result should be zero since there are no timestamps to consider. Develop an efficient algorithm to tackle this problem, considering both the quantity of the log entries and their potential time frames.","solution":"from typing import List def max_user_activity(timestamps: List[int]) -> int: Returns the maximum number of active users within any sliding 1-hour window. if not timestamps: return 0 # Sort the timestamps to ensure they are in chronological order timestamps.sort() max_count = 0 for i in range(len(timestamps)): start_time = timestamps[i] end_time = start_time + 3600 # End time for the 1-hour window # Count the number of activities within the 1-hour window count = 0 for timestamp in timestamps[i:]: if start_time <= timestamp < end_time: count += 1 else: break # Update the maximum count if the current count is higher max_count = max(max_count, count) return max_count"},{"question":"# Balanced Binary Search Tree Construction and Search You are tasked with implementing a Balanced Binary Search Tree (BST) and performing an in-order traversal search. This question assesses your understanding of tree data structures, binary search operations, and tree balancing techniques. Function 1: build_balanced_bst Implement a function `build_balanced_bst` that constructs a balanced BST from a given sorted list of integers. The BST should be height-balanced with the minimum height possible. # Input: * `sorted_list`: A sorted list of integers (e.g., [1, 2, 3, 4, 5, 6, 7]). # Output: * The root `TreeNode` of the constructed balanced BST or `None` if the input list is empty. ```python class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right ``` Function 2: search_bst Implement a function `search_bst` that performs an in-order traversal search on the BST. It should return all the elements in the BST in ascending order. # Input: * `root`: The root `TreeNode` of the BST. # Output: * A list of integers representing the in-order traversal of the BST. Example ```python sorted_list = [1, 2, 3, 4, 5, 6, 7] root = build_balanced_bst(sorted_list) result = search_bst(root) ``` In the above example, `result` should return the list `[1, 2, 3, 4, 5, 6, 7]` since the BST is built from a sorted list. # Constraints * The sorted list will have at least one element. * Elements in the sorted list are unique. * List length will be between 1 and 10^3.","solution":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def build_balanced_bst(sorted_list): Constructs a balanced BST from a sorted list of integers. if not sorted_list: return None def build_bst(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(sorted_list[mid]) node.left = build_bst(left, mid - 1) node.right = build_bst(mid + 1, right) return node return build_bst(0, len(sorted_list) - 1) def search_bst(root): Performs an in-order traversal of the BST and returns a list of the elements in ascending order. result = [] def in_order_traversal(node): if node: in_order_traversal(node.left) result.append(node.value) in_order_traversal(node.right) in_order_traversal(root) return result"},{"question":"# Coding Assessment Question Problem Statement You are given a list of integers representing task durations. Your goal is to schedule all tasks on two processors such that the maximum load (sum of tasks) on any processor is minimized. Implement the function `minimize_max_load` to find the optimal scheduling. Requirements * **Function Signature**: ```python def minimize_max_load(tasks: list[int]) -> int: ``` * **Input**: * A list of integers `tasks` where 1 <= len(tasks) <= 1000 and 1 <= `tasks[i]` <= 10^4. * **Output**: * An integer representing the minimal possible maximum load on any processor. Constraints * Each task must be scheduled on exactly one of the two processors. * The function should aim to minimize the maximum load among the two processors. * You must use a greedy or a dynamic programming approach to solve the problem efficiently. Example ```python >>> minimize_max_load([1, 2, 3, 4, 5]) 8 >>> minimize_max_load([10, 20, 30]) 30 >>> minimize_max_load([5, 5, 5, 5, 5, 5]) 15 ``` Explanation 1. Initialize two variables to represent the load on each processor. 2. Sort the tasks in decreasing order. 3. Assign tasks to the processor with the lesser current load using a greedy approach. 4. Compute the maximum load after assigning all tasks. Edge Cases to Consider 1. A list with a single task. 2. A list where all tasks have the same duration. 3. A list where task durations are varied widely. Implement the function `minimize_max_load` according to the specifications above and ensure it passes all given test cases.","solution":"def minimize_max_load(tasks: list[int]) -> int: tasks.sort(reverse=True) processor1 = 0 processor2 = 0 for task in tasks: if processor1 <= processor2: processor1 += task else: processor2 += task return max(processor1, processor2)"},{"question":"# Problem Statement: You are given an array of integers and an integer target value. Your task is to implement a function `three_sum_closest` that finds three integers in the array such that the sum is closest to the given target. Return the sum of the three integers. You may assume that each input would have exactly one solution. # Input: - An array of integers `nums` of length between 3 and 1000. - An integer `target` which is the desired sum. # Output: - An integer representing the closest sum of three integers to the target. # Constraints: - The input array will contain integers (both positive and negative). - The length of the array will be at least 3. Function Signature: ```python def three_sum_closest(nums: list[int], target: int) -> int: pass ``` # Example: ```python assert three_sum_closest([-1, 2, 1, -4], 1) == 2 #(Closest sum is -1 + 2 + 1 = 2) assert three_sum_closest([0, 0, 0], 1) == 0 #(Closest sum is 0 + 0 + 0 = 0) ``` # Additional Context: The task is derived from the classic coding interview problem involving the \'closest sum\'. Optimize the approach to handle arrays close to the upper length efficiently. # Notes: - Consider both positive and negative integers in the input array while calculating sums. - Avoid overly complex solutions; aim for an algorithm with reasonable time complexity for large input arrays.","solution":"def three_sum_closest(nums: list[int], target: int) -> int: nums.sort() closest_sum = float(\'inf\') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum # perfect match return closest_sum"},{"question":"# Matrix Transposition Challenge You need to implement a function that performs a transposition of a square matrix. This task will assess your understanding of advanced indexing, mutating nested data structures, and ensuring algorithm correctness. Function: Matrix Transposition Write a function `transpose_matrix` that transposes a given square matrix in place. The function should adhere to the following constraints: - **Input**: A two-dimensional list (a list of lists) where each sublist represents a row of the matrix. The matrix is guaranteed to be square, meaning it has the same number of rows and columns. - **Output**: The function should modify the input matrix in place and return nothing. Post-transposition, each element at position `(i, j)` should be placed at position `(j, i)`. # Expected Function Signature ```python def transpose_matrix(matrix: list[list[int]]) -> None: pass ``` # Example Scenarios & Expected Outputs * `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - After calling `transpose_matrix(matrix)`, the matrix should become `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]`. * `matrix = [[1, 0], [0, 1]]` - After calling `transpose_matrix(matrix)`, the matrix should remain `[[1, 0], [0, 1]]`. # Constraints & Conditions - The input matrix will always be square (n x n) with `n` ranging from 1 to 1000. - Your solution should minimize the number of additional data structures created. - Ensure your function handles edge cases like a 1x1 matrix gracefully. - Strive for an in-place transformation, modifying the original matrix to save space. Implement the `transpose_matrix` function with robust test cases to validate its correctness across various scenarios. Consider edge cases and confirm the algorithm\'s efficiency.","solution":"def transpose_matrix(matrix: list[list[int]]) -> None: Transpose the given square matrix in place. Args: matrix (list of list of int): The square matrix to be transposed. Returns: None n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Sentence Autocomplete System Implementation You are tasked with implementing a sentence autocomplete system using a provided dictionary of phrases. The aim is to develop a system that suggests possible completions for a given input prefix. This will assess your understanding of data structures, particularly tries (prefix trees), and string manipulation. # Functional Requirements: 1. **Insert Phrases**: Load a set of phrases into an efficient data structure that supports quick lookups. 2. **Autocomplete**: For a given input prefix, return a list of phrases that start with this prefix. # Input and Output Formats: - **Input**: 1. A list of phrases to load into the autocomplete system. 2. A prefix string for which autocomplete suggestions are needed. - **Output**: A list of phrases that start with the given prefix. # Constraints: 1. The phrases can include spaces and should be case-insensitive. 2. Ensure the autocomplete operation runs in optimal time, leveraging the properties of the data structure used. 3. The returned suggestions should be sorted lexicographically. # Performance Requirements: 1. Efficient memory usage for storing the input phrases. 2. Quick insert and lookup times, utilizing an appropriate data structure. # Implementation Scenario: You are required to implement the class `AutocompleteSystem` with the following methods: - `add_phrases(phrases: List[str])`: Adds a list of phrases to the autocomplete system. - `get_autocomplete_suggestions(prefix: str) -> List[str]`: Returns a list of phrases that start with the provided prefix. ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.phrases = [] class AutocompleteSystem: def __init__(self): self.root = TrieNode() def add_phrases(self, phrases: List[str]): # Implement the logic to add phrases to the trie pass def get_autocomplete_suggestions(self, prefix: str) -> List[str]: # Implement the logic to retrieve autocomplete suggestions pass # Example usage: # autocomplete_system = AutocompleteSystem() # autocomplete_system.add_phrases([\\"hello world\\", \\"hi there\\", \\"happy coding\\", \\"hero in training\\"]) # suggestions = autocomplete_system.get_autocomplete_suggestions(\\"he\\") # print(suggestions) # Should output [\\"hello world\\", \\"hero in training\\"] ``` *Note*: The full structure should involve methods for inserting phrases into the Trie and retrieving suggestions by traversing the Trie nodes according to the input prefix.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.phrases = [] class AutocompleteSystem: def __init__(self): self.root = TrieNode() def add_phrases(self, phrases: List[str]): for phrase in phrases: self._insert(phrase.lower().strip()) def _insert(self, phrase: str): node = self.root for char in phrase: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.phrases.append(phrase) # Keep track of phrases at each node node.is_end_of_word = True def get_autocomplete_suggestions(self, prefix: str) -> List[str]: node = self.root prefix = prefix.lower().strip() for char in prefix: if char not in node.children: return [] node = node.children[char] return sorted(node.phrases) # Example usage: # autocomplete_system = AutocompleteSystem() # autocomplete_system.add_phrases([\\"hello world\\", \\"hi there\\", \\"happy coding\\", \\"hero in training\\"]) # suggestions = autocomplete_system.get_autocomplete_suggestions(\\"he\\") # print(suggestions) # Should output [\\"hello world\\", \\"hero in training\\"]"},{"question":"# Sum of Odd and Even Positions in an Array Write a function `sum_odd_even_positions` that takes an array of integers and returns a tuple `(odd_sum, even_sum)` where `odd_sum` is the sum of elements at odd indices (1, 3, 5, ...) and `even_sum` is the sum of elements at even indices (0, 2, 4, ...). # Guidelines 1. **Input**: An array of integers. 2. **Output**: A tuple containing the sum of elements at odd indices and the sum of elements at even indices. 3. **Constraints**: * The input array can contain positive, negative, and zero values. * The array can be of any size, including empty. # Details **Function Signature**: ```python def sum_odd_even_positions(arr: List[int]) -> Tuple[int, int]: ``` **Input Format**: - A list of integers `arr`. **Output Format**: - A tuple containing two integers `(odd_sum, even_sum)`. # Example **Input**: ``` arr = [10, 3, 7, -2, 8, 0, 5, -1] ``` **Output**: ``` (odd_sum, even_sum) = (0, 30) ``` **Explanation**: Sum of elements at even positions (0-based indices) -> 10 + 7 + 8 + 5 = 30 Sum of elements at odd positions (0-based indices) -> 3 + (-2) + 0 + (-1) = 0 **Edge Cases**: 1. If the array is empty, the function should return `(0, 0)`. 2. If the array has one element, it should be considered as if placed at an even position (index 0). # Notes * Ensure to handle arrays with mixed positive and negative values. * Consider edge cases such as an empty array or single-element array. * Aim for a time complexity of O(n). ```python from typing import List, Tuple def sum_odd_even_positions(arr: List[int]) -> Tuple[int, int]: odd_sum = 0 even_sum = 0 for i in range(len(arr)): if i % 2 == 0: even_sum += arr[i] else: odd_sum += arr[i] return odd_sum, even_sum # Example Usage arr = [10, 3, 7, -2, 8, 0, 5, -1] print(sum_odd_even_positions(arr)) # Output: (0, 30) ```","solution":"from typing import List, Tuple def sum_odd_even_positions(arr: List[int]) -> Tuple[int, int]: odd_sum = 0 even_sum = 0 for i in range(len(arr)): if i % 2 == 0: even_sum += arr[i] else: odd_sum += arr[i] return odd_sum, even_sum # Example Usage arr = [10, 3, 7, -2, 8, 0, 5, -1] print(sum_odd_even_positions(arr)) # Output: (0, 30)"},{"question":"# Problem Statement You are provided with a pre-order traversal of a binary tree and the tree\'s corresponding in-order traversal. Your task is to reconstruct the binary tree from these traversals. # Function Signature ```python def build_tree(preorder: list[int], inorder: list[int]) -> Optional[TreeNode]: pass ``` TreeNode Class ```python class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right ``` # Detailed Requirements 1. **Input**: - `preorder` (list[int]): The list of values representing the pre-order traversal of a binary tree. - `inorder` (list[int]): The list of values representing the in-order traversal of a binary tree. 2. **Output**: - Returns the root node of the reconstructed binary tree. 3. **Examples**: ```python >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> tree = build_tree(preorder, inorder) >>> tree.val 3 >>> tree.left.val 9 >>> tree.right.val 20 >>> tree.right.left.val 15 >>> tree.right.right.val 7 ``` # Constraints 1. The length of `preorder` and `inorder` are equal and range from 1 to 2000. 2. It is guaranteed that `preorder` and `inorder` are valid traversals of the same binary tree. 3. Each value in the tree is unique, i.e., no duplicates exist in `preorder` or `inorder`. # Notes - The pre-order traversal visits the nodes of the tree in the following order: root, left subtree, right subtree. - The in-order traversal visits the nodes of the tree in the following order: left subtree, root, right subtree. - Utilize the properties of these traversals to efficiently reconstruct the tree.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def build_tree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]: if not preorder or not inorder: return None # The root is always the first element of the preorder traversal root_val = preorder[0] root = TreeNode(root_val) # Finding index of root value in inorder traversal root_index = inorder.index(root_val) # Recursively build the left and right subtrees root.left = build_tree( preorder[1:1 + root_index], # elements for the left subtree in preorder inorder[:root_index] # elements for the left subtree in inorder ) root.right = build_tree( preorder[1 + root_index:], # elements for the right subtree in preorder inorder[root_index + 1:] # elements for the right subtree in inorder ) return root"},{"question":"# Problem Statement You have been provided with an implementation of the Dijkstra algorithm for finding the shortest paths in a graph with non-negative weights. This implementation employs an adjacency list representation of the graph. Given the class `DijkstraGraph`, implement a function `get_shortest_path` which returns the shortest path from a given start node to a given end node. Your function should reconstruct the path by following the predecessors recorded during the Dijkstra algorithm execution. # Function Specifications Function Signature ```python def get_shortest_path(graph: DijkstraGraph, start: int, end: int) -> List[int]: ``` Input - `graph (DijkstraGraph)`: An instance of the `DijkstraGraph` class, which has a method `dijkstra` that calculates shortest paths and stores predecessors. - `start (int)`: The starting node. - `end (int)`: The end node to which the shortest path is required. Output - `List[int]`: A list of node indices representing the shortest path from the start node to the end node (inclusive). # Constraints - The graph is connected and contains at least two nodes. - The weights of the edges are non-negative. # Example ```python # Assuming you have a graph with nodes and edges represented as: # graph = DijkstraGraph(adjacency_list) # graph.dijkstra(start_node) # Call your function shortest_path = get_shortest_path(graph, start_node, end_node) print(shortest_path) # Output: List of nodes representing the shortest path ``` # Notes - You should leverage the properties and methods of the provided `DijkstraGraph` class without changing its internal implementation. - Consider readability and efficiency in your implementation. - Remember to handle edge cases such as start node being the same as the end node, or unreachable nodes.","solution":"from typing import List, Dict, Tuple class DijkstraGraph: def __init__(self, adjacency_list: Dict[int, List[Tuple[int, int]]]): self.adjacency_list = adjacency_list self.distances = {} self.predecessors = {} def dijkstra(self, start: int): import heapq self.distances = {node: float(\'inf\') for node in self.adjacency_list} self.distances[start] = 0 self.predecessors = {node: None for node in self.adjacency_list} priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > self.distances[current_node]: continue for neighbor, weight in self.adjacency_list[current_node]: distance = current_distance + weight if distance < self.distances[neighbor]: self.distances[neighbor] = distance self.predecessors[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) def get_shortest_path(graph: DijkstraGraph, start: int, end: int) -> List[int]: graph.dijkstra(start) path = [] current = end while current is not None: path.append(current) current = graph.predecessors.get(current) path.reverse() return path if path[0] == start else [] # Example setup # graph_data = { # 0: [(1, 4), (2, 1)], # 1: [(3, 1)], # 2: [(1, 2), (3, 5)], # 3: [] # } # graph = DijkstraGraph(graph_data) # graph.dijkstra(0) # Example shortest path from node 0 to node 3: get_shortest_path(graph, 0, 3) # Expected output: [0, 2, 1, 3]"},{"question":"# Task You are given a data structure to maintain and update a collection of integer intervals. You should implement a function that merges overlapping intervals and queries the sum of the intervals after merging. # Function Signature ```python class IntervalCollection: def __init__(self): Initialize the IntervalCollection. Example Usage: >>> intervals = IntervalCollection() self.intervals = [] def add_interval(self, start: int, end: int) -> None: Adds a new interval to the collection and merges it with existing intervals if they overlap. Parameters: start (int): The starting index of the interval (inclusive). end (int): The ending index of the interval (exclusive). Example Usage: >>> intervals = IntervalCollection() >>> intervals.add_interval(1, 5) >>> intervals.intervals [(1, 5)] >>> intervals.add_interval(3, 7) >>> intervals.intervals [(1, 7)] pass def query_sum(self) -> int: Queries the sum of lengths of all the merged intervals. Returns: int: The sum of lengths of all merged intervals. Example Usage: >>> intervals = IntervalCollection() >>> intervals.add_interval(1, 5) >>> intervals.add_interval(3, 7) >>> intervals.query_sum() 6 pass ``` # Specifications 1. Implement the `add_interval` method to add new intervals and merge them with existing overlapping intervals. 2. Implement the `query_sum` method to return the sum of lengths of all the merged intervals. # Input - **start**: An integer representing the starting index of the interval (inclusive). - **end**: An integer representing the ending index of the interval (exclusive). # Output `add_interval` method - This method should not return anything. It should merge the intervals internally. `query_sum` method - This method should return the sum of lengths of all merged intervals. # Example 1. Create an `IntervalCollection`: ```python intervals = IntervalCollection() ``` 2. Add intervals to the collection: ```python intervals.add_interval(1, 5) intervals.add_interval(3, 7) ``` 3. Query the sum of lengths of all merged intervals: ```python assert intervals.query_sum() == 6 ``` # Constraints - You can assume that the `start` and `end` indexes provided are non-negative integers and `start` < `end`. - Intervals in the collection should be merged if they overlap or are immediately adjacent.","solution":"class IntervalCollection: def __init__(self): Initialize the IntervalCollection. self.intervals = [] def add_interval(self, start: int, end: int) -> None: Adds a new interval to the collection and merges it with existing intervals if they overlap. new_intervals = [] current_interval = (start, end) for interval in sorted(self.intervals + [current_interval], key=lambda x: x[0]): if not new_intervals or new_intervals[-1][1] < interval[0]: new_intervals.append(interval) else: new_intervals[-1] = (new_intervals[-1][0], max(new_intervals[-1][1], interval[1])) self.intervals = new_intervals def query_sum(self) -> int: Queries the sum of lengths of all the merged intervals. return sum(end - start for start, end in self.intervals)"},{"question":"# Problem Statement You are working on a graphics rendering engine and your task is to implement a function that calculates the intersection point of two line segments in 2D space. A line segment is defined by its two endpoints. Your function should return the coordinates of the intersection point if the segments intersect, or a message indicating no intersection. # Function Signature ```python from typing import Tuple, Union def line_segment_intersection(segment1: Tuple[Tuple[float, float], Tuple[float, float]], segment2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Union[Tuple[float, float], str]: ... ``` # Input * `segment1` - A tuple of two tuples, each containing two floats, representing the endpoints (x1, y1) and (x2, y2) of the first line segment. * `segment2` - A tuple of two tuples, each containing two floats, representing the endpoints (x3, y3) and (x4, y4) of the second line segment. # Output * A tuple containing two floats representing the coordinates (x, y) of the intersection point rounded to two decimal places, or a string indicating no intersection. # Constraints 1. A line segment must have distinct endpoints. 2. Ensure the segments provided are valid and do not overlap completely. # Examples ```python >>> line_segment_intersection(((1, 1), (4, 4)), ((1, 8), (2, 4))) (1.8, 1.8) >>> line_segment_intersection(((1, 1), (4, 4)), ((1, 4), (4, 1))) (2.5, 2.5) >>> line_segment_intersection(((1, 1), (4, 4)), ((5, 5), (6, 6))) \'No intersection\' >>> line_segment_intersection(((0, 0), (0, 0)), ((1, 1), (2, 2))) Traceback (most recent call last): ... ValueError: A line segment must have distinct endpoints ``` # Notes 1. Implement an efficient algorithm to determine the intersection point, taking into account edge cases such as parallel lines. 2. Validate the inputs to ensure the endpoints are not identical for any segment. 3. Return the result rounded to two decimal places for consistency.","solution":"from typing import Tuple, Union def line_segment_intersection(segment1: Tuple[Tuple[float, float], Tuple[float, float]], segment2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Union[Tuple[float, float], str]: def ccw(A, B, C): return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0]) def intersect(A, B, C, D): return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D) def det(a, b, c, d): return a * d - b * c (x1, y1), (x2, y2) = segment1 (x3, y3), (x4, y4) = segment2 # Validate that the lines have distinct endpoints if (x1 == x2 and y1 == y2) or (x3 == x4 and y3 == y4): raise ValueError(\\"A line segment must have distinct endpoints\\") if not intersect((x1, y1), (x2, y2), (x3, y3), (x4, y4)): return \\"No intersection\\" # Solve for the intersection point using determinants denom = det(x1 - x2, x3 - x4, y1 - y2, y3 - y4) if denom == 0: return \\"No intersection\\" intersect_x = det(det(x1, y1, x2, y2), x1 - x2, det(x3, y3, x4, y4), x3 - x4) / denom intersect_y = det(det(x1, y1, x2, y2), y1 - y2, det(x3, y3, x4, y4), y3 - y4) / denom return (round(intersect_x, 2), round(intersect_y, 2))"},{"question":"# Question: Enhanced Data Structure for Median Calculation Context You are required to design a custom data structure that allows for efficient insertion of elements and provides a function to calculate the median of the current elements. This class should leverage both a max-heap and a min-heap data structure to maintain the elements in a way that allows for efficient median calculation. Requirements 1. **Custom Data Structure Class (`MedianTracker`)**: - Should have two heaps: a max-heap for the lower half of elements and a min-heap for the upper half. - Must support addition of new elements. 2. **Median Calculation Method**: - Implement a method `find_median` within the `MedianTracker` class to calculate and return the median of the elements in the data structure. Implementation Details - **Input Format**: - Elements to be added: list of integers. - **Output Format**: - Current median after each insertion. - Final median after all elements have been added. - **Constraints**: - Ensure the solution is efficient for calculating the median even with a large number of elements. - The data structure should handle at least 10,000 insertions without significant performance degradation. Function Signature ```python import heapq from typing import List class MedianTracker: def __init__(self): self.lower_half = [] # max-heap self.upper_half = [] # min-heap def add_element(self, element: int) -> None: pass # Add element to the respective heap and rebalance if necessary def find_median(self) -> float: pass # Calculate the median of the current elements # Example Usage: # median_tracker = MedianTracker() # median_tracker.add_element(1) # median_tracker.add_element(5) # median1 = median_tracker.find_median() # Should return 3.0 # median_tracker.add_element(3) # median2 = median_tracker.find_median() # Should return 3.0 ``` Performance Requirements - The `add_element` method should run in O(log n) time complexity. - The `find_median` method should run in O(1) time complexity. - The solution should handle updates and median calculations efficiently, maintaining a balanced state between two heaps.","solution":"import heapq class MedianTracker: def __init__(self): self.lower_half = [] # max-heap (inverted to use python\'s min-heap) self.upper_half = [] # min-heap def add_element(self, element: int) -> None: # We simulate a max-heap for the lower_half by pushing negative values. if len(self.lower_half) == 0 or element <= -self.lower_half[0]: heapq.heappush(self.lower_half, -element) else: heapq.heappush(self.upper_half, element) # Rebalance heaps if necessary if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def find_median(self) -> float: if len(self.lower_half) > len(self.upper_half): return float(-self.lower_half[0]) else: return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"# Problem Statement **String Rotation Check** Given two strings `s1` and `s2`, write a function `is_rotation(s1, s2)` to determine if `s2` is a rotation of `s1`. # Input - `s1`: a string of length (n) (1 ≤ (n) ≤ 1000). - `s2`: a string of length (n) (1 ≤ (n) ≤ 1000). # Output - Return `True` if `s2` is a rotation of `s1`, otherwise return `False`. # Example ```python def is_rotation(s1: str, s2: str) -> bool: # Your code here # Example 1 # Input: # s1 = \\"waterbottle\\", s2 = \\"erbottlewat\\" # Output: # True # Example 2 # Input: # s1 = \\"hello\\", s2 = \\"lloeh\\" # Output: # False # Example 3 # Input: # s1 = \\"rotation\\", s2 = \\"tationro\\" # Output: # True ``` # Explanation For the input `(s1=\\"waterbottle\\", s2=\\"erbottlewat\\")`: - The string `s2` can be derived by rotating `s1` such that the \\"water\\" part shifts to the end and \\"erbottle\\" comes to the front, making `s2` a rotation of `s1`. For the input `(s1=\\"hello\\", s2=\\"lloeh\\")`: - The string `s2` cannot be derived by rotating `s1` in any way, hence it is not a rotation of `s1`. For the input `(s1=\\"rotation\\", s2=\\"tationro\\")`: - The string `s2` can be derived by rotating `s1` such that the \\"tation\\" part comes to the front and \\"ro\\" shifts to the end, making `s2` a rotation of `s1`. You need to implement the function `is_rotation` which checks if one string is a rotation of another by potentially employing string concatenation and substring search techniques.","solution":"def is_rotation(s1: str, s2: str) -> bool: Check if s2 is a rotation of s1. Args: s1 : str : original string. s2 : str : string to check against rotation. Returns: bool : True if s2 is a rotation of s1, otherwise False. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"# Problem Statement You are developing a feature for an e-commerce platform where, given a list of product prices, you need to calculate the maximum possible profit from a single purchase and subsequent sale of a product. You buy a product at a given day\'s price and sell it at a following day\'s price. Your task is to implement a function that takes a list of integers representing the prices of a product over several days and returns the maximum profit achievable. If no profit is possible, return 0. # Function Signature ```python def max_profit(prices: List[int]) -> int: pass ``` # Input * A list of integers `prices` where `1 <= len(prices) <= 10^5` and `0 <= prices[i] <= 10^4` — the prices of the product over several days. # Output * An integer representing the maximum profit that can be achieved from a single buy and sell transaction. If no profit is possible, return 0. # Constraints * You cannot sell a product before you buy it. * The algorithm should be efficient, with a time complexity of O(n). # Examples ```python >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 ``` # Notes 1. Consider using a linear scan approach to keep track of the minimum price seen so far and calculate the potential profit at each day. 2. Make sure the implementation handles edge cases like very short price lists correctly.","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit from a single purchase and subsequent sale. If no profit is possible, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"# Closest Pair of Points **Problem Statement:** Given a list of `n` points on the 2D plane, where each point is represented as a tuple of two integers `(x, y)`, write a function `closest_pair_of_points(points: list[tuple[int, int]]) -> float` that finds and returns the minimum distance between any two points from the list. **Function Signature:** ```python def closest_pair_of_points(points: list[tuple[int, int]]) -> float: pass ``` **Input:** - `points`: A list of tuples, where each tuple represents the coordinates of a point on a 2D plane. **Output:** - Returns a float representing the minimum distance between any two points. **Example:** ```python >>> closest_pair_of_points([(0, 0), (1, 1), (4, 5), (2, 2)]) 1.4142135623730951 ``` **Constraints:** 1. If the number of points is less than 2, the function should raise an exception of type `ValueError` with the message \\"At least two points are required.\\" 2. The distance should be calculated using the Euclidean distance formula. 3. The input list will contain at most ( 10^4 ) points. **Hints:** 1. Use a divide-and-conquer approach for an optimal solution in ( O(n log n) ) time complexity. 2. Consider edge cases where multiple points overlap or are positioned very close to each other. **Notes:** - Test your function with various cases, including the given example, edge cases with overlapping points, and large datasets. - Ensure to handle floating-point precision within reasonable limits. This problem can be solved by breaking the input set of points into smaller subsets, recursively solving for the closest pairs in these subsets, and then combining the results. Consider implementing efficient algorithms like the \\"Closest-Pair\\" algorithm which leverages sorting and the divide-and-conquer technique.","solution":"import math def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_pair_recursive(points_sorted_by_x, points_sorted_by_y): # Base case if len(points_sorted_by_x) <= 3: min_dist = float(\'inf\') for i in range(len(points_sorted_by_x)): for j in range(i + 1, len(points_sorted_by_x)): dist = euclidean_distance(points_sorted_by_x[i], points_sorted_by_x[j]) if dist < min_dist: min_dist = dist return min_dist # Divide mid = len(points_sorted_by_x) // 2 mid_point = points_sorted_by_x[mid] points_left = points_sorted_by_x[:mid] points_right = points_sorted_by_x[mid:] # Conquer points_sorted_by_y_left = list(filter(lambda x: x[0] <= mid_point[0], points_sorted_by_y)) points_sorted_by_y_right = list(filter(lambda x: x[0] > mid_point[0], points_sorted_by_y)) min_dist_left = closest_pair_recursive(points_left, points_sorted_by_y_left) min_dist_right = closest_pair_recursive(points_right, points_sorted_by_y_right) min_dist = min(min_dist_left, min_dist_right) # Combine strip = [point for point in points_sorted_by_y if abs(point[0] - mid_point[0]) < min_dist] for i in range(len(strip)): for j in range(i + 1, min(i + 7, len(strip))): dist = euclidean_distance(strip[i], strip[j]) if dist < min_dist: min_dist = dist return min_dist def closest_pair_of_points(points): if len(points) < 2: raise ValueError(\\"At least two points are required.\\") points_sorted_by_x = sorted(points) points_sorted_by_y = sorted(points, key=lambda x: x[1]) return closest_pair_recursive(points_sorted_by_x, points_sorted_by_y)"},{"question":"# Problem Statement You are given a binary matrix where each cell contains either a `0` or a `1`. Your task is to write a function `max_square_submatrix` that finds the size of the largest square submatrix that contains only `1`s. # Input - A list of lists `matrix` where each element is either `0` or `1`. # Output - An integer representing the size (area) of the largest square submatrix consisting entirely of `1`s. # Constraints - The dimensions of the given binary matrix `matrix` will not exceed 100x100. # Example ```python def max_square_submatrix(matrix: List[List[int]]) -> int: # Your implementation here # Example Usage matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] print(max_square_submatrix(matrix)) # Output: 4 ``` # Note - In the example, the largest square submatrix with all `1`s has a size of 2x2, hence the area is 4.","solution":"def max_square_submatrix(matrix): Finds the size of the largest square submatrix that contains only `1`s. :param matrix: List[List[int]] - a 2D binary matrix :return: int - the size (area) of the largest square submatrix consisting entirely of `1`s if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side # Area of the largest square"},{"question":"# Sorting Algorithm Optimizer **Objective**: Implement a flexible function in Python that can sort a list of tuples based on any element of the tuple, and specify the sort order (ascending or descending). **Task**: 1. Create a function `sort_tuples` that accepts a list of tuples, an index indicating which element of the tuple to sort by, and a boolean flag for ascending or descending order. 2. The function should sort the list of tuples based on the specified element (using the index) and return the sorted list. 3. Ensure the function handles edge cases, such as empty lists and invalid indices. ```python def sort_tuples(lst: list, index: int, ascending: bool = True) -> list: Sort a list of tuples by a specific element denoted by the index. Parameters: lst: A list of tuples to be sorted. index: The tuple index to sort by. ascending: Boolean flag for ascending (True) or descending (False) order. Returns: The sorted list of tuples. # Code implementation here pass if __name__ == \\"__main__\\": test_data = [ (3, \'banana\', 7.5), (1, \'apple\', 5.0), (2, \'orange\', 6.0) ] index_to_sort = 1 order = True # True for ascending, False for descending sorted_list = sort_tuples(test_data, index_to_sort, order) print(f\\"Sorted list: {sorted_list}\\") ``` **Constraints**: - The index provided will always be a valid index for the tuples in the list. - The list can contain any number of tuples, including zero. - The tuples will have consistent lengths (i.e., all tuples in the list will have the same number of elements). - The elements of the tuples will be comparable (i.e., no mixed-type elements that cannot be compared). **Expected Input/Output**: - **Input**: A list of tuples, an integer index, and a boolean flag for sort order. - **Output**: The sorted list of tuples. **Examples**: 1. Input: `[(3, \'banana\', 7.5), (1, \'apple\', 5.0), (2, \'orange\', 6.0)]`, `1`, `True` - Output: `[(1, \'apple\', 5.0), (3, \'banana\', 7.5), (2, \'orange\', 6.0)]` 2. Input: `[(3, \'banana\', 7.5), (1, \'apple\', 5.0), (2, \'orange\', 6.0)]`, `2`, `False` - Output: `[(3, \'banana\', 7.5), (2, \'orange\', 6.0), (1, \'apple\', 5.0)]` 3. Input: `[]`, `0`, `True` - Output: `[]` **Performance Requirements**: - The function should efficiently sort the list of tuples, managing any reasonable number of tuples with standard Python sorting methods.","solution":"def sort_tuples(lst: list, index: int, ascending: bool = True) -> list: Sort a list of tuples by a specific element denoted by the index. Parameters: lst: A list of tuples to be sorted. index: The tuple index to sort by. ascending: Boolean flag for ascending (True) or descending (False) order. Returns: The sorted list of tuples. return sorted(lst, key=lambda x: x[index], reverse=not ascending)"},{"question":"# Question: Implement Primes Sieve Using Segmented Sieve Algorithm Context The Segmented Sieve Algorithm is an extension of the Sieve of Eratosthenes, which can find all prime numbers in a given range [L, R]. This approach is more efficient when dealing with a large range. Task You are tasked with implementing the Segmented Sieve Algorithm to find all prime numbers in a specific range. Implementation Requirements 1. **Input**: * Two integers `L` and `R` where `1 ≤ L ≤ R ≤ 10^6`. * Note: `L` and `R` could be very large, and their difference can also be large. 2. **Output**: * A list of prime numbers in the range [L, R]. 3. **Constraints**: * Utilize the segmented sieve algorithm to ensure efficiency. 4. **Performance**: * Your solution should be optimized to handle large ranges efficiently. Write a function `segmented_sieve(L, R)` that implements the required functionality. Example ```python def segmented_sieve(L, R): # Your implementation here # Example usage: L = 10 R = 50 primes_in_range = segmented_sieve(L, R) print(primes_in_range) # Expected output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ```","solution":"import math def simple_sieve(limit): A simple sieve of Eratosthenes up to a given limit. is_prime = [True] * (limit + 1) p = 2 while p * p <= limit: if is_prime[p] == True: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, limit + 1) if is_prime[p]] return primes def segmented_sieve(L, R): Segmented sieve algorithm to find primes in [L, R]. limit = math.isqrt(R) + 1 primes = simple_sieve(limit) is_prime = [True] * (R - L + 1) for p in primes: start = max(p * p, (L + p - 1) // p * p) for j in range(start, R + 1, p): is_prime[j - L] = False if L == 1: is_prime[0] = False primes_in_range = [num for num, prime in zip(range(L, R + 1), is_prime) if prime] return primes_in_range"},{"question":"# Coding Assessment Question: Converting Decimal to Binary Context Binary representation of numbers is a fundamental concept in computer science, used for everything from low-level data processing to data compression. This exercise will help you demonstrate a solid understanding of binary conversion principles by asking you to implement a function that converts a given decimal number to its binary representation. Problem Statement Write a function `decimal_to_binary(n: int) -> str` that returns the binary representation of a given non-negative integer `n`. Input and Output * The input will be a non-negative integer `n`. * The output should be a string representing the binary form of `n`. Constraints * The input value `n` will be a valid non-negative integer within the range 0 to 10^6. * Do not use any external libraries such as `bin`. Edge Cases * Consider how to handle the case when `n` is zero. * Ensure the implementation can handle large numbers efficiently. Example ```python def decimal_to_binary(n: int) -> str: Return the binary representation of n as a string. :param n: the non-negative integer :return: the binary representation as a string. >>> decimal_to_binary(5) \'101\' >>> decimal_to_binary(0) \'0\' >>> decimal_to_binary(10) \'1010\' >>> decimal_to_binary(1) \'1\' >>> decimal_to_binary(1024) \'10000000000\' pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def decimal_to_binary(n: int) -> str: Return the binary representation of n as a string. :param n: the non-negative integer :return: the binary representation as a string. if n == 0: return \'0\' binary_rep = [] while n > 0: binary_rep.append(str(n % 2)) n = n // 2 return \'\'.join(reversed(binary_rep))"},{"question":"# Scenario You are developing a feature that optimizes product recommendations in an e-commerce platform. To achieve this, you need to implement an algorithm that identifies the longest common subsequence (LCS) between two product descriptions. # Task Write a function that finds the length of the longest common subsequence between two given strings. The LCS is defined as the longest sequence that appears in both given strings in the same order but not necessarily consecutively. # Function Signature ```python def longest_common_subsequence(str1: str, str2: str) -> int: pass ``` # Input * `str1` (string): The first string for comparison. * `str2` (string): The second string for comparison. # Output * An integer representing the length of the longest common subsequence between `str1` and `str2`. # Constraints * The length of each string will not exceed 1000 characters. * The function should be case-sensitive. # Performance Requirements * Must efficiently handle input sizes up to the maximum constraint (in terms of both time and space). # Examples ```python assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 # LCS is \\"ace\\" assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 # LCS is \\"abc\\" assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 # No common subsequence assert longest_common_subsequence(\\"\\", \\"abc\\") == 0 # Empty string scenario assert longest_common_subsequence(\\"abcde\\", \\"acf\\") == 2 # LCS is \\"ac\\" ``` Implement this algorithm in the function `longest_common_subsequence`.","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between `str1` and `str2`. m = len(str1) n = len(str2) # Create a 2D array to store lengths of LCS of substrings dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] # Example use cases print(longest_common_subsequence(\\"abcde\\", \\"ace\\")) # Should print 3 print(longest_common_subsequence(\\"abc\\", \\"abc\\")) # Should print 3 print(longest_common_subsequence(\\"abc\\", \\"def\\")) # Should print 0 print(longest_common_subsequence(\\"\\", \\"abc\\")) # Should print 0 print(longest_common_subsequence(\\"abcde\\", \\"acf\\")) # Should print 2"},{"question":"# Coding Assessment Question Objective Implement a function to resize an image to the desired dimensions while maintaining its aspect ratio using the Pillow library. Task Write a function `resize_image(img: Image, target_width: int, target_height: int) -> Image:` which resizes the given image to the specified dimensions while preserving the original aspect ratio. The function should ensure that the entire content of the image fits within the specified dimensions without distortion. Input and Output Format **Input**: - `img`: An instance of `PIL.Image`. - `target_width`: An integer representing the target width for the resized image. - `target_height`: An integer representing the target height for the resized image. **Output**: - The function should return an instance of `PIL.Image` resized to fit within the specified dimensions while maintaining the aspect ratio of the original image. Constraints - The output image must fit within the target dimensions without cropping. - Ensure that the function runs efficiently for large images. Performance Requirements - The function should run efficiently with a time complexity of O(n), where n is the number of pixels in the output image. Example ```python from PIL import Image def resize_image(img: Image, target_width: int, target_height: int) -> Image: Function to resize an image while maintaining the aspect ratio. original_width, original_height = img.size aspect_ratio = original_width / original_height if target_width / target_height > aspect_ratio: new_height = target_height new_width = int(aspect_ratio * new_height) else: new_width = target_width new_height = int(new_width / aspect_ratio) return img.resize((new_width, new_height), Image.LANCZOS) # Example usage: # Load image using PIL with Image.open(\\"path/to/your/image.jpg\\") as img: # Resize image resized_img = resize_image(img, 800, 600) # Save the resized image resized_img.save(\\"path/to/your/resized_image.png\\", format=\\"png\\") ``` Scenario Imagine you are developing an image gallery application where users can view uploaded images in various display sizes. Your task is to implement the core resizing functionality that will be used to create thumbnails and larger preview images while maintaining the original aspect ratio. Use the provided `resize_image` function template to complete this task.","solution":"from PIL import Image def resize_image(img: Image, target_width: int, target_height: int) -> Image: Resize the given image to the specified dimensions while preserving the original aspect ratio. original_width, original_height = img.size aspect_ratio = original_width / original_height if target_width / target_height > aspect_ratio: new_height = target_height new_width = int(aspect_ratio * new_height) else: new_width = target_width new_height = int(new_width / aspect_ratio) return img.resize((new_width, new_height), Image.LANCZOS)"},{"question":"# Problem Statement Design a function that determines if it\'s possible to create a target number by summing any subset of a given list of integers. The function should be efficient and handle edge cases appropriately. You need to write a function `can_sum` that takes a list of integers and a target number and returns a boolean indicating whether the target number can be achieved by summing any subset of the integers. # Input and Output Format * **Input**: - A list of integers `nums` where each integer is non-negative and (0 leq text{nums[i]} leq 1000). - An integer `target` where (0 leq text{target} leq 10^6). * **Output**: A boolean value (True or False). # Constraints - The length of the list `nums` is such that (1 leq text{len(nums)} leq 100). - All integers in the list are non-negative. # Example ```python # Example input nums = [2, 3, 5, 7] target = 10 # Example output True ``` # Task Implement the function `can_sum(nums: List[int], target: int) -> bool` to determine if the target number can be achieved by summing any subset of the integers in the given list. ```python from typing import List def can_sum(nums: List[int], target: int) -> bool: # Implement your function here pass # Example usage nums = [2, 3, 5, 7] target = 10 print(can_sum(nums, target)) # Output should be True ```","solution":"from typing import List def can_sum(nums: List[int], target: int) -> bool: # Initialize a list to keep track of possible sums dp = [False] * (target + 1) dp[0] = True # Base case: a sum of 0 is always achievable with an empty subset for num in nums: for i in range(target, num - 1, -1): # Traverse backwards to avoid overwriting values that are needed if dp[i - num]: dp[i] = True return dp[target]"},{"question":"# Sorting a List of Tuples You are provided with a function `sort_tuples` that takes a list of tuples, where each tuple contains a name and a score. Your task is to sort this list of tuples in descending order based on the scores. If two tuples have the same score, they should be ordered alphabetically by the name. Function Signature ```python def sort_tuples(lst: List[Tuple[str, int]]) -> List[Tuple[str, int]]: ``` Input - `lst` (List[Tuple[str, int]]): A list of tuples, where each tuple contains a string (the name) and an integer (the score). Output - Returns a new list of tuples, sorted in descending order of scores and alphabetically by name in case of ties. Constraints - The length of the list is between 1 and 1000. - Each name in the tuple is a non-empty string containing only alphabetic characters. - Scores are non-negative integers. Example ```python input_tuples = [(\\"Alice\\", 70), (\\"Bob\\", 80), (\\"Charlie\\", 70)] # After sorting: [(\\"Bob\\", 80), (\\"Alice\\", 70), (\\"Charlie\\", 70)] assert sort_tuples(input_tuples) == [(\\"Bob\\", 80), (\\"Alice\\", 70), (\\"Charlie\\", 70)] input_tuples = [(\\"Dave\\", 50), (\\"Eve\\", 50), (\\"Frank\\", 20)] # After sorting: [(\\"Dave\\", 50), (\\"Eve\\", 50), (\\"Frank\\", 20)] assert sort_tuples(input_tuples) == [(\\"Dave\\", 50), (\\"Eve\\", 50), (\\"Frank\\", 20)] ``` In this question, you need to focus on sorting a list of tuples based on multiple criteria: primarily by score in descending order and secondarily by name in ascending order in the case of ties. Ensure your implementation handles the constraints and edge cases effectively.","solution":"from typing import List, Tuple def sort_tuples(lst: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sort the list of tuples first by score in descending order, and then by name in ascending order in case of a tie. return sorted(lst, key=lambda x: (-x[1], x[0]))"},{"question":"# Coding Assessment Question: Optimizing Matrix Multiplication Problem Statement You are given two matrices `A` and `B` and your task is to implement an optimized matrix multiplication algorithm. Your solution should aim to handle large matrices efficiently. # Requirements 1. **Function Signature**: Write a function `optimized_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]` in Python. 2. **Input**: * Two matrices `A` (of size `m x n`) and `B` (of size `n x p`), where `1 ≤ m, n, p ≤ 500`. * Each element of the matrices is an integer in the range `-1000` to `1000`. 3. **Output**: * A matrix `C` which is the result of multiplying `A` with `B` with dimensions `m x p`. 4. **Constraints**: * It is guaranteed that the number of columns in `A` equals the number of rows in `B`. * Optimize the algorithm to minimize the number of redundant calculations. # Example ```python def optimized_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Implement the optimized matrix multiplication algorithm here pass # Example Usage A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] print(optimized_matrix_multiplication(A, B)) # Output: [[19, 22], [43, 50]] ``` # Performance Requirements: * Aim for an algorithm that runs faster than the naive O(m*n*p) matrix multiplication approach whenever possible. * The solution should be able to efficiently handle the edge cases when the matrices are very large or very small.","solution":"from typing import List def optimized_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Returns the result of the matrix multiplication of A and B. if not A or not B or len(A[0]) != len(B): raise ValueError(\\"Invalid matrices for multiplication\\") m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix with zeros C = [[0] * p for _ in range(m)] # Precompute transpose of B to improve cache performance B_T = [[B[j][i] for j in range(n)] for i in range(p)] for i in range(m): for j in range(p): C[i][j] = sum(A[i][k] * B_T[j][k] for k in range(n)) return C"},{"question":"# Problem Statement You are given a list of strings representing various URLs and a set of keywords. Your task is to determine which URLs contain all the given keywords in the order specified within the URL path. Implement this solution in Python using regular expressions. # Function Signature ```python def urls_with_keywords_in_order( urls: List[str], keywords: List[str] ) -> List[str]: Finds URLs that contain all specified keywords in the given order in the URL path. :param urls: A list of URL strings. :param keywords: A list of keywords that must appear in the specified order. :return: A list of URLs that fit the criteria. ``` # Input - urls: List[str] * A list of URL strings following standard HTTP/HTTPS URL format. - keywords: List[str] * A list of strings where each string represents a keyword that must be present in the URL path. # Output - Returns a list of URLs (List[str]) from the input list that contain all the specified keywords in the order provided. # Examples ```python assert urls_with_keywords_in_order( urls=[ \\"https://example.com/page/subpage/keyword1/keyword2\\", \\"http://anotherexample.com/keyword1/someotherpage/keyword2\\", \\"https://yetanotherexample.com/keyword2/keyword1\\", \\"http://example.com/keyword2/keyword1\\" ], keywords=[\\"keyword1\\", \\"keyword2\\"] ) == [ \\"https://example.com/page/subpage/keyword1/keyword2\\", \\"http://anotherexample.com/keyword1/someotherpage/keyword2\\" ] assert urls_with_keywords_in_order( urls=[ \\"https://ecommerce.com/products/electronics/tv\\", \\"https://ecommerce.com/products/furniture/table\\", \\"https://ecommerce.com/products/furniture/chair\\", \\"https://ecommerce.com/products/electronics/camera\\" ], keywords=[\\"products\\", \\"electronics\\"] ) == [ \\"https://ecommerce.com/products/electronics/tv\\", \\"https://ecommerce.com/products/electronics/camera\\" ] ``` # Constraints - The number of URLs will be between 1 and 1000. - The number of keywords will be between 1 and 10. - Each URL will be at most 200 characters long. # Notes - Consider the path of the URL only, ignoring query parameters and fragments. - Use regular expressions to search for keywords in the correct order within the URL path. - Ensure that keywords are treated as case-sensitive and match exactly.","solution":"import re from typing import List def urls_with_keywords_in_order(urls: List[str], keywords: List[str]) -> List[str]: # Create a single regex pattern that matches all keywords in order pattern = r\\"/\\" + r\\".*\\".join(re.escape(keyword) for keyword in keywords) + r\\"(/|)\\" regex = re.compile(pattern) # Filter the URLs that match the pattern result = [url for url in urls if regex.search(url)] return result"},{"question":"# Problem Statement: You are given a binary tree, and your task is to determine the level order traversal of its nodes\' values. This traversal goes level by level from left to right. As detailed in the provided analysis, level order traversal of a binary tree can be performed using a queue to keep track of nodes at the current level. # Task: Implement the `level_order_traversal` function which takes the root of a binary tree and returns a list of lists, where each list contains the values of nodes at each level of the binary tree. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> List[List[int]]: ``` # Input: - A binary tree node `root` (0 ≤ number of nodes ≤ 10^4). # Output: - A list of lists of integers, where each inner list contains the values of nodes at each level of the binary tree. # Example: ```python # Given the binary tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert level_order_traversal(root) == [[3], [9, 20], [15, 7]] # Given the binary tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert level_order_traversal(root) == [[1], [2, 3], [4, 5]] # Given the binary tree: # 1 # # 2 # # 3 root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) assert level_order_traversal(root) == [[1], [2], [3]] ``` # Constraints: - The binary tree could be empty. Return an empty list for an empty tree. - You can assume that the values of the nodes are integers. # Implementation Note: You may not use any built-in tree traversal functions. The goal is to demonstrate your understanding of the level order traversal by implementing it manually using a queue data structure.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Problem Statement You are tasked with creating two functions to work with simplified Morse code sequences for encoded message validation and decoding. 1. Develop a function to validate if a given string adheres to the simplified Morse code format. Simplified Morse code contains only dots `.` and dashes `-`, representing short and long signals, respectively. 2. Implement a decoding function that converts a simplified Morse code string into its corresponding English message. For simplicity, assume the mapping only includes the first five letters of the alphabet: {\'A\': \\".-\\", \'B\': \\"-...\\", \'C\': \\"-.-.\\", \'D\': \\"-..\', \'E\': \\".\\"}. # Input 1. For the validation function: - A single string `code` consisting of dots `.` and dashes `-`. 2. For the decoding function: - A single string `code_segment` containing dots `.` and dashes `-` separated by spaces, where each segment corresponds to one encoded character. # Output 1. For the validation function: - A boolean indicating whether the string is a valid simplified Morse code. 2. For the decoding function: - A string representing the decoded English message. # Function Signature ```python def is_valid_simplified_morse(code: str) -> bool: # Your code here def decode_simplified_morse(code_segment: str) -> str: # Your code here ``` # Example ```python # Example 1: Validation Function assert is_valid_simplified_morse(\\"..\\") == True assert is_valid_simplified_morse(\\".. --- ..\\") == False # Example 2: Decoding Function assert decode_simplified_morse(\\".- -... -.-. -.. .\\") == \\"ABCDE\\" assert decode_simplified_morse(\\".-. ..- -.-. -.-\\") == \\"Unknown\\" ``` # Constraints 1. `1 <= len(code) <= 1000` 2. `1 <= len(code_segment) <= 5000` # Notes - The valid simplified Morse code should strictly be a string of dots and dashes without spaces. - Ensure the decoding function maps only the provided characters and handles strings that don\'t translate into recognized Morse sequences by returning \\"Unknown\\".","solution":"def is_valid_simplified_morse(code: str) -> bool: Validate if the given string adheres to the simplified Morse code format. Only dots `.` and dashes `-` are allowed. Args: code (str): The Morse code string to validate. Returns: bool: True if the string is valid Morse code, False otherwise. valid_characters = set(\'.-\') return all(c in valid_characters for c in code) def decode_simplified_morse(code_segment: str) -> str: Convert a simplified Morse code string into its corresponding English message. Args: code_segment (str): The Morse code string with segments separated by spaces. Returns: str: The decoded English message or \\"Unknown\\" if any segment doesn\'t correspond to known letters. morse_dict = { \\".-\\": \\"A\\", \\"-...\\": \\"B\\", \\"-.-.\\": \\"C\\", \\"-..\\": \\"D\\", \\".\\": \\"E\\" } decoded_message = [] segments = code_segment.split() for segment in segments: if segment in morse_dict: decoded_message.append(morse_dict[segment]) else: return \\"Unknown\\" return \'\'.join(decoded_message)"},{"question":"# Question: Implement an Efficient Word Frequency Counter Using Concurrent Processing Context: You are tasked with creating a word frequency counter that efficiently processes large text files. The current implementation reads and counts the words in a single-threaded manner, which can be slow for large files. Requirements: 1. **File Reading**: Implement functionality to read a large text file. 2. **Concurrent Processing**: Utilize concurrent processing techniques (e.g., threading, multiprocessing) to split the workload and count word frequencies more efficiently. 3. **Synchronization**: Ensure safe access and updating of shared resources (word counts) to avoid race conditions. Main Function Specification: ```python def count_word_frequencies(file_path: str) -> Dict[str, int]: Given the path to a text file, return a dictionary with the count of each word in the file. Parameters: file_path (str): Path to the text file. Returns: Dict[str, int]: A dictionary mapping each word to its frequency count. pass ``` * **Input**: A string representing the path to the text file. * **Output**: A dictionary with words as keys and their corresponding frequency counts as values. Constraints: - The function should efficiently handle text files of size up to 1GB. - Ensure thread-safe operations on shared resources (e.g., using locks or thread-safe data structures). - Ignore case and punctuation for word counting (e.g., \\"Word\\" and \\"word\\" should be counted as the same word). * **Example**: ```python input_file_path = \\"large_text_file.txt\\" # Assuming \\"large_text_file.txt\\" contains: \\"hello world, HELLO again!\\" expected_output = { \\"hello\\": 2, \\"world\\": 1, \\"again\\": 1 } assert count_word_frequencies(input_file_path) == expected_output ``` Performance Requirements: - Ensure the function can process large files efficiently within a reasonable time limit (e.g., depending on file size, test with reasonable performance metrics like processing a 1GB file within a few minutes). Note: Provide a well-documented and tested solution showcasing your understanding of file I/O, concurrent processing, and thread-safety in Python.","solution":"import re import os from collections import Counter from concurrent.futures import ThreadPoolExecutor from typing import Dict def read_chunks(file_path: str, chunk_size: int = 1024 * 1024): Read a file in chunks with open(file_path, \'r\', encoding=\'utf-8\') as f: while True: chunk = f.read(chunk_size) if not chunk: break yield chunk def process_chunk(chunk: str) -> Counter: Process a chunk of text and return a Counter of word frequencies words = re.findall(r\'bw+b\', chunk.lower()) return Counter(words) def count_word_frequencies(file_path: str) -> Dict[str, int]: Given the path to a text file, return a dictionary with the count of each word in the file. Parameters: file_path (str): Path to the text file. Returns: Dict[str, int]: A dictionary mapping each word to its frequency count. word_counts = Counter() with ThreadPoolExecutor() as executor: futures = [executor.submit(process_chunk, chunk) for chunk in read_chunks(file_path)] for future in futures: result = future.result() word_counts.update(result) return dict(word_counts)"},{"question":"# Problem Statement Write a function to determine if a given string is a permutation of another string. A permutation is a rearrangement of characters. The function should return `True` if one string is a permutation of the other, and `False` otherwise. # Function Signature ```python def is_permutation(str1: str, str2: str) -> bool: ``` # Input * Two strings `str1` and `str2`. # Output * A boolean value `True` if `str1` is a permutation of `str2`; `False` otherwise. # Constraints * Both input strings will consist only of lowercase English letters. * The length of each string will be between 1 and 100, inclusive. # Examples ```python is_permutation(\\"abc\\", \\"bca\\") => True is_permutation(\\"abcd\\", \\"dcba\\") => True is_permutation(\\"abcd\\", \\"abce\\") => False is_permutation(\\"123\\", \\"321\\") => False is_permutation(\\"a\\", \\"a\\") => True is_permutation(\\"a\\", \\"b\\") => False ``` # Additional Information * Consider the edge cases where the strings are of different lengths, or contain different characters, which should result in `False`. * You may utilize sorting or a frequency count (hash map/dictionary) to determine if one string is a permutation of another. # Implementation Challenge Ensure that your function handles varying lengths of input strings efficiently. Additionally, aim to minimize time complexity to make the function performant for the upper limit of string lengths.","solution":"def is_permutation(str1: str, str2: str) -> bool: Returns True if str1 is a permutation of str2, False otherwise. if len(str1) != len(str2): return False # Count the frequency of each character in both strings char_count1 = {} char_count2 = {} for char in str1: char_count1[char] = char_count1.get(char, 0) + 1 for char in str2: char_count2[char] = char_count2.get(char, 0) + 1 # Compare the frequency dictionaries return char_count1 == char_count2"},{"question":"# Question: Implement a Binary Search Tree Scenario In a system that requires quick insertion, deletion, and lookup operations on a set of unique integer keys, a Binary Search Tree (BST) is an ideal data structure. You are tasked with implementing a simple BST and providing methods for insertion, search, and deletion of nodes. Task Implement a class `BST` with the following methods: 1. **`insert(self, key: int) -> None:`** * Inserts a new key into the BST. If the key already exists, it should not insert a duplicate. 2. **`search(self, key: int) -> bool:`** * Returns `True` if the key exists in the BST, otherwise returns `False`. 3. **`delete(self, key: int) -> None:`** * Deletes a key from the BST if it exists. If the key does not exist, the method does nothing. Constraints * The BST property must be maintained after each insertion and deletion. * Assume all keys are distinct integers. * The methods will be called as follows: * `tree = BST()` * `tree.insert(key)` * `result = tree.search(key)` * `tree.delete(key)` Example ```python class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = TreeNode(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node: TreeNode, key: int) -> None: if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert_rec(node.left, key) elif key > node.key: if node.right is None: node.right = TreeNode(key) else: self._insert_rec(node.right, key) def search(self, key: int) -> bool: return self._search_rec(self.root, key) def _search_rec(self, node: TreeNode, key: int) -> bool: if node is None: return False if key == node.key: return True elif key < node.key: return self._search_rec(node.left, key) else: return self._search_rec(node.right, key) def delete(self, key: int) -> None: self.root = self._delete_rec(self.root, key) def _delete_rec(self, node: TreeNode, key: int) -> TreeNode: if node is None: return node if key < node.key: node.left = self._delete_rec(node.left, key) elif key > node.key: node.right = self._delete_rec(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.key = min_larger_node.key node.right = self._delete_rec(node.right, min_larger_node.key) return node def _get_min(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current # Example Usage: tree = BST() tree.insert(5) tree.insert(3) tree.insert(7) print(tree.search(3)) # returns True print(tree.search(4)) # returns False tree.delete(3) print(tree.search(3)) # returns False ```","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = TreeNode(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node: TreeNode, key: int) -> None: if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert_rec(node.left, key) elif key > node.key: if node.right is None: node.right = TreeNode(key) else: self._insert_rec(node.right, key) def search(self, key: int) -> bool: return self._search_rec(self.root, key) def _search_rec(self, node: TreeNode, key: int) -> bool: if node is None: return False if key == node.key: return True elif key < node.key: return self._search_rec(node.left, key) else: return self._search_rec(node.right, key) def delete(self, key: int) -> None: self.root = self._delete_rec(self.root, key) def _delete_rec(self, node: TreeNode, key: int) -> TreeNode: if node is None: return node if key < node.key: node.left = self._delete_rec(node.left, key) elif key > node.key: node.right = self._delete_rec(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.key = min_larger_node.key node.right = self._delete_rec(node.right, min_larger_node.key) return node def _get_min(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current"},{"question":"Problem Statement Given an integer array `nums`, write a function `move_zeros_to_end` that moves all zeros present in the array to the end while maintaining the relative order of non-zero elements. # Function Signature ```python def move_zeros_to_end(nums: List[int]) -> List[int]: pass ``` # Input - An array of integers `nums` where the length can range from 1 to 10^4. # Output - The modified array where all zeros are moved to the end. # Constraints - The function should modify the array in place. - Avoid using extra space for another array. # Example ```python >>> move_zeros_to_end([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros_to_end([1, 0, 1]) [1, 1, 0] >>> move_zeros_to_end([0, 0, 0, 0]) [0, 0, 0, 0] ``` # Notes - Ensure the function handles edge cases such as arrays with no zeros or arrays composed solely of zeros. - Consider the time complexity of your solution and aim for an efficient implementation.","solution":"from typing import List def move_zeros_to_end(nums: List[int]) -> List[int]: Moves all zeros in the given list to the end while maintaining the relative order of non-zero elements. non_zero_index = 0 # First pass: fill non-zeros for i in range(len(nums)): if nums[i] != 0: nums[non_zero_index] = nums[i] non_zero_index += 1 # Second pass: fill remaining with zeros for i in range(non_zero_index, len(nums)): nums[i] = 0 return nums"},{"question":"# Question You are a developer tasked with creating a utility function to analyze sales data for a retail store. Your function should identify the most frequently sold item from a given list of sales transactions. # Function Description Implement the function `get_most_frequent_item` which takes in a list of sales transactions and returns the item that was sold the most. # Input * A list of strings `sales` where each string is an item that was sold. Assume no string is empty. # Output * A string representing the item that was sold the most frequently. If there is a tie for the most frequent item, return any one of the most frequent items. # Constraints * The length of the input list `sales` will not exceed 100,000 items. * Each string in the list has a maximum length of 15 characters and contains only alphanumeric characters. # Performance Requirements * Your function should efficiently handle large input sizes within the constraints provided. # Example ```python def get_most_frequent_item(sales): from collections import Counter counter = Counter(sales) most_common = counter.most_common(1)[0] return most_common[0] # Example usage: sales = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"] most_frequent_item = get_most_frequent_item(sales) print(most_frequent_item) # Output: \\"banana\\" ``` In the above example, the `get_most_frequent_item` function identifies \\"banana\\" as the most frequently sold item in the `sales` list.","solution":"def get_most_frequent_item(sales): Returns the most frequently sold item from the given list of sales. :param sales: List of strings representing items sold. :return: String representing the most sold item. from collections import Counter counter = Counter(sales) most_common = counter.most_common(1)[0] return most_common[0]"},{"question":"# Coding Assessment Question Context: You are tasked with implementing a text analysis feature for a large-scale document search engine. One of the requirements is to identify unique words that are common across a set of documents. Problem: Your task is to write a Python function `common_unique_words(docs: List[str]) -> Set[str]` that takes a list of document strings and returns a set of unique words that are present in every document. Function Signature: ```python from typing import List, Set def common_unique_words(docs: List[str]) -> Set[str]: pass ``` Input: - A list `docs` containing `n` (1 ≤ n ≤ 1000) strings, where each string represents a document (1 ≤ length of each string ≤ 10^6). Each document consists of lowercase alphabetical words separated by spaces. Output: - A set of unique words that are common to all documents. Example: ```python docs = [ \\"the quick brown fox jumps over the lazy dog\\", \\"the fox is quick and the dog is lazy\\", \\"the dog sleep quick under the brown tree\\" ] assert common_unique_words(docs) == {\\"the\\", \\"quick\\", \\"dog\\"} ``` Constraints: 1. You should ensure the function handles large inputs efficiently. 2. Consider edge cases such as documents with no common words or documents with different lengths. 3. The solution should make use of appropriate data structures to ensure optimal performance. Solution Approach: 1. Parse each document to extract unique words. 2. Use set operations to find the intersection of words across all documents. 3. Return the resulting set of common unique words. Good luck and remember to consider edge cases, optimization, and correct use of data structures!","solution":"from typing import List, Set def common_unique_words(docs: List[str]) -> Set[str]: if not docs: return set() # Split the first document into unique words set common_words = set(docs[0].split()) for doc in docs[1:]: current_words = set(doc.split()) common_words &= current_words # Set intersection # If at any point common_words is empty, break early if not common_words: break return common_words"},{"question":"# Problem Statement You are given a class named `Node` that represents a node in a singly linked list. Each `Node` object has two attributes, `value` which stores an integer value, and `next` which points to the next node in the linked list. Your task is to write a function called `remove_kth_last_node` to remove the k-th last node from the linked list. If k is greater than the length of the list, raise an error with a clear message. # Function Signature ```python class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_kth_last_node(head: Node, k: int) -> Node: ``` # Input - `head`: The head node of a singly linked list. - `k`: An integer representing the position of the node from the end of the list to be removed. # Output - The head node of the new singly linked list with the k-th last node removed. # Constraints - The list length will be between 1 and (10^4). - `k` will be a non-negative integer. # Examples ```python # Create a linked list: 1 -> 2 -> 3 -> 4 -> 5 head = Node(1, Node(2, Node(3, Node(4, Node(5))))) >>> new_head = remove_kth_last_node(head, 2) # The resulting linked list should be: 1 -> 2 -> 3 -> 5 >>> nodes = [] >>> current = new_head >>> while current: >>> nodes.append(current.value) >>> current = current.next >>> nodes [1, 2, 3, 5] # More examples # Create a linked list: 1 -> 2 -> 3 head = Node(1, Node(2, Node(3))) >>> new_head = remove_kth_last_node(head, 1) # The resulting linked list should be: 1 -> 2 >>> nodes = [] >>> current = new_head >>> while current: >>> nodes.append(current.value) >>> current = current.next >>> nodes [1, 2] >>> remove_kth_last_node(head, 4) Traceback (most recent call last): ... ValueError: k is greater than the length of the linked list ``` # Error Handling - If `k` is greater than the length of the list, the function should raise a `ValueError` with the message `k is greater than the length of the linked list`. - If `k` is 0, the function should raise a `ValueError` with the message `k must be a positive integer`. This problem requires a solid understanding of linked list manipulation, edge cases handling, and robust error-free code.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_kth_last_node(head: Node, k: int) -> Node: if k <= 0: raise ValueError(\\"k must be a positive integer\\") # Find the length of the linked list length = 0 current = head while current: length += 1 current = current.next if k > length: raise ValueError(\\"k is greater than the length of the linked list\\") # Removing the head node (special case) if k == length: return head.next # Find the (length - k)th node (which is the node before the one we want to remove) current = head for _ in range(length - k - 1): current = current.next # Remove the kth last node if current.next: current.next = current.next.next return head"},{"question":"# Coding Task: Fibonacci Series Variations **Objective**: Implement three variations of the Fibonacci series calculation: 1. Finding the nth Fibonacci number, 2. Generating a list of the first `m` Fibonacci numbers, 3. Determining if a given number is a Fibonacci number. Functions to Implement: 1. **`find_fibonacci(n: int) -> int`**: - **Input**: - `n` (Integer): The position (0-based) in the Fibonacci sequence for which to find the Fibonacci number. - **Output**: - Returns the nth Fibonacci number (Integer). - **Constraints**: - `n` must be a non-negative integer. - **Exception Handling**: - Raise `ValueError` if `n < 0`. - Raise `TypeError` if `n` is not an integer. 2. **`generate_fibonacci(m: int) -> list`**: - **Input**: - `m` (Integer): The number of Fibonacci numbers to generate. - **Output**: - Returns a list of the first `m` Fibonacci numbers. - **Constraints**: - `m` must be a positive integer. - **Exception Handling**: - Raise `ValueError` if `m <= 0`. - Raise `TypeError` if `m` is not an integer. 3. **`is_fibonacci(number: int) -> bool`**: - **Input**: - `number` (Integer): The number to check if it is a Fibonacci number. - **Output**: - Returns `True` if the given number is a Fibonacci number, otherwise `False`. - **Constraints**: - `number` must be a non-negative integer. - **Exception Handling**: - Raise `ValueError` if `number < 0`. - Raise `TypeError` if `number` is not an integer. **Example Usages**: ```python assert find_fibonacci(6) == 8 assert find_fibonacci(0) == 0 assert generate_fibonacci(6) == [0, 1, 1, 2, 3, 5] assert is_fibonacci(8) == True assert is_fibonacci(7) == False ``` **Notes**: - Ensure that your code handles large input efficiently. - Provide appropriate documentation and doctests for each function. - Optimize the implementation where possible to lower the time complexity, especially for finding large Fibonacci numbers and checking if a number is a Fibonacci number.","solution":"import math def find_fibonacci(n: int) -> int: Returns the nth Fibonacci number (0-based index). if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input cannot be negative\\") a, b = 0, 1 for _ in range(n): a, b = b, a + b return a def generate_fibonacci(m: int) -> list: Generates a list of the first m Fibonacci numbers. if not isinstance(m, int): raise TypeError(\\"Input must be an integer\\") if m <= 0: raise ValueError(\\"Input must be a positive integer\\") fibonacci_sequence = [] a, b = 0, 1 for _ in range(m): fibonacci_sequence.append(a) a, b = b, a + b return fibonacci_sequence def is_fibonacci(number: int) -> bool: Determines if a given number is a Fibonacci number. if not isinstance(number, int): raise TypeError(\\"Input must be an integer\\") if number < 0: raise ValueError(\\"Input cannot be negative\\") # A number is a Fibonacci number if and only if one or both of # (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. def is_perfect_square(x): s = int(math.isqrt(x)) return s * s == x x1 = 5 * number * number + 4 x2 = 5 * number * number - 4 return is_perfect_square(x1) or is_perfect_square(x2)"},{"question":"# Given Task You need to write a function to generate a list representing the Fibonacci sequence up to the nth term, but with a twist: each term is the sum of the previous two terms modulo a given integer `m`. # Function Signature ```python def modified_fibonacci(n: int, m: int) -> list[int]: pass ``` # Input * `n`: An integer denoting the number of terms in the Fibonacci sequence (1 ≤ n ≤ 100). * `m`: An integer to take modulo with (1 ≤ m ≤ 1000). # Output * A list of integers representing the modified Fibonacci sequence. # Example ```python >>> modified_fibonacci(5, 10) [0, 1, 1, 2, 3] >>> modified_fibonacci(7, 5) [0, 1, 1, 2, 3, 0, 3] >>> modified_fibonacci(8, 3) [0, 1, 1, 2, 0, 2, 2, 1] ``` # Edge Cases * If `n` is 1, return a list with a single element [0]. * If `m` is 1, all terms after the first will eventually become 0. * Handle cases with the smallest and largest values for `n` and `m` properly. Write a proper implementation for the function `modified_fibonacci` ensuring it handles the conditions mentioned above.","solution":"def modified_fibonacci(n: int, m: int) -> list[int]: Returns a list of the first n terms of the modified Fibonacci sequence, where each term is the sum of the previous two terms modulo m. Args: n: int - The number of terms in the sequence (1 ≤ n ≤ 100). m: int - The modulus integer (1 ≤ m ≤ 1000). Returns: list[int] - The modified Fibonacci sequence. if n == 1: return [0] sequence = [0, 1] for i in range(2, n): next_term = (sequence[-1] + sequence[-2]) % m sequence.append(next_term) return sequence[:n]"},{"question":"# **Logic Circuit Simulation** As an electrical engineer, you are tasked with simulating the behavior of a basic digital logic circuit. The circuit is composed of AND, OR, and NOT gates. Each gate performs its respective logical operation on the input signals. You need to implement a function that processes a list of logic gate definitions and their connections to simulate the final output of the circuit. **Function Signature**: ```python def simulate_logic_circuit(components: List[str], inputs: Dict[str, int]) -> int: pass ``` **Input**: * `components`: A list of strings representing the logic gates and their connections. Each string has the format `{OUT}=AND({IN1},{IN2})`, `{OUT}=OR({IN1},{IN2})`, or `{OUT}=NOT({IN})`, where `OUT`, `IN1`, and `IN2` are labels for the output and input signals of the gates, respectively. * `inputs`: A dictionary where keys are input labels and values are the binary input values (0 or 1) for these labels. **Output**: * An integer (0 or 1) representing the final output value of the circuit. **Constraints**: * Assume the components list contains at most 100 gate definitions. * The input labels and connection labels are single uppercase letters. * Valid gate definitions and input signals will be provided. **Example**: ```python components = [ \\"A=AND(X,Y)\\", \\"B=OR(A,Z)\\", \\"C=NOT(B)\\" ] inputs = { \\"X\\": 1, \\"Y\\": 0, \\"Z\\": 1 } result = simulate_logic_circuit(components, inputs) assert result == 0 ``` **Explanation**: 1. Calculate the output of `A=AND(X,Y)`: `AND(1,0) = 0` 2. Calculate the output of `B=OR(A,Z)`: `OR(0,1) = 1` 3. Calculate the output of `C=NOT(B)`: `NOT(1) = 0` 4. The final output `C` is `0`. Note: Ensure your implementation handles the connections and logical operations correctly and performs within the provided constraints.","solution":"def simulate_logic_circuit(components, inputs): values = inputs.copy() # Let\'s start with the given inputs for component in components: # parse the component string out, expr = component.split(\'=\') if expr.startswith(\'AND\'): in1, in2 = expr[4:-1].split(\',\') values[out] = values[in1] & values[in2] elif expr.startswith(\'OR\'): in1, in2 = expr[3:-1].split(\',\') values[out] = values[in1] | values[in2] elif expr.startswith(\'NOT\'): in1 = expr[4:-1] values[out] = 1 - values[in1] return values[out]"},{"question":"# Problem Description You are given code for converting a binary search tree into a sorted doubly linked list. Your task is to implement a modified version of this function that will return the head of the doubly linked list. Each node in the doubly linked list should maintain an additional property \'sum_descendants\' which is the sum of values of all its descendants in the original binary search tree including the node itself. # Input and Output Format * **Input**: You will be given the root of a binary search tree. * `root`: The root of the binary search tree. * **Output**: Return the head of the newly created doubly linked list based on the defined transformation rule. # Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * The values of the nodes are in the range `[0, 10000]`. # Implementation Requirements * Implement the function `bst_to_doubly_linked_list(root: Node | None) -> DLLNode | None`. # Example ```python from typing import Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.left: Union[Node, None] = None self.right: Union[Node, None] = None class DLLNode: def __init__(self, value: int = 0) -> None: self.value = value self.sum_descendants: int = value self.prev: Union[DLLNode, None] = None self.next: Union[DLLNode, None] = None def bst_to_doubly_linked_list(root: Node | None) -> DLLNode | None: if not root: return None def in_order_traversal(node: Node) -> list: if not node: return [] return in_order_traversal(node.left) + [node.value] + in_order_traversal(node.right) def node_sum_descendants(node: Node) -> int: if not node: return 0 node.sum_descendants = node.value + node_sum_descendants(node.left) + node_sum_descendants(node.right) return node.sum_descendants node_sum_descendants(root) sorted_values = in_order_traversal(root) if not sorted_values: return None dll_head = DLLNode(sorted_values[0]) current = dll_head for value in sorted_values[1:]: new_node = DLLNode(value) current.next = new_node new_node.prev = current current = new_node return dll_head # Example to test the implementation def print_dll(head: DLLNode | None) -> None: current = head while current: print(f\\"Value: {current.value}, Sum of Descendants: {current.sum_descendants}\\") current = current.next tree = Node(4) tree.left = Node(2) tree.right = Node(5) tree.left.left = Node(1) tree.left.right = Node(3) dll_head = bst_to_doubly_linked_list(tree) print(\\"Doubly Linked List is: \\") print_dll(dll_head) ``` # Explanation Given the BST: ``` 4 / 2 5 / 1 3 ``` The resulting doubly linked list should be: ``` DLL: Value: 1, Sum of Descendants: 1 Value: 2, Sum of Descendants: 6 Value: 3, Sum of Descendants: 3 Value: 4, Sum of Descendants: 15 Value: 5, Sum of Descendants: 5 ```","solution":"from typing import Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.left: Union[Node, None] = None self.right: Union[Node, None] = None class DLLNode: def __init__(self, value: int = 0) -> None: self.value = value self.sum_descendants: int = value self.prev: Union[DLLNode, None] = None self.next: Union[DLLNode, None] = None def bst_to_doubly_linked_list(root: Node | None) -> DLLNode | None: if not root: return None def calculate_sum_descendants(node: Node) -> int: if not node: return 0 node.sum_descendants = node.value + calculate_sum_descendants(node.left) + calculate_sum_descendants(node.right) return node.sum_descendants def convert_to_dll(node: Node) -> DLLNode: if not node: return None left_dll = convert_to_dll(node.left) right_dll = convert_to_dll(node.right) dll_node = DLLNode(node.value) dll_node.sum_descendants = node.sum_descendants if left_dll: left_dll_tail = left_dll while left_dll_tail.next: left_dll_tail = left_dll_tail.next left_dll_tail.next = dll_node dll_node.prev = left_dll_tail if right_dll: right_dll.prev = dll_node dll_node.next = right_dll return left_dll if left_dll else dll_node # Calculate sum of descendants for each node calculate_sum_descendants(root) # Convert BST to doubly linked list head = convert_to_dll(root) return head"},{"question":"# Problem Description You are given a binary tree implementation in Python. Your task is to add a feature to this implementation: **Find All Paths from Root to Leaf**. The method should traverse the binary tree and return a list of all paths from the root node to each leaf node. Each path should be represented as a list of node values. # Objective Implement a method in the `TreeNode` class called `find_all_paths` that returns a list of all paths from the root to the leaf nodes. # Input * A `TreeNode` instance representing the root of the binary tree. # Output * A list of lists, where each inner list is a path from the root node to a leaf node. # Constraints * The binary tree can have up to 1000 nodes. * Node values are unique integers. # Example Given the binary tree: ``` 1 / 2 3 / 4 5 ``` Represented as: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) ``` Calling `root.find_all_paths()` should return: ``` [[1, 2, 4], [1, 2, 5], [1, 3]] ``` # Implementation Notes 1. Use Depth-First Search (DFS) to traverse the tree and gather all paths from the root to the leaf nodes. 2. A leaf node is defined as a node with no left or right child. # Code Template ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_all_paths(self) -> list[list[int]]: Find all paths from the root to leaf nodes. Returns: list[list[int]]: A list containing all paths from the root to leaf nodes. def dfs(node, path, paths): if node is None: return path.append(node.value) if not node.left and not node.right: paths.append(list(path)) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() paths = [] dfs(self, [], paths) return paths # Example usage root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(root.find_all_paths()) # Output should be [[1, 2, 4], [1, 2, 5], [1, 3]] ``` # Requirements * Ensure the function operates efficiently. * Handle edge cases appropriately, such as an empty tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_all_paths(self) -> list: Find all paths from the root to leaf nodes. Returns: list[list[int]]: A list containing all paths from the root to leaf nodes. def dfs(node, path, paths): if node is None: return path.append(node.value) if not node.left and not node.right: paths.append(list(path)) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() paths = [] dfs(self, [], paths) return paths"},{"question":"# Question: Develop a Custom Priority Queue with Modifiable Priorities You are tasked with implementing a custom priority queue where the priority of existing elements can be updated efficiently. The priority queue should support typical operations such as insertion, deletion, extraction of the element with the highest priority, and modification of an element\'s priority. Function Specifications: 1. `insert(element: Any, priority: int) -> None` - **Input**: An element (`element`) and its priority (`priority`). - **Output**: None. - **Example**: ```python pq.insert(\\"apple\\", 5) pq.insert(\\"banana\\", 3) ``` 2. `extract_max() -> Optional[Tuple[Any, int]]` - **Input**: None. - **Output**: The element with the highest priority and its priority as a tuple, or `None` if the queue is empty. - **Example**: ```python assert pq.extract_max() == (\\"apple\\", 5) assert pq.extract_max() == (\\"banana\\", 3) ``` 3. `delete(element: Any) -> bool` - **Input**: An element (`element`). - **Output**: `True` if the element was found and removed, `False` otherwise. - **Example**: ```python pq.insert(\\"cherry\\", 4) assert pq.delete(\\"cherry\\") == True assert pq.delete(\\"orange\\") == False ``` 4. `change_priority(element: Any, new_priority: int) -> bool` - **Input**: An element (`element`) and its new priority (`new_priority`). - **Output**: `True` if the priority was successfully updated, `False` if the element was not found. - **Example**: ```python pq.insert(\\"date\\", 2) assert pq.change_priority(\\"date\\", 6) == True assert pq.change_priority(\\"mango\\", 7) == False ``` Requirements: - Implement an efficient way to update the priority of elements. - Ensure that the extraction of the element with the highest priority is performed in O(log n) time. - Handle edge cases such as inserting duplicate elements, updating priority for non-existent elements, and deleting from an empty queue. Constraints: - Assume all elements are unique. - Priorities are integer values. - The queue must maintain its properties after every operation. Develop a class `PriorityQueue` leveraging appropriate data structures to ensure all operations are efficient and adhere to the requirements specified. ```python class PriorityQueue: def __init__(self): # Initialize the priority queue pass def insert(self, element: Any, priority: int) -> None: # Insert a new element with its priority pass def extract_max(self) -> Optional[Tuple[Any, int]]: # Extract the element with the highest priority pass def delete(self, element: Any) -> bool: # Delete the specified element pass def change_priority(self, element: Any, new_priority: int) -> bool: # Change the priority of the specified element pass ``` Complete the implementation of the `PriorityQueue` class with the methods described above to pass all the provided test cases.","solution":"import heapq class PriorityQueue: def __init__(self): self.pq = [] # list for the heap/priority queue self.entry_finder = {} # mapping of elements to entries self.REMOVED = \'<removed-element>\' # placeholder for a removed element self.counter = 0 # unique sequence count def _add_task(self, element, priority): \'Add a new element or update the priority of an existing element\' if element in self.entry_finder: self._remove_task(element) count = self.counter self.counter += 1 entry = [-priority, count, element] self.entry_finder[element] = entry heapq.heappush(self.pq, entry) def _remove_task(self, element): \'Mark an existing element as REMOVED. Raise KeyError if not found.\' entry = self.entry_finder.pop(element) entry[-1] = self.REMOVED def insert(self, element, priority): self._add_task(element, priority) def extract_max(self): \'Remove and return the highest priority task. Raise KeyError if empty.\' while self.pq: priority, count, element = heapq.heappop(self.pq) if element is not self.REMOVED: del self.entry_finder[element] return (element, -priority) return None def delete(self, element): \'Remove the task from the priority queue.\' if element in self.entry_finder: self._remove_task(element) return True return False def change_priority(self, element, new_priority): \'Change the priority of an existing task\' if element in self.entry_finder: self._add_task(element, new_priority) return True return False"},{"question":"# Coding Assessment Question **Scenario**: You are developing a file synchronization tool, and one of the important features is to find duplicates among the files. To efficiently identify duplicate files, you decide to compute checksums for the file contents and compare them. **Task**: Implement the MD5 algorithm to generate a checksum for a given file input. Your implementation should be efficient and handle edge cases gracefully. Additionally, ensure that the generated checksum is consistent for identical file contents. **Function Signature**: ```python def md5_checksum(file_path: str) -> str: Compute the MD5 checksum for the given file. :param file_path: str - Path to the input file. :return: str - Corresponding MD5 checksum in hexadecimal format. ``` **Input**: - A single string `file_path` representing the path to the file (length of file contents <= 10^9 bytes). **Output**: - A string representing the MD5 checksum of the file contents in hexadecimal format. **Constraints**: - The function should correctly handle the case where the file is empty. - Ensure the function executes efficiently even for very large files. **Example**: ```python # Create temporary files for example demonstration with open(\'example1.txt\', \'w\') as f: f.write(\'testing\') with open(\'example2.txt\', \'w\') as f: f.write(\'another test\') assert md5_checksum(\'example1.txt\') == \'ae2b1fca515949e5d54fb22b8ed95575\' assert md5_checksum(\'example2.txt\') == \'eeb9e7d1e7f34d5e84446d9bf36ff4af\' ```","solution":"import hashlib def md5_checksum(file_path: str) -> str: Compute the MD5 checksum for the given file. :param file_path: str - Path to the input file. :return: str - Corresponding MD5 checksum in hexadecimal format. hash_md5 = hashlib.md5() with open(file_path, \\"rb\\") as f: for chunk in iter(lambda: f.read(4096), b\\"\\"): hash_md5.update(chunk) return hash_md5.hexdigest()"},{"question":"# Image Processing Task You are tasked with creating an image processing function that applies a filter to an image and saves the modified image in a specific format. Problem Statement Implement the function `apply_filter_and_save_image(image_path: str, filter_type: str, output_format: str = \'JPEG\') -> str` which will: 1. Load an image from the given file path. 2. Apply a specified filter to the image. 3. Save the modified image in the specified format. 4. Ensure that each modified image is saved with a unique name to avoid overwriting existing files. The available filters are: - \'BLUR\': Blurs the image. - \'CONTOUR\': Applies a contour effect. - \'DETAIL\': Enhances the detail of the image. - \'EDGE_ENHANCE\': Enhances edges in the image. - \'SHARPEN\': Sharpens the image. You must use the Python Imaging Library (PIL) or its successor, Pillow, for image processing tasks. Input and Output Formats * **Input**: * `image_path` (string): Path to the input image file. * `filter_type` (string): One of the available filters - \'BLUR\', \'CONTOUR\', \'DETAIL\', \'EDGE_ENHANCE\', \'SHARPEN\'. * `output_format` (string): Desired format of the output image (e.g., \'JPEG\', \'PNG\'). Default is \'JPEG\'. * **Output**: * A string indicating the file name where the modified image has been saved. Constraints: * If the `image_path` does not exist or is not a valid image file, raise a `FileNotFoundError` with a message \\"Image file not found\\". * If the `filter_type` is not among the specified filters, raise a `ValueError` with a message \\"Invalid filter type\\". * The function should not allow overwriting of existing files. Example ```python # Example usage output_file_name = apply_filter_and_save_image(\\"path/to/image.jpg\\", \\"BLUR\\", \\"PNG\\") print(f\\"Filtered image saved as: {output_file_name}\\") ``` This new question maintains the integrity of the question set by adhering to the same level of complexity, integrating domain-specific tasks (image processing), and providing clear and manageable constraints.","solution":"from PIL import Image, ImageFilter import os import uuid def apply_filter_and_save_image(image_path: str, filter_type: str, output_format: str = \'JPEG\') -> str: Applies a specified filter to the image and saves the modified image in the specified format. Args: - image_path (str): Path to the input image file. - filter_type (str): One of the available filters - \'BLUR\', \'CONTOUR\', \'DETAIL\', \'EDGE_ENHANCE\', \'SHARPEN\'. - output_format (str): Desired format of the output image. Default is \'JPEG\'. Returns: - str: Path to the saved modified image. # Validate the image path if not os.path.exists(image_path) or not os.path.isfile(image_path): raise FileNotFoundError(\\"Image file not found\\") # Validate the filter type filters = { \'BLUR\': ImageFilter.BLUR, \'CONTOUR\': ImageFilter.CONTOUR, \'DETAIL\': ImageFilter.DETAIL, \'EDGE_ENHANCE\': ImageFilter.EDGE_ENHANCE, \'SHARPEN\': ImageFilter.SHARPEN } if filter_type not in filters: raise ValueError(\\"Invalid filter type\\") # Load the image image = Image.open(image_path) # Apply the filter image = image.filter(filters[filter_type]) # Generate a unique file name base_name = os.path.splitext(os.path.basename(image_path))[0] unique_suffix = uuid.uuid4().hex output_file_name = f\\"{base_name}_{unique_suffix}.{output_format.lower()}\\" # Save the modified image image.save(output_file_name, format=output_format) return output_file_name"},{"question":"# Question: Python Solution Performance Optimizer for Data Processing You are required to implement a data processing utility that optimizes the performance of a simplified data analysis task. The utility reads a large dataset, performs specified transformations, and outputs the result. Your focus should be on efficiency and handling of large datasets effectively. # Task: 1. **Implement the Data Processing Utility**: - Create a class `DataProcessor` with methods to: - Read a dataset from a text file. - Apply transformations including filtering, mapping, and reducing the data. - Output the processed data to a new text file. 2. **Optimize and Test**: - Analyze the efficiency of your algorithm in terms of time and space complexity. - Write appropriate unittests to ensure that the implementation handles edge cases and performs correctly. # Specifications: - **`DataProcessor` Class**: - `__init__(self, input_file: str, output_file: str)`: Initialize the processor with input and output file names. - `read_data(self) -> list[str]`: Read the dataset from the input file into a list of strings. - `filter_data(self, condition: Callable[[str], bool]) -> list[str]`: Filter the dataset based on the provided condition function. - `map_data(self, transform: Callable[[str], str]) -> list[str]`: Apply a transformation to each element of the dataset. - `reduce_data(self, reducer: Callable[[Any, str], Any], initializer: Any) -> Any`: Reduce the dataset to a single value using the provided reducer function. - `write_data(self, data: list[str])`: Write the transformed data to the output file. - `process(self, condition: Callable[[str], bool], transform: Callable[[str], str], reducer: Callable[[Any, str], Any], initializer: Any) -> Any`: Perform an end-to-end processing step. # Input and Output: - **Input**: - File name strings for input and output files. - Condition, transformation, and reducer functions. - Initializer for the reducer. - **Output**: - List of processed strings written to the output file. - Result of the reduction process. # Constraints: - The input file will contain one data entry per line. - The condition function will return a boolean. - The transform function will return a transformed string. - The reducer function will return an accumulated result. # Example: ```python # Define a condition function def condition(line: str) -> bool: return \\"important\\" in line # Define a transformation function def transform(line: str) -> str: return line.upper() # Define a reducer function def reducer(acc, line: str): return acc + len(line) # Initialize data processor dp = DataProcessor(\'input.txt\', \'output.txt\') # Read data from input file data = dp.read_data() # Filter data based on condition filtered_data = dp.filter_data(condition) # Map data using the transformation function mapped_data = dp.map_data(transform) # Reduce data to get the total length of processed lines total_length = dp.reduce_data(reducer, 0) # Write the processed data to output file dp.write_data(mapped_data) # Perform full processing step result = dp.process(condition, transform, reducer, 0) print(result) # Output: total length of processed lines ``` # Deliverables: - The complete implementation of `DataProcessor`. - Analysis of the implemented code regarding its time and space complexity. - Unittests to validate the correct operation of the utility for various cases, including large datasets.","solution":"from typing import Callable, Any, List class DataProcessor: def __init__(self, input_file: str, output_file: str): self.input_file = input_file self.output_file = output_file self.data = [] def read_data(self) -> List[str]: with open(self.input_file, \'r\') as file: self.data = file.readlines() return self.data def filter_data(self, condition: Callable[[str], bool]) -> List[str]: return [line for line in self.data if condition(line)] def map_data(self, transform: Callable[[str], str]) -> List[str]: return [transform(line) for line in self.data] def reduce_data(self, reducer: Callable[[Any, str], Any], initializer: Any) -> Any: result = initializer for line in self.data: result = reducer(result, line) return result def write_data(self, data: List[str]): with open(self.output_file, \'w\') as file: file.writelines(data) def process(self, condition: Callable[[str], bool], transform: Callable[[str], str], reducer: Callable[[Any, str], Any], initializer: Any) -> Any: self.read_data() self.data = self.filter_data(condition) self.data = self.map_data(transform) self.write_data(self.data) return self.reduce_data(reducer, initializer)"},{"question":"# Coding Question: Calculate Light Travel Time You are given the task of implementing a function that calculates the time in seconds it takes for light to travel a certain distance in a vacuum. The speed of light in a vacuum (`c`) is a constant value of `299,792,458` meters per second. The formula to calculate the travel time `T` is: T = D / c Where: - `D` is the distance in meters (positive float). Your task is to implement the function `light_travel_time(distance)` that returns the travel time `T`. # Function Signature ```python def light_travel_time(distance: float) -> float: pass ``` # Input - `distance` (float): The distance in meters (positive). # Output - Returns a single float: The travel time in seconds. # Constraints - The numeric value of the distance will be provided within a range that makes the result meaningful in the context of travel. # Edge Cases - Handle cases where the input parameter is invalid (e.g., negative distance) by raising a `ValueError` with an appropriate error message. # Example ```python >>> light_travel_time(299792458) 1.0 >>> light_travel_time(599584916) 2.0 >>> light_travel_time(1498962290) 5.0 >>> light_travel_time(-1000) Traceback (most recent call last): ... ValueError: Distance must be a positive value ``` # Explanation The light travel time is calculated by dividing the input distance by the speed of light. If the distance is negative, a `ValueError` is raised. The expected output is a float representing the time in seconds for light to travel the given distance.","solution":"def light_travel_time(distance: float) -> float: Returns the travel time in seconds for light to travel the given distance in a vacuum. :param distance: Distance in meters (positive float) :return: Travel time in seconds (float) :raises ValueError: If distance is not a positive float SPEED_OF_LIGHT = 299792458 # Speed of light in meters per second if distance < 0: raise ValueError(\\"Distance must be a positive value\\") return distance / SPEED_OF_LIGHT"},{"question":"# Problem Statement Write a function that calculates the greatest common divisor (GCD) of two given non-negative integers using the Euclidean algorithm and returns the GCD in binary form prefixed with \\"0b\\". # Function Signature ```python def binary_gcd(a: int, b: int) -> str: pass ``` # Input * `a` (int): A non-negative integer. * `b` (int): A non-negative integer. # Output * A string that represents the GCD of the two given integers in binary form prefixed with \\"0b\\". # Constraints * `0 <= a, b <= 10^6` * If `a` or \'b\' is negative, your function should raise a ValueError with the message \\"the value of both inputs must be positive\\". * If `a` or \'b\' is not an integer, your function should raise a TypeError. # Example ```python >>> binary_gcd(48, 18) \'0b110\' >>> binary_gcd(54, 24) \'0b110\' >>> binary_gcd(99, 78) \'0b11\' >>> binary_gcd(0, 255) \'0b11111111\' >>> binary_gcd(128, 256) \'0b10000000\' ``` # Notes 1. Ensure inputs are validated for type and value restrictions as mentioned in the constraints. 2. The function should use the Euclidean algorithm to calculate the GCD. 3. The implementation should handle the given range of values efficiently.","solution":"def binary_gcd(a: int, b: int) -> str: if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Both inputs must be integers.\\") if a < 0 or b < 0: raise ValueError(\\"The value of both inputs must be positive.\\") while b != 0: a, b = b, a % b return bin(a)"},{"question":"# Advanced Coding Challenge: Efficient String Matching with Suffix Trees Background String matching is a fundamental problem in computer science with numerous applications. The naive string matching algorithm has a time complexity of O(M * N), where M is the length of the pattern and N is the length of the text. More efficient algorithms exist, such as the Suffix Tree-based approach, which can reduce the time complexity to O(M + N). Task Your goal is to improve the efficiency of a string matching function by implementing a Suffix Tree to search for all occurrences of a pattern in a given text. Requirements 1. Construct a Suffix Tree for the given text. 2. Implement a method to search for a pattern within the constructed Suffix Tree. 3. Return the starting indices of all occurrences of the pattern in the text. Inputs and Outputs - Input: A string `text` and a string `pattern`. - Output: A list of starting indices where `pattern` is found in `text`. Constraints - The length of `text`, N, will be in the range of 1 to 100,000 characters. - The length of `pattern`, M, will be in the range of 1 to 1,000 characters. Instructions 1. Develop the Suffix Tree class with methods for construction and pattern searching. 2. Optimize your implementation to handle large input sizes efficiently. Example ```python text = \\"bananabanana\\" pattern = \\"ana\\" # Output: [1, 3, 7, 9] # Example output provided indices where \\"ana\\" is found in \\"bananabanana\\". ``` Ensure that your solution can handle edge cases such as overlapping patterns and patterns not present in the text.","solution":"class SuffixTreeNode: def __init__(self): self.children = {} self.index = -1 class SuffixTree: def __init__(self, text): self.root = SuffixTreeNode() self.text = text self._build_suffix_tree() def _build_suffix_tree(self): for i in range(len(self.text)): current_node = self.root suffix = self.text[i:] for char in suffix: if char not in current_node.children: current_node.children[char] = SuffixTreeNode() current_node = current_node.children[char] current_node.index = i def search(self, pattern): result = [] current_node = self.root for char in pattern: if char not in current_node.children: return result current_node = current_node.children[char] self._collect_indices(current_node, result) return result def _collect_indices(self, node, result): if node.index != -1: result.append(node.index) for child in node.children.values(): self._collect_indices(child, result) def find_pattern_indices(text, pattern): suffix_tree = SuffixTree(text) indices = suffix_tree.search(pattern) return sorted(indices) # Example usage text = \\"bananabanana\\" pattern = \\"ana\\" print(find_pattern_indices(text, pattern)) # Output: [1, 3, 7, 9]"},{"question":"# Question: Numeric Palindrome Generator You are given a coding task to generate a numeric palindrome that is at least n digits long. A numeric palindrome reads the same backward as forward. Given an integer n, your task is to find the smallest numeric palindrome with at least n digits. # Function Signature ```python def smallest_palindrome(n: int) -> int: ``` # Input - `n` (int): A positive integer (1 <= `n` <= 1000). # Output - Returns an integer representing the smallest numeric palindrome with at least `n` digits. # Constraints 1. `1 <= n <= 1000` 2. Your solution should be able to handle very large numbers efficiently. # Example ```python >>> smallest_palindrome(1) 1 >>> smallest_palindrome(2) 11 >>> smallest_palindrome(3) 101 >>> smallest_palindrome(4) 1001 ``` # Explanation For `n = 1`, the smallest single-digit palindrome is 1. For `n = 2`, the smallest two-digit palindrome is 11. For `n = 3`, the smallest three-digit palindrome is 101. The pattern continues as the length of required digits increases. # Hints 1. Consider how you can construct the smallest palindrome by focusing on the properties of palindromic numbers. 2. Utilizing string manipulation or mathematical operations may help in generating the palindrome efficiently.","solution":"def smallest_palindrome(n: int) -> int: This function returns the smallest numeric palindrome with at least n digits. if n == 1: return 1 half = 10 ** ((n - 1) // 2) prefix = half if n % 2 == 0: # Even length palindrome palindrome = int(str(prefix) + str(prefix)[::-1]) else: # Odd length palindrome palindrome = int(str(prefix) + str(prefix)[::-1][1:]) return palindrome"},{"question":"# Question: Problem Statement: You are tasked with writing a function to simulate the behavior of a 4-bit ripple carry adder using only basic logic gates (AND, OR, and XOR). The 4-bit ripple carry adder will add two 4-bit binary numbers, producing a 4-bit sum and a carry-out. Function Signature: ```python def ripple_carry_adder(a: int, b: int) -> Tuple[int, int]: Compute the 4-bit sum and carry-out using a ripple carry adder :param a: First 4-bit integer (0 to 15) :param b: Second 4-bit integer (0 to 15) :return: A tuple with the 4-bit sum and the carry-out (sum, carry-out) ``` Input: - `a`: An integer between 0 and 15, representing the first 4-bit binary number. - `b`: An integer between 0 and 15, representing the second 4-bit binary number. Output: - A tuple of two integers: - The first integer is the 4-bit sum (0 to 15). - The second integer is the carry-out (0 or 1). Example: ```python >>> ripple_carry_adder(3, 6) (9, 0) >>> ripple_carry_adder(7, 8) (15, 0) >>> ripple_carry_adder(15, 1) (0, 1) >>> ripple_carry_adder(9, 6) (15, 0) ``` Constraints: - Input values will always be integers between 0 and 15. - You must simulate the addition using only basic logic gates functions: AND, OR, and XOR. - You may define auxiliary functions to represent these basic gates. Performance Requirements: The function should operate in constant time O(1) due to fixed-bit operations. # Note: Ensure you handle all possible combinations of 4-bit additions and correctly compute both the 4-bit sum and the carry-out. ```python def and_gate(input_1: int, input_2: int) -> int: return input_1 & input_2 def or_gate(input_1: int, input_2: int) -> int: return input_1 | input_2 def xor_gate(input_1: int, input_2: int) -> int: return input_1 ^ input_2 ``` Good luck!","solution":"from typing import Tuple def and_gate(input_1: int, input_2: int) -> int: return input_1 & input_2 def or_gate(input_1: int, input_2: int) -> int: return input_1 | input_2 def xor_gate(input_1: int, input_2: int) -> int: return input_1 ^ input_2 def full_adder(bit_a: int, bit_b: int, carry_in: int) -> Tuple[int, int]: sum_ab = xor_gate(xor_gate(bit_a, bit_b), carry_in) carry_out = or_gate(and_gate(bit_a, bit_b), and_gate(carry_in, xor_gate(bit_a, bit_b))) return sum_ab, carry_out def ripple_carry_adder(a: int, b: int) -> Tuple[int, int]: a_bits = [(a >> i) & 1 for i in range(4)] b_bits = [(b >> i) & 1 for i in range(4)] carry = 0 sum_bits = [] for bit_a, bit_b in zip(a_bits, b_bits): sum_bit, carry = full_adder(bit_a, bit_b, carry) sum_bits.append(sum_bit) sum_result = sum((bit << i) for i, bit in enumerate(sum_bits)) return sum_result, carry"},{"question":"# Class-Based Complex Numbers You are required to implement a `ComplexNumber` class that supports basic complex number operations. The class should have methods to add, subtract, multiply, divide, and compute the modulus of complex numbers. Each complex number is represented as `a + bi`, where `a` is the real part and `b` is the imaginary part. **Class Definition**: ```python class ComplexNumber: def __init__(self, real: float, imaginary: float): ... def add(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... def subtract(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... def multiply(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... def divide(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... def modulus(self) -> float: ... ``` **Method Details**: 1. **Initialization (`__init__`)**: * **Input**: Two floats, representing the real and imaginary parts. * **Store**: These as instance variables `real` and `imaginary`. 2. **Addition (`add`)**: * **Input**: Another `ComplexNumber` object. * **Output**: A new `ComplexNumber` that is the sum of the current complex number and the input complex number. 3. **Subtraction (`subtract`)**: * **Input**: Another `ComplexNumber` object. * **Output**: A new `ComplexNumber` that is the difference between the current complex number and the input complex number. 4. **Multiplication (`multiply`)**: * **Input**: Another `ComplexNumber` object. * **Output**: A new `ComplexNumber` that is the product of the current complex number and the input complex number. 5. **Division (`divide`)**: * **Input**: Another `ComplexNumber` object. * **Output**: A new `ComplexNumber` that is the quotient of the current complex number divided by the input complex number. * **Note**: Handle division by zero by raising an appropriate exception. 6. **Modulus (`modulus`)**: * **Output**: A float representing the modulus of the complex number, calculated as: ``` modulus = sqrt(real^2 + imaginary^2) ``` **Example Usage**: ```python c1 = ComplexNumber(1, 2) c2 = ComplexNumber(3, 4) # Addition result_add = c1.add(c2) print(result_add) # Output: ComplexNumber(4, 6) # Subtraction result_subtract = c1.subtract(c2) print(result_subtract) # Output: ComplexNumber(-2, -2) # Multiplication result_multiply = c1.multiply(c2) print(result_multiply) # Output: ComplexNumber(-5, 10) # Division result_divide = c1.divide(c2) print(result_divide) # Output: ComplexNumber(0.44, 0.08) # Modulus result_modulus = c1.modulus() print(result_modulus) # Output: 2.236 ```","solution":"import math class ComplexNumber: def __init__(self, real: float, imaginary: float): self.real = real self.imaginary = imaginary def add(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary) def subtract(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary) def multiply(self, other: \'ComplexNumber\') -> \'ComplexNumber\': real_part = self.real * other.real - self.imaginary * other.imaginary imaginary_part = self.real * other.imaginary + self.imaginary * other.real return ComplexNumber(real_part, imaginary_part) def divide(self, other: \'ComplexNumber\') -> \'ComplexNumber\': if other.real == 0 and other.imaginary == 0: raise ValueError(\\"Cannot divide by zero.\\") denominator = other.real**2 + other.imaginary**2 real_part = (self.real * other.real + self.imaginary * other.imaginary) / denominator imaginary_part = (self.imaginary * other.real - self.real * other.imaginary) / denominator return ComplexNumber(real_part, imaginary_part) def modulus(self) -> float: return math.sqrt(self.real**2 + self.imaginary**2) def __repr__(self) -> str: return f\\"ComplexNumber({self.real}, {self.imaginary})\\""},{"question":"# Problem Statement You are developing a recommendation system for an e-commerce platform. To personalize recommendations, a function is required to filter out items from a catalog based on user-defined criteria. Each item in the catalog is represented by a dictionary containing various attributes like \\"price\\", \\"rating\\", and \\"category\\". Your task is to implement a function that filters items in the catalog based on a given set of criteria. The function should return a list of items that meet all the specified criteria. # Function Signature ```python def filter_catalog(catalog: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: pass ``` # Input * `catalog`: A list of dictionaries, where each dictionary represents an item with various attributes. * `criteria`: A dictionary containing the filter conditions. Each key corresponds to an attribute, and the value is the desired value for that attribute. # Output * A list of dictionaries, each representing an item that matches all the given criteria. # Constraints * The `catalog` can contain up to 10^5 items. * Each item dictionary contains up to 10 key-value pairs. * Criteria dictionary can have up to 10 key-value pairs, and criteria values are exact matches (for `int` and `float`, use equality; for `str`, use exact string comparison). # Examples ```python catalog = [ {\\"id\\": 1, \\"price\\": 100, \\"rating\\": 4.5, \\"category\\": \\"electronics\\"}, {\\"id\\": 2, \\"price\\": 150, \\"rating\\": 4.0, \\"category\\": \\"electronics\\"}, {\\"id\\": 3, \\"price\\": 80, \\"rating\\": 3.5, \\"category\\": \\"books\\"}, {\\"id\\": 4, \\"price\\": 120, \\"rating\\": 4.8, \\"category\\": \\"books\\"} ] criteria = {\\"category\\": \\"electronics\\", \\"rating\\": 4.0} >>> filter_catalog(catalog, criteria) [ {\\"id\\": 1, \\"price\\": 100, \\"rating\\": 4.5, \\"category\\": \\"electronics\\"}, {\\"id\\": 2, \\"price\\": 150, \\"rating\\": 4.0, \\"category\\": \\"electronics\\"} ] criteria = {\\"category\\": \\"books\\", \\"rating\\": 5.0} >>> filter_catalog(catalog, criteria) [] ``` # Notes 1. Ensure to handle cases where criteria have no matching items. 2. Optimizing for quick lookups where possible is encouraged, given potentially large input sizes. 3. The function should be efficient both in terms of time and space complexity, preferably O(n * m) in the worst case, where n is the number of items in the catalog and m is the number of criteria.","solution":"from typing import List, Dict, Any def filter_catalog(catalog: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: Filters items in the catalog based on the given set of criteria. Parameters: catalog (List[Dict[str, Any]]): List of items where each item is a dictionary with various attributes. criteria (Dict[str, Any]): Dictionary containing the filter conditions. Returns: List[Dict[str, Any]]: List of items that meet all the specified criteria. result = [] for item in catalog: match = all(item.get(key) == value for key, value in criteria.items()) if match: result.append(item) return result"},{"question":"You are working on an inventory management system that helps businesses track their stock levels and reorder products when necessary. The system should send an email notification when the stock level of an item falls below the reorder threshold. To ensure your code sends the correct email, you should write unit tests that accurately mock the email sending function without actually sending any emails. # Task Using the structure provided in the previous example snippet, write a Python function, `test_send_reorder_notification`, to mock an email sending function for a `send_email` method. The test should simulate sending an email notification and verify that the email sending function was called with the correct parameters. Requirements: - Create a class `FakeEmailServer` that mimics the real email server. - Mock the `send_email` method to return a controlled response (`{\\"status\\": \\"sent\\", \\"message\\": \\"Email sent successfully\\"}`). - Ensure the mock function checks the parameters sent in the email function, such as recipient email, subject, and body. - Use the `monkeypatch` fixture to apply the mock. - Verify that the returned response contains the expected keys and values. - Handle erroneous scenarios such as incorrect email format or missing recipient address with appropriate assertions. Input and Output: - You don’t need to worry about the input and output format as it\'s a unit test configuration. - If the setup is correct, the unit test should pass without sending actual emails. Constraints: - Assume the email sending function is defined in a function `send_email_to_supplier`. - The function to test can be named `send_reorder_notification`, which calls `send_email_to_supplier`. - Email operations should be fully mocked. # Example: ```python def send_email_to_supplier(recipient, subject, body): # This function would typically send an email pass def send_reorder_notification(recipient, item_name): subject = \\"Reorder Notification\\" body = f\\"The stock level of {item_name} has fallen below the reorder threshold. Please reorder as soon as possible.\\" response = send_email_to_supplier(recipient, subject, body) return response ``` Create the mock unit test function `test_send_reorder_notification` for the above example. --- This new question aims to test skills in mocking and unit testing email functionality, similar to how the original question focused on mocking API responses. The complexity and scope are aligned, requiring an understanding of Python, unit testing, and mocking techniques without directly copying from the sample question.","solution":"def send_email_to_supplier(recipient, subject, body): # This function would typically send an email pass def send_reorder_notification(recipient, item_name): Send a reorder notification email to a supplier. Args: recipient (str): The email of the recipient. item_name (str): The name of the item that needs reordering. Returns: dict: A mock response indicating the email was sent. subject = \\"Reorder Notification\\" body = f\\"The stock level of {item_name} has fallen below the reorder threshold. Please reorder as soon as possible.\\" response = send_email_to_supplier(recipient, subject, body) return response"},{"question":"# Sum of All Left Leaves in a Binary Tree In this exercise, you are required to write a function to calculate the sum of all left leaves in a binary tree. A leaf is a node with no children, and a left leaf is a leaf that is a left child of its parent. Consider the following binary tree as an example: ``` 3 / 9 20 / 15 7 ``` The left leaves are 9 and 15, so the sum is 24. # Requirements: * **Function Name**: `sum_of_left_leaves` * **Input**: A `Node` object representing the root of the binary tree. * **Output**: An integer representing the sum of all left leaves in the binary tree. * **Constraints**: * The number of nodes in the tree is in the range [0, 10^4]. * `Node` data values will be of integer type. * **Performance**: * The function should have a time complexity of (O(n)) where (n) is the number of nodes in the tree. * The space complexity should be (O(h)), where (h) is the height of the tree. You should handle the edge case where the input is `None` (i.e., an empty tree), which should return a sum of 0. **Function Signature**: ```python def sum_of_left_leaves(root: Node | None) -> int: pass ``` # Example ```python # Example input tree # The below tree: # 3 # / # 9 20 # / # 15 7 # Example usage root = Node(3) root.left = Node(9) root.right = Node(20) root.right.left = Node(15) root.right.right = Node(7) print(sum_of_left_leaves(root)) # Output: 24 ``` **Tip**: You can utilize a recursive approach or an iterative approach using a stack or queue to solve this problem. Ensure to test for edge cases like an empty tree and trees with varying structures. # Notes * You may assume the given `Node` class and tree creation functions (`make_tree`) are available to you. * Your solution will be tested for performance efficiency and correctness. * Write your solution with clarity and ensure to comment your code where necessary. --- This new question maintains the style, complexity, and scope of the initial question set, while introducing a different yet related problem in binary tree operations.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_left_leaves(root: Node | None) -> int: Calculate the sum of all left leaves in a binary tree. :param root: Root node of the binary tree :return: Sum of all left leaf nodes if root is None: return 0 def is_leaf(node): return node is not None and node.left is None and node.right is None def dfs(node, is_left): if node is None: return 0 if is_leaf(node) and is_left: return node.value return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"# Sorting Students by GPA You are tasked with developing a program that reads a list of student records, sorts them by their GPA in descending order, and prints the sorted list. Each student record contains the student\'s name and their GPA. Implement the following function: 1. **sort_students_by_gpa**: This function should take a list of tuples, where each tuple consists of a student\'s name (str) and their GPA (float). The function should return a new list of tuples, sorted by GPA in descending order. * **Input**: A list of tuples. Each tuple contains a string (student\'s name) and a float (GPA). * **Output**: A list of tuples sorted by GPA in descending order. * **Constraints**: - The input list may contain up to 100 student records. - GPAs are floating-point numbers between 0.0 and 4.0. - Student names are non-empty strings with a maximum length of 100 characters. - If two students have the same GPA, they should be sorted by their names in ascending order. # Example ```python # Example usage if __name__ == \\"__main__\\": students = [ (\\"Alice Johnson\\", 3.5), (\\"Bob Smith\\", 3.8), (\\"Charlie White\\", 3.5), (\\"David Brown\\", 3.9) ] sorted_students = sort_students_by_gpa(students) for student in sorted_students: print(f\\"{student[0]}: {student[1]}\\") ``` # Expected Output ```plaintext David Brown: 3.9 Bob Smith: 3.8 Alice Johnson: 3.5 Charlie White: 3.5 ``` # Notes - Ensure robust handling of edge cases, such as identical GPAs for multiple students. - Consider using Python\'s built-in sorting capabilities to simplify your implementation. - Emphasize readability and efficiency in your solution, avoiding unnecessary complexity.","solution":"def sort_students_by_gpa(students): Sorts a list of students by their GPA in descending order. If two students have the same GPA, they should be sorted by their names in ascending order. :param students: List of tuples, where each tuple contains a student\'s name (str) and their GPA (float). :return: List of tuples sorted by GPA in descending order. # First, sort by name in ascending order to ensure correct tie-breaking students_sorted = sorted(students, key=lambda student: student[0]) # Then, sort by GPA in descending order students_sorted = sorted(students_sorted, key=lambda student: student[1], reverse=True) return students_sorted"},{"question":"# Binary Search Tree Height Calculation Context Binary Search Trees (BST) are a crucial data structure in computer science, known for their logarithmic time complexity for search operations. One common task involving BSTs involves calculating their height. The height of a BST is the number of edges in the longest path from the root node to a leaf node. Task Implement a function `calculate_bst_height(root: TreeNode) -> int` that computes the height of a given Binary Search Tree. The BST is represented by nodes defined in the TreeNode class, where each node has a value, a left child, and a right child. Input and Output Formats * **Input**: - `root`: The root node of the Binary Search Tree. The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: - An integer representing the height of the BST. Constraints * The number of nodes in the BST is between 1 and 10,000. * The TreeNode values are unique integers. Performance Requirements - Aim to achieve an O(n) time complexity where n is the number of nodes in the tree. Example ```python def calculate_bst_height(root: TreeNode) -> int: if root is None: return -1 left_height = calculate_bst_height(root.left) right_height = calculate_bst_height(root.right) return max(left_height, right_height) + 1 # Example usage: root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(20) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(25) result = calculate_bst_height(root) print(f\\"The height of the BST is {result}\\") ``` Expected Output: ``` The height of the BST is 2 ``` Notes * Consider edge cases such as a tree with a single node or an unbalanced tree. * Ensure your function handles the maximum constraint efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_bst_height(root: TreeNode) -> int: if root is None: return -1 # base case: the height of a non-existent node is considered -1 for edge calculation purposes left_height = calculate_bst_height(root.left) right_height = calculate_bst_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Binary Tree Inorder Traversal **Context**: In computer science, a binary tree is a widely-used tree data structure where each node has at most two children, referred to as the left child and the right child. Traversing a binary tree involves visiting all the nodes in a specific order. One common traversal method is inorder traversal, where nodes are visited in the order: left subtree, root, right subtree. **Problem Statement**: Your task is to implement an inorder traversal of a binary tree. The provided `TreeNode` class represents the nodes of the tree, and the `BinaryTree` class includes the structure. You will need to write a method `inorder` in the `BinaryTree` class to perform the inorder traversal, returning a list of the values of the nodes in the inorder sequence. Requirements: * Implement the `inorder` method in the `BinaryTree` class. * Traverse the binary tree in an inorder manner. * Return a list of node values collected during the traversal. # Function Signature ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def inorder(self): pass ``` # Input & Output * There are no inputs to the `inorder` method. * It should return a list of integers, representing the values of nodes in the inorder traversal sequence. # Example ```python >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> tree = BinaryTree(root) >>> tree.inorder() [1, 3, 2] >>> empty_tree = BinaryTree() >>> empty_tree.inorder() [] ``` # Constraints * Assume the tree has at most 1000 nodes. # Solution Template ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def inorder(self): result = [] def _inorder(node): if node: _inorder(node.left) result.append(node.value) _inorder(node.right) _inorder(self.root) return result ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def inorder(self): result = [] def _inorder(node): if node: _inorder(node.left) result.append(node.value) _inorder(node.right) _inorder(self.root) return result"},{"question":"# Question You are required to implement a text-based Sudoku solver that follows these specific guidelines: 1. The solver should handle the standard 9x9 Sudoku puzzles. 2. It should identify and fill each empty cell, represented by a `.` (dot), with the appropriate digit from `1` to `9`. 3. The solution should ensure that each number appears only once in each row, each column, and each of the nine 3x3 sub-grids. # Function Requirements solve_sudoku * **Input**: A list of strings `board`, where each string represents a row of the Sudoku board. * **Output**: A solved Sudoku board in the same format as the input. # Constraints * The input board will always be a valid 9x9 grid. * It is guaranteed that there is always one unique solution. # Example ```python board = [ \\"53..7....\\", \\"6..195...\\", \\".98....6.\\", \\"8...6...3\\", \\"4..8.3..1\\", \\"7...2...6\\", \\".6....28.\\", \\"...419..5\\", \\"....8..79\\" ] solved_board = solve_sudoku(board) for row in solved_board: print(row) ``` Example Output: ``` \\"534678912\\" \\"672195348\\" \\"198342567\\" \\"859761423\\" \\"426853791\\" \\"713924856\\" \\"961537284\\" \\"287419635\\" \\"345286179\\" ``` Notes: * You must implement an efficient backtracking approach to ensure that the solution is found within a reasonable timeframe. * Ensure that your code handles potential edge cases, such as boards with minimal empty cells or boards requiring extensive backtracking.","solution":"def solve_sudoku(board): Solves a given Sudoku puzzle. Args: board: a list of strings representing the 9x9 Sudoku board. Returns: A list of strings representing the solved Sudoku board. # Convert input to a mutable 2D list board = [list(row) for row in board] def is_safe(board, row, col, num): # Check if \'num\' is not present in the row if num in board[row]: return False # Check if \'num\' is not present in the column for r in range(9): if board[r][col] == num: return False # Check if \'num\' is not present in 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(3): for c in range(3): if board[start_row + r][start_col + c] == num: return False return True def solve(): for r in range(9): for c in range(9): if board[r][c] == \'.\': for num in \'123456789\': if is_safe(board, r, c, num): board[r][c] = num if solve(): return True board[r][c] = \'.\' return False return True solve() return [\'\'.join(row) for row in board]"},{"question":"# Chessboard Problem You are given a standard chessboard of size (8 times 8) represented as an 8x8 matrix filled with 0s and 1s. Write a function called `check_legal_moves` that takes the chessboard matrix and a tuple of integers representing the position of a knight on the board and returns a list of all legal moves the knight can make from that position. A knight moves in an L-shape: two squares in one direction and then one square in a perpendicular direction. Additional Requirements: 1. **Parameter Validation**: Ensure the position of the knight is a valid board position (i.e., the row and column indices should each be in the range 0-7). Raise an `IndexError` if the position is not valid. 2. **Occupied Squares**: If a knight\'s move lands on a square that already contains a 1, that move is deemed illegal and should not be included in the output. 3. **Output Format**: The function should return a list of tuples, each containing two integers representing legal destination positions for the knight. Input and Output Format: * **Input**: The function will receive the chessboard as an 8x8 list of lists of integers and a tuple of two integers representing the knight\'s current position. * **Output**: A list of tuples, each representing a legal move position. Constraints: * The chessboard will always be a valid 8x8 binary matrix. * The knight\'s starting position will always be an integer tuple. # Example Usage ```python >>> chessboard = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] >>> position = (4, 2) >>> check_legal_moves(chessboard, position) [(2, 1), (2, 3), (3, 0), (3, 4), (5, 0), (5, 4), (6, 1)] ``` # Function Signature ```python def check_legal_moves(chessboard: list[list[int]], position: tuple[int, int]) -> list[tuple[int, int]]: pass ```","solution":"def check_legal_moves(chessboard, position): Returns a list of legal moves for a knight in a standard 8x8 chessboard. if not (0 <= position[0] < 8 and 0 <= position[1] < 8): raise IndexError(\\"Position of the knight is not valid\\") knight_moves = [ (-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1) ] legal_moves = [] for move in knight_moves: new_row = position[0] + move[0] new_col = position[1] + move[1] if 0 <= new_row < 8 and 0 <= new_col < 8 and chessboard[new_row][new_col] == 0: legal_moves.append((new_row, new_col)) return legal_moves"},{"question":"# Context: You are developing a financial application that requires processing and analyzing stock price data. One common analysis involves calculating the moving average for a given period to smooth out price data and identify trends. # Problem: Given the `StockData` class defined above, extend the functionality to include a method that calculates the `moving_average` for a specific period. Ensure your implementation is efficient, as it will be operated on large time series datasets. # Function Signature: ```python def moving_average(self, period: int) -> List[float]: Calculates the moving average over the specified period. :param period: The number of days over which to calculate the moving average. :return: A list of floats representing the moving average. ``` # Input: - `self`: An instance of `StockData` containing the stock prices as a list of floats. `[1.0, 2.0, 3.0, 4.0, 5.0]` - `period`: The number of days over which to compute the moving average. `[int]` # Output: - A list of floats representing the moving average values. # Constraints: 1. The `prices` list should not be empty. 2. The `period` should be a positive integer and less than or equal to the length of the `prices` list. # Examples: ```python class StockData: def __init__(self, prices): self.prices = prices def moving_average(self, period: int) -> List[float]: if period <= 0 or period > len(self.prices): raise ValueError(\\"Invalid period\\") averages = [] for i in range(len(self.prices) - period + 1): avg = sum(self.prices[i:i+period]) / period averages.append(avg) return averages >>> stock_data = StockData([1.0, 2.0, 3.0, 4.0, 5.0]) >>> stock_data.moving_average(3) [2.0, 3.0, 4.0] ``` # Notes: - Make sure to validate the period value and raise an appropriate exception for invalid inputs. - The first moving average value should align with the start of the price list, meaning it uses the first `period` elements. - Consider the efficiency of your implementation, especially for large datasets.","solution":"from typing import List class StockData: def __init__(self, prices: List[float]): self.prices = prices def moving_average(self, period: int) -> List[float]: if period <= 0 or period > len(self.prices): raise ValueError(\\"Invalid period\\") averages = [] sum_period = sum(self.prices[:period]) averages.append(sum_period / period) for i in range(period, len(self.prices)): sum_period += self.prices[i] - self.prices[i - period] averages.append(sum_period / period) return averages"},{"question":"# Implementing a Simple In-Memory Key-Value Store Scenario: You are building a simplified version of an in-memory key-value store. This system allows users to store, retrieve, update, and delete key-value pairs. Additionally, it supports operations to determine the existence of a key and to retrieve all keys. The store should handle various data types (string, integer, float, list, dictionary) as values. Requirements: 1. **Basic Operations**: Implement methods to set, get, update, delete, and check the existence of a key. 2. **Data Consistency**: Ensure type consistency for values retrieved from the store. 3. **Key Listing**: Provide functionality to retrieve all keys currently stored. Input & Output: * **Function Signatures**: ```python class KeyValueStore: def __init__(self): # Initialize an empty store pass def set(self, key: str, value: Union[str, int, float, list, dict]) -> None: # Store the key-value pair in the store pass def get(self, key: str) -> Union[str, int, float, list, dict, None]: # Retrieve the value associated with the key, or None if the key does not exist pass def update(self, key: str, value: Union[str, int, float, list, dict]) -> None: # Update the value associated with the key pass def delete(self, key: str) -> None: # Remove the key-value pair from the store pass def exists(self, key: str) -> bool: # Check if a key exists in the store pass def list_keys(self) -> List[str]: # Return a list of all keys in the store pass ``` * **Constraints**: * Keys must be unique and strings. * Values can be of type string, integer, float, list, or dictionary. * If attempting to update a non-existent key, raise `KeyError` with the message \\"Key not found\\". * **Error Handling**: * Ensure `set` and `update` methods handle adding and updating values correctly. * Properly handle non-existent keys for `get`, `update`, and `delete` methods by raising `KeyError` with the message \\"Key not found\\". Example: ```python # Example usage: store = KeyValueStore() # Set key-value pairs store.set(\\"name\\", \\"Alice\\") store.set(\\"age\\", 30) store.set(\\"height\\", 5.5) store.set(\\"tags\\", [\\"engineer\\", \\"developer\\", \\"blogger\\"]) # Get values assert store.get(\\"name\\") == \\"Alice\\" assert store.get(\\"age\\") == 30 assert store.get(\\"height\\") == 5.5 assert store.get(\\"tags\\") == [\\"engineer\\", \\"developer\\", \\"blogger\\"] assert store.get(\\"non_existing_key\\") is None # Update values store.update(\\"name\\", \\"Bob\\") assert store.get(\\"name\\") == \\"Bob\\" # Check existence assert store.exists(\\"name\\") == True assert store.exists(\\"non_existing_key\\") == False # Delete key-value pair store.delete(\\"height\\") assert store.get(\\"height\\") is None # List all keys assert set(store.list_keys()) == {\\"name\\", \\"age\\", \\"tags\\"} ``` Implementation Details: Provide your implementation for the `KeyValueStore` class following the specifications and requirements provided.","solution":"from typing import Union, List class KeyValueStore: def __init__(self): Initialize an empty store. self.store = {} def set(self, key: str, value: Union[str, int, float, list, dict]) -> None: Store the key-value pair in the store. self.store[key] = value def get(self, key: str) -> Union[str, int, float, list, dict, None]: Retrieve the value associated with the key, or None if the key does not exist. return self.store.get(key) def update(self, key: str, value: Union[str, int, float, list, dict]) -> None: Update the value associated with the key. if key not in self.store: raise KeyError(\\"Key not found\\") self.store[key] = value def delete(self, key: str) -> None: Remove the key-value pair from the store. if key not in self.store: raise KeyError(\\"Key not found\\") del self.store[key] def exists(self, key: str) -> bool: Check if a key exists in the store. return key in self.store def list_keys(self) -> List[str]: Return a list of all keys in the store. return list(self.store.keys())"},{"question":"# Problem: Circular Linked List - Insertion and Detection You are provided with a partial implementation of a circular linked list, and your task is to complete it by writing functionalities for inserting a new node into the list and detecting if the list contains a loop. A circular linked list is one where all nodes are connected in a way that forms a circle, with no end node pointing to `None` (a node points back to a previously visited node). # Requirements: Implement the following methods in the `CircularLinkedList` class: 1. **Insert Node**: Define a method `insert_node(value: int) -> None` that inserts a new node with the provided value into the circular linked list. 2. **Detect Loop**: Define a method `detect_loop() -> bool` that checks if there is a loop in the linked list and returns `True` if a loop is detected, otherwise `False`. # Constraints: - Each node in the circular linked list contains an integer value. - You can assume that the initial list given during tests will always be circular. - Ensure that your implementation is efficient in terms of time and space complexity. # Class Definition: ```python class Node: def __init__(self, data: int): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def insert_node(self, value: int) -> None: # Implement this method pass def detect_loop(self) -> bool: # Implement this method pass ``` # Example: ```python # Example usage: cll = CircularLinkedList() # Insertion of nodes cll.insert_node(1) cll.insert_node(2) cll.insert_node(3) cll.insert_node(4) # List is now: 1 -> 2 -> 3 -> 4 -> 1 (circular) # Detecting loop print(cll.detect_loop()) # Output: True new_cll = CircularLinkedList() # Insertion into an initially empty list new_cll.insert_node(10) new_cll.insert_node(20) new_cll.insert_node(30) # Artificially break the circularity for detection test new_cll.head.next.next.next = None print(new_cll.detect_loop()) # Output: False ``` # Additional Considerations Your solution should: - Handle edge case scenarios efficiently, such as inserting into an empty list or a list with one node. - Consider all logical flows to correctly detect the loop in a circular linked list. - Include proper checks to ensure the circular nature is maintained during insertions. Ensure that the `insert_node` and `detect_loop` methods conform to the expectations laid out, with appropriate comments and clear logic reflecting their functionality.","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def insert_node(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node new_node.next = self.head else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node new_node.next = self.head def detect_loop(self) -> bool: if not self.head: return False slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Problem Statement Implement a function to perform integer division without using the division or multiplication operators. Additionally, implement another function to perform integer division and return the remainder as well. # Function 1: `integer_divide(dividend: int, divisor: int) -> int` * **Input Parameters**: - `dividend` (int): An integer representing the number to be divided. - `divisor` (int): An integer representing the divisor. * **Output**: - Returns an integer representing the quotient of the integer division. * **Constraints**: - `-10^9 <= dividend <= 10^9` - `-10^9 <= divisor <= 10^9` - `divisor` will never be 0. # Function 2: `integer_divide_with_remainder(dividend: int, divisor: int) -> (int, int)` * **Input Parameters**: - `dividend` (int): An integer representing the number to be divided. - `divisor` (int): An integer representing the divisor. * **Output**: - Returns a tuple with two integers: the quotient and the remainder of the division. * **Constraints**: - `-10^9 <= dividend <= 10^9` - `-10^9 <= divisor <= 10^9` - `divisor` will never be 0. # Requirements: 1. Implement `integer_divide(dividend: int, divisor: int) -> int`. 2. Implement `integer_divide_with_remainder(dividend: int, divisor: int) -> (int, int)`. 3. Ensure efficient computation with the time complexity of O(log n), where n is the absolute value of the dividend. # Examples: Example 1 ```python >>> integer_divide(10, 3) 3 ``` Example 2 ```python >>> integer_divide_with_remainder(10, 3) (3, 1) ``` Example 3 ```python >>> integer_divide(43, -8) -5 ``` Example 4 ```python >>> integer_divide_with_remainder(43, -8) (-5, 3) ``` # Explanation: 1. `integer_divide(10, 3)` returns 3 because 10 divided by 3 is 3 with a remainder. 2. `integer_divide_with_remainder(10, 3)` returns (3, 1) because the quotient of 10 divided by 3 is 3 and the remainder is 1. 3. `integer_divide(43, -8)` returns -5 because 43 divided by -8 is -5 with a remainder. 4. `integer_divide_with_remainder(43, -8)` returns (-5, 3) because the quotient of 43 divided by -8 is -5 and the remainder is 3.","solution":"def integer_divide(dividend: int, divisor: int) -> int: if dividend == 0: return 0 negative = (dividend < 0) != (divisor < 0) dividend, divisor = abs(dividend), abs(divisor) quotient = 0 current_sum = divisor while dividend >= current_sum: current_quota = 1 while current_sum + current_sum <= dividend: current_sum += current_sum current_quota += current_quota dividend -= current_sum quotient += current_quota current_sum = divisor return -quotient if negative else quotient def integer_divide_with_remainder(dividend: int, divisor: int) -> (int, int): quotient = integer_divide(dividend, divisor) remainder = dividend - quotient * divisor return (quotient, remainder)"},{"question":"# Coding Assessment Question: Unique Product Identifier Checker You work at an e-commerce company where each product needs a unique identifier called a Product ID. To ensure data integrity, you need to create a function that validates these Product IDs based on certain rules. Your task is to implement a function that checks if a given Product ID adheres to the following guidelines: 1. The input should be a string. 2. The Product ID must consist of exactly 12 alphanumeric characters (both uppercase and lowercase letters are permitted). 3. The Product ID must start with an uppercase letter. 4. The Product ID should end with a digit. 5. The Product ID should not contain any special characters or spaces. 6. If any of these conditions are not met, return `False`. **Function Specification** ```python def validate_product_id(product_id: str) -> bool: Validate the given Product ID based on the specified guidelines. Parameters: product_id (str): The Product ID to be checked for validity. Returns: bool: True if the Product ID is valid based on the guidelines, otherwise False. ``` # Input * A string `product_id` representing the Product ID. The string can be any length. # Output * Return `True` if the Product ID is valid based on the specified rules. * Return `False` if the Product ID does not meet any of the criteria. # Constraints * The function should handle strings of up to 100 characters, but primarily focus on validating the 12-character Product IDs. # Example ```python print(validate_product_id(\\"A1B2C3D4E5F6\\")) # True print(validate_product_id(\\"a1b2c3d4e5f6\\")) # False (does not start with an uppercase letter) print(validate_product_id(\\"A1B2C3D4E5FZ\\")) # False (does not end with a digit) print(validate_product_id(\\"A1B2C3D4E5F\\")) # False (not 12 characters) print(validate_product_id(\\"A1B2C3D4E5F#\\")) # False (contains special character) ``` # Notes - Ensure your function is efficient and handles edge cases appropriately. - Provide reasoning in your comments for any design choices made during implementation.","solution":"import re def validate_product_id(product_id: str) -> bool: Validate the given Product ID based on the specified guidelines. Parameters: product_id (str): The Product ID to be checked for validity. Returns: bool: True if the Product ID is valid based on the guidelines, otherwise False. # Check if the product ID has exactly 12 characters if len(product_id) != 12: return False # Check if the product ID starts with an uppercase letter and ends with a digit if not (product_id[0].isupper() and product_id[-1].isdigit()): return False # Check if the product ID contains only alphanumeric characters if not product_id.isalnum(): return False return True"},{"question":"A sequence of numbers is considered \\"monotonically increasing\\" if each number is greater than or equal to the number preceding it. Given a list of potential price changelogs represented as integers, your task is to determine the longest monotonically increasing subsequence within this list. Note that a subsequence is derived by deleting some or no elements of the list without changing the order of the remaining elements. # Function Signature ```python def longest_monotonic_increasing_subsequence(prices: list[int]) -> int: pass ``` # Input - `prices`: A list of integers (1 ≤ len(prices) ≤ 10^4; -10^4 ≤ prices[i] ≤ 10^4 for all integers in `prices`). # Output - Return an integer representing the length of the longest monotonically increasing subsequence in the list. # Constraints 1. Ensure that your solution is efficient, ideally with a time complexity of O(n log n). 2. Consider using dynamic programming or binary search to optimize your solution. 3. The input list may contain both negative and positive integers. # Examples ```python assert longest_monotonic_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_monotonic_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2, 2, 6]) == 5 assert longest_monotonic_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert longest_monotonic_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 assert longest_monotonic_increasing_subsequence([-2, -1, -3, -4, -1, 4, 2, 3]) == 4 ``` # Additional Notes 1. In the example [10, 9, 2, 5, 3, 7, 101, 18], the longest monotonically increasing subsequence is [2, 3, 7, 101], resulting in a length of 4. 2. Ensure that your solution efficiently handles the upper constraints of the input size.","solution":"import bisect def longest_monotonic_increasing_subsequence(prices: list[int]) -> int: Returns the length of the longest monotonically increasing subsequence in the list of integers. if not prices: return 0 sub = [] for price in prices: pos = bisect.bisect_left(sub, price) if pos == len(sub): sub.append(price) else: sub[pos] = price return len(sub)"},{"question":"# Problem: Implement a Data Processing Pipeline with User-Specified Transformations **Context**: You have been tasked with designing a flexible data processing pipeline that can apply a series of user-specified transformations to a list of numbers. Each transformation is a function that takes a number as input and outputs a modified number. Your goal is to implement a class `DataPipeline` which allows users to add transformations to the pipeline and then apply all added transformations to a given list of numbers. # Problem Statement: Implement the class `DataPipeline` with the following requirements: * **Class Definition**: * `class DataPipeline` * **Function Implementations**: 1. `add_transformation(self, func: callable)`: Adds a transformation function to the pipeline. 2. `apply_transformations(self, data: list[int]) -> list[int]`: Applies all added transformations to the input data sequentially. # Example ```python # Define transformation functions def increment(x): return x + 1 def double(x): return x * 2 def square(x): return x * x # Initialize the data pipeline pipeline = DataPipeline() # Add transformations to the pipeline pipeline.add_transformation(increment) pipeline.add_transformation(double) pipeline.add_transformation(square) # Apply the transformations to the data data = [1, 2, 3, 4] transformed_data = pipeline.apply_transformations(data) # transformed_data is expected to be [16, 36, 64, 100] ``` # Constraints * Each transformation function is assumed to be valid and does not contain errors. * There can be any number of transformations in the pipeline. * The input numbers for transformations will be non-negative integers. **Note**: The process involves applying all transformations in the order they were added to each element of the data list.","solution":"class DataPipeline: def __init__(self): self.transformations = [] def add_transformation(self, func: callable): self.transformations.append(func) def apply_transformations(self, data: list[int]) -> list[int]: for transformation in self.transformations: data = [transformation(x) for x in data] return data # Example usage: # def increment(x): # return x + 1 # # def double(x): # return x * 2 # # def square(x): # return x * x # # pipeline = DataPipeline() # pipeline.add_transformation(increment) # pipeline.add_transformation(double) # pipeline.add_transformation(square) # # data = [1, 2, 3, 4] # transformed_data = pipeline.apply_transformations(data) # Expected: [16, 36, 64, 100]"},{"question":"# Coding Assessment Question Context: You have been introduced to sorting techniques and improving algorithm performance. To evaluate your understanding of these concepts while leveraging dictionary operations, you\'ll implement an algorithm that efficiently counts word occurrences. Task: Implement a function that takes a list of strings representing words and returns a dictionary where the keys are the words, and the values are the number of times each word appears in the list. Function Signature: ```python def word_count(words: List[str]) -> Dict[str, int]: pass ``` Input & Output: - **Input**: A list of strings `words` (0 <= len(words) <= 1000). - **Output**: A dictionary where each key is a word and its corresponding value is the count of that word in the input list. Constraints: - The input list can be empty. - Words consist of lowercase alphabetic characters only. - Do not use any external libraries for the frequency count. - The function should handle words of varied lengths, including single character words. - You should not use any in-built dictionary frequency count methods. Performance Requirements: - Time Complexity: O(n) where n is the number of words. - Space Complexity: O(n) for storing the dictionary. Examples: ```python assert word_count([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == {\\"apple\\": 3, \\"banana\\": 2, \\"orange\\": 1} assert word_count([\\"one\\", \\"one\\", \\"two\\", \\"two\\", \\"two\\"]) == {\\"one\\": 2, \\"two\\": 3} assert word_count([]) == {} assert word_count([\\"a\\", \\"b\\", \\"a\\", \\"a\\", \\"b\\", \\"c\\"]) == {\\"a\\": 3, \\"b\\": 2, \\"c\\": 1} ``` Additional Challenge: Implement a function that sorts the dictionary based on word frequencies in descending order. Return a sorted list of tuples, where each tuple contains a word and its count. Function Signature: ```python def sorted_word_count(words: List[str]) -> List[Tuple[str, int]]: pass ``` Example: ```python assert sorted_word_count([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == [(\\"apple\\", 3), (\\"banana\\", 2), (\\"orange\\", 1)] assert sorted_word_count([\\"one\\", \\"one\\", \\"two\\", \\"two\\", \\"two\\"]) == [(\\"two\\", 3), (\\"one\\", 2)] ```","solution":"from typing import List, Dict, Tuple def word_count(words: List[str]) -> Dict[str, int]: Takes a list of strings representing words and returns a dictionary where the keys are the words, and the values are the number of times each word appears in the list. word_frequency = {} for word in words: if word in word_frequency: word_frequency[word] += 1 else: word_frequency[word] = 1 return word_frequency def sorted_word_count(words: List[str]) -> List[Tuple[str, int]]: Takes a list of strings representing words and returns a sorted list of tuples, where each tuple contains a word and its count, sorted by frequency in descending order. word_frequency = word_count(words) sorted_word_freq = sorted(word_frequency.items(), key=lambda item: item[1], reverse=True) return sorted_word_freq"},{"question":"# Coding Assessment Question: Balanced Binary Search Tree Construction Background A binary search tree (BST) is a binary tree in which each node has a value that is greater than the values in its left subtree and less than the values in its right subtree. Maintaining a balanced BST is crucial for ensuring O(log n) time complexity for insertion, deletion, and search operations. Task Write a function that constructs a balanced binary search tree from a given sorted list of integers. The resulting binary search tree should be balanced, meaning the depth of the two subtrees of every node never differ by more than 1. Input * A list of integers `sorted_list`, which is sorted in ascending order and contains no duplicates. Output * A binary search tree constructed as a balanced BST. Constraints * The length of the sorted list, `n`, is between 1 and 10^5. * The values in the list are integers within the range of -10^9 to 10^9. Performance Requirements The implementation should efficiently construct the BST in O(n) time complexity. Example ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def construct_balanced_bst(sorted_list): # Your implementation here # Test case sorted_list = [-10, -3, 0, 5, 9] root = construct_balanced_bst(sorted_list) def inorder_traversal(root): return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) if root else [] print(inorder_traversal(root)) # Expected Output: [-10, -3, 0, 5, 9] ``` Additional Information - The function `construct_balanced_bst` takes a sorted list and should return the root of the balanced BST. - You may define a helper function as needed for constructing the tree recursively. - The `TreeNode` class is pre-defined for constructing tree nodes. This new question involves key concepts such as data structures, recursion, and algorithmic efficiency, consistent with the style and complexity presented in the original question.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def construct_balanced_bst(sorted_list): if not sorted_list: return None def build_bst(start, end): if start > end: return None mid = (start + end) // 2 node = TreeNode(value=sorted_list[mid]) node.left = build_bst(start, mid - 1) node.right = build_bst(mid + 1, end) return node return build_bst(0, len(sorted_list) - 1)"},{"question":"# Question: Reverse Words in a String You are working on a text processing application, and need a function to reverse the order of words in a given sentence. Implement a function `reverse_words(s: str) -> str` that reverses the words in the input string `s`. The function should: 1. Split the input string by spaces to separate each word. 2. Reverse the order of the words. 3. Join the words back into a single string with one space between each word. 4. Ensure that there are no leading, trailing, or multiple spaces in the output string. **Input:** - `s`: A string containing words separated by spaces. **Output:** - Returns a string with the words in reversed order. **Constraints:** - The input string `s` consists of lowercase and uppercase English letters, digits, and spaces `\' \'`. - The returned string should only have a single space between words and no extra spaces. **Example:** ```python s = \\" hello world \\" assert reverse_words(s) == \\"world hello\\" s = \\"a good example\\" assert reverse_words(s) == \\"example good a\\" ``` **Function Call:** ```python print(reverse_words(\\" The quick brown fox \\")) # Output: \\"fox brown quick The\\" ```","solution":"def reverse_words(s: str) -> str: Reverses the words in a string. Parameters: s (str): The input string containing words separated by spaces. Returns: str: A string with the words in reversed order while ensuring no extra spaces. # Split the string by spaces while filtering out empty strings words = s.split() # Reverse the order of words reversed_words = words[::-1] # Join the reversed words into a single string with one space between each word return \' \'.join(reversed_words)"},{"question":"# String Compression and Decompression Scenario You are working as a software developer intern at a data storage company. One of your tasks is to implement a feature that compresses strings by converting sequences of repeated characters into a format that indicates the character followed by the number of occurrences. Additionally, you need to provide a way to decompress these strings back to their original form. Problem Implement two functions `compress_string(s: str) -> str` and `decompress_string(s: str) -> str` to handle the string compression and decompression respectively. The functions should: * Compress the input string by replacing consecutive repeated characters with the character followed by the count of repetitions. * Decompress the input string back to its original form. Input - `s`: A string that consists of uppercase and lowercase alphabetic characters. Output - `compress_string(s)`: Returns the compressed string. - `decompress_string(s)`: Returns the decompressed string. Constraints - The compressed string should only contain alphabetic characters followed by digits representing counts. - If a character sequence appears only once, it should remain unchanged. - The input string for decompression will always be valid according to the compression format. Example ```python # Example for compression assert compress_string(\\"aaabbcccc\\") == \\"a3b2c4\\" assert compress_string(\\"aabbaa\\") == \\"a2b2a2\\" assert compress_string(\\"abcd\\") == \\"abcd\\" # Example for decompression assert decompress_string(\\"a3b2c4\\") == \\"aaabbcccc\\" assert decompress_string(\\"a2b2a2\\") == \\"aabbaa\\" assert decompress_string(\\"abcd\\") == \\"abcd\\" ``` Notes * The `compress_string` function should iterate over the input string and keep track of the count of consecutive characters. * The `decompress_string` function should parse the input string and expand each character followed by a number into a sequence of repeated characters.","solution":"def compress_string(s: str) -> str: Compresses the input string by converting sequences of repeated characters into the character followed by the number of occurrences. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + (str(count) if count > 1 else \'\')) count = 1 compressed.append(s[-1] + (str(count) if count > 1 else \'\')) return \'\'.join(compressed) def decompress_string(s: str) -> str: Decompresses the input string back to its original form. if not s: return \\"\\" decompressed = [] i = 0 while i < len(s): char = s[i] count = 1 i += 1 if i < len(s) and s[i].isdigit(): count_str = [] while i < len(s) and s[i].isdigit(): count_str.append(s[i]) i += 1 count = int(\'\'.join(count_str)) decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Question: Custom Markdown to HTML Converter You are required to implement a custom markdown converter that transforms basic markdown text into HTML. This converter should handle headers, bold text, and links. Requirements: 1. **Headers**: Convert markdown headers to HTML headers. A header in markdown is a line that starts with one or more hash `#` symbols. The number of `#` symbols determines the level of the header (`<h1>`, `<h2>`, `<h3>`, etc.). 2. **Bold Text**: Convert text enclosed in double asterisks `**` to bold text (`<strong>`). 3. **Links**: Convert markdown links to HTML links. A link in markdown is represented as `[text](url)` and should be converted to `<a href=\\"url\\">text</a>`. 4. **Input/Output**: - `markdown` (str): A string containing markdown formatted text. - Returns: A string containing the corresponding HTML content. Example: ```python markdown = # Header 1 Header 2 **Bold text** and a [link](https://example.com) html = markdown_to_html(markdown) expected_html = <h1>Header 1</h1> <h2>Header 2</h2> <strong>Bold text</strong> and a <a href=\\"https://example.com\\">link</a> assert html.strip() == expected_html.strip() ``` # Implementation: Define the following function to complete this task: 1. `markdown_to_html(markdown: str) -> str` Function Specs: 1. `markdown_to_html`: - Args: `markdown` (str). - Returns: `html` (str). - Functionality: Convert markdown formatted text to HTML ensuring the specified conversions are handled. # Constraints: - Only consider handling the markdown elements mentioned in the requirements (headers, bold text, and links). - Input markdown string will only contain valid markdown syntax for the specified elements. - Ensure to handle multi-line markdown input efficiently.","solution":"import re def markdown_to_html(markdown: str) -> str: Converts basic markdown text into HTML. Supports headers, bold text, and links. Parameters: markdown (str): A string containing markdown formatted text. Returns: str: A string containing the corresponding HTML content. # Convert headers def convert_header(line): header_match = re.match(r\\"^(#{1,6})s*(.*)\\", line) if header_match: level = len(header_match.group(1)) content = header_match.group(2) return f\\"<h{level}>{content}</h{level}>\\" return line # Convert bold text def convert_bold(text): return re.sub(r\\"**(.*?)**\\", r\\"<strong>1</strong>\\", text) # Convert links def convert_links(text): return re.sub(r\\"[(.*?)]((.*?))\\", r\'<a href=\\"2\\">1</a>\', text) # Split the markdown input by lines lines = markdown.splitlines() # Process each line html_lines = [] for line in lines: # Convert headers line = convert_header(line) # Convert bold text line = convert_bold(line) # Convert links line = convert_links(line) html_lines.append(line) # Join the processed lines into a single HTML string return \\"n\\".join(html_lines)"},{"question":"# Coding Assessment Question Context In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path. The maximum number of neighbors for any node in such a graph (its degree) plays a significant role in various applications, such as network resilience and topology design. Task Write a function `max_node_degree(edges: list[tuple[int, int]]) -> int` that determines the maximum degree of any node in the tree described by the given edges. Function Signature ```python def max_node_degree(edges: list[tuple[int, int]]) -> int: pass ``` Input - A list `edges` of `n-1` tuples where each tuple `(a, b)` denotes an edge between nodes `a` and `b` in a tree of `n` nodes. Each edge is represented by a pair of integers `(a, b)` where `a` and `b` are the nodes connected by that edge. Nodes are numbered starting from 0. Output - An integer representing the maximum degree of any node in the tree. Constraints - The function should raise a `ValueError` with the message `\\"Invalid tree structure\\"` if the input is empty or does not form a valid tree (e.g., cycles). - The function should handle trees with up to (10^6) nodes. Performance Requirements - Time Complexity: O(n) - Space Complexity: O(n) Examples ```python >>> max_node_degree([(0, 1), (0, 2), (1, 3), (1, 4)]) 3 >>> max_node_degree([(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> max_node_degree([(0, 1), (0, 2), (2, 3)]) 2 >>> max_node_degree([(1, 2)]) 1 >>> max_node_degree([]) Traceback (most recent call last): ... ValueError: Invalid tree structure ``` Hints - Utilize dictionaries or lists to keep track of the degree of each node. - Ensure each node count and connection adheres to the properties of a tree.","solution":"def max_node_degree(edges): Determines the maximum degree of any node in the tree described by the given edges. if not edges: raise ValueError(\\"Invalid tree structure\\") from collections import defaultdict degree_count = defaultdict(int) for a, b in edges: degree_count[a] += 1 degree_count[b] += 1 return max(degree_count.values())"},{"question":"# Coding Assessment Question: A software company wants to automate its employee bonus calculation system. The bonuses are given based on the number of years an employee has been with the company and their current annual salary. The annual bonus is calculated using the following rules: 1. If the employee has been with the company for more than 10 years, they receive a 10% bonus. 2. If the employee has been with the company for more than 5 years but less than or equal to 10 years, they receive a 5% bonus. 3. If the employee has been with the company for 5 years or less, they receive a 2% bonus. **Function Details**: * Write a function `calculate_bonus(annual_salary: float, years_with_company: int) -> float` that calculates and returns the annual bonus for an employee. **Input**: * `annual_salary` (float): The annual salary of the employee. Must be greater than 0. * `years_with_company` (int): The number of years the employee has been with the company. Must be a non-negative integer. **Output**: * A single float value representing the annual bonus. **Constraints**: * Typical real-world constraints apply; precision errors are tolerated within reasonable limits. **Performance Requirements**: * The implementation must process inputs and provide the result in constant time, O(1). **Scenario**: The company needs to calculate the bonuses at the end of each year for all employees. The automated solution helps the HR department quickly process the bonuses according to the company’s rules. **Example Use Cases**: * `calculate_bonus(50000, 12)` should return `5000.0`. * `calculate_bonus(40000, 7)` should return `2000.0`. * `calculate_bonus(30000, 3)` should return `600.0`. **Edge Cases**: * Inputs like `calculate_bonus(0, 3)` should raise an exception: `\\"Annual salary must be > 0\\"`. * Inputs like `calculate_bonus(50000, -1)` should raise an exception: `\\"Years with the company must be >= 0\\"`. Formulate your function to handle the input values, apply the appropriate rules, and return the correct bonus calculation accordingly.","solution":"def calculate_bonus(annual_salary: float, years_with_company: int) -> float: Calculates the annual bonus for an employee based on their annual salary and years with the company. Parameters: annual_salary (float): The annual salary of the employee. Must be greater than 0. years_with_company (int): The number of years the employee has been with the company. Must be a non-negative integer. Returns: float: The calculated annual bonus. if annual_salary <= 0: raise ValueError(\\"Annual salary must be > 0\\") if years_with_company < 0: raise ValueError(\\"Years with the company must be >= 0\\") if years_with_company > 10: bonus = annual_salary * 0.10 elif 5 < years_with_company <= 10: bonus = annual_salary * 0.05 else: bonus = annual_salary * 0.02 return bonus"},{"question":"# Problem: Merge Two Sorted Arrays You are given two non-decreasingly sorted integer arrays, `arr1` and `arr2`. Your task is to merge these two arrays into a single non-decreasingly sorted array without using any extra space. That means the merging must be done in place in `arr1`, assuming that `arr1` has enough space to accommodate the elements of `arr2`. Expected Function Signature ```python def merge_sorted_arrays(arr1: list[int], m: int, arr2: list[int], n: int) -> None: pass ``` # Input * Two lists of integers `arr1` and `arr2`, where: * `arr1` is a list of size `m + n`, where the first `m` elements are the initial elements, and the rest are zeros to accommodate elements from `arr2`. * `arr2` is a list of size `n`, containing `n` elements. * Two integers `m` and `n` (0 <= m, n <= 10^6), representing the number of initial elements in `arr1` and the elements in `arr2` respectively. # Output * The function modifies `arr1` in place such that it contains a sorted combination of elements from both `arr1` and `arr2`. # Constraints * The function does not return anything. * You are not allowed to use additional arrays or collections to assist with the merge. # Implementation Notes * Utilize a two-pointer approach starting from the end of the arrays to efficiently merge the elements in place. * The time complexity should be O(m + n). # Example ```python arr1 = [1, 2, 3, 0, 0, 0] arr2 = [2, 5, 6] merge_sorted_arrays(arr1, 3, arr2, 3) assert arr1 == [1, 2, 2, 3, 5, 6] arr1 = [1, 2, 4, 5, 6, 0] arr2 = [3] merge_sorted_arrays(arr1, 5, arr2, 1) assert arr1 == [1, 2, 3, 4, 5, 6] arr1 = [2, 0] arr2 = [1] merge_sorted_arrays(arr1, 1, arr2, 1) assert arr1 == [1, 2] ``` # Additional Edge Cases * Input `m` or `n` as 0 should handle correctly without modifying non-existent elements. * Arrays with duplicate values should correctly merge without issues.","solution":"def merge_sorted_arrays(arr1: list[int], m: int, arr2: list[int], n: int) -> None: Merges two sorted arrays into a single sorted array in place in arr1. :param arr1: First sorted array of integers with extra space to accommodate arr2 :param m: Number of initial elements in arr1 :param arr2: Second sorted array of integers :param n: Number of elements in arr2 # Index for the last element in arr1\'s initial elements i = m - 1 # Index for the last element in arr2 j = n - 1 # Index for the last position in arr1 k = m + n - 1 # Start merging from the end of the arrays while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[k] = arr1[i] i -= 1 else: arr1[k] = arr2[j] j -= 1 k -= 1 # If there are remaining elements in arr2, copy them over while j >= 0: arr1[k] = arr2[j] k -= 1 j -= 1"},{"question":"# Coding Assessment Question **Problem Statement**: Given an array of integers, your task is to sort the array according to the frequency of elements. The sorting should be done in such a way that the elements that have higher frequency come first. If two elements have the same frequency, the smaller element should precede the larger one. **Function Signature**: ```python def frequency_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers `0 <= len(arr) <= 10^5` where each element `-10^5 <= arr[i] <= 10^5`. **Output**: - Returns a list of integers sorted according to the frequency of elements, with ties broken by the value of the elements. **Example**: ```python arr = [4, 6, 2, 2, 6, 4, 4, 4] Output: [4, 4, 4, 4, 2, 2, 6, 6] ``` **Constraints**: - The input array can be empty. - The elements should be valid integers within the specified range. **Hints**: 1. Use a dictionary to count the frequency of each element. 2. Sort the elements based on the frequency and then by their value if frequencies are equal. 3. Leverage appropriate sorting mechanisms to ensure the desired order. **Performance Requirements**: - The solution should have a time complexity of O(n log n) where n is the number of elements in the array due to the need of sorting the elements. - The space complexity should be O(n) to store the frequencies. Write the function `frequency_sort` that follows the above requirements. Make sure to handle the edge cases such as an empty array or an array with only one element.","solution":"from typing import List from collections import Counter def frequency_sort(arr: List[int]) -> List[int]: Sorts the array according to the frequency of elements in descending order. If two elements have the same frequency, the smaller element should precede the larger one. # Count the frequency of each number in the array freq = Counter(arr) # Sort the array based on frequency. In case of a tie, sort by the number itself. sorted_arr = sorted(arr, key=lambda x: (-freq[x], x)) return sorted_arr"},{"question":"# Coding Assessment Question Context You are managing a data logging system that records timestamped event entries. The system needs to maintain efficient access to recent events and categorize them by timestamp intervals. Problem Statement Implement a class `EventLogger` that supports logging events, querying recent events within the last given number of seconds, and categorizing the events by hourly intervals. 1. Implement the class `EventLogger` such that it: - Accepts a dictionary of initial events during initialization. - Has a method `log_event` to log a new event with a current timestamp. - Has a method `query_recent` to retrieve all events within the last given number of seconds from the current moment. - Has a method `categorize_by_hour` to return events grouped by hourly intervals of their timestamps. 2. Ensure proper handling of edge cases: - Provide meaningful error messages for querying beyond the data range. - Ensure the method categorizing by hour correctly handles empty events. Constraints * The timestamp is an integer representing the number of seconds since the Unix epoch (January 1, 1970). * The maximum number of events that can be logged is 10^5. Function Signatures * `class EventLogger` - `__init__(self, initial_events: dict[int, str] = {}) -> None` - `log_event(self, timestamp: int, event: str) -> None` - `query_recent(self, seconds: int) -> list[str]` - `categorize_by_hour(self) -> dict[int, list[str]]` Input and Output * `EventLogger.__init__(initial_events: dict[int, str] = {})` - **Input**: A dictionary `initial_events` where keys are timestamps (int) and values are event strings. - **Initialization**: Stores the initial events. * `EventLogger.log_event(timestamp: int, event: str)` - **Input**: An integer `timestamp` and an event string. - **Output**: Logs the event at the given timestamp; No return value. * `EventLogger.query_recent(seconds: int)` - **Input**: An integer `seconds` representing the time window. - **Output**: A list of event strings logged within the last given seconds. - **Raises**: `ValueError` if `seconds` is negative or if there are no events within the specified range. * `EventLogger.categorize_by_hour()` - **Output**: A dictionary where keys are hour indices (int) from 0 to 23, and values are lists of event strings logged in that hour. Example Usage ```python import time # Initialize with some events initial_events = { 1617556725: \\"Event 1\\", # Corresponds to some actual date-time 1617556726: \\"Event 2\\", 1617559726: \\"Event 3\\", } logger = EventLogger(initial_events) # Log new events current_time = int(time.time()) logger.log_event(current_time, \\"New Event\\") # Query recent events (assuming current_time is 1617556730) print(logger.query_recent(10)) # Outputs: [\\"Event 1\\", \\"Event 2\\", \\"New Event\\"] # Categorize by hour categorized_events = logger.categorize_by_hour() print(categorized_events) # Outputs: { # 0: [], 1: [], ..., 12: [], 13: [], 14: [], 15: [], 16: [\\"Event 1\\", \\"Event 2\\", \\"Event 3\\", \\"New Event\\"], ..., 23: [] # } # Handling edge cases try: logger.query_recent(-10) except ValueError as e: print(e) # Outputs: invalid time window try: empty_logger = EventLogger() print(empty_logger.query_recent(100)) except ValueError as e: print(e) # Outputs: no events within the specified range ``` - - -","solution":"import time from collections import defaultdict class EventLogger: def __init__(self, initial_events: dict[int, str] = {}) -> None: self.events = initial_events def log_event(self, timestamp: int, event: str) -> None: Logs a new event with the given timestamp. self.events[timestamp] = event def query_recent(self, seconds: int) -> list[str]: Retrieves all events within the last given number of seconds from now. if seconds < 0: raise ValueError(\\"Invalid time window, must be non-negative.\\") current_time = int(time.time()) results = [event for ts, event in self.events.items() if current_time - ts <= seconds] if not results: raise ValueError(\\"No events within the specified range.\\") return results def categorize_by_hour(self) -> dict[int, list[str]]: Groups the events by hourly intervals of their timestamps. categorized_events = defaultdict(list) for timestamp, event in self.events.items(): hour_index = (timestamp // 3600) % 24 categorized_events[hour_index].append(event) return dict(categorized_events)"},{"question":"# Problem Statement Write a function to encrypt a given message using a shift cipher (also known as Caesar cipher). The function should take a string message and an integer shift value as input and return the encrypted message. Each character in the message is shifted by the specified value along the alphabet. The encryption should preserve the case of the characters and should not alter non-alphabet characters. # Implementation Details Implement the following function: ```python def caesar_cipher(message: str, shift: int) -> str: Encrypt a message using a Caesar cipher. Args: message (str): The message to be encrypted. shift (int): The shift value for the cipher. Returns: str: The encrypted message. Examples: >>> caesar_cipher(\\"Hello, World!\\", 3) \'Khoor, Zruog!\' >>> caesar_cipher(\\"python\\", 5) \'udymts\' >>> caesar_cipher(\\"A quick brown fox jumps over the lazy dog.\\", 7) \'H xzbjr iytdu lve qbtwl vcly aol sgrf kvn.\' >>> caesar_cipher(\\"Shift123\\", 2) \'Ujkhr123\' pass ``` Input * `message`: A string containing the message to be encrypted. * `shift`: An integer representing the number of positions to shift each character (can be negative or positive). Output * A string representing the encrypted message. Constraints * All characters must maintain their original case. * Non-alphabet characters should remain unchanged. * The shift value can be negative, zero, or positive. # Points to Consider * Handle shifts greater than the length of the alphabet. * Correctly adjust the shift when it is negative. * Ensure the preservation of non-alphabet characters in their original positions throughout the encryption process. Performance Requirements * The function should handle messages of substantial length efficiently.","solution":"def caesar_cipher(message: str, shift: int) -> str: def shift_char(c, shift): if \'a\' <= c <= \'z\': start = ord(\'a\') elif \'A\' <= c <= \'Z\': start = ord(\'A\') else: return c return chr(start + (ord(c) - start + shift) % 26) return \'\'.join(shift_char(c, shift) for c in message)"},{"question":"# Finding the Kth Largest Element in an Array You are required to develop a function that returns the k-th largest element in a given list of real numbers. The k-th largest element is the k-th element in a sorted order, not the k-th distinct element. Understanding how to find the k-th largest element using different algorithmic approaches is crucial. Implement a solution that adheres to the specified constraints and efficiently handles edge cases. Function Signature ```python def kth_largest_element(arr: list[float], k: int) -> float: pass ``` Requirements 1. The function should accept a list of real numbers (integers and floats) and an integer k. 2. The function should return the k-th largest element in the list. 3. Assume the list only contains real numbers. 4. The function must handle: - An empty list (return None or raise an appropriate error). - A list with one element. - Valid and invalid values for k (e.g., k greater than the list length, k less than 1). - Lists with duplicated elements and the presence of negative numbers. 5. Demonstrate your implementation by writing test cases for each of these edge cases. 6. Use Python\'s built-in assertion mechanism to validate your outputs. Constraints * Do not use any built-in sort functions. * Ensure your solution runs efficiently for small to medium-sized lists. Example Usage Here are some examples of expected input and output: ```python assert kth_largest_element([3, 2, 1, 5, 6, 4], 2) == 5 assert kth_largest_element([3.5, 2.1, 1.0, 5.2, 6.6, 4.3], 1) == 6.6 assert kth_largest_element([4, 4, 3, 2, 1, 5], 3) == 4 assert kth_largest_element([-1, -2, -3, -4, -5], 1) == -1 assert kth_largest_element([1], 1) == 1 assert kth_largest_element([], 1) is None # or raise ValueError(\\"Invalid input\\") assert kth_largest_element([3, 3, 3], 2) == 3 # Example test case for invalid k try: kth_largest_element([1, 2, 3], 4) except ValueError as e: assert str(e) == \\"Invalid value for k\\" ``` Test your implementation rigorously to cover all edge cases. Provide brief comments explaining how each test case verifies specific scenarios and constraints.","solution":"def kth_largest_element(arr: list[float], k: int) -> float: Returns the k-th largest element in the array `arr`. Parameters: arr (list of float): The list of real numbers. k (int): The position of the largest element to return. Returns: float: The k-th largest element in the list. Raises: ValueError: If k is not valid for the given list. if not arr: return None # Raising ValueError(\\"Invalid input\\") is also an option if k < 1 or k > len(arr): raise ValueError(\\"Invalid value for k\\") # We implement a simple quickselect algorithm to find the k-th largest element def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] > pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"# K-Means Clustering Implementation Assessment Context You are tasked with implementing and customizing a K-Means Clustering algorithm. The objective is to validate your understanding of unsupervised learning methods, centroids initialization, convergence criteria, and handling multi-dimensional data. Task 1. **Implement K-Means Clustering**: - Develop a K-Means clustering algorithm from scratch. - The algorithm should initialize centroids either randomly or using the k-means++ method. - Ensure the algorithm handles convergence based on a maximum number of iterations or when centroids do not change significantly. 2. **Custom Initialization and Convergence Criteria**: - Implement functions for random initialization and k-means++ initialization. - Implement a function to determine the convergence criteria. Expected Function Implementation 1. **Centroid Initializations (Random, K-Means++)**: ```python def initialize_centroids_random(data: np.ndarray, k: int) -> np.ndarray: # Your code here def initialize_centroids_kmeans_plus_plus(data: np.ndarray, k: int) -> np.ndarray: # Your code here ``` 2. **Convergence Criteria**: ```python def check_convergence(old_centroids: np.ndarray, new_centroids: np.ndarray, tolerance: float) -> bool: # Your code here ``` 3. **K-Means Algorithm**: ```python class KMeans: def __init__(self, n_clusters: int, init: str = \'random\', max_iter: int = 300, tol: float = 1e-4): # Your code here def fit(self, data: np.ndarray) -> None: # Your code here def predict(self, data: np.ndarray) -> np.ndarray: # Your code here ``` Input and Output **Input**: - Data as a 2D NumPy array (features). - Number of clusters (integer, k). - Initialization method (\'random\' or \'kmeans++\'). - Maximum number of iterations (integer). - Tolerance for convergence (float). **Output**: - Cluster labels for each data point in the input dataset. Constraints - The number of clusters (k) should be a positive integer. - The maximum iterations should be a positive integer. - Tolerance should be a positive float. - Input data should be a valid NumPy array. Scenario Develop and integrate the required functions and classes to run the K-Means clustering algorithm on a dataset. Verify the implementation through example usage and check for correct clustering and convergence behavior.","solution":"import numpy as np def initialize_centroids_random(data: np.ndarray, k: int) -> np.ndarray: indices = np.random.choice(data.shape[0], k, replace=False) return data[indices] def initialize_centroids_kmeans_plus_plus(data: np.ndarray, k: int) -> np.ndarray: centroids = [data[np.random.randint(0, data.shape[0])]] for _ in range(1, k): distances = np.min([np.sum((data - centroid) ** 2, axis=1) for centroid in centroids], axis=0) probabilities = distances / np.sum(distances) cumulative_probabilities = np.cumsum(probabilities) r = np.random.rand() for j, p in enumerate(cumulative_probabilities): if r < p: centroids.append(data[j]) break return np.array(centroids) def check_convergence(old_centroids: np.ndarray, new_centroids: np.ndarray, tolerance: float) -> bool: distances = np.linalg.norm(old_centroids - new_centroids, axis=1) return np.all(distances <= tolerance) class KMeans: def __init__(self, n_clusters: int, init: str = \'random\', max_iter: int = 300, tol: float = 1e-4): self.n_clusters = n_clusters self.init = init self.max_iter = max_iter self.tol = tol self.centroids = None def fit(self, data: np.ndarray): if self.init == \'random\': self.centroids = initialize_centroids_random(data, self.n_clusters) elif self.init == \'kmeans++\': self.centroids = initialize_centroids_kmeans_plus_plus(data, self.n_clusters) else: raise ValueError(f\\"Unknown initialization method \'{self.init}\'\\") for i in range(self.max_iter): labels = self.predict(data) new_centroids = np.array([data[labels == j].mean(axis=0) for j in range(self.n_clusters)]) if check_convergence(self.centroids, new_centroids, self.tol): break self.centroids = new_centroids def predict(self, data: np.ndarray) -> np.ndarray: distances = np.linalg.norm(data[:, np.newaxis] - self.centroids, axis=2) return np.argmin(distances, axis=1)"},{"question":"# Problem Statement You are required to implement a function that calculates the Fibonacci sequence up to the n-th term and returns it as a list. The Fibonacci sequence is defined as: - `fib(0) = 0` - `fib(1) = 1` - `fib(n) = fib(n-1) + fib(n-2)` for `n > 1` The function should handle various input types and raise appropriate exceptions when necessary. # Function Signature ```python def fibonacci_sequence(n: int) -> list: pass ``` # Input * One integer `n` where 0 ≤ `n` ≤ 30. # Output * A list representing the Fibonacci sequence up to the n-th term. # Constraints * The input value `n` must be a non-negative integer not exceeding 30. * Handle invalid inputs by raising the appropriate exceptions: * Raise `ValueError` if `n` is negative or exceeds 30. * Raise `TypeError` if the input is not of the type integer. # Example ```python assert fibonacci_sequence(0) == [0] assert fibonacci_sequence(1) == [0, 1] assert fibonacci_sequence(5) == [0, 1, 1, 2, 3, 5] assert fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] assert fibonacci_sequence(30) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040] ``` # Edge Cases * `fibonacci_sequence(-1)` should raise `ValueError`. * `fibonacci_sequence(31)` should raise `ValueError`. * `fibonacci_sequence(\\"10\\")` should raise `TypeError`.","solution":"def fibonacci_sequence(n: int) -> list: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0 or n > 30: raise ValueError(\\"Input must be a non-negative integer not exceeding 30\\") if n == 0: return [0] elif n == 1: return [0, 1] sequence = [0, 1] for i in range(2, n + 1): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"# Problem Statement Design a function `find_missing_number(nums: List[int]) -> int` that takes a list of unique integers ranging from 1 to `n` (inclusive) with exactly one integer missing, and returns that missing integer. # Input - A list `nums` containing `n-1` unique integers from the range `1` to `n`. # Output - An integer representing the missing number. # Constraints - `1 <= n <= 10^5` - Each number in the given list is unique. - The list contains exactly `n-1` integers, meaning one integer in the range from `1` to `n` is missing. # Performance Requirements - The algorithm should run in O(n) time complexity and O(1) space complexity. # Example Usage ```python >>> find_missing_number([3, 7, 1, 2, 8, 4, 5, 9, 10]) 6 >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([2, 3, 4, 5]) 1 >>> find_missing_number([1]) 2 >>> find_missing_number([2, 3, 1]) 4 ``` # Additional Notes - Use mathematical properties such as the sum of the first `n` natural numbers to help in deducing the missing number efficiently. - Ensure that the function handles large inputs within the performance constraints.","solution":"def find_missing_number(nums): Returns the missing number from the list `nums` which contains unique numbers from 1 to n with one missing. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"# Coding Assessment Question You are given a class `Matrix` that represents a 2D matrix (a list of lists) and some initial methods to manipulate it. Your task is to enhance the `Matrix` class by adding two new operations: 1. `rotate_90_degrees()` - Rotates the matrix by 90 degrees clockwise. 2. `transpose()` - Transposes the matrix (swaps rows with columns). Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python class Matrix: def __init__(self, matrix: List[List[int]]): self.matrix = matrix def rotate_90_degrees(self) -> None: Rotates the matrix by 90 degrees clockwise. Example: >>> mat = Matrix([[1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) >>> mat.rotate_90_degrees() >>> mat.matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> def transpose(self) -> None: Transposes the matrix (rows <-> columns). Example: >>> mat = Matrix([[1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) >>> mat.transpose() >>> mat.matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> ``` Constraints: - The matrix can be of any size, but for simplicity, assume it is square (N x N). - You must perform the rotation and transposition operations in place. - Memory usage should be minimized and additional space should be avoided if possible. - The operations should be performed efficiently. - Given matrix dimensions should not exceed 1000 x 1000 for performance considerations. **Scenario/Context**: In your image processing application, you often need to transform the image data represented as matrices. Implementing these functionalities efficiently enhances the flexibility and performance of your image processing tasks.","solution":"from typing import List class Matrix: def __init__(self, matrix: List[List[int]]): self.matrix = matrix def rotate_90_degrees(self) -> None: Rotates the matrix by 90 degrees clockwise. self.transpose() for row in self.matrix: row.reverse() def transpose(self) -> None: Transposes the matrix (rows <-> columns). n = len(self.matrix) for i in range(n): for j in range(i + 1, n): self.matrix[i][j], self.matrix[j][i] = self.matrix[j][i], self.matrix[i][j]"},{"question":"**Scenario**: You are working on developing a robotics control system that needs to navigate a small robot through a grid-based maze. The robot can move in four directions: up, down, left, and right. Each cell in the maze either contains an obstacle or is empty. The robot needs to find its way from the starting point to the destination efficiently. **Problem**: Given a maze represented as a 2D grid of 1s and 0s, where 1 represents an obstacle and 0 represents an empty space, and starting and ending coordinates, implement a function that determines the shortest path the robot needs to take to reach the destination. If there\'s no possible path, the function should return -1. # Function Signature ```python def shortest_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: pass ``` # Input Format * `maze` (List[List[int]]): A list of lists of integers representing the grid. * `start` (Tuple[int, int]): A tuple representing the starting coordinates (row, col). * `end` (Tuple[int, int]): A tuple representing the ending coordinates (row, col). # Output Format * **Return** (int): The length of the shortest path from the start to the end. If no path exists, return -1. # Constraints * The dimensions of the maze (number of rows and columns) will not exceed 100. * The given start or end points are always valid and within the maze. * The maze will be well-formed and won’t contain invalid characters. # Example ```python # Example 1 maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start, end = (0, 0), (4, 4) print(shortest_path(maze, start, end)) # Expected output: 9 # Example 2 maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 1] ] start, end = (0, 0), (4, 4) print(shortest_path(maze, start, end)) # Expected output: -1 ``` # Additional Requirements 1. Use meaningful variable names and ensure code readability. 2. Implement an efficient search mechanism (e.g., BFS) to handle the pathfinding. 3. Provide robust handling of edge cases, such as completely blocked paths or no valid paths. 4. Include unit tests to cover normal, edge, and extreme scenarios.","solution":"from typing import List, Tuple from collections import deque def shortest_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: if not maze or not maze[0]: return -1 rows, cols = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Problem Statement In many popular board games, the movement of pieces is determined by rolling dice. You are required to write a function `simulate_dice_rolls` that simulates rolling a pair of six-sided dice a given number of times and returns the frequency count of the sum of the two dice. # Function Signature ```python def simulate_dice_rolls(num_rolls: int) -> dict: pass ``` # Input - An integer `num_rolls` (1 <= `num_rolls` <= 10^6): the number of times the dice are rolled. # Output - A dictionary where the keys are the possible sums of the two dice (from 2 to 12), and the values are the counts of how many times each sum appeared in the simulation. # Constraints - Ensure that your function executes efficiently even for the maximum input size. # Example ```python >>> simulate_dice_rolls(100) {2: 2, 3: 5, 4: 7, 5: 10, 6: 15, 7: 25, 8: 14, 9: 9, 10: 8, 11: 3, 12: 2} ``` # Notes - The function should use a random number generator to simulate the dice rolls. - Make sure your solution is optimized for large values of `num_rolls`. - Utilize appropriate random libraries to handle dice roll simulations accurately.","solution":"import random def simulate_dice_rolls(num_rolls: int) -> dict: Simulates rolling a pair of six-sided dice a given number of times and returns the frequency count of the sum of the two dice. :param num_rolls: Number of times to roll the pair of dice :return: A dictionary with the sums of the dice as keys and their frequencies as values # Initialize the frequency dictionary frequency = {i: 0 for i in range(2, 13)} # Simulate the dice rolls for _ in range(num_rolls): die1 = random.randint(1, 6) die2 = random.randint(1, 6) dice_sum = die1 + die2 frequency[dice_sum] += 1 return frequency"},{"question":"# Coding Assessment Question Problem Statement You are required to write a function that finds the first missing positive integer from an unsorted list of integers. Function Requirements: Write a function `first_missing_positive(nums: List[int]) -> int` that takes a list of integers and returns the smallest positive integer that does not appear in the list. Parameters: - `nums` (List[int]): A list of integers. Return: - An integer representing the smallest positive integer that is not present in the list. Constraints: - Your solution must be efficient, aiming for a time complexity of O(n) and use constant extra space, O(1) (excluding the input list). Examples: ```python >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1, 2, 3]) 4 ``` # Additional Context: - You can assume the list consists of integers within the range [-2^31, 2^31 - 1]. Note: - The list can contain duplicates and negative numbers. - The list can be empty, in which case the smallest positive integer is `1`. This question evaluates your understanding of array manipulation and efficient searching techniques, while ensuring you maintain the constraints of optimal time and space complexity.","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: n = len(nums) # Ensure all numbers are in the range 1 to n by replacing out-of-range numbers with n+1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Mark each cell nums[i] by changing nums[abs(nums[i]) - 1] to a negative number for i in range(n): num = abs(nums[i]) if num <= n: if nums[num - 1] > 0: nums[num - 1] = -nums[num - 1] # Check the first positive index for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"# Handshake Problem Implementation Context: In the context of graph theory and social networks, a common problem involves determining the number of handshakes that occur in a group of people, given that each person shakes hands with every other person exactly once. This problem has applications in networking and communication within groups, where each connection or communication session can be represented as a handshake. Task: Implement a function `count_handshakes` to determine the number of unique handshakes in a group of `n` people. Requirements: * **Function Signature**: ```python def count_handshakes(n: int) -> int: ``` * **Input**: An integer `n` representing the number of people in the group. * **Output**: An integer representing the total number of unique handshakes. * **Constraints**: * `1 <= n <= 10^6` The number of unique handshakes can be determined by the formula for the number of combinations of 2 people from the group, which is given by `n * (n - 1) / 2`. Example: ```python >>> count_handshakes(2) 1 >>> count_handshakes(4) 6 >>> count_handshakes(10) 45 ``` Performance: Make sure your solution runs in constant time O(1) since the calculation involves only basic arithmetic operations. Good luck!","solution":"def count_handshakes(n: int) -> int: Calculates the number of unique handshakes in a group of n people. Parameters: n (int): The number of people in the group. Returns: int: Total number of unique handshakes. if n <= 1: return 0 return n * (n - 1) // 2"},{"question":"**Context**: Binary trees are a fundamental data structure in computer science, useful for various applications such as representing hierarchical data, facilitating search operations, and more. Given a binary tree, each node contains an integer value, and your task is to determine if the sum of the left subtree is equal to the sum of the right subtree for every node in the tree. **Problem Statement**: You are given the root of a binary tree. Implement the function `is_balanced_tree(root: Optional[TreeNode]) -> bool` that returns `True` if for every node, the sum of its left subtree is equal to the sum of its right subtree, and `False` otherwise. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_tree(root: Optional[TreeNode]) -> bool: pass ``` # Input: - `root`: a TreeNode representing the root of the binary tree. A TreeNode is defined with a `val` and optional `left` and `right` nodes. # Output: - A boolean value: `True` if the tree is balanced as described, `False` otherwise. # Constraints: - The node values are integers within the range of -10^4 to 10^4. - The binary tree contains at most 10^4 nodes. - You may assume the binary tree structure to be well-formed. # Example: ```python assert is_balanced_tree(TreeNode(0)) == True assert is_balanced_tree(TreeNode(1, TreeNode(2), TreeNode(2))) == False assert is_balanced_tree(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5))) == False ``` # Note: - You might need a helper function to compute the subtree sums effectively. - Consider edge cases, such as when the tree is empty or has only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_tree(root: TreeNode) -> bool: def subtree_sum(node: TreeNode) -> int: if node is None: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) return node.val + left_sum + right_sum def is_balanced(node: TreeNode) -> bool: if node is None: return True left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) return left_sum == right_sum and is_balanced(node.left) and is_balanced(node.right) return is_balanced(root)"},{"question":"# Task: Compute the Longest Subsequence with Unique Characters Objective Write a function `longest_unique_subseq(s: str) -> int` to find the length of the longest subsequence in a given string where all characters are unique. Description A subsequence is derived from another sequence by deleting some or none of the elements without changing the order of the remaining elements. The problem is to determine the length of the longest such subsequence where all characters are unique. Input - `s` (1 ≤ |s| ≤ 10^5): a string consisting of lowercase letters. Output - Return the length of the longest subsequence with all unique characters. Example ```python assert longest_unique_subseq(\\"abcabcbb\\") == 3 assert longest_unique_subseq(\\"bbbbb\\") == 1 assert longest_unique_subseq(\\"pwwkew\\") == 3 assert longest_unique_subseq(\\"a\\") == 1 assert longest_unique_subseq(\\"abcdefghi\\") == 9 ``` Constraints - Ensure the code runs efficiently within the given constraints. - Use appropriate data structures to manage the uniqueness and length calculation. Guidelines 1. Utilize frequency counting and set operations to track unique characters. 2. Optimize the approach to handle large input sizes effectively. 3. Avoid excessive memory usage for intermediate results. 4. Handle edge cases, such as single-character strings, thoroughly.","solution":"def longest_unique_subseq(s: str) -> int: Function to compute the length of the longest subsequence with all unique characters. return len(set(s))"},{"question":"# Problem Statement Design an algorithm to convert a non-negative integer to its English words representation. Your solution should efficiently handle ranges from 0 to 999,999,999. # Function Signature ```python def number_to_words(num: int) -> str: pass ``` # Input - `num`: A non-negative integer. # Output - A string representing the given integer in English words. # Constraints - 0 <= num <= 999,999,999 # Example ```python # Example usage num = 123456789 # Example expected output # \\"One Hundred Twenty Three Million Four Hundred Fifty Six Thousand Seven Hundred Eighty Nine\\" print(number_to_words(num)) ``` # Task Description 1. **Number Segmentation**: Segment the number into billions, millions, thousands, and the last three digits. 2. **Word Conversion**: Implement the function to convert each segment to English words using helper functions. 3. **Edge Cases & Performance**: Handle edge cases such as 0 and ensure the solution can quickly process large numbers. --- # Hints: - Think about breaking down the problem into smaller parts, for example, handling numbers below 1000 separately. - Reuse common lexical patterns for segments like \\"Thousand\\", \\"Million\\", and \\"Billion\\". - Consider special cases for numbers below 20 and round tens like 30, 40, etc.","solution":"def number_to_words(num: int) -> str: if num == 0: return \\"Zero\\" below_20 = [\\"\\", \\"One\\", \\"Two\\", \\"Three\\", \\"Four\\", \\"Five\\", \\"Six\\", \\"Seven\\", \\"Eight\\", \\"Nine\\", \\"Ten\\", \\"Eleven\\", \\"Twelve\\", \\"Thirteen\\", \\"Fourteen\\", \\"Fifteen\\", \\"Sixteen\\", \\"Seventeen\\", \\"Eighteen\\", \\"Nineteen\\"] tens = [\\"\\", \\"\\", \\"Twenty\\", \\"Thirty\\", \\"Forty\\", \\"Fifty\\", \\"Sixty\\", \\"Seventy\\", \\"Eighty\\", \\"Ninety\\"] thousands = [\\"\\", \\"Thousand\\", \\"Million\\", \\"Billion\\"] def helper(n): if n == 0: return \\"\\" elif n < 20: return below_20[n] + \\" \\" elif n < 100: return tens[n // 10] + \\" \\" + helper(n % 10) else: return below_20[n // 100] + \\" Hundred \\" + helper(n % 100) res = \\"\\" for idx, chunk in enumerate(thousands): if num % 1000 != 0: res = helper(num % 1000) + chunk + \\" \\" + res num //= 1000 return res.strip()"},{"question":"# Coding Assessment Question **Context:** You are working on a problem related to balanced strings where each character should appear the same number of times. A string is considered balanced if all characters in the string appear the same number of times. **Problem Statement:** Write a function `is_almost_balanced(s: str) -> bool` that determines if a given string `s` can be made balanced by removing at most one character. The function should return `True` if it\'s possible to make the string balanced by removing zero or one character, and `False` otherwise. **Input:** - A string `s` consisting of lowercase English letters. **Output:** - A boolean value `True` if the string can be made balanced by removing at most one character, and `False` otherwise. **Constraints:** - The length of the string `s` will not exceed 1000 characters. # Function Signature ```python def is_almost_balanced(s: str) -> bool: pass ``` # Examples ```python # Example 1: print(is_almost_balanced(\\"aabbcc\\")) # Output: True # Example 2: print(is_almost_balanced(\\"aabbccc\\")) # Output: True # Example 3: print(is_almost_balanced(\\"aabbcccc\\")) # Output: False # Example 4: print(is_almost_balanced(\\"abcd\\")) # Output: True ``` In this question, you will be developing a function to check if a given string can be made balanced by removing at most one character. The objective is to explore the efficient use of dictionaries and sets to manage character counts within the constraints provided. This problem checks the ability to work with string manipulation and balancing logic, similar to problems assessing combinatorial calculations or threshold-based conditions.","solution":"def is_almost_balanced(s: str) -> bool: from collections import Counter # Count frequency of each character freq = Counter(s) freq_values = list(freq.values()) # Frequency of frequencies freq_counts = Counter(freq_values) if len(freq_counts) == 1: return True if len(freq_counts) == 2: # Extract most common frequencies and their counts (first_freq, first_count), (second_freq, second_count) = freq_counts.most_common() # Check conditions to balance the string by removing at most one character # Case 1: One of the frequency counts is 1 and you can remove one character to match the other frequency if first_count == 1 and (first_freq - 1 == second_freq or first_freq == 1): return True if second_count == 1 and (second_freq - 1 == first_freq or second_freq == 1): return True return False"},{"question":"# Merging Intervals with Query Support Objective: Design a data structure to dynamically manage a list of intervals and support queries for the merged intervals. Description: You need to create a new type of interval list that allows adding intervals and querying the current list of merged intervals. When adding an interval, it should automatically merge with any existing intervals that overlap or touch. When queried, it should return the list of non-overlapping intervals. Requirements: * Define an IntervalManager structure and initialize it without any intervals. * Implement functions to: * Add a new interval. * Retrieve the list of current merged intervals. Function Signatures: ```python class IntervalManager: def __init__(self) -> None: Initialize the Interval Manager without any intervals. pass def add_interval(self, start: int, end: int) -> None: Add an interval (start, end) to the manager. pass def get_merged_intervals(self) -> List[Tuple[int, int]]: Return a list of the current merged intervals. pass ``` Example: ```python # Initializing the Interval Manager im = IntervalManager() # Adding intervals im.add_interval(1, 3) im.add_interval(5, 8) im.add_interval(2, 6) # Querying the merged intervals assert im.get_merged_intervals() == [(1, 8)] # The intervals [1, 3], [5, 8], and [2, 6] merge into [1, 8] # Adding another interval im.add_interval(10, 12) # Querying the merged intervals assert im.get_merged_intervals() == [(1, 8), (10, 12)] # Interval [10, 12] added without merging ``` Constraints: * Intervals are inclusive and represented as tuples `(start, end)` where `start` and `end` are integers. * The start value will always be less than or equal to the end value. * The number of intervals managed at any time will not exceed 10^4. * Each interval\'s start and end values will be between -10^4 and 10^4. # Explanation: - The new question involves managing intervals and ensuring they are merged appropriately, similar in complexity to the Segment Tree operations but in a different context. - The provided example ensures clarity in usage and expectations from the solution. - This task involves common data structure operations that match the style and level of difficulty seen in the original question.","solution":"from typing import List, Tuple class IntervalManager: def __init__(self) -> None: Initialize the Interval Manager without any intervals. self.intervals = [] def add_interval(self, start: int, end: int) -> None: Add an interval (start, end) to the manager. new_interval = (start, end) self.intervals.append(new_interval) self.intervals.sort(key=lambda x: x[0]) self._merge_intervals() def _merge_intervals(self) -> None: Merge overlapping intervals. merged_intervals = [] for current in self.intervals: if not merged_intervals or merged_intervals[-1][1] < current[0] - 1: merged_intervals.append(current) else: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], current[1])) self.intervals = merged_intervals def get_merged_intervals(self) -> List[Tuple[int, int]]: Return a list of the current merged intervals. return self.intervals"},{"question":"**Context**: In a system for managing event bookings, we have a list of events where each event has a start time and an end time. To avoid conflicts, we need a way to determine if a new event can be scheduled given a list of existing events. **Coding Task**: Write a function named `can_schedule_event` that takes three parameters: * `events` (a list of tuples, where each tuple contains two integers (start, end) representing the start and end times of an existing event), * `new_event_start` (an integer, the start time of the new event), * `new_event_end` (an integer, the end time of the new event). Your function should return a boolean indicating whether the new event can be scheduled without overlapping any existing event. # Input * The function will be called as: `can_schedule_event(events: List[Tuple[int, int]], new_event_start: int, new_event_end: int) -> bool` * `events`: A list of tuples representing existing events. Each tuple has two integers (start, end) where `1 ≤ start < end ≤ 10^9`. * `new_event_start` and `new_event_end`: Integers representing the start and end times of the new event where `1 ≤ new_event_start < new_event_end ≤ 10^9`. # Output * Return `True` if the new event can be scheduled without overlapping any existing event, `False` otherwise. # Constraints * Assume that no two existing events overlap. * Ensure the solution handles cases efficiently, even when there are a large number of events. # Example ```python from typing import List, Tuple def can_schedule_event(events: List[Tuple[int, int]], new_event_start: int, new_event_end: int) -> bool: # Your implementation here # Example usage events = [(1, 5), (6, 10), (12, 15)] print(can_schedule_event(events, 5, 6)) # Output: True print(can_schedule_event(events, 3, 7)) # Output: False ``` # Explanation * In the first example, the new event from time 5 to 6 does not overlap with any existing events, so it returns `True`. * In the second example, the new event from time 3 to 7 overlaps with the existing event from 1 to 5, so it returns `False`.","solution":"from typing import List, Tuple def can_schedule_event(events: List[Tuple[int, int]], new_event_start: int, new_event_end: int) -> bool: for start, end in events: if not (new_event_end <= start or new_event_start >= end): return False return True"},{"question":"# Question: Detect and Remove Cycles in a Directed Graph You are given a directed graph represented as a dictionary where keys are node labels, and values are lists of adjacent nodes. Implement a class `DirectedGraph` with the following methods: 1. **Constructor `__init__(self, graph: dict[str, list[str]])`**: - Initializes the directed graph. 2. **Method `detect_cycle(self) -> bool`**: - Detects if there is any cycle in the graph. Utilizes Depth-First Search (DFS) algorithm. - Returns `True` if a cycle is detected, otherwise `False`. 3. **Method `remove_cycles(self) -> None`**: - If a cycle is detected, modifies the graph to remove cycles by removing the necessary edges. - The resulting graph should have no cycles. # Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\", \\"E\\"], \\"C\\": [\\"F\\"], \\"D\\": [\\"C\\", \\"G\\"], \\"E\\": [\\"D\\"], \\"F\\": [\\"H\\"], \\"G\\": [\\"A\\"], \\"H\\": [] } g = DirectedGraph(graph) # Detect cycle print(g.detect_cycle()) # Output: True # Remove cycles g.remove_cycles() # Check if cycles are removed print(g.detect_cycle()) # Output: False ``` # Constraints - The graph is directed. - All vertex names are unique and consist of uppercase English letters. - You can assume that the input graph will not have self-loops. - Ensure to handle the case where removing any edge can break a cycle but aim to preserve the graph\'s structure as much as possible. # Notes - The `detect_cycle` method should efficiently detect cycles using standard algorithms such as DFS with back edge detection. - The `remove_cycles` method should remove the minimum number of edges to break the cycles effectively and maintain connectivity of the graph where possible.","solution":"class DirectedGraph: def __init__(self, graph): Initializes the directed graph. :param graph: dict[str, list[str]] self.graph = graph def detect_cycle(self): Detects if there is any cycle in the graph using DFS. :return: bool WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in self.graph} def dfs(node): if color[node] == GRAY: return True # Found cycle if color[node] == BLACK: return False # Already processed color[node] = GRAY for neighbor in self.graph[node]: if dfs(neighbor): return True color[node] = BLACK return False for node in self.graph: if color[node] == WHITE: if dfs(node): return True return False def remove_cycles(self): Remove cycles from the graph by removing the necessary edges. def dfs(node, stack, visited): if node in stack: cycle_start_index = stack.index(node) cycle = stack[cycle_start_index:] return cycle if node not in visited: stack.append(node) visited.add(node) for neighbor in self.graph[node]: cycle = dfs(neighbor, stack, visited) if cycle: return cycle stack.pop() return None while self.detect_cycle(): visited = set() cycle = None for node in self.graph: if node not in visited: cycle = dfs(node, [], visited) if cycle: break if cycle: # Remove an edge to break the cycle to_remove = cycle[-1] for node in cycle: if to_remove in self.graph[node]: self.graph[node].remove(to_remove) break"},{"question":"# Problem Statement You are given logs of user activity on a website. Each log entry is a tuple containing three elements: 1. User ID (a string) 2. Action (a string, which can be either `\'login\'` or `\'logout\'`) 3. Timestamp (an integer representing the time in seconds from the epoch) The logs are supposed to be processed to determine the total time each user has spent logged in. Write a Python function named `calculate_user_session_times()` that processes these log entries and returns a dictionary mapping user IDs to their total session time in seconds. If a user has a \'login\' action without a corresponding \'logout\', the session should be considered invalid and ignored. # Input - `logs`: A list of tuples where each tuple is of the form: - (string: user_id, string: action, int: timestamp) - The list is sorted by timestamp in ascending order. # Output - A dictionary where keys are user IDs and values are integers representing the total session time for each user. # Constraints - Each user ID will only have valid (login, logout) pairs or invalid sessions (login without logout). - There will be no overlapping sessions for any user. # Example ```python # Example usage logs = [ (\'user1\', \'login\', 100), (\'user2\', \'login\', 200), (\'user1\', \'logout\', 300), (\'user2\', \'logout\', 400), (\'user1\', \'login\', 500), (\'user1\', \'logout\', 600) ] print(calculate_user_session_times(logs)) # Output: # {\'user1\': 300, \'user2\': 200} ``` # Note - Users without a valid session (login without logout) should not appear in the output dictionary. - The input logs list will always be sorted by timestamp.","solution":"def calculate_user_session_times(logs): user_sessions = {} login_times = {} for user_id, action, timestamp in logs: if action == \'login\': if user_id in login_times: # If there\'s a login without a logout ignore this session login_times[user_id] = None else: login_times[user_id] = timestamp elif action == \'logout\': if user_id in login_times and login_times[user_id] is not None: logged_in_time = timestamp - login_times[user_id] if user_id in user_sessions: user_sessions[user_id] += logged_in_time else: user_sessions[user_id] = logged_in_time del login_times[user_id] return user_sessions"},{"question":"# **Coding Assessment Question** **Pathfinding and Maze Solving** In this task, you will create methods to solve a maze represented as a 2D grid. The objective is to demonstrate your understanding of graph traversal algorithms by implementing the methods as specified below. **Task** 1. **Find Path**: Implement a method `find_path` to return the path from the top-left corner to the bottom-right corner of the maze, if it exists. Use Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the maze. ```python def find_path(self) -> List[Tuple[int, int]]: Return a list of tuples representing the path from the top-left to the bottom-right corner of the maze. If no path exists, return an empty list. >>> Maze([[0, 1, 0], [0, 1, 0], [0, 0, 0]]).find_path() [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] >>> Maze([[0, 1], [1, 0]]).find_path() [] >>> Maze([[0, 0, 0], [1, 1, 0], [0, 0, 0]]).find_path() [(0,0), (0, 1), (0, 2), (1, 2), (2, 2)] # Implement the method here ``` 2. **Is Solvable**: Implement a method `is_solvable` to check if there exists a path from the start to the end of the maze. ```python def is_solvable(self) -> bool: Return a boolean indicating whether the maze is solvable from top-left to bottom-right corner. >>> Maze([[0, 1, 0], [0, 1, 0], [0, 0, 0]]).is_solvable() True >>> Maze([[0, 1], [1, 0]]).is_solvable() False >>> Maze([[0, 0, 0], [1, 1, 0], [0, 0, 0]]).is_solvable() True # Implement the method here ``` 3. **Shortest Path**: Implement a method `shortest_path` to return the shortest path from the start to the end of the maze, if it exists. ```python def shortest_path(self) -> List[Tuple[int, int]]: Return a list of tuples representing the shortest path from the top-left to the bottom-right corner of the maze. If no path exists, return an empty list. >>> Maze([[0, 1, 0], [0, 1, 0], [0, 0, 0]]).shortest_path() [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] >>> Maze([[0, 1], [1, 0]]).shortest_path() [] >>> Maze([[0, 0, 0], [1, 1, 0], [0, 0, 0]]).shortest_path() [(0,0), (0, 1), (0, 2), (1, 2), (2, 2)] # Implement the method here ``` **Function Signature** ```python from typing import List, Tuple class Maze: def __init__(self, grid: List[List[int]]): self.grid = grid def find_path(self) -> List[Tuple[int, int]]: # Implement here pass def is_solvable(self) -> bool: # Implement here pass def shortest_path(self) -> List[Tuple[int, int]]: # Implement here pass ``` **Input and Output Formats** * The `find_path` method should return a list of tuples representing the coordinates of the path from the start to the end of the maze or an empty list if no path exists. * The `is_solvable` method should return a boolean indicating if the maze can be solved from the start to the end. * The `shortest_path` method should return a list of tuples representing the shortest path or an empty list if no path exists. **Constraints/Limitations** * The maze will be represented as a 2D grid where 0s represent open paths and 1s represent walls. * The maze will always have at least one cell. * The top-left and bottom-right corners will always be represented by 0s.","solution":"from typing import List, Tuple from collections import deque class Maze: def __init__(self, grid: List[List[int]]): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) def find_path(self) -> List[Tuple[int, int]]: def dfs(r, c, path): if r < 0 or r >= self.rows or c < 0 or c >= self.cols or self.grid[r][c] == 1: return False path.append((r, c)) if (r, c) == (self.rows-1, self.cols-1): return True self.grid[r][c] = 1 # mark as visited # explore neighbors if (dfs(r+1, c, path) or dfs(r, c+1, path) or dfs(r-1, c, path) or dfs(r, c-1, path)): return True path.pop() return False path = [] if dfs(0, 0, path): return path else: return [] def is_solvable(self) -> bool: def bfs(): queue = deque([(0, 0)]) visited = set((0, 0)) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: r, c = queue.popleft() if (r, c) == (self.rows-1, self.cols-1): return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < self.rows and 0 <= nc < self.cols and self.grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc)) visited.add((nr, nc)) return False return bfs() def shortest_path(self) -> List[Tuple[int, int]]: queue = deque([((0, 0), [(0, 0)])]) visited = set((0, 0)) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: (r, c), path = queue.popleft() if (r, c) == (self.rows-1, self.cols-1): return path for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < self.rows and 0 <= nc < self.cols and self.grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append(((nr, nc), path + [(nr, nc)])) visited.add((nr, nc)) return []"},{"question":"# Coding Assessment Question You are tasked with developing a system for a library to manage book loans. The library needs to keep track of overdue books and calculate the fines for late returns. Each book must be returned by its due date, and a fine is applied for each day the book is overdue. Task: Implement a class `LibrarySystem` that manages book loans and calculates overdue fines. The class should have the following methods: - `loan_book(self, book_id: int, due_date: str) -> None`: Registers a book loan with the given `book_id` and `due_date` in the format `\'YYYY-MM-DD\'`. - `return_book(self, book_id: int, return_date: str) -> float`: Registers the return of a book with the given `book_id` on `return_date` in the format `\'YYYY-MM-DD\'`. Calculates and returns the fine for the book if it is overdue. The fine is `1.0` unit of currency for each day the book is overdue. - `current_fine(self) -> float`: Returns the total fine accumulated for all overdue books in the system. You can assume the system clock is not necessary, and dates are provided in the correct format. Constraints: - Dates are given in the format `\'YYYY-MM-DD\'`, and both `due_date` and `return_date` are valid dates. - Each book has a unique `book_id`. - If `return_date` is before `due_date`, the fine is `0.0`. Class Definition: ```python from datetime import datetime class LibrarySystem: def __init__(self): self.loans = {} self.total_fine = 0.0 def loan_book(self, book_id: int, due_date: str) -> None: pass def return_book(self, book_id: int, return_date: str) -> float: pass def current_fine(self) -> float: pass ``` Example Usage: ```python library = LibrarySystem() library.loan_book(1, \'2023-11-01\') library.loan_book(2, \'2023-11-03\') fine1 = library.return_book(1, \'2023-11-05\') print(fine1) # Output: 4.0 fine2 = library.return_book(2, \'2023-11-03\') print(fine2) # Output: 0.0 total_fine = library.current_fine() print(total_fine) # Output: 4.0 ``` Make sure to handle edge cases and ensure that the fine calculations are accurate.","solution":"from datetime import datetime class LibrarySystem: def __init__(self): self.loans = {} self.total_fine = 0.0 def loan_book(self, book_id: int, due_date: str) -> None: self.loans[book_id] = due_date def return_book(self, book_id: int, return_date: str) -> float: if book_id in self.loans: due_date = datetime.strptime(self.loans[book_id], \'%Y-%m-%d\').date() return_date = datetime.strptime(return_date, \'%Y-%m-%d\').date() overdue_days = (return_date - due_date).days if overdue_days > 0: fine = overdue_days * 1.0 self.total_fine += fine return fine return 0.0 def current_fine(self) -> float: return self.total_fine"},{"question":"# Coding Assessment Question Objective Extend the algorithm to find the smallest prime number greater than each element in a given list of integers. Problem Statement Write a Python function `next_prime(nums: List[int]) -> List[int]` that takes a list of integers and for each integer `n`, determines the smallest prime number greater than `n`. Return a list of these smallest prime numbers. # Input * `nums`: A list of integers (1 <= len(nums) <= 1000, 0 <= nums[i] <= 10000) # Output * A list of integers where each integer corresponds to the smallest prime number greater than the respective integer in the input list `nums`. # Constraints * You can assume that all inputs are valid according to the above specifications. * The function should be optimized for performance given the constraints. # Example ```python def next_prime(nums: List[int]) -> List[int]: def is_prime(x: int) -> bool: if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def find_next_prime(n: int) -> int: candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate return [find_next_prime(n) for n in nums] # Example Usage print(next_prime([3, 10, 17, 0, 10000])) # Output: [5, 11, 19, 2, 10007] ``` # Requirements 1. The function should be efficiently implemented to handle the maximum constraints. 2. The use of helper functions is encouraged to streamline the readability of the code. Notes: * Ensure your implementation can handle the edge cases where `n` is minimal or maximal within the given range. * Conduct thorough testing with various scenarios to verify the correctness and performance of your solution.","solution":"from typing import List def next_prime(nums: List[int]) -> List[int]: def is_prime(x: int) -> bool: if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def find_next_prime(n: int) -> int: candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate return [find_next_prime(n) for n in nums]"},{"question":"# Problem Description Create a function `sum_even_and_product_odds` that accepts a list of integers, `input_list`. Your task is to compute the sum of all the even integers and the product of all the odd integers in the list. The function should return a tuple `(sum_even, product_odd)`. # Input * `input_list` (list): A list of integers which can be positive, negative, or zero. # Output * The function should return a tuple where: - The first element is the sum of all even integers in the list. - The second element is the product of all odd integers in the list. If there are no odd integers, the product should be considered as 1. # Constraints * The list can be empty. In such cases, both the sum of evens and the product of odds should be considered as 0 and 1 respectively. * The integers can be positive, negative, or zero. # Example ```python >>> sum_even_and_product_odds([1, 2, 3, 4, 5]) (6, 15) >>> sum_even_and_product_odds([-1, -2, -3, -4, -5]) (-6, -15) >>> sum_even_and_product_odds([0, 2, 4, 6]) (12, 1) >>> sum_even_and_product_odds([1, 3, 5, 7]) (0, 105) >>> sum_even_and_product_odds([]) (0, 1) ``` # Requirements * Implement the function `sum_even_and_product_odds` that meets the specifications. * Ensure the code adequately handles edge cases and is efficient.","solution":"def sum_even_and_product_odds(input_list): Returns the sum of all even integers and the product of all odd integers in the input_list. Args: input_list: list of integers (can be positive, negative, or zero). Returns: A tuple (sum_even, product_odd) where sum_even is the sum of all even integers and product_odd is the product of all odd integers in the input_list. sum_even = 0 product_odd = 1 found_odd = False for num in input_list: if num % 2 == 0: # even sum_even += num else: # odd product_odd *= num found_odd = True if not found_odd: product_odd = 1 return (sum_even, product_odd)"},{"question":"# Background You are working with a system that processes user scores from multiple competitions. Scores for each user are recorded across different events, and you need to identify consistent performers. A consistent performer is defined as someone who has improved their score in each subsequent competition. # Problem Write a function `consistent_performers` that receives a dictionary where keys are user IDs and values are lists of integers representing scores achieved by that user in chronological order. The function should return a list of user IDs who improved their score in every subsequent competition without exception. # Function Signature ```python def consistent_performers(scores: dict) -> list: pass ``` # Input * `scores` (dict): A dictionary where keys are user IDs (strings) and values are lists of integers representing scores in chronological order (e.g., `[50, 60, 80]`). # Output * Returns a list of user IDs (strings) who have improved their score in every subsequent competition. # Example ```python consistent_performers({ \\"user1\\": [50, 60, 80], \\"user2\\": [45, 30, 50, 65], \\"user3\\": [70, 80, 75], \\"user4\\": [40, 40, 40] }) # Returns [\\"user1\\", \\"user2\\"] ``` # Constraints * Each list of scores will have at least 2 integers. * Scores are guaranteed to be positive integers. * The length of any list of scores does not exceed 100. * The number of users does not exceed 10,000. # Additional Notes * A user is considered to have improved if every score is strictly greater than the preceding score. * Ensure the function efficiently processes large dictionaries and lists.","solution":"def consistent_performers(scores: dict) -> list: consistent_users = [] for user, user_scores in scores.items(): if all(user_scores[i] < user_scores[i+1] for i in range(len(user_scores) - 1)): consistent_users.append(user) return consistent_users"},{"question":"# Scenario You have been tasked with creating a function to analyze a list of valid IP addresses and return the IP that appears most frequently. In case of a tie, return the IP that appears first in alphabetical order. # Task Write a Python function, `get_most_frequent_ip()`, that accepts a list of valid IPv4 addresses and determines the most frequently occurring IP address. If there is a tie, the function should return the IP address that comes first when sorted alphabetically. # Requirements 1. **Function Signature**: ```python def get_most_frequent_ip(ip_list: list[str]) -> str: ``` 2. **Input**: A list of strings with each string being a valid IPv4 address. 3. **Output**: A string representing the most frequently occurring IP address. If multiple IP addresses have the same frequency, return the one that appears first in alphabetical order. 4. **Constraints**: - The list will contain only valid IPv4 addresses. - The length of the list will be between 1 and 10,000 (inclusive). - No requirement to handle invalid IP addresses, empty lists, or non-list inputs. # Example ```python ip_list = [\'192.168.0.1\', \'192.168.0.5\', \'192.168.0.1\', \'10.0.0.1\', \'192.168.0.5\', \'192.168.0.5\' ] print(get_most_frequent_ip(ip_list)) # Output: \'192.168.0.5\' ``` # Additional Guidelines * Ensure that your function is efficient in terms of both time and space complexity. * Write a few test cases to validate your implementation. * You can use any standard Python libraries as you see fit.","solution":"def get_most_frequent_ip(ip_list): Determines the most frequently occurring IP address in a list of valid IPv4 addresses. In case of a tie, returns the IP address that appears first in alphabetical order. Parameters: ip_list (list): List of valid IPv4 addresses Returns: str: Most frequent IP address or the first alphabetically in case of a tie from collections import Counter # Count the frequency of each IP address ip_count = Counter(ip_list) # Find the maximum frequency max_count = max(ip_count.values()) # Filter out IPs with the maximum frequency most_frequent_ips = [ip for ip, count in ip_count.items() if count == max_count] # Return the first IP address in alphabetical order return sorted(most_frequent_ips)[0]"},{"question":"# Circular String Rotation Checker **Objective**: Implement a function that checks if one string is a rotation (circular permutation) of another string. # Scenario Suppose you are working on a text processing module where you need to determine if one given string can be transformed into another given string by rotating its characters. For example, \\"hello\\" can be rotated to \\"llohe\\", \\"lohel\\", etc. Your task is to implement a function that can check for such circular permutations. # Problem Specification Write a function `is_rotation(s1: str, s2: str) -> bool` that takes two strings and returns `True` if one string is a rotation of the other, and `False` otherwise. Constraints 1. Both input strings will have the same length, with a length range of 1 to 10^4. 2. The strings are composed of lowercase alphabetical characters only. Input - `s1`: A string that may potentially be a rotation of `s2`. - `s2`: A string that may potentially be a rotation of `s1`. Output - `True` if `s1` is a rotation of `s2`, `False` otherwise. # Example ```python def is_rotation(s1: str, s2: str) -> bool: Check if s1 is a rotation of s2. Example: >>> is_rotation(\\"hello\\", \\"llohe\\") True >>> is_rotation(\\"hello\\", \\"heoll\\") False >>> is_rotation(\\"abcde\\", \\"deabc\\") True >>> is_rotation(\\"abc\\", \\"acb\\") False pass if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Note**: Your function should effectively and efficiently determine if one string is a rotation of the other, checking all possible circular permutations.","solution":"def is_rotation(s1: str, s2: str) -> bool: Check if s1 is a rotation of s2. Parameters: s1 (str): The first string. s2 (str): The second string, which may be a rotation of the first. Returns: bool: True if s1 is a rotation of s2, False otherwise. # A quick check to see if lengths are different if len(s1) != len(s2): return False # The trick is to concatenate s1 with itself concatenated_s1 = s1 + s1 # If s2 is a substring of the concatenated version of s1, then s2 is a rotation. return s2 in concatenated_s1"},{"question":"# Problem Statement Create a function called `pairwise_sum` that takes a single list of integers and returns a new list where each element is the sum of adjacent elements in the original list. # Function Signature ```python def pairwise_sum(arr: list[int]) -> list[int]: pass ``` # Input - **arr (list[int])**: A list of integers (0 ≤ len(arr) ≤ 10^4, -10^3 ≤ arr[i] ≤ 10^3). # Output - **list[int]**: A list of integers representing the summed adjacent pairs. # Constraints - The input list can be empty, in which case the output should also be an empty list. - If there is only one element in the list, the output should be an empty list as well. - The input list will always contain valid integers within the specified range. # Requirements 1. Ensure the function correctly handles edge cases such as an empty list or a list with a single item. 2. Optimize for performance and readability. # Examples ```python assert pairwise_sum([1, 2, 3, 4]) == [3, 5, 7] assert pairwise_sum([10, 20, 30]) == [30, 50] assert pairwise_sum([5]) == [] assert pairwise_sum([]) == [] assert pairwise_sum([-1, -1, -1, -1]) == [-2, -2, -2] ``` # Additional Context This function tests your knowledge of list manipulations, including iterating through lists and performing arithmetic operations on list elements. Make sure your implementation is efficient and handles the specified edge cases.","solution":"def pairwise_sum(arr: list[int]) -> list[int]: Takes a list of integers and returns a list where each element is the sum of adjacent elements in the original list. Parameters: arr (list[int]): a list of integers Returns: list[int]: a list of integers denoting the summed adjacent pairs # Check if the length of the list is less than 2, return an empty list as per the requirements. if len(arr) < 2: return [] # Calculate the pairwise sums result = [arr[i] + arr[i + 1] for i in range(len(arr) - 1)] return result"},{"question":"You are given an undirected graph with nodes labeled from 0 to n-1. Your task is to implement an algorithm that detects if a cycle exists in the graph. **Task**: Identify if the graph contains a cycle using the Union-Find data structure. **Function Signature**: ```python def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: Args: n : int : Number of nodes in the graph. edges : List[Tuple[int, int]] : A list of tuples where each tuple (a, b) represents an undirected edge between nodes a and b. Returns: bool : True if the graph contains a cycle, False otherwise. ``` # Input * Integer `n` representing the number of nodes (1 ≤ n ≤ 10^5). * List `edges` of undirected edges [(a, b), ...] (0 ≤ a, b < n). # Output * Boolean value indicating whether the graph contains a cycle. # Example ```python edges = [(0, 1), (1, 2), (2, 0), (3, 4)] print(has_cycle(5, edges)) # Output: True ``` # Explanation - The graph contains a cycle: (0, 1) -> (1, 2) -> (2, 0). - There is no other cycle involving the node 3 and 4 as they are disconnected from the cycle. # Constraints * Implement the Union-Find with path compression and union by rank heuristics to ensure efficient cycle detection.","solution":"from typing import List, Tuple def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: Detects if an undirected graph contains a cycle using Union-Find method. Args: n : int : Number of nodes in the graph. edges : List[Tuple[int, int]] : A list of tuples where each tuple (a, b) represents an undirected edge between nodes a and b. Returns: bool : True if the graph contains a cycle, False otherwise. parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return False else: return True for u, v in edges: if union(u, v): return True return False"},{"question":"# Binary Search Tree - Find Closest Value Scenario Emily is working on a financial analysis system that needs to quickly find the closest value to a given target in a large dataset of integers. She decides to use a Binary Search Tree (BST) for its efficient search operations. Objective Extend the provided Binary Search Tree implementation to include a method that finds the closest value to a given target. Implement the following additional operations: 1. `findClosestValue(self, target: int) -> int`: Returns the value in the BST that is closest to the target. Requirements * **Function Specifications**: * Traverse the BST efficiently to find the closest value to the target. * Validate the target is within the range of integer values present in the tree. * **Constraints**: * The tree should remain a valid BST after operations. * Optimize for time complexity and ensure memory efficiency. * **Performance**: * Aim to achieve O(log n) time complexity for the search operation. Implementation Given the following class template: ```python class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Inserts a value into the BST. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.insert(5) # duplicate values handled appropriately >>> bst.insert(13) >>> bst.insert(22) >>> bst.insert(1) >>> bst.insert(14) if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def findClosestValue(self, target: int) -> int: Finds the closest value to the target in the BST. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.insert(5) >>> bst.insert(13) >>> bst.insert(22) >>> bst.insert(1) >>> bst.insert(14) >>> bst.findClosestValue(12) 13 >>> bst.findClosestValue(8) 10 # Your implementation here return self._findClosestValue(self.root, target, float(\'inf\')) def _findClosestValue(self, node, target, closest): if node is None: return closest if abs(target - closest) > abs(target - node.value): closest = node.value if target < node.value: return self._findClosestValue(node.left, target, closest) elif target > node.value: return self._findClosestValue(node.right, target, closest) else: return closest ``` Complete the implementation of `findClosestValue` method. Ensure that the BST maintains valid structure and performs efficient searches.","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def findClosestValue(self, target: int) -> int: Finds the closest value to the target in the BST. return self._findClosestValue(self.root, target, float(\'inf\')) def _findClosestValue(self, node, target, closest): if node is None: return closest if abs(target - closest) > abs(target - node.value): closest = node.value if target < node.value: return self._findClosestValue(node.left, target, closest) elif target > node.value: return self._findClosestValue(node.right, target, closest) else: return closest bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(5) bst.insert(13) bst.insert(22) bst.insert(1) bst.insert(14)"},{"question":"**Context**: You are given a social media platform\'s user interaction data represented as a directed graph. Each user is a node, and each directed edge (u, v) signifies that user `u` follows user `v`. Your task is to identify the influencer within this network. An influencer is defined as a user who is followed by the maximum number of other users and does not follow anyone themselves. # Task: Implement a function `find_influencer(following_data: List[Tuple[int, int]]) -> int` that processes the following data and returns the user id of the influencer, or `-1` if no influencer exists. # Detailed Steps: 1. Parse the list of tuples where each tuple represents a directed edge (u, v). 2. Identify users who follow others and users who are followed. 3. Determine the influencer based on the criteria: - The user has the highest follower count. - The user does not follow anyone. 4. Return the user id of the influencer or `-1` if no such user exists. # Input: * `following_data`: A list of tuples where each tuple consists of two integers representing a directed edge (follows relation) between users. `(u, v)` means user `u` follows user `v`. # Output: * Returns an integer representing the user id of the influencer, or `-1` if no influencer exists. # Constraints: * The number of users can be very large (up to 100,000). * User ids are non-negative integers. * Users follow at most 10,000 other users. # Example: ```python def find_influencer(following_data: List[Tuple[int, int]]) -> int: # Your implementation here # Usage following_data = [(1, 3), (2, 3), (4, 3), (5, 3), (3, 6)] result = find_influencer(following_data) print(result) # Expected output: 3 (if 3 is the user with the highest following count who follows no one) ``` # Performance Requirements: * Your solution should efficiently process input up to 100,000 users and 10,000 follow relationships.","solution":"from typing import List, Tuple from collections import defaultdict def find_influencer(following_data: List[Tuple[int, int]]) -> int: follower_count = defaultdict(int) follows_someone = set() for u, v in following_data: follower_count[v] += 1 follows_someone.add(u) potential_influencers = {user for user in follower_count.keys() if user not in follows_someone} if not potential_influencers: return -1 influencer = max(potential_influencers, key=lambda user: follower_count[user]) return influencer if follower_count[influencer] == max(follower_count.values()) else -1"},{"question":"# Line Segment Intersection You are required to write a function to determine if two line segments intersect. A line segment is defined by two endpoints, and intersection means that the two segments share at least one point. # Requirements: 1. **Endpoint Representation**: - Each line segment is represented by a pair of points, where each point is an ordered pair of (x, y) coordinates. 2. **Intersection Handling**: - Determine if the line segments intersect, considering cases where they might be collinear or exactly overlapping at one or multiple points. - Return a boolean indicating whether the two segments intersect. 3. **Edge Cases**: - Handle edge cases where one or both line segments are of zero length (i.e., both endpoints are the same). - Consider boundary conditions where the segments only touch at an endpoint. # Specification: - Input: Two line segments, each represented as a pair of tuples: `((x1, y1), (x2, y2))` and `((x3, y3), (x4, y4))`. - Output: Boolean indicating the intersection status. # Example: ```python # Example 1: segment1 = ((1, 1), (4, 4)) segment2 = ((1, 4), (4, 1)) assert check_intersection(segment1, segment2) == True # Example 2: segment1 = ((1, 1), (2, 2)) segment2 = ((3, 3), (4, 4)) assert check_intersection(segment1, segment2) == False # Example 3: segment1 = ((1, 1), (4, 4)) segment2 = ((2, 2), (6, 6)) assert check_intersection(segment1, segment2) == True ``` # Deliverables: - Implement the function `check_intersection(segment1, segment2)`: ```python def check_intersection(segment1, segment2): pass # Helper function to check the orientation of the triplet (p, q, r) def orientation(p, q, r): # Implementation details # Helper function to check if point q lies on segment pr def on_segment(p, q, r): # Implementation details ``` - Demonstrate the function with the provided examples, ensuring accuracy and handling all edge cases. # Implementation: ```python def check_intersection(segment1, segment2): def orientation(p, q, r): val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 elif val > 0: return 1 else: return 2 def on_segment(p, q, r): if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]): return True return False p1, q1 = segment1 p2, q2 = segment2 o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) if o1 != o2 and o3 != o4: return True if o1 == 0 and on_segment(p1, p2, q1): return True if o2 == 0 and on_segment(p1, q2, q1): return True if o3 == 0 and on_segment(p2, p1, q2): return True if o4 == 0 and on_segment(p2, q1, q2): return True return False # Example demonstrating the function usage segment1 = ((1, 1), (4, 4)) segment2 = ((1, 4), (4, 1)) print(check_intersection(segment1, segment2)) # True segment1 = ((1, 1), (2, 2)) segment2 = ((3, 3), (4, 4)) print(check_intersection(segment1, segment2)) # False segment1 = ((1, 1), (4, 4)) segment2 = ((2, 2), (6, 6)) print(check_intersection(segment1, segment2)) # True ``` # Additional Notes: - Consider potential precision issues with floating-point operations. - Include comments and documentation outlining the function logic. - Test the function with additional custom cases to ensure robustness.","solution":"def check_intersection(segment1, segment2): def orientation(p, q, r): Function to find the orientation of the ordered triplet (p, q, r). 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 elif val > 0: return 1 else: return 2 def on_segment(p, q, r): Given three collinear points p, q, r, check if point q lies on segment pr. if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]): return True return False p1, q1 = segment1 p2, q2 = segment2 # Find the four orientations needed for the general and special cases o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) # General case if o1 != o2 and o3 != o4: return True # Special cases # p1, q1 and p2 are collinear and p2 lies on segment p1q1 if o1 == 0 and on_segment(p1, p2, q1): return True # p1, q1 and q2 are collinear and q2 lies on segment p1q1 if o2 == 0 and on_segment(p1, q2, q1): return True # p2, q2 and p1 are collinear and p1 lies on segment p2q2 if o3 == 0 and on_segment(p2, p1, q2): return True # p2, q2 and q1 are collinear and q1 lies on segment p2q2 if o4 == 0 and on_segment(p2, q1, q2): return True # Otherwise, the segments do not intersect return False"},{"question":"# File System Space Usage Calculation Scenario: You are developing a monitoring tool for a file system that reports the space usage of various directories. A critical part of this tool is to accurately calculate the total space used by files within a given directory path, including subdirectories. Each file and directory has a size associated with it, and your task is to compute the total size of all files under a specified directory. Task: Implement a Python function `calculate_space_usage(directory: str, files: dict) -> int` that calculates the total space used by all files within the specified directory and its subdirectories. The `files` dictionary represents the file system, where the keys are directory paths and the values are lists of tuples, each containing a file name and its size in bytes. Function Requirements: * **Input**: * `directory` (str): The path of the directory whose space usage needs to be calculated. * `files` (dict): A dictionary representing the file system. Keys are directory paths, and values are lists of tuples where each tuple represents a file (`filename`, `size`). * **Output**: * Returns the total space used by all files in the given directory (including its subdirectories). * **Constraints**: * Directory paths use forward slashes (`/`) for separation. * Only valid directory paths will be provided. * Assume all file sizes are positive integers. * If a directory has no files or subdirectories, the total space used should be 0. Example Usage: ```python files = { \\"/\\": [(\\"file1.txt\\", 100), (\\"file2.txt\\", 200)], \\"/subdir1\\": [(\\"file3.txt\\", 300)], \\"/subdir1/subsubdir1\\": [(\\"file4.txt\\", 400)], \\"/subdir2\\": [(\\"file5.txt\\", 500)] } assert calculate_space_usage(\\"/\\", files) == 1500 assert calculate_space_usage(\\"/subdir1\\", files) == 700 assert calculate_space_usage(\\"/subdir2\\", files) == 500 assert calculate_space_usage(\\"/subdir1/subsubdir1\\", files) == 400 ``` Additional Scenarios & Edge Cases to Consider: * Directory with no files or subdirectories: ```python assert calculate_space_usage(\\"/emptydir\\", {}) == 0 ``` * Complex nested structure: ```python files = { \\"/\\": [], \\"/dir1\\": [(\\"file1.txt\\", 100)], \\"/dir1/dir2\\": [(\\"file2.txt\\", 200)], \\"/dir1/dir2/dir3\\": [(\\"file3.txt\\", 300)] } assert calculate_space_usage(\\"/\\", files) == 600 assert calculate_space_usage(\\"/dir1\\", files) == 600 assert calculate_space_usage(\\"/dir1/dir2\\", files) == 500 assert calculate_space_usage(\\"/dir1/dir2/dir3\\", files) == 300 ``` Implement the function `calculate_space_usage` to fulfill these requirements.","solution":"def calculate_space_usage(directory: str, files: dict) -> int: Calculates the total space used by all files within the specified directory and its subdirectories. :param directory: The path of the directory whose space usage needs to be calculated. :param files: A dictionary representing the file system. Keys are directory paths, and values are lists of tuples where each tuple represents a file (filename, size). :return: Total space used by all files in the given directory (including its subdirectories). total_size = 0 for dir_path, file_list in files.items(): if dir_path.startswith(directory): total_size += sum(size for _, size in file_list) return total_size"},{"question":"# Background You are given a text file containing information about a series of transactions. Each line in the file follows the format \\"transaction_id, amount, type\\", where \\"transaction_id\\" is a unique identifier for the transaction, \\"amount\\" is the monetary value of the transaction, and \\"type\\" is either \\"credit\\" or \\"debit\\". # Task Implement a function that processes the transaction data from the file, calculates the total credits and debits, and returns a dictionary with the sum of credits and the sum of debits. Your function should read the file, parse the contents, and compute the totals efficiently. # Function Signature ```python def process_transactions(file_path: str) -> dict: pass ``` # Input - `file_path` (str): The path to the text file containing the transaction data. # Output - `result` (dict): A dictionary with the following keys and corresponding values: - \\"total_credit\\": The sum of all credit transactions. - \\"total_debit\\": The sum of all debit transactions. # Example ```python # Assuming transactions.txt content: # 1, 150.00, credit # 2, 200.50, debit # 3, 320.75, credit # 4, 100.00, debit assert process_transactions(\\"transactions.txt\\") == { \\"total_credit\\": 470.75, \\"total_debit\\": 300.50 } ``` # Constraints - The input file will have at most 10,000 lines. - Each line in the file will be formatted correctly and will not contain any errors. - Transaction amounts will be non-negative numbers.","solution":"def process_transactions(file_path: str) -> dict: Processes the transaction data from the file and returns a dictionary with the sum of credits and the sum of debits. Args: file_path (str): The path to the text file containing the transaction data. Returns: dict: A dictionary containing the total credits and debits. total_credit = 0.0 total_debit = 0.0 with open(file_path, \'r\') as file: for line in file: transaction_id, amount, trans_type = line.strip().split(\', \') amount = float(amount) if trans_type == \'credit\': total_credit += amount elif trans_type == \'debit\': total_debit += amount return { \\"total_credit\\": total_credit, \\"total_debit\\": total_debit }"},{"question":"# Scenario You are required to implement a structure called `StringCompressor` that efficiently compresses and decompresses strings using the Run-Length Encoding (RLE) algorithm. RLE operates by turning a sequence of repeated characters into a single character followed by the count of its repetitions. # Problem Statement Implement the `StringCompressor` class that supports compressing and decompressing strings. Your implementation should support the following methods: - `compress(string: str) -> str`: Compress the input string using Run-Length Encoding. - `decompress(string: str) -> str`: Decompress the input string back to its original form. # Input and Output Formats compress - **Input**: string (str) - **Output**: str (the compressed string) decompress - **Input**: string (str) - **Output**: str (the decompressed string) # Constraints - The input string to compress consists only of uppercase and lowercase English letters. - The input string length for compression or decompression will not exceed 1000 characters. # Example ```python sc = StringCompressor() compressed = sc.compress(\\"aaabbccca\\") print(compressed) # \\"a3b2c3a1\\" decompressed = sc.decompress(compressed) print(decompressed) # \\"aaabbccca\\" compressed = sc.compress(\\"aabccccdd\\") print(compressed) # \\"a2b1c4d2\\" decompressed = sc.decompress(compressed) print(decompressed) # \\"aabccccdd\\" ``` # Performance Requirements - The implementation should efficiently handle strings up to the maximum constraint length, aiming for linear time complexity O(n) for both compression and decompression.","solution":"class StringCompressor: @staticmethod def compress(string: str) -> str: if not string: return \\"\\" compressed = [] count = 1 for i in range(1, len(string)): if string[i] == string[i-1]: count += 1 else: compressed.append(string[i-1] + str(count)) count = 1 compressed.append(string[-1] + str(count)) return \'\'.join(compressed) @staticmethod def decompress(string: str) -> str: decompressed = [] i = 0 while i < len(string): char = string[i] count = 0 i += 1 while i < len(string) and string[i].isdigit(): count = count * 10 + int(string[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# LED Display Configuration Your task is to implement a function `configure_display` that sets the brightness of an LED display based on the given time and environmental light levels. The function should dynamically adjust the LED brightness using a foundational logic involving time of day and ambient light measurements. The function `configure_display` should: 1. Accept two parameters: - `time_of_day`, a string formatted as \\"HH:MM\\" representing the current time. - `ambient_light`, an integer representing the light level (range 0 to 100, inclusive, where 0 is dark and 100 is very bright). 2. Compute and return the appropriate brightness level for the LED display. - During the night (from 20:00 to 06:59), the brightness should be capped at a maximum of 40, irrespective of the ambient light level. - During the day, the brightness is directly proportional to the ambient light level with a 20% enhancement. However, the enhanced brightness should not exceed 100. **Function Signature**: ```python def configure_display(time_of_day: str, ambient_light: int) -> int: pass ``` # Example: ```python print(configure_display(\\"21:30\\", 50)) # Output should be 40 (since it\'s night) print(configure_display(\\"09:00\\", 50)) # Output should be 60 (50 * 1.2 = 60) print(configure_display(\\"14:45\\", 80)) # Output should be 96 (80 * 1.2 = 96, clamped to 100) print(configure_display(\\"03:15\\", 70)) # Output should be 40 (since it\'s night) print(configure_display(\\"12:00\\", 90)) # Output should be 100 (90 * 1.2 = 108, clamped to 100) ``` # Constraints: 1. The time of day will be a valid string in \\"HH:MM\\" 24-hour format. 2. The ambient light will be an integer within the range 0 to 100 inclusive. 3. Ensure your function performs efficiently with a focus on accurately computing the correct brightness level for the specified conditions.","solution":"def configure_display(time_of_day: str, ambient_light: int) -> int: # Split the time_of_day into hours and minutes hours, minutes = map(int, time_of_day.split(\':\')) # Check if it\'s night time (20:00 to 06:59) if (hours >= 20 or hours < 7): # Cap the brightness at 40 during the night return 40 else: # Calculate enhanced brightness with a 20% enhancement enhanced_brightness = int(ambient_light * 1.2) # Clamp the brightness to a maximum of 100 return min(enhanced_brightness, 100)"},{"question":"# Coding Assessment Question: E-commerce platforms often need to analyze customer purchase patterns to improve the recommendation system. Your task is to enhance the implementation of a recommendation algorithm by adding features and ensuring robustness, thus making it more adaptive and effective. Objectives: 1. **Error Handling**: Implement error handling in the `calculate_similarity` method to manage scenarios where product data might be missing or corrupted. 2. **Feature Addition**: Extend the `RecommendationSystem` class to include user purchase history, product ratings, and whether a product is in stock or discontinued. 3. **Algorithm Improvement**: Enhance the recommendation algorithm by incorporating user purchase frequency and product ratings in the similarity calculation. 4. **Performance Optimization**: Optimize the `recommend_products` method by caching previous recommendation results to avoid redundant calculations for the same user within a short period. Function Specification: * **Expected Input and Output Formats**: - **Input**: A user ID as a string. - **Output**: A list of dictionaries, each representing a recommended product with its details. * **Constraints and Limitations**: - Assume a valid, non-empty string for the user ID. - Handle cases where user purchase history or product data might be incomplete or unavailable. * **Performance Requirements**: The solution should efficiently manage multiple recommendation requests without unnecessary recalculations. Implementation Requirements: 1. The `RecommendationSystem` class should be updated to include a method `get_recommendations` which: - Retrieves and returns a list of recommended products as dictionaries. - Implements error handling and retry logic for data fetching. 2. Modify the `calculate_similarity` method to: - Log errors appropriately for debugging purposes. - Use user purchase frequency and product ratings to improve similarity calculation. - Cache results to enhance performance. 3. Add properties or methods to retrieve new fields (purchase history, product ratings, is in stock). Function Signature: ```python from typing import List, Dict class RecommendationSystem: def __init__(self, user_id: str): self.user_id = user_id self.user_data = self.get_user_data() self.product_data = self.get_product_data() def get_user_data(self) -> Dict: Fetch and return user data including purchase history as a dictionary. # Implementation goes here. def get_product_data(self) -> Dict: Fetch and return product data including ratings and stock status as a dictionary. # Implementation goes here. def calculate_similarity(self, user_data: Dict, product_data: Dict) -> float: Calculate and return similarity score based on user data and product data. # Implementation goes here. def get_recommendations(self) -> List[Dict]: Retrieve and return a list of recommended products as dictionaries. # Implementation goes here. ``` # Example Usage: ```python # Initialize the class with a user ID recommendation_system = RecommendationSystem(\\"example_user_id\\") # Get product recommendations for the user print(recommendation_system.get_recommendations()) ``` Ensure your implementation is robust, efficient, and handles various edge cases. Include appropriate documentation and comments for clarity.","solution":"from typing import List, Dict import logging class RecommendationSystem: def __init__(self, user_id: str): self.user_id = user_id self.user_data = self.get_user_data() self.product_data = self.get_product_data() self.recommendation_cache = {} def get_user_data(self) -> Dict: Fetch and return user data including purchase history as a dictionary. # Dummy implementation for example. This should fetch real data. return { \\"purchase_history\\": [\\"product_1\\", \\"product_2\\"], \\"ratings\\": {\\"product_1\\": 4, \\"product_2\\": 5} } def get_product_data(self) -> Dict: Fetch and return product data including ratings and stock status as a dictionary. # Dummy implementation for example. This should fetch real data. return { \\"product_1\\": {\\"rating\\": 3.5, \\"in_stock\\": True}, \\"product_2\\": {\\"rating\\": 4.0, \\"in_stock\\": True}, \\"product_3\\": {\\"rating\\": 4.5, \\"in_stock\\": False}, \\"product_4\\": {\\"rating\\": 5.0, \\"in_stock\\": True} } def calculate_similarity(self, user_data: Dict, product_data: Dict) -> float: Calculate and return similarity score based on user data and product data. similarity_score = 0.0 try: purchase_history = user_data[\\"purchase_history\\"] user_ratings = user_data[\\"ratings\\"] for product_id in product_data: if product_id in purchase_history: # Increase score if user has purchased the product similarity_score += 1 # Further increase score based on user\'s rating of the product if product_id in user_ratings: similarity_score += user_ratings[product_id] except KeyError as e: logging.error(f\\"Missing key in data: {e}\\") return similarity_score def get_recommendations(self) -> List[Dict]: Retrieve and return a list of recommended products as dictionaries. if self.user_id in self.recommendation_cache: return self.recommendation_cache[self.user_id] recommendations = [] try: user_data = self.user_data product_data = self.product_data scores = {} for product_id, data in product_data.items(): scores[product_id] = self.calculate_similarity(user_data, {product_id: data}) # Sort the product IDs based on their scores in descending order sorted_products = sorted(scores.items(), key=lambda x: x[1], reverse=True) for product_id, score in sorted_products: if product_data[product_id][\\"in_stock\\"]: recommendations.append({ \\"product_id\\": product_id, \\"similarity_score\\": score, \\"rating\\": product_data[product_id][\\"rating\\"], \\"in_stock\\": product_data[product_id][\\"in_stock\\"] }) except Exception as e: logging.error(f\\"Error while fetching recommendations: {e}\\") self.recommendation_cache[self.user_id] = recommendations return recommendations"},{"question":"# Objective Simulate the behavior of a simple ATM machine handling transactions. # Question Write a Python class `ATM` that simulates an ATM machine allowing for deposit, withdrawal, balance inquiry, and transaction history functionalities. The class should: * Initialize with a starting balance of 0. * Allow the user to deposit a valid amount (positive integer) to the account. * Allow the user to withdraw a valid amount (positive integer) from the account, ensuring the balance does not go negative. * Allow the user to inquire about the current balance. * Maintain a transaction history containing all the operations performed. **Class Definition:** ```python class ATM: def __init__(self): pass def deposit(self, amount: int) -> str: pass def withdraw(self, amount: int) -> str: pass def get_balance(self) -> int: pass def get_history(self) -> list: pass ``` # Methods * `__init__(self)`: Initializes the ATM with a starting balance of 0 and an empty transaction history. * `deposit(self, amount: int) -> str`: Adds the given amount to the account balance. Returns a string indicating the completion of the deposit. * `withdraw(self, amount: int) -> str`: Deducts the given amount from the account balance if sufficient funds exist. Returns a string indicating the completion of the withdrawal or an error message if sufficient funds are not available. * `get_balance(self) -> int`: Returns the current balance of the account. * `get_history(self) -> list`: Returns the transaction history as a list of strings, each string describing a single transaction. # Input - No input will be provided directly. - Methods will be called on an instance of the `ATM` class. # Output - `deposit`: A string message confirming the amount deposited. - `withdraw`: A string message confirming the amount withdrawn or an error message. - `get_balance`: An integer representing the current account balance. - `get_history`: A list of strings representing the transaction history. # Example ```python atm = ATM() assert atm.deposit(1000) == \\"Deposited 1000\\" assert atm.get_balance() == 1000 assert atm.withdraw(500) == \\"Withdrew 500\\" assert atm.get_balance() == 500 assert atm.withdraw(600) == \\"Insufficient balance to withdraw 600\\" assert atm.get_balance() == 500 assert atm.get_history() == [\\"Deposited 1000\\", \\"Withdrew 500\\", \\"Attempted to withdraw 600 - Insufficient balance\\"] ``` # Notes * Ensure the class handles typical edge cases, such as attempting to withdraw more than the available balance. * Ensure the transaction history correctly reflects the sequence and types of all transactions performed.","solution":"class ATM: def __init__(self): self.balance = 0 self.history = [] def deposit(self, amount: int) -> str: if amount <= 0: return \\"Deposit amount must be positive.\\" self.balance += amount transaction = f\\"Deposited {amount}\\" self.history.append(transaction) return transaction def withdraw(self, amount: int) -> str: if amount <= 0: return \\"Withdrawal amount must be positive.\\" if amount > self.balance: transaction = f\\"Attempted to withdraw {amount} - Insufficient balance\\" self.history.append(transaction) return \\"Insufficient balance to withdraw \\" + str(amount) self.balance -= amount transaction = f\\"Withdrew {amount}\\" self.history.append(transaction) return transaction def get_balance(self) -> int: return self.balance def get_history(self) -> list: return self.history"},{"question":"# Question: Merge and Sort Two Lists In this task, you need to implement a function that merges two lists of integers and then sorts the merged list in non-decreasing order. Function Signature ```python def merge_and_sort_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two integer lists into one and returns the sorted list. ``` Input: * Two lists of integers, `list1` and `list2`. Output: * A new list containing all elements from `list1` and `list2`, sorted in non-decreasing order. Constraints: * 0 <= len(list1), len(list2) <= 1000 * -10^9 <= element of list1, list2 <= 10^9 Example ```python assert merge_and_sort_lists([1, 4, 7], [2, 3, 5, 6]) == [1, 2, 3, 4, 5, 6, 7] assert merge_and_sort_lists([10, 20, 30], [-30, -20, -10, 0]) == [-30, -20, -10, 0, 10, 20, 30] assert merge_and_sort_lists([], [2, 2, 2]) == [2, 2, 2] assert merge_and_sort_lists([3, 3, 3], []) == [3, 3, 3] assert merge_and_sort_lists([], []) == [] assert merge_and_sort_lists([5, 5, 5], [5, 5, 5]) == [5, 5, 5, 5, 5, 5] ``` Guidelines: 1. Concatenate `list1` and `list2`. 2. Sort the merged list in non-decreasing order. 3. Handle edge cases such as empty lists. Implement the `merge_and_sort_lists` function in Python and ensure it passes the following test cases: ```python def test_merge_and_sort_lists(): assert merge_and_sort_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort_lists([4, 1, 3], [6, 2, 5]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort_lists([], []) == [] assert merge_and_sort_lists([3], [1, 2]) == [1, 2, 3] assert merge_and_sort_lists([4, 2, 3], [2, 2, 1]) == [1, 2, 2, 2, 3, 4] test_merge_and_sort_lists() print(\\"All test cases passed!\\") ``` This question tests the candidate\'s ability to merge lists and understand sorting algorithms. It ensures coding skills in handling lists and edge cases, making it align well with coding assessment standards.","solution":"def merge_and_sort_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two integer lists into one and returns the sorted list. merged_list = list1 + list2 merged_list.sort() return merged_list"},{"question":"# Problem Statement You are tasked with implementing a function that finds the intersection of two given lists of integers and returns the result as a sorted list. The function should ensure the result contains only unique elements and is sorted in non-decreasing order. # Function Signature ```python def sorted_intersection(list_a: list[int], list_b: list[int]) -> list[int]: pass ``` # Input * `list_a`: A non-empty list of integers. * `list_b`: A non-empty list of integers. # Output * The function should return a sorted list of unique integers that are present in both input lists. # Constraints * Both inputs will be non-empty lists containing integers only. * The function should handle inputs with thousands of elements efficiently. * The output list should be sorted in non-decreasing order. # Examples ```python >>> list_a = [4, 9, 5] >>> list_b = [9, 4, 9, 8, 4] >>> sorted_intersection(list_a, list_b) [4, 9] >>> list_a = [1, 2, 2, 1] >>> list_b = [2, 2] >>> sorted_intersection(list_a, list_b) [2] >>> list_a = [1, 2, 3, 4, 5] >>> list_b = [5, 6, 7, 8, 9] >>> sorted_intersection(list_a, list_b) [5] >>> list_a = [10, 15, 20, 25] >>> list_b = [30, 20, 10, 40] >>> sorted_intersection(list_a, list_b) [10, 20] ``` # Performance Requirements * The function should have a time complexity of O(n + m) where n and m are the sizes of `list_a` and `list_b`, respectively. * The function should have a space complexity of O(min(n, m)) to handle the storage of intersected elements.","solution":"def sorted_intersection(list_a: list[int], list_b: list[int]) -> list[int]: Computes the intersection of two lists and returns a sorted list of unique elements. # Convert both lists to sets to remove duplicates and allow fast intersection set_a = set(list_a) set_b = set(list_b) # Compute the intersection of both sets intersection = set_a & set_b # Convert the set back to a list and sort it result = sorted(intersection) return result"},{"question":"# Question: Implement Tic Tac Toe Game Context You are tasked with implementing a simple command-line version of the Tic Tac Toe game. The game should be able to handle two human players, check for wins, and declare the winner or a tie. Task Implement a class `TicTacToe` that allows two players to play the game. The class should offer methods to display the board, make moves, check for a winner, and determine if the game has ended in a tie. Classes and Methods 1. **TicTacToe** - **Constructor**: - `__init__(self) -> None`: Initializes the 3x3 board as a list of lists and sets the current player (\'X\' or \'O\'). - **Display Board**: - `display_board(self) -> None`: Prints the current state of the board. - **Make Move**: - `make_move(self, row: int, col: int) -> bool`: Places the current player\'s symbol at the given row (0-2) and column (0-2). Returns `True` if the move is successful, otherwise `False`. - **Check Winner**: - `check_winner(self) -> Union[str, None]`: Checks if there is a winner. Returns \'X\' or \'O\' if there is a winner, otherwise `None`. - **Is Full**: - `is_full(self) -> bool`: Returns `True` if the board is full, indicating a tie, otherwise `False`. - **Switch Player**: - `switch_player(self) -> None`: Switches the current player from \'X\' to \'O\' or \'O\' to \'X\'. Example Usage ```python def play_tic_tac_toe(): game = TicTacToe() while True: game.display_board() row = int(input(f\\"Player {game.current_player}, enter row (0-2): \\")) col = int(input(f\\"Player {game.current_player}, enter col (0-2): \\")) if game.make_move(row, col): winner = game.check_winner() if winner: game.display_board() print(f\\"Player {winner} wins!\\") break elif game.is_full(): game.display_board() print(\\"The game is a tie!\\") break else: game.switch_player() else: print(\\"Invalid move! Try again.\\") # How to use it: play_tic_tac_toe() ``` Constraints - Only moves within the bounds of the 3x3 board (0-2 for row and column) should be allowed. - If a spot is already taken, the move should be considered invalid. - The game should alternate between player \'X\' and player \'O\' after each move.","solution":"class TicTacToe: def __init__(self) -> None: # Initialize the 3x3 board as a list of lists filled with empty strings self.board = [[\'\' for _ in range(3)] for _ in range(3)] self.current_player = \'X\' def display_board(self) -> None: for row in self.board: print(\'|\'.join([cell if cell else \' \' for cell in row])) print(\'-\' * 5) def make_move(self, row: int, col: int) -> bool: if 0 <= row < 3 and 0 <= col < 3 and not self.board[row][col]: self.board[row][col] = self.current_player return True return False def check_winner(self) -> str: lines = self.board + [[self.board[row][col] for row in range(3)] for col in range(3)] lines.append([self.board[i][i] for i in range(3)]) lines.append([self.board[i][2 - i] for i in range(3)]) for line in lines: if line[0] and all(cell == line[0] for cell in line): return line[0] return None def is_full(self) -> bool: return all(cell for row in self.board for cell in row) def switch_player(self) -> None: self.current_player = \'O\' if self.current_player == \'X\' else \'X\'"},{"question":"# Coding Assessment Question Context You have been assigned to create a utility that parses and processes dates from various formats. The system you develop should ensure dates are in a consistent format and validate input dates accurately. # Objective Develop the necessary functions to parse, format, and validate dates, ensuring they adhere to the correct format and handle any discrepancies or errors gracefully. # Problem Statement 1. **Function: `parse_date(date_str)`** - **Description**: Parse a string representation of a date and convert it into a tuple of integers `(year, month, day)`. - **Input**: A string date formatted as `\\"YYYY-MM-DD\\"`, `\\"DD-MM-YYYY\\"`, or `\\"MM/DD/YYYY\\"`. - **Output**: A tuple of integers `(year, month, day)`. - **Constraints**: Ensure the date string matches one of the specified formats and handle invalid formats appropriately. 2. **Function: `format_date(year, month, day)`** - **Description**: Format a given date represented by integers into a string following the `\\"YYYY-MM-DD\\"` format. - **Input**: Three integers representing `year`, `month`, and `day`. - **Output**: A string date formatted as `\\"YYYY-MM-DD\\"`. - **Constraints**: Ensure the date components represent a valid date. 3. **Function: `validate_date(year, month, day)`** - **Description**: Validate whether a given date represented by integers is a legitimate date. - **Input**: Three integers representing `year`, `month`, and `day`. - **Output**: A boolean indicating whether the date is valid (considering leap years, correct days in each month, etc.). - **Constraints**: Handle leap years and ensure the date components form a valid date. # Example ```python def parse_date(date_str): # [Write your code here] def format_date(year, month, day): # [Write your code here] def validate_date(year, month, day): # [Write your code here] # Example Usage: assert parse_date(\\"2023-10-25\\") == (2023, 10, 25) assert parse_date(\\"25-10-2023\\") == (2023, 10, 25) assert parse_date(\\"10/25/2023\\") == (2023, 10, 25) assert format_date(2023, 10, 25) == \\"2023-10-25\\" assert validate_date(2023, 10, 25) == True assert validate_date(2023, 2, 29) == False # 2023 is not a leap year assert validate_date(2024, 2, 29) == True # 2024 is a leap year try: parse_date(\\"25-10-23\\") except ValueError: pass # Expected error for an invalid format ```","solution":"import re from datetime import datetime def parse_date(date_str): Parse a string representation of a date and convert it into a tuple of integers (year, month, day). Acceptable formats are \\"YYYY-MM-DD\\", \\"DD-MM-YYYY\\", or \\"MM/DD/YYYY\\". date_formats = [\\"%Y-%m-%d\\", \\"%d-%m-%Y\\", \\"%m/%d/%Y\\"] for fmt in date_formats: try: parsed_date = datetime.strptime(date_str, fmt) return (parsed_date.year, parsed_date.month, parsed_date.day) except ValueError: continue raise ValueError(\\"Date format is invalid\\") def format_date(year, month, day): Format a given date represented by integers into a string following the \\"YYYY-MM-DD\\" format. try: date = datetime(year, month, day) except ValueError as e: raise e return date.strftime(\\"%Y-%m-%d\\") def validate_date(year, month, day): Validate whether a given date represented by integers is a legitimate date. try: datetime(year, month, day) return True except ValueError: return False"},{"question":"**Context**: You\'ve been hired to design a scheduling system for a series of events that may have dependencies on other events. The events are represented as nodes in a directed acyclic graph (DAG), where an edge from event A to event B signifies that event A must be scheduled before event B. **Task**: Implement the `schedule_events` function, which returns the order in which the events should be scheduled, ensuring that all dependencies are respected. You should use topological sorting to achieve this. **Function Signature**: ```python def schedule_events(events: list, dependencies: list) -> list: Compute and return a valid schedule order of events, adhering to their dependencies. :param events: list, a list of strings representing the events :param dependencies: list, a list of tuples representing the dependencies between events :return: list, a list of events in a valid schedule order ``` # Input: - `events` (list): A list of strings representing the events. - `dependencies` (list): A list of tuples where each tuple (A, B) signifies that event A must occur before event B. # Output: - A list representing the order in which the events should be scheduled. If there is no valid schedule, return an empty list. # Constraints: - The graph is a directed acyclic graph (DAG). - There may be multiple valid schedules, return any one of them. - The number of events and dependencies will be at most 10^4. # Example: ```python events = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"] dependencies = [(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"C\\", \\"E\\"), (\\"D\\", \\"F\\"), (\\"E\\", \\"F\\")] assert schedule_events(events, dependencies) in [[\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"], [\\"A\\", \\"C\\", \\"B\\", \\"E\\", \\"D\\", \\"F\\"]] ``` # Note: - Ensure your implementation handles cases with multiple possible valid schedules. - Optimize for both runtime and memory usage. - Be mindful of edge cases such as events with no dependencies and graphs with isolated nodes. **Your implementation will be evaluated on correctness, efficiency, and handling of edge cases.**","solution":"from collections import defaultdict, deque def schedule_events(events, dependencies): Compute and return a valid schedule order of events, adhering to their dependencies. :param events: list, a list of strings representing the events :param dependencies: list, a list of tuples representing the dependencies between events :return: list, a list of events in a valid schedule order # Create an adjacency list and in-degree list adj_list = defaultdict(list) in_degree = {event: 0 for event in events} # Fill the adjacency list and in-degrees for pre, post in dependencies: adj_list[pre].append(post) in_degree[post] += 1 # Initialize a queue and add all events with an in-degree of 0 queue = deque([event for event in events if in_degree[event] == 0]) # List to store the result order of events schedule_order = [] # Process the queue while queue: current_event = queue.popleft() schedule_order.append(current_event) # Decrease the in-degree of neighboring nodes for neighbor in adj_list[current_event]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we have scheduled all events if len(schedule_order) == len(events): return schedule_order else: return []"},{"question":"# Problem Statement: You are provided with a list of integers `data` and an integer `k`. Your task is to implement a function `k_largest_elements` that returns the `k` largest elements from the list in descending order using a min-heap. Requirements: 1. Use a min-heap to keep track of the largest `k` elements found so far. 2. Iterate through the list and maintain a heap of size `k`. 3. Once the iteration is complete, sort the elements in the heap in descending order to get the final result. Function Signature: ```python def k_largest_elements(data: list[int], k: int) -> list[int]: Finds the k largest elements in the provided data list. :param data: A list of integers. :param k: The number of largest elements to find. :return: A list containing the k largest elements in descending order. ``` Example: ```python data = [10, 5, 2, 7, 8, 7] k = 3 print(k_largest_elements(data, k)) # Output: [10, 8, 7] data = [1, 23, 12, 9, 30, 2, 50] k = 4 print(k_largest_elements(data, k)) # Output: [50, 30, 23, 12] ``` Constraints: - `0 <= k <= len(data)` - The list `data` contains no more than (10^5) elements. - The elements of `data` can be any integer values, both positive and negative. Notes: - You may use the `heapq` module from Python\'s standard library to help with heap operations. - Ensure that the function works efficiently with large input sizes. The time complexity should be (O(n log k)).","solution":"import heapq def k_largest_elements(data: list[int], k: int) -> list[int]: Finds the k largest elements in the provided data list. :param data: A list of integers. :param k: The number of largest elements to find. :return: A list containing the k largest elements in descending order. if k == 0: return [] # Create a min-heap with the first k elements. min_heap = data[:k] heapq.heapify(min_heap) # Iterate through the rest of the elements. for num in data[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) # Sort the min-heap in descending order. return sorted(min_heap, reverse=True)"},{"question":"# Context: You are building a library management system that helps librarians keep track of book inventories, user transactions, and overdue books. # Task: Implement a function `calculate_overdue_fines` that calculates the total overdue fines for all users based on the borrowed and returned dates. Each user can borrow multiple books, and each book has a specific fine rate per day if overdue. # Requirements: Input: - `borrowed_books`: List of dictionaries where each dictionary has the keys `user_id`, `book_id`, `borrowed_date`, `due_date`, and `returned_date`. Dates are given in the format \'YYYY-MM-DD\'. - `user_id`: String representing the unique ID of the user. - `book_id`: String representing the unique ID of the book. - `borrowed_date`: String representing the date the book was borrowed. - `due_date`: String representing the due date of the book. - `returned_date`: String representing the date the book was returned. If the book is not returned, this field will be `None`. - `fine_rates`: Dictionary where each key is a `book_id` and the value is the daily fine rate for that book. Output: - A dictionary where each key is a `user_id` and the value is the total overdue fine for that user. Constraints: - The dates are valid and in the correct format. - `borrowed_books` list can contain up to (10^4) entries. - `fine_rates` dictionary will contain valid book IDs with non-negative daily fine rates. Example: ```python borrowed_books = [ {\'user_id\': \'u1\', \'book_id\': \'b1\', \'borrowed_date\': \'2023-01-01\', \'due_date\': \'2023-01-10\', \'returned_date\': \'2023-01-12\'}, {\'user_id\': \'u2\', \'book_id\': \'b2\', \'borrowed_date\': \'2023-01-05\', \'due_date\': \'2023-01-15\', \'returned_date\': None}, {\'user_id\': \'u1\', \'book_id\': \'b3\', \'borrowed_date\': \'2023-01-02\', \'due_date\': \'2023-01-12\', \'returned_date\': \'2023-01-15\'} ] fine_rates = { \'b1\': 10, \'b2\': 5, \'b3\': 7 } calculate_overdue_fines(borrowed_books, fine_rates) # Output: {\'u1\': 49, \'u2\': (current_date - \'2023-01-15\') * 5} ``` # Explanation: - User `u1` has two borrowed books `b1` and `b3`. `b1` is 2 days overdue with a rate of 10 per day, and `b3` is 3 days overdue with a rate of 7 per day, totaling 49. - User `u2` has not returned `b2`, which is overdue. The fine is calculated based on the number of days since `2023-01-15` up to the current date when the function is executed, with a rate of 5 per day. # Note: - Implement the `calculate_overdue_fines` function in Python. - Use appropriate date libraries for date calculations and ensure the function works correctly for different scenarios. - Consider handling edge cases such as books returned on the due date, books not returned, and no overdue fines.","solution":"from datetime import datetime def calculate_overdue_fines(borrowed_books, fine_rates): fines = {} current_date = datetime.now().date() for record in borrowed_books: user_id = record[\'user_id\'] book_id = record[\'book_id\'] due_date = datetime.strptime(record[\'due_date\'], \'%Y-%m-%d\').date() returned_date = datetime.strptime(record[\'returned_date\'], \'%Y-%m-%d\').date() if record[\'returned_date\'] else current_date overdue_days = (returned_date - due_date).days if overdue_days > 0: fine = overdue_days * fine_rates[book_id] if user_id in fines: fines[user_id] += fine else: fines[user_id] = fine return fines"},{"question":"Problem Statement Write a function that validates if a given undirected graph is a tree. An undirected graph is a tree if and only if it is connected and acyclic. You will be provided with the number of nodes in the graph and a list of edges. # Input: * An integer `n` (1 ≤ n ≤ 10^5) representing the number of nodes. * A list of pairs `edges` (each pair representing an undirected edge between two nodes). # Output: * A boolean value `True` if the given graph is a tree, `False` otherwise. # Function signature: ```python def is_tree(n: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Example: ```python >>> is_tree(5, [(0, 1), (0, 2), (0, 3), (3, 4)]) True >>> is_tree(5, [(0, 1), (1, 2), (2, 3), (1, 3), (1, 4)]) False >>> is_tree(3, [(0, 1), (1, 2)]) True ``` # Constraints: * Each edge connects two distinct nodes. * There will be at most `min(10^5, n * (n - 1) / 2)` edges. # Notes: * An undirected graph with `n` nodes is a tree if it has exactly `n-1` edges and is connected. * Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to check for connectivity and cycles. * Handle edge cases like having no edges for `n=1` where the single node is trivially a tree.","solution":"from typing import List, Tuple def is_tree(n: int, edges: List[Tuple[int, int]]) -> bool: if n - 1 != len(edges): return False from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() # Use BFS to check connectivity queue = deque([0]) visited.add(0) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return len(visited) == n"},{"question":"Problem Statement You are given a grid of integers representing elevations on a terrain map. Write a function `trap_snow(grid)` that calculates the amount of snow (measured in unit cubes) that can be trapped after a snowstorm. Snow can only be trapped in valleys formed by the elevations of the grid. # Function Signature ```python def trap_snow(grid: List[List[int]]) -> int: ``` # Input - `grid`: A list of lists of integers where each integer represents the elevation at that cell. The grid will have dimensions `m x n` where `1 ≤ m, n ≤ 100`. # Output - Returns an integer representing the total units of snow trapped in the grid. # Constraints - Each element in the grid is a non-negative integer representing the elevation. - Ensure that the calculation of trapped snow respects the grid\'s boundaries, meaning snow cannot be trapped along the edges of the grid. # Example ```python grid = [ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ] print(trap_snow(grid)) # Output: 4 ``` # Notes - The problem is a 2D extension of the well-known \\"trapping rain water\\" problem. - Consider using algorithms that take advantage of priority queues such as shortest-path algorithms, which can help in efficiently finding the boundaries that can trap snow.","solution":"from heapq import heappop, heappush def trap_snow(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] heap = [] # Adding all the boundary cells to the heap for i in range(m): heappush(heap, (grid[i][0], i, 0)) heappush(heap, (grid[i][n-1], i, n-1)) visited[i][0] = visited[i][n-1] = True for j in range(1, n-1): heappush(heap, (grid[0][j], 0, j)) heappush(heap, (grid[m-1][j], m-1, j)) visited[0][j] = visited[m-1][j] = True trapped_snow = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True trapped_snow += max(0, height - grid[nx][ny]) heappush(heap, (max(height, grid[nx][ny]), nx, ny)) return trapped_snow"},{"question":"# [New Question] You are developing a data processing pipeline for a large-scale financial application, and one of the tasks involves computing the greatest common divisor (GCD) of large sets of integer pairs. To optimize performance, you need to implement an efficient algorithm for calculating the GCD. # Task: Your task is to implement a function `efficient_gcd` that computes the greatest common divisor of two given non-negative integers ( a ) and ( b ) using the Euclidean algorithm. # Function Signature: ```python def efficient_gcd(a: int, b: int) -> int: pass ``` # Expected Input and Output: * **Input:** Two non-negative integers ( a ) and ( b ). * **Output:** An integer which is the greatest common divisor of ( a ) and ( b ). # Constraints: * The integers ( a ) and ( b ) will be non-negative and not exceed ( 10^9 ). * The function should run efficiently even for the upper limit of input values. # Examples: ```python >>> efficient_gcd(48, 18) 6 >>> efficient_gcd(1000000000, 2) 2 >>> efficient_gcd(101, 103) 1 >>> efficient_gcd(0, 5) 5 ``` # Context: You are working on the financial backend where operations like finding GCD of numbers related to users\' accounts need to be performed quickly and accurately. Ensuring this function is efficient will help in maintaining the overall performance of the system, especially when handling large numbers and multiple requests simultaneously.","solution":"def efficient_gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two non-negative integers a and b using the Euclidean algorithm. while b != 0: a, b = b, a % b return a"},{"question":"New Question # Problem Statement You are given a list of `n` positive integers representing dimensions of rectangles in a 2D plane. Your task is to determine the maximal area of a rectangle that can be formed using any two of the provided dimensions. The rectangles can have either dimension as width or height. Implement this using Python. # Function Signature ```python def max_rectangle_area(dimensions: List[int]) -> int: Finds the maximum rectangle area using any two dimensions from the given list. :param dimensions: A list of positive integers representing the dimensions of rectangles. :return: An integer representing the maximal area of the rectangle. ``` # Input - dimensions: List[int] * A list containing `n` positive integers (`2 <= n <= 10^5`, `1 <= dimensions[i] <= 10^4`), indicating the dimensions of the rectangles. # Output - An integer representing the maximal area of a rectangle that can be formed using any two of the provided dimensions. # Examples ```python assert max_rectangle_area([1, 2, 3, 4]) == 12 # Possible rectangles: (1x2, 1x3, 1x4, 2x3, 2x4, 3x4), max area 3x4 = 12 assert max_rectangle_area([5, 1, 8, 6]) == 48 # Possible rectangles: (1x5, 1x8, 1x6, 5x8, 5x6, 8x6), max area 6x8 = 48 ``` # Constraints - Each element in the `dimensions` list will be a positive integer. - You can assume at least two dimensions are provided. - The output should be computed efficiently to handle the upper constraint limits. # Notes - You can iterate through the list and calculate the area for each pair of dimensions to find the maximal area rectangle. - Use an optimized solution to handle larger input sizes within a reasonable time frame.","solution":"from typing import List def max_rectangle_area(dimensions: List[int]) -> int: Finds the maximum rectangle area using any two dimensions from the given list. :param dimensions: A list of positive integers representing the dimensions of rectangles. :return: An integer representing the maximal area of the rectangle. # Sort the dimensions in descending order dimensions.sort(reverse=True) # Calculate area of the rectangle with the two largest dimensions return dimensions[0] * dimensions[1]"},{"question":"# Problem Statement You are tasked with creating an efficient data structure that supports dynamic updates and efficient range minimum queries. You will be implementing a Segment Tree specifically designed for this purpose. Your task is to extend the existing functionality by implementing a new method. # Function to Implement **Function**: `range_min_query(self, left: int, right: int) -> int` You need to implement the above function in the given `SegmentTree` class. This function should return the minimum value in the specified range from `left` to `right` (inclusive). # Input and Output Formats * **Input**: * `left` (int): The starting index of the range. * `right` (int): The ending index of the range (inclusive). * **Output**: * **int**: The minimum value within the range `[left, right]`. # Constraints * `0 <= left <= right < size` (where size is the total number of elements in the Segment Tree) * Assume that update operations have already been performed before querying the range minimum. # Examples ```python st = SegmentTree([18, 17, 13, 19, 15, 11, 20]) assert st.range_min_query(0, 2) == 13 assert st.range_min_query(1, 3) == 13 assert st.range_min_query(3, 5) == 11 assert st.range_min_query(1, 6) == 11 assert st.range_min_query(0, 6) == 11 ``` # Implementation Details * Ensure the function handles edge cases like querying the full range or a single element correctly. * Optimize the function to leverage the Segment Tree properties for efficient querying. * Remember that the Segment Tree has already been built and potentially updated before range queries are run.","solution":"class SegmentTree: def __init__(self, data): Initialize the Segment Tree with a data array. self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Build the Segment Tree. # initialize the leaves for i in range(self.n): self.tree[self.n + i] = data[i] # initialize the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, pos, value): Update the element at index \'pos\' to \'value\'. pos += self.n self.tree[pos] = value while pos > 1: pos >>= 1 self.tree[pos] = min(self.tree[pos << 1], self.tree[pos << 1 | 1]) def range_min_query(self, left, right): Return the minimum value in the range [left, right] (inclusive). left += self.n right += self.n + 1 minimum = float(\'inf\') while left < right: if left & 1: minimum = min(minimum, self.tree[left]) left += 1 if right & 1: right -= 1 minimum = min(minimum, self.tree[right]) left >>= 1 right >>= 1 return minimum"},{"question":"# Coding Assessment Question: Scenario: You have been asked to develop a simplified inventory management system for a small retail store. The store keeps track of sales using a list of transactions, each specifying the item sold and the quantity. Your task is to implement a function that will calculate the remaining stock of various items after a series of sales transactions. # Function Signature: ```python def calculate_remaining_stock(initial_stock: dict, transactions: list) -> dict: pass ``` # Input: * `initial_stock` (dict): A dictionary where keys are item names (strings) and values are the initial quantities of each item (integers). * `transactions` (list): A list of transactions, where each transaction is represented as a tuple `(item, quantity_sold)`. # Output: * A dictionary representing the remaining stock of each item, with the item names as keys and the remaining quantities as values. # Example: ```python initial_stock = { \\"apples\\": 50, \\"bananas\\": 30, \\"oranges\\": 20 } transactions = [ (\\"apples\\", 5), (\\"bananas\\", 10), (\\"apples\\", 3), (\\"oranges\\", 5), (\\"bananas\\", 10) ] assert calculate_remaining_stock(initial_stock, transactions) == { \\"apples\\": 42, \\"bananas\\": 10, \\"oranges\\": 15 } ``` # Constraints: * `1 <= len(initial_stock) <= 100`: The number of different items will not exceed 100. * Each `quantity_sold` will be a non-negative integer. * The `quantity_sold` for any item in any single transaction will not exceed the initially available stock of the item. * Each item in `transactions` will be a key in `initial_stock`. # Performance Requirements: * Ensure your solution efficiently handles up to 100 items with multiple transactions without significant performance degradation. Implementation: Write the function `calculate_remaining_stock` that updates the initial stock quantities based on the provided transactions and returns the final remaining stock for each item.","solution":"def calculate_remaining_stock(initial_stock: dict, transactions: list) -> dict: Calculate the remaining stock after a series of transactions. Parameters: initial_stock (dict): A dictionary where keys are item names and values are the initial quantities of each item. transactions (list): A list of transactions. Each transaction is a tuple (item, quantity_sold). Returns: dict: A dictionary representing the remaining stock of each item. remaining_stock = initial_stock.copy() for item, quantity_sold in transactions: if item in remaining_stock: remaining_stock[item] -= quantity_sold return remaining_stock"},{"question":"# Range Sum Query - Immutable Context You are working on a data analysis tool that needs to quickly respond to range sum queries. The input is an array of integers, and you need to provide the sum of elements between two given indices, inclusively. To improve the speed of such queries, it\'s essential to preprocess the input array. Task Implement the `NumArray` class with an efficient range sum query mechanism. Specific Objectives 1. **Preprocessing**: Preprocess the input array to make the range sum queries efficient. 2. **Range Sum Query**: Implement a function to return the sum of elements between given indices. Class Signature ```python class NumArray: def __init__(self, nums: List[int]): pass def sumRange(self, left: int, right: int) -> int: pass ``` Input - `nums`: A list of integers of length `n` where `n` is the number of elements in the array. - `left`: An integer representing the start index of the range (0 ≤ left < n). - `right`: An integer representing the end index of the range (left ≤ right < n). Output - Returns an integer representing the sum of elements between indices `left` and `right` inclusive. Constraints - (1 leq n leq 10^4) - (-10^5 leq text{nums[i]} leq 10^5) Requirements - Your implementation should efficiently handle multiple calls to `sumRange` after the initial preprocessing. - Precompute any necessary information to optimize query performance. Example ```python # Input nums = [-2, 0, 3, -5, 2, -1] # Create the NumArray object numArray = NumArray(nums) # Output: 1, (sum of elements from index 0 to 2, i.e., -2 + 0 + 3) print(numArray.sumRange(0, 2)) # Output: -1, (sum of elements from index 2 to 5, i.e., 3 - 5 + 2 - 1) print(numArray.sumRange(2, 5)) # Output: -3, (sum of elements from index 0 to 5, i.e., -2 + 0 + 3 - 5 + 2 - 1) print(numArray.sumRange(0, 5)) ``` Hint - Consider using prefix sums to preprocess the input array. - Store cumulative sums up to each index position during initialization. Good luck!","solution":"class NumArray: def __init__(self, nums): self.prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i] def sumRange(self, left, right): return self.prefix_sums[right + 1] - self.prefix_sums[left]"},{"question":"# Data Processing Task: Implementing a Multi-threaded File Line Search Scenario You have been given the task to search for specific keywords in a large text file. To improve the performance of the search operation, you need to make use of multi-threading to divide the workload among multiple threads. # Problem Statement Write a Python function `multi_threaded_keyword_search(filename, keywords, num_threads)` that searches for a list of keywords in a large text file using multi-threading. Each thread should process a portion of the file and collect any lines containing the keywords. Requirements: 1. **Input**: - `filename`: a string representing the path to the file to be searched. - `keywords`: a list of strings, where each string is a keyword to search for in the file. - `num_threads`: an integer representing the number of threads to use for the search operation. 2. **Output**: - The function should return a list of strings, where each string is a line from the file that contains at least one of the keywords. 3. **Constraints**: - Ensure that the file reading is done efficiently to handle large files. - The implementation must leverage Python\'s `threading` or `concurrent.futures` modules to parallelize the search operation. 4. **Performance**: - Optimize the implementation to balance the workload among threads. # Example: ```python results = multi_threaded_keyword_search(\\"largefile.txt\\", [\\"error\\", \\"fail\\", \\"critical\\"], 4) for line in results: print(line) ``` This should print out all lines containing any of the keywords \\"error\\", \\"fail\\", or \\"critical\\" found in `largefile.txt` using 4 threads. # Additional Notes: - Handle edge cases such as empty files or files without the keywords. - Implement proper error handling for file I/O operations. - Ensure thread-safe operations for collecting results.","solution":"import threading def multi_threaded_keyword_search(filename, keywords, num_threads): def worker(partition, result): matches = [] for line in partition: if any(keyword in line for keyword in keywords): matches.append(line) result.extend(matches) with open(filename, \'r\') as file: lines = file.readlines() partition_size = len(lines) // num_threads partitions = [lines[i * partition_size:(i + 1) * partition_size] for i in range(num_threads)] # If there are remaining lines that didn\'t fit perfectly into partitions, add them to the last partition if len(lines) % num_threads: partitions[-1].extend(lines[num_threads * partition_size:]) threads = [] result = [] result_lock = threading.Lock() def thread_worker(partition): matches = [] worker(partition, matches) with result_lock: result.extend(matches) for partition in partitions: t = threading.Thread(target=thread_worker, args=(partition,)) threads.append(t) t.start() for t in threads: t.join() return result"},{"question":"# Coding Assessment Question You are tasked with writing a Python function that extracts and analyzes information from a log file, then formats and returns the report in a specific structure. **Function Description:** Write a function `generate_log_report(file_path: str) -> dict` that reads a log file, parses its content to extract key information, and returns a dictionary summarizing the data. Input: * `file_path` (str): The path to the log file. Output: * A dictionary containing the summary of the log. The dictionary should have the following keys: - `total_requests`: Total number of log entries. - `requests_by_status`: A dictionary where keys are status codes and values are the number of requests with that status. - `ip_addresses`: A list of unique IP addresses that made requests. Log Format: Each line in the log file represents a request and has the following format: ``` <IP_ADDRESS> - - [<DATE>] \\"<METHOD> <URL> <HTTP_VERSION>\\" <STATUS_CODE> <RESPONSE_SIZE> ``` Example: For a log file containing the following lines: ``` 192.168.1.1 - - [01/Jan/2022:10:00:00] \\"GET /index.html HTTP/1.1\\" 200 1024 192.168.1.2 - - [01/Jan/2022:10:01:00] \\"POST /submit HTTP/1.1\\" 404 512 192.168.1.1 - - [01/Jan/2022:10:02:00] \\"GET /about.html HTTP/1.1\\" 200 2048 ``` The output should be: ```python { \\"total_requests\\": 3, \\"requests_by_status\\": { \\"200\\": 2, \\"404\\": 1 }, \\"ip_addresses\\": [\\"192.168.1.1\\", \\"192.168.1.2\\"] } ``` **Constraints:** * Assume the log file is well-formed and each line follows the specified format. * You must not import any additional modules beyond the ones provided (`re`, `os`). Notes: * The function should handle large log files efficiently. * Implement appropriate error handling for file operations (e.g., file not found).","solution":"import re def generate_log_report(file_path: str) -> dict: report = { \\"total_requests\\": 0, \\"requests_by_status\\": {}, \\"ip_addresses\\": set() } log_entry_pattern = re.compile( r\'(?P<ip>[d.]+)s+-s+-s+[.+?]s+\\".+?\\"s+(?P<status>d+)s+d+\' ) try: with open(file_path, \'r\') as file: for line in file: report[\\"total_requests\\"] += 1 match = log_entry_pattern.match(line) if match: ip = match.group(\'ip\') status = match.group(\'status\') report[\\"ip_addresses\\"].add(ip) if status in report[\\"requests_by_status\\"]: report[\\"requests_by_status\\"][status] += 1 else: report[\\"requests_by_status\\"][status] = 1 except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} was not found.\\") report[\\"ip_addresses\\"] = list(report[\\"ip_addresses\\"]) return report"},{"question":"# Array Balance Checker Background In data structures and algorithms, examining the properties of arrays is a common task. Sometimes it\'s necessary to determine if an array can be divided into two non-empty subarrays with equal sums. This type of problem tests your understanding of array traversal and condition checking. Task Write a Python function `can_balance(arr: list) -> bool` that checks if an array can be split into two non-empty parts such that the sum of the elements in the first part is equal to the sum of the elements in the second part. The split index can be anywhere in the array as long as both resulting subarrays are non-empty. Input * One parameter: * `arr` (list of integers): The array to be checked. Output * A boolean: * `True` if the array can be split into two parts with equal sums. * `False` otherwise. Constraints * The input array will have a length of at least 2. Examples ```python >>> can_balance([1, 1, 1, 2, 1]) True >>> can_balance([2, 1, 1, 2, 1]) False >>> can_balance([10, 10]) True >>> can_balance([10, 10, 10]) False >>> can_balance([1, 2, 3, 4, 5, 5]) True ``` Use this function prototype: ```python def can_balance(arr: list) -> bool: # Your code here ``` Notes - You can assume that all element values in the array are integers. - The function should efficiently determine if the array can be split as specified.","solution":"def can_balance(arr: list) -> bool: Determines if the array can be split into two non-empty parts with equal sums. Args: arr (list): The array to be checked. Returns: bool: True if the array can be split into two parts with equal sums, False otherwise. total_sum = sum(arr) left_sum = 0 # Traverse the array and keep adding to the left_sum for i in range(len(arr) - 1): # -1 because we need both parts to be non-empty. left_sum += arr[i] right_sum = total_sum - left_sum if left_sum == right_sum: return True return False"},{"question":"# Question You are tasked with creating a custom class, `NumberSeries`, that encapsulates a series of numbers and provides functionality to add numbers to the series, find the median of the series, and reset the series back to empty. The class must maintain a list of numbers and ensure efficient computation of the median. # Requirements * **Class Name**: `NumberSeries` * **Methods**: - `__init__(self) -> None`: Initializes an empty series. - `add_number(self, number: int | float) -> None`: Adds a number to the series. - `get_median(self) -> int | float | None`: Returns the median of the series. If the series is empty, return `None`. - `reset(self) -> None`: Resets the series to an empty state. # Constraints 1. The added numbers can be either integers or floats. 2. The median is defined as the middle number in a sorted, odd-length series, or the average of the two middle numbers in an even-length series. 3. The `add_number` method should allow for adding numbers in any order and maintain the series. 4. The `get_median` method should efficiently compute the median each time it is called. # Example ```python series = NumberSeries() series.add_number(3) series.add_number(1) print(series.get_median()) # Output should be 2.0 series.add_number(4) print(series.get_median()) # Output should be 3.0 series.reset() print(series.get_median()) # Output should be None ``` # Implementation Guidelines * Use appropriate data structures to maintain and update the series. * Ensure that adding a number and finding the median are efficient operations. * Perform necessary validations and error handling within each method.","solution":"import bisect class NumberSeries: def __init__(self): self.numbers = [] def add_number(self, number): bisect.insort(self.numbers, number) def get_median(self): n = len(self.numbers) if n == 0: return None elif n % 2 == 1: return self.numbers[n // 2] else: mid1, mid2 = n // 2 - 1, n // 2 return (self.numbers[mid1] + self.numbers[mid2]) / 2 def reset(self): self.numbers.clear()"},{"question":"# Context: You are developing a system that processes large datasets of integers. A common operation is to determine if a given number is a power of two. For optimization purposes, you want to incorporate a function that efficiently checks whether a number is a power of two using bitwise operations. # Problem Statement: Write a function `is_power_of_two(number: int) -> bool` that takes a non-negative integer as input and returns `True` if the number is a power of two, and `False` otherwise. The function should validate the input and raise a `ValueError` if the input is not a non-negative integer. Input and Output Formats: * **Input**: A single argument `number` which is a non-negative integer. * **Output**: A boolean value indicating whether the input is a power of two. Constraints and Limitations: * The input is guaranteed to be a non-negative integer. * You should consider edge cases and validate the input. Example: ```python >>> is_power_of_two(0) False >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(16) True >>> is_power_of_two(-4) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> is_power_of_two(\'string\') Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> is_power_of_two(4.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer ``` # Performance Requirements: * The solution should ideally run in O(1) time complexity for bitwise operations.","solution":"def is_power_of_two(number: int) -> bool: Checks if a given non-negative integer is a power of two. Args: - number (int): The number to check. Returns: - bool: True if the number is a power of two, False otherwise. Raises: - ValueError: If the input is not a non-negative integer. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer\\") # A number is a power of two if it is greater than 0 # and its binary representation has only one \'1\' bit return number != 0 and (number & (number - 1)) == 0"},{"question":"# Problem Statement **Context:** You are given a string containing a mix of digits, letters, and other characters. Your task is to identify and sum up all the \\"hidden\\" integers within the string. An integer is defined as any consecutive sequence of numerical digits within the string. The final result should be the sum of all these integers. **Definition:** - A hidden integer is any consecutive sequence of digits within the string. For instance, the string \\"abc123xyz45\\" contains two hidden integers: 123 and 45. - Non-digit characters can separate hidden integers, but should be ignored for the sum calculation. For example: - For the string `\\"abc123xyz\\"`, the hidden integer sum is `123`. - For the string `\\"a1b2c345\\"`, the hidden integer sum is `1 + 2 + 345 = 348`. - For the string `\\"noDigits\\"`, the hidden integer sum is `0`. **Requirements:** Implement the following function: ```python def sum_hidden_integers(s: str) -> int: Calculates the sum of hidden integers within the given string. Args: s (str): The input string potentially containing hidden integers. Returns: int: The sum of all hidden integers found within the string. pass ``` **Input:** - `s`: A string containing a mix of digits, letters, and other characters **Output:** - An integer representing the sum of all hidden integers found within the string **Examples:** ```python assert sum_hidden_integers(\\"abc123xyz\\") == 123 assert sum_hidden_integers(\\"a1b2c345\\") == 348 assert sum_hidden_integers(\\"noDigits\\") == 0 assert sum_hidden_integers(\\"12abc34def56\\") == 102 assert sum_hidden_integers(\\"0xx0yy0\\") == 0 assert sum_hidden_integers(\\"3cats4dogs\\") == 7 ``` **Constraints:** - The string length should be manageable to avoid performance issues (consider practical limits such as length <= 10^5). - Only integer values are considered for the sum; floating-point numbers separated by non-digit characters will be treated as separate integers.","solution":"import re def sum_hidden_integers(s: str) -> int: Calculates the sum of hidden integers within the given string. Args: s (str): The input string potentially containing hidden integers. Returns: int: The sum of all hidden integers found within the string. # Find all sequences of digits using regular expression numbers = re.findall(r\'d+\', s) # Convert all found sequences to integers and sum them up return sum(int(num) for num in numbers)"},{"question":"You are given an integer array `arr` of length `n` and an integer `d`. Your task is to compute the maximum possible sum of a contiguous subarray that contains exactly `d` elements. # Function Signature ```python def max_sum_subarray(arr: List[int], d: int) -> int: arr : List[int] : The input array of integers. d : int : The specific number of elements in the subarray. Returns the maximum sum of a contiguous subarray containing exactly d elements. ``` # Input * `arr` (List[int]): A list of integers. * `d` (int): The number of contiguous subarray elements to consider for the sum. You can assume `1 <= d <= len(arr)`. # Output * Returns the maximum possible sum of a contiguous subarray of length `d`. # Constraints 1. The function must handle the calculation efficiently within a linear time complexity, i.e., O(n). 2. You should not use any third-party libraries. # Example ```python def test_max_sum_subarray(): assert max_sum_subarray([1, 2, 3, 4, 5], 2) == 9 assert max_sum_subarray([10, -5, 20, -10, 30], 3) == 40 assert max_sum_subarray([-1, -2, -3, -4], 1) == -1 assert max_sum_subarray([100, 200, 300, 400], 4) == 1000 test_max_sum_subarray() ``` # Explanation 1. The first example shows the array `[1, 2, 3, 4, 5]` and asks for the maximum sum of a contiguous subarray containing 2 elements. The highest sum comes from the subarray `[4, 5]`, which sums to `9`. 2. In the second example, the array `[10, -5, 20, -10, 30]` with `d = 3` has the maximum sum from the subarray `[20, -10, 30]`, which totals `40`. 3. For the third example, the array `[-1, -2, -3, -4]` with `d = 1` has the subarray with the maximum sum as `[-1]`, resulting in `-1`. 4. The fourth example, the array `[100, 200, 300, 400]` with `d = 4` has the only subarray of length 4 with the sum `1000`. You can assume that input will always be valid and that `1 <= d <= len(arr)`.","solution":"from typing import List def max_sum_subarray(arr: List[int], d: int) -> int: Returns the maximum sum of a contiguous subarray containing exactly d elements. # Calculate initial sum of the first subarray of length d max_sum = sum(arr[:d]) current_sum = max_sum # Use sliding window to find the maximum sum subarray of length d for i in range(d, len(arr)): current_sum += arr[i] - arr[i - d] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"# Question Context A logistics company wants to optimize the locations of warehouses to minimize the delivery time to various destinations. The company needs a function to calculate the minimum distance from a warehouse to a set of delivery points considering possible diagonals. Task Write a function `min_distance_to_points` that computes the minimum distance from a starting point to any point in a given list of delivery points. The movement is allowed vertically, horizontally, and diagonally. Function Signature ```python def min_distance_to_points(start: Tuple[int, int], points: List[Tuple[int, int]]) -> float: ``` Input * `start` (Tuple[int, int]): The starting coordinates (x, y) of the warehouse. Coordinates are non-negative integers. * `points` (List[Tuple[int, int]]): A list of tuples representing the coordinates of delivery points. Each coordinate is a non-negative integer. Output * (float): The minimum distance to the nearest delivery point with high precision (e.g., 5.656854249492381). Example ```python >>> min_distance_to_points((0, 0), [(1, 1), (3, 4), (6, 8)]) 1.4142135623730951 >>> min_distance_to_points((2, 2), [(5, 5), (1, 2), (2, 10)]) 1.0 >>> min_distance_to_points((3, 3), [(3, 3), (6, 7), (5, 5)]) 0.0 ``` Constraints * Ensured that the `points` list is non-empty. * Both `start` coordinates and `points` are non-negative integers. * Assume valid input formats for coordinates. Edge Cases * When the starting point is the same as a delivery point, the distance should be 0. * If there is only one delivery point, the function should return the distance to that point. * Include scenarios where both the start and one of the points lie on the same diagonal, vertical, or horizontal line.","solution":"from typing import List, Tuple import math def min_distance_to_points(start: Tuple[int, int], points: List[Tuple[int, int]]) -> float: Computes the minimum distance from a starting point to any point in a given list of delivery points. Movement is allowed vertically, horizontally, and diagonally. :param start: The starting coordinates (x, y) of the warehouse. Coordinates are non-negative integers. :param points: A list of tuples representing the coordinates of delivery points. Each coordinate is a non-negative integer. :return: The minimum distance to the nearest delivery point. min_distance = float(\'inf\') for point in points: dx = abs(start[0] - point[0]) dy = abs(start[1] - point[1]) distance = math.sqrt(dx**2 + dy**2) if distance < min_distance: min_distance = distance return min_distance"},{"question":"# Problem Description You are required to implement a function that detects if there exists a cycle in an undirected graph. A cycle in an undirected graph means there is a path that starts and ends at the same vertex without repeating any edge. # Task * Implement a function `has_cycle(edges: list[tuple[int, int]], num_nodes: int) -> bool` that determines if a cycle exists in an undirected graph. # Input - `edges` - A list of tuples `[(u1, v1), (u2, v2), ...]`, where each tuple represents an undirected edge between nodes `u` and `v`. - `num_nodes` - An integer representing the number of nodes in the graph (nodes are labeled from `0` to `num_nodes - 1`). # Output - A boolean value: * `True` if the graph contains a cycle. * `False` otherwise. # Constraints - The length of `edges` will be between 0 and 2000. - The number of nodes `num_nodes` will be between 1 and 1000. # Example ```python def has_cycle(edges: list[tuple[int, int]], num_nodes: int) -> bool: # Your code here # Example Usage edges = [(0, 1), (1, 2), (2, 0), (3, 4)] num_nodes = 5 print(has_cycle(edges, num_nodes)) # Example output: True edges = [(0, 1), (1, 2), (2, 3), (3, 4)] num_nodes = 5 print(has_cycle(edges, num_nodes)) # Example output: False ``` # Explanation For example 1: - The graph has 5 nodes and edges forming a cycle: 0-1-2-0. Therefore the function should return `True`. For example 2: - The graph has 5 nodes connected in a single line: 0-1-2-3-4. There are no cycles in this graph, so the function should return `False`. Ensure your function properly handles edge cases such as disconnected graphs, graphs with no edges, and graphs where every node has a self-loop. Use efficient algorithms such as Depth First Search (DFS) to detect cycles with optimal performance.","solution":"def has_cycle(edges: list[tuple[int, int]], num_nodes: int) -> bool: from collections import defaultdict def dfs(node, parent): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, node): return True elif neighbor != parent: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * num_nodes for v in range(num_nodes): if not visited[v]: if dfs(v, -1): return True return False"},{"question":"# Mirror Tree Transformation You are asked to transform a given binary tree into its mirror image. In a mirror image of a binary tree, the left and right children of each node are swapped. Your task is to implement the function to accomplish this transformation. Function Signature ```python def mirror_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: pass ``` Input * `root` is the root node of a binary tree. Each node is represented by a `TreeNode` object with the following structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` * The binary tree can have up to (10^4) nodes, and the values in the nodes can be any integers. Output * Return the root node of the binary tree, which is now transformed into its mirror image. Constraints * You must handle trees of varying sizes, including trees with only one node or an empty tree (`None`). * The function should handle the transformation within acceptable time and space limits for large trees. Performance Requirements * There is no strict time complexity requirement, but aim for an efficient traversal approach. * The implementation should use O(n) space complexity, where n is the number of nodes in the binary tree, mainly due to the recursion stack. Example Consider the following binary tree: ``` 1 / 2 3 / / 4 5 6 7 ``` Calling `mirror_tree(root)` should transform it into: ``` 1 / 3 2 / / 7 6 5 4 ``` If the tree is represented as: ```python root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) ``` Outputting the transformed tree\'s root node should reveal the mirrored structure.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively mirror the left and right subtrees mirror_tree(root.left) mirror_tree(root.right) return root"},{"question":"# Question You are assigned to enhance the functionality of a basic calculator class with additional features such as handling mathematical expressions involving parentheses and implementing variable assignments. The calculator should support addition, subtraction, multiplication, and division operations, along with the ability to store and refer to variables within expressions. # Requirements Modify the provided `Calculator` class by: 1. Adding a method `evaluate_expression` to evaluate expressions that may include variables and parentheses. 2. Adding a method `assign_variable` to assign values to variables. 3. Ensuring that variable assignments can be used in subsequent expressions. # Function Signature ```python class Calculator: def __init__(self): self.variables = {} def evaluate_expression(self, expression: str) -> float: Evaluate a mathematical expression that may contain variables and parentheses. Args: expression: A string representing the mathematical expression. Returns: A float value representing the evaluated result. Example: >>> calc = Calculator() >>> calc.assign_variable(\'x\', 5) >>> calc.evaluate_expression(\'(2 + 3) * x\') # doctest: +ELLIPSIS 25.0 >>> calc.evaluate_expression(\'x / 2 + 1\') # doctest: +ELLIPSIS 3.5 >>> calc.evaluate_expression(\'y * 3\') # doctest: +ELLIPSIS Traceback (most recent call last): ... NameError: Variable \'y\' is not defined pass def assign_variable(self, name: str, value: float): Assign a value to a variable. Args: name: A string representing the variable name. value: A float value to be assigned to the variable. Example: >>> calc = Calculator() >>> calc.assign_variable(\'x\', 5) >>> calc.variables[\'x\'] 5.0 self.variables[name] = value ``` # Constraints 1. The `evaluate_expression` method should handle: - Basic arithmetic operations: `+`, `-`, `*`, and `/`. - Parentheses for changing the order of operations. - Usage of previously assigned variables. 2. Variables must be assigned before they are used in any expression. 3. Expressions will be valid and properly formatted. 4. Division by zero should raise an appropriate error. 5. Variables names will consist of only alphabetic characters. # Input * `expression`: A string containing a mathematical expression. * `name`: A string representing a variable name. * `value`: A float value to be assigned to a variable. # Output * A float value representing the evaluated result of the expression. # Assumptions 1. The input expressions are syntactically correct. 2. Variable names are case-sensitive. # Example Scenarios The implementation will be tested to: 1. Evaluate complex expressions involving different arithmetic operations and parentheses. 2. Handle division by zero errors gracefully. 3. Correctly use and identify previously assigned variables.","solution":"class Calculator: def __init__(self): self.variables = {} def evaluate_expression(self, expression: str) -> float: Evaluate a mathematical expression that may contain variables and parentheses. Args: expression: A string representing the mathematical expression. Returns: A float value representing the evaluated result. # replace variables in the expression for var in self.variables: expression = expression.replace(var, str(self.variables[var])) try: result = eval(expression) return result except ZeroDivisionError: raise ValueError(\\"Division by zero error\\") except NameError as e: raise NameError(f\\"Variable {str(e).split()[-1]} is not defined\\") def assign_variable(self, name: str, value: float): Assign a value to a variable. Args: name: A string representing the variable name. value: A float value to be assigned to the variable. self.variables[name] = value"},{"question":"# Question You are developing a feature for a text editor that transforms text based on specific rules. Implement a function that takes a string and a set of transformation commands, then applies those transformations in the correct order to produce the final modified string. Function Signature ```python def transform_text(text: str, operations: List[str]) -> str: ... ``` Input - **text** (str): the initial string to be transformed. - **operations** (List[str]): a list of transformation commands. Each command is a string in one of the following formats: - `\\"upper\\"`: Convert the entire string to uppercase. - `\\"lower\\"`: Convert the entire string to lowercase. - `\\"capitalize\\"`: Capitalize the first letter of each word in the string. - `\\"reverse\\"`: Reverse the entire string. - `\\"replace <old> <new>\\"`: Replace all occurrences of substring `<old>` with substring `<new>`. Output - (str): the transformed string after applying all operations in the given order. Constraints - The length of the text will be at most 1000 characters. - The number of operations will be at most 100. - The operations can be a mix of any allowed commands. - The `replace` command\'s `<old>` and `<new>` substrings will be valid and non-empty. Examples ```python >>> transform_text(\\"hello world\\", [\\"upper\\"]) \'HELLO WORLD\' >>> transform_text(\\"HELLO WORLD\\", [\\"lower\\", \\"capitalize\\"]) \'Hello World\' >>> transform_text(\\"abc def ghi\\", [\\"replace def xyz\\", \\"reverse\\"]) \'ihg zyx cba\' >>> transform_text(\\"tech assessments\\", [\\"replace tech code\\", \\"uppercase\\"]) \'CODE ASSESSMENTS\' ``` By following the above guidelines and format, this question explores text manipulation functions and string transformations, aligning well with the logical and computational thought process similar to the bitwise shift operations seen in the provided sample question.","solution":"from typing import List def transform_text(text: str, operations: List[str]) -> str: for operation in operations: if operation == \\"upper\\": text = text.upper() elif operation == \\"lower\\": text = text.lower() elif operation == \\"capitalize\\": text = text.title() elif operation == \\"reverse\\": text = text[::-1] elif operation.startswith(\\"replace \\"): parts = operation.split(\\" \\", 2) old = parts[1] new = parts[2] text = text.replace(old, new) return text"},{"question":"# Question You are tasked with implementing a spell checker feature for a text editor. This spell checker should: 1. Use a given dictionary of valid words. 2. Identify and correct possible misspellings in a given text. 3. Suggest the closest valid word for each misspelled word based on the Levenshtein distance. 4. Include a method to update the dictionary with new words. # Function Requirements spell_check * **Input**: - `input_text`: A string containing a sentence. - `dictionary`: A list of strings representing the valid words. * **Output**: A corrected string where the misspelled words are replaced with the closest valid words from the dictionary. update_dictionary * **Input**: - `word`: A string to be added to the dictionary. - `dictionary`: A list of strings representing the current valid words. * **Output**: An updated list of strings with the new word included. # Constraints * Assume the length of `input_text` will not exceed `10^4` characters. * The number of words in the `dictionary` will not exceed `10^4`. * Each word in the `dictionary` and `input_text` will be lowercase and contain only alphabetic characters. # Example ```python input_text = \'thes quikc brownn foxx\' dictionary = [\'the\', \'quick\', \'brown\', \'fox\'] corrected_text = spell_check(input_text, dictionary) print(corrected_text) # Output should be \'the quick brown fox\' new_word = \'jumps\' updated_dictionary = update_dictionary(new_word, dictionary) print(updated_dictionary) # Output should be [\'the\', \'quick\', \'brown\', \'fox\', \'jumps\'] ``` # Notes: * Use Levenshtein distance to determine the closest valid word from the dictionary for misspelled words. * Ensure that both functions handle and report errors gracefully, such as invalid input data. * The spell checker should maintain the original colors and formatting of the text while only correcting the spelling errors.","solution":"def levenshtein_distance(word1, word2): Computes the Levenshtein distance between two words. len1, len2 = len(word1), len(word2) if len1 < len2: return levenshtein_distance(word2, word1) # len1 >= len2 previous_row = range(len2 + 1) for i, c1 in enumerate(word1): current_row = [i + 1] for j, c2 in enumerate(word2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def find_closest_word(word, dictionary): Finds the closest word in the dictionary to the given word based on Levenshtein distance. closest_word = None min_distance = float(\'inf\') for dict_word in dictionary: distance = levenshtein_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_word = dict_word return closest_word def spell_check(input_text, dictionary): Checks the spelling of words in the input_text and corrects misspelled words. words = input_text.split() corrected_words = [find_closest_word(word, dictionary) for word in words] corrected_text = \' \'.join(corrected_words) return corrected_text def update_dictionary(word, dictionary): Adds a new word to the dictionary if it does not already exist. if word not in dictionary: dictionary.append(word) return dictionary"},{"question":"# Binary Search Tree Removal Operations You are given a basic implementation of a Binary Search Tree (BST). The BST supports common operations such as insertion and traversal. You are required to enhance the functionality of the BST by implementing the removal operation. The removal operation should handle the following scenarios: 1. **Node with No Children (Leaf Node)**: Directly remove the node. 2. **Node with One Child**: Bypass the node and link its parent to its child. 3. **Node with Two Children**: Replace the node\'s value with its in-order successor (smallest value in the right subtree) and remove the in-order successor. # Function Signature ```python def remove(root: Node, key: int) -> Node: pass ``` # Input/Output * `remove(root: Node, key: int) -> Node`: Removes the node with the specified `key` from the BST and returns the root of the modified BST. If the `key` is not found, returns the original BST. # Constraints * Nodes contain unique integer values. * You may assume that the input `root` is a valid BST. * The BST operations must maintain their O(log n) average time complexity. # Examples ```python # Example BST creation root = None root = insert(root, 8) root = insert(root, 3) root = insert(root, 10) root = insert(root, 1) root = insert(root, 6) root = insert(root, 14) root = insert(root, 4) root = insert(root, 7) root = insert(root, 13) # Removal operations root = remove(root, 1) assert inorder_traversal(root) == [3, 4, 6, 7, 8, 10, 13, 14] root = remove(root, 3) assert inorder_traversal(root) == [4, 6, 7, 8, 10, 13, 14] root = remove(root, 10) assert inorder_traversal(root) == [4, 6, 7, 8, 13, 14] ``` # Implementation Notes 1. **Handling Leaf Nodes**: Simply set the appropriate child reference of the node\'s parent to `None`. 2. **Handling Single Child Nodes**: Update the appropriate child reference of the node\'s parent to the child of the node being removed. 3. **Handling Two Children Nodes**: * Find the in-order successor (leftmost child of the node\'s right subtree). * Replace the node\'s value with the in-order successor\'s value. * Recursively remove the in-order successor node. # Helper Functions You might find it useful to define some helper functions to keep your implementation clean and modular. * `find_minimum(root: Node) -> Node`: Finds and returns the node with the minimum value in the BST. * `inorder_traversal(root: Node) -> List[int]`: Returns a list of values representing the in-order traversal of the BST. # Additional Example ```python # Example BST creation root = None root = insert(root, 20) root = insert(root, 10) root = insert(root, 30) root = insert(root, 5) root = insert(root, 15) root = insert(root, 25) root = insert(root, 35) # Removal operations root = remove(root, 20) # Node with two children assert inorder_traversal(root) == [5, 10, 15, 25, 30, 35] root = remove(root, 10) # Node with one child assert inorder_traversal(root) == [5, 15, 25, 30, 35] ``` Ensure your implementation maintains the properties of the BST and handles all edge cases appropriately.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return Node(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def find_minimum(root): while root.left is not None: root = root.left return root def remove(root, key): if root is None: return root if key < root.val: root.left = remove(root.left, key) elif key > root.val: root.right = remove(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = find_minimum(root.right) root.val = temp.val root.right = remove(root.right, temp.val) return root"},{"question":"# Problem Statement Implement a function that takes in a string representing a mathematical expression containing integers, the operators \'+\', \'-\', \'*\', and \'/\', and parentheses \'(\', \')\'. The function should correctly evaluate the expression and return the result as an integer. Note: Division should truncate toward zero, and it is guaranteed that the expression is valid and non-empty. **Input Format**: - A string `expression` representing the mathematical expression. **Output Format**: - Return an integer which is the result of the evaluated expression. **Constraints**: 1. The length of `expression` is at least 1 and at most 10^4. 2. `expression` contains only non-negative integers, operators \'+\', \'-\', \'*\', \'/\', and parentheses \'(\' and \')\'. 3. The expression is guaranteed to be valid based on the problem\'s operators and parentheses. Write your function: ```python def evaluate_expression(expression: str) -> int: pass ``` **Example**: ```python >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\"(2+6* 3+5- (3*14/7+2)*5)+3\\") -12 ```","solution":"def evaluate_expression(expression: str) -> int: def operate(operand1, operand2, operator): if operator == \'+\': return operand1 + operand2 elif operator == \'-\': return operand1 - operand2 elif operator == \'*\': return operand1 * operand2 elif operator == \'/\': return int(operand1 / operand2) # truncate towards zero def precedence(operator): if operator in (\'+\', \'-\'): return 1 elif operator in (\'*\', \'/\'): return 2 return 0 def apply_operation(operators, operands): operator = operators.pop() right_operand = operands.pop() left_operand = operands.pop() operands.append(operate(left_operand, right_operand, operator)) operators = [] operands = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operation(operators, operands) operators.pop() # remove \'(\' else: # operator while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operation(operators, operands) operators.append(expression[i]) i += 1 while operators: apply_operation(operators, operands) return operands[-1]"},{"question":"# Subarray Sum Equals K Assessment Question You are working on an analytics tool that processes large datasets to identify specific patterns and sums within arrays of integers. One of the functionalities required is to find the number of continuous subarrays whose sum equals a given integer `k`. Task: Write a function `subarray_sum_equals_k(nums: List[int], k: int) -> int` that takes two arguments as input: - `nums` (List[int]): A list of integers. - `k` (int): The target sum value. The function should return an integer representing the number of continuous subarrays that sum up to `k`. Input: - `nums` (List[int]): An array of integers where the length is at most 10,000 and each element lies between -10,000 and 10,000. - `k` (int): The target sum value. Output: - Return an integer representing the number of continuous subarrays whose sum is equal to `k`. Examples: ```python >>> subarray_sum_equals_k([1,1,1], 2) 2 >>> subarray_sum_equals_k([1,2,3], 3) 2 >>> subarray_sum_equals_k([3,4,7,2,-3,1,4,2], 7) 4 >>> subarray_sum_equals_k([], 0) 0 >>> subarray_sum_equals_k([0,0,0,0,0], 0) 15 ``` Constraints: - The function should efficiently handle both positive and negative integers within the list. - Consider edge cases such as empty arrays and arrays where no subarray sums to `k`.","solution":"from typing import List def subarray_sum_equals_k(nums: List[int], k: int) -> int: count = 0 cumulative_sum = 0 sum_dict = {0: 1} for num in nums: cumulative_sum += num if (cumulative_sum - k) in sum_dict: count += sum_dict[cumulative_sum - k] sum_dict[cumulative_sum] = sum_dict.get(cumulative_sum, 0) + 1 return count"},{"question":"**Next Greater Element with Same Digits** Your task is to write a function that takes a positive integer and returns the next greater number that can be formed using the same digits. If no such greater number exists, the function should return -1. # Function Signature ```python def next_greater_number(n: int) -> int: pass ``` # Input - An integer `n` where (1 leq n leq 10^9). # Output - The next greater integer that can be formed using the same digits, or `-1` if no such number exists. # Constraints - You may assume that the digits of the integer are unique and no leading zeros will be present. - The integer must remain within the bounds of a positive 32-bit signed integer. # Example - Input: `1234` - Output: `1243` - Input: `4321` - Output: `-1` # Performance Requirements - The solution should ideally run in O(n) time, where n is the number of digits in the given number. # Scenario/Context You are asked to implement a solution to a classic problem in combinatorial mathematics often encountered in algorithmic contests and coding interviews. The function you write will determine the next permutation in lexicographic order without producing unnecessary permutations, providing an efficient path to the solution.","solution":"def next_greater_number(n: int) -> int: digits = list(str(n)) length = len(digits) i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: return -1 j = length - 1 while digits[j] <= digits[i]: j -= 1 digits[i], digits[j] = digits[j], digits[i] digits = digits[:i + 1] + digits[i + 1:][::-1] result = int(\'\'.join(digits)) return result if result < 2**31 else -1"},{"question":"# Problem Description You are required to implement a function that determines whether there exists a subset within a given list of integers that sums to zero. # Input Format - The first line contains an integer `n`, the number of integers in the list. - The second line contains `n` space-separated integers representing the elements of the list. # Output Format - Print \\"YES\\" if there exists a subset that sums to zero, otherwise print \\"NO\\". # Constraints - 1 ≤ n ≤ 100 - The elements of the list can be any integer within the range of -10^5 to 10^5. # Performance Requirements - Your solution should preferably have a time complexity of O(n * log(n)) or better on average. # Example **Input** ``` 5 -3 1 2 -1 6 ``` **Output** ``` YES ``` **Input** ``` 3 1 2 3 ``` **Output** ``` NO ``` Function Signature ```python def subset_sum_zero_exists(nums: List[int]) -> str: # your code here pass ``` # Implementation notes - Consider using a set to track the sums of subsets as you iterate through the list. - Handle potential edge cases such as lists with all positive or all negative numbers, or lists containing zero.","solution":"def subset_sum_zero_exists(n, nums): Determines if there exists a subset in the list \'nums\' that sums to zero. Parameters: - n (int): The number of integers in the list. - nums (List[int]): The list of integers. Returns: - str: \\"YES\\" if there exists a subset that sums to zero, otherwise \\"NO\\". # A set to store the cumulative sums cumulative_sums = set() # Initial sum current_sum = 0 for num in nums: current_sum += num # Subset with sum zero if we see the current_sum again # (current_sum - some_previous_sum = 0 => current_sum = some_previous_sum) if current_sum == 0 or current_sum in cumulative_sums: return \\"YES\\" cumulative_sums.add(current_sum) return \\"NO\\""},{"question":"# Problem Statement You are given a binary tree where each node contains a positive integer value. Your task is to implement a function that finds the sum of the values of all leaf nodes in the binary tree where a leaf node is defined as a node with no children. # Objectives 1. Traverse the binary tree and identify the leaf nodes. 2. Calculate the sum of the values of these leaf nodes. 3. Ensure the solution efficiently handles large trees with up to (10^4) nodes. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaf_nodes(root: TreeNode) -> int: pass ``` # Input * `root` (TreeNode): The root node of a binary tree where each node contains a positive integer. # Output * Returns an integer representing the sum of all leaf nodes\' values. # Constraints * The number of nodes in the tree will be in the range ([1, 10^4]). * All node values are positive integers. # Example ```python # Example 1 # Input: # 3 # / # 5 1 # / # 6 2 9 # / # 7 4 # # Output: 26 # Explanation: The leaf nodes are [6, 7, 4, 9], and their sum is 6 + 7 + 4 + 9 = 26. root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) root.right.right = TreeNode(9) print(sum_of_leaf_nodes(root)) # Output: 26 # Example 2 # Input: # 2 # # Output: 2 # Explanation: The leaf node is [2], and its sum is 2. root2 = TreeNode(2) print(sum_of_leaf_nodes(root2)) # Output: 2 ``` # Notes * The problem requires you to traverse the tree and handle all possible binary tree structures efficiently. * Consider various tree shapes, including skewed trees, balanced trees, and trees with multiple leaf nodes at varying depths.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaf_nodes(root: TreeNode) -> int: Returns the sum of the values of all the leaf nodes in the given binary tree. if root is None: return 0 # Helper function to traverse the tree and sum the values of leaf nodes def dfs(node): if node is None: return 0 # If it is a leaf node if node.left is None and node.right is None: return node.val # Recurse on child nodes return dfs(node.left) + dfs(node.right) return dfs(root)"},{"question":"# Scenario: You are a software developer working on a task scheduling application that needs to prioritize tasks based on their urgency. Each task is represented with an integer indicating its urgency level, with higher numbers indicating more urgent tasks. Your task is to find the median urgency level of a given list of tasks. # Task: Implement a function `find_median_urgency(tasks: list) -> float` that determines the median urgency level from the given list of tasks. If the number of tasks is odd, return the middle element. If the number of tasks is even, return the average of the two middle elements. # Function Signature: ```python def find_median_urgency(tasks: list) -> float: pass ``` # Input: * `tasks`: A list of integers representing the urgency levels of the tasks. # Output: * Return the median urgency level as a float. # Example: ```python >>> find_median_urgency([50, 20, 10, 60, 30]) 30.0 >>> find_median_urgency([50, 20, 10, 60]) 35.0 >>> find_median_urgency([5, 2, 9, 3, 8, 4]) 4.5 ``` # Constraints: * Expect to handle lists with a length up to 1,000 elements efficiently. # Notes: * Implement and test your `find_median_urgency` function thoroughly. * Sorting the list is acceptable for finding the median given the constraint on the list size.","solution":"def find_median_urgency(tasks: list) -> float: Determines the median urgency level from the given list of tasks. If the number of tasks is odd, returns the middle element. If the number of tasks is even, returns the average of the two middle elements. tasks.sort() n = len(tasks) if n % 2 == 0: # If even, the median is the average of the two middle elements median = (tasks[n//2 - 1] + tasks[n//2]) / 2.0 else: # If odd, the median is the middle element median = tasks[n//2] return median"},{"question":"# Problem Statement Context: You are tasked with implementing a coding challenge designed to explore recursive functions and understand the mechanics of binary search algorithms. You will create two functions: one for generating the Fibonacci series using recursion and another to apply binary search technique on a given sorted list. Instructions: 1. **Implement the `fibonacci_recursive` function**: - This function should recursively compute the nth Fibonacci number. - Input: A non-negative integer `n`. - Output: The nth Fibonacci number. 2. **Implement the `binary_search` function**: - This function should perform a binary search on a sorted list to find the index of a target value. - Inputs: - `arr`: A list of sorted integers. - `target`: An integer value to search for within the list. - Output: The index of `target` in `arr` if it exists, otherwise -1. Specifications: - **Function Signatures**: ```python def fibonacci_recursive(n: int) -> int: ... def binary_search(arr: list, target: int) -> int: ... ``` - **Input/Output Examples**: ```python >>> fibonacci_recursive(5) 5 >>> fibonacci_recursive(10) 55 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 4 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 >>> binary_search([], 1) -1 ``` - **Constraints**: - `n` must be a non-negative integer. - For `binary_search`, `arr` must be a list of integers and `target` must be an integer. - Ensure the binary search implementation has a time complexity of O(log n). - **Performance Requirements**: - The recursive function should handle small values of `n` efficiently but may become slow for large `n` due to the nature of recursion. - The binary search function should maintain efficient search performance by dividing the search space in half as expected in a binary search algorithm.","solution":"def fibonacci_recursive(n): Returns the nth Fibonacci number using recursion. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2) def binary_search(arr, target): Perform a binary search on a sorted list to find the target value. Returns the index of the target value if found, otherwise returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement Create a library management system that can efficiently handle operations to manage books within a library. Specifically, you need to implement a system that supports the following operations: 1. **Add a Book:** Add a new book to the collection. 2. **Borrow a Book:** Borrow a book from the library, ensuring it is available. 3. **Return a Book:** Return a borrowed book back to the library. 4. **Check Availability:** Check if a book is available to borrow. # Input You will interact with the library management system through several operations: 1. `add_book(book_id)`: Add the book with the unique identifier `book_id` to the collection. 2. `borrow_book(book_id)`: Borrow the book with the unique identifier `book_id` if it is available. 3. `return_book(book_id)`: Return the book with the unique identifier `book_id` back to the library. 4. `is_available(book_id)`: Check if the book with the unique identifier `book_id` is available. # Output For each `is_available` operation, return `True` if the book is available to borrow, otherwise return `False`. # Constraints * The number of books ID will be between 1 and 100000. * The book IDs are unique and integers. * The number of operations will not exceed 100000. * Operations will be given in no particular order. # Example ```python library = LibrarySystem() library.add_book(1) library.add_book(2) print(library.is_available(1)) # Should return True library.borrow_book(1) print(library.is_available(1)) # Should return False library.return_book(1) print(library.is_available(1)) # Should return True ``` # Requirements Implement the `LibrarySystem` class with the following method stubs: ```python class LibrarySystem: def __init__(self): Initializes the Library System. def add_book(self, book_id): Adds a new book to the collection. def borrow_book(self, book_id): Borrows a book from the library if it is available. def return_book(self, book_id): Returns a borrowed book back to the library. def is_available(self, book_id): Checks if a book is available to borrow. ``` You need to implement the above class such that it correctly supports the `add_book`, `borrow_book`, `return_book`, and `is_available` operations efficiently.","solution":"class LibrarySystem: def __init__(self): Initializes the Library System. self.books = set() self.borrowed_books = set() def add_book(self, book_id): Adds a new book to the collection. self.books.add(book_id) self.borrowed_books.discard(book_id) def borrow_book(self, book_id): Borrows a book from the library if it is available. if book_id in self.books: self.books.remove(book_id) self.borrowed_books.add(book_id) def return_book(self, book_id): Returns a borrowed book back to the library. if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) self.books.add(book_id) def is_available(self, book_id): Checks if a book is available to borrow. return book_id in self.books"},{"question":"# Problem Statement You have been tasked with creating a function that generates the Pascal\'s triangle up to a given number of rows. Pascal\'s triangle is a triangular array of the binomial coefficients. Implement the function: 1. `generate_pascals_triangle(n: int) -> list[list[int]]` Function Definition * **`generate_pascals_triangle`**: * **Input**: * `n` (int): The number of rows for Pascal\'s triangle to generate. * **Output**: * `list[list[int]]`: A 2-dimensional list representing the first `n` rows of Pascal\'s triangle. Constraints * `n` should be a non-negative integer. Error Handling * If `n` is not a non-negative integer, raise a `ValueError` with the message: `\\"generate_pascals_triangle() requires a non-negative integer for n\\"`. Examples * `generate_pascals_triangle(5)` should return `[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]`. * `generate_pascals_triangle(0)` should return `[]`. * `generate_pascals_triangle(-3)` should raise a `ValueError`.","solution":"def generate_pascals_triangle(n: int) -> list[list[int]]: Generates Pascal\'s triangle up to n rows. Args: n (int): The number of rows for Pascal\'s triangle to generate. Returns: list[list[int]]: A 2-dimensional list representing the first n rows of Pascal\'s triangle. Raises: ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"generate_pascals_triangle() requires a non-negative integer for n\\") if n == 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i - 1][j - 1] + triangle[i - 1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"# Question **Context**: As part of a data processing system, you need to aggregate multiple numeric data streams efficiently. You have observed that maintaining an average in an optimized manner is critical for this task. **Goal**: Your task is to implement a specialized data structure, **MovingAverage**, that calculates the moving average of the last `n` integers in a stream of integers. This structure will support adding new integers and fetching the current moving average efficiently. **Class to Implement**: ```python class MovingAverage: def __init__(self, size: int): Initialize a MovingAverage object with a specific window size. :param size: int, number of elements in the moving average window def next(self, val: int) -> float: Adds a new integer to the moving average data stream and returns the current moving average. :param val: int, new integer to be added :return: float, current moving average of the last \'size\' integers ``` **Input**: - The `__init__` method will be called once to initialize the `MovingAverage` object with an integer `size` (1 <= size <= 10^4). - The `next` method will be called multiple times with a new integer `val` (-10^4 <= val <= 10^4). **Output**: - The `next` method should return the current moving average after incorporating the new integer. **Constraints**: - Your solution should maintain an average update time complexity of O(1) for each `next` call. - You may use any data structures that optimize for the given constraints. **Example**: ```python >>> ma = MovingAverage(3) >>> ma.next(1) 1.0 >>> ma.next(10) 5.5 >>> ma.next(3) 4.666666666666667 >>> ma.next(5) 6.0 ``` **Hint**: - Consider using a queue or circular buffer to store the latest `size` elements and maintain a running sum to optimize for the average computation.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize a MovingAverage object with a specific window size. :param size: int, number of elements in the moving average window self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Adds a new integer to the moving average data stream and returns the current moving average. :param val: int, new integer to be added :return: float, current moving average of the last \'size\' integers if len(self.queue) == self.size: removed = self.queue.popleft() self.sum -= removed self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"**Scenario**: You are building a route planner for a railway network that optimizes travel based on several criteria. One of the important tasks is to locate and remove cycles in the railway network, ensuring that the pathfinding algorithm doesn\'t enter an infinite loop. **Problem**: Given a directed graph representing the railway network and an adjacency list that describes the routes between cities, detect if there are any cycles in this graph. If a cycle is detected, return `True`; otherwise, return `False`. # Function Signature ```python def detect_cycle(graph: Dict[int, List[int]]) -> bool: pass ``` # Input Format * `graph` (Dict[int, List[int]]): A dictionary where the key is a city (represented as an integer) and the value is a list of cities (integers) that are directly accessible from the key city. # Output Format * **Return** (bool): `True` if the graph contains a cycle, `False` otherwise. # Constraints * Assume cities are represented by non-negative integers. * The number of cities (nodes) and routes (edges) are within typical limits for problem-solving contests (for example, at most 1000 cities and 5000 routes). # Example ```python # Example 1 graph = {0: [1], 1: [2], 2: [0]} print(detect_cycle(graph)) # Expected output: True # Example 2 graph = {0: [1], 1: [2], 2: [3]} print(detect_cycle(graph)) # Expected output: False ``` # Additional Requirements 1. The solution should implement an efficient cycle detection algorithm (e.g., using depth-first search (DFS) or Kahn\'s algorithm for detecting cycles). 2. Ensure that all variable names are descriptive and meaningful. 3. Provide precise handling of edge cases, such as isolated nodes and disconnected graphs. 4. Include comprehensive unit tests for typical, edge, and extreme cases to verify the correctness of the function.","solution":"def detect_cycle(graph): Detects if there is a cycle in the given directed graph. :param graph: A dictionary where keys are cities (as integers) and values are lists of cities accessible from the key city. :return: True if there is a cycle in the graph, False otherwise. def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph.keys(): if node not in visited: if dfs(node): return True return False"},{"question":"# Task You are required to write a function `next_permutation(nums: list) -> list` that transforms the given list of integers `nums` into the next permutation in lexicographically sorted order. The function should modify the list in-place and return it. # Input - A list of integers `nums` containing only positive integers. # Output - The same list `nums`, now transformed into the next permutation. If the function is called on the highest possible permutation, it should transform the list into the lowest possible permutation. # Constraints - (1 leq text{len(nums)} leq 1000) - (1 leq text{nums[i]} leq 10^6) for every (i) # Performance Requirements - The solution must operate in O(n) time complexity, where n is the length of the list. # Scenario You are creating a feature for a combinatorial application that helps users generate permutations of a sequence. This functionality is valuable for tasks in fields like operations research, bioinformatics, and game theory where generating permutations is a fundamental operation. # Example ```python >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([1]) [1] ``` # Implementation ```python def next_permutation(nums: list) -> list: n = len(nums) i = n - 2 # Find the first descending element from the end while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the element just larger than `nums[i]` j = n - 1 while nums[j] <= nums[i]: j -= 1 # Swap them nums[i], nums[j] = nums[j], nums[i] # Reverse the part of the list after index `i` nums[i + 1:] = reversed(nums[i + 1:]) return nums ```","solution":"def next_permutation(nums: list) -> list: n = len(nums) i = n - 2 # Find the first descending element from the end while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the element just larger than `nums[i]` j = n - 1 while nums[j] <= nums[i]: j -= 1 # Swap them nums[i], nums[j] = nums[j], nums[i] # Reverse the part of the list after index `i` nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"# Coding Challenge: String Pattern Matching Scenario As part of a text-processing software, you need to develop a feature that checks if a given pattern exists within another string. This problem focuses on using string matching techniques to determine the presence of a substring pattern within a longer text. Question Write a Python function that takes two strings, `text` and `pattern`, and returns `True` if the `pattern` is found within the `text`, otherwise returns `False`. Function Signature ```python def is_pattern_present(text: str, pattern: str) -> bool: Returns True if the pattern is found within the text, otherwise False. Parameters: text (str): the string to be searched. pattern (str): the string pattern to find within the text. Returns: bool: True if the pattern is present in the text, False otherwise. ``` Input/Output * **Input Format**: Two strings, `text` and `pattern`, where: - `text` is a non-empty string consisting of lowercase alphabets. - `pattern` is a non-empty string consisting of lowercase alphabets, which you need to search in `text`. * **Output Format**: A boolean value, `True` if the pattern is found in the text, otherwise `False`. Constraints 1. 1 <= len(text) <= 10^5 2. 1 <= len(pattern) <= 10^3 Example ```python is_pattern_present(\\"hello world\\", \\"world\\") # Expected output: True is_pattern_present(\\"coding is fun\\", \\"python\\") # Expected output: False ``` Explanation 1. In the first example, the pattern \\"world\\" is found in the text \\"hello world\\", so the function returns `True`. 2. In the second example, the pattern \\"python\\" is not found in the text \\"coding is fun\\", so the function returns `False`. Remember to implement the function efficiently to handle the given constraints.","solution":"def is_pattern_present(text: str, pattern: str) -> bool: Returns True if the pattern is found within the text, otherwise False. Parameters: text (str): the string to be searched. pattern (str): the string pattern to find within the text. Returns: bool: True if the pattern is present in the text, False otherwise. return pattern in text"},{"question":"# String Permutations with Character Swaps Context: You are given two strings of equal length consisting only of lowercase letters. Your goal is to determine if one string can be transformed into the other by swapping any two characters in the string any number of times. Specifications: * Function Signature: `def can_transform_by_swaps(str1: str, str2: str) -> bool` * Input: * Two strings `str1` and `str2` of the same length consisting only of lowercase letters. * Output: * A boolean value: `True` if `str1` can be transformed into `str2` by swapping any two characters any number of times, otherwise `False`. Constraints: 1. The two input strings are of the same length. 2. The input strings consist only of lowercase English letters. 3. Your solution should be able to handle strings of length up to 10^5 efficiently. Example: ```python can_transform_by_swaps(\\"abcd\\", \\"dcba\\") # Returns True can_transform_by_swaps(\\"aabb\\", \\"bbaa\\") # Returns True can_transform_by_swaps(\\"abcd\\", \\"abdc\\") # Returns True can_transform_by_swaps(\\"abcd\\", \\"abcc\\") # Returns False ``` Task: Implement `can_transform_by_swaps()` that meets the above specifications. Ensure your solution is efficient and takes into account all edge cases, including when the two strings are already identical or when it is impossible to transform one string into the other.","solution":"def can_transform_by_swaps(str1: str, str2: str) -> bool: Returns True if str1 can be transformed into str2 by any number of character swaps, otherwise returns False. # If the sorted characters of both strings are the same # then we can swap characters to convert one string into the other. return sorted(str1) == sorted(str2)"},{"question":"# Question: Write a function `subarray_product_less_than_k(nums: List[int], k: int) -> int` that counts the number of contiguous subarrays within a given list `nums` whose product of elements is less than `k`. If `k` is less than or equal to 1, the function should return 0. Function Signature: ```python from typing import List def subarray_product_less_than_k(nums: List[int], k: int) -> int: pass ``` Input: - `nums`: A list of integers where the length of the list is between 1 and (10^4). - `k`: An integer threshold. Output: - An integer representing the number of contiguous subarrays whose product is less than `k`. Constraints: 1. All elements in the `nums` list are positive integers. 2. (1 leq text{len}(nums) leq 10^4) 3. (1 leq nums[i] leq 1000) 4. (0 leq k leq 10^9) Examples: ```python assert subarray_product_less_than_k([10, 5, 2, 6], 100) == 8 assert subarray_product_less_than_k([1, 2, 3], 0) == 0 assert subarray_product_less_than_k([1, 2, 3], 7) == 6 assert subarray_product_less_than_k([1, 1, 1], 2) == 6 ``` Notes: - To solve this problem efficiently, consider using a sliding window approach where the window is expanded or contracted based on the product. - Document any assumptions or steps clearly within your function to illustrate your reasoning. - Optimize for performance to handle large lists within the constraints.","solution":"from typing import List def subarray_product_less_than_k(nums: List[int], k: int) -> int: if k <= 1: return 0 product = 1 left = 0 count = 0 for right in range(len(nums)): product *= nums[right] while product >= k and left <= right: product //= nums[left] left += 1 count += right - left + 1 return count"},{"question":"# Problem Statement Write a function called `find_palindromes` that receives a list of strings and returns a new list containing only the strings that are palindromes. # Function Signature ```python def find_palindromes(words: list) -> list: pass ``` # Input - A list `words` of strings (`list[str]`), where each string is a word consisting of lowercase alphabetical characters. The list may be empty. # Output - A list of strings (`list[str]`), containing only the words from the input list that are palindromes, in the same order they appeared in the input list. # Example ```python # Example 1 assert find_palindromes([\\"madam\\", \\"racecar\\", \\"hello\\", \\"world\\"]) == [\\"madam\\", \\"racecar\\"] # Example 2 assert find_palindromes([\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] # Example 3 assert find_palindromes([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [] # Example 4 assert find_palindromes([]) == [] ``` # Constraints - The function should output the palindromes in the same order they appeared in the input list. - Each string in the input list will consist of lowercase alphabetical characters only (`a-z`). - Palindromes are words that read the same forward and backward, e.g., \\"madam\\", \\"racecar\\". # Requirements - **Correctness**: Ensure the function accurately identifies and returns palindromes. - **Edge Cases**: Handle edge cases such as an empty list, single-character words, and no palindromes in the list. - **Efficiency**: Aim for an efficient algorithm in terms of both time and space complexity.","solution":"def find_palindromes(words: list) -> list: This function takes a list of strings and returns a new list containing only the strings that are palindromes. Parameters: words (list): A list of strings. Returns: list: A list of palindromic strings. return [word for word in words if word == word[::-1]]"},{"question":"# Context You have been asked to implement a sorting algorithm that sorts a list of integers in ascending order. Notably, you are required to implement the Merge Sort algorithm. Merge Sort is a classic divide-and-conquer algorithm that effectively handles large lists with efficiency. # Objective Write a function `merge_sort` that takes a list of integers and returns a new list with the integers sorted in ascending order. Your implementation must follow the standard procedure of the Merge Sort algorithm, including the divide, conquer, and combine steps. # Required Implementations 1. **Merge Function**: - Helper function `merge(left: List[int], right: List[int]) -> List[int]` - Arguments: * `left`: A list of integers. * `right`: A list of integers. - Returns a merged and sorted list containing all elements from `left` and `right`. 2. **Merge Sort Function**: - `merge_sort(arr: List[int]) -> List[int]` - Arguments: * `arr`: A list of integers to be sorted. - Returns a new list of integers sorted in ascending order. # Constraints - The function should handle lists of up to (10^5) integers. - All integers in the list will fit in the range (-10^9) to (10^9). # Example Usage ```python # Example of merge sort arr = [38, 27, 43, 3, 9, 82, 10] sorted_arr = merge_sort(arr) # Expected output: [3, 9, 10, 27, 38, 43, 82] ``` # Performance Requirements The solution must efficiently handle the sorting to ensure a time complexity of (O(n log n)). Avoid unnecessary computations and ensure that the merge function executes correctly by merging two sorted lists into a single sorted list. Implement your `merge` and `merge_sort` functions below. Ensure the implementation can handle large lists and provides accurate sorting results.","solution":"from typing import List def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists (left and right) into a single sorted list. result = [] i = j = 0 # Merge the two lists while maintaining order while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Add remaining elements from left list, if any while i < len(left): result.append(left[i]) i += 1 # Add remaining elements from right list, if any while j < len(right): result.append(right[j]) j += 1 return result def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Merge Sort algorithm. if len(arr) <= 1: return arr # Split array into halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"# Problem Statement: **Prime Factorization in Range** Write a function `prime_factors_in_range(m: int, n: int) -> List[Dict[int, int]]` to return a list of dictionaries representing the prime factorization of each integer in the inclusive range from `m` to `n`. Each dictionary in the list corresponds to an integer in the range and has the prime factors as keys and their respective powers as values. Input: * Two integers `m (2 <= m <= 1*10^3)` and `n (m <= n <= 1*10^3)` specifying the range of integers to be factorized. Output: * A list of dictionaries where each dictionary represents the prime factorization of an integer in the range `[m, n]`. Example: ```python # Example 1: m = 10 n = 12 prime_factors_in_range(m, n) -> [{2: 1, 5: 1}, {11: 1}, {2: 2, 3: 1}] # Explanation: # 10 is factored as 2^1 * 5^1, so its dictionary is {2: 1, 5: 1} # 11 is a prime number, so its dictionary is {11: 1} # 12 is factored as 2^2 * 3^1, so its dictionary is {2: 2, 3: 1} # Example 2: m = 5 n = 7 prime_factors_in_range(m, n) -> [{5: 1}, {2: 1, 3: 1}, {7: 1}] # Explanation: # 5 is a prime number, so its dictionary is {5: 1} # 6 is factored as 2^1 * 3^1, so its dictionary is {2: 1, 3: 1} # 7 is a prime number, so its dictionary is {7: 1} ``` Constraints: * Function should handle invalid inputs gracefully and raise appropriate exceptions. * Ensure the function maintains efficiency and correctness even at the upper limit constraints. Edge Cases to Consider: 1. Very small ranges, e.g., `m = 2, n = 2`. 2. Non-integer inputs (returning appropriate error messages). 3. Large ranges where `m` and `n` are far apart in value. Notes: * Use efficient prime factorization techniques to ensure performance constraints are met. * Simplify the problem using any built-in functions or libraries if necessary but maintain clarity and comprehensibility in the algorithm.","solution":"from typing import List, Dict def prime_factors_in_range(m: int, n: int) -> List[Dict[int, int]]: Returns a list of dictionaries representing the prime factorization of each integer in the inclusive range from m to n. def prime_factors(num: int) -> Dict[int, int]: factors = {} d = 2 while d * d <= num: while (num % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 num //= d d += 1 if num > 1: factors[num] = 1 return factors if not (isinstance(m, int) and isinstance(n, int)): raise ValueError(\\"Both m and n must be integers\\") if m < 2 or m > 1000 or n < m or n > 1000: raise ValueError(\\"m and n must satisfy 2 <= m <= 1000 and m <= n <= 1000\\") return [prime_factors(i) for i in range(m, n + 1)]"},{"question":"# Reversible Min-Heap Implementation Context: You are tasked with implementing a reversible min-heap data structure. In addition to the standard min-heap operations, this heap should support reversing the order of elements. When reversed, the heap should behave as a max-heap. Problem Statement: Design and implement a `ReversibleHeap` class that supports the following operations: 1. Insert an element into the heap. 2. Extract the minimum (or maximum, if reversed) element from the heap. 3. Reverse the order of the heap. Requirements: 1. `insert(element)`: Insert an element into the heap. If the heap is currently reversed, maintain the max-heap property. 2. `extract()`: Extract and return the minimum element if the heap is in its original state, or the maximum element if reversed. After extraction, maintain the heap property (min-heap or max-heap depending on the state). 3. `reverse()`: Reverse the order of the heap. If the heap was a min-heap, it should become a max-heap, and vice versa. Input/Output: The following sequence outlines the operations to be supported and their expected behavior: * `insert(element)`: No output. The element is added to the heap. * `extract()`: Returns the minimum (or maximum, if reversed) element from the heap. * `reverse()`: No output. The heap should now behave as the opposite type (min-heap or max-heap). Constraints: * Elements will be integers in the range from -10^6 to 10^6. * The number of operations will not exceed 10^4. Example: ```python heap = ReversibleHeap() heap.insert(5) heap.insert(2) heap.insert(8) print(heap.extract()) # Output: 2 heap.reverse() heap.insert(1) print(heap.extract()) # Output: 8 heap.reverse() print(heap.extract()) # Output: 1 print(heap.extract()) # Output: 5 ``` Class Signature: ```python class ReversibleHeap: def __init__(self): # Initialize the heap and reversal state def insert(self, element: int): # Implement the insert operation def extract(self) -> int: # Implement the extract operation def reverse(self): # Implement the reverse operation ``` Implement the `ReversibleHeap` class by following the given requirements. Ensure that the heap maintains its properties after each operation for both min-heap and max-heap states.","solution":"import heapq class ReversibleHeap: def __init__(self): self.heap = [] self.reversed = False def insert(self, element: int): if self.reversed: heapq.heappush(self.heap, -element) else: heapq.heappush(self.heap, element) def extract(self) -> int: if self.reversed: return -heapq.heappop(self.heap) else: return heapq.heappop(self.heap) def reverse(self): self.reversed = not self.reversed self.heap = [-x for x in self.heap] heapq.heapify(self.heap)"},{"question":"# Question **Movie Recommendation Algorithm** You are required to develop a movie recommendation system in Python. The system will receive a user\'s watch history and a dictionary of available movies with their respective genres. Based on the user\'s watch history, the system should recommend movies that match the user\'s preferred genres. The provided code snippets attempt to achieve this but lack efficiency and handling of edge cases. Your task is to: 1. Improve the efficiency of the recommendation algorithm. 2. Handle edge cases appropriately. 3. Ensure the function is robust and accurate. **Function Signature** ```python def recommend_movies(watch_history: list[tuple[str, str]], available_movies: dict[str, str]) -> list[str]: ... ``` # Expected Input and Output Format * **Input**: * `watch_history` (list of tuples): Each tuple contains a movie title (str) and its genre (str) that the user has already watched. (1 <= len(watch_history) <= 10^5) * `available_movies` (dict): A dictionary where the key is the movie title (str) and the value is its genre (str). (1 <= len(available_movies) <= 10^5) * **Output**: * A list of movie titles (str) that are recommended for the user based on their watch history, with no duplicates. The titles should be sorted in alphabetical order. # Constraints * Ensure that the function handles edge cases where `watch_history` is empty by returning an empty list. * Make sure the function raises a `ValueError` if `available_movies` is empty. * Each movie title and genre are case-insensitive, i.e., \'Action\' and \'action\' should be treated as the same genre. # Scenario/Context Consider a scenario where a streaming service needs to recommend movies to users based on their existing watch history. This helps keep users engaged by suggesting movies they are likely to enjoy. # Example **Example 1**: ```python >>> watch_history = [(\'Inception\', \'Sci-Fi\'), (\'The Matrix\', \'Sci-Fi\'), (\'Interstellar\', \'Sci-Fi\')] >>> available_movies = {\'Blade Runner\': \'Sci-Fi\', \'The Dark Knight\': \'Action\', \'The Terminator\': \'Sci-Fi\'} >>> recommend_movies(watch_history, available_movies) [\'Blade Runner\', \'The Terminator\'] ``` **Example 2**: ```python >>> watch_history = [(\'Titanic\', \'Romance\'), (\'Pride and Prejudice\', \'Romance\')] >>> available_movies = {\'Love Actually\': \'Romance\', \'The Notebook\': \'Romance\', \'Mad Max\': \'Action\'} >>> recommend_movies(watch_history, available_movies) [\'Love Actually\', \'The Notebook\'] ``` **Example Edge Case**: ```python >>> watch_history = [] >>> available_movies = {\'Love Actually\': \'Romance\'} >>> recommend_movies(watch_history, available_movies) [] ``` **Example Edge Case**: ```python >>> watch_history = [(\'Titanic\', \'Romance\')] >>> available_movies = {} Traceback (most recent call last): ... ValueError: No movies available for recommendation ``` # Performance Considerations * Ensure optimal performance for large watch histories and available movie lists. * Minimize memory usage by utilizing appropriate data structures and algorithms. Submit your implementation as the `recommend_movies` function.","solution":"def recommend_movies(watch_history: list[tuple[str, str]], available_movies: dict[str, str]) -> list[str]: Returns a list of recommended movie titles based on the user\'s watch history. Parameters: watch_history (list of tuples): Each tuple contains a movie title (str) and its genre (str). available_movies (dict): A dictionary where the key is the movie title (str) and the value is its genre (str). Returns: list: A list of recommended movie titles that match the user\'s preferred genres, sorted alphabetically. Raises: ValueError: If the available_movies dictionary is empty. if not available_movies: raise ValueError(\\"No movies available for recommendation\\") if not watch_history: return [] # Normalize genres to be case-insensitive preferred_genres = {genre.lower() for _, genre in watch_history} available_movies_normalized = {title: genre.lower() for title, genre in available_movies.items()} # Recommend movies that match the preferred genres recommendations = [title for title, genre in available_movies_normalized.items() if genre in preferred_genres] return sorted(recommendations)"},{"question":"# Find Majority Element in Array In computer science, a majority element in an array of size `n` is an element that appears more than `n/2` times. Given an array of integers, your task is to write a function that identifies the majority element if it exists. If no such element exists, the function should return `None`. Function Signature ```python def find_majority_element(arr: List[int]) -> Union[int, None]: pass ``` Input - `arr` (List[int]): A list of integers where the length of the list `n` satisfies `1 <= n <= 10^5`. The elements of the list are all integers within the range of `-10^9` to `10^9`. Output - Returns the integer that is the majority element, or `None` if no such element exists. Constraints - The algorithm should run in linear time, O(n). - Additional space usage should be kept to a minimum. # Examples ```python find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) # Returns 4 find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) # Returns None find_majority_element([1]) # Returns 1 find_majority_element([]) # Returns None ``` # Requirements - Implement the `find_majority_element` function that identifies the majority element in a provided list of integers. - Ensure the solution is efficient in terms of both time and space complexity. - Validate your implementation with the given examples and consider additional edge cases. # Scenario In many real-world applications such as voting systems, identifying a majority element quickly and efficiently is crucial. Your task is to build a robust function that can determine if a majority element exists in a list of integers, thereby ensuring effective and reliable decision-making processes in scenarios where understanding the prevalent choice or item is necessary. Make sure your solution handles different sizes of input effectively, and correctly identifies the majority element or determines its absence if appropriate.","solution":"from typing import List, Union def find_majority_element(arr: List[int]) -> Union[int, None]: This function finds the majority element in the array `arr`, which is the element that appears more than n/2 times, if such element exists. If there is no majority element, the function returns None. # Boyer-Moore Voting Algorithm candidate = None count = 0 # First pass to find a candidate for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify if the candidate is indeed the majority if candidate is not None and arr.count(candidate) > len(arr) // 2: return candidate else: return None"},{"question":"# Knapsack Problem Using Dynamic Programming Context You are developing a software solution for a shipping company. They need an efficient way to maximize the value of items carried within a fixed weight limit. Your task is to implement the 0/1 Knapsack problem using dynamic programming to determine the maximum value that can be achieved without exceeding the weight limit. Task Implement a function to solve the 0/1 Knapsack problem. Your implementation will: 1. Take as input lists of item weights and their corresponding values. 2. Include the maximum weight capacity of the knapsack. 3. Utilize dynamic programming to calculate the maximum achievable value for the given weight limit. 4. Return the maximum value obtainable and the list of items (by their indices) that make up this maximum value. Function Signature ```python def knapsack_dynamic_programming( weights: List[int], values: List[int], max_weight: int ) -> Tuple[int, List[int]]: # your implementation here pass ``` Input * **weights**: A list of integers representing the weights of the items. * **values**: A list of integers representing the values of the items. * **max_weight**: An integer representing the maximum weight capacity of the knapsack. Output * Returns a tuple containing: 1. An integer representing the maximum value that can be achieved without exceeding the weight limit. 2. A list of integers indicating the indices of items included in the knapsack to achieve the maximum value. Constraints * The number of items, `n` (length of weights and values), will be between 1 and 100. * Each weight value will be a positive integer not exceeding 1000. * Each value will be a positive integer not exceeding 1000. * The maximum weight capacity will be a positive integer not exceeding 10000. **Notes**: * Consider typical edge cases like having no capacity or no items to include. * Ensure the solution is optimized for time and space complexities appropriately using dynamic programming. Example ```python # Example function call max_value, items_indices = knapsack_dynamic_programming( weights=[1, 3, 4, 5], values=[1, 4, 5, 7], max_weight=7 ) print(\\"Max Value:\\", max_value) print(\\"Items Indices:\\", items_indices) ``` *Expected Output:* ``` Max Value: 9 Items Indices: [1, 2] ```","solution":"from typing import List, Tuple def knapsack_dynamic_programming(weights: List[int], values: List[int], max_weight: int) -> Tuple[int, List[int]]: n = len(weights) # Create a table to store the maximum value at each n-th item and weight capacity dp = [[0 for _ in range(max_weight + 1)] for _ in range(n + 1)] # Build the dp table in bottom up manner for i in range(1, n + 1): for w in range(1, max_weight + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] # Backtracking to find the items included in the knapsack max_value = dp[n][max_weight] w = max_weight items_indices = [] for i in range(n, 0, -1): if max_value > dp[i - 1][w]: items_indices.append(i - 1) w -= weights[i - 1] max_value -= values[i - 1] items_indices.reverse() # Optional: to maintain the order of items as received in the input return dp[n][max_weight], items_indices"},{"question":"# Coding Challenge **Problem Statement**: You are provided with a list of words and an integer `k`. Your task is to determine the `k` most frequent words in the list. If there are multiple words with the same frequency, sort them in alphabetical order. **Function Specifications**: Complete the function `top_k_frequent_words(words: list[str], k: int) -> list[str]` which takes in the following parameters: - `words`: A list of strings, each representing a word. - `k`: An integer representing the number of top frequent words to return. The function should return a list of strings, representing the `k` most frequent words sorted first by frequency (from highest to lowest) and then alphabetically for ties. **Input Constraints**: - The length of `words` is between 1 and 10000. - Each word in `words` consists of lowercase English letters. - The length of each word does not exceed 50. - The value of `k` is between 1 and 10000. **Output**: - A list of strings representing the `k` most frequent words. **Example**: ```python assert top_k_frequent_words([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) == [\\"i\\", \\"love\\"] assert top_k_frequent_words([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) == [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] ``` **Additional Specifications**: - You may use any standard libraries for hash maps and sorting. - Optimize for time and space where possible. **Explanation**: Given the words `[\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"]` and `k = 2`, the two most frequent words are \\"i\\" and \\"love\\". Therefore the output is `[\\"i\\", \\"love\\"]`. Given the words `[\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"]` and `k = 4`, the four most frequent words are \\"the\\", \\"is\\", \\"sunny\\", and \\"day\\". Therefore the output is `[\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"]`.","solution":"from collections import Counter def top_k_frequent_words(words: list[str], k: int) -> list[str]: Returns the k most frequent words sorted first by frequency and then alphabetically. count = Counter(words) sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"# Problem Statement You are provided with a singly linked list and an integer `n`. Your task is to implement a function `remove_nth_from_end` that removes the nth node from the end of the list and returns the head of the modified list. Additionally, you should implement a function `reverse_linked_list` that reverses the entire linked list and returns the head of the reversed list. # Function Signatures ```python def remove_nth_from_end(head: ListNode | None, n: int) -> ListNode | None: pass def reverse_linked_list(head: ListNode | None) -> ListNode | None: pass ``` # Input - `head`: The head of the singly linked list. It can be `None` if the list is empty. - `n`: An integer representing the position from the end of the list of the node to be removed. # Output - `remove_nth_from_end`: The head of the modified linked list after the nth node from the end has been removed. - `reverse_linked_list`: The head of the reversed linked list. # Constraints - The linked list node values are integers. - The length of the linked list will always be at least `n`. - The solution should handle edge cases, such as when the list contains only one node. # Example ```python >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> new_head = remove_nth_from_end(head, 2) >>> list(new_head) [1, 2, 3, 5] >>> reversed_head = reverse_linked_list(new_head) >>> list(reversed_head) [5, 3, 2, 1] >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head = remove_nth_from_end(head, 1) >>> list(head) [1] ``` You can use the provided `ListNode` class and helper functions as needed. # Hints - Consider using a two-pointer approach to efficiently find the nth node from the end. - Remember to handle the case when the node to be removed is the head of the list. - Reversing the linked list should update the `next` pointer of each node carefully.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head: ListNode | None, n: int) -> ListNode | None: dummy = ListNode(0, head) first = dummy second = dummy # Move first pointer n+1 steps ahead for _ in range(n + 1): first = first.next # Move both first and second pointers while first: first = first.next second = second.next # Remove the nth node from end second.next = second.next.next return dummy.next def reverse_linked_list(head: ListNode | None) -> ListNode | None: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def to_list(head: ListNode | None) -> list: Helper function to convert a linked list to a Python list result = [] current = head while current: result.append(current.val) current = current.next return result def from_list(values: list) -> ListNode | None: Helper function to convert a Python list to a linked list dummy = ListNode() current = dummy for val in values: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"# Coding Assessment Question # Sum of All Nodes in a Complete Binary Tree Given the root of a complete binary tree, write a function to calculate the sum of the values of all nodes in the tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Task Implement the function `sum_of_nodes(root: Optional[TreeNode]) -> int` to compute the sum of the node values in the given complete binary tree. Class Definitions The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Input * `root` - the root node of the binary tree (0 ≤ number of nodes ≤ 100,000). Output * Return the integer sum of all the node values in the tree. Example ```python def sum_of_nodes(root: Optional[TreeNode]) -> int: if not root: return 0 return root.val + sum_of_nodes(root.left) + sum_of_nodes(root.right) # Example tree: # 1 # / # 2 3 # / / # 4 5 6 7 # Test case root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) print(sum_of_nodes(root)) # Output: 28 ``` # Guidelines 1. Handle the base case where the root is `None`. 2. Utilize a recursive approach to traverse the entire tree and calculate the sum. 3. Ensure your function is optimized for large trees, and consider using an iterative approach if needed to handle large input sizes efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_nodes(root: TreeNode) -> int: if not root: return 0 return root.val + sum_of_nodes(root.left) + sum_of_nodes(root.right) # Example tree: # 1 # / # 2 3 # / / # 4 5 6 7 # Test case root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) print(sum_of_nodes(root)) # Output: 28"},{"question":"# Problem Statement **Matrix Transpose Optimization** You are required to implement a function that efficiently computes the transpose of a given matrix. The transpose of a matrix is obtained by flipping it over its diagonal, switching the row and column indices of the matrix. # Task Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list `matrix` as input and returns its transpose. # Input Format * A 2D list `matrix` of integers with dimensions ( n times m ). # Output Format * A 2D list representing the transpose of `matrix`, with dimensions ( m times n ). # Constraints * ( 1 leq n, m leq 10^3 ) # Performance Requirements * The solution should efficiently handle matrices of large dimensions within the given constraints. # Example *Example 1:* Input: ```python matrix = [ [1, 2, 3], [4, 5, 6] ] ``` Output: ```python [ [1, 4], [2, 5], [3, 6] ] ``` *Example 2:* Input: ```python matrix = [ [1] ] ``` Output: ```python [ [1] ] ``` # Notes * Make sure your function handles edge cases such as matrices with a single row or a single column efficiently. * Do not use any built-in functions specifically designed for matrix transposition. Implement the function `transpose_matrix` as specified: ```python from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Explanation - The transpose operation will flip the matrix over its diagonal. - For instance, the element at position ( (i, j) ) in the original matrix will move to position ( (j, i) ) in the transposed matrix. - Carefully handle edge cases such as empty matrices or non-uniform matrices. Create a solution that maintains readability and optimal performance.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. :param matrix: A 2D list of integers. :return: The transpose of the matrix as a 2D list. if not matrix or not matrix[0]: return [] num_rows = len(matrix) num_cols = len(matrix[0]) transposed = [[0] * num_rows for _ in range(num_cols)] for i in range(num_rows): for j in range(num_cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Coding Assessment Question You are given the following problem involving sequence manipulation and optimization: Problem Statement: Write a function `reduce_sequence` to take a list of integers and repeatedly remove the smallest integer until the sequence is reduced to a specific target length. However, the removal process should be optimized such that the sum of the remaining integers is minimized. To clarify, the procedure can be outlined as follows: 1. Repeatedly identify and remove the smallest integer from the list. 2. Continue this process until the list contains exactly `target_length` number of integers. 3. Ensure that the remaining elements\' sum is the smallest possible. Your Task: Implement the function `reduce_sequence` to achieve the described reduction in optimal time complexity. **Function Signature**: ```python def reduce_sequence(nums: list[int], target_length: int) -> list[int]: pass ``` **Input**: - `nums`: A list of `n` integers where `n > target_length`. - `target_length`: An integer representing the desired length of the list after reduction. **Output**: - A list of integers of length `target_length` which has the minimum possible sum. **Constraints**: - The length of `nums` will always be greater than `target_length`. - Elements of `nums` can be any integer (positive, negative, or zero). Example Usage: Consider the following examples for clarity: **Example 1**: ```python nums = [4, 1, 3, 2, 7, 5] target_length = 3 result = reduce_sequence(nums, target_length) print(result) # Output: [3, 4, 5] or any permutation with sum minimized ``` **Example 2**: ```python nums = [10, -1, 8, 5, -3, 2] target_length = 4 result = reduce_sequence(nums, target_length) print(result) # Output: [2, 5, 8, 10] ``` **Explanation**: - In the first example, removing the two smallest numbers (1 and 2) results in a sum of 3+4+5 = 12, which is minimal. - In the second example, removing the two smallest numbers (-3 and -1) results in a sum of 2+5+8+10 = 25, which is minimal. **Performance Considerations**: - Aim for an efficient solution that reduces excessive time complexity. Notes: - Utilize built-in Python functions where appropriate for optimized operations. - Ensure robustness by testing against edge cases.","solution":"def reduce_sequence(nums: list[int], target_length: int) -> list[int]: Reduces the list nums to \'target_length\' elements such that the sum of the remaining elements is minimized. This is achieved by removing the smallest elements first. # Sort the list in descending order nums.sort() # As we need to keep the \'target_length\' largest elements # we just need to remove the smallest n-target_length elements return nums[-target_length:]"},{"question":"# Coding Assessment Question Context A delivery company wants to optimize its delivery routes to minimize the total distance traveled while ensuring all delivery locations are serviced. The company uses a fleet of delivery vehicles, each with limited capacity. The delivery locations need to be partitioned into multiple routes, where each route starts and ends at the company depot. Each delivery vehicle can serve a subset of locations without exceeding its capacity. Your task is to implement an algorithm to determine the optimal partitioning of delivery locations and the routing order for each vehicle. Task Write a function `optimize_delivery_routes` that, given the delivery locations, their demands, and vehicle capacity, determines an optimized set of routes for the fleet to follow. # Function Signature ```python def optimize_delivery_routes( depot: Tuple[int, int], locations: List[Tuple[int, int]], demands: List[int], vehicle_capacity: int ) -> List[List[Tuple[int, int]]]: Optimizes delivery routes for a fleet of vehicles with limited capacity. Args: depot: A tuple (x, y) representing the coordinates of the company depot. locations: A list of tuples [(x1, y1), (x2, y2), ..., (xn, yn)] representing the coordinates of delivery locations. demands: A list of integers [d1, d2, ..., dn] representing the delivery demands at each corresponding location. vehicle_capacity: An integer representing the capacity of each delivery vehicle. Returns: List of lists, where each inner list represents the route for one vehicle as a sequence of (x, y) coordinates, including the depot as the start and end point of each route. ``` # Input and Output Format - **Input**: - `depot` : A tuple of two integers representing the coordinates `(x, y)` of the company depot. - `locations` : A list of tuples, each of form `(x, y)`, representing the coordinates of delivery locations. The length of the list is `n`. - `demands` : A list of integers representing the delivery demands at each location. The length of the list is `n`. - `vehicle_capacity` : An integer representing the capacity of each delivery vehicle. - **Output**: A list of lists, where each inner list represents the route for one vehicle as a sequence of `(x, y)` coordinates, including the depot as the start and end point of each route. # Constraints - Assume `1 <= n <= 1000`. - Locations have non-negative integer coordinates. - Demands are non-negative integers. - `vehicle_capacity` is a positive integer. # Example ```python depot = (0, 0) locations = [(1, 3), (4, 5), (7, 1), (2, 6)] demands = [3, 6, 2, 4] vehicle_capacity = 10 routes = optimize_delivery_routes(depot, locations, demands, vehicle_capacity) print(routes) # Expected output: a list of lists where each inner list is a valid route, e.g. # [ # [(0, 0), (1, 3), (2, 6), (0, 0)], # [(0, 0), (4, 5), (7, 1), (0, 0)] # ] ``` # Notes - Use appropriate heuristics or optimization algorithms to partition the locations and propose routes. - Each vehicle must start and end its route at the depot. - Ensure that the total demand serviced by each vehicle does not exceed its capacity. - Consider edge cases such as locations with zero demand and vehicles having to revisit the depot. Hints 1. Experiment with clustering algorithms to partition the locations. 2. Use algorithms like the Traveling Salesman Problem (TSP) to determine the most efficient routes for each cluster. 3. Implement checks to ensure the vehicle capacity is not exceeded.","solution":"from typing import List, Tuple import itertools import math def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def tsp_route(depot: Tuple[int, int], locations: List[Tuple[int, int]]) -> List[Tuple[int, int]]: n = len(locations) all_permutations = itertools.permutations(locations) min_route = None min_distance = float(\'inf\') for perm in all_permutations: perm = (depot,) + perm + (depot,) distance = sum(calculate_distance(perm[i], perm[i+1]) for i in range(len(perm) - 1)) if distance < min_distance: min_distance = distance min_route = perm return min_route def optimize_delivery_routes( depot: Tuple[int, int], locations: List[Tuple[int, int]], demands: List[int], vehicle_capacity: int ) -> List[List[Tuple[int, int]]]: n = len(locations) routes = [] used = [False] * n while not all(used): current_load = 0 current_route = [depot] for i in range(n): if not used[i] and current_load + demands[i] <= vehicle_capacity: current_load += demands[i] current_route.append(locations[i]) used[i] = True current_route.append(depot) tsp_optimized_route = tsp_route(depot, current_route[1:-1]) routes.append(list(tsp_optimized_route)) return routes"},{"question":"# Coding Assessment Question Problem Description You need to implement a function that identifies if a given integer is a power of two. An integer `n` is considered a power of two if there exists an integer `x` such that `n = 2^x`. For instance: - 1 is a power of two (2^0 = 1) - 2 is a power of two (2^1 = 2) - 4 is a power of two (2^2 = 4) Write a function `is_power_of_two` that takes an integer and determines if it is a power of two. Requirements 1. The function should take a single parameter `n`, an integer. 2. The function should return a boolean `True` if `n` is a power of two, otherwise `False`. 3. The function should handle both positive and negative values of `n`, as well as zero. Input Format - A single integer `n` (-2^31 ≤ n ≤ 2^31 - 1). Output Format - A single boolean value: `True` if `n` is a power of two, otherwise `False`. Constraints - The input integer can be any valid 32-bit signed integer. Example ```python is_power_of_two(1) # Returns: True is_power_of_two(2) # Returns: True is_power_of_two(3) # Returns: False is_power_of_two(16) # Returns: True is_power_of_two(-8) # Returns: False is_power_of_two(0) # Returns: False ``` Additional Notes - For a number to be a power of two, there should be only one bit set in its binary representation. - Consider edge cases such as large negative numbers, zero, and maximum possible values for a 32-bit integer.","solution":"def is_power_of_two(n): Determines if an integer n is a power of two. Parameters: n (int): The integer to check. Returns: bool: True if n is a power of two, False otherwise. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Question: Find Peak Element in a 1D Array Given an array of integers, write a function to find a peak element. An element is a peak if it is greater than its neighbors. For corner elements, consider only one neighbor. Function Signature ```python def find_peak_element(nums: list[int]) -> int: pass ``` Input - `nums` (list of integers): An array of integers. Output - An integer representing the index of one peak element. If there are multiple peaks, return the index of any one of them. Examples ```python # Example 1 nums = [1, 2, 3, 1] # Output: 2 # Example 2 nums = [1, 2, 1, 3, 5, 6, 4] # Output: 5 (or 1 or 6, any of these is a valid peak) # Example 3 nums = [10, 20, 15, 2, 23, 90, 67] # Output: 1 or 5 ``` Constraints - The length of the array is at least 1 and at most 1000. - You can assume that `nums[i] != nums[i+1]` for all valid `i`. - Your solution should have an optimal time complexity of `O(log N)`. # Solution Approach Use a binary search algorithm to find a peak element in `O(log N)` time complex.","solution":"def find_peak_element(nums: list[int]) -> int: Finds the index of a peak element in the array. A peak element is greater than its neighbors. For corner elements, it is compared to only one neighbor. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"# Unique String Rearrangement **Context**: Given a string `s` composed of lowercase English letters, a unique rearrangement is defined as a rearrangement where no two adjacent characters are the same. **Task**: Write a function `rearrange_unique(s: str) -> str` that rearranges the string in such a way that no two adjacent characters are the same, if possible. If it is not possible to rearrange the string to meet the criteria, return an empty string. **Function Signature**: ```python def rearrange_unique(s: str) -> str: pass ``` **Expected Output**: - The function returns a string where no two adjacent characters are the same. - If such rearrangement is not possible, return an empty string. **Constraints**: - The string will consist of only lowercase English letters. - The length of the string will be in the range `1 ≤ len(s) ≤ 10^5`. **Example**: ```python print(rearrange_unique(\\"aab\\")) # Possible Output: \\"aba\\" or other valid rearrangements print(rearrange_unique(\\"aaab\\")) # Expected Output: \\"\\" print(rearrange_unique(\\"aaabbc\\")) # Possible Output: \\"ababac\\" or other valid rearrangements ``` **Additional Requirements**: - Ensure the solution is efficient, especially for the upper limit of input size. - Consider using data structures that can help in tracking the frequency of characters and maintaining a priority for rearrangement. Define the function `rearrange_unique` to handle the rearrangement effectively while following the constraints and expected output.","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_unique(s: str) -> str: # Step 1: Count the frequency of each character char_count = Counter(s) # Step 2: Create a max heap based on the counts max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # If prev_count still has remaining characters, push it back to the heap if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Update previous character and count prev_char, prev_count = char, count + 1 result_str = \'\'.join(result) # If the length of the result string is equal to the input string # It means we have successfully rearranged the string if len(result_str) == len(s): return result_str else: return \\"\\""},{"question":"# Rotate Matrix by 90 Degrees Clockwise Context: A common problem in image processing is rotating an image by 90 degrees. This operation can be visualized as rotating a 2D matrix in place without using additional space for a second matrix. Task: Implement a `rotate_matrix_90` function that takes a square 2D list (matrix) of integers and rotates it 90 degrees clockwise in place. Function Signature: ```python def rotate_matrix_90(matrix: list) -> None: pass ``` Input and Output: - **Input**: A square 2D list (matrix) of integers. - **Output**: The function should modify the input matrix in place, rotating it 90 degrees clockwise. No return value is necessary. Constraints: - The matrix will always be square (i.e., number of rows equals number of columns). - Elements of the matrix are integers. - The dimensions of the matrix will be within (2x2) to (100x100). Examples: 1. Given matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` After `rotate_matrix_90(matrix)`, the matrix should be: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. Given matrix: ``` [ [1, 2], [3, 4] ] ``` After `rotate_matrix_90(matrix)`, the matrix should be: ``` [ [3, 1], [4, 2] ] ``` Notes: - You are required to modify the input matrix in-place. - The function should handle edge cases, such as the smallest matrix (2x2) and larger matrices efficiently.","solution":"def rotate_matrix_90(matrix: list) -> None: Rotates the given square matrix by 90 degrees clockwise in place. Args: matrix (list): A square 2D list of integers. Returns: None n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Assessment Question You are required to implement a Python function that processes a list of transactions and returns a summary of account balances. **Function Description:** Write a function `calculate_balances(transactions: List[str]) -> Dict[str, float]` that takes a list of transaction strings formatted as `\'account_name operation amount\'` and returns a dictionary summarizing the balances in each account. Input: * `transactions` (List[str]): A list of strings, where each string represents a transaction. Each transaction includes the `account_name` (str), `operation` (either \'credit\' or \'debit\'), and `amount` (float), separated by spaces. Output: * A dictionary where keys are the account names (str) and values are their respective balances (float). Credit operations increase the balance, while debit operations decrease it. Transaction Details: * Each transaction is formatted as `\'account_name operation amount\'`. * `operation` is either \'credit\' (to add funds) or \'debit\' (to subtract funds). * `amount` is a positive floating-point number representing the transaction amount. Example: For a list of transactions like this: ``` [ \\"savings credit 500.0\\", \\"checking credit 200.0\\", \\"savings debit 150.0\\", \\"savings credit 100.0\\", \\"checking debit 50.0\\" ] ``` The function should return: ```python { \\"savings\\": 450.0, \\"checking\\": 150.0 } ``` Constraints: * `account_name` will not contain spaces and will consist of alphanumeric characters. * The list of transactions will have at most 10,000 entries. * Each `amount` will be a positive floating-point number.","solution":"def calculate_balances(transactions): Processes a list of transactions and returns a summary of account balances. Args: transactions (List[str]): List of transaction strings. Returns: Dict[str, float]: Dictionary with account names and their respective balances. balances = {} for transaction in transactions: account_name, operation, amount = transaction.split() amount = float(amount) if account_name not in balances: balances[account_name] = 0.0 if operation == \'credit\': balances[account_name] += amount elif operation == \'debit\': balances[account_name] -= amount return balances"},{"question":"# Problem Statement You are developing a system for analyzing and categorizing text documents. One common task in this process is to determine the most frequently occurring words in a document after removing a set of \\"stop words.\\" Stop words are common words that are often removed because they are considered unimportant for the purpose of text analysis. # Description You need to write a function to find the most frequently occurring words in a document, excluding stop words. The function should return these words in order of their frequency, from most to least common. In case of a tie, the words should be returned in alphabetical order. # Objective Write a function `most_frequent_words` that takes in a string `document` and a list of strings `stop_words`, and returns a list of the most frequent words in the document, sorted by frequency and then alphabetically. # Function Signature ```python def most_frequent_words(document: str, stop_words: List[str]) -> List[str]: pass ``` # Input - **document** (str): a string representing the text document. - **stop_words** (List[str]): a list of strings representing the stop words. # Output - Return a list of strings representing the most frequent words in the document, sorted by frequency and then alphabetically. # Constraints - The document contains only alphanumeric characters and spaces. - All words in the document are separated by one or more spaces. - Stop words are all in lowercase. - The document will have at least one word that is not a stop word. # Examples **Example 1:** ```python document = \\"the quick brown fox jumps over the lazy dog\\" stop_words = [\\"the\\", \\"over\\"] print(most_frequent_words(document, stop_words)) # Expected output: [\\"brown\\", \\"dog\\", \\"fox\\", \\"jumps\\", \\"lazy\\", \\"quick\\"] ``` **Example 2:** ```python document = \\"hello world hello\\" stop_words = [\\"hello\\"] print(most_frequent_words(document, stop_words)) # Expected output: [\\"world\\"] ``` **Example 3:** ```python document = \\"a a a b b c c c d\\" stop_words = [\\"a\\"] print(most_frequent_words(document, stop_words)) # Expected output: [\\"c\\", \\"b\\", \\"d\\"] ``` # Hints 1. Use the `collections.Counter` class to count the frequency of words. 2. Convert all words to lowercase to ensure case insensitivity. 3. Filter out the stop words before counting frequencies. 4. Pay attention to the tie-breaking condition where words with the same frequency need to be sorted alphabetically. # Additional Information - Ensure your solution is efficient with a time complexity of around O(n log n) where n is the number of unique words in the document. - Handle edge cases carefully, such as when all words are stop words.","solution":"from typing import List from collections import Counter def most_frequent_words(document: str, stop_words: List[str]) -> List[str]: # Convert document to lowercase and split into words words = document.lower().split() # Filter out the stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequency of each word word_count = Counter(filtered_words) # Sort words first by frequency (descending), then alphabetically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract just the words from the sorted list result = [word for word, count in sorted_words] return result"},{"question":"# Question **String Transformation: Advanced Coding Challenge** In this challenge, you will implement a function that performs a specific transformation on a given string. The transformation involves reversing the order of words, where a word is defined as a sequence of non-space characters. Additionally, you have to capitalize the first letter of each word in the resulting string. Problem Statement 1. **Function to Implement**: Implement the function `transform_string(s: str) -> str`. 2. **Function Signature**: The function signature should be `def transform_string(s: str) -> str:` 3. **Input**: - `s` (string): A non-empty string containing words separated by spaces. The string may have leading or trailing spaces, and words are guaranteed to be separated by a single space within the string. Constraints: `1 <= len(s) <= 10^4` 4. **Output**: - A string where the order of words is reversed, and each word is capitalized. Example ```python # Example calls print(transform_string(\\"hello world\\")) # Output: \\"World Hello\\" print(transform_string(\\" the sky is blue \\")) # Output: \\"Blue Is Sky The\\" print(transform_string(\\"a quick brown fox\\")) # Output: \\"Fox Brown Quick A\\" ``` Additional Information - Capitalization means converting the first character of each word to uppercase and the remaining characters to lowercase. - The input string will not contain any special characters other than standard alphabets and spaces. Testing Your implementation will be tested using various strings containing different numbers and lengths of words. Make sure your solution correctly handles edge cases like strings with multiple leading and trailing spaces. # Solution ```python def transform_string(s: str) -> str: # Split the string into words, handling leading/trailing/multiple spaces words = s.strip().split() # Reverse the order of words words.reverse() # Capitalize each word and join them with a single space transformed_string = \' \'.join(word.capitalize() for word in words) return transformed_string # Example calls for testing print(transform_string(\\"hello world\\")) # Output: \\"World Hello\\" print(transform_string(\\" the sky is blue \\")) # Output: \\"Blue Is Sky The\\" print(transform_string(\\"a quick brown fox\\")) # Output: \\"Fox Brown Quick A\\" ``` This new question aligns with the style, complexity, and scope of the provided example, ensuring it blends seamlessly with the existing set.","solution":"def transform_string(s: str) -> str: # Split the string into words, handling leading/trailing/multiple spaces words = s.strip().split() # Reverse the order of words words.reverse() # Capitalize each word and join them with a single space transformed_string = \' \'.join(word.capitalize() for word in words) return transformed_string"},{"question":"# Coding Question Context You are working on an e-commerce platform, and one of the functionalities is to recommend products to users based on their browsing patterns. The recommendation system needs to identify the most frequent product viewed by a user in their browsing history to suggest similar products. Implement a function to determine which product appears most frequently in the given browsing history. Objective Write a function `most_frequent_product` that takes an array of strings representing the browsing history and returns the product that appears most frequently. If there is a tie, return any of the products with the maximum frequency. Function Signature ```python def most_frequent_product(history: list[str]) -> str: ``` Input * `history`: a list of strings representing the browsing history of a user. Constraints: 1 <= len(history) <= 1000 and each string represents a valid product name with a length of 1 to 100 characters. Output * A string representing the product that appears most frequently in the browsing history. Examples ```python >>> most_frequent_product([\'apple\', \'banana\', \'apple\', \'apple\', \'banana\', \'carrot\']) \'apple\' >>> most_frequent_product([\'watch\', \'phone\', \'laptop\', \'tablet\', \'phone\', \'watch\', \'watch\']) \'watch\' >>> most_frequent_product([\'book\', \'pen\', \'pencil\', \'book\', \'pencil\', \'book\', \'pen\']) \'book\' >>> most_frequent_product([\'shoes\']) \'shoes\' ``` Constraints * Your function should efficiently determine the most frequent product with a time complexity of O(n), where n is the number of items in the browsing history. Notes 1. Consider edge cases such as a single product in the list, or all products having the same frequency. 2. Ensure your function handles valid string inputs only.","solution":"def most_frequent_product(history): from collections import Counter # Count the frequency of each product product_counts = Counter(history) # Find the most common product most_common_product, _ = product_counts.most_common(1)[0] return most_common_product"},{"question":"# Problem Statement In your recent data analysis project, you came across the need to generate sequences of prime numbers based on specific constraints. Specifically, you need to find the nth prime number where n is a positive integer. Your task is to implement the function `nth_prime(n: int) -> int` which returns the nth prime number. # Function Signature ```python def nth_prime(n: int) -> int: ``` # Input * `n` : A positive integer (1 ≤ n ≤ 10,000) representing the sequence position of the prime number to compute. # Output * The nth prime number. # Constraints * Raise a `TypeError` if the input is not an integer. * Raise a `ValueError` if the input is less than 1. # Examples Example 1 Input: ```python nth_prime(6) ``` Output: ```python 13 ``` Example 2 Input: ```python nth_prime(1) ``` Output: ```python 2 ``` # Performance Requirements Your solution should efficiently find the nth prime number, considering the upper bound of n. Simple loops may not be performant enough, so optimized algorithms like the Sieve of Eratosthenes or other advanced methods for prime number generation should be considered. # Notes 1. The sequence of prime numbers begins: 2, 3, 5, 7, 11, 13, 17, ... 2. Consider implementing memoization or other optimization techniques to handle large values of n efficiently.","solution":"from math import isqrt def nth_prime(n: int) -> int: Returns the nth prime number. :param n: A positive integer representing the sequence position of the prime number to compute. :return: The nth prime number. :raises TypeError: If the input is not an integer. :raises ValueError: If the input is less than 1. if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 1: raise ValueError(\\"Input must be a positive integer greater than or equal to 1\\") def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True primes = [] candidate = 2 while len(primes) < n: if is_prime(candidate): primes.append(candidate) candidate += 1 return primes[-1]"},{"question":"# Problem Description You are given a weighted, undirected graph represented by an adjacency matrix `weights`, where `weights[i][j]` indicates the weight of the edge between vertex `i` and vertex `j`. Write a function `find_minimum_spanning_tree(weights: List[List[int]]) -> int` that computes the total weight of the minimum spanning tree (MST) using Prim\'s algorithm. # Input * `weights`: A 2D list of integers representing the weights between nodes in the undirected graph (0 ≤ weights[i][j] ≤ 1000). If there is no edge between node `i` and node `j`, `weights[i][j]` is set to a very large value (e.g., `float(\'inf\')`). The graph has `n` nodes (1 ≤ n ≤ 100). # Output * Returns an integer representing the total weight of the minimum spanning tree. # Constraints * The graph is connected, meaning there is at least one path between every pair of nodes. * Nodes are indexed from `0` to `n-1`. # Example ```python weights = [ [0, 2, float(\'inf\'), 6, float(\'inf\')], [2, 0, 3, 8, 5], [float(\'inf\'), 3, 0, float(\'inf\'), 7], [6, 8, float(\'inf\'), 0, 9], [float(\'inf\'), 5, 7, 9, 0] ] print(find_minimum_spanning_tree(weights)) # Output: 16 weights = [ [0, 1, 4], [1, 0, 2], [4, 2, 0] ] print(find_minimum_spanning_tree(weights)) # Output: 3 ``` # Note Your implementation should use Prim\'s algorithm to find the MST. Start from an arbitrary node and iterate, adding the lowest cost edge that connects a vertex in the tree to a vertex outside the tree until all vertices are included in the tree. # Steps to Solve 1. Initialize a list to keep track of the nodes included in the MST. 2. Use a priority queue (or min-heap) to select the minimum weight edge at each step. 3. Add the selected edge to the MST and update the priority queue with new edges connected to newly included nodes. 4. Repeat until all nodes are included in the MST. 5. Return the total weight of the MST.","solution":"from typing import List import heapq def find_minimum_spanning_tree(weights: List[List[int]]) -> int: n = len(weights) visited = [False] * n min_heap = [(0, 0)] # (cost, vertex) total_weight = 0 while min_heap: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_weight += weight for v in range(n): if not visited[v] and weights[u][v] != float(\'inf\'): heapq.heappush(min_heap, (weights[u][v], v)) return total_weight"},{"question":"# Problem Statement Create a function `factorial_sum(n)` to compute the sum of the factorials of all integers from 1 to `n`. The function must handle valid inputs and exceptions appropriately. # Function Signature ```python def factorial_sum(n: int) -> int: ``` # Input - An integer `n` where `1 <= n <= 20`. # Output - The sum of the factorials of all integers from 1 to `n` (integer). # Constraints - If `n` is not a positive integer, raise a `ValueError` with the message: `Input value of [number={n}] must be > 0` - If `n` is not an integer, raise a `TypeError` with the message: `Input value of [number={n}] must be an integer` # Performance Requirements - The solution should have a time complexity of O(n) and a space complexity of O(1). # Example ```python >>> factorial_sum(4) 33 # 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 >>> factorial_sum(1) 1 # 1! = 1 ``` # Additional Test Cases ```python >>> factorial_sum(5) 153 # 1! + 2! + 3! + 4! + 5! = 1 + 2 + 6 + 24 + 120 >>> factorial_sum(0) Traceback (most recent call last): ... ValueError: Input value of [number=0] must be > 0 >>> factorial_sum(6.7) Traceback (most recent call last): ... TypeError: Input value of [number=6.7] must be an integer ``` # Implementation Constraints - Do not use libraries or external modules to compute the factorial. - Ensure input validation is performed at the beginning of the function.","solution":"def factorial_sum(n: int) -> int: Computes the sum of the factorials of all integers from 1 to n. Parameters: n (int): The upper limit integer. Returns: int: The sum of the factorials of all integers from 1 to n. Raises: ValueError: If n is not greater than 0 TypeError: If n is not an integer if not isinstance(n, int): raise TypeError(f\\"Input value of [number={n}] must be an integer\\") if n <= 0: raise ValueError(f\\"Input value of [number={n}] must be > 0\\") def factorial(x): result = 1 for i in range(2, x + 1): result *= i return result total_sum = 0 for i in range(1, n + 1): total_sum += factorial(i) return total_sum"},{"question":"# Objective Write a function that processes a list of astronomical objects each defined by their mass and distance from the observer, and calculates the total gravitational pull at the observer\'s location exerted by all objects. # Function Implementation Function: Calculate Total Gravitational Pull - **Function Name**: `total_gravitational_pull` - **Input**: - `objects` (List[Tuple[float, float]]): A list of tuples where each tuple contains: - `mass` (float): Mass of the astronomical object (kilograms). - `distance` (float): Distance of the object from the observer (meters). - **Output**: (float) Total gravitational pull (Newtons) at the observer\'s location. - **Constraints**: - Mass and distance of each object must be positive numbers. # Error Handling - Raise ValueError with an appropriate message if: - Any object\'s mass or distance is negative or zero. # Example ```python def total_gravitational_pull(objects: List[Tuple[float, float]]) -> float: # Implement the function as specified above ``` Sample Usage ```python # List of astronomical objects (mass in kg, distance in m) objects = [(5.97e24, 6.378e6), (1.989e30, 1.496e11)] # Calculate the total gravitational pull total_gravitational_pull(objects) # Expected output: 0.2073749328795 ``` # Notes - Use the gravitational constant `G` from the `scipy.constants` module. - Ensure that your solution handles edge cases and constraints effectively. - The gravitational pull for each object is given by the formula: [F = frac{G times m}{d^2}] where (m) is the mass and (d) is the distance of the object from the observer. This question retains the style, complexity, and scope of the existing set by focusing on astronomical computations, introducing cumulative calculation, and requiring careful error handling around physical constraints.","solution":"from typing import List, Tuple from scipy.constants import G def total_gravitational_pull(objects: List[Tuple[float, float]]) -> float: Calculates the total gravitational pull exerted by all astronomical objects at the observer\'s location. :param objects: List of tuples, each representing (mass, distance) of the astronomical objects. :return: Total gravitational pull in Newtons. :raises ValueError: If any object\'s mass or distance is non-positive. total_pull = 0.0 for mass, distance in objects: if mass <= 0 or distance <= 0: raise ValueError(\\"Mass and distance must be positive numbers.\\") pull = (G * mass) / (distance ** 2) total_pull += pull return total_pull"},{"question":"**Context**: You are working with a binary tree data structure that supports basic operations such as inserting nodes, but lacks a method to find the lowest common ancestor (LCA) of two given nodes in the tree. **Objective**: Implement the `find_lca` method in the given `BinaryTree` class that finds the lowest common ancestor of two given nodes with specified data values, ensuring the solution works in linear time relative to the number of nodes in the tree. **Function Signature**: ```python def find_lca(self, node1_data: int, node2_data: int) -> Optional[int]: Find the lowest common ancestor of the two given nodes in the binary tree. Args: node1_data (int): Data value of the first node. node2_data (int): Data value of the second node. Returns: Optional[int]: Data value of the lowest common ancestor, or None if either node is not present in the tree. Examples: >>> bt = BinaryTree() >>> bt.insert(20) >>> bt.insert(10) >>> bt.insert(30) >>> bt.insert(5) >>> bt.insert(15) >>> bt.insert(25) >>> bt.insert(35) >>> bt.find_lca(5, 15) 10 >>> bt.find_lca(5, 30) 20 >>> bt.find_lca(5, 40) # Node with data 40 does not exist in the tree None ``` **Constraints**: - The method should handle binary trees with any structure, including skewed trees. - The method should find the LCA within O(n) time complexity where n is the number of nodes in the tree. - Assume all node data values are unique. **Examples**: 1. Finding the LCA of nodes that exist in the tree: ```python bt = BinaryTree() bt.insert(20) bt.insert(10) bt.insert(30) bt.insert(5) bt.insert(15) bt.insert(25) bt.insert(35) assert bt.find_lca(5, 15) == 10 assert bt.find_lca(5, 30) == 20 ``` 2. Trying to find the LCA when one of the nodes does not exist in the tree: ```python bt = BinaryTree() bt.insert(20) bt.insert(10) bt.insert(30) bt.insert(5) assert bt.find_lca(5, 40) is None # Node with data 40 does not exist in the tree ``` 3. Finding the LCA in a sparse tree: ```python bt = BinaryTree() bt.insert(20) bt.insert(10) assert bt.find_lca(10, 20) == 20 ```","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = TreeNode(data) else: self._insert_recursive(self.root, data) def _insert_recursive(self, node, data): if data < node.data: if node.left is None: node.left = TreeNode(data) else: self._insert_recursive(node.left, data) else: if node.right is None: node.right = TreeNode(data) else: self._insert_recursive(node.right, data) def find_lca(self, node1_data, node2_data): def find_lca_helper(node, n1, n2): if node is None: return None if node.data == n1 or node.data == n2: return node left_lca = find_lca_helper(node.left, n1, n2) right_lca = find_lca_helper(node.right, n1, n2) if left_lca and right_lca: return node return left_lca if left_lca is not None else right_lca def find(node, data): if node is None: return False if node.data == data: return True return find(node.left, data) or find(node.right, data) if not find(self.root, node1_data) or not find(self.root, node2_data): return None lca_node = find_lca_helper(self.root, node1_data, node2_data) return lca_node.data if lca_node else None"},{"question":"# Context You are building a notification system where alerts are triggered only when specific conditions are met, based on time and priority. Each alert has a timestamp and a priority. Your system should manage alerts and allow for the following operations: 1. Insert a new alert. 2. Deactivate the oldest alert with the highest priority. 3. Check the current active highest priority alert. # Task Implement a class `AlertManager` using a priority queue data structure to efficiently manage alerts. The queue must support the following operations: 1. **Add an alert**: Insert an alert with its timestamp and priority into the system. 2. **Deactivate highest priority**: Remove and return the oldest alert with the highest priority. 3. **Get current highest priority**: Retrieve but do not remove the oldest alert with the highest priority. Alerts consist of a description string, a timestamp, and a priority value. Implement methods with the following signatures: ```python class AlertManager: def add_alert(self, description: str, timestamp: int, priority: int) -> None: pass def deactivate_highest_priority(self) -> str: pass def get_current_highest_priority(self) -> str: pass ``` # Requirements 1. Ensure that `add_alert` operates with an average-case time complexity of O(log n). 2. Ensure that `deactivate_highest_priority` and `get_current_highest_priority` operate with an average-case time complexity of O(log n) and O(1) respectively. 3. Manage conflicts where multiple alerts have the same priority by deactivating the oldest one based on the timestamp. # Constraints * Timestamps are represented as integers and are always non-negative. * Priorities are integers within the range [-10^6, 10^6]. * Description strings have a maximum length of 200 characters. * No two alerts will have the same timestamp. # Example ```python manager = AlertManager() manager.add_alert(\\"Alert1\\", 1000, 5) manager.add_alert(\\"Alert2\\", 2000, 10) manager.add_alert(\\"Alert3\\", 1500, 5) print(manager.get_current_highest_priority()) # Output: \\"Alert2\\" print(manager.deactivate_highest_priority()) # Output: \\"Alert2\\" print(manager.get_current_highest_priority()) # Output: \\"Alert1\\" ``` Submission Submit a class `AlertManager` implemented in Python, with the specified methods efficiently managing alert priorities as described.","solution":"import heapq class AlertManager: def __init__(self): # Use a min-heap where each element is a tuple (-priority, timestamp, description) # We use -priority to simulate a max-heap self.heap = [] def add_alert(self, description: str, timestamp: int, priority: int) -> None: heapq.heappush(self.heap, (-priority, timestamp, description)) def deactivate_highest_priority(self) -> str: if not self.heap: return None return heapq.heappop(self.heap)[2] def get_current_highest_priority(self) -> str: if not self.heap: return None return self.heap[0][2]"},{"question":"# Problem Statement You are tasked with developing a simple in-memory key-value store with support for multi-level transactions. Implement a data structure that supports set, get, delete, and commit operations with transaction management. # Input The input consists of multiple operations which can be one of the following: 1. `set(key, value)`: Sets the given key to the given value. 2. `get(key)`: Returns the current value of the key. If the key does not exist, return `\\"NULL\\"`. 3. `delete(key)`: Deletes the key from the store. 4. `begin()`: Begins a new transaction. 5. `commit()`: Commits all changes made in the current transaction. 6. `rollback()`: Rolls back all changes made in the current transaction. # Output Your data structure should return the appropriate output for `get` operations and ensure data integrity across transactions. # Constraints * The number of operations will not exceed 100000. * Keys are strings with a length up to 100 characters. * Values are strings with a length up to 1000 characters. * Transactions can be nested i.e., you can start a transaction within another transaction. # Example ```python store = KeyValueStore() store.set(\\"a\\", \\"1\\") print(store.get(\\"a\\")) # Should return \\"1\\" store.begin() store.set(\\"a\\", \\"2\\") print(store.get(\\"a\\")) # Should return \\"2\\" store.rollback() print(store.get(\\"a\\")) # Should return \\"1\\" store.commit() # Nothing to commit print(store.get(\\"a\\")) # Should return \\"1\\" ``` # Requirements Implement the `KeyValueStore` class with the following method stubs: ```python class KeyValueStore: def __init__(self): Initializes the key-value store. def set(self, key, value): Sets the key to the given value. def get(self, key): Returns the value of the given key or \\"NULL\\" if the key does not exist. def delete(self, key): Deletes the key from the store. def begin(self): Begins a new transaction. def commit(self): Commits all changes in the current transaction. def rollback(self): Rolls back all changes made in the current transaction. ``` # Implementation Notes * You may need additional helper methods to manage transactions effectively. * Ensure that each operation performs efficiently and maintains data consistency across nested transactions.","solution":"class KeyValueStore: def __init__(self): self.data = {} self.transactions = [] def set(self, key, value): if self.transactions: self.transactions[-1].append((\\"set\\", key, self.data.get(key, \\"NULL\\"))) self.data[key] = value def get(self, key): return self.data.get(key, \\"NULL\\") def delete(self, key): if self.transactions: self.transactions[-1].append((\\"delete\\", key, self.data.get(key, \\"NULL\\"))) if key in self.data: del self.data[key] def begin(self): self.transactions.append([]) def commit(self): if not self.transactions: return \\"No transaction\\" self.transactions.pop() def rollback(self): if not self.transactions: return \\"No transaction\\" changes = self.transactions.pop() for action, key, value in reversed(changes): if action == \\"set\\": if value == \\"NULL\\": del self.data[key] else: self.data[key] = value elif action == \\"delete\\": self.data[key] = value"},{"question":"# Question: Write a Python function `collapse_strings` that accepts a list of strings and collapses consecutive duplicate elements into a single instance of that element. The function should return the resulting list without any consecutive duplicates. Function Signature ```python def collapse_strings(strings: list[str]) -> list[str]: ``` # Input - `strings`: A list of strings where consecutive duplicate elements may appear. # Output - Returns a list of strings where consecutive duplicate elements are collapsed into a single instance. # Constraints - The list can be empty. - The elements of the list are non-empty strings. - The list can have a varying number of elements (up to 1000 elements). # Examples ```python assert collapse_strings([\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] assert collapse_strings([\\"a\\", \\"a\\", \\"a\\"]) == [\\"a\\"] assert collapse_strings([\\"x\\", \\"y\\", \\"y\\", \\"z\\", \\"z\\", \\"z\\", \\"x\\"]) == [\\"x\\", \\"y\\", \\"z\\", \\"x\\"] assert collapse_strings([]) == [] assert collapse_strings([\\"one\\", \\"two\\", \\"two\\", \\"three\\", \\"three\\", \\"three\\", \\"one\\", \\"one\\"]) == [\\"one\\", \\"two\\", \\"three\\", \\"one\\"] ``` # Requirements 1. Ensure the function handles an empty list gracefully. 2. Handle the input validation to accept only lists of non-empty strings; raise a `ValueError` for invalid inputs. 3. Ensure the function handles edge cases such as all elements being the same or no consecutive duplicates. # Scenario This function is useful for cleaning up user input by removing unnecessary repetition. It is particularly useful for text processing tasks where repeated words or elements should be consolidated before further analysis or storage.","solution":"def collapse_strings(strings: list[str]) -> list[str]: Collapses consecutive duplicate elements in a list of strings into a single instance. Parameters: strings (list[str]): List of strings with potential consecutive duplicates. Returns: list[str]: A list with collapsed consecutive duplicates. Raises: ValueError: If any element in the list is not a non-empty string. if not all(isinstance(s, str) and s for s in strings): raise ValueError(\\"All elements in the list must be non-empty strings\\") if not strings: return [] collapsed_list = [strings[0]] for s in strings[1:]: if s != collapsed_list[-1]: collapsed_list.append(s) return collapsed_list"},{"question":"# Problem Statement You are given a string `input_string` and an integer `word_length`. Implement the function `split_string_into_chunks(input_string: str, word_length: int) -> list`. This function should split the given string into chunks of the specified length and return them as a list of strings. If the last chunk is shorter than the specified length, include it as it is. # Input * `input_string`: A non-empty string containing any characters. * `word_length`: An integer specifying the desired length of each chunk (1 <= word_length <= len(input_string)). # Output A list of strings, with each string being a chunk of the specified length from the input string. The last chunk may be shorter if the remaining characters are fewer than the specified length. # Constraints - `input_string` can have a length of up to 10^6 characters. - The function should run in O(n) time complexity, where n is the length of the input string. - You may assume that `word_length` is always a positive integer that does not exceed the length of the input string. # Examples ```python split_string_into_chunks(\\"abcdefghij\\", 3) # Returns: [\\"abc\\", \\"def\\", \\"ghi\\", \\"j\\"] split_string_into_chunks(\\"HelloWorld\\", 5) # Returns: [\\"Hello\\", \\"World\\"] split_string_into_chunks(\\"This is a test\\", 4) # Returns: [\\"This\\", \\" is \\", \\"a te\\", \\"st\\"] split_string_into_chunks(\\"12345\\", 1) # Returns: [\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\"] ``` # Performance Requirements Your solution should efficiently handle strings of up to 10^6 characters, maintaining linear time complexity with respect to the input string\'s length.","solution":"def split_string_into_chunks(input_string: str, word_length: int) -> list: Splits the input_string into chunks of the specified word_length and returns them as a list of strings. Args: input_string (str): The string to be split. word_length (int): The length of each chunk. Returns: list: A list of strings, each of the specified word_length. The last chunk may be shorter. return [input_string[i:i+word_length] for i in range(0, len(input_string), word_length)]"},{"question":"# Coding Challenge: Efficient CSV Data Summarization Scenario You are a data engineer at a startup that processes large CSV files containing transaction records. Your current method for summarizing the data is slow and cannot handle the increasing volume efficiently. You need to write a more efficient summarization function. Task Write a function `summarize_transactions(file_path)` that efficiently reads and summarizes the transaction data from a CSV file. Expected Function Signature ```python def summarize_transactions(file_path: str) -> Dict[str, float]: file_path: path to a CSV file containing transaction records Returns a dictionary where keys are the column names and values are the sum of the values in each column. ``` Input - A string `file_path`, representing the path to a CSV file. The CSV file contains multiple columns with numerical data representing transaction amounts. Output - A dictionary where each key is a column name from the CSV, and each value is the sum of the values in that column. Constraints - The CSV file may contain millions of rows, so your algorithm must be optimized for performance. - Assume all columns in the CSV file have numerical (float) data types. - The CSV file will have a header row with column names. Example ```python # Example usage result = summarize_transactions(\\"path_to_transactions.csv\\") print(result) # Output should be of the form: # { # \\"column1\\": 123456.78, # \\"column2\\": 98765.43, # ... # } ``` Additional Information - You may assume the CSV file is well-formatted. - Consider using efficient libraries like Pandas or csv for handling the CSV file to achieve optimal performance. - Take into account edge cases such as empty CSV files or files with inconsistent row lengths.","solution":"import pandas as pd from typing import Dict def summarize_transactions(file_path: str) -> Dict[str, float]: Summarizes the transaction data by reading the CSV file and calculating the sum of each column. :param file_path: Path to the CSV file containing transaction records. :return: A dictionary where keys are the column names and values are the sum of the values in each column. df = pd.read_csv(file_path) summary = df.sum().to_dict() return {column: round(total, 2) for column, total in summary.items()}"},{"question":"# Problem Statement You are building a system that helps analyze and evaluate the performance of students based on their scores across multiple subjects. Your task is to determine the top performer among the students based on the highest average score. # Objective Write a function `find_top_performer(scores: dict) -> str` that takes a dictionary where keys represent student names and values are lists of their scores across different subjects. The function should return the name of the student with the highest average score. # Description - If multiple students have the same highest average score, return the name that appears first alphabetically. - You can assume that each student has at least one score. # Input Format - A dictionary `scores` where each key is a string representing a student name, and each value is a list of integers representing their scores (1 <= score <= 100). # Output Format - A string representing the name of the top performer. # Constraints - The number of students `m` will not exceed 100. - Each list of scores can have a length between 1 and 10. # Examples Example 1: ```python find_top_performer({ \\"Alice\\": [90, 95, 100], \\"Bob\\": [88, 92, 96], \\"Charlie\\": [90, 95, 100] }) ``` **Output:** ```python \'Alice\' ``` Example 2: ```python find_top_performer({ \\"David\\": [85, 87], \\"Eve\\": [95, 92], \\"Frank\\": [100] }) ``` **Output:** ```python \'Frank\' ``` # Edge Cases 1. Ensure that if there’s a tie in average scores, the result is the alphabetically first name. 2. Handle cases with varying lengths of score lists for different students correctly. # Scenario or Context Imagine you are developing an educational software that needs to provide real-time feedback to teachers about student performance in various subjects. This function could help in quickly identifying the top students based on their average performance across exams, allowing for efficient monitoring and encouragement of high performers.","solution":"def find_top_performer(scores: dict) -> str: Determines the student with the highest average score. :param scores: A dictionary where keys are student names and values are lists of scores. :return: The name of the student with the highest average score. top_student = None highest_avg = -1 for student, grades in scores.items(): avg_score = sum(grades) / len(grades) # Check if this student has the highest average score or if tied, appears first alphabetically if avg_score > highest_avg or (avg_score == highest_avg and student < top_student): highest_avg = avg_score top_student = student return top_student"},{"question":"# Binary Search Tree (BST) Implementation and Operations You are tasked with implementing a simplified version of a Binary Search Tree (BST) and providing methods for insertion, deletion, searching, and in-order traversal. The goal is to demonstrate your understanding of tree data structures, recursion, and algorithmic complexity. # Functional Requirements: 1. **Insertion**: Method to insert a new node with a unique key into the BST. 2. **Deletion**: Method to delete a node by its key. 3. **Search**: Method to search for a node by its key and return a boolean indicating its presence in the tree. 4. **In-order Traversal**: Method to perform in-order traversal and return the keys in a sorted list. # Input and Output Formats: - **Input**: 1. The initial list of keys to create the BST. 2. The keys for nodes to be inserted, deleted, and searched. 3. (Optional) Key for updating the in-order traversal. - **Output**: 1. For search, return `True` if the key is found, otherwise `False`. 2. For insertion and deletion, return the updated BST or relevant confirmation. 3. For in-order traversal, return the list of keys in sorted order. # Constraints: 1. Ensure that the BST properties are maintained after every operation. 2. Handle edge cases like deleting a node with one or zero children. 3. Optimize for minimal height increase during insertions when possible. # Performance Requirements: 1. Efficient insertion, deletion, and search with average time complexity of O(log n). 2. Verify the BST properties during and after each modification. # Implementation Scenario: You are required to implement the `BinarySearchTree` class with methods `insert`, `delete`, `search`, and `in_order_traversal`: ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self, keys=None): self.root = None if keys: for key in keys: self.insert(key) def insert(self, key): # Implement insertion logic pass def delete(self, key): # Implement deletion logic pass def search(self, key): # Implement search logic pass def in_order_traversal(self): # Implement in-order traversal pass ``` # Example Usage ```python # Initialize BST with initial keys bst = BinarySearchTree([15, 7, 20, 3, 9, 17, 25]) # Insert a new key bst.insert(10) # Search for a key print(bst.search(7)) # Returns: True # Delete a key bst.delete(3) # Perform in-order traversal print(bst.in_order_traversal()) # Returns: [7, 9, 10, 15, 17, 20, 25] ```","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self, keys=None): self.root = None if keys: for key in keys: self.insert(key) def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) elif key > node.key: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def search(self, key): return self._search_recursive(self.root, key) def _search_recursive(self, node, key): if node is None: return False if node.key == key: return True elif key < node.key: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def delete(self, key): self.root = self._delete_recursive(self.root, key) def _delete_recursive(self, node, key): if node is None: return node if key < node.key: node.left = self._delete_recursive(node.left, key) elif key > node.key: node.right = self._delete_recursive(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete_recursive(node.right, temp.key) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def in_order_traversal(self): result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node: self._in_order_recursive(node.left, result) result.append(node.key) self._in_order_recursive(node.right, result)"},{"question":"# Coding Assessment Question You are tasked with developing a Pathfinding Algorithm to be used in a navigation system for a robotics competition. The algorithm should find the shortest path between two points in a grid. The robot can move up, down, left, or right, but can\'t move diagonally and can\'t move through obstacles. # Objective Implement a function that takes the dimensions of the grid, start and end positions, and a list of obstacles, and returns the shortest path from the start to the end as a list of coordinates. If no path exists, return an empty list. # Requirements 1. **Input**: - `rows` (int): Number of rows in the grid. - `cols` (int): Number of columns in the grid. - `start` (tuple): The starting position as a tuple (row, col). - `end` (tuple): The ending position as a tuple (row, col). - `obstacles` (list): A list of tuples representing obstacle positions. 2. **Output**: - Returns a list of tuples representing the coordinates of the shortest path from start to end. - If no path exists, return an empty list. 3. **Constraints**: - The grid is always larger than 0 and at most 100x100. - The start and end positions are within the grid boundaries and are not obstacles. - Performance requirement: Should find the shortest path (if exists) in under 1 second for any grid size up to the maximum. # Example Usage ```python >>> shortest_path(5, 5, (0, 0), (4, 4), [(1, 1), (2, 2), (3, 3)]) [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)] >>> shortest_path(3, 3, (0, 0), (2, 2), [(1, 1)]) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] >>> shortest_path(3, 3, (0, 0), (2, 2), [(1, 1), (1, 2), (2, 1)]) [] ``` # Implementation Requirements 1. Use either Breadth-First Search (BFS) or A* algorithm to solve the shortest path problem. 2. Handle edge cases such as no available path due to obstacles blocking the way. 3. Ensure the function is optimized to handle the largest grid size efficiently. 4. Include several unittest cases to validate your implementation, covering scenarios such as: - Start and end being the same. - No available path. - Path that navigates around multiple obstacles.","solution":"from collections import deque def shortest_path(rows, cols, start, end, obstacles): Finds the shortest path in a grid from start to end avoiding obstacles. :param rows: Number of rows in the grid. :param cols: Number of columns in the grid. :param start: Starting position as a tuple (row, col). :param end: Ending position as a tuple (row, col). :param obstacles: A list of tuples representing obstacle positions. :return: List of tuples representing the shortest path or empty list if no path exists. if start == end: return [start] grid = [[0] * cols for _ in range(rows)] for obstacle in obstacles: grid[obstacle[0]][obstacle[1]] = 1 directions = [(0,1),(1,0),(0,-1),(-1,0)] # right, down, left, up queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (current, path) = queue.popleft() for direction in directions: new_row, new_col = current[0] + direction[0], current[1] + direction[1] if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: if (new_row, new_col) == end: return path + [(new_row, new_col)] queue.append(((new_row, new_col), path + [(new_row, new_col)])) visited.add((new_row, new_col)) return []"},{"question":"# Problem Statement Write a function `sum_of_unique_integers(arr: List[int]) -> int` that calculates the sum of all unique integers in a given list of integers. Function Signature ```python def sum_of_unique_integers(arr: List[int]) -> int: ``` # Input - `arr`: A list of integers where the length of the list is within the range `[0, 10^5]` and the integers are within the range `[-10^6, 10^6]`. # Output - An integer representing the sum of all unique integers in the list. An integer is considered unique if it appears exactly once in the list. # Constraints - The function should handle empty lists and lists with negative numbers. - The function should handle large lists efficiently. # Example ```python >>> sum_of_unique_integers([1, 2, 2, 3, 4]) 8 >>> sum_of_unique_integers([1, 1, 1, 1]) 0 >>> sum_of_unique_integers([7, 3, 5, 5, 3, -1]) 6 >>> sum_of_unique_integers([]) 0 ``` # Explanation 1. For `arr = [1, 2, 2, 3, 4]`, the unique integers are `1, 3, 4`, and their sum is `8`. 2. For `arr = [1, 1, 1, 1]`, there are no unique integers, so the sum is `0`. 3. For `arr = [7, 3, 5, 5, 3, -1]`, the unique integers are `7, -1`, and their sum is `6`. 4. For an empty list `arr = []`, the sum is `0`. # Notes - Your solution should aim for a time complexity of O(n). - Consider edge cases, such as lists with all identical elements, empty lists, and lists with mixed positive and negative values. # Testing Ensure your implementation is tested against various scenarios: 1. Lists with different lengths, including empty lists. 2. Lists with all identical elements. 3. Lists with mixed positive and negative values.","solution":"from typing import List def sum_of_unique_integers(arr: List[int]) -> int: Returns the sum of all unique integers in the list. An integer is considered unique if it appears exactly once in the list. from collections import Counter # Count the occurrences of each number in the list count = Counter(arr) # Sum only numbers that appear exactly once return sum(num for num, freq in count.items() if freq == 1)"},{"question":"# Sorting Yearly Sales Data Problem Statement You are analyzing sales data from multiple years and need to sort these data entries based on the total sales amount. Each year’s data includes the year and the total sales for that year. Your task is to write a function that sorts the sales data by total sales in descending order. If two years have the same total sales, they should be sorted by the year in ascending order. Requirements Implement the function `sort_sales_data` that accepts a list of dictionaries, each representing sales data for a year, and returns the list sorted by total sales in descending order and by year in ascending order when sales are equal. Inputs - A list of dictionaries, where each dictionary contains: - `year`: An integer representing the year, e.g., `2020` - `total_sales`: A float representing the total sales amount for that year, e.g., `1500.75` Output - A list of dictionaries sorted by `total_sales` in descending order. If two entries have the same `total_sales`, they should be sorted by `year` in ascending order. Example Here are some example inputs and expected outputs: ```python sales_data = [ {\\"year\\": 2020, \\"total_sales\\": 1500.75}, {\\"year\\": 2019, \\"total_sales\\": 1600.60}, {\\"year\\": 2021, \\"total_sales\\": 1500.75}, {\\"year\\": 2018, \\"total_sales\\": 1400.50}, ] assert sort_sales_data(sales_data) == [ {\\"year\\": 2019, \\"total_sales\\": 1600.60}, {\\"year\\": 2020, \\"total_sales\\": 1500.75}, {\\"year\\": 2021, \\"total_sales\\": 1500.75}, {\\"year\\": 2018, \\"total_sales\\": 1400.50}, ] sales_data = [ {\\"year\\": 2015, \\"total_sales\\": 3000.00}, {\\"year\\": 2016, \\"total_sales\\": 3000.00}, {\\"year\\": 2014, \\"total_sales\\": 4000.00}, ] assert sort_sales_data(sales_data) == [ {\\"year\\": 2014, \\"total_sales\\": 4000.00}, {\\"year\\": 2015, \\"total_sales\\": 3000.00}, {\\"year\\": 2016, \\"total_sales\\": 3000.00}, ] ``` The function should handle various edge cases and sort the data correctly based on the provided conditions. Make sure to account for floating-point precision in the total sales amounts when performing comparisons.","solution":"def sort_sales_data(sales_data): Sorts the sales data by total sales in descending order. If two entries have the same total sales, they are sorted by year in ascending order. Parameters: sales_data (list): A list of dictionaries containing \'year\' and \'total_sales\'. Returns: list: Sorted list of dictionaries. # Sorting primarily by total sales (descending) and secondarily by year (ascending) return sorted(sales_data, key=lambda x: (-x[\'total_sales\'], x[\'year\']))"},{"question":"# Problem: Unique Morse Code Words You are given a list of words where each word can be written as a combination of Morse code signals. Morse code is used to encode text characters into sequences of dots (.) and dashes (-). Your task is to determine the number of unique Morse code representations from the given list of words. Input: - A list of lowercase English words: `List[str]`. Output: - An integer representing the number of unique Morse code representations. Example: Here is a basic example to illustrate the problem: ``` Input: words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] Output: 2 Explanation: The transformation of each word to Morse code: \\"gin\\" -> \\"--...-.\\" \\"zen\\" -> \\"--...-.\\" \\"gig\\" -> \\"--...--.\\" \\"msg\\" -> \\"--...--.\\" There are 2 unique Morse code representations: \\"--...-.\\" and \\"--...--.\\" ``` The Morse code representation for each letter is given by the following array: ``` morse = [\\".-\\",\\"-...\\",\\"-.-.\\",\\"-..\\",\\".\\",\\"..-.\\",\\"--.\\",\\"....\\",\\"..\\", \\".---\\",\\"-.-\\",\\".-..\\",\\"--\\",\\"-.\\",\\"---\\",\\".--.\\",\\"--.-\\",\\".-.\\", \\"...\\",\\"-\\",\\"..-\\",\\"...-\\",\\".--\\",\\"-..-\\",\\"-.--\\",\\"--..\\"] ``` Write a function `uniqueMorseRepresentations` that solves the problem. ```python from typing import List def uniqueMorseRepresentations(words: List[str]) -> int: morse = [\\".-\\",\\"-...\\",\\"-.-.\\",\\"-..\\",\\".\\",\\"..-.\\",\\"--.\\",\\"....\\",\\"..\\", \\".---\\",\\"-.-\\",\\".-..\\",\\"--\\",\\"-.\\",\\"---\\",\\".--.\\",\\"--.-\\",\\".-.\\", \\"...\\",\\"-\\",\\"..-\\",\\"...-\\",\\".--\\",\\"-..-\\",\\"-.--\\",\\"--..\\"] char_to_morse = {chr(97 + i): morse[i] for i in range(26)} transformations = set() for word in words: morse_representation = \'\'.join(char_to_morse[char] for char in word) transformations.add(morse_representation) return len(transformations) # Example of usage if __name__ == \\"__main__\\": print(uniqueMorseRepresentations([\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"])) ``` # Constraints: - The list of words will have a length of at least 1 and at most 1000. - Each word will have a length of at least 1 and at most 12. - Each word consists only of lowercase English letters.","solution":"from typing import List def uniqueMorseRepresentations(words: List[str]) -> int: morse = [\\".-\\",\\"-...\\",\\"-.-.\\",\\"-..\\",\\".\\",\\"..-.\\",\\"--.\\",\\"....\\",\\"..\\", \\".---\\",\\"-.-\\",\\".-..\\",\\"--\\",\\"-.\\",\\"---\\",\\".--.\\",\\"--.-\\",\\".-.\\", \\"...\\",\\"-\\",\\"..-\\",\\"...-\\",\\".--\\",\\"-..-\\",\\"-.--\\",\\"--..\\"] char_to_morse = {chr(97 + i): morse[i] for i in range(26)} transformations = set() for word in words: morse_representation = \'\'.join(char_to_morse[char] for char in word) transformations.add(morse_representation) return len(transformations)"},{"question":"Question: Analyze List of Lists and Return Maximum Element # Context In this problem, you will deepen your understanding of nested lists and gain insights on how to traverse and manipulate them in Python. Nested lists can be thought of as matrices or simply lists within lists, which may vary in length. # Task Write a Python function `find_max_nested_list(nested_list)` that takes a list of lists containing numerical elements and returns the maximum element found in any of the nested lists. # Expected Function Signature ```python def find_max_nested_list(nested_list): # Your implementation here ``` # Input - `nested_list` (list of lists): Each individual list inside the `nested_list` contains one or more numerical values (integers or floats). # Output - Returns the maximum numerical value found within any of the sublists. # Constraints - Each sublist will contain at least one numerical element. - The `nested_list` itself will contain at least one sublist. - You may assume all elements are valid numerical values. # Example ```python nested_list = [[3, 4, 1], [5, 9, 2], [8, 7]] print(find_max_nested_list(nested_list)) # Expected Output: 9 ``` # Requirements - Design a solution that efficiently traverses each sublist and identifies the maximum element. - Handle nested lists of varying lengths and ensure the function returns a single numerical value accurately reflecting the maximum element found.","solution":"def find_max_nested_list(nested_list): This function takes a list of lists containing numerical elements and returns the maximum element found in any of the nested lists. max_element = float(\'-inf\') for sublist in nested_list: for item in sublist: if item > max_element: max_element = item return max_element"},{"question":"# Question: You have been given an implementation of the Segment Tree data structure that supports point updates and range sum queries. Your task is to extend this data structure by introducing a new method to determine and return the k-th smallest element in a specified subarray range. **Function Signature**: ```python def range_kth_smallest(node: Node | None, start: int, end: int, k: int) -> int: Returns the k-th smallest element in the range [start, end] of the array represented by the Segment Tree. Parameters: - node: The root node of the Segment Tree. - start: Starting index of the range (inclusive). - end: Ending index of the range (inclusive). - k: The 1-based index of the smallest element to find within the range. Returns: - The k-th smallest value of the numbers in the specified range. If the range is invalid or k is out of bounds, return -1. ``` # Input: * `node:` The Segment Tree root node built from the given array. * `start (int):` The starting index of the range (0-indexed). * `end (int):` The ending index of the range (0-indexed). * `k (int):` The 1-based index of the smallest element to find within the range. # Output: * Return the k-th smallest value of the numbers in the range `[start, end]` of the array. If the range is invalid or `k` is out of bounds, return `-1`. # Constraints: * The array contains integers, and the size will not exceed 100,000 elements. * Ensure the k-th smallest element calculation works correctly for valid ranges and values of `k`. * The function should be capable of handling edge cases properly. # Example: ```python >>> root = build_segment_tree([2, 1, 4, 5, 6, 0, 8, 9, 1, 2, 0, 6, 4, 2, 0, 6, 5, 3, 2, 7]) >>> range_kth_smallest(root, 0, 4, 3) 4 >>> range_kth_smallest(root, 6, 10, 2) 1 >>> range_kth_smallest(root, 13, 18, 4) 3 ``` **Notes**: * The k-th smallest element is the element that would be in the k-th position in the sorted array of the specified range.","solution":"class SegmentTreeNode: def __init__(self, start, end, count): self.start = start self.end = end self.count = count # Dictionary to store frequency of elements self.left = None self.right = None def build_segment_tree(arr): def build(start, end): if start == end: return SegmentTreeNode(start, end, {arr[start]: 1}) mid = (start + end) // 2 left = build(start, mid) right = build(mid + 1, end) count = merge_counts(left.count, right.count) node = SegmentTreeNode(start, end, count) node.left = left node.right = right return node def merge_counts(left_counts, right_counts): merged_counts = left_counts.copy() for key, value in right_counts.items(): if key in merged_counts: merged_counts[key] += value else: merged_counts[key] = value return merged_counts return build(0, len(arr) - 1) def query(node, start, end): if node is None or start > node.end or end < node.start: return {} if start <= node.start and end >= node.end: return node.count left_counts = query(node.left, start, end) right_counts = query(node.right, start, end) return {key: left_counts.get(key, 0) + right_counts.get(key, 0) for key in set(left_counts) | set(right_counts)} def range_kth_smallest(node, start, end, k): if start > end or k <= 0: return -1 counts = query(node, start, end) sorted_keys = sorted(counts.keys()) current_count = 0 for key in sorted_keys: current_count += counts[key] if current_count >= k: return key return -1"},{"question":"# Question: Jump Game You are given an array of non-negative integers, where each element represents the maximum number of steps you can jump forward from that position. Write a function to determine if you can reach the last index starting from the first index. Function Signature ```python def can_reach_end(jumps: list) -> bool: Determine if you can reach the last index in the jumps array. :param jumps: A list of non-negative integers representing jump lengths. :return: A boolean indicating if the last index can be reached. ``` Input - A list `jumps` of non-negative integers with 1 ≤ length of `jumps` ≤ 10^5. Output - A boolean value: `True` if you can reach the last index, `False` otherwise. Examples ```python # Example 1: # Input: [2, 3, 1, 1, 4] # Output: True # Example 2: # Input: [3, 2, 1, 0, 4] # Output: False # Example 3: # Input: [6, 2, 4, 0, 5, 1, 1, 4, 2, 3] # Output: True # Example 4: # Input: [0] # Output: True ``` Additional Notes: - You are initially positioned at the first index. - A jump to any position further than the last index is considered as reaching the last index. - The input list will never be empty. Performance Requirements - Aim for an O(n) time complexity. By solving this problem, you demonstrate knowledge of greedy algorithms and proficiency in handling array manipulations efficiently.","solution":"def can_reach_end(jumps: list) -> bool: Determine if you can reach the last index in the jumps array. :param jumps: A list of non-negative integers representing jump lengths. :return: A boolean indicating if the last index can be reached. max_reachable = 0 for i, jump in enumerate(jumps): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return max_reachable >= len(jumps) - 1"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},O={class:"card-container"},L={key:0,class:"empty-state"},R=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const Y=c(S,[["render",D],["__scopeId","data-v-b1165619"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/14.md","filePath":"drive/14.md"}'),j={name:"drive/14.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{M as __pageData,U as default};
