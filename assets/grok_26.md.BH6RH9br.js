import{_ as d,o as s,c as n,a as t,m,t as _,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},N={class:"review-content"};function E(i,e,u,c,r,a){return s(),n("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(_(u.poem.solution),1)])])])}const R=d(q,[["render",E],["__scopeId","data-v-afe7f556"]]),S=JSON.parse(`[{"question":"def longest_almost_geometric_subsequence(n: int, sequence: List[int]) -> int: Gina has recently taken an interest in \\"almost geometric progressions\\". A sequence is considered an almost geometric progression if its elements can be represented as: a[i] = a[1] * q^(i-1) + d where \`q\` is a constant ratio, \`d\` is a constant difference, and \`i\` indicates the element's position in the sequence. Given a sequence of integers, Gina wants to find the longest subsequence that is an almost geometric progression. A subsequence is derived by removing zero or more elements from the original sequence without changing the order of the remaining elements. Parameters: - n: int, representing the number of elements in the sequence - sequence: List[int], the elements of the sequence Returns: - int, representing the length of the longest subsequence that is an almost geometric progression. >>> longest_almost_geometric_subsequence(5, [2, 4, 8, 16, 32]) 5 >>> longest_almost_geometric_subsequence(6, [1, 2, 4, 8, 7, 64]) 4 >>> longest_almost_geometric_subsequence(1, [1]) 1 >>> longest_almost_geometric_subsequence(2, [1, 3]) 2 >>> longest_almost_geometric_subsequence(5, [1, 10, 20, 30, 40]) 2","solution":"def longest_almost_geometric_subsequence(n, sequence): def is_almost_geometric(subseq): if len(subseq) < 2: return True q = subseq[1] / subseq[0] d = subseq[1] - q * subseq[0] for i, val in enumerate(subseq): if not (val == subseq[0] * (q ** i) + d): return False return True max_length = 0 for i in range(n): for j in range(i + 1, n + 1): subseq = sequence[i:j] if is_almost_geometric(subseq): max_length = max(max_length, len(subseq)) return max_length # Sample Usage: # n = 5 # sequence = [2, 4, 8, 16, 32] # print(longest_almost_geometric_subsequence(n, sequence)) # Output: 5"},{"question":"from typing import List, Tuple def monitor_access_events(n: int, m: int, events: List[Tuple[int, ...]]) -> List[int]: A network administrator needs to monitor server activity across multiple data centers. You need to write a program to help the administrator aggregate these logs to determine how many unique users have accessed any servers during the monitoring period. >>> monitor_access_events(3, 5, [(1, 1001, 1), (1, 1002, 2), (2, 3), (1, 1001, 3), (2, 5)]) [2, 2] >>> monitor_access_events(1, 3, [(1, 1001, 1), (2, 2), (2, 3)]) [1, 1] >>> monitor_access_events(5, 6, [(1, 1001, 1), (1, 1002, 2), (1, 1003, 3), (1, 1004, 4), (2, 5), (1, 1002, 5)]) [4] >>> monitor_access_events(2, 4, [(1, 101, 1), (1, 102, 1), (1, 103, 2), (2, 3)]) [3] >>> monitor_access_events(5, 3, [(2, 1), (2, 2), (2, 3)]) [0, 0, 0]","solution":"def monitor_access_events(n, m, events): from collections import defaultdict # Dictionary to keep track of unique users on each server servers = defaultdict(set) # List to gather results of queries results = [] # Set to keep track of unique users globally unique_users = set() for i in range(m): event = events[i] if event[0] == 1: # Access event _, user, server = event if user not in servers[server]: servers[server].add(user) unique_users.add(user) elif event[0] == 2: # Query event _, time = event results.append(len(unique_users)) return results # Example input output n = 3 m = 5 events = [ (1, 1001, 1), (1, 1002, 2), (2, 3), (1, 1001, 3), (2, 5) ] print(monitor_access_events(n, m, events)) # Expected Output: [2, 2]"},{"question":"def max_sum_subarray_of_length_k(n: int, k: int, A: List[int]) -> int: Computes the maximum possible sum of a subarray of length exactly k, modulo 10^9 + 7. Args: n (int): The number of elements in the array. k (int): The length of the subarray. A (list of int): The array of integers. Returns: int: The maximum possible sum modulo 10^9 + 7. Example: >>> max_sum_subarray_of_length_k(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_sum_subarray_of_length_k(1, 1, [1000000000]) 1000000000 % (10**9 + 7) >>> max_sum_subarray_of_length_k(5, 2, [-1, -2, -3, -4, -5]) (-1 - 2) % (10**9 + 7) >>> max_sum_subarray_of_length_k(5, 5, [1, 2, -3, 4, 5]) 9 >>> max_sum_subarray_of_length_k(1000000, 1, [i for i in range(1, 1000001)]) 1000000 % (10**9 + 7)","solution":"def max_sum_subarray_of_length_k(n, k, A): Computes the maximum possible sum of a subarray of length exactly k, modulo 10^9 + 7. Args: n (int): The number of elements in the array. k (int): The length of the subarray. A (list of int): The array of integers. Returns: int: The maximum possible sum modulo 10^9 + 7. MOD = 10**9 + 7 current_sum = sum(A[:k]) max_sum = current_sum for i in range(n - k): current_sum = current_sum - A[i] + A[i + k] max_sum = max(max_sum, current_sum) return max_sum % MOD"},{"question":"def max_visited_cells(n: int, m: int) -> int: Returns the maximum number of cells that can be visited on an n x m grid if Saitama and Genos play optimally. >>> max_visited_cells(3, 3) 9 >>> max_visited_cells(1, 1) 1 >>> max_visited_cells(2, 2) 4 >>> max_visited_cells(4, 7) 28 >>> max_visited_cells(1000, 1000) 1000000","solution":"def max_visited_cells(n, m): Returns the maximum number of cells that can be visited on an n x m grid if Saitama and Genos play optimally. # Since both players play optimally to visit the maximum number of cells # The answer is straightforward as they will always be able to visit all cells return n * m"},{"question":"from typing import List, Tuple def max_decommissioned_paths(n: int, m: int, k: int, connections: List[Tuple[int, int, int]], secure_paths: List[Tuple[int, int]]) -> int: Determine the maximum number of secure paths which can be decommissioned without increasing the shortest latency from the central module to any other module. >>> max_decommissioned_paths(5, 6, 3, [(1, 2, 1), (1, 3, 3), (2, 4, 4), (3, 4, 2), (4, 5, 2), (3, 5, 8)], [(2, 1), (4, 3), (5, 10)]) == 1 >>> max_decommissioned_paths(4, 3, 2, [(1, 2, 2), (2, 3, 2), (3, 4, 1)], [(3, 3), (4, 5)]) == 0 >>> max_decommissioned_paths(3, 2, 2, [(1, 2, 1), (1, 3, 2)], [(2, 3), (3, 4)]) == 2","solution":"from heapq import heappop, heappush from collections import defaultdict import sys def min_latencies(n, adj): dist = [float('inf')] * (n + 1) dist[1] = 0 pq = [(0, 1)] while pq: d, u = heappop(pq) if d > dist[u]: continue for v, w in adj[u]: if dist[u] + w < dist[v]: dist[v] = dist[u] + w heappush(pq, (dist[v], v)) return dist def max_decommissioned_paths(n, m, k, connections, secure_paths): adj = defaultdict(list) secure_path_map = defaultdict(list) for u, v, x in connections: adj[u].append((v, x)) adj[v].append((u, x)) secure_paths_list = [] for s, y in secure_paths: secure_paths_list.append((s, y)) secure_path_map[s].append(y) secure_paths_list.sort(key=lambda x: x[1]) # Sort based on latency min_dists = min_latencies(n, adj) count_decommissioned = 0 for s, y in secure_paths_list: if y > min_dists[s]: count_decommissioned += 1 return count_decommissioned"},{"question":"def minimum_stops(n: int, a: List[int]) -> int: Determines the minimum number of stops required to deliver supplies to all space stations. Parameters: n (int): The number of space stations. a (list of int): The amount of supplies required by each space station. Returns: int: The minimum number of stops required. pass # Unit tests def test_example(): assert minimum_stops(4, [3, 2, 4, 1]) == 4 def test_all_ones(): assert minimum_stops(5, [1, 1, 1, 1, 1]) == 5 def test_varied_supplies(): assert minimum_stops(3, [5, 10, 15]) == 3 def test_single_station(): assert minimum_stops(1, [10]) == 1 def test_two_stations(): assert minimum_stops(2, [30, 40]) == 2","solution":"def minimum_stops(n, a): Returns the minimum number of stops required to deliver supplies to all space stations. Parameters: n (int): The number of space stations. a (list of int): The amount of supplies required by each space station. Returns: int: The minimum number of stops required. # Each space station needs a separate stop because each requires a unique amount of supplies return n"},{"question":"from collections import defaultdict, deque def is_balanced_forest(n, m, edges): Determine if the given forest is balanced. Args: n (int): Number of vertices m (int): Number of edges edges (List[Tuple[int, int]]): List of edges Returns: str: \\"YES\\" if the forest is balanced, otherwise \\"NO\\" Example: >>> is_balanced_forest(6, 4, [(1, 2), (1, 3), (4, 5), (4, 6)]) \\"YES\\" >>> is_balanced_forest(7, 5, [(1, 2), (1, 3), (3, 4), (4, 5), (5, 6)]) \\"NO\\"","solution":"from collections import defaultdict, deque def is_balanced_forest(n, m, edges): if n == 1: # A single node is always balanced return \\"YES\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(node): queue = deque([(node, None, 0)]) # (vertex, parent, depth) depths = defaultdict(list) while queue: v, parent, depth = queue.popleft() children = 0 for neighbor in graph[v]: if neighbor != parent: queue.append((neighbor, v, depth + 1)) children += 1 if children == 0: # It's a leaf depths[depth].append(v) return depths visited = set() for i in range(1, n + 1): if i not in visited: depths = bfs(i) if len(depths) > 1 and len(set(depths.keys())) != 1: return \\"NO\\" visited.update(node for depth in depths.values() for node in depth) return \\"YES\\""},{"question":"def longest_binary_gap(N: int) -> int: Returns the length of the longest binary gap within the binary representation of a positive integer N. Parameters: N (int): A positive integer (1 ≤ N ≤ 2,147,483,647) Returns: int: The length of the longest binary gap Examples: >>> longest_binary_gap(9) 2 >>> longest_binary_gap(529) 4 >>> longest_binary_gap(20) 1 >>> longest_binary_gap(15) 0 >>> longest_binary_gap(32) 0 pass def test_example_1(): assert longest_binary_gap(9) == 2 def test_example_2(): assert longest_binary_gap(529) == 4 def test_example_3(): assert longest_binary_gap(20) == 1 def test_example_4(): assert longest_binary_gap(15) == 0 def test_example_5(): assert longest_binary_gap(32) == 0 def test_no_gap(): assert longest_binary_gap(1) == 0 def test_single_gap(): assert longest_binary_gap(18) == 2 def test_multiple_gaps(): assert longest_binary_gap(1041) == 5","solution":"def longest_binary_gap(N: int) -> int: Returns the length of the longest binary gap within the binary representation of a positive integer N. # Convert the integer N to binary representation (removing the '0b' prefix) binary_representation = bin(N)[2:] # Initialize variables to track the longest gap and the current gap length longest_gap = 0 current_gap = 0 found_one = False # Iterate through the binary representation for char in binary_representation: if char == '1': # If current character is a '1', update longest_gap and reset current_gap if found_one and current_gap > longest_gap: longest_gap = current_gap current_gap = 0 found_one = True elif char == '0' and found_one: # If current character is a '0', increment current_gap current_gap += 1 return longest_gap"},{"question":"def max_sum_cards(cards): You have n cards placed in a row, each card has a certain integer written on it. You have to play a game with these cards using the following rules: 1. You take turns alternately with your opponent. 2. On each turn, a player can take one card from either the beginning or the end of the current row of cards. 3. The game ends when there are no more cards left to take. 4. The player with the highest sum of the integers on the cards they have taken is the winner. Both players are perfect and will play optimally. Determine the maximum possible sum that you can achieve if you take the first turn. >>> max_sum_cards([5]) 5 >>> max_sum_cards([1, 2]) 2 >>> max_sum_cards([1, 100, 1, 100]) 200 >>> max_sum_cards([1, 2, 3, 4, 5]) 9 >>> max_sum_cards([5, 4, 3, 2, 1]) 9 >>> max_sum_cards([3, 9, 1, 2]) 11 >>> max_sum_cards([8, 15, 3, 7]) 22","solution":"def max_sum_cards(cards): # Use dynamic programming to find the max sum achievable by the first player n = len(cards) dp = [[0] * n for _ in range(n)] for length in range(1, n+1): for i in range(n-length+1): j = i + length - 1 if i == j: dp[i][j] = cards[i] else: take_start = cards[i] + (sum(cards[i+1:j+1]) - dp[i+1][j]) take_end = cards[j] + (sum(cards[i:j]) - dp[i][j-1]) dp[i][j] = max(take_start, take_end) return dp[0][n-1]"},{"question":"from typing import List def generate_balancing_plate_numbers(n: int) -> List[str]: Generate n distinct 7-digit balancing license plate numbers. A balancing license plate number is defined as a number where the sum of the first three digits is equal to the sum of the last three digits. Args: n (int): The number of distinct balancing license plate numbers to generate. Returns: List[str]: A list of n balancing license plate numbers. Example: >>> generate_balancing_plate_numbers(5) ['1234321', '9010991', '4569654', '2302332', '6702196'] import sys from io import StringIO from typing import List from solution import generate_balancing_plate_numbers def test_generate_balancing_plate_numbers(): original_stdout = sys.stdout sys.stdout = StringIO() generate_balancing_plate_numbers(5) output = sys.stdout.getvalue().strip().split(\\"n\\") sys.stdout = original_stdout # Check if the output has exactly 5 numbers assert len(output) == 5 # Check if all numbers are unique assert len(set(output)) == 5 # Check if all numbers are 7 digits long for number in output: assert len(number) == 7 # Check if each number is balancing for number in output: first_part = sum(int(digit) for digit in number[:3]) second_part = sum(int(digit) for digit in number[-3:]) assert first_part == second_part def test_generate_balancing_plate_numbers_edge_case(): original_stdout = sys.stdout sys.stdout = StringIO() generate_balancing_plate_numbers(0) output = sys.stdout.getvalue().strip().split(\\"n\\") sys.stdout = original_stdout # Since n=0, there should be no output assert output == ['']","solution":"def generate_balancing_plate_numbers(n): balancing_numbers = [] for a in range(10): for b in range(10): for c in range(10): for d in range(10): if len(balancing_numbers) >= n: break num1 = a + b + c num2 = c + b + a if num1 == num2: plate_number = f\\"{a}{b}{c}{d}{c}{b}{a}\\" if plate_number not in balancing_numbers: balancing_numbers.append(plate_number) for num in balancing_numbers[:n]: print(num) # Example usage: # generate_balancing_plate_numbers(5)"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of the grid while avoiding obstacles. The robot can only move either right or down at any point in time. Args: grid (List[List[int]]): 2D array representing the grid where \`0\` indicates a free cell and \`1\` indicates an obstacle. Returns: int: Number of unique paths from the top-left to the bottom-right of the grid. Examples: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 1, 0], [0, 0, 0]]) 0 pass # Test cases to validate the solution import pytest def test_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 6 def test_with_obstacles(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_start_obstacle(): grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_end_obstacle(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 1] ] assert unique_paths_with_obstacles(grid) == 0 def test_large_grid(): grid = [ [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 3 def test_single_cell(): grid = [ [0] ] assert unique_paths_with_obstacles(grid) == 1 def test_single_cell_obstacle(): grid = [ [1] ] assert unique_paths_with_obstacles(grid) == 0 if __name__ == \\"__main__\\": pytest.main()","solution":"def unique_paths_with_obstacles(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] # Example usage grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] print(unique_paths_with_obstacles(grid)) # Output: 2"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the characters of a string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: str: \\"YES\\" if the string's characters can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\" >>> can_form_palindrome(\\"aabbcc\\") \\"YES\\" pass # Implement this function def solve(test_cases: List[str]) -> List[str]: Solves multiple test cases for the string palindrome rearrangement problem. Args: test_cases (List[str]): List of strings to be tested. Returns: List[str]: List of results corresponding to each test case, \\"YES\\" or \\"NO\\". >>> solve([\\"aabb\\", \\"abc\\", \\"aabbcc\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solve([\\"a\\", \\"aa\\", \\"ab\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve([\\"abcd\\", \\"abcabc\\", \\"aabbccdd\\"]) [\\"NO\\", \\"YES\\", \\"YES\\"] pass # Implement this function","solution":"def can_form_palindrome(s): Determines if the characters of a string can be rearranged to form a palindrome. from collections import Counter # Count the frequencies of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # A string can form a palindrome if it has at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\" def solve(test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Given a grid of 0s and 1s, find the largest rectangle containing only 1s. >>> maximalRectangle([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) == 6 >>> maximalRectangle([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 9 >>> maximalRectangle([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 >>> maximalRectangle([ [0, 1, 1], [1, 1, 1], [0, 1, 1] ]) == 6 >>> maximalRectangle([ [1, 0, 1, 1, 1] ]) == 3 >>> maximalRectangle([ [1], [1], [1], [0], [1] ]) == 3","solution":"def largestRectangleArea(heights): Helper function to find the largest rectangle in a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def maximalRectangle(matrix): Given a grid of 0s and 1s, finds the largest rectangle containing only 1s. if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 heights = [0] * m for i in range(n): for j in range(m): if matrix[i][j] == 0: heights[j] = 0 else: heights[j] += 1 max_area = max(max_area, largestRectangleArea(heights)) return max_area"},{"question":"def get_word_weight(word: str) -> int: Calculates the weight of a given word. >>> get_word_weight(\\"apple\\") 50 >>> get_word_weight(\\"dog\\") 26 # Your code here def highest_weight_word(words: str) -> str: Returns the word with the highest weight from a space-separated list of words. In case of a tie, returns the lexicographically first word. >>> highest_weight_word(\\"dog cat zebra apple\\") \\"zebra\\" >>> highest_weight_word(\\"aaa bbb ccc ddd\\") \\"ddd\\" # Your code here","solution":"def get_word_weight(word): Calculates the weight of a given word. return sum(ord(char) - ord('a') + 1 for char in word) def highest_weight_word(words): Returns the word with the highest weight. In case of a tie, returns the lexicographically first word. word_list = words.split() max_weight = -1 result_word = \\"\\" for word in word_list: weight = get_word_weight(word) if weight > max_weight or (weight == max_weight and word < result_word): max_weight = weight result_word = word return result_word"},{"question":"def maximal_rectangle(matrix: List[List[str]]) -> int: Find the largest rectangle containing only 1's and return its area. >>> maximal_rectangle([ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ...]) 6 >>> maximal_rectangle([]) 0 >>> maximal_rectangle([ ... ['0', '0', '0'], ... ['0', '0', '0'] ...]) 0 >>> maximal_rectangle([ ... ['1', '1'], ... ['1', '1'] ...]) 4 >>> maximal_rectangle([ ... ['1', '0', '1', '1', '1'] ...]) 3 >>> maximal_rectangle([ ... ['1'], ... ['1'], ... ['0'], ... ['1'], ... ['1'], ... ['1'] ...]) 3 >>> maximal_rectangle([ ... ['1', '1', '1'], ... ['1', '1', '0'], ... ['1', '0', '0'] ...]) 4","solution":"def maximal_rectangle(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m max_area = 0 for row in matrix: for i in range(m): if row[i] == '1': heights[i] += 1 else: heights[i] = 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): stack = [] max_area = 0 heights.append(0) # Add a zero to make sure all elements are processed for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Restore the original list return max_area"},{"question":"def count_unique_pairs_with_same_product(test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given a list of integers and your task is to determine how many unique pairs of consecutive elements in the list have the same product when multiplied together. The first line of the input contains an integer 't' (1 ≤ t ≤ 50) – the number of test cases. The first line of each test case contains an integer 'n' (2 ≤ n ≤ 100) – the number of integers in the list. The second line of each test case contains 'n' integers 'a_1, a_2, ..., a_n' (1 ≤ a_i ≤ 1000) separated by spaces. For each test case, output the number of unique pairs of consecutive elements in the list that have the same product when multiplied together. Example >>> count_unique_pairs_with_same_product([(5, [2, 3, 6, 12, 4]), (4, [1, 4, 4, 16])]) [0, 0] >>> count_unique_pairs_with_same_product([(3, [1, 2, 3]), (2, [1000, 1000])]) [0, 0] >>> count_unique_pairs_with_same_product([(3, [2, 2, 2]), (4, [3, 1, 3, 1])]) [1, 1] >>> count_unique_pairs_with_same_product([(5, [2, 5, 10, 2, 5]), (6, [1, 2, 2, 1, 2, 2])]) [1, 2]","solution":"def count_unique_pairs_with_same_product(test_cases): results = [] for case in test_cases: n, lst = case products = {} for i in range(n - 1): product = lst[i] * lst[i + 1] if product in products: products[product] += 1 else: products[product] = 1 count = sum(1 for x in products.values() if x > 1) results.append(count) return results"},{"question":"from typing import List def filter_text(paragraph: List[str], bad_words: List[str]) -> List[str]: Create a function that takes a list of strings representing a paragraph of text and a list of \\"bad\\" words. Your task is to implement a filtering system that replaces every occurrence of a bad word in the provided text with asterisks (*) of the same length as the bad word. Words are case-insensitive but must preserve their original case in the output. >>> filter_text([ \\"This is a bad example of a bad sentence.\\", \\"Another bad example: badly written.\\" ], [\\"bad\\", \\"example\\"]) [\\"This is a *** ******* of a *** sentence.\\", \\"Another *** *******: badly written.\\"] >>> filter_text([ \\"Bad words are not good.\\", \\"BAD WORDS SHOULD BE FILTERED.\\" ], [\\"bad\\", \\"words\\"]) [\\"*** ***** are not good.\\", \\"*** ***** SHOULD BE FILTERED.\\"]","solution":"from typing import List import re def filter_text(paragraph: List[str], bad_words: List[str]) -> List[str]: def replace_bad_word(match): word = match.group() return '*' * len(word) bad_words_regex = re.compile(r'b(' + '|'.join(map(re.escape, bad_words)) + r')b', re.IGNORECASE) filtered_paragraph = [] for line in paragraph: filtered_line = bad_words_regex.sub(replace_bad_word, line) filtered_paragraph.append(filtered_line) return filtered_paragraph"},{"question":"def count_and_find_kth_brother(n: int, words: List[str], target: str, k: int) -> Tuple[int, Optional[str]]: Count the number of brother words the target word has in the list and find the k-th brother word in alphabetical order. >>> count_and_find_kth_brother(6, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"sinister\\"], \\"listen\\", 2) (3, \\"inlets\\") >>> count_and_find_kth_brother(4, [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"pear\\", 1) (0, None) >>> count_and_find_kth_brother(3, [\\"act\\", \\"cat\\", \\"dog\\"], \\"tac\\", 1) (2, \\"act\\") >>> count_and_find_kth_brother(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\"], \\"abc\\", 5) (2, None) >>> count_and_find_kth_brother(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\"], \\"abc\\", 4) (4, \\"cab\\")","solution":"def count_and_find_kth_brother(n, words, target, k): def is_brother(word1, word2): return sorted(word1) == sorted(word2) and word1 != word2 brother_words = [word for word in words if is_brother(word, target)] brother_words.sort() count = len(brother_words) kth_brother = brother_words[k-1] if k <= count else None return count, kth_brother"},{"question":"from typing import List, Tuple from collections import defaultdict from math import factorial def count_valid_orders(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the number of distinct valid execution orders for the given tree of tasks. Args: n (int): Number of tasks. edges (List[Tuple[int, int]]): List of edges representing dependencies between tasks. Returns: int: The number of distinct valid execution orders. Example: >>> count_valid_orders(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 8 >>> count_valid_orders(1, []) 1 >>> count_valid_orders(2, [(1, 2)]) 1","solution":"from math import factorial from collections import defaultdict def count_valid_orders(n, edges): def dfs(node): ways = 1 size = 0 for neighbor in tree[node]: sub_ways, sub_size = dfs(neighbor) ways *= sub_ways ways *= comb(size + sub_size, sub_size) size += sub_size return ways, size + 1 def comb(n, k): if k == 0 or k == n: return 1 return factorial(n) // (factorial(k) * factorial(n - k)) tree = defaultdict(list) for u, v in edges: tree[u].append(v) total_ways, total_size = dfs(1) return total_ways"},{"question":"from typing import List def count_smaller_elements_to_right(arr: List[int]) -> List[int]: Given an array arr, return a list where each element represents the number of elements to its right that are smaller than itself. >>> count_smaller_elements_to_right([5, 2, 6, 1, 3]) [3, 1, 2, 0, 0] >>> count_smaller_elements_to_right([4, 3, 2, 1]) [3, 2, 1, 0] def process_test_cases(test_cases: List[tuple]) -> List[List[int]]: Given multiple test cases, process each and return their corresponding results. >>> process_test_cases([(5, [5, 2, 6, 1, 3]), (4, [4, 3, 2, 1])]) [[3, 1, 2, 0, 0], [3, 2, 1, 0]]","solution":"def count_smaller_elements_to_right(arr): Given an array arr, return a list where each element represents the number of elements to its right that are smaller than itself. n = len(arr) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if arr[j] < arr[i]: count += 1 result[i] = count return result def process_test_cases(test_cases): Given multiple test cases, process each and return their corresponding results. results = [] for n, arr in test_cases: results.append(count_smaller_elements_to_right(arr)) return results"},{"question":"def min_operations_to_increasing(arr: List[int], k: int) -> int: Returns the minimum number of operations required to make the array strictly increasing, or -1 if it's not possible with at most k operations. >>> min_operations_to_increasing([1, 2, 3], 3) == 0 >>> min_operations_to_increasing([3, 2, 1], 6) == 6 >>> min_operations_to_increasing([1, 2, 2], 3) == 1 >>> min_operations_to_increasing([4, 3, 2], 5) == -1 >>> min_operations_to_increasing([1, 1, 1], 3) == 3","solution":"def min_operations_to_increasing(arr, k): Returns the minimum number of operations required to make the array strictly increasing, or -1 if it's not possible with at most k operations. n = len(arr) operations = 0 for i in range(1, n): if arr[i] <= arr[i-1]: needed_increments = arr[i-1] - arr[i] + 1 arr[i] += needed_increments operations += needed_increments if operations > k: return -1 return operations if operations <= k else -1"},{"question":"from typing import List def ruler_of_forest(n: int, m: int, creatures: List[List[int]], abilities: List[int]) -> int: Determine the creature who would become the ruler of the forest after n duels. Parameters: n (int): Number of creatures in the forest. m (int): Number of different abilities. creatures (List[List[int]]): Ability values of each creature. abilities (List[int]): The order of abilities chosen for duels. Returns: int: The index of the creature who becomes the ruler of the forest (1-based index). Examples: >>> ruler_of_forest(4, 2, [[10, 15], [20, 5], [25, 30], [10, 40]], [1, 2, 2, 1]) 3 >>> ruler_of_forest(3, 3, [[5, 15, 25], [20, 10, 30], [10, 25, 35]], [1, 2, 3]) 2 >>> ruler_of_forest(3, 2, [[10, 20], [20, 5], [30, 15]], [1, 1, 1]) 3 >>> ruler_of_forest(3, 2, [[10, 30], [20, 5], [30, 25]], [1, 2, 1]) 3 # Implementation goes here","solution":"def find_ruler(n, m, creatures, abilities): current_creatures = list(range(n)) # index of creatures still in the forest for ability in abilities: ability -= 1 # converting to 0-based index # Perform duels for the current ability new_creatures = [] while len(current_creatures) > 1: for i in range(0, len(current_creatures) - 1, 2): if creatures[current_creatures[i]][ability] > creatures[current_creatures[i + 1]][ability]: new_creatures.append(current_creatures[i]) else: new_creatures.append(current_creatures[i + 1]) if len(current_creatures) % 2 == 1: new_creatures.append(current_creatures[-1]) current_creatures = new_creatures new_creatures = [] return current_creatures[0] + 1 # converting back to 1-based index # Helper function to initiate the process def ruler_of_forest(n, m, creatures, abilities): return find_ruler(n, m, creatures, abilities)"},{"question":"def min_operations_to_identical_rows(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of operations required to make all rows of the grid identical. >>> min_operations_to_identical_rows(2, 2, [\\"AA\\", \\"AA\\"]) 0 >>> min_operations_to_identical_rows(2, 2, [\\"AA\\", \\"BB\\"]) 2 >>> min_operations_to_identical_rows(3, 1, [\\"A\\", \\"A\\", \\"A\\"]) 0 >>> min_operations_to_identical_rows(4, 4, [\\"AABA\\", \\"BBAA\\", \\"AAAB\\", \\"BBAA\\"]) 6 >>> min_operations_to_identical_rows(4, 4, [\\"ABAB\\", \\"BABA\\", \\"ABAB\\", \\"BABA\\"]) 8","solution":"def min_operations_to_identical_rows(n, m, grid): def calc_changes(row1, row2): return sum(r1 != r2 for r1, r2 in zip(row1, row2)) min_operations = float('inf') for target_row in grid: current_operations = sum(calc_changes(target_row, row) for row in grid) min_operations = min(min_operations, current_operations) return min_operations"},{"question":"def min_streetlights(grid: List[str]) -> int: Determine the minimum number of streetlights required to illuminate all the street cells in the grid. Args: grid (List[str]): A list of strings representing the grid, where 'S' is a street and 'B' is a building. Returns: int: The minimum number of streetlights required. >>> grid = [ ... \\"SBBB\\", ... \\"SSSB\\", ... \\"BSSS\\", ... \\"SSBB\\" ... ] >>> min_streetlights(grid) 2 >>> grid = [ ... \\"SSSS\\", ... \\"SSSS\\", ... \\"SSSS\\", ... \\"SSSS\\" ... ] >>> min_streetlights(grid) 1 >>> grid = [ ... \\"BBBB\\", ... \\"BBBB\\", ... \\"BBBB\\", ... \\"BBBB\\" ... ] >>> min_streetlights(grid) 0 >>> grid = [ ... \\"SBSB\\", ... \\"BSBS\\", ... \\"SBSB\\", ... \\"BSBS\\" ... ] >>> min_streetlights(grid) 4 >>> grid = [ ... \\"S\\" ... ] >>> min_streetlights(grid) 1 >>> grid = [ ... \\"B\\" ... ] >>> min_streetlights(grid) 0","solution":"def min_streetlights(grid): m = len(grid) n = len(grid[0]) streetlights = 0 # To count the number of streetlights placed illum_rows = [False] * m # Track if a row is already lit by a streetlight illum_cols = [False] * n # Track if a column is already lit by a streetlight for i in range(m): for j in range(n): if grid[i][j] == 'S' and not illum_rows[i] and not illum_cols[j]: # Place a streetlight here streetlights += 1 # Illuminate the entire row until B or grid boundary k = j while k < n and grid[i][k] != 'B': illum_cols[k] = True k += 1 # Illuminate the entire column until B or grid boundary k = i while k < m and grid[k][j] != 'B': illum_rows[k] = True k += 1 return streetlights"},{"question":"def min_trails(t: int, d: int, c: int, trails: List[Tuple[int, int]]) -> int: Calculate the minimum number of trails a team needs to complete to meet the required difficulty points and checkpoints. If it's not possible, return -1. >>> min_trails(3, 8, 7, [(4, 5), (2, 4), (6, 3)]) == 2 >>> min_trails(2, 10, 10, [(1, 1), (2, 2)]) == -1 >>> min_trails(2, 5, 3, [(5, 3), (3, 2)]) == 1 >>> min_trails(3, 10, 6, [(3, 2), (3, 2), (4, 2)]) == 3 >>> min_trails(4, 7, 5, [(1, 1), (6, 4), (2, 2), (3, 4)]) == 2","solution":"from itertools import combinations def min_trails(t, d, c, trails): Calculate the minimum number of trails a team needs to complete to meet the required difficulty points and checkpoints. If it's not possible, return -1. for i in range(1, t + 1): for comb in combinations(trails, i): sum_difficulty = sum(trail[0] for trail in comb) sum_checkpoints = sum(trail[1] for trail in comb) if sum_difficulty >= d and sum_checkpoints >= c: return i return -1 # Example usage: # t = 3 # d = 8 # c = 7 # trails = [(4, 5), (2, 4), (6, 3)] # print(min_trails(t, d, c, trails)) # Output: 2"},{"question":"def largest_secure_area(n: int, grid: List[List[int]]) -> int: Determine the largest possible k for which there exists at least one secure area of size k × k in the museum. >>> largest_secure_area(5, [ ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [0, 0, 0, 0, 0] ... ]) == 2 >>> largest_secure_area(3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 3 >>> largest_secure_area(3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0 >>> largest_secure_area(4, [ ... [1, 0, 0, 1], ... [0, 0, 0, 1], ... [0, 0, 0, 1], ... [1, 1, 1, 1] ... ]) == 2 >>> largest_secure_area(2, [ ... [0, 0], ... [0, 0] ... ]) == 2 >>> largest_secure_area(3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1","solution":"def largest_secure_area(n, grid): # Initialize a DP table with dimensions (n+1)x(n+1) to facilitate boundary conditions dp = [[0] * (n + 1) for _ in range(n + 1)] max_k = 0 # Variable to store the maximum k found # Iterate through each cell in the grid for i in range(1, n + 1): for j in range(1, n + 1): # If current cell is a secure room if grid[i - 1][j - 1] == 0: # Calculate the size of the largest square subgrid ending at (i, j) dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 # Update the max_k if we found a larger square max_k = max(max_k, dp[i][j]) return max_k # Input reading and main function are omitted as per the task requirements"},{"question":"from typing import List def largestNumber(nums: List[int]) -> str: Given an array of non-negative integers, form the largest possible integer by concatenating them. >>> largestNumber([10, 2]) \\"210\\" >>> largestNumber([3, 30, 34, 5, 9]) \\"9534330\\" >>> largestNumber([0, 0]) \\"0\\" >>> largestNumber([5]) \\"5\\" >>> largestNumber([12, 121]) \\"12121\\" >>> largestNumber([0, 0, 1]) \\"100\\" pass def test_example_1(): assert largestNumber([10, 2]) == \\"210\\" def test_example_2(): assert largestNumber([3, 30, 34, 5, 9]) == \\"9534330\\" def test_all_zeros(): assert largestNumber([0, 0]) == \\"0\\" def test_single_element(): assert largestNumber([5]) == \\"5\\" def test_multiple_same_digits(): assert largestNumber([12, 121]) == \\"12121\\" def test_leading_zero_case(): assert largestNumber([0, 0, 1]) == \\"100\\" def test_larger_input(): large_input = [i for i in range(10**3, 0, -1)] result = largestNumber(large_input) # Specific order is difficult to predict here but it won't have leading zeros assert result[0] != \\"0\\" def test_edge_case(): assert largestNumber([999, 9, 99, 911]) == \\"999999911\\"","solution":"from functools import cmp_to_key def largestNumber(nums): Forms the largest number from the list of non-negative integers. # Custom comparator function def compare(a, b): if a + b > b + a: return -1 else: return 1 # Convert the list of integers to strings for comparison nums_str = list(map(str, nums)) # Sort the array with the custom comparator sorted_nums = sorted(nums_str, key=cmp_to_key(compare)) # Join the sorted strings result = ''.join(sorted_nums) # Edge case - when the largest number is '0', in cases like [0, 0] if result[0] == '0': return '0' return result"},{"question":"from typing import List def longest_peak_sequence(heights: List[int]) -> int: Function to find the length of the longest peak sequence in an array of plant heights. A peak sequence is one that strictly increases to a peak and then strictly decreases. >>> longest_peak_sequence([1, 3, 2, 1, 5, 6, 4, 2]) 5 >>> longest_peak_sequence([1, 2, 3, 4, 5]) 0 >>> longest_peak_sequence([5, 4, 3, 2, 1]) 0 >>> longest_peak_sequence([1, 3, 2, 1, 4, 5, 3, 2]) 5 >>> longest_peak_sequence([3, 2, 1, 4, 5, 3, 2]) 5 >>> longest_peak_sequence([1, 2, 3, 4, 3, 1]) 6 >>> longest_peak_sequence([1, 2, 3, 3, 2, 1]) 0 >>> longest_peak_sequence([1, 3, 1]) 3","solution":"def longest_peak_sequence(heights): Function to find the length of the longest peak sequence in an array of plant heights. A peak sequence is one that strictly increases to a peak and then strictly decreases. if len(heights) < 3: return 0 longest_peak = 0 n = len(heights) for i in range(1, n - 1): if heights[i - 1] < heights[i] > heights[i + 1]: # peak condition left = i - 1 while left > 0 and heights[left - 1] < heights[left]: left -= 1 right = i + 1 while right < n - 1 and heights[right] > heights[right + 1]: right += 1 current_peak_length = right - left + 1 longest_peak = max(longest_peak, current_peak_length) return longest_peak"},{"question":"def exist(board: List[List[str]], word: str) -> str: Determine if the word exists in the matrix by moving left, right, up, or down starting from any cell. Each cell can only be used once in each path. >>> exist([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], \\"ABCCED\\") == \\"YES\\" >>> exist([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], \\"SEE\\") == \\"YES\\" >>> exist([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], \\"ABCB\\") == \\"NO\\"","solution":"def exist(board, word): n, m = len(board), len(board[0]) def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= n or y < 0 or y >= m or board[x][y] != word[index]: return False temp, board[x][y] = board[x][y], '#' found = (dfs(x+1, y, index+1) or dfs(x-1, y, index+1) or dfs(x, y+1, index+1) or dfs(x, y-1, index+1)) board[x][y] = temp return found for i in range(n): for j in range(m): if dfs(i, j, 0): return \\"YES\\" return \\"NO\\""},{"question":"def merge_sort(arr: List[str]) -> List[str]: Implement Merge Sort algorithm to sort an array of strings in ascending lexicographical order if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[str], right: List[str]) -> List[str]: Helper function to merge two sorted arrays merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 while i < len(left): merged.append(left[i]) i += 1 while j < len(right): merged.append(right[j]) j += 1 return merged def sort_strings(n: int, strings: List[str]) -> List[str]: Sort an array of n strings using the Merge Sort algorithm. >>> sort_strings(5, [\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\", \\"mango\\"]) [\\"apple\\", \\"banana\\", \\"grape\\", \\"mango\\", \\"orange\\"] >>> sort_strings(3, [\\"zebra\\", \\"apple\\", \\"yellow\\"]) [\\"apple\\", \\"yellow\\", \\"zebra\\"] return merge_sort(strings)","solution":"def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 while i < len(left): merged.append(left[i]) i += 1 while j < len(right): merged.append(right[j]) j += 1 return merged def sort_strings(n, strings): return merge_sort(strings)"},{"question":"def min_total_distance(n: int, m: int, q: int, transfers: List[Tuple[int, int, int, int]]) -> int: Calculate the minimum total distance required to complete all transfers. Parameters: n : int : Number of floors m : int : Floor change multiplier q : int : Number of box transfers transfers : List of tuples : Each tuple contains (f1, r1, f2, r2) representing a transfer Returns: int : Minimum total distance required >>> min_total_distance(3, 5, 2, [(1, 2, 2, 3), (3, 4, 1, 1)]) 19 pass","solution":"def min_total_distance(n, m, q, transfers): Calculate the minimum total distance required to complete all transfers. Parameters: n (int): Number of floors m (int): Floor change multiplier q (int): Number of box transfers transfers (list of tuples): Each tuple contains (f1, r1, f2, r2) representing a transfer Returns: int: Minimum total distance required total_distance = 0 for f1, r1, f2, r2 in transfers: room_distance = abs(r1 - r2) floor_distance = abs(f1 - f2) * m total_distance += room_distance + floor_distance return total_distance"},{"question":"def remove_divisible_and_unique(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Form an array B from A that contains only the unique elements of A while preserving their order of first occurrence. Remove all occurrences of integers from B which are divisible by d. Args: t: int - number of test cases test_cases: List[Tuple[int, int, List[int]]] - list of tuples containing: n: int - number of elements in array A d: int - the divisor A: List[int] - the elements of the array A Returns: List[List[int]] - resulting arrays for each test case Example: >>> remove_divisible_and_unique(1, [(7, 3, [1, 2, 3, 2, 4, 3, 5])]) [[1, 2, 4, 5]] >>> remove_divisible_and_unique(2, [(7, 3, [1, 2, 3, 2, 4, 3, 5]), (6, 2, [5, 4, 4, 2, 8, 5])]) [[1, 2, 4, 5], [5]]","solution":"def remove_divisible_and_unique(t, test_cases): results = [] for i in range(t): n, d, A = test_cases[i] seen = set() B = [] for num in A: if num not in seen: if num % d != 0: B.append(num) seen.add(num) results.append(B) return results"},{"question":"def can_assign_shifts(test_cases): Determine whether it is possible to assign employees to shifts such that all shifts are covered and no employee is assigned to more than one shift. >>> input_string = \\"2n3 6n2 2 2n2 2n3 1\\" >>> test_cases = process_input(input_string) >>> can_assign_shifts(test_cases) [\\"YES\\", \\"NO\\"] >>> input_string = \\"1n4 10n2 3 1 4\\" >>> test_cases = process_input(input_string) >>> can_assign_shifts(test_cases) [\\"YES\\"] >>> input_string = \\"1n4 5n2 2 1 3\\" >>> test_cases = process_input(input_string) >>> can_assign_shifts(test_cases) [\\"NO\\"] >>> input_string = \\"1n1 1n1\\" >>> test_cases = process_input(input_string) >>> can_assign_shifts(test_cases) [\\"YES\\"] >>> input_string = \\"1n100 5000n\\" + \\" \\".join(\\"1\\" for _ in range(100)) >>> test_cases = process_input(input_string) >>> can_assign_shifts(test_cases) [\\"YES\\"] >>> input_string = \\"1n100 50n\\" + \\" \\".join(\\"1\\" for _ in range(100)) >>> test_cases = process_input(input_string) >>> can_assign_shifts(test_cases) [\\"NO\\"] def process_input(input_string): Process the input string and convert it into test cases. >>> input_string = \\"2n3 6n2 2 2n2 2n3 1\\" >>> process_input(input_string) [(3, 6, [2, 2, 2]), (2, 2, [3, 1])]","solution":"def can_assign_shifts(test_cases): results = [] for n, m, shifts in test_cases: total_required_employees = sum(shifts) if total_required_employees <= m: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, m = map(int, lines[index].split()) shifts = list(map(int, lines[index + 1].split())) test_cases.append((n, m, shifts)) index += 2 return test_cases"},{"question":"def lexicographically_smallest_string(k: int, s: str) -> str: Returns the lexicographically smallest string by performing at most k operations. Each operation consists of moving a character to another position. >>> lexicographically_smallest_string(3, \\"dcab\\") \\"abcd\\" >>> lexicographically_smallest_string(1, \\"dcaeb\\") \\"cadbe\\"","solution":"def lexicographically_smallest_string(k, s): Returns the lexicographically smallest string by performing at most k operations. Each operation consists of moving a character to another position. n = len(s) if k >= n: return ''.join(sorted(s)) s = list(s) for i in range(n): min_index = i for j in range(i + 1, min(i + k + 1, n)): if s[j] < s[min_index]: min_index = j if min_index != i: # move s[min_index] to position i s.insert(i, s.pop(min_index)) return ''.join(s)"},{"question":"def calculate_total_tips(t: int, waiter_tips: List[List[int]]) -> int: Calculate the total amount of tips earned by all waiters. >>> calculate_total_tips(3, [[5, 10, 15], [3, 3, 3, 3], [8, 8]]) 58 >>> calculate_total_tips(1, [[1, 2, 3]]) 6 >>> calculate_total_tips(2, [[], []]) 0 >>> calculate_total_tips(1, [[-5, 10, -15, 20]]) 10 >>> calculate_total_tips(4, [[1, 1, 1], [2, 2, 2, 2], [5], [100, 200, 300]]) 616","solution":"def calculate_total_tips(t, waiter_tips): Calculate the total amount of tips earned by all waiters. Parameters: t (int): The number of waiters. waiter_tips (list of list of int): A list where each element is a list of tips for each waiter. Returns: int: The total tips earned by all waiters combined. total_tips = 0 for tips in waiter_tips: total_tips += sum(tips) return total_tips # Example input reading function def read_input(): t = int(input().strip()) waiter_tips = [] for _ in range(t): tips = list(map(int, input().strip().split()))[:-1] # Ignore the last -1 waiter_tips.append(tips) return t, waiter_tips if __name__ == '__main__': t, waiter_tips = read_input() print(calculate_total_tips(t, waiter_tips))"},{"question":"def longest_subset_not_divisible_by_k(n, k, arr): Given an array of integers, find the length of the longest subset where the sum of any two numbers in the subset is not divisible by a given integer k. Args: n: int - the size of the array k: int - the integer divisor arr: List[int] - the array of integers Returns: int - the length of the longest valid subset Examples: >>> longest_subset_not_divisible_by_k(7, 3, [1, 7, 2, 4, 5, 6, 3]) 4 >>> longest_subset_not_divisible_by_k(1, 2, [1]) 1 >>> longest_subset_not_divisible_by_k(5, 3, [3, 3, 3, 3, 3]) 1 >>> longest_subset_not_divisible_by_k(0, 3, []) 0 >>> longest_subset_not_divisible_by_k(6, 6, [6, 12, 18, 24, 30, 36]) 1 >>> n = 10**5 >>> k = 10 >>> arr = [i for i in range(1, n+1)] >>> longest_subset_not_divisible_by_k(n, k, arr) > 0 True","solution":"def longest_subset_not_divisible_by_k(n, k, arr): mod_count = [0] * k for num in arr: mod_count[num % k] += 1 result = min(mod_count[0], 1) for i in range(1, (k // 2) + 1): if i != k - i: result += max(mod_count[i], mod_count[k - i]) else: result += min(mod_count[i], 1) return result"},{"question":"def can_form_valid_queue(n: int, heights: List[int]) -> str: Determine if the given array of heights can be rearranged to form a valid queue under the given conditions. >>> can_form_valid_queue(5, [3, 5, 1, 4, 2]) 'YES' >>> can_form_valid_queue(3, [4, 4, 4]) 'NO' >>> can_form_valid_queue(4, [3, 8, 6, 7]) 'YES' >>> can_form_valid_queue(2, [2, 2]) 'NO'","solution":"def can_form_valid_queue(n, heights): if n == 1: return \\"YES\\" sorted_heights = sorted(heights, reverse=True) if sorted_heights[0] == sorted_heights[1]: return \\"NO\\" return \\"YES\\""},{"question":"def count_days_above_target(target: int, temperatures: List[int]) -> int: Returns the number of days where the temperatures are greater than the target temperature. :param target: int - the target temperature :param temperatures: list of int - temperatures for each day of the week :return: int - the number of days with temperatures greater than the target >>> count_days_above_target(30, [31, 29, 35, 30, 28, 32, 33]) 4 >>> count_days_above_target(30, [30, 29, 28, 27, 26, 25, 24]) 0 >>> count_days_above_target(25, [26, 24, 27, 23, 28, 22, 29]) 4","solution":"def count_days_above_target(target, temperatures): Returns the number of days where the temperatures are greater than the target temperature. :param target: int - the target temperature :param temperatures: list of int - temperatures for each day of the week :return: int - the number of days with temperatures greater than the target return sum(1 for temp in temperatures if temp > target)"},{"question":"def flag_transaction(transactions: list, target: int) -> bool: Determines if there are any two distinct transactions in the list that sum up to the target value. Args: transactions (list): An array of integers representing transaction amounts. target (int): An integer representing the target sum. Returns: bool: True if there are any two distinct transactions that sum up to the target value, otherwise False. Examples: >>> flag_transaction([1, 3, 8, 2, 7], 10) True >>> flag_transaction([1, 2, 3, 4, 5], 10) False","solution":"def flag_transaction(transactions: list, target: int) -> bool: Determines if there are any two distinct transactions in the list that sum up to the target value. seen = set() for amount in transactions: if target - amount in seen: return True seen.add(amount) return False"},{"question":"def tallest_tree_height(n: int, t: int, trees: List[Tuple[int, int]]) -> int: Returns the height of the tallest tree after t days. Parameters: n (int): Number of trees. t (int): Number of days. trees (list of tuples): Each tuple contains (xi, gi) where xi is the position of the tree and gi is its growth rate. Returns: int: Height of the tallest tree after t days. def test_tallest_tree_height_example(): trees = [(1, 2), (3, 4), (5, 1)] assert tallest_tree_height(3, 10, trees) == 40 def test_tallest_tree_height_single_tree(): trees = [(2, 5)] assert tallest_tree_height(1, 10, trees) == 50 def test_tallest_tree_height_all_same_rate(): trees = [(1, 2), (3, 2), (5, 2)] assert tallest_tree_height(3, 10, trees) == 20 def test_tallest_tree_height_diff_rates(): trees = [(1, 3), (2, 1), (3, 4)] assert tallest_tree_height(3, 5, trees) == 20 def test_tallest_tree_height_zero_rate(): trees = [(1, 0), (2, 0), (3, 0)] assert tallest_tree_height(3, 5, trees) == 0 def test_tallest_tree_height_negative_coordinates(): trees = [(-1, 3), (-2, 1), (-3, 4)] assert tallest_tree_height(3, 5, trees) == 20","solution":"def tallest_tree_height(n, t, trees): Returns the height of the tallest tree after t days. Parameters: n (int): Number of trees. t (int): Number of days. trees (list of tuples): Each tuple contains (xi, gi) where xi is the position of the tree and gi is its growth rate. Returns: int: Height of the tallest tree after t days. max_height = 0 for _, gi in trees: height = gi * t if height > max_height: max_height = height return max_height"},{"question":"def is_valid_parentheses(sequence: str) -> bool: Determine if the sequence of parentheses is valid. >>> is_valid_parentheses(\\"{[()()]}\\") True >>> is_valid_parentheses(\\"[(])\\") False >>> is_valid_parentheses(\\"\\") True >>> is_valid_parentheses(\\"{[a+b]*(c+d)}\\") False >>> is_valid_parentheses(\\"{{{{{{{{{{{{}}}}}}}}}}}}\\") True","solution":"def is_valid_parentheses(sequence): Returns True if the sequence of parentheses is valid, False otherwise. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in sequence: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return False else: # Invalid character case which should ideally not occur due to input constraint return False return stack == []"},{"question":"def find_winner(s: str) -> str: Determines the game winner (Alex or Jamie) based on the input string. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"Alex\\" if Alex wins, \\"Jamie\\" if Jamie wins. Examples: >>> find_winner(\\"abc\\") \\"Jamie\\" >>> find_winner(\\"aabb\\") \\"Alex\\"","solution":"def find_winner(s: str) -> str: Determines the game winner (Alex or Jamie) based on the input string. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"Alex\\" if Alex wins, \\"Jamie\\" if Jamie wins. # Count the frequency of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Determine number of characters that appear more than once more_than_once = sum(1 for count in char_count.values() if count > 1) # If there are more than one character that repeats, Alex wins if more_than_once > 0: return \\"Alex\\" else: return \\"Jamie\\""},{"question":"def min_substitutions_to_palindrome(s: str) -> int: Determine the minimum number of substitutions required to make the given string a palindrome. >>> min_substitutions_to_palindrome(\\"abca\\") 1 >>> min_substitutions_to_palindrome(\\"abcd\\") 2","solution":"def min_substitutions_to_palindrome(s): Returns the minimum number of substitutions required to make the given string a palindrome. n = len(s) substitutions = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: substitutions += 1 return substitutions"},{"question":"def correct_priorities(n: int, priorities: List[int]) -> List[int]: Corrects the priority levels such that they form a permutation of numbers from 1 to n. Parameters: n (int): The number of projects priorities (list): The initial priority levels of the projects Returns: list: The corrected priority levels >>> correct_priorities(5, [5, 3, 3, 3, 1]) [5, 3, 2, 4, 1] >>> correct_priorities(3, [1, 2, 3]) [1, 2, 3] >>> correct_priorities(5, [1, 1, 1, 1, 1]) [1, 2, 3, 4, 5] >>> correct_priorities(6, [4, 4, 2, 2, 1, 6]) [4, 3, 2, 5, 1, 6] >>> correct_priorities(1, [1]) [1]","solution":"def correct_priorities(n, priorities): Corrects the priority levels such that they form a permutation of numbers from 1 to n. Parameters: n (int): The number of projects priorities (list): The initial priority levels of the projects Returns: list: The corrected priority levels correct_set = set(range(1, n + 1)) current_set = set(priorities) missing = list(correct_set - current_set) duplicates = [p for p in priorities if priorities.count(p) > 1] result = [] duplicate_seen = set() missing_ptr = 0 for priority in priorities: if priorities.count(priority) == 1: result.append(priority) else: if priority not in duplicate_seen: result.append(priority) duplicate_seen.add(priority) else: result.append(missing[missing_ptr]) missing_ptr += 1 return result"},{"question":"from typing import List, Union, Tuple def can_arrange_books(n: int, heights: List[int]) -> Union[str, Tuple[str, List[int]]]: Determine if it's possible to arrange books such that no two adjacent books have the same height. >>> can_arrange_books(7, [1, 1, 1, 2, 2, 3, 4]) ('YES', [1, 2, 1, 3, 1, 4, 2]) >>> can_arrange_books(1, [1]) ('YES', [1]) >>> can_arrange_books(4, [2, 2, 2, 2]) 'NO' >>> can_arrange_books(4, [1, 2, 1, 2]) ('YES', [1, 2, 1, 2]) >>> result = can_arrange_books(5, [1, 2, 3, 4, 5]) >>> result[0] 'YES' >>> for i in range(len(result[1]) - 1): >>> assert result[1][i] != result[1][i + 1] >>> result = can_arrange_books(6, [1, 1, 2, 2, 3, 3]) >>> result[0] 'YES' >>> for i in range(len(result[1]) - 1): >>> assert result[1][i] != result[1][i + 1]","solution":"def can_arrange_books(n, heights): from collections import Counter height_count = Counter(heights) max_count = max(height_count.values()) if max_count > (n + 1) // 2: return \\"NO\\" sorted_heights = sorted(heights, key=lambda h: (-height_count[h], h)) result = [0] * n result[::2] = sorted_heights[:(n + 1) // 2] result[1::2] = sorted_heights[(n + 1) // 2:] return \\"YES\\", result # Example use-case for testing n = 7 heights = [1, 1, 1, 2, 2, 3, 4] print(can_arrange_books(n, heights)) # Expected output: \\"YES\\", followed by a valid arrangement"},{"question":"def unique_integers_in_range(n: int, m: int, nums: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an integer array \`nums\` of length \`n\` and an array \`queries\` of length \`m\`, where each element in \`queries\` is a pair of integers \`[l, r]\` representing a query range \`[l, r]\` (1-indexed). Determine, for each query, the number of unique integers in the range \`nums[l]\` to \`nums[r]\` inclusive. Parameters: n (int): The length of the nums array. m (int): The number of queries. nums (List[int]): The array of integers. queries (List[Tuple[int, int]]): Each pair [l, r] represents a query range. Returns: List[int]: A list where each integer represents the number of unique integers in the corresponding query range. >>> unique_integers_in_range(5, 3, [1, 2, 1, 3, 4], [(1, 3), (2, 4), (1, 5)]) [2, 3, 4] >>> unique_integers_in_range(4, 2, [1, 1, 1, 1], [(1, 2), (1, 4)]) [1, 1]","solution":"def unique_integers_in_range(n, m, nums, queries): This function takes in: - An integer n representing the length of the nums array. - An integer m representing the number of queries. - A list of integers nums representing the array. - A list of pair of integers queries, where each pair [l, r] represents a query range. It returns a list of integers where each integer represents the number of unique integers in the corresponding query range. from collections import defaultdict # Results to be returned results = [] # Mega Data Structures unique_count = defaultdict(int) frequency = defaultdict(int) # Initialize the Mo's algorithm data structures current_l, current_r, current_unique_count = 0, 0, 0 def add(x): nonlocal current_unique_count frequency[x] += 1 if frequency[x] == 1: current_unique_count += 1 def remove(x): nonlocal current_unique_count if frequency[x] == 1: current_unique_count -= 1 frequency[x] -= 1 queries = [(l-1, r-1, i) for i, (l, r) in enumerate(queries)] # Mo's algorithm magic (Square Root Decomposition) block_size = int(n ** 0.5) queries.sort(key=lambda x: (x[0] // block_size, x[1] if (x[0] // block_size) % 2 == 0 else -x[1])) for l, r, idx in queries: while current_r <= r: add(nums[current_r]) current_r += 1 while current_r > r + 1: current_r -= 1 remove(nums[current_r]) while current_l < l: remove(nums[current_l]) current_l += 1 while current_l > l: current_l -= 1 add(nums[current_l]) results.append((current_unique_count, idx)) results.sort(key=lambda x: x[1]) return [res[0] for res in results]"},{"question":"from typing import List def smallest_subset_size(n: int, target_word: str, words: List[str]) -> int: Find the smallest subset of the list such that the concatenation of all words in the subset contains all the characters of the target word at least once. Args: n: int - the number of words in the list target_word: str - the target word to be formed words: List[str] - list of words Returns: int - the size of the smallest subset or -1 if it's not possible >>> smallest_subset_size(4, 'apple', ['ael', 'pe', 'pl', 'ae']) 2 >>> smallest_subset_size(3, 'hello', ['abc', 'def', 'ghi']) -1 >>> smallest_subset_size(1, 'word', ['word']) 1 >>> smallest_subset_size(3, 'abc', ['a', 'b', 'c']) 3 >>> smallest_subset_size(3, 'abc', ['ab', 'bc', 'ca']) 2 >>> smallest_subset_size(5, 'alphabet', ['alpha', 'bet', 'gamma', 'delta', 'epsilon']) 2","solution":"from itertools import combinations def smallest_subset_size(n, target_word, words): def contains_all_chars(word, target_chars): for char in target_chars: if char in word: target_chars = target_chars.replace(char, '', 1) return not target_chars target_chars = ''.join(set(target_word)) for size in range(1, n+1): for combo in combinations(words, size): combined = ''.join(combo) if contains_all_chars(combined, target_chars): return size return -1"},{"question":"def find_string_placement(n: int, m: int, grid: List[str], t: str) -> Union[List[Tuple[int, int]], int]: Find one way to place the string t on the grid such that all characters of the string fit into horizontally, vertically, or diagonally adjacent cells of the grid without intersecting any asterisks '*'. Parameters: n (int): the number of rows in the grid. m (int): the number of columns in the grid. grid (List[str]): the grid consisting of characters '*' and '.'. t (str): the string to be placed on the grid. Returns: Union[List[Tuple[int, int]], int]: The positions of string t placed on the grid, or -1 if not possible. Example: >>> find_string_placement(4, 5, [\\".....\\", \\"..*..\\", \\".....\\", \\".....\\"], \\"hello\\") [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)] >>> find_string_placement(3, 3, [\\"***\\", \\"*.*\\", \\"***\\"], \\"hi\\") -1","solution":"def find_string_placement(n, m, grid, t): directions = [ (1, 0), (0, 1), (1, 1), (1, -1), # Down, Right, Diagonal Down-Right, Diagonal Down-Left (-1, 0), (0, -1), (-1, -1), (-1, 1) # Up, Left, Diagonal Up-Left, Diagonal Up-Right ] def is_valid_position(positions): for pi, pj in positions: if grid[pi][pj] == '*': return False return True for i in range(n): for j in range(m): if grid[i][j] == '.': for di, dj in directions: positions = [] for k in range(len(t)): ni = (i + k * di) % n nj = (j + k * dj) % m positions.append((ni, nj)) if is_valid_position(positions): result = [(pi + 1, pj + 1) for pi, pj in positions] return result return -1"},{"question":"def preprocess_array(arr): Preprocess the array to calculate the prefix sums. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] >>> preprocess_array([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0, 0] def query_sum(prefix_sums, l, r): Return the sum of elements between indices l and r (inclusive) using the prefix sums. >>> prefix_sums = preprocess_array([1, 2, 3, 4, 5]) >>> query_sum(prefix_sums, 1, 3) 6 >>> query_sum(prefix_sums, 2, 4) 9","solution":"def preprocess_array(arr): Preprocess the array to calculate the prefix sums. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] return prefix_sums def query_sum(prefix_sums, l, r): Return the sum of elements between indices l and r (inclusive) using the prefix sums. return prefix_sums[r] - prefix_sums[l - 1] # Sample array and queries for testing arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4)] prefix_sums = preprocess_array(arr) results = [] for l, r in queries: results.append(query_sum(prefix_sums, l, r)) print(results) # Should output [6, 9] for the example"},{"question":"def find_min_manhattan_distance(n: int, m: int, matrix: List[List[int]]) -> Tuple[int, int]: Find the cell with the minimum sum of Manhattan distances to all other cells. Parameters: n (int): number of rows in the matrix m (int): number of columns in the matrix matrix (list of list of int): 2D list representing the matrix Returns: tuple: row index (1-based), column index (1-based) of the cell with the minimum sum of distances >>> find_min_manhattan_distance(3, 3, [[1, 0, 0], [0, 0, 0], [0, 1, 0]]) (2, 2) >>> find_min_manhattan_distance(1, 1, [[5]]) (1, 1) >>> find_min_manhattan_distance(1, 3, [[1, 2, 3]]) (1, 2) >>> find_min_manhattan_distance(3, 1, [[1], [2], [3]]) (2, 1) >>> find_min_manhattan_distance(2, 2, [[1, 1], [1, 1]]) (1, 1) >>> find_min_manhattan_distance(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) (2, 2) >>> find_min_manhattan_distance(2, 2, [[999, 999], [999, 999]]) (1, 1)","solution":"def find_min_manhattan_distance(n, m, matrix): Find the cell with the minimum sum of Manhattan distances to all other cells. Parameters: n (int): number of rows in the matrix m (int): number of columns in the matrix matrix (list of list of int): 2D list representing the matrix Returns: tuple: row index (1-based), column index (1-based) of the cell with the minimum sum of distances min_sum = float('inf') min_cell = (0, 0) for i in range(n): for j in range(m): current_sum = 0 for x in range(n): for y in range(m): current_sum += abs(i - x) + abs(j - y) if current_sum < min_sum: min_sum = current_sum min_cell = (i, j) return (min_cell[0] + 1, min_cell[1] + 1)"},{"question":"def find_min_new_connections(n: int, m: int, connections: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]: Determine the minimum number of new direct connections required to ensure that all planets are connected. >>> find_min_new_connections(4, 2, [(1, 2), (3, 4)]) (1, [(1, 3)]) >>> find_min_new_connections(5, 3, [(1, 2), (2, 3), (4, 5)]) (1, [(1, 4)])","solution":"def find_min_new_connections(n, m, connections): from collections import defaultdict, deque def bfs(start, visited, adj): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # adjacency list adj = defaultdict(list) for u, v in connections: adj[u].append(v) adj[v].append(u) # finding connected components visited = [False] * (n + 1) components = [] for i in range(1, n + 1): if not visited[i]: component = [] bfs(i, visited, adj) components.append(i) # components is a list of representative nodes of each connected component k = len(components) - 1 # Need (number of components minus 1) edges to connect all components new_connections = [] for i in range(1, len(components)): new_connections.append((components[i - 1], components[i])) return k, new_connections"},{"question":"def remove_stop_words(stop_words: List[str], text: str) -> str: Removes specified stop words from the text and returns the modified text. Parameters: stop_words (list): List of stop words to be removed. text (str): Input text string containing words separated by single spaces. Returns: str: Modified text with stop words removed. >>> remove_stop_words([\\"is\\", \\"the\\", \\"in\\", \\"at\\", \\"of\\", \\"and\\", \\"a\\"], \\"the quick brown fox jumps over the lazy dog\\") \\"quick brown fox jumps over lazy dog\\" >>> remove_stop_words([\\"he\\", \\"she\\", \\"it\\", \\"they\\", \\"him\\", \\"her\\", \\"them\\"], \\"he said that she would be here but she did not show up\\") \\"said that would be here but did not show up\\"","solution":"def remove_stop_words(stop_words, text): Removes specified stop words from the text and returns the modified text. Parameters: stop_words (list): List of stop words to be removed. text (str): Input text string containing words separated by single spaces. Returns: str: Modified text with stop words removed. stop_words_set = set(stop_words) words = text.split() filtered_words = [word for word in words if word not in stop_words_set] return ' '.join(filtered_words)"},{"question":"def smallest_path(path: str) -> str: Returns the lexicographically smallest possible path by replacing each '?' with either '+' or '-'. >>> smallest_path('??+') '--+' >>> smallest_path('??') '--' >>> smallest_path('????') '----' >>> smallest_path('?+?') '-+-' >>> smallest_path('?-?+') '---+' >>> smallest_path('+??+?') '+--+-' >>> smallest_path('+-+') '+-+' >>> smallest_path('---') '---' >>> smallest_path('+++') '+++' >>> smallest_path('?') '-' >>> smallest_path('+') '+' >>> smallest_path('-') '-'","solution":"def smallest_path(path: str) -> str: Returns the lexicographically smallest possible path by replacing each '?' with either '+' or '-'. return path.replace('?', '-')"},{"question":"class HospitalNetworks: def __init__(self, n): self.parent = list(range(n + 1)) self.size = [1] * (n + 1) self.networks_count = n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.size[root_u] < self.size[root_v]: self.parent[root_u] = root_v self.size[root_v] += self.size[root_u] else: self.parent[root_v] = root_u self.size[root_u] += self.size[root_v] self.networks_count -= 1 def hospital_networks(n, queries): Handle a series of queries about merging networks of hospitals and counting distinct networks. Args: n: int - number of hospitals queries: List[Tuple] - list of queries where each query is a tuple. - \\"1 u v\\" - merge the network containing hospital u with the network containing hospital v. - \\"2\\" - output the number of distinct hospital networks. Returns: List[int] - results of each query type \\"2\\" Example: >>> n, queries = 5, [(1, 1, 2), (1, 3, 4), (2,), (1, 4, 5), (2,), (1, 2, 3), (2,)] >>> hospital_networks(n, queries) [3, 2, 1]","solution":"class HospitalNetworks: def __init__(self, n): self.parent = list(range(n + 1)) self.size = [1] * (n + 1) self.networks_count = n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: # Merge smaller tree under larger tree to keep it balanced if self.size[root_u] < self.size[root_v]: self.parent[root_u] = root_v self.size[root_v] += self.size[root_u] else: self.parent[root_v] = root_u self.size[root_u] += self.size[root_v] self.networks_count -= 1 def hospital_networks(n, queries): hospital_networks = HospitalNetworks(n) result = [] for query in queries: if query[0] == 1: u, v = query[1], query[2] hospital_networks.union(u, v) elif query[0] == 2: result.append(hospital_networks.networks_count) return result"},{"question":"def min_candies_distribution(test_cases): Calculate the minimum number of candies required to satisfy all children. Each child should get at least their preferred number of candies but not exceed their limit. >>> test_cases = [ ... (3, [1, 2, 3], [3, 4, 5]), ... (4, [2, 2, 2, 2], [3, 3, 3, 3]) ... ] >>> min_candies_distribution(test_cases) [6, 8] pass def process_input(input_string): Process the input string and return structured test cases. >>> input_data = ''' ... 2 ... 3 ... 1 2 3 ... 3 4 5 ... 4 ... 2 2 2 2 ... 3 3 3 3 ... ''' >>> process_input(input_data) [ (3, [1, 2, 3], [3, 4, 5]), (4, [2, 2, 2, 2], [3, 3, 3, 3]) ] pass","solution":"def min_candies_distribution(test_cases): results = [] for case in test_cases: n, preferred, limit = case candies = 0 for p, l in zip(preferred, limit): if p > l: candies += l else: candies += p results.append(candies) return results # Handling the input and converting it to the required format for the function def process_input(input_string): input_lines = input_string.strip().split('n') idx = 0 t = int(input_lines[idx]) idx += 1 test_cases = [] for _ in range(t): n = int(input_lines[idx]) idx += 1 preferred = list(map(int, input_lines[idx].split())) idx += 1 limit = list(map(int, input_lines[idx].split())) idx += 1 test_cases.append((n, preferred, limit)) return test_cases"},{"question":"def maxEvents(events): Returns the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuple): List of tuples where each tuple (start, end) represents the start and end time of an event. Returns: int: Maximum number of non-overlapping events. pass def test_single_event(): assert maxEvents([(1, 3)]) == 1 def test_non_overlapping_events(): assert maxEvents([(1, 3), (4, 6), (6, 8)]) == 3 def test_overlapping_events(): assert maxEvents([(1, 3), (2, 5), (4, 6), (6, 8)]) == 3 def test_completely_overlapping_events(): assert maxEvents([(1, 5), (2, 6), (3, 7), (4, 8)]) == 1 def test_subsets_of_overlapping_events(): assert maxEvents([(1, 3), (3, 5), (2, 6), (6, 8)]) == 3 def test_all_events_same_end_time(): assert maxEvents([(1, 3), (2, 3), (0, 3), (3, 5)]) == 2 # Add more edge cases def test_edge_case_single_minimal_event(): assert maxEvents([(0, 1)]) == 1 def test_edge_case_maximal_event_range(): assert maxEvents([(0, 24)]) == 1 def test_edge_case_no_events(): assert maxEvents([]) == 0 def test_edge_case_all_start_and_end_times_same(): assert maxEvents([(5, 7), (5, 7), (5, 7), (5, 7)]) == 1","solution":"def maxEvents(events): Returns the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuple): List of tuples where each tuple (start, end) represents the start and end time of an event. Returns: int: Maximum number of non-overlapping events. # Sort events by end time events.sort(key=lambda x: x[1]) # Initialize count and current end time count = 0 curr_end = 0 for start, end in events: # If the start time is after or at the end time of the last attended event if start >= curr_end: # Attend this event count += 1 curr_end = end return count"},{"question":"def longest_subarray_with_sum_k(arr, k): Returns the length of the longest subarray whose sum is equal to k. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The length of the longest subarray with sum equal to k, or 0 if no such subarray exists. from solution import longest_subarray_with_sum_k def test_example_case(): assert longest_subarray_with_sum_k([10, 5, 2, 7, 1, 9, 3, 6], 15) == 4 def test_no_subarray(): assert longest_subarray_with_sum_k([1, 2, 3, 4, 5], 100) == 0 def test_entire_array(): assert longest_subarray_with_sum_k([1, 2, 3, 4, 5], 15) == 5 def test_multiple_subarrays(): assert longest_subarray_with_sum_k([1, -1, 5, -2, 3], 3) == 4 def test_negative_numbers(): assert longest_subarray_with_sum_k([-2, -3, 4, -1, -2, 1, 5, -3], 3) == 4 def test_single_element(): assert longest_subarray_with_sum_k([5], 5) == 1 assert longest_subarray_with_sum_k([5], 0) == 0 def test_empty_array(): assert longest_subarray_with_sum_k([], 5) == 0 def test_mixed_signs(): assert longest_subarray_with_sum_k([-10, 20, -10, 10], 10) == 4","solution":"def longest_subarray_with_sum_k(arr, k): Returns the length of the longest subarray whose sum is equal to k. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The length of the longest subarray with sum equal to k, or 0 if no such subarray exists. sum_map = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] # Check if current sum is equal to k if current_sum == k: max_length = i + 1 # Check if (current_sum - k) is in the dictionary if (current_sum - k) in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) # If current sum is not in the dictionary, add it if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"from typing import List def find_pair_indices(arr: List[int], target: int) -> List[int]: Given a list of integers and a target integer, return the indices of two numbers such that they add up to the target. >>> find_pair_indices([2, 7, 11, 15, 3], 9) [0, 1] >>> find_pair_indices([-2, 1, 4, 8], 2) [0, 2] >>> find_pair_indices([1000000000, 0, -1000000000], 0) [0, 2] >>> find_pair_indices([1, 2], 3) [0, 1] >>> find_pair_indices([1, 1, 1, 1], 2) # Multiple possible solutions: [0, 1], [1, 0], [2, 3], [3, 2]","solution":"def find_pair_indices(arr, target): Given a list of integers and a target integer, return the indices of two numbers such that they add up to the target. value_to_index = {} for index, number in enumerate(arr): difference = target - number if difference in value_to_index: return [value_to_index[difference], index] value_to_index[number] = index return [] # We assume there is exactly one solution, so this should never happen."},{"question":"def check_rectangle_exists(n: int, points: List[Tuple[int, int]]) -> str: Determines if there is a rectangle whose sides are parallel to the coordinate axes formed by some of the given points. Parameters: n (int): Number of points (4 to 50). points (list): List of tuples containing the coordinates of points (xi, yi). Returns: str: \\"YES\\" if such a rectangle exists, otherwise \\"NO\\". Example: >>> check_rectangle_exists(4, [(0, 0), (0, 1), (1, 0), (1, 1)]) \\"YES\\" >>> check_rectangle_exists(5, [(0, 0), (1, 2), (2, 2), (1, 3), (3, 1)]) \\"NO\\"","solution":"def check_rectangle_exists(n, points): Determines if there is a rectangle whose sides are parallel to the coordinate axes formed by some of the given points. Parameters: n (int): Number of points (4 to 50). points (list): List of tuples containing the coordinates of points (xi, yi). Returns: str: \\"YES\\" if such a rectangle exists, otherwise \\"NO\\". point_set = set(points) for i in range(n): for j in range(i + 1, n): x1, y1 = points[i] x2, y2 = points[j] # Check for potential rectangle diagonal (x1,y1) to (x2,y2) if x1 != x2 and y1 != y2: if (x1, y2) in point_set and (x2, y1) in point_set: return \\"YES\\" return \\"NO\\""},{"question":"def can_rearrange_to_form(s1: str, s2: str) -> bool: Determines if it is possible to rearrange the characters of s1 to form s2. >>> can_rearrange_to_form(\\"listen\\", \\"silent\\") True >>> can_rearrange_to_form(\\"triangle\\", \\"integral\\") True >>> can_rearrange_to_form(\\"apple\\", \\"pale\\") False >>> can_rearrange_to_form(\\"test\\", \\"testing\\") False >>> can_rearrange_to_form(\\"abc\\", \\"def\\") False >>> can_rearrange_to_form(\\"aabbcc\\", \\"ddeeff\\") False >>> can_rearrange_to_form(\\"a\\", \\"a\\") True >>> can_rearrange_to_form(\\"a\\", \\"b\\") False >>> can_rearrange_to_form(\\"abc\\", \\"Abc\\") False >>> can_rearrange_to_form(\\"\\", \\"\\") True","solution":"def can_rearrange_to_form(s1, s2): Determines if it is possible to rearrange the characters of s1 to form s2. Parameters: s1 (str): The first string s2 (str): The second string Returns: bool: True if s1 can be rearranged to form s2, False otherwise if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"def find_start_days(n: int, days: List[int]) -> List[int]: Determines the start day for each book given the number of books and the days taken to finish each book. Args: n (int): The number of books. days (list of int): A list where each element represents the days taken to finish each book. Returns: list of int: A list where each element represents the start day for each book. >>> find_start_days(3, [1, 2, 1]) == [1, 2, 4] >>> find_start_days(2, [2, 3]) == [1, 3] >>> find_start_days(4, [1, 1, 1, 1]) == [1, 2, 3, 4] >>> find_start_days(5, [3, 1, 4, 1, 2]) == [1, 4, 5, 9, 10] >>> find_start_days(3, [2, 2, 2]) == [1, 3, 5] >>> find_start_days(3, [50, 50, 50]) == [1, 51, 101] # Your code here","solution":"def find_start_days(n, days): Determines the start day for each book given the number of books and the days taken to finish each book. Args: n (int): The number of books. days (list of int): A list where each element represents the days taken to finish each book. Returns: list of int: A list where each element represents the start day for each book. start_days = [] current_day = 1 # Maria starts reading on the first day for d in days: start_days.append(current_day) current_day += d # Update the current day to the next starting day return start_days"},{"question":"def count_effective_potions(n: int, positions: List[int]) -> int: Count the number of effective potions given their positions on a number line. Parameters: n (int): Number of potions positions (list of int): Positions of the potions on the number line Returns: int: Number of effective potions pass # Test cases def test_count_effective_potions(): assert count_effective_potions(3, [-5, 3, -2]) == 2 assert count_effective_potions(4, [-1, 2, -3, 4]) == 2 assert count_effective_potions(3, [5, 3, 2]) == 1 assert count_effective_potions(5, [-10, -8, -5, -2, 1]) == 2 assert count_effective_potions(2, [5, -5]) == 2 assert count_effective_potions(1, [0]) == 0 assert count_effective_potions(4, [7, 3, 8, -6]) == 2 assert count_effective_potions(5, [-10, -8, -2, 3, 10]) == 2 def test_edge_cases(): assert count_effective_potions(1, [1000000000]) == 1 assert count_effective_potions(2, [-1000000000, 1000000000]) == 2 assert count_effective_potions(1, [-1000000000]) == 1","solution":"def count_effective_potions(n, positions): Count the number of effective potions given their positions on a number line. Parameters: n (int): Number of potions positions (list of int): Positions of the potions on the number line Returns: int: Number of effective potions min_positive = float('inf') max_negative = float('-inf') for position in positions: if position > 0: min_positive = min(min_positive, position) elif position < 0: max_negative = max(max_negative, position) effective_count = 0 for position in positions: if position > 0 and position == min_positive: effective_count += 1 elif position < 0 and position == max_negative: effective_count += 1 return effective_count"},{"question":"def find_MST(n, m, d, edges): Compute the weight of the minimum spanning tree that uses only edges with weights divisible by d. If it's not possible to form such an MST, return -1. Parameters: n (int): number of nodes m (int): number of edges d (int): integer divisor edges (List[Tuple[int, int, int]]): list of edges represented by tuples (u, v, w) Returns: int: total weight of the MST or -1 if no such MST can be formed >>> find_MST(4, 5, 3, [(1, 2, 3), (1, 3, 6), (2, 3, 3), (2, 4, 9), (3, 4, 5)]) 15 >>> find_MST(4, 5, 10, [(1, 2, 7), (1, 3, 11), (2, 3, 5), (2, 4, 13), (3, 4, 17)]) -1","solution":"def find_MST(n, m, d, edges): parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 valid_edges = [edge for edge in edges if edge[2] % d == 0] valid_edges.sort(key=lambda x: x[2]) mst_weight = 0 mst_edges = 0 for u, v, w in valid_edges: if find(u) != find(v): union(u, v) mst_weight += w mst_edges += 1 if mst_edges == n - 1: break if mst_edges == n - 1: return mst_weight else: return -1 # Example usage: # edges = [(1, 2, 3), (1, 3, 6), (2, 3, 3), (2, 4, 9), (3, 4, 5)] # print(find_MST(4, 5, 3, edges)) # Output should be 15"},{"question":"from typing import List, Tuple, Union def find_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> Union[List[int], str]: Determine if the graph contains a cycle, and if so, find and return one such cycle. If there is no cycle, return \\"No cycle\\". Args: n (int): Number of vertices. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges, where each edge is represented as a tuple (u, v). Returns: Union[List[int], str]: A list of vertices in the cycle if a cycle is found, otherwise \\"No cycle\\". Example: >>> find_cycle(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) [2, 1, 3, 2] >>> find_cycle(3, 2, [(1, 2), (2, 3)]) \\"No cycle\\" pass","solution":"def find_cycle(n, m, edges): from collections import defaultdict def dfs(vertex, parent): visited[vertex] = True path.append(vertex) on_stack[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(neighbor, vertex): return True elif on_stack[neighbor] and neighbor != parent: cycle_start_index = path.index(neighbor) cycle.extend(path[cycle_start_index:]) return True path.pop() on_stack[vertex] = False return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) on_stack = [False] * (n + 1) path = [] cycle = [] for v in range(1, n + 1): if not visited[v]: if dfs(v, -1): return cycle return \\"No cycle\\""},{"question":"from typing import List, Tuple def tree_sum(n: int, q: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: You are given a binary tree with n nodes. The nodes are labeled from 1 to n and each node has a value associated with it. You need to perform q queries on this tree. Each query asks for the sum of the values of all nodes in the subtree rooted at a given node v. Args: n (int): the number of nodes in the tree q (int): the number of queries values (List[int]): the values of the nodes edges (List[Tuple[int, int]]): the edges between the nodes queries (List[int]): the roots of the subtrees to be queried Returns: List[int]: the answers to the queries >>> tree_sum(5, 3, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], [1, 3, 4]) [15, 12, 4] >>> tree_sum(1, 1, [10], [], [1]) [10] >>> tree_sum(3, 2, [1, 2, 3], [(1, 2), (1, 3)], [1, 2]) [6, 2] >>> tree_sum(7, 4, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [1, 2, 3, 4]) [28, 11, 16, 4] >>> tree_sum(4, 1, [1000000000, 1000000000, 1000000000, 1000000000], [(1, 2), (1, 3), (3, 4)], [1]) [4000000000]","solution":"def tree_sum(n, q, values, edges, queries): from collections import defaultdict, deque # Create an adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to compute the sum of the subtree def compute_subtree_sum(node, parent): total = values[node - 1] for neighbor in tree[node]: if neighbor != parent: total += compute_subtree_sum(neighbor, node) subtree_sum[node] = total return total # Precompute subtree sums subtree_sum = {} compute_subtree_sum(1, -1) # Answer the queries results = [subtree_sum[v] for v in queries] return results # Test case n = 5 q = 3 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 3, 4] print(tree_sum(n, q, values, edges, queries)) # Output: [15, 12, 4]"},{"question":"def is_valid_path(n: int, m: int, matrix: List[List[int]]) -> str: Identify whether there exists a valid path from the top-left corner to the bottom-right corner such that each step always moves to a cell of the same or decreasing value. >>> is_valid_path(4, 4, [[5, 4, 3, 2], [4, 5, 1, 6], [3, 2, 2, 5], [6, 1, 1, 1]]) \\"YES\\" >>> is_valid_path(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \\"NO\\"","solution":"def is_valid_path(n, m, matrix): def dfs(x, y, value): if x < 0 or x >= n or y < 0 or y >= m or visited[x][y] or matrix[x][y] > value: return False if x == n - 1 and y == m - 1: return True visited[x][y] = True if (dfs(x + 1, y, matrix[x][y]) or dfs(x - 1, y, matrix[x][y]) or dfs(x, y + 1, matrix[x][y]) or dfs(x, y - 1, matrix[x][y])): return True visited[x][y] = False return False visited = [[False] * m for _ in range(n)] return \\"YES\\" if dfs(0, 0, matrix[0][0]) else \\"NO\\" # Sample Usage n = 4 m = 4 matrix = [[5, 4, 3, 2], [4, 5, 1, 6], [3, 2, 2, 5], [6, 1, 1, 1]] print(is_valid_path(n, m, matrix)) # Output: YES"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of character changes required to transform the string s into a palindrome. >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"racecar\\") 0 >>> min_changes_to_palindrome(\\"abcd\\") 2 >>> min_changes_to_palindrome(\\"a\\") 0 >>> min_changes_to_palindrome(\\"aa\\") 0 >>> min_changes_to_palindrome(\\"aba\\") 0 >>> min_changes_to_palindrome(\\"abb\\") 1 pass","solution":"def min_changes_to_palindrome(s): Returns the minimum number of character changes required to transform the string s into a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def count_distinct_increasing_subsequences(n: int, k: int, arr: List[int]) -> int: Count the number of distinct k-length subsequences of a sequence which are strictly increasing. >>> count_distinct_increasing_subsequences(5, 2, [1, 2, 3, 4, 5]) 10 >>> count_distinct_increasing_subsequences(3, 2, [3, 2, 1]) 0 >>> count_distinct_increasing_subsequences(5, 1, [1, 2, 3, 4, 5]) 5 >>> count_distinct_increasing_subsequences(5, 2, [1, 2, 2, 3, 4]) 6 >>> count_distinct_increasing_subsequences(4, 3, [1, 3, 2, 4]) 2 >>> count_distinct_increasing_subsequences(5, 2, [2, 2, 2, 2, 2]) 0","solution":"def count_distinct_increasing_subsequences(n, k, arr): from itertools import combinations # Get all possible k-length subsequences subsequences = combinations(arr, k) # Filter to keep only strictly increasing subsequences increasing_subsequences = [seq for seq in subsequences if all(seq[i] < seq[i+1] for i in range(k-1))] # Count the distinct increasing subsequences distinct_increasing_subsequences = set(increasing_subsequences) return len(distinct_increasing_subsequences)"},{"question":"def can_fit_grid(a: int, l: int) -> bool: Determines if there exists at least one possible grid configuration with the specified grid size a that sums to l. >>> can_fit_grid(3, 18) == True >>> can_fit_grid(2, 10) == False >>> can_fit_grid(1, 1) == True >>> can_fit_grid(100, 5050*100) == True >>> can_fit_grid(4, 40) == True >>> can_fit_grid(5, 75) == True >>> can_fit_grid(3, 16) == False >>> can_fit_grid(4, 48) == False","solution":"def can_fit_grid(a: int, l: int) -> bool: Determines if there exists at least one possible grid configuration with the specified grid size a that sums to l. # Calculate the minimum and maximum possible sums for the grid grid_sum_min = sum(range(1, a + 1)) * a grid_sum_max = sum(range(1, a + 1)) * a # Since every row contains each number from 1 to a exactly once, # their sum will be the same for each row. return grid_sum_min == l"},{"question":"from typing import List def can_rearrange(arr: List[int]) -> str: Determine if it's possible to rearrange the integers such that no two adjacent integers in the new arrangement have a common factor greater than 1. >>> can_rearrange([6, 10, 15, 25]) \\"YES\\" >>> can_rearrange([4, 6, 8]) \\"NO\\" >>> can_rearrange([1, 2]) \\"YES\\" >>> can_rearrange([2, 5, 7, 11]) \\"YES\\" >>> can_rearrange([7, 7, 7, 7]) \\"NO\\" >>> can_rearrange([999983, 100003, 100019]) \\"YES\\" >>> can_rearrange([3, 9, 5, 25, 7]) \\"YES\\"","solution":"from math import gcd from functools import reduce def can_rearrange(arr): Determine if it's possible to rearrange the integers such that no two adjacent integers in the new arrangement have a common factor greater than 1. n = len(arr) def gcd_of_list(lst): return reduce(gcd, lst) if gcd_of_list(arr) == 1: return \\"YES\\" else: return \\"NO\\" # Example usage: # result = can_rearrange([6, 10, 15, 25]) # print(result) # Output should be \\"YES\\""},{"question":"def largest_even_sum_submatrix(n, m, matrix): You have a rectangular matrix of n rows and m columns. Each cell of the matrix contains a non-negative integer. Your task is to find the largest rectangular submatrix such that the sum of all elements in this submatrix is even. Parameters: - n (int): The number of rows in the matrix. (1 ≤ n, m ≤ 100) - m (int): The number of columns in the matrix. - matrix (List[List[int]]): The matrix itself, where matrix[i][j] is the element in the i-th row and j-th column. Each element is between 0 and 1000 inclusive. Returns: - int: The largest possible area of a rectangular submatrix with an even sum of its elements. Examples: >>> largest_even_sum_submatrix(3, 4, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ]) 12 >>> largest_even_sum_submatrix(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ]) 9 >>> largest_even_sum_submatrix(1, 1, [ ... [2] ]) 1 >>> largest_even_sum_submatrix(1, 1, [ ... [1] ]) 0 >>> largest_even_sum_submatrix(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ]) 4 >>> largest_even_sum_submatrix(3, 3, [ ... [10, 23, 12], ... [8, 15, 100], ... [22, 4, 9] ]) 6","solution":"def largest_even_sum_submatrix(n, m, matrix): max_area = 0 # Calculate the prefix sums for the matrix prefix_sum = [[0]*(m+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): prefix_sum[i][j] = (prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] + matrix[i-1][j-1]) # Calculate the largest area with an even sum for i1 in range(n): for i2 in range(i1, n): for j1 in range(m): for j2 in range(j1, m): total_sum = (prefix_sum[i2+1][j2+1] - prefix_sum[i1][j2+1] - prefix_sum[i2+1][j1] + prefix_sum[i1][j1]) if total_sum % 2 == 0: area = (i2 - i1 + 1) * (j2 - j1 + 1) if area > max_area: max_area = area return max_area"},{"question":"def move_robot(m: int, n: int, x: int, y: int, k: int, commands: List[str]) -> Tuple[int, int]: Simulates the movement of a robot on an m x n grid starting from position (x, y) and moving according to the given commands. The robot can move up, down, left, or right, but cannot move diagonally or off the grid. If a command would result in the robot moving off the grid, it is ignored. Parameters: - m: int, number of rows in the grid. - n: int, number of columns in the grid. - x: int, starting row position of the robot. - y: int, starting column position of the robot. - k: int, number of movement commands. - commands: list of str, each string is one of \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". Returns: - tuple: final row and column position of the robot. Examples: >>> move_robot(5, 5, 2, 2, 4, [\\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\"]) (2, 2) >>> move_robot(5, 5, 0, 0, 4, [\\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"RIGHT\\"]) (1, 1) >>> move_robot(3, 3, 1, 1, 2, [\\"UP\\", \\"UP\\"]) (0, 1) >>> move_robot(4, 4, 1, 1, 8, [\\"UP\\", \\"UP\\", \\"LEFT\\", \\"LEFT\\", \\"DOWN\\", \\"RIGHT\\", \\"RIGHT\\", \\"DOWN\\"]) (2, 2) >>> move_robot(10, 10, 5, 5, 6, [\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"RIGHT\\", \\"RIGHT\\"]) (4, 6)","solution":"def move_robot(m, n, x, y, k, commands): Simulates the movement of a robot on an m x n grid starting from position (x, y) and moving according to the given commands. Parameters: - m: int, number of rows in the grid. - n: int, number of columns in the grid. - x: int, starting row position of the robot. - y: int, starting column position of the robot. - k: int, number of movement commands. - commands: list of str, each string is one of \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". Returns: - tuple: final row and column position of the robot. for command in commands: if command == \\"UP\\": if x > 0: x -= 1 elif command == \\"DOWN\\": if x < m - 1: x += 1 elif command == \\"LEFT\\": if y > 0: y -= 1 elif command == \\"RIGHT\\": if y < n - 1: y += 1 return (x, y)"},{"question":"from typing import List def can_rearrange_no_adjacent(t: int, cases: List[str]) -> List[str]: Determine if the characters of each string can be rearranged so that no two adjacent characters are the same. Args: t (int): The number of test cases. cases (List[str]): A list of strings to be tested. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_rearrange_no_adjacent(3, [\\"AABB\\", \\"AAAB\\", \\"ABAB\\"]) ['YES', 'NO', 'YES'] pass def solve(input_data: str) -> List[str]: Reads input data, processes it and returns the results for each test case. Args: input_data (str): Input string containing test cases in the format: t (number of test cases) followed by t lines each containing a string. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. Example: >>> input_data = \\"3nAABBnAAABnABABn\\" >>> solve(input_data) ['YES', 'NO', 'YES'] pass","solution":"from collections import Counter def can_rearrange_no_adjacent(t, cases): results = [] for s in cases: char_count = Counter(s) max_freq = max(char_count.values()) if max_freq > (len(s) + 1) // 2: results.append(\\"NO\\") else: results.append(\\"YES\\") return results def solve(input_data): input_lines = input_data.strip().split(\\"n\\") t = int(input_lines[0]) cases = input_lines[1:t+1] return can_rearrange_no_adjacent(t, cases)"},{"question":"from typing import List, Tuple def travel_costs(n: int, cleanliness: List[int], m: int, edges: List[Tuple[int, int]], k: int, travels: List[Tuple[int, int]]) -> List[int]: Calculate the travel cost for each visitor based on the kingdom's village layout. >>> travel_costs(5, [10, 20, 30, 40, 50], 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 3, [(1, 3), (2, 4), (5, 1)]) [20, 20, 40] >>> travel_costs(1, [10], 0, [], 1, [(1, 1)]) [0] >>> travel_costs(2, [10, 15], 1, [(1, 2)], 1, [(1, 2)]) [5] >>> travel_costs(4, [1, 3, 6, 8], 4, [(1, 2), (2, 3), (3, 4), (1, 3)], 2, [(1, 4), (4, 1)]) [7, 7] >>> travel_costs(3, [10, 30, 20], 1, [(1, 2)], 2, [(1, 3), (3, 1)]) [float('inf'), float('inf')]","solution":"import heapq def travel_costs(n, cleanliness, m, edges, k, travels): adj = [[] for _ in range(n)] for a, b in edges: a -= 1 b -= 1 cost = abs(cleanliness[a] - cleanliness[b]) adj[a].append((cost, b)) adj[b].append((cost, a)) def dijkstra(start, end): costs = [float('inf')] * n costs[start] = 0 priority_queue = [(0, start)] heapq.heapify(priority_queue) while priority_queue: current_cost, current_node = heapq.heappop(priority_queue) if current_node == end: return current_cost if current_cost > costs[current_node]: continue for next_cost, neighbor in adj[current_node]: new_cost = current_cost + next_cost if new_cost < costs[neighbor]: costs[neighbor] = new_cost heapq.heappush(priority_queue, (new_cost, neighbor)) return costs[end] result = [] for s, l in travels: s -= 1 l -= 1 result.append(dijkstra(s, l)) return result"},{"question":"def sequence_transformation(m: int, sequence: List[int]) -> int: Repeatedly applies the transformation function g to the sequence until it is reduced to a single integer. Parameters: m (int): The length of the sequence. sequence (list): The initial sequence of integers. Returns: int: The single integer result after repeatedly applying the transformation. Examples: >>> sequence_transformation(4, [4, 1, 8, 3]) 34 >>> sequence_transformation(3, [1, 1, 1]) 4 >>> sequence_transformation(2, [100, 200]) 300 >>> sequence_transformation(5, [1, 2, 3, 4, 5]) 48 >>> sequence_transformation(3, [1000, 1000, 1000]) 4000","solution":"def sequence_transformation(m, sequence): Repeatedly applies the transformation function g to the sequence until it is reduced to a single integer. Parameters: m (int): The length of the sequence. sequence (list): The initial sequence of integers. Returns: int: The single integer result after repeatedly applying the transformation. while len(sequence) > 1: sequence = [sequence[i] + sequence[i + 1] for i in range(len(sequence) - 1)] return sequence[0]"},{"question":"def longest_contiguous_equal_subarray_length(n: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray where all elements are equal. Parameters: n (int): Number of elements in the list. arr (list): List of n integers. Returns: int: Length of the longest contiguous subarray where all elements are equal. >>> longest_contiguous_equal_subarray_length(9, [1, 1, 2, 2, 2, 3, 3, 3, 3]) 4 >>> longest_contiguous_equal_subarray_length(5, [5, 5, 5, 5, 5]) 5 >>> longest_contiguous_equal_subarray_length(5, [1, 2, 3, 4, 5]) 1 >>> longest_contiguous_equal_subarray_length(10, [1, 1, 2, 2, 2, 3, 3, 3, 3, 3]) 5 >>> longest_contiguous_equal_subarray_length(1, [1]) 1 >>> longest_contiguous_equal_subarray_length(0, []) 0","solution":"def longest_contiguous_equal_subarray_length(n, arr): Returns the length of the longest contiguous subarray where all elements are equal. Parameters: n (int): Number of elements in the list. arr (list): List of n integers. Returns: int: Length of the longest contiguous subarray where all elements are equal. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] == arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def longest_contiguous_subsequence_with_limited_diff(n: int, sequence: List[int], k: int) -> int: Determine the length of the longest contiguous subsequence where the difference between the maximum and minimum element is at most k. >>> longest_contiguous_subsequence_with_limited_diff(5, [1, 3, 5, 7, 9], 4) 3 >>> longest_contiguous_subsequence_with_limited_diff(6, [4, 6, 7, 1, 3, 5], 3) 3 >>> longest_contiguous_subsequence_with_limited_diff(7, [1, 2, 2, 2, 2, 2, 2], 0) 6 >>> longest_contiguous_subsequence_with_limited_diff(7, [1, 2, 3, 4, 5, 6, 7], 1) 2 >>> longest_contiguous_subsequence_with_limited_diff(8, [1, 2, 3, 4, 5, 6, 7, 8], 7) 8 >>> longest_contiguous_subsequence_with_limited_diff(3, [1, 10, 20], 5) 1 >>> longest_contiguous_subsequence_with_limited_diff(4, [10, 20, 15, 25], 15) 4","solution":"def longest_contiguous_subsequence_with_limited_diff(n, sequence, k): Determine the length of the longest contiguous subsequence where the difference between the maximum and minimum element is at most k. max_length = 0 for i in range(n): current_min = current_max = sequence[i] for j in range(i, n): current_min = min(current_min, sequence[j]) current_max = max(current_max, sequence[j]) if current_max - current_min <= k: max_length = max(max_length, j - i + 1) else: break return max_length"},{"question":"def has_divisible_pair(arr: List[int], k: int) -> str: Determines if there exists a pair of indices (i, j) such that 1 ≤ i < j ≤ n and the sum of arr[i] + arr[j] is divisible by k. :param arr: List[int], array of integers :param k: int, the divisor :return: str, \\"Yes\\" or \\"No\\" >>> has_divisible_pair([12, 25, 9, 6, 15], 5) == \\"Yes\\" >>> has_divisible_pair([5, 9, 13], 4) == \\"No\\"","solution":"def has_divisible_pair(arr, k): Determines if there exists a pair of indices (i, j) such that 1 ≤ i < j ≤ n and the sum of arr[i] + arr[j] is divisible by k. :param arr: List[int], array of integers :param k: int, the divisor :return: str, \\"Yes\\" or \\"No\\" n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: return \\"Yes\\" return \\"No\\""},{"question":"def longest_increasing_subsequence(array: List[int]) -> int: Given an array of integers, find the length of the longest subsequence in which the elements are in sorted order (strictly increasing). >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([1, 3, 2, 3, 4, 5, 0, 6]) 6 >>> longest_increasing_subsequence([7, 6, 5, 4, 3, 2, 1]) 1","solution":"def longest_increasing_subsequence(array): Returns the length of the longest strictly increasing subsequence in the given array of integers. if not array: return 0 # Initialize DP array where dp[i] will store the length of the LIS ending at index i dp = [1] * len(array) for i in range(1, len(array)): for j in range(i): if array[i] > array[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def find_pair_with_sum(nums: List[int], target: int) -> List[int]: Given a list of integers, determine if there exists a pair of distinct indices (i, j) such that the sum of the elements at these indices equals the target value. Return the indices if such a pair exists, otherwise return an empty list. Args: nums (List[int]): A list of integers. target (int): The target sum we are looking for. Returns: List[int]: A list of two integers representing the indices of the elements that add up to the target value, or an empty list if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) [0, 1] >>> find_pair_with_sum([3, 2, 4], 6) [1, 2] >>> find_pair_with_sum([3, 3], 6) [0, 1] pass","solution":"from typing import List def find_pair_with_sum(nums: List[int], target: int) -> List[int]: Returns a list of two integers representing the indices of the elements that add up to the target value, or an empty list if no such pair is found. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def highest_possible_score(n: int, scores: List[int]) -> int: Determine the highest score that can be achieved by any participant after excluding at most one score from the array. Args: n (int): The number of participants. scores (List[int]): The scores of the participants. Returns: int: The highest possible score after excluding at most one score. >>> highest_possible_score(5, [3, 7, 5, 6, 2]) 21 >>> highest_possible_score(4, [4, 4, 4, 4]) 12 >>> highest_possible_score(3, [5, 10, 3]) 15 >>> highest_possible_score(6, [10, 9, 8, 7, 6, 5]) 40 >>> highest_possible_score(2, [1, 2]) 2 >>> highest_possible_score(100000, list(range(1, 100001))) 5000049999","solution":"def highest_possible_score(n, scores): Returns the highest possible score by excluding at most one score from the list. # Calculate the sum of all scores total_score = sum(scores) # Find the minimum score in the list min_score = min(scores) # The highest possible score is obtained by removing the minimum score from the total return total_score - min_score"},{"question":"def min_rotations_to_upright(fields): Determine the minimal number of 90-degree rotations required for each field to align with the coordinate axes. >>> min_rotations_to_upright([[(0, 0), (1, 0), (1, 1), (0, 1)], [(0, 0), (2, 1), (3, 4), (-1, 3)]]) [0, -1] >>> min_rotations_to_upright([[(1, 1), (3, 1), (3, 3), (1, 3)]]) [0] >>> min_rotations_to_upright([[(1, 1), (2, 3), (4, 3), (3, 1)]]) [-1] >>> min_rotations_to_upright([[(1, 1), (3, 1), (3, 3), (1, 3)], [(0, 0), (2, 1), (3, 4), (-1, 3)], [(2, 2), (4, 2), (4, 5), (2, 5)]]) [0, -1, 0] >>> min_rotations_to_upright([[(0, 0), (0, 1), (1, 1), (1, 0)], [(2, 2), (2, 3), (3, 3), (3, 2)]]) [0, 0]","solution":"def min_rotations_to_upright(fields): results = [] for field in fields: x_coords = [field[i][0] for i in range(4)] y_coords = [field[i][1] for i in range(4)] intersections_x = len(set(x_coords)) intersections_y = len(set(y_coords)) if intersections_x == 2 and intersections_y == 2: results.append(0) else: results.append(-1) return results"},{"question":"def count_less_than_elements(n: int, a: List[int]) -> List[int]: Constructs an array b such that for each integer c in a, its position in b is the count of numbers in a that are less than c. :param n: Number of integers :param a: List of n distinct integers :return: List of integers representing the counts of numbers less than each element in array a >>> count_less_than_elements(3, [3, 1, 2]) [2, 0, 1] >>> count_less_than_elements(3, [1, 3, 2]) [0, 2, 1] >>> count_less_than_elements(1, [5]) [0] >>> count_less_than_elements(4, [10, 20, 30, 40]) [0, 1, 2, 3] >>> count_less_than_elements(5, [1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> count_less_than_elements(5, [5, 4, 3, 2, 1]) [4, 3, 2, 1, 0] >>> count_less_than_elements(4, [7, -3, 2, 5]) [3, 0, 1, 2] >>> count_less_than_elements(3, [1000000, -1000000, 0]) [2, 0, 1]","solution":"def count_less_than_elements(n, a): Constructs an array b such that for each integer c in a, its position in b is the count of numbers in a that are less than c. :param n: Number of integers :param a: List of n distinct integers :return: List of integers representing the counts of numbers less than each element in array a b = [] for i in range(n): count = sum(1 for x in a if x < a[i]) b.append(count) return b"},{"question":"def find_single_number(nums: List[int]) -> int: Finds the single number in a list where every number except one appears exactly three times. >>> find_single_number([2, 2, 3, 2, 4, 4, 4]) 3 >>> find_single_number([1, 1, 1, 5]) 5 >>> find_single_number([0, 0, 0, 7]) 7 >>> find_single_number([6, 6, 6, 8, 9, 9, 9, 10, 10, 10]) 8 >>> find_single_number([11, 22, 11, 22, 11, 22, 5]) 5 def parse_input_and_find_single_number(input_data: str) -> int: Parses the input data to extract the list of numbers and calls the \`find_single_number\` function to find the result. >>> input_data = \\"7n2 2 3 2 4 4 4\\" >>> parse_input_and_find_single_number(input_data) 3 >>> input_data = \\"4n1 1 1 5\\" >>> parse_input_and_find_single_number(input_data) 5 >>> input_data = \\"4n0 0 0 7\\" >>> parse_input_and_find_single_number(input_data) 7 >>> input_data = \\"10n6 6 6 8 9 9 9 10 10 10\\" >>> parse_input_and_find_single_number(input_data) 8 >>> input_data = \\"7n11 22 11 22 11 22 5\\" >>> parse_input_and_find_single_number(input_data) 5","solution":"def find_single_number(nums): Finds the single number in a list where every number except one appears exactly three times. ones, twos = 0, 0 for num in nums: # Add \`num\` to \`twos\` if it is already in \`ones\` twos |= ones & num # Add \`num\` to \`ones\` ones ^= num # \`threes\` will contain all the numbers appearing three times threes = ones & twos # Remove \`threes\` from \`ones\` and \`twos\` ones &= ~threes twos &= ~threes return ones def parse_input_and_find_single_number(input_data): Parses the input data to extract the list of numbers and calls the \`find_single_number\` function to find the result. lines = input_data.strip().split(\\"n\\") n = int(lines[0]) nums = list(map(int, lines[1].strip().split())) return find_single_number(nums)"},{"question":"import heapq class HospitalQueue: def __init__(self): Initialize your data structure here. pass def add(self, name, priority): Add a patient with the given name and priority to the queue. :param name: str, the name of the patient :param priority: int, the priority of the patient pass def serve(self): Serve the patient with the highest priority and return their name. :return: str, the name of the served patient pass def retrieve(self): Retrieve the current state of the queue as a list of patient names. :return: str, the patient names in the order they would be served pass def test_hospital_queue_operations(): hq = HospitalQueue() hq.add('Alice', 5) hq.add('Bob', 1) hq.add('Charlie', 5) assert hq.retrieve() == 'Alice Charlie Bob' assert hq.serve() == 'Alice' assert hq.retrieve() == 'Charlie Bob' assert hq.serve() == 'Charlie' assert hq.retrieve() == 'Bob' assert hq.serve() == 'Bob' assert hq.retrieve() == '' def test_hospital_queue_with_varied_priorities(): hq = HospitalQueue() hq.add('Alice', 5) hq.add('Bob', 3) hq.add('Charlie', 4) hq.add('David', 5) assert hq.retrieve() == 'Alice David Charlie Bob' assert hq.serve() == 'Alice' assert hq.retrieve() == 'David Charlie Bob' assert hq.serve() == 'David' assert hq.serve() == 'Charlie' assert hq.serve() == 'Bob' assert hq.retrieve() == '' def test_hospital_queue_same_priority_order(): hq = HospitalQueue() hq.add('Alice', 3) hq.add('Bob', 3) hq.add('Charlie', 3) assert hq.retrieve() == 'Alice Bob Charlie' assert hq.serve() == 'Alice' assert hq.serve() == 'Bob' assert hq.serve() == 'Charlie' assert hq.retrieve() == '' def test_hospital_queue_empty_serve(): hq = HospitalQueue() assert hq.serve() is None assert hq.retrieve() == ''","solution":"import heapq class HospitalQueue: def __init__(self): self.queue = [] self.counter = 0 self.entries = {} def add(self, name, priority): entry = (-priority, self.counter, name) # Use negative priority for max-heap effect heapq.heappush(self.queue, entry) self.entries[name] = entry self.counter += 1 def serve(self): while self.queue: _, _, name = heapq.heappop(self.queue) if name in self.entries: del self.entries[name] return name return None def retrieve(self): result = [] temp_queue = [] while self.queue: entry = heapq.heappop(self.queue) if entry[2] in self.entries: result.append(entry[2]) temp_queue.append(entry) for item in temp_queue: heapq.heappush(self.queue, item) return \\" \\".join(result)"},{"question":"def roman_to_int(roman: str) -> int: Converts a Roman numeral to its integer equivalent. Parameters: roman (str): String representing a Roman numeral (valid, uppercase, range 1 to 3999). Returns: int: Integer equivalent of the Roman numeral. Examples: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994","solution":"def roman_to_int(roman): Converts a Roman numeral to its integer equivalent. Parameters: roman (str): String representing a Roman numeral (valid, uppercase, range 1 to 3999). Returns: int: Integer equivalent of the Roman numeral. roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def max_non_adjacent_sum(arr): Given an array of integers, determine the max-sum of a subarray with the constraint that no two elements in the subarray are adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 13 >>> max_non_adjacent_sum([-1, 3, -2, 4, -5]) 7 >>> max_non_adjacent_sum([2, 1, 4, 9]) 11 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([-100]) 0","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements in the given array. if not arr: return 0 n = len(arr) if n == 1: return max(0, arr[0]) prev1 = max(0, arr[0]) prev2 = max(0, arr[1], arr[0]) if n == 2: return prev2 for i in range(2, n): current = max(prev2, prev1 + arr[i]) prev1 = prev2 prev2 = current return prev2"},{"question":"def make_beautiful_garden(n, f): Make the garden beautiful by using at most n/2 operations. Parameters: n (int): The length of the garden. f (string): The garden represented as a string of 'R' and 'B'. Returns: (int, List[Tuple[int, int]]): The number of operations and the list of operations to perform. pass def arrange_flowers(t, test_cases): Arrange flowers for multiple test cases. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, str]]): List of tuples where each tuple contains the length of the garden and the garden string. Returns: List[Tuple[int, List[Tuple[int, int]]]]: List of results for each test case. Each result is a tuple containing the number of operations and the list of operations. pass from typing import List, Tuple def test_single_case_1(): t = 1 test_cases = [(6, \\"RBRRRB\\")] expected_outputs = [(1, [(3, 4)])] assert arrange_flowers(t, test_cases) == expected_outputs def test_single_case_2(): t = 1 test_cases = [(4, \\"RRBB\\")] expected_outputs = [(2, [(1, 2), (3, 4)])] assert arrange_flowers(t, test_cases) == expected_outputs def test_multiple_cases(): t = 2 test_cases = [ (6, \\"RBRRRB\\"), (4, \\"RRBB\\") ] expected_outputs = [ (1, [(3, 4)]), (2, [(1, 2), (3, 4)]) ] assert arrange_flowers(t, test_cases) == expected_outputs def test_case_already_beautiful(): t = 1 test_cases = [(5, \\"RBRBR\\")] expected_outputs = [(0, [])] assert arrange_flowers(t, test_cases) == expected_outputs def test_case_max_operations(): t = 1 test_cases = [(8, \\"RRRRBBBB\\")] expected_outputs = [(4, [(1, 2), (3, 4), (5, 6), (7, 8)])] assert arrange_flowers(t, test_cases) == expected_outputs","solution":"def make_beautiful_garden(n, f): Make the garden beautiful by using at most n/2 operations. Parameters: n (int): The length of the garden. f (string): The garden represented as a string of 'R' and 'B'. Returns: (int, List[Tuple[int, int]]): The number of operations and the list of operations to perform. operations = [] i = 0 while i < n - 1: if f[i] == f[i + 1]: operations.append((i + 1, i + 2)) # Flip the substring from i+1 to i+2 f = f[:i] + ('B' if f[i] == 'R' else 'R') + ('R' if f[i + 1] == 'B' else 'B') + f[i + 2:] # Move to the next character after the flip i += 1 i += 1 return (len(operations), operations) def arrange_flowers(t, test_cases): Arrange flowers for multiple test cases. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, str]]): List of tuples where each tuple contains the length of the garden and the garden string. Returns: List[Tuple[int, List[Tuple[int, int]]]]: List of results for each test case. Each result is a tuple containing the number of operations and the list of operations. results = [] for n, f in test_cases: results.append(make_beautiful_garden(n, f)) return results"},{"question":"import numpy as np def identify_unitary(unitary): Identify the given single-qubit unitary transformation as X or Y gate. Returns 0 if it was the X gate or 1 if it was the Y gate. Args: unitary (function): A function that applies the given unitary operation to a state. Returns: int: 0 if the unitary is X, 1 if the unitary is Y. # Define the |0> and |1> states # Apply the unitary to the |0> and |1> states # The X gate swaps |0> and |1> # The Y gate maps |0> to i|1> and |1> to -i|0> raise ValueError(\\"Unknown unitary operation provided\\") def test_identify_X_gate(): assert identify_unitary(X_gate) == 0 def test_identify_Y_gate(): assert identify_unitary(Y_gate) == 1 def test_invalid_unitary_operation(): def invalid_unitary(state): return state # does nothing try: identify_unitary(invalid_unitary) assert False, \\"Expected ValueError\\" except ValueError: pass","solution":"import numpy as np def identify_unitary(unitary): Identify the given single-qubit unitary transformation as X or Y gate. Returns 0 if it was the X gate or 1 if it was the Y gate. Args: unitary (function): A function that applies the given unitary operation to a state. Returns: int: 0 if the unitary is X, 1 if the unitary is Y. # Define the |0> and |1> states zero_state = np.array([1, 0], dtype=complex) one_state = np.array([0, 1], dtype=complex) # Apply the unitary to the |0> and |1> states transformed_zero = unitary(zero_state) transformed_one = unitary(one_state) # The X gate swaps |0> and |1> if (np.allclose(transformed_zero, one_state) and np.allclose(transformed_one, zero_state)): return 0 # The Y gate maps |0> to i|1> and |1> to -i|0> i = 1j if (np.allclose(transformed_zero, i * one_state) and np.allclose(transformed_one, -i * zero_state)): return 1 raise ValueError(\\"Unknown unitary operation provided\\")"},{"question":"def chocolate_bar_break(n: int, m: int) -> int: Calculate the minimum number of operations to split an n x m chocolate bar into individual squares. Args: n (int): The number of rows of the chocolate bar. m (int): The number of columns of the chocolate bar. Returns: int: The minimum number of operations required. Examples: >>> chocolate_bar_break(2, 2) 3 >>> chocolate_bar_break(3, 1) 2","solution":"def chocolate_bar_break(n, m): Returns the number of operations to split an n x m chocolate bar into individual 1x1 pieces. # In an n x m chocolate bar, we need (n-1) horizontal cuts and (m-1) vertical cuts. # Thus, the minimum number of cuts/operations needed is (n * m - 1) return n * m - 1"},{"question":"def filter_and_remove_duplicates(posts: List[str]) -> List[str]: Filters out image posts and removes duplicate text posts, keeping only the first occurrence in their original order. :param posts: List of posts (strings) :return: Filtered list of unique text posts in their original order >>> filter_and_remove_duplicates([ ... \\"Hello World!\\", ... \\"img:http://example.com/image1.png\\", ... \\"Exciting news!\\", ... \\"img:http://example.com/image2.png\\", ... \\"Hello World!\\" ... ]) ['Hello World!', 'Exciting news!'] >>> filter_and_remove_duplicates([\\"Good morning\\", \\"Good night\\", \\"Good morning\\"]) ['Good morning', 'Good night']","solution":"def filter_and_remove_duplicates(posts): Filters out image posts and removes duplicate text posts, keeping only the first occurrence in their original order. :param posts: List of posts (strings) :return: Filtered list of unique text posts in their original order seen = set() result = [] for post in posts: if post.startswith(\\"img:\\"): continue if post not in seen: seen.add(post) result.append(post) return result"},{"question":"def count_valid_subsequences(arr, L, R): Given an array of integers and a range [L, R], this function returns the number of subsequences that have at least one element within the range. >>> count_valid_subsequences([1, 2, 3], 2, 3) # 6 >>> count_valid_subsequences([5], 2, 8) # 1 >>> count_valid_subsequences([1], 2, 3) # 0 >>> count_valid_subsequences([2, 3, 4], 2, 5) # 7 >>> count_valid_subsequences([1, 2, 3], 4, 5) # 0 >>> count_valid_subsequences([5, 6, 10, 15], 5, 10) # 14","solution":"def count_valid_subsequences(arr, L, R): Given an array of integers and a range [L, R], this function returns the number of subsequences that have at least one element within the range. total_subsequences = (1 << len(arr)) - 1 invalid_subsequences = 1 for num in arr: if num < L or num > R: invalid_subsequences *= 2 return total_subsequences - invalid_subsequences + 1 # Sample input n = 3 arr = [1, 2, 3] L, R = 2, 3 print(count_valid_subsequences(arr, L, R)) # Should print 6"},{"question":"def count_unique_books(logbook): Returns a dictionary where keys are customer ids and values are the number of unique books read by that customer. :param logbook: List of tuples, each tuple contains a customer id and a book id. :return: Dictionary with customer id as keys and number of unique books as values. pass def process_logbook(entries): Parses a list of logbook entries and returns the number of unique books read by each customer. :param entries: List of strings, first entry is the number of logbook entries, followed by pairs of customer id and book id. :return: Dictionary with customer id and number of unique books read. pass # Unit Tests def test_single_customer_multiple_books(): entries = [ \\"5\\", \\"1 10\\", \\"1 20\\", \\"1 30\\", \\"1 40\\", \\"1 10\\" ] assert process_logbook(entries) == {1: 4} def test_multiple_customers(): entries = [ \\"6\\", \\"1 10\\", \\"2 10\\", \\"1 20\\", \\"2 30\\", \\"3 20\\", \\"3 30\\" ] assert process_logbook(entries) == {1: 2, 2: 2, 3: 2} def test_customer_with_repeated_books(): entries = [ \\"6\\", \\"1 10\\", \\"1 10\\", \\"1 10\\", \\"2 20\\", \\"2 20\\", \\"3 30\\" ] assert process_logbook(entries) == {1: 1, 2: 1, 3: 1} def test_empty_logbook(): entries = [ \\"0\\" ] assert process_logbook(entries) == {} def test_mixed_entries(): entries = [ \\"7\\", \\"1 10\\", \\"2 10\\", \\"1 20\\", \\"2 30\\", \\"3 20\\", \\"3 30\\", \\"2 10\\" ] assert process_logbook(entries) == {1: 2, 2: 2, 3: 2}","solution":"def count_unique_books(logbook): Returns a dictionary where keys are customer ids and values are the number of unique books read by that customer. :param logbook: List of tuples, each tuple contains a customer id and a book id. :return: Dictionary with customer id as keys and number of unique books as values. customer_books = {} for ci, bi in logbook: if ci not in customer_books: customer_books[ci] = set() customer_books[ci].add(bi) result = {k: len(v) for k, v in customer_books.items()} return dict(sorted(result.items())) def process_logbook(entries): Parses a list of logbook entries and returns the number of unique books read by each customer. :param entries: List of strings, first entry is the number of logbook entries, followed by pairs of customer id and book id. :return: List of tuples with customer id and number of unique books read. n = int(entries[0]) logbook = [tuple(map(int, entry.split())) for entry in entries[1:n+1]] return count_unique_books(logbook)"},{"question":"def max_product_triplet(arr: List[int]) -> Union[Tuple[int, int, int], None]: Returns a triplet (a, b, c) such that a < b < c and the product a * b * c is maximized among the elements of the array arr. If no such triplet exists, returns None. >>> max_product_triplet([1, 2, 3, 4, 5, 6]) (4, 5, 6) >>> max_product_triplet([-10, -10, 5, 2, 1]) (-10, -10, 5) >>> max_product_triplet([1, 1, 1]) (1, 1, 1) >>> max_product_triplet([1, 2]) None","solution":"def max_product_triplet(arr): Returns a triplet (a, b, c) such that a < b < c and the product a * b * c is maximized. If no such triplet exists, returns None. n = len(arr) if n < 3: return None arr.sort() # Possible triplets: # 1. Three largest positives: (arr[-3], arr[-2], arr[-1]) # 2. Two smallest negatives and largest positive: (arr[0], arr[1], arr[-1]) candidate1 = arr[-3] * arr[-2] * arr[-1] candidate2 = arr[0] * arr[1] * arr[-1] if candidate1 >= candidate2: return arr[-3], arr[-2], arr[-1] else: return arr[0], arr[1], arr[-1]"},{"question":"def max_elevation_sum(grid: List[List[int]]) -> int: Given an \`n x n\` grid of integers where each cell represents the elevation at that point, determine the maximum sum of elevations possible starting from any cell in the first row to any cell in the last row. >>> grid = [ ... [10, 11, 12], ... [14, 13, 10], ... [17, 15, 19] ... ] >>> max_elevation_sum(grid) 44 >>> grid = [ ... [1, 2], ... [3, 4] ... ] >>> max_elevation_sum(grid) 6 >>> grid = [ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ] >>> max_elevation_sum(grid) 15 >>> grid = [ ... [1] * 1000, ... *([[i] * 1000 for i in range(2, 1001)]) ... ] >>> max_elevation_sum(grid) sum(range(1, 1001)) >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_elevation_sum(grid) 18","solution":"from typing import List def max_elevation_sum(grid: List[List[int]]) -> int: n = len(grid) dp = [[0] * n for _ in range(n)] # Initialize the dp array with the first row of the grid for j in range(n): dp[0][j] = grid[0][j] # Fill the dp array for i in range(1, n): for j in range(n): dp[i][j] = grid[i][j] max_prev = dp[i-1][j] if j > 0: max_prev = max(max_prev, dp[i-1][j-1]) if j < n - 1: max_prev = max(max_prev, dp[i-1][j+1]) dp[i][j] += max_prev # The result is the maximum value in the last row return max(dp[n-1])"},{"question":"def can_complete_activities(n: int, activities: List[Tuple[int, int]]) -> Tuple[str, Union[List[int], int]]: Determines if Alex can complete all the activities within their deadlines, and if so, returns the earliest completion times for each activity. If not, returns the index of the first activity that cannot be completed on time. :param n: Number of activities :param activities: List of tuples, each containing the duration di and deadline ti of an activity :return: \\"YES\\" followed by completion times if all activities can be completed on time, otherwise \\"NO\\" and the index of the first problematic activity >>> can_complete_activities(5, [(3, 10), (7, 15), (2, 17), (5, 20), (6, 25)]) (\\"YES\\", [3, 10, 12, 17, 23]) >>> can_complete_activities(3, [(5, 3), (2, 10), (1, 12)]) (\\"NO\\", 0) >>> can_complete_activities(4, [(2, 5), (3, 10), (2, 15), (10, 16)]) (\\"NO\\", 3) >>> can_complete_activities(3, [(2, 2), (4, 6), (1, 7)]) (\\"YES\\", [2, 6, 7]) >>> can_complete_activities(1, [(5, 10)]) (\\"YES\\", [5]) >>> can_complete_activities(2, [(10**4, 10**4), (10**4, 2 * 10**4)]) (\\"YES\\", [10**4, 2 * 10**4])","solution":"def can_complete_activities(n, activities): Determines if Alex can complete all the activities within their deadlines, and if so, returns the earliest completion times for each activity. If not, returns the index of the first activity that cannot be completed on time. :param n: Number of activities :param activities: List of tuples, each containing the duration di and deadline ti of an activity :return: \\"YES\\" followed by completion times if all activities can be completed on time, otherwise \\"NO\\" and the index of the first problematic activity current_time = 0 completion_times = [] for i in range(n): d, t = activities[i] current_time += d if current_time > t: return \\"NO\\", i completion_times.append(current_time) return \\"YES\\", completion_times"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Calculates the maximum sum of any contiguous subarray of size k within the given array. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([5], 1) 5 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4], 4) 6 >>> max_sum_subarray([1, 2, 3, 4, 5], 1) 5 >>> max_sum_subarray([10**5] * 10**6, 3) 300000 >>> max_sum_subarray([1, -1, 1, -1, 1, -1], 6) 0","solution":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Calculates the maximum sum of any contiguous subarray of size k within the given array. # Calculate the sum of the first window max_sum = current_sum = sum(arr[:k]) # Slide the window over the array, updating the sum and tracking the maximum sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def process_operations(n: int, q: int, operations: List[Tuple[int, ...]]) -> List[int]: Process a sequence of operations on an integer sequence and return the results of query operations. Each operation is either of type \`1 x\` which updates the value at position x to 1, or type \`2\` which queries the longest contiguous subsequence of 1s. Args: n : int : Length of the sequence q : int : Number of operations operations : List[Tuple[int, ...]] : List of operations to perform Returns: List[int] : List of results of query operations Example: >>> process_operations(5, 6, [(1, 2), (1, 4), (2,), (1, 3), (2,), (1, 5)]) [1, 3] >>> process_operations(5, 5, [(1, 1), (1, 2), (1, 3), (1, 4), (2,)]) [4] import pytest from solution import process_operations def test_operations_example(): n = 5 q = 6 operations = [ (1, 2), (1, 4), (2,), (1, 3), (2,), (1, 5), ] expected_output = [1, 3] assert process_operations(n, q, operations) == expected_output def test_operations_all_updates_then_queries(): n = 5 q = 5 operations = [ (1, 1), (1, 2), (1, 3), (1, 4), (2,), ] expected_output = [4] assert process_operations(n, q, operations) == expected_output def test_operations_sparse_updates(): n = 7 q = 8 operations = [ (1, 1), (2,), (1, 3), (2,), (1, 5), (2,), (1, 7), (2,), ] expected_output = [1, 1, 1, 1] assert process_operations(n, q, operations) == expected_output def test_operations_contiguous_updates(): n = 7 q = 8 operations = [ (1, 1), (1, 2), (1, 3), (2,), (1, 4), (1, 5), (2,), (1, 6) ] expected_output = [3, 5] assert process_operations(n, q, operations) == expected_output def test_operations_no_updates(): n = 5 q = 3 operations = [ (2,), (2,), (2,), ] expected_output = [0, 0, 0] assert process_operations(n, q, operations) == expected_output","solution":"def process_operations(n, q, operations): sequence = [0] * n max_lens = [] # List to hold the results of '2' operations def update(x): sequence[x-1] = 1 def query(): max_len = curr_len = 0 for val in sequence: if val == 1: curr_len += 1 max_len = max(max_len, curr_len) else: curr_len = 0 return max_len for operation in operations: if operation[0] == 1: update(operation[1]) elif operation[0] == 2: max_lens.append(query()) return max_lens"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of a contiguous subarray. Parameters: arr (list): List of integers representing the growth rates of the plant. Returns: int: The maximum sum of any contiguous subarray. >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([4, -1, 2, 1]) 6 >>> max_subarray_sum([-2, 3, -1, 2, -1, 3, -2]) 6","solution":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray. Parameters: arr (list): List of integers representing the growth rates of the plant. Returns: int: The maximum sum of any contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Calculate and return the number of cells in the shortest path from the top-left to the bottom-right of the grid, or -1 if there is no such path. >>> shortest_path([[0, 1, 0], [0, 0, 0], [1, 1, 0]]) 5 >>> shortest_path([[0, 1, 0], [1, 1, 0], [1, 1, 0]]) -1 >>> shortest_path([[0]]) 1 >>> shortest_path([[0]*1000 for _ in range(1000)]) 1999 >>> shortest_path([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) -1 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) -1","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # no path found"},{"question":"from typing import List, Tuple def longest_path_with_stops(castles: int, portals: int, paths: List[Tuple[int, int, int]], stops: int) -> int: Compute the maximum amount of magic energy consumed on any valid path starting from Castle 1 and making exactly M stops. Args: castles (int): The number of castles. portals (int): The number of portals. paths (List[Tuple[int, int, int]]): Each tuple contains three integers (u, v, w) indicating a portal from castle u to castle v with a magic fee of w units. stops (int): The number of stops required on the path. Returns: int: The maximum amount of magic energy consumed on any valid path with exactly M stops, or -1 if no such path exists. Examples: >>> longest_path_with_stops(5, 7, [(1, 2, 4), (2, 3, 5), (3, 4, 9), (1, 3, 7), (1, 4, 2), (4, 5, 1), (3, 5, 6)], 4) 18 >>> longest_path_with_stops(4, 3, [(1, 2, 2), (2, 3, 3), (3, 4, 4)], 5) -1","solution":"def longest_path_with_stops(castles, portals, paths, stops): from collections import defaultdict import heapq # Building the graph from input paths graph = defaultdict(list) for u, v, w in paths: graph[u].append((v, w)) # DP table initialization dp = [[-float('inf')] * (stops + 1) for _ in range(castles + 1)] dp[1][1] = 0 # Starting from castle 1 with 1 stop # Priority Queue to explore nodes heap = [(-0, 1, 1)] # (negated magic_energy, current_castle, current_stops) # Process is similar to Bellman-Ford but with limited stops while heap: current_energy, current_castle, current_stops = heapq.heappop(heap) current_energy = -current_energy # Revert to positive if current_stops == stops: continue # No point in exploring further from here for next_castle, weight in graph[current_castle]: new_energy = current_energy + weight new_stops = current_stops + 1 if new_energy > dp[next_castle][new_stops]: dp[next_castle][new_stops] = new_energy heapq.heappush(heap, (-new_energy, next_castle, new_stops)) # Get the maximum value with exactly M stops from any castle (not necessarily 1) max_energy = max(dp[i][stops] for i in range(1, castles + 1)) return max_energy if max_energy != -float('inf') else -1"},{"question":"class ArrayOperations: def __init__(self, n, array): Initialize the ArrayOperations class with the array size and the array itself. self.n = n self.array = array def update(self, x, v): Update the x-th element of the array to the value v. def sum_query(self, l, r): Calculate the sum of integers in the subarray from the l-th element to the r-th element, inclusive. def process_queries(n, array, queries): Process a list of queries on the array and return the results for sum queries. Args: n: int : the number of elements in the array array: List[int] : the elements of the array queries: List[Tuple[int, int, int]] : the list of queries Returns: List[int] : the results of the sum queries >>> process_queries(5, [1, 5, 2, 4, -1], [(2, 1, 3), (1, 3, 10), (2, 2, 5), (1, 5, 0), (2, 1, 5)]) [8, 18, 20]","solution":"class ArrayOperations: def __init__(self, n, array): self.n = n self.array = array def update(self, x, v): self.array[x - 1] = v def sum_query(self, l, r): return sum(self.array[l - 1:r]) def process_queries(n, array, queries): arr_op = ArrayOperations(n, array) results = [] for query in queries: if query[0] == 1: _, x, v = query arr_op.update(x, v) elif query[0] == 2: _, l, r = query results.append(arr_op.sum_query(l, r)) return results"},{"question":"def count_quasi_primes(n: int) -> int: Returns the count of Quasi-Primes up to number n. Quasi-Primes are numbers of the form p^2 where p is a prime number. >>> count_quasi_primes(1) == 0 >>> count_quasi_primes(4) == 1 >>> count_quasi_primes(9) == 2 >>> count_quasi_primes(15) == 2 >>> count_quasi_primes(16) == 2 >>> count_quasi_primes(25) == 3 >>> count_quasi_primes(100) == 4 >>> count_quasi_primes(2) == 0 >>> count_quasi_primes(3) == 0 >>> count_quasi_primes(10**6 + 1) == 168 def process_queries(T: int, queries: List[int]) -> List[int]: Processes multiple queries to count Quasi-Primes in given ranges. >>> process_queries(1, [1]) == [0] >>> process_queries(3, [1, 4, 100]) == [0, 1, 4] >>> process_queries(2, [9, 25]) == [2, 3] >>> process_queries(1, [10**6]) == [168]","solution":"def count_quasi_primes(n): Returns the count of Quasi-Primes up to number n. Quasi-Primes are numbers of the form p^2 where p is a prime number. if n < 2: return 0 is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n + 1, i): is_prime[j] = False quasi_primes_count = 0 for i in range(2, int(n**0.5) + 1): if is_prime[i] and i*i <= n: quasi_primes_count += 1 return quasi_primes_count def process_queries(T, queries): results = [] for n in queries: results.append(count_quasi_primes(n)) return results"},{"question":"def minimize_difference(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Minimize the difference in the number of scenic spots visited each day of a hiking trip. :param t: An integer representing the number of test cases. :param test_cases: A list of tuples, each containing two integers, n and d, representing the number of scenic spots and the number of days respectively for each test case. :return: A list of integers representing the minimized difference for each test case. >>> minimize_difference(2, [(10, 3), (15, 4)]) [1, 2] >>> minimize_difference(1, [(10, 3)]) [1] >>> minimize_difference(2, [(12, 4), (20, 5)]) [0, 0] >>> minimize_difference(2, [(11, 3), (21, 5)]) [1, 1] >>> minimize_difference(2, [(100000, 100), (100001, 100)]) [0, 1]","solution":"def minimize_difference(t, test_cases): results = [] for n, d in test_cases: # Base number of spots each day and remainder base, remainder = divmod(n, d) if remainder == 0: results.append(0) else: results.append(1) return results # Example Usage: t = 2 test_cases = [ (10, 3), (15, 4) ] print(minimize_difference(t, test_cases)) # Output: [1, 1]"},{"question":"def min_removals_to_make_increasing(heights: List[int]) -> int: Returns the minimum number of students to remove to make the heights strictly increasing. >>> min_removals_to_make_increasing([5, 1, 3, 4, 2, 6, 1, 7]) == 3 >>> min_removals_to_make_increasing([1, 2, 3, 4, 5]) == 0 >>> min_removals_to_make_increasing([5, 4, 3, 2, 1]) == 4 >>> min_removals_to_make_increasing([10]) == 0 >>> min_removals_to_make_increasing([1, 3, 2, 4, 3, 5]) == 2 >>> min_removals_to_make_increasing([10, 3, 5, 6, 2, 8, 1, 9]) == 3 >>> min_removals_to_make_increasing([]) == 0 >>> min_removals_to_make_increasing(list(range(2*10**5, 0, -1))) == 2*10**5 - 1","solution":"import bisect def min_removals_to_make_increasing(heights): Returns the minimum number of students to remove to make the heights strictly increasing. if not heights: return 0 # Helper to find LIS using binary search. def lis_length(seq): lis = [] for height in seq: pos = bisect.bisect_left(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height return len(lis) n = len(heights) lis_len = lis_length(heights) return n - lis_len"},{"question":"from typing import List def maxWaterContainer(heights: List[int]) -> int: This function returns the maximum volume of water that can be held between any two buildings. Parameters: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The maximum volume of water that can be held between any two buildings. Examples: >>> maxWaterContainer([1,8,6,2,5,4,8,3,7]) 49 >>> maxWaterContainer([1,1]) 1 >>> maxWaterContainer([4,3,2,1,4]) 16 >>> maxWaterContainer([1,2,1]) 2 pass # your code here def test_example_1(): assert maxWaterContainer([1,8,6,2,5,4,8,3,7]) == 49 def test_example_2(): assert maxWaterContainer([1,1]) == 1 def test_example_3(): assert maxWaterContainer([4,3,2,1,4]) == 16 def test_example_4(): assert maxWaterContainer([1,2,1]) == 2 def test_increasing_heights(): assert maxWaterContainer([1,2,3,4,5,6,7,8,9]) == 20 def test_decreasing_heights(): assert maxWaterContainer([9,8,7,6,5,4,3,2,1]) == 20 def test_single_building(): assert maxWaterContainer([4]) == 0 def test_alternating_heights(): assert maxWaterContainer([1,3,2,4,1,5,1,6]) == 18 def test_same_heights(): assert maxWaterContainer([5,5,5,5,5,5,5,5]) == 35","solution":"def maxWaterContainer(heights): This function returns the maximum volume of water that can be held between any two buildings. Parameters: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The maximum volume of water that can be held between any two buildings. n = len(heights) left = 0 right = n - 1 max_volume = 0 while left < right: width = right - left height = min(heights[left], heights[right]) current_volume = width * height max_volume = max(max_volume, current_volume) # Move the shorter pointer towards the center if heights[left] < heights[right]: left += 1 else: right -= 1 return max_volume"},{"question":"class OperationHandler: def __init__(self, arr): Initializes the OperationHandler with the given list of integers. self.arr = arr def update(self, x, v): Update the value at position x to v. pass def sum(self, l, r): Return the sum of elements in the subarray from index l to r. >>> OperationHandler([1, 2, 3, 4, 5]).sum(1, 5) 15 >>> OperationHandler([1, 2, 3, 4, 5]).sum(2, 4) 9 pass def find_max(self, l, r): Return the maximum value in the subarray from index l to r. >>> OperationHandler([1, 2, 3, 4, 5]).find_max(1, 5) 5 >>> OperationHandler([1, 2, 3, 4, 5]).find_max(2, 4) 4 pass","solution":"class OperationHandler: def __init__(self, arr): self.arr = arr def update(self, x, v): Update the value at position x to v self.arr[x - 1] = v def sum(self, l, r): Return the sum of elements in the subarray from index l to r return sum(self.arr[l - 1:r]) def find_max(self, l, r): Return the maximum value in the subarray from index l to r return max(self.arr[l - 1:r])"},{"question":"from typing import List, Tuple def min_operations_to_make_anagram(a: str, b: str) -> int: Returns the minimum number of operations to make the strings a and b anagrams of each other. >>> min_operations_to_make_anagram(\\"listen\\", \\"silent\\") 0 >>> min_operations_to_make_anagram(\\"abc\\", \\"cba\\") 0 >>> min_operations_to_make_anagram(\\"abcdef\\", \\"ghijkl\\") 12 def min_operations_multiple_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Returns a list of minimum number of operations for multiple test cases to make the strings anagrams. >>> min_operations_multiple_cases([(\\"listen\\", \\"silent\\"), (\\"abc\\", \\"cba\\"), (\\"abcdef\\", \\"ghijkl\\")]) [0, 0, 12] >>> min_operations_multiple_cases([(\\"a\\", \\"b\\"), (\\"abc\\", \\"\\"), (\\"\\", \\"def\\")]) [2, 3, 3] def test_min_operations_to_make_anagram(): assert min_operations_to_make_anagram(\\"listen\\", \\"silent\\") == 0 assert min_operations_to_make_anagram(\\"abc\\", \\"cba\\") == 0 assert min_operations_to_make_anagram(\\"abcdef\\", \\"ghijkl\\") == 12 assert min_operations_to_make_anagram(\\"aabbcc\\", \\"abbccc\\") == 2 assert min_operations_to_make_anagram(\\"abcd\\", \\"dcbae\\") == 1 def test_min_operations_multiple_cases(): test_cases = [(\\"listen\\", \\"silent\\"), (\\"abc\\", \\"cba\\"), (\\"abcdef\\", \\"ghijkl\\")] expected_results = [0, 0, 12] assert min_operations_multiple_cases(test_cases) == expected_results test_cases = [(\\"a\\", \\"b\\"), (\\"abc\\", \\"\\"), (\\"\\", \\"def\\")] expected_results = [2, 3, 3] assert min_operations_multiple_cases(test_cases) == expected_results def test_edge_cases(): assert min_operations_to_make_anagram(\\"\\", \\"\\") == 0 assert min_operations_to_make_anagram(\\"a\\", \\"\\") == 1 assert min_operations_to_make_anagram(\\"\\", \\"a\\") == 1 assert min_operations_to_make_anagram(\\"z\\", \\"z\\") == 0","solution":"def min_operations_to_make_anagram(a, b): Returns the minimum number of operations to make the strings a and b anagrams of each other. from collections import Counter count_a = Counter(a) count_b = Counter(b) # Calculate differences total_diff = 0 for char in (set(a) | set(b)): total_diff += abs(count_a[char] - count_b[char]) return total_diff def min_operations_multiple_cases(test_cases): results = [] for a, b in test_cases: results.append(min_operations_to_make_anagram(a, b)) return results"},{"question":"def closestSubsetSum(n: int, nums: List[int], T: int) -> int: Find a subset of the given list of integers such that the sum of the subset is as close as possible to the target integer T. Return the sum of the subset that is closest to T. If there are multiple subsets with sums that are equally close to T, return the smallest sum among them. >>> closestSubsetSum(4, [1, 2, 3, 4], 6) 6 >>> closestSubsetSum(4, [1, 2, 3, 4], 10) 10 >>> closestSubsetSum(3, [-1, 2, 9], 1) 1","solution":"from itertools import combinations def closestSubsetSum(n, nums, T): closest_sum = float('inf') for r in range(n + 1): for subset in combinations(nums, r): subset_sum = sum(subset) if abs(subset_sum - T) < abs(closest_sum - T) or (abs(subset_sum - T) == abs(closest_sum - T) and subset_sum < closest_sum): closest_sum = subset_sum return closest_sum"},{"question":"def countPalindromicSubstrings(s: str) -> int: Returns the number of palindromic substrings in the given string. >>> countPalindromicSubstrings(\\"abc\\") 3 >>> countPalindromicSubstrings(\\"aaa\\") 6","solution":"def countPalindromicSubstrings(s): Returns the number of palindromic substrings in the given string. n = len(s) count = 0 for center in range(2 * n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count"},{"question":"def can_form_consecutive_sequence(numbers: List[int]) -> str: Returns 'YES' if the list can be rearranged to form a consecutive sequence, and 'NO' otherwise. >>> can_form_consecutive_sequence([1, 2, 3, 4, 5]) == \\"YES\\" >>> can_form_consecutive_sequence([4, 3, 1, 2, 5]) == \\"YES\\" >>> can_form_consecutive_sequence([1, 3, 4, 5]) == \\"NO\\" >>> can_form_consecutive_sequence([10, 11, 12, 13, 14]) == \\"YES\\" >>> can_form_consecutive_sequence([5, 3, 1, 2]) == \\"NO\\" >>> can_form_consecutive_sequence([1]) == \\"YES\\" >>> can_form_consecutive_sequence([100, 99, 98, 97, 96]) == \\"YES\\" >>> can_form_consecutive_sequence([1, 2, 2, 3, 4, 5]) == \\"NO\\"","solution":"def can_form_consecutive_sequence(numbers): Returns 'YES' if the list can be rearranged to form a consecutive sequence, and 'NO' otherwise. sorted_numbers = sorted(numbers) for i in range(len(sorted_numbers) - 1): if sorted_numbers[i+1] != sorted_numbers[i] + 1: return 'NO' return 'YES'"},{"question":"def count_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner of the grid. >>> count_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> count_paths([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 0 >>> count_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 0 >>> count_paths([[0]]) 1 >>> count_paths([[1]]) 0 >>> count_paths([ ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 0] ... ]) 4 >>> count_paths([ ... [0, 1], ... [1, 0] ... ]) 0","solution":"def count_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 M = len(grid) N = len(grid[0]) dp = [[0] * N for _ in range(M)] dp[0][0] = 1 # Start point # Initialize first row for j in range(1, N): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Initialize first column for i in range(1, M): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] for i in range(1, M): for j in range(1, N): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[M-1][N-1]"},{"question":"from typing import List, Tuple def selectForPromotion(k: int, employees: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Select employees for promotion based on minimum years of service and performance scores. Args: k: int - Minimum years of service required for promotion eligibility. employees: List[Tuple[int, int]] - List of tuples containing (years of service, performance score). Returns: List[Tuple[int, int]] - List of tuples representing the selected employees, sorted in descending order based on performance scores. Examples: >>> selectForPromotion(5, [(3, 50), (7, 85), (10, 90), (5, 80), (8, 75), (6, 90)]) [(10, 90), (6, 90), (7, 85), (5, 80), (8, 75)] >>> selectForPromotion(10, [(10, 60), (12, 70), (9, 85), (14, 90)]) [(14, 90), (12, 70), (10, 60)] >>> selectForPromotion(3, [(2, 65), (3, 70), (4, 75), (4, 60), (5, 80)]) [(5, 80), (4, 75), (3, 70), (4, 60)] pass","solution":"from typing import List, Tuple def selectForPromotion(k: int, employees: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Select employees for promotion based on minimum years of service and performance scores. Args: k: int - Minimum years of service required for promotion eligibility. employees: List[Tuple[int, int]] - List of tuples containing (years of service, performance score). Returns: List[Tuple[int, int]] - List of tuples representing the selected employees, sorted in descending order based on performance scores. # Filter out employees who don't meet the minimum years of service requirement eligible_employees = [emp for emp in employees if emp[0] >= k] # Sort eligible employees by performance score in descending order, # and by years of service in descending order if scores are tied. eligible_employees.sort(key=lambda x: (-x[1], -x[0])) return eligible_employees"},{"question":"def max_enjoyment_points(hills: List[int]) -> int: Calculates the maximum enjoyment points Alex can earn by hiking hills optimally. >>> max_enjoyment_points([3, 2, 5, 10, 7]) 15 >>> max_enjoyment_points([1, 2, 3]) 4 >>> max_enjoyment_points([10, 5, 15, 20, 2, 30]) 60 >>> max_enjoyment_points([10]) 10 >>> max_enjoyment_points([]) 0 >>> max_enjoyment_points([1, 2, 9, 4, 5, 0, 4, 11, 6]) 26 >>> max_enjoyment_points([10, 20, 30, 40, 50]) 90 >>> max_enjoyment_points([20, 1, 3, 50, 40, 10, 25]) 95 pass","solution":"def max_enjoyment_points(hills): Calculates the maximum enjoyment points Alex can earn by hiking hills optimally. n = len(hills) if n == 0: return 0 if n == 1: return hills[0] # dp[i] will store the maximum points Alex can earn considering up to the i-th hill dp = [0] * n dp[0] = hills[0] if n > 1: dp[1] = max(hills[0], hills[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + hills[i]) return dp[-1] def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) hills = list(map(int, data[1:])) print(max_enjoyment_points(hills))"},{"question":"def minimal_employees_to_cover_skills(m: int, k: int, project_skills: List[List[int]], employee_skills: List[List[int]]) -> int: Determine the minimal number of employees needed to ensure that all required skills are covered. Parameters: m (int): number of projects k (int): number of employees project_skills (list(list(int))): each sub-list contains skills required for each project employee_skills (list(list(int))): each sub-list contains skills that each employee possesses Returns: int: the minimal number of employees needed or -1 if it is not possible to cover all skills >>> minimal_employees_to_cover_skills(2, 3, [[1, 2, 3], [3, 4]], [[1, 2, 3], [2, 4], [4]]) 2 >>> minimal_employees_to_cover_skills(1, 1, [[1]], [[1]]) 1 >>> minimal_employees_to_cover_skills(1, 2, [[1, 2]], [[1], [2]]) 2 >>> minimal_employees_to_cover_skills(3, 4, [[1, 2], [2, 3], [3, 4]], [[1], [2, 3], [4], [3]]) 3 >>> minimal_employees_to_cover_skills(1, 3, [[1, 2, 3]], [[1], [2], [3]]) 3 >>> minimal_employees_to_cover_skills(3, 2, [[1, 2], [3, 4], [5]], [[1, 2, 3, 4], [5]]) 2 >>> minimal_employees_to_cover_skills(1, 0, [[1]], [[]]) -1 >>> minimal_employees_to_cover_skills(0, 2, [], [[1, 2], [3, 4]]) 0 pass","solution":"import itertools def minimal_employees_to_cover_skills(m, k, project_skills, employee_skills): Determine the minimal number of employees needed to ensure that all required skills are covered. Parameters: m (int): number of projects k (int): number of employees project_skills (list(list(int))): each sub-list contains skills required for each project employee_skills (list(list(int))): each sub-list contains skills that each employee possesses Returns: int: the minimal number of employees needed or -1 if it is not possible to cover all skills # Get the set of all required skills required_skills = set() for required_skills_list in project_skills: required_skills.update(required_skills_list) # If there are no required skills, return 0 if not required_skills: return 0 # Get the list of all employee skills sets employee_skills_sets = [{skill for skill in skills_list} for skills_list in employee_skills] # Iterate over combinations of employees to find the minimal subset that covers all required skills for r in range(1, k + 1): for combination in itertools.combinations(employee_skills_sets, r): combined_skills = set().union(*combination) if combined_skills >= required_skills: return r # If no combination covers all skills, return -1 return -1"},{"question":"def min_diff_between_two_teams(n: int, skills: List[int]) -> int: Finds the minimum difference between the sums of skills of two non-empty teams. Parameters: n (int): The number of participants skills (list of int): The skill levels of the participants Returns: int: The minimum difference between the sums of the skills of the two teams >>> min_diff_between_two_teams(4, [1, 2, 3, 4]) 0 >>> min_diff_between_two_teams(2, [1, 2]) 1","solution":"def min_diff_between_two_teams(n, skills): Finds the minimum difference between the sums of skills of two non-empty teams. Parameters: n (int): The number of participants skills (list of int): The skill levels of the participants Returns: int: The minimum difference between the sums of the skills of the two teams total_sum = sum(skills) half_sum = total_sum // 2 dp = [False] * (half_sum + 1) dp[0] = True for skill in skills: for j in range(half_sum, skill - 1, -1): dp[j] = dp[j] or dp[j - skill] for i in range(half_sum, -1, -1): if dp[i]: return abs(total_sum - 2 * i)"},{"question":"def longest_non_decreasing_subsequence(n: int, sequence: List[int]) -> int: Returns the length of the longest non-decreasing subsequence. >>> longest_non_decreasing_subsequence(6, [5, 3, 4, 8, 6, 7]) 4 >>> longest_non_decreasing_subsequence(5, [2, 2, 2, 2, 2]) 5","solution":"def longest_non_decreasing_subsequence(n, sequence): Returns the length of the longest non-decreasing subsequence. if n == 0: return 0 # Initialize the DP array dp = [1] * n # Calculate the longest non-decreasing subsequence using dynamic programming for i in range(1, n): for j in range(i): if sequence[i] >= sequence[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest non-decreasing subsequence return max(dp)"},{"question":"def minimize_height_difference(n: int, k: int, heights: List[int]) -> int: Finds the smallest possible difference between the maximum and minimum heights in any subarray of length k. Parameters: n (int): Number of buildings. k (int): Length of the subarray. heights (list of int): Heights of the buildings. Returns: int: The smallest possible difference between the maximum and minimum heights in any subarray of length k. >>> minimize_height_difference(7, 3, [1, 3, 4, 9, 2, 8, 7]) 2 >>> minimize_height_difference(5, 2, [5, 5, 5, 5, 5]) 0 >>> minimize_height_difference(5, 3, [1, 2, 3, 4, 5]) 2 >>> minimize_height_difference(5, 2, [10, 9, 8, 7, 6]) 1 >>> minimize_height_difference(6, 4, [10, 23, 15, 8, 19, 6]) 9 >>> minimize_height_difference(1, 1, [15]) 0 >>> minimize_height_difference(6, 2, [1000000000, 1, 999999999, 2, 3, 4]) 1 >>> minimize_height_difference(10, 10, [3, 3, 1, 2, 4, 5, 2, 1, 7, 9]) 8","solution":"def minimize_height_difference(n, k, heights): Finds the smallest possible difference between the maximum and minimum heights in any subarray of length k. Parameters: n (int): Number of buildings. k (int): Length of the subarray. heights (list of int): Heights of the buildings. Returns: int: The smallest possible difference between the maximum and minimum heights in any subarray of length k. # Sort the heights array heights.sort() # Initialize the minimum difference to a large value min_diff = float('inf') # Iterate over the sorted list and find the minimum difference for i in range(n - k + 1): diff = heights[i + k - 1] - heights[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"from typing import List def customSort(nums: List[int]) -> List[int]: Sorts the list such that all even numbers come before all odd numbers. Both even and odd numbers are sorted in ascending order within their respective groups. Example: >>> customSort([3, 1, 2, 4]) [2, 4, 1, 3] >>> customSort([0, -2, 5, -7, -3, -10]) [-10, -2, 0, -7, -3, 5]","solution":"from typing import List def customSort(nums: List[int]) -> List[int]: Sorts the list such that all even numbers come before all odd numbers. Both even and odd numbers are sorted in ascending order within their respective groups. evens = sorted([num for num in nums if num % 2 == 0]) odds = sorted([num for num in nums if num % 2 != 0]) return evens + odds"},{"question":"def shift_string(s: str, shift: int) -> str: Shifts each character in the given string s by the given number of positions to the right in the alphabet. :param s: String of lowercase alphabetic characters :param shift: Integer number of positions to shift (0 ≤ shift ≤ 25) :return: Resultant string after applying shift >>> shift_string('abc', 0) == 'abc' >>> shift_string('xyz', 2) == 'zab' >>> shift_string('hello', 2) == 'jgnnq'","solution":"def shift_string(s, shift): Shifts each character in the given string s by the given number of positions to the right in the alphabet. :param s: String of lowercase alphabetic characters :param shift: Integer number of positions to shift (0 ≤ shift ≤ 25) :return: Resultant string after applying shift shifted_string = [] for char in s: shifted_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) shifted_string.append(shifted_char) return ''.join(shifted_string)"},{"question":"def correct_currents(n: int, currents: List[int]) -> List[int]: Returns the corrected sequence of current speeds. >>> correct_currents(6, [1, 2, 4, 9, 16, 50]) [1, 2, 4, 8, 16, 32] >>> correct_currents(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> correct_currents(5, [1, 4, 16, 64, 256]) [1, 2, 4, 8, 16] >>> correct_currents(1, [10]) [10] >>> correct_currents(6, [1, 2, 5, 6, 15, 20]) [1, 2, 4, 6, 12, 20] pass","solution":"def correct_currents(n, currents): Returns the corrected sequence of current speeds. corrected = currents[:1] for i in range(1, n): if currents[i] > 2 * corrected[i-1]: corrected.append(2 * corrected[i-1]) else: corrected.append(currents[i]) return corrected"},{"question":"from typing import List def constructArray(arr: List[int]) -> List[int]: Construct a new array where each element at index i is the product of all elements in the original array except the one at index i. >>> constructArray([1, 2, 3, 4]) [24, 12, 8, 6] >>> constructArray([1, 2, 0, 4]) [0, 0, 8, 0] >>> constructArray([-1, 2, 3, 4]) [24, -12, -8, -6] >>> constructArray([0, 0, 0, 0]) [0, 0, 0, 0] >>> constructArray([]) [] >>> constructArray([3, 5]) [5, 3] >>> constructArray([100000, 200000]) [200000, 100000] >>> constructArray([-1, -2, -3, -4]) [-24, -12, -8, -6] pass","solution":"from typing import List def constructArray(arr: List[int]) -> List[int]: n = len(arr) if n == 0: return [] result = [1] * n # Product of elements to the left of arr[i] left = 1 for i in range(n): result[i] *= left left *= arr[i] # Product of elements to the right of arr[i] right = 1 for i in range(n-1, -1, -1): result[i] *= right right *= arr[i] return result"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, returns a list of days until a warmer temperature. Args: temperatures (List[int]): A list representing daily temperatures for a week. Returns: List[int]: A list where each value represents the number of days to wait for a warmer temperature. Example: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] pass","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, returns a list of days until a warmer temperature. Args: temperatures (List[int]): A list of daily temperatures. Returns: List[int]: A list where the value at each index represents the number of days until a warmer temperature. result = [0] * len(temperatures) stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"from typing import List, Tuple def partition_list(nums: List[int]) -> Tuple[List[int], List[int]]: Partition the list of integers into two sublists such that the absolute difference between their sums is minimized. >>> partition_list([1, 6, 11, 5]) ([11, 1], [6, 5]) >>> partition_list([10]) ([10], []) >>> partition_list([1, 2]) ([1], [2]) >>> partition_list([10, 20, 15, 5]) ([20, 5], [10, 15]) >>> partition_list([5, 5, 5, 5]) ([5, 5], [5, 5])","solution":"from typing import List, Tuple def partition_list(nums: List[int]) -> Tuple[List[int], List[int]]: Partition the list of integers into two sublists such that the absolute difference between their sums is minimized. total_sum = sum(nums) n = len(nums) # dp[i][j] will be True if j sum is possible with first i elements. dp = [[False] * (total_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum + 1): dp[i][j] = dp[i-1][j] if j >= nums[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-nums[i-1]] half_sum = total_sum // 2 for s in range(half_sum, -1, -1): if dp[n][s]: sum1 = s break sum2 = total_sum - sum1 sublist1 = [] sublist2 = [] i, j = n, sum1 while i > 0 and j > 0: if not dp[i-1][j]: sublist1.append(nums[i-1]) j -= nums[i-1] else: sublist2.append(nums[i-1]) i -= 1 while i > 0: sublist2.append(nums[i-1]) i -= 1 return sublist1, sublist2"},{"question":"def minimize_absolute_difference_sum(n: int, a: List[int]) -> Tuple[int, List[int]]: This function takes in an integer n and a list a of length n. It returns the minimized value of the sum of absolute differences between consecutive elements and the sorted array that achieves this minimized value. >>> minimize_absolute_difference_sum(4, [4, 2, 1, 3]) (3, [1, 2, 3, 4]) >>> minimize_absolute_difference_sum(2, [1, 2]) (1, [1, 2]) >>> minimize_absolute_difference_sum(5, [5, 4, 3, 2, 1]) (4, [1, 2, 3, 4, 5]) >>> minimize_absolute_difference_sum(3, [1000, 1, 500]) (999, [1, 500, 1000]) >>> minimize_absolute_difference_sum(6, [1, 2, 3, 4, 5, 6]) (5, [1, 2, 3, 4, 5, 6]) >>> minimize_absolute_difference_sum(4, [7, 7, 7, 7]) (0, [7, 7, 7, 7])","solution":"def minimize_absolute_difference_sum(n, a): This function takes in an integer n and a list a of length n. It returns the minimized value of the sum of absolute differences between consecutive elements and the sorted array that achieves this minimized value. b = sorted(a) total_sum = sum(abs(b[i] - b[i-1]) for i in range(1, n)) return total_sum, b"},{"question":"def largest_rectangle_area(heights): Given a list of heights representing buildings in a histogram, returns the area of the largest rectangle that can be formed within the bounds of the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([0, 0, 0, 0]) 0 >>> largest_rectangle_area([0, 1, 0, 2]) 2 >>> largest_rectangle_area([1]) 1","solution":"def largest_rectangle_area(heights): Given a list of heights representing buildings in a histogram, returns the area of the largest rectangle that can be formed within the bounds of the histogram. n = len(heights) stack = [] max_area = 0 for i in range(n): while stack and heights[stack[-1]] > heights[i]: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = n if not stack else n - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"def find_special_arithmetic_sequence(n: int, sequence: List[int]) -> List[int]: Determines whether a given sequence of distinct integers can be rearranged into a \\"special arithmetic sequence\\". The sequence must have at least two distinct integers, a constant difference between elements, and all elements must be distinct. Parameters: n (int): The length of the sequence. sequence (list of int): The list of distinct integers. Returns: list of int or int: A rearranged sequence that forms a special arithmetic sequence if possible, otherwise return -1. >>> find_special_arithmetic_sequence(5, [10, 30, 20, 50, 40]) [10, 20, 30, 40, 50] >>> find_special_arithmetic_sequence(1, [10]) -1 >>> find_special_arithmetic_sequence(3, [7, 1, 4]) [1, 4, 7] >>> find_special_arithmetic_sequence(4, [1, 3, 5, 8]) -1 >>> find_special_arithmetic_sequence(6, [1, 7, 10, 4, 13, 16]) [1, 4, 7, 10, 13, 16]","solution":"def find_special_arithmetic_sequence(n, sequence): Determines whether a given sequence of distinct integers can be rearranged into a \\"special arithmetic sequence\\". The sequence must have at least two distinct integers, a constant difference between elements, and all elements must be distinct. Parameters: n (int): The length of the sequence. sequence (list of int): The list of distinct integers. Returns: list of int or int: A rearranged sequence that forms a special arithmetic sequence if possible, otherwise return -1. if n == 1: return -1 sequence.sort() diff = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i-1] != diff: return -1 return sequence"},{"question":"def lexicographically_smallest_array(n: int, a: List[int]) -> List[int]: Returns the lexicographically smallest array that can be obtained by performing the allowed operation any number of times. :param n: int, size of the array :param a: List[int], the input array :return: List[int], the lexicographically smallest array >>> lexicographically_smallest_array(5, [4, 2, 3, 1, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_array(3, [5, 4, 3]) [3, 4, 5] from typing import List def test_lexicographically_smallest_array_example_cases(): assert lexicographically_smallest_array(5, [4, 2, 3, 1, 5]) == [1, 2, 3, 4, 5] assert lexicographically_smallest_array(3, [5, 4, 3]) == [3, 4, 5] def test_lexicographically_smallest_array_all_elements_same(): assert lexicographically_smallest_array(4, [2, 2, 2, 2]) == [2, 2, 2, 2] def test_lexicographically_smallest_array_already_sorted(): assert lexicographically_smallest_array(5, [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_lexicographically_smallest_array_reverse_sorted(): assert lexicographically_smallest_array(4, [4, 3, 2, 1]) == [1, 2, 3, 4] def test_lexicographically_smallest_array_mixed_elements(): assert lexicographically_smallest_array(6, [10, 20, 15, 30, 5, 50]) == [5, 10, 15, 20, 30, 50]","solution":"def lexicographically_smallest_array(n, a): Returns the lexicographically smallest array that can be obtained. :param n: int, size of the array :param a: List[int], the input array :return: List[int], the lexicographically smallest array return sorted(a)"},{"question":"def gcd(x, y): Calculate the Greatest Common Divisor (GCD) of x and y. while y: x, y = y, x % y return x def lcm(a, b): Returns the Least Common Multiple (LCM) of a and b. >>> lcm(4, 6) == 12 >>> lcm(5, 10) == 10 >>> lcm(7, 7) == 7 >>> lcm(7, 13) == 91 >>> lcm(1, 10) == 10 >>> lcm(1, 1) == 1 >>> lcm(25, 30) == 150 >>> lcm(100, 25) == 100","solution":"def gcd(x, y): Calculate the Greatest Common Divisor (GCD) of x and y. while y: x, y = y, x % y return x def lcm(a, b): Returns the Least Common Multiple (LCM) of a and b. return abs(a * b) // gcd(a, b)"},{"question":"def is_bipartite(num_vertices, edges): Determines if the given graph can be 2-colored (bipartite). num_vertices: Number of vertices in the graph. edges: List of tuples, where each tuple represents an edge between two vertices. Returns \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". pass def process_test_cases(t, test_cases): Processes multiple test cases to determine bipartiteness of graphs. t: Number of test cases. test_cases: List of tuples, where each tuple contains: - A tuple (n, m) representing number of vertices and edges, - A list of tuples representing edges in the graph. Returns a list of strings \\"YES\\" or \\"NO\\" for each test case. pass # Example test cases def test_case_1(): t = 2 test_cases = [ ((4, 4), [(1, 2), (2, 3), (3, 4), (4, 2)]), ((3, 2), [(1, 2), (2, 3)]) ] assert process_test_cases(t, test_cases) == [\\"NO\\", \\"YES\\"] def test_single_vertex(): t = 1 test_cases = [ ((1, 0), []) ] assert process_test_cases(t, test_cases) == [\\"YES\\"] def test_small_bipartite_graph(): t = 1 test_cases = [ ((4, 4), [(1, 2), (2, 3), (3, 4), (4, 1)]) ] assert process_test_cases(t, test_cases) == [\\"YES\\"] def test_multi_edge_graph(): t = 1 test_cases = [ ((3, 3), [(1, 2), (1, 2), (2, 3)]) ] assert process_test_cases(t, test_cases) == [\\"YES\\"] def test_self_loop(): t = 1 test_cases = [ ((3, 3), [(1, 2), (2, 3), (1, 1)]) ] assert process_test_cases(t, test_cases) == [\\"NO\\"]","solution":"from collections import deque def is_bipartite(num_vertices, edges): Determines if the given graph can be 2-colored (bipartite). num_vertices: Number of vertices in the graph. edges: List of tuples, where each tuple represents an edge between two vertices. Returns \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". graph = [[] for _ in range(num_vertices + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (num_vertices + 1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, num_vertices + 1): if color[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][0] edges = test_cases[i][1] results.append(is_bipartite(n, edges)) return results"},{"question":"def can_all_tasks_be_completed(test_cases): Given a series of tasks with deadlines and durations, determine if all tasks can be completed on time if started at the same time and done consecutively in any order. Parameters: test_cases: List[List[Tuple[int, int]]] - A list of test cases, each containing a list of tuples where each tuple represents a task with a deadline and duration. Return: List[str] - A list of results for each test case, \\"YES\\" if all tasks can be completed on time, otherwise \\"NO\\". >>> can_all_tasks_be_completed([[(5, 3), (2, 1), (7, 2)], [(4, 3), (10, 2), (6, 1), (3, 2)]]) ['YES', 'NO'] >>> can_all_tasks_be_completed([[(5, 4), (10, 6)]]) ['YES'] >>> can_all_tasks_be_completed([[(5, 6), (10, 6)]]) ['NO'] pass def process_input(input_str): Process input string to generate output for task completion verification. Parameters: input_str: str - Multiline string with number of test cases, number of tasks, followed by pairs of deadlines and durations for each task. Return: List[str] - A list of results for each test case, \\"YES\\" if all tasks can be completed on time, otherwise \\"NO\\". >>> process_input(\\"2n3n5 3n2 1n7 2n4n4 3n10 2n6 1n3 2\\") ['YES', 'NO'] >>> process_input(\\"1n2n5 4n10 6\\") ['YES'] >>> process_input(\\"1n2n5 6n10 6\\") ['NO'] pass from solution import can_all_tasks_be_completed, process_input def test_can_all_tasks_be_completed(): test_cases = [ [(5, 3), (2, 1), (7, 2)], [(4, 3), (10, 2), (6, 1), (3, 2)] ] assert can_all_tasks_be_completed(test_cases) == [\\"YES\\", \\"NO\\"] test_cases = [ [(5, 4), (10, 6)] ] assert can_all_tasks_be_completed(test_cases) == [\\"YES\\"] test_cases = [ [(5, 6), (10, 6)] ] assert can_all_tasks_be_completed(test_cases) == [\\"NO\\"] def test_process_input(): input_str = \\"2n3n5 3n2 1n7 2n4n4 3n10 2n6 1n3 2\\" expected_output = [\\"YES\\", \\"NO\\"] assert process_input(input_str) == expected_output input_str = \\"1n2n5 4n10 6\\" expected_output = [\\"YES\\"] assert process_input(input_str) == expected_output input_str = \\"1n2n5 6n10 6\\" expected_output = [\\"NO\\"] assert process_input(input_str) == expected_output","solution":"def can_all_tasks_be_completed(test_cases): results = [] for tasks in test_cases: tasks.sort() # Sort tasks by deadlines current_time = 0 possible = True for deadline, duration in tasks: current_time += duration if current_time > deadline: possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results def process_input(input_str): input_lines = input_str.strip().split(\\"n\\") t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) tasks = [] for i in range(1, n + 1): d, l = map(int, input_lines[index + i].split()) tasks.append((d, l)) index += n + 1 test_cases.append(tasks) return can_all_tasks_be_completed(test_cases)"},{"question":"def longestValidParentheses(s: str) -> int: Write a function that takes a string s consisting of parentheses characters: '(', ')', '{', '}', '[' and ']', and returns the length of the longest valid (well-formed) parentheses substring. A valid parentheses string is one that meets the following criteria: 1. Each opening parentheses has a corresponding closing parentheses of the same type. 2. Parentheses must be closed in the correct order. Example: >>> longestValidParentheses(\\"(()\\") 2 >>> longestValidParentheses(\\")()())\\") 4 >>> longestValidParentheses(\\"\\") 0","solution":"def longestValidParentheses(s: str) -> int: # Initialize a stack and set the base for longest sequence tracking stack = [] max_length = 0 last_invalid_index = -1 for i, char in enumerate(s): if char in '({[': stack.append(i) else: if stack and ((char == ')' and s[stack[-1]] == '(') or (char == '}' and s[stack[-1]] == '{') or (char == ']' and s[stack[-1]] == '[')): stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: max_length = max(max_length, i - last_invalid_index) else: last_invalid_index = i return max_length"},{"question":"from typing import List def min_palindrome_partitions(t: int, test_cases: List[str]) -> List[int]: Determine the minimum number of palindromic substrings that the string can be partitioned into. >>> min_palindrome_partitions(2, [\\"abac\\", \\"aabb\\"]) [2, 2] >>> min_palindrome_partitions(1, [\\"racecar\\"]) [1]","solution":"def min_palindrome_partitions(t, test_cases): def is_palindrome(s): return s == s[::-1] results = [] for s in test_cases: if is_palindrome(s): results.append(1) else: results.append(2) return results"},{"question":"def minimal_consolidated_route_length(n: int, orders: List[Tuple[int, int]]) -> int: Calculates the minimal length of the consolidated route. :param n: Number of delivery orders :param orders: List of tuples containing (starting address, ending address) :return: Length of the consolidated route >>> minimal_consolidated_route_length(4, [(2, 5), (4, 8), (1, 3), (6, 9)]) 9 >>> minimal_consolidated_route_length(1, [(1, 10)]) 10 >>> minimal_consolidated_route_length(3, [(5, 5), (5, 5), (5, 5)]) 1 >>> minimal_consolidated_route_length(2, [(1, 3), (10, 15)]) 15 >>> minimal_consolidated_route_length(3, [(1, 4), (3, 6), (2, 5)]) 6 >>> minimal_consolidated_route_length(5, [(2, 4), (3, 5), (1, 7), (6, 8), (7, 9)]) 9 >>> minimal_consolidated_route_length(3, [(100, 200), (150, 250), (110, 260)]) 161","solution":"def minimal_consolidated_route_length(n, orders): Calculates the minimal length of the consolidated route. :param n: Number of delivery orders :param orders: List of tuples containing (starting address, ending address) :return: Length of the consolidated route min_start = float('inf') max_end = float('-inf') for start, end in orders: if start < min_start: min_start = start if end > max_end: max_end = end return max_end - min_start + 1 # Example usage orders = [(2, 5), (4, 8), (1, 3), (6, 9)] print(minimal_consolidated_route_length(4, orders)) # Output: 9"},{"question":"def can_form_palindrome(s: str) -> str: Determines if a given string can be rearranged to form a palindrome. Parameters: s (str): The input string consisting of lowercase Latin letters. Returns: str: \\"YES\\" if it's possible to rearrange the string to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome('civic') 'YES' >>> can_form_palindrome('ivicc') 'YES' >>> can_form_palindrome('hello') 'NO' >>> can_form_palindrome('aabb') 'YES' from solution import can_form_palindrome def test_example_1(): assert can_form_palindrome('civic') == 'YES' def test_example_2(): assert can_form_palindrome('ivicc') == 'YES' def test_example_3(): assert can_form_palindrome('hello') == 'NO' def test_example_4(): assert can_form_palindrome('aabb') == 'YES' def test_single_character(): assert can_form_palindrome('a') == 'YES' def test_two_different_characters(): assert can_form_palindrome('ab') == 'NO' def test_palindromic_even_length(): assert can_form_palindrome('aabbcc') == 'YES' def test_palindromic_odd_length(): assert can_form_palindrome('aabbc') == 'YES' def test_all_characters_different(): assert can_form_palindrome('abcdefg') == 'NO' def test_all_characters_same(): assert can_form_palindrome('aaaa') == 'YES'","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Parameters: s (str): The input string consisting of lowercase Latin letters. Returns: str: \\"YES\\" if it's possible to rearrange the string to form a palindrome, \\"NO\\" otherwise. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"from typing import List def can_construct(target: str, word_bank: List[str]) -> bool: Determines if the target string can be constructed by concatenating words from the word_bank. >>> can_construct(\\"abcdef\\", [\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"]) True >>> can_construct(\\"skateboard\\", [\\"bo\\", \\"rd\\", \\"ate\\", \\"t\\", \\"ska\\", \\"sk\\", \\"boar\\"]) False >>> can_construct(\\"\\", [\\"cat\\", \\"dog\\", \\"mouse\\"]) True >>> can_construct(\\"a\\", [\\"b\\", \\"x\\", \\"a\\"]) True >>> can_construct(\\"c\\", [\\"b\\", \\"a\\"]) False >>> can_construct(\\"abcabc\\", [\\"abc\\", \\"a\\", \\"ab\\", \\"bc\\"]) True >>> can_construct(\\"aaaa\\", [\\"a\\", \\"aa\\"]) True >>> can_construct(\\"aaaaa\\", [\\"a\\", \\"aa\\"]) True >>> can_construct(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) True >>> can_construct(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"from typing import List def can_construct(target: str, word_bank: List[str]) -> bool: Determines if target can be constructed by concatenating words in word_bank. memo = {} def can_construct_memo(target): if target in memo: return memo[target] if target == \\"\\": return True for word in word_bank: if target.startswith(word): suffix = target[len(word):] if can_construct_memo(suffix): memo[target] = True return True memo[target] = False return False return can_construct_memo(target)"},{"question":"from typing import List def min_insertions_to_make_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the string s a palindrome. >>> min_insertions_to_make_palindrome(\\"abc\\") == 2 >>> min_insertions_to_make_palindrome(\\"race\\") == 3 >>> min_insertions_to_make_palindrome(\\"aaaa\\") == 0 def solve(t: int, test_cases: List[str]) -> List[int]: For each test case, returns the minimum number of insertions required to make the string a palindrome. >>> solve(3, [\\"abc\\", \\"race\\", \\"aaaa\\"]) == [2, 3, 0] >>> solve(2, [\\"google\\", \\"civic\\"]) == [2, 0] >>> solve(3, [\\"a\\", \\"ab\\", \\"abcde\\"]) == [0, 1, 4]","solution":"def min_insertions_to_make_palindrome(s): Returns the minimum number of insertions needed to make the string s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1] def solve(t, test_cases): results = [] for s in test_cases: results.append(min_insertions_to_make_palindrome(s)) return results"},{"question":"def minimize_hiking_time(trails: List[int], speeds: List[int]) -> int: Given the lengths of hiking trails and the walking speeds of friends, computes the minimum possible total time in hours for all friends to complete their assigned trails. Args: trails (list of int): The lengths of hiking trails in kilometers. speeds (list of int): The walking speeds of friends in kilometers per hour. Returns: int: The minimum possible time in hours for all friends to complete their trails. >>> minimize_hiking_time([6, 8, 10, 12], [1, 2, 3, 4]) 6 >>> minimize_hiking_time([5, 5, 5, 5], [5, 5, 5, 5]) 1 >>> minimize_hiking_time([2, 4, 6, 8], [2, 2, 2, 2]) 4 >>> minimize_hiking_time([3, 3, 3, 3], [1, 2, 3, 4]) 3 >>> minimize_hiking_time([12, 6, 8, 10], [4, 2, 3, 1]) 6 >>> minimize_hiking_time([10], [2]) 5 >>> minimize_hiking_time([100, 90, 80, 70], [5, 10, 15, 20]) 14","solution":"def minimize_hiking_time(trails, speeds): Given the lengths of hiking trails and the walking speeds of friends, computes the minimum possible total time in hours for all friends to complete their assigned trails. Args: trails (list of int): The lengths of hiking trails in kilometers. speeds (list of int): The walking speeds of friends in kilometers per hour. Returns: int: The minimum possible time in hours for all friends to complete their trails. # Sort both lists trails.sort() speeds.sort() # Assign longest trails to the fastest friends and find the maximum time taken by any friend max_time = max(trail / speed for trail, speed in zip(trails, speeds)) return int(max_time)"},{"question":"def min_max_step(n: int, heights: List[int]) -> int: Determine the minimum possible maximum difference between the heights of any two consecutive buildings in your path from the leftmost to the rightmost building. Args: n (int): The number of buildings. heights (List[int]): The heights of the buildings. Returns: int: The minimum possible maximum difference. Examples: >>> min_max_step(6, [1, 5, 3, 2, 6, 4]) 2 >>> min_max_step(3, [1, 1000000000, 500000000]) 499999999","solution":"def min_max_step(n, heights): if n <= 1: return 0 # No steps needed if there's only one building. # To minimize the step differences, we can sort the heights and take adjacent steps. sorted_heights = sorted(heights) # The minimum possible maximum difference between consecutive buildings min_max_diff = float('inf') for i in range(1, n): diff = sorted_heights[i] - sorted_heights[i - 1] if diff < min_max_diff: min_max_diff = diff return min_max_diff"},{"question":"def min_steps_in_maze(n: int, m: int, maze: List[List[int]]) -> int: Determine the minimum number of steps required for the robot to reach the bottom-right corner if a path exists. >>> n = 3 >>> m = 3 >>> maze = [[0, 1, 0], [0, 0, 0], [1, 1, 0]] >>> min_steps_in_maze(n, m, maze) 4 >>> n = 3 >>> m = 3 >>> maze = [[0, 1, 0], [1, 1, 0], [1, 1, 0]] >>> min_steps_in_maze(n, m, maze) -1","solution":"from collections import deque def min_steps_in_maze(n, m, maze): if maze[0][0] == 1 or maze[n-1][m-1] == 1: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set() visited.add((0, 0)) while queue: r, c, steps = queue.popleft() # If reached the bottom-right corner if r == n - 1 and c == m - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and maze[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def determine_point_status(n: int, vertices: List[Tuple[int, int]], point: Tuple[int, int]) -> str: Determine if a given point lies inside, on the boundary, or outside a convex polygon. :param n: Number of vertices of the polygon :param vertices: List of (x, y) coordinates of the polygon vertices in clockwise order :param point: (x, y) coordinates of the point to be checked :return: \\"INSIDE\\" if the point is inside the polygon, \\"BOUNDARY\\" if it is on the boundary, \\"OUTSIDE\\" if it is outside >>> determine_point_status(5, [(0,0), (4,0), (4,4), (0,4), (-1,2)], (2,2)) 'INSIDE' >>> determine_point_status(4, [(1,1), (3,1), (3,3), (1,3)], (4,4)) 'OUTSIDE' >>> determine_point_status(4, [(0,0), (5,0), (5,5), (0,5)], (0,3)) 'BOUNDARY' from typing import List, Tuple def test_inside(): assert determine_point_status(5, [(0,0), (4,0), (4,4), (0,4), (-1,2)], (2,2)) == \\"INSIDE\\" def test_outside(): assert determine_point_status(4, [(1,1), (3,1), (3,3), (1,3)], (4,4)) == \\"OUTSIDE\\" def test_boundary(): assert determine_point_status(4, [(0,0), (5,0), (5,5), (0,5)], (0,3)) == \\"BOUNDARY\\" def test_on_vertex(): assert determine_point_status(4, [(0,0), (2,0), (2,2), (0,2)], (0,0)) == \\"BOUNDARY\\" def test_on_edge(): assert determine_point_status(4, [(1,1), (4,1), (4,4), (1,4)], (2,1)) == \\"BOUNDARY\\" def test_convex_polygon_large(): vertices = [(i, 0) for i in range(10000)] + [(i, 1) for i in range(9999, -1, -1)] assert determine_point_status(20000, vertices, (5000, 0)) == \\"BOUNDARY\\" assert determine_point_status(20000, vertices, (5000, 0.5)) == \\"INSIDE\\" assert determine_point_status(20000, vertices, (5000, 2)) == \\"OUTSIDE\\"","solution":"def is_point_in_polygon(vertices, point): def on_segment(p, q, r): Check if point q lies on segment pr if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])): return True return False def orientation(p, q, r): Return the orientation of the triplet (p, q, r). 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 return 1 if val > 0 else 2 def intersect(p1, q1, p2, q2): Check if line segment p1q1 and p2q2 intersect o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) if o1 != o2 and o3 != o4: return True if o1 == 0 and on_segment(p1, p2, q1): return True if o2 == 0 and on_segment(p1, q2, q1): return True if o3 == 0 and on_segment(p2, p1, q2): return True if o4 == 0 and on_segment(p2, q1, q2): return True return False n = len(vertices) if n < 3: return \\"OUTSIDE\\" extreme = (10**10, point[1]) count = i = 0 while True: next = (i + 1) % n if intersect(vertices[i], vertices[next], point, extreme): if orientation(vertices[i], point, vertices[next]) == 0: return \\"BOUNDARY\\" if on_segment(vertices[i], point, vertices[next]) else \\"OUTSIDE\\" count += 1 i = next if i == 0: break return \\"INSIDE\\" if count % 2 == 1 else \\"OUTSIDE\\" def determine_point_status(n, vertices, point): return is_point_in_polygon(vertices, point)"},{"question":"def is_alternating_route(n: int, edges: List[Tuple[int, int, str]]) -> bool: Determines if there exists an alternating route from node 0 to node n-1 that strictly alternates between left turns ('L') and right turns ('R'). Args: n (int): Number of intersections. edges (List[Tuple[int, int, str]]): List of edges where each tuple (u, v, d) represents a directed edge from intersection u to intersection v with direction d ('L' or 'R'). Returns: bool: True if an alternating route exists, False otherwise. Examples: >>> is_alternating_route(4, [(0, 1, 'L'), (1, 2, 'R'), (2, 3, 'L')]) True >>> is_alternating_route(4, [(0, 1, 'L'), (1, 2, 'L'), (2, 3, 'R')]) False >>> is_alternating_route(3, [(0, 1, 'L'), (1, 2, 'L')]) False >>> is_alternating_route(5, [(0, 1, 'L'), (1, 2, 'R'), (2, 3, 'L'), (3, 4, 'R')]) True >>> is_alternating_route(3, []) False >>> is_alternating_route(2, [(0, 1, 'L')]) True >>> is_alternating_route(5, [(0, 1, 'L'), (1, 2, 'R'), (1, 3, 'R'), (3, 4, 'L'), (2, 4, 'R')]) True","solution":"def is_alternating_route(n, edges): from collections import deque, defaultdict # Create an adjacency list with direction graph = defaultdict(list) for u, v, d in edges: graph[u].append((v, d)) # BFS to check if there's an alternating path from 0 to n-1 queue = deque([(0, None)]) # Start with node 0 and no previous direction visited = {(0, None)} while queue: node, prev_direction = queue.popleft() if node == n - 1: return True for neighbor, direction in graph[node]: # Check if the path alternates if prev_direction is None or (prev_direction == 'L' and direction == 'R') or (prev_direction == 'R' and direction == 'L'): if (neighbor, direction) not in visited: visited.add((neighbor, direction)) queue.append((neighbor, direction)) return False"},{"question":"def count_beautiful_subsequences(n: int, m: int, k: int, arr: List[int]) -> int: Determine the number of beautiful subsequences of length m that can be formed from the given array. >>> count_beautiful_subsequences(5, 3, 2, [1, 3, 5, 7, 9]) 10 >>> count_beautiful_subsequences(4, 3, 10, [1, 2, 3, 4]) 0 >>> count_beautiful_subsequences(6, 3, 10, [5, 15, 30, 45, 60, 75]) 20 >>> count_beautiful_subsequences(5, 1, 1, [1, 2, 3, 4, 5]) 5 >>> count_beautiful_subsequences(4, 3, 1, [1, 1, 1, 1]) 0 >>> count_beautiful_subsequences(7, 4, 3, [1, 4, 7, 10, 13, 16, 19]) 35 # Your implementation here","solution":"MOD = 10**9 + 7 def count_beautiful_subsequences(n, m, k, arr): from itertools import combinations def is_beautiful(seq): return all(abs(seq[i] - seq[i-1]) >= k for i in range(1, len(seq))) beautiful_count = 0 for comb in combinations(arr, m): if is_beautiful(comb): beautiful_count += 1 return beautiful_count % MOD # Example usage: # n, m, k = 5, 3, 2 # arr = [1, 3, 5, 7, 9] # print(count_beautiful_subsequences(n, m, k, arr))"},{"question":"def min_string_length(s: str) -> int: Determine the minimum length of the string after performing any sequence of operations. In each operation, you can pick any two adjacent distinct characters and remove them. :param s: A string consisting of lowercase English letters. :return: Minimum possible length of the string after operations. >>> min_string_length(\\"abbba\\") 1 >>> min_string_length(\\"aaaa\\") 4 >>> min_string_length(\\"ab\\") 0 >>> min_string_length(\\"abccba\\") 0 >>> min_string_length(\\"abcba\\") 1 >>> min_string_length(\\"a\\") 1 >>> min_string_length(\\"aacaa\\") 3 >>> min_string_length(\\"abcddcba\\") 0 from solution import min_string_length def test_min_string_length_example(): assert min_string_length(\\"abbba\\") == 1 def test_min_string_length_no_reduction(): assert min_string_length(\\"aaaa\\") == 4 def test_min_string_length_complete_reduction(): assert min_string_length(\\"ab\\") == 0 def test_min_string_length_partial_reduction(): assert min_string_length(\\"abccba\\") == 0 assert min_string_length(\\"abcba\\") == 1 def test_min_string_length_single_character(): assert min_string_length(\\"a\\") == 1 def test_min_string_length_reduction_with_multiple_operations(): assert min_string_length(\\"aacaa\\") == 3 def test_min_string_length_complex_case(): assert min_string_length(\\"abcddcba\\") == 0","solution":"def min_string_length(s): Return the minimum length of the string after performing any sequence of operations. In each operation, you can pick any two adjacent distinct characters and remove them. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() # Remove the top element because it's distinct from the current char else: stack.append(char) return len(stack)"},{"question":"from typing import List, Tuple def compute_balances(transactions: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Compute the net balance for each customer and return a list of tuples sorted by the customer's name in alphabetical order. Args: transactions: A list of tuples where each tuple contains a string (the customer's name) and an integer (the transaction amount). Returns: A list of tuples, each containing a customer's name and their net balance, sorted by the customer's name in alphabetical order. Examples: >>> transactions = [(\\"Alice\\", 50), (\\"Bob\\", 20), (\\"Alice\\", -20), (\\"Bob\\", 30), (\\"Charlie\\", 10)] >>> compute_balances(transactions) [('Alice', 30), ('Bob', 50), ('Charlie', 10)] >>> transactions = [(\\"Alice\\", 50)] >>> compute_balances(transactions) [('Alice', 50)]","solution":"from typing import List, Tuple def compute_balances(transactions: List[Tuple[str, int]]) -> List[Tuple[str, int]]: balances = {} for name, amount in transactions: if name in balances: balances[name] += amount else: balances[name] = amount sorted_balances = sorted(balances.items(), key=lambda x: x[0]) return sorted_balances"},{"question":"def minimal_left_rotation(s: str, k: int, rotations: List[int]) -> int: Determines the minimal left rotation that achieves the same result as performing all given rotations in sequence. Args: s (str): The original string. k (int): The number of rotations to be performed. rotations (list of int): List of integers representing each rotation. Returns: int: The number of positions for the minimal left rotation. >>> minimal_left_rotation(\\"abcdef\\", 3, [1, 2, 3]) 0 >>> minimal_left_rotation(\\"abcdef\\", 1, [2]) 2 >>> minimal_left_rotation(\\"abcdef\\", 3, [1, 2, 4]) 1 >>> minimal_left_rotation(\\"abcdef\\", 0, []) 0 >>> minimal_left_rotation(\\"abcdef\\", 3, [100, 200, 300]) 0 >>> minimal_left_rotation(\\"abcdef\\", 3, [101, 102, 103]) 0 pass","solution":"def minimal_left_rotation(s, k, rotations): Determines the minimal left rotation that achieves the same result as performing all given rotations in sequence. Args: s (str): The original string. k (int): The number of rotations to be performed. rotations (list of int): List of integers representing each rotation. Returns: int: The number of positions for the minimal left rotation. total_rotation = sum(rotations) minimal_rotation = total_rotation % len(s) return minimal_rotation"},{"question":"def numIslands(grid: List[List[str]]) -> int: Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. >>> numIslands([ ['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0'] ]) 1 >>> numIslands([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'] ]) 3 >>> numIslands([]) 0 >>> numIslands([ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ]) 0 >>> numIslands([ ['1'] ]) 1 >>> numIslands([ ['1', '0', '0', '0', '1'], ['0', '0', '0', '0', '0'], ['0', '1', '1', '0', '0'], ['0', '0', '0', '1', '1'] ]) 4","solution":"def numIslands(grid): Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. def dfs(grid, r, c): grid[r][c] = '0' for x, y in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == '1': dfs(grid, x, y) if not grid: return 0 count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1': count += 1 dfs(grid, r, c) return count"},{"question":"def count_symmetric_strings(n: int) -> int: Returns the number of different symmetric strings of length n that can be created using only lowercase letters ('a' to 'z') and digits ('0' to '9'), modulo 10^9 + 7. >>> count_symmetric_strings(1) == 36 >>> count_symmetric_strings(2) == 1296 def test_single_character(): assert count_symmetric_strings(1) == 36 def test_two_characters(): assert count_symmetric_strings(2) == 36**2 def test_three_characters(): assert count_symmetric_strings(3) == 36**2 * 36 % (10**9 + 7) def test_four_characters(): assert count_symmetric_strings(4) == (36**2) ** 2 % (10**9 + 7) def test_large_input(): assert count_symmetric_strings(1000) == (36**500)**2 % (10**9 + 7) def test_odd_length(): assert count_symmetric_strings(5) == (36**2 * 36**2 * 36) % (10**9 + 7)","solution":"def count_symmetric_strings(n): Returns the number of different symmetric strings of length n that can be created using only lowercase letters ('a' to 'z') and digits ('0' to '9'), modulo 10^9 + 7. MOD = 10**9 + 7 num_possible_chars = 36 # 26 lowercase letters + 10 digits # If n is odd, center character can be any of num_possible_chars choices if n % 2 == 1: half_length = n // 2 count = (num_possible_chars * (num_possible_chars ** half_length)**2) % MOD else: half_length = n // 2 count = (num_possible_chars ** half_length) ** 2 % MOD return count"},{"question":"def two_sum(numbers: List[int], target: int) -> Tuple[int, int]: Given an array of integers and a target integer, determine if there exist two elements in the array that add up to the target integer. If such a pair exists, return their indices as a tuple. If no such pair exists, return an empty tuple. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1], 2) () >>> two_sum([1, 2, 3], 7) () >>> two_sum([1, 2, 3, 4, 5], 9) (3, 4) >>> two_sum([-3, 4, 3, 90], 0) (0, 2) >>> large_input = list(range(1, 10001)) >>> two_sum(large_input, 19999) (9998, 9999)","solution":"def two_sum(numbers, target): Returns a tuple of indices of the two elements in the array that add up to the target. If no such pair exists, returns an empty tuple. num_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"def maxFlowerbeds(l: int, b: int, p: int, q: int) -> int: Returns the maximum number of flowerbeds that can be placed inside the park without overlapping. >>> maxFlowerbeds(15, 12, 3, 2) 30 >>> maxFlowerbeds(5, 5, 6, 6) 0 >>> maxFlowerbeds(10, 10, 2, 2) 25 >>> maxFlowerbeds(12, 8, 4, 3) 8 >>> maxFlowerbeds(10, 10, 10, 10) 1","solution":"def maxFlowerbeds(l, b, p, q): Returns the maximum number of flowerbeds that can be placed inside the park without overlapping. # Calculate the numbers when flowerbeds are placed in both possible orientations if p > l and p > b: # Early termination in case flowerbeds are larger than park in either orientation return 0 horizontal_fit_1 = (l // p) * (b // q) horizontal_fit_2 = (l // q) * (b // p) return max(horizontal_fit_1, horizontal_fit_2)"},{"question":"def sum_of_even_index_elements_multiplied_by_length(n, A): Computes the sum of elements at even indices and multiplies it by the length of the array. :param n: Integer, the number of elements in the array. :param A: List of integers, the array. :return: Integer, the resultant sum. >>> sum_of_even_index_elements_multiplied_by_length(1, [5]) == 5*1 >>> sum_of_even_index_elements_multiplied_by_length(2, [3, 4]) == 3*2 >>> sum_of_even_index_elements_multiplied_by_length(3, [1, 2, 3]) == (1 + 3)*3 >>> sum_of_even_index_elements_multiplied_by_length(4, [1, 3, 5, 7]) == (1 + 5)*4 >>> sum_of_even_index_elements_multiplied_by_length(3, [4, -1, -2]) == (4 - 2)*3 >>> sum_of_even_index_elements_multiplied_by_length(4, [-1, -2, -3, -4]) == (-1 - 3)*4","solution":"def sum_of_even_index_elements_multiplied_by_length(n, A): Computes the sum of elements at even indices and multiplies it by the length of the array. :param n: Integer, the number of elements in the array. :param A: List of integers, the array. :return: Integer, the resultant sum. sum_even = 0 for i in range(0, n, 2): sum_even += A[i] result = sum_even * n return result"},{"question":"def has_subarray_with_sum(n: int, k: int, a: List[int]) -> str: Determine if there exists a subarray of a such that the sum of its elements equals k. >>> has_subarray_with_sum(5, 12, [1, 2, 3, 4, 5]) 'YES' >>> has_subarray_with_sum(5, 9, [1, 2, 3, 4, 5]) 'YES' >>> has_subarray_with_sum(4, 0, [-1, 1, -1, 1]) 'YES' >>> has_subarray_with_sum(3, 10, [1, 2, 3]) 'NO' >>> has_subarray_with_sum(3, -1, [1, -1, 2]) 'YES' >>> has_subarray_with_sum(3, -6, [-2, -2, -2]) 'YES' def process_multiple_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Process multiple test cases to determine if there exists a subarray of a such that the sum of its elements equals k. >>> process_multiple_test_cases([(5, 12, [1, 2, 3, 4, 5]), (5, 9, [1, 2, 3, 4, 5]), (4, 0, [-1, 1, -1, 1])]) ['YES', 'YES', 'YES'] >>> process_multiple_test_cases([(5, 12, [1, 2, 3, 4, 5]), (3, 10, [1, 2, 3]), (4, 0, [-1, 1, -1, 1]), (3, 5, [5, -5, 5]), (6, 1, [-1, 2, -3, 4, 5, -6])]) ['YES', 'NO', 'YES', 'YES', 'YES']","solution":"def has_subarray_with_sum(n, k, a): Determine if there exists a subarray of a such that the sum of its elements equals k. prefix_sums = {0} current_sum = 0 for num in a: current_sum += num if (current_sum - k) in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\" def process_multiple_test_cases(test_cases): results = [] for n, k, a in test_cases: result = has_subarray_with_sum(n, k, a) results.append(result) return results"},{"question":"from typing import List, Tuple def can_attend_meetings(meetings: List[Tuple[str, str]]) -> bool: Determine if a person can attend all meetings without overlaps. Args: meetings (List[Tuple[str, str]]): A list of tuples where each tuple represents the start and end time of a meeting in \\"HH:MM\\" format. Returns: bool: True if all meetings can be attended without overlap, otherwise False. Examples: >>> can_attend_meetings([(\\"09:00\\", \\"10:30\\"), (\\"11:00\\", \\"12:00\\"), (\\"12:30\\", \\"14:00\\")]) True >>> can_attend_meetings([(\\"09:00\\", \\"10:30\\"), (\\"10:15\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")]) False def test_can_attend_meetings(): assert can_attend_meetings([(\\"09:00\\", \\"10:30\\"), (\\"11:00\\", \\"12:00\\"), (\\"12:30\\", \\"14:00\\")]) == True assert can_attend_meetings([(\\"09:00\\", \\"10:30\\"), (\\"10:15\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")]) == False assert can_attend_meetings([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")]) == True assert can_attend_meetings([(\\"09:00\\", \\"10:30\\")]) == True assert can_attend_meetings([]) == True assert can_attend_meetings([(\\"09:00\\", \\"10:00\\"), (\\"09:00\\", \\"10:00\\")]) == False assert can_attend_meetings([(\\"22:00\\", \\"23:00\\"), (\\"23:30\\", \\"00:30\\")]) == True","solution":"from typing import List, Tuple def time_to_minutes(t: str) -> int: Convert a time string in the format 'HH:MM' to the number of minutes since 00:00. hours, minutes = map(int, t.split(':')) return hours * 60 + minutes def can_attend_meetings(meetings: List[Tuple[str, str]]) -> bool: Determines if a person can attend all meetings without overlaps. if not meetings: return True # Convert meeting times to minutes from 00:00 meetings_in_minutes = [(time_to_minutes(start), time_to_minutes(end)) for start, end in meetings] # Sort meetings by start time meetings_in_minutes.sort() # Check for overlaps for i in range(1, len(meetings_in_minutes)): if meetings_in_minutes[i][0] < meetings_in_minutes[i-1][1]: return False return True"},{"question":"def largest_square_subgrid(n: int, grid: List[List[int]]) -> int: Find the length of the largest square sub-grid that contains only 1s. Args: n (int): The size of the grid (number of rows/columns). grid (List[List[int]]): A 2D list representing the grid where each cell is either a 0 or a 1. Returns: int: The size of the largest square sub-grid containing only 1s. >>> largest_square_subgrid(4, [ ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 1], ... [1, 1, 1, 1] ... ]) == 3 >>> largest_square_subgrid(2, [ ... [1, 1], ... [0, 1] ... ]) == 1 >>> largest_square_subgrid(3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3 >>> largest_square_subgrid(3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> largest_square_subgrid(5, [ ... [0, 0, 1, 0, 0], ... [0, 1, 1, 0, 0], ... [1, 1, 1, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 1, 0, 0] ... ]) == 2","solution":"def largest_square_subgrid(n, grid): if n == 0: return 0 dp = [[0]*n for _ in range(n)] max_square_length = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if dp[i][j] > max_square_length: max_square_length = dp[i][j] return max_square_length"},{"question":"def process_text_editor_operations(test_cases): Process a series of operations on an infinite-line buffer text editor. >>> process_text_editor_operations([ (5, [\\"INSERT 1 a\\", \\"INSERT 2 b\\", \\"INSERT 1 c\\", \\"DELETE 2\\", \\"INSERT 3 d\\"]), (3, [\\"INSERT 1 a\\", \\"DELETE 1\\", \\"INSERT 2 b\\"]) ]) [[\\"ac\\", \\"d\\"], [\\"b\\"]] def parse_input(input_data): Parse the input data into a structured format. >>> parse_input(\\"2n5nINSERT 1 anINSERT 2 bnINSERT 1 cnDELETE 2nINSERT 3 dn3nINSERT 1 anDELETE 1nINSERT 2 b\\") [(5, [\\"INSERT 1 a\\", \\"INSERT 2 b\\", \\"INSERT 1 c\\", \\"DELETE 2\\", \\"INSERT 3 d\\"]), (3, [\\"INSERT 1 a\\", \\"DELETE 1\\", \\"INSERT 2 b\\"])] def format_output(all_outputs): Format the processed output into the required string format. >>> format_output([[\\"ac\\", \\"d\\"], [\\"b\\"]]) \\"acndnnb\\" def test_simple_operations(): input_data = \\"2n5nINSERT 1 anINSERT 2 bnINSERT 1 cnDELETE 2nINSERT 3 dn3nINSERT 1 anDELETE 1nINSERT 2 b\\" test_cases = parse_input(input_data) outputs = process_text_editor_operations(test_cases) formatted_output = format_output(outputs) expected_output = \\"acndnnb\\" assert formatted_output == expected_output def test_no_operations(): input_data = \\"1n0\\" test_cases = parse_input(input_data) outputs = process_text_editor_operations(test_cases) formatted_output = format_output(outputs) expected_output = \\"\\" assert formatted_output == expected_output def test_single_insert(): input_data = \\"1n1nINSERT 1 x\\" test_cases = parse_input(input_data) outputs = process_text_editor_operations(test_cases) formatted_output = format_output(outputs) expected_output = \\"x\\" assert formatted_output == expected_output def test_insert_and_delete(): input_data = \\"1n2nINSERT 1 anDELETE 1\\" test_cases = parse_input(input_data) outputs = process_text_editor_operations(test_cases) formatted_output = format_output(outputs) expected_output = \\"\\" assert formatted_output == expected_output def test_insert_multiple_lines(): input_data = \\"1n4nINSERT 1 anINSERT 2 bnINSERT 1 cnINSERT 3 d\\" test_cases = parse_input(input_data) outputs = process_text_editor_operations(test_cases) formatted_output = format_output(outputs) expected_output = \\"acnbnd\\" assert formatted_output == expected_output","solution":"def process_text_editor_operations(test_cases): all_outputs = [] for case in test_cases: m, operations = case buffer = {} for operation in operations: parts = operation.split() if parts[0] == 'INSERT': x = int(parts[1]) y = parts[2] if x in buffer: buffer[x] += y else: buffer[x] = y elif parts[0] == 'DELETE': x = int(parts[1]) if x in buffer: buffer[x] = \\"\\" result = [] for key in sorted(buffer.keys()): if buffer[key]: result.append(buffer[key]) all_outputs.append(result) return all_outputs # Parse input def parse_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): m = int(lines[index]) index += 1 operations = lines[index:index + m] index += m test_cases.append((m, operations)) return test_cases # Print output def format_output(all_outputs): result = [] for output in all_outputs: result.append(\\"n\\".join(output)) return \\"nn\\".join(result)"},{"question":"def check_no_overlap(n: int, d: int, s: int, sessions: List[List[int]]) -> str: Function to check if there is an overlap in attendance across different sessions. :param n: int - number of employees :param d: int - duration of each session in minutes :param s: int - number of sessions :param sessions: list of list of int - list of sessions where each session is a list of employee IDs :return: str - \\"YES\\" if no overlap, \\"NO\\" otherwise >>> check_no_overlap(5, 60, 3, [[1, 2, 3], [4, 5], [6]]) 'YES' >>> check_no_overlap(5, 60, 3, [[1, 2, 3], [4, 5], [1, 5]]) 'NO'","solution":"def check_no_overlap(n, d, s, sessions): Function to check if there is an overlap in attendance across different sessions. :param n: int - number of employees :param d: int - duration of each session in minutes :param s: int - number of sessions :param sessions: list of list of int - list of sessions where each session is a list of employee IDs :return: str - \\"YES\\" if no overlap, \\"NO\\" otherwise seen_employees = set() for session in sessions: session_set = set(session) if seen_employees & session_set: return \\"NO\\" seen_employees.update(session_set) return \\"YES\\""},{"question":"def min_operations_to_sort(n: int, d: List[int]) -> int: Determine the minimum number of operations required to reorder the queue in non-decreasing difficulty order. >>> min_operations_to_sort(5, [4, 3, 1, 6, 2]) 3 >>> min_operations_to_sort(4, [1, 2, 3, 4]) 0 >>> min_operations_to_sort(4, [4, 3, 2, 1]) 3 >>> min_operations_to_sort(1, [10]) 0 >>> min_operations_to_sort(4, [3, 1, 2, 4]) 1","solution":"def min_operations_to_sort(n, d): target = sorted(d) longest_increasing_subsequence_length = 0 current_length = 0 prev = -1 for value in d: if value >= prev: current_length += 1 else: current_length = 1 prev = value longest_increasing_subsequence_length = max(longest_increasing_subsequence_length, current_length) return n - longest_increasing_subsequence_length"},{"question":"def max_potency(p1: int, p2: int, p3: int) -> int: Returns the maximum possible potency value that can be obtained by mixing potions with given potency values according to the rules. >>> max_potency(1, 2, 3) 6 >>> max_potency(5, 3, 8) 16 >>> max_potency(4, 4, 4) 12 >>> max_potency(0, 0, 0) 0 >>> max_potency(1000, 0, 0) 1000 >>> max_potency(10, 20, 30) 60","solution":"def max_potency(p1, p2, p3): Returns the maximum possible potency value that can be obtained by mixing potions with given potency values according to the rules. potions = [p1, p2, p3] # Sort potions to handle them easily potions.sort() # Maximum potency can be calculated by summing all potencies. max_potency_value = sum(potions) return max_potency_value"},{"question":"def check_tic_tac_toe(moves: [(str, int, int)]) -> str: Determines the outcome of a Tic-Tac-Toe game. Args: - moves: List of tuples. Each tuple contains a play ('X' or 'O'), and two integers indicating the row index (0, 1, or 2) and the column index (0, 1, or 2). Returns: - A string representing the game's outcome: \\"X wins\\", \\"O wins\\", \\"Draw\\", or \\"Pending\\". >>> check_tic_tac_toe([('X', 0, 0), ('O', 1, 1), ('X', 0, 1), ('O', 1, 0), ('X', 0, 2)]) 'X wins' >>> check_tic_tac_toe([('X', 0, 0), ('O', 1, 1), ('X', 0, 1), ('O', 1, 0), ('X', 2, 2), ('O', 1, 2)]) 'O wins' >>> check_tic_tac_toe([('X', 0, 0), ('O', 1, 1), ('X', 0, 1), ('O', 1, 0), ('X', 2, 2), ('O', 1, 2), ('X', 2, 0), ('O', 2, 1), ('X', 1, 1)]) 'Draw' >>> check_tic_tac_toe([('X', 0, 0), ('O', 1, 1)]) 'Pending'","solution":"def check_tic_tac_toe(moves): Determines the outcome of a Tic-Tac-Toe game. Args: - moves: List of tuples. Each tuple contains a play ('X' or 'O'), and two integers indicating the row index (0, 1, or 2) and the column index (0, 1, or 2). Returns: - A string representing the game's outcome: \\"X wins\\", \\"O wins\\", \\"Draw\\", or \\"Pending\\". grid = [['' for _ in range(3)] for _ in range(3)] for move in moves: player, row, col = move grid[row][col] = player # Check rows for row in grid: if row[0] == row[1] == row[2] and row[0] != '': return f\\"{row[0]} wins\\" # Check columns for col in range(3): if grid[0][col] == grid[1][col] == grid[2][col] and grid[0][col] != '': return f\\"{grid[0][col]} wins\\" # Check diagonals if grid[0][0] == grid[1][1] == grid[2][2] and grid[0][0] != '': return f\\"{grid[0][0]} wins\\" if grid[0][2] == grid[1][1] == grid[2][0] and grid[0][2] != '': return f\\"{grid[0][2]} wins\\" # Check for pending moves for row in grid: if '' in row: return \\"Pending\\" # If no winner and no pending moves, it's a draw return \\"Draw\\""},{"question":"def sort_and_remove_duplicates(nums: List[int]) -> List[int]: Sorts a list in ascending order and removes any duplicate elements. >>> sort_and_remove_duplicates([4, 2, 5, 2, 3, 3, 1]) [1, 2, 3, 4, 5] >>> sort_and_remove_duplicates([1, 1, 1, 1, 1]) [1] >>> sort_and_remove_duplicates([]) [] >>> sort_and_remove_duplicates([-1, -2, 0, 1, 1, 2]) [-2, -1, 0, 1, 2] >>> sort_and_remove_duplicates([1000, -1000, 0, 500, -500, 1000]) [-1000, -500, 0, 500, 1000] >>> sort_and_remove_duplicates([5, 3, 9, 1, 8, 3]) [1, 3, 5, 8, 9]","solution":"def sort_and_remove_duplicates(nums): Returns a sorted list with duplicates removed. return sorted(set(nums))"},{"question":"def highest_shared_point(n: int, heights: List[int]) -> int: Determine the highest point both Alice and Bob can reach together. Parameters: n (int): Number of points on the trail. heights (list): List of integers representing the heights of the points on the trail. Returns: int: The highest point both Alice and Bob can reach together. >>> highest_shared_point(6, [1, 2, 3, 2, 4, 5]) == 3 >>> highest_shared_point(1, [10]) == 10 >>> highest_shared_point(5, [3, 3, 3, 3, 3]) == 3 >>> highest_shared_point(4, [1, 2, 2, 1]) == 2 >>> highest_shared_point(7, [1, 5, 3, 5, 6, 4, 7]) == 7","solution":"def highest_shared_point(n, heights): Determine the highest point both Alice and Bob can reach together. Parameters: n (int): Number of points on the trail. heights (list): List of integers representing the heights of the points on the trail. Returns: int: The highest point both Alice and Bob can reach together. # Alice and Bob start together at the first point highest_point = heights[0] for height in heights: # Update the highest point they can reach together if height > highest_point: highest_point = height return highest_point"},{"question":"from typing import List, Tuple def rearrange_string(s: str, k: int) -> str: Rearrange the characters of the string s such that every pair of equal characters has at least k other characters between them. If such a rearrangement is possible, return \\"YES\\" followed by a valid rearranged string. Otherwise, return \\"NO\\". >>> rearrange_string(\\"aabb\\", 2) \\"YESnabab\\" >>> rearrange_string(\\"aabb\\", 3) \\"NO\\" pass def solve(test_cases: List[Tuple[int, str]]) -> List[str]: Solve the problem for multiple test cases. >>> solve([(2, \\"aabb\\"), (3, \\"aabb\\")]) [\\"YESnabab\\", \\"NO\\"] >>> solve([(1, \\"a\\"), (0, \\"a\\")]) [\\"YESna\\", \\"YESna\\"] pass","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s, k): if k == 0: return \\"YESn\\" + s counter = Counter(s) max_heap = [] for char, count in counter.items(): heappush(max_heap, (-count, char)) result = [] queue = [] while max_heap: count, char = heappop(max_heap) result.append(char) queue.append((char, count + 1)) if len(queue) < k: continue prev_char, prev_count = queue.pop(0) if -prev_count > 0: heappush(max_heap, (prev_count, prev_char)) if len(result) != len(s): return \\"NO\\" return \\"YESn\\" + \\"\\".join(result) def solve(test_cases): results = [] for k, s in test_cases: result = rearrange_string(s, k) results.append(result) return results"},{"question":"def assignRanks(scores): Assign ranks to participants based on their scores. Parameters: scores (list): A list of integers representing the scores of participants. Returns: list: A list of tuples where each tuple contains the original index and rank of the participant. Examples: >>> assignRanks([100, 90, 90, 80]) [(0, 1), (1, 2), (2, 2), (3, 4)] >>> assignRanks([50, 50, 50, 50]) [(0, 1), (1, 1), (2, 1), (3, 1)] >>> assignRanks([70, 80, 90, 100]) [(0, 4), (1, 3), (2, 2), (3, 1)] # Your code here","solution":"def assignRanks(scores): Function to assign ranks to participants based on their scores. Parameters: scores (list): A list of integers representing the scores of participants. Returns: list: A list of tuples where each tuple contains the original index and rank of the participant. # Create a list of tuples where each tuple contains the score and its original index indexed_scores = [(score, index) for index, score in enumerate(scores)] # Sort this list in descending order based on the scores indexed_scores.sort(reverse=True, key=lambda x: x[0]) # Initialize the result list and variables to track the current rank and previous score result = [] current_rank = 0 previous_score = None last_rank = 0 for i, (score, index) in enumerate(indexed_scores): if score != previous_score: current_rank = i + 1 previous_score = score last_rank = current_rank result.append((index, current_rank)) # Sort the result list by the original index to match the input order result.sort(key=lambda x: x[0]) return result"},{"question":"def max_challenges(n: int, ranks: List[int]) -> int: Given the number of contestants and their ranks, find the maximum number of challenges that can be initiated among them. Args: n (int): The number of contestants. ranks (List[int]): The ranks of the contestants. Returns: int: The maximum number of challenges that can be initiated. >>> max_challenges(5, [1, 2, 3, 4, 5]) 4 >>> max_challenges(5, [1, 3, 5, 7, 9]) 0 >>> max_challenges(3, [10, 10, 10]) 0 >>> max_challenges(6, [4, 5, 8, 9, 12, 13]) 3 >>> max_challenges(4, [1, 100, 101, 102]) 2","solution":"def max_challenges(n, ranks): Given the number of contestants and their ranks, find the maximum number of challenges that can be initiated among them. ranks = sorted(ranks) max_challenges = 0 for i in range(1, n): if ranks[i] - ranks[i - 1] == 1: max_challenges += 1 return max_challenges"},{"question":"def sentiment_distribution(comments): Determine the overall sentiment distribution in a given set of comments. >>> comments = [ ... \\"Comment: I think this gadget is absolutely fantastic!\\", ... \\"Comment: The performance of this gadget is poor.\\", ... \\"Comment: pretty good experience overall.\\", ... \\"Comment: It is just okay, not too good or bad.\\", ... \\"Comment: horrible build quality!\\", ... \\"Comment: AMAZING design, love it.\\" ... ] >>> sentiment_distribution(comments) (3, 2, 1) pass","solution":"def sentiment_distribution(comments): positive_words = {\\"good\\", \\"excellent\\", \\"amazing\\", \\"fantastic\\", \\"great\\"} negative_words = {\\"bad\\", \\"terrible\\", \\"poor\\", \\"awful\\", \\"horrible\\"} positive_count = 0 negative_count = 0 neutral_count = 0 for comment in comments: comment_text = comment.strip().lower().replace(\\"comment: \\", \\"\\") if any(word in comment_text for word in positive_words): positive_count += 1 elif any(word in comment_text for word in negative_words): negative_count += 1 else: neutral_count += 1 return positive_count, negative_count, neutral_count"},{"question":"def convert_roman_to_integer(s: str) -> int: Convert the Roman numeral string to an integer. >>> convert_roman_to_integer('III') == 3 >>convert_roman_to_integer('IV') == 4 >>> convert_roman_to_integer('IX') == 9 >>> convert_roman_to_integer('LVIII') == 58 >>> convert_roman_to_integer('MCMXCIV') == 1994","solution":"def convert_roman_to_integer(s: str) -> int: Convert the Roman numeral string to an integer. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in s: current_value = roman_to_int[char] if current_value > prev_value: total += current_value - 2 * prev_value else: total += current_value prev_value = current_value return total"},{"question":"def minimal_transportation_cost(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimal transportation cost needed to ensure all towns are interconnected. Args: N (int): The number of towns. M (int): The number of bidirectional roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers, u (town 1), v (town 2), and w (cost). Returns: int: Minimal transportation cost or -1 if not all towns can be interconnected. Example: >>> minimal_transportation_cost(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 1, 9)]) 9 >>> minimal_transportation_cost(4, 2, [(1, 2, 3), (3, 4, 4)]) -1 from typing import List, Tuple from heapq import heappop, heappush from collections import defaultdict","solution":"def minimal_transportation_cost(N, M, roads): Find minimal transportation cost needed to ensure all towns are interconnected using Prim's Algorithm. from heapq import heappop, heappush from collections import defaultdict if N == 1: return 0 # Create adjacency list graph = defaultdict(list) for u, v, w in roads: graph[u].append((w, v)) graph[v].append((w, u)) total_cost = 0 visited = set() min_heap = [(0, 1)] # (cost, node) num_edges_used = 0 while min_heap and num_edges_used < N: cost, u = heappop(min_heap) if u in visited: continue total_cost += cost visited.add(u) num_edges_used += 1 for w, v in graph[u]: if v not in visited: heappush(min_heap, (w, v)) if num_edges_used == N: return total_cost else: return -1"},{"question":"import math from itertools import combinations from typing import List, Tuple def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Computes the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def min_largest_distance(n: int, k: int, coordinates: List[Tuple[int, int]]) -> float: Calculate the minimum possible value of the largest distance any one of the friends has to travel. >>> min_largest_distance(4, 2, [(0, 0), (3, 4), (6, 8), (9, 12)]) 5.0 >>> min_largest_distance(3, 2, [(1, 1), (4, 5), (7, 9)]) 5.0 >>> min_largest_distance(5, 3, [(0, 0), (3, 4), (5, 12), (9, 40), (50, 60)]) 13.0 >>> min_largest_distance(2, 2, [(0, 0), (1, 1)]) 1.4142135623730951 >>> min_largest_distance(4, 1, [(0, 0), (1, 1), (2, 2), (3, 3)]) 0.0","solution":"import math from itertools import combinations def calculate_distance(p1, p2): Computes the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def min_largest_distance(n, k, coordinates): Returns the minimum possible value of the largest distance any friend would need to travel. def max_distance_selected(islands): Helper function to calculate the maximum distance among selected islands. max_dist = 0 for i in range(len(islands)): for j in range(i + 1, len(islands)): max_dist = max(max_dist, calculate_distance(islands[i], islands[j])) return max_dist selected_combinations = combinations(coordinates, k) min_max_distance = float('inf') for selected in selected_combinations: min_max_distance = min(min_max_distance, max_distance_selected(selected)) return min_max_distance"},{"question":"from typing import List def find_closest_triplet_sum(arr: List[int], target: int) -> int: Find a triplet in the array whose sum is closest to the target. Return the sum of the triplet. >>> find_closest_triplet_sum([-1, 2, 1, -4], 1) 2 >>> find_closest_triplet_sum([0, 2, 1, -3, 2], 0) 0 def process_test_cases(test_cases: List[tuple]) -> List[int]: Process multiple test cases and return the results for each as a list of integers. >>> process_test_cases([ (4, 1, [-1, 2, 1, -4]), (5, 0, [0, 2, 1, -3, 2]) ]) [2, 0] >>> process_test_cases([ (4, 3, [1, 1, 1, 1]), (4, 6, [1, 2, 3, 4]), (4, -6, [-1, -2, -3, -4]) ]) [3, 6, -6]","solution":"def find_closest_triplet_sum(arr, target): arr.sort() closest_sum = float('inf') for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: # If current_sum is exactly equal to target, we found the closest possible return current_sum return closest_sum def process_test_cases(test_cases): results = [] for n, target, arr in test_cases: results.append(find_closest_triplet_sum(arr, target)) return results"},{"question":"def rearrange_array(arr: List[int]) -> List[int]: Rearranges the array such that all negative numbers appear before all non-negative numbers. The relative order of the negative and non-negative numbers should remain unchanged. :param arr: List of integers :return: Rearranged list of integers pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Processes multiple test cases for the rearrange_array function. :param test_cases: List of tuples, where each tuple contains (n, arr) :return: List of rearranged arrays pass # Unit tests import unittest class TestRearrangeArray(unittest.TestCase): def test_rearrange_array_all_negative(self): self.assertEqual(rearrange_array([-4, -3, -2, -1]), [-4, -3, -2, -1]) def test_rearrange_array_all_non_negative(self): self.assertEqual(rearrange_array([0, 2, 4, 6]), [0, 2, 4, 6]) def test_rearrange_array_mixed(self): self.assertEqual(rearrange_array([-4, 3, -9, 0, 4]), [-4, -9, 3, 0, 4]) def test_rearrange_array_no_negatives(self): self.assertEqual(rearrange_array([3, 2, 1, 0]), [3, 2, 1, 0]) def test_rearrange_array_no_non_negatives(self): self.assertEqual(rearrange_array([-3, -2, -1]), [-3, -2, -1]) def test_process_test_cases(self): test_cases = [(5, [-4, 3, -9, 0, 4]), (7, [12, -1, -7, 8, -15, 30, 12])] expected = [[-4, -9, 3, 0, 4], [-1, -7, -15, 12, 8, 30, 12]] self.assertEqual(process_test_cases(test_cases), expected) if __name__ == '__main__': unittest.main()","solution":"def rearrange_array(arr): Rearranges the array such that all negative numbers appear before all non-negative numbers. The relative order of the negative and non-negative numbers should remain unchanged. :param arr: List of integers :return: Rearranged list of integers neg = [x for x in arr if x < 0] non_neg = [x for x in arr if x >= 0] return neg + non_neg def process_test_cases(test_cases): Processes multiple test cases for the rearrange_array function. :param test_cases: List of tuples, where each tuple contains (n, arr) :return: List of rearranged arrays results = [] for n, arr in test_cases: results.append(rearrange_array(arr)) return results"},{"question":"def min_subarray_length(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Calculate the minimum length of a contiguous subarray of which the sum is at least S. Args: T: int - the number of test cases. test_cases: List[Tuple[int, int, List[int]]] - a list of test cases, each containing: - n (the length of the array) - S (the target sum) - arr (the list of integers) Returns: List[int] - a list of integers representing the minimum length of a contiguous subarray for each test case. If there isn't one, the function should return 0 for that test case. >>> min_subarray_length(4, [(3, 7, [2, 4, 8]), (5, 15, [1, 2, 3, 4, 9]), (6, 17, [1, 2, 7, 4, 3, 4]), (5, 20, [1, 2, 3, 4, 5])]) [1, 3, 4, 0] from typing import List, Tuple def test_example_cases(): T = 4 test_cases = [ (3, 7, [2, 4, 8]), (5, 15, [1, 2, 3, 4, 9]), (6, 17, [1, 2, 7, 4, 3, 4]), (5, 20, [1, 2, 3, 4, 5]) ] expected = [1, 3, 4, 0] assert min_subarray_length(T, test_cases) == expected def test_single_element_meeting_sum(): T = 1 test_cases = [ (3, 5, [5, 1, 1]) ] expected = [1] assert min_subarray_length(T, test_cases) == expected def test_no_possible_subarray(): T = 1 test_cases = [ (3, 10, [1, 2, 3]) ] expected = [0] assert min_subarray_length(T, test_cases) == expected def test_all_elements_summing_to_target(): T = 1 test_cases = [ (3, 6, [1, 2, 3]) ] expected = [3] assert min_subarray_length(T, test_cases) == expected def test_large_case(): T = 1 test_cases = [ (6, 15, [1, 2, 3, 4, 5, 6]) ] expected = [3] assert min_subarray_length(T, test_cases) == expected def test_multiple_splits_possible(): T = 1 test_cases = [ (6, 10, [1, 2, 3, 4, 5, 6]) ] expected = [2] assert min_subarray_length(T, test_cases) == expected","solution":"def min_subarray_length(T, test_cases): results = [] for case in test_cases: n, S, arr = case left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += arr[right] while current_sum >= S: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 if min_length == float('inf'): results.append(0) else: results.append(min_length) return results"},{"question":"def min_groups(soldiers: List[int], threshold: int) -> int: Determine the minimum number of groups such that the difference in strength between the strongest and the weakest soldier in any group does not exceed the given threshold. :param soldiers: A list of integers representing the strength of soldiers. :param threshold: An integer representing the maximum allowed difference in strength within a group. :return: An integer representing the minimum number of groups required. >>> min_groups([1, 3, 3, 4, 6], 3) 2 >>> min_groups([7, 2, 4, 10, 5], 2) 3","solution":"def min_groups(soldiers, threshold): Returns the minimum number of groups required such that the difference in strength between the strongest and weakest soldier in any group does not exceed the given threshold. # Sort the soldiers by their strength soldiers.sort() # Initialize the number of groups groups = 0 i = 0 # Traverse through the sorted list while i < len(soldiers): # Start a new group groups += 1 j = i # Expand the group as long as it satisfies the threshold constraint while j < len(soldiers) and soldiers[j] - soldiers[i] <= threshold: j += 1 # Move to the next soldier that has not been grouped yet i = j return groups"},{"question":"def min_jumps(arr: List[int]) -> int: Returns the minimum number of jumps required to reach the last index from the first index of the given array. If it's not possible to reach the last index, return \`-1\`. >>> min_jumps([2, 3, 1, 1, 4]) == 2 >>> min_jumps([3, 2, 1, 0, 4]) == -1 >>> min_jumps([0]) == 0 >>> min_jumps([1, 2, 3]) == 2","solution":"def min_jumps(arr): Returns the minimum number of jumps required to reach the last index from the first index of the given array. If it's not possible to reach the last index, return -1. n = len(arr) if n == 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(n-1): farthest = max(farthest, i + arr[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= n - 1: return jumps return -1"},{"question":"from typing import List, Tuple def min_toll_fee(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Given a country with n cities connected by m bidirectional roads, find the minimum total toll fee required to travel from city 1 to city n. If no path exists from city 1 to city n, return \\"Impossible\\" Parameters: n (int): The number of cities. m (int): The number of roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers, ai, bi, ci indicating that there is a bidirectional road connecting city ai and city bi with a toll fee of ci. Returns: int: The minimum total toll fee required or \\"Impossible\\" if no path exists. Example: >>> min_toll_fee(5, 7, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (1, 3, 50), (3, 5, 30), (2, 5, 20)]) 30 >>> min_toll_fee(4, 2, [(1, 2, 5), (3, 4, 5)]) Impossible","solution":"import heapq def min_toll_fee(n, m, roads): graph = [[] for _ in range(n + 1)] for a, b, c in roads: graph[a].append((b, c)) graph[b].append((a, c)) # Dijkstra's algorithm to find the shortest path in terms of toll fees pq = [(0, 1)] # (cost, city) dist = [float('inf')] * (n + 1) dist[1] = 0 while pq: current_cost, current_city = heapq.heappop(pq) if current_city == n: return current_cost for neighbor, cost in graph[current_city]: new_cost = current_cost + cost if new_cost < dist[neighbor]: dist[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return \\"Impossible\\""},{"question":"def can_store_items(n: int, m: int, item_masses: List[int], unit_capacities: List[int]) -> str: Determines if items can be stored without exceeding the capacity of the storage units. :param n: Number of items :param m: Number of storage units :param item_masses: List of masses of the items :param unit_capacities: List of capacities of the storage units :return: \\"YES\\" followed by the distribution of items if possible, otherwise \\"NO\\" >>> can_store_items(4, 3, [2, 3, 2, 5], [5, 5, 5]) 'YESn1 2n3n4' >>> can_store_items(4, 2, [2, 3, 2, 5], [5, 2]) 'NO' >>> can_store_items(1, 1, [1], [1]) 'YESn1' >>> can_store_items(4, 2, [1, 1, 1, 1], [3, 2]) 'YESn1 2 3n4' >>> can_store_items(3, 3, [2, 3, 1], [3, 1, 2]) 'YESn1n2n3' pass","solution":"def can_store_items(n, m, item_masses, unit_capacities): Determines if items can be stored without exceeding the capacity of the storage units. :param n: Number of items :param m: Number of storage units :param item_masses: List of masses of the items :param unit_capacities: List of capacities of the storage units :return: \\"YES\\" followed by the distribution of items if possible, otherwise \\"NO\\" # Initialize storage unit remaining capacity remaining_capacity = unit_capacities[:] # Result list to store which items go into which unit result = [[] for _ in range(m)] # Sort both items and storage units items = sorted([(mass, i) for i, mass in enumerate(item_masses)], reverse=True) units = sorted([(capacity, i) for i, capacity in enumerate(unit_capacities)], reverse=True) for mass, item_index in items: placed = False for capacity, unit_index in units: if remaining_capacity[unit_index] >= mass: remaining_capacity[unit_index] -= mass result[unit_index].append(item_index + 1) # Store 1-based index placed = True break if not placed: return \\"NO\\" output = \\"YESn\\" for storage in result: output += \\" \\".join(map(str, storage)) + \\"n\\" return output.strip()"},{"question":"def max_unique_towers(n: int, heights: List[int]) -> int: Returns the maximum number of towers that can be kept while ensuring all remaining towers have unique heights. Parameters: n (int): Number of towers heights (list of int): Heights of each tower Returns: int: The maximum number of towers with unique heights >>> max_unique_towers(7, [1, 3, 3, 2, 1, 4, 6]) 5 >>> max_unique_towers(5, [1, 2, 3, 4, 5]) 5 >>> max_unique_towers(5, [2, 2, 2, 2, 2]) 1 >>> max_unique_towers(6, [1, 2, 2, 3, 3, 4]) 4 >>> max_unique_towers(10, [1, 10, 1, 10, 1, 10, 1, 10, 20, 20]) 3","solution":"def max_unique_towers(n, heights): Returns the maximum number of towers that can be kept while ensuring all remaining towers have unique heights. Parameters: n (int): Number of towers heights (list of int): Heights of each tower Returns: int: The maximum number of towers with unique heights return len(set(heights))"},{"question":"from typing import List, Tuple def longest_increasing_subsequence(sequence: List[int]) -> Tuple[int, List[int]]: Given a set of integers, find a strictly increasing sub-sequence of maximum length. Args: sequence (List[int]): A list of integers Returns: Tuple[int, List[int]]: A tuple containing the length of the longest strictly increasing sub-sequence and the sub-sequence itself. Examples: >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) (5, [10, 22, 33, 50, 60]) >>> longest_increasing_subsequence([1]) (1, [1]) >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) (1, [5]) >>> longest_increasing_subsequence([1, 3, 2, 4, 3, 5]) (4, [1, 3, 4, 5]) >>> longest_increasing_subsequence([7, 7, 7, 7]) (1, [7]) >>> longest_increasing_subsequence([1, 3, 1, 3, 1, 3]) (2, [1, 3])","solution":"def longest_increasing_subsequence(sequence): n = len(sequence) if n == 0: return 0, [] dp = [1] * n parent = [-1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 parent[i] = j max_length = max(dp) index = dp.index(max_length) lis = [] while index != -1: lis.append(sequence[index]) index = parent[index] lis.reverse() return max_length, lis"},{"question":"def count_subsets_with_sum(arr: List[int], target: int) -> int: Determine if there exists a subset of array elements that sums up to a given target sum. If such a subset exists, return the number of distinct subsets that can form the target sum. Otherwise, return 0. Example: >>> count_subsets_with_sum([2, 3, 5, 6, 8], 10) 2 >>> count_subsets_with_sum([1, 2, 3], 7) 0","solution":"def count_subsets_with_sum(arr, target): Returns the number of distinct subsets that sum up to the target. n = len(arr) # Initialize a dp array where dp[i][j] represents the number of ways to achieve sum j with the first i elements dp = [[0] * (target + 1) for _ in range(n + 1)] # There is one way to achieve the sum 0: use the empty subset for i in range(n + 1): dp[i][0] = 1 for i in range(1, n + 1): for j in range(target + 1): # We can always ignore the current element dp[i][j] = dp[i - 1][j] # Or we can include it, if it does not exceed the current sum we aim for if arr[i - 1] <= j: dp[i][j] += dp[i - 1][j - arr[i - 1]] return dp[n][target]"},{"question":"def compute_average_sales(n: int, p: int, sales_data: List[List[int]]) -> List[int]: Computes the average sales for each product across all periods, rounded down to the nearest integer. Parameters: n (int): The number of products. p (int): The number of periods. sales_data (list[list[int]]): The sales data for each product over each period. Returns: list[int]: The average sales for each product, rounded down to the nearest integer. >>> compute_average_sales(4, 3, [[10, 20, 30, 40], [15, 25, 35, 45], [20, 30, 40, 50]]) [15, 25, 35, 45] >>> compute_average_sales(1, 3, [[10], [20], [30]]) [20] >>> compute_average_sales(4, 1, [[10, 20, 30, 40]]) [10, 20, 30, 40] >>> compute_average_sales(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) [0, 0, 0] >>> compute_average_sales(2, 2, [[1000000, 2000000], [3000000, 4000000]]) [2000000, 3000000]","solution":"def compute_average_sales(n, p, sales_data): Computes the average sales for each product across all periods, rounded down to the nearest integer. Parameters: n (int): The number of products. p (int): The number of periods. sales_data (list[list[int]]): The sales data for each product over each period. Returns: list[int]: The average sales for each product, rounded down to the nearest integer. average_sales = [] for product_index in range(n): total_sales = sum(sales_data[period][product_index] for period in range(p)) average_sales.append(total_sales // p) return average_sales # Example usage n = 4 p = 3 sales_data = [ [10, 20, 30, 40], [15, 25, 35, 45], [20, 30, 40, 50] ] result = compute_average_sales(n, p, sales_data) print(result) # Output: [15, 25, 35, 45]"},{"question":"def unique_elements(arr: List[int]) -> List[int]: Returns a new array containing only the unique elements from the input array in the order they appeared originally. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([7, -1, -1, 5, 5, 10]) [7, -1, 5, 10] pass def test_unique_elements_with_duplicates(): assert unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_unique_elements_no_duplicates(): assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_unique_elements_all_same(): assert unique_elements([2, 2, 2, 2, 2]) == [2] def test_unique_elements_empty(): assert unique_elements([]) == [] def test_unique_elements_mixed_sign_numbers(): assert unique_elements([7, -1, -1, 5, 5, 10]) == [7, -1, 5, 10] def test_unique_elements_negative_numbers(): assert unique_elements([-3, -2, -1, -1, -2, -3]) == [-3, -2, -1] def test_unique_elements_single_element(): assert unique_elements([10]) == [10] def test_unique_elements_large_range(): arr = list(range(1000)) assert unique_elements(arr) == arr def test_unique_elements_single_repeating_pattern(): assert unique_elements([1, 2, 3, 1, 2, 3, 4]) == [1, 2, 3, 4]","solution":"def unique_elements(arr): Returns a new array containing only the unique elements from the input array in the order they appeared originally. seen = set() unique_arr = [] for num in arr: if num not in seen: seen.add(num) unique_arr.append(num) return unique_arr"},{"question":"from typing import List, Tuple def calculate_node_values(n: int, values: List[int], edges: List[Tuple[int, int]]) -> List[int]: Calculate the updated values of each node in a tree with given initial values and edges. Args: n (int): Number of nodes in the tree. values (List[int]): The initial values of the nodes. edges (List[Tuple[int, int]]): The edges of the tree. Returns: List[int]: The updated values of each node in the order from node 1 to node n. Example: >>> calculate_node_values(5, [1, 1, 1, 1, 1], [(1, 2), (1, 3), (2, 4), (2, 5)]) [6, 3, 1, 1, 1] >>> calculate_node_values(1, [5], []) [5] The updated values are calculated as the sum of the initial value and the sum of values of all direct children.","solution":"def calculate_node_values(n, values, edges): from collections import defaultdict import sys sys.setrecursionlimit(200000) # To handle large recursion depths tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Convert \`values\` from list to dict for easier updates values_dict = {i+1: values[i] for i in range(n)} def dfs(node, parent): total_value = values_dict[node] for child in tree[node]: if child != parent: total_value += dfs(child, node) values_dict[node] = total_value return total_value dfs(1, -1) return [values_dict[i] for i in range(1, n + 1)]"},{"question":"def canScheduleTasks(tasks): Determines if all tasks can be scheduled without overlapping. Parameters: tasks (list of tuples): A list of tuples where each tuple represents the start and end time (inclusive) of a task. Returns: bool: Returns True if tasks can be scheduled without overlapping, False otherwise. >>> canScheduleTasks([(1, 4), (4, 5), (7, 9)]) True >>> canScheduleTasks([(1, 4), (3, 5), (6, 8)]) False from solution import canScheduleTasks def test_canScheduleTasks_no_overlap(): tasks = [(1, 4), (4, 5), (7, 9)] assert canScheduleTasks(tasks) == True, \\"Test case 1 failed\\" def test_canScheduleTasks_with_overlap(): tasks = [(1, 4), (3, 5), (6, 8)] assert canScheduleTasks(tasks) == False, \\"Test case 2 failed\\" def test_canScheduleTasks_edge_case_single_task(): tasks = [(0, 23)] assert canScheduleTasks(tasks) == True, \\"Test case 3 failed\\" def test_canScheduleTasks_edge_case_all_overlapping(): tasks = [(1, 5), (2, 6), (3, 7)] assert canScheduleTasks(tasks) == False, \\"Test case 4 failed\\" def test_canScheduleTasks_no_tasks(): tasks = [] assert canScheduleTasks(tasks) == True, \\"Test case 5 failed\\" def test_canScheduleTasks_boundary_times(): tasks = [(0, 1), (1, 2), (2, 3), (3, 4)] assert canScheduleTasks(tasks) == True, \\"Test case 6 failed\\" def test_canScheduleTasks_various_lengths(): tasks = [(0, 4), (5, 9), (9, 15), (15, 20)] assert canScheduleTasks(tasks) == True, \\"Test case 7 failed\\" def test_canScheduleTasks_immediate_overlaps(): tasks = [(0, 1), (1, 3), (3, 5), (5, 6), (6, 8), (8, 10)] assert canScheduleTasks(tasks) == True, \\"Test case 8 failed\\" def test_canScheduleTasks_partial_overlaps(): tasks = [(0, 2), (1, 3), (3, 5), (4, 6)] assert canScheduleTasks(tasks) == False, \\"Test case 9 failed\\"","solution":"def canScheduleTasks(tasks): Determines if all tasks can be scheduled without overlapping. Parameters: tasks (list of tuple): A list of tuples where each tuple represents the start and end time (inclusive) of a task. Returns: bool: Returns True if tasks can be scheduled without overlapping, False otherwise. # Sort the tasks based on their start times tasks.sort() # Iterate through each task and check for overlap with the next task for i in range(len(tasks) - 1): # If the end time of the current task is greater than the start time of the next task if tasks[i][1] > tasks[i + 1][0]: return False return True"},{"question":"def largest_rectangular_area_of_empty_cells(grid: List[List[str]], R: int, C: int) -> int: Determine the largest rectangle of empty cells ('.') within a given grid. >>> largest_rectangular_area_of_empty_cells([ ... ['.', '.', '.', '.', '.'], ... ['.', '.', '#', '.', '.'], ... ['.', '.', '.', '.', '.'] ... ], 3, 5) 6 >>> largest_rectangular_area_of_empty_cells([ ... ['#', '#', '#'], ... ['#', '#', '#'], ... ['#', '#', '#'] ... ], 3, 3) 0","solution":"def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_rectangular_area_of_empty_cells(grid, R, C): if R == 0 or C == 0: return 0 heights = [0] * C max_area = 0 for i in range(R): for j in range(C): if grid[i][j] == '.': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"from typing import List def min_days_to_bloom(n: int, growth_times: List[int]) -> int: Determine the minimum number of days required from any starting day to achieve the goal where all flower types bloom on the same day. >>> min_days_to_bloom(3, [5, 10, 15]) 30 >>> min_days_to_bloom(1, [4]) 4 >>> min_days_to_bloom(2, [6, 8]) 24 >>> min_days_to_bloom(4, [3, 4, 5, 6]) 60 >>> min_days_to_bloom(3, [2, 3, 5]) 30 >>> min_days_to_bloom(3, [7, 7, 7]) 7 >>> min_days_to_bloom(2, [100, 100]) 100","solution":"import math from functools import reduce def lcm(a, b): return abs(a * b) // math.gcd(a, b) def lcm_multiple(numbers): return reduce(lcm, numbers) def min_days_to_bloom(n, growth_times): return lcm_multiple(growth_times)"},{"question":"from typing import List, Tuple, Dict def analyze_bird_migration(test_cases: List[Dict[str, Any]]) -> List[Tuple[int, List[int]]]: Analyzes bird migration patterns given multiple test cases. For each test case, returns: 1. The maximum distance traveled in a single day by any bird. 2. The total distance traveled by each bird over the entire period. :param test_cases: List of dictionaries each containing: - 'n': integer, number of birds - 'm': integer, number of days - 'distances': List of lists of integers representing the distances traveled by each bird. :return: List of tuples containing: - Integer, maximum distance traveled in a single day by any bird - List of integers, total distance traveled by each bird over the entire period. Examples: >>> analyze_bird_migration([ ... {'n': 3, 'm': 3, 'distances': [[4, 2, 3], [1, 3, 5], [2, 2, 4]]} ... ]) [(5, [9, 9, 8])] >>> analyze_bird_migration([ ... {'n': 2, 'm': 4, 'distances': [[5, 1, 1, 4], [3, 2, 1, 2]]} ... ]) [(5, [11, 8])]","solution":"def analyze_bird_migration(test_cases): Analyzes bird migration patterns given multiple test cases. For each test case, returns: 1. The maximum distance traveled in a single day by any bird. 2. The total distance traveled by each bird over the entire period. results = [] for case in test_cases: n, m, distances = case['n'], case['m'], case['distances'] max_distance = 0 total_distances = [] for bird in distances: max_distance = max(max_distance, max(bird)) total_distances.append(sum(bird)) results.append((max_distance, total_distances)) return results"},{"question":"def max_candies_collected(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum number of candies Alice can collect, assuming both players play optimally. Args: n (int): Number of rows in the grid m (int): Number of columns in the grid grid (List[List[int]]): 2D list representing number of candies in each cell Returns: int: Maximum number of candies Alice can collect >>> max_candies_collected(3, 4, [[1, 3, 1, 5], [2, 2, 4, 1], [1, 5, 3, 1]]) 15 >>> max_candies_collected(1, 1, [[42]]) 42 >>> max_candies_collected(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_candies_collected(1, 5, [[1, 2, 3, 4, 5]]) 15 >>> max_candies_collected(5, 1, [[1], [2], [3], [4], [5]]) 15 >>> max_candies_collected(2, 3, [[1, 3, 1], [2, 2, 4]]) 10","solution":"def max_candies_collected(n, m, grid): Returns the maximum number of candies Alice can collect, assuming both players play optimally. # Since the problem is adversarial and involves optimization, we can use dynamic programming to simulate the game. dp = [[0 for _ in range(m)] for _ in range(n)] # Initialize the dp array with the values given in the grid for i in range(n): for j in range(m): dp[i][j] = grid[i][j] # Traverse the grid and update the dp array as per the game's rule for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j]) if i > 0 and j > 0: dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + grid[i][j]) # Maximum sum is the maximum value in the dp table result = 0 for i in range(n): for j in range(m): result = max(result, dp[i][j]) return result"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if the characters of the input string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True # Unit Tests def test_can_form_palindrome_1(): assert can_form_palindrome(\\"civic\\") == True def test_can_form_palindrome_2(): assert can_form_palindrome(\\"ivicc\\") == True def test_can_form_palindrome_3(): assert can_form_palindrome(\\"hello\\") == False def test_can_form_palindrome_4(): assert can_form_palindrome(\\"aabbcc\\") == True def test_can_form_palindrome_5(): assert can_form_palindrome(\\"a\\") == True def test_can_form_palindrome_6(): assert can_form_palindrome(\\"ab\\") == False def test_can_form_palindrome_7(): assert can_form_palindrome(\\"aabbc\\") == True def test_can_form_palindrome_8(): assert can_form_palindrome(\\"aabbccc\\") == True def test_can_form_palindrome_9(): assert can_form_palindrome(\\"xyzzyx\\") == True def test_can_form_palindrome_10(): assert can_form_palindrome(\\"abcd\\") == False","solution":"def can_form_palindrome(s): Determines if the characters of the input string can be rearranged to form a palindrome. :param s: Input string consisting of lowercase English letters. :return: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string. char_count = Counter(s) # To form a palindrome, at most one character can have an odd frequency. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if there's at most one character with an odd count. return odd_count <= 1"},{"question":"def max_coins(grid: List[List[int]]) -> int: Find the maximum number of coins Aelaya can collect when moving from the top-left corner to the bottom-right corner of a grid. >>> max_coins([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_coins([[5]]) 5 >>> max_coins([[1, 2, 3, 4]]) 10 >>> max_coins([[1], [2], [3], [4]]) 10 >>> max_coins([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_coins([[1, 2], [1, 1]]) 4 >>> max_coins([[100, 100], [100, 100]]) 300","solution":"def max_coins(grid): n = len(grid) m = len(grid[0]) # Create a 2D dp array to store the maximum coins collected up to each cell dp = [[0 for _ in range(m)] for _ in range(n)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum coins that can be collected return dp[n-1][m-1]"},{"question":"from typing import List, Tuple def calculate_frequency(n: int, measurements: List[Tuple[int, int]]) -> int: A scientist is conducting an experiment involving a special type of crystal. The crystal resonates at a specific frequency F based on certain conditions. The frequency F is calculated as the sum of the distances between each pair of points, (x_i, y_i) and (x_j, y_j), where i != j and the distance is defined as the Manhattan distance. The Manhattan distance between two points A and B with coordinates (x_A, y_A) and (x_B, y_B) is given by: |x_A - x_B| + |y_A - y_B|, where | · | represents the absolute value. Given the number of measurements n and the integer coordinates of each measurement, compute the frequency F. Parameters: n (int): The number of measurements measurements (List[Tuple[int, int]]): A list of tuples each containing the coordinates of a measurement Returns: int: The frequency F Examples: >>> calculate_frequency(3, [(1, 2), (3, 4), (5, 6)]) 16 >>> calculate_frequency(2, [(1, 1), (4, 5)]) 7 frequency = 0 for i in range(n): for j in range(i + 1, n): frequency += abs(measurements[i][0] - measurements[j][0]) + abs(measurements[i][1] - measurements[j][1]) return frequency def test_calculate_frequency_example(): measurements = [(1, 2), (3, 4), (5, 6)] assert calculate_frequency(3, measurements) == 16 def test_calculate_frequency_single_measurement(): measurements = [(0, 0)] assert calculate_frequency(1, measurements) == 0 def test_calculate_frequency_two_measurements(): measurements = [(1, 1), (4, 5)] assert calculate_frequency(2, measurements) == 7 def test_calculate_frequency_large_coordinates(): measurements = [(1000000, -1000000), (-1000000, 1000000)] assert calculate_frequency(2, measurements) == 4000000 def test_calculate_frequency_mixed_coordinates(): measurements = [(1, -1), (-1, 1), (0, 0)] assert calculate_frequency(3, measurements) == 8 def test_calculate_frequency_equal_coordinates(): measurements = [(1, 1), (1, 1)] assert calculate_frequency(2, measurements) == 0","solution":"def calculate_frequency(n, measurements): Calculate the frequency F based on Manhattan distances between each pair of points. n: int - Number of measurements measurements: List of tuples - List of (x_i, y_i) coordinates Returns: int - The frequency F frequency = 0 for i in range(n): for j in range(i + 1, n): frequency += abs(measurements[i][0] - measurements[j][0]) + abs(measurements[i][1] - measurements[j][1]) return frequency"},{"question":"def find_pairs_with_difference(n, k, array): Find pairs (i, j) such that the absolute difference between array[i] and array[j] is equal to k, and maximize the number of distinct elements used. Args: n : int : the length of the array k : int : the target difference array : List[int] : the array of integers Returns: List[Tuple[int, int]] : a list of pairs that covers more distinct elements of the array def calculate_coverage_and_length(pairs): Calculate the length covered by the maximum number of distinct elements from given pairs. Args: pairs : List[Tuple[int, int]] : a list of pairs of integers Returns: Tuple[List[Tuple[int, int]], int] : the same list of pairs and the length covered by them from solution import find_pairs_with_difference, calculate_coverage_and_length def test_find_pairs_with_difference(): n = 8 k = 2 array = [1, 3, 5, 7, 9, 10, 12, 14] result = find_pairs_with_difference(n, k, array) assert result == [(1, 3), (5, 7), (10, 12)] def test_find_pairs_with_difference_no_pairs(): n = 5 k = 10 array = [1, 2, 3, 4, 5] result = find_pairs_with_difference(n, k, array) assert result == [] def test_find_pairs_with_difference_single_pair(): n = 6 k = 6 array = [1, 6, 12, 18, 24, 30] result = find_pairs_with_difference(n, k, array) assert result == [(6, 12), (18, 24)] def test_calculate_coverage_and_length(): pairs = [(1, 3), (5, 7), (10, 12)] result, length = calculate_coverage_and_length(pairs) assert result == [(1, 3), (5, 7), (10, 12)] assert length == 12 def test_calculate_coverage_and_length_no_pairs(): pairs = [] result, length = calculate_coverage_and_length(pairs) assert result == [] assert length == 0","solution":"def find_pairs_with_difference(n, k, array): array.sort() pairs = [] used = set() i, j = 0, 1 while i < n and j < n: if i == j: j += 1 continue if abs(array[j] - array[i]) == k: if array[i] not in used and array[j] not in used: pairs.append((array[i], array[j])) used.add(array[i]) used.add(array[j]) i += 1 j += 1 else: j += 1 elif abs(array[j] - array[i]) < k: j += 1 else: i += 1 return pairs def calculate_coverage_and_length(pairs): if not pairs: return ([], 0) elements = set() for a, b in pairs: elements.add(a) elements.add(b) min_elem = min(elements) max_elem = max(elements) length_covered = max_elem - min_elem + 1 return pairs, length_covered"},{"question":"def max_score(n: int, k: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Determine the maximum score after performing exactly k operations of coloring nodes. n: number of nodes k: number of nodes to color black values: list of node values edges: list of edges in the tree >>> max_score(5, 2, [3, 2, 7, 1, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) # 15 >>> max_score(3, 1, [10, 20, 15], [(1, 2), (1, 3)]) # 35 >>> max_score(4, 3, [8, 10, 5, 1], [(1, 2), (2, 3), (2, 4)]) # 10 >>> max_score(6, 0, [12, 3, 9, 7, 6, 8], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) # 45 >>> max_score(4, 4, [1, 2, 3, 4], [(1, 2), (1, 3), (3, 4)]) # 0","solution":"def max_score(n, k, values, edges): # Sort the values to determine which nodes to color black. sorted_values = sorted(values) # The idea is to color the nodes with the smallest k values black. white_values = sorted_values[k:] # Calculate the sum of remaining white nodes' values max_possible_score = sum(white_values) return max_possible_score"},{"question":"from typing import List, Tuple def generate_difficulties(l: int, b1: int, v: int, w: int, m: int) -> List[int]: Generate the sequence of difficulties for a participant. >>> generate_difficulties(2, 5, 3, 2, 100) [5, 11] >>> generate_difficulties(2, 4, 1, 5, 50) [4, 9] pass def minimize_difficult_transitions(n: int, participants: List[Tuple[int, int, int, int, int]]) -> Tuple[int, List[Tuple[int, int]]]: Minimize the number of difficult transitions. >>> n = 2 >>> participants = [(2, 5, 3, 2, 100), (2, 4, 1, 5, 50)] >>> minimize_difficult_transitions(n, participants) (0, [(4, 2), (5, 1), (9, 2), (11, 1)]) pass def solve(n: int, participants: List[Tuple[int, int, int, int, int]]): Solve the problem of organizing the competition problems. >>> n = 2 >>> participants = [(2, 5, 3, 2, 100), (2, 4, 1, 5, 50)] >>> solve(n, participants) 0n4 2n5 1n9 2n11 1n pass","solution":"def generate_difficulties(l, b1, v, w, m): difficulties = [b1] for j in range(1, l): next_difficulty = (difficulties[-1] + v * w) % m difficulties.append(next_difficulty) return difficulties def minimize_difficult_transitions(n, participants): all_problems = [] for i, (l, b1, v, w, m) in enumerate(participants): difficulties = generate_difficulties(l, b1, v, w, m) problems = [(difficulty, i + 1) for difficulty in difficulties] all_problems.extend(problems) all_problems.sort() difficult_transitions = 0 for i in range(1, len(all_problems)): if all_problems[i][0] < all_problems[i - 1][0]: difficult_transitions += 1 return difficult_transitions, all_problems def solve(n, participants): difficult_transitions, ordered_problems = minimize_difficult_transitions(n, participants) print(difficult_transitions) if len(ordered_problems) <= 200000: for problem in ordered_problems: print(problem[0], problem[1]) # Example usage: n = 2 participants = [ (2, 5, 3, 2, 100), (2, 4, 1, 5, 50), ] solve(n, participants)"},{"question":"def treasure_hunt(n: int, q: int, boxes: List[int], queries: List[Tuple[int, int]]) -> List[str]: Simulate the treasure hunt system, returning \\"Yes\\" or \\"No\\" for each query. Parameters: n (int): The number of boxes. q (int): The number of queries. boxes (list): List of box identifiers. queries (list): List of queries with ranges to check for the treasure. Returns: list: List of responses (\\"Yes\\" or \\"No\\") for each query. # Your code here # Example test cases def test_basic_case(): assert treasure_hunt(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (3, 3)]) == [\\"No\\", \\"Yes\\", \\"No\\"] def test_single_box_treasure(): assert treasure_hunt(1, 1, [1], [(1, 1)]) == [\\"Yes\\"] def test_range_includes_last_box(): assert treasure_hunt(5, 2, [1, 2, 3, 4, 5], [(4, 5), (1, 5)]) == [\\"Yes\\", \\"Yes\\"] def test_range_excludes_last_box(): assert treasure_hunt(5, 2, [1, 2, 3, 4, 5], [(1, 4), (2, 3)]) == [\\"No\\", \\"No\\"] def test_query_out_of_bounds(): # Simulating a larger range than the list (invalid scenario in real use but for robustness) assert treasure_hunt(5, 1, [1, 2, 3, 4, 5], [(1, 6)]) == [\\"Yes\\"] def test_large_inputs(): n = 10000 boxes = list(range(1, n + 1)) queries = [(1, 5000), (5000, 10000), (9999, 10000)] expected = [\\"No\\", \\"Yes\\", \\"Yes\\"] assert treasure_hunt(n, 3, boxes, queries) == expected def test_empty_queries(): assert treasure_hunt(5, 0, [1, 2, 3, 4, 5], []) == []","solution":"def treasure_hunt(n, q, boxes, queries): Simulate the treasure hunt system, returning \\"Yes\\" or \\"No\\" for each query. Parameters: n (int): The number of boxes. q (int): The number of queries. boxes (list): List of box identifiers. queries (list): List of queries with ranges to check for the treasure. Returns: list: List of responses (\\"Yes\\" or \\"No\\") for each query. if n <= 0 or q <= 0: return [] # The treasure is always in the last box treasure = boxes[-1] responses = [] for l, r in queries: if treasure in boxes[l-1:r]: responses.append(\\"Yes\\") else: responses.append(\\"No\\") return responses"},{"question":"from typing import List, Tuple def tree_node_sum(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Given a tree with 'n' nodes and their values, compute the sum of node values in the subtree rooted at each queried node. >>> tree_node_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], [1, 3, 4]) [15, 12, 4] >>> tree_node_sum(3, [10, 20, 30], [(1, 2), (1, 3)], [1, 2]) [60, 20] >>> tree_node_sum(4, [3, 5, 8, 2], [(1, 2), (1, 3), (3, 4)], [1, 3, 2]) [18, 10, 5] # Your implementation here","solution":"def tree_node_sum(n, values, edges, queries): from collections import defaultdict # Building the tree as an adjacency list tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) # DFS to compute subtree sums def dfs(node, parent): subtree_sum = values[node - 1] for neighbor in tree[node]: if neighbor != parent: subtree_sum += dfs(neighbor, node) subtree_sums[node] = subtree_sum return subtree_sum subtree_sums = [0] * (n + 1) dfs(1, -1) result = [] for query in queries: result.append(subtree_sums[query]) return result # Example usage: n = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 3, 4] print(tree_node_sum(n, values, edges, queries))"},{"question":"from typing import List, Tuple def max_total_value(n: int, m: int, t: int, food_items: List[Tuple[int, int]], toy_items: List[Tuple[int, int]]) -> int: Determine the maximum possible total value of the items that John can place on the table with size t. Parameters: n (int): Number of packets of food. m (int): Number of toys. t (int): Size of the table. food_items (List[Tuple[int, int]]): List of tuples where each tuple contains value and size of a food packet. toy_items (List[Tuple[int, int]]): List of tuples where each tuple contains value and size of a toy. Returns: int: The maximum total value of items that can be placed on the table. Examples: >>> max_total_value(2, 1, 10, [(3, 4), (6, 5)], [(4, 3)]) 10 >>> max_total_value(1, 2, 5, [(3, 2)], [(4, 2), (2, 1)]) 9 >>> max_total_value(3, 1, 7, [(3, 2), (4, 4), (2, 6)], [(4, 3)]) 7 >>> max_total_value(1, 2, 8, [(5, 3)], [(6, 4), (7, 5)]) 11 >>> max_total_value(0, 1, 1, [], [(5, 2)]) 0 pass","solution":"def max_total_value(n, m, t, food_items, toy_items): Returns the maximum possible total value of the items that John can place on the table. Parameters: n (int): Number of packets of food. m (int): Number of toys. t (int): Size of the table. food_items (list of tuples): Each tuple contains two integers, value and size of a food packet. toy_items (list of tuples): Each tuple contains two integers, value and size of a toy. Returns: int: The maximum total value of items that can be placed on the table. # Combine all items into a single list items = food_items + toy_items # Sort items based on their value-to-size ratio in descending order items.sort(key=lambda x: x[0] / x[1], reverse=True) total_size = 0 total_value = 0 for value, size in items: if total_size + size <= t: total_size += size total_value += value return total_value"},{"question":"def find_two_subarrays_with_sum_k(n: int, k: int, arr: List[int]) -> str: Determines if it's possible to find two non-overlapping subarrays that both sum to k. Parameters: n (int): The length of the array. k (int): The target sum for subarrays. arr (list of int): The input array. Returns: str: \\"YES\\" if two such subarrays exist, otherwise \\"NO\\". >>> find_two_subarrays_with_sum_k(5, 10, [1, 2, 3, 4, 5]) \\"NO\\" >>> find_two_subarrays_with_sum_k(5, 5, [1, 2, 2, 1, 2, 3]) \\"YES\\" >>> find_two_subarrays_with_sum_k(1, 3, [3]) \\"NO\\" >>> find_two_subarrays_with_sum_k(5, 0, [-1, 1, 2, -2, 0]) \\"YES\\" >>> find_two_subarrays_with_sum_k(5, -5, [-1, -4, 1, -4, -1]) \\"YES\\" >>> find_two_subarrays_with_sum_k(5, 11, [1, 2, 3, 4, 5]) \\"NO\\"","solution":"def find_two_subarrays_with_sum_k(n, k, arr): Determines if it's possible to find two non-overlapping subarrays that both sum to k. Parameters: n (int): The length of the array. k (int): The target sum for subarrays. arr (list of int): The input array. Returns: str: \\"YES\\" if two such subarrays exist, otherwise \\"NO\\". prefix_sums = {0} current_sum = 0 for i in range(n): current_sum += arr[i] if current_sum - k in prefix_sums: prefix_sums_at_i = prefix_sums.copy() current_sum_i = current_sum for j in range(i + 1, n): current_sum_i += arr[j] if (current_sum_i - k) in prefix_sums_at_i: return \\"YES\\" prefix_sums_at_i.add(current_sum_i) prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def maxBitonicSubarray(nums: List[int]) -> int: Find the maximum length of a bitonic subarray within nums. >>> maxBitonicSubarray([1, 3, 5, 4, 2]) 5 >>> maxBitonicSubarray([1, 2, 2, 3, 4, 3, 2, 5, 6]) 5 >>> maxBitonicSubarray([1, 2, 3, 4, 5]) 5 >>> maxBitonicSubarray([5, 4, 3, 2, 1]) 5 >>> maxBitonicSubarray([1]) 1 >>> maxBitonicSubarray([1, 2]) 2 >>> maxBitonicSubarray([2, 1]) 2 >>> maxBitonicSubarray([3, 5, 7, 10, 1]) 5 >>> maxBitonicSubarray([10, 9, 8, 7, 6, 5]) 6 >>> maxBitonicSubarray([1, 3, 5, 4, 2, 6, 8, 7, 4]) 5 pass","solution":"def maxBitonicSubarray(nums): n = len(nums) if n <= 2: return n # Arrays to store the length of increasing or decreasing subarray ending at index i inc = [1] * n dec = [1] * n # Fill the increasing subarray lengths for i in range(1, n): if nums[i] > nums[i - 1]: inc[i] = inc[i - 1] + 1 # Fill the decreasing subarray lengths for i in range(n - 2, -1, -1): if nums[i] > nums[i + 1]: dec[i] = dec[i + 1] + 1 # Find the maximum length of bitonic subarray max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"import math from typing import List def max_gcd_of_pairs(n: int, array: List[int]) -> int: Finds the maximum GCD of all possible pairs (i, j) in the given list of integers. Parameters: n (int): Number of integers in the list. array (List[int]): List of integers. Returns: int: The maximum GCD obtained from any pair of distinct indices in the list. >>> max_gcd_of_pairs(4, [10, 8, 6, 15]) 5 >>> max_gcd_of_pairs(5, [10, 25, 50, 100, 40]) 50 >>> max_gcd_of_pairs(2, [1, 2]) 1 >>> max_gcd_of_pairs(3, [12, 24, 36]) 12 >>> max_gcd_of_pairs(4, [3, 5, 7, 11]) 1 >>> max_gcd_of_pairs(4, [50, 100, 75, 25]) 50","solution":"import math def max_gcd_of_pairs(n, array): Finds the maximum GCD of all possible pairs (i, j) in the given list of integers. Parameters: n (int): Number of integers in the list. array (List[int]): List of integers. Returns: int: The maximum GCD obtained from any pair of distinct indices in the list. array.sort() max_gcd = 1 for i in range(n-1): for j in range(i+1, n): current_gcd = math.gcd(array[i], array[j]) if current_gcd > max_gcd: max_gcd = current_gcd return max_gcd"},{"question":"def contains_cycle(matrix, m, n): Determine if there is a cycle in a given m x n matrix of characters. Each element in the matrix is a lowercase English letter. A cycle is a path of the same character that starts and ends at the same cell, and visits at least one other cell. From a given cell, you can move to one of the neighbouring cells which share a common side. Input: - matrix: List[List[str]], a 2D list of characters representing the matrix - m: int, number of rows in the matrix - n: int, number of columns in the matrix Output: - str: \\"Yes\\" if there is a cycle in the matrix, otherwise \\"No\\" >>> contains_cycle([['a', 'a', 'a', 'a'], ['a', 'b', 'c', 'a'], ['a', 'a', 'a', 'a']], 3, 4) \\"Yes\\" >>> contains_cycle([['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l']], 3, 4) \\"No\\" pass def input_to_matrix(input_string): Convert an input formatted string to a matrix representation. Input: - input_string: str, input string with m, n and the matrix elements Output: - tuple: (matrix, m, n) >>> input_to_matrix(\\"3 4naaaanabcanaaaa\\") ([['a', 'a', 'a', 'a'], ['a', 'b', 'c', 'a'], ['a', 'a', 'a', 'a']], 3, 4) pass","solution":"def contains_cycle(matrix, m, n): def dfs(x, y, from_x, from_y, char): if visited[x][y]: return True visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: next_x, next_y = x + dx, y + dy if 0 <= next_x < m and 0 <= next_y < n and (next_x != from_x or next_y != from_y) and matrix[next_x][next_y] == char: if dfs(next_x, next_y, x, y, char): return True return False visited = [[False]*n for _ in range(m)] for i in range(m): for j in range(n): if not visited[i][j]: if dfs(i, j, -1, -1, matrix[i][j]): return \\"Yes\\" return \\"No\\" def input_to_matrix(input_string): lines = input_string.strip().split('n') m, n = map(int, lines[0].split()) matrix = [list(line) for line in lines[1:]] return matrix, m, n"},{"question":"def shortest_palindromic_subsequence(s: str) -> str: Find the shortest palindromic subsequence of the given string \`s\` with a length greater than 1. If no such subsequence exists, return -1. >>> shortest_palindromic_subsequence(\\"a\\") -1 >>> shortest_palindromic_subsequence(\\"abcdef\\") -1 >>> shortest_palindromic_subsequence(\\"abcba\\") \\"aa\\" >>> shortest_palindromic_subsequence(\\"abcaabca\\") \\"aa\\" >>> shortest_palindromic_subsequence(\\"aa\\") \\"aa\\" >>> shortest_palindromic_subsequence(\\"aaaaaa\\") \\"aa\\" >>> shortest_palindromic_subsequence(\\"bcbacbab\\") \\"bb\\" pass","solution":"def shortest_palindromic_subsequence(s: str) -> str: Find the shortest palindromic subsequence of the given string \`s\` with a length greater than 1. If no such subsequence exists, return -1. n = len(s) # Generate all pairs of letters in the string for i in range(n): for j in range(i + 1, n): if s[i] == s[j]: return s[i] * 2 # If no such pair is found, return -1 return -1"},{"question":"def min_cost_to_connect_junctions(n: int, m: int, pipes: List[Tuple[int, int, int]]) -> int: Returns the minimum cost required to connect all junctions with provided pipes. If not possible, returns -1. >>> min_cost_to_connect_junctions(4, 5, [(1, 2, 3), (1, 3, 4), (4, 2, 6), (3, 4, 5), (3, 2, 2)]) 10 >>> min_cost_to_connect_junctions(3, 0, []) -1 >>> min_cost_to_connect_junctions(2, 1, [(1, 2, 1)]) 1 >>> min_cost_to_connect_junctions(4, 2, [(1, 2, 3), (3, 4, 4)]) -1 >>> min_cost_to_connect_junctions(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 50)]) 3","solution":"def min_cost_to_connect_junctions(n, m, pipes): Returns the minimum cost required to connect all junctions with provided pipes. If not possible, returns -1. parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 pipes.sort(key=lambda x: x[2]) num_edges = 0 total_cost = 0 for u, v, w in pipes: if find(u) != find(v): union(u, v) total_cost += w num_edges += 1 if num_edges == n - 1: return total_cost else: return -1 # Example usage n = 4 m = 5 pipes = [(1, 2, 3), (1, 3, 4), (4, 2, 6), (3, 4, 5), (3, 2, 2)] print(min_cost_to_connect_junctions(n, m, pipes)) # Output: 10"},{"question":"def decrypt_caesar_cipher(n: int, s: str, k: int) -> str: Decrypts the given string s of length n with Caesar cipher by shifting each character k positions to the left in the alphabet. :param n: Length of the string s :param s: String to be decrypted :param k: Number of positions to shift each character to the left :return: Decrypted string >>> decrypt_caesar_cipher(5, \\"bcdef\\", 1) \\"abcde\\" >>> decrypt_caesar_cipher(4, \\"zabc\\", 1) \\"yzab\\" >>> decrypt_caesar_cipher(3, \\"abc\\", 26) \\"abc\\" >>> decrypt_caesar_cipher(4, \\"ijkl\\", 0) \\"ijkl\\" >>> decrypt_caesar_cipher(6, \\"ghijkl\\", 13) \\"tuvwxy\\" >>> decrypt_caesar_cipher(26, \\"abcdefghijklmnopqrstuvwxyz\\", 13) \\"nopqrstuvwxyzabcdefghijklm\\" >>> decrypt_caesar_cipher(5, \\"zyxwv\\", 5) \\"utsrq\\"","solution":"def decrypt_caesar_cipher(n, s, k): Decrypts the given string s of length n with Caesar cipher by shifting each character k positions to the left in the alphabet. :param n: Length of the string s :param s: String to be decrypted :param k: Number of positions to shift each character to the left :return: Decrypted string decrypted_string = '' for char in s: # Find the new position in the alphabet new_position = (ord(char) - ord('a') - k) % 26 new_char = chr(ord('a') + new_position) decrypted_string += new_char return decrypted_string"},{"question":"from typing import List def filter_emails(emails: List[str]) -> List[str]: Implement a function, filter_emails, that takes a list of email addresses and returns only those that follow specific criteria. An email address must consist of a local part, followed by the \\"@\\" symbol, and then a domain part. The local part must contain only alphanumeric characters and periods, but it cannot start or end with a period, and it cannot contain consecutive periods. The domain part must consist of at least two labels separated by periods, each label containing only alphanumeric characters. The top-level domain (the final label) must consist entirely of alphabetic characters and be between 2 to 6 characters long. >>> filter_emails([\\"example.email@domain.com\\"]) [\\"example.email@domain.com\\"] >>> filter_emails([\\"user@sub.domain.co.uk\\"]) [\\"user@sub.domain.co.uk\\"] >>> filter_emails([\\"invalid..email@domain.com\\"]) [] >>> filter_emails([\\".leadingdot@domain.com\\"]) [] >>> filter_emails([\\"trailingdot.@domain.com\\"]) [] >>> filter_emails([\\"username@domain..com\\"]) [] >>> filter_emails([\\"user@domain.c0m\\"]) [] >>> filter_emails([\\"example.email@domain.com\\", \\"user@sub.domain.co.uk\\", \\"invalid..email@domain.com\\", \\".leadingdot@domain.com\\", \\"username@domain..com\\", \\"user@domain.c0m\\"]) [\\"example.email@domain.com\\", \\"user@sub.domain.co.uk\\"]","solution":"import re from typing import List def filter_emails(emails: List[str]) -> List[str]: Returns a list of email addresses that meet the specified criteria. valid_emails = [] for email in emails: if re.fullmatch(r\\"^[a-zA-Z0-9](.?[a-zA-Z0-9])*@[a-zA-Z0-9]+(.[a-zA-Z0-9]+)*.[a-zA-Z]{2,6}\\", email): if \\"..\\" not in email.split('@')[0]: # Ensure no consecutive periods in local part valid_emails.append(email) return valid_emails"},{"question":"import heapq from typing import List, Tuple def find_shortest_path(n: int, m: int, routes: List[Tuple[int, int, int]], start: int, end: int) -> int: Finds the shortest path between start and end using Dijkstra's algorithm. Parameters: n (int): Number of cities m (int): Number of bus routes routes (list of tuples): List of routes described by tuples (u, v, w) start (int): Starting city end (int): Destination city Returns: int: Shortest travel time between start and end; -1 if no path exists >>> find_shortest_path(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 4)], 1, 3) 3 >>> find_shortest_path(3, 2, [(1, 2, 5), (2, 3, 5)], 1, 3) 10 >>> find_shortest_path(2, 1, [(1, 2, 1)], 1, 2) 1 >>> find_shortest_path(5, 6, [(1, 2, 2), (1, 3, 2), (2, 4, 1), (3, 4, 3), (4, 5, 1), (3, 5, 4)], 1, 5) 4 >>> find_shortest_path(4, 2, [(1, 2, 1), (3, 4, 1)], 1, 3) -1","solution":"import heapq def find_shortest_path(n, m, routes, start, end): Finds the shortest path between start and end using Dijkstra's algorithm. Parameters: n (int): Number of cities m (int): Number of bus routes routes (list of tuples): List of routes described by tuples (u, v, w) start (int): Starting city end (int): Destination city Returns: int: Shortest travel time between start and end; -1 if no path exists # Create a graph from the routes graph = {i: [] for i in range(1, n + 1)} for u, v, w in routes: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm min_heap = [(0, start)] shortest_paths = {i: float('inf') for i in range(1, n + 1)} shortest_paths[start] = 0 while min_heap: current_time, current_city = heapq.heappop(min_heap) if current_city == end: return current_time for neighbor, travel_time in graph[current_city]: time = current_time + travel_time if time < shortest_paths[neighbor]: shortest_paths[neighbor] = time heapq.heappush(min_heap, (time, neighbor)) return -1 if shortest_paths[end] == float('inf') else shortest_paths[end]"},{"question":"def optimal_hamiltonian_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the weight of the optimal Hamiltonian path in an undirected graph. If no Hamiltonian path exists, return -1. Args: - n (int): The number of vertices in the graph. - m (int): The number of edges in the graph. - edges (List[Tuple[int, int, int]]): A list of tuples where each tuple represents an edge (u, v, w) with vertices u and v and weight w. Returns: - int: The weight of the optimal Hamiltonian path, or -1 if no Hamiltonian path exists. >>> optimal_hamiltonian_path(1, 0, []) 0 >>> optimal_hamiltonian_path(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 10)]) 2 >>> optimal_hamiltonian_path(4, 2, [(1, 2, 1), (3, 4, 1)]) -1 >>> optimal_hamiltonian_path(4, 6, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (2, 3, 1), (2, 4, 1), (3, 4, 1)]) 3 >>> optimal_hamiltonian_path(3, 0, []) -1","solution":"def optimal_hamiltonian_path(n, m, edges): from itertools import permutations if n == 1: return 0 graph = [[float('inf')] * n for _ in range(n)] for u, v, w in edges: u -= 1 v -= 1 graph[u][v] = w graph[v][u] = w def calculate_path_cost(path): cost = 0 for i in range(1, len(path)): if graph[path[i-1]][path[i]] == float('inf'): return float('inf') cost += graph[path[i-1]][path[i]] return cost min_cost = float('inf') for perm in permutations(range(n)): cost = calculate_path_cost(perm) if cost < min_cost: min_cost = cost return min_cost if min_cost != float('inf') else -1"},{"question":"def max_palindromic_substrings(s): Determine the maximum number of distinct palindromic substrings after any number of swaps. Args: s (str): The input string. Returns: int: The maximum number of distinct palindromic substrings. >>> max_palindromic_substrings(\\"abac\\") 3 >>> max_palindromic_substrings(\\"aabb\\") 2 >>> max_palindromic_substrings(\\"abc\\") 3 >>> max_palindromic_substrings(\\"aaaa\\") 1 def solve(test_cases): Solve multiple test cases for maximum distinct palindromic substrings. Args: test_cases (List[str]): The list of input strings. Returns: List[int]: The list of results for each test case. >>> solve([\\"abac\\", \\"aabb\\", \\"abc\\"]) [3, 2, 3] >>> solve([\\"abcd\\", \\"aaa\\", \\"aabbccdd\\"]) [4, 1, 4]","solution":"def max_palindromic_substrings(s): # A set to keep track of all distinct characters in 's'. unique_chars = set(s) # All individual characters are palindromic substrings. # Swapping characters won't change the count of unique characters, # thus the maximum number of distinct palindromic substrings is # the number of unique characters. return len(unique_chars) def solve(test_cases): results = [] for s in test_cases: results.append(max_palindromic_substrings(s)) return results"},{"question":"def min_steps_to_zero_grid(grid: List[List[int]]) -> int: Returns the minimum number of steps required to convert the grid to zeroes. :param grid: List of lists representing the grid with integers :return: The minimum number of steps or -1 if impossible >>> min_steps_to_zero_grid([[2, 3, 4], [1, 2, 3], [4, 3, 2]]) 4 >>> min_steps_to_zero_grid([[7, 8, 9]]) 9 >>> min_steps_to_zero_grid([[5], [10], [3]]) 10 >>> min_steps_to_zero_grid([[4]]) 4 >>> min_steps_to_zero_grid([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def min_steps_to_zero_grid(grid): Returns the minimum number of steps required to convert the grid to zeroes. :param grid: List of lists representing the grid with integers :return: The minimum number of steps or -1 if impossible max_val = 0 for row in grid: max_val = max(max_val, max(row)) return max_val"},{"question":"def max_books(N: int, queries: int) -> int: Determines the maximum number of books that can be borrowed from contiguous segments of N bookshelves, using up to \`queries\` queries to get the sum of books from shelf L to shelf R. Arguments: N : int : Number of bookshelves queries : int : Maximum number of queries allowed Returns: int : Maximum number of books that can be borrowed in a single continuous segment pass def test_max_books(): assert max_books(6, 10) <= 28 assert max_books(10, 15) <= 55 assert max_books(3, 3) <= 6 assert max_books(20, 40) <= 210 assert max_books(5, 8) <= 15 test_max_books()","solution":"def max_books(N, queries): Determines the maximum number of books that can be borrowed from contiguous segments of N bookshelves, using up to \`queries\` queries to get the sum of books from shelf L to shelf R. Arguments: N : int : Number of bookshelves queries : int : Maximum number of queries allowed Returns: int : Maximum number of books that can be borrowed in a single continuous segment # simulate initial values of bookshelves shelves = [i % 10 for i in range(1, N + 1)] # This is just an example, original will depend on input def query(L, R): Returns the total number of books from shelf L to shelf R inclusive. return sum(shelves[L-1:R]) max_books = 0 for L in range(1, N + 1): for R in range(L, N + 1): if queries > 0: curr_books = query(L, R) max_books = max(max_books, curr_books) queries -= 1 else: break if queries <= 0: break return max_books"},{"question":"from typing import List def generate_parentheses(N: int) -> List[str]: Generates all valid parentheses combinations of length 2N. Parameters: N (int): The number of pairs of parentheses. Returns: List[str]: A list of strings containing all valid combinations. >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]","solution":"def generate_parentheses(N): Generates all valid parentheses combinations of length 2N. Parameters: N (int): The number of pairs of parentheses. Returns: list: A list of strings containing all valid combinations. result = [] def backtrack(S='', left=0, right=0): if len(S) == 2 * N: result.append(S) return if left < N: backtrack(S + '(', left + 1, right) if right < left: backtrack(S + ')', left, right + 1) backtrack() return result"},{"question":"def minimal_travel_time(n, m): Returns the minimal total time required for the astronauts to travel from the first crater to the last crater modulo m. >>> minimal_travel_time(5, 100) 4 >>> minimal_travel_time(10, 12) 9","solution":"def minimal_travel_time(n, m): Returns the minimal total time required for the astronauts to travel from the first crater to the last crater modulo m. total_time = (n - 1) return total_time % m"},{"question":"def max_stones_from_paths(test_cases): Determine the maximum number of stones Sarah can collect for each test case. Parameters: test_cases (List[List[int]]): A list of test cases where each test case is a list of integers representing the number of stones on each path. Returns: List[int]: A list of integers where each integer is the maximum number of stones that can be collected for the corresponding test case. >>> max_stones_from_paths([[2, 3, 1, 5]]) [5] >>> max_stones_from_paths([[4, 4, 4]]) [4] >>> max_stones_from_paths([[1, 2, 8, 3, 2]]) [8] >>> max_stones_from_paths([[10]]) [10]","solution":"def max_stones_from_paths(test_cases): results = [] for paths in test_cases: results.append(max(paths)) return results # Example usage input_data = [ [2, 3, 1, 5], [4, 4, 4], [1, 2, 8, 3, 2] ] print(max_stones_from_paths(input_data)) # Output should be [5, 4, 8]"},{"question":"def is_geometric_sequence(n: int, sequence: List[int]) -> str: Determines if a given sequence is a geometric sequence. n: int - number of elements in the sequence sequence: list of int - elements of the sequence Returns \\"YES\\" if the sequence is a geometric sequence, otherwise \\"NO\\". >>> is_geometric_sequence(3, [2, 6, 18]) \\"YES\\" >>> is_geometric_sequence(3, [1, 2, 3]) \\"NO\\"","solution":"def is_geometric_sequence(n, sequence): Determines if a given sequence is a geometric sequence. n: int - number of elements in the sequence sequence: list of int - elements of the sequence Returns \\"YES\\" if the sequence is a geometric sequence, otherwise \\"NO\\". if n == 2: return \\"YES\\" ratio = sequence[1] / sequence[0] for i in range(1, n): if sequence[i] / sequence[i - 1] != ratio: return \\"NO\\" return \\"YES\\""},{"question":"from collections import defaultdict from typing import List, Tuple, Union def possible_team_assignment(n: int, k: int, m: int, preferences: List[Tuple[int, int]]) -> Tuple[str, Union[None, List[List[int]]]]: Determine whether it’s possible to assign employees to teams such that each team has exactly k members and no two employees who dislike each other are on the same team. Args: n : int - number of employees (1 ≤ n ≤ 100) k : int - size of each team (1 ≤ k ≤ n) m : int - number of pairs where employees prefer not to be on the same team (1 ≤ m ≤ 1000) preferences : List[Tuple[int, int]] - list of pairs (a, b) indicating that employee a does not want to be on the same team as employee b Returns: Tuple[str, Union[None, List[List[int]]]] - \\"YES\\" and the possible team assignments if feasible, \\"NO\\" otherwise. >>> possible_team_assignment(6, 3, 2, [(1, 2), (3, 4)]) (\\"YES\\", [[1, 3, 5], [2, 4, 6]]) >>> possible_team_assignment(6, 2, 4, [(1, 2), (3, 4), (5, 6), (1, 3)]) (\\"NO\\", None) pass def test_possible_teams(): n, k, m = 6, 3, 2 preferences = [(1, 2), (3, 4)] expected_result = \\"YES\\" res, teams = possible_team_assignment(n, k, m, preferences) assert res == expected_result assert teams == [[1, 3, 5], [2, 4, 6]] or teams == [[1, 4, 6], [2, 3, 5]] def test_no_possible_teams(): n, k, m = 6, 2, 4 preferences = [(1, 2), (3, 4), (5, 6), (1, 3)] expected_result = \\"NO\\" res, _ = possible_team_assignment(n, k, m, preferences) assert res == expected_result def test_possible_teams_single_pref(): n, k, m = 4, 2, 1 preferences = [(1, 2)] expected_result = \\"YES\\" res, teams = possible_team_assignment(n, k, m, preferences) assert res == expected_result assert teams == [[1, 3], [2, 4]] or teams == [[1, 4], [2, 3]] def test_large_input(): n, k, m = 100, 10, 2 preferences = [(1, 2), (3, 4)] expected_result = \\"YES\\" res, _ = possible_team_assignment(n, k, m, preferences) assert res == expected_result","solution":"from collections import defaultdict, deque def possible_team_assignment(n, k, m, preferences): if n % k != 0: return \\"NO\\", None dislike = defaultdict(set) for a, b in preferences: dislike[a].add(b) dislike[b].add(a) teams = [[] for _ in range(n // k)] team_idx = 0 def find_team(employee): for i in range(len(teams)): if len(teams[i]) < k and not any(member in dislike[employee] for member in teams[i]): return i return -1 for employee in range(1, n + 1): team_index = find_team(employee) if team_index == -1: return \\"NO\\", None teams[team_index].append(employee) return \\"YES\\", teams def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) m = int(data[2]) preferences = [] for i in range(3, 3 + 2 * m, 2): preferences.append((int(data[i]), int(data[i + 1]))) result, teams = possible_team_assignment(n, k, m, preferences) print(result) if result == \\"YES\\": for i, team in enumerate(teams): print(f\\"Team {i + 1}: {' '.join(map(str, team))}\\") if __name__ == \\"__main__\\": main()"},{"question":"class Inventory: def __init__(self): self.stock = {} def add(self, x, y): Add \`y\` items to the stock of the item with code \`x\`. If item \`x\` does not exist in the inventory, it should be added with the given stock \`y\`. pass def remove(self, x, y): Remove \`y\` items from the stock of the item with code \`x\`. If the item has fewer than \`y\` items in stock, remove all items of that code and the stock of that item should become 0. pass def check(self, x): Return the current stock of the item with code \`x\`. If the item doesn't exist, return 0. pass def inventory_system(queries): Execute a series of inventory queries and return the results of each \`check\` query. >>> queries = ['add 101 5', 'add 102 10', 'check 101', 'remove 101 3', 'check 101', 'remove 101 4', 'check 101'] >>> inventory_system(queries) [5, 2, 0] >>> queries = ['check 999'] >>> inventory_system(queries) [0] pass def test_inventory_system(): queries = [ \\"add 101 5\\", \\"add 102 10\\", \\"check 101\\", \\"remove 101 3\\", \\"check 101\\", \\"remove 101 4\\", \\"check 101\\" ] expected = [5, 2, 0] result = inventory_system(queries) assert result == expected def test_inventory_system_empty_check(): queries = [ \\"check 999\\" ] expected = [0] result = inventory_system(queries) assert result == expected def test_inventory_system_add_remove_check(): queries = [ \\"add 111 50\\", \\"add 111 50\\", \\"check 111\\", \\"remove 111 30\\", \\"check 111\\", \\"remove 111 120\\", \\"check 111\\" ] expected = [100, 70, 0] result = inventory_system(queries) assert result == expected def test_inventory_system_remove_nonexisting(): queries = [ \\"remove 123 10\\", \\"check 123\\" ] expected = [0] result = inventory_system(queries) assert result == expected def test_inventory_system_mixed_operations(): queries = [ \\"add 222 20\\", \\"remove 222 5\\", \\"check 222\\", \\"add 222 15\\", \\"remove 222 30\\", \\"check 222\\" ] expected = [15, 0] result = inventory_system(queries) assert result == expected","solution":"class Inventory: def __init__(self): self.stock = {} def add(self, x, y): if x in self.stock: self.stock[x] += y else: self.stock[x] = y def remove(self, x, y): if x in self.stock: if self.stock[x] <= y: self.stock[x] = 0 else: self.stock[x] -= y def check(self, x): return self.stock.get(x, 0) def inventory_system(queries): inventory = Inventory() results = [] for query in queries: parts = query.split() cmd = parts[0] x = int(parts[1]) if cmd == \\"add\\": y = int(parts[2]) inventory.add(x, y) elif cmd == \\"remove\\": y = int(parts[2]) inventory.remove(x, y) elif cmd == \\"check\\": results.append(inventory.check(x)) return results"},{"question":"def shortest_paths(m: int, n: int, roads: List[Tuple[int, int, int]], s: int) -> List[int]: Find the shortest paths from city \`s\` to all other cities in Graphland. Parameters: - m (int): the number of cities - n (int): the number of roads - roads (list of tuples): each tuple contains three integers u, v, w indicating a road between city u and city v with weight w - s (int): the starting city Returns: - list of int: distance from city \`s\` to every other city. If a city is not reachable, the distance is -1. >>> shortest_paths(1, 0, [], 1) [0] >>> shortest_paths(2, 1, [(1, 2, 5)], 1) [0, 5] >>> shortest_paths(2, 1, [(1, 2, 5)], 2) [5, 0] >>> shortest_paths(4, 2, [(1, 2, 4), (3, 4, 6)], 1) [0, 4, -1, -1] >>> shortest_paths(4, 2, [(1, 2, 4), (3, 4, 6)], 3) [-1, -1, 0, 6] >>> roads = [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 1)] >>> shortest_paths(4, 4, roads, 1) [0, 1, 3, 4] >>> roads = [(i, i+1, 1) for i in range(1, 100000)] >>> shortest_paths(100000, 99999, roads, 1)[-1] 99999","solution":"import heapq import sys def shortest_paths(m, n, roads, s): Find the shortest paths from city \`s\` to all other cities. Parameters: - m (int): the number of cities - n (int): the number of roads - roads (list of tuples): each tuple contains three integers u, v, w indicating a road between city u and city v with weight w - s (int): the starting city Returns: - list of int: distance from city \`s\` to every other city. If a city is not reachable, the distance is -1. # Create adjacency list graph = {i: [] for i in range(1, m + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm distances = [float('inf')] * (m + 1) distances[s] = 0 priority_queue = [(0, s)] # (distance, city) while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_distance > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Format the distances as required: replace \`inf\` with -1, adjust for zero-based index result = [] for i in range(1, m + 1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"def max_balloons_sum(n: int, sections: List[List[int]]) -> int: Calculate the maximum sum of burst balloons given the constraints. >>> max_balloons_sum(3, [[1, 5, 3], [7, 2], [8, 6, 4, 5]]) 41 >>> max_balloons_sum(2, [[10, 20], [30]]) 60 >>> max_balloons_sum(1, [[50]]) 50 >>> max_balloons_sum(4, [[2], [4, 4], [1, 1, 1], [10, 20, 30]]) 73 >>> max_balloons_sum(0, []) 0","solution":"def max_balloons_sum(n, sections): This function calculates the maximum sum of burst balloons given the constraints. Parameters: n (int): the number of sections. sections (list of lists): each inner list contains the numbers on balloons in that section. Returns: int: the maximum sum of burst balloons. max_sum = 0 for section in sections: max_sum += sum(section) return max_sum # Example Usage: # n = 3 # sections = [[1, 5, 3], [7, 2], [8, 6, 4, 5]] # max_balloons_sum(n, sections) should return 41"},{"question":"def longest_increasing_subarray_length(heights: List[int]) -> int: Find the length of the longest increasing subarray of mountain heights. >>> longest_increasing_subarray_length([1, 2, 2, 3, 5, 1, 7, 8]) == 3 >>> longest_increasing_subarray_length([5]) == 1 >>> longest_increasing_subarray_length([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subarray_length([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subarray_length([1, 3, 2, 4, 3, 5]) == 2 >>> longest_increasing_subarray_length([1, 2, 2, 2, 2, 3]) == 2 >>> longest_increasing_subarray_length([10, 20, 3, 4, 5, 2, 40, 50, 60]) == 4 >>> longest_increasing_subarray_length([]) == 0 >>> longest_increasing_subarray_length([100]) == 1 >>> longest_increasing_subarray_length([1, 100000]) == 2 >>> longest_increasing_subarray_length([100000, 1]) == 1","solution":"def longest_increasing_subarray_length(heights): Finds the length of the longest increasing subarray in the given list of mountain heights. n = len(heights) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def maxStations(a: List[int], m: int) -> int: Returns the maximum number of stations that can be fully allocated resources. >>> maxStations([4, 3, 5], 10) 2 >>> maxStations([3, 8, 5, 7], 15) 3","solution":"def maxStations(a, m): Returns the maximum number of stations that can be fully allocated resources. # Sort the resource times to allocate smaller periods first a.sort() # Initialize count of fully allocated stations and total allocated resources count = 0 total = 0 # Allocate resources to stations while within the total available resources for time in a: if total + time <= m: total += time count += 1 else: break return count"},{"question":"def min_possible_max_value(n: int, sequence: List[int]) -> int: Determines the minimum possible maximum value of the sequence after exactly one operation. :param n: Length of the sequence (1 ≤ n ≤ 100,000) :param sequence: List of integers (1 ≤ ai ≤ 1,000,000) :return: The minimum possible maximum value of the sequence >>> min_possible_max_value(1, [5]) 6 >>> min_possible_max_value(3, [3, 3, 3]) 4 >>> min_possible_max_value(3, [2, 3, 5]) 4 >>> min_possible_max_value(4, [1, 2, 3, 4]) 3 >>> min_possible_max_value(3, [1000000, 1000000, 1000000]) 1000001 >>> min_possible_max_value(5, [1, 6, 3, 4, 2]) 4","solution":"def min_possible_max_value(n, sequence): Determines the minimum possible maximum value of the sequence after exactly one operation. :param n: Length of the sequence (1 ≤ n ≤ 100,000) :param sequence: List of integers (1 ≤ ai ≤ 1,000,000) :return: The minimum possible maximum value of the sequence # Sort the sequence to facilitate finding the median sorted_sequence = sorted(sequence) # Possible operations: we should adjust the elements to the median value if possible # Median minimizes the maximum deviation in either direction if n % 2 == 0: median1, median2 = sorted_sequence[n // 2 - 1], sorted_sequence[n // 2] return min(median1 + 1, median2 + 1) else: median = sorted_sequence[n // 2] return median + 1 # Example case implementation n = 4 sequence = [1, 2, 3, 4] print(min_possible_max_value(n, sequence)) # Should output 3"},{"question":"def has_unique_chars(s: str) -> bool: Determines if the string consists of all unique characters. Args: s (str): The input string. Returns: bool: True if all characters in the string are unique, False otherwise. >>> has_unique_chars(\\"abcdef\\") True >>> has_unique_chars(\\"hello\\") False >>> has_unique_chars(\\"aabbcc\\") False >>> has_unique_chars(\\"a\\") True >>> has_unique_chars(\\"\\") True >>> has_unique_chars(\\"abcdefghijklmnopqrstuvwxyz\\") True >>> has_unique_chars(\\"abcdea\\") False >>> has_unique_chars(\\"abcde \\") True","solution":"def has_unique_chars(s: str) -> bool: Determines if the string consists of all unique characters. Args: s (str): The input string. Returns: bool: True if all characters in the string are unique, False otherwise. char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True"},{"question":"from typing import List def max_notifications_in_window(timestamps: List[int]) -> int: Given an array of integers timestamps representing the moments (in seconds, in ascending order) when the notifications were generated, return the maximum number of notifications that were generated within any 60-second window. >>> max_notifications_in_window([1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) 7 >>> max_notifications_in_window([5, 15, 25, 35, 45, 55, 65, 75, 85, 95, 105]) 6 >>> max_notifications_in_window([]) 0 >>> max_notifications_in_window([100]) 1 >>> max_notifications_in_window([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> max_notifications_in_window([1, 61, 121, 181]) 1 pass","solution":"from typing import List def max_notifications_in_window(timestamps: List[int]) -> int: start = 0 max_count = 0 n = len(timestamps) for end in range(n): while timestamps[end] - timestamps[start] >= 60: start += 1 max_count = max(max_count, end - start + 1) return max_count"},{"question":"def is_special_dna(dna_sequence: str) -> str: Determines if the given DNA sequence is a \\"Special DNA\\", which means it should not contain the subsequence \\"ATG\\". >>> is_special_dna(\\"ATGCA\\") \\"NO\\" >>> is_special_dna(\\"AACG\\") \\"YES\\" >>> is_special_dna(\\"TGA\\") \\"YES\\" >>> is_special_dna(\\"AGGTCG\\") \\"YES\\" def special_dna_test_cases(test_cases: List[str]) -> List[str]: Takes a list of DNA sequences and determines for each if it is a \\"Special DNA\\". Returns a list of \\"YES\\"/\\"NO\\" results for each corresponding input sequence. >>> special_dna_test_cases([\\"ATGCA\\", \\"AACG\\", \\"TGA\\", \\"AGGTCG\\"]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_special_dna(dna_sequence): Determines if the given DNA sequence is a \\"Special DNA\\", which means it should not contain the subsequence \\"ATG\\". t = len(dna_sequence) for i in range(t - 2): if dna_sequence[i] == 'A' and dna_sequence[i+1] == 'T' and dna_sequence[i+2] == 'G': return \\"NO\\" return \\"YES\\" def special_dna_test_cases(test_cases): results = [] for dna in test_cases: results.append(is_special_dna(dna)) return results"},{"question":"from typing import List def count_k_palindromic_substrings(s: str) -> List[int]: Determine the number of k-palindromic substrings for each value of k from 1 to the length of the string. A k-palindromic substring of the string is any substring of length k that reads the same forwards and backwards. >>> count_k_palindromic_substrings(\\"a\\") [1] >>> count_k_palindromic_substrings(\\"aa\\") [2, 1] >>> count_k_palindromic_substrings(\\"ab\\") [2, 0] >>> count_k_palindromic_substrings(\\"aba\\") [3, 0, 1] >>> count_k_palindromic_substrings(\\"abcba\\") [5, 0, 1, 0, 1] pass def process_test_cases(test_cases: List[str]) -> List[List[int]]: Process multiple test cases and return the results. >>> process_test_cases([\\"a\\", \\"aa\\", \\"ab\\", \\"aba\\", \\"abcba\\"]) [[1], [2, 1], [2, 0], [3, 0, 1], [5, 0, 1, 0, 1]] pass # Unit tests def test_single_character(): s = \\"a\\" assert count_k_palindromic_substrings(s) == [1] def test_double_character_same(): s = \\"aa\\" assert count_k_palindromic_substrings(s) == [2, 1] def test_double_character_diff(): s = \\"ab\\" assert count_k_palindromic_substrings(s) == [2, 0] def test_palindrome_string(): s = \\"aba\\" assert count_k_palindromic_substrings(s) == [3, 0, 1] def test_mixed_string(): s = \\"abcba\\" assert count_k_palindromic_substrings(s) == [5, 0, 1, 0, 1] def test_process_test_cases(): test_cases = [\\"a\\", \\"aa\\", \\"ab\\", \\"aba\\", \\"abcba\\"] expected = [ [1], [2, 1], [2, 0], [3, 0, 1], [5, 0, 1, 0, 1] ] assert process_test_cases(test_cases) == expected","solution":"def count_k_palindromic_substrings(s): n = len(s) result = [0] * n # Process for each length from 1 to n for k in range(1, n + 1): count = 0 for i in range(n - k + 1): substr = s[i:i + k] if substr == substr[::-1]: count += 1 result[k - 1] = count return result def process_test_cases(test_cases): results = [] for s in test_cases: results.append(count_k_palindromic_substrings(s)) return results"},{"question":"def lexicographically_smallest_string(S: str) -> str: Returns the lexicographically smallest string possible by replacing one character in the string S. >>> lexicographically_smallest_string(\\"dab\\") \\"aab\\" >>> lexicographically_smallest_string(\\"baa\\") \\"aaa\\" >>> lexicographically_smallest_string(\\"z\\") \\"a\\" >>> lexicographically_smallest_string(\\"aaa\\") \\"aaa\\" >>> lexicographically_smallest_string(\\"zxy\\") \\"axy\\"","solution":"def lexicographically_smallest_string(S): Returns the lexicographically smallest string possible by replacing one character in the string S. n = len(S) for i in range(n): for c in 'a': # Try replacing with the smallest possible letter 'a' if S[i] != c: new_string = S[:i] + c + S[i+1:] return new_string # Should not reach here as at least one replacement is always possible according to problem constraints return S"},{"question":"def daily_temperatures(n: int, temperatures: List[int]) -> List[int]: Calculate the number of days until a warmer temperature for each day. If there is no such future day, return 0 for that day. :param n: int - number of days :param temperatures: list of int - temperatures for each day :return: list of int - number of days until a warmer temperature for each day >>> daily_temperatures(8, [73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures(5, [100, 90, 80, 70, 60]) [0, 0, 0, 0, 0] >>> daily_temperatures(1, [50]) [0] >>> daily_temperatures(4, [70, 70, 70, 70]) [0, 0, 0, 0] >>> daily_temperatures(5, [60, 61, 62, 63, 64]) [1, 1, 1, 1, 0]","solution":"def daily_temperatures(n, temperatures): Calculate the number of days until a warmer temperature for each day. If there is no such future day, return 0 for that day. :param n: int - number of days :param temperatures: list of int - temperatures for each day :return: list of int - number of days until a warmer temperature for each day result = [0] * n stack = [] # this will store the index of temperatures for current_day in range(n): # While stack is not empty and current temperature is higher than the temperature at the index stored in the stack while stack and temperatures[current_day] > temperatures[stack[-1]]: previous_day = stack.pop() result[previous_day] = current_day - previous_day stack.append(current_day) return result"},{"question":"def shortest_path(maze: List[List[int]]) -> int: Find the length of the shortest path from the top-left corner to the bottom-right corner of a 2D grid maze. The robot can only move up, down, left, or right, and cannot pass through obstacles. If no such path exists, return -1. >>> shortest_path([[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0]]) 7 >>> shortest_path([[0, 1], [1, 0]]) -1 >>> shortest_path([[0]]) 1 >>> shortest_path([[0, 0], [0, 0]]) 3 >>> shortest_path([[0, 1], [1, 1]]) -1 >>> shortest_path([[0, 0, 1, 0, 0], [1, 0, 1, 1, 0], [1, 0, 0, 0, 0]]) 7","solution":"from typing import List from collections import deque def shortest_path(maze: List[List[int]]) -> int: n = len(maze) m = len(maze[0]) if maze[0][0] == 1 or maze[n-1][m-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == n - 1 and c == m - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and maze[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if the input string s can be rearranged to form a palindrome. Returns \\"YES\\" if possible, otherwise returns \\"NO\\". >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"racecar\\") \\"YES\\" >>> can_form_palindrome(\\"abcdefgh\\") \\"NO\\" >>> can_form_palindrome(\\"cdcd\\") \\"YES\\" pass def process_queries(queries: List[str]) -> List[str]: Given a list of query strings, returns a list of \\"YES\\" or \\"NO\\" for each query based on whether the string can be rearranged to form a palindrome. >>> process_queries([\\"aabb\\", \\"racecar\\", \\"abcdefgh\\", \\"cdcd\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] pass import pytest def test_can_form_palindrome(): assert can_form_palindrome(\\"aabb\\") == \\"YES\\" assert can_form_palindrome(\\"racecar\\") == \\"YES\\" assert can_form_palindrome(\\"abcdefgh\\") == \\"NO\\" assert can_form_palindrome(\\"cdcd\\") == \\"YES\\" assert can_form_palindrome(\\"a\\") == \\"YES\\" assert can_form_palindrome(\\"aa\\") == \\"YES\\" assert can_form_palindrome(\\"aaa\\") == \\"YES\\" assert can_form_palindrome(\\"abca\\") == \\"NO\\" def test_process_queries(): queries = [ \\"aabb\\", \\"racecar\\", \\"abcdefgh\\", \\"cdcd\\" ] expected_output = [ \\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\" ] assert process_queries(queries) == expected_output queries = [ \\"a\\", \\"ab\\", \\"abc\\", \\"abccba\\", \\"abcdabcd\\", \\"aabbccddeeffgg\\" ] expected_output = [ \\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\" ] assert process_queries(queries) == expected_output","solution":"def can_form_palindrome(s): Determines if the input string s can be rearranged to form a palindrome. Returns \\"YES\\" if possible, otherwise returns \\"NO\\". from collections import Counter # Count the occurrence of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_occurrences = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd number of occurrences return \\"YES\\" if odd_occurrences <= 1 else \\"NO\\" def process_queries(queries): Given a list of query strings, returns a list of \\"YES\\" or \\"NO\\" for each query based on whether the string can be rearranged to form a palindrome. return [can_form_palindrome(query) for query in queries]"},{"question":"def count_unique_addresses(invitations: List[Tuple[str, str]], queries: List[str]) -> List[int]: John is organizing a party and he has a list of invitations to send. Each invitation contains the name and the address of the recipient. John wants to evaluate how many unique addresses he has to send invitations to. Additionally, he decides to perform some updates on the invitations and needs to check the number of unique addresses after each update. Return a list of results for each \\"c\\" query. >>> invitations = [(\\"john\\", \\"123main\\"), (\\"doe\\", \\"456elm\\"), (\\"alice\\", \\"123main\\"), (\\"bob\\", \\"789oak\\"), (\\"mary\\", \\"456elm\\")] >>> queries = [\\"c\\"] >>> count_unique_addresses(invitations, queries) [3] >>> queries = [\\"u 2 789pine\\", \\"c\\"] >>> count_unique_addresses(invitations, queries) [4] >>> queries = [\\"c\\", \\"u 2 789pine\\", \\"c\\"] >>> count_unique_addresses(invitations, queries) [3, 4] >>> queries = [\\"c\\", \\"c\\"] >>> count_unique_addresses(invitations, queries) [3, 3] >>> queries = [\\"u 4 123main\\", \\"c\\"] >>> count_unique_addresses(invitations, queries) [2]","solution":"def count_unique_addresses(invitations, queries): from collections import defaultdict n = len(invitations) address_map = defaultdict(set) addresses = {} for idx in range(n): name, address = invitations[idx] address_map[address].add(idx) addresses[idx] = address results = [] for query in queries: parts = query.split() if parts[0] == \\"c\\": unique_count = len(address_map) results.append(unique_count) elif parts[0] == \\"u\\": idx = int(parts[1]) - 1 new_address = parts[2] old_address = addresses[idx] address_map[old_address].remove(idx) if not address_map[old_address]: del address_map[old_address] address_map[new_address].add(idx) addresses[idx] = new_address return results"},{"question":"def can_make_elements_equal(sequence: List[int]) -> str: Determine if all elements of the sequence can be made equal by selecting a subsequence and increasing each of its elements by one, zero or more times. Args: sequence (list of int): The sequence of integers. Returns: str: \\"YES\\" if it's possible to make all elements equal, otherwise \\"NO\\". # Check the difference between max and min if max(sequence) - min(sequence) > 1: return \\"NO\\" return \\"YES\\" def test_all_elements_equal(): assert can_make_elements_equal([3, 3, 3, 3]) == \\"YES\\" def test_elements_with_difference_one(): assert can_make_elements_equal([1, 2, 2, 1, 1]) == \\"YES\\" assert can_make_elements_equal([1, 2, 1, 2]) == \\"YES\\" def test_elements_with_greater_difference(): assert can_make_elements_equal([1, 2, 3, 4]) == \\"NO\\" assert can_make_elements_equal([1, 5, 1, 2]) == \\"NO\\" def test_single_element(): assert can_make_elements_equal([1]) == \\"YES\\" assert can_make_elements_equal([10**9]) == \\"YES\\" def test_two_elements(): assert can_make_elements_equal([1, 1]) == \\"YES\\" assert can_make_elements_equal([1, 2]) == \\"YES\\" assert can_make_elements_equal([1, 3]) == \\"NO\\"","solution":"def can_make_elements_equal(sequence): Determine if all elements of the sequence can be made equal by selecting a subsequence and increasing each of its elements by one, zero or more times. Args: sequence (list of int): The sequence of integers. Returns: str: \\"YES\\" if it's possible to make all elements equal, otherwise \\"NO\\". # Check the difference between max and min if max(sequence) - min(sequence) > 1: return \\"NO\\" return \\"YES\\""},{"question":"from collections import deque from typing import List, Tuple def shortest_chain_bfs(n: int, friends: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Finds the shortest chain of friendships connecting users using BFS. Parameters: n (int): Number of users. friends (List[Tuple[int, int]]): List of user friendships. queries (List[Tuple[int, int]]): List of user queries to find the shortest chain. Returns: List[int]: List of shortest lengths of chains for each query, or -1 if no chain exists. >>> shortest_chain_bfs(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 3), (1, 5), (2, 5)]) [2, 3, 2] >>> shortest_chain_bfs(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 5), (2, 4), (1, 3)]) [4, 3, 2]","solution":"from collections import deque def shortest_chain_bfs(n, friends, queries): Finds the shortest chain of friendships connecting users using BFS. Parameters: n (int): Number of users. friends (List[Tuple[int, int]]): List of user friendships. queries (List[Tuple[int, int]]): List of user queries to find the shortest chain. Returns: List[int]: List of shortest lengths of chains for each query, or -1 if no chain exists. graph = [[] for _ in range(n + 1)] # Build the friendship graph for u, v in friends: graph[u].append(v) graph[v].append(u) def bfs(start, end): Helper function to perform BFS to find the shortest path. Parameters: start (int): The starting node. end (int): The target node. Returns: int: Length of the shortest path, or -1 if no path exists. if start == end: return 0 visited = [False] * (n + 1) queue = deque([(start, 0)]) # (current_node, current_distance) while queue: node, distance = queue.popleft() for neighbor in graph[node]: if neighbor == end: return distance + 1 if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, distance + 1)) return -1 # Process each query result = [] for x, y in queries: result.append(bfs(x, y)) return result"},{"question":"def count_increasing_triplets(arr: List[int]) -> int: Count the number of triplets (i, j, k) such that i < j < k and arr[i] < arr[j] < arr[k]. >>> count_increasing_triplets([1, 2, 3, 4]) 4 >>> count_increasing_triplets([4, 3, 2, 1]) 0 >>> count_increasing_triplets([1, 5, 2, 4, 3]) 2 >>> count_increasing_triplets([2, 2, 2, 2, 2]) 0 >>> count_increasing_triplets([1, 2]) 0 >>> count_increasing_triplets([]) 0 >>> count_increasing_triplets([1]) 0 >>> count_increasing_triplets([1, 2, 3]) 1","solution":"def count_increasing_triplets(arr): n = len(arr) count = 0 # Iterate through each possible j for the middle of the triplet for j in range(1, n-1): count_i = 0 count_k = 0 # Count elements less than arr[j] before index j for i in range(j): if arr[i] < arr[j]: count_i += 1 # Count elements greater than arr[j] after index j for k in range(j+1, n): if arr[k] > arr[j]: count_k += 1 count += count_i * count_k return count"},{"question":"from typing import List, Tuple def is_valid_reservation(n: int, reservations: List[Tuple[int, str, str]]) -> str: Determines if a list of reservations is valid according to the policy that no two guests can be assigned the same room on the same night. Parameters: n (int): The number of reservations. reservations (list of tuples): Each tuple contains (room_number, start_date, end_date) in the format: - room_number: positive integer representing the room number - start_date: str representing the start date in the format YYYY-MM-DD (inclusive) - end_date: str representing the end date in the format YYYY-MM-DD (exclusive) Returns: str: \\"VALID\\" if no reservations overlap for the same room, \\"INVALID\\" otherwise. Example: >>> is_valid_reservation(4, [(101, \\"2023-01-01\\", \\"2023-01-05\\"), (101, \\"2023-01-05\\", \\"2023-01-10\\"), (102, \\"2023-01-03\\", \\"2023-01-08\\"), (101, \\"2023-01-04\\", \\"2023-01-06\\")]) 'INVALID' >>> is_valid_reservation(3, [(101, \\"2023-01-01\\", \\"2023-01-05\\"), (102, \\"2023-01-04\\", \\"2023-01-06\\"), (102, \\"2023-01-01\\", \\"2023-01-03\\")]) 'VALID'","solution":"from datetime import datetime def is_valid_reservation(n, reservations): Determines if a list of reservations is valid. Parameters: n (int): number of reservations reservations (list of tuples): each tuple contains (room_number, start_date, end_date) Returns: str: \\"VALID\\" if no reservations overlap for the same room, \\"INVALID\\" otherwise. # Create a dictionary to store reservations by room number room_reservations = {} for reservation in reservations: room_number, start_date, end_date = reservation # Convert dates to datetime objects start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") # Initialize the list for the room number if it doesn't exist if room_number not in room_reservations: room_reservations[room_number] = [] # Check for overlap with existing bookings in the same room for existing_start, existing_end in room_reservations[room_number]: if not (end_date <= existing_start or start_date >= existing_end): return \\"INVALID\\" # Add the current reservation to the room reservations room_reservations[room_number].append((start_date, end_date)) return \\"VALID\\""},{"question":"def trap_rainwater(heights): Given a list of building heights, calculate the amount of trapped rainwater. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([]) 0 >>> trap_rainwater([1]) 0 >>> trap_rainwater([1, 2]) 0 >>> trap_rainwater([3, 0, 2, 0, 4]) 7 >>> trap_rainwater([2, 2, 2, 2]) 0 >>> trap_rainwater([0, 1, 2, 1, 0]) 0 >>> trap_rainwater([2, 0, 2]) 2","solution":"def trap_rainwater(heights): Given a list of building heights, calculate the amount of trapped rainwater. if not heights: return 0 n = len(heights) if n < 3: return 0 left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"import math MOD = 1000000007 def ways_to_form_circle(n: int) -> int: Calculate the number of distinct ways to arrange n villagers in a circle. Args: n (int): The number of villagers Returns: int: The number of distinct ways to arrange the villagers modulo 1000000007 Example: >>> ways_to_form_circle(1) 1 >>> ways_to_form_circle(5) 24","solution":"import math MOD = 1000000007 def ways_to_form_circle(n): Calculate the number of distinct ways to arrange n villagers in a circle. Args: n (int): The number of villagers Returns: int: The number of distinct ways to arrange the villagers modulo 1000000007 if n == 1: return 1 # Calculate (n-1)! % MOD return math.factorial(n - 1) % MOD"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def find_farthest_distance(n: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Determine the farthest distance from each city to any other city and report the maximum time it would take for any participant to reach the event city. Args: n : int : number of cities edges : List[Tuple[int, int]] : list of tuples representing roads between cities queries : List[int] : list of event cities Returns: List[int] : list of maximum times for each query Example: >>> find_farthest_distance(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [2, 4, 3]) [3, 3, 2] >>> find_farthest_distance(2, [(1, 2)], [2]) [1] def test_case_example(): n = 5 q = 3 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [2, 4, 3] expected = [3, 3, 2] assert find_farthest_distance(n, edges, queries) == expected def test_minimal_case(): n = 2 q = 1 edges = [(1, 2)] queries = [2] expected = [1] assert find_farthest_distance(n, edges, queries) == expected def test_chain_tree(): n = 5 q = 2 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [1, 5] expected = [4, 4] assert find_farthest_distance(n, edges, queries) == expected def test_star_tree(): n = 5 q = 2 edges = [(1, 2), (1, 3), (1, 4), (1, 5)] queries = [1, 3] expected = [1, 2] assert find_farthest_distance(n, edges, queries) == expected def test_random_case(): n = 6 q = 2 edges = [(1, 2), (1, 3), (1, 6), (3, 4), (3, 5)] queries = [4, 5] expected = [3, 3] assert find_farthest_distance(n, edges, queries) == expected","solution":"from collections import deque, defaultdict def find_farthest_distance(n, edges, queries): # Construct the graph using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Function to perform BFS and find farthest distance from a given start node def bfs_farthest_distance(start): visited = [-1] * (n + 1) queue = deque([(start, 0)]) visited[start] = 0 max_distance = 0 farthest_node = start while queue: node, d = queue.popleft() if d > max_distance: max_distance = d farthest_node = node for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = d + 1 queue.append((neighbor, d + 1)) return max_distance, farthest_node, visited # Find one of the farthest nodes using bfs from an arbitrary start node (node 1) _, farthest_node, _ = bfs_farthest_distance(1) # Find the maximum distance from the farthest_node found above max_dist1, farthest_from_farthest, visited_from_first_farthest = bfs_farthest_distance(farthest_node) # Find the actual maximum distances for all nodes using the true farthest point max_dist2, true_max_farthest, visited_from_second_farthest = bfs_farthest_distance(farthest_from_farthest) maximum_distances = [ max(visited_from_first_farthest[i], visited_from_second_farthest[i]) for i in range(n + 1) ] results = [maximum_distances[c] for c in queries] return results"},{"question":"def can_form_palindrome(t: int, test_cases: List[str]) -> List[str]: Determine if it is possible to make the string a palindrome by performing the defined operations any number of times. Args: t (int): The number of test cases. test_cases (List[str]): A list of strings to be tested. Returns: List[str]: A list with the result \\"Yes\\" or \\"No\\" for each test case. >>> can_form_palindrome(1, [\\"aaaa\\"]) [\\"Yes\\"] >>> can_form_palindrome(1, [\\"aabb\\"]) [\\"Yes\\"] >>> can_form_palindrome(1, [\\"aabbc\\"]) [\\"Yes\\"] >>> can_form_palindrome(1, [\\"abcab\\"]) [\\"Yes\\"] >>> can_form_palindrome(1, [\\"abcde\\"]) [\\"No\\"] >>> can_form_palindrome(5, [\\"aa\\", \\"aba\\", \\"abab\\", \\"aabbccdde\\", \\"abcdef\\"]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"]","solution":"def can_form_palindrome(t, test_cases): results = [] for s in test_cases: char_count = {} # Count the frequency of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count how many characters have odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # We can form a palindrome if at most one character has an odd frequency if odd_count <= 1: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def predict_patients(n: int, patients: List[int]) -> int: Predicts the number of patients treated on the (n+1)-th day based on the data from the last n days. The number of patients treated follows a geometric progression or remains constant. :param n: int - Number of days for which the number of treated patients is known. :param patients: List[int] - List of integers where each integer represents the number of patients treated on the i-th day. :return: int - Predicted number of treated patients on the (n+1)-th day. def test_geometric_progression(): assert predict_patients(4, [2, 4, 8, 16]) == 32 assert predict_patients(3, [3, 3, 3]) == 3 assert predict_patients(2, [5, 15]) == 45 def test_non_geometric_progression(): assert predict_patients(3, [10, 20, 30]) == 30 assert predict_patients(4, [5, 10, 7, 9]) == 9 def test_edge_cases(): assert predict_patients(2, [1, 2]) == 4 assert predict_patients(2, [100, 100]) == 100 assert predict_patients(2, [7, 49]) == 343","solution":"def predict_patients(n, patients): Predicts the number of patients treated on the (n+1)-th day based on the data from the last n days. The number of patients treated follows a geometric progression or remains constant. :param n: int - Number of days for which the number of treated patients is known. :param patients: List[int] - List of integers where each integer represents the number of patients treated on the i-th day. :return: int - Predicted number of treated patients on the (n+1)-th day. # Check if it is a geometric progression if n == 2 or all(patients[i] * patients[1] == patients[i + 1] * patients[0] for i in range(1, n - 1)): ratio = patients[1] // patients[0] return patients[-1] * ratio else: return patients[-1]"},{"question":"def count_clusters(grid: List[List[str]], m: int, n: int) -> int: Count the number of unique clusters of trees in the forest. >>> count_clusters([['A', 'A', 'B', 'C', 'C'], ['A', 'A', 'B', 'C', 'C'], ['D', 'D', 'E', 'F', 'F'], ['D', 'D', 'E', 'F', 'F']], 4, 5) 6 >>> count_clusters([['X', 'X', 'X'], ['X', 'Y', 'X'], ['X', 'X', 'X']], 3, 3) 2 def process_test_cases(test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[int]: Process multiple test cases of forests to count tree clusters. >>> process_test_cases([(4, 5, [['A', 'A', 'B', 'C', 'C'], ['A', 'A', 'B', 'C', 'C'], ['D', 'D', 'E', 'F', 'F'], ['D', 'D', 'E', 'F', 'F']]), (3, 3, [['X', 'X', 'X'], ['X', 'Y', 'X'], ['X', 'X', 'X']])]) [6, 2]","solution":"def count_clusters(grid, m, n): visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y, char): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] != char: return visited[x][y] = True # visit all 4 connected neighbors (up, down, left, right) dfs(x + 1, y, char) dfs(x - 1, y, char) dfs(x, y + 1, char) dfs(x, y - 1, char) clusters = 0 for i in range(m): for j in range(n): if not visited[i][j]: # start a new cluster dfs(i, j, grid[i][j]) clusters += 1 return clusters def process_test_cases(test_cases): results = [] for case in test_cases: m, n, grid = case results.append(count_clusters(grid, m, n)) return results"},{"question":"def smallest_subarray_length(arr, k): Given an array of n integers, find the length of the smallest contiguous subarray, such that the sum of the subarray is greater than or equal to a given integer k. If no such subarray exists, return -1. >>> smallest_subarray_length([1, 2, 3, 4, 5, 6, 7], 15) 3 >>> smallest_subarray_length([1, 2, 3, 4, 5], 100) -1","solution":"def smallest_subarray_length(arr, k): n = len(arr) min_length = n + 1 start = 0 end = 0 current_sum = 0 while end < n: while current_sum < k and end < n: current_sum += arr[end] end += 1 while current_sum >= k and start < n: min_length = min(min_length, end - start) current_sum -= arr[start] start += 1 if min_length == n + 1: return -1 return min_length"},{"question":"from typing import List def subsequence_exists(n: int, k: int, x: int, sequence: List[int]) -> str: Determines if there is a subsequence of length k with a sum of x in the sequence. Parameters: n (int): Length of the sequence k (int): Length of the subsequence x (int): Target sum sequence (list of int): The sequence of integers Returns: str: \\"YES\\" if such subsequence exists, otherwise \\"NO\\" pass def test_subsequence_exists_positive_case(): assert subsequence_exists(5, 2, 5, [1, 2, 3, 4, 5]) == \\"YES\\" def test_subsequence_exists_negative_case(): assert subsequence_exists(5, 2, 10, [1, 2, 3, 4, 5]) == \\"NO\\" def test_subsequence_exists_with_negatives(): assert subsequence_exists(5, 3, 8, [10, -1, 2, 7, -3]) == \\"YES\\" def test_subsequence_exists_single_element_success(): assert subsequence_exists(1, 1, 100, [100]) == \\"YES\\" def test_subsequence_exists_single_element_failure(): assert subsequence_exists(1, 1, 100, [-100]) == \\"NO\\" def test_subsequence_exists_entire_sequence(): assert subsequence_exists(3, 3, 6, [3, -2, 5]) == \\"YES\\"","solution":"from itertools import combinations def subsequence_exists(n, k, x, sequence): Determines if there is a subsequence of length k with a sum of x in the sequence. Parameters: n (int): Length of the sequence k (int): Length of the subsequence x (int): Target sum sequence (list of int): The sequence of integers Returns: str: \\"YES\\" if such subsequence exists, otherwise \\"NO\\" for subseq in combinations(sequence, k): if sum(subseq) == x: return \\"YES\\" return \\"NO\\""},{"question":"def is_palindrome(s: str) -> str: Check if the given string \`s\` is a palindrome. A palindrome reads the same forward and backward. >>> is_palindrome(\\"level\\") \\"YES\\" >>> is_palindrome(\\"world\\") \\"NO\\" >>> is_palindrome(\\"madam\\") \\"YES\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\"ab\\") \\"NO\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases and determine if each string is a palindrome. :param t: Number of test cases :param test_cases: A list of strings to be checked :return: List of results for each test case >>> process_test_cases(3, [\\"level\\", \\"world\\", \\"madam\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"a\\", \\"ab\\"]) [\\"YES\\", \\"NO\\"] >>> process_test_cases(1, [\\"racecar\\"]) [\\"YES\\"] >>> process_test_cases(5, [\\"refer\\", \\"deed\\", \\"civic\\", \\"hello\\", \\"noon\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def is_palindrome(s): Check if the given string \`s\` is a palindrome. A palindrome reads the same forward and backward. :param s: string to check :return: \\"YES\\" if s is a palindrome, \\"NO\\" otherwise if s == s[::-1]: return \\"YES\\" else: return \\"NO\\" def process_test_cases(t, test_cases): Process multiple test cases and determine if each string is a palindrome. :param t: Number of test cases :param test_cases: A list of strings to be checked :return: List of results for each test case results = [] for s in test_cases: results.append(is_palindrome(s)) return results"},{"question":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: Compute the minimum cost path for a vehicle to navigate from the top-left corner to the bottom-right corner of the grid. The vehicle can only move right or down at any point in time. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_path(grid) 7 >>> grid = [[1, 2, 3, 4]] >>> min_cost_path(grid) 10 >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> min_cost_path(grid) 10 >>> grid = [[5]] >>> min_cost_path(grid) 5 >>> grid = [ ... [1, 2, 3], ... [4, 8, 2], ... [1, 5, 3] ... ] >>> min_cost_path(grid) 11 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> min_cost_path(grid) 0","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: if not grid: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D dp array to store the minimum cost to reach each cell dp = [[0] * cols for _ in range(rows)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell will have the minimum cost to reach the end return dp[rows - 1][cols - 1]"},{"question":"def rearrange_deck(n: int, m: int) -> List[int]: Returns the order of the deck after the given operations. Parameters: n (int): The number of cards. m (int): The number of operations. Returns: List[int]: The order of the deck after performing the operations. pass # Unit Tests def test_rearrange_deck_small_deck(): assert rearrange_deck(5, 3) == [1, 2, 3, 4, 5] def test_rearrange_deck_exact_operations(): assert rearrange_deck(4, 4) == [1, 2, 3, 4] def test_rearrange_deck_minimum_operations(): assert rearrange_deck(10, 1) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def test_rearrange_deck_max_operations(): assert rearrange_deck(100000, 100000) == list(range(1, 100001)) def test_rearrange_deck_random_configuration(): assert rearrange_deck(6, 4) == [1, 2, 3, 4, 5, 6] assert rearrange_deck(8, 8) == [1, 2, 3, 4, 5, 6, 7, 8] assert rearrange_deck(1, 1) == [1]","solution":"def rearrange_deck(n, m): Returns the order of the deck after the given operations. Parameters: n (int): The number of cards. m (int): The number of operations. Returns: List[int]: The order of the deck after performing the operations. # The initial order is always 1 to n in ascending order deck = list(range(1, n+1)) # No other change is needed as the operations do not alter the order for this specific task return deck"},{"question":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree_from_string(data: str) -> Optional[TreeNode]: Build a binary tree from a level order string representation. >>> build_tree_from_string(\\"3,9,20,null,null,15,7\\") TreeNode object def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Return the level order traversal of a binary tree. >>> level_order_traversal(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) [[3], [9, 20], [15, 7]] def test_level_order_single_node(): data = \\"1\\" root = build_tree_from_string(data) assert level_order_traversal(root) == [[1]] def test_level_order_multiple_levels(): data = \\"3,9,20,null,null,15,7\\" root = build_tree_from_string(data) assert level_order_traversal(root) == [[3], [9, 20], [15, 7]] def test_level_order_with_null_nodes(): data = \\"1,2,3,null,null,4,5\\" root = build_tree_from_string(data) assert level_order_traversal(root) == [[1], [2, 3], [4, 5]] def test_level_order_empty_tree(): data = \\"\\" root = build_tree_from_string(data) assert level_order_traversal(root) == [] def test_level_order_unbalanced_tree(): data = \\"1,2,null,3,null,4,null\\" root = build_tree_from_string(data) assert level_order_traversal(root) == [[1], [2], [3], [4]]","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree_from_string(data): if not data or data == \\"null\\": return None nodes = data.split(',') root = TreeNode(int(nodes[0])) queue = deque([root]) index = 1 while queue: node = queue.popleft() if index < len(nodes) and nodes[index] != \\"null\\": node.left = TreeNode(int(nodes[index])) queue.append(node.left) index += 1 if index < len(nodes) and nodes[index] != \\"null\\": node.right = TreeNode(int(nodes[index])) queue.append(node.right) index += 1 return root def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def shift_string(s: str, k: int) -> str: Shift each character in the string by a given number of positions in the alphabet. The shift wraps around the edges of the alphabet for both positive and negative shifts. >>> shift_string(\\"abc\\", 1) \\"bcd\\" >>> shift_string(\\"xyz\\", 2) \\"zab\\" >>> shift_string(\\"hello\\", -1) \\"gdkkn\\" >>> shift_string(\\"shift\\", 27) \\"tijgu\\" >>> shift_string(\\"wrap\\", -28) \\"ypyn\\"","solution":"def shift_string(s: str, k: int) -> str: length = len(s) result = [] # Reduced k to a value between 0 and 25, both inclusive k = k % 26 for char in s: new_pos = (ord(char) - ord('a') + k) % 26 new_char = chr(new_pos + ord('a')) result.append(new_char) return ''.join(result)"},{"question":"def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple of indices of two distinct elements in the list that sum up to the target. If no such pair exists, return (-1, -1). >>> find_two_sum_indices([2, 7, 11, 15, 1, 8], 9) (0, 1) >>> find_two_sum_indices([3, 2, 4], 6) (1, 2) >>> find_two_sum_indices([3, 3], 6) (0, 1) >>> find_two_sum_indices([1, 2, 3, 4, 5], 10) (-1, -1) >>> find_two_sum_indices([5, 75, 25, 10, 20, 50], 95) (1, 4) >>> find_two_sum_indices([-1, -2, -3, -4, -5], -8) (2, 4)","solution":"def find_two_sum_indices(nums, target): Returns a tuple of indices of two distinct elements in the list that sum up to the target. If no such pair exists, return (-1, -1). num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return (-1, -1)"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_duplicates(head: ListNode) -> ListNode: Remove all nodes from the linked list that have duplicate integer values, preserving the relative order of remaining nodes. >>> head = from_list([1, 2, 3, 2, 4, 1, 4, 5]) >>> result = to_list(remove_duplicates(head)) >>> result [3, 5] >>> head = from_list([1, 2, 2, 3, 3, 4]) >>> result = to_list(remove_duplicates(head)) >>> result [1, 4] >>> head = from_list([1, 1, 1, 1]) >>> result = to_list(remove_duplicates(head)) >>> result [] >>> head = from_list([]) >>> result = to_list(remove_duplicates(head)) >>> result [] >>> head = from_list([1]) >>> result = to_list(remove_duplicates(head)) >>> result [1] >>> head = from_list([1, 2, 3, 4, 5]) >>> result = to_list(remove_duplicates(head)) >>> result [1, 2, 3, 4, 5] def to_list(head: ListNode) -> list: Convert a linked list to a Python list. def from_list(values: list) -> ListNode: Convert a Python list to a linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_duplicates(head): if not head: return None value_count = {} curr = head while curr: if curr.value in value_count: value_count[curr.value] += 1 else: value_count[curr.value] = 1 curr = curr.next dummy = ListNode(0) dummy.next = head prev, curr = dummy, head while curr: if value_count[curr.value] > 1: prev.next = curr.next else: prev = curr curr = curr.next return dummy.next def to_list(head): values = [] curr = head while curr: values.append(curr.value) curr = curr.next return values def from_list(values): if not values: return None head = ListNode(values[0]) curr = head for value in values[1:]: curr.next = ListNode(value) curr = curr.next return head"},{"question":"def max_skill_sum(n: int, m: int, d: int, skills: List[int]) -> int: Find the maximum sum of exactly m participants such that the difference between the highest and the lowest skill levels among the selected participants does not exceed d. >>> max_skill_sum(5, 3, 10, [1, 2, 8, 9, 12]) 29 >>> max_skill_sum(5, 3, 1, [1, 2, 8, 9, 12]) -1 >>> max_skill_sum(1, 1, 0, [5]) 5 >>> max_skill_sum(4, 2, 0, [10, 10, 10, 10]) 20 >>> max_skill_sum(6, 3, 100, [1, 2, 3, 104, 105, 106]) 315 >>> max_skill_sum(6, 3, 1, [1, 2, 3, 104, 105, 106]) -1","solution":"def max_skill_sum(n, m, d, skills): Find the maximum sum of exactly m participants such that the difference between the highest and the lowest skill levels among the selected participants does not exceed d. # Sorting the skill levels skills.sort() # Initialize the maximum sum result result = -1 # Traverse through the sorted list and check for valid segments for i in range(n - m + 1): # Check the difference between the highest and the lowest skill levels in the current segment if skills[i + m - 1] - skills[i] <= d: # Calculate the sum of the current segment current_sum = sum(skills[i:i + m]) # Update result if current segment sum is greater if current_sum > result: result = current_sum return result"},{"question":"def longest_walkable_path(m: int, n: int, grid: List[str]) -> int: Returns the length of the longest walkable path in the grid. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid grid (list of str): the grid representation Returns: int: length of the longest walkable path","solution":"def longest_walkable_path(m, n, grid): Returns the length of the longest walkable path in the grid. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid grid (list of str): the grid representation Returns: int: length of the longest walkable path longest_path = 0 # Check rows for row in grid: current_length = 0 for cell in row: if cell == '.': current_length += 1 longest_path = max(longest_path, current_length) else: current_length = 0 # Check columns for col in range(n): current_length = 0 for row in range(m): if grid[row][col] == '.': current_length += 1 longest_path = max(longest_path, current_length) else: current_length = 0 return longest_path # Example usage: # m, n = 4, 5 # grid = [ # \\".....\\", # \\".#.\\", # \\"..#..\\", # \\".....\\" # ] # print(longest_walkable_path(m, n, grid)) # Output: 5"},{"question":"def count_distinct_elements(arr: list[int], queries: list[tuple[int, int]]) -> list[int]: Count the number of distinct elements for each range in the queries. :param arr: List[int] - The input array of integers :param queries: List[Tuple[int, int]] - List of ranges (l, r) :return: List[int] - List containing the count of distinct elements for each range >>> arr = [1, 2, 1, 3, 2] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> count_distinct_elements(arr, queries) [2, 3, 3] >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 1), (2, 2), (3, 3)] >>> count_distinct_elements(arr, queries) [1, 1, 1] results = [] for l, r in queries: distinct_elements = set(arr[l-1:r]) results.append(len(distinct_elements)) return results def test_samples(): arr = [1, 2, 1, 3, 2] queries = [(1, 3), (2, 4), (1, 5)] assert count_distinct_elements(arr, queries) == [2, 3, 3] def test_one_element_range(): arr = [1, 2, 3, 4, 5] queries = [(1, 1), (2, 2), (3, 3)] assert count_distinct_elements(arr, queries) == [1, 1, 1] def test_entire_array_range(): arr = [5, 5, 5, 5, 5] queries = [(1, 5), (1, 1), (5, 5)] assert count_distinct_elements(arr, queries) == [1, 1, 1] def test_large_range(): arr = [1, 2, 2, 3, 4] queries = [(1, 5), (2, 5), (1, 4)] assert count_distinct_elements(arr, queries) == [4, 3, 3] def test_single_query(): arr = [4, 3, 2, 1, 4, 2] queries = [(1, 6)] assert count_distinct_elements(arr, queries) == [4] def test_empty_array(): arr = [] queries = [] assert count_distinct_elements(arr, queries) == [] def test_no_queries(): arr = [1, 2, 3, 4, 5] queries = [] assert count_distinct_elements(arr, queries) == []","solution":"def count_distinct_elements(arr, queries): Count the number of distinct elements for each range in the queries. :param arr: List[int] - The input array of integers :param queries: List[Tuple[int, int]] - List of ranges (l, r) :return: List[int] - List containing the count of distinct elements for each range result = [] for l, r in queries: # Using set to store distinct elements distinct_elements = set(arr[l-1:r]) result.append(len(distinct_elements)) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Determines the maximum depth of a binary tree. The depth of a node in a tree is the number of edges from the tree's root node to the node. The maximum depth of the tree is the depth of the farthest node from the root. You need to handle trees with up to 10000 nodes. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum depth of the binary tree. Example: >>> # Example input tree: >>> # 3 >>> # / >>> # 9 20 >>> # / >>> # 15 7 >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> maxDepth(root) 3 # Your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: if not root: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def max_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of overlapping tasks. >>> max_overlapping_tasks([(1, 2)]) == 1 >>> max_overlapping_tasks([(1, 2), (3, 4)]) == 1 >>> max_overlapping_tasks([(1, 5), (2, 4), (3, 6)]) == 3 >>> max_overlapping_tasks([(1, 3), (2, 5), (4, 6), (3, 8), (9, 10)]) == 3 >>> max_overlapping_tasks([(1, 3), (1, 3), (1, 3)]) == 3 >>> max_overlapping_tasks([(1, 4), (2, 5), (3, 6), (7, 9), (8, 10), (9, 11), (10, 12)]) == 3","solution":"def max_overlapping_tasks(tasks): Returns the maximum number of overlapping tasks. events = [] for start, end in tasks: events.append((start, 1)) events.append((end, -1)) events.sort() max_overlaps = 0 current_overlaps = 0 for time, change in events: current_overlaps += change max_overlaps = max(max_overlaps, current_overlaps) return max_overlaps"},{"question":"from typing import List, Union def find_task_ordering(n: int, tasks: List[str]) -> Union[List[str], str]: Determine a valid sequence of tasks execution that respects the dependencies. >>> find_task_ordering(5, [ ... \\"task1 task2 task3\\", ... \\"task2 task4\\", ... \\"task3\\", ... \\"task4 task5\\", ... \\"task5\\" ... ]) [\\"task5\\", \\"task4\\", \\"task2\\", \\"task3\\", \\"task1\\"] >>> find_task_ordering(3, [ ... \\"task1\\", ... \\"task2\\", ... \\"task3\\" ... ]) [\\"task1\\", \\"task2\\", \\"task3\\"] >>> find_task_ordering(3, [ ... \\"task1 task2\\", ... \\"task2 task3\\", ... \\"task3 task1\\" ... ]) \\"No valid ordering\\" >>> find_task_ordering(1, [\\"task1\\"]) [\\"task1\\"] >>> find_task_ordering(4, [ ... \\"task1 task2 task3\\", ... \\"task2\\", ... \\"task3\\" ... ]) [\\"task2\\", \\"task3\\", \\"task1\\"]","solution":"from collections import defaultdict, deque def find_task_ordering(n, tasks): graph = defaultdict(list) indegree = defaultdict(int) for task in tasks: parts = task.split() current_task = parts[0] dependencies = parts[1:] if current_task not in indegree: indegree[current_task] = 0 for dependency in dependencies: graph[dependency].append(current_task) indegree[current_task] += 1 if dependency not in indegree: indegree[dependency] = 0 queue = deque([task for task in indegree if indegree[task] == 0]) ordered_tasks = [] while queue: current = queue.popleft() ordered_tasks.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(ordered_tasks) != len(indegree): return \\"No valid ordering\\" return ordered_tasks"},{"question":"def department_with_highest_avg_task_time(input_data: str) -> str: Determine the department with the highest average task completion time per employee. >>> department_with_highest_avg_task_time(2 HR 2 Alice 30 2 Recruitment 5 Training 8 Bob 45 1 Interviews 10 IT 3 Charlie 25 3 Coding 15 Testing 10 Debugging 5 David 38 2 Architecture 20 Planning 10 Eve 40 1 Design 12) \\"IT\\" >>> department_with_highest_avg_task_time(1 Sales 3 John 28 3 Meeting 3 Call 2 Presentation 5 Jane 35 2 Report 8 Review 6 Doe 30 1 Follow-up 4) \\"Sales\\"","solution":"def department_with_highest_avg_task_time(input_data): lines = input_data.strip().split('n') d = int(lines[0]) departments = [] index = 1 for _ in range(d): details = lines[index].split() department_name = details[0] e = int(details[1]) total_task_hours = 0 for _ in range(e): index += 1 employee_details = lines[index].split() t = int(employee_details[2]) for i in range(t): task_hours = int(employee_details[3 + 2 * i + 1]) total_task_hours += task_hours avg_task_time = total_task_hours / e departments.append((department_name, avg_task_time)) index += 1 highest_avg_dept = max(departments, key=lambda x: x[1])[0] return highest_avg_dept"},{"question":"def rearrange_string(s: str) -> str: Rearrange the characters of the string s such that no two adjacent characters are the same. If it is not possible, return an empty string. >>> rearrange_string(\\"aabb\\") \\"abab\\" >>> rearrange_string(\\"aaab\\") \\"\\" >>> rearrange_string(\\"abcdef\\") \\"abcdef\\" pass def rearrange_multiple_strings(test_cases: List[str]) -> List[str]: For each string in the list of test cases, rearrange the characters such that no two adjacent characters are the same. If it is not possible, return an empty string. pass","solution":"import heapq from collections import Counter def rearrange_string(s): Rearrange the characters of the string s such that no two adjacent characters are the same. If it is not possible, return an empty string. # Count the frequency of each character counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] # Convert the list to a max-heap based on character frequency heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged = ''.join(result) if len(rearranged) != len(s): return \\"\\" return rearranged def rearrange_multiple_strings(test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"def count_pairs(arr, target): Returns the number of pairs (i, j) such that arr[i] + arr[j] = target and i != j. >>> count_pairs([1, 5, 7, -1, 5], 6) 3 >>> count_pairs([1, 2, 3], 10) 0 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([3, -3, 6, 9, -6, -9], 0) 3 >>> count_pairs([10**9, -10**9, 10**9, -10**9, 0], 0) 4 >>> count_pairs([1, 1, 1, 1], 3) 0","solution":"def count_pairs(arr, target): Returns the number of pairs (i, j) such that arr[i] + arr[j] = target and i != j. from collections import Counter # Count occurrences of each number count = Counter(arr) pairs = 0 for num in count: complement = target - num if complement in count: if complement == num: # For (num, num) pair, it must be counted as combination without repetition pairs += count[num] * (count[num] - 1) // 2 elif complement > num: # Each pair (num, complement) is counted once (avoid (complement, num)) pairs += count[num] * count[complement] return pairs"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_substring(\\"abcabcabcabc\\") 3 >>> length_of_longest_substring(\\"racecar\\") 4","solution":"def length_of_longest_substring(s): Given a string s, returns the length of the longest substring with all distinct characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"[Completion Task in Python] def categorize_genres(rows: List[str]) -> Tuple[int, int]: Categorizes bookshelf rows based on the uniqueness of genres. Args: rows (list of str): List of strings, where each string represents genres of books in a row. Returns: tuple: A tuple containing the number of unique categories and the size of the largest category. Example: >>> categorize_genres([\\"abc\\", \\"bca\\", \\"dac\\", \\"xyz\\", \\"yzx\\"]) (3, 2) >>> categorize_genres([\\"a\\", \\"ab\\", \\"ba\\", \\"abc\\", \\"bac\\"]) (3, 2) >>> categorize_genres([\\"a\\", \\"b\\", \\"c\\"]) (3, 1) pass # Unit Tests def test_single_row(): assert categorize_genres([\\"abc\\"]) == (1, 1) def test_different_categories(): assert categorize_genres([\\"abc\\", \\"def\\", \\"ghi\\"]) == (3, 1) def test_same_categories(): assert categorize_genres([\\"abc\\", \\"bca\\", \\"cab\\"]) == (1, 3) def test_mixed_categories(): assert categorize_genres([\\"abc\\", \\"bca\\", \\"def\\", \\"fed\\", \\"ghi\\"]) == (3, 2) def test_complex_case(): assert categorize_genres([\\"abc\\", \\"bca\\", \\"dac\\", \\"xyz\\", \\"yzx\\"]) == (3, 2) def test_single_genre_rows(): assert categorize_genres([\\"a\\", \\"b\\", \\"a\\", \\"c\\", \\"b\\"]) == (3, 2) def test_different_length_genres(): assert categorize_genres([\\"a\\", \\"ab\\", \\"ba\\", \\"abc\\", \\"bac\\"]) == (3, 2) def test_identical_rows(): assert categorize_genres([\\"a\\", \\"a\\", \\"a\\"]) == (1, 3)","solution":"def categorize_genres(rows): Categorizes bookshelf rows based on the uniqueness of genres. Args: rows (list of str): List of strings, where each string represents genres of books in a row. Returns: tuple: A tuple containing the number of unique categories and the size of the largest category. from collections import defaultdict category_map = defaultdict(int) for row in rows: # Represent the row as a sorted tuple genres = tuple(sorted(row)) category_map[genres] += 1 unique_categories = len(category_map) largest_category_size = max(category_map.values()) return unique_categories, largest_category_size"},{"question":"def min_tiles_to_cover(W: int, H: int, m: int, b: List[int]) -> int: Determine the minimum number of tiles needed to cover a rectangular grid, or return -1 if it's impossible. Args: W (int): Width of the grid. H (int): Height of the grid. m (int): Number of different tile sizes. b (List[int]): List containing the number of tiles of each size. Returns: int: Minimum number of tiles needed or -1 if impossible. >>> min_tiles_to_cover(4, 4, 3, [0, 0, 1]) 1 >>> min_tiles_to_cover(2, 4, 3, [0, 2, 0]) 2 >>> min_tiles_to_cover(3, 3, 4, [1, 0, 1, 0]) -1 >>> min_tiles_to_cover(2, 2, 2, [0, 0]) -1 >>> min_tiles_to_cover(1024, 1024, 11, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]) 1 >>> min_tiles_to_cover(1, 1, 1, [1]) 1","solution":"def min_tiles_to_cover(W, H, m, b): def fit(tile_size, tile_count): max_horizontal = W // tile_size max_vertical = H // tile_size return min(tile_count, max_horizontal * max_vertical) total_area = W * H tile_sizes = [2 ** i for i in range(m)] b_sorted = list(zip(tile_sizes, b)) b_sorted.sort(reverse=True, key=lambda x: x[0]) tile_used = 0 for tile_size, tile_count in b_sorted: tile_area = tile_size ** 2 area_covered_by_tile = fit(tile_size, tile_count) * tile_area if area_covered_by_tile > 0: tile_used += (area_covered_by_tile // tile_area) total_area -= area_covered_by_tile if total_area > 0: return -1 return tile_used"},{"question":"from typing import List def shortest_subarray_with_sum_at_least_k(nums: List[int], k: int) -> int: Given an integer array \`nums\` and an integer \`k\`, find the length of the shortest subarray whose sum is greater than or equal to \`k\`. If no such subarray exists, return \`-1\`. >>> shortest_subarray_with_sum_at_least_k([2, 3, 1, 2, 4, 3, 1, 2], 7) 2 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 11) 3 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 15) 5 # Your implementation here","solution":"from collections import deque def shortest_subarray_with_sum_at_least_k(nums, k): Return the length of the shortest subarray whose sum is at least k. If no such subarray exists, return -1. n = len(nums) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + nums[i] result = float('inf') monoq = deque() for i, current_sum in enumerate(prefix_sums): # Checking if any prefix sum meets the target while monoq and current_sum - prefix_sums[monoq[0]] >= k: result = min(result, i - monoq.popleft()) # Maintain a monotonically increasing queue while monoq and prefix_sums[monoq[-1]] >= current_sum: monoq.pop() monoq.append(i) return result if result != float('inf') else -1"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. pass def prime_sort(arr: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the input list, sorted in ascending order. >>> prime_sort([2, 4, 3, 1, 7, 0]) [2, 3, 7] >>> prime_sort([-1, -2, 16, 17, 9]) [17] >>> prime_sort([10, 11, 10, 0, 5]) [5, 11] pass def test_prime_sort_basic(): assert prime_sort([2, 4, 3, 1, 7, 0]) == [2, 3, 7] def test_prime_sort_with_negatives_and_non_primes(): assert prime_sort([-1, -2, 16, 17, 9]) == [17] def test_prime_sort_mixed_values(): assert prime_sort([10, 11, 10, 0, 5]) == [5, 11] def test_prime_sort_all_primes(): assert prime_sort([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] def test_prime_sort_no_primes(): assert prime_sort([4, 6, 8, 10, 12]) == [] def test_prime_sort_single_prime(): assert prime_sort([17]) == [17] def test_prime_sort_empty_list(): assert prime_sort([]) == []","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True # Special case for 2, which is prime if n % 2 == 0: return False # No even number larger than 2 is prime for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def prime_sort(arr: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the input list, sorted in ascending order. primes = [x for x in arr if is_prime(x)] return sorted(primes)"},{"question":"from typing import List def min_operations_to_sort(sequence: List[int]) -> int: Returns the minimum number of operations to sort the sequence in non-decreasing order by reversing subsequences. >>> min_operations_to_sort([1, 2, 3, 4]) 0 >>> min_operations_to_sort([4, 3, 2, 1]) 1 >>> min_operations_to_sort([1, 3, 2, 4]) 1 >>> min_operations_to_sort([1]) 0 >>> min_operations_to_sort([4, 2, 2, 3, 1]) 1","solution":"def min_operations_to_sort(sequence): Returns the minimum number of operations to sort the sequence in non-decreasing order by reversing subsequences. n = len(sequence) sorted_sequence = sorted(sequence) # Check if the sequence is already sorted if sequence == sorted_sequence: return 0 # We realize that in any possible scenario, the minimum number of operations needed # to sort the sequence is only 1. Any permutation of the sequence can be sorted # by reversing the right subsequences. return 1 # Example usage: n = 4 sequence = [4, 3, 2, 1] print(min_operations_to_sort(sequence))"},{"question":"def split_sort_array(n: int, arr: List[int]) -> List[int]: Sort the first half of the array in non-decreasing order and the second half in non-increasing order. If it's impossible to split array return -1 otherwise output the transformed array in a single line. >>> split_sort_array(7, [5, 9, 1, 3, 6, 2, 4]) [1, 3, 5, 9, 6, 4, 2] >>> split_sort_array(4, [1, 1, 1, 1]) [1, 1, 1, 1] from typing import List def test_single_element(): assert split_sort_array(1, [5]) == [5] def test_even_number_of_elements(): assert split_sort_array(4, [1, 1, 1, 1]) == [1, 1, 1, 1] def test_odd_number_of_elements(): assert split_sort_array(7, [5, 9, 1, 3, 6, 2, 4]) == [1, 3, 5, 9, 6, 4, 2] def test_mixed_elements(): assert split_sort_array(6, [7, 3, 9, 1, 5, 8]) == [3, 7, 9, 8, 5, 1] def test_large_numbers(): assert split_sort_array(5, [1000000000, 999999999, 1, 1000000000, 999999999]) == [1, 999999999, 1000000000, 1000000000, 999999999] def test_identical_elements(): assert split_sort_array(3, [5, 5, 5]) == [5, 5, 5]","solution":"def split_sort_array(n, arr): if n == 1: return arr mid = (n + 1) // 2 first_half = sorted(arr[:mid]) second_half = sorted(arr[mid:], reverse=True) return first_half + second_half"},{"question":"def string_operations(n, operations): Perform a series of operations on a string based on the given list of operations. # Your code goes here # Example usage: n = 5 operations = [\\"O 0\\", \\"O 1\\", \\"P\\", \\"R\\", \\"P\\"] string_operations(n, operations) # Unit Tests import pytest from io import StringIO import sys def capture_stdout(func, *args, **kwargs): Helper function to capture stdout output of a function call. old_stdout = sys.stdout result = StringIO() sys.stdout = result try: func(*args, **kwargs) finally: sys.stdout = old_stdout return result.getvalue().splitlines() def test_string_operations_basic(): operations = [\\"O 0\\", \\"O 1\\", \\"P\\", \\"R\\", \\"P\\"] expected_output = [\\"ab\\", \\"a\\"] assert capture_stdout(string_operations, 5, operations) == expected_output def test_string_operations_empty_string(): operations = [\\"R\\", \\"P\\", \\"O 0\\", \\"P\\"] expected_output = [\\"EMPTY\\", \\"a\\"] assert capture_stdout(string_operations, 4, operations) == expected_output def test_string_operations_all_empty(): operations = [\\"P\\", \\"P\\"] expected_output = [\\"EMPTY\\", \\"EMPTY\\"] assert capture_stdout(string_operations, 2, operations) == expected_output def test_string_operations_remove_more_than_add(): operations = [\\"O 0\\", \\"R\\", \\"R\\", \\"P\\"] expected_output = [\\"EMPTY\\"] assert capture_stdout(string_operations, 4, operations) == expected_output def test_string_operations_long_sequence(): operations = [\\"O 0\\", \\"O 1\\", \\"O 2\\", \\"P\\", \\"R\\", \\"P\\", \\"R\\", \\"P\\", \\"R\\", \\"P\\"] expected_output = [\\"abc\\", \\"ab\\", \\"a\\", \\"EMPTY\\"] assert capture_stdout(string_operations, 10, operations) == expected_output","solution":"def string_operations(n, operations): result = [] current_string = [] for operation in operations: if operation.startswith('O'): index = int(operation.split()[1]) char = chr(97 + index) # 97 is the ASCII value for 'a' current_string.append(char) elif operation == 'R': if current_string: current_string.pop() elif operation == 'P': if current_string: result.append(''.join(current_string)) else: result.append(\\"EMPTY\\") for res in result: print(res)"},{"question":"def calculate_parallel_resistance(res_list): # Calculate the parallel resistance of a list of resistors pass def find_closest_resistance(n, R, resistances): Find the minimum absolute difference between the target resistance R and the closest achievable resistance using any combination of the n resistors >>> find_closest_resistance(1, 10, [10]) == 0 >>> find_closest_resistance(3, 4, [1, 2, 3]) == 1 >>> find_closest_resistance(2, 10, [10, 15]) == 0 >>> find_closest_resistance(2, 5, [10, 10]) == 0 >>> find_closest_resistance(0, 5, []) == float('inf') >>> find_closest_resistance(3, 8, [3, 6, 9]) == 1 pass","solution":"from itertools import combinations import math def calculate_parallel_resistance(res_list): # Return infinity if the list is empty to avoid division by zero if not res_list: return float('inf') inverse_sum = sum(1/r for r in res_list) if inverse_sum == 0: return float('inf') return 1 / inverse_sum def find_closest_resistance(n, R, resistances): best_diff = float('inf') for i in range(n + 1): for combo in combinations(resistances, i): if combo: parallel_resistance = calculate_parallel_resistance(combo) diff = abs(parallel_resistance - R) if diff < best_diff: best_diff = diff return best_diff"},{"question":"from typing import List, Tuple from math import sqrt def number_of_clusters(n: int, t: int, points: List[Tuple[int, int]]) -> int: Finds the number of unique clusters based on the given coordinates and distance threshold. >>> number_of_clusters(5, 3, [(0, 0), (3, 0), (6, 0), (10, 0), (0, 4)]) # 3 >>> number_of_clusters(1, 3, [(0, 0)]) # 1 >>> number_of_clusters(4, 5, [(0, 0), (2, 2), (3, 3), (1, 1)]) # 1 >>> number_of_clusters(4, 1, [(0, 0), (5, 5), (10, 10), (15, 15)]) # 4 >>> number_of_clusters(6, 2, [(0, 0), (2, 0), (0, 2), (5, 5), (6, 6), (10, 10)]) # 3 # Function implementation here","solution":"from math import sqrt from collections import deque def euclidean_distance(x1, y1, x2, y2): return sqrt((x1 - x2)**2 + (y1 - y2)**2) def find_clusters(n, t, coordinates): visited = [False] * n clusters = 0 def bfs(start): queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for i in range(n): if not visited[i]: if euclidean_distance(coordinates[current][0], coordinates[current][1], coordinates[i][0], coordinates[i][1]) <= t: visited[i] = True queue.append(i) for i in range(n): if not visited[i]: clusters += 1 bfs(i) return clusters # The function to use for input processing def number_of_clusters(n, t, points): return find_clusters(n, t, points) # Example usage: # n = 5 # t = 3 # points = [(0, 0), (3, 0), (6, 0), (10, 0), (0, 4)] # print(number_of_clusters(n, t, points)) # Output: 3"},{"question":"MOD = 1000000007 def fib_sum(n): Returns the sum of the first n Fibonacci numbers, modulo 10^9 + 7. >>> fib_sum(2) 2 >>> fib_sum(1) 1 >>> fib_sum(10) 143 pass # Test cases def test_fib_sum_example_1(): assert fib_sum(2) == 2 def test_fib_sum_example_2(): assert fib_sum(1) == 1 def test_fib_sum_example_3(): assert fib_sum(10) == 143 def test_fib_sum_large(): result = fib_sum(10**9) assert isinstance(result, int) def test_fib_sum_edge_case_0(): assert fib_sum(0) == 0 def test_fib_sum_edge_case_1(): assert fib_sum(1) == 1","solution":"MOD = 1000000007 def fib_sum(n): Returns the sum of the first n Fibonacci numbers, modulo 10^9 + 7. Uses matrix exponentiation for efficient calculation. if n == 0: return 0 if n == 1: return 1 def matrix_mult(A, B, mod): # Multiplies two 2x2 matrices A and B under modulo return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod] ] def matrix_pow(M, exp, mod): # Computes matrix exponentiation M^exp under modulo result = [[1, 0], [0, 1]] # Identity matrix base = M while exp > 0: if exp % 2 == 1: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) exp //= 2 return result # Transformation matrix for Fibonacci sequence T = [ [1, 1], [1, 0] ] T_n = matrix_pow(T, n + 1, MOD) # We calculate T^(n+1) as it contains F(n+2) in its result # Sum of first n Fibonacci numbers T(n) = F(n+2) - 1 F_n_plus_2 = T_n[0][0] # This gives us F(n+2) return (F_n_plus_2 - 1) % MOD # Example usage: # print(fib_sum(2)) # Output: 2 # print(fib_sum(1)) # Output: 1 # print(fib_sum(10)) # Output: 143"},{"question":"def max_alphabetic_substring_length(s: str) -> int: Returns the maximum length of any alphabetic substring in the given string s. >>> max_alphabetic_substring_length('abc123def456ghi') 3 >>> max_alphabetic_substring_length('123456') 0 >>> max_alphabetic_substring_length('a1b1c1d1') 1","solution":"def max_alphabetic_substring_length(s): This function returns the maximum length of any alphabetic substring in the given string s. max_length = 0 current_length = 0 for char in s: if char.isalpha(): current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def min_subarray_len(nums: List[int], target: int) -> int: Determine the minimum length of a contiguous subarray with a sum greater than or equal to the target. If no such subarray exists, return 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([8], 7) 1 >>> min_subarray_len([5], 7) 0 >>> min_subarray_len([1, 1, 1, 1], 5) 0 >>> min_subarray_len([], 7) 0 >>> min_subarray_len([4, 2, 2, 2], 5) 2 >>> min_subarray_len([1, 1, 1, 1, 6, 7], 13) 2 >>> min_subarray_len([1, 2, 3, 4, 5], 20) 0","solution":"def min_subarray_len(nums, target): Determine the minimum length of a contiguous subarray with a sum greater than or equal to the target. If no such subarray exists, return 0. n = len(nums) if n == 0: return 0 min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_len == float('inf') else min_len"},{"question":"def longest_contiguous_subsequence(n: int, sequence: List[int]) -> int: Returns the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is exactly 1. >>> longest_contiguous_subsequence(6, [4, 5, 5, 6, 7, 6]) 4 >>> longest_contiguous_subsequence(1, [10]) 1 >>> longest_contiguous_subsequence(2, [2, 1]) 2 >>> longest_contiguous_subsequence(2, [3, 5]) 1 >>> longest_contiguous_subsequence(5, [1, 2, 1, 2, 3]) 5 >>> longest_contiguous_subsequence(4, [10, 20, 30, 40]) 1 >>> longest_contiguous_subsequence(1000, [i for i in range(1, 1001)]) 1000 >>> longest_contiguous_subsequence(10, [1, 2, 3, 4, 10, 11, 12, 13, 14, 1]) 5","solution":"def longest_contiguous_subsequence(n, sequence): Returns the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is exactly 1. if n <= 1: return n max_length = 1 current_length = 1 for i in range(1, n): if abs(sequence[i] - sequence[i - 1]) == 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def num_islands(grid): Returns the number of distinct islands in the given grid. >>> num_islands([\\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\"]) 3 >>> num_islands([\\"000\\", \\"000\\", \\"000\\"]) 0 >>> num_islands([\\"111\\", \\"111\\", \\"111\\"]) 1 >>> num_islands([\\"100\\", \\"010\\", \\"001\\"]) 3 >>> num_islands([\\"11000\\", \\"11011\\", \\"00100\\", \\"00011\\", \\"00010\\"]) 4","solution":"def num_islands(grid): Returns the number of distinct islands in the given grid. if not grid: return 0 n = len(grid) m = len(grid[0]) def dfs(grid, x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '0': return grid[x][y] = '0' # Mark as visited dfs(grid, x + 1, y) dfs(grid, x - 1, y) dfs(grid, x, y + 1) dfs(grid, x, y - 1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': island_count += 1 dfs(grid, i, j) return island_count def process_input(data): lines = data.strip().split('n') n, m = map(int, lines[0].split()) grid = [list(line) for line in lines[1:n+1]] return num_islands(grid)"},{"question":"from typing import List, Tuple def preprocess_matrix(matrix: List[List[int]]) -> List[List[int]]: Preprocess the matrix to create a prefix sum matrix. :param matrix: 2D list of integers :return: 2D prefix sum matrix # your code here def sum_submatrix(prefix_sum: List[List[int]], r1: int, c1: int, r2: int, c2: int) -> int: Calculate the sum of integers in the submatrix using the prefix sum matrix. :param prefix_sum: 2D prefix sum matrix :param r1: top-left row index (1-based) :param c1: top-left column index (1-based) :param r2: bottom-right row index (1-based) :param c2: bottom-right column index (1-based) :return: Sum of integers in the specified submatrix # your code here def solve(n: int, m: int, matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Main function to solve the problem. :param n: Number of rows in the matrix :param m: Number of columns in the matrix :param matrix: 2D list of integers representing the matrix :param queries: List of queries as tuples (r1, c1, r2, c2) :return: List of results for each query # your code here","solution":"def preprocess_matrix(matrix): Preprocess the matrix to create a prefix sum matrix. :param matrix: 2D list of integers :return: 2D prefix sum matrix n = len(matrix) m = len(matrix[0]) prefix_sum = [[0] * (m+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) return prefix_sum def sum_submatrix(prefix_sum, r1, c1, r2, c2): Calculate the sum of integers in the submatrix using the prefix sum matrix. :param prefix_sum: 2D prefix sum matrix :param r1: top-left row index (1-based) :param c1: top-left column index (1-based) :param r2: bottom-right row index (1-based) :param c2: bottom-right column index (1-based) :return: Sum of integers in the specified submatrix return (prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1]) def solve(n, m, matrix, queries): Main function to solve the problem. :param n: Number of rows in the matrix :param m: Number of columns in the matrix :param matrix: 2D list of integers representing the matrix :param queries: List of queries as tuples (r1, c1, r2, c2) :return: List of results for each query prefix_sum = preprocess_matrix(matrix) results = [] for r1, c1, r2, c2 in queries: results.append(sum_submatrix(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"from typing import List def min_length_binary_string(n: int, cases: List[str]) -> List[int]: For each binary string in the list, this function calculates the minimum possible length of the string after performing as many \\"01\\" or \\"10\\" removal operations as possible. Args: n: int : Number of test cases cases: List[str] : List of binary strings Returns: List[int]: Minimum possible length of each binary string after removals >>> min_length_binary_string(2, [\\"001100\\", \\"101010\\"]) [2, 0] >>> min_length_binary_string(1, [\\"1111\\"]) [4] >>> min_length_binary_string(1, [\\"0\\"]) [1]","solution":"def min_length_binary_string(n, cases): result = [] for s in cases: count_01_10_pairs = 0 i = 0 while i < len(s) - 1: if s[i] != s[i+1]: # If s[i] != s[i+1], it is either \\"01\\" or \\"10\\" count_01_10_pairs += 1 i += 2 # skip the next character as \\"10\\" or \\"01\\" is removed else: i += 1 # Each pair removal reduces the length by 2 result.append(len(s) - 2 * count_01_10_pairs) return result"},{"question":"from typing import List def min_shipments(boxes: List[int], target: int) -> int: Returns the minimum number of shipments required to transport all boxes without exceeding the target weight for any shipment. Args: boxes (List[int]): List of integers representing the weights of the boxes. target (int): The maximum allowed weight a single shipment can carry. Returns: int: Minimum number of shipments required. Examples: >>> min_shipments([10, 5, 10, 5], 15) 2 >>> min_shipments([1, 2, 3, 4, 5], 10) 2 def test_example_1(): boxes = [10, 5, 10, 5] target = 15 assert min_shipments(boxes, target) == 2 def test_example_2(): boxes = [1, 2, 3, 4, 5] target = 10 assert min_shipments(boxes, target) == 2 def test_single_box(): boxes = [5] target = 10 assert min_shipments(boxes, target) == 1 def test_multiple_boxes_exact_fit(): boxes = [2, 3, 5] target = 10 assert min_shipments(boxes, target) == 1 def test_multiple_boxes_non_exact_fit(): boxes = [2, 3, 5] target = 8 assert min_shipments(boxes, target) == 2 def test_all_boxes_equal_target(): boxes = [4, 4, 4] target = 4 assert min_shipments(boxes, target) == 3 def test_large_input(): boxes = [1]*1000 target = 1 assert min_shipments(boxes, target) == 1000 def test_mixed_boxes(): boxes = [2, 4, 4, 5] target = 8 assert min_shipments(boxes, target) == 2","solution":"from typing import List def min_shipments(boxes: List[int], target: int) -> int: Returns the minimum number of shipments required to transport all boxes without exceeding the target weight for any shipment. boxes.sort(reverse=True) shipments = 0 while boxes: current_shipment = 0 to_remove = [] for i, box in enumerate(boxes): if current_shipment + box <= target: current_shipment += box to_remove.append(i) if current_shipment == target: break for index in reversed(to_remove): boxes.pop(index) shipments += 1 return shipments"},{"question":"def longest_continuous_period(logs): Given a list of logs, each log entry contains a timestamp and an HTTP status code, determine the longest continuous period during which every log entry has the same status code. :param logs: List of tuples, where each tuple contains (timestamp, status code) :return: Length of the longest continuous period with the same status code >>> logs = [(1, 200), (2, 200), (3, 404), (4, 404), (5, 404)] >>> longest_continuous_period(logs) 3 >>> logs = [(1, 100)] >>> longest_continuous_period(logs) 1","solution":"def longest_continuous_period(logs): Given a list of logs, each log entry contains a timestamp and an HTTP status code, determine the longest continuous period during which every log entry has the same status code. :param logs: List of tuples, where each tuple contains (timestamp, status code) :return: Length of the longest continuous period with the same status code if not logs: return 0 longest_period = 0 current_period = 1 for i in range(1, len(logs)): if logs[i][1] == logs[i-1][1]: current_period += 1 else: longest_period = max(longest_period, current_period) current_period = 1 longest_period = max(longest_period, current_period) return longest_period"},{"question":"from typing import List def find_subsets(nums: List[int]) -> List[List[int]]: Returns all possible non-empty subsets of nums. :param nums: List of integers to find the subsets of. :return: List of all non-empty subsets. pass def unique_subsets(nums: List[int]) -> List[List[int]]: Returns all non-empty unique subsets of nums, sorted in lexicographical order. :param nums: List of integers to find the unique subsets of. :return: List of all non-empty unique subsets in lexicographical order. pass # Unit Tests def test_find_subsets(): assert sorted(find_subsets([1, 2, 2])) == sorted([ (1,), (2,), (2,), (1, 2), (1, 2), (2, 2), (1, 2, 2) ]) def test_unique_subsets(): assert unique_subsets([1, 2, 2]) == [[1], [1, 2], [1, 2, 2], [2], [2, 2]] def test_unique_subsets_with_negative_numbers(): assert unique_subsets([1, -1, 2]) == [[-1], [-1, 1], [-1, 1, 2], [-1, 2], [1], [1, 2], [2]] def test_unique_subsets_single_element(): assert unique_subsets([3]) == [[3]] def test_unique_subsets_all_same_elements(): assert unique_subsets([2, 2, 2]) == [[2], [2, 2], [2, 2, 2]] def test_unique_subsets_empty_list(): assert unique_subsets([]) == [] def test_unique_subsets_different_order(): assert unique_subsets([2, 1, 2]) == [[1], [1, 2], [1, 2, 2], [2], [2, 2]]","solution":"import itertools def find_subsets(nums): Returns all possible non-empty subsets of nums. subsets = [] for i in range(1, len(nums) + 1): subsets.extend(itertools.combinations(nums, i)) return subsets def unique_subsets(nums): Returns all non-empty unique subsets of nums, sorted in lexicographical order. nums.sort() all_subsets = find_subsets(nums) unique_subsets_set = set(tuple(sorted(subset)) for subset in all_subsets) unique_subsets_list = sorted(unique_subsets_set) return [list(subset) for subset in unique_subsets_list]"},{"question":"def room_lights_state(n, m, intervals, t): Determines the state of each room ('on' or 'off') at time t based on given intervals. Parameters: - n (int): number of rooms - m (int): number of intervals - intervals (list of tuples): list containing the intervals (r, start, end) - t (int): the specific time to check Returns: - list: list of strings \\"on\\" or \\"off\\" for each room from 1 to n Examples: >>> room_lights_state(3, 5, [(1, 0, 10), (2, 5, 15), (3, 10, 20), (1, 30, 40), (3, 25, 30)], 11) ['off', 'on', 'on'] >>> room_lights_state(3, 2, [(1, 0, 10), (2, 5, 15)], 20) ['off', 'off', 'off'] >>> room_lights_state(3, 3, [(1, 0, 10), (2, 0, 10), (3, 0, 10)], 5) ['on', 'on', 'on'] >>> room_lights_state(2, 2, [(1, 5, 10), (2, 15, 20)], 5) ['on', 'off'] >>> room_lights_state(2, 2, [(1, 1, 5), (2, 10, 15)], 5) ['off', 'off']","solution":"def room_lights_state(n, m, intervals, t): Determines the state of each room ('on' or 'off') at time t based on given intervals. Parameters: - n (int): number of rooms - m (int): number of intervals - intervals (list of tuples): list containing the intervals (r, start, end) - t (int): the specific time to check Returns: - list: list of strings \\"on\\" or \\"off\\" for each room from 1 to n states = ['off'] * n # Initially, assume all rooms are \\"off\\" for r, start, end in intervals: if start <= t < end: states[r - 1] = 'on' return states # Example input n = 3 m = 5 intervals = [ (1, 0, 10), (2, 5, 15), (3, 10, 20), (1, 30, 40), (3, 25, 30) ] t = 11 print(room_lights_state(n, m, intervals, t))"},{"question":"def assign_rocks_to_crates(n: int, hardness_levels: List[int]) -> Union[str, Tuple[str, List[List[int]]]]: Assigns rocks to three crates such that each crate has at least one rock. Returns a tuple (\\"YES\\", crates) where crates is a list of three lists containing rock indices. Returns \\"NO\\" if it is not possible to assign the rocks to three non-empty crates. :param n: Integer, number of rocks. :param hardness_levels: List of integers, hardness levels of the rocks. :return: Tuple or string (\\"YES\\", [lists of indices]) if possible, \\"NO\\" otherwise. >>> assign_rocks_to_crates(7, [5, 3, 10, 8, 6, 2, 4]) (\\"YES\\", [[1, 4, 7], [2, 5], [3, 6]]) >>> assign_rocks_to_crates(4, [1, 1, 1, 1]) \\"NO\\" def parse_input(input_data: str) -> Tuple[int, List[int]]: Parses the input data into the expected format. :param input_data: String, raw input data :return: Tuple containing the number of rocks and a list of hardness levels. >>> parse_input(\\"7n5 3 10 8 6 2 4\\") (7, [5, 3, 10, 8, 6, 2, 4]) >>> parse_input(\\"4n1 1 1 1\\") (4, [1, 1, 1, 1]) def format_output(result: Union[str, Tuple[str, List[List[int]]]]) -> str: Formats the output as expected based on the result provided. :param result: Result tuple or string :return: String formatted output >>> format_output((\\"YES\\", [[1, 4, 7], [2, 5], [3, 6]])) \\"YESn1 4 7n2 5n3 6\\" >>> format_output(\\"NO\\") \\"NO\\"","solution":"def assign_rocks_to_crates(n, hardness_levels): Assigns rocks to three crates such that each crate has at least one rock. Returns a tuple (\\"YES\\", crates) where crates is a list of three lists containing rock indices. Returns \\"NO\\" if it is not possible to assign the rocks to three non-empty crates. :param n: Integer, number of rocks. :param hardness_levels: List of integers, hardness levels of the rocks. :return: Tuple or string (\\"YES\\", [lists of indices]) if possible, \\"NO\\" otherwise. if n < 3: return \\"NO\\" rocks = list(range(1, n + 1)) # List of rock indices crates = [[], [], []] # Dividing the rocks in a round robin manner for i in range(n): crates[i % 3].append(rocks[i]) # Checking if all crates are non-empty if all(crates): return \\"YES\\", crates else: return \\"NO\\" def parse_input(input_data): Parses the input data into the expected format. lines = input_data.strip().split(\\"n\\") n = int(lines[0]) hardness_levels = list(map(int, lines[1].split())) return n, hardness_levels def format_output(result): Formats the output as expected based on the result provided. if result == \\"NO\\": return \\"NO\\" else: status, crates = result return \\"{}n{}n{}n{}\\".format( status, \\" \\".join(map(str, crates[0])), \\" \\".join(map(str, crates[1])), \\" \\".join(map(str, crates[2])), )"},{"question":"def min_moves_to_organize(n, m, book_ids, shelf_states): This function calculates the minimum number of moves required to organize the books on shelves. n: int - Number of books. m: int - Number of shelves. book_ids: list - List of book IDs (length n). shelf_states: list - List representing each shelf state (length m). 0 if empty, otherwise the ID of the book on that shelf. Returns an integer representing the minimum number of moves. # Example test cases def test_min_moves_to_organize(): assert min_moves_to_organize(5, 3, [3, 1, 4, 2, 5], [0, 3, 0]) == 3 assert min_moves_to_organize(5, 5, [3, 1, 4, 2, 5], [0, 3, 0, 4, 5]) == 3 assert min_moves_to_organize(5, 5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 0 assert min_moves_to_organize(3, 3, [1, 2, 3], [1, 0, 3]) == 1 assert min_moves_to_organize(4, 4, [3, 1, 2, 4], [1, 0, 0, 0]) == 3 assert min_moves_to_organize(4, 4, [4, 3, 2, 1], [0, 0, 0, 0]) == 4 if __name__ == \\"__main__\\": test_min_moves_to_organize()","solution":"def min_moves_to_organize(n, m, book_ids, shelf_states): This function calculates the minimum number of moves required to organize the books on shelves. n: int - Number of books. m: int - Number of shelves. book_ids: list - List of book IDs (length n). shelf_states: list - List representing each shelf state (length m). 0 if empty, otherwise the ID of the book on that shelf. Returns an integer representing the minimum number of moves. book_pos = {book_id: i for i, book_id in enumerate(book_ids, 1)} # map book IDs to positions move_count = 0 # A list of desired book positions desired_positions = list(range(1, min(n, m) + 1)) index = 0 for pos in desired_positions: current_book_id = shelf_states[index] if current_book_id != pos: move_count += 1 shelf_states[index] = pos index += 1 if index >= m: break return move_count"},{"question":"from typing import List, Tuple def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array \`a\` of \`n\` integers (either 0 or 1), find the minimum number of moves required to make all the elements in the array the same. In one move, you can do one of the following: - Select any two adjacent elements and swap them. - Increase or decrease any element by 1. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing an integer \`n\` and a list \`a\` of \`n\` integers. Returns: List[int]: A list of integers representing the minimum number of moves for each test case. Example: >>> process_test_cases([(3, [1, 0, 1]), (4, [0, 1, 1, 0])]) [1, 2] >>> process_test_cases([(5, [1, 1, 1, 1, 1])]) [0] >>> process_test_cases([(5, [0, 0, 0, 0, 0])]) [0] pass","solution":"def min_moves_to_uniform_array(n, a): count_0 = a.count(0) count_1 = n - count_0 # since the array only contains 0s and 1s return min(count_0, count_1) def process_test_cases(test_cases): results = [] for n, a in test_cases: results.append(min_moves_to_uniform_array(n, a)) return results"},{"question":"def count_ways_peak_sequence(m: int, sequence: List[int]) -> int: Calculate the number of ways to fill in the missing numbers such that the sequence forms a valid peak sequence. Args: m (int): the length of the sequence sequence (List[int]): the sequence of integers where each integer is either -1 (indicating the number is missing) or a valid integer (1 <= v <= 1000) Returns: int: the number of ways to fill the missing numbers modulo 10^9 + 7 >>> count_ways_peak_sequence(3, [-1, 5, -1]) 1000 >>> count_ways_peak_sequence(5, [-1, -1, -1, -1, -1]) 1000**3 % (10**9 + 7)","solution":"MOD = 10**9 + 7 def count_ways_peak_sequence(m, sequence): def valid_filling(seq): mid = len(seq) // 2 for i in range(mid): if seq[i] == -1 or seq[-i-1] == -1: continue if seq[i] != seq[-i-1]: return False return True if valid_filling(sequence): ways = 1 mid = m // 2 for i in range(mid + 1): if sequence[i] == -1: if i != mid: ways = (ways * 1000) % MOD else: ways = (ways * 1000) % MOD return ways else: return 0"},{"question":"def combine_projects(s1: str, s2: str) -> str: Determines if two project ideas can be combined without sharing any tasks. Args: s1: str - first project idea s2: str - second project idea Returns: A string representing the combined project idea if no task appears more than once across the two projects, otherwise returns \\"IMPOSSIBLE\\". Examples: >>> combine_projects('abc', 'def') 'abcdef' >>> combine_projects('abc', 'cde') 'IMPOSSIBLE'","solution":"def combine_projects(s1, s2): Returns the combined project idea if the two projects can be combined without any task being repeated, otherwise returns \\"IMPOSSIBLE\\". s1: str - first project idea s2: str - second project idea set1 = set(s1) set2 = set(s2) # Check for common tasks if set1 & set2: return \\"IMPOSSIBLE\\" return s1 + s2"},{"question":"def can_reach_end(n: int, m: int, grid: List[List[str]]) -> str: Determines if it is possible to reach the bottom-right corner from the top-left corner of the grid. >>> can_reach_end(5, 5, [['.', '.', '#', '.', '.'], ['.', '#', '#', '.', '.'], ['.', '.', '.', '.', '.'], ['#', '#', '.', '#', '#'], ['.', '.', '.', '.', '.']]) == \\"Yes\\" >>> can_reach_end(4, 4, [['.', '#', '.', '.'], ['#', '#', '#', '.'], ['.', '.', '#', '#'], ['#', '.', '.', '.']]) == \\"No\\" >>> can_reach_end(3, 3, [['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) == \\"No\\" >>> can_reach_end(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#']]) == \\"No\\" >>> can_reach_end(2, 2, [['.', '.'], ['.', '.']]) == \\"Yes\\"","solution":"def can_reach_end(n, m, grid): Determines if it is possible to reach the bottom-right corner from the top-left corner of the grid. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"No\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y] def dfs(x, y): if x == n-1 and y == m-1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): if dfs(nx, ny): return True return False return \\"Yes\\" if dfs(0, 0) else \\"No\\""},{"question":"def xor_binary_strings(a: str, b: str) -> str: Takes in two binary strings a and b of the same length and returns the resulting binary string after performing the XOR operation on each bit. Args: a (str): The first binary string. b (str): The second binary string. Returns: str: The resulting binary string after XOR operation. Raises: ValueError: If the lengths of a and b are not the same. >>> xor_binary_strings(\\"1101\\", \\"1011\\") \\"0110\\" >>> xor_binary_strings(\\"0000\\", \\"0000\\") \\"0000\\" >>> xor_binary_strings(\\"1111\\", \\"1111\\") \\"0000\\" >>> xor_binary_strings(\\"1010\\", \\"0101\\") \\"1111\\" >>> xor_binary_strings(\\"1\\", \\"0\\") \\"1\\" >>> xor_binary_strings(\\"0\\", \\"1\\") \\"1\\" >>> xor_binary_strings(\\"0\\", \\"0\\") \\"0\\" >>> xor_binary_strings(\\"1\\", \\"1\\") \\"0\\" >>> xor_binary_strings(\\"101\\", \\"0100\\") ValueError(\\"Input strings must be of the same length.\\")","solution":"def xor_binary_strings(a, b): Returns XOR of two binary strings a and b. if len(a) != len(b): raise ValueError(\\"Input strings must be of the same length.\\") result = [] for bit_a, bit_b in zip(a, b): # XOR operation for each bit if bit_a == bit_b: result.append('0') else: result.append('1') return ''.join(result)"},{"question":"import math from typing import List, Tuple def minimum_distance(n: int, coordinates: List[Tuple[int, int]]) -> float: Calculates the minimum distance between any two landing sites. :param n: Integer, number of landing sites :param coordinates: List of tuples, where each tuple contains x, y coordinates of a landing site :return: Float, the minimum distance between any two landing sites rounded to 6 decimal places >>> minimum_distance(4, [(0, 0), (1, 1), (2, 2), (3, 3)]) 1.414214 >>> minimum_distance(2, [(-1000000, -1000000), (1000000, 1000000)]) 2828427.124746 >>> minimum_distance(4, [(0, 0), (0, 1), (0, 2), (0, 3)]) 1.000000 >>> minimum_distance(4, [(-1000000, 0), (1000000, 0), (0, -1000000), (0, 1000000)]) 1414213.562373 >>> minimum_distance(4, [(0, 0), (0, 0), (0, 0), (0, 0)]) 0.000000 >>> minimum_distance(5, [(0, 0), (1, 1), (3, 5), (7, 9), (-1, -1)]) 1.414214","solution":"import math def minimum_distance(n, coordinates): Calculates the minimum distance between any two landing sites. :param n: Integer, number of landing sites :param coordinates: List of tuples, where each tuple contains x, y coordinates of a landing site :return: Float, the minimum distance between any two landing sites rounded to 6 decimal places min_dist = float('inf') # Compare each pair of landing sites for i in range(n): for j in range(i + 1, n): x1, y1 = coordinates[i] x2, y2 = coordinates[j] dist = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) if dist < min_dist: min_dist = dist return round(min_dist, 6)"},{"question":"def min_deletions_to_k_distinct(s: str, k: int) -> int: Determine the minimum number of deletions required to make the string have exactly k distinct characters. Args: s (str): A string containing lowercase English letters. k (int): Target number of distinct characters. Returns: int: The minimum number of deletions required to achieve exactly k distinct characters, or -1 if it's impossible. >>> min_deletions_to_k_distinct(\\"aaabbc\\", 2) 1 >>> min_deletions_to_k_distinct(\\"abcdef\\", 10) -1","solution":"from collections import Counter def min_deletions_to_k_distinct(s, k): Returns the minimum number of deletions required to make the string have exactly k distinct characters, or -1 if it's not possible. distinct_char_counts = Counter(s) n_distinct = len(distinct_char_counts) # If the number of distinct characters is already k, no deletions are required if n_distinct == k: return 0 # If not possible to have exactly k distinct characters if n_distinct < k: return -1 # Get the frequency of each character in the string char_frequencies = sorted(distinct_char_counts.values()) # Delete characters to reduce the number of distinct characters to exactly k deletions = 0 while n_distinct > k: freq = char_frequencies.pop(0) deletions += freq n_distinct -= 1 return deletions"},{"question":"def convert_to_base10(base: int, num_str: str) -> int: Convert a number string from a specified base to its integer representation in base 10. >>> convert_to_base10(2, \\"1011\\") 11 >>> convert_to_base10(16, \\"1A3\\") 419 >>> convert_to_base10(36, \\"z\\") 35","solution":"def convert_to_base10(base: int, num_str: str) -> int: Convert a number string from a specified base to its integer representation in base 10. Args: - base (int): The base of the input number (2 ≤ base ≤ 36). - num_str (str): The number as a string in the given base. Returns: - int: The integer representation of the number in base 10. return int(num_str, base)"},{"question":"from typing import List def count_good_subarrays(arr: List[int]) -> int: Calculate the number of 'good' subarrays. A subarray is defined as 'good' if it contains at least one element which is the sum of any two elements within that subarray. Args: arr (List[int]): The array of integers. Returns: int: The number of 'good' subarrays. def number_of_good_subarrays(n: int, arr: List[int]) -> int: Wrapper function to calculate the number of 'good' subarrays. Args: n (int): The size of the array. arr (List[int]): The array of integers. Returns: int: The number of 'good' subarrays. >>> number_of_good_subarrays(3, [1, 2, 3]) 3 >>> number_of_good_subarrays(4, [1, 1, 1, 1]) 6 >>> number_of_good_subarrays(2, [1, 2]) 1 >>> number_of_good_subarrays(1, [5]) 0 >>> number_of_good_subarrays(3, [1, 1, 1]) 3 >>> number_of_good_subarrays(4, [1000000000, 999999999, 999999998, 999999997]) 6 >>> number_of_good_subarrays(5, [4, 5, 1, 2, 3]) 10 >>> number_of_good_subarrays(2, [1, 3]) 1","solution":"def count_good_subarrays(arr): n = len(arr) good_count = 0 for i in range(n): for j in range(i, n): seen_sums = set() is_good = False for k in range(i, j + 1): for l in range(i, j + 1): if k != l: if arr[k] + arr[l] in seen_sums: is_good = True break seen_sums.add(arr[k] + arr[l]) if is_good: break if is_good: good_count += 1 return good_count # Function for the task def number_of_good_subarrays(n, arr): return count_good_subarrays(arr)"},{"question":"from typing import List def earliest_celebration_year(n: int, k: int, life_cycles: List[int]) -> int: Determine the earliest year after the initial year (year 0) when all n types of creatures can gather for the celebration, given that year is also a multiple of k. >>> earliest_celebration_year(2, 12, [3, 4]) 12 >>> earliest_celebration_year(3, 6, [2, 3, 4]) 12 >>> earliest_celebration_year(4, 15, [3, 5, 10, 15]) 30 >>> earliest_celebration_year(1, 7, [14]) 14 >>> earliest_celebration_year(3, 10, [2, 5, 7]) 70 >>> earliest_celebration_year(2, 8, [16, 24]) 48","solution":"import math from functools import reduce def lcm(a, b): return abs(a*b) // math.gcd(a, b) def earliest_celebration_year(n, k, life_cycles): # Finding the LCM of all life cycle lengths lcm_all = reduce(lcm, life_cycles) # Find the first year that is multiple of both lcm_all and k if lcm_all % k == 0: return lcm_all else: return (lcm_all * k) // math.gcd(lcm_all, k) # Example n = 2 k = 12 life_cycles = [3, 4] print(earliest_celebration_year(n, k, life_cycles)) # Output should be 12"},{"question":"def min_subarrays_required(n: int, arr: List[int]) -> int: Given an array of integers, determine the minimum number of contiguous subarrays required such that each subarray contains at least one unique element that does not appear in other subarrays. >>> min_subarrays_required(5, [1, 2, 2, 3, 4]) == 3 >>> min_subarrays_required(6, [4, 4, 4, 4, 4, 4]) == 6 >>> min_subarrays_required(0, []) == 0 >>> min_subarrays_required(1, [1]) == 1 >>> min_subarrays_required(5, [1, 2, 3, 4, 5]) == 1 >>> min_subarrays_required(6, [1, 2, 1, 2, 1, 2]) == 3 >>> min_subarrays_required(10, [5, 5, 5, 5, 1, 2, 3, 4, 6, 7]) == 4","solution":"def min_subarrays_required(n, arr): Returns the minimum number of subarrays required to ensure each subarray contains at least one unique element. if n == 0: return 0 # Create a dictionary to keep track of the frequency of each element frequency = {} for num in arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # The minimum number of subarrays required is the highest frequency of any element max_frequency = max(frequency.values()) return max_frequency"},{"question":"[Completion Task in Python] from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns a new list where each element is the maximum value in a sliding window of the specified size that moves from left to right across the original list. The implementation should aim for a time complexity better than O(n * k). Parameters: nums (List[int]): A list of integers representing the input sequence. k (int): The size of the sliding window. \`1 ≤ k ≤ len(nums)\`. Returns: List[int]: A list of integers representing the maximum values in each sliding window. Examples: >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [3, 4, 5, 6, 7, 8, 9] >>> max_sliding_window([9, 8, 7, 6, 5, 4, 3, 2, 1], 3) [9, 8, 7, 6, 5, 4, 3] pass","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns the maximum values in each sliding window of size k across the list nums. if not nums or k == 0: return [] n = len(nums) if k == 1: return nums dq = deque() # Store indices of useful elements max_values = [] for i in range(n): # Remove indices that are out of the current window while dq and dq[0] < i - k + 1: dq.popleft() # Remove elements from deque that are smaller than current element while dq and nums[dq[-1]] <= nums[i]: dq.pop() # Add the current element's index to the deque dq.append(i) # Add the maximum element of current window to result list if i >= k - 1: max_values.append(nums[dq[0]]) return max_values"},{"question":"def can_match(s: str, t: str) -> str: Determines if string s can be matched by string t where each '*' in t can be replaced by any sequence of lowercase Latin letters. Args: s (str): The input string to be matched. t (str): The pattern string containing lowercase Latin letters and the wildcard character '*'. Returns: str: 'YES' if t can match s; otherwise 'NO'. pass def test_can_match_simple(): assert can_match(\\"hello\\", \\"h*o\\") == \\"YES\\" assert can_match(\\"hello\\", \\"he*o\\") == \\"YES\\" assert can_match(\\"hello\\", \\"he*lo\\") == \\"YES\\" def test_can_match_exact(): assert can_match(\\"hello\\", \\"hello\\") == \\"YES\\" assert can_match(\\"abcde\\", \\"abcde\\") == \\"YES\\" assert can_match(\\"xyz\\", \\"xyz\\") == \\"YES\\" def test_can_match_empty_wildcard(): assert can_match(\\"hello\\", \\"h*\\") == \\"YES\\" assert can_match(\\"hello\\", \\"*o\\") == \\"YES\\" assert can_match(\\"hello\\", \\"*\\") == \\"YES\\" def test_can_match_no_match(): assert can_match(\\"hello\\", \\"a*o\\") == \\"NO\\" assert can_match(\\"hello\\", \\"h*d\\") == \\"NO\\" assert can_match(\\"hello\\", \\"he*l\\") == \\"NO\\" def test_can_match_edge_cases(): assert can_match(\\"a\\", \\"a*\\") == \\"YES\\" assert can_match(\\"a\\", \\"*a\\") == \\"YES\\" assert can_match(\\"a\\", \\"*\\") == \\"YES\\" assert can_match(\\"a\\", \\"b*\\") == \\"NO\\" assert can_match(\\"a\\", \\"*b\\") == \\"NO\\"","solution":"def can_match(s, t): Determines if string s can be matched by string t where each '*' in t can be replaced by any sequence of lowercase Latin letters. Args: s (str): The input string to be matched. t (str): The pattern string containing lowercase Latin letters and the wildcard character '*'. Returns: str: 'YES' if t can match s; otherwise 'NO'. ns, nt = len(s), len(t) if '*' not in t: return \\"YES\\" if s == t else \\"NO\\" prefix, suffix = t.split('*') # Check if s starts with prefix and ends with suffix if s.startswith(prefix) and s.endswith(suffix): if ns >= len(prefix) + len(suffix): return \\"YES\\" return \\"NO\\""},{"question":"def alice_collects(n: int, sequence: List[int]) -> int: Calculate the sum of the numbers Alice will collect if both players play optimally. >>> alice_collects(4, [1, 2, 9, 4]) 10 >>> alice_collects(2, [5, 4]) 5 >>> alice_collects(4, [1, 1, 1, 1]) 2 >>> alice_collects(1, [7]) 7 >>> alice_collects(6, [5, 3, 7, 10, 3, 2]) 17 >>> alice_collects(4, [1, 2, 3, 4]) 6","solution":"def alice_collects(n, sequence): Calculate the sum of the numbers Alice will collect if both players play optimally. # Create a memoization table for dynamic programming dp = [[0] * n for _ in range(n)] # Fill the dp array diagonally for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 # dp[i][j] represents the maximum sum Alice can collect from sequence[i:j+1] if i == j: dp[i][j] = sequence[i] else: # Alice chooses the start start_pick = sequence[i] + min(dp[i + 2][j] if i + 2 <= j else 0, dp[i + 1][j - 1]) # Alice chooses the end end_pick = sequence[j] + min(dp[i + 1][j - 1], dp[i][j - 2] if j - 2 >= i else 0) dp[i][j] = max(start_pick, end_pick) return dp[0][n - 1]"},{"question":"def split_sequence(n: int): Determines whether it is possible to split the sequence of numbers from 1 to n into two parts with equal sums. Args: n (int): The end of the sequence (inclusive). Returns: A tuple containing: - A boolean indicating if a split is possible. - If possible, two lists representing the two parts with equal sums. Examples: >>> split_sequence(7) (\\"YES\\", [1, 2, 3, 4, 5], [6, 7]) >>> split_sequence(6) (\\"NO\\",)","solution":"def split_sequence(n): Determines whether it is possible to split the sequence of numbers from 1 to n into two parts with equal sums. Args: n (int): The end of the sequence (inclusive). Returns: A tuple containing: - A boolean indicating if a split is possible. - If possible, two lists representing the two parts with equal sums. total_sum = n * (n + 1) // 2 if total_sum % 2 != 0: return (\\"NO\\",) half_sum = total_sum // 2 part1, part2 = [], [] current_sum = 0 for i in range(n, 0, -1): if current_sum + i <= half_sum: part1.append(i) current_sum += i else: part2.append(i) return (\\"YES\\", part1, part2)"},{"question":"def min_colors_for_grid(m: int, n: int) -> int: Returns the minimum number of colors needed to paint the m x n grid such that no two adjacent cells have the same color. >>> min_colors_for_grid(1, 1) 1 >>> min_colors_for_grid(2, 3) 2 >>> min_colors_for_grid(4, 4) 2 >>> min_colors_for_grid(5, 5) 2 def min_colors_for_multiple_grids(test_cases: List[Tuple[int, int]]) -> List[int]: For a list of test cases, each represented as a tuple (m, n), returns a list of integers where each integer is the minimum number of colors needed to paint the respective m x n grid. >>> min_colors_for_multiple_grids([(1, 1), (2, 3), (4, 4), (5, 5)]) [1, 2, 2, 2] >>> min_colors_for_multiple_grids([(1, 1), (1, 100), (100, 1), (10, 10)]) [1, 1, 1, 2]","solution":"def min_colors_for_grid(m, n): Returns the minimum number of colors needed to paint the m x n grid such that no two adjacent cells have the same color. if m == 1 or n == 1: return 1 else: return 2 def min_colors_for_multiple_grids(test_cases): results = [] for m, n in test_cases: results.append(min_colors_for_grid(m, n)) return results"},{"question":"from typing import List def search_rotated_array(nums: List[int], target: int) -> int: Searches for a target in a rotated sorted array and returns its index. If the target is not found, returns -1. >>> search_rotated_array([4,5,6,7,0,1,2], 0) == 4 >>> search_rotated_array([4,5,6,7,0,1,2], 3) == -1 def test_search_rotated_array(): assert search_rotated_array([4,5,6,7,0,1,2], 0) == 4 assert search_rotated_array([4,5,6,7,0,1,2], 3) == -1 assert search_rotated_array([1], 0) == -1 assert search_rotated_array([1], 1) == 0 def test_search_rotated_array_with_duplicates(): assert search_rotated_array([5,5,6,6,7,7,0,0,1,1,2,2], 1) == 8 assert search_rotated_array([5,5,6,6,7,7,0,0,1,1,2,2], 6) == 2 def test_search_rotated_array_multiple_rotations(): assert search_rotated_array([5,1,2,3,4], 1) == 1 assert search_rotated_array([5,1,2,3,4], 5) == 0 def test_search_rotated_array_edge_cases(): assert search_rotated_array([], 1) == -1 assert search_rotated_array([3], 5) == -1 assert search_rotated_array([3], 3) == 0 def test_search_rotated_array_rotated_twice(): nums = [7,8,1,2,3,4,5,6] assert search_rotated_array(nums, 6) == 7 assert search_rotated_array(nums, 7) == 0 assert search_rotated_array(nums, 5) == 6 assert search_rotated_array(nums, 2) == 3 def test_search_rotated_array_large_input(): large_list = list(range(10001, 20001)) + list(range(1, 10001)) assert search_rotated_array(large_list, 15000) == 4999 assert search_rotated_array(large_list, 1) == 10000 assert search_rotated_array(large_list, 20000) == 9999 assert search_rotated_array(large_list, 10001) == 0 assert search_rotated_array(large_list, 10002) == 1 assert search_rotated_array(large_list, 9999) == 19998","solution":"def search_rotated_array(nums, target): Searches for a target in a rotated sorted array and returns its index. If the target is not found, returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def balanced_sequences_count(n: int) -> int: Returns the count of balanced sequences of length n. A sequence is balanced if the number of 0s is equal to the number of 1s. >>> balanced_sequences_count(4) 6 >>> balanced_sequences_count(3) 0 >>> balanced_sequences_count(6) 20 pass # Add appropriate unit tests: def test_even_n(): assert balanced_sequences_count(4) == 6 assert balanced_sequences_count(6) == 20 assert balanced_sequences_count(2) == 2 assert balanced_sequences_count(8) == 70 assert balanced_sequences_count(10) == 252 def test_odd_n(): assert balanced_sequences_count(1) == 0 assert balanced_sequences_count(3) == 0 assert balanced_sequences_count(5) == 0 assert balanced_sequences_count(7) == 0 assert balanced_sequences_count(9) == 0 def test_edge_cases(): assert balanced_sequences_count(0) == 1 # even though n=0 is not in the range, combinatorially there's 1 empty sequence assert balanced_sequences_count(20) == 184756","solution":"def balanced_sequences_count(n): Returns the count of balanced sequences of length n. A sequence is balanced if the number of 0s is equal to the number of 1s. if n % 2 != 0: return 0 # No balanced sequence possible if length is odd # To find the balanced sequence count, we can use combinatorial approach: # In a balanced sequence of length n, there are exactly n//2 0s and n//2 1s. from math import comb half_n = n // 2 return comb(n, half_n)"},{"question":"def unique_paths(h: int, w: int, grid: List[List[int]]) -> int: Calculate the number of distinct paths from the top-left corner to the bottom-right corner in a grid with obstacles. >>> unique_paths(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths(2, 2, [ ... [0, 1], ... [1, 0] ... ]) == 0 pass # Unit Tests import pytest from solution import unique_paths def test_example_case(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths(3, 3, grid) == 2 def test_no_path_case(): grid = [ [0, 1], [1, 0] ] assert unique_paths(2, 2, grid) == 0 def test_single_row(): grid = [[0, 0, 0, 0]] assert unique_paths(1, 4, grid) == 1 def test_single_column(): grid = [[0], [0], [0], [0]] assert unique_paths(4, 1, grid) == 1 def test_obstacle_in_first_cell(): grid = [ [1, 0], [0, 0] ] assert unique_paths(2, 2, grid) == 0 def test_obstacle_in_last_cell(): grid = [ [0, 0], [0, 1] ] assert unique_paths(2, 2, grid) == 0 def test_large_grid(): h, w = 500, 500 grid = [[0]*w for _ in range(h)] assert unique_paths(h, w, grid) > 0 def test_case_all_obstacles_except_start_and_end(): grid = [ [0, 1, 1], [1, 1, 1], [1, 1, 0] ] assert unique_paths(3, 3, grid) == 0 def test_case_with_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths(3, 3, grid) == 6","solution":"def unique_paths(h, w, grid): MOD = 1000000007 # dp table initialization dp = [[0 for _ in range(w)] for _ in range(h)] # If starting point or ending point is an obstacle, return 0 if grid[0][0] == 1 or grid[h-1][w-1] == 1: return 0 # Starting point dp[0][0] = 1 for i in range(h): for j in range(w): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[h-1][w-1]"},{"question":"def can_make_identical(a, b): Determines if two arrays \`a\` and \`b\` can be made identical by multiplying elements by any prime number any number of times. >>> can_make_identical([6, 4, 3, 9], [18, 4, 27, 3]) 'YES' >>> can_make_identical([2, 3, 5], [4, 9, 10]) 'NO'","solution":"def prime_factors(number): Returns the set of prime factors of a given number. i = 2 factors = set() while i * i <= number: while (number % i) == 0: factors.add(i) number //= i i += 1 if number > 1: factors.add(number) return factors def can_make_identical(a, b): Determines if two arrays \`a\` and \`b\` can be made identical by multiplying elements by any prime number any number of times. n = len(a) for i in range(n): if prime_factors(a[i]) != prime_factors(b[i]): return \\"NO\\" return \\"YES\\""},{"question":"def earliest_finish_time(m: int, requests: List[Tuple[int, int]]) -> int: Calculate the earliest time the server can finish processing all the requests. Parameters: m (int): The number of incoming requests. requests (list of tuples): A list of tuples where each tuple contains t_i (arrival time) and p_i (processing time) for each request. Returns: int: The earliest time the server can finish processing all the requests. >>> earliest_finish_time(1, [(0, 5)]) 5 >>> earliest_finish_time(3, [(0, 2), (3, 4), (8, 1)]) 9 >>> earliest_finish_time(3, [(0, 3), (1, 2), (2, 4)]) 9 >>> earliest_finish_time(3, [(0, 3), (3, 2), (3, 4)]) 9 >>> earliest_finish_time(4, [(0, 2), (0, 3), (2, 2), (4, 1)]) 8 >>> earliest_finish_time(2, [(0, 1000000000), (1000000000, 1000000000)]) 2000000000","solution":"def earliest_finish_time(m, requests): Calculate the earliest time the server can finish processing all the requests. Parameters: m (int): The number of incoming requests. requests (list of tuples): A list of tuples where each tuple contains t_i (arrival time) and p_i (processing time) for each request. Returns: int: The earliest time the server can finish processing all the requests. current_time = 0 for arrival_time, processing_time in requests: if current_time <= arrival_time: current_time = arrival_time + processing_time else: current_time += processing_time return current_time"},{"question":"from typing import List def sum_with_neighbors(arr: List[int]) -> List[int]: Given an input integer array arr[] of size n containing only positive integers, this function returns a new array where each element is the sum of the element and its immediate neighbors. For the edge elements, consider the neighbor as the only adjacent element. >>> sum_with_neighbors([2, 4, 5, 10]) [6, 11, 19, 15] >>> sum_with_neighbors([10]) [10] >>> sum_with_neighbors([3, 8]) [11, 11] >>> sum_with_neighbors([1, 2, 3, 4, 5]) [3, 6, 9, 12, 9] >>> sum_with_neighbors([1, 1, 1, 1, 1]) [2, 3, 3, 3, 2] >>> sum_with_neighbors([999, 1000, 999, 1000, 999]) [1999, 2998, 2999, 2998, 1999] >>> sum_with_neighbors([]) []","solution":"from typing import List def sum_with_neighbors(arr: List[int]) -> List[int]: Given an input integer array arr[] of size n containing only positive integers, this function returns a new array where each element is the sum of the element and its immediate neighbors. For the edge elements, consider the neighbor as the only adjacent element. n = len(arr) if n == 0: return [] if n == 1: return arr result = [] for i in range(n): if i == 0: result.append(arr[i] + arr[i + 1]) elif i == n - 1: result.append(arr[i] + arr[i - 1]) else: result.append(arr[i - 1] + arr[i] + arr[i + 1]) return result"},{"question":"def minimal_reels(n: int, l: int, w: int, k: int) -> int: Returns the minimal number of string light reels required to decorate k rooms. Parameters: n (int): Length of each string light reel. l (int): Length of each room. w (int): Width of each room. k (int): Number of rooms. Returns: int: Minimal number of string light reels required. >>> minimal_reels(50, 10, 10, 1) 1 >>> minimal_reels(40, 10, 10, 2) 2 >>> minimal_reels(20, 10, 10, 2) 4 >>> minimal_reels(1, 1, 1, 1) 4 >>> minimal_reels(1000, 100, 100, 1) 1 >>> minimal_reels(1, 100, 100, 1) 400 >>> minimal_reels(500, 100, 1, 2) 2","solution":"def minimal_reels(n, l, w, k): Returns the minimal number of string light reels required to decorate k rooms. Parameters: n (int): Length of each string light reel. l (int): Length of each room. w (int): Width of each room. k (int): Number of rooms. Returns: int: Minimal number of string light reels required. # Calculate the perimeter of one room perimeter = 2 * (l + w) # Calculate the number of reels needed for one room reels_per_room = -(-perimeter // n) # Equivalent to ceil(perimeter / n) # Calculate the total number of reels needed for k rooms total_reels = reels_per_room * k return total_reels"},{"question":"def most_frequent_animal(n: int, sightings: List[int]) -> int: Finds the identifier of the animal sighted most frequently. In case of a tie, returns the smallest identifier. Args: n (int): The number of sightings reported for that day. sightings (List[int]): List of animal identifiers sighted. Returns: int: The identifier of the most frequently sighted animal. Examples: >>> most_frequent_animal(7, [1, 1, 2, 2, 3, 3, 3]) 3 >>> most_frequent_animal(6, [1, 1, 2, 2, 3, 3]) 1 pass def test_most_frequent_animal_single_most_frequent(): assert most_frequent_animal(7, [1, 1, 2, 2, 3, 3, 3]) == 3 def test_most_frequent_animal_tie(): assert most_frequent_animal(6, [1, 1, 2, 2, 3, 3]) == 1 def test_most_frequent_animal_no_sightings(): assert most_frequent_animal(0, []) == None def test_most_frequent_animal_single_sighting(): assert most_frequent_animal(1, [100]) == 100 def test_most_frequent_animal_multiple_ties(): assert most_frequent_animal(8, [4, 4, 2, 2, 1, 1, 3, 3]) == 1 def test_most_frequent_animal_diff_sightings(): assert most_frequent_animal(10, [10, 20, 10, 30, 20, 30, 30, 40, 40, 40]) == 30 def test_most_frequent_animal_single_type(): assert most_frequent_animal(5, [2, 2, 2, 2, 2]) == 2 def test_most_frequent_animal_split_sightings(): assert most_frequent_animal(5, [1, 2, 2, 3, 3]) == 2","solution":"def most_frequent_animal(n, sightings): Returns the identifier of the most frequently sighted animal. In case of a tie, returns the smallest identifier. from collections import Counter if n == 0: return None count = Counter(sightings) max_frequency = max(count.values()) most_frequent = [identifier for identifier, freq in count.items() if freq == max_frequency] return min(most_frequent) # Example usage: # n = 7 # sightings = [1, 1, 2, 2, 3, 3, 3] # print(most_frequent_animal(n, sightings)) # Output: 3"},{"question":"def minimize_sum_of_max_elements(n: int, arr: List[int]) -> int: This function returns the minimum possible sum of the maximum elements of the contiguous subarrays. >>> minimize_sum_of_max_elements(6, [4, 3, 2, 5, 1, 6]) 6 >>> minimize_sum_of_max_elements(5, [7, 2, 5, 10, 8]) 10 >>> minimize_sum_of_max_elements(1, [1]) 1 >>> minimize_sum_of_max_elements(3, [5, 5, 5]) 5 >>> minimize_sum_of_max_elements(4, [1, 2, 3, 4]) 4 >>> minimize_sum_of_max_elements(4, [6, 2, 3, 4]) 6 >>> minimize_sum_of_max_elements(4, [1, 2, 3, 8]) 8","solution":"def minimize_sum_of_max_elements(n, arr): This function returns the minimum possible sum of the maximum elements of the contiguous subarrays. # The best way to minimize the sum of maximums is to have each element # of the array as a separate subarray (since no greater elements can combine # and add up). # Therefore, the minimum possible sum of the maximum elements will be the max element itself, # since we partition each number into its own subarray. return max(arr)"},{"question":"def can_park_vehicles(n: int, s: str) -> str: Takes the total number of parking spaces n, and a sequence s of vehicles, and returns \\"YES\\" if all vehicles can be parked without any two cars being adjacent, otherwise returns \\"NO\\". >>> can_park_vehicles(5, \\"CMCMC\\") \\"YES\\" >>> can_park_vehicles(6, \\"CCMMCM\\") \\"NO\\" >>> can_park_vehicles(3, \\"MMM\\") \\"YES\\" >>> can_park_vehicles(1, \\"C\\") \\"YES\\" >>> can_park_vehicles(1, \\"M\\") \\"YES\\" >>> can_park_vehicles(0, \\"\\") \\"YES\\" >>> can_park_vehicles(5, \\"MCMCC\\") \\"NO\\" >>> can_park_vehicles(5, \\"CCMMM\\") \\"NO\\" >>> can_park_vehicles(5, \\"MMMCM\\") \\"YES\\"","solution":"def can_park_vehicles(n, s): Takes the total number of parking spaces n, and a sequence s of vehicles, and returns \\"YES\\" if all vehicles can be parked without any two cars being adjacent, otherwise returns \\"NO\\". for i in range(n - 1): if s[i] == 'C' and s[i + 1] == 'C': return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def can_form_by_adding_one_char(t: int, test_cases: List[Tuple[str, str]]) -> List[str]: Determine if string B can be obtained by rearranging the characters of string A and inserting exactly one additional character. Args: t (int): number of test cases test_cases (List[Tuple[str, str]]): list of tuples where each tuple contains two strings A and B respectively Returns: List[str]: list of \\"YES\\" or \\"NO\\" for each test case >>> can_form_by_adding_one_char(3, [(\\"abc\\", \\"abdc\\"), (\\"hello\\", \\"heollx\\"), (\\"abcde\\", \\"abcdfg\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_form_by_adding_one_char(2, [(\\"a\\", \\"ab\\"), (\\"b\\", \\"ba\\")]) [\\"YES\\", \\"YES\\"] >>> can_form_by_adding_one_char(2, [(\\"abc\\", \\"abc\\"), (\\"def\\", \\"defg\\")]) [\\"NO\\", \\"YES\\"] >>> can_form_by_adding_one_char(1, [(\\"a\\" * 100, \\"a\\" * 100 + \\"b\\")]) [\\"YES\\"] >>> can_form_by_adding_one_char(2, [(\\"xyz\\", \\"xyzz\\"), (\\"lmn\\", \\"lmn\\")]) [\\"YES\\", \\"NO\\"]","solution":"def can_form_by_adding_one_char(t, test_cases): from collections import Counter results = [] for A, B in test_cases: if len(B) != len(A) + 1: results.append(\\"NO\\") continue count_A = Counter(A) count_B = Counter(B) differences = 0 for char in count_B: if count_B[char] != count_A.get(char, 0): differences += (count_B[char] - count_A.get(char, 0)) if differences > 1: break if differences == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import math from typing import List, Tuple def minimal_irrigation_pipe_length(n: int, coordinates: List[Tuple[int, int]]) -> float: Calculate the minimal length of a pipe required to cover all the trees. Args: n: int : Number of trees coordinates: List[Tuple[int, int]] : List of (x, y) coordinates of the trees Returns: float : The length of the minimal irrigation pipe Examples: >>> abs(minimal_irrigation_pipe_length(4, [(0, 0), (0, 5), (5, 0), (5, 5)]) - 7.071067812) < 1e-6 True >>> abs(minimal_irrigation_pipe_length(2, [(1, 2), (3, 4)]) - 2.82842712) < 1e-6 True >>> abs(minimal_irrigation_pipe_length(4, [(2, 3), (2, 7), (6, 3), (6, 7)]) - 5.656854249) < 1e-6 True >>> minimal_irrigation_pipe_length(1, [(0, 0)]) == 0.0 True >>> abs(minimal_irrigation_pipe_length(2, [(0, 0), (3, 4)]) - 5.0) < 1e-6 True >>> abs(minimal_irrigation_pipe_length(2, [(0, 0), (6, 8)]) - 10.0) < 1e-6 True","solution":"import math def minimal_irrigation_pipe_length(n, coordinates): Calculate the minimal length of a pipe required to cover all the trees. Args: n: int : Number of trees coordinates: list of tuples : List of (x, y) coordinates of the trees Returns: float : The length of the minimal irrigation pipe if n <= 1: return 0.0 min_x = min(coord[0] for coord in coordinates) max_x = max(coord[0] for coord in coordinates) min_y = min(coord[1] for coord in coordinates) max_y = max(coord[1] for coord in coordinates) return math.sqrt((max_x - min_x)**2 + (max_y - min_y)**2)"},{"question":"def count_fruits_starting_with_consonant(fruits: List[str]) -> int: Determine the number of fruits that start with a consonant. >>> count_fruits_starting_with_consonant([\\"apple\\", \\"orange\\", \\"icefruit\\"]) == 0 >>> count_fruits_starting_with_consonant([\\"banana\\", \\"pear\\", \\"grape\\"]) == 3 >>> count_fruits_starting_with_consonant([\\"apple\\", \\"banana\\", \\"orange\\", \\"mango\\"]) == 2 >>> count_fruits_starting_with_consonant([]) == 0 >>> count_fruits_starting_with_consonant([\\"apple\\"]) == 0 >>> count_fruits_starting_with_consonant([\\"banana\\"]) == 1 >>> count_fruits_starting_with_consonant([\\"a\\", \\"b\\", \\"c\\", \\"e\\", \\"i\\"]) == 2","solution":"def count_fruits_starting_with_consonant(fruits): Returns the number of fruits that start with a consonant. Parameters: fruits (list of str): List of fruit names. Returns: int: Number of fruits starting with a consonant. vowels = set('aeiou') count = 0 for fruit in fruits: if fruit[0] not in vowels: count += 1 return count"},{"question":"def find_slowest_segments(m: int, n: int, data: list[list[tuple[int, int]]]) -> list[tuple[int, float]]: Determines the slowest segment for each week. Parameters: m (int): Number of weeks. n (int): Number of segments each week. data (list of list of tuples): Training data for each week, where each inner list represents one week and contains tuples (di, ti) representing distance and time for each segment. Returns: list of tuples: Each tuple contains the 1-based index of the slowest segment and the time-to-distance ratio. pass def test_find_slowest_segments(): m = 2 n = 3 data = [ [(500, 100), (600, 120), (700, 140)], [(1000, 150), (2000, 300), (500, 90)] ] expected_output = [(1, 0.2), (3, 0.18)] assert find_slowest_segments(m, n, data) == expected_output def test_single_week_single_segment(): m = 1 n = 1 data = [ [(800, 200)] ] expected_output = [(1, 0.25)] assert find_slowest_segments(m, n, data) == expected_output def test_all_segments_same_ratio(): m = 1 n = 3 data = [ [(100, 20), (200, 40), (300, 60)] ] expected_output = [(1, 0.2)] # Any segment could be the slowest since they have the same ratio assert find_slowest_segments(m, n, data) == expected_output def test_multiple_weeks(): m = 3 n = 2 data = [ [(800, 160), (400, 120)], [(1000, 200), (300, 60)], [(1200, 300), (150, 60)] ] expected_output = [(2, 0.3), (1, 0.2), (2, 0.4)] assert find_slowest_segments(m, n, data) == expected_output def test_large_values(): m = 2 n = 2 data = [ [(1000, 10000), (2000, 20000)], [(5000, 25000), (10000, 50000)] ] expected_output = [(1, 10.0), (1, 5.0)] assert find_slowest_segments(m, n, data) == expected_output","solution":"def find_slowest_segments(m, n, data): Determines the slowest segment for each week. Parameters: m (int): Number of weeks. n (int): Number of segments each week. data (list of list of tuples): Training data for each week, where each inner list represents one week and contains tuples (di, ti) representing distance and time for each segment. Returns: list of tuples: Each tuple contains the 1-based index of the slowest segment and the time-to-distance ratio. result = [] for week in data: slowest_ratio = 0 slowest_index = 0 for i in range(n): di, ti = week[i] ratio = ti / di if ratio > slowest_ratio: slowest_ratio = ratio slowest_index = i + 1 result.append((slowest_index, round(slowest_ratio, 6))) return result"},{"question":"def max_sum_of_k_houses(arr, n, k): Calculate the maximum possible sum of the prices of k houses that are not closer than 2 indices. Args: arr (List[int]): The list of house prices. n (int): The number of houses. k (int): The number of houses you want to buy. Returns: int: The maximum sum of the prices of k houses. Examples: >>> max_sum_of_k_houses([9, 7, 10, 13, 5, 15], 6, 2) 28 >>> max_sum_of_k_houses([5], 1, 1) 5 >>> max_sum_of_k_houses([1, 1, 1, 1, 1], 5, 3) 3 >>> max_sum_of_k_houses([9, 7, 10, 13, 5, 15, 10, 20, 1], 9, 3) 48 >>> max_sum_of_k_houses([100, 200, 300, 500, 700, 600, 800, 900], 8, 1) 900 >>> max_sum_of_k_houses([10, 1, 10, 1, 10, 1, 10, 1, 10], 9, 4) 40","solution":"def max_sum_of_k_houses(arr, n, k): if k == 0: return 0 if k == 1: return max(arr) dp = [[0] * n for _ in range(k+1)] for j in range(k+1): for i in range(n): if j == 0: dp[j][i] = 0 elif i == 0: dp[j][i] = arr[i] if j == 1 else 0 elif i == 1: dp[j][i] = max(arr[i], dp[j][0]) else: dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 2] + arr[i]) return max(dp[k]) # Parsing input not included based on instructions. # Example usage: # n = 6 # k = 2 # arr = [9, 7, 10, 13, 5, 15] # print(max_sum_of_k_houses(arr, n, k)) # Output: 28"},{"question":"def largest_plateau(grid, n, m): Given a grid representing the heights of cells, calculate the size of the largest plateau. A plateau is defined as a collection of connected cells that have the same height. Args: grid: List of List of integers representing the heights. n: Integer representing the number of rows in the grid. m: Integer representing the number of columns in the grid. Returns: Integer representing the size of the largest plateau. Example: >>> grid = [ [1, 2, 3], [3, 3, 3], [2, 2, 2] ] >>> largest_plateau(grid, 3, 3) 4 from solution import largest_plateau def test_largest_plateau_example(): grid = [ [1, 2, 3], [3, 3, 3], [2, 2, 2] ] assert largest_plateau(grid, 3, 3) == 4 def test_largest_plateau_single_element(): grid = [ [1] ] assert largest_plateau(grid, 1, 1) == 1 def test_largest_plateau_all_different(): grid = [ [1, 2], [3, 4] ] assert largest_plateau(grid, 2, 2) == 1 def test_largest_plateau_whole_grid(): grid = [ [5, 5], [5, 5] ] assert largest_plateau(grid, 2, 2) == 4 def test_largest_plateau_separate_plateaus(): grid = [ [1, 1, 2, 2], [1, 1, 2, 2], [3, 3, 4, 4], [3, 3, 4, 4] ] assert largest_plateau(grid, 4, 4) == 4","solution":"def largest_plateau(grid, n, m): Returns the size of the largest plateau in the grid. A plateau is a collection of connected cells that have the same height. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y, height): return 0 <= x < n and 0 <= y < m and grid[x][y] == height and not visited[x][y] def bfs(x, y): queue = [(x, y)] visited[x][y] = True height = grid[x][y] size = 0 while queue: cx, cy = queue.pop(0) size += 1 for dir_x, dir_y in directions: nx, ny = cx + dir_x, cy + dir_y if is_valid(nx, ny, height): queue.append((nx, ny)) visited[nx][ny] = True return size visited = [[False] * m for _ in range(n)] largest = 0 for i in range(n): for j in range(m): if not visited[i][j]: largest = max(largest, bfs(i, j)) return largest"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[List[int]]) -> List[int]: Process a series of queries on an array where each query is either an update or a range product calculation. Args: n: int - The number of elements in the array. q: int - The number of queries. array: List[int] - The initial elements of the array. queries: List[List[int]] - The list of queries to process. Returns: List[int] - The results of all 'Range Product' queries, modulo 10^9 + 7. >>> process_queries(5, 3, [2, 3, 5, 7, 11], [[2, 1, 3], [1, 3, 6], [2, 1, 3]]) [30, 36]","solution":"class SegmentTree: def __init__(self, data, mod): self.n = len(data) self.mod = mod self.tree = [1] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = data[i] % self.mod for i in range(self.n - 1, 0, -1): self.tree[i] = (self.tree[i * 2] * self.tree[i * 2 + 1]) % self.mod def update(self, index, value): pos = self.n + index self.tree[pos] = value % self.mod while pos > 1: pos //= 2 self.tree[pos] = (self.tree[2 * pos] * self.tree[2 * pos + 1]) % self.mod def range_product(self, left, right): left += self.n right += self.n product = 1 while left < right: if left % 2: product = (product * self.tree[left]) % self.mod left += 1 if right % 2: right -= 1 product = (product * self.tree[right]) % self.mod left //= 2 right //= 2 return product def process_queries(n, q, array, queries): MOD = 10**9 + 7 seg_tree = SegmentTree(array, MOD) results = [] for query in queries: if query[0] == 1: _, x, y = query seg_tree.update(x - 1, y) elif query[0] == 2: _, l, r = query results.append(seg_tree.range_product(l - 1, r)) return results"},{"question":"def max_cards_with_gcd_1(n: int, card_values: List[int]) -> int: You have a deck of n playing cards, each card has a number on it. You can choose any number of cards (including zero) from the deck such that the greatest common divisor (gcd) of the chosen cards is 1. The task is to find the maximum number of cards you can take from the deck such that the gcd of their values is equal to 1. >>> max_cards_with_gcd_1(4, [6, 10, 15, 25]) 2 >>> max_cards_with_gcd_1(1, [5]) 1 >>> max_cards_with_gcd_1(3, [4, 8, 12]) 1 >>> max_cards_with_gcd_1(4, [6, 10, 15, 25]) 2 >>> max_cards_with_gcd_1(5, [2, 3, 5, 7, 11]) 2 >>> max_cards_with_gcd_1(5, [12, 15, 20, 22, 25]) 2","solution":"from math import gcd from functools import reduce def max_cards_with_gcd_1(n, card_values): # Helper function to find gcd of a list of numbers def find_gcd_of_list(lst): return reduce(gcd, lst) # Iterate over all subsets of card values max_count = 0 for i in range(n): for j in range(i+1, n): if gcd(card_values[i], card_values[j]) == 1: max_count = max(max_count, 2) return max_count if max_count > 0 else 1 # At least one card can always be chosen"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the total number of unique paths in a m x n grid from the top-left corner to the bottom-right corner. >>> unique_paths(3, 7) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. # Create a 2D array with m rows and n columns initialized to 1 dp = [[1] * n for _ in range(m)] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"from typing import List, Tuple def analyze_books(data: List[str]) -> Tuple[int, int]: Alex wants to analyze a collection of books. The function calculates: 1. The number of unique genres in the dataset. 2. The range of publication years, which is the difference between the latest and earliest publication year inclusive. >>> analyze_books([\\"book1 1980 science\\", \\"book2 1990 fiction\\", \\"book3 2000 science\\", \\"book4 2010 fiction\\", \\"book5 1985 history\\"]) (3, 30) >>> analyze_books([\\"book1 2000 fiction\\"]) (1, 0) >>> analyze_books([\\"book1 2000 science\\", \\"book2 2000 fiction\\", \\"book3 2000 history\\"]) (3, 0)","solution":"def analyze_books(data): genres = set() years = [] for book in data: title, year, genre = book.split() years.append(int(year)) genres.add(genre) unique_genres_count = len(genres) year_range = max(years) - min(years) return unique_genres_count, year_range"},{"question":"def max_rectangle_area(heights): Calculate the maximum possible area of a rectangle formed by buildings. The input is a list of integers representing the heights of buildings. >>> max_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> max_rectangle_area([5]) 5 >>> max_rectangle_area([3, 3, 3, 3, 3]) 15 >>> max_rectangle_area([5, 4, 3, 2, 1]) 9 >>> max_rectangle_area([1, 2, 3, 4, 5]) 9 >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([]) 0","solution":"def max_rectangle_area(heights): This function takes a list of integers representing the heights of buildings and returns the maximum area of a rectangle formed by the buildings. n = len(heights) if n == 0: return 0 # Create an empty stack. The stack holds indexes of the heights array. # The bars stored in the stack are always in increasing order of heights. stack = [] max_area = 0 # Initialize max area index = 0 while index < n: # If this bar is higher than the bar at the stack top, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with top_of_stack as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with every popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def longest_contiguous_substring(s: str) -> str: Given a string s (1 ≤ |s| ≤ 100), find the longest contiguous substring consisting of the same character and output the character along with the length of this substring. If there are multiple such substrings with the same maximum length, output the character that appears first. >>> longest_contiguous_substring(\\"aaabbccccddee\\") 'c 4' >>> longest_contiguous_substring(\\"a\\") 'a 1' >>> longest_contiguous_substring(\\"abcdef\\") 'a 1' >>> longest_contiguous_substring(\\"aaabbbccc\\") 'a 3' >>> longest_contiguous_substring(\\"aabbcccc\\") 'c 4' >>> longest_contiguous_substring(\\"dddaaae\\") 'd 3' >>> longest_contiguous_substring(\\"aabbbbcc\\") 'b 4' >>> longest_contiguous_substring(\\"aabbcc\\") 'a 2'","solution":"def longest_contiguous_substring(s): Returns the character and the length of the longest contiguous substring of the same character. max_char = s[0] max_length = 1 current_char = s[0] current_length = 1 for i in range(1, len(s)): if s[i] == current_char: current_length += 1 else: if current_length > max_length: max_char = current_char max_length = current_length current_char = s[i] current_length = 1 if current_length > max_length: max_char = current_char max_length = current_length return f\\"{max_char} {max_length}\\""},{"question":"from typing import List def length_of_smallest_substring(s: str) -> int: Given a string s consisting of lowercase English letters, find the length of the smallest substring which contains all unique characters of the string s. >>> length_of_smallest_substring(\\"abac\\") 3 >>> length_of_smallest_substring(\\"aabcbcdbca\\") 4 >>> length_of_smallest_substring(\\"a\\") 1 >>> length_of_smallest_substring(\\"aaaaaa\\") 1 >>> length_of_smallest_substring(\\"abcdef\\") 6 >>> length_of_smallest_substring(\\"cbadef\\") 6 >>> length_of_smallest_substring(\\"abcdefghijklmnopqrstuvwxyz\\" * 1000 + \\"abc\\") 26","solution":"def length_of_smallest_substring(s): Returns the length of the smallest substring which contains all unique characters of the string \`s\`. from collections import defaultdict n = len(s) unique_chars = set(s) required_len = len(unique_chars) min_length = float('inf') left = 0 unique_char_count = defaultdict(int) formed = 0 for right in range(n): unique_char_count[s[right]] += 1 if unique_char_count[s[right]] == 1: formed += 1 while formed == required_len: min_length = min(min_length, right - left + 1) unique_char_count[s[left]] -= 1 if unique_char_count[s[left]] == 0: formed -= 1 left += 1 return min_length"},{"question":"def is_well_balanced(n: int, difficulties: List[int]) -> str: Determines if the given contest is well-balanced. :param n: Integer, number of problems :param difficulties: List of integers representing the difficulty ratings :return: \\"Yes\\" if the contest is well-balanced, otherwise \\"No\\" >>> is_well_balanced(6, [1, 2, 3, 4, 5, 6]) 'Yes' >>> is_well_balanced(4, [2, 4, 6, 8]) 'No'","solution":"def is_well_balanced(n, difficulties): Determines if the given contest is well-balanced. :param n: Integer, number of problems :param difficulties: List of integers representing the difficulty ratings :return: \\"Yes\\" if the contest is well-balanced, otherwise \\"No\\" for i in range(n - 2): segment = difficulties[i:i+3] has_even = any(d % 2 == 0 for d in segment) has_odd = any(d % 2 == 1 for d in segment) if not (has_even and has_odd): return \\"No\\" return \\"Yes\\""},{"question":"def can_transform_to_same(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to transform the array so that all elements are the same by performing any number of the described operations. Args: t: number of test cases test_cases: list of tuples, each containing an integer n (number of elements) and a list of integers (the array elements) Returns: List of strings \\"YES\\" or \\"NO\\" for each test case. >>> can_transform_to_same(2, [(3, [1, 2, 3]), (4, [1, 1, 1, 1])]) ['NO', 'YES'] >>> can_transform_to_same(1, [(5, [5, 5, 5, 5, 5])]) ['YES']","solution":"def can_transform_to_same(t, test_cases): results = [] for case in test_cases: n, arr = case if len(set(arr)) == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_inversions(arr: List[int]) -> int: Counts the number of inversions in the given permutation. An inversion is a pair of indices (i, j) such that 1 ≤ i < j ≤ n and arr[i] > arr[j]. :param arr: List[int] - A list representing the permutation :return: int - The number of inversions in the permutation >>> count_inversions([2, 3, 8, 6, 1]) # 7 inversions >>> count_inversions([1, 2, 3, 4, 5]) # 0 inversions >>> count_inversions([5, 4, 3, 2, 1]) # 10 inversions >>> count_inversions([1]) # 0 inversions >>> count_inversions([1, 2, 4, 3, 5]) # 1 inversion","solution":"def count_inversions(arr): Counts the number of inversions in the given permutation. An inversion is a pair of indices (i, j) such that 1 ≤ i < j ≤ n and arr[i] > arr[j]. :param arr: List[int] - A list representing the permutation :return: int - The number of inversions in the permutation def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid + 1, right) inv_count += merge(arr, temp_arr, left, mid, right) return inv_count def merge(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count n = len(arr) temp_arr = [0]*n return merge_sort(arr, temp_arr, 0, n-1)"},{"question":"from typing import List def length_of_longest_IAP(arr: List[int]) -> int: Find the length of the longest subsequence which is also a valid increasing arithmetic progression. An increasing arithmetic progression is a sequence where the difference between consecutive elements is constant and greater than zero. >>> length_of_longest_IAP([1, 7, 10, 15, 27]) 2 >>> length_of_longest_IAP([3, 6, 9, 12, 15, 18]) 6 def solve(inputs: List[str]) -> List[int]: Function to solve multiple test cases of the problem. Each test case starts with an integer n, the length of the array. The next line contains n space-separated integers representing the array elements a[i]. Returns a list of integers representing the length of the longest increasing arithmetic progression found in the array for each test case. >>> solve([\\"2\\", \\"5\\", \\"1 7 10 15 27\\", \\"6\\", \\"3 6 9 12 15 18\\"]) [2, 6] >>> solve([\\"1\\", \\"5\\", \\"5 10 15 20 25\\"]) [5]","solution":"def length_of_longest_IAP(arr): n = len(arr) if n == 1: return 1 longest = 1 # Create a table to store lengths of longest increasing AP subsequences ending at each pair. L = [{} for i in range(n)] for i in range(n - 1): for j in range(i + 1, n): diff = arr[j] - arr[i] if diff > 0: if diff in L[i]: L[j][diff] = L[i][diff] + 1 else: L[j][diff] = 2 # Minimum length when we find a new difference is 2 longest = max(longest, L[j][diff]) return longest def solve(inputs): t = int(inputs[0]) index = 1 results = [] for _ in range(t): n = int(inputs[index]) arr = list(map(int, inputs[index + 1].split())) results.append(length_of_longest_IAP(arr)) index += 2 return results"},{"question":"def largest_non_adjacent_subset(n: int, heights: List[int], colors: List[int]) -> Tuple[int, int]: Find the largest subset of buildings such that no two buildings in the subset are adjacent and all buildings in the subset are of the same color. >>> largest_non_adjacent_subset(5, [3, 1, 3, 2, 3], [1, 2, 1, 3, 1]) (2, 1) >>> largest_non_adjacent_subset(1, [5], [2]) (1, 2) >>> largest_non_adjacent_subset(3, [5, 4, 5], [2, 2, 2]) (2, 2) >>> largest_non_adjacent_subset(6, [1, 1, 1, 1, 1, 1], [2, 2, 3, 3, 2, 3]) in [(2, 2), (2, 3)] >>> largest_non_adjacent_subset(4, [1, 2, 3, 4], [1, 2, 3, 4]) in [(1, 1), (1, 2), (1, 3), (1, 4)] from typing import List, Tuple","solution":"def largest_non_adjacent_subset(n, heights, colors): from collections import defaultdict # Create a dictionary where key is the color and value is a list of buildings (by index) with that color color_map = defaultdict(list) for index, color in enumerate(colors): color_map[color].append(index) def max_subset_length(bldgs): n = len(bldgs) if n == 0: return 0 if n == 1: return 1 # Dynamic programming to find the maximum subset length dp = [0] * n dp[0] = 1 dp[1] = max(1, 1) # since minimum length is 1 and they are non-adjacent for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + 1) return dp[-1] best_length = 0 best_color = -1 for color, bldgs in color_map.items(): longest_length = max_subset_length(bldgs) if longest_length > best_length: best_length = longest_length best_color = color if best_length == 0: return -1 return best_length, best_color"},{"question":"def has_zero_sum_subarray(arr): Returns 'YES' if there exists a subarray with sum zero, otherwise 'NO'. >>> has_zero_sum_subarray([1, 2, -3, 4, 5]) \\"YES\\" >>> has_zero_sum_subarray([1, 2, 3]) \\"NO\\" def check_subarray_with_zero_sum(test_cases): For each test case, determine if there exists a subarray with zero sum and return a list of strings either \\"YES\\" or \\"NO\\" for each test case. >>> check_subarray_with_zero_sum([(5, [1, 2, -3, 4, 5]), (3, [1, 2, 3]), (7, [4, 2, -3, 1, 6, -1, 0])]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def has_zero_sum_subarray(arr): Returns 'YES' if there exists a subarray with sum zero, otherwise 'NO'. prefix_sum = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in prefix_sum: return \\"YES\\" prefix_sum.add(current_sum) return \\"NO\\" def check_subarray_with_zero_sum(test_cases): For each test case, determine if there exists a subarray with zero sum and returns a list of strings either \\"YES\\" or \\"NO\\" for each test case. result = [] for n, arr in test_cases: result.append(has_zero_sum_subarray(arr)) return result"},{"question":"def max_candies_collected(n: int, candies: List[int]) -> int: Returns the maximum number of candies that can be collected from any contiguous sequence of houses. Args: n (int): number of houses candies (List[int]): list of integers representing number of candies in each house Returns: int: maximum number of candies collected >>> max_candies_collected(5, [1, 2, 3, 4, 5]) 15 >>> max_candies_collected(4, [-1, -2, -3, -4]) -1 >>> max_candies_collected(5, [2, -1, 2, 3, -5]) 6 >>> max_candies_collected(1, [10]) 10 >>> max_candies_collected(6, [1, -2, 3, 4, -1, 2]) 8 >>> max_candies_collected(0, []) 0 >>> max_candies_collected(4, [0, 0, 0, 0]) 0 >>> max_candies_collected(3, [-1, -1, -2]) -1 >>> max_candies_collected(3, [-1, 3, 4]) 7 pass","solution":"def max_candies_collected(n, candies): Returns the maximum number of candies that can be collected from any contiguous sequence of houses. if n == 0: return 0 current_sum = max_sum = candies[0] for i in range(1, n): current_sum = max(candies[i], current_sum + candies[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_minimum_special_edge(n: int, m: int, k: int, special_nodes: List[int], edges: List[Tuple[int, int, int]]) -> int: Find the minimum weight of an edge connecting a special node to a non-special node. Parameters: - n: number of nodes in the graph. - m: number of edges in the graph. - k: number of special nodes. - special_nodes: list of special nodes. - edges: list of edges, where each edge is represented as (u, v, w). Returns: - Minimum weight of an edge connecting a special node to a non-special node, or -1 if no such edge exists. Examples: >>> find_minimum_special_edge(5, 5, 2, [1, 2], [(1, 3, 4), (1, 4, 8), (2, 4, 7), (3, 5, 6), (4, 5, 1)]) 4 >>> find_minimum_special_edge(4, 3, 1, [1], [(2, 3, 5), (3, 4, 6), (4, 2, 2)]) -1","solution":"def find_minimum_special_edge(n, m, k, special_nodes, edges): Find the minimum weight of an edge connecting a special node to a non-special node. Parameters: - n: number of nodes in the graph. - m: number of edges in the graph. - k: number of special nodes. - special_nodes: list of special nodes. - edges: list of edges, where each edge is represented as (u, v, w). Returns: - Minimum weight of an edge connecting a special node to a non-special node, or -1 if no such edge exists. special_set = set(special_nodes) min_weight = float('inf') for u, v, w in edges: if (u in special_set and v not in special_set) or (v in special_set and u not in special_set): min_weight = min(min_weight, w) return min_weight if min_weight != float('inf') else -1"},{"question":"from typing import List from functools import reduce from math import gcd def max_sum_subsequence_with_gcd_one(array: List[int]) -> int: Given an array of integers, find the maximum possible sum of elements of a non-empty subsequence such that the greatest common divisor (GCD) of the elements in the subsequence is equal to 1. >>> max_sum_subsequence_with_gcd_one([3, 6, 2, 7, 5]) 18 >>> max_sum_subsequence_with_gcd_one([4, 6, 8]) -1 >>> max_sum_subsequence_with_gcd_one([1, 2, 3, 4]) 10 import pytest def test_example_1(): assert max_sum_subsequence_with_gcd_one([3, 6, 2, 7, 5]) == 18 def test_example_2(): assert max_sum_subsequence_with_gcd_one([4, 6, 8]) == -1 def test_example_3(): assert max_sum_subsequence_with_gcd_one([1, 2, 3, 4]) == 10 def test_single_element_1(): assert max_sum_subsequence_with_gcd_one([1]) == 1 def test_single_element_2(): assert max_sum_subsequence_with_gcd_one([4]) == -1 def test_all_elements_gcd_1(): assert max_sum_subsequence_with_gcd_one([2, 3, 5, 7, 11]) == 28 def test_all_same_elements(): assert max_sum_subsequence_with_gcd_one([9, 9, 9, 9]) == -1 def test_large_array(): assert max_sum_subsequence_with_gcd_one([10**4] * 10**5) == -1 def test_large_array_with_gcd_1_elements(): array = [i for i in range(1, 10**5 + 1)] assert max_sum_subsequence_with_gcd_one(array) == sum(array)","solution":"from math import gcd from functools import reduce def max_sum_subsequence_with_gcd_one(array): def find_gcd_of_list(lst): return reduce(gcd, lst) # Check if the GCD of the entire array is 1 if find_gcd_of_list(array) == 1: return sum(array) else: return -1"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: You are given a two-dimensional grid of n x m cells. Each cell contains either a 1 or a 0. Your task is to find the largest sub-grid that contains only 1s. >>> maximalRectangle([[1, 1, 0, 1, 1], [1, 1, 1, 1, 0], [0, 1, 1, 1, 1], [1, 0, 1, 1, 1]]) 6 >>> maximalRectangle([[1, 1, 1, 1]]) 4 >>> maximalRectangle([[1], [1], [0], [1]]) 2 >>> maximalRectangle([]) 0 >>> maximalRectangle([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> maximalRectangle([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 n, m = len(matrix), len(matrix[0]) heights = [0] * (m + 1) for i in range(n): for j in range(m): if matrix[i][j] == 1: heights[j] += 1 else: heights[j] = 0 stack = [-1] for k in range(m + 1): while heights[k] < heights[stack[-1]]: h = heights[stack.pop()] w = k - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(k) return max_area"},{"question":"def min_operations_to_sort(arr: List[int]) -> int: Determines the minimum number of contiguous subarray reverses required to sort the array in non-decreasing order. :param arr: List[int] - List of integers to sort :return: int - Minimum number of operations required >>> min_operations_to_sort([1, 2, 3, 4]) == 0 >>> min_operations_to_sort([1, 3, 2, 4, 5]) == 1 >>> min_operations_to_sort([5, 4, 3, 2, 1]) == 1 >>> min_operations_to_sort([4, 3, 1, 2]) == 2 >>> min_operations_to_sort([1]) == 0 >>> min_operations_to_sort([4, 3, 1, 2, 5]) == 2 >>> min_operations_to_sort([1, 1, 2, 2, 3, 3]) == 0 >>> min_operations_to_sort([3, 1, 2, 2, 1]) == 2","solution":"def min_operations_to_sort(arr): Determines the minimum number of contiguous subarray reverses required to sort the array in non-decreasing order. :param arr: List[int] - List of integers to sort :return: int - Minimum number of operations required n = len(arr) if arr == sorted(arr): return 0 sorted_arr = sorted(arr) l, r = 0, n-1 while arr[l] == sorted_arr[l]: l += 1 while arr[r] == sorted_arr[r]: r -= 1 if arr[l:r+1][::-1] == sorted_arr[l:r+1]: return 1 return 2"},{"question":"def min_moves_to_partition(n: int, k: int) -> int: Calculate the minimum number of moves required to partition the shelf into k sections of consecutively identified books. Parameters: n (int): The number of books on the shelf. k (int): The number of sections. Returns: int: The minimum number of moves required. >>> min_moves_to_partition(5, 3) 2 >>> min_moves_to_partition(1, 1) 0","solution":"def min_moves_to_partition(n, k): Calculate the minimum number of moves required to partition the shelf into k sections of consecutively identified books. Parameters: n (int): The number of books on the shelf. k (int): The number of sections. Returns: int: The minimum number of moves required. # The minimum moves required is the number of gaps we need, which is (k - 1). return k - 1"},{"question":"def min_sprinklers_needed(n: int, strip: str) -> int: Returns the minimum number of sprinklers needed to cover sections with flowers. >>> min_sprinklers_needed(7, \\"1001001\\") 3 >>> min_sprinklers_needed(5, \\"11111\\") 2 >>> min_sprinklers_needed(5, \\"00000\\") 0 >>> min_sprinklers_needed(1, \\"1\\") 1 >>> min_sprinklers_needed(1, \\"0\\") 0 >>> min_sprinklers_needed(5, \\"10001\\") 2 >>> min_sprinklers_needed(5, \\"10010\\") 2","solution":"def min_sprinklers_needed(n, strip): Returns the minimum number of sprinklers needed to cover sections with flowers. sprinklers_needed = 0 i = 0 while i < n: if strip[i] == '1': sprinklers_needed += 1 i += 3 # move to the section that is beyond the reach of the current sprinkler else: i += 1 # move to the next section return sprinklers_needed"},{"question":"def minimum_cost_to_make_arrays_identical(n: int, array1: list[int], array2: list[int]) -> int: Returns the minimum cost to make the two arrays identical. Parameters: n (int): The length of both arrays. array1 (list of int): The first array of integers. array2 (list of int): The second array of integers. Returns: int: The minimum cost to make the arrays identical. >>> minimum_cost_to_make_arrays_identical(2, [1, 3], [1, 7]) 4 >>> minimum_cost_to_make_arrays_identical(2, [5, 8], [4, 5]) 4 >>> minimum_cost_to_make_arrays_identical(3, [1, 2, 3], [1, 2, 3]) 0 >>> minimum_cost_to_make_arrays_identical(1, [5], [10]) 5 >>> minimum_cost_to_make_arrays_identical(3, [1000, 900, 800], [1000, 700, 600]) 400 >>> minimum_cost_to_make_arrays_identical(100, [i for i in range(1, 101)], [i for i in range(1, 101)]) 0","solution":"def minimum_cost_to_make_arrays_identical(n, array1, array2): Returns the minimum cost to make the two arrays identical. Parameters: n (int): The length of both arrays. array1 (list of int): The first array of integers. array2 (list of int): The second array of integers. Returns: int: The minimum cost to make the arrays identical. total_cost = 0 for a, b in zip(array1, array2): total_cost += abs(a - b) return total_cost"},{"question":"def can_form_power_of_2(s: str) -> str: Given a string s representing a non-negative integer, check if the digits of the number can be rearranged to form a power of 2. If such a rearrangement is possible, return \\"YES\\". Otherwise, return \\"NO\\". >>> can_form_power_of_2('821') == \\"YES\\" True >>> can_form_power_of_2('12345') == \\"NO\\" True","solution":"def can_form_power_of_2(s): Returns \\"YES\\" if the digits of the number represented by string s can be rearranged to form a power of 2. Otherwise, returns \\"NO\\". from itertools import permutations num_set = set(''.join(p) for p in permutations(s) if p[0] != '0') def is_power_of_2(n): return (n & (n - 1)) == 0 for num in num_set: if is_power_of_2(int(num)): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple from collections import defaultdict def calculate_subtree_sizes(n: int, edges: List[Tuple[int, int]]) -> List[int]: You are given a tree with n vertices rooted at vertex 1. For every vertex, if it has children, it will be denoted by a list of its children’s indices. You need to calculate the size of the subtree for each vertex. Parameters: n (int): the number of vertices in the tree. edges (List[Tuple[int, int]]): list of edges where each edge is represented as a tuple (u, v) indicating there is an edge between vertex u and vertex v. Returns: List[int]: a list of n integers where the i-th integer is the size of the subtree rooted at vertex i. Example: >>> calculate_subtree_sizes(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) [7, 3, 3, 1, 1, 1, 1] from solution import calculate_subtree_sizes def test_small_tree(): edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] result = calculate_subtree_sizes(7, edges) assert result == [7, 3, 3, 1, 1, 1, 1] def test_single_node_tree(): edges = [] result = calculate_subtree_sizes(1, edges) assert result == [1] def test_line_tree(): edges = [(1, 2), (2, 3), (3, 4)] result = calculate_subtree_sizes(4, edges) assert result == [4, 3, 2, 1] def test_balanced_tree(): edges = [(1, 2), (1, 3), (2, 4), (2, 5)] result = calculate_subtree_sizes(5, edges) assert result == [5, 3, 1, 1, 1] def test_unbalanced_tree(): edges = [(1, 2), (2, 3), (2, 4), (4, 5)] result = calculate_subtree_sizes(5, edges) assert result == [5, 4, 1, 2, 1]","solution":"from collections import defaultdict def calculate_subtree_sizes(n, edges): def dfs(node, parent): size = 1 for neighbor in tree[node]: if neighbor != parent: size += dfs(neighbor, node) subtree_sizes[node] = size return size tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) subtree_sizes = [0] * (n + 1) dfs(1, -1) return subtree_sizes[1:] # Example usage: edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] print(calculate_subtree_sizes(7, edges)) # Output: [7, 3, 3, 1, 1, 1, 1]"},{"question":"def max_non_overlapping_tasks(tasks: List[List[int]]) -> int: Returns the maximum number of non-overlapping tasks. Each task is represented by a pair of integers [start, end]. >>> max_non_overlapping_tasks([[1, 4], [2, 3], [3, 5], [6, 8]]) 3 >>> max_non_overlapping_tasks([[1, 2]]) 1 >>> max_non_overlapping_tasks([[1, 2], [3, 4], [5, 6]]) 3 >>> max_non_overlapping_tasks([[1, 4], [2, 5], [3, 6]]) 1 >>> max_non_overlapping_tasks([[1, 3], [2, 4], [3, 5], [6, 8], [7, 9]]) 3","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks. Each task is represented by a pair of integers [start, end]. # Sort tasks by their end time tasks.sort(key=lambda x: x[1]) # Initialize count of non-overlapping tasks count = 0 end_time = 0 for task in tasks: if task[0] >= end_time: count += 1 end_time = task[1] return count # Example usage: # tasks = [[1, 4], [2, 3], [3, 5], [6, 8]] # print(max_non_overlapping_tasks(tasks)) # Output: 3"},{"question":"def compute_total_waste(S: List[int], L: List[int]) -> int: Compute the total waste produced by cutting each rod in L to yield segments of lengths specified in S. Parameters: S (list of int): Segment lengths. L (list of int): Rod lengths. Returns: int: Total waste produced. Examples: >>> compute_total_waste([2, 3], [7, 8]) 1 >>> compute_total_waste([3], [7]) 1 >>> compute_total_waste([4], [8, 16, 24]) 0","solution":"def compute_total_waste(S, L): Compute the total waste produced by cutting each rod in L to yield segments of lengths specified in S. Parameters: S (list of int): Segment lengths. L (list of int): Rod lengths. Returns: int: Total waste produced. total_waste = 0 for length in L: min_waste = min(length % segment for segment in S) total_waste += min_waste return total_waste"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head: ListNode) -> ListNode: Detect whether there is a cycle in the linked list and return the starting node of the cycle. >>> head = ListNode(3) >>> head.next = ListNode(2) >>> head.next.next = ListNode(0) >>> head.next.next.next = ListNode(-4) >>> head.next.next.next.next = head.next # Creating a cycle >>> detect_cycle(head) == head.next True >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = head # Creating a cycle >>> detect_cycle(head) == head True >>> head = ListNode(1) >>> detect_cycle(head) is None True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): if not head or not head.next: return None slow = head fast = head # Find the meeting point in the cycle, if it exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle exists, return None if not fast or not fast.next: return None # Move slow to head. Both pointers move one step at a time to find the cycle start point slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def count_inversions(arr: List[int]) -> int: Count the number of inversions in a sequence of integers. An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j]. >>> count_inversions([2, 3, 8, 6, 1]) 5 >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([5, 4, 3, 2, 1]) 10","solution":"def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all the remaining elements in the left # subarray (arr[i]...arr[mid]) are all greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def count_inversions(arr): temp_arr = [0]*len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)"},{"question":"def longest_increasing_subarray_length(n: int, b: List[int]) -> int: Returns the length of the longest increasing subarray. The function takes as input the length of the array \`n\` and the array \`b\`, and returns the length of the longest increasing subarray. >>> longest_increasing_subarray_length(6, [1, 2, 3, 2, 3, 4]) 3 >>> longest_increasing_subarray_length(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray_length(0, []) 0 >>> longest_increasing_subarray_length(1, [1]) 1 >>> longest_increasing_subarray_length(2, [1, 2]) 2 >>> longest_increasing_subarray_length(2, [2, 1]) 1 >>> longest_increasing_subarray_length(7, [1, 2, 3, 4, 1, 2, 3]) 4 >>> longest_increasing_subarray_length(5, [2, 2, 2, 2, 2]) 1 >>> longest_increasing_subarray_length(6, [1, 2, 3, 4, 5, 6]) 6","solution":"def longest_increasing_subarray_length(n, b): Returns the length of the longest increasing subarray. n: int - the length of array b b: list of int - the array b if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if b[i] > b[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def count_lakes(n: int, m: int, grid: List[List[str]]) -> int: Count the number of lakes in a given grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[str]]): The grid representation where '.' is land and '*' is lake. Returns: int: The number of lakes in the grid. Examples: >>> count_lakes(4, 5, [\\"*.*..\\", \\".*.*.\\", \\".....\\", \\".....\\"]) 2 >>> count_lakes(3, 3, [\\"***\\", \\"***\\", \\"***\\"]) 1 pass # Implement the function here from typing import List def test_example_1(): grid = [ \\".*...\\", \\".*..*\\", \\"..*..\\", \\"..*..\\" ] assert count_lakes(4, 5, [list(row) for row in grid]) == 2 def test_single_lake(): grid = [ \\"***\\", \\"***\\", \\"***\\" ] assert count_lakes(3, 3, [list(row) for row in grid]) == 1 def test_no_lake(): grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert count_lakes(3, 3, [list(row) for row in grid]) == 0 def test_disconnected_lakes(): grid = [ \\"*.*\\", \\"...\\", \\"*.*\\" ] assert count_lakes(3, 3, [list(row) for row in grid]) == 4 def test_large_grid(): grid = [ \\"........\\", \\"..*.....\\", \\"........\\", \\".....*..\\", \\".*......\\", \\"........\\", \\"........\\", ] assert count_lakes(7, 8, [list(row) for row in grid]) == 3","solution":"def count_lakes(n, m, grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != '*': return grid[x][y] = '.' # Mark as visited by changing '*' to '.' for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]: dfs(x + dx, y + dy) lakes_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '*': dfs(i, j) lakes_count += 1 return lakes_count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] offset = 2 for i in range(n): grid.append(list(data[offset + i])) print(count_lakes(n, m, grid))"},{"question":"def can_form_arithmetic_progression(arr): Determines if the elements of the array can be rearranged to form an arithmetic progression. :param arr: List of integers :return: \\"YES\\" if they can be rearranged, otherwise \\"NO\\" def test_example_case(): assert can_form_arithmetic_progression([3, 5, 1, 7, 9]) == \\"YES\\" def test_single_element(): assert can_form_arithmetic_progression([5]) == \\"YES\\" def test_two_elements(): assert can_form_arithmetic_progression([5, 10]) == \\"YES\\" assert can_form_arithmetic_progression([10, 5]) == \\"YES\\" def test_no_arithmetic_progression(): assert can_form_arithmetic_progression([1, 2, 4]) == \\"NO\\" assert can_form_arithmetic_progression([10, 5, 1]) == \\"NO\\" def test_large_common_difference(): assert can_form_arithmetic_progression([1000000000, 500000000, 0]) == \\"YES\\" def test_negative_numbers(): assert can_form_arithmetic_progression([-1, -3, -5, -7]) == \\"YES\\" assert can_form_arithmetic_progression([-1, -3, -6]) == \\"NO\\" def test_mixed_numbers(): assert can_form_arithmetic_progression([-5, 0, 5, 10, 15]) == \\"YES\\" assert can_form_arithmetic_progression([-5, 0, 6, 10, 15]) == \\"NO\\"","solution":"def can_form_arithmetic_progression(arr): Determines if the elements of the array can be rearranged to form an arithmetic progression. :param arr: List of integers :return: \\"YES\\" if they can be rearranged, otherwise \\"NO\\" if len(arr) <= 1: return \\"YES\\" arr.sort() common_diff = arr[1] - arr[0] for i in range(1, len(arr)): if arr[i] - arr[i - 1] != common_diff: return \\"NO\\" return \\"YES\\""},{"question":"def has_even_sum_pair(n: int, arr: List[int]) -> str: Determines if there is a pair of distinct elements in the list such that their sum is an even number. Parameters: n (int): The number of elements in the list. arr (list of int): The list of integers. Returns: str: \\"YES\\" if there is such a pair, otherwise \\"NO\\". >>> has_even_sum_pair(5, [1, 3, 4, 5, 6]) \\"YES\\" >>> has_even_sum_pair(3, [1, 2, 5]) \\"NO\\"","solution":"def has_even_sum_pair(n, arr): Determines if there is a pair of distinct elements in the list such that their sum is an even number. Parameters: n (int): The number of elements in the list. arr (list of int): The list of integers. Returns: str: \\"YES\\" if there is such a pair, otherwise \\"NO\\". odd_count = sum(1 for x in arr if x % 2 != 0) even_count = n - odd_count if odd_count >= 1 and even_count >= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def is_consecutive_identifiers(employee_data: List[Tuple[int, int]]) -> bool: Determine if all departments have consecutive identifiers for their employees. Args: employee_data (List[Tuple[int, int]]): A list of tuples where each tuple consists of two integers. The first integer is the employee ID, and the second integer is the department ID. Returns: bool: True if all departments have consecutive identifiers, False otherwise. Example: >>> is_consecutive_identifiers([(1, 2), (2, 2), (1, 3), (2, 3), (3, 3)]) True >>> is_consecutive_identifiers([(1, 1), (2, 1), (3, 1), (5, 1)]) False >>> is_consecutive_identifiers([(1, 4), (3, 4), (2, 4)]) True","solution":"from typing import List, Tuple def is_consecutive_identifiers(employee_data: List[Tuple[int, int]]) -> bool: from collections import defaultdict departments = defaultdict(list) for emp_id, dep_id in employee_data: departments[dep_id].append(emp_id) for emp_ids in departments.values(): emp_ids.sort() for i in range(1, len(emp_ids)): if emp_ids[i] != emp_ids[i - 1] + 1: return False return True"},{"question":"def minimum_lamps(l: int, d: int) -> int: Calculate the minimum number of lamps required to fully illuminate the street. Parameters: l (int): length of the street in meters (1 ≤ l ≤ 10^9) d (int): maximum distance each lamp can illuminate on both sides (1 ≤ d ≤ 10^9) Returns: int: the minimum number of lamps required >>> minimum_lamps(14, 3) == 3 >>> minimum_lamps(20, 5) == 2 >>> minimum_lamps(19, 5) == 2 >>> minimum_lamps(1, 1) == 1 >>> minimum_lamps(10, 5) == 1 >>> minimum_lamps(1000000000, 500000000) == 1 >>> minimum_lamps(10, 2) == 3 >>> minimum_lamps(13, 3) == 3 >>> minimum_lamps(1, 10) == 1 >>> minimum_lamps(10, 3) == 2","solution":"def minimum_lamps(l, d): Calculate the minimum number of lamps required to fully illuminate the street. Parameters: l (int): length of the street in meters (1 ≤ l ≤ 10^9) d (int): maximum distance each lamp can illuminate on both sides (1 ≤ d ≤ 10^9) Returns: int: the minimum number of lamps required # If one lamp can cover a total distance of '2*d' meters # (d meters on both sides from its point of installation) coverage_per_lamp = 2 * d # Calculate minimum number of lamps required if l % coverage_per_lamp == 0: min_lamps = l // coverage_per_lamp else: min_lamps = (l // coverage_per_lamp) + 1 return min_lamps"},{"question":"def shortest_path(N: int, M: int, friendships: list, S: int, T: int) -> int: Determine the shortest path of friendships between two given citizens. Parameters: - N : int : Number of citizens - M : int : Number of friendships - friendships : list of tuple of int : Pairs representing friendships (a, b) - S : int : Start citizen ID - T : int : Target citizen ID Returns: - int : Number of friendships in the shortest path between S and T, or -1 if no path exists pass","solution":"from collections import deque def shortest_path(N, M, friendships, S, T): Determine the shortest path of friendships between two given citizens. Parameters: - N : int : Number of citizens - M : int : Number of friendships - friendships : list of tuple of int : Pairs representing friendships (a, b) - S : int : Start citizen ID - T : int : Target citizen ID Returns: - int : Number of friendships in the shortest path between S and T, or -1 if no path exists # Generate the adjacency list adj_list = {i: [] for i in range(1, N+1)} for a, b in friendships: adj_list[a].append(b) adj_list[b].append(a) # BFS to find shortest path queue = deque([(S, 0)]) visited = set([S]) while queue: current, level = queue.popleft() if current == T: return level for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, level + 1)) return -1"},{"question":"from typing import List def min_difference_between_two_groups(N: int, weights: List[int]) -> int: Distribute items into two groups to minimize the difference between their total weights. >>> min_difference_between_two_groups(5, [2, 3, 7, 1, 5]) 0 >>> min_difference_between_two_groups(1, [1000]) 1000 >>> min_difference_between_two_groups(2, [500, 500]) 0 >>> min_difference_between_two_groups(2, [300, 700]) 400 >>> min_difference_between_two_groups(4, [1, 2, 3, 4]) 0 >>> min_difference_between_two_groups(4, [1, 1, 4, 9]) 3 >>> min_difference_between_two_groups(6, [10, 20, 30, 40, 50, 60]) 10","solution":"def min_difference_between_two_groups(N, weights): total_weight = sum(weights) # DP array to keep track of possible sums dp = [False] * (total_weight + 1) dp[0] = True for weight in weights: for j in range(total_weight, weight - 1, -1): if dp[j - weight]: dp[j] = True min_diff = float('inf') for i in range(total_weight // 2 + 1): if dp[i]: min_diff = min(min_diff, abs((total_weight - i) - i)) return min_diff"},{"question":"def find_min_skill_difference_pairs(n: int, skill_levels: List[int]) -> Union[str, List[Tuple[int, int]]]: Pair up employees such that the maximum difference of skill levels between any pair is minimized. If the number of employees is odd, return \\"IMPOSSIBLE\\". If the number of employees is even, return pairs of employee indices where each pair is represented by a tuple of two integers (1-based). >>> find_min_skill_difference_pairs(4, [1, 5, 3, 9]) [(1, 3), (2, 4)] >>> find_min_skill_difference_pairs(5, [7, 1, 5, 3, 9]) 'IMPOSSIBLE'","solution":"def find_min_skill_difference_pairs(n, skill_levels): if n % 2 != 0: return \\"IMPOSSIBLE\\" indexed_skills = list(enumerate(skill_levels, start=1)) indexed_skills.sort(key=lambda x: x[1]) pairs = [] for i in range(0, n, 2): pairs.append((indexed_skills[i][0], indexed_skills[i + 1][0])) return pairs"},{"question":"def is_subset_sum(arr, n, sum): Determines if there exists a subset of the array \`arr\` of size \`n\` that adds up to \`sum\`. :param arr: List of integers. :param n: Integer, length of the list arr. :param sum: Integer, the target sum. :return: String \\"YES\\" if such subset exists, otherwise \\"NO\\".","solution":"def is_subset_sum(arr, n, sum): Determines if there exists a subset of the array \`arr\` of size \`n\` that adds up to \`sum\`. :param arr: List of integers. :param n: Integer, length of the list arr. :param sum: Integer, the target sum. :return: String \\"YES\\" if such subset exists, otherwise \\"NO\\". dp = [[False for _ in range(sum + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, sum + 1): if j < arr[i - 1]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] return \\"YES\\" if dp[n][sum] else \\"NO\\""},{"question":"def pieces_to_place(n, m, pre_placed_positions): Compute the number of pieces Karl needs to place to complete the puzzle. Parameters: n (int): The number of rows of the puzzle. m (int): The number of columns of the puzzle. pre_placed_positions (list of tuples): The positions of pre-placed pieces. Returns: int: The number of pieces Karl needs to place. >>> pieces_to_place(4, 3, []) 12 >>> pieces_to_place(4, 3, [(1, 2), (3, 3), (4, 1)]) 9 >>> pieces_to_place(1, 1, []) 1 >>> pieces_to_place(1, 1, [(1, 1)]) 0 >>> n, m = 4, 3 >>> pre_placed_positions = [(i, j) for i in range(1, n + 1) for j in range(m + 1)] >>> pieces_to_place(n, m, pre_placed_positions) 0 pass","solution":"def pieces_to_place(n, m, pre_placed_positions): Compute the number of pieces Karl needs to place to complete the puzzle. Parameters: n (int): The number of rows of the puzzle. m (int): The number of columns of the puzzle. pre_placed_positions (list of tuples): The positions of pre-placed pieces. Returns: int: The number of pieces Karl needs to place. # Calculate total number of pieces in the puzzle total_pieces = n * m # Calculate the number of pre-placed pieces k = len(pre_placed_positions) # The number of pieces Karl needs to place return total_pieces - k"},{"question":"def place_guards(p: int, q: int, zones: List[List[int]]) -> Union[str, Tuple[str, List[List[int]]]]: Determines if it's possible to place guards in each city such that no two adjacent cities have guards of the same type. Parameters: p (int): the number of zones q (int): the number of cities per zone zones (List[List[int]]): a list containing p arrays, each with q integers Returns: Union[str, Tuple[str, List[List[int]]]]: \\"IMPOSSIBLE\\" or a tuple with \\"POSSIBLE\\" and a list of guard assignments Example: >>> place_guards(2, 4, [[1, 2, 3, 4], [4, 3, 2, 1]]) (\\"POSSIBLE\\", [[1, 2, 1, 2], [1, 2, 1, 2]]) >>> place_guards(3, 5, [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 3, 5, 2, 4]]) \\"IMPOSSIBLE\\"","solution":"def place_guards(p, q, zones): if q % 2 == 1: return \\"IMPOSSIBLE\\" def guard_arrangement(q): return [(i % 2) + 1 for i in range(q)] guards = [guard_arrangement(q) for _ in range(p)] return \\"POSSIBLE\\", guards # Example execution p = 2 q = 4 zones = [ [1, 2, 3, 4], [4, 3, 2, 1] ] result = place_guards(p, q, zones) print(result)"},{"question":"def min_operations_to_k(n: int, k: int, sequence: List[int]) -> int: Calculate the minimum number of operations required to make all elements in sequence equal to k. If it is not possible, return -1. >>> min_operations_to_k(3, 5, [1, 2, 3]) == 4 >>> min_operations_to_k(3, 10, [1, 1, 1]) == 27 >>> min_operations_to_k(3, 2, [2, 2, 2]) == 0 >>> min_operations_to_k(3, 1, [5, 5, 5]) == -1 >>> min_operations_to_k(1, 1000, [1]) == 999","solution":"def min_operations_to_k(n, k, sequence): This function calculates the minimum number of operations required to make all elements in sequence equal to k. If it is not possible, it returns -1. operations = 0 for i in range(n): while sequence[i] != k: if sequence[i] > k: return -1 # Cannot decrease the numbers with given operations, so it's impossible # If the current element is less than k, we need to increase it sequence[i] += 1 operations += 1 return operations"},{"question":"from typing import List, Union def can_purchase(total_coin_value: int, prices: List[int]) -> Union[int, str]: Determine if the user can purchase any snack exactly with the coins they have inserted. :param total_coin_value: an integer representing the total value of coins inserted :param prices: a list of integers representing the prices of the snacks available :return: the price of the snack the user can purchase, or \\"Not possible\\" if no exact match can be found >>> can_purchase(15, [10, 15, 20, 25, 30]) 15 >>> can_purchase(12, [5, 8, 14, 20]) \\"Not possible\\" >>> can_purchase(25, [25, 50, 75, 100]) 25 >>> can_purchase(50, [1, 2, 3, 4]) \\"Not possible\\" >>> can_purchase(17, [17]) 17 >>> can_purchase(1000, [500, 700, 1000]) 1000 >>> can_purchase(99, [100, 200, 99]) 99","solution":"from typing import List, Union def can_purchase(total_coin_value: int, prices: List[int]) -> Union[int, str]: Determine if the user can purchase any snack exactly with the coins they have inserted. :param total_coin_value: an integer representing the total value of coins inserted :param prices: a list of integers representing the prices of the snacks available :return: the price of the snack the user can purchase, or \\"Not possible\\" if no exact match can be found if total_coin_value in prices: return total_coin_value return \\"Not possible\\""},{"question":"from typing import List def process_queries(n: int, q: int, arr: List[int], queries: List[str]) -> List[int]: Perform a series of update and sum queries on an array of integers. Args: n : int : Number of elements in the array q : int : Number of queries arr : List[int] : Initial array of integers queries : List[str] : List of queries to perform Returns: List[int] : Results of the sum queries >>> process_queries(5, 5, [1, 2, 3, 4, 5], [\\"UPDATE 2 10\\", \\"SUM 1 3\\", \\"SUM 2 5\\", \\"UPDATE 5 20\\", \\"SUM 1 5\\"]) [14, 22, 38] >>> process_queries(3, 1, [1, 2, 3], [\\"SUM 1 3\\"]) [6] The input consists of two integers n and q, representing the number of elements in the array and the number of queries respectively. This is followed by n integers representing the initial array, and q lines containing the queries.","solution":"def process_queries(n, q, arr, queries): results = [] for query in queries: parts = query.split() if parts[0] == 'UPDATE': index = int(parts[1]) - 1 value = int(parts[2]) arr[index] = value elif parts[0] == 'SUM': l = int(parts[1]) - 1 r = int(parts[2]) results.append(sum(arr[l:r])) return results"},{"question":"def count_paths(n: int, grid: List[List[str]]) -> int: Returns the number of distinct paths from (0, 0) to (n-1, n-1) avoiding obstacles. Parameters: n (int): the size of the grid (n x n) grid (list of list of str): the grid representation Returns: int: the number of distinct paths Examples: >>> count_paths(3, [['.', '.', '.'], ['.', 'X', '.'], ['.', '.', '.']]) 2 >>> count_paths(3, [['.', 'X', '.'], ['.', 'X', '.'], ['.', '.', '.']]) 1 >>> count_paths(3, [['.', 'X', '.'], ['.', 'X', '.'], ['X', '.', '.']]) 0","solution":"def count_paths(n, grid): Returns the number of distinct paths from (0, 0) to (n-1, n-1) avoiding obstacles. Parameters: n (int): the size of the grid (n x n) grid (list of list of str): the grid representation Returns: int: the number of distinct paths # If the starting point or ending point is an obstacle, there's no path if grid[0][0] == 'X' or grid[n-1][n-1] == 'X': return 0 # Initialize a dp array with 0's dp = [[0]*n for _ in range(n)] # Start point dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(n): if grid[i][j] == 'X': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def can_transform(s: str, t: str) -> str: Determines if it is possible to transform s into t by making the appropriate replacements. The '?' character in s can be replaced with any single lowercase alphabet, and the '*' character can be replaced with any sequence of lowercase alphabets (including an empty sequence). Args: s (str): the string consisting of lowercase alphabets and special characters ('?', '*') t (str): the string consisting of lowercase alphabets only Returns: str: \\"YES\\" if it is possible to transform s into t, and \\"NO\\" otherwise Examples: >>> can_transform(\\"a?c\\", \\"abc\\") \\"YES\\" >>> can_transform(\\"a*c\\", \\"aaabc\\") \\"YES\\" >>> can_transform(\\"a*d\\", \\"abc\\") \\"NO\\"","solution":"def can_transform(s, t): import re # Convert pattern from s to a regex pattern pattern = s.replace('?', '.').replace('*', '.*') # Check if t matches the entire pattern return \\"YES\\" if re.fullmatch(pattern, t) else \\"NO\\""},{"question":"def max_total_beauty_score(n: int, m: int, beauty_scores: List[int]) -> int: Returns the maximum possible total beauty score for Bibi's garden. :param n: Number of types of flowers :param m: Number of pots :param beauty_scores: List of beauty scores of each type of flower :return: Maximum possible total beauty score >>> max_total_beauty_score(5, 3, [3, 7, 2, 5, 8]) 20 >>> max_total_beauty_score(5, 5, [3, 7, 2, 5, 8]) 25 >>> max_total_beauty_score(1, 5, [10]) 10 >>> max_total_beauty_score(3, 1, [4, 4, 4]) 4 >>> max_total_beauty_score(3, 2, [1, 5, 3]) 8 >>> max_total_beauty_score(4, 4, [10, 9, 8, 7]) 34","solution":"def max_total_beauty_score(n, m, beauty_scores): Returns the maximum possible total beauty score for Bibi's garden. :param n: Number of types of flowers :param m: Number of pots :param beauty_scores: List of beauty scores of each type of flower :return: Maximum possible total beauty score # Sort the beauty scores in descending order to maximize the score beauty_scores.sort(reverse=True) # Since no two adjacent pots can contain the same flower, # we will take the top m different beauty scores. return sum(beauty_scores[:min(n, m)])"},{"question":"def find_triplet(nums: List[int]) -> Optional[Tuple[int, int, int]]: Given an array of integers \`nums\`, determine if there are three distinct indices \`i\`, \`j\`, and \`k\` in the array such that \`nums[i] + nums[j] = nums[k]\`. Returns a triplet \`(i, j, k)\` if such elements exist, otherwise returns \`None\`. >>> find_triplet([1, 2, 3, 4, 5]) (0, 1, 2) >>> find_triplet([2, 3, 5, 7, 11]) (0, 1, 2) >>> find_triplet([1, 2, 4, 8, 16]) None","solution":"def find_triplet(nums): Finds a triplet (i, j, k) such that nums[i] + nums[j] = nums[k] n = len(nums) # Dictionary to store the value and its index value_to_index = {value: index for index, value in enumerate(nums)} for i in range(n): for j in range(i + 1, n): summation = nums[i] + nums[j] if summation in value_to_index: k = value_to_index[summation] if k != i and k != j: return (i, j, k) return None"},{"question":"import heapq def minimum_travel_time(n, m, roads): Find the minimum time required to travel from the first intersection to the last. Args: n (int): The number of intersections. m (int): The number of roads. roads (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and t, describing a road between intersections u and v that takes t time to traverse. Returns: int: The minimum time to travel from the first intersection to the last, or -1 if no valid path exists. Example: >>> minimum_travel_time(4, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 2), (1, 3, 20)]) 17 >>> minimum_travel_time(4, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 20)]) -1","solution":"import heapq def minimum_travel_time(n, m, roads): graph = [[] for _ in range(n+1)] for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) def dijkstra(start, end): min_times = [float('inf')] * (n + 1) min_times[start] = 0 priority_queue = [(0, start)] while priority_queue: current_time, u = heapq.heappop(priority_queue) if current_time > min_times[u]: continue for v, time in graph[u]: new_time = current_time + time if new_time < min_times[v]: min_times[v] = new_time heapq.heappush(priority_queue, (new_time, v)) return min_times[end] if min_times[end] != float('inf') else -1 return dijkstra(1, n)"},{"question":"def rotate_array(arr, k): Shifts the elements of array \`arr\` k positions to the right. Parameters: arr (list): List of integers k (int): Number of positions to shift the array Returns: list: Array after shifting \`k\` positions to the right >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([1, 2], 1) [2, 1] >>> rotate_array([1, 2], 2) [1, 2] >>> rotate_array([1, 2, 3], 5) [2, 3, 1] >>> rotate_array([1], 100) [1] >>> rotate_array([1, 2, 3, 4], 4) [1, 2, 3, 4]","solution":"def rotate_array(arr, k): Shifts the elements of array \`arr\` k positions to the right. Parameters: arr (list): List of integers k (int): Number of positions to shift the array Returns: list: Array after shifting \`k\` positions to the right n = len(arr) k = k % n # Handle cases where k >= n return arr[-k:] + arr[:-k]"},{"question":"import random from typing import List def roll_dice(N: int, M: int) -> List[int]: Simulates the roll of a set of N dice, each with M sides. Parameters: N (int): Number of dice to roll. M (int): Number of faces on each die. Returns: List[int]: List of integers representing the result of each dice roll. >>> len(roll_dice(3, 6)) == 3 True >>> all(1 <= result <= 6 for result in roll_dice(5, 6)) True >>> roll_dice(0, 6) == [] True >>> roll_dice(10, 1) == [1]*10 True","solution":"import random def roll_dice(N, M): Simulates the roll of N dice, each with M sides. Parameters: N (int): Number of dice to roll. M (int): Number of faces on each die. Returns: list: List of integers representing the result of each dice roll. return [random.randint(1, M) for _ in range(N)]"},{"question":"def assign_property_values(n: int, ranges: List[Tuple[int, int]]) -> Tuple[str, List[int]]: Assigns unique property values to each test tube within the specified ranges, ensuring each value remains within its respective range [c_i, d_i] and is distinct from immediate neighbors. :param n: Number of test tubes :param ranges: List of tuples containing (c_i, d_i) for each test tube :return: A tuple (status, values) where status is 'YES' or 'NO' and values is a list of assigned values >>> assign_property_values(3, [(1, 2), (2, 3), (1, 1)]) ('YES', [1, 3, 2]) >>> assign_property_values(2, [(1, 2), (1, 2)]) ('YES', [1, 2]) from solution import assign_property_values def test_assign_property_values_example1(): n = 3 ranges = [(1, 2), (2, 3), (1, 1)] status, values = assign_property_values(n, ranges) assert status == \\"YES\\" assert len(values) == n assert values in [[1, 2, 1], [2, 3, 1]] def test_assign_property_values_example2(): n = 2 ranges = [(1, 2), (1, 2)] status, values = assign_property_values(n, ranges) assert status == \\"YES\\" assert len(values) == n assert values in [[1, 2], [2, 1]] def test_assign_property_values_single_tube(): n = 1 ranges = [(1, 1)] status, values = assign_property_values(n, ranges) assert status == \\"YES\\" assert values == [1] def test_assign_property_values_longer_sequence(): n = 4 ranges = [(1, 5), (2, 3), (4, 5), (1, 2)] status, values = assign_property_values(n, ranges) assert status == \\"YES\\" assert len(values) == n for i in range(n-1): assert values[i] != values[i+1] assert ranges[i][0] <= values[i] <= ranges[i][1]","solution":"def assign_property_values(n, ranges): Assigns unique property values to each test tube within the specified ranges, ensuring each value remains within its respective range [c_i, d_i] and is distinct from immediate neighbors. :param n: Number of test tubes :param ranges: List of tuples containing (c_i, d_i) for each test tube :return: A tuple (status, values) where status is 'YES' or 'NO' and values is a list of assigned values # Initialize the list for the final assigned values result = [0] * n # Start with the smallest value within the range of the first test tube for i in range(n): ci, di = ranges[i] # Try to assign a value within the specified limits assigned = False for val in range(ci, di + 1): # Check if it doesn't conflict with the previous test tube's value if i == 0 or result[i - 1] != val: result[i] = val assigned = True break if not assigned: return \\"NO\\", [] return \\"YES\\", result # Example usage: # n = 3 # ranges = [(1, 2), (2, 3), (1, 1)] # print(assign_property_values(n, ranges))"},{"question":"def find_cut_position(n: int, s: str) -> Union[int, str]: Determine the position to cut the string where one section contains all 'C' and the other section contains all 'D'. Args: n (int): The number of houses. s (str): A string of length n consisting of characters 'C' and 'D'. Returns: Union[int, str]: The 1-based index of the position to cut, or \\"Impossible\\" if such a cut is not possible. Examples: >>> find_cut_position(5, \\"CCCDD\\") 3 >>> find_cut_position(6, \\"CCCDDC\\") \\"Impossible\\"","solution":"def find_cut_position(n, s): This function finds the position where we can divide the town into two contiguous sections: one with all 'C' and the other with all 'D'. # Iterate through the string to find a position where all 'C' are followed by all 'D' for i in range(1, n): if s[:i] == 'C' * i and s[i:] == 'D' * (n - i): return i # If no such position is found, return \\"Impossible\\" return \\"Impossible\\""},{"question":"def min_snow_clearing_passes(n: int, grid: List[str]) -> int: Determine the minimum number of passes required to clear all the obstructions of snow from the streets. >>> min_snow_clearing_passes(4, [ ... \\".#..\\", ... \\"..#.\\", ... \\"..\\", ... \\".#..\\" ... ]) == 3 >>> min_snow_clearing_passes(4, [ ... \\"\\", ... \\"\\", ... \\"\\", ... \\"\\" ... ]) == 4 pass # Unit tests def test_no_snow(): grid = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert min_snow_clearing_passes(4, grid) == 0 def test_full_cross(): grid = [ \\"\\", \\"\\", \\"\\", \\"\\" ] assert min_snow_clearing_passes(4, grid) == 4 def test_one_row_clear(): grid = [ \\"\\", \\"....\\", \\"....\\", \\"....\\" ] assert min_snow_clearing_passes(4, grid) == 1 def test_mixed_grid(): grid = [ \\".#..\\", \\"..#.\\", \\"..\\", \\".#..\\" ] assert min_snow_clearing_passes(4, grid) == 3 def test_one_column_clear(): grid = [ \\"....\\", \\"....\\", \\"....\\", \\"\\" ] assert min_snow_clearing_passes(4, grid) == 1 def test_single_obstruction(): grid = [ \\"....\\", \\"....\\", \\"..#.\\", \\"....\\" ] assert min_snow_clearing_passes(4, grid) == 1","solution":"def min_snow_clearing_passes(n, grid): row_clear = [False] * n col_clear = [False] * n for r in range(n): for c in range(n): if grid[r][c] == '#': row_clear[r] = True col_clear[c] = True row_passes = sum(row_clear) col_passes = sum(col_clear) return min(row_passes, col_passes) # Example usage: # n = 4 # grid = [ # \\".#..\\", # \\"..#.\\", # \\"..\\", # \\".#..\\" # ] # print(min_snow_clearing_passes(n, grid)) # Output: 3"},{"question":"def maximum_excitement_level(n: int, heights: List[int]) -> int: Determines the maximum excitement level for any segment by calculating the maximum difference between the maximum and minimum heights in that segment. >>> maximum_excitement_level(5, [1, 2, 3, 4, 5]) 4 >>> maximum_excitement_level(3, [5, 5, 5]) 0 >>> maximum_excitement_level(6, [7, 3, 1, 8, 4, 2]) 7","solution":"def maximum_excitement_level(n, heights): Determines the maximum excitement level for any segment by calculating the maximum difference between the maximum and minimum heights in that segment. if n == 0: return 0 max_height = max(heights) min_height = min(heights) return max_height - min_height # Read the input values # For testing purpose, we define an example input n = 5 heights = [1, 2, 3, 4, 5] # Calling the function with the input values result = maximum_excitement_level(n, heights) print(result)"},{"question":"def longest_string_after_operations(s: str) -> int: Given a string s, performs the operation of removing two adjacent equal characters any number of times and returns the length of the longest string that can be obtained. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest string that can be obtained. >>> longest_string_after_operations(\\"\\") == 0 >>> longest_string_after_operations(\\"abcdef\\") == 6 >>> longest_string_after_operations(\\"aabbcc\\") == 0 >>> longest_string_after_operations(\\"abbaccdde\\") == 1 >>> longest_string_after_operations(\\"ababababa\\") == 9 >>> longest_string_after_operations(\\"a\\") == 1 >>> longest_string_after_operations(\\"a\\" * 200000) == 0 >>> longest_string_after_operations(\\"ab\\") == 2","solution":"def longest_string_after_operations(s): Given a string s, performs the operation of removing two adjacent equal characters any number of times and returns the length of the longest string that can be obtained. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest string that can be obtained. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def max_efficiency(n: int, k: int, speeds: List[int], weights: List[int]) -> int: Returns the maximum sum of efficiencies by assigning exactly one order to each robot. >>> max_efficiency(3, 5, [2, 3, 4], [1, 2, 3, 4, 5]) 38 >>> max_efficiency(1, 1, [10], [20]) 200 >>> max_efficiency(2, 2, [2, 5], [6, 3]) 36 >>> max_efficiency(2, 5, [7, 8], [1, 1, 1, 1, 1]) 15 >>> max_efficiency(2, 3, [100000, 200000], [150000, 250000, 300000]) 95000000000","solution":"def max_efficiency(n, k, speeds, weights): Returns the maximum sum of efficiencies by assigning exactly one order to each robot. Parameters: n (int): The number of robots. k (int): The number of orders. speeds (list of int): The speeds of the robots. weights (list of int): The weights of the orders. Returns: int: The maximum sum of efficiencies. # Sort robots' speeds in descending order speeds.sort(reverse=True) # Sort orders' weights in descending order weights.sort(reverse=True) # Assign each robot the heaviest remaining order to maximize the efficiency max_efficiency_sum = 0 for i in range(n): max_efficiency_sum += speeds[i] * weights[i] return max_efficiency_sum"},{"question":"def min_meeting_rooms(intervals: List[Tuple[int, int]]) -> int: Find the minimum number of meeting rooms required to schedule all meetings without any overlaps. Args: intervals (List[Tuple[int, int]]): List of tuples where each tuple contains two integers representing the start and end time of a meeting. Returns: int: Minimum number of meeting rooms required. Examples: >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([(0, 30)]) 1 >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(0, 10), (10, 20), (20, 30)]) 1 >>> min_meeting_rooms([(1, 5), (6, 10), (11, 15)]) 1 >>> min_meeting_rooms([(0, 10), (5, 15), (10, 20), (25, 30), (28, 40)]) 2","solution":"def min_meeting_rooms(intervals): if not intervals: return 0 start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) start_pointer = 0 end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(start_times): if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def longest_balanced_subarray(n: int, arr: List[int]) -> int: Find the length of the longest balanced subarray, which contains equal number of even and odd numbers. >>> longest_balanced_subarray(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_balanced_subarray(5, [1, 2, 3, 4, 5]) 4 >>> longest_balanced_subarray(4, [1, 3, 5, 7]) 0","solution":"def longest_balanced_subarray(n, arr): max_length = 0 for i in range(n): even_count = 0 odd_count = 0 for j in range(i, n): if arr[j] % 2 == 0: even_count += 1 else: odd_count += 1 if even_count == odd_count: max_length = max(max_length, j - i + 1) return max_length"},{"question":"def count_valid_park_locations(n: int, grid: List[str]) -> int: Determine the number of valid locations in the city grid where a new park can be placed. A valid location for a new park ('P') is an 'E' cell with no adjacent (up, down, left, or right) 'B' cells. Args: n (int): The size of the city grid. grid (List[str]): The n x n city grid consisting of 'B', 'E', and 'P'. Returns: int: The number of valid locations for a new park. Example: >>> count_valid_park_locations(5, [\\"EEEEE\\", \\"EBBBE\\", \\"EEPEE\\", \\"EEEPE\\", \\"BEEEB\\"]) 7 >>> count_valid_park_locations(3, [\\"EEE\\", \\"EEE\\", \\"EEE\\"]) 9 >>> count_valid_park_locations(3, [\\"BBB\\", \\"BBB\\", \\"BBB\\"]) 0 >>> count_valid_park_locations(3, [\\"BEB\\", \\"EEE\\", \\"BEB\\"]) 1 >>> count_valid_park_locations(3, [\\"PPP\\", \\"PPP\\", \\"PPP\\"]) 0","solution":"def count_valid_park_locations(n, grid): def is_valid_park_location(i, j): if grid[i][j] != 'E': return False if i > 0 and grid[i-1][j] == 'B': return False if i < n-1 and grid[i+1][j] == 'B': return False if j > 0 and grid[i][j-1] == 'B': return False if j < n-1 and grid[i][j+1] == 'B': return False return True valid_count = 0 for i in range(n): for j in range(n): if is_valid_park_location(i, j): valid_count += 1 return valid_count"},{"question":"def min_operations_to_zero_grid(n: int, m: int, grid: List[str]) -> int: Find the minimum number of operations needed to transform the initial grid to a grid where all values are 0. >>> min_operations_to_zero_grid(3, 3, [\\"111\\", \\"101\\", \\"111\\"]) 1 >>> min_operations_to_zero_grid(2, 2, [\\"10\\", \\"11\\"]) 1 >>> min_operations_to_zero_grid(3, 3, [\\"000\\", \\"000\\", \\"000\\"]) 0 >>> min_operations_to_zero_grid(4, 4, [\\"1111\\", \\"1111\\", \\"1111\\", \\"1111\\"]) 1 >>> min_operations_to_zero_grid(1, 5, [\\"10101\\"]) 1 >>> min_operations_to_zero_grid(5, 1, [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"]) 1","solution":"def min_operations_to_zero_grid(n, m, grid): # Check for the presence of '1' in the grid has_one = any('1' in row for row in grid) # If there is no '1' in the grid, no operations are needed. if not has_one: return 0 # If any '1' exists, one operation is always sufficient (to flip the whole grid). return 1"},{"question":"from typing import List def reconstruct_file(packets: List[str], indices: List[int], total_packets: int) -> str: Reconstruct the file from the received packets and their indices. Parameters: packets (List[str]): List of strings representing the received packets. indices (List[int]): List of integers representing the indices of the received packets. total_packets (int): Total number of packets the file was divided into. Returns: str: Reconstructed file with '*' at positions of missing packets. >>> reconstruct_file(['abc', 'def', 'ghi'], [0, 1, 2], 3) 'abcdefghi' >>> reconstruct_file(['def', 'ghi'], [1, 2], 3) '*defghi' >>> reconstruct_file(['abc', 'ghi'], [0, 2], 3) 'abc*ghi' >>> reconstruct_file(['abc', 'def'], [0, 1], 3) 'abcdef*' >>> reconstruct_file([], [], 3) '***' >>> reconstruct_file(['abc'], [0], 3) 'abc**'","solution":"from typing import List def reconstruct_file(packets: List[str], indices: List[int], total_packets: int) -> str: Reconstruct the file from the received packets and their indices. Parameters: packets (List[str]): List of strings representing the received packets. indices (List[int]): List of integers representing the indices of the received packets. total_packets (int): Total number of packets the file was divided into. Returns: str: Reconstructed file with '*' at positions of missing packets. # Initialize the file reconstruction with asterisks for missing packets file_parts = ['*'] * total_packets # Place each packet in the correct index for packet, index in zip(packets, indices): file_parts[index] = packet # Join the parts to form the reconstructed file return ''.join(file_parts)"},{"question":"from typing import List def is_valid_path(grid: List[List[str]], n: int) -> str: Determine if there is a valid path from the top-left cell to the bottom-right cell in an n x n grid. The grid consists of cells that are either free ('.') or blocked ('#'). >>> is_valid_path([ ... ['.', '.', '.', '#'], ... ['.', '#', '.', '.'], ... ['.', '.', '#', '.'], ... ['.', '.', '#', '.'] ... ], 4) \\"YES\\" >>> is_valid_path([ ... ['#', '#', '#', '#'], ... ['#', '.', '#', '#'], ... ['#', '.', '#', '#'], ... ['#', '#', '#', '#'] ... ], 4) \\"NO\\" from solution import is_valid_path def test_is_valid_path_case1(): assert is_valid_path([ ['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '#', '.'] ], 4) == \\"YES\\" def test_is_valid_path_case2(): assert is_valid_path([ ['#', '#', '#', '#'], ['#', '.', '#', '#'], ['#', '.', '#', '#'], ['#', '#', '#', '#'] ], 4) == \\"NO\\" def test_is_valid_path_case3(): assert is_valid_path([ ['.', '#'], ['#', '.'] ], 2) == \\"NO\\" def test_is_valid_path_case4(): assert is_valid_path([ ['.', '.'], ['.', '.'] ], 2) == \\"YES\\" def test_is_valid_path_case5(): assert is_valid_path([ ['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.'] ], 3) == \\"YES\\"","solution":"def is_valid_path(grid, n): def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= n or grid[x][y] == '#' or visited[x][y]: return False if x == n-1 and y == n-1: return True visited[x][y] = True # Move right, left, down, up if (dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1)): return True return False visited = [[False] * n for _ in range(n)] if grid[0][0] == '#' or grid[n-1][n-1] == '#': return \\"NO\\" return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"from typing import List def product_except_self(array: List[int]) -> List[int]: Given an array of integers, returns an array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. Args: array (List[int]): List of integers Returns: List[int]: List of products Example: >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] pass def solve_product_problem(test_cases: List[List[int]]) -> List[List[int]]: results = [] for array in test_cases: results.append(product_except_self(array)) return results","solution":"def product_except_self(array): Given an array of integers, returns an array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. n = len(array) if n == 0: return [] left_products = [1] * n right_products = [1] * n # Compute left products for i in range(1, n): left_products[i] = left_products[i - 1] * array[i - 1] # Compute right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * array[i + 1] # Compute result by multiplying left and right products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result def solve_product_problem(test_cases): results = [] for array in test_cases: results.append(product_except_self(array)) return results"},{"question":"def can_plant_trees(n: int, m: int, k: int, positions: List[Tuple[int, int]]) -> str: Determine if it is possible to plant trees such that no two trees share the same row or column. >>> can_plant_trees(4, 4, 3, [(1, 1), (2, 3), (4, 2)]) \\"YES\\" >>> can_plant_trees(3, 3, 3, [(1, 1), (1, 2), (2, 2)]) \\"NO\\" from typing import List, Tuple # Test cases to validate the solution def test_no_trees(): assert can_plant_trees(5, 5, 0, []) == \\"YES\\" def test_no_conflict(): assert can_plant_trees(4, 4, 3, [(1, 1), (2, 3), (4, 2)]) == \\"YES\\" def test_row_conflict(): assert can_plant_trees(3, 3, 3, [(1, 1), (1, 2), (2, 2)]) == \\"NO\\" def test_column_conflict(): assert can_plant_trees(3, 3, 3, [(1, 1), (2, 1), (3, 1)]) == \\"NO\\" def test_large_grid_no_conflict(): assert can_plant_trees(1000, 1000, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == \\"YES\\" def test_large_grid_with_conflict(): assert can_plant_trees(1000, 1000, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (3, 5)]) == \\"NO\\"","solution":"def can_plant_trees(n, m, k, positions): if k == 0: return \\"YES\\" rows = set() cols = set() for r, c in positions: if r in rows or c in cols: return \\"NO\\" rows.add(r) cols.add(c) return \\"YES\\" # Example usage: n = 4 m = 4 k = 3 positions = [(1, 1), (2, 3), (4, 2)] print(can_plant_trees(n, m, k, positions)) # Output: YES n = 3 m = 3 k = 3 positions = [(1, 1), (1, 2), (2, 2)] print(can_plant_trees(n, m, k, positions)) # Output: NO"},{"question":"def reorganize_books(s: str) -> str: Alicia loves reading books, and she has a collection of books placed on her bookshelf. Each book is represented by a different letter. Alicia has a peculiar way of rearranging the books. She wants to rearrange the books in such a way that no two adjacent books have the same letter. You are given a string \`s\` of length n (1 ≤ n ≤ 500,000), where each character denotes a book on Alicia’s shelf. Your task is to find if it is possible to rearrange the books so that no two adjacent books are the same, and if possible, return any suitable rearrangement. If it is not possible, return an empty string. >>> reorganize_books(\\"aaabb\\") 'ababa' >>> reorganize_books(\\"aaab\\") '' >>> reorganize_books(\\"a\\") 'a' >>> reorganize_books(\\"ab\\") 'ab' >>> reorganize_books(\\"aa\\") '' >>> reorganize_books(\\"aabbcc\\") 'abcabc'","solution":"import heapq from collections import Counter def reorganize_books(s): if not s: return \\"\\" # Count frequency of each character freq = Counter(s) # Create a max heap maxHeap = [(-count, char) for char, count in freq.items()] heapq.heapify(maxHeap) # Previous character details prev_char = None prev_count = 0 # Result list to build the final rearranged string result = [] while maxHeap: count, char = heapq.heappop(maxHeap) result.append(char) # If prev_char still has remaining count, add it back to the heap if prev_char: heapq.heappush(maxHeap, (prev_count, prev_char)) prev_char = None # Update prev_char and prev_count for the current character if count + 1 < 0: # Since count is negative prev_char = char prev_count = count + 1 # Check if the final string has the same length as the original string if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"def longest_subarray_with_two_colors(n: int, colors: List[int]) -> int: Returns the length of the longest subarray with at most two distinct integers from the given list. >>> longest_subarray_with_two_colors(7, [1, 2, 1, 2, 1, 3, 4]) == 5 >>> longest_subarray_with_two_colors(5, [1, 1, 1, 1, 1]) == 5 >>> longest_subarray_with_two_colors(6, [2, 2, 3, 3, 3, 2]) == 6 >>> longest_subarray_with_two_colors(7, [1, 2, 1, 3, 1, 2, 1]) == 3 >>> longest_subarray_with_two_colors(0, []) == 0 >>> longest_subarray_with_two_colors(7, [1000000000, 1000000000, 999999999, 999999999, 1000000000, 1000000000, 1000000000]) == 7","solution":"def longest_subarray_with_two_colors(n, colors): Returns the length of the longest subarray with at most two distinct integers from the given list. n: int - The size of the array colors: list of int - The colors of the banners if n == 0: return 0 left = 0 max_length = 0 color_count = {} for right in range(n): color_count[colors[right]] = color_count.get(colors[right], 0) + 1 while len(color_count) > 2: color_count[colors[left]] -= 1 if color_count[colors[left]] == 0: del color_count[colors[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def largestRectangleArea(heights): Compute the maximum area of a rectangle formed by contiguous walls in the histogram. :param heights: List[int] - an array of integers representing the heights of walls in the city skyline. :return: int - the maximum rectangular area that can be enclosed within the histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([3, 3, 3, 3]) 12 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([0, 1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([1, 3, 2, 1, 2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([0, 0, 0, 0, 0]) 0 # Your code here","solution":"def largestRectangleArea(heights): Compute the maximum area of a rectangle formed by contiguous walls in the histogram. :param heights: List[int] :return: int # Initialize variables max_area = 0 stack = [] index = 0 # Iterate over all bars of the histogram while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update the maximum area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate the area with each popped bar as smallest bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_difficulty_difference(n, k, pieces): Returns the minimum possible difference between the most and least number of pieces in any sequence of k consecutive puzzles. :param n: int, number of puzzles :param k: int, length of the sequence :param pieces: List of integers, number of pieces in each puzzle :return: int, minimum possible difference >>> min_difficulty_difference(6, 3, [10, 12, 10, 7, 5, 22]) == 2 >>> min_difficulty_difference(1, 1, [5]) == 0 >>> min_difficulty_difference(5, 3, [7, 7, 7, 7, 7]) == 0 >>> min_difficulty_difference(5, 2, [10, 8, 6, 4, 2]) == 2 >>> min_difficulty_difference(8, 4, [4, 12, 3, 8, 10, 7, 1, 9]) == 3","solution":"def min_difficulty_difference(n, k, pieces): Returns the minimum possible difference between the most and least number of pieces in any sequence of k consecutive puzzles. :param n: int, number of puzzles :param k: int, length of the sequence :param pieces: List of integers, number of pieces in each puzzle :return: int, minimum possible difference pieces.sort() min_diff = float('inf') for i in range(n - k + 1): current_diff = pieces[i + k - 1] - pieces[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def level_order_traversal(arr: List[int]) -> List[List[int]]: Reconstruct the binary tree from the given compressed form and perform a level-order traversal. >>> level_order_traversal([1, 2, 3, -1, 4, 5, 6, -1, -1, 7, -1, -1]) [[1], [2, 3], [4, 5, 6], [7]] >>> level_order_traversal([1, -1, 2, -1, 3, -1, 4]) [[1], [2], [3], [4]] >>> level_order_traversal([1, 2, -1, 3, -1, 4, -1]) [[1], [2], [3], [4]] >>> level_order_traversal([1, 2, 3, 4, 5, 6, 7]) [[1], [2, 3], [4, 5, 6, 7]] >>> level_order_traversal([]) [] >>> level_order_traversal([1, -1]) [[1]]","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(arr: List[int]) -> Optional[TreeNode]: if not arr or arr[0] == -1: return None root = TreeNode(arr[0]) queue = deque([root]) i = 1 while i < len(arr): current = queue.popleft() if i < len(arr) and arr[i] != -1: current.left = TreeNode(arr[i]) queue.append(current.left) i += 1 if i < len(arr) and arr[i] != -1: current.right = TreeNode(arr[i]) queue.append(current.right) i += 1 return root def level_order_traversal(arr: List[int]) -> List[List[int]]: root = buildTree(arr) if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result # Sample execution arr = [1, 2, 3, -1, 4, 5, 6, -1, -1, 7, -1, -1] print(level_order_traversal(arr)) # Expected output: [[1], [2, 3], [4, 5, 6], [7]]"},{"question":"from typing import List def max_flowers(n: int, flowers: List[int], fences: str) -> int: Find the maximum number of flowers that can be collected in a sequence without crossing any fences. >>> max_flowers(6, [4, 5, 0, 9, 2, 3], \\"OXXOXO\\") 9 >>> max_flowers(1, [10], \\"O\\") 10 >>> max_flowers(2, [1, 2], \\"XX\\") 0 >>> max_flowers(3, [7, 7, 7], \\"OOO\\") 21 >>> max_flowers(5, [2, 3, 4, 5, 1], \\"XOXOX\\") 5 >>> max_flowers(5, [0, 0, 0, 0, 0], \\"OOOOO\\") 0","solution":"def max_flowers(n, flowers, fences): max_flowers_collected = 0 current_flowers = 0 for i in range(n): if fences[i] == 'O': current_flowers += flowers[i] else: max_flowers_collected = max(max_flowers_collected, current_flowers) current_flowers = 0 # check last segment max_flowers_collected = max(max_flowers_collected, current_flowers) return max_flowers_collected"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, u: int, v: int, edges: List[Tuple[int, int, int]]) -> int: Finds the shortest path from a starting location to a destination location in a cave system. Parameters: n (int): Number of locations. m (int): Number of tunnels. u (int): Starting location. v (int): Destination location. edges (List[Tuple[int, int, int]]): List of tunnels where each tunnel is represented by a tuple (a, b, c) with a and b being locations and c being travel cost. Returns: int: Minimum travel cost from location u to location v. If no path exists, returns -1. Example: >>> shortest_path(5, 6, 1, 5, [(1, 2, 3), (1, 3, 10), (2, 3, 1), (2, 4, 2), (3, 5, 6), (4, 5, 1)]) 6 def test_shortest_path_case_1(): n = 5 m = 6 u = 1 v = 5 edges = [ (1, 2, 3), (1, 3, 10), (2, 3, 1), (2, 4, 2), (3, 5, 6), (4, 5, 1) ] assert shortest_path(n, m, u, v, edges) == 6 def test_shortest_path_no_path(): n = 3 m = 2 u = 1 v = 3 edges = [ (1, 2, 2), (2, 3, 2) ] assert shortest_path(n, m, u, v, edges) == 4 def test_shortest_path_disconnected_graph(): n = 4 m = 2 u = 1 v = 4 edges = [ (1, 2, 3), (3, 4, 5) ] assert shortest_path(n, m, u, v, edges) == -1 def test_shortest_path_single_node(): n = 2 m = 1 u = 1 v = 2 edges = [ (1, 2, 5) ] assert shortest_path(n, m, u, v, edges) == 5 def test_shortest_path_multiple_paths(): n = 4 m = 4 u = 1 v = 4 edges = [ (1, 2, 1), (1, 3, 4), (2, 4, 2), (3, 4, 3) ] assert shortest_path(n, m, u, v, edges) == 3","solution":"import heapq import sys def shortest_path(n, m, u, v, edges): graph = [[] for _ in range(n + 1)] for a, b, c in edges: graph[a].append((b, c)) graph[b].append((a, c)) INF = float('inf') distance = [INF] * (n + 1) distance[u] = 0 priority_queue = [(0, u)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distance[current_node]: continue for neighbor, weight in graph[current_node]: distance_through_u = current_distance + weight if distance_through_u < distance[neighbor]: distance[neighbor] = distance_through_u heapq.heappush(priority_queue, (distance_through_u, neighbor)) return distance[v] if distance[v] != INF else -1"},{"question":"from typing import List, Tuple def find_top_sender(n: int, requests: List[Tuple[int, int]]) -> int: Determine the user who has sent the maximum number of friend requests during a given period. If there are multiple users with the same maximum number of friend requests sent, return the smallest user ID among them. Parameters: n (int): Total number of users in the network. requests (List[Tuple[int, int]]): List of tuples where each tuple (sender, receiver) represents a friend request sent from sender to receiver. Returns: int: User ID who has sent the most friend requests. >>> find_top_sender(5, [(1, 2), (3, 2), (1, 4), (2, 3), (1, 5), (3, 4)]) 1 >>> find_top_sender(3, [(1, 2), (2, 1), (3, 1), (3, 2)]) 3","solution":"from typing import List, Tuple def find_top_sender(n: int, requests: List[Tuple[int, int]]) -> int: # Dictionary to store the count of requests sent by each user sent_request_count = {} # Count the number of requests for each sender for sender, _ in requests: if sender in sent_request_count: sent_request_count[sender] += 1 else: sent_request_count[sender] = 1 # Find the user with the maximum number of requests sent max_requests = 0 top_sender = float('inf') for user, count in sent_request_count.items(): if count > max_requests or (count == max_requests and user < top_sender): max_requests = count top_sender = user return top_sender"},{"question":"def warehouse_query(n, stacks_data, q, queries): In a large warehouse, there are several stacks of boxes. Each stack is defined by its height, and each box in a stack has a unique identifier. The warehouse manager needs a way to efficiently query the total height of boxes with specific identifiers across multiple stacks. Each query specifies a list of box identifiers, and the manager wants to know the combined height of these boxes. :param n: Number of stacks :param stacks_data: List of stacks where each stack contains the number of boxes followed by pairs of height and identifier for each box :param q: Number of queries :param queries: List of queries where each query contains the number of identifiers followed by the list of box identifiers to be queried :return: List of total heights for each query >>> n = 3 >>> stacks_data = [[2, 2, 102, 5, 101], [3, 1, 104, 6, 102, 4, 105], [2, 1, 101, 3, 103]] >>> q = 2 >>> queries = [[101, 102], [104]] >>> warehouse_query(n, stacks_data, q, queries) [14, 1] from solution import warehouse_query def test_single_stack_single_query(): n = 1 stacks_data = [ [2, 2, 102, 5, 101] ] q = 1 queries = [ [101, 102] ] assert warehouse_query(n, stacks_data, q, queries) == [7] def test_multiple_stacks_single_query(): n = 2 stacks_data = [ [2, 2, 102, 5, 101], [1, 1, 103] ] q = 1 queries = [ [101, 102, 103] ] assert warehouse_query(n, stacks_data, q, queries) == [8] def test_multiple_stacks_multiple_queries(): n = 3 stacks_data = [ [2, 2, 102, 5, 101], [3, 1, 104, 6, 102, 4, 105], [2, 1, 101, 3, 103] ] q = 2 queries = [ [101, 102], [104] ] assert warehouse_query(n, stacks_data, q, queries) == [14, 1] def test_single_query_zero_result(): n = 2 stacks_data = [ [2, 2, 102, 5, 101], [3, 1, 104, 6, 102, 4, 105] ] q = 1 queries = [ [999] ] assert warehouse_query(n, stacks_data, q, queries) == [0] def test_large_number_of_queries(): n = 3 stacks_data = [ [2, 2, 102, 5, 101], [3, 1, 104, 6, 102, 4, 105], [2, 1, 101, 3, 103] ] q = 5 queries = [ [104], [102], [101], [103], [105] ] assert warehouse_query(n, stacks_data, q, queries) == [1, 8, 6, 3, 4]","solution":"def warehouse_query(n, stacks_data, q, queries): box_heights = {} # Read the box data for stack in stacks_data: m = stack[0] for i in range(1, 2 * m, 2): height = stack[i] box_id = stack[i + 1] if box_id in box_heights: box_heights[box_id] += height else: box_heights[box_id] = height # Process the queries results = [] for query in queries: total_height = 0 for box_id in query: if box_id in box_heights: total_height += box_heights[box_id] results.append(total_height) return results"},{"question":"def jump_sequence(n: int, q: int, queries: List[Tuple[int, int, int]]) -> List[int]: Process multiple queries to either update or sum elements in an array. Parameters: n (int): Length of the array. q (int): Number of queries. queries (List[Tuple[int, int, int]]): List of queries to process. Returns: List[int]: Results of sum queries, each result modulo 998244353. Example: >>> jump_sequence(5, 4, [(1, 2, 3), (2, 1, 3), (1, 1, -1), (2, 1, 5)]) [3, 2] >>> jump_sequence(3, 2, [(1, 1, 1000), (2, 1, 3)]) [1000] results = [] MOD = 998244353 # Your code goes here to implement the functionality. return results Unit tests: def test_jump_sequence_case_1(): n = 5 q = 4 queries = [ (1, 2, 3), (2, 1, 3), (1, 1, -1), (2, 1, 5) ] expected_output = [3, 2] assert jump_sequence(n, q, queries) == expected_output def test_jump_sequence_case_2(): n = 3 q = 2 queries = [ (1, 1, 1000), (2, 1, 3) ] expected_output = [1000] assert jump_sequence(n, q, queries) == expected_output def test_jump_sequence_case_3(): n = 4 q = 5 queries = [ (1, 4, 500), (1, 3, 200), (1, 1, -100), (2, 1, 4), (2, 2, 4) ] expected_output = [600, 700] assert jump_sequence(n, q, queries) == expected_output def test_jump_sequence_case_4(): n = 5 q = 1 queries = [ (2, 1, 5) ] expected_output = [0] assert jump_sequence(n, q, queries) == expected_output def test_jump_sequence_case_5(): n = 6 q = 3 queries = [ (1, 6, 150), (2, 3, 6), (1, 3, 100) ] expected_output = [150] assert jump_sequence(n, q, queries) == expected_output","solution":"MOD = 998244353 def jump_sequence(n, q, queries): # Initialize the array of length n with zeros arr = [0] * n def update(v, d): arr[v - 1] += d def get_sum(l, r): return sum(arr[l - 1:r]) % MOD results = [] for query in queries: t, a, b = query if t == 1: update(a, b) elif t == 2: results.append(get_sum(a, b)) return results"},{"question":"from typing import List def reorganize_string(s: str) -> str: Returns a reordering of the string \`s\` such that no two adjacent characters are the same, or \\"IMPOSSIBLE\\" if no such reordering exists. pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes multiple test cases for the reorganize_string function. pass def test_reorganize_string(): assert reorganize_string(\\"aab\\") in [\\"aba\\"] assert reorganize_string(\\"aa\\") == \\"IMPOSSIBLE\\" assert reorganize_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert reorganize_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] assert reorganize_string(\\"aaab\\") == \\"IMPOSSIBLE\\" def test_process_test_cases(): assert process_test_cases(3, [\\"aab\\", \\"aa\\", \\"abc\\"]) == [\\"aba\\", \\"IMPOSSIBLE\\", \\"abc\\"] assert process_test_cases(2, [\\"aaa\\", \\"aabb\\"]) == [\\"IMPOSSIBLE\\", \\"abab\\"] def test_edge_cases(): assert reorganize_string(\\"a\\") == \\"a\\" assert reorganize_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] assert reorganize_string(\\"aaaabbbb\\") in [\\"abababab\\", \\"babababa\\"]","solution":"from collections import Counter import heapq def reorganize_string(s): Returns a reordering of the string \`s\` such that no two adjacent characters are the same, or \\"IMPOSSIBLE\\" if no such reordering exists. # Count frequency of each character counter = Counter(s) max_len = (len(s) + 1) // 2 if any(count > max_len for count in counter.values()): return \\"IMPOSSIBLE\\" # Create a max heap with negative counts because heapq is a min-heap by default max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append current character to the result result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Prepare for the next round prev_count, prev_char = count + 1, char return ''.join(result) def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(reorganize_string(s)) return results"},{"question":"def update_array(n: int, m: int, initial_array: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Updates the array based on the provided operations. Parameters: n (int): Number of elements in the array. m (int): Number of operations. initial_array (list): The initial state of the array. operations (list): List of tuples where each tuple consists of (l, r, v). Returns: list: The final state of the array after all operations. Example: >>> update_array(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 4, 3), (3, 5, 1)]) [3, 7, 9, 8, 6] >>> update_array(4, 0, [1, 2, 3, 4], []) [1, 2, 3, 4] Unit Test: >>> update_array(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 4, 3), (3, 5, 1)]) == [3, 7, 9, 8, 6] True >>> update_array(1, 1, [10], [(1, 1, 5)]) == [15] True","solution":"def update_array(n, m, initial_array, operations): Updates the array based on the provided operations. Parameters: n (int): Number of elements in the array. m (int): Number of operations. initial_array (list): The initial state of the array. operations (list): List of tuples where each tuple consists of (l, r, v). Returns: list: The final state of the array after all operations. # Initialize a list to store the incremental changes increment = [0] * (n + 1) # Apply operations in a range update fashion for l, r, v in operations: increment[l - 1] += v if r < n: increment[r] -= v # Apply the incremental array to the initial array current_addition = 0 for i in range(n): current_addition += increment[i] initial_array[i] += current_addition return initial_array"},{"question":"from typing import List def allocate_tasks(n: int, m: int, preferences: List[List[int]]) -> List[int]: Allocate tasks to each intern based on their preferences. >>> allocate_tasks(3, 3, [[1, 2, 3], [2, 1, 3], [3, 1, 2]]) [1, 2, 3] >>> allocate_tasks(3, 4, [[1, 2, 3], [3, 1, 2], [2, 3, 1], [1, 3, 2]]) [1, 3, 2, 0] >>> allocate_tasks(3, 6, [[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]) [1, 2, 3, 0, 0, 0] >>> allocate_tasks(2, 2, [[2, 1], [1, 2]]) [2, 1] >>> allocate_tasks(5, 3, [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [2, 3, 1, 5, 4]]) [1, 5, 2] >>> allocate_tasks(2, 4, [[2, 1], [1, 2], [1, 2], [1, 2]]) [2, 1, 0, 0] # Your code here","solution":"from typing import List def allocate_tasks(n: int, m: int, preferences: List[List[int]]) -> List[int]: allocated_tasks = [] assigned = set() # This set keeps track of assigned tasks for pref in preferences: allocated_task = 0 for task in pref: if task not in assigned: allocated_task = task assigned.add(task) break allocated_tasks.append(allocated_task) return allocated_tasks"},{"question":"from typing import List def update_difficulties(difficulties: List[int], i: int, d: int) -> None: Updates the difficulty of the i-th problem to d. >>> diff = [4, 1, 7, 3, 2] >>> update_difficulties(diff, 2, 6) >>> diff [4, 1, 6, 3, 2] pass def minimum_difficulty_range(difficulties: List[int], k: int) -> int: Finds the minimum possible difficulty range for any subset of exactly k problems. >>> minimum_difficulty_range([4, 1, 7, 3, 2], 3) 2 >>> minimum_difficulty_range([4, 1, 7, 3, 2], 4) 3 >>> minimum_difficulty_range([4, 1, 7, 3, 2], 2) 1 pass def handle_queries(n: int, q: int, initial_difficulties: List[int], queries: List[List[int]]) -> List[int]: Handles the queries and returns the appropriate outputs as a list. >>> handle_queries(5, 5, [4, 1, 7, 3, 2], [[2, 3], [1, 3, 6], [2, 4], [1, 5, 5], [2, 2]]) [2, 3, 1] pass","solution":"def update_difficulties(difficulties, i, d): Updates the difficulty of the i-th problem to d. difficulties[i] = d def minimum_difficulty_range(difficulties, k): Finds the minimum possible difficulty range for any subset of exactly k problems. # Sort the list of difficulties sorted_difficulties = sorted(difficulties) min_range = float('inf') # Iterate through the sorted difficulties and find the minimum range for k consecutive problems for i in range(len(sorted_difficulties) - k + 1): current_range = sorted_difficulties[i + k - 1] - sorted_difficulties[i] if current_range < min_range: min_range = current_range return min_range def handle_queries(n, q, initial_difficulties, queries): Handles the queries and prints the appropriate outputs. # Make a copy of initial difficulties as they can be modified current_difficulties = initial_difficulties[:] results = [] for query in queries: if query[0] == 1: # Update query: query format is [1, i, d] _, i, d = query update_difficulties(current_difficulties, i - 1, d) elif query[0] == 2: # Range query: query format is [2, k] _, k = query result = minimum_difficulty_range(current_difficulties, k) results.append(result) return results"},{"question":"from typing import List def minimum_inversions_after_modification(A: List[int]) -> int: Given a list of integers A, this function modifies each integer to 0, epsilon, or -epsilon and returns the minimum number of inversions possible in the modified array. :param A: List[int] :return: int >>> minimum_inversions_after_modification([1]) 0 >>> minimum_inversions_after_modification([1, 2, 3]) 0 >>> minimum_inversions_after_modification([-3, -2, -1]) 0 >>> minimum_inversions_after_modification([4, -1, 0, 2]) 0 >>> minimum_inversions_after_modification([0, 0, 0]) 0 >>> minimum_inversions_after_modification([2, 2, 2]) 0 >>> minimum_inversions_after_modification([-2, -2, -2]) 0 >>> minimum_inversions_after_modification([-5, -1, 0, 3, 7]) 0 >>> minimum_inversions_after_modification([2, -3, 0, -1, 4]) 0 def test_single_element(): assert minimum_inversions_after_modification([1]) == 0 def test_no_inversions_needed(): assert minimum_inversions_after_modification([1, 2, 3]) == 0 def test_all_negative(): assert minimum_inversions_after_modification([-3, -2, -1]) == 0 def test_mixed_elements(): assert minimum_inversions_after_modification([4, -1, 0, 2]) == 0 def test_all_zeros(): assert minimum_inversions_after_modification([0, 0, 0]) == 0 def test_all_same_positive(): assert minimum_inversions_after_modification([2, 2, 2]) == 0 def test_all_same_negative(): assert minimum_inversions_after_modification([-2, -2, -2]) == 0 def test_sorted_array_with_negatives_and_positives(): assert minimum_inversions_after_modification([-5, -1, 0, 3, 7]) == 0 def test_random_order_with_negatives_and_positives(): assert minimum_inversions_after_modification([2, -3, 0, -1, 4]) == 0","solution":"def minimum_inversions_after_modification(A): Given a list of integers A, this function modifies each integer to 0, epsilon, or -epsilon and returns the minimum number of inversions possible in the modified array. :param A: List[int] :return: int n = len(A) if n <= 1: return 0 # No inversions possible in a single element array. # Count provides the number of zeroes, positive and negative numbers zeros = sum(1 for x in A if x == 0) positives = sum(1 for x in A if x > 0) negatives = sum(1 for x in A if x < 0) # Sorting orders negatives first, followed by zeros, then positives, # leading to the minimal number of inversions. return 0 # After sorting the transformed array correctly, we will have 0 inversions."},{"question":"def max_interesting_segments(n: int, arr: List[int]) -> int: Find the maximum number of interesting segments in an array of 0s and 1s. An interesting segment contains at least one '1'. Args: n (int): Length of the array. arr (List[int]): Array of 0s and 1s. Returns: int: Maximum number of interesting segments. Example: >>> max_interesting_segments(8, [0, 1, 0, 1, 1, 0, 0, 1]) 3 >>> max_interesting_segments(5, [0, 0, 0, 0, 0]) 0 >>> max_interesting_segments(5, [1, 1, 1, 1, 1]) 1 >>> max_interesting_segments(1, [0]) 0 >>> max_interesting_segments(1, [1]) 1 >>> max_interesting_segments(10, [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]) 5 >>> max_interesting_segments(7, [0, 1, 0, 0, 0, 1, 0]) 2 >>> max_interesting_segments(9, [0, 1, 1, 1, 0, 1, 1, 1, 1]) 2","solution":"def max_interesting_segments(n, arr): count = 0 i = 0 while i < n: if arr[i] == 1: count += 1 while i < n and arr[i] == 1: i += 1 i += 1 return count"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Function to calculate the largest rectangular area in a histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([3, 3, 3, 3, 3, 3]) 18 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([2, 4, 2, 1]) 6 pass","solution":"def largest_rectangle_area(heights): Function to calculate the largest rectangular area in a histogram. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List, Tuple from collections import defaultdict def consolidate_sensor_readings(n: int, k: int, m: int, readings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Consolidates sensor readings for every \`k\` minutes and calculates the total readings modulo \`m\`. Args: - n: Number of unique sensor types. - k: Time interval after which sensor readings are reset. - m: Constant for calculating the modulo of the sum of readings. - readings: List of sensor readings in the form (sensor_type, value, time). Returns: - List of tuples containing sensor type and their consolidated reading modulo \`m\`. >>> consolidate_sensor_readings(3, 5, 100, [(1, 10, 1), (2, 15, 1), (1, 20, 6), (3, 5, 7), (2, 10, 11)]) [(1, 30), (2, 25), (3, 5)] >>> consolidate_sensor_readings(3, 5, 100, []) [] >>> consolidate_sensor_readings(1, 5, 10, [(1, 25, 1), (1, 35, 2)]) [(1, 0)] >>> consolidate_sensor_readings(2, 10, 50, [(1, 20, 1), (2, 10, 1), (1, 40, 5), (2, 10, 12)]) [(1, 10), (2, 20)] >>> consolidate_sensor_readings(2, 100000, 1000000000, [(1, 1000000000, 1), (2, 1000000000, 2), (2, 500000000, 100000)]) [(1, 0), (2, 500000000)]","solution":"from typing import List, Tuple from collections import defaultdict def consolidate_sensor_readings(n: int, k: int, m: int, readings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Consolidates sensor readings for every \`k\` minutes and calculates the total readings modulo \`m\`. Args: - n: Number of unique sensor types. - k: Time interval after which sensor readings are reset. - m: Constant for calculating the modulo of the sum of readings. - readings: List of sensor readings in the form (sensor_type, value, time). Returns: - List of tuples containing sensor type and their consolidated reading modulo \`m\`. sensors = defaultdict(int) # Dictionary to hold sum of readings per sensor type for sensor_type, value, time in readings: sensors[sensor_type] += value consolidated_readings = [(sensor_type, total % m) for sensor_type, total in sensors.items()] return consolidated_readings"},{"question":"def min_operations_to_make_elements_equal(n: int, arr: List[int]) -> int: Determine the minimum number of operations required to make all elements of the array equal. An operation is defined where you can select any two elements of the array and replace one of them with their sum. If it is not possible to make all elements of the array equal, return -1. >>> min_operations_to_make_elements_equal(3, [1, 2, 3]) 2 >>> min_operations_to_make_elements_equal(4, [1, 1, 2, 3]) -1 >>> min_operations_to_make_elements_equal(4, [4, 4, 4, 4]) 3 >>> min_operations_to_make_elements_equal(3, [1000000000, 1000000000, 1000000000]) 2 >>> min_operations_to_make_elements_equal(3, [3, 6, 9]) 2","solution":"def min_operations_to_make_elements_equal(n, arr): total_sum = sum(arr) if total_sum % n != 0: return -1 # The target value for all elements to become equal target = total_sum // n # Minimal number of operations is always (n - 1) if it's possible return n - 1"},{"question":"def update_and_query_balances(n: int, initial_balances: List[int], m: int, transactions: List[Tuple[int, int]], q: int, queries: List[int]) -> List[int]: Updates the balances of bank accounts based on transactions and answers the queries for current balances. :param n: int - Number of bank accounts :param initial_balances: list of int - Initial amounts in each bank account :param m: int - Number of transactions :param transactions: list of tuples (int, int) - Transactions represented by (account, amount) :param q: int - Number of queries :param queries: list of int - Queries for the current balance of specified accounts :return: list of int - Current balances for each query >>> update_and_query_balances(5, [100, 200, 300, 400, 500], 6, [(1, 50), (2, -100), (3, 200), (1, -25), (5, -300), (4, 100)], 3, [1, 5, 4]) [125, 200, 500] >>> update_and_query_balances(2, [150, 250], 0, [], 2, [1, 2]) [150, 250] from typing import List, Tuple def test_update_and_query_balances(): assert update_and_query_balances(1, [100], 1, [(1, 50)], 1, [1]) == [150] assert update_and_query_balances(3, [100, 200, 300], 3, [(1, 50), (2, -100), (3, 200)], 1, [2]) == [100] assert update_and_query_balances(5, [100, 200, 300, 400, 500], 6, [(1, 50), (2, -100), (3, 200), (1, -25), (5, -300), (4, 100)], 3, [1, 5, 4]) == [125, 200, 500] assert update_and_query_balances(2, [150, 250], 0, [], 2, [1, 2]) == [150, 250] assert update_and_query_balances(1, [1000], 1, [(1, 99999)], 1, [1]) == [100999]","solution":"def update_and_query_balances(n, initial_balances, m, transactions, q, queries): Updates the balances of bank accounts based on transactions and answers the queries for current balances. :param n: int - Number of bank accounts :param initial_balances: list of int - Initial amounts in each bank account :param m: int - Number of transactions :param transactions: list of tuples (int, int) - Transactions represented by (account, amount) :param q: int - Number of queries :param queries: list of int - Queries for the current balance of specified accounts :return: list of int - Current balances for each query # Applying the transactions for account, amount in transactions: initial_balances[account - 1] += amount # Preparing results for queries results = [initial_balances[account - 1] for account in queries] return results"},{"question":"def encode_message(k: int, message: str) -> str: Encodes the message by shifting each letter by k positions in the alphabet. >>> encode_message(1, \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") \\"BCDEFGHIJKLMNOPQRSTUVWXYZA\\" >>> encode_message(3, \\"HELLO\\") \\"KHOOR\\" >>> encode_message(2, \\"XYZ\\") \\"ZAB\\" >>> encode_message(25, \\"ABCDEFG\\") \\"ZABCDEF\\" >>> encode_message(5, \\"AAAA\\") \\"FFFF\\" >>> encode_message(5, \\"A\\" * 100) \\"F\\" * 100","solution":"def encode_message(k, message): Encodes the message by shifting each letter by k positions in the alphabet. :param k: Shift value (1 ≤ k ≤ 25) :param message: Message to be encoded (only uppercase Latin letters) :return: Encoded message encoded_message = [] for char in message: # Find the original position of the character (0-based index) original_pos = ord(char) - ord('A') # Calculate the new position using the shift, wrapping around at 'Z' new_pos = (original_pos + k) % 26 # Convert the new position back to a character new_char = chr(new_pos + ord('A')) # Append to the result encoded_message.append(new_char) # Join the list of characters into a single string return ''.join(encoded_message)"},{"question":"def minimum_time_to_complete_relay_race(teams: List[List[int]]) -> List[int]: Returns a list of minimum times required for each team to complete the relay race. Parameters: teams (list of list of int): A list where each sublist describes a team's stations in order. Returns: list of int: A list of minimum times (in hours) for each team. Examples: >>> minimum_time_to_complete_relay_race([[5, 9, 12, 18], [3, 8, 15]]) [13, 12] >>> minimum_time_to_complete_relay_race([[1, 2, 3, 4], [9, 6, 3]]) [3, 6] import unittest class TestMinimumTimeToCompleteRelayRace(unittest.TestCase): def test_minimum_time_to_complete_relay_race(self): self.assertEqual(minimum_time_to_complete_relay_race([[5, 9, 12, 18], [3, 8, 15]]), [13, 12]) self.assertEqual(minimum_time_to_complete_relay_race([[1, 2, 3, 4], [9, 6, 3]]), [3, 6]) self.assertEqual(minimum_time_to_complete_relay_race([[10, 10, 10], [20, 30, 40, 50]]), [0, 30]) self.assertEqual(minimum_time_to_complete_relay_race([[50, 100, 150], [1, 4, 7, 10]]), [100, 9]) self.assertEqual(minimum_time_to_complete_relay_race([[1], [1000]]), [0, 0]) if __name__ == \\"__main__\\": unittest.main()","solution":"def minimum_time_to_complete_relay_race(teams): Returns a list of minimum times required for each team to complete the relay race. Parameters: teams (list of list of int): A list where each sublist describes a team's stations in order. Returns: list of int: A list of minimum times (in hours) for each team. result = [] for team in teams: time = 0 for i in range(len(team) - 1): time += abs(team[i+1] - team[i]) result.append(time) return result"},{"question":"from typing import List def last_stone_weight(stones: List[int]) -> int: Simulates the stone smashing process and returns the weight of the last stone. If no stones are left, returns 0. >>> last_stone_weight([2, 7, 4, 1, 8, 1]) 1 >>> last_stone_weight([5, 5, 5, 5]) 0 >>> last_stone_weight([7]) 7 >>> last_stone_weight([10, 4]) 6 >>> last_stone_weight([10, 10, 1, 1]) 0 >>> last_stone_weight([3, 7, 2, 5, 8]) 1","solution":"import heapq from typing import List def last_stone_weight(stones: List[int]) -> int: Simulates the stone smashing process and returns the weight of the last stone. If no stones are left, returns 0. # Convert all weights to negative to simulate a max-heap using Python's min-heap stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: # Extract the two heaviest stones (remember they are negative) heaviest = heapq.heappop(stones) second_heaviest = heapq.heappop(stones) if heaviest != second_heaviest: # Calculate the new weight and push it back to the heap new_weight = heaviest - second_heaviest heapq.heappush(stones, new_weight) # If there are no stones left, return 0, else return the absolute value of the last stone return -stones[0] if stones else 0"},{"question":"def optimal_game_result(n: int) -> str: Predicts the lexicographically smallest possible string two players can construct after n turns, with Alice and Bob playing optimally. Alice tries to make it smaller and Bob tries to make it larger. >>> optimal_game_result(1) 'A' >>> optimal_game_result(2) 'AA' >>> optimal_game_result(3) 'AAA' >>> optimal_game_result(4) 'AAAA' >>> optimal_game_result(100) 'A' * 100","solution":"def optimal_game_result(n: int) -> str: Predicts the lexicographically smallest possible string two players can construct after n turns, with Alice and Bob playing optimally. Alice tries to make it smaller and Bob tries to make it larger. return 'A' * n"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], src: int, dest: int) -> int: Find the minimum communication time from the source server to the destination server. Parameters: n (int): Number of servers. m (int): Number of communication links. edges (List[Tuple[int, int, int]]): List of edges where each edge is a tuple (u, v, w). src (int): Source server. dest (int): Destination server. Returns: int: The minimum communication time from src to dest, or -1 if no such path exists. Examples: >>> shortest_path(5, 6, [(1, 2, 10), (1, 3, 5), (2, 3, 8), (2, 4, 2), (3, 4, 3), (3, 5, 7)], 1, 4) 8 >>> shortest_path(4, 2, [(1, 2, 6), (3, 4, 2)], 1, 3) -1","solution":"import heapq def shortest_path(n, m, edges, src, dest): # Create graph adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Use Dijkstra's algorithm to find shortest path def dijkstra(start, end): heap = [(0, start)] distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 while heap: current_dist, node = heapq.heappop(heap) if node == end: return current_dist for neighbor, weight in graph[node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return -1 return dijkstra(src, dest)"},{"question":"def minimum_spanning_tree_cost(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: Given an undirected graph with \`n\` nodes and \`m\` edges, where each edge has a weight of either 1 or 2, find the minimum cost to connect all nodes in the graph using these edges (construct the Minimum Spanning Tree). Return -1 if it is impossible to connect all nodes. Example: >>> minimum_spanning_tree_cost(4, 5, [(1, 2, 1), (1, 3, 2), (2, 3, 1), (2, 4, 2), (3, 4, 1)]) 3 >>> minimum_spanning_tree_cost(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 1)]) 2 >>> minimum_spanning_tree_cost(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> minimum_spanning_tree_cost(1, 0, []) 0 >>> minimum_spanning_tree_cost(5, 6, [(1, 2, 2), (1, 3, 2), (1, 4, 2), (1, 5, 2), (2, 3, 1), (3, 4, 1)]) 6 >>> minimum_spanning_tree_cost(5, 0, []) -1","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 return True return False def find_minimum_spanning_tree(n, edges): if n == 1: return 0 uf = UnionFind(n) edges.sort(key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for u, v, w in edges: if uf.union(u - 1, v - 1): mst_cost += w edges_used += 1 if edges_used == n - 1: return mst_cost return -1 if edges_used != n - 1 else mst_cost def minimum_spanning_tree_cost(n, m, edge_list): return find_minimum_spanning_tree(n, edge_list)"},{"question":"def num_islands(grid): Returns the number of islands in the given grid of 0's and 1's. >>> grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0] ] >>> num_islands(grid) 3","solution":"def num_islands(grid): Returns the number of islands in the given grid of 0's and 1's. if not grid: return 0 n, m = len(grid), len(grid[0]) visited = [[False] * m for _ in range(n)] def dfs(i, j): Depth-first search to mark all cells connected to (i, j). if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 0 or visited[i][j]: return visited[i][j] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for di, dj in directions: dfs(i + di, j + dj) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) island_count += 1 return island_count # Example usage grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0] ] print(num_islands(grid)) # Output: 3"},{"question":"from typing import List def most_frequent_webpage(n: int, logs: List[str]) -> str: Finds the most frequently visited webpage from the logs. Args: n (int): number of log entries. logs (list of str): log entries. Returns: str: the webpage URL most frequently visited. >>> most_frequent_webpage(5, [ ... \\"2023-07-16T20:20:30 user1 http://example.com/page1\\", ... \\"2023-07-16T20:21:45 user2 http://example.com/page2\\", ... \\"2023-07-16T20:22:56 user3 http://example.com/page1\\", ... \\"2023-07-16T20:23:59 user2 http://example.com/page1\\", ... \\"2023-07-16T20:24:01 user1 http://example.com/page3\\" ... ]) == 'http://example.com/page1' >>> most_frequent_webpage(5, [ ... \\"2023-07-16T20:20:30 user1 http://example.com/page1\\", ... \\"2023-07-16T20:21:45 user2 http://example.com/page2\\", ... \\"2023-07-16T20:22:56 user3 http://example.com/page2\\", ... \\"2023-07-16T20:23:59 user2 http://example.com/page1\\", ... \\"2023-07-16T20:24:01 user1 http://example.com/page3\\" ... ]) in ['http://example.com/page1', 'http://example.com/page2'] >>> most_frequent_webpage(1, [ ... \\"2023-07-16T20:20:30 user1 http://example.com/page1\\" ... ]) == 'http://example.com/page1' >>> most_frequent_webpage(3, [ ... \\"2023-07-16T20:20:30 user1 http://example.com/page1\\", ... \\"2023-07-16T20:21:45 user2 http://example.com/page2\\", ... \\"2023-07-16T20:22:56 user3 http://example.com/page3\\" ... ]) in ['http://example.com/page1', 'http://example.com/page2', 'http://example.com/page3']","solution":"from collections import Counter import sys def most_frequent_webpage(n, logs): Finds the most frequently visited webpage from the logs. Args: n (int): number of log entries. logs (list of str): log entries. Returns: str: the webpage URL most frequently visited. webpage_counter = Counter() for log in logs: _, _, webpageURL = log.split() webpage_counter[webpageURL] += 1 # Find the most common webpage most_common_webpage = webpage_counter.most_common(1)[0][0] return most_common_webpage"},{"question":"def average_completion_times(n: int, m: int, completion_times: List[List[int]]) -> List[float]: Calculate the average completion time for each task. Args: n (int): Number of tasks. m (int): Number of students. completion_times (list of list of int): A list of lists where each inner list represents the completion times of tasks by one student. Returns: list of float: A list of average completion times for each task, rounded to two decimal places. from typing import List # Unit Tests def test_example_case(): n = 4 m = 3 completion_times = [ [5, 8, 3, 4], [6, 7, 2, 5], [4, 5, 3, 1] ] assert average_completion_times(n, m, completion_times) == [5.0, 6.67, 2.67, 3.33] def test_single_task_single_student(): n = 1 m = 1 completion_times = [ [10] ] assert average_completion_times(n, m, completion_times) == [10.0] def test_single_task_multiple_students(): n = 1 m = 3 completion_times = [ [2], [4], [6] ] assert average_completion_times(n, m, completion_times) == [4.0] def test_multiple_tasks_single_student(): n = 3 m = 1 completion_times = [ [1, 2, 3] ] assert average_completion_times(n, m, completion_times) == [1.0, 2.0, 3.0] def test_large_values(): n = 2 m = 2 completion_times = [ [1000000, 1000000], [1000000, 1000000] ] assert average_completion_times(n, m, completion_times) == [1000000.0, 1000000.0]","solution":"def average_completion_times(n, m, completion_times): Calculate the average completion time for each task. Args: n (int): Number of tasks. m (int): Number of students. completion_times (list of list of int): A list of lists where each inner list represents the completion times of tasks by one student. Returns: list of float: A list of average completion times for each task, rounded to two decimal places. # Initialize a list to store the sum of completion times for each task sum_times = [0] * n # Iterate over each student's completion times for student_times in completion_times: for i in range(n): sum_times[i] += student_times[i] # Calculate the average completion time for each task average_times = [round(sum_time / m, 2) for sum_time in sum_times] return average_times"},{"question":"def minimum_toll_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Compute the minimum total toll cost required to connect all cities to the capital (city with index 1) using a Minimum Spanning Tree (MST) approach. Parameters: n (int): number of cities m (int): number of roads roads (List[Tuple[int, int, int]]): list of roads where each road is described by three integers (u, v, w) Returns: int: minimum total toll cost to connect all cities >>> minimum_toll_cost(5, 7, [(1, 2, 3), (1, 3, 4), (2, 3, 2), (2, 4, 5), (3, 4, 1), (3, 5, 6), (4, 5, 2)]) 8 >>> minimum_toll_cost(1, 0, []) 0 >>> minimum_toll_cost(4, 2, [(1, 2, 1), (3, 4, 2)]) 3 >>> minimum_toll_cost(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 >>> minimum_toll_cost(4, 5, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (2, 3, 1), (3, 4, 1)]) 3","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_toll_cost(n, m, roads): roads.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n mst_cost = 0 edge_count = 0 for u, v, w in roads: u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_cost += w edge_count += 1 if edge_count == n - 1: break return mst_cost"},{"question":"from typing import List, Tuple def plan_trip(n: int, m: int, roads: List[Tuple[int, int, int]], s: int, priority_scores: List[int]) -> List[int]: Plan a trip for a group of friends that minimizes total travel time and prioritizes attractions according to their preferences. Args: n (int): number of cities m (int): number of roads roads (List[Tuple[int, int, int]]): list of roads where each road is represented by a tuple (u, v, w) - u (int): one end of the road - v (int): other end of the road - w (int): travel time between cities u and v s (int): starting city priority_scores (List[int]): list of priority scores for attractions in each city Returns: List[int]: the sequence of cities in the order they should be visited, starting and ending with the starting city >>> plan_trip(5, 7, [(1, 2, 10), (1, 3, 15), (2, 4, 25), (2, 5, 35), (3, 4, 20), (3, 5, 30), (4, 5, 10)], 1, [5, 3, 8, 10, 6]) [1, 2, 4, 5, 3, 1] >>> plan_trip(4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)], 1, [5, 10, 8, 7]) [1, 2, 3, 4, 1] >>> plan_trip(3, 2, [(1, 2, 10), (2, 3, 15)], 1, [1, 2, 3]) [1, 2, 3, 1]","solution":"import heapq def plan_trip(n, m, roads, s, priority_scores): # Step 1: Build graph representation from collections import defaultdict import heapq graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Step 2: Implement nearest neighbor TSP heuristic with priority attraction def tsp_with_priorities(start, n): visited = set() path = [] total_cost = 0 def visit(city): visited.add(city) path.append(city) visit(start) while len(visited) < n: last_city = path[-1] min_heap = [] for neighbor, travel_time in graph[last_city]: if neighbor not in visited: heapq.heappush(min_heap, (travel_time, -priority_scores[neighbor - 1], neighbor)) if not min_heap: break min_time, neg_priority, next_city = heapq.heappop(min_heap) total_cost += min_time visit(next_city) path.append(start) # Return to start to complete the cycle return path return tsp_with_priorities(s, n)"},{"question":"def min_time_to_pass_baton(n: int, d: int) -> int: Calculates the minimum time required to pass the baton from cabin 1 to all other cabins exactly once. Parameters: n (int): number of cabins d (int): distance threshold Returns: int: minimum amount of time in seconds >>> min_time_to_pass_baton(5, 1) == 4 >>> min_time_to_pass_baton(10, 1) == 9 >>> min_time_to_pass_baton(10, 9) == 1 >>> min_time_to_pass_baton(6, 3) == 2 >>> min_time_to_pass_baton(7, 2) == 3 >>> min_time_to_pass_baton(100, 1) == 99 >>> min_time_to_pass_baton(100, 99) == 1 pass","solution":"def min_time_to_pass_baton(n, d): Calculates the minimum time required to pass the baton from cabin 1 to all other cabins exactly once. Parameters: n (int): number of cabins d (int): distance threshold Returns: int: minimum amount of time in seconds # To pass the baton to all other cabins starting from cabin 1 return (n - 1 + d - 1) // d"},{"question":"def shortest_path_matrix(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[List[int]]: Generates the matrix of shortest paths between any two attractions based on the given road lengths. Args: n (int): Number of attractions. m (int): Number of roads. roads (List[Tuple[int, int, int]]): List of tuples representing the road connections. Each tuple contains three integers u, v, w where u and v are the attractions and w is the road length. Returns: List[List[int]]: A matrix of size n x n where element at row i and column j represents the shortest distance between attraction i and attraction j. Example: >>> shortest_path_matrix(4, 4, [(1, 2, 3), (2, 3, 5), (3, 4, 4), (1, 4, 10)]) [[0, 3, 8, 10], [3, 0, 5, 9], [8, 5, 0, 4], [10, 9, 4, 0]]","solution":"def shortest_path_matrix(n, m, roads): # Initialize distance matrix with infinities dist = [[float('inf') for _ in range(n)] for _ in range(n)] # Distance to self is zero for i in range(n): dist[i][i] = 0 # Populate initial distances based on the roads provided for u, v, w in roads: dist[u-1][v-1] = w dist[v-1][u-1] = w # Floyd-Warshall Algorithm to calculate shortest paths for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"def minimal_distance(n: int, m: int, locks: List[int], keys: List[int]) -> int: Determine the minimal distance \`r\` such that every lock can be opened by some key. >>> minimal_distance(4, 5, [1, 5, 9, 11], [4, 8, 12, 16, 20]) == 3 >>> minimal_distance(2, 1, [0, 2], [5]) == 5 >>> minimal_distance(4, 4, [1, 3, 5, 7], [10, 12, 14, 16]) == 9 >>> minimal_distance(3, 3, [1, 3, 5], [2, 4, 6]) == 1 >>> minimal_distance(1, 1, [1], [1]) == 0 >>> minimal_distance(2, 2, [1, 10], [0, 20]) == 10 >>> minimal_distance(3, 4, [-5, 0, 5], [-10, 5, 15, 20]) == 5","solution":"def minimal_distance(n, m, locks, keys): def can_all_locks_be_opened(r): key_index = 0 for lock in locks: while key_index < m and keys[key_index] < lock - r: key_index += 1 if key_index == m or keys[key_index] > lock + r: return False return True low, high = 0, max(max(locks), max(keys)) - min(min(locks), min(keys)) while low < high: mid = (low + high) // 2 if can_all_locks_be_opened(mid): high = mid else: low = mid + 1 return low"},{"question":"def max_resource_utilization(n, intervals): Returns the maximum number of people who can access the resource without overlapping intervals. Args: n (int): The number of time intervals. intervals (List[int]): The list of integers where each integer represents the number of people who can access the resource. Returns: int: The maximum number of people who can access the resource with the optimal schedule. Examples: >>> max_resource_utilization(5, [3, 2, 5, 10, 7]) 15 >>> max_resource_utilization(3, [1, 3, 2]) 3 # Your code here from solution import max_resource_utilization def test_max_resource_utilization_example1(): assert max_resource_utilization(5, [3, 2, 5, 10, 7]) == 15 def test_max_resource_utilization_example2(): assert max_resource_utilization(3, [1, 3, 2]) == 3 def test_max_resource_utilization_single_interval(): assert max_resource_utilization(1, [10]) == 10 def test_max_resource_utilization_two_intervals(): assert max_resource_utilization(2, [10, 5]) == 10 assert max_resource_utilization(2, [5, 10]) == 10 def test_max_resource_utilization_edge_case_empty(): assert max_resource_utilization(0, []) == 0 def test_max_resource_utilization_all_equal(): assert max_resource_utilization(4, [5, 5, 5, 5]) == 10 def test_max_resource_utilization_alternating(): assert max_resource_utilization(5, [5, 1, 5, 1, 5]) == 15 def test_max_resource_utilization_large_values(): assert max_resource_utilization(3, [10000, 5000, 10000]) == 20000","solution":"def max_resource_utilization(n, intervals): Returns the maximum number of people who can access the resource without overlapping intervals. if n == 0: return 0 if n == 1: return intervals[0] if n == 2: return max(intervals[0], intervals[1]) dp = [0] * n dp[0] = intervals[0] dp[1] = max(intervals[0], intervals[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + intervals[i]) return dp[n-1]"},{"question":"def max_path_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum path sum in a binary tree defined by values and edges. >>> max_path_sum(5, [-10, 9, 20, 15, 7], [(1, 2), (1, 3), (3, 4), (3, 5)]) 42 >>> max_path_sum(1, [5], []) 5 >>> max_path_sum(3, [-1, -2, -3], [(1, 2), (1, 3)]) -1 >>> max_path_sum(3, [1, 2, 3], [(1, 2), (1, 3)]) 6 >>> max_path_sum(4, [1, -2, 3, 4], [(1, 2), (1, 3), (3, 4)]) 8","solution":"from typing import List, Tuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(n: int, values: List[int], edges: List[Tuple[int, int]]) -> TreeNode: if not n: return None nodes = {i: TreeNode(values[i-1]) for i in range(1, n+1)} for u, v in edges: if nodes[u].left is None: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes[1] def max_path_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: if n == 0: return 0 root = build_tree(n, values, edges) def max_gain(node): nonlocal max_sum if not node: return 0 left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) current_max_path = node.val + left_gain + right_gain max_sum = max(max_sum, current_max_path) return node.val + max(left_gain, right_gain) max_sum = float('-inf') max_gain(root) return max_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and addition operators, possibly with whitespace characters, and returns the sum. >>> evaluate_expression(\\"1+1\\") == 2 >>> evaluate_expression(\\"2 + 2\\") == 4 >>> evaluate_expression(\\"3+5+2\\") == 10 >>> evaluate_expression(\\" 1 + 2 + 3 \\") == 6 >>> evaluate_expression(\\" 4 + 6 \\") == 10 >>> evaluate_expression(\\"10+ 20 +30\\") == 60 >>> evaluate_expression(\\" 1 + 10\\") == 11 >>> evaluate_expression(\\"100000 + 200000 + 300000\\") == 600000 >>> evaluate_expression(\\"123456 + 789012\\") == 912468 >>> evaluate_expression(\\"5\\") == 5 >>> evaluate_expression(\\" 7 \\") == 7 >>> evaluate_expression(\\"8+7+1\\") == 16 >>> evaluate_expression(\\"0+0+0\\") == 0 >>> evaluate_expression(\\"0 + 5 + 0\\") == 5","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and addition operators, possibly with whitespace characters, and returns the sum. # Split the expression by the '+' operator and remove any extra whitespace numbers = [int(num.strip()) for num in expression.split('+')] # Return the sum of all the numbers return sum(numbers)"},{"question":"def min_difference(arr: List[int]) -> int: Given a list of integers, divide this list into two non-empty parts such that the absolute difference between the sum of the elements in the first part and the sum of the elements in the second part is minimized. >>> min_difference([1, 2, 3, 4, 5]) == 1 >>> min_difference([10, 15, 20, 25]) == 0 >>> min_difference([-1, -2, -3, -4]) == 0 >>> min_difference([12, 3, 7, 5, 10, 8]) == 1","solution":"from itertools import combinations def min_difference(arr): total_sum = sum(arr) n = len(arr) half_sum = total_sum // 2 best_diff = float('inf') for i in range(1, n // 2 + 1): for comb in combinations(arr, i): current_sum = sum(comb) current_diff = abs(total_sum - 2 * current_sum) if current_diff < best_diff: best_diff = current_diff return best_diff"},{"question":"from typing import List, Tuple def min_moves_to_equal_strings(test_cases: List[Tuple[str, str]]) -> List[int]: Find the minimum number of moves required to make string s equal to string t in each test case. Args: test_cases (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings s and t of the same length. Returns: List[int]: A list of integers representing the minimum number of moves required for each test case. Examples: >>> min_moves_to_equal_strings([(\\"abc\\", \\"def\\")]) [3] >>> min_moves_to_equal_strings([(\\"xyzz\\", \\"xyyx\\")]) [2]","solution":"def min_moves_to_equal_strings(test_cases): results = [] for s, t in test_cases: moves = sum(1 for x, y in zip(s, t) if x != y) results.append(moves) return results"},{"question":"def is_path_exists(n, m, grid): Determines if there exists a path from the top-left corner to the bottom-right corner of the grid, passing only through free spaces (denoted by '1') and moving only up, down, left, or right. Args: n: int, number of rows in the grid. m: int, number of columns in the grid. grid: List of strings, each string representing a row in the grid (values are '1' or '0'). Returns: str: \\"YES\\" if there exists a path, \\"NO\\" otherwise. >>> is_path_exists(5, 5, [\\"11000\\", \\"01100\\", \\"00110\\", \\"00011\\", \\"00001\\"]) \\"YES\\" >>> is_path_exists(5, 5, [\\"11000\\", \\"01000\\", \\"00110\\", \\"01011\\", \\"00001\\"]) \\"NO\\" >>> is_path_exists(2, 2, [\\"11\\", \\"11\\"]) \\"YES\\" from solution import is_path_exists def test_is_path_exists_no_obstacles(): grid = [ \\"11111\\", \\"11111\\", \\"11111\\", \\"11111\\", \\"11111\\" ] assert is_path_exists(5, 5, grid) == \\"YES\\" def test_is_path_exists_with_isolated_zeros(): grid = [ \\"11000\\", \\"01100\\", \\"00110\\", \\"00011\\", \\"00001\\" ] assert is_path_exists(5, 5, grid) == \\"YES\\" def test_is_path_exists_blocked_path(): grid = [ \\"11000\\", \\"01000\\", \\"00110\\", \\"01011\\", \\"00001\\" ] assert is_path_exists(5, 5, grid) == \\"NO\\" def test_is_path_exists_small_grid_path_exists(): grid = [ \\"11\\", \\"11\\" ] assert is_path_exists(2, 2, grid) == \\"YES\\" def test_is_path_exists_small_grid_no_path(): grid = [ \\"10\\", \\"01\\" ] assert is_path_exists(2, 2, grid) == \\"NO\\" def test_is_path_exists_start_blocked(): grid = [ \\"011\\", \\"111\\", \\"111\\" ] assert is_path_exists(3, 3, grid) == \\"NO\\" def test_is_path_exists_end_blocked(): grid = [ \\"111\\", \\"111\\", \\"110\\" ] assert is_path_exists(3, 3, grid) == \\"NO\\"","solution":"def is_path_exists(n, m, grid): Determines if there exists a path from the top-left corner to the bottom-right corner of the grid, passing only through free spaces (denoted by '1') and moving only up, down, left, or right. Args: n: int, number of rows in the grid. m: int, number of columns in the grid. grid: List of strings, each string representing a row in the grid (values are '1' or '0'). Returns: str: \\"YES\\" if there exists a path, \\"NO\\" otherwise. from collections import deque if grid[0][0] == '0' or grid[n-1][m-1] == '0': return \\"NO\\" queue = deque([(0, 0)]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if x == n-1 and y == m-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '1': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def organize_products_by_price(products): Organizes products by price in non-decreasing order. :param products: List of tuples, where each tuple contains a product name and price in format \\"d.dd\\". :return: List of product names in non-decreasing order of their prices. >>> organize_products_by_price([(\\"Apple\\", \\"1.00\\")]) ['Apple'] >>> organize_products_by_price([(\\"Banana\\", \\"0.50\\"), (\\"Apple\\", \\"1.00\\"), (\\"Cherry\\", \\"0.75\\")]) ['Banana', 'Cherry', 'Apple'] >>> organize_products_by_price([(\\"Banana\\", \\"0.50\\"), (\\"Apple\\", \\"0.50\\"), (\\"Cherry\\", \\"0.75\\")]) in (['Banana', 'Apple', 'Cherry'], ['Apple', 'Banana', 'Cherry']) True >>> organize_products_by_price([(\\"apple\\", \\"1.00\\"), (\\"Apple\\", \\"0.50\\"), (\\"cherry\\", \\"0.75\\"), (\\"Cherry\\", \\"0.75\\")]) ['Apple', 'cherry', 'Cherry', 'apple'] >>> organize_products_by_price([(\\"Gold\\", \\"1000.00\\"), (\\"Silver\\", \\"900.00\\"), (\\"Bronze\\", \\"300.00\\")]) ['Bronze', 'Silver', 'Gold']","solution":"def organize_products_by_price(products): Organizes products by price in non-decreasing order. :param products: List of tuples, where each tuple contains a product name and price in format \\"d.dd\\". :return: List of product names in non-decreasing order of their prices. # Parse prices and sort products by price parsed_products = [(name, float(price[1:])) for name, price in products] sorted_products = sorted(parsed_products, key=lambda x: x[1]) # Return product names in the sorted order return [name for name, price in sorted_products]"},{"question":"from typing import List, Dict def can_accommodate(bookings: List[Dict], rooms: Dict[int, int]) -> List[bool]: Determines if each booking request can be accommodated. Parameters: bookings (List[Dict]): List of booking requests. rooms (Dict[int, int]): Dictionary of room capacities. Returns: List[bool]: List indicating whether each booking can be accommodated. Example: >>> bookings = [ ... {\\"guests\\": 4, \\"room_ids\\": [101, 102, 103]}, ... {\\"guests\\": 3, \\"room_ids\\": [104]} ... ] >>> rooms = { ... 101: 2, ... 102: 1, ... 103: 1, ... 104: 2 ... } >>> can_accommodate(bookings, rooms) [True, False]","solution":"def can_accommodate(bookings, rooms): Determines if each booking request can be accommodated. Parameters: bookings (List[Dict]): List of booking requests. rooms (Dict[int, int]): Dictionary of room capacities. Returns: List[bool]: List indicating whether each booking can be accommodated. results = [] for booking in bookings: guests_needed = booking.get(\\"guests\\", 0) room_ids = booking.get(\\"room_ids\\", []) total_capacity = sum(rooms.get(room_id, 0) for room_id in room_ids) if total_capacity >= guests_needed: results.append(True) else: results.append(False) return results"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process the range sum queries on the given array. Parameters: n (int): The size of the array. q (int): The number of queries. array (list of int): The elements of the array. queries (list of tuple): Each tuple has two integers (l, r) representing the range [l, r] Returns: list of int: The sum of elements for each range specified in the queries. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 14, 15] >>> process_queries(1, 1, [42], [(1, 1)]) [42] >>> process_queries(4, 2, [10, 20, 30, 40], [(1, 4), (1, 1)]) [100, 10] >>> process_queries(6, 3, [1, 2, 3, 4, 5, 6], [(1, 6), (3, 5), (4, 6)]) [21, 12, 15] >>> process_queries(3, 1, [10**9, 10**9, 10**9], [(1, 3)]) [3000000000] >>> process_queries(7, 2, [3, 1, 4, 1, 5, 9, 2], [(2, 4), (3, 6)]) [6, 19]","solution":"def process_queries(n, q, array, queries): Process the range sum queries on the given array. Parameters: n (int): The size of the array. q (int): The number of queries. array (list of int): The elements of the array. queries (list of tuple): Each tuple has two integers (l, r) representing the range [l, r] Returns: list of int: The sum of elements for each range specified in the queries. # Precompute the prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] results = [] for l, r in queries: # Convert 1-based index to 0-based index sum_lr = prefix_sums[r] - prefix_sums[l - 1] results.append(sum_lr) return results"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Write a function that takes as input an array of integers and returns the maximum possible sum of a contiguous subarray within the given array. Parameters: arr (List[int]): An array of integers where 1 ≤ |arr| ≤ 1000 and -1000 ≤ arr[i] ≤ 1000. Returns: int: The maximum possible sum of a contiguous subarray. Example: >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 pass def test_max_subarray_sum_all_positive(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_max_subarray_sum_mixed_numbers(): assert max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 def test_max_subarray_sum_all_negative(): assert max_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_max_subarray_sum_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_max_subarray_sum_large_variation(): assert max_subarray_sum([-1, 3, -2, 5, -6, 7, -8, 9, -10]) == 9 def test_max_subarray_sum_empty_array(): assert max_subarray_sum([]) == 0","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the maximum possible sum of a contiguous subarray within the given array. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def shortest_subarray_length(arr: List[int], n: int, S: int) -> int: This function returns the length of the shortest subarray with a sum equal to S. If no such subarray exists, it returns -1. >>> shortest_subarray_length([5, 1, 3, 6, 2], 5, 12) == 4 >>> shortest_subarray_length([1, 2, 3, 4, 5], 5, 7) == 2 >>> shortest_subarray_length([1, 2, 3], 3, 15) == -1","solution":"def shortest_subarray_length(arr, n, S): This function returns the length of the shortest subarray with a sum equal to S. If no such subarray exists, it returns -1. from collections import defaultdict current_sum = 0 min_length = float('inf') sums_map = defaultdict(int) sums_map[0] = -1 # To handle the case when the subarray starts from index 0 for i in range(n): current_sum += arr[i] if (current_sum - S) in sums_map: min_length = min(min_length, i - sums_map[current_sum - S]) sums_map[current_sum] = i return min_length if min_length != float('inf') else -1 # Example usage arr = [5, 1, 3, 6, 2] n = 5 S = 12 print(shortest_subarray_length(arr, n, S)) # Output: 4"},{"question":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds two indices i and j such that nums[i] + nums[j] == target and i < j. If there are multiple solutions, return the one with the smallest i value, and if there is still a tie, return the one with the smallest j value. If no such indices exist, return (-1, -1). >>> find_indices([1, 2, 3, 4, 5], 9) (3, 4) >>> find_indices([-1, -2, -3, -4], -6) (1, 3) >>> find_indices([1, 2, 3], 7) (-1, -1) def test_find_indices(): assert find_indices([1, 2, 3, 4, 5], 9) == (3, 4) assert find_indices([-1, -2, -3, -4], -6) == (1, 3) assert find_indices([1, 2, 3], 7) == (-1, -1) assert find_indices([2, 7, 11, 15], 9) == (0, 1) assert find_indices([1, 1, 1, 1], 2) == (0, 1) assert find_indices([1, 2, 3, 4, 5], 10) == (-1, -1) assert find_indices([3, 2, 4], 6) == (1, 2) assert find_indices([3, 3], 6) == (0, 1) assert find_indices([1], 1) == (-1, -1) if __name__ == \\"__main__\\": test_find_indices() print(\\"All tests passed.\\")","solution":"def find_indices(nums, target): Finds two indices i and j such that nums[i] + nums[j] == target and i < j. If there are multiple solutions, return the one with the smallest i value, and if there is still a tie, return the one with the smallest j value. If no such indices exist, return (-1, -1). num_indices = {} for i, num in enumerate(nums): complement = target - num if complement in num_indices: return (num_indices[complement], i) if num not in num_indices: # ensure we record the smallest index for each number num_indices[num] = i return (-1, -1)"},{"question":"def sum_of_digits(s: str) -> int: Returns the sum of all digits present in the string s. Parameters: s (str): a string containing digits and lowercase alphabets Returns: int: sum of all digits present in the string Examples: >>> sum_of_digits(\\"ab1234cd56\\") 21 >>> sum_of_digits(\\"abcdef\\") 0","solution":"def sum_of_digits(s): Returns the sum of all digits present in the string s. Parameters: s (str): a string containing digits and lowercase alphabets Returns: int: sum of all digits present in the string return sum(int(char) for char in s if char.isdigit())"},{"question":"from typing import List def compress_strings(strings: List[str]) -> List[str]: Compresses each given string by collapsing multiple spaces into a single space, removes leading and trailing spaces, and converts all characters to lowercase. :param strings: List of input strings. :return: List of compressed strings. pass # Example usage input_strings = [\\" Hello World \\", \\" Python Programming is fun \\"] output_strings = compress_strings(input_strings) print(output_strings) # Output: ['hello world', 'python programming is fun'] # Unit tests def test_compress_strings_normal_cases(): input_strings = [\\" Hello World \\", \\" Python Programming is fun \\"] expected_output = ['hello world', 'python programming is fun'] assert compress_strings(input_strings) == expected_output def test_compress_strings_already_compressed(): input_strings = [\\"hello world\\", \\"python programming is fun\\"] expected_output = ['hello world', 'python programming is fun'] assert compress_strings(input_strings) == expected_output def test_compress_strings_with_multiple_spaces(): input_strings = [\\"hello world\\", \\" python programming is fun \\"] expected_output = ['hello world', 'python programming is fun'] assert compress_strings(input_strings) == expected_output def test_compress_strings_with_leading_and_trailing_spaces(): input_strings = [\\" hello world \\"] expected_output = ['hello world'] assert compress_strings(input_strings) == expected_output def test_compress_strings_with_all_spaces(): input_strings = [\\" \\"] expected_output = [''] assert compress_strings(input_strings) == expected_output def test_compress_strings_with_empty_string(): input_strings = [\\"\\"] expected_output = [''] assert compress_strings(input_strings) == expected_output def test_compress_strings_mixed_cases(): input_strings = [\\"HeLLo WORld\\", \\"Python PROGramMIng\\"] expected_output = ['hello world', 'python programming'] assert compress_strings(input_strings) == expected_output","solution":"from typing import List def compress_strings(strings: List[str]) -> List[str]: Compresses each given string by collapsing multiple spaces into a single space, removes leading and trailing spaces, and converts all characters to lowercase. :param strings: List of input strings. :return: List of compressed strings. compressed = [] for s in strings: compressed.append(' '.join(s.strip().lower().split())) return compressed"},{"question":"def longest_palindromic_subarray(arr): Returns the length of the longest subarray that can be rearranged to form a palindrome. >>> longest_palindromic_subarray([1, 2, 3, 2, 1, 3, 3]) 7 >>> longest_palindromic_subarray([4, 4, 4, 4, 4]) 5 >>> longest_palindromic_subarray([]) 0 >>> longest_palindromic_subarray([1, 2, 3, 4]) 1 >>> longest_palindromic_subarray([1, 2, 1, 2, 1]) 5 >>> longest_palindromic_subarray([1]) 1","solution":"def longest_palindromic_subarray(arr): Returns the length of the longest subarray that can be rearranged to form a palindrome. from collections import defaultdict def can_form_palindrome(freq): odd_count = 0 for count in freq.values(): if count % 2 == 1: odd_count += 1 if odd_count > 1: return False return True n = len(arr) max_len = 0 for i in range(n): freq = defaultdict(int) for j in range(i, n): freq[arr[j]] += 1 if can_form_palindrome(freq): max_len = max(max_len, j - i + 1) return max_len"},{"question":"def remove_duplicates_preserve_order(S: str) -> str: Transform the string such that all characters occurring multiple times are removed, leaving only distinct characters present in the original order they appeared. >>> remove_duplicates_preserve_order(\\"abacabad\\") \\"cd\\" >>> remove_duplicates_preserve_order(\\"abcdefghijklmnopqrstuvwxyz\\") \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def remove_duplicates_preserve_order(S): from collections import Counter # First, count the frequency of each character in the string char_count = Counter(S) # Filter the characters that appear only once and keep their relative order. result = ''.join([char for char in S if char_count[char] == 1]) return result"},{"question":"def min_knight_moves(start: str, end: str) -> int: Calculate the minimum number of moves required for a knight to move from the starting position to the ending position on a standard 8x8 chessboard. >>> min_knight_moves(\\"a1\\", \\"b3\\") 1 >>> min_knight_moves(\\"a1\\", \\"c2\\") 1 >>> min_knight_moves(\\"a1\\", \\"h8\\") 6 >>> min_knight_moves(\\"a1\\", \\"a1\\") 0 from solution import min_knight_moves def test_knight_same_position(): assert min_knight_moves(\\"a1\\", \\"a1\\") == 0 def test_knight_short_moves(): assert min_knight_moves(\\"a1\\", \\"b3\\") == 1 assert min_knight_moves(\\"a1\\", \\"c2\\") == 1 def test_knight_to_corners(): assert min_knight_moves(\\"a1\\", \\"h8\\") == 6 def test_knight_random_positions(): assert min_knight_moves(\\"g1\\", \\"f3\\") == 1 assert min_knight_moves(\\"d4\\", \\"f5\\") == 1 assert min_knight_moves(\\"b1\\", \\"c3\\") == 1 assert min_knight_moves(\\"h1\\", \\"h8\\") == 5 def test_knight_large_distance(): assert min_knight_moves(\\"a1\\", \\"h8\\") == 6 assert min_knight_moves(\\"a1\\", \\"h7\\") == 5","solution":"from collections import deque def min_knight_moves(start: str, end: str) -> int: def pos_to_idx(pos): return ord(pos[0]) - ord('a'), int(pos[1]) - 1 knight_moves = [ (2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2) ] start_pos = pos_to_idx(start) end_pos = pos_to_idx(end) if start_pos == end_pos: return 0 queue = deque([(start_pos, 0)]) visited = set() visited.add(start_pos) while queue: (current_x, current_y), moves = queue.popleft() for dx, dy in knight_moves: next_x, next_y = current_x + dx, current_y + dy if (next_x, next_y) == end_pos: return moves + 1 if 0 <= next_x < 8 and 0 <= next_y < 8 and (next_x, next_y) not in visited: visited.add((next_x, next_y)) queue.append(((next_x, next_y), moves + 1)) return -1 # not possible, though, on an 8x8 board it usually is always possible"},{"question":"def check_ab_pair(s: str) -> str: Determines if there is any 'A' that is followed immediately by 'B' in the string s. Returns \\"FOUND\\" if such a pair exists, otherwise returns \\"NOT FOUND\\". >>> check_ab_pair(\\"AAA\\") == \\"NOT FOUND\\" >>> check_ab_pair(\\"BB\\") == \\"NOT FOUND\\" >>> check_ab_pair(\\"AB\\") == \\"FOUND\\" >>> check_ab_pair(\\"ABBA\\") == \\"FOUND\\" >>> check_ab_pair(\\"AABBA\\") == \\"FOUND\\" >>> check_ab_pair(\\"AABBBB\\") == \\"FOUND\\" >>> check_ab_pair(\\"BBAAB\\") == \\"FOUND\\" >>> check_ab_pair(\\"BBBAAAB\\") == \\"FOUND\\" >>> check_ab_pair(\\"A\\") == \\"NOT FOUND\\" >>> check_ab_pair(\\"B\\") == \\"NOT FOUND\\" >>> check_ab_pair(\\"AA\\") == \\"NOT FOUND\\" >>> check_ab_pair(\\"BA\\") == \\"NOT FOUND\\"","solution":"def check_ab_pair(s): Determines if there is any 'A' that is followed immediately by 'B' in the string s. Returns \\"FOUND\\" if such a pair exists, otherwise returns \\"NOT FOUND\\". for i in range(len(s) - 1): if s[i] == 'A' and s[i+1] == 'B': return \\"FOUND\\" return \\"NOT FOUND\\""},{"question":"def first_non_repeating_character(s: str) -> int: Given a string, return the index of the first non-repeating character. If there's no non-repeating character, return -1. The string contains only lowercase English letters. Example: >>> first_non_repeating_character(\\"leetcode\\") 0 >>> first_non_repeating_character(\\"loveleetcode\\") 2 >>> first_non_repeating_character(\\"aabbcc\\") -1 \`","solution":"def first_non_repeating_character(s: str) -> int: Returns the index of the first non-repeating character in the string. If no such character exists, returns -1. char_count = {} # First pass to count the frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"def busy_time_window(n, logs, window_duration): Find the maximum number of items sold in any time window of the given duration for each store. Parameters: n (int): The number of log entries. logs (list): A list of tuples, each containing timestamp, store_id, and items_sold. window_duration (int): The duration of the time window in seconds. Returns: dict: A dictionary where keys are store IDs and values are the maximum number of items sold in any time window of the given duration. >>> busy_time_window(5, [(1, 1, 10), (2, 1, 5), (601, 1, 20), (120, 2, 7), (150, 2, 11)], 600) == {1: 35, 2: 18} >>> busy_time_window(4, [(100, 1, 15), (200, 1, 10), (300, 1, 20), (700, 1, 25)], 400) == {1: 45} >>> busy_time_window(6, [(50, 1, 10), (120, 1, 20), (400, 1, 15), (50, 2, 5), (350, 2, 30), (360, 2, 10)], 500) == {1: 45, 2: 45} >>> busy_time_window(0, [], 500) == {} >>> busy_time_window(3, [(0, 1, 5), (0, 1, 10), (0, 1, 7)], 100) == {1: 22}","solution":"def busy_time_window(n, logs, window_duration): from collections import defaultdict from itertools import combinations_with_replacement store_sales = defaultdict(list) for log in logs: timestamp, store_id, items_sold = log store_sales[store_id].append((timestamp, items_sold)) results = {} for store_id, sales in store_sales.items(): sales.sort() max_items_sold = 0 current_window_sales = 0 start = 0 for end in range(len(sales)): current_window_sales += sales[end][1] while sales[end][0] - sales[start][0] > window_duration: current_window_sales -= sales[start][1] start += 1 max_items_sold = max(max_items_sold, current_window_sales) results[store_id] = max_items_sold return results # Test the function with the example input n = 5 logs = [ (1, 1, 10), (2, 1, 5), (601, 1, 20), (120, 2, 7), (150, 2, 11) ] window_duration = 600 print(busy_time_window(n, logs, window_duration))"},{"question":"def max_sum_after_game(n: int, a: List[int]) -> int: Given an array a of length n, computes the maximum possible sum of the elements after any number of swaps by Alice and replacements by Bob. >>> max_sum_after_game(3, [1, 2, 3]) 6 >>> max_sum_after_game(5, [-1, -2, 1, 2, 0]) 0 >>> max_sum_after_game(4, [2, 2, 2, 9]) 15 pass # Example test cases def test_example_1(): assert max_sum_after_game(3, [1, 2, 3]) == 6 def test_example_2(): assert max_sum_after_game(5, [-1, -2, 1, 2, 0]) == 0 def test_example_3(): assert max_sum_after_game(4, [2, 2, 2, 9]) == 15 def test_all_negative(): assert max_sum_after_game(3, [-3, -2, -1]) == -6 def test_mixed_signs(): assert max_sum_after_game(5, [1, -1, 2, -2, 3]) == 3 def test_single_element(): assert max_sum_after_game(2, [5, -5]) == 0 def test_large_numbers(): assert max_sum_after_game(3, [10**9, -10**9, 0]) == 0","solution":"def max_sum_after_game(n, a): Given an array a of length n, computes the maximum possible sum of the elements after any number of swaps by Alice and replacements by Bob. return sum(a)"},{"question":"def project_with_highest_awesomeness(n: int, projects: List[str]) -> str: Returns the project with the highest awesomeness score. If multiple projects have the same score, the lexicographically smallest project is returned. >>> project_with_highest_awesomeness(1, [\\"abc\\"]) \\"abc\\" >>> project_with_highest_awesomeness(3, [\\"xyz\\", \\"abc\\", \\"def\\"]) \\"xyz\\" >>> project_with_highest_awesomeness(2, [\\"cba\\", \\"abc\\"]) \\"abc\\" >>> project_with_highest_awesomeness(2, [\\"bac\\", \\"acb\\"]) \\"acb\\" >>> project_with_highest_awesomeness(3, [\\"a\\"*100, \\"b\\"*100, \\"c\\"*100]) \\"cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\\" >>> project_with_highest_awesomeness(2, [\\"\\", \\"abc\\"]) \\"abc\\" from typing import List def test_project_with_highest_awesomeness(): assert project_with_highest_awesomeness(1, [\\"abc\\"]) == \\"abc\\" assert project_with_highest_awesomeness(3, [\\"xyz\\", \\"abc\\", \\"def\\"]) == \\"xyz\\" assert project_with_highest_awesomeness(2, [\\"cba\\", \\"abc\\"]) == \\"abc\\" assert project_with_highest_awesomeness(2, [\\"bac\\", \\"acb\\"]) == \\"acb\\" projects = [\\"a\\"*100, \\"b\\"*100, \\"c\\"*100] assert project_with_highest_awesomeness(3, projects) == \\"c\\"*100 assert project_with_highest_awesomeness(2, [\\"\\", \\"abc\\"]) == \\"abc\\"","solution":"def project_with_highest_awesomeness(n, projects): Returns the project with the highest awesomeness score. If multiple projects have the same score, the lexicographically smallest project is returned. highest_score = -1 best_project = None for project in projects: # Sort the project string lexicographically sorted_project = ''.join(sorted(project)) # Calculate the awesomeness score awesomeness_score = sum(ord(c) for c in sorted_project) # Check if this project has the highest score or is lexicographically smaller than the current best one if awesomeness_score > highest_score or (awesomeness_score == highest_score and sorted_project < best_project): highest_score = awesomeness_score best_project = project return best_project"},{"question":"def num_distinct_subsequences(s: str) -> int: Computes the number of distinct subsequences of a given string. >>> num_distinct_subsequences(\\"abc\\") 8 >>> num_distinct_subsequences(\\"ab\\") 4 >>> num_distinct_subsequences(\\"aa\\") 3 >>> num_distinct_subsequences(\\"abcd\\") 16 >>> num_distinct_subsequences(\\"\\") 1","solution":"def num_distinct_subsequences(s): Computes the number of distinct subsequences of a given string. n = len(s) dp = [1] * (n + 1) last_occurrence = {} for i in range(1, n + 1): dp[i] = 2 * dp[i - 1] if s[i - 1] in last_occurrence: dp[i] -= dp[last_occurrence[s[i - 1]] - 1] last_occurrence[s[i - 1]] = i return dp[n]"},{"question":"class ParkingLot: def __init__(self, n): self.spaces = [False] * n def park_car(self, x): Park a car in the x-th parking space. If the parking space is already occupied, return \\"Already occupied\\". pass def remove_car(self, x): Remove the car from the x-th parking space. If the parking space is already empty, return \\"Already empty\\". pass def count_occupied(self, l, r): Count the number of occupied parking spaces in the range [l, r] (both inclusive). pass def manage_parking_lot(n, operations): Manage the parking lot with the given operations. Args: n: Number of parking spaces. operations: List of operations to be performed. Returns: List of results from operations of type 3. pass import pytest def test_operations(): operations = [ \\"1 3\\", \\"1 3\\", \\"3 1 5\\", \\"2 3\\", \\"3 1 5\\" ] assert manage_parking_lot(6, operations) == [\\"Already occupied\\", \\"1\\", \\"0\\"] def test_empty_parking_lot(): operations = [ \\"1 1\\", \\"2 1\\", \\"2 1\\" ] assert manage_parking_lot(1, operations) == [\\"Already empty\\"] def test_range_count(): operations = [ \\"1 1\\", \\"1 2\\", \\"1 3\\", \\"3 1 3\\", \\"2 2\\", \\"3 1 3\\" ] assert manage_parking_lot(3, operations) == [\\"3\\", \\"2\\"] def test_no_operation(): operations = [] assert manage_parking_lot(5, operations) == [] if __name__ == \\"__main__\\": pytest.main()","solution":"class ParkingLot: def __init__(self, n): self.spaces = [False] * n def park_car(self, x): if self.spaces[x-1]: return \\"Already occupied\\" else: self.spaces[x-1] = True def remove_car(self, x): if not self.spaces[x-1]: return \\"Already empty\\" else: self.spaces[x-1] = False def count_occupied(self, l, r): return sum(self.spaces[l-1:r]) def manage_parking_lot(n, operations): parking_lot = ParkingLot(n) output = [] for operation in operations: parts = list(map(int, operation.split())) if parts[0] == 1: result = parking_lot.park_car(parts[1]) if result: output.append(result) elif parts[0] == 2: result = parking_lot.remove_car(parts[1]) if result: output.append(result) elif parts[0] == 3: output.append(str(parking_lot.count_occupied(parts[1], parts[2]))) return output"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Design a function that finds the longest common subsequence between two given strings using dynamic programming. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Args: s1 (str): First input string. s2 (str): Second input string. Returns: int: The length of the longest common subsequence. Example: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between two given strings. m, n = len(s1), len(s2) # Create a 2D array to store the lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def find_subset_with_sum(arr: List[int], S: int) -> List[int]: Determine if there is a subset of the array whose elements sum up to the target sum. If such a subset exists, return the subset. If there are multiple solutions, return any single one of them. If no such subset exists, return an empty array. >>> find_subset_with_sum([3, 34, 4, 12, 5, 2], 9) [4, 5] >>> find_subset_with_sum([1, 2, 3, 4, 5], 10) [1, 2, 3, 4] >>> find_subset_with_sum([-5, -3, -2, 1, 2, 3, 4, 5], 0) [-5, 5] >>> find_subset_with_sum([1, 2, 3], 7) [] >>> find_subset_with_sum([10], 10) [10] >>> find_subset_with_sum([10], 5) [] >>> find_subset_with_sum([-4, -3, 2, 5, 1], 3) [2, 1]","solution":"from typing import List def find_subset_with_sum(arr: List[int], S: int) -> List[int]: n = len(arr) def subsets(idx, current_subset, current_sum): if idx == n: if current_sum == S: return current_subset return None # Include arr[idx] in subset result_with = subsets(idx + 1, current_subset + [arr[idx]], current_sum + arr[idx]) if result_with is not None: return result_with # Exclude arr[idx] from subset result_without = subsets(idx + 1, current_subset, current_sum) if result_without is not None: return result_without return None result = subsets(0, [], 0) return result or [] # Example usages # print(find_subset_with_sum([3, 34, 4, 12, 5, 2], 9)) # Expected Output: [4, 5] # print(find_subset_with_sum([1, 2, 3, 4, 5], 10)) # Expected Output: [1, 2, 3, 4] # print(find_subset_with_sum([-5, -3, -2, 1, 2, 3, 4, 5], 0)) # Expected Output: [-5, 5]"},{"question":"def max_sum_petya(n: int, array: List[int]) -> int: Petya and Vasya are playing a game with an array of integers. The rules of the game are as follows: 1. Both players alternately pick numbers from the array. 2. Petya always starts first. 3. In each turn, a player can pick either the first or the last number from the array. 4. The game continues until all numbers are picked. Both players want to maximize the sum of the numbers they have picked by the end of the game. Given the initial array of integers, determine the maximum possible sum Petya can achieve if both players play optimally. :param n: An integer representing the length of the array. :param array: A list of integers representing the elements of the array. :return: The maximum possible sum Petya can achieve. >>> max_sum_petya(4, [4, 7, 2, 9]) 16 >>> max_sum_petya(1, [5]) 5 >>> max_sum_petya(2, [10, 11]) 11 >>> max_sum_petya(3, [8, 15, 3]) 11 >>> max_sum_petya(6, [1, 2, 3, 4, 5, 6]) 12 >>> max_sum_petya(4, [5, 5, 5, 5]) 10 >>> max_sum_petya(6, [9, 1, 8, 2, 7, 3]) 24","solution":"def max_sum_petya(n, array): # Create a 2D DP table to store the best possible scores for subarrays dp = [[0] * n for _ in range(n)] # Fill the table for one-element subarrays (diagonal) for i in range(n): dp[i][i] = array[i] # Fill the rest of the dp table for length in range(2, n + 1): # length of the subarray for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max( array[i] + min(dp[i + 2][j] if (i + 2 <= j) else 0, dp[i + 1][j - 1] if (i + 1 <= j - 1) else 0), array[j] + min(dp[i + 1][j - 1] if (i + 1 <= j - 1) else 0, dp[i][j - 2] if (i <= j - 2) else 0) ) # Petya starts first, so the answer is in dp[0][n-1] return dp[0][n - 1]"},{"question":"def maximum_beauty_scores(n, beauty_scores, q, queries): Returns the maximum beauty score for each given range of canvases. :param n: Number of canvases :param beauty_scores: List of beauty scores of each canvas :param q: Number of queries :param queries: List of tuples, each containing a range (l, r) :return: List of maximum beauty scores for each query >>> maximum_beauty_scores(5, [2, 4, 6, 8, 10], 3, [(1, 3), (2, 5), (1, 5)]) [6, 10, 10] >>> maximum_beauty_scores(1, [10], 1, [(1, 1)]) [10] >>> maximum_beauty_scores(5, [1, 3, 5, 7, 9], 3, [(1, 3), (1, 3), (1, 3)]) [5, 5, 5] >>> maximum_beauty_scores(4, [2, 3, 1, 4], 1, [(1, 4)]) [4] >>> maximum_beauty_scores(5, [5, 5, 5, 5, 5], 1, [(2, 4)]) [5] >>> maximum_beauty_scores(4, [1, 100, 30, 50], 2, [(1, 2), (3, 4)]) [100, 50]","solution":"def maximum_beauty_scores(n, beauty_scores, q, queries): Returns the maximum beauty score for each given range of canvases. :param n: Number of canvases :param beauty_scores: List of beauty scores of each canvas :param q: Number of queries :param queries: List of tuples, each containing a range (l, r) :return: List of maximum beauty scores for each query results = [] for l, r in queries: results.append(max(beauty_scores[l-1:r])) return results"},{"question":"from typing import List, Tuple class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = n def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def get_count(self): return self.count def count_groups(n: int, m: int, trails: List[Tuple[int, int]]) -> List[int]: Determine the number of distinct groups of camps after each trail construction. Args: n (int): number of locations m (int): number of trails trails (List[Tuple[int, int]]): list of trails to be constructed Returns: List[int]: number of distinct groups after each trail is built >>> count_groups(5, 4, [(1, 2), (2, 3), (4, 5), (3, 4)]) [4, 3, 2, 1] >>> count_groups(2, 1, [(1, 2)]) [1] >>> count_groups(3, 3, [(1, 2), (2, 3), (1, 3)]) [2, 1, 1] >>> count_groups(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) [5, 4, 3, 2] >>> count_groups(7, 6, [(1, 2), (3, 4), (1, 3), (5, 6), (6, 7), (4, 5)]) [6, 5, 4, 3, 2, 1]","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = n def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def get_count(self): return self.count def count_groups(n, m, trails): uf = UnionFind(n) result = [] for a, b in trails: uf.union(a - 1, b - 1) # convert 1-based index to 0-based result.append(uf.get_count()) return result"},{"question":"def check_indentation(n: int, lines: List[str]) -> str: Check whether a given piece of code has consistent indentation according to the specified rules. - Code lines should be indented using only spaces. - All lines in a block should be indented the same number of spaces. - Nested blocks should be indented by exactly 4 spaces more than the containing block. - The first line of the code is not indented. Args: n: An integer representing the number of lines in the code. lines: A list of strings where each string represents a line of code. Returns: A string \\"YES\\" if the code follows the indentation rules, \\"NO\\" otherwise. Examples: >>> check_indentation(4, [\\"def main():\\", \\" print('Hello, World!')\\", \\" if condition:\\", \\" print('Condition met')\\"]) 'YES' >>> check_indentation(4, [\\"def hello():\\", \\" print('Hello, World!')\\", \\"if True:\\", \\" print('True!')\\"]) 'NO' pass def test_consistent_indentation_with_nested_blocks(): assert check_indentation(4, [ \\"def main():\\", \\" print(\\"Hello, World!\\")\\", \\" if condition:\\", \\" print(\\"Condition met\\")\\" ]) == \\"YES\\" def test_inconsistent_indentation_with_spaced_method(): assert check_indentation(4, [ \\"def hello():\\", \\" print(\\"Hello, World!\\")\\", \\"if True:\\", \\" print(\\"True!\\")\\" ]) == \\"NO\\" def test_mixed_indentations(): assert check_indentation(6, [ \\"def func():\\", \\" line1\\", \\" line2\\", \\" line3\\", \\" if something:\\", \\" line4\\" ]) == \\"NO\\" def test_empty_lines_and_nested_blocks(): assert check_indentation(8, [ \\"def main():\\", \\"\\", \\" if condition1:\\", \\" action1\\", \\"\\", \\" if condition2:\\", \\" action2\\", \\"after_main\\" ]) == \\"NO\\" def test_complete_correct_code_structure(): assert check_indentation(3, [ \\"def main():\\", \\" if True:\\", \\" pass\\" ]) == \\"YES\\"","solution":"def check_indentation(n, lines): def is_valid_indentation(line, expected_indent): count_spaces = len(line) - len(line.lstrip(' ')) if count_spaces != expected_indent: return False return True expected_indent_stack = [0] for line in lines: stripped_line = line.strip() if not stripped_line: continue # skip empty lines current_expected_indent = expected_indent_stack[-1] if not is_valid_indentation(line, current_expected_indent): return \\"NO\\" if stripped_line.endswith(':'): expected_indent_stack.append(current_expected_indent + 4) elif not stripped_line: continue else: while len(expected_indent_stack) > 1 and len(line) - len(line.lstrip(' ')) < expected_indent_stack[-1]: expected_indent_stack.pop() return \\"YES\\""},{"question":"def sort_visitors(n: int, visitors: List[Tuple[str, str]]) -> List[str]: Sort the visitors based on the given rules. :param n: Number of visitors :param visitors: List of tuples where each tuple contains (name, category) :return: List of names sorted according to the rules >>> sort_visitors(6, [(\\"Alice\\", \\"VIP\\"), (\\"Bob\\", \\"senior\\"), (\\"Charlie\\", \\"child\\"), (\\"Daisy\\", \\"adult\\"), (\\"Eve\\", \\"VIP\\"), (\\"Fred\\", \\"senior\\")]) [\\"Alice\\", \\"Eve\\", \\"Bob\\", \\"Fred\\", \\"Charlie\\", \\"Daisy\\"] >>> sort_visitors(4, [(\\"Alice\\", \\"adult\\"), (\\"Bob\\", \\"child\\"), (\\"Charlie\\", \\"senior\\"), (\\"Eve\\", \\"VIP\\")]) [\\"Eve\\", \\"Charlie\\", \\"Bob\\", \\"Alice\\"] from solution import sort_visitors def test_single_visitor(): assert sort_visitors(1, [(\\"Alice\\", \\"VIP\\")]) == [\\"Alice\\"] def test_all_categories(): assert sort_visitors(4, [(\\"Alice\\", \\"adult\\"), (\\"Bob\\", \\"child\\"), (\\"Charlie\\", \\"senior\\"), (\\"Eve\\", \\"VIP\\")]) == [\\"Eve\\", \\"Charlie\\", \\"Bob\\", \\"Alice\\"] def test_multiple_visitors_same_category(): assert sort_visitors(3, [(\\"Alice\\", \\"VIP\\"), (\\"Bob\\", \\"VIP\\"), (\\"Charlie\\", \\"VIP\\")]) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_complex_case(): assert sort_visitors(6, [(\\"Alice\\", \\"VIP\\"), (\\"Bob\\", \\"senior\\"), (\\"Charlie\\", \\"child\\"), (\\"Daisy\\", \\"adult\\"), (\\"Eve\\", \\"VIP\\"), (\\"Fred\\", \\"senior\\")]) == [\\"Alice\\", \\"Eve\\", \\"Bob\\", \\"Fred\\", \\"Charlie\\", \\"Daisy\\"] def test_no_vip(): assert sort_visitors(4, [(\\"Alice\\", \\"senior\\"), (\\"Bob\\", \\"child\\"), (\\"Charlie\\", \\"adult\\"), (\\"Daisy\\", \\"child\\")]) == [\\"Alice\\", \\"Bob\\", \\"Daisy\\", \\"Charlie\\"] def test_no_senior(): assert sort_visitors(3, [(\\"Alice\\", \\"VIP\\"), (\\"Bob\\", \\"child\\"), (\\"Charlie\\", \\"adult\\")]) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_edge_case_max_visitors(): visitors = [(\\"Visitor\\" + str(i), \\"VIP\\") for i in range(1, 101)] expected = [\\"Visitor\\" + str(i) for i in range(1, 101)] assert sort_visitors(100, visitors) == expected","solution":"def sort_visitors(n, visitors): Sort the visitors based on the given rules. :param n: Number of visitors :param visitors: List of tuples where each tuple contains (name, category) :return: List of names sorted according to the rules category_priorities = {'VIP': 1, 'senior': 2, 'child': 3, 'adult': 4} # Sort visitors according to category priority and their original order sorted_visitors = sorted(visitors, key=lambda v: category_priorities[v[1]]) # Extract sorted names sorted_names = [visitor[0] for visitor in sorted_visitors] return sorted_names"},{"question":"from typing import List, Tuple def detect_fraudulent_transactions(D: int, T: int, transactions: List[Tuple[int, int]]) -> List[int]: Detect fraudulent transactions based on the same user making more than \`T\` transactions within any \`D\` day period. >>> detect_fraudulent_transactions(3, 2, [(1, 1), (1, 2), (1, 3), (2, 1), (2, 3)]) [1] >>> detect_fraudulent_transactions(3, 2, [(1, 1), (1, 3), (2, 5), (2, 6), (2, 8)]) [] pass def main(D: int, T: int, n: int, data: List[str]) -> List[int]: transactions = [tuple(map(int, data[i].split())) for i in range(n)] return detect_fraudulent_transactions(D, T, transactions) if __name__ == \\"__main__\\": D, T = map(int, input().split()) n = int(input()) data = [input().strip() for _ in range(n)] result = main(D, T, n, data) for user in result: print(user)","solution":"def detect_fraudulent_transactions(D, T, transactions): from collections import defaultdict fraudulent_users = set() user_transactions = defaultdict(list) # Populate user transactions dictionary for user_id, timestamp in transactions: user_transactions[user_id].append(timestamp) # Check each user for fraudulent behavior for user_id, timestamps in user_transactions.items(): timestamps.sort() for i in range(len(timestamps)): count = 0 for j in range(i, len(timestamps)): if timestamps[j] <= timestamps[i] + D - 1: count += 1 else: break if count > T: fraudulent_users.add(user_id) break return sorted(fraudulent_users) def main(D, T, n, data): transactions = [tuple(map(int, data[i].split())) for i in range(n)] return detect_fraudulent_transactions(D, T, transactions)"},{"question":"def plant_garden(m: int, n: int): Plant the garden in such a way that no two plants with the same type are in the same row or column. Args: m (int): The number of rows in the garden. n (int): The number of columns in the garden. Returns: list: A 2D list representing the garden, where each cell contains the plant type. If it's not possible, return -1. >>> plant_garden(3, 3) [[1, 2, 3], [2, 3, 1], [3, 1, 2]] >>> plant_garden(2, 3) [[1, 2, 3], [2, 3, 1]] >>> plant_garden(4, 5) [[1, 2, 3, 4, 5], [2, 3, 4, 5, 1], [3, 4, 5, 1, 2], [4, 5, 1, 2, 3]] >>> plant_garden(0, 5) -1","solution":"def plant_garden(m, n): if m == 0 or n == 0: return -1 result = [] for i in range(m): row = [(i + j) % n + 1 for j in range(n)] result.append(row) return result"},{"question":"from typing import List, Tuple, Union def can_form_strictly_increasing_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Union[List[int], int]]: Determine if you can rearrange the integers in such a way that the resulting list forms a strictly increasing sequence. Return the rearranged sequence if possible, otherwise return -1. >>> can_form_strictly_increasing_sequence(2, [(5, [1, 3, 2, 3, 4]), (3, [1, 2, 3])]) [-1, [1, 2, 3]] >>> can_form_strictly_increasing_sequence(3, [(4, [4, 3, 2, 1]), (6, [1, 1, 1, 1, 1, 1]), (4, [1, 2, 2, 3])]) [[1, 2, 3, 4], -1, -1]","solution":"def can_form_strictly_increasing_sequence(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] numbers = test_cases[i][1] if len(set(numbers)) != n: results.append(-1) else: results.append(sorted(numbers)) return results # Example usage to verify the solution t = 2 test_cases = [ (5, [1, 3, 2, 3, 4]), (3, [1, 2, 3]) ] print(can_form_strictly_increasing_sequence(t, test_cases))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes: return None n = len(nodes) node_dict = {i: TreeNode(val=nodes[i-1][0]) for i in range(1, n+1)} for i in range(1, n+1): val, l, r = nodes[i-1] node_dict[i].left = node_dict.get(l, None) node_dict[i].right = node_dict.get(r, None) return node_dict[1] def subtree_info(node): if not node: return (0, 0) left_sum, left_count = subtree_info(node.left) right_sum, right_count = subtree_info(node.right) current_sum = node.val + left_sum + right_sum current_count = 1 + left_count + right_count return (current_sum, current_count) def average_subtree(node): total_sum, total_count = subtree_info(node) if total_count == 0: return 0 return total_sum / total_count def check_balanced(tree_nodes): root = build_tree(tree_nodes) if not root: return \\"Balanced\\" left_average = average_subtree(root.left) right_average = average_subtree(root.right) if abs(left_average - right_average) <= 1: return \\"Balanced\\" else: return \\"Not Balanced\\" def plant_balance(n, nodes): Computes the average number of days of the left and right subtrees of the root node and determines whether they are balanced. >>> plant_balance(5, [(1, 2, 3), (2, 4, 0), (3, 0, 5), (4, 0, 0), (5, 0, 0)]) \\"Balanced\\" >>> plant_balance(3, [(0, 2, 3), (2, 0, 0), (5, 0, 0)]) \\"Not Balanced\\"","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes: return None n = len(nodes) node_dict = {i: TreeNode(val=nodes[i-1][0]) for i in range(1, n+1)} for i in range(1, n+1): val, l, r = nodes[i-1] node_dict[i].left = node_dict.get(l, None) node_dict[i].right = node_dict.get(r, None) return node_dict[1] def subtree_info(node): if not node: return (0, 0) left_sum, left_count = subtree_info(node.left) right_sum, right_count = subtree_info(node.right) current_sum = node.val + left_sum + right_sum current_count = 1 + left_count + right_count return (current_sum, current_count) def average_subtree(node): total_sum, total_count = subtree_info(node) if total_count == 0: return 0 return total_sum / total_count def check_balanced(tree_nodes): root = build_tree(tree_nodes) if not root: return \\"Balanced\\" left_average = average_subtree(root.left) right_average = average_subtree(root.right) if abs(left_average - right_average) <= 1: return \\"Balanced\\" else: return \\"Not Balanced\\" def plant_balance(n, nodes): return check_balanced(nodes)"},{"question":"def generate_codes(base_string, start, increment, n): Generates a list of alphanumeric codes based on the given base string, start integer, increment, and number of codes. Parameters: base_string (str): The base string to use in the code. start (int): The starting integer value. increment (int): The value to increment the integer by for each new code. n (int): The number of codes to generate. Returns: list: A list of alphanumeric codes generated. >>> generate_codes(\\"alpha\\", 100, 10, 5) ['alpha100', 'alpha110', 'alpha120', 'alpha130', 'alpha140'] >>> generate_codes(\\"base\\", 200, 5, 1) ['base200'] >>> generate_codes(\\"test\\", 1, 1, 5) ['test1', 'test2', 'test3', 'test4', 'test5'] >>> generate_codes(\\"start\\", 500, 500, 4) ['start500', 'start1000', 'start1500', 'start2000'] >>> generate_codes(\\"edge\\", 1, 100000, 2) ['edge1', 'edge100001']","solution":"def generate_codes(base_string, start, increment, n): Generates a list of alphanumeric codes based on the given base string, start integer, increment, and number of codes. Parameters: base_string (str): The base string to use in the code. start (int): The starting integer value. increment (int): The value to increment the integer by for each new code. n (int): The number of codes to generate. Returns: list: A list of alphanumeric codes generated. codes = [] current_value = start for _ in range(n): codes.append(f\\"{base_string}{current_value}\\") current_value += increment return codes"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(values, edges): Build a binary tree from given values and edges. nodes = [TreeNode(val) for val in values] for a, b in edges: a -= 1 b -= 1 connect(nodes[a], nodes[b]) return nodes[0] def connect(node1, node2): Helper function to connect two nodes. if not node1.left: node1.left = node2 elif not node1.right: node1.right = node2 else: connect(node1.left, node2) def maxPathSum(root: TreeNode) -> int: Find the maximum sum of values from any path in the binary tree. >>> root = TreeNode(5) >>> maxPathSum(root) 5 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> maxPathSum(root) 3 >>> root = TreeNode(-10) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxPathSum(root) 42 >>> n = 5 >>> values = [2, -1, 3, 4, -5] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> root = build_tree(values, edges) >>> maxPathSum(root) 9","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(values, edges): nodes = [TreeNode(val) for val in values] for a, b in edges: a -= 1 b -= 1 connect(nodes[a], nodes[b]) return nodes[0] def connect(node1, node2): if not node1.left: node1.left = node2 elif not node1.right: node1.right = node2 else: connect(node1.left, node2) def maxPathSum(root): def dfs(node): nonlocal max_sum if not node: return 0 left_gain = max(dfs(node.left), 0) right_gain = max(dfs(node.right), 0) price_newpath = node.val + left_gain + right_gain max_sum = max(max_sum, price_newpath) return node.val + max(left_gain, right_gain) max_sum = float('-inf') dfs(root) return max_sum # Reading input and building tree n = 5 values = [2, -1, 3, 4, -5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] root = build_tree(values, edges) print(maxPathSum(root)) # Output: 9"},{"question":"def transform_array(arr: List[int]) -> List[int]: For each element in the array, if it is an even number, divide it by 2. If it is an odd number, multiply it by 3 and add 1. Returns the resulting array after all operations are performed. >>> transform_array([4, 15, 8, 23, 42]) [2, 46, 4, 70, 21] >>> transform_array([1, 3, 5, 7]) [4, 10, 16, 22]","solution":"def transform_array(arr): For each element in the array, if it is an even number, divide it by 2. If it is an odd number, multiply it by 3 and add 1. Returns the resulting array after all operations are performed. result = [] for num in arr: if num % 2 == 0: result.append(num // 2) else: result.append(num * 3 + 1) return result"},{"question":"from typing import List def game_of_life(initial_state: List[List[int]], k: int) -> List[List[int]]: Compute the state of the grid after k generations in Miranda's variation of Conway's Game of Life. >>> initial_state = [ ... [0, 1, 0], ... [0, 0, 1], ... [1, 1, 1], ... [0, 0, 0] ... ] >>> k = 1 >>> game_of_life(initial_state, k) [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]]","solution":"from typing import List def game_of_life(initial_state: List[List[int]], k: int) -> List[List[int]]: def get_neighbors_count(board: List[List[int]], x: int, y: int) -> int: directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]): count += board[nx][ny] return count def next_state(board: List[List[int]]) -> List[List[int]]: m, n = len(board), len(board[0]) new_board = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): neighbors = get_neighbors_count(board, i, j) if board[i][j] == 1: if neighbors < 2 or neighbors > 3: new_board[i][j] = 0 else: new_board[i][j] = 1 else: if neighbors == 3: new_board[i][j] = 1 return new_board board = initial_state for _ in range(k): board = next_state(board) return board"},{"question":"def min_adjacent_swaps_to_sort(nums): Function to return the minimum number of adjacent swaps needed to sort the list. swaps = 0 n = len(nums) for i in range(n): for j in range(0, n-i-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] swaps += 1 return swaps def process_test_cases(t, test_data): Function to process multiple test cases and return the results. result = [] for i in range(t): n = test_data[i][0] nums = test_data[i][1] result.append(min_adjacent_swaps_to_sort(nums)) return result def test_min_adjacent_swaps_to_sort(): Unit test for min_adjacent_swaps_to_sort function. assert min_adjacent_swaps_to_sort([3, 1, 2, 4, 5]) == 2 assert min_adjacent_swaps_to_sort([4, 3, 2, 1]) == 6 assert min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) == 0 assert min_adjacent_swaps_to_sort([2]) == 0 def test_process_test_cases(): Unit test for process_test_cases function. assert process_test_cases(2, [(5, [3, 1, 2, 4, 5]), (4, [4, 3, 2, 1])]) == [2, 6] assert process_test_cases(1, [(3, [3, 2, 1])]) == [3] assert process_test_cases(1, [(5, [5, 4, 3, 2, 1])]) == [10] assert process_test_cases(3, [(2, [2, 1]), (3, [3, 2, 1]), (4, [1, 3, 2, 4])]) == [1, 3, 1]","solution":"def min_adjacent_swaps_to_sort(nums): Function to return the minimum number of adjacent swaps needed to sort the list. swaps = 0 n = len(nums) for i in range(n): for j in range(0, n-i-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] swaps += 1 return swaps def process_test_cases(t, test_data): result = [] for i in range(t): n = test_data[i][0] nums = test_data[i][1] result.append(min_adjacent_swaps_to_sort(nums)) return result"},{"question":"def smallest_subarray_with_sum_at_least_x(n, x, A): Find the length of the smallest contiguous subarray with sum at least x. >>> smallest_subarray_with_sum_at_least_x(6, 7, [2, 3, 1, 2, 4, 3]) 2 >>> smallest_subarray_with_sum_at_least_x(5, 100, [1, 2, 3, 4, 5]) 0 >>> smallest_subarray_with_sum_at_least_x(4, 10, [2, 1, 5, 2]) 4 >>> smallest_subarray_with_sum_at_least_x(5, 4, [1, 4, 1, 1, 2]) 1 >>> smallest_subarray_with_sum_at_least_x(8, 15, [1, 2, 3, 4, 5, 6, 1, 2]) 3 >>> smallest_subarray_with_sum_at_least_x(6, 10, [1, 2, 3, 1, 1, 1]) 0","solution":"def smallest_subarray_with_sum_at_least_x(n, x, A): Find the length of the smallest contiguous subarray with sum at least x. min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += A[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= A[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"def manage_books(commands: List[str]) -> List[int]: Simulate the borrowing and returning process of books in a library management system. Each student can borrow up to 3 books at a time. The input consists of a series of commands in the format \\"borrow <book_id>\\" or \\"return <book_id>\\", and the input ends with the command \\"end\\". The function returns the final list of borrowed books in ascending order of book IDs. >>> manage_books([\\"borrow 101\\", \\"borrow 102\\", \\"borrow 103\\", \\"end\\"]) [101, 102, 103] >>> manage_books([\\"borrow 101\\", \\"borrow 102\\", \\"borrow 103\\", \\"borrow 104\\", \\"end\\"]) [101, 102, 103] >>> manage_books([\\"borrow 101\\", \\"borrow 102\\", \\"borrow 103\\", \\"return 102\\", \\"end\\"]) [101, 103] >>> manage_books([\\"borrow 101\\", \\"return 101\\", \\"borrow 101\\", \\"end\\"]) [101] # Your code here","solution":"def manage_books(commands): borrowed_books = set() for command in commands: parts = command.split() if len(parts) != 2: continue action, book_id_str = parts[0], parts[1] try: book_id = int(book_id_str) except ValueError: continue if action == \\"borrow\\": if len(borrowed_books) < 3 and book_id not in borrowed_books: borrowed_books.add(book_id) elif action == \\"return\\": borrowed_books.discard(book_id) return sorted(borrowed_books)"},{"question":"def is_prime(num): Utility function to check if a number is prime. # Implementation here def prime_matrix(n): Generate an n x n matrix filled with prime numbers in increasing order. Args: n (int): The size of the matrix. Returns: List[List[int]]: A 2D list representing the n x n prime matrix. Examples: >>> prime_matrix(1) [[2]] >>> prime_matrix(2) [[2, 3], [5, 7]] >>> prime_matrix(3) [[2, 3, 5], [7, 11, 13], [17, 19, 23]] # Implementation here from solution import is_prime, prime_matrix def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(11) == True assert is_prime(1) == False def test_prime_matrix_1x1(): expected = [[2]] assert prime_matrix(1) == expected def test_prime_matrix_2x2(): expected = [ [2, 3], [5, 7] ] assert prime_matrix(2) == expected def test_prime_matrix_3x3(): expected = [ [2, 3, 5], [7, 11, 13], [17, 19, 23] ] assert prime_matrix(3) == expected def test_prime_matrix_4x4(): expected = [ [2, 3, 5, 7], [11, 13, 17, 19], [23, 29, 31, 37], [41, 43, 47, 53] ] assert prime_matrix(4) == expected","solution":"def is_prime(num): Utility function to check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def prime_matrix(n): Generate an n x n matrix filled with prime numbers in increasing order. prime_numbers = [] current_num = 2 while len(prime_numbers) < n * n: if is_prime(current_num): prime_numbers.append(current_num) current_num += 1 matrix = [] for i in range(n): row = prime_numbers[i * n:(i + 1) * n] matrix.append(row) return matrix"},{"question":"def smallest_lexicographical_string(s: str) -> str: Replace all '*' characters in the string s with the smallest lexicographical characters to form the smallest possible lexicographical string. Args: s (str): Input string containing lowercase alphabets and '*' Returns: str: The a string with all '*' replaced by the smallest lexicographical character Examples: >>> smallest_lexicographical_string(\\"a*c*b\\") 'aacab' >>> smallest_lexicographical_string(\\"*bc\\") 'abc'","solution":"def smallest_lexicographical_string(s): Replace all '*' characters in the string s with the smallest lexicographical characters to form the smallest possible lexicographical string. result = [] for char in s: if char == '*': result.append('a') else: result.append(char) return ''.join(result)"},{"question":"def min_value_difference(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum possible difference in total value between the most valuable box and the least valuable box once all items are distributed. >>> min_value_difference(1, [(6, 3, [1, 2, 3, 4, 5, 6])]) [2] >>> min_value_difference(1, [(4, 2, [7, 8, 5, 2])]) [1] Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of test cases where each test case is a tuple containing number of items, number of boxes, and a list of item values. Returns: List[int]: List of minimum possible differences for each test case.","solution":"def min_value_difference(t, test_cases): def find_minimum_difference(n, k, items): items.sort() min_diff = float('inf') for i in range(n - k + 1): diff = items[i+k-1] - items[i] min_diff = min(min_diff, diff) return min_diff results = [] for case in test_cases: n, k, items = case results.append(find_minimum_difference(n, k, items)) return results"},{"question":"def segregateEvenOdd(arr: List[int]) -> None: Segregates even numbers to the left side and odd numbers to the right side. Modifies the given list in place. >>> arr = [12, 34, 45, 9, 8, 90, 3] >>> segregateEvenOdd(arr) >>> arr [12, 34, 8, 90, 45, 9, 3] >>> arr = [1, 3, 5, 7] >>> segregateEvenOdd(arr) >>> arr [1, 3, 5, 7] >>> arr = [2, 4, 6, 8] >>> segregateEvenOdd(arr) >>> arr [2, 4, 6, 8]","solution":"from typing import List def segregateEvenOdd(arr: List[int]) -> None: Segregates even numbers to the left side and odd numbers to the right side. Modifies the given list in place. n = len(arr) even_index = 0 for i in range(n): if arr[i] % 2 == 0: arr[i], arr[even_index] = arr[even_index], arr[i] even_index += 1"},{"question":"def compress_string(s: str) -> str: Compresses the input string by replacing consecutive repeating characters with the character followed by its count in angle brackets. >>> compress_string(\\"aaaabbbccdaa\\") 'a<4>b<3>c<2>d<1>a<2>' >>> compress_string(\\"abcdef\\") 'a<1>b<1>c<1>d<1>e<1>f<1>'","solution":"def compress_string(s: str) -> str: Takes a string s and compresses it by replacing consecutive repeating characters with the character and its count in angle brackets. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(f\\"{s[i-1]}<{count}>\\") count = 1 compressed.append(f\\"{s[-1]}<{count}>\\") # append the last character count return \\"\\".join(compressed)"},{"question":"def kth_smallest_numbers(n, nums, queries): Given an array of n integers and a series of q queries, this function finds the k-th smallest integer in the subarray for each query. Parameters: n (int): the number of elements in the array. nums (list): the array of n integers. queries (list of tuples): each tuple contains three integers l, r, and k representing each query. Returns: list: a list containing the k-th smallest element from the subarray for each query. from solution import kth_smallest_numbers def test_kth_smallest_numbers(): n = 6 nums = [5, 3, 1, 6, 4, 2] queries = [(1, 4, 2), (2, 5, 3), (1, 6, 4)] expected_output = [3, 4, 4] assert kth_smallest_numbers(n, nums, queries) == expected_output def test_kth_smallest_single_element_subarray(): n = 5 nums = [10, 50, 40, 30, 20] queries = [(1, 1, 1), (5, 5, 1)] expected_output = [10, 20] assert kth_smallest_numbers(n, nums, queries) == expected_output def test_kth_smallest_entire_array(): n = 4 nums = [7, 9, 3, 8] queries = [(1, 4, 1), (1, 4, 4)] expected_output = [3, 9] assert kth_smallest_numbers(n, nums, queries) == expected_output def test_kth_smallest_random_order(): n = 7 nums = [7, 5, 3, 9, 6, 8, 2] queries = [(2, 5, 2), (4, 7, 3)] expected_output = [5, 8] assert kth_smallest_numbers(n, nums, queries) == expected_output def test_kth_smallest_identical_elements(): n = 5 nums = [1, 1, 1, 1, 1] queries = [(1, 5, 1), (1, 5, 3)] expected_output = [1, 1] assert kth_smallest_numbers(n, nums, queries) == expected_output","solution":"def kth_smallest_numbers(n, nums, queries): Given an array of n integers and a series of q queries, this function finds the k-th smallest integer in the subarray for each query. Parameters: n (int): the number of elements in the array. nums (list): the array of n integers. queries (list of tuples): each tuple contains three integers l, r, and k representing each query. Returns: list: a list containing the k-th smallest element from the subarray for each query. results = [] for l, r, k in queries: subarray = nums[l-1:r] subarray.sort() results.append(subarray[k-1]) return results"},{"question":"def can_transform_to_palindrome(s: str) -> str: Determines if it is possible to transform the string into a palindrome with at most one character change. Returns \\"YES\\" if possible, otherwise \\"NO\\". >>> can_transform_to_palindrome(\\"madam\\") == \\"YES\\" >>> can_transform_to_palindrome(\\"abba\\") == \\"YES\\" >>> can_transform_to_palindrome(\\"racecar\\") == \\"YES\\" >>> can_transform_to_palindrome(\\"abca\\") == \\"YES\\" >>> can_transform_to_palindrome(\\"abcdef\\") == \\"NO\\" pass","solution":"def can_transform_to_palindrome(s): Determines if it is possible to transform the string into a palindrome with at most one character change. Returns \\"YES\\" if possible, otherwise \\"NO\\". n = len(s) mismatch_count = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: mismatch_count += 1 if mismatch_count > 1: return \\"NO\\" # If we have at most one mismatch, we can fix it by one change. return \\"YES\\" if mismatch_count <= 1 else \\"NO\\""},{"question":"def minimum_cost_to_connect_stations(n: int, m: int, tracks: List[Tuple[int, int, int]]) -> int: Calculates the minimum cost to connect all stations using Kruskal's algorithm. If all stations cannot be connected, returns \\"Impossible\\". Args: n (int): the number of stations. m (int): the number of potential tracks. tracks (list of tuples): each tuple contains u, v, w representing a track between station u and station v with cost w. Returns: int: minimum total cost to connect all stations or \\"Impossible\\" if it is not possible. import pytest from typing import List, Tuple def test_example(): n = 4 m = 5 tracks = [(1, 2, 5), (1, 3, 10), (1, 4, 7), (2, 3, 6), (3, 4, 1)] assert minimum_cost_to_connect_stations(n, m, tracks) == 12 def test_impossible_case(): n = 4 m = 2 tracks = [(1, 2, 1), (3, 4, 1)] assert minimum_cost_to_connect_stations(n, m, tracks) == \\"Impossible\\" def test_large_case(): n = 5 m = 7 tracks = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 5), (2, 4, 5), (3, 5, 5) ] assert minimum_cost_to_connect_stations(n, m, tracks) == 4 def test_minimum_edge_case(): n = 2 m = 1 tracks = [(1, 2, 1)] assert minimum_cost_to_connect_stations(n, m, tracks) == 1 def test_disconnect_case(): n = 3 m = 2 tracks = [(1, 2, 4), (2, 3, 5)] assert minimum_cost_to_connect_stations(n, m, tracks) == 9 def test_single_node(): n = 1 m = 0 tracks = [] assert minimum_cost_to_connect_stations(n, m, tracks) == 0 # No cost since no edges needed pytest.main()","solution":"def minimum_cost_to_connect_stations(n, m, tracks): Calculates the minimum cost to connect all stations using Kruskal's algorithm. If all stations cannot be connected, returns \\"Impossible\\". Args: n (int): the number of stations. m (int): the number of potential tracks. tracks (list of tuples): each tuple contains u, v, w representing a track between station u and station v with cost w. Returns: int: minimum total cost to connect all stations or \\"Impossible\\" if it is not possible. # Helper function to find the representative of a set def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to unify two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort all the edges based on their weight tracks.sort(key=lambda x: x[2]) parent = list(range(n+1)) rank = [0] * (n+1) mst_cost = 0 edges_used = 0 for u, v, w in tracks: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w edges_used += 1 if edges_used == n - 1: # early exit if we've used exactly n-1 edges break # If we used fewer edges than n-1, it means we couldn't connect all stations if edges_used != n - 1: return \\"Impossible\\" return mst_cost"},{"question":"from typing import List, Tuple def find_trending_posts(interactions: List[Tuple[int, int, int]], k: int, d: int) -> List[int]: Finds posts that are trending based on given interactions, minimum likes k and time window d. Args: interactions (List[Tuple[int, int, int]]): List of tuples with (timestamp, user_id, post_id). k (int): The minimum number of likes required for a post to be trending. d (int): The time window in seconds. Returns: List[int]: List of post IDs that are trending. def test_find_trending_posts(): interactions = [(1, 101, 10), (2, 102, 20), (5, 101, 10), (6, 103, 20), (7, 104, 10), (8, 105, 30), (12, 102, 10)] k = 2 d = 5 assert find_trending_posts(interactions, k, d) == [10, 20] interactions = [(1, 101, 10), (20, 102, 20), (30, 103, 10), (40, 104, 20)] k = 3 d = 5 assert find_trending_posts(interactions, k, d) == [] interactions = [(1, 101, 10), (2, 102, 10), (5, 101, 20), (6, 103, 20), (7, 104, 10), (8, 105, 30), (10, 102, 30), (11, 106, 30)] k = 2 d = 10 assert find_trending_posts(interactions, k, d) == [10, 20, 30] interactions = [(1, 101, 10), (4, 102, 10), (1, 103, 20), (5, 103, 20), (9, 104, 10), (15, 105, 30)] k = 2 d = 4 assert find_trending_posts(interactions, k, d) == [10, 20] interactions = [(1, 101, 10)] k = 1 d = 1 assert find_trending_posts(interactions, k, d) == [10] interactions = [(1, 101, 10), (1, 102, 20), (1, 103, 30)] k = 1 d = 10 assert find_trending_posts(interactions, k, d) == [10, 20, 30]","solution":"from typing import List, Tuple from collections import defaultdict import heapq def find_trending_posts(interactions: List[Tuple[int, int, int]], k: int, d: int) -> List[int]: Finds posts that are trending based on given interactions, minimum likes k and time window d. Args: interactions (List[Tuple[int, int, int]]): List of tuples with (timestamp, user_id, post_id). k (int): The minimum number of likes required for a post to be trending. d (int): The time window in seconds. Returns: List[int]: List of post IDs that are trending. # Initialize structures for processing post_interactions = defaultdict(list) # Group interactions by post ID for timestamp, user_id, post_id in interactions: post_interactions[post_id].append(timestamp) trending_posts = [] # Evaluate each post ID for trending status for post_id, timestamps in post_interactions.items(): timestamps.sort() start_idx = 0 # Use a sliding window algorithm to find if the post is trending for end_idx in range(len(timestamps)): while timestamps[end_idx] - timestamps[start_idx] > d: start_idx += 1 if end_idx - start_idx + 1 >= k: trending_posts.append(post_id) break return trending_posts"},{"question":"from typing import List def min_distance(n: int, m: int, grid: List[List[int]]) -> int: Determines the minimum distance needed to travel from the top-left corner to the bottom-right corner in a grid with some blocked cells. Parameters: n (int): number of rows m (int): number of columns grid (List[List[int]]): the grid where 0 represents an open cell and 1 represents a blocked cell Returns: int: the minimum distance or -1 if no such path exists >>> min_distance(4, 5, [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0] ]) 7 >>> min_distance(3, 3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1 >>> min_distance(2, 2, [[0, 0], [0, 0]]) 2 >>> min_distance(2, 2, [[1, 1], [1, 1]]) -1 >>> min_distance(1, 1, [[0]]) 0 >>> min_distance(1, 1, [[1]]) -1 >>> min_distance(10, 10, [[0]*10 for _ in range(10)]) 18","solution":"from collections import deque def min_distance(n, m, grid): Determines the minimum distance needed to travel from the top-left corner to the bottom-right corner in a grid with some blocked cells. Parameters: n (int): number of rows m (int): number of columns grid (list of list of int): the grid where 0 represents an open cell and 1 represents a blocked cell Returns: int: the minimum distance or -1 if no such path exists if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 # Directions for movement: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS with (row, column, distance) queue = deque([(0, 0, 0)]) # Visited set to keep track of visited cells visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() # If we have reached the bottom-right corner if x == n - 1 and y == m - 1: return dist # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is within the grid and not blocked if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List, Tuple def max_gold_coins(n: int, coins: List[int], edges: List[Tuple[int, int]]) -> int: Determine the maximum number of gold coins Sasha can collect starting from the root and ending at any other node in the forest. n: int - the number of nodes in the tree coins: List[int] - the number of gold coins in each node from node 1 to node n edges: List[Tuple[int, int]] - edges between nodes u and v >>> max_gold_coins(6, [5, 3, 2, 7, 1, 4], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == 15 >>> max_gold_coins(2, [1, 10], [(1, 2)]) == 11","solution":"from collections import defaultdict, deque def max_gold_coins(n, coins, edges): # Create the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # DFS to find the maximum path sum def dfs(node, parent): max_sum = 0 for neighbor in graph[node]: if neighbor != parent: max_sum = max(max_sum, dfs(neighbor, node)) return max_sum + coins[node - 1] return dfs(1, -1)"},{"question":"def identify_gate(unitary) -> int: Identifies whether the unitary operation is Rx or H gate. Returns 0 if it is Rx, 1 if it is H. Parameters: unitary (function): A function representing the unitary operation to be identified. It takes a rotation angle and a qubit as parameters. Example: >>> def Rx(angle, qubit): ... if angle == 0: ... qubit.state = \\"rx_applied\\" >>> identify_gate(Rx) 0 >>> def H(angle, qubit): ... if angle == 0: ... qubit.state = \\"h_applied\\" >>> identify_gate(H) 1","solution":"def identify_gate(unitary): Identifies whether the unitary operation is Rx or H gate. Returns 0 if it is Rx, 1 if it is H. Parameters: unitary (function): A function representing the unitary operation to be identified. It takes a rotation angle and a qubit as parameters. # Mock objects to simulate qubit and measured outcome class MockQubit: def __init__(self): self.state = \\"initial\\" class MockMeasurement: def __call__(self, qubit): return 0 if qubit.state == \\"rx_applied\\" else 1 # Create a mock qubit qubit = MockQubit() # Apply the unitary with 0 rotation angle to the qubit unitary(0, qubit) # Simulate the measurement measurement = MockMeasurement() result = measurement(qubit) # Determine the gate based on measurement if result == 0: return 0 # Rx gate else: return 1 # H gate"},{"question":"def max_length_subarray_with_two_distinct(n: int, arr: List[int]) -> int: Find the maximum length of a subarray that contains at most two distinct integers. >>> max_length_subarray_with_two_distinct(6, [1, 2, 1, 2, 3, 4]) 4 >>> max_length_subarray_with_two_distinct(6, [1, 2, 1, 3, 4, 5]) 3 >>> max_length_subarray_with_two_distinct(1, [1]) 1 >>> max_length_subarray_with_two_distinct(7, [1, 2, 1, 2, 1, 2, 1]) 7 >>> max_length_subarray_with_two_distinct(5, [1, 2, 3, 2, 2]) 4 >>> max_length_subarray_with_two_distinct(0, []) 0 >>> max_length_subarray_with_two_distinct(5, [1, 2, 2, 2, 2]) 5 >>> max_length_subarray_with_two_distinct(10, [1, 2, 3, 4, 5, 1, 2, 1, 1, 1]) 5 pass","solution":"def max_length_subarray_with_two_distinct(n, arr): if n == 0: return 0 left = 0 right = 0 max_length = 0 freq_map = {} while right < n: if arr[right] in freq_map: freq_map[arr[right]] += 1 else: freq_map[arr[right]] = 1 while len(freq_map) > 2: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: del freq_map[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def count_lexicographically_smallest_strings(M: int, S: str) -> int: Determine the number of different lexicographically smallest strings that can be obtained after performing exactly M operations. >>> count_lexicographically_smallest_strings(1, \\"ba\\") == 1 >>> count_lexicographically_smallest_strings(0, \\"ba\\") == 0 >>> count_lexicographically_smallest_strings(2, \\"cba\\") == 1 >>> count_lexicographically_smallest_strings(1, \\"a\\") == 1","solution":"def count_lexicographically_smallest_strings(M, S): Returns the number of different lexicographically smallest strings that can be obtained after performing exactly M operations. # Sorting the string to obtain the lexicographically smallest version sorted_S = ''.join(sorted(S)) # We only need to determine if it's possible to obtain the sorted_S using exactly M operations if S == sorted_S: # If S is already sorted, no operations are required return 1 elif M >= len(S) - 1: # If we have more or equal operations as the length of the string - 1, we can always get the lexicographically smallest string return 1 else: # If the number of operations is less than the length of the string - 1, we can't guarantee we'd get the lexicographically smallest string return 0"},{"question":"def form_dance_circle(p: int, q: int) -> str: Returns a string representing the optimal arrangement of men (M) and women (W) such that they alternate as much as possible in a circle. >>> form_dance_circle(3, 2) in {\\"MWMWM\\", \\"WMWMW\\"} True >>> form_dance_circle(2, 3) in {\\"MWMWM\\", \\"WMWMW\\"} True >>> form_dance_circle(4, 2) in {\\"MWMWMM\\", \\"WMWMMM\\"} True >>> form_dance_circle(1, 1) in {\\"MW\\", \\"WM\\"} True >>> form_dance_circle(5, 5) 10 >>> form_dance_circle(10, 1) in {\\"MWMMMMMMMMM\\", \\"WMMMMMMMMMM\\"} True","solution":"def form_dance_circle(p, q): Returns a string representing the optimal arrangement of men (M) and women (W) such that they alternate as much as possible in a circle. arrangement = [] larger = 'M' if p > q else 'W' larger_count = max(p, q) smaller = 'W' if p > q else 'M' smaller_count = min(p, q) diff = larger_count - smaller_count for i in range(smaller_count): arrangement.append(larger) arrangement.append(smaller) arrangement += [larger] * diff return ''.join(arrangement)"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product that can be obtained by multiplying any three integers from the list. >>> maximum_product_of_three([1, 2, 3, 4, 5]) 60 >>> maximum_product_of_three([-10, -10, 1, 3, 2]) 300 >>> maximum_product_of_three([-5, -4, -3, -2, -1]) -6 >>> maximum_product_of_three([-10, -10, 5, 2, 4, 6]) 600 >>> maximum_product_of_three([-3, 1, 2]) -6 >>> maximum_product_of_three([-1000, -1000, 1000, 1, 2, 3]) 1000000000","solution":"def maximum_product_of_three(nums): Returns the maximum product that can be obtained by multiplying any three integers from the list. nums.sort() # The maximum product can be obtained from: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers (could be negative) and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def lockers_open(t, cases): Determine which lockers are open after all students have toggled the lockers. Parameters: t (int): Number of test cases. cases (list of int): Each element represents the number of lockers for a test case. Returns: list of list of int: Each inner list contains the locker numbers that remain open. >>> lockers_open(3, [1, 2, 10]) [[1], [1], [1, 4, 9]] >>> lockers_open(1, [100]) [[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]] >>> lockers_open(1, [2]) [[1]]","solution":"def lockers_open(t, cases): Determine which lockers are open after all students have toggled the lockers. Parameters: t (int): Number of test cases. cases (list of int): Each element represents the number of lockers for a test case. Returns: list of list of int: Each inner list contains the locker numbers that remain open. results = [] for n in cases: open_lockers = [i * i for i in range(1, int(n**0.5) + 1)] results.append(open_lockers) return results"},{"question":"def find_overall_leader(n: int, m: int, scores: List[List[int]]) -> int: Determine the overall leader of a competition based on scores across multiple rounds. Args: n: int - Number of players m: int - Number of rounds scores: List[List[int]] - Scores of players in each round Returns: int - Index of the overall leader >>> find_overall_leader(3, 3, [[10, 20, 30], [30, 20, 10], [20, 20, 20]]) 1 >>> find_overall_leader(2, 2, [[5, 10], [20, 5]]) 2","solution":"def find_overall_leader(n, m, scores): leader_index = 0 highest_total_score = -1 highest_single_score = -1 for i in range(n): total_score = sum(scores[i]) single_high_score = max(scores[i]) if (total_score > highest_total_score) or (total_score == highest_total_score and single_high_score > highest_single_score) or (total_score == highest_total_score and single_high_score == highest_single_score and i < leader_index): highest_total_score = total_score highest_single_score = single_high_score leader_index = i return leader_index + 1 # returning 1-based index"},{"question":"def max_books_within_sum(n: int, widths: List[int], S: int) -> int: Returns the maximum number of contiguous books Mike can select such that the sum of their widths does not exceed S. >>> max_books_within_sum(5, [1, 2, 3, 4, 5], 10) 4 >>> max_books_within_sum(3, [1, 1, 2], 4) 3 >>> max_books_within_sum(1, [10], 10) 1 >>> max_books_within_sum(3, [10000, 10000, 10000], 10000) 1 >>> max_books_within_sum(3, [5, 6, 7], 4) 0 >>> max_books_within_sum(5, [4, 3, 1, 2, 8], 8) 3 >>> max_books_within_sum(5, [1, 2, 3, 4, 5], 0) 0 >>> max_books_within_sum(4, [3, 1, 4, 2], 10) 4 >>> max_books_within_sum(7, [1, 2, 3, 4, 1, 2, 1], 5) 3","solution":"def max_books_within_sum(n, widths, S): Returns the maximum number of contiguous books Mike can select such that the sum of their widths does not exceed S. max_books = 0 current_sum = 0 left = 0 for right in range(n): current_sum += widths[right] while current_sum > S: current_sum -= widths[left] left += 1 max_books = max(max_books, right - left + 1) return max_books"},{"question":"def can_arrange_seating(n: int, dietary_preferences: str) -> str: Determines if it is possible to arrange the guests such that no two guests with the same dietary preference sit next to each other. Args: n: int, number of guests dietary_preferences: str, string representation of dietary preferences of guests Returns: str: \\"YES\\" if such an arrangement is possible, otherwise \\"NO\\" >>> can_arrange_seating(6, \\"VNVNGG\\") \\"YES\\" >>> can_arrange_seating(3, \\"VVV\\") \\"NO\\"","solution":"def can_arrange_seating(n, dietary_preferences): Determines if it is possible to arrange the guests such that no two guests with the same dietary preference sit next to each other. Args: n: int, number of guests dietary_preferences: str, string representation of dietary preferences of guests Returns: str: \\"YES\\" if such an arrangement is possible, otherwise \\"NO\\" from collections import Counter # Count the frequency of each dietary preference freq = Counter(dietary_preferences) # Find the maximum count of any dietary preference max_count = max(freq.values()) # If the maximum count is more than half the total number of guests (rounded up), it is not possible if max_count > (n + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def min_absolute_difference(arr: List[int]) -> List[int]: Given an array, returns a permutation which minimizes the maximum absolute difference between any two consecutive elements. >>> min_absolute_difference([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] >>> min_absolute_difference([10, 20, 30]) == [10, 20, 30] def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Process multiple test cases and return the results for each one. >>> process_test_cases(2, [(5, [3, 1, 4, 1, 5]), (3, [10, 20, 30])]) == [[1, 1, 3, 4, 5], [10, 20, 30]] >>> process_test_cases(1, [(4, [7, 5, 3, 1])]) == [[1, 3, 5, 7]]","solution":"def min_absolute_difference(arr): Given an array, returns a permutation which minimizes the maximum absolute difference between any two consecutive elements. arr.sort() return arr def process_test_cases(t, test_cases): results = [] for case in test_cases: n, arr = case result = min_absolute_difference(arr) results.append(result) return results"},{"question":"def merge_large_sorted_lists(iter1, iter2): Merge two sorted iterables into one sorted output, using limited memory. >>> list(merge_large_sorted_lists(iter([1, 4, 5, 8]), iter([2, 3, 6, 7]))) [1, 2, 3, 4, 5, 6, 7, 8] >>> list(merge_large_sorted_lists(iter([1, 2, 3]), iter([4, 5, 6]))) [1, 2, 3, 4, 5, 6] >>> list(merge_large_sorted_lists(iter([]), iter([1, 2, 3]))) [1, 2, 3] >>> list(merge_large_sorted_lists(iter([]), iter([]))) [] >>> list(merge_large_sorted_lists(iter([1, 3, 5]), iter([2, 4, 6]))) [1, 2, 3, 4, 5, 6] >>> list(merge_large_sorted_lists(iter([1000000000, 1000000001]), iter([1000000002, 1000000003]))) [1000000000, 1000000001, 1000000002, 1000000003] >>> list(merge_large_sorted_lists(iter([1, 1, 2]), iter([1, 3, 4]))) [1, 1, 1, 2, 3, 4]","solution":"def merge_large_sorted_lists(iter1, iter2): Merge two sorted iterables into one sorted output, using limited memory. iter1, iter2 = iter(iter1), iter(iter2) sentinel = object() # Unique object to denote the end of of an iterator item1 = next(iter1, sentinel) item2 = next(iter2, sentinel) while item1 is not sentinel or item2 is not sentinel: if item1 is not sentinel and (item2 is sentinel or item1 <= item2): yield item1 item1 = next(iter1, sentinel) else: yield item2 item2 = next(iter2, sentinel)"},{"question":"def length_of_lis(sequence: List[int]) -> int: Returns the length of the longest increasing subsequence in the given sequence of integers. :param sequence: List of integers :return: Length of the longest increasing subsequence >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_lis([1]) == 1 >>> length_of_lis([5, 4, 3, 2, 1]) == 1 >>> length_of_lis([2, 2, 2, 2, 2]) == 1 >>> length_of_lis([10, 20, 10, 30, 20, 50]) == 4 >>> length_of_lis([]) == 0 >>> length_of_lis([1, 1000000000, 2, 999999999]) == 3","solution":"def length_of_lis(sequence): Returns the length of the longest increasing subsequence in the given sequence of integers. :param sequence: List of integers :return: Length of the longest increasing subsequence if not sequence: return 0 from bisect import bisect_left lis = [] for num in sequence: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def count_paths(grid: List[str]) -> int: Calculate the number of different paths from the top-left corner to the bottom-right corner in a grid. The input grid is a list of strings, where '.' indicates an open cell and '#' indicates a blocked cell. You can only move right or down to an adjacent cell if it is open. Returns the number of paths modulo 1000000007, or 0 if no path exists. pass def number_of_paths_from_input(input_string: str) -> int: Parse the input string and compute the number of paths in the given grid. The input string consists of n+1 lines, where the first line contains two integers n and m, and the next n lines contain m characters each, representing the grid. >>> number_of_paths_from_input(\\"3 3n...n.#.n...\\") 2 >>> number_of_paths_from_input(\\"3 3n#n#n#\\") 0 pass","solution":"MOD = 1000000007 def count_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[-1][-1] def number_of_paths_from_input(input_string): input_lines = input_string.strip().split('n') n, m = map(int, input_lines[0].split()) grid = input_lines[1:] return count_paths(grid) # For testing purposes, call number_of_paths_from_input with input string."},{"question":"import bisect class ScoreManager: A data structure that supports: - insert(score): Insert a new integer score into the data structure. - remove(score): Remove a score from the data structure. If the score does not exist, ignore the operation. - get_max(): Retrieve the highest score currently in the data structure. - get_min(): Retrieve the lowest score currently in the data structure. Each operation should have a time complexity of O(log n). Example: >>> sm = ScoreManager() >>> sm.insert(5) >>> sm.insert(3) >>> sm.insert(10) >>> sm.get_max() 10 >>> sm.get_min() 3 >>> sm.remove(10) >>> sm.get_max() 5 >>> sm.remove(5) >>> sm.get_min() 3 >>> sm.remove(3) >>> sm.get_max() 'Empty' >>> sm.get_min() 'Empty' def test_operations(): sm = ScoreManager() sm.insert(5) sm.insert(3) sm.insert(10) assert sm.get_max() == 10 assert sm.get_min() == 3 sm.remove(10) assert sm.get_max() == 5 sm.remove(3) assert sm.get_min() == 5 sm.remove(5) assert sm.get_min() == \\"Empty\\" assert sm.get_max() == \\"Empty\\" def test_edge_cases(): sm = ScoreManager() assert sm.get_min() == \\"Empty\\" assert sm.get_max() == \\"Empty\\" sm.insert(1) sm.remove(1) assert sm.get_min() == \\"Empty\\" assert sm.get_max() == \\"Empty\\" sm.insert(1) sm.insert(2) sm.remove(1) sm.remove(1) # removing non-existing element assert sm.get_min() == 2 assert sm.get_max() == 2 def test_duplicates(): sm = ScoreManager() sm.insert(5) sm.insert(5) sm.insert(5) assert sm.get_min() == 5 assert sm.get_max() == 5 sm.remove(5) assert sm.get_min() == 5 assert sm.get_max() == 5 sm.remove(5) sm.remove(5) assert sm.get_min() == \\"Empty\\" assert sm.get_max() == \\"Empty\\"","solution":"import bisect class ScoreManager: def __init__(self): self.scores = [] def insert(self, score): bisect.insort(self.scores, score) def remove(self, score): index = bisect.bisect_left(self.scores, score) if index != len(self.scores) and self.scores[index] == score: self.scores.pop(index) def get_max(self): if self.scores: return self.scores[-1] else: return \\"Empty\\" def get_min(self): if self.scores: return self.scores[0] else: return \\"Empty\\""},{"question":"def max_trees(m: int, n: int, grid: List[List[str]]) -> int: Determine the maximum number of trees that can be planted in the park grid while keeping it aesthetically pleasing. There should be no more than two consecutive cells with trees in any row, column, or diagonal (both main and anti-diagonal). >>> max_trees(4, 4, [['T', '.', 'T', '.'], ['.', '.', '.', '.'], ['.', 'T', '.', '.'], ['.', '.', '.', '.']]) 6 >>> max_trees(2, 2, [['.', '.'], ['.', '.']]) 4 >>> max_trees(3, 3, [['T', 'T', 'T'], ['T', 'T', 'T'], ['T', 'T', 'T']]) 0 >>> max_trees(1, 1, [['.']]) 1 >>> max_trees(1, 5, [['.', 'T', '.', 'T', '.']]) 2","solution":"def max_trees(m, n, grid): Function to determine the maximum number of trees that can be planted in the park grid while keeping it aesthetically pleasing. max_trees_count = 0 def is_valid(x, y): # Check horizontal if y > 1 and grid[x][y-1] == 'T' and grid[x][y-2] == 'T': return False if y < n-2 and grid[x][y+1] == 'T' and grid[x][y+2] == 'T': return False if y > 0 and y < n-1 and grid[x][y-1] == 'T' and grid[x][y+1] == 'T': return False # Check vertical if x > 1 and grid[x-1][y] == 'T' and grid[x-2][y] == 'T': return False if x < m-2 and grid[x+1][y] == 'T' and grid[x+2][y] == 'T': return False if x > 0 and x < m-1 and grid[x-1][y] == 'T' and grid[x+1][y] == 'T': return False # Check main diagonal if x > 1 and y > 1 and grid[x-1][y-1] == 'T' and grid[x-2][y-2] == 'T': return False if x < m-2 and y < n-2 and grid[x+1][y+1] == 'T' and grid[x+2][y+2] == 'T': return False if x > 0 and y > 0 and x < m-1 and y < n-1 and grid[x-1][y-1] == 'T' and grid[x+1][y+1] == 'T': return False # Check anti-diagonal if x > 1 and y < n-2 and grid[x-1][y+1] == 'T' and grid[x-2][y+2] == 'T': return False if x < m-2 and y > 1 and grid[x+1][y-1] == 'T' and grid[x+2][y-2] == 'T': return False if x > 0 and y < n-1 and x < m-1 and y > 0 and grid[x-1][y+1] == 'T' and grid[x+1][y-1] == 'T': return False return True def plant_tree(x, y): nonlocal max_trees_count grid[x][y] = 'T' max_trees_count += 1 for row in range(m): for col in range(n): if grid[row][col] == '.' and is_valid(row, col): plant_tree(row, col) return max_trees_count # Example usage: m, n = 4, 4 grid = [ ['T', '.', 'T', '.'], ['.', '.', '.', '.'], ['.', 'T', '.', '.'], ['.', '.', '.', '.'] ] print(max_trees(m, n, grid)) # Output should be 6"},{"question":"def min_operations_to_mirror(s: str) -> int: Returns the minimum number of operations required to transform string s into a mirror string. >>> min_operations_to_mirror(\\"abcba\\") 0 >>> min_operations_to_mirror(\\"abfgh\\") 2","solution":"def min_operations_to_mirror(s): Returns the minimum number of operations required to transform string s into a mirror string. n = len(s) operations = 0 # Compare characters from beginning and end for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"class Theater: A class representing a theater seating arrangement. Attributes: rows (int): Number of rows in the theater. cols (int): Number of columns in the theater. seats (List[List[str]]): Current seating arrangement. Methods: __init__(rows: int, cols: int): Initializes the theater seats. book_seat(row: int, col: int) -> bool: Attempts to book a seat. is_available(row: int, col: int) -> bool: Checks if a seat is available. display_seats() -> None: Displays the current seating arrangement. def __init__(self, rows: int, cols: int): Initializes the theater with the given rows and columns. Args: rows (int): Number of rows in the theater. cols (int): Number of columns in the theater. def book_seat(self, row: int, col: int) -> bool: Books a seat if it is available. Args: row (int): The row number of the seat. col (int): The column number of the seat. Returns: bool: Returns True if the seat was successfully booked, otherwise returns False if the seat is already booked. def is_available(self, row: int, col: int) -> bool: Checks if a seat is available. Args: row (int): The row number of the seat. col (int): The column number of the seat. Returns: bool: Returns True if the seat is available, otherwise returns False if the seat is already booked. def display_seats(self) -> None: Displays the current seating arrangement.","solution":"class Theater: def __init__(self, rows: int, cols: int): self.rows = rows self.cols = cols self.seats = [['A' for _ in range(cols)] for _ in range(rows)] def book_seat(self, row: int, col: int) -> bool: if self.seats[row][col] == 'A': self.seats[row][col] = 'B' return True return False def is_available(self, row: int, col: int) -> bool: return self.seats[row][col] == 'A' def display_seats(self) -> None: for row in self.seats: print(\\" \\".join(row))"},{"question":"def final_inventory(n: int, initial_stocks: List[int], k: int, events: List[str]) -> List[int]: Calculate the final inventory in each warehouse after processing the events. :param n: Number of warehouses :param initial_stocks: List of integers representing initial stock in each warehouse :param k: Number of log entries (events) :param events: List of event strings that describe an order or restock event :return: Final stock levels in each warehouse as a list of integers # Unit Tests: from solution import final_inventory def test_example(): n = 3 initial_stocks = [50, 80, 90] k = 5 events = [ \\"order 1 1 20\\", \\"restock 2 2 30\\", \\"order 3 3 50\\", \\"order 4 1 10\\", \\"restock 5 3 100\\" ] assert final_inventory(n, initial_stocks, k, events) == [20, 110, 140] def test_no_events(): n = 2 initial_stocks = [100, 200] k = 0 events = [] assert final_inventory(n, initial_stocks, k, events) == [100, 200] def test_all_orders(): n = 3 initial_stocks = [100, 100, 100] k = 3 events = [ \\"order 1 1 50\\", \\"order 2 2 100\\", \\"order 3 3 10\\" ] assert final_inventory(n, initial_stocks, k, events) == [50, 0, 90] def test_all_restocks(): n = 3 initial_stocks = [50, 50, 50] k = 3 events = [ \\"restock 1 1 30\\", \\"restock 2 2 20\\", \\"restock 3 3 40\\" ] assert final_inventory(n, initial_stocks, k, events) == [80, 70, 90] def test_mixed_events(): n = 4 initial_stocks = [10, 20, 30, 40] k = 4 events = [ \\"order 1 1 5\\", \\"restock 2 3 15\\", \\"order 3 4 20\\", \\"restock 4 2 10\\" ] assert final_inventory(n, initial_stocks, k, events) == [5, 30, 45, 20]","solution":"def final_inventory(n, initial_stocks, k, events): Calculate the final inventory in each warehouse after processing the events. :param n: Number of warehouses :param initial_stocks: List of integers representing initial stock in each warehouse :param k: Number of log entries (events) :param events: List of event strings that describe an order or restock event :return: Final stock levels in each warehouse as a list of integers # Create a copy of initial stocks to update final_stocks = initial_stocks[:] # Process each event for event in events: details = event.split() t = int(details[1]) # time, not used in this problem i = int(details[2]) # warehouse index (1-based) c = int(details[3]) # amount change if details[0] == 'order': final_stocks[i - 1] -= c elif details[0] == 'restock': final_stocks[i - 1] += c return final_stocks"},{"question":"def minTransformations(s: str, t: str) -> int: Returns the minimum number of bridging transformations required to convert s into t. If it is impossible, returns -1. >>> minTransformations(\\"abc\\", \\"abcbabccabc\\") 3 >>> minTransformations(\\"xyz\\", \\"xyzxyz\\") 2 >>> minTransformations(\\"abc\\", \\"def\\") -1 >>> minTransformations(\\"a\\", \\"a\\") 1 >>> minTransformations(\\"a\\", \\"aaaaa\\") 5 >>> minTransformations(\\"abc\\", \\"abcd\\") -1 >>> minTransformations(\\"ab\\", \\"ababab\\") 3 >>> minTransformations(\\"abc\\", \\"zzzz\\") -1","solution":"def minTransformations(s: str, t: str) -> int: Returns the minimum number of bridging transformations required to convert s into t. If it is impossible, returns -1. # Check if s is a substring of t anywhere. if not set(s).issubset(set(t)): return -1 n = len(s) m = len(t) # Removes the need for complex dynamic programming by simple greedy approach: transformations = 0 i = 0 while i < m: transformations += 1 j = 0 while i < m and j < n: if s[j] == t[i]: j += 1 i += 1 if j != n and i == m: return -1 return transformations"},{"question":"def is_balanced(s: str) -> str: Checks if the input string containing only the characters '(', ')', '{', '}', '[' and ']' is a balanced string of parentheses. Args: s (str): Input string to check. Returns: str: \\"balanced\\" if the string is balanced, otherwise \\"unbalanced\\". pass if __name__ == \\"__main__\\": import pytest def test_balanced_parentheses(): assert is_balanced(\\"()\\") == \\"balanced\\" assert is_balanced(\\"[]\\") == \\"balanced\\" assert is_balanced(\\"{}\\") == \\"balanced\\" assert is_balanced(\\"()[]{}\\") == \\"balanced\\" assert is_balanced(\\"{[()]}\\") == \\"balanced\\" assert is_balanced(\\"({[]})\\") == \\"balanced\\" assert is_balanced(\\"[({})]\\") == \\"balanced\\" def test_unbalanced_parentheses(): assert is_balanced(\\"(\\") == \\"unbalanced\\" assert is_balanced(\\"(((\\") == \\"unbalanced\\" assert is_balanced(\\"({[})\\") == \\"unbalanced\\" assert is_balanced(\\"[(()]\\") == \\"unbalanced\\" assert is_balanced(\\"{[}\\") == \\"unbalanced\\" assert is_balanced(\\"{[(])}\\") == \\"unbalanced\\" def test_empty_string(): assert is_balanced(\\"\\") == \\"balanced\\" def test_mixed_characters(): assert is_balanced(\\"(a+b)\\") == \\"unbalanced\\" assert is_balanced(\\"{[a]b}\\") == \\"unbalanced\\" assert is_balanced(\\"[()]\\") == \\"balanced\\" def test_balanced_longer_sequences(): assert is_balanced(\\"(({{[[()]]}}))\\") == \\"balanced\\" assert is_balanced(\\"()()()()\\") == \\"balanced\\" assert is_balanced(\\"([])({})[{}](()[])\\") == \\"balanced\\" def test_unbalanced_longer_sequences(): assert is_balanced(\\"]\\") == \\"unbalanced\\" assert is_balanced(\\"[([)]]\\") == \\"unbalanced\\" assert is_balanced(\\"({(})[\\") == \\"unbalanced\\" pytest.main()","solution":"def is_balanced(s): Checks if the input string containing only the characters '(', ')', '{', '}', '[' and ']' is a balanced string of parentheses. Args: s (str): Input string to check. Returns: str: \\"balanced\\" if the string is balanced, otherwise \\"unbalanced\\". stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if not stack or stack[-1] != matching_parentheses[char]: return \\"unbalanced\\" stack.pop() else: return \\"unbalanced\\" return \\"balanced\\" if not stack else \\"unbalanced\\""},{"question":"def find_odd_occurrence(numbers): Returns the integer that appears an odd number of times in the list. Args: numbers (list of int): The list of integers. Returns: int: The integer that appears an odd number of times. >>> find_odd_occurrence([1]) == 1 >>> find_odd_occurrence([1, 2, 3, 2, 1]) == 3 >>> find_odd_occurrence([4, 4, 5, 5, 7, 7, 8]) == 8 >>> find_odd_occurrence([10, 10, 10, 20, 20, 10, 30, 30, 40, 40, 30, 30, 10]) == 10 >>> find_odd_occurrence([1000000000, 1000000000, 999999999]) == 999999999 >>> find_odd_occurrence([0, 1, 2, 1, 0, 2, 2]) == 2","solution":"def find_odd_occurrence(numbers): Returns the integer that appears an odd number of times in the list. Args: numbers (list of int): The list of integers. Returns: int: The integer that appears an odd number of times. result = 0 for number in numbers: result ^= number return result"},{"question":"def assign_tasks_to_employees(n: int, skill_levels: List[int], m: int, task_difficulties: List[int]) -> List[int]: Assign tasks to employees based on their skill levels. :param n: Number of employees :param skill_levels: List of integers representing the skill levels of employees :param m: Number of tasks :param task_difficulties: List of integers representing the difficulties of the tasks :return: List of integers where the i-th integer corresponds to the 1-based index of the employee assigned to the i-th task If no employee can handle a task, return -1 for that task. >>> assign_tasks_to_employees(5, [4, 2, 7, 1, 3], 6, [2, 5, 1, 8, 3, 4]) [2, 3, 4, -1, 5, 1] >>> assign_tasks_to_employees(3, [5, 6, 7], 3, [2, 3, 4]) [1, 1, 1] >>> assign_tasks_to_employees(2, [1, 2], 3, [3, 4, 5]) [-1, -1, -1] >>> assign_tasks_to_employees(4, [4, 2, 8, 3], 4, [1, 5, 2, 10]) [2, 3, 2, -1] >>> assign_tasks_to_employees(5, [10, 9, 8, 7, 6], 5, [3, 3, 3, 3, 3]) [5, 5, 5, 5, 5] >>> assign_tasks_to_employees(4, [4, 4, 4, 4], 3, [2, 4, 4]) [1, 1, 1] >>> assign_tasks_to_employees(3, [1, 2, 3], 4, [3, 3, 3, 3]) [3, 3, 3, 3]","solution":"def assign_tasks_to_employees(n, skill_levels, m, task_difficulties): Assign tasks to employees based on their skill levels. :param n: Number of employees :param skill_levels: List of integers representing the skill levels of employees :param m: Number of tasks :param task_difficulties: List of integers representing the difficulties of the tasks :return: List of integers where the i-th integer corresponds to the 1-based index of the employee assigned to the i-th task If no employee can handle a task, return -1 for that task. # Pair skill levels with their respective 1-based indices indexed_skills = sorted((skill, index + 1) for index, skill in enumerate(skill_levels)) # Function to find the first employee who can handle the task def find_employee(task_difficulty): low, high = 0, n - 1 while low <= high: mid = (low + high) // 2 if indexed_skills[mid][0] >= task_difficulty: high = mid - 1 else: low = mid + 1 return indexed_skills[low][1] if low < n and indexed_skills[low][0] >= task_difficulty else -1 # Assign tasks to employees assignment = [find_employee(task) for task in task_difficulties] return assignment"},{"question":"def apply_spells(n, q, initial_levels, spells): Returns the final enchantment levels of trees after applying all spells. Parameters: n (int): Number of trees. q (int): Number of spells. initial_levels (list of int): Initial enchantment levels of the trees. spells (list of tuple): List of spells represented by (Li, Ri). Returns: list: Final enchantment levels of the trees. from solution import apply_spells def test_apply_spells_basic(): n, q = 5, 3 initial_levels = [1, 2, 3, 4, 5] spells = [(1, 3), (2, 4), (1, 5)] result = apply_spells(n, q, initial_levels, spells) assert result == [3, 5, 6, 6, 6] def test_apply_spells_single_spell(): n, q = 4, 1 initial_levels = [1, 1, 1, 1] spells = [(2, 3)] result = apply_spells(n, q, initial_levels, spells) assert result == [1, 2, 2, 1] def test_apply_spells_no_spell(): n, q = 3, 0 initial_levels = [5, 3, 4] spells = [] result = apply_spells(n, q, initial_levels, spells) assert result == [5, 3, 4] def test_apply_spells_full_range_spell(): n, q = 6, 2 initial_levels = [10, 20, 30, 40, 50, 60] spells = [(1, 6), (3, 5)] result = apply_spells(n, q, initial_levels, spells) assert result == [11, 21, 32, 42, 52, 61] def test_apply_spells_edge_case(): n, q = 1, 1 initial_levels = [0] spells = [(1, 1)] result = apply_spells(n, q, initial_levels, spells) assert result == [1] def test_apply_spells_large_input(): n, q = 100000, 1 initial_levels = [0] * n spells = [(1, 100000)] result = apply_spells(n, q, initial_levels, spells) for level in result: assert level == 1","solution":"def apply_spells(n, q, initial_levels, spells): Returns the final enchantment levels of trees after applying all spells. Parameters: n (int): Number of trees. q (int): Number of spells. initial_levels (list of int): Initial enchantment levels of the trees. spells (list of tuple): List of spells represented by (Li, Ri). Returns: list: Final enchantment levels of the trees. # Initialize a difference array diff = [0] * (n + 1) for Li, Ri in spells: diff[Li - 1] += 1 if Ri < n: diff[Ri] -= 1 # Apply the difference array to get final increments increment = 0 for i in range(n): increment += diff[i] initial_levels[i] += increment return initial_levels"},{"question":"def process_queries(n, q, array, queries): Process an array of integers with update and distinct queries. The function takes: - n: number of elements in the array - q: number of queries - array: list of integers - queries: list of tuples representing the queries The query types are: 1. (1, x, y) - update the value at position x to y 2. (2, l, r) - find the number of distinct integers in the subarray from index l to r >>> process_queries(5, 3, [1, 2, 1, 3, 2], [(2, 1, 3), (1, 3, 4), (2, 1, 3)]) [2, 3] >>> process_queries(4, 4, [4, 5, 6, 7], [(2, 1, 4), (1, 2, 4), (2, 1, 4), (1, 3, 5)]) [4, 3] >>> process_queries(6, 2, [1, 2, 3, 2, 1, 4], [(2, 1, 3), (2, 4, 6)]) [3, 3] >>> process_queries(1, 2, [1], [(2, 1, 1), (1, 1, 2)]) [1]","solution":"def process_queries(n, q, array, queries): results = [] for query in queries: if query[0] == 1: _, x, y = query array[x - 1] = y elif query[0] == 2: _, l, r = query subarray = array[l - 1:r] results.append(len(set(subarray))) return results"},{"question":"def count_flower_cells(N: int, M: int, grid: List[str]) -> int: Determine the number of empty cells that will turn into flower cells after surrounding all possible trees. >>> count_flower_cells(4, 5, [ \\".....\\", \\".T...\\", \\"..T..\\", \\".....\\"]) 6 >>> count_flower_cells(3, 5, [ \\".....\\", \\".....\\", \\".....\\"]) 0 >>> count_flower_cells(5, 5, [ \\"T.TTT\\", \\".....\\", \\"T.T.T\\", \\".....\\", \\"T.TTT\\"]) 12 >>> count_flower_cells(4, 5, [ \\"TTTTT\\", \\"TTTTT\\", \\"TTTTT\\", \\"TTTTT\\"]) 0 >>> count_flower_cells(3, 3, [ \\"TFT\\", \\"FTF\\", \\"TFT\\"]) 0","solution":"def count_flower_cells(N, M, grid): def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] count = 0 visited = [[False] * M for _ in range(N)] for i in range(N): for j in range(M): if grid[i][j] == 'T': for dx, dy in directions: nx, ny = i + dx, j + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True count += 1 return count"},{"question":"def process_input(n: int, m: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum sum of values of nodes in a connected subgraph. :param n: The number of nodes in the graph :param m: The number of edges in the graph :param values: A list of integers where the i-th integer represents the value associated with the i-th node :param edges: A list of tuples containing two integers each, indicating an undirected edge connecting nodes u and v :return: An integer representing the maximum sum of values of nodes in any connected subgraph >>> process_input(5, 4, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (4, 5)]) 15 >>> process_input(1, 0, [10], []) 10 >>> process_input(5, 2, [3, 1, 9, 2, 6], [(1, 2), (4, 5)]) 9 >>> process_input(6, 4, [1, 2, 3, 4, 1, 2], [(1, 2), (2, 3), (4, 5), (5, 6)]) 7 >>> process_input(6, 7, [4, 3, 1, 5, 2, 1], [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6), (5, 6)]) 16","solution":"from collections import defaultdict, deque def max_connected_subgraph_sum(n, m, node_values, edges): def bfs(start): queue = deque([start]) visited[start] = True total_value = 0 while queue: node = queue.popleft() total_value += node_values[node] for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return total_value graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) visited = [False] * n max_sum = 0 for i in range(n): if not visited[i]: connected_sum = bfs(i) max_sum = max(max_sum, connected_sum) return max_sum # Sample input processing function (assuming input directly as function parameters is provided) def process_input(n, m, values, edges): return max_connected_subgraph_sum(n, m, values, edges)"},{"question":"def max_codes(n, codes): Determines the maximum number of codes that can be selected such that no two codes have been modified within the same five-minute interval. Args: - n (int): The number of codes. - codes (list of tuples): Each tuple contains a string (ID of the code) and an integer (timestamp). Returns: - int: The maximum number of codes that can be selected. >>> max_codes(4, [(\\"code1\\", 3), (\\"code2\\", 7), (\\"code3\\", 8), (\\"code4\\", 12)]) 3 >>> max_codes(5, [(\\"code1\\", 2), (\\"code2\\", 3), (\\"code3\\", 1), (\\"code4\\", 4), (\\"code5\\", 0)]) 1 >>> max_codes(5, [(\\"code1\\", 0), (\\"code2\\", 5), (\\"code3\\", 10), (\\"code4\\", 15), (\\"code5\\", 20)]) 5 >>> max_codes(3, [(\\"code1\\", 4), (\\"code2\\", 5), (\\"code3\\", 29)]) 3 >>> max_codes(1, [(\\"code1\\", 12345)]) 1 >>> max_codes(3, [(\\"code1\\", 0), (\\"code2\\", 5), (\\"code3\\", 10)]) 3","solution":"def max_codes(n, codes): Determines the maximum number of codes that can be selected such that no two codes have been modified within the same five-minute interval. Args: - n (int): The number of codes. - codes (list of tuples): Each tuple contains a string (ID of the code) and an integer (timestamp). Returns: - int: The maximum number of codes that can be selected. intervals = set() max_count = 0 for _, timestamp in codes: interval = timestamp // 5 if interval not in intervals: intervals.add(interval) max_count += 1 return max_count"},{"question":"def is_subsequence(s: str, t: str) -> str: Check if t is a subsequence of s :param s: String in which we are searching :param t: String that we are searching for as a subsequence :return: \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\" >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"NO\\" >>> is_subsequence(\\"abc\\", \\"abc\\") \\"YES\\" >>> is_subsequence(\\"abc\\", \\"\\") \\"YES\\" >>> is_subsequence(\\"abc\\", \\"abcd\\") \\"NO\\" >>> is_subsequence(\\"abc\\", \\"cba\\") \\"NO\\" def check_subsequences(queries: List[Tuple[str, str]]) -> List[str]: Process multiple queries to check if t is a subsequence of s :param queries: List of tuples (s, t) for each query :return: List of \\"YES\\" or \\"NO\\" for each query >>> check_subsequences([(\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aec\\"), (\\"abc\\", \\"abc\\"), (\\"abc\\", \\"\\"), (\\"abc\\", \\"abcd\\"), (\\"abc\\", \\"cba\\")]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_subsequence(s, t): Check if t is a subsequence of s :param s: String in which we are searching :param t: String that we are searching for as a subsequence :return: \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\" it = iter(s) return \\"YES\\" if all(char in it for char in t) else \\"NO\\" def check_subsequences(queries): Process multiple queries to check if t is a subsequence of s :param queries: List of tuples (s, t) for each query :return: List of \\"YES\\" or \\"NO\\" for each query return [is_subsequence(s, t) for s, t in queries]"},{"question":"def find_min_bridges_to_remove(n: int, m: int, bridges: List[Tuple[int, int]]) -> int: Given the number of islands n, number of bridges m, and a list of bridges, find the minimum number of bridges that need to be removed so that no two islands are directly connected by more than one bridge while ensuring all islands are accessible. >>> find_min_bridges_to_remove(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) == 1 >>> find_min_bridges_to_remove(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) == 1 >>> find_min_bridges_to_remove(3, 3, [(1, 2), (2, 3), (3, 1)]) == 1 from solution import find_min_bridges_to_remove def test_case_1(): n = 5 m = 5 bridges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)] assert find_min_bridges_to_remove(n, m, bridges) == 1 def test_case_2(): n = 4 m = 4 bridges = [(1, 2), (2, 3), (3, 4), (4, 2)] assert find_min_bridges_to_remove(n, m, bridges) == 1 def test_case_3(): n = 3 m = 3 bridges = [(1, 2), (2, 3), (3, 1)] assert find_min_bridges_to_remove(n, m, bridges) == 1 def test_case_4(): n = 6 m = 7 bridges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (2, 5)] assert find_min_bridges_to_remove(n, m, bridges) == 2 def test_case_5(): n = 3 m = 2 bridges = [(1, 2), (2, 3)] assert find_min_bridges_to_remove(n, m, bridges) == 0 def test_case_6(): n = 6 m = 5 bridges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert find_min_bridges_to_remove(n, m, bridges) == 0","solution":"def find_min_bridges_to_remove(n, m, bridges): from collections import defaultdict graph = defaultdict(list) for u, v in bridges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) parent = [-1] * (n + 1) def dfs(u): nonlocal cycle_edge_count visited[u] = True for v in graph[u]: if not visited[v]: parent[v] = u dfs(v) elif v != parent[u]: cycle_edge_count += 1 cycle_edge_count = 0 for i in range(1, n + 1): if not visited[i]: dfs(i) # Each cycle introduces 2 counts of edges, so we divide by 2 return cycle_edge_count // 2"},{"question":"def max_distinct_after_removal(n: int, a: List[int]) -> int: Determine the maximum number of distinct integers you can achieve by removing exactly one element from the array. Parameters: n (int): Length of the array a (list): List of integers Returns: int: Maximum number of distinct integers after removal of one element >>> max_distinct_after_removal(4, [1, 2, 2, 3]) == 3 >>> max_distinct_after_removal(4, [4, 4, 4, 4]) == 1 >>> max_distinct_after_removal(5, [1, 2, 3, 4, 5]) == 4 >>> max_distinct_after_removal(1, [10]) == 0 >>> max_distinct_after_removal(6, [1, 1, 2, 2, 3, 3]) == 3 >>> max_distinct_after_removal(4, [1, 1, 1, 2]) == 2","solution":"def max_distinct_after_removal(n, a): Determine the maximum number of distinct integers you can achieve by removing exactly one element from the array. Parameters: n (int): Length of the array a (list): List of integers Returns: int: Maximum number of distinct integers after removal of one element unique_elements = set(a) if len(unique_elements) == n: return n - 1 else: return len(unique_elements)"},{"question":"def process_operations(L: int, R: int, C: int, operations: List[str]) -> List[List[List[int]]]: Simulate a multi-store car park system with multiple levels, each level having a 2D grid of parking spaces. The car park is managed based on operations: enter, leave, and status. Args: - L: Number of levels in the car park. - R: Number of rows per level. - C: Number of columns per level. - operations: A list of operations to be performed in the car park. Returns: - A list of lists representing the car park status for each \\"STATUS\\" operation. Example: >>> L, R, C = 2, 2, 2 >>> operations = [\\"ENTER 5\\", \\"ENTER 6\\", \\"STATUS\\", \\"LEAVE 5\\", \\"STATUS\\"] >>> process_operations(L, R, C, operations) [[[5, 6], [0, 0]], [[0, 0], [0, 0]]], [[[0, 6], [0, 0]], [[0, 0], [0, 0]]] # Here are some sample test cases you can use to verify your solution: def test_process_operations(): L, R, C = 2, 2, 2 operations = [ \\"ENTER 5\\", \\"ENTER 6\\", \\"STATUS\\", \\"LEAVE 5\\", \\"STATUS\\" ] expected_output = [ [[[5, 6], [0, 0]], [[0, 0], [0, 0]]], [[[0, 6], [0, 0]], [[0, 0], [0, 0]]] ] result = process_operations(L, R, C, operations) assert result == expected_output def test_all_spaces_filled(): L, R, C = 1, 2, 2 operations = [ \\"ENTER 1\\", \\"ENTER 2\\", \\"ENTER 3\\", \\"ENTER 4\\", \\"ENTER 5\\", # Should be ignored because the car park is full \\"STATUS\\" ] expected_output = [ [[[1, 2], [3, 4]]] ] result = process_operations(L, R, C, operations) assert result == expected_output def test_leave_nonexistent_car(): L, R, C = 1, 2, 2 operations = [ \\"ENTER 1\\", \\"LEAVE 2\\", # Should be ignored because car ID 2 does not exist \\"STATUS\\" ] expected_output = [ [[[1, 0], [0, 0]]] ] result = process_operations(L, R, C, operations) assert result == expected_output def test_reenter_same_car(): L, R, C = 1, 2, 2 operations = [ \\"ENTER 1\\", \\"ENTER 1\\", # Should be ignored because car ID 1 is already parked \\"STATUS\\" ] expected_output = [ [[[1, 0], [0, 0]]] ] result = process_operations(L, R, C, operations) assert result == expected_output def test_leave_then_enter(): L, R, C = 1, 2, 2 operations = [ \\"ENTER 1\\", \\"LEAVE 1\\", \\"ENTER 2\\", # Car ID 2 should take the place of car ID 1 \\"STATUS\\" ] expected_output = [ [[[2, 0], [0, 0]]] ] result = process_operations(L, R, C, operations) assert result == expected_output","solution":"class CarPark: def __init__(self, L, R, C): self.L = L self.R = R self.C = C self.total_spaces = L * R * C self.spaces = [0] * self.total_spaces self.car_position = {} def enter(self, car_id): if car_id in self.car_position: return # Car is already parked for index in range(self.total_spaces): if self.spaces[index] == 0: self.spaces[index] = car_id self.car_position[car_id] = index break def leave(self, car_id): if car_id not in self.car_position: return # Car is not parked index = self.car_position.pop(car_id) self.spaces[index] = 0 def status(self): result = [] for level in range(self.L): level_status = [] for row in range(self.R): row_status = self.spaces[level * self.R * self.C + row * self.C : level * self.R * self.C + (row + 1) * self.C] level_status.append(row_status) result.append(level_status) return result def process_operations(L, R, C, operations): car_park = CarPark(L, R, C) results = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"ENTER\\": car_id = int(parts[1]) car_park.enter(car_id) elif cmd == \\"LEAVE\\": car_id = int(parts[1]) car_park.leave(car_id) elif cmd == \\"STATUS\\": status = car_park.status() results.append(status) return results"},{"question":"def max_gems_collected(n: int, grid: List[str]) -> int: Given a grid configuration of gems, determine the maximum number of gems that can be collected by selecting a single rectangular region on the grid. >>> max_gems_collected(3, [\\".G.\\", \\"G.G\\", \\".G.\\"]) 4 >>> max_gems_collected(1, [\\"G\\"]) 1 >>> max_gems_collected(3, [\\"...\\", \\"...\\", \\"...\\"]) 0 >>> max_gems_collected(3, [\\"GGG\\", \\"GGG\\", \\"GGG\\"]) 9 >>> max_gems_collected(3, [\\"...\\", \\"GGG\\", \\"...\\"]) 3 >>> max_gems_collected(3, [\\".G.\\", \\".G.\\", \\".G.\\"]) 3","solution":"def max_gems_collected(n, grid): def preprocess_grid(grid): Preprocess the grid to create a sum table sum_grid = [[0] * n for _ in range(n)] for r in range(n): row_sum = 0 for c in range(n): row_sum += 1 if grid[r][c] == 'G' else 0 sum_grid[r][c] = row_sum + (sum_grid[r-1][c] if r > 0 else 0) return sum_grid def get_sum(x1, y1, x2, y2, sum_grid): Get the sum of gems in the rectangular region (x1, y1) to (x2, y2) total = sum_grid[x2][y2] if x1 > 0: total -= sum_grid[x1-1][y2] if y1 > 0: total -= sum_grid[x2][y1-1] if x1 > 0 and y1 > 0: total += sum_grid[x1-1][y1-1] return total sum_grid = preprocess_grid(grid) max_gems = 0 for x1 in range(n): for x2 in range(x1, n): for y1 in range(n): for y2 in range(y1, n): max_gems = max(max_gems, get_sum(x1, y1, x2, y2, sum_grid)) return max_gems"},{"question":"def process_transactions(n: int, transactions: List[float]) -> List[str]: Processes a list of transaction amounts and ensures each amount is correctly rounded to two decimal places. Any negative transaction amounts are flagged as \\"ERROR\\". Parameters: n : int - Number of transaction amounts transactions : list of float - The transaction amounts Returns: list : Processed transaction amounts as strings # Example test cases # >>> process_transactions(5, [12.5, 3.456, -1.2, 100.999, 0.1]) # [\\"12.50\\", \\"3.46\\", \\"ERROR\\", \\"101.00\\", \\"0.10\\"] # >>> process_transactions(4, [12.5, -3.456, 100.999, 0.1]) # [\\"12.50\\", \\"ERROR\\", \\"101.00\\", \\"0.10\\"] # >>> process_transactions(3, [-1.1, -2.2, -3.3]) # [\\"ERROR\\", \\"ERROR\\", \\"ERROR\\"] # >>> process_transactions(5, [0.0, -0.1, 0.1, 1.0, -1.0]) # [\\"0.00\\", \\"ERROR\\", \\"0.10\\", \\"1.00\\", \\"ERROR\\"] # >>> process_transactions(1, [12.3456]) # [\\"12.35\\"] # >>> process_transactions(1, [-12.3456]) # [\\"ERROR\\"]","solution":"def process_transactions(n, transactions): Processes a list of transaction amounts and ensures each amount is correctly rounded to two decimal places. Any negative transaction amounts are flagged as \\"ERROR\\". Parameters: n : int - Number of transaction amounts transactions : list of float - The transaction amounts Returns: list : Processed transaction amounts as strings results = [] for amount in transactions: if amount < 0: results.append(\\"ERROR\\") else: results.append(f\\"{amount:.2f}\\") return results"},{"question":"from typing import List def longest_subarray_with_sum(arr: List[int], k: int) -> int: Write a function that takes a list of integers \`arr\` and an integer \`k\` as input, and returns the length of the longest contiguous subarray whose sum is exactly \`k\`. If no such subarray exists, return 0. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([1, 2, 3], 3) 2 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 def test_longest_subarray_with_sum_case1(): assert longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 def test_longest_subarray_with_sum_case2(): assert longest_subarray_with_sum([1, 2, 3], 3) == 2 def test_longest_subarray_with_sum_case3(): assert longest_subarray_with_sum([-2, -1, 2, 1], 1) == 2 def test_longest_subarray_with_sum_nosubarray(): assert longest_subarray_with_sum([1, 2, 3], 7) == 0 def test_longest_subarray_with_sum_all_negative(): assert longest_subarray_with_sum([-1, -2, -3], -6) == 3 def test_longest_subarray_with_sum_large_k(): assert longest_subarray_with_sum([1, 1, 1, 1, 1, 1, 1], 5) == 5 def test_longest_subarray_with_sum_single_element(): assert longest_subarray_with_sum([3], 3) == 1 assert longest_subarray_with_sum([4], 3) == 0","solution":"from typing import List def longest_subarray_with_sum(arr: List[int], k: int) -> int: sum_map = {} current_sum = 0 max_len = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_len = i + 1 if (current_sum - k) in sum_map: max_len = max(max_len, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_len"},{"question":"def is_twisted_list_possible(n: int) -> (bool, List[int]): Function to determine if a twisted list is possible for a given n. >>> is_twisted_list_possible(1) == (False, []) >>> is_twisted_list_possible(2) == (False, []) >>> is_twisted_list_possible(3) == (True, [2, 1, 3]) >>> is_twisted_list_possible(4) == (True, [2, 1, 4, 3]) def twisted_list_solver(test_cases: List[int]) -> List[str]: Function to solve multiple test cases for twisted list problem. >>> twisted_list_solver([1, 2, 3, 4]) == [\\"NO\\", \\"NO\\", \\"YES\\", \\"2 1 3\\", \\"YES\\", \\"2 1 4 3\\"] >>> twisted_list_solver([5, 6, 7, 8]) == [ \\"YES\\", \\"2 1 4 3 5\\", \\"YES\\", \\"2 1 4 3 6 5\\", \\"YES\\", \\"2 1 4 3 6 5 7\\", \\"YES\\", \\"2 1 4 3 6 5 8 7\\" ]","solution":"def is_twisted_list_possible(n): Function to determine if a twisted list is possible for a given n if n == 1 or n == 2: return False, [] # Create the twisted list for n > 2 twisted_list = [] for i in range(1, n+1, 2): if i+1 <= n: twisted_list.extend([i+1, i]) # In case of an odd length, append the remaining element at the end if n % 2 != 0: twisted_list.append(n) return True, twisted_list def twisted_list_solver(test_cases): results = [] for n in test_cases: possible, twisted_list = is_twisted_list_possible(n) if possible: results.append(\\"YES\\") results.append(\\" \\".join(map(str, twisted_list))) else: results.append(\\"NO\\") return results"},{"question":"def max_possible_height(n: int, q: int, heights: List[int], queries: List[int]) -> List[int]: For each query, determine the maximum possible height of the person to be inserted at the given position without violating the 'no person in front can be taller' rule. Parameters: n (int): Number of people initially standing in the line. q (int): Number of queries. heights (list of int): Heights of the people initially standing in the line. queries (list of int): Positions where a new person is to be inserted. Returns: list of int: The maximum possible height for each query position. Example: >>> max_possible_height(5, 3, [1, 2, 3, 4, 5], [0, 3, 5]) [1, 4, 5] >>> max_possible_height(5, 4, [2, 2, 2, 2, 2], [0, 2, 3, 5]) [2, 2, 2, 2]","solution":"def max_possible_height(n, q, heights, queries): For each query, determine the maximum possible height of the person to be inserted at the given position without violating the 'no person in front can be taller' rule. Parameters: n (int): Number of people initially standing in the line. q (int): Number of queries. heights (list of int): Heights of the people initially standing in the line. queries (list of int): Positions where a new person is to be inserted. Returns: list of int: The maximum possible height for each query position. results = [] for p in queries: if p == 0: # Inserting at the start, can be at most the height of the first person results.append(heights[0]) elif p == n: # Inserting at the end, can be at most the height of the last person results.append(heights[-1]) else: # Inserting in between, can be at most the height of the person in the same position results.append(heights[p]) return results"},{"question":"def min_energy(grid): Computes the minimum energy required to travel from the top-left corner to the bottom-right corner. :param grid: A list of lists representing the grid with energy levels. :return: An integer representing the minimum energy required. >>> min_energy([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_energy([[1, 2], [1, 1]]) 3 >>> min_energy([[5]]) 5 >>> min_energy([[1, 2, 3], [4, 8, 2], [1, 5, 3]]) 11 >>> min_energy([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5","solution":"def min_energy(grid): Computes the minimum energy required to travel from the top-left corner to the bottom-right corner. :param grid: A list of lists representing the grid with energy levels. :return: An integer representing the minimum energy required. n = len(grid) m = len(grid[0]) # Create a DP table to store the minimum energy required to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the grid for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The result is in the bottom-right corner return dp[n - 1][m - 1]"},{"question":"from typing import List, Tuple def alice_bob_game(arr: List[int]) -> Tuple[int, int]: Alice and Bob are playing a game with an array of integers. The game proceeds in turns, with Alice going first. Each player must choose an element from either end of the array and remove it. The game ends when there are no more elements left to remove from the array. The goal of each player is to maximize the sum of the elements they have chosen. Args: arr (List[int]): A list of integers representing the array, with 1 ≤ len(arr) ≤ 1000 and -1000 ≤ arr[i] ≤ 1000. Returns: Tuple[int, int]: The total sum of elements chosen by Alice and by Bob, respectively, if both players play optimally. >>> alice_bob_game([4, 7, 2, 3]) (10, 6) >>> alice_bob_game([1, 2, 3, 4]) (6, 4)","solution":"from typing import List, Tuple def alice_bob_game(arr: List[int]) -> Tuple[int, int]: def optimal_choice(l: int, r: int, is_alice: bool, dp: dict) -> Tuple[int, int]: if l > r: return (0, 0) if (l, r, is_alice) in dp: return dp[(l, r, is_alice)] if is_alice: take_left = optimal_choice(l + 1, r, not is_alice, dp) take_right = optimal_choice(l, r - 1, not is_alice, dp) if arr[l] + take_left[0] > arr[r] + take_right[0]: result = (arr[l] + take_left[0], take_left[1]) else: result = (arr[r] + take_right[0], take_right[1]) else: take_left = optimal_choice(l + 1, r, not is_alice, dp) take_right = optimal_choice(l, r - 1, not is_alice, dp) if arr[l] + take_left[1] > arr[r] + take_right[1]: result = (take_left[0], arr[l] + take_left[1]) else: result = (take_right[0], arr[r] + take_right[1]) dp[(l, r, is_alice)] = result return result dp = {} alice_score, bob_score = optimal_choice(0, len(arr) - 1, True, dp) return alice_score, bob_score"},{"question":"def max_solved_contests(contests, participants): Determines the maximum number of contests that can be solved by participants. Args: contests (List[int]): The list of difficulty levels of the contests. participants (List[int]): The list of skill levels of the participants. Returns: int: The maximum number of contests that can be solved. Example: >>> max_solved_contests([4, 1, 3, 2], [3, 1, 4]) 3 >>> max_solved_contests([4, 6, 8], [1, 2, 3]) 0 from solution import max_solved_contests def test_example_case(): contests = [4, 1, 3, 2] participants = [3, 1, 4] assert max_solved_contests(contests, participants) == 3 def test_no_participants(): contests = [4, 1, 3, 2] participants = [] assert max_solved_contests(contests, participants) == 0 def test_no_contests(): contests = [] participants = [1, 2, 3, 4] assert max_solved_contests(contests, participants) == 0 def test_all_participants_too_weak(): contests = [4, 6, 8] participants = [1, 2, 3] assert max_solved_contests(contests, participants) == 0 def test_all_participants_strong_enough(): contests = [1, 1, 1] participants = [1, 1, 1] assert max_solved_contests(contests, participants) == 3 def test_more_participants_than_contests(): contests = [1, 2] participants = [1, 2, 3, 4] assert max_solved_contests(contests, participants) == 2 def test_more_contests_than_participants(): contests = [1, 2, 3, 4, 5] participants = [2, 4] assert max_solved_contests(contests, participants) == 2 def test_varied_difficulties_and_skills(): contests = [5, 2, 8, 6, 3] participants = [4, 1, 5, 7] assert max_solved_contests(contests, participants) == 3","solution":"def max_solved_contests(contests, participants): # Sorting contests and participants to use a two pointer technique contests.sort() participants.sort() contests_solved = 0 i, j = 0, 0 while i < len(contests) and j < len(participants): if participants[j] >= contests[i]: # Participant j can solve contest i contests_solved += 1 i += 1 j += 1 else: # Participant j cannot solve contest i, go to the next participant j += 1 return contests_solved"},{"question":"def longest_substring_with_k_distinct(k: int, s: str) -> int: Given an integer k and a string s consisting of lowercase English letters, determine the length of the longest substring that contains no more than k distinct characters. >>> longest_substring_with_k_distinct(1, \\"aaaaa\\") == 5 >>> longest_substring_with_k_distinct(2, \\"aabbcc\\") == 4 >>> longest_substring_with_k_distinct(3, \\"aaabbccaaa\\") == 10 >>> longest_substring_with_k_distinct(0, \\"anystring\\") == 0 >>> longest_substring_with_k_distinct(3, \\"abc\\") == 3 >>> longest_substring_with_k_distinct(1, \\"\\") == 0 >>> longest_substring_with_k_distinct(2, \\"eceba\\") == 3 >>> longest_substring_with_k_distinct(10, \\"abcde\\") == 5","solution":"def longest_substring_with_k_distinct(k, s): Returns the length of the longest substring that contains no more than k distinct characters. if not s or k == 0: return 0 left = 0 right = 0 max_len = 0 char_count = {} while right < len(s): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def can_transform(s1: str, s2: str) -> str: Determines if it's possible to transform binary string s1 into binary string s2 using an even number of bit flip operations. :param s1: Initial binary string :param s2: Target binary string :return: \\"YES\\" if possible with an even number of bit flips, otherwise \\"NO\\" >>> can_transform(\\"11001\\", \\"10101\\") == \\"YES\\" >>> can_transform(\\"11111\\", \\"11111\\") == \\"YES\\" >>> can_transform(\\"000\\", \\"111\\") == \\"NO\\" >>> can_transform(\\"0000\\", \\"1111\\") == \\"YES\\" >>> can_transform(\\"1100\\", \\"1001\\") == \\"YES\\" >>> can_transform(\\"11001\\", \\"11101\\") == \\"NO\\" >>> can_transform(\\"110\\", \\"1100\\") == \\"NO\\"","solution":"def can_transform(s1, s2): Determines if it's possible to transform binary string s1 into binary string s2 using an even number of bit flip operations. :param s1: Initial binary string :param s2: Target binary string :return: \\"YES\\" if possible with an even number of bit flips, otherwise \\"NO\\" if len(s1) != len(s2): return \\"NO\\" bit_flips_needed = sum(1 for a, b in zip(s1, s2) if a != b) # It is possible if the number of differing bits is even return \\"YES\\" if bit_flips_needed % 2 == 0 else \\"NO\\""},{"question":"def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Determine the diameter of the tree given its number of nodes and edges. >>> tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> tree_diameter(1, []) 0 >>> tree_diameter(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> tree_diameter(5, [(1, 2), (2, 3), (2, 4), (4, 5)]) 3 >>> tree_diameter(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 4","solution":"def tree_diameter(n, edges): from collections import defaultdict, deque if n == 1: return 0 def bfs(start): visited = [False] * (n + 1) dist = [-1] * (n + 1) queue = deque([start]) visited[start] = True dist[start] = 0 max_dist_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True dist[neighbor] = dist[node] + 1 queue.append(neighbor) if dist[neighbor] > dist[max_dist_node]: max_dist_node = neighbor return max_dist_node, dist[max_dist_node] # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Step 1: BFS from an arbitrary node to find the farthest node 'x' x, _ = bfs(1) # Step 2: BFS from 'x' to find the farthest node from 'x' and the distance 'd' y, diameter = bfs(x) return diameter"},{"question":"def find_expression(n: int, k: int, matrix: List[str]) -> str: Given an n x n matrix with characters '+', '-', '*', '/', or invalid operators, determine whether any row or column can form a valid arithmetic expression that equals to the given integer k by making at most 3 * n queries. Prints \\"? i row\\" or \\"? i column\\" to query a specific row or column (1-based index). If a valid expression is found, returns \\"! FOUND\\". Otherwise, returns \\"! NOT FOUND\\". >>> find_expression(3, 12, [\\"*-/\\",\\"+/\\",\\"-//*\\"]) ! NOT FOUND >>> find_expression(2, 5, [\\"*-\\", \\"+/\\"]) ! NOT FOUND pass def test_find_expression_found_in_row(monkeypatch): responses = iter([\\"NO\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]) monkeypatch.setattr('builtins.input', lambda: next(responses)) assert find_expression(3, 12, [\\"*-/\\",\\"+/\\",\\"-//*\\"]) == \\"! FOUND\\" def test_find_expression_found_in_column(monkeypatch): responses = iter([\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]) monkeypatch.setattr('builtins.input', lambda: next(responses)) assert find_expression(3, 12, [\\"*-/\\",\\"+/\\",\\"-//*\\"]) == \\"! FOUND\\" def test_find_expression_not_found(monkeypatch): responses = iter([\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]) monkeypatch.setattr('builtins.input', lambda: next(responses)) assert find_expression(3, 12, [\\"*-/\\",\\"+/\\",\\"-//*\\"]) == \\"! NOT FOUND\\" def test_find_expression_larger_matrix(monkeypatch): responses = iter([\\"NO\\"] * 27) monkeypatch.setattr('builtins.input', lambda: next(responses)) assert find_expression(9, 12, [ \\"*-+*/-*-*\\", \\"+-*/+-*/-\\", \\"-*+/*-++-\\", \\"/--*/-+/*\\", \\"+*--/*+/-\\", \\"-*/-*/+*-\\", \\"/+*/-/+*+\\", \\"*-/*+-*/-\\", \\"+*--*+/*-\\"]) == \\"! NOT FOUND\\"","solution":"def find_expression(n, k, matrix): def query(index, type): return f\\"? {index + 1} {type}\\" # Maximum allowed queries max_queries = 3 * n # Perform row queries for i in range(n): print(query(i, \\"row\\")) response = input().strip() if response == \\"YES\\": return \\"! FOUND\\" # Perform column queries for i in range(n): print(query(i, \\"column\\")) response = input().strip() if response == \\"YES\\": return \\"! FOUND\\" return \\"! NOT FOUND\\""},{"question":"def check_all_employees_solved_at_least_one(m: int, submissions: List[Tuple[int, str, int]]) -> str: Determine if each employee who attempted the contest successfully solved at least one problem. >>> check_all_employees_solved_at_least_one(4, [(1, \\"easy\\", 1), (2, \\"medium\\", 1), (1, \\"hard\\", 0), (2, \\"easy\\", 0)]) \\"YES\\" >>> check_all_employees_solved_at_least_one(4, [(1, \\"easy\\", 1), (2, \\"medium\\", 0), (2, \\"hard\\", 0), (3, \\"medium\\", 0)]) \\"NO\\" from typing import List, Tuple def test_all_employees_solved(): submissions = [ (1, \\"easy\\", 1), (2, \\"medium\\", 1), (1, \\"hard\\", 0), (2, \\"easy\\", 0), ] assert check_all_employees_solved_at_least_one(4, submissions) == \\"YES\\" def test_some_employees_did_not_solve(): submissions = [ (1, \\"easy\\", 1), (2, \\"medium\\", 0), (2, \\"hard\\", 0), (3, \\"medium\\", 0), ] assert check_all_employees_solved_at_least_one(4, submissions) == \\"NO\\" def test_employee_with_correct_and_incorrect_submissions(): submissions = [ (1, \\"easy\\", 1), (1, \\"hard\\", 0), (2, \\"medium\\", 0), (2, \\"hard\\", 1), (3, \\"easy\\", 0), ] assert check_all_employees_solved_at_least_one(5, submissions) == \\"NO\\" def test_only_one_employee(): submissions = [ (1, \\"easy\\", 1), (1, \\"medium\\", 0), (1, \\"hard\\", 0), ] assert check_all_employees_solved_at_least_one(3, submissions) == \\"YES\\" def test_no_submissions(): submissions = [] assert check_all_employees_solved_at_least_one(0, submissions) == \\"YES\\"","solution":"def check_all_employees_solved_at_least_one(m, submissions): employees = {} for submission in submissions: employee_id, difficulty, correct = submission if employee_id not in employees: employees[employee_id] = 0 if correct == 1: employees[employee_id] += 1 for solved in employees.values(): if solved == 0: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def hasPairWithSum(nums: List[int], k: int) -> bool: Determines if there are two distinct elements in the array whose sum is equal to k. >>> hasPairWithSum([10, 15, 3, 7], 17) True >>> hasPairWithSum([1, 2, 3, 9], 8) False >>> hasPairWithSum([5, 5, 5, 5], 10) True >>> hasPairWithSum([1], 2) False >>> hasPairWithSum([], 0) False >>> hasPairWithSum([-10**9, 0, 10**9], 0) True >>> hasPairWithSum([-1, -2, -3, -4, -5], -8) True >>> hasPairWithSum([0, 0], 0) True >>> hasPairWithSum([0, -1, 1], 0) True","solution":"def hasPairWithSum(nums, k): Determines if there are two distinct elements in the array whose sum is equal to k. Parameters: nums (List[int]): List of integers k (int): The target sum Returns: bool: True if a pair exists with the sum of k, False otherwise seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"def largest_prime(n: int) -> int: Returns the largest prime number less than or equal to n. >>> largest_prime(10) 7 >>> largest_prime(29) 29 >>> largest_prime(1) None","solution":"def largest_prime(n): Returns the largest prime number less than or equal to n. if n < 2: return None # Sieve of Eratosthenes to find all primes up to n sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for i in range(start*start, n + 1, start): sieve[i] = False # Find the largest prime number less than or equal to n for num in range(n, 1, -1): if sieve[num]: return num"},{"question":"def can_plant_flowers(garden: List[int], n: int) -> bool: Determines if n new flowers can be planted in the garden without violating the no-adjacent-flowers rule. Parameters: garden (list of int): The garden array where 0 means an empty cell and 1 means a cell with a flower. n (int): The number of new flowers Alice wants to plant. Returns: bool: True if Alice can plant the n new flowers, False otherwise. pass def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[bool]: Processes a list of test cases to determine if Alice can plant the given number of flowers in each garden. Parameters: test_cases (list of tuple): List of test cases where each test case is a tuple (n, m, garden). Returns: list of bool: List of results for each test case. pass from typing import List, Tuple def test_example_1(): assert process_test_cases([(1, 5, [1, 0, 0, 0, 1])]) == [True] def test_example_2(): assert process_test_cases([(2, 5, [1, 0, 0, 1, 0])]) == [False] def test_example_3(): assert process_test_cases([(1, 4, [1, 0, 0, 0])]) == [True] def test_multiple_test_cases(): test_cases = [ (1, 5, [1, 0, 0, 0, 1]), # True (2, 5, [1, 0, 0, 1, 0]), # False (1, 4, [1, 0, 0, 0]), # True (3, 7, [0, 0, 0, 0, 0, 0, 0]), # True (1, 1, [0]), # True (1, 1, [1]), # False ] expected = [True, False, True, True, True, False] assert process_test_cases(test_cases) == expected def test_edge_cases(): assert process_test_cases([(1, 10, [0]*10)]) == [True] assert process_test_cases([(5, 10, [0, 1, 0, 1, 0, 1, 0, 1, 0, 1])]) == [False] assert process_test_cases([(2, 5, [1, 0, 0, 0, 0])]) == [True] assert process_test_cases([(0, 5, [1, 0, 0, 0, 0])]) == [True] def test_large_array(): assert process_test_cases([(5000, 10000, [0] * 10000)]) == [True] assert process_test_cases([(5001, 10000, [0] * 10000)]) == [False] assert process_test_cases([(2000, 10000, [i % 2 for i in range(10000)])]) == [False]","solution":"def can_plant_flowers(garden, n): Determines if n new flowers can be planted in the garden without violating the no-adjacent-flowers rule. Parameters: garden (list of int): The garden array where 0 means an empty cell and 1 means a cell with a flower. n (int): The number of new flowers Alice wants to plant. Returns: bool: True if Alice can plant the n new flowers, False otherwise. length = len(garden) count = 0 for i in range(length): # Check if current position is empty and both neighbors (if any) are empty or boundaries if garden[i] == 0 and (i == 0 or garden[i-1] == 0) and (i == length-1 or garden[i+1] == 0): # Plant a flower here garden[i] = 1 count += 1 if count >= n: return True return count >= n def process_test_cases(test_cases): results = [] for t in test_cases: n, m, garden = t results.append(can_plant_flowers(garden, n)) return results"},{"question":"from typing import List, Tuple def graph_path_exists(n: int, m: int, k: int, edges: List[Tuple[int, int, int]]) -> str: Determine if there exists a path between any two vertices such that the sum of weights along the path equals k. Parameters: n (int): Number of vertices m (int): Number of edges k (int): Desired sum of weights edges (List[Tuple[int, int, int]]): List of edges, where each edge is represented by a tuple (u, v, w) Returns: str: \\"YES\\" if there exists a path with sum of weights equals k, otherwise \\"NO\\". Examples: >>> graph_path_exists(5, 6, 7, [(1, 2, 3), (2, 3, 4), (1, 3, 5), (3, 4, 2), (2, 5, 1), (4, 5, -1)]) \\"YES\\" >>> graph_path_exists(3, 3, 6, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) \\"NO\\" pass def test_case_1(): n = 5 m = 6 k = 7 edges = [(1, 2, 3), (2, 3, 4), (1, 3, 5), (3, 4, 2), (2, 5, 1), (4, 5, -1)] assert graph_path_exists(n, m, k, edges) == \\"YES\\" def test_case_2(): n = 3 m = 3 k = 6 edges = [(1, 2, 1), (2, 3, 2), (1, 3, 3)] assert graph_path_exists(n, m, k, edges) == \\"NO\\" def test_case_3(): n = 4 m = 4 k = 2 edges = [(1, 2, 1), (2, 3, 1), (3, 4, 2), (1, 4, -5)] assert graph_path_exists(n, m, k, edges) == \\"YES\\" def test_case_4(): n = 2 m = 1 k = 5 edges = [(1, 2, 5)] assert graph_path_exists(n, m, k, edges) == \\"YES\\" def test_case_5(): n = 2 m = 1 k = 4 edges = [(1, 2, 5)] assert graph_path_exists(n, m, k, edges) == \\"NO\\"","solution":"import collections from itertools import product def does_path_exist(n, m, k, edges): Returns \\"YES\\" if there exists any path between any two vertices such that the sum of weights along the path equals k. Otherwise, returns \\"NO\\". graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dfs(node, target, visited, current_sum): if current_sum == target: return True visited.add(node) for neighbor, weight in graph[node]: if neighbor not in visited: if dfs(neighbor, target, visited, current_sum + weight): return True visited.remove(node) return False for start_node in range(1, n + 1): if dfs(start_node, k, set(), 0): return \\"YES\\" return \\"NO\\" def graph_path_exists(n, m, k, edges): return does_path_exist(n, m, k, edges)"},{"question":"def closest_sum_to_target(difficulties: List[int], target: int) -> int: Given an array of integers where each integer represents the difficulty of a challenge and an integer T, find the subset of challenges whose sum of difficulties is closest to T. Args: difficulties : List[int]: A list of integers representing the difficulty levels of challenges. target : int: An integer T representing the target difficulty value. Returns: int: The sum of difficulties of the subset that is closest to T. >>> closest_sum_to_target([3, 34, 4, 12, 5], 9) 9 >>> closest_sum_to_target([1, 2, 9, 10], 6) 3","solution":"def closest_sum_to_target(difficulties, target): Returns the sum of the subset of difficulties closest to the target. n = len(difficulties) dp = [0] * (target + 1) for difficulty in difficulties: for i in range(target, difficulty - 1, -1): dp[i] = max(dp[i], dp[i - difficulty] + difficulty) return dp[target]"},{"question":"def max_sum_subarray_with_one_exclusion(n: int, k: int, arr: List[int]) -> int: Returns the maximum sum of a subarray of length exactly k after removing at most one element from a subarray of length k+1. >>> max_sum_subarray_with_one_exclusion(8, 3, [6, 2, 1, 8, 10, 7, 4, 7]) 25 >>> max_sum_subarray_with_one_exclusion(5, 3, [5, 1, 3, 7, 6]) 16 >>> max_sum_subarray_with_one_exclusion(5, 2, [4, 4, 4, 4, 4]) 8 >>> max_sum_subarray_with_one_exclusion(1, 1, [10000]) 10000 >>> max_sum_subarray_with_one_exclusion(100000, 99999, [i for i in range(1, 100001)]) 5000050000 >>> max_sum_subarray_with_one_exclusion(7, 3, [5, 1, 2, 3, 6, 8, 12]) 26","solution":"def max_sum_subarray_with_one_exclusion(n, k, arr): Returns the maximum sum of a subarray of length exactly k after removing at most one element from a subarray of length k+1. # Calculate the initial k sum cur_sum = sum(arr[:k]) max_sum = cur_sum # Calculate the k+1 sums and determine sums after removing one element for i in range(k, n): cur_sum += arr[i] - arr[i - k] max_sum = max(max_sum, cur_sum) check_sum = cur_sum - min(arr[i - k: i + 1]) max_sum = max(max_sum, check_sum) return max_sum"},{"question":"def exists_anomalous_point(points): Determine if there exists an anomalous point in a list of 2D points on a Cartesian plane. The function should return \\"YES\\" if there exists at least one anomalous point, otherwise return \\"NO\\". >>> exists_anomalous_point([(0, 0), (2, 0), (1, 1), (3, 3), (10, 10)]) == \\"YES\\" >>> exists_anomalous_point([(1, 1), (2, 2), (3, 3), (4, 4)]) == \\"NO\\"","solution":"def exists_anomalous_point(points): import math def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) n = len(points) if n < 2: return \\"NO\\" # Calculate all distances distances = [] for i in range(n): for j in range(i + 1, n): dist = euclidean_distance(points[i], points[j]) distances.append((dist, i, j)) distances.sort() # Sort distances by the first element, which is the distance min_distance = distances[0][0] # Dictionary to track the nearest neighbor distance for each point nearest_neighbor_distance = [float('inf')] * n for dist, p1, p2 in distances: nearest_neighbor_distance[p1] = min(nearest_neighbor_distance[p1], dist) nearest_neighbor_distance[p2] = min(nearest_neighbor_distance[p2], dist) for dist, p1, p2 in distances: if nearest_neighbor_distance[p1] >= 2 * min_distance or nearest_neighbor_distance[p2] >= 2 * min_distance: return \\"YES\\" return \\"NO\\""},{"question":"def min_elements_to_remove_to_meet_target(n: int, t: int, elements: List[int]) -> int: Given a list of integers, remove the minimum number of elements to make the sum of the remaining elements equal to a target value. If it is not possible to achieve the target sum, return -1. >>> min_elements_to_remove_to_meet_target(5, 9, [1, 2, 3, 4, 5]) 0 >>> min_elements_to_remove_to_meet_target(5, 10, [1, 2, 3, 4, 5]) 1 >>> min_elements_to_remove_to_meet_target(5, 7, [1, 2, 3, 4, 5]) 2 >>> min_elements_to_remove_to_meet_target(5, 8, [1, 2, 3, 4, 5]) 2 >>> min_elements_to_remove_to_meet_target(5, 20, [1, 2, 3, 4, 5]) -1 >>> min_elements_to_remove_to_meet_target(5, 0, [1, 2, 3, 4, 5]) 5 >>> min_elements_to_remove_to_meet_target(5, 14, [1, 2, 3, 4, 5]) 1","solution":"def min_elements_to_remove_to_meet_target(n, t, elements): from itertools import combinations total_sum = sum(elements) if total_sum == t: return 0 min_removals = float('inf') found = False for i in range(1, n + 1): for subset in combinations(elements, i): if total_sum - sum(subset) == t: min_removals = min(min_removals, i) found = True return min_removals if found else -1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\" \\") 1 >>> length_of_longest_substring(\\"\\") 0 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases([\\"dvdf\\", \\"anviaj\\", \\" \\"]) [3, 5, 1] >>> process_test_cases([]) [] >>> process_test_cases([\\"\\"]) [0]","solution":"def length_of_longest_substring(s): This function takes a string s and returns the length of the longest substring with all distinct characters. n = len(s) char_set = set() left = 0 max_length = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length def process_test_cases(test_cases): results = [] for case in test_cases: results.append(length_of_longest_substring(case)) return results"},{"question":"from typing import List def shortest_path_matrix(n: int, matrix: List[List[int]]) -> List[List[int]]: Computes the length of the shortest path between every pair of clearings. :param n: The number of clearings. :param matrix: The adjacency matrix representing path lengths. :return: A matrix of shortest paths between all pairs of clearings. Example usage: >>> input_matrix = [ ... [0, 3, -1, 7], ... [3, 0, 2, 8], ... [-1, 2, 0, 1], ... [7, 8, 1, 0] ... ] >>> expected_output = [ ... [0, 3, 5, 6], ... [3, 0, 2, 3], ... [5, 2, 0, 1], ... [6, 3, 1, 0] ... ] >>> assert shortest_path_matrix(4, input_matrix) == expected_output >>> input_matrix = [ ... [0, -1, -1, -1], ... [-1, 0, -1, -1], ... [-1, -1, 0, -1], ... [-1, -1, -1, 0] ... ] >>> expected_output = [ ... [0, -1, -1, -1], ... [-1, 0, -1, -1], ... [-1, -1, 0, -1], ... [-1, -1, -1, 0] ... ] >>> assert shortest_path_matrix(4, input_matrix) == expected_output >>> input_matrix = [ ... [0, 2, 4, 6], ... [2, 0, 3, 5], ... [4, 3, 0, 1], ... [6, 5, 1, 0] ... ] >>> expected_output = [ ... [0, 2, 4, 5], ... [2, 0, 3, 4], ... [4, 3, 0, 1], ... [5, 4, 1, 0] ... ] >>> assert shortest_path_matrix(4, input_matrix) == expected_output >>> input_matrix = [ ... [0, 0, -1, 4], ... [0, 0, 1, -1], ... [-1, 1, 0, 2], ... [4, -1, 2, 0] ... ] >>> expected_output = [ ... [0, 0, 1, 3], ... [0, 0, 1, 3], ... [1, 1, 0, 2], ... [3, 3, 2, 0] ... ] >>> assert shortest_path_matrix(4, input_matrix) == expected_output # Implementation here","solution":"def floyd_warshall(n, graph): Uses Floyd-Warshall algorithm to find the shortest paths between all pairs of clearings. :param n: Number of clearings. :param graph: Adjacency matrix representing path lengths. :return: Matrix of shortest paths between all pairs of clearings. # Initialize the distance matrix dist = [[float('inf')] * n for _ in range(n)] # Initialize distances according to the input graph for i in range(n): for j in range(n): if i == j: dist[i][j] = 0 elif graph[i][j] != -1: dist[i][j] = graph[i][j] # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][k] < float('inf') and dist[k][j] < float('inf'): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) # Replace float('inf') with -1 to indicate no path exists for i in range(n): for j in range(n): if dist[i][j] == float('inf'): dist[i][j] = -1 return dist # Example usage: def shortest_path_matrix(n, matrix): return floyd_warshall(n, matrix)"},{"question":"def count_primes_in_range(l: int, r: int) -> int: Returns the count of prime numbers in the inclusive range [l, r]. Parameters: l (int): the start of the range (inclusive) r (int): the end of the range (inclusive) Returns: int: the count of primes in the range Example: >>> count_primes_in_range(10, 30) 6 >>> count_primes_in_range(1, 10) 4 >>> count_primes_in_range(13, 13) 1 >>> count_primes_in_range(14, 16) 0 >>> count_primes_in_range(1, 100) 25 from solution import count_primes_in_range def test_prime_count_small_range(): assert count_primes_in_range(10, 30) == 6 def test_prime_count_entire_range(): assert count_primes_in_range(1, 10) == 4 def test_prime_count_single_prime(): assert count_primes_in_range(13, 13) == 1 def test_prime_count_no_primes(): assert count_primes_in_range(14, 16) == 0 def test_prime_count_large_range(): assert count_primes_in_range(1, 100) == 25","solution":"def count_primes_in_range(l, r): Returns the count of prime numbers in the inclusive range [l, r]. Parameters: l (int): the start of the range (inclusive) r (int): the end of the range (inclusive) Returns: int: the count of primes in the range def sieve(n): is_prime = [True] * (n+1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n+1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False return is_prime prime = sieve(r) count = 0 for i in range(l, r+1): if prime[i]: count += 1 return count"},{"question":"def max_reward(n: int, D: int, levels: List[Tuple[int, int]]) -> int: Given the number of levels \`n\`, maximum obstacle difficulty \`D\`, and a list of levels with their respective difficulties and rewards, find the maximum total reward \`S\` that can be achieved without exceeding the total obstacle difficulty limit \`D\`. :param n: int, number of levels :param D: int, maximum total obstacle difficulty :param levels: list of tuples, where each tuple (di, ri) represents the obstacle difficulty and reward of a level :return: int, the maximum total reward >>> max_reward(4, 50, [(10, 60), (20, 100), (30, 120), (40, 200)]) 260 >>> max_reward(3, 50, [(60, 100), (80, 200), (90, 300)]) 0 >>> max_reward(3, 3, [(1, 1), (1, 1), (1, 1)]) 3 >>> max_reward(1, 1, [(1, 1)]) 1 >>> max_reward(3, 1000, [(1, 100), (2, 200), (3, 300)]) 600","solution":"def max_reward(n, D, levels): Returns the maximum total reward possible without exceeding the total obstacle difficulty limit D. :param n: int, number of levels :param D: int, maximum total obstacle difficulty :param levels: list of tuples, where each tuple (di, ri) represents the obstacle difficulty and reward of a level :return: int, the maximum total reward # Create an array to store the maximum reward for each difficulty from 0 to D dp = [0] * (D + 1) for d, r in levels: # Traverse the dp array in reverse to prevent over-counting for j in range(D, d - 1, -1): dp[j] = max(dp[j], dp[j - d] + r) return max(dp)"},{"question":"from collections import deque from typing import List, Tuple def min_transformations(n: int, words: List[str], start: str, end: str) -> int: Returns the minimum number of transformations needed to change start into end by changing exactly one letter at a time with each intermediate word being a valid English word. If no transformation is possible, returns -1. Args: n (int): number of words in dictionary words (List[str]): list of valid English words start (str): starting word end (str): ending word Returns: int: minimum number of transformations or -1 if not possible Examples: >>> min_transformations(6, [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"], \\"hit\\", \\"cog\\") 4 >>> min_transformations(6, [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"], \\"hit\\", \\"hot\\") 1 # Test Cases def test_no_transformation_needed(): assert min_transformations(6, [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"], \\"hit\\", \\"hit\\") == 0 def test_one_transformation(): assert min_transformations(6, [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"], \\"hit\\", \\"hot\\") == 1 def test_multiple_transformations(): assert min_transformations(6, [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"], \\"hit\\", \\"cog\\") == 4 def test_no_possible_transformation(): assert min_transformations(6, [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"], \\"hit\\", \\"cog\\") == -1 def test_disconnected_graph(): assert min_transformations(5, [\\"abc\\", \\"abd\\", \\"xyz\\", \\"xyy\\", \\"xxz\\"], \\"abc\\", \\"xxz\\") == -1 def test_different_word_lengths(): # The test case below should actually never be encountered as per the problem statement # it is guaranteed that 'start' and 'end' are of the same length. assert min_transformations(3, [\\"abc\\", \\"def\\", \\"xyz\\"], \\"abcd\\", \\"xyz\\") == -1","solution":"from collections import deque def min_transformations(n, words, start, end): Returns the minimum number of transformations needed to change start into end by changing exactly one letter at a time with each intermediate word being valid. If no transformation is possible, returns -1. word_set = set(words) if end not in word_set: return -1 word_set.add(start) queue = deque([(start, 0)]) while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling a stock once. :param prices: List of stock prices where prices[i] is the price of the stock on the i-th day. :return: The maximum profit achievable, or 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4 >>> max_profit([2, 4, 1, 8, 7, 9]) 8 >>> max_profit([]) 0 >>> max_profit([1]) 0 >>> max_profit([2, 1, 4]) 3","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling a stock once. :param prices: List of stock prices where prices[i] is the price of the stock on the i-th day. :return: The maximum profit achievable, or 0 if no profit is possible. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def max_buildings_receive_sunlight(n: int, heights: List[int]) -> int: Returns the maximum number of contiguous buildings that can receive sunlight. :param n: int - the number of buildings. :param heights: list of int - the heights of the buildings. :return: int - the maximum number of contiguous buildings that can receive sunlight. from typing import List # Test cases def test_max_buildings_receive_sunlight_basic(): assert max_buildings_receive_sunlight(6, [4, 2, 3, 1, 5, 8]) == 2 def test_all_same_height(): assert max_buildings_receive_sunlight(5, [3, 3, 3, 3, 3]) == 1 def test_increasing_heights(): assert max_buildings_receive_sunlight(4, [1, 2, 3, 4]) == 1 def test_decreasing_heights(): assert max_buildings_receive_sunlight(5, [5, 4, 3, 2, 1]) == 5 def test_single_building(): assert max_buildings_receive_sunlight(1, [7]) == 1 def test_alternating_heights(): assert max_buildings_receive_sunlight(6, [5, 2, 6, 1, 7, 3]) == 2 def test_edge_case_no_height(): assert max_buildings_receive_sunlight(5, [10**9, 10**9-1, 10**9-2, 10**9-3, 10**9-4]) == 5","solution":"def max_buildings_receive_sunlight(n, heights): Returns the maximum number of contiguous buildings that can receive sunlight. :param n: int - the number of buildings. :param heights: list of int - the heights of the buildings. :return: int - the maximum number of contiguous buildings that can receive sunlight. # If there's only one building, it will always receive sunlight. if n == 1: return 1 max_count = 1 # At least the first building receives sunlight. current_count = 1 max_height = heights[0] # The height of the first building for i in range(1, n): if heights[i] < max_height: current_count += 1 max_height = heights[i] else: break return current_count"},{"question":"def max_sword_power(n: int, enchantments: List[int]) -> int: Calculates the maximum possible total power of the sword by rearranging the enchantments in non-decreasing order to avoid any decreases due to adjacent slots. :param n: Number of slots (integer) :param enchantments: List of enchantment power values (list of integers) :return: Maximum total power of the sword (integer) >>> max_sword_power(5, [4, 2, 3, 1, 5]) 15 >>> max_sword_power(4, [1, 2, 3, 4]) 10 >>> max_sword_power(1, [7]) 7 >>> max_sword_power(5, [3, 3, 3, 3, 3]) 15 >>> max_sword_power(3, [1000000, 500000, 100000]) 1600000 >>> max_sword_power(6, [5, 1, 9, 3, 7, 2]) 27 # Implement your function here","solution":"def max_sword_power(n, enchantments): Calculates the maximum possible total power of the sword by rearranging the enchantments in non-decreasing order to avoid any decreases due to adjacent slots. :param n: Number of slots (integer) :param enchantments: List of enchantment power values (list of integers) :return: Maximum total power of the sword (integer) enchantments.sort() return sum(enchantments)"},{"question":"def is_balanced_possible(n: int, S: str) -> str: Determine if it is possible to make the binary string balanced by performing the described operations, and if so, find the minimal number of operations required. Args: n (int): The length of the binary string S. S (str): The binary string consisting of only '0's and '1's. Returns: str: \\"YES\\" if it is possible to make the binary string balanced and the minimal number of operations required, or \\"NO\\" if it is not possible. Examples: >>> is_balanced_possible(4, '1100') 'YESn0' >>> is_balanced_possible(5, '11011') 'NO' from solution import is_balanced_possible def test_balanced_possible(): assert is_balanced_possible(4, '1100') == 'YESn0' def test_balanced_not_possible(): assert is_balanced_possible(5, '11011') == 'NO' def test_single_character_string(): assert is_balanced_possible(1, '0') == 'NO' assert is_balanced_possible(1, '1') == 'NO' def test_even_length_unbalanced(): assert is_balanced_possible(6, '111000') == 'YESn0' def test_odd_length_unbalanced(): assert is_balanced_possible(7, '1110000') == 'NO'","solution":"def is_balanced_possible(n, S): count_0 = S.count('0') count_1 = S.count('1') if count_0 != count_1: return \\"NO\\" return \\"YESn0\\""},{"question":"from typing import List def areReorderableTagsDistinct(posts: List[List[int]]) -> bool: Determines whether it's possible to reorder the tags of each post such that no post will have the same set of tags as another post. Args: posts (List[List[int]]): A list of lists, where each sublist represents a post with distinct integer tags. Returns: bool: True if it's possible to reorder the tags such that all posts have unique sets of tags, False otherwise. Examples: >>> areReorderableTagsDistinct([[1, 2, 3], [4, 5, 6], [1, 2, 3]]) False >>> areReorderableTagsDistinct([[1, 2, 3], [3, 2, 1], [1, 3, 2]]) False >>> areReorderableTagsDistinct([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) True","solution":"def areReorderableTagsDistinct(posts): Determines whether it's possible to reorder the tags of each post such that no post will have the same set of tags as another post. Args: posts (List[List[int]]): A list of lists, where each sublist represents a post with distinct integer tags. Returns: bool: True if it's possible to reorder the tags such that all posts have unique sets of tags, False otherwise. # Convert each list of tags to a sorted tuple which makes comparison easier sorted_post_sets = [tuple(sorted(post)) for post in posts] # Convert list of sorted tuples to a set to eliminate any duplicates unique_post_sets = set(sorted_post_sets) # If the length of the original list and the set are the same, all posts had unique sets return len(posts) == len(unique_post_sets)"},{"question":"def max_elements_to_remove(n: int, m: int, k: int, c: int, p: List[int], q: List[int]) -> int: Calculate the maximum total number of elements that can be removed from both sequences without allowing Aniston's energy to go negative. >>> max_elements_to_remove(5, 4, 10, 1, [1, 2, 3, 4, 5], [6, 7, 8, 9]) 9 >>> max_elements_to_remove(5, 4, 6, 1, [1, 2, 3, 4, 5], [6, 7, 8, 9]) 6 >>> max_elements_to_remove(5, 4, 2, 3, [1, 2, 3, 4, 5], [6, 7, 8, 9]) 0 >>> max_elements_to_remove(5, 0, 6, 1, [1, 2, 3, 4, 5], []) 5 >>> max_elements_to_remove(0, 0, 10, 1, [], []) 0","solution":"def max_elements_to_remove(n, m, k, c, p, q): total_removed = 0 p_index, q_index = 0, 0 while p_index < n and k >= c: k -= c p_index += 1 total_removed += 1 while q_index < m and k >= c: k -= c q_index += 1 total_removed += 1 return total_removed"},{"question":"from typing import List def is_path_possible(grid: List[str], n: int, m: int, sx: int, sy: int, fx: int, fy: int) -> str: Determines if there is a path from (sx, sy) to (fx, fy) on the given grid avoiding '#' cells. >>> grid = [ ... '.....', ... '.#.', ... '.....', ... '.#.', ... '.....' ... ] >>> n, m = 5, 5 >>> sx, sy, fx, fy = 1, 1, 5, 5 >>> is_path_possible(grid, n, m, sx, sy, fx, fy) 'YES' >>> grid = [ ... '....#', ... '.#.', ... '.....', ... '.#.', ... '.....' ... ] >>> n, m = 5, 5 >>> sx, sy, fx, fy = 1, 1, 5, 5 >>> is_path_possible(grid, n, m, sx, sy, fx, fy) 'NO' # Implement the solution here","solution":"from collections import deque def is_path_possible(grid, n, m, sx, sy, fx, fy): Determines if there is a path from (sx, sy) to (fx, fy) on the given grid avoiding '#' cells. # Convert to zero-based indexing sx -= 1 sy -= 1 fx -= 1 fy -= 1 if grid[sx][sy] == '#' or grid[fx][fy] == '#': return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(sx, sy)]) visited[sx][sy] = True while queue: x, y = queue.popleft() if (x, y) == (fx, fy): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def max_stacks(n: int, boxes: List[Tuple[int, int]]) -> int: Determine the maximum number of stacks that can be formed while adhering to the constraints given each box's weight and stack limit. >>> max_stacks(4, [(5, 10), (3, 6), (4, 8), (2, 5)]) 3 >>> max_stacks(1, [(7, 10)]) 1 >>> max_stacks(3, [(10, 5), (5, 4), (2, 1)]) 3 >>> max_stacks(3, [(4, 10), (3, 6), (2, 5)]) 2 >>> max_stacks(5, [(2, 4), (2, 4), (2, 4), (2, 4), (2, 4)]) 3 >>> max_stacks(6, [(9, 20), (1, 11), (4, 7), (1, 8), (3, 10), (2, 5)]) 3","solution":"def max_stacks(n, boxes): boxes.sort(key=lambda x: x[1]) # Sort boxes based on their stack weight limit stacks = [] for weight, limit in boxes: placed = False for stack in stacks: if sum(w for w, _ in stack) + weight <= stack[-1][1]: stack.append((weight, limit)) placed = True break if not placed: stacks.append([(weight, limit)]) return len(stacks) # Example usage: n = 4 boxes = [(5, 10), (3, 6), (4, 8), (2, 5)] print(max_stacks(n, boxes)) # Output: 3"},{"question":"def total_pages(n, pages, m, intervals): Calculate the total number of pages read according to the given intervals. Args: - n (int): number of chapters in the book. - pages (list of int): number of pages in each chapter. - m (int): number of reading intervals. - intervals (list of tuple): list of tuples where each tuple contains two integers a and b representing the start and end chapters of the interval. Returns: - int: total number of pages read according to the intervals. Examples: >>> n = 5, pages = [10, 20, 30, 40, 50], m = 2, intervals = [(1, 3), (2, 5)] >>> total_pages(n, pages, m, intervals) 200 >>> n = 4, pages = [10, 20, 30, 40], m = 0, intervals = [] >>> total_pages(n, pages, m, intervals) 0 >>> n = 6, pages = [10, 20, 30, 40, 50, 60], m = 3, intervals = [(1, 2), (3, 4), (5, 6)] >>> total_pages(n, pages, m, intervals) 210 # Your code goes here # Example Usage n = 5 pages = [10, 20, 30, 40, 50] m = 2 intervals = [(1, 3), (2, 5)] print(total_pages(n, pages, m, intervals)) # Output should be 200","solution":"def total_pages(n, pages, m, intervals): Calculate the total number of pages read according to the given intervals. Args: - n (int): number of chapters in the book. - pages (list of int): number of pages in each chapter. - m (int): number of reading intervals. - intervals (list of tuple): list of tuples where each tuple contains two integers a and b representing the start and end chapters of the interval. Returns: - int: total number of pages read according to the intervals. total_pages_read = 0 for (a, b) in intervals: total_pages_read += sum(pages[a-1:b]) return total_pages_read # Example usage n = 5 pages = [10, 20, 30, 40, 50] m = 2 intervals = [(1, 3), (2, 5)] print(total_pages(n, pages, m, intervals)) # Output should be 200"},{"question":"def encrypt(message: str, shift: int) -> str: Encrypt the message using a Caesar cipher with the given shift. >>> encrypt(\\"hello world\\", 3) \\"khoor zruog\\" >>> encrypt(\\"HELLO WORLD\\", 3) \\"KHOOR ZRUOG\\" >>> encrypt(\\"hello world! 123\\", 3) \\"khoor zruog! 123\\" >>> encrypt(\\"hello world\\", 0) \\"hello world\\" def decrypt(encrypted_message: str, shift: int) -> str: Decrypt the message previously encrypted using a Caesar cipher with the given shift. >>> decrypt(\\"khoor zruog\\", 3) \\"hello world\\" >>> decrypt(\\"KHOOR ZRUOG\\", 3) \\"HELLO WORLD\\" >>> decrypt(\\"khoor zruog! 123\\", 3) \\"hello world! 123\\" >>> decrypt(\\"hello world\\", 0) \\"hello world\\"","solution":"def encrypt(message, shift): Encrypt the message using a Caesar cipher with the given shift. encrypted_message = [] for char in message: if char.isalpha(): shift_base = ord('A') if char.isupper() else ord('a') shifted_char = chr(shift_base + (ord(char) - shift_base + shift) % 26) encrypted_message.append(shifted_char) else: encrypted_message.append(char) return ''.join(encrypted_message) def decrypt(encrypted_message, shift): Decrypt the message previously encrypted using a Caesar cipher with the given shift. decrypted_message = [] for char in encrypted_message: if char.isalpha(): shift_base = ord('A') if char.isupper() else ord('a') shifted_char = chr(shift_base + (ord(char) - shift_base - shift) % 26) decrypted_message.append(shifted_char) else: decrypted_message.append(char) return ''.join(decrypted_message)"},{"question":"class BankAccount: A class representing a simple banking system. Methods: - __init__(self, balance: int): Initialize the bank account with the given balance. - deposit(self, amount: int) -> int: Add the given amount to the account balance and return the new balance. - withdraw(self, amount: int) -> Union[int, str]: Subtract the given amount from the account balance and return the new balance. If the balance is insufficient, return the string \\"Insufficient funds\\". - transfer(self, amount: int, target_account: 'BankAccount') -> Union[int, str]: Transfer the given amount from this account to the target account. If the balance is insufficient, return the string \\"Insufficient funds\\". Return the new balance of the account after the transfer. - get_balance(self) -> int: Return the current balance of the account. # Add your implementation here def test_initial_balance(): account = BankAccount(1000) assert account.get_balance() == 1000 def test_deposit(): account = BankAccount(1000) new_balance = account.deposit(200) assert new_balance == 1200 assert account.get_balance() == 1200 def test_withdraw_sufficient_balance(): account = BankAccount(1000) new_balance = account.withdraw(300) assert new_balance == 700 assert account.get_balance() == 700 def test_withdraw_insufficient_balance(): account = BankAccount(1000) result = account.withdraw(1500) assert result == \\"Insufficient funds\\" assert account.get_balance() == 1000 def test_transfer_sufficient_balance(): account1 = BankAccount(1000) account2 = BankAccount(500) new_balance = account1.transfer(400, account2) assert new_balance == 600 assert account1.get_balance() == 600 assert account2.get_balance() == 900 def test_transfer_insufficient_balance(): account1 = BankAccount(500) account2 = BankAccount(1000) result = account1.transfer(600, account2) assert result == \\"Insufficient funds\\" assert account1.get_balance() == 500 assert account2.get_balance() == 1000 def test_get_balance(): account = BankAccount(1000) assert account.get_balance() == 1000","solution":"class BankAccount: def __init__(self, balance: int): self.balance = balance def deposit(self, amount: int) -> int: self.balance += amount return self.balance def withdraw(self, amount: int) -> int: if amount > self.balance: return \\"Insufficient funds\\" self.balance -= amount return self.balance def transfer(self, amount: int, target_account: 'BankAccount') -> int: if amount > self.balance: return \\"Insufficient funds\\" self.balance -= amount target_account.deposit(amount) return self.balance def get_balance(self) -> int: return self.balance"},{"question":"from typing import List from collections import Counter def top_k_frequent_words(n: int, k: int, words: List[str]) -> List[str]: Returns the k most frequent words from the given list. If multiple words have the same frequency, returns them in lexicographical order. >>> top_k_frequent_words(8, 3, [\\"i\\", \\"love\\", \\"coding\\", \\"i\\", \\"love\\", \\"python\\"]) ['i', 'love', 'coding'] >>> top_k_frequent_words(1, 1, [\\"hello\\"]) ['hello'] >>> top_k_frequent_words(5, 2, [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"fig\\"]) ['apple', 'banana'] >>> top_k_frequent_words(6, 3, [\\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\", \\"apple\\", \\"apple\\"]) ['apple', 'banana', 'cherry'] >>> top_k_frequent_words(6, 3, [\\"banana\\", \\"apple\\", \\"cherry\\", \\"date\\", \\"banana\\", \\"cherry\\"]) ['banana', 'cherry', 'apple'] >>> top_k_frequent_words(7, 4, [\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"c\\", \\"c\\", \\"d\\"]) ['a', 'b', 'c', 'd'] >>> top_k_frequent_words(4, 2, [\\"b\\", \\"a\\", \\"c\\", \\"b\\"]) ['b', 'a']","solution":"from collections import Counter def top_k_frequent_words(n, k, words): Returns the k most frequent words from the given list. If multiple words have the same frequency, returns them in lexicographical order. word_count = Counter(words) sorted_words = sorted(word_count.keys(), key=lambda word: (-word_count[word], word)) return sorted_words[:k]"},{"question":"def is_subtree(tree1: str, tree2: str) -> str: Determines if \`tree2\` is a subtree of \`tree1\` based on their inorder traversal represented as strings. Args: tree1 (str): The inorder traversal of the first binary tree. tree2 (str): The inorder traversal of the second binary tree. Returns: str: \\"YES\\" if tree2 is a subtree of tree1, otherwise \\"NO\\". >>> is_subtree(\\"abcde\\", \\"bcd\\") \\"YES\\" >>> is_subtree(\\"xyzabc\\", \\"abcx\\") \\"NO\\"","solution":"def is_subtree(tree1, tree2): Determines if tree2 is a subtree of tree1 based on their inorder traversal represented as strings. Args: tree1 (str): The inorder traversal of the first binary tree. tree2 (str): The inorder traversal of the second binary tree. Returns: str: \\"YES\\" if tree2 is a subtree of tree1, otherwise \\"NO\\". if tree2 in tree1: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def find_pairs(N: int) -> List[Tuple[int, int]]: Returns the number of distinct pairs (a, b) such that a * b = N, and the pairs themselves in ascending order based on the value of a. >>> find_pairs(12) [(1, 12), (2, 6), (3, 4)] >>> find_pairs(25) [(1, 25), (5, 5)] pass def distinct_pairs(N: int) -> Tuple[int, List[Tuple[int, int]]]: Returns the number of distinct pairs (a, b) and the pairs themselves in ascending order based on the value of a for the given integer N. >>> distinct_pairs(12) (3, [(1, 12), (2, 6), (3, 4)]) >>> distinct_pairs(25) (2, [(1, 25), (5, 5)]) pass","solution":"def find_pairs(N): Returns the number of distinct pairs (a, b) such that a * b = N, and the pairs themselves in ascending order based on the value of a. pairs = [] for a in range(1, int(N**0.5) + 1): if N % a == 0: b = N // a pairs.append((a, b)) return pairs def distinct_pairs(N): pairs = find_pairs(N) M = len(pairs) return M, pairs"},{"question":"def determine_winner(x1: int, y1: int, x2: int, y2: int) -> str: Determine the winner of the game based on the initial positions of Jack and Jill. Parameters: x1, y1 (int, int): Initial coordinates of Jack. x2, y2 (int, int): Initial coordinates of Jill. Returns: str: \\"JACK\\", \\"JILL\\" or \\"DRAW\\" depending on who will win under optimal play. >>> determine_winner(0, 0, 1, 1) \\"JACK\\" >>> determine_winner(0, 0, 3, 3) \\"JILL\\"","solution":"def determine_winner(x1, y1, x2, y2): Determine the winner of the game based on the initial positions of Jack and Jill. Parameters: x1, y1 (int, int): Initial coordinates of Jack. x2, y2 (int, int): Initial coordinates of Jill. Returns: str: \\"JACK\\", \\"JILL\\" or \\"DRAW\\" depending on who will win under optimal play. # Calculate the Manhattan distance between Jack's and Jill's starting positions distance = abs(x1 - x2) + abs(y1 - y2) # If the distance between their positions is even, Jack wins. Otherwise, Jill wins. if distance % 2 == 0: return \\"JACK\\" else: return \\"JILL\\""},{"question":"def longest_consecutive_subsequence(numbers: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers. >>> longest_consecutive_subsequence([1, 9, 3, 10, 2, 20]) 3 >>> longest_consecutive_subsequence([6, 3, 5, 10, 4, 11]) 4","solution":"def longest_consecutive_subsequence(numbers): Returns the length of the longest subsequence of consecutive integers. numbers_set = set(numbers) longest_length = 0 for num in numbers: # Check if it's the start of a sequence if num - 1 not in numbers_set: current_num = num current_streak = 1 while current_num + 1 in numbers_set: current_num += 1 current_streak += 1 longest_length = max(longest_length, current_streak) return longest_length"},{"question":"def min_changes_to_distinct_elements(n, k, a): Returns the minimum number of changes needed to make the array \`a\` contain exactly \`k\` distinct elements or -1 if it is impossible. >>> min_changes_to_distinct_elements(4, 2, [1, 2, 2, 3]) == 0 >>> min_changes_to_distinct_elements(4, 3, [1, 1, 2, 2]) == 1 >>> min_changes_to_distinct_elements(4, 5, [1, 1, 1, 1]) == -1 >>> min_changes_to_distinct_elements(5, 3, [1, 1, 1, 2, 2]) == 1 >>> min_changes_to_distinct_elements(6, 2, [1, 2, 3, 4, 5, 6]) == 0 >>> min_changes_to_distinct_elements(5, 3, [7, 7, 7, 7, 8]) == 1 >>> min_changes_to_distinct_elements(1, 1, [5]) == 0 >>> min_changes_to_distinct_elements(4, 2, [4, 4, 4, 4]) == 1 >>> min_changes_to_distinct_elements(1, 1, [1]) == 0","solution":"def min_changes_to_distinct_elements(n, k, a): Returns the minimum number of changes needed to make the array \`a\` contain exactly \`k\` distinct elements or -1 if it is impossible. from collections import Counter unique_elements = set(a) if len(unique_elements) == k: return 0 if len(unique_elements) > k: return 0 if len(unique_elements) < k: if n >= k: return k - len(unique_elements) else: return -1 return -1"},{"question":"def maximum_possible_sum(n: int, a: List[int]) -> int: Moose the Mathematician has an array of integers a of length n. Moose can perform no more than n-1 (possibly zero) operations to maximize the value of the sum of the elements in the array after performing any number of operations (up to n-1). Args: n (int): The length of the array. a (List[int]): The elements of the array. Returns: int: The maximum possible sum Moose can obtain. >>> maximum_possible_sum(4, [1, 2, 3, 4]) 10 >>> maximum_possible_sum(1, [5]) 5 >>> maximum_possible_sum(2, [7, 3]) 10 >>> maximum_possible_sum(5, [-1, -2, -3, -4, -5]) -15 >>> maximum_possible_sum(3, [1000000000, -1000000000, 1000000000]) 1000000000 from typing import List def test_example_case(): assert maximum_possible_sum(4, [1, 2, 3, 4]) == 10 def test_single_element(): assert maximum_possible_sum(1, [5]) == 5 def test_two_elements(): assert maximum_possible_sum(2, [7, 3]) == 10 def test_negative_elements(): assert maximum_possible_sum(5, [-1, -2, -3, -4, -5]) == -15 def test_mixed_elements(): assert maximum_possible_sum(3, [1000000000, -1000000000, 1000000000]) == 1000000000 def test_large_sum(): n = 1000000 # large n a = [1] * n # array of 1's assert maximum_possible_sum(n, a) == 1000000","solution":"def maximum_possible_sum(n, a): Returns the maximum possible sum of the array elements after performing up to n-1 operations as described in the problem statement. return sum(a)"},{"question":"def max_flower_beds(n: int, flowers: List[int]) -> Tuple[int, List[int]]: The Smart Beaver and Beaverette have decided to plant a garden together. Beaverette loves having different types of flowers in the garden, but she's very particular about their arrangement. The garden will be represented as a sequence of flower beds, each containing a certain number of flowers. Beaverette wants the garden to be as diverse as possible, which means that no two adjacent flower beds should have the same number of flowers. The Smart Beaver needs your help to determine the maximum number of flower beds they can have while keeping Beaverette happy with no two adjacent flower beds having the same number of flowers. Args: n (int): The initial number of flower beds, 1 ≤ n ≤ 1000. flowers (List[int]): The number of flowers in each flower bed (0 ≤ fi ≤ 1000). Returns: Tuple[int, List[int]]: A tuple containing an integer m — the maximum number of flower beds that can be retained such that no two adjacent flower beds have the same number of flowers, and list of m integers representing the positions of the flower beds to be retained. Examples: >>> max_flower_beds(1, [0]) (1, [1]) >>> max_flower_beds(2, [1, 2]) (2, [1, 2]) >>> max_flower_beds(2, [2, 2]) (1, [1]) >>> max_flower_beds(5, [1, 2, 2, 3, 4]) (4, [1, 2, 4, 5]) >>> max_flower_beds(6, [4, 4, 4, 4, 4, 4]) (1, [1]) >>> max_flower_beds(7, [0, 1, 0, 1, 0, 1, 0]) (7, [1, 2, 3, 4, 5, 6, 7])","solution":"def max_flower_beds(n, flowers): if n == 1: return 1, [1] positions = [1] last_flower_count = flowers[0] for i in range(1, n): if flowers[i] != last_flower_count: positions.append(i+1) last_flower_count = flowers[i] return len(positions), positions"},{"question":"def findSingle(arr: List[int]) -> int: Returns the single integer in the array that does not appear twice. >>> findSingle([4, 1, 2, 1, 2]) 4 >>> findSingle([1]) 1 >>> findSingle([-1, -1, -2, -2, -3]) -3 >>> findSingle([1000000, 999999, 1000000]) 999999 >>> findSingle([5, -7, 5]) -7 >>> findSingle([10, 20, 20, 10, 30, 40, 40, 50, 50]) 30","solution":"def findSingle(arr): Returns the single integer in the array that does not appear twice. result = 0 for num in arr: result ^= num return result"},{"question":"from collections import defaultdict def max_gold(n: int, gold: List[int], edges: List[Tuple[int, int]]) -> int: Given a tree rooted at node 1, with each node containing an amount of gold, this function finds the maximum gold that can be collected starting from the root node. >>> max_gold(1, [10], []) == 10 >>> max_gold(2, [10, 5], [(1, 2)]) == 15 >>> max_gold(3, [10, 5, 7], [(1, 2), (1, 3)]) == 22 >>> max_gold(5, [2, 3, 5, 1, 4], [(1, 2), (1, 3), (2, 4), (2, 5)]) == 15 >>> max_gold(5, [10, 5, 7, 6, 8], [(1, 2), (2, 3), (2, 4), (4, 5)]) == 36","solution":"from collections import defaultdict def max_gold(n, gold, edges): # Create an adjacency list for the tree tree = defaultdict(list) for (u, v) in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): # Max gold we can collect starting from this node max_gold_from_here = gold[node - 1] for child in tree[node]: if child != parent: max_gold_from_here += dfs(child, node) return max_gold_from_here # Start DFS from the root node which is 1 result = dfs(1, -1) return result"},{"question":"def calculate_rental_cost(car_type: str, days: int, insurance: str) -> int: Calculate the total rental cost given the type of car, number of days, and chosen insurance package. Args: car_type (str): Type of car (\\"SUV\\", \\"sedan\\", \\"compact\\"). days (int): Number of rental days. insurance (str): Type of insurance package (\\"none\\", \\"basic\\", \\"premium\\", \\"deluxe\\"). Returns: int: Total rental cost. Raises: ValueError: If the car type or insurance type is invalid. Examples: >>> calculate_rental_cost(\\"SUV\\", 3, \\"premium\\") 180 >>> calculate_rental_cost(\\"sedan\\", 2, \\"basic\\") 70 >>> calculate_rental_cost(\\"compact\\", 1, \\"deluxe\\") 35 >>> calculate_rental_cost(\\"SUV\\", 5, \\"none\\") 250 # Test cases to validate the solution from solution import calculate_rental_cost def test_calculate_rental_cost_SUV_with_premium(): assert calculate_rental_cost(\\"SUV\\", 3, \\"premium\\") == 180 def test_calculate_rental_cost_sedan_with_basic(): assert calculate_rental_cost(\\"sedan\\", 2, \\"basic\\") == 70 def test_calculate_rental_cost_compact_with_deluxe(): assert calculate_rental_cost(\\"compact\\", 1, \\"deluxe\\") == 35 def test_calculate_rental_cost_SUV_with_none(): assert calculate_rental_cost(\\"SUV\\", 5, \\"none\\") == 250 def test_calculate_rental_cost_invalid_car_type(): try: calculate_rental_cost(\\"truck\\", 3, \\"premium\\") except ValueError as e: assert str(e) == \\"Invalid car type.\\" def test_calculate_rental_cost_invalid_insurance_type(): try: calculate_rental_cost(\\"sedan\\", 2, \\"full\\") except ValueError as e: assert str(e) == \\"Invalid insurance type.\\"","solution":"def calculate_rental_cost(car_type, days, insurance): Calculate the total rental cost given the type of car, number of days, and chosen insurance package. Parameters: car_type (str): Type of car (\\"SUV\\", \\"sedan\\", \\"compact\\"). days (int): Number of rental days. insurance (str): Type of insurance package (\\"none\\", \\"basic\\", \\"premium\\", \\"deluxe\\"). Returns: int: Total rental cost. car_prices = { \\"SUV\\": 50, \\"sedan\\": 30, \\"compact\\": 20 } insurance_prices = { \\"none\\": 0, \\"basic\\": 5, \\"premium\\": 10, \\"deluxe\\": 15 } if car_type not in car_prices: raise ValueError(\\"Invalid car type.\\") if insurance not in insurance_prices: raise ValueError(\\"Invalid insurance type.\\") car_cost = car_prices[car_type] * days insurance_cost = insurance_prices[insurance] * days total_cost = car_cost + insurance_cost return total_cost"},{"question":"def find_products_needing_restocks(n: int, products: List[Tuple[str, int]], threshold: int) -> List[str]: Identifies products that need restocking. Args: n : int Number of products listed products : list of tuples Each tuple contains a string (product ID) and an integer (current stock quantity) threshold : int The restocking threshold Returns: list of strings List of product IDs that need restocking # Write your code here # Example usage # products = [(\\"A123\\", 50), (\\"B456\\", 20), (\\"C789\\", 100), (\\"D012\\", 5), (\\"E345\\", 120)] # print(find_products_needing_restocks(5, products, 30)) # Output: [\\"B456\\", \\"D012\\"]","solution":"def find_products_needing_restocks(n, products, threshold): Identifies products that need restocking. Args: n : int Number of products listed products : list of tuples Each tuple contains a string (product ID) and an integer (current stock quantity) threshold : int The restocking threshold Returns: list of strings List of product IDs that need restocking restock_list = [] for product_id, quantity in products: if quantity < threshold: restock_list.append(product_id) if restock_list: return restock_list else: return [\\"All products are sufficiently stocked\\"]"},{"question":"def min_deletions_to_avoid_adjacent_duplicates(s: str) -> int: Calculate the minimum number of deletions required to create a string where no two adjacent characters are the same. >>> min_deletions_to_avoid_adjacent_duplicates(\\"aab\\") == 1 True >>> min_deletions_to_avoid_adjacent_duplicates(\\"aaaa\\") == 3 True >>> min_deletions_to_avoid_adjacent_duplicates(\\"ababa\\") == 0 True >>> min_deletions_to_avoid_adjacent_duplicates(\\"abcdee\\") == 1 True","solution":"def min_deletions_to_avoid_adjacent_duplicates(s): Calculate the minimum number of deletions required to create a string where no two adjacent characters are the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def is_domino_fillable(n, m, grid: List[str]) -> str: Determine if a grid is domino-fillable. >>> is_domino_fillable(3, 3, [\\"++-\\", \\"+--\\", \\"+++\\"]) \\"NO\\" >>> is_domino_fillable(2, 2, [\\"++\\", \\"--\\"]) \\"YES\\" >>> is_domino_fillable(4, 4, [\\"++++\\", \\"++++\\", \\"++++\\", \\"++++\\"]) \\"YES\\" >>> is_domino_fillable(2, 2, [\\"+-\\", \\"-+\\"]) \\"NO\\" >>> is_domino_fillable(3, 3, [\\"+--\\", \\"+--\\", \\"+--\\"]) \\"NO\\" >>> is_domino_fillable(1, 2, [\\"++\\"]) \\"YES\\" pass from pytest import approx, raises def test_is_domino_fillable_case_1(): assert is_domino_fillable(3, 3, [\\"++-\\", \\"+--\\", \\"+++\\"]) == \\"NO\\" def test_is_domino_fillable_case_2(): assert is_domino_fillable(2, 2, [\\"++\\", \\"--\\"]) == \\"YES\\" def test_is_domino_fillable_case_3(): assert is_domino_fillable(4, 4, [\\"++++\\", \\"++++\\", \\"++++\\", \\"++++\\"]) == \\"YES\\" def test_is_domino_fillable_case_4(): assert is_domino_fillable(2, 2, [\\"+-\\", \\"-+\\"]) == \\"NO\\" def test_is_domino_fillable_case_5(): assert is_domino_fillable(3, 3, [\\"+--\\", \\"+--\\", \\"+--\\"]) == \\"NO\\" def test_is_domino_fillable_case_6(): assert is_domino_fillable(1, 2, [\\"++\\"]) == \\"YES\\" def process_input(T, cases): results = [] for case in cases: n, m = case[0] grid = case[1] results.append(is_domino_fillable(n, m, grid)) return results def test_process_input(): T = 3 cases = [ ((3, 3), [\\"++-\\", \\"+--\\", \\"+++\\"]), ((2, 2), [\\"++\\", \\"--\\"]), ((4, 4), [\\"++++\\", \\"++++\\", \\"++++\\", \\"++++\\"]) ] assert process_input(T, cases) == [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def is_domino_fillable(n, m, grid): plus_cells = sum(row.count('+') for row in grid) if plus_cells % 2 != 0: return \\"NO\\" visited = [[False] * m for _ in range(n)] def can_place_domino(x, y): if x + 1 < n and not visited[x][y] and not visited[x + 1][y] and grid[x][y] == grid[x + 1][y] == '+': return True if y + 1 < m and not visited[x][y] and not visited[x][y + 1] and grid[x][y] == grid[x][y + 1] == '+': return True return False def place_domino(x, y): if x + 1 < n and not visited[x][y] and not visited[x + 1][y] and grid[x][y] == grid[x + 1][y] == '+': visited[x][y] = visited[x + 1][y] = True return True if y + 1 < m and not visited[x][y] and not visited[x][y + 1] and grid[x][y] == grid[x][y + 1] == '+': visited[x][y] = visited[x][y + 1] = True return True return False for i in range(n): for j in range(m): if grid[i][j] == '+' and not visited[i][j]: if not place_domino(i, j): return \\"NO\\" return \\"YES\\" def process_input(T, cases): results = [] for case in cases: n, m = case[0] grid = case[1] results.append(is_domino_fillable(n, m, grid)) return results"},{"question":"def maximize_productivity(n: int, k: int, x: int, productivities: List[int]) -> int: Calculate the maximum possible total productivity after optimally applying the boosting rule. :param n: Number of days :param k: Maximum number of times the boost can be applied :param x: Increase in productivity per boost :param productivities: List of productivity values for each day :return: Maximum possible total productivity >>> maximize_productivity(5, 3, 10, [3, 8, 5, 7, 4]) 57 >>> maximize_productivity(1, 1, 5, [2]) 7 >>> maximize_productivity(3, 0, 10, [1, 2, 3]) 6 >>> maximize_productivity(3, 3, 2, [1, 1, 1]) 9 >>> maximize_productivity(1, 10**9, 10**9, [1]) 1000000000000000001 >>> maximize_productivity(10**5, 10**5, 10, [1] * 10**5) 2000000","solution":"def maximize_productivity(n, k, x, productivities): Calculate the maximum possible total productivity after optimally applying the boosting rule. :param n: Number of days :param k: Maximum number of times the boost can be applied :param x: Increase in productivity per boost :param productivities: List of productivity values for each day :return: Maximum possible total productivity # Find the maximum productivity value to target for boosting max_productivity = max(productivities) # Calculate the number of boosts we can apply to this maximum productivity total_boost = min(k, n * (x // 1)) # Calculate the additional productivity that can be gained from boosting additional_productivity = total_boost * x # Calculate the total productivity total_productivity = sum(productivities) + additional_productivity return total_productivity"},{"question":"from typing import List def find_transfer_station(n: int, m: int, routes: List[List[int]]) -> str: Determine if there is a bus stop present in at least 3 different bus routes. Parameters: n (int): Number of bus routes. m (int): Number of bus stops. routes (list of lists): List of bus routes, where each route is represented as a list of bus stops. Returns: str: \\"YES\\" followed by the bus stop number if such a bus stop exists, otherwise \\"NO\\". Examples: >>> find_transfer_station(4, 10, [[1, 2, 3, 4, 5, 6], [3, 7, 8], [2, 3, 8, 9, 10], [1, 7, 8, 4]]) 'YES 8' >>> find_transfer_station(3, 6, [[1, 2, 3, 4], [3, 5, 6], [2, 3]]) 'YES 3' >>> find_transfer_station(3, 3, [[1], [2], [3]]) 'NO'","solution":"def find_transfer_station(n, m, routes): Determine if there is a bus stop present in at least 3 different bus routes. Parameters: n (int): Number of bus routes. m (int): Number of bus stops. routes (list of lists): List of bus routes, where each route is represented as a list of bus stops. Returns: str: \\"YES\\" followed by the bus stop number if such a bus stop exists, otherwise \\"NO\\". from collections import defaultdict stop_count = defaultdict(int) for route in routes: unique_stops = set(route) # To count only unique stops per route for stop in unique_stops: stop_count[stop] += 1 for stop, count in stop_count.items(): if count >= 3: return f\\"YES {stop}\\" return \\"NO\\" # Example n, m = 4, 10 routes = [ [1, 2, 3, 4, 5, 6], [3, 7, 8], [2, 3, 8, 9, 10], [1, 7, 8, 4] ] print(find_transfer_station(n, m, routes))"},{"question":"def longest_repeating_substring(n: int, k: int, s: str) -> int: Determine the length of the longest possible substring consisting of repeating identical characters that can be obtained using at most k operations. >>> longest_repeating_substring(8, 1, \\"aabbccdd\\") 3 >>> longest_repeating_substring(5, 1, \\"aaaaa\\") 5 >>> longest_repeating_substring(7, 0, \\"aaaabbb\\") 4 >>> longest_repeating_substring(5, 2, \\"abcde\\") 3 >>> longest_repeating_substring(5, 5, \\"abcde\\") 5 >>> longest_repeating_substring(4, 10, \\"abcd\\") 4 >>> longest_repeating_substring(5, 1, \\"aaaab\\") 5 >>> longest_repeating_substring(5, 1, \\"baaaa\\") 5 >>> longest_repeating_substring(1, 0, \\"a\\") 1 >>> longest_repeating_substring(2, 0, \\"ab\\") 1 >>> longest_repeating_substring(2, 1, \\"ab\\") 2","solution":"def longest_repeating_substring(n, k, s): def max_length_with_char(c): left = 0 count = 0 max_len = 0 for right in range(n): if s[right] != c: count += 1 while count > k: if s[left] != c: count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len return max(max_length_with_char(c) for c in set(s))"},{"question":"def trap_rainwater(heights): Computes the total amount of rainwater trapped between the buildings given their heights. :param heights: List of integers representing the height of buildings. :return: Total amount of rainwater trapped. pass # Unit tests def test_trap_rainwater_no_rainwater(): assert trap_rainwater([0, 0, 0, 0]) == 0 assert trap_rainwater([1, 2, 3, 4]) == 0 def test_trap_rainwater_basic_case(): assert trap_rainwater([0, 1, 0, 2, 1, 0]) == 1 assert trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_rainwater_edge_cases(): assert trap_rainwater([]) == 0 assert trap_rainwater([1]) == 0 assert trap_rainwater([1, 2]) == 0 def test_trap_rainwater_large_values(): assert trap_rainwater([0, 10, 0, 5, 0, 10, 0]) == 25 def test_trap_rainwater_complex_cases(): assert trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 assert trap_rainwater([5, 4, 1, 2]) == 1 assert trap_rainwater([9, 6, 8, 8, 5, 6, 3]) == 3","solution":"def trap_rainwater(heights): Computes the total amount of rainwater trapped between the buildings given their heights. :param heights: List of integers representing the height of buildings. :return: Total amount of rainwater trapped. if not heights or len(heights) < 3: return 0 n = len(heights) # Create two arrays to store the maximum height to the left and right of each building max_left = [0] * n max_right = [0] * n # Fill the max_left array max_left[0] = heights[0] for i in range(1, n): max_left[i] = max(max_left[i-1], heights[i]) # Fill the max_right array max_right[n-1] = heights[n-1] for i in range(n-2, -1, -1): max_right[i] = max(max_right[i+1], heights[i]) # Compute the total water trapped total_water = 0 for i in range(n): total_water += min(max_left[i], max_right[i]) - heights[i] return total_water"},{"question":"def minimum_largest_number_in_collection(numbers: List[int]) -> int: Determine the minimum possible value of the largest number in the collection where any two numbers co-prime with each other sum up to a composite number. >>> minimum_largest_number_in_collection([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]) 19 >>> minimum_largest_number_in_collection([19, 1, 3, 5, 7, 9, 11, 13, 15, 17]) 19 >>> minimum_largest_number_in_collection([2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) 20 >>> minimum_largest_number_in_collection([4, 6, 8, 9, 10, 12, 14, 15, 16, 18]) 18","solution":"def minimum_largest_number_in_collection(numbers): sorted_numbers = sorted(numbers) return sorted_numbers[-1] # Assuming the collection of first 10 distinct odd positive integers numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]"},{"question":"def max_gold_coins(n: int, m: int, grid: List[List[int]]) -> int: Stanley is playing a treasure hunting game on a grid with dimensions n x m. Each cell in the grid contains a number of gold coins. Stanley starts at the top-left corner (cell (1,1)) and wants to reach the bottom-right corner (cell (n, m)). He can move only to the right or down at each step and wants to maximize the number of gold coins collected along the path. Args: n (int): Number of rows. m (int): Number of columns. grid (List[List[int]]): 2D list representing the grid with gold coins. Returns: int: Maximum number of gold coins collected. Examples: >>> max_gold_coins(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1]]) 12 >>> max_gold_coins(1, 4, [ ... [1, 2, 3, 4]]) 10 >>> max_gold_coins(4, 1, [ ... [1], ... [2], ... [3], ... [4]]) 10 pass","solution":"def max_gold_coins(n, m, grid): # Create a 2D list to store the maximum coins collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the starting position dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the maximum coins collected return dp[n-1][m-1]"},{"question":"def max_product_subarray(nums): Returns the maximum product of a contiguous subarray. >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0 >>> max_product_subarray([-2, 3, -4]) 24 >>> max_product_subarray([2, -5, -2, -4, 3]) 24 >>> max_product_subarray([-4, -3, -2]) 12 >>> max_product_subarray([5]) 5 >>> max_product_subarray([0, -3, 1, 1]) 1 >>> max_product_subarray([-1, -2, -3, 0]) 6 >>> max_product_subarray([1, 2, 3, 4, 5]) 120 >>> max_product_subarray([-1, -3, 10, 0, 60]) 60","solution":"def max_product_subarray(nums): Returns the maximum product of a contiguous subarray. if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for i in range(1, len(nums)): current = nums[i] if current < 0: max_product, min_product = min_product, max_product max_product = max(current, max_product * current) min_product = min(current, min_product * current) result = max(result, max_product) return result"},{"question":"def max_subarray_sum(arr): Finds the sum of the contiguous subarray with the largest sum. Args: - arr: List of integers representing the array. Returns: - The maximum sum of the contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Finds the sum of the contiguous subarray with the largest sum. Args: - arr: List of integers representing the array. Returns: - The maximum sum of the contiguous subarray. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def has_zero_sum_subarray(arr): Write a function that takes an integer array and determines if there is a subarray (of at least one element) with a sum of zero. :param arr: List of integers :return: \\"YES\\" if there is a subarray with sum 0, otherwise \\"NO\\" >>> has_zero_sum_subarray([1, 2, -3, 3]) 'YES' >>> has_zero_sum_subarray([1, 2, 3, 4, 5]) 'NO' >>> has_zero_sum_subarray([1, 2, 3, -6]) 'YES' >>> has_zero_sum_subarray([-1, 1]) 'YES' >>> has_zero_sum_subarray([0]) 'YES'","solution":"def has_zero_sum_subarray(arr): Determines if there is a subarray with a sum of zero. :param arr: List of integers :return: \\"YES\\" if there is a subarray with sum 0, otherwise \\"NO\\" prefix_sum_set = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in prefix_sum_set: return \\"YES\\" prefix_sum_set.add(current_sum) return \\"NO\\""},{"question":"from typing import List, Tuple def find_matching_pairs(n: int, m: int, board: List[List[int]]) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]: Finds the sequence of flips that reveal all pairs with the minimum number of flips. Args: n (int): number of rows in the board m (int): number of columns in the board board (list of list of int): the grid representing the board with card IDs Returns: list of tuple of tuple of int: list of pairs of indices representing the flips pass # Unit tests def test_find_matching_pairs(): board1 = [ [1, 2], [1, 2] ] result1 = find_matching_pairs(2, 2, board1) expected1 = [((1, 1), (2, 1)), ((1, 2), (2, 2))] assert result1 == expected1 board2 = [ [1, 1], [2, 2] ] result2 = find_matching_pairs(2, 2, board2) expected2 = [((1, 1), (1, 2)), ((2, 1), (2, 2))] assert result2 == expected2 board3 = [ [1, 2, 1], [3, 2, 3] ] result3 = find_matching_pairs(2, 3, board3) expected3 = [((1, 1), (1, 3)), ((1, 2), (2, 2)), ((2, 1), (2, 3))] assert result3 == expected3 board4 = [ [4, 1, 1], [2, 2, 4] ] result4 = find_matching_pairs(2, 3, board4) expected4 = [((1, 1), (2, 3)), ((1, 2), (1, 3)), ((2, 1), (2, 2))] assert result4 == expected4 board5 = [ [5, 6, 5, 7], [6, 8, 7, 8] ] result5 = find_matching_pairs(2, 4, board5) expected5 = [((1, 1), (1, 3)), ((1, 2), (2, 1)), ((1, 4), (2, 3)), ((2, 2), (2, 4))] assert result5 == expected5","solution":"def find_matching_pairs(n, m, board): Finds the sequence of flips that reveal all pairs with the minimum number of flips. Args: n (int): number of rows in the board m (int): number of columns in the board board (list of list of int): the grid representing the board with card IDs Returns: list of tuple of tuple of int: list of pairs of indices representing the flips from collections import defaultdict # Create a dictionary to store the positions of each card ID card_positions = defaultdict(list) for i in range(n): for j in range(m): card_positions[board[i][j]].append((i+1, j+1)) # Prepare the list of flips flips = [] for positions in card_positions.values(): p1, p2 = positions flips.append((p1, p2)) return flips"},{"question":"def minimum_days_to_complete_tasks(n: int, k: int, d: int, difficulties: List[int]) -> int: Determines the minimum number of days required to complete all tasks, or returns -1 if impossible. >>> minimum_days_to_complete_tasks(5, 3, 10, [4, 4, 2, 7, 3]) 2 >>> minimum_days_to_complete_tasks(5, 2, 10, [8, 8, 8, 8, 8]) -1 >>> minimum_days_to_complete_tasks(3, 3, 5, [6, 3, 2]) -1 >>> minimum_days_to_complete_tasks(5, 1, 10**9, [1, 1, 1, 1, 1]) 1 >>> minimum_days_to_complete_tasks(4, 4, 10, [1, 1, 1, 1]) 1 >>> minimum_days_to_complete_tasks(3, 2, 10, [4, 4, 2, 7, 3]) 2 >>> minimum_days_to_complete_tasks(3, 2, 20, [5, 6, 8]) 1","solution":"def minimum_days_to_complete_tasks(n, k, d, difficulties): days_needed = 0 current_sum = 0 task_count = 0 for difficulty in difficulties: if difficulty > d: return -1 if current_sum + difficulty > d: days_needed += 1 current_sum = difficulty task_count = 1 else: current_sum += difficulty task_count += 1 if task_count > 0: days_needed += 1 return days_needed if days_needed <= k else -1"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Determine the area of the largest rectangle that can be formed in a histogram represented by heights. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([2, 1, 2]) 3 >>> largestRectangleArea([0, 1, 0, 1]) 1 >>> largestRectangleArea([2, 0, 2]) 2 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largestRectangleArea(heights): This function determines the area of the largest rectangle that can be formed in a histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def count_k_in_range(arr, queries): This function takes an array of integers and a list of queries, where each query consists of three integers l, r, and k. For each query, it determines the count of the value k within the range [l, r] in the array. Parameters: arr (list of int): List of integers representing the ancient scroll. queries (list of tuples): List of queries, where each query is a tuple (l, r, k). Returns: list of int: List containing the count of k for each query. Example: >>> arr = [1, 2, 1, 3, 4, 2, 1] >>> queries = [(1, 4, 1), (2, 5, 2), (3, 7, 1)] >>> count_k_in_range(arr, queries) [2, 1, 2] from solution import count_k_in_range def test_single_query(): arr = [1, 2, 1, 3, 4, 2, 1] queries = [(1, 4, 1)] assert count_k_in_range(arr, queries) == [2] def test_multiple_queries(): arr = [1, 2, 1, 3, 4, 2, 1] queries = [(1, 4, 1), (2, 5, 2), (3, 7, 1)] assert count_k_in_range(arr, queries) == [2, 1, 2] def test_all_same_elements(): arr = [2, 2, 2, 2, 2] queries = [(1, 5, 2), (2, 4, 2), (1, 3, 1)] assert count_k_in_range(arr, queries) == [5, 3, 0] def test_no_occurrences(): arr = [1, 2, 3, 4, 5] queries = [(1, 5, 6), (1, 3, 0)] assert count_k_in_range(arr, queries) == [0, 0] def test_boundary_values(): arr = [1, 100, 1, 100, 1] queries = [(1, 3, 1), (2, 4, 100), (1, 5, 1)] assert count_k_in_range(arr, queries) == [2, 2, 3]","solution":"def count_k_in_range(arr, queries): results = [] for l, r, k in queries: count = sum(1 for i in range(l-1, r) if arr[i] == k) results.append(count) return results # Example usage # n = 7 # arr = [1, 2, 1, 3, 4, 2, 1] # m = 3 # queries = [(1, 4, 1), (2, 5, 2), (3, 7, 1)] # print(count_k_in_range(arr, queries)) # Should output [2, 1, 2]"},{"question":"import math from typing import List def count_flower_arrangements(n: int) -> int: Returns the number of valid flower arrangements such that no two adjacent flowers are of the same type. >>> count_flower_arrangements(3) 6 >>> count_flower_arrangements(4) 24 >>> count_flower_arrangements(1) 1 pass # Implement your solution here # Unit tests def test_single_flower(): assert count_flower_arrangements(1) == 1 def test_two_flowers(): assert count_flower_arrangements(2) == 2 def test_three_flowers(): assert count_flower_arrangements(3) == 6 def test_four_flowers(): assert count_flower_arrangements(4) == 24 def test_five_flowers(): assert count_flower_arrangements(5) == 120 def test_twenty_flowers(): assert count_flower_arrangements(20) == math.factorial(20)","solution":"import math def count_flower_arrangements(n): Returns the number of valid flower arrangements such that no two adjacent flowers are of the same type. This is equivalent to finding the number of permutations of n unique items. if n == 1: return 1 return math.factorial(n)"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Determine the maximum value that can be obtained by selecting a subset of gemstones with a given weight limit. >>> knapsack(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90 >>> knapsack(4, 0, [(5, 10), (4, 40), (6, 30), (3, 50)]) 0 >>> knapsack(1, 10, [(5, 10)]) 10 >>> knapsack(4, 8, [(4, 10), (4, 20), (4, 30), (4, 40)]) 70 >>> knapsack(1000, 1000, [(1, 1)] * 1000) 1000","solution":"def knapsack(n, W, items): dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): wi, vi = items[i - 1] for w in range(W + 1): if wi <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - wi] + vi) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"def minimum_moves_to_unlock(n: int, initial: List[int], target: List[int]) -> int: Calculate the minimum number of moves required to unlock the tomb. Parameters: n (int): Number of discs. initial (list of int): Initial state of each disc. target (list of int): Target state of each disc. Returns: int: The minimum number of moves required. pass # Test cases def test_example_case(): n = 5 initial = [77, 45, 99, 23, 56] target = [78, 44, 0, 24, 55] assert minimum_moves_to_unlock(n, initial, target) == 5 def test_single_disc_forward(): n = 1 initial = [10] target = [20] assert minimum_moves_to_unlock(n, initial, target) == 10 def test_single_disc_backward(): n = 1 initial = [20] target = [10] assert minimum_moves_to_unlock(n, initial, target) == 10 def test_min_moves_wrap_around(): n = 1 initial = [1] target = [99] assert minimum_moves_to_unlock(n, initial, target) == 2 def test_zero_moves(): n = 3 initial = [50, 50, 50] target = [50, 50, 50] assert minimum_moves_to_unlock(n, initial, target) == 0","solution":"def minimum_moves_to_unlock(n, initial, target): Calculate the minimum number of moves required to unlock the tomb. Parameters: n (int): Number of discs. initial (list of int): Initial state of each disc. target (list of int): Target state of each disc. Returns: int: The minimum number of moves required. moves = 0 for i in range(n): forward_moves = (target[i] - initial[i]) % 100 backward_moves = (initial[i] - target[i]) % 100 moves += min(forward_moves, backward_moves) return moves"},{"question":"def count_connected_components(grid, n, m): Returns the number of connected components in the grid. A connected component is a group of non-blocked cells ('.') that are connected vertically or horizontally. # Implementation here # Test cases def test_example_case(): grid = [ \\"..*..\\", \\".*.*.\\", \\"..*..\\", \\".....\\" ] assert count_connected_components(grid, 4, 5) == 2 def test_single_component(): grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert count_connected_components(grid, 3, 3) == 1 def test_no_empty_cells(): grid = [ \\"***\\", \\"***\\", \\"***\\" ] assert count_connected_components(grid, 3, 3) == 0 def test_multiple_components(): grid = [ \\"..**\\", \\"**..\\", \\"..**\\", \\"**..\\" ] assert count_connected_components(grid, 4, 4) == 4 def test_edge_case_one_row(): grid = [ \\"*.*.\\" ] assert count_connected_components(grid, 1, 4) == 2 def test_edge_case_one_column(): grid = [ \\"*\\", \\".\\", \\"*\\", \\".\\" ] assert count_connected_components(grid, 4, 1) == 2","solution":"def count_connected_components(grid, n, m): Returns the number of connected components in the grid. A connected component is a group of non-blocked cells ('.') that are connected vertically or horizontally. def dfs(grid, visited, x, y, n, m): # Define movement directions: left, right, up, down directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True stack.append((nx, ny)) # Initialize visited matrix visited = [[False] * m for _ in range(n)] count = 0 # Traverse the grid to find all connected components for i in range(n): for j in range(m): if not visited[i][j] and grid[i][j] == '.': # Start a new DFS for each new component visited[i][j] = True dfs(grid, visited, i, j, n, m) count += 1 return count"},{"question":"from typing import List def min_moves(n: int, m: int, grid: List[List[str]]) -> int: Returns the minimum number of moves required for the robot to reach the bottom-right corner from the top-left corner on the given grid, or -1 if it is impossible. >>> min_moves(4, 4, [ ... \\". . . #\\".split(), ... \\"# # . .\\".split(), ... \\". . . #\\".split(), ... \\". # . .\\".split() ... ]) 6 >>> min_moves(4, 4, [ ... \\". # . .\\".split(), ... \\"# # . .\\".split(), ... \\". . # #\\".split(), ... \\". # . .\\".split() ... ]) -1 pass def test_min_moves_possible(): grid = [ \\". . . #\\".split(), \\"# # . .\\".split(), \\". . . #\\".split(), \\". # . .\\".split() ] assert min_moves(4, 4, grid) == 6 def test_min_moves_impossible(): grid = [ \\". # . .\\".split(), \\"# # . .\\".split(), \\". . # #\\".split(), \\". # . .\\".split() ] assert min_moves(4, 4, grid) == -1 def test_min_moves_one_by_one(): grid = [ \\".\\" ] assert min_moves(1, 1, grid) == 0 def test_min_moves_two_by_two(): grid = [ \\". #\\".split(), \\"# .\\".split() ] assert min_moves(2, 2, grid) == -1 def test_min_moves_large_grid(): grid = [ ['.'] * 10 for _ in range(10) ] assert min_moves(10, 10, grid) == 18 def test_min_moves_starting_blocked(): grid = [ \\"# . . .\\".split(), \\". . . .\\".split(), \\". . . .\\".split(), \\". . . .\\".split() ] assert min_moves(4, 4, grid) == -1 def test_min_moves_ending_blocked(): grid = [ \\". . . .\\".split(), \\". . . .\\".split(), \\". . . .\\".split(), \\". . . #\\".split() ] assert min_moves(4, 4, grid) == -1","solution":"from collections import deque def min_moves(n, m, grid): Returns the minimum number of moves required for the robot to reach the bottom-right corner from the top-left corner on the given grid, or -1 if it is impossible. if grid[0][0] == '#' or grid[n - 1][m - 1] == '#': return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # queue of (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == n - 1 and col == m - 1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited and grid[new_row][new_col] == '.': visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"def min_demolitions_to_beautiful_skyline(arr: List[int]) -> int: Returns the minimum number of buildings to be demolished to achieve a non-decreasing sequence. >>> min_demolitions_to_beautiful_skyline([1, 2, 4, 3, 2, 2]) 2 >>> min_demolitions_to_beautiful_skyline([1, 2, 3, 5, 4]) 1 >>> min_demolitions_to_beautiful_skyline([1, 2, 3, 4, 5]) 0 >>> min_demolitions_to_beautiful_skyline([5, 4, 3, 2, 1]) 4 >>> min_demolitions_to_beautiful_skyline([10, 20, 30, 25, 35, 40, 50]) 1 >>> min_demolitions_to_beautiful_skyline([2]) 0 >>> min_demolitions_to_beautiful_skyline([5, 3]) 1","solution":"def min_demolitions_to_beautiful_skyline(arr): Returns the minimum number of buildings to be demolished to achieve a non-decreasing sequence. n = len(arr) lis = [1] * n # Initialize LIS array with 1 # Compute the length of LIS ending at each index of \`arr\` for i in range(1, n): for j in range(0, i): if arr[i] >= arr[j]: lis[i] = max(lis[i], lis[j] + 1) # Get the length of the longest increasing subsequence max_lis_len = max(lis) # The minimum number of demolitions needed return n - max_lis_len"},{"question":"from typing import List, Tuple def least_cost_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Returns the least-cost path from vertex 1 to vertex n, or -1 if no such path exists. >>> least_cost_path(5, 6, [(1, 2, 0), (2, 3, 1), (3, 5, 0), (1, 4, 1), (4, 5, 0), (2, 5, 1)]) 1 >>> least_cost_path(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 0)]) 0 >>> least_cost_path(3, 2, [(1, 2, 1), (2, 3, 1)]) 2 >>> least_cost_path(2, 1, [(1, 2, 0)]) 0 >>> least_cost_path(4, 2, [(1, 2, 1), (3, 4, 1)]) -1 pass","solution":"from collections import deque, defaultdict def least_cost_path(n, m, edges): Returns the least-cost path from vertex 1 to vertex n, or -1 if no such path exists. graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Use a deque for BFS. Elements are tuples (node, cost) queue = deque([(1, 0)]) visited = [False] * (n + 1) visited[1] = True while queue: node, cost = queue.popleft() if node == n: return cost for neighbor, weight in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, cost + weight)) return -1"},{"question":"def calculate_processing_time(t: int, test_cases: List[dict]) -> List[int]: Calculate the total time the server spends processing all the tasks considering the given rules. >>> t = 2 >>> test_cases = [ ... {'n': 3, 'tasks': [(1, 5, 2), (2, 6, 3), (4, 8, 1)]}, ... {'n': 2, 'tasks': [(1, 3, 2), (2, 5, 2)]} ... ] >>> calculate_processing_time(t, test_cases) [7, 4] >>> t = 1 >>> test_cases = [{'n': 1, 'tasks': [(1, 3, 1)]}] >>> calculate_processing_time(t, test_cases) [2] >>> t = 1 >>> test_cases = [{'n': 3, 'tasks': [(1, 3, 1), (4, 6, 2), (7, 8, 3)]}] >>> calculate_processing_time(t, test_cases) [5] >>> t = 1 >>> test_cases = [{'n': 3, 'tasks': [(1, 5, 1), (2, 6, 1), (3, 7, 1)]}] >>> calculate_processing_time(t, test_cases) [6] >>> t = 1 >>> test_cases = [{'n': 3, 'tasks': [(1, 5, 1), (2, 6, 2), (3, 7, 3)]}] >>> calculate_processing_time(t, test_cases) [6] >>> t = 1 >>> test_cases = [{'n': 4, 'tasks': [(1, 5, 1), (2, 6, 3), (3, 9, 2), (7, 10, 4)]}] >>> calculate_processing_time(t, test_cases) [9]","solution":"def calculate_processing_time(t, test_cases): Calculate the total time the server spends processing all the tasks considering the given rules. results = [] for case in test_cases: n = case['n'] tasks = case['tasks'] # Flatten the tasks information into a list of events events = [] for i in range(n): start, end, priority = tasks[i] events.append((start, True, priority, i)) # Start event events.append((end, False, priority, i)) # End event # Sort events: # 1. By time # 2. By type (end before start if same time) # 3. By priority (highest priority first for start events, lowest priority first for end events) events.sort(key=lambda x: (x[0], not x[1], -x[2] if x[1] else x[2], x[3])) current_active = None active_task_indices = set() last_time = 0 total_time = 0 for time, is_start, priority, index in events: if current_active is not None: total_time += time - last_time if is_start: active_task_indices.add((priority, index)) else: active_task_indices.remove((priority, index)) if active_task_indices: current_active = max(active_task_indices) # Highest priority task else: current_active = None last_time = time results.append(total_time) return results"},{"question":"def count_connected_components(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Given an undirected graph, determine the number of connected components in the graph. A connected component is a maximal set of vertices such that there is a path between any two vertices in this set. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases, each containing: - an integer ni: the number of vertices in the graph. - an integer mi: the number of edges in the graph. - a list of mi edges, where each edge is represented by a tuple of two integers u and v. Returns: List[int]: A list of integers representing the number of connected components for each test case. Example: >>> count_connected_components(2, [(5, 3, [(1, 2), (2, 3), (4, 5)]), (4, 2, [(1, 2), (3, 4)])]) [2, 2]","solution":"def dfs(node, graph, visited): Depth-First Search (DFS) to traverse the graph and mark all nodes in the same connected component. stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) def count_connected_components(t, test_cases): results = [] for n, m, edges in test_cases: # Initialize adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) # Array to keep track of visited nodes visited = [False] * (n + 1) connected_components = 0 for node in range(1, n + 1): if not visited[node]: visited[node] = True dfs(node, graph, visited) connected_components += 1 results.append(connected_components) return results"},{"question":"import random from typing import List def simulate_dice_rolls(q: int, queries: List[int]) -> List[List[int]]: Simulates the roll of two fair dice and returns the sum of the results for a given number of queries. Args: q (int): The number of queries. queries (List[int]): A list of integers specifying the number of dice rolls for each query. Returns: List[List[int]]: A list of lists, where each inner list contains the sequence of sums of dice rolls for each query. >>> simulate_dice_rolls(2, [3, 5]) [[8, 6, 7], [9, 5, 7, 11, 9]] >>> simulate_dice_rolls(1, [4]) [[5, 9, 11, 8]]","solution":"import random def simulate_dice_rolls(q, queries): random.seed(1337) results = [] for n in queries: roll_sums = [random.randint(1, 6) + random.randint(1, 6) for _ in range(n)] results.append(roll_sums) return results"},{"question":"def can_label_nodes(n: int, k: int, edges: List[Tuple[int, int]]) -> str: Determine if the nodes of the graph can be labeled with distinct integers from 1 to n such that for every edge (u, v), the absolute difference between the labels of u and v is at most k. >>> can_label_nodes(3, 2, [(1, 2), (2, 3)]) 'YES' >>> can_label_nodes(4, 1, [(1, 2), (2, 3), (3, 4)]) 'NO'","solution":"def can_label_nodes(n, k, edges): from collections import defaultdict import heapq def bfs(start): queue = [(0, start)] # (distance, node) distances = dict() while queue: cur_dist, node = heapq.heappop(queue) if node not in distances: distances[node] = cur_dist for neighbor in graph[node]: if neighbor not in distances: heapq.heappush(queue, (cur_dist + 1, neighbor)) return distances graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # We can run bfs from any node, let's start from node 1 distances_from_first = bfs(1) # Get the maximum distance from this BFS max_distance = max(distances_from_first.values()) # Check if the maximum distance is manageable with the given \`k\` if max_distance <= k: return \\"YES\\" return \\"NO\\""},{"question":"def find_integer(n: int, k: int, m: int) -> str: Find the smallest integer of length n, with digits between 1 and k, which is divisible by m. Returns the integer as a string or \\"-1\\" if no such integer exists. >>> find_integer(2, 3, 3) \\"12\\" >>> find_integer(1, 9, 5) \\"5\\" >>> find_integer(1, 1, 1) \\"1\\" >>> find_integer(4, 9, 1001) \\"-1\\" >>> find_integer(2, 3, 5) \\"-1\\" >>> find_integer(3, 4, 8) \\"112\\"","solution":"def find_integer(n, k, m): Finds the smallest integer of length n, with digits between 1 and k, which is divisible by m. Returns the integer as a string or \\"-1\\" if no such integer exists. if m > int('9' * n): return \\"-1\\" start = 10**(n-1) end = 10**n - 1 for num in range(start, end+1): num_str = str(num) if all(1 <= int(d) <= k for d in num_str) and num % m == 0: return num_str return \\"-1\\""},{"question":"def find_subarray_with_sum(n: int, k: int, m: int, arr: List[int], queries: List[int]) -> List[str]: For each query, decide if there exists a subarray of length \`k\` with a sum exactly equal to the number provided in the query. >>> find_subarray_with_sum(5, 3, 3, [1, 2, 3, 4, 5], [6,10,9]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> find_subarray_with_sum(5, 3, 2, [1, 2, 3, 4, 5], [15,16]) [\\"NO\\", \\"NO\\"]","solution":"def find_subarray_with_sum(n, k, m, arr, queries): result = [] for query in queries: found = False current_sum = sum(arr[:k]) if current_sum == query: result.append(\\"YES\\") continue for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum == query: found = True break if found: result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"from collections import defaultdict import bisect class AutoComplete: A class to simulate an auto-complete feature for a dynamic dictionary of words. Methods: - add(word): Adds a word to the dictionary. - delete(word): Deletes a word from the dictionary. - find(prefix, k): Returns the top k suggestions of words that start with the given prefix. Examples: >>> auto_complete = AutoComplete() >>> auto_complete.add(\\"apple\\") >>> auto_complete.add(\\"app\\") >>> auto_complete.find(\\"app\\", 2) ['app', 'apple'] >>> auto_complete.delete(\\"app\\") >>> auto_complete.find(\\"app\\", 2) ['apple'] >>> auto_complete.find(\\"banana\\", 2) ['-1'] >>> auto_complete.add(\\"app\\") >>> auto_complete.add(\\"apple\\") >>> auto_complete.add(\\"application\\") >>> auto_complete.find(\\"app\\", 5) ['app', 'apple', 'application'] >>> auto_complete.delete(\\"banana\\") >>> auto_complete.find(\\"app\\", 2) ['apple']","solution":"from collections import defaultdict import bisect class AutoComplete: def __init__(self): self.words = defaultdict(set) def add(self, word): for i in range(1, len(word) + 1): prefix = word[:i] self.words[prefix].add(word) self.words[''].add(word) def delete(self, word): for i in range(1, len(word) + 1): prefix = word[:i] if word in self.words[prefix]: self.words[prefix].remove(word) if word in self.words['']: self.words[''].remove(word) def find(self, prefix, k): if prefix in self.words: suggestions = sorted(self.words[prefix]) return suggestions[:k] if suggestions else [\\"-1\\"] else: return [\\"-1\\"] # Example of how the class works auto_complete = AutoComplete() auto_complete.add(\\"apple\\") auto_complete.add(\\"app\\") print(auto_complete.find(\\"app\\", 2)) # Output: ['app', 'apple'] auto_complete.delete(\\"app\\") print(auto_complete.find(\\"app\\", 2)) # Output: ['apple']"},{"question":"from typing import List def transform_array(n: int, m: int, array: List[int], operations: List[str]) -> List[int]: Transform the given array by performing the specified operations in order to obtain the lexicographically smallest array. >>> transform_array(5, 3, [3, 8, 7, 9, 2], [\\"LEFT_ROTATE\\", \\"XOR 3\\", \\"LEFT_ROTATE\\"]) [0, 5, 12, 0, 10] >>> transform_array(4, 2, [8, 6, 5, 7], [\\"XOR 2\\", \\"LEFT_ROTATE\\"]) [3, 0, 1, 4] # Unit Tests def test_case_1(): assert transform_array(5, 3, [3, 8, 7, 9, 2], [\\"LEFT_ROTATE\\", \\"XOR 3\\", \\"LEFT_ROTATE\\"]) == [0, 5, 12, 0, 10] def test_case_2(): assert transform_array(4, 2, [8, 6, 5, 7], [\\"XOR 2\\", \\"LEFT_ROTATE\\"]) == [3, 0, 1, 4] def test_case_3(): assert transform_array(1, 2, [3], [\\"XOR 1\\", \\"LEFT_ROTATE\\"]) == [2] def test_case_4(): assert transform_array(3, 0, [5, 1, 3], []) == [5, 1, 3] def test_case_5(): assert transform_array(6, 1, [1, 2, 3, 4, 5, 6], [\\"XOR 2\\"]) == [3, 0, 1, 6, 7, 4]","solution":"def transform_array(n, m, array, operations): def left_rotate(arr): return arr[1:] + [arr[0]] def xor_update(arr, k): return [x ^ k for x in arr] for operation in operations: if operation == \\"LEFT_ROTATE\\": array = left_rotate(array) elif operation.startswith(\\"XOR\\"): _, k = operation.split() k = int(k) array = xor_update(array, k) return array # Sample input reading if __name__ == \\"__main__\\": n, m = map(int, input().strip().split()) array = list(map(int, input().strip().split())) operations = [] for _ in range(m): operations.append(input().strip()) transformed_array = transform_array(n, m, array, operations) print(\\" \\".join(map(str, transformed_array)))"},{"question":"def largest_rectangle_area(heights): Calculate the largest rectangular area in a histogram with given heights. heights: List of integers representing the heights of buildings Return: Integer, the largest rectangular area possible with the given buildings >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 5, 3]) == 12 >>> largest_rectangle_area([6]) == 6 >>> largest_rectangle_area([4, 4, 4, 4]) == 16 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10]) == 18 >>> largest_rectangle_area([2, 1, 2, 1, 2]) == 5 >>> largest_rectangle_area([]) == 0","solution":"def largest_rectangle_area(heights): Calculate the largest rectangular area in a histogram with given heights. heights: List of integers representing the heights of buildings Return: Integer, the largest rectangular area possible with the given buildings stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def calculate_ranks(n, scores): Determine the ranks of contestants based on their scores. :param n: Number of contestants :param scores: List of scores for each contestant :return: List of ranks for each contestant from solution import calculate_ranks def test_simple_case(): assert calculate_ranks(5, [100, 50, 50, 25, 10]) == [1, 2, 2, 4, 5] def test_all_unique_scores(): assert calculate_ranks(4, [70, 50, 30, 10]) == [1, 2, 3, 4] def test_all_same_scores(): assert calculate_ranks(3, [50, 50, 50]) == [1, 1, 1] def test_mixed_scores(): assert calculate_ranks(6, [100, -20, 50, 50, 15, 100]) == [1, 6, 3, 3, 5, 1] def test_single_contestant(): assert calculate_ranks(1, [10]) == [1] def test_large_scores(): assert calculate_ranks(5, [100000, 99999, 99999, -100000, 0]) == [1, 2, 2, 5, 4] def test_zero_scores(): assert calculate_ranks(4, [0, 0, 0, 0]) == [1, 1, 1, 1]","solution":"def calculate_ranks(n, scores): Function to determine the ranks of contestants based on their scores. :param n: Number of contestants :param scores: List of scores for each contestant :return: List of ranks for each contestant # Create a list of tuples (score, index) indexed_scores = [(score, index) for index, score in enumerate(scores)] # Sort the scores in descending order but keep track of the original indices indexed_scores.sort(reverse=True, key=lambda x: x[0]) # Create an array for the ranks ranks = [0] * n # Initialize the first rank and previous score current_rank = 1 previous_score = indexed_scores[0][0] ranks[indexed_scores[0][1]] = current_rank for i in range(1, n): score, original_index = indexed_scores[i] if score == previous_score: # If the score is the same as the previous score, assign the same rank ranks[original_index] = current_rank else: # Otherwise, update the rank current_rank = i + 1 ranks[original_index] = current_rank previous_score = score return ranks"},{"question":"from typing import List def maxRob(n: int, money: List[int]) -> int: There are n houses situated on a street in a row. Each house has a certain amount of money hidden inside it, represented by an integer array \`money\` where \`money[i]\` is the amount of money present in the i-th house. A professional thief is planning to rob the houses, but he can never rob two consecutive houses as it would trigger the alarm system. The thief wants to maximize the total amount of money he can rob. Given the array \`money\`, write a function \`maxRob\` that returns the maximum amount of money the thief can rob without robbing two consecutive houses. >>> maxRob(6, [2, 7, 9, 3, 1, 4]) 15 >>> maxRob(5, [10, 1, 2, 10, 5]) 20 >>> maxRob(1, [5]) 5 >>> maxRob(2, [4, 3]) 4 >>> maxRob(4, [5, 5, 5, 5]) 10 >>> maxRob(100000, [1] * 100000) 50000 pass","solution":"from typing import List def maxRob(n: int, money: List[int]) -> int: if n == 0: return 0 if n == 1: return money[0] dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[n-1]"},{"question":"def can_form_palindrome(s: str) -> str: Given a string s, determine if it is possible to rearrange it to form a palindromic string. If possible, return one such palindromic string; otherwise, return \\"No\\". >>> can_form_palindrome('aaabb') in [\\"ababa\\", \\"baaab\\"] True >>> can_form_palindrome('abc') == \\"No\\" True >>> can_form_palindrome('aaaa') == \\"aaaa\\" True >>> can_form_palindrome('a') == \\"a\\" True >>> can_form_palindrome('aabb') in [\\"abba\\", \\"baab\\"] True","solution":"from collections import Counter def can_form_palindrome(s): Given a string s, determine if it is possible to rearrange it to form a palindromic string. If possible, return one such palindromic string; otherwise, return \\"No\\". freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) if odd_count > 1: return \\"No\\" # Create half of the palindrome half_palindrome = [] middle_char = '' for char, count in freq.items(): if count % 2 != 0: middle_char = char half_palindrome.append(char * (count // 2)) half_pal_str = ''.join(half_palindrome) reverse_half_pal_str = half_pal_str[::-1] return half_pal_str + middle_char + reverse_half_pal_str"},{"question":"def maxSubarraySumWithRemoval(arr): Finds the maximum sum of contiguous subarray with at most one removal. >>> maxSubarraySumWithRemoval([1, -2, 0, 3, -2, 3, 4, -5]) 10 >>> maxSubarraySumWithRemoval([1, -2, -2, 3, 4]) 7","solution":"def maxSubarraySumWithRemoval(arr): n = len(arr) if n == 1: return arr[0] # Forward pass: max subarray sum ending at each position max_end_here = [0] * n max_end_here[0] = arr[0] for i in range(1, n): max_end_here[i] = max(arr[i], max_end_here[i - 1] + arr[i]) # Backward pass: max subarray sum starting at each position max_start_here = [0] * n max_start_here[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): max_start_here[i] = max(arr[i], max_start_here[i + 1] + arr[i]) max_subarray_sum = max(max_end_here) # Normal max subarray sum without any removal for i in range(1, n - 1): # Consider removing arr[i] max_subarray_sum = max(max_subarray_sum, max_end_here[i - 1] + max_start_here[i + 1]) return max_subarray_sum"},{"question":"def min_clips_to_cover_event(n: int, T: int, clips: List[Tuple[int, int]]) -> int: Determine the minimum number of video clips required to cover the event from 0 to T. If it is not possible to cover the entire event from 0 to T, return -1. Args: n (int): The number of video clips. T (int): The total duration of the event to be covered. clips (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end times of a video clip. Returns: int: The minimum number of video clips required to cover the entire event from 0 to T, or -1 if it is not possible. Examples: >>> min_clips_to_cover_event(3, 10, [(0, 5), (5, 10), (1, 6)]) 2 >>> min_clips_to_cover_event(3, 10, [(0, 1), (6, 10), (1, 5)]) -1","solution":"def min_clips_to_cover_event(n, T, clips): # Sort clips by start time and then by end time in descending order clips.sort(key=lambda x: (x[0], -x[1])) max_end = 0 count = 0 i = 0 while max_end < T: # Find the clip with the furthest end time that starts at or before max_end new_end = max_end while i < n and clips[i][0] <= max_end: new_end = max(new_end, clips[i][1]) i += 1 # If we couldn't extend, then it's not possible to cover the event if new_end == max_end: return -1 # Use the selected clip and update the max_end max_end = new_end count += 1 return count"},{"question":"def max_profit(prices: List[int]) -> int: Given the daily prices of the stocks, identify the maximum profit that can be achieved by buying one share of a stock on one day and selling it on another day in the future. Return 0 if no profit can be achieved. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([]) == 0 >>> max_profit([10]) == 0 >>> max_profit([9, 8, 7, 6, 5]) == 0 >>> max_profit([5, 5, 5, 5]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) == 4 # Your code here","solution":"from typing import List def max_profit(prices: List[int]) -> int: # Initialize the minimum price to a very large value min_price = float('inf') # Initialize maximum profit to 0 max_profit = 0 # Iterate through the list of prices for price in prices: # Update the minimum price if current price is lower if price < min_price: min_price = price # Calculate the profit if we sell at current price profit = price - min_price # Update the maximum profit if the current profit is higher if profit > max_profit: max_profit = profit # Return the maximum profit found, 0 if no profit is possible return max_profit"},{"question":"def traffic_light_duration(N: int, W: List[int], R: List[int]) -> List[int]: Calculate the duration of the green light needed for each lane. Parameters: N (int): The number of lanes W (list of int): The number of cars waiting in each lane R (list of int): The rate at which cars can pass through the intersection for each lane Returns: list of int: The minimum duration of the green light needed for each lane in seconds pass def test_example(): assert traffic_light_duration(3, [10, 20, 30], [2, 5, 10]) == [5, 4, 3] def test_single_lane(): assert traffic_light_duration(1, [15], [3]) == [5] assert traffic_light_duration(1, [500000000], [1]) == [500000000] def test_no_waiting_cars(): assert traffic_light_duration(3, [0, 0, 0], [1, 2, 3]) == [0, 0, 0] def test_high_rate(): assert traffic_light_duration(2, [1, 2], [1000000000, 1000000000]) == [1, 1] def test_high_waiting_cars(): assert traffic_light_duration(2, [1000000000, 500000000], [1, 5]) == [1000000000, 100000000]","solution":"def traffic_light_duration(N, W, R): Calculate the duration of the green light needed for each lane. Parameters: N (int): The number of lanes W (list of int): The number of cars waiting in each lane R (list of int): The rate at which cars can pass through the intersection for each lane Returns: list of int: The minimum duration of the green light needed for each lane in seconds return [(W[i] + R[i] - 1) // R[i] for i in range(N)]"},{"question":"def maxGridSum(grid, n, m): Returns the maximum sum of integers collected starting from [0,0] to [n-1,m-1] in the grid. You can only move either right or down at any point in time. # Sample Input grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] n = 3 m = 3 # Expected Output print(maxGridSum(grid, n, m)) # Output should be 12 def test_maxGridSum(): grid1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] n1 = 3 m1 = 3 assert maxGridSum(grid1, n1, m1) == 12 grid2 = [ [1, 2, 5], [3, 2, 1] ] n2 = 2 m2 = 3 assert maxGridSum(grid2, n2, m2) == 9 grid3 = [ [1] ] n3 = 1 m3 = 1 assert maxGridSum(grid3, n3, m3) == 1 grid4 = [ [5, 3], [1, 4] ] n4 = 2 m4 = 2 assert maxGridSum(grid4, n4, m4) == 12 grid5 = [ [3, 7, 9, 2, 7], [9, 8, 3, 5, 5], [1, 7, 9, 8, 5], [3, 8, 6, 4, 10], [6, 3, 9, 7, 8] ] n5 = 5 m5 = 5 assert maxGridSum(grid5, n5, m5) == 67","solution":"def maxGridSum(grid, n, m): Returns the maximum sum of integers collected starting from [0,0] to [n-1,m-1] in the grid. You can only move either right or down at any point in time. # Create a 2D dp array with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Initialize the first cell with the value at the starting position dp[0][0] = grid[0][0] # Fill the dp table for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) # The bottom right cell contains the maximum sum return dp[n-1][m-1]"},{"question":"from datetime import datetime class Document: def __init__(self, title, author, date_of_creation, body): self.title = title self.author = author self.date_of_creation = date_of_creation self.body = body class DocumentDetailScreen: def __init__(self): self.current_document = None def display_document(self, document): Display document details. Args: document (Document): The document to be displayed. Returns: dict: A dictionary containing the document's title, author, date of creation, and body. # Implement the function to display the document details pass def navigate_to_document(self, document): Navigate to the document detail screen. Args: document (Document): The document to navigate to. Returns: dict: A dictionary containing the document's title, author, date of creation, and body. # Implement the function to navigate to the document pass # Unit Tests import pytest def test_document_initialization(): date = datetime.now() doc = Document(\\"Test Title\\", \\"Test Author\\", date, \\"Test body of the document.\\") assert doc.title == \\"Test Title\\" assert doc.author == \\"Test Author\\" assert doc.date_of_creation == date assert doc.body == \\"Test body of the document.\\" def test_display_document(): date = datetime(2023, 10, 2) doc = Document(\\"Test Title\\", \\"Test Author\\", date, \\"Test body of the document.\\") screen = DocumentDetailScreen() result = screen.display_document(doc) assert result['title'] == \\"Test Title\\" assert result['author'] == \\"Test Author\\" assert result['date_of_creation'] == \\"2023-10-02\\" assert result['body'] == \\"Test body of the document.\\" def test_navigate_to_document(): date = datetime(2023, 10, 2) doc = Document(\\"Test Title\\", \\"Test Author\\", date, \\"Test body of the document.\\") screen = DocumentDetailScreen() result = screen.navigate_to_document(doc) assert result['title'] == \\"Test Title\\" assert result['author'] == \\"Test Author\\" assert result['date_of_creation'] == \\"2023-10-02\\" assert result['body'] == \\"Test body of the document.\\" assert screen.current_document == doc # Run tests with pytest # pytest will pick up the test functions and execute them accordingly.","solution":"from datetime import datetime class Document: def __init__(self, title, author, date_of_creation, body): self.title = title self.author = author self.date_of_creation = date_of_creation self.body = body class DocumentDetailScreen: def __init__(self): self.current_document = None def display_document(self, document): self.current_document = document return { 'title': document.title, 'author': document.author, 'date_of_creation': document.date_of_creation.strftime(\\"%Y-%m-%d\\"), 'body': document.body } def navigate_to_document(self, document): return self.display_document(document) # Example Usage: # doc = Document(\\"Sample Title\\", \\"Author Name\\", datetime.now(), \\"This is the body of the document.\\") # screen = DocumentDetailScreen() # print(screen.navigate_to_document(doc))"},{"question":"def longest_increasing_segment(n: int, heights: List[int]) -> int: Returns the length of the longest continuous segment that can be planted in increasing order. Parameters: n (int): the number of plants heights (List[int]): a list of plant heights Returns: int: length of the longest increasing segment Examples: >>> longest_increasing_segment(6, [2, 1, 3, 2, 1, 4]) == 2 >>> longest_increasing_segment(4, [1, 2, 3, 4]) == 4 from solution import longest_increasing_segment def test_increasing_segment(): assert longest_increasing_segment(6, [2, 1, 3, 2, 1, 4]) == 2 def test_fully_increasing(): assert longest_increasing_segment(4, [1, 2, 3, 4]) == 4 def test_no_increasing(): assert longest_increasing_segment(5, [5, 4, 3, 2, 1]) == 1 def test_single_element(): assert longest_increasing_segment(1, [1]) == 1 def test_increasing_and_decreasing(): assert longest_increasing_segment(7, [1, 3, 5, 4, 6, 8, 7]) == 3 def test_empty_list(): assert longest_increasing_segment(0, []) == 0 def test_repeated_heights(): assert longest_increasing_segment(8, [5, 5, 5, 5, 5, 5, 5, 5]) == 1","solution":"def longest_increasing_segment(n, heights): Returns the length of the longest continuous segment that can be planted in increasing order. Parameters: n (int): the number of plants heights (List[int]): a list of plant heights Returns: int: length of the longest increasing segment if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def decode_message(numbers: List[int]) -> str: Decodes a list of integers into a string based on a defined character set. Args: numbers (List[int]): List of integers where each integer is between 1 and 30. Returns: str: Decoded string message. >>> decode_message([8, 5, 12, 12, 15, 27, 23, 15, 18, 12, 4]) 'HELLO WORLD' >>> decode_message([1, 13, 1, 26, 9, 14, 7, 27, 9, 19, 27, 6, 21, 14]) 'AMAZING IS FUN' >>> decode_message([30, 1, 9, 14, 27, 20, 8, 5, 27, 12, 1, 19, 20, 27, 17, 21, 5, 19, 20, 9, 15, 14]) '?AIN THE LAST QUESTION' >>> decode_message([1, 2, 3, 27, 4, 5, 6]) 'ABC DEF' >>> decode_message([1, 28, 2, 29, 3]) 'A.B,C'","solution":"def decode_message(numbers): Decodes a list of integers into a string based on a defined character set. Args: numbers (List[int]): List of integers where each integer is between 1 and 30. Returns: str: Decoded string message. # Mapping of numbers to characters num_to_char = { i + 1: chr(65 + i) for i in range(26) # Maps 1-26 to 'A'-'Z' } num_to_char.update({ 27: ' ', 28: '.', 29: ',', 30: '?' # Maps 27-30 to space, period, comma, question mark }) # Decode the message return ''.join(num_to_char[num] for num in numbers)"},{"question":"def count_balls_on_ground(ball_drops: List[Tuple[int, int]]) -> List[int]: Determines the number of balls on the ground after each ball drop. :param ball_drops: List of tuples, where each tuple contains (height, range) :return: List of integers representing the number of balls on the ground after each drop. >>> count_balls_on_ground([(5, 1)]) [1] >>> count_balls_on_ground([(5, 1), (7, 1), (3, 0)]) [1, 2, 3] >>> count_balls_on_ground([(5, 5), (7, 7), (6, 3)]) [1, 1, 1] >>> count_balls_on_ground([(5, 1), (7, 2), (3, 0)]) [1, 1, 2] >>> count_balls_on_ground([(5, 1), (7, 2), (3, 0), (10, 5), (2, 0)]) [1, 1, 2, 2, 3] >>> count_balls_on_ground([(100, 1000)]) [1]","solution":"def count_balls_on_ground(ball_drops): Determines the number of balls on the ground after each ball drop. :param ball_drops: List of tuples, where each tuple contains (height, range) :return: List of integers representing the number of balls on the ground after each drop. balls_on_ground = [] current_ground_heights = [] for h, r in ball_drops: solid_ground = True for ground_height in current_ground_heights: if abs(ground_height - h) <= r: solid_ground = False break if solid_ground: current_ground_heights.append(h) balls_on_ground.append(len(current_ground_heights)) return balls_on_ground"},{"question":"def find_maximum_cost_in_mst(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: This function takes the number of nodes (n), number of edges (m), and a list of edges (each represented by a tuple (u, v, w) where u and v are nodes and w is the weight of the edge). It returns the maximum cost for the MST or -1 if no MST can be formed. >>> find_maximum_cost_in_mst(4, 5, [(1, 2, 3), (1, 3, 4), (4, 2, 5), (3, 2, 2), (3, 4, 6)]) == 5 True >>> find_maximum_cost_in_mst(3, 2, [(1, 2, 1), (2, 3, 2)]) == 2 True >>> find_maximum_cost_in_mst(3, 1, [(1, 2, 1)]) == -1 True >>> find_maximum_cost_in_mst(1, 0, []) == 0 True >>> find_maximum_cost_in_mst(4, 2, [(1, 2, 1), (3, 4, 1)]) == -1 True >>> find_maximum_cost_in_mst(4, 5, [(1, 2, 1), (1, 3, 1), (4, 2, 1), (3, 2, 1), (3, 4, 1)]) == 1 True pass","solution":"def find_maximum_cost_in_mst(n, m, edges): This function takes the number of nodes (n), number of edges (m), and a list of edges (each represented by a tuple (u, v, w) where u and v are nodes and w is the weight of the edge). It returns the maximum cost for the MST or -1 if no MST can be formed. from heapq import heappop, heappush if n == 1: return 0 # Only one node, no edges, max cost is 0 # Sort edges to prepare for Kruskal’s MST algorithm edges.sort(key=lambda edge: edge[2]) # Disjoint set (union-find with path compression and union by rank) parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Kruskal's algorithm to find the MST and maximum edge weight in the MST max_cost_in_mst = -1 edges_used = 0 for u, v, w in edges: if find(u) != find(v): union(u, v) max_cost_in_mst = max(max_cost_in_mst, w) edges_used += 1 if edges_used == n - 1: break # Check if we used exactly n-1 edges which confirms that the graph is connected if edges_used == n - 1: return max_cost_in_mst else: return -1"},{"question":"def can_form_arithmetic_progression(n: int, sequence: List[int]) -> str: Determine if the sequence can form an arithmetic progression after rearranging. Parameters: n - Number of elements in the sequence sequence - List of integers representing the sequence Returns: str - \\"YES\\" if the sequence can form an arithmetic progression, otherwise \\"NO\\" Examples: >>> can_form_arithmetic_progression(3, [3, 1, 2]) \\"YES\\" >>> can_form_arithmetic_progression(4, [1, 2, 4, 6]) \\"NO\\" pass","solution":"def can_form_arithmetic_progression(n, sequence): Determine if the sequence can form an arithmetic progression after rearranging. Parameters: n - Number of elements in the sequence sequence - List of integers representing the sequence Returns: str - \\"YES\\" if the sequence can form an arithmetic progression, otherwise \\"NO\\" sequence.sort() difference = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i - 1] != difference: return \\"NO\\" return \\"YES\\""},{"question":"def preprocess(arr): Preprocess the array to compute prefix products modulo 1000000007. Args: arr (List[int]): The input array. Returns: List[int]: The prefix products array. pass def product_query(prefix_prod, l, r): Compute the product of elements in the subarray arr[l:r] modulo 1000000007. Args: prefix_prod (List[int]): The prefix products array. l (int): The starting index (1-based). r (int): The ending index (1-based). Returns: int: The product of the subarray modulo 1000000007. pass def process_queries(n, q, array, queries): Process multiple product queries on the array. Args: n (int): The number of elements in the array. q (int): The number of queries. array (List[int]): The input array. queries (List[Tuple[int, int]]): The queries as a list of tuples (l, r). Returns: List[int]: The results of each query. pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) q = int(data[1]) array = list(map(int, data[2:n+2])) queries = [(int(data[i]), int(data[i+1])) for i in range(n+2, len(data), 2)] results = process_queries(n, q, array, queries) for res in results: print(res) # Unit Tests def test_preprocess(): arr = [1, 2, 3, 4, 5] expected = [1, 1, 2, 6, 24, 120] assert preprocess(arr) == expected def test_product_query(): prefix_prod = preprocess([1, 2, 3, 4, 5]) assert product_query(prefix_prod, 1, 3) == 6 assert product_query(prefix_prod, 2, 5) == 120 assert product_query(prefix_prod, 3, 3) == 3 def test_process_queries(): n = 5 q = 3 array = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 5), (3, 3)] expected = [6, 120, 3] assert process_queries(n, q, array, queries) == expected","solution":"MOD = 1000000007 def preprocess(arr): n = len(arr) prefix_prod = [1] * (n + 1) for i in range(1, n + 1): prefix_prod[i] = (prefix_prod[i - 1] * arr[i - 1]) % MOD return prefix_prod def product_query(prefix_prod, l, r): if l == 1: return prefix_prod[r] return (prefix_prod[r] * pow(prefix_prod[l - 1], MOD - 2, MOD)) % MOD def process_queries(n, q, array, queries): result = [] prefix_prod = preprocess(array) for l, r in queries: result.append(product_query(prefix_prod, l, r)) return result"},{"question":"from typing import List def min_moves_to_bottom_right(n: int, grid: List[List[int]]) -> int: Calculate the minimum number of moves required to travel from the top-left corner to the bottom-right corner of the grid. Return -1 if it is not possible to reach the bottom-right corner. Args: n : int : size of the grid grid : List[List[int]] : 2D list representing the grid, where 0 is an empty cell and 1 is a wall Returns: int : minimum number of moves or -1 if the bottom-right corner is not reachable. Example: >>> grid = [ ... [0, 1, 0], ... [0, 0, 0], ... [1, 0, 0] ... ] >>> min_moves_to_bottom_right(3, grid) 4","solution":"from collections import deque from typing import List, Tuple def min_moves_to_bottom_right(n: int, grid: List[List[int]]) -> int: Returns the minimum number of moves required to travel from the top-left corner to the bottom-right corner of the grid, or -1 if it is not possible. # Directions are in order of right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x: int, y: int) -> bool: return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 # BFS initialization queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() # Check if we have reached the bottom-right corner if x == n - 1 and y == n - 1: return steps # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def find_first_occurrence(words_list: List[str], word: str) -> int: Returns the index of the first occurrence of the word in words_list, or -1 if it does not exist. >>> find_first_occurrence([\\"hello\\", \\"world\\", \\"foo\\", \\"bar\\"], \\"foo\\") 2 >>> find_first_occurrence([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"grape\\") -1 >>> find_first_occurrence([\\"one\\", \\"two\\", \\"three\\", \\"two\\"], \\"two\\") 1 from solution import find_first_occurrence def test_find_first_occurrence_word_exists(): assert find_first_occurrence([\\"hello\\", \\"world\\", \\"foo\\", \\"bar\\"], \\"foo\\") == 2 def test_find_first_occurrence_word_does_not_exist(): assert find_first_occurrence([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"grape\\") == -1 def test_find_first_occurrence_multiple_occurrences(): assert find_first_occurrence([\\"one\\", \\"two\\", \\"three\\", \\"two\\"], \\"two\\") == 1 def test_find_first_occurrence_word_at_start(): assert find_first_occurrence([\\"start\\", \\"middle\\", \\"end\\"], \\"start\\") == 0 def test_find_first_occurrence_empty_list(): assert find_first_occurrence([], \\"empty\\") == -1 def test_find_first_occurrence_word_at_end(): assert find_first_occurrence([\\"start\\", \\"middle\\", \\"end\\"], \\"end\\") == 2","solution":"def find_first_occurrence(words_list, word): Returns the index of the first occurrence of the word in words_list, or -1 if it does not exist. :param words_list: List of strings :param word: A string to find in words_list :return: The index of the first occurrence or -1 if not found for index, current_word in enumerate(words_list): if current_word == word: return index return -1"},{"question":"from typing import List, Tuple def collaboration(N: int, M: int, pairs: List[Tuple[int, int]]) -> int: Determines the size of the largest group of collaborating employees. Args: N: An integer representing the number of employees. M: An integer representing the number of pairs of employees who will collaborate. pairs: A list of tuples where each tuple contains two integers ai and bi indicating that employee ai and employee bi will collaborate. Returns: An integer representing the size of the largest group of collaborating employees. Example: >>> collaboration(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (1, 3)]) 3 >>> collaboration(2, 1, [(1, 2)]) 2 from solution import collaboration def test_example(): N = 6 M = 5 pairs = [ (1, 2), (2, 3), (4, 5), (5, 6), (1, 3) ] assert collaboration(N, M, pairs) == 3 def test_single_group(): N = 4 M = 3 pairs = [ (1, 2), (2, 3), (3, 4) ] assert collaboration(N, M, pairs) == 4 def test_disconnected_groups(): N = 6 M = 2 pairs = [ (1, 2), (3, 4) ] assert collaboration(N, M, pairs) == 2 def test_large_case(): N = 5 M = 10 pairs = [ (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5) ] assert collaboration(N, M, pairs) == 5 def test_min_case(): N = 2 M = 1 pairs = [(1, 2)] assert collaboration(N, M, pairs) == 2","solution":"def collaboration(N, M, pairs): from collections import defaultdict, deque def bfs(start, adj, visited): queue = deque([start]) visited[start] = True size = 0 while queue: node = queue.popleft() size += 1 for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return size # Create an adjacency list adj = defaultdict(list) for a, b in pairs: adj[a].append(b) adj[b].append(a) visited = [False] * (N + 1) largest_group_size = 0 for i in range(1, N + 1): if not visited[i]: group_size = bfs(i, adj, visited) largest_group_size = max(largest_group_size, group_size) return largest_group_size"},{"question":"def meets_goal(n: int, k: int, goal: int, distances: List[int]) -> str: Determine if there is any subarray of length k whose sum is greater than or equal to the goal. >>> meets_goal(7, 3, 15, [4, 7, 2, 5, 8, 4, 3]) \\"YES\\" >>> meets_goal(5, 2, 20, [1, 2, 3, 4, 5]) \\"NO\\" >>> meets_goal(5, 3, 10, [1, 2, 7, 0, 3]) \\"YES\\" >>> meets_goal(4, 2, 6, [3, 3, 3, 3]) \\"YES\\" >>> meets_goal(6, 2, 1, [0, 0, 0, 0, 0, 0]) \\"NO\\" >>> meets_goal(4, 2, 0, [0, 0, 0, 0]) \\"YES\\" >>> meets_goal(100000, 1, 1000000, [1000000] * 100000) \\"YES\\" >>> meets_goal(100000, 1, 1, [0] * 100000) \\"NO\\"","solution":"def meets_goal(n, k, goal, distances): Determines if there is any subarray of length k whose sum is greater than or equal to the goal. Parameters: n (int): Number of days. k (int): Number of consecutive days to check. goal (int): Mileage goal. distances (list of int): Distances run each day. Returns: str: \\"YES\\" if there exists any k consecutive days where the sum of distances is >= goal, otherwise \\"NO\\". current_sum = sum(distances[:k]) if current_sum >= goal: return \\"YES\\" for i in range(k, n): current_sum += distances[i] - distances[i - k] if current_sum >= goal: return \\"YES\\" return \\"NO\\""},{"question":"def count_unique_rarities(n: int, rarities: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of unique rarities for each query sub-collection. Args: n (int): Number of stamps. rarities (list of int): List of integers representing the rarities of each stamp. queries (list of tuple of int): List of queries with each query being a tuple (l, r). Returns: list of int: Number of unique rarities for each query. from typing import List, Tuple def test_example_case(): n = 5 rarities = [1, 2, 1, 3, 2] queries = [(1, 3), (2, 4), (1, 5)] assert count_unique_rarities(n, rarities, queries) == [2, 3, 3] def test_single_rarity(): n = 3 rarities = [7, 7, 7] queries = [(1, 1), (1, 2), (1, 3), (2, 3)] assert count_unique_rarities(n, rarities, queries) == [1, 1, 1, 1] def test_mixed_rarities(): n = 4 rarities = [3, 3, 1, 2] queries = [(1, 2), (2, 3), (1, 4), (3, 4)] assert count_unique_rarities(n, rarities, queries) == [1, 2, 3, 2] def test_large_case(): n = 100000 rarities = list(range(1, 100001)) queries = [(1, 100000), (50000, 100000), (1, 50000)] assert count_unique_rarities(n, rarities, queries) == [100000, 50001, 50000] def test_minimum_case(): n = 1 rarities = [1] queries = [(1, 1)] assert count_unique_rarities(n, rarities, queries) == [1]","solution":"def count_unique_rarities(n, rarities, queries): Returns the number of unique rarities for each query sub-collection. Args: n (int): Number of stamps. rarities (list of int): List of integers representing the rarities of each stamp. queries (list of tuple of int): List of queries with each query being a tuple (l, r). Returns: list of int: Number of unique rarities for each query. result = [] for l, r in queries: sub_collection = rarities[l-1:r] # Get the sub-collection unique_rarities = len(set(sub_collection)) # Count unique rarities result.append(unique_rarities) return result"},{"question":"def minimum_moves_to_target(xt: int, yt: int) -> int: Returns the minimum number of moves required to reach (xt, yt) from (0, 0). >>> minimum_moves_to_target(3, 4) # 7 >>> minimum_moves_to_target(-2, -3) # 5 >>> minimum_moves_to_target(0, 0) # 0 >>> minimum_moves_to_target(1, 1) # 2 >>> minimum_moves_to_target(-1, -1) # 2 >>> minimum_moves_to_target(1000000, -1000000) # 2000000 >>> minimum_moves_to_target(-1000000, 1000000) # 2000000 >>> minimum_moves_to_target(123456, 654321) # 777777","solution":"def minimum_moves_to_target(xt, yt): Returns the minimum number of moves required to reach (xt, yt) from (0, 0). Parameters: xt (int): x-coordinate of the target position. yt (int): y-coordinate of the target position. Returns: int: Minimum number of moves required to reach the target position. # The minimum number of moves will be the sum of the absolute values # of the x and y target coordinates because each move changes either x or y by 1. return abs(xt) + abs(yt)"},{"question":"def assign_weights(n: int, edges: List[Tuple[int, int]]) -> List[int]: Assigns a unique sum of edge weights for subtree sums rooted at any vertex. Args: n (int): Number of vertices in the tree. edges (list of tuple of int): List of edges represented by tuples (u, v). Returns: list of int: List of weights for corresponding edges. Examples: >>> assign_weights(4, [(1, 2), (1, 3), (1, 4)]) [10, 20, 30] >>> assign_weights(2, [(1, 2)]) [10] >>> assign_weights(3, [(1, 2), (1, 3)]) [10, 20] >>> assign_weights(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) [10, 20, 30, 40, 50]","solution":"def assign_weights(n, edges): Assigns a unique sum of edge weights for subtree sums rooted at any vertex. Parameters: n (int): Number of vertices in the tree. edges (list of tuple of int): List of edges represented by tuples (u, v). Returns: list of int: List of weights for corresponding edges. # Just assigning incremental weights for simplicity weights = [i for i in range(10, 10 * (n - 1) + 1, 10)] return weights"},{"question":"def reorganize_tree(N: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Reorganizes the nodes of the tree such that the in-order traversal of the new tree is identical to the sorted sequence of values from 1 to N. Args: - N (int): The number of nodes in the tree. - edges (list): List of tuples representing the edges of the tree. Returns: - List of tuples representing the edges of the reorganized tree. from solution import reorganize_tree def test_reorganize_tree_single_node(): assert reorganize_tree(1, []) == [] def test_reorganize_tree_two_nodes(): assert reorganize_tree(2, [(1, 2)]) == [(1, 2)] def test_reorganize_tree_three_nodes(): assert reorganize_tree(3, [(1, 2), (1, 3)]) == [(1, 2), (2, 3)] def test_reorganize_tree_five_nodes(): edges = [(1, 2), (1, 3), (3, 4), (3, 5)] assert reorganize_tree(5, edges) == [(1, 2), (2, 3), (3, 4), (4, 5)] def test_reorganize_tree_seven_nodes(): edges = [(3, 1), (3, 6), (1, 2), (6, 7), (6, 4), (7, 5)] assert reorganize_tree(7, edges) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]","solution":"def reorganize_tree(N, edges): Reorganizes the nodes of the tree such that the in-order traversal of the new tree is identical to the sorted sequence of values from 1 to N. Args: - N (int): The number of nodes in the tree. - edges (list): List of tuples representing the edges of the tree. Returns: - List of tuples representing the edges of the reorganized tree. new_edges = [] for i in range(1, N): new_edges.append((i, i+1)) return new_edges"},{"question":"def longest_increasing_subsequence(blocks: List[int]) -> int: Returns the length of the longest increasing subsequence of blocks. >>> longest_increasing_subsequence([5, 3, 4, 8, 6, 7]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(blocks): Returns the length of the longest increasing subsequence of blocks. if not blocks: return 0 n = len(blocks) dp = [1] * n for i in range(1, n): for j in range(i): if blocks[i] > blocks[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def min_edit_distance(s1: str, s2: str) -> int: Computes the minimum number of steps to convert one string into another by either inserting, deleting, or replacing a character. >>> min_edit_distance(\\"horse\\", \\"ros\\") 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"abc\\", \\"def\\") 3 def solve_min_edit_distance(t: int, cases: List[str]) -> List[int]: Solves multiple test cases of the minimum edit distance problem. >>> solve_min_edit_distance(3, [\\"horse\\", \\"ros\\", \\"intention\\", \\"execution\\", \\"abc\\", \\"def\\"]) [3, 5, 3]","solution":"def min_edit_distance(s1, s2): m, n = len(s1), len(s2) # Create a dp array to store the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for the base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the dp values for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 return dp[m][n] def solve_min_edit_distance(t, cases): results = [] for i in range(t): s1, s2 = cases[i * 2], cases[i * 2 + 1] results.append(min_edit_distance(s1, s2)) return results"},{"question":"from typing import List def find_unique(nums: List[int]) -> int: Returns the integer that occurs only once in the list where every other integer appears exactly twice. Args: nums (List[int]): List of integers where each integer except one appears exactly twice. Returns: int: The unique integer that appears only once. Examples: >>> find_unique([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique([2, 3, 4, 2, 3, 5, 4]) 5 >>> find_unique([-1, -2, -3, -1, -2, -3, -4]) -4 pass","solution":"from typing import List def find_unique(nums: List[int]) -> int: Returns the integer that occurs only once in the list where every other integer appears exactly twice. Args: nums (List[int]): List of integers where each integer except one appears exactly twice. Returns: int: The unique integer that appears only once. unique = 0 for num in nums: unique ^= num return unique"},{"question":"from typing import List def shortest_path_length(n: int, m: int, maze: List[str]) -> int: Returns the length of the shortest path for Polycarp to reach an exit in the maze. If no such path exists, returns -1. >>> shortest_path_length(5, 7, [ \\"#\\", \\"#S..E.#\\", \\"#...#\\", \\"#.....#\\", \\"#\\" ]) == 3 >>> shortest_path_length(5, 7, [ \\"#\\", \\"#S..#\\", \\"#...#\\", \\"#.....#\\", \\"#\\" ]) == -1 from collections import deque def test_shortest_path_example(): maze = [ \\"#\\", \\"#S..E.#\\", \\"#...#\\", \\"#.....#\\", \\"#\\" ] n, m = 5, 7 assert shortest_path_length(n, m, maze) == 3 def test_shortest_path_no_exit(): maze = [ \\"#\\", \\"#S..#\\", \\"#...#\\", \\"#.....#\\", \\"#\\" ] n, m = 5, 7 assert shortest_path_length(n, m, maze) == -1 def test_shortest_path_direct_exit(): maze = [ \\"#\\", \\"#S#\\", \\"#E#\\", \\"#\\" ] n, m = 4, 3 assert shortest_path_length(n, m, maze) == 1 def test_multiple_paths(): maze = [ \\"#\\", \\"#S..E.#\\", \\"#.....#\\", \\"#.E...#\\", \\"#\\" ] n, m = 5, 7 assert shortest_path_length(n, m, maze) == 3 def test_no_path_due_to_walls(): maze = [ \\"#\\", \\"#S#.#E#\\", \\"#.#.#.#\\", \\"#\\" ] n, m = 4, 7 assert shortest_path_length(n, m, maze) == -1","solution":"from collections import deque def shortest_path_length(n, m, maze): Returns the length of the shortest path for Polycarp to reach an exit in the maze. If no such path exists, returns -1. # Locate the start position start = None exits = [] for i in range(n): for j in range(m): if maze[i][j] == 'S': start = (i, j) elif maze[i][j] == 'E': exits.append((i, j)) if not start or not exits: return -1 # Directions for moving: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # BFS setup queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if maze[x][y] == 'E': return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and maze[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List, Tuple def min_trips(n: int, m: int, K: int, bridges: List[Tuple[int, int]], l: int, letters: List[int]) -> int: Determine the minimum number of trips required to deliver all the letters to their destination islands. Args: n : int : Number of islands m : int : Number of one-way bridges K : int : Number of letters the courier can carry in a single trip bridges : List[Tuple[int, int]] : List of one-way bridges described by (u, v) l : int : Number of letters to deliver letters : List[int] : List of destination islands for the letters Returns: int : Minimum number of trips required to deliver all the letters Examples: >>> min_trips(5, 6, 2, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)], 3, [2, 4, 5]) 2 >>> min_trips(4, 4, 2, [(1, 2), (1, 3), (2, 4), (3, 4)], 3, [2, 3, 4]) 2 pass # your implementation here # Example tests def test_case_1(): n = 5 m = 6 K = 2 bridges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)] l = 3 letters = [2, 4, 5] assert min_trips(n, m, K, bridges, l, letters) == 2 def test_case_2(): n = 4 m = 4 K = 2 bridges = [(1, 2), (1, 3), (2, 4), (3, 4)] l = 3 letters = [2, 3, 4] assert min_trips(n, m, K, bridges, l, letters) == 2 def test_case_3(): n = 7 m = 8 K = 3 bridges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6), (5, 7)] l = 4 letters = [2, 4, 6, 7] assert min_trips(n, m, K, bridges, l, letters) == 2 def test_case_4(): n = 3 m = 2 K = 1 bridges = [(1, 2), (2, 3)] l = 2 letters = [2, 3] assert min_trips(n, m, K, bridges, l, letters) == 2 def test_case_5(): n = 6 m = 7 K = 2 bridges = [(1, 2), (1, 3), (2, 4), (3, 5), (4, 6), (5, 6), (3, 4)] l = 5 letters = [2, 3, 4, 5, 6] assert min_trips(n, m, K, bridges, l, letters) == 3","solution":"from collections import deque, defaultdict def min_trips(n, m, K, bridges, l, letters): # Build the graph graph = defaultdict(list) for u, v in bridges: graph[u].append(v) # Perform BFS from node 1 to find shortest paths def bfs(start): dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 queue = deque([(start, 0)]) while queue: current, d = queue.popleft() for neighbor in graph[current]: if d + 1 < dist[neighbor]: dist[neighbor] = d + 1 queue.append((neighbor, d + 1)) return dist dist_from_1 = bfs(1) # Find distances from island 1 to all the destinations letter_distances = [dist_from_1[destination] for destination in letters] letter_distances.sort() trips = 0 while letter_distances: trips += 1 trip_letters = letter_distances[:K] letter_distances = letter_distances[K:] return trips"},{"question":"def min_max_distance(N: int, K: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum possible maximum distance between any city and the closest castle in Treeland. >>> min_max_distance(7, 2, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 3 >>> min_max_distance(1, 1, []) 0 >>> min_max_distance(2, 1, [(1, 2)]) 1 >>> min_max_distance(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> min_max_distance(5, 2, [(1, 2), (1, 3), (3, 4), (3, 5)]) 1","solution":"from collections import deque, defaultdict def bfs_longest(node, adjacency_list): queue = deque([(node, 0)]) visited = set() visited.add(node) farthest_node = node max_distance = 0 while queue: current, distance = queue.popleft() for neighbor in adjacency_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) if distance + 1 > max_distance: max_distance = distance + 1 farthest_node = neighbor return farthest_node, max_distance def min_max_distance(N, K, roads): if K >= N: return 0 adjacency_list = defaultdict(list) for U, V in roads: adjacency_list[U].append(V) adjacency_list[V].append(U) # Find one endpoint of the tree diameter node, _ = bfs_longest(1, adjacency_list) # Find the other endpoint and the actual diameter length farthest, diameter = bfs_longest(node, adjacency_list) # Binary search on the longest distance low, high = 1, (diameter // 2) + 1 while low < high: mid = (low + high) // 2 if can_place_castles(N, K, adjacency_list, mid): high = mid else: low = mid + 1 return low def can_place_castles(N, K, adjacency_list, max_dist): visited = set() num_castles = 0 def dfs(node, parent): farthest = 0 for neighbor in adjacency_list[node]: if neighbor == parent: continue if neighbor in visited: continue dist = dfs(neighbor, node) + 1 if dist > max_dist: num_castles_needed[num_castles_needed['count'] < K] = 1 dist = 0 num_castles_needed['count'] += 1 farthest = max(farthest, dist) return farthest num_castles_needed = {'count': 1} dfs(1, -1) return num_castles_needed['count'] <= K"},{"question":"def min_max_toll(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: In a mysterious land, there are n cities and multiple bidirectional roads connecting pairs of these cities. Each road has a certain toll cost. The king of the land wants to travel from his capital city to all other cities. He demands to find the path that minimizes the maximum toll cost he has to pay on any single road during his journey. The first line contains two integers n (2 ≤ n ≤ 100) and m (1 ≤ m ≤ 10,000) — the number of cities and the number of roads, respectively. Each of the next m lines contains three integers u, v, and w (1 ≤ u, v ≤ n, 1 ≤ w ≤ 100), indicating there is a road between city u and city v with toll cost w. The king's capital city is city 1. Output the minimum possible value of the maximum toll cost that the king has to pay on any road during his journey from the capital city to visit all other cities. If it's impossible for the king to reach all cities, output -1. >>> min_max_toll(3, 3, [(1, 2, 4), (2, 3, 3), (1, 3, 5)]) 4 >>> min_max_toll(4, 4, [(1, 2, 1), (1, 3, 4), (3, 4, 2), (2, 4, 3)]) 3 >>> min_max_toll(3, 3, [(1, 2, 10), (2, 3, 10), (3, 1, 10)]) 10 >>> min_max_toll(4, 3, [(1, 2, 2), (2, 3, 2), (3, 4, 2)]) 2 >>> min_max_toll(4, 2, [(1, 2, 5), (3, 4, 10)]) -1","solution":"def can_travel_with_max_toll(n, roads, max_toll): from collections import deque, defaultdict graph = defaultdict(list) for u, v, w in roads: if w <= max_toll: graph[u].append(v) graph[v].append(u) visited = set() queue = deque([1]) visited.add(1) while queue: city = queue.popleft() for next_city in graph[city]: if next_city not in visited: visited.add(next_city) queue.append(next_city) return len(visited) == n def min_max_toll(n, m, roads): roads.sort(key=lambda x: x[2]) low, high = 0, len(roads) - 1 best_toll = float('inf') while low <= high: mid = (low + high) // 2 max_toll = roads[mid][2] if can_travel_with_max_toll(n, roads, max_toll): best_toll = max_toll high = mid - 1 else: low = mid + 1 return best_toll if best_toll != float('inf') else -1"},{"question":"def minimize_max_subarray_sum(n, k, a): Splits an array into exactly k non-empty subarrays and minimize the maximum sum of elements in any subarray. The function \`minimize_max_subarray_sum\` takes in three parameters: - n: an integer, representing the length of the array. - k: an integer, representing the number of subarrays to split into. - a: a list of n integers, representing the array. The function should return a single integer, the minimum possible value of the maximum sum of the k subarrays. Examples: >>> minimize_max_subarray_sum(5, 2, [1, 2, 3, 4, 5]) 9 >>> minimize_max_subarray_sum(5, 3, [1, 2, 3, 4, 5]) 6 from solution import minimize_max_subarray_sum def test_minimize_max_subarray_sum_example_1(): assert minimize_max_subarray_sum(5, 2, [1, 2, 3, 4, 5]) == 9 def test_minimize_max_subarray_sum_example_2(): assert minimize_max_subarray_sum(5, 3, [1, 2, 3, 4, 5]) == 6 def test_minimize_max_subarray_sum_single_element(): assert minimize_max_subarray_sum(1, 1, [10]) == 10 def test_minimize_max_subarray_sum_equal_elements(): assert minimize_max_subarray_sum(4, 2, [1, 1, 1, 1]) == 2 def test_minimize_max_subarray_sum_large_values(): assert minimize_max_subarray_sum(5, 2, [100, 200, 300, 400, 500]) == 900 def test_minimize_max_subarray_sum_min_subarrays(): assert minimize_max_subarray_sum(5, 5, [1, 2, 3, 4, 5]) == 5","solution":"def minimize_max_subarray_sum(n, k, a): def valid_partition(max_sum): current_sum = 0 required_subarrays = 1 for num in a: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True low, high = max(a), sum(a) while low < high: mid = (low + high) // 2 if valid_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"def longest_consecutive_team_sequence(n: int, participants: List[int]) -> int: Determine the length of the longest consecutive sequence of participants from the same team. Parameters: n (int): Total number of participants. participants (List[int]): List of integers where the i-th integer represents the team number of the i-th participant. Returns: int: The length of the longest consecutive sequence of participants from the same team. Example: >>> longest_consecutive_team_sequence(7, [1, 1, 2, 2, 2, 3, 3]) 3 >>> longest_consecutive_team_sequence(5, [1, 2, 3, 4, 5]) 1 from typing import List def test_single_participant(): assert longest_consecutive_team_sequence(1, [1]) == 1 def test_all_different_teams(): assert longest_consecutive_team_sequence(5, [1, 2, 3, 4, 5]) == 1 def test_all_same_team(): assert longest_consecutive_team_sequence(4, [2, 2, 2, 2]) == 4 def test_mixed_teams(): assert longest_consecutive_team_sequence(7, [1, 1, 2, 2, 2, 3, 3]) == 3 def test_edge_case_empty(): assert longest_consecutive_team_sequence(0, []) == 0 def test_long_sequence(): assert longest_consecutive_team_sequence(10, [1,1,1,2,2,2,2,3,3,3]) == 4 def test_two_sequences_with_same_max_length(): assert longest_consecutive_team_sequence(8, [1, 1, 2, 2, 3, 3, 3, 3]) == 4","solution":"def longest_consecutive_team_sequence(n, participants): This function takes number of participants and their corresponding team numbers and returns the length of the longest consecutive sequence of participants from the same team. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if participants[i] == participants[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 # Check for the last sequence if current_length > max_length: max_length = current_length return max_length"},{"question":"def can_travel(N: int, K: int, elevations: List[int]) -> str: Determines if it is possible to travel from the first island to the last island without crossing more than K meters in elevation difference between any two consecutive islands. Args: N (int): Number of islands K (int): Maximum allowed elevation difference elevations (list): List of elevations of the islands Returns: str: \\"yes\\" if the journey is possible, otherwise \\"no\\" >>> can_travel(5, 3, [2, 5, 6, 9, 10]) \\"yes\\" >>> can_travel(4, 1, [1, 3, 2, 4]) \\"no\\" from typing import List def test_example_1(): assert can_travel(5, 3, [2, 5, 6, 9, 10]) == \\"yes\\" def test_example_2(): assert can_travel(4, 1, [1, 3, 2, 4]) == \\"no\\" def test_case_with_increasing_elevations(): assert can_travel(6, 5, [1, 3, 8, 13, 18, 23]) == \\"yes\\" def test_case_with_decreasing_elevations(): assert can_travel(3, 4, [10, 7, 3]) == \\"yes\\" def test_case_with_large_K(): assert can_travel(4, 1000, [1, 2, 100, 200]) == \\"yes\\" def test_case_with_too_large_difference(): assert can_travel(3, 5, [0, 7, 12]) == \\"no\\"","solution":"def can_travel(N, K, elevations): Determines if it is possible to travel from the first island to the last island without crossing more than K meters in elevation difference between any two consecutive islands. Args: N (int): Number of islands K (int): Maximum allowed elevation difference elevations (list): List of elevations of the islands Returns: str: \\"yes\\" if the journey is possible, otherwise \\"no\\" for i in range(1, N): if abs(elevations[i] - elevations[i-1]) > K: return \\"no\\" return \\"yes\\""},{"question":"def minimum_moves_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of moves required to sort the array in non-decreasing order or determine if it is impossible. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): The list containing tuples where each tuple has an integer n (size of the array) and a list of n integers (the array to be sorted). Returns: List[int]: A list containing the result for each test case - either the minimum number of moves required or -1 if sorting is impossible. Example: >>> minimum_moves_to_sort(2, [(3, [4, 5, 3]), (4, [5, 2, 3, 4])]) [1, 1] >>> minimum_moves_to_sort(1, [(4, [1, 2, 3, 4])]) [-1]","solution":"def minimum_moves_to_sort(t, test_cases): results = [] for case in test_cases: n, a = case if all(abs(a[i] - a[i + 1]) < 2 for i in range(n - 1)): results.append(-1) else: results.append(1) return results # Example usage: # t = 2 # test_cases = [ # (3, [4, 5, 3]), # (4, [5, 2, 3, 4]) # ] # print(minimum_moves_to_sort(t, test_cases)) # Output: [1, 1]"},{"question":"def min_removals_to_make_increasing(arr: List[int]) -> int: You have an array of integers, and your task is to find the minimum number of contiguous subarrays you need to remove in order for the remaining array to become strictly increasing. A strictly increasing array is an array where each element is greater than the previous one. Args: arr (List[int]): List of integers. Returns: int: Minimum number of contiguous subarrays to remove. >>> min_removals_to_make_increasing([4, 3, 5, 1, 6]) 2 >>> min_removals_to_make_increasing([1]) 0 >>> min_removals_to_make_increasing([1, 2, 3, 4, 5]) 0 >>> min_removals_to_make_increasing([5, 4, 3, 2, 1]) 4 >>> min_removals_to_make_increasing([1, 3, 2, 4, 3, 5]) 2","solution":"def min_removals_to_make_increasing(arr): n = len(arr) if n == 1: return 0 # Length of longest increasing subsequence ending at index i dp = [1] * n for i in range(1, n): for j in range(i): if arr[j] < arr[i]: dp[i] = max(dp[i], dp[j] + 1) # Length of longest increasing subsequence in the array lis_length = max(dp) # Minimum number of elements to remove to get strictly increasing array min_removals = n - lis_length return min_removals"},{"question":"def max_price_difference(n: int, prices: List[int]) -> int: Returns the maximum possible difference between the highest and the lowest prices after performing any number of swaps. >>> max_price_difference(1, [5]) 0 >>> max_price_difference(4, [7, 7, 7, 7]) 0 >>> max_price_difference(5, [1, 9, 3, 4, 8]) 8 >>> max_price_difference(5, [100000, 500000, 300000, 200000, 900000]) 800000 >>> max_price_difference(0, []) 0 >>> max_price_difference(2, [5, 15]) 10 >>> max_price_difference(2, [15, 5]) 10","solution":"def max_price_difference(n, prices): Returns the maximum possible difference between the highest and the lowest prices after performing any number of swaps. Parameters: - n: int, the number of products - prices: list of int, the initial prices of the products Returns: - int: the maximum possible difference between the highest and the lowest price if not prices or n == 0: return 0 max_price = max(prices) min_price = min(prices) return max_price - min_price"},{"question":"from typing import List def simulate_growth(n: int, m: int, events: List[int]) -> List[int]: Simulate the growth of a plant over a period of m months given the growth events. Each month, the plant either doubles its height or grows by a fixed number of units. Args: n (int): The fixed number of units the plant grows when it does not double its height (1 <= n <= 100). m (int): The number of months to simulate (1 <= m <= 100). events (List[int]): A list of length m containing integers where 1 indicates the plant should double its height, and 0 indicates the plant should grow by the fixed number of units. Returns: List[int]: A list of length m where the i-th element is the height of the plant at the end of the i-th month. Examples: >>> simulate_growth(3, 4, [1, 0, 1, 0]) [2, 5, 10, 13] >>> simulate_growth(2, 3, [1, 1, 1]) [2, 4, 8] >>> simulate_growth(1, 4, [0, 0, 0, 0]) [2, 3, 4, 5] >>> simulate_growth(5, 5, [0, 1, 0, 1, 0]) [6, 12, 17, 34, 39]","solution":"from typing import List def simulate_growth(n: int, m: int, events: List[int]) -> List[int]: height = 1 heights = [] for event in events: if event == 1: height *= 2 else: height += n heights.append(height) return heights"},{"question":"def can_see_sunset(buildings): Determines if each building can see the sunset. Args: buildings (list): A list of integers representing the heights of buildings. Returns: list: A list of integers where 1 denotes that the respective building can see the sunset, and 0 otherwise. def process_input(input_str): Processes the input string and converts it to a list of integers. Args: input_str (str): A space-separated string of integers representing building heights. Returns: list: A list of integers. def format_output(results): Formats the output list into a space-separated string. Args: results (list): A list of integers. Returns: str: A space-separated string of integers. # Test cases def test_can_see_sunset(): buildings = [3, 7, 8, 3, 6, 1] expected = [1, 1, 1, 0, 0, 0] assert can_see_sunset(buildings) == expected def test_can_see_sunset_single_building(): buildings = [3] expected = [1] assert can_see_sunset(buildings) == expected def test_can_see_sunset_all_blocked(): buildings = [6, 5, 4, 3, 2, 1] expected = [1, 0, 0, 0, 0, 0] assert can_see_sunset(buildings) == expected def test_can_see_sunset_mixed(): buildings = [1, 3, 2, 5, 3, 6] expected = [1, 1, 0, 1, 0, 1] assert can_see_sunset(buildings) == expected def test_process_input(): input_str = \\"3 7 8 3 6 1\\" expected = [3, 7, 8, 3, 6, 1] assert process_input(input_str) == expected def test_format_output(): results = [1, 1, 1, 0, 0, 0] expected = \\"1 1 1 0 0 0\\" assert format_output(results) == expected def test_integration(): input_str = \\"3 7 8 3 6 1\\" buildings = process_input(input_str) results = can_see_sunset(buildings) output_str = format_output(results) expected_output = \\"1 1 1 0 0 0\\" assert output_str == expected_output","solution":"def can_see_sunset(buildings): Determines if each building can see the sunset. Args: buildings (list): A list of integers representing the heights of buildings. Returns: list: A list of integers where 1 denotes that the respective building can see the sunset, and 0 otherwise. max_height = float('-inf') results = [] for height in buildings: if height > max_height: results.append(1) max_height = height else: results.append(0) return results def process_input(input_str): Processes the input string and converts it to a list of integers. Args: input_str (str): A space-separated string of integers representing building heights. Returns: list: A list of integers. return list(map(int, input_str.strip().split())) def format_output(results): Formats the output list into a space-separated string. Args: results (list): A list of integers. Returns: str: A space-separated string of integers. return ' '.join(map(str, results))"},{"question":"class ArrayOperations: def __init__(self, arr): self.arr = arr self.n = len(arr) def update(self, x, v): Update the value at index \`x\` to \`v\` in the array. Args: x (int): 1-based index to update. v (int): New value to set at index \`x\`. # Implement the update operation here def query(self, l, r): Compute the sum of the elements from index \`l\` to \`r\` inclusive. Args: l (int): 1-based starting index of the range. r (int): 1-based ending index of the range. Returns: int: Sum of the elements from index \`l\` to \`r\`. # Implement the query operation here def perform_operations(n, q, arr, operations): Perform a series of update and query operations on an array. Args: n (int): Size of the array. q (int): Number of operations. arr (list): Initial array of integers. operations (list): List of operation strings. Returns: list: Results of the query operations. array_operations = ArrayOperations(arr) result = [] for operation in operations: op_details = operation.split() op_type = int(op_details[0]) if op_type == 1: x = int(op_details[1]) v = int(op_details[2]) array_operations.update(x, v) elif op_type == 2: l = int(op_details[1]) r = int(op_details[2]) result.append(array_operations.query(l, r)) return result from solution import perform_operations def test_sample_input(): n = 5 q = 3 arr = [1, 2, 3, 4, 5] operations = [\\"2 1 3\\", \\"1 3 10\\", \\"2 1 3\\"] assert perform_operations(n, q, arr, operations) == [6, 13] def test_update_query(): n = 4 q = 4 arr = [1, 3, 5, 7] operations = [\\"2 2 4\\", \\"1 4 10\\", \\"1 1 2\\", \\"2 1 4\\"] assert perform_operations(n, q, arr, operations) == [15, 20] def test_only_updates(): n = 3 q = 3 arr = [10, 20, 30] operations = [\\"1 1 15\\", \\"1 2 25\\", \\"1 3 35\\"] assert perform_operations(n, q, arr, operations) == [] def test_only_queries(): n = 3 q = 2 arr = [10, 20, 30] operations = [\\"2 1 2\\", \\"2 2 3\\"] assert perform_operations(n, q, arr, operations) == [30, 50] def test_large_values(): n = 2 q = 2 arr = [10**9, 10**9] operations = [\\"2 1 2\\", \\"1 1 1\\"] assert perform_operations(n, q, arr, operations) == [2 * 10**9]","solution":"class ArrayOperations: def __init__(self, arr): self.arr = arr self.n = len(arr) def update(self, x, v): if 1 <= x <= self.n: self.arr[x - 1] = v def query(self, l, r): if 1 <= l <= r <= self.n: return sum(self.arr[l - 1:r]) def perform_operations(n, q, arr, operations): array_operations = ArrayOperations(arr) result = [] for operation in operations: op_details = operation.split() op_type = int(op_details[0]) if op_type == 1: x = int(op_details[1]) v = int(op_details[2]) array_operations.update(x, v) elif op_type == 2: l = int(op_details[1]) r = int(op_details[2]) result.append(array_operations.query(l, r)) return result"},{"question":"def determine_winner(t: int, test_cases: List[Tuple[int, int, int, int, int, Set[Tuple[int, int]]]]) -> List[str]: Determine the winner of each game if both Alice and Bob play optimally. >>> determine_winner(2, [(3, 3, 2, 2, 1, {(1, 2)}), (2, 2, 1, 1, 4, {(1, 2), (2, 1), (2, 2), (3, 3)})]) [\\"Alice\\", \\"Bob\\"] >>> determine_winner(1, [(3, 3, 2, 2, 0, set())]) [\\"Alice\\"]","solution":"def determine_winner(t, test_cases): results = [] for case in test_cases: n, m, x, y, f, forbidden_cells = case # Any move to a forbidden or already visited cell loses the game immediately for optimal players # This means optimal players will avoid these cells and try to force the other into them # Initial moves available for Alice are four directions initial_moves = 0 if (x - 1 > 0) and ((x - 1, y) not in forbidden_cells): initial_moves += 1 if (x + 1 <= n) and ((x + 1, y) not in forbidden_cells): initial_moves += 1 if (y - 1 > 0) and ((x, y - 1) not in forbidden_cells): initial_moves += 1 if (y + 1 <= m) and ((x, y + 1) not in forbidden_cells): initial_moves += 1 # If Alice has no initial moves, Bob wins immediately if initial_moves == 0: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results # Parsing and preparing input def main(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] line_index = 1 for _ in range(t): n, m = map(int, lines[line_index].split()) x, y = map(int, lines[line_index + 1].split()) f = int(lines[line_index + 2]) forbidden_cells = set() for i in range(f): a, b = map(int, lines[line_index + 3 + i].split()) forbidden_cells.add((a, b)) test_cases.append((n, m, x, y, f, forbidden_cells)) line_index += 3 + f result = determine_winner(t, test_cases) return \\"n\\".join(result)"},{"question":"def is_path_sum_divisible_by_k(grid: List[List[int]], rows: int, columns: int, k: int) -> str: Determine if there is a path from the top-left to the bottom-right of the grid, where the sum of the path is divisible by k. >>> is_path_sum_divisible_by_k([[5, 2, 1], [1, 3, 2], [1, 1, 2]], 3, 3, 5) 'YES' >>> is_path_sum_divisible_by_k([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, 10) 'NO'","solution":"def is_path_sum_divisible_by_k(grid, rows, columns, k): # dp will store sets of possible sums modulo k for each position dp = [[set() for _ in range(columns)] for _ in range(rows)] dp[0][0].add(grid[0][0] % k) for r in range(rows): for c in range(columns): if r > 0: for prev_sum in dp[r-1][c]: dp[r][c].add((prev_sum + grid[r][c]) % k) if c > 0: for prev_sum in dp[r][c-1]: dp[r][c].add((prev_sum + grid[r][c]) % k) return \\"YES\\" if 0 in dp[rows-1][columns-1] else \\"NO\\""},{"question":"def longest_consecutive_subsequence(n: int, nums: List[int]) -> int: Find the length of the longest consecutive subsequence in a given array. >>> longest_consecutive_subsequence(7, [100, 4, 200, 1, 3, 2, 3]) 4 >>> longest_consecutive_subsequence(6, [36, 41, 56, 35, 44, 33, 34, 90, 32, 42]) 5 >>> longest_consecutive_subsequence(0, []) 0 >>> longest_consecutive_subsequence(1, [10]) 1 >>> longest_consecutive_subsequence(5, [5, 5, 5, 5, 5]) 1 >>> longest_consecutive_subsequence(7, [7, 6, 5, 4, 3, 2, 1]) 7 >>> longest_consecutive_subsequence(8, [10, 20, 30, 40, 31, 21, 11, 50]) 2","solution":"def longest_consecutive_subsequence(n, nums): if n == 0: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # Check if it's the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def three_sum_exists(nums: List[int], target: int) -> bool: Determine if there exist any three numbers in the array whose sum equals the target value. :param nums: List[int], the list of integers. :param target: int, the target sum. :return: bool, whether such a triplet exists. >>> three_sum_exists([1, 2, 3, 4, 5, 6], 12) True >>> three_sum_exists([1, 1, 1, 1, 1], 10) False pass","solution":"def three_sum_exists(nums, target): Determine if there exist any three numbers in the array whose sum equals the target value. :param nums: List[int], the list of integers. :param target: int, the target sum. :return: bool, whether such a triplet exists. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def min_operations_to_equal_elements(arr: List[int]) -> int: Given a list of non-negative integers, find the minimum number of increment or decrement operations required to make all elements in the array equal. >>> min_operations_to_equal_elements([1, 2, 3]) == 2 >>> min_operations_to_equal_elements([10]) == 0 >>> min_operations_to_equal_elements([10, 10, 10, 10]) == 0 >>> min_operations_to_equal_elements([1, 1000000]) == 999999 >>> min_operations_to_equal_elements([1, 2, 3, 4]) == 4 >>> min_operations_to_equal_elements([]) == 0 pass","solution":"def min_operations_to_equal_elements(arr): Given a list of non-negative integers, find the minimum number of increment or decrement operations required to make all elements in the array equal. n = len(arr) if n == 0: return 0 # Step 1: Sort the array arr.sort() # Step 2: Find the median median = arr[n // 2] # Step 3: Calculate the total number of operations operations = sum(abs(x - median) for x in arr) return operations"},{"question":"from math import comb def num_ways_to_place_tiles(n: int, m: int, k: int) -> int: Calculate the number of ways to place exactly k non-overlapping 1x1 tiles on a n x m grid. Parameters: - n: number of rows (1 ≤ n ≤ 1000) - m: number of columns (1 ≤ m ≤ 1000) - k: number of tiles to be placed (0 ≤ k ≤ n * m) Returns: - The number of distinct ways to place exactly k non-overlapping 1x1 tiles. >>> num_ways_to_place_tiles(3, 3, 2) 36 >>> num_ways_to_place_tiles(1, 5, 3) 10 >>> num_ways_to_place_tiles(5, 1, 3) 10 >>> num_ways_to_place_tiles(2, 2, 4) 1 >>> num_ways_to_place_tiles(20, 30, 0) 1 >>> num_ways_to_place_tiles(3, 3, 9) 1 >>> num_ways_to_place_tiles(1000, 1000, 0) 1 >>> num_ways_to_place_tiles(1000, 1000, 1000000) 1","solution":"from math import comb def num_ways_to_place_tiles(n, m, k): Calculate the number of ways to place exactly k non-overlapping 1x1 tiles on a n x m grid. Parameters: - n: number of rows (1 ≤ n ≤ 1000) - m: number of columns (1 ≤ m ≤ 1000) - k: number of tiles to be placed (0 ≤ k ≤ n * m) Returns: - The number of distinct ways to place exactly k non-overlapping 1x1 tiles. total_cells = n * m return comb(total_cells, k) # Example usage # n, m, k = 3, 3, 2 # print(num_ways_to_place_tiles(n, m, k)) # Output: 36"},{"question":"def count_k_palindromes(s: str, k: int) -> int: Count the number of substrings in \`s\` that are k-palindromes. A k-palindrome is a substring that can be transformed into a palindrome by changing at most \`k\` characters. :param s: The input string consisting of lowercase English letters. :param k: The maximum number of character changes allowed. :return: The number of k-palindrome substrings. >>> count_k_palindromes(\\"abba\\", 1) 10 >>> count_k_palindromes(\\"abc\\", 1) 6","solution":"def is_k_palindrome(sub, k): Check if the substring \`sub\` can be converted to a palindrome by changing at most \`k\` characters. l = len(sub) mismatch_count = 0 for i in range(l // 2): if sub[i] != sub[l - 1 - i]: mismatch_count += 1 if mismatch_count > k: return False return True def count_k_palindromes(s, k): Count the number of substrings in \`s\` that are k-palindromes. n = len(s) count = 0 for i in range(n): for j in range(i + 1, n + 1): if is_k_palindrome(s[i:j], k): count += 1 return count"},{"question":"def max_crystals(n: int, m: int, k: int, crystals: List[int]) -> int: Returns the maximum number of crystals possible by selecting exactly k cycles. :param n: int: Number of available cycles :param m: int: Number of crystals produced in each cycle :param k: int: Exact number of cycles to run :param crystals: List[int]: List of integers where the i-th integer represents the number of crystals in i-th cycle :return: int: Maximum number of crystals produced >>> max_crystals(7, 7, 3, [3, 7, 9, 2, 5, 8, 10]) 27 >>> max_crystals(5, 5, 2, [1, 2, 3, 4, 5]) 9 >>> max_crystals(2, 2, 1, [100, 150]) 150 >>> max_crystals(4, 4, 2, [10, 10, 10, 10]) 20 >>> max_crystals(1, 1, 1, [5]) 5 >>> max_crystals(10, 10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 40 >>> max_crystals(3, 3, 1, [1, 1, 1]) 1","solution":"def max_crystals(n, m, k, crystals): Returns the maximum number of crystals possible by selecting exactly k cycles. :param n: int: Number of available cycles :param m: int: Number of crystals produced in each cycle :param k: int: Exact number of cycles to run :param crystals: List[int]: List of integers where the i-th integer represents the number of crystals in i-th cycle :return: int: Maximum number of crystals produced # Sort the crystals list in descending order crystals_sorted = sorted(crystals, reverse=True) # Sum up the largest k elements to get maximum crystals return sum(crystals_sorted[:k])"},{"question":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def has_zero_sum_cycle(head: Node) -> bool: Determine if the circular linked list has a cycle with a sum of zero. Args: head (Node): Head of the circular linked list Returns: bool: True if there exists a cycle with a sum of zero, otherwise False. Examples: >>> node4 = Node(7) >>> node3 = Node(5, node4) >>> node2 = Node(-2, node3) >>> node1 = Node(3, node2) >>> node4.next = node1 >>> has_zero_sum_cycle(node1) False >>> node7 = Node(1) >>> node6 = Node(-4, node7) >>> node5 = Node(4, node6) >>> node4 = Node(1, node5) >>> node3 = Node(-3, node4) >>> node2 = Node(2, node3) >>> node1 = Node(1, node2) >>> node7.next = node1 >>> has_zero_sum_cycle(node1) True","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def has_zero_sum_cycle(head): Determine if a circular linked list has a cycle with a sum of zero. slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return False cycle_nodes = [] current = slow while True: cycle_nodes.append(current.value) current = current.next if current == slow: break for i in range(len(cycle_nodes)): current_sum = 0 for j in range(len(cycle_nodes)): current_sum += cycle_nodes[(i+j) % len(cycle_nodes)] if current_sum == 0: return True return False"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Given a list of non-negative integers, this function returns the length of the longest contiguous subarray where at most two distinct integers are present. Parameters: nums (List[int]): A list of non-negative integers. Returns: int: The length of the longest contiguous subarray with at most two distinct integers. Examples: >>> longest_subarray_with_two_distinct([1, 2, 1]) 3 >>> longest_subarray_with_two_distinct([0, 1, 2, 2]) 3 >>> longest_subarray_with_two_distinct([1, 2, 3, 2, 2]) 4 >>> longest_subarray_with_two_distinct([4, 4, 4, 4, 4]) 5 >>> longest_subarray_with_two_distinct([]) 0 >>> longest_subarray_with_two_distinct([1]) 1 >>> longest_subarray_with_two_distinct([2, 2]) 2 >>> longest_subarray_with_two_distinct([1, 2]) 2 >>> longest_subarray_with_two_distinct([3, 3, 3, 3, 3]) 5 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1, 2]) 6","solution":"def longest_subarray_with_two_distinct(nums): Given a list of non-negative integers, this function returns the length of the longest contiguous subarray where at most two distinct integers are present. from collections import defaultdict if not nums: return 0 left = 0 right = 0 max_len = 0 counts = defaultdict(int) while right < len(nums): counts[nums[right]] += 1 while len(counts) > 2: counts[nums[left]] -= 1 if counts[nums[left]] == 0: del counts[nums[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def fibonacci(n): Generate the Fibonacci sequence up to the n-th term. Parameters: n (int): The number of terms in the Fibonacci sequence to generate. Returns: list: A list containing the Fibonacci sequence up to the n-th term. Raises: ValueError: If n is a negative integer. Examples: >>> fibonacci(0) [] >>> fibonacci(1) [0] >>> fibonacci(5) [0, 1, 1, 2, 3]","solution":"def fibonacci(n): Generate the Fibonacci sequence up to the n-th term. Parameters: n (int): The number of terms in the Fibonacci sequence to generate. Returns: list: A list containing the Fibonacci sequence up to the n-th term. Raises: ValueError: If n is a negative integer. if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if n == 0: return [] if n == 1: return [0] sequence = [0, 1] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"def diagonal_sum_difference(matrix: List[List[int]]) -> int: Calculate the Diagonal Sum Difference (DSD) for a given n x n matrix. The DSD is the absolute difference between the sum of the primary diagonal and the sum of the secondary diagonal. >>> diagonal_sum_difference([ ... [11, 2, 4], ... [4, 5, 6], ... [10, 8, -12] ... ]) == 15 >>> diagonal_sum_difference([ ... [1, 2], ... [3, 4] ... ]) == 0 >>> diagonal_sum_difference([ ... [1] ... ]) == 0 >>> diagonal_sum_difference([ ... [2, 1], ... [1, 2] ... ]) == 2 >>> diagonal_sum_difference([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 0","solution":"def diagonal_sum_difference(matrix): n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"def can_rearrange_to_divisible_by_60(n: int) -> str: Determines if the digits of the integer n can be rearranged to form a number divisible by 60. >>> can_rearrange_to_divisible_by_60(1020) 'Yes' >>> can_rearrange_to_divisible_by_60(123) 'No'","solution":"def can_rearrange_to_divisible_by_60(n): Determines if the digits of the integer n can be rearranged to form a number divisible by 60. digits = list(str(n)) # Check if there is at least one '0' since the number must end in 0 to be divisible by 60 if '0' not in digits: return \\"No\\" # Check if the sum of the digits is divisible by 3 digit_sum = sum(int(d) for d in digits) if digit_sum % 3 != 0: return \\"No\\" # Check if there is at least one even number to ensure it can form a 2 multiple with zero if not any(int(d) % 2 == 0 for d in digits): return \\"No\\" return \\"Yes\\""},{"question":"def min_largest_sum(n: int, k: int, arr: List[int]) -> int: You are given an array of length n consisting of positive integers. Your task is to find the minimum possible value of the largest sum among k contiguous subarrays that the original array can be divided into. >>> min_largest_sum(5, 2, [7, 2, 5, 10, 8]) == 18 >>> min_largest_sum(1, 1, [10]) == 10 >>> min_largest_sum(4, 2, [2, 2, 2, 2]) == 4 >>> min_largest_sum(6, 6, [4, 3, 6, 8, 2, 1]) == 8 >>> min_largest_sum(6, 1, [4, 3, 6, 8, 2, 1]) == 24 >>> min_largest_sum(10, 5, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 2 >>> min_largest_sum(2, 2, [1, 2]) == 2 >>> min_largest_sum(2, 1, [1, 2]) == 3 >>> min_largest_sum(5, 5, [4, 2, 4, 2, 4]) == 4 >>> n = 100000; k = 1; arr = [1] * n; min_largest_sum(n, k, arr) == n","solution":"def min_largest_sum(n, k, arr): def can_split_with_max_sum(max_sum): current_sum = 0 subarrays = 1 for num in arr: if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split_with_max_sum(mid): right = mid else: left = mid + 1 return left"},{"question":"def reorder_l1_to_fit_l2(n: int, l1: List[int], l2: List[int]) -> Union[List[int], str]: Determines if it is possible to reorder the elements of l1 such that for every i, l1[i] is less than or equal to l2[i]. Args: n (int): the number of elements in the lists l1 (List[int]): first list of integers l2 (List[int]): second list of integers Returns: List[int]: the modified l1 list or str: \\"No solution\\" if no such reordering exists Example: >>> reorder_l1_to_fit_l2(5, [4, 5, 1, 2, 3], [5, 4, 4, 3, 2]) [1, 2, 3, 4, 5] >>> reorder_l1_to_fit_l2(3, [2, 7, 4], [3, 3, 3]) 'No solution' from typing import List, Union def test_possible_reordering(): assert reorder_l1_to_fit_l2(5, [4, 5, 1, 2, 3], [5, 4, 4, 3, 2]) == [1, 2, 3, 4, 5] assert reorder_l1_to_fit_l2(3, [1, 2, 3], [3, 3, 3]) == [1, 2, 3] assert reorder_l1_to_fit_l2(4, [7, 8, 3, 5], [10, 6, 7, 4]) == [3, 5, 7, 8] def test_no_solution_possible(): assert reorder_l1_to_fit_l2(3, [2, 7, 4], [3, 3, 3]) == \\"No solution\\" assert reorder_l1_to_fit_l2(2, [5, 6], [4, 4]) == \\"No solution\\"","solution":"def reorder_l1_to_fit_l2(n, l1, l2): Determines if l1 can be reordered so that l1[i] <= l2[i] for all i. Args: n : int : the number of elements in the lists l1 : list of int : first list of integers l2 : list of int : second list of integers Returns: list of int if reordering is possible, otherwise \\"No solution\\" l1.sort() l2.sort() for i in range(n): if l1[i] > l2[i]: return \\"No solution\\" return l1"},{"question":"def lexicographically_smallest_array(n: int, k: int, arr: List[int]) -> List[int]: Find the lexicographically smallest array possible after performing exactly k operations. >>> lexicographically_smallest_array(7, 3, [7, 6, 5, 8, 3, 4, 1]) [1, 3, 4, 5, 6, 7, 8] >>> lexicographically_smallest_array(1, 1, [5]) [5] >>> lexicographically_smallest_array(5, 1, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_array(4, 2, [4, 3, 2, 1]) [1, 2, 3, 4] >>> lexicographically_smallest_array(6, 3, [4, 3, 1, 5, 2, 6]) [1, 2, 3, 4, 5, 6]","solution":"def lexicographically_smallest_array(n, k, arr): arr.sort() return arr"},{"question":"def permute_with_no_coprime_adj(n: int, arr: List[int]) -> int: Calculate the number of valid permutations such that no two adjacent elements are coprime, modulo 10^9 + 7. >>> permute_with_no_coprime_adj(3, [6, 8, 12]) == 6 >>> permute_with_no_coprime_adj(3, [1, 2, 3]) == 0 >>> permute_with_no_coprime_adj(3, [10**9, 10**9-1, 10**9-2]) == 0 >>> permute_with_no_coprime_adj(3, [4, 4, 4]) == 6 >>> permute_with_no_coprime_adj(4, [2, 4, 8, 16]) == 24","solution":"import math from collections import defaultdict MOD = 10**9 + 7 def permute_with_no_coprime_adj(n, arr): def gcd(x, y): while y: x, y = y, x % y return x dp = [[0] * (1 << n) for _ in range(n)] for i in range(n): dp[i][1 << i] = 1 for mask in range(1 << n): for i in range(n): if not (mask & (1 << i)): continue for j in range(n): if mask & (1 << j) or gcd(arr[i], arr[j]) == 1: continue dp[j][mask | (1 << j)] += dp[i][mask] dp[j][mask | (1 << j)] %= MOD res = 0 full_mask = (1 << n) - 1 for i in range(n): res += dp[i][full_mask] res %= MOD return res"},{"question":"def count_unique_participants(n: int, names: List[str]) -> int: Given the number of registration records \`n\` and a list of names representing the participant names, return the number of unique participants. >>> count_unique_participants(5, [\\"Alice Johnson\\", \\"Bob Smith\\", \\"Alice Johnson\\", \\"Charlie Brown\\", \\"Bob Smith\\"]) == 3 >>> count_unique_participants(3, [\\"Alice Johnson\\", \\"Alice Johnson\\", \\"Alice Johnson\\"]) == 1 >>> count_unique_participants(0, []) == 0 >>> count_unique_participants(1, [\\"Alice Johnson\\"]) == 1","solution":"def count_unique_participants(n, names): Given the number of registration records \`n\` and a list of names representing the participant names, return the number of unique participants. unique_names = set(names) return len(unique_names)"},{"question":"def find_minimal_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Given the number of cities (n), number of roads (m), and a list of roads with costs (roads), this function returns the minimum possible total cost to ensure the connectivity of all cities. >>> find_minimal_cost(3, 3, [(1, 2, 4), (2, 3, 3), (1, 3, 5)]) 7 >>> find_minimal_cost(3, 3, [(1, 2, 2), (2, 3, 3), (1, 3, 6)]) 5 >>> find_minimal_cost(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 2), (2, 4, 3)]) 4 >>> find_minimal_cost(100, 99, [(i, i+1, i) for i in range(1, 100)]) sum(range(1, 100)) pass","solution":"def find_minimal_cost(n, m, roads): Given the number of cities (n), number of roads (m), and a list of roads with costs (roads), this function returns the minimum possible total cost to ensure the connectivity of all cities. # Sorting edges by their weight. roads.sort(key=lambda x: x[2]) # Helper function to find the root of a city def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to union two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Initially, each city is its own parent and has a rank of 0. parent = [i for i in range(n)] rank = [0] * n result = 0 # Initialize result e = 0 # Count of edges in the result i = 0 # Index of current edge # Number of edges in MST will be n-1 while e < n - 1: # Pick the smallest edge and increment the index for the next iteration u, v, w = roads[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) # If including this edge does not cause a cycle, include it in the result if x != y: e = e + 1 result = result + w union(parent, rank, x, y) return result"},{"question":"def sort_stamps(entries): Sorts a list of stamp catalog entries by year, then by country, then by code. Args: entries (list of str): The entries to sort, each in the format \\"country code year\\". Returns: list of str: The sorted list of entries. from solution import sort_stamps def test_sort_stamps(): input_data = [ \\"finland ab23c4 2001\\", \\"usa x12b3a 2003\\", \\"canada lmnop3 2001\\", \\"uk w2asf5 1999\\", \\"france qp58a 2003\\", ] expected_output = [ \\"uk w2asf5 1999\\", \\"canada lmnop3 2001\\", \\"finland ab23c4 2001\\", \\"france qp58a 2003\\", \\"usa x12b3a 2003\\", ] assert sort_stamps(input_data) == expected_output def test_sort_stamps_with_same_country_and_code(): input_data = [ \\"india abc123 2001\\", \\"india abc123 1999\\", \\"india abc123 2003\\", ] expected_output = [ \\"india abc123 1999\\", \\"india abc123 2001\\", \\"india abc123 2003\\", ] assert sort_stamps(input_data) == expected_output def test_sort_stamps_with_all_same_year(): input_data = [ \\"india bcd456 2000\\", \\"india abc123 2000\\", \\"india def789 2000\\", ] expected_output = [ \\"india abc123 2000\\", \\"india bcd456 2000\\", \\"india def789 2000\\", ] assert sort_stamps(input_data) == expected_output def test_sort_stamps_with_various_countries_and_years(): input_data = [ \\"india def789 2001\\", \\"nepal zxy987 2001\\", \\"bhutan dfg542 2001\\", \\"india abc123 2000\\", \\"nepal lmn654 1999\\", ] expected_output = [ \\"nepal lmn654 1999\\", \\"india abc123 2000\\", \\"bhutan dfg542 2001\\", \\"india def789 2001\\", \\"nepal zxy987 2001\\", ] assert sort_stamps(input_data) == expected_output","solution":"def sort_stamps(entries): Sorts a list of stamp catalog entries by year, then by country, then by code. Args: entries (list of str): The entries to sort, each in the format \\"country code year\\". Returns: list of str: The sorted list of entries. # Split each entry into components and convert the year to an integer for proper sorting. parsed_entries = [ (entry.split()[0], entry.split()[1], int(entry.split()[2])) for entry in entries ] # Sort by year, then by country, then by code sorted_entries = sorted(parsed_entries, key=lambda x: (x[2], x[0], x[1])) # Convert sorted entries back to original string format result = [\\"{} {} {}\\".format(country, code, year) for country, code, year in sorted_entries] return result"},{"question":"from collections import Counter def is_beautiful(s: str) -> str: Determines if a string is \\"beautiful\\" (can be rearranged to form a palindrome). Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". Examples: >>> is_beautiful(\\"a\\") \\"YES\\" >>> is_beautiful(\\"aa\\") \\"YES\\" >>> is_beautiful(\\"ab\\") \\"NO\\" >>> is_beautiful(\\"aabb\\") \\"YES\\" >>> is_beautiful(\\"aabbc\\") \\"YES\\" >>> is_beautiful(\\"abcde\\") \\"NO\\"","solution":"from collections import Counter def is_beautiful(s): Determines if a string is \\"beautiful\\" (can be rearranged to form a palindrome). Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". count = Counter(s) # A string can be rearranged to form a palindrome if at most one character has an odd count. odd_count = sum(1 for c in count.values() if c % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List def has_zero_sum_subarray(arr: List[int]) -> bool: Checks if there is a subarray in arr which sums to zero. >>> has_zero_sum_subarray([4, 2, -3, 1, 6]) True >>> has_zero_sum_subarray([4, 2, 3, 1, 6]) False >>> has_zero_sum_subarray([1, -1]) True def process_test_cases(test_cases: List[List[int]]) -> List[str]: Processes multiple test cases to check for zero sum subarrays. >>> process_test_cases([[4, 2, -3, 1, 6], [4, 2, 3, 1, 6], [1, -1]]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([[1, 2, 3, 4, 5], [1, -1, -1, 1], [10, -10]]) [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def has_zero_sum_subarray(arr): Checks if there is a subarray in arr which sums to zero. prefix_sum_set = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in prefix_sum_set: return True prefix_sum_set.add(current_sum) return False def process_test_cases(test_cases): Processes multiple test cases to check for zero sum subarrays. results = [] for arr in test_cases: if has_zero_sum_subarray(arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maxLengthSubarray(arr: List[int], target: int) -> int: Returns the length of the longest contiguous subarray that sums to the target sum. If no such subarray exists, return 0. >>> maxLengthSubarray([1, -1, 5, -2, 3], 3) == 4 >>> maxLengthSubarray([-2, -1, 2, 1], 1) == 2","solution":"def maxLengthSubarray(arr, target): Returns the length of the longest contiguous subarray that sums to the target sum. If no such subarray exists, return 0. sum_indices = {0: -1} # Dictionary to store the first occurrence of each cumulative sum current_sum = 0 max_length = 0 for i, num in enumerate(arr): current_sum += num if current_sum - target in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - target]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"def count_unobstructed_views(n: int, heights: List[int]) -> int: Returns the number of buildings that have an unobstructed view of the sunrise. :param n: int - Number of buildings. :param heights: List[int] - Heights of the buildings. :return: int - Number of buildings with an unobstructed view of the sunrise. pass # Unit tests from solution import count_unobstructed_views def test_example(): assert count_unobstructed_views(6, [3, 2, 4, 1, 5, 2]) == 3 def test_all_same_height(): assert count_unobstructed_views(4, [2, 2, 2, 2]) == 1 def test_increasing_heights(): assert count_unobstructed_views(5, [1, 2, 3, 4, 5]) == 5 def test_decreasing_heights(): assert count_unobstructed_views(5, [5, 4, 3, 2, 1]) == 1 def test_mixed_heights(): assert count_unobstructed_views(7, [1, 3, 2, 4, 3, 5, 4]) == 4 def test_all_buildings_have_view(): assert count_unobstructed_views(3, [6, 6, 7]) == 2 def test_no_buildings(): assert count_unobstructed_views(0, []) == 0 def test_single_building(): assert count_unobstructed_views(1, [1]) == 1","solution":"def count_unobstructed_views(n, heights): Returns the number of buildings that have an unobstructed view of the sunrise. :param n: int - Number of buildings. :param heights: List[int] - Heights of the buildings. :return: int - Number of buildings with an unobstructed view of the sunrise. max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"def min_page_variance(n: int, k: int, pages: List[int]) -> int: Given the total number of books \`n\` and the number of books to read \`k\`, as well as the list of pages in each book \`pages\`, returns the minimum possible difference between the maximum and minimum number of pages among the \`k\` books Emily chooses to read. >>> min_page_variance(5, 3, [10, 20, 30, 40, 50]) 20 >>> min_page_variance(6, 2, [100, 200, 300, 400, 500, 600]) 100 >>> min_page_variance(7, 3, [1, 2, 3, 4, 5, 6, 7]) 2 >>> min_page_variance(4, 4, [15, 10, 20, 25]) 15 >>> min_page_variance(5, 5, [1, 4, 7, 12, 100]) 99 >>> min_page_variance(1, 1, [42]) 0","solution":"def min_page_variance(n, k, pages): Given the total number of books \`n\` and the number of books to read \`k\`, as well as the list of pages in each book \`pages\`, returns the minimum possible difference between the maximum and minimum number of pages among the \`k\` books Emily chooses to read. # Sort the list of pages pages.sort() # Initialize the minimum variance to a large number min_variance = float('inf') # Iterate through the sorted pages list with a window of size \`k\` for i in range(n - k + 1): current_variance = pages[i + k - 1] - pages[i] if current_variance < min_variance: min_variance = current_variance return min_variance"},{"question":"from typing import List def minimizeDifference(weights: List[int]) -> int: You are given a set of N gemstones, each with a unique weight. Your goal is to split these gemstones into two groups such that the absolute difference between the sum of the weights of the gemstones in the two groups is minimized. Write a function \`minimizeDifference(weights: List[int]) -> int\` that takes in a list of weights of the gemstones and returns an integer representing the smallest possible difference between the sums of the weights of the two groups. # Example: >>> minimizeDifference([2, 4, 5, 6]) 1 >>> minimizeDifference([1, 2, 3, 9]) 3 >>> minimizeDifference([20]) 20 pass def test_minimizeDifference_single_stone(): assert minimizeDifference([20]) == 20 def test_minimizeDifference_equal_stones(): assert minimizeDifference([2, 4, 5, 6]) == 1 def test_minimizeDifference_large_difference(): assert minimizeDifference([1, 2, 3, 9]) == 3 def test_minimizeDifference_two_equal_stones(): assert minimizeDifference([10, 10]) == 0 def test_minimizeDifference_mixed_stones(): assert minimizeDifference([1, 6, 11, 5]) == 1 def test_minimizeDifference_complex_case(): assert minimizeDifference([1, 5, 10, 20, 50]) == 14 def test_minimizeDifference_all_same_weight(): assert minimizeDifference([1, 1, 1, 1, 1]) == 1","solution":"def minimizeDifference(weights): n = len(weights) total_weight = sum(weights) target = total_weight // 2 # Initialize a DP array to store reachable weights dp = [0] * (target + 1) for weight in weights: # Traverse in reverse to avoid over-counting the same item for j in range(target, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) # The closest sum to half of total weight closest_sum = dp[target] # The other group's sum will be the total weight minus this group difference = abs(total_weight - 2 * closest_sum) return difference"},{"question":"def find_deleted_char(s: str, t: str) -> str: Returns the character deleted from string s to form string t. If no character was deleted, returns an empty string. >>> find_deleted_char(\\"abcd\\", \\"abc\\") \\"d\\" >>> find_deleted_char(\\"a\\", \\"\\") \\"a\\" >>> find_deleted_char(\\"abbc\\", \\"abc\\") \\"b\\" >>> find_deleted_char(\\"\\", \\"\\") \\"\\" >>> find_deleted_char(\\"abcd\\", \\"dcb\\") \\"a\\"","solution":"def find_deleted_char(s, t): Returns the character deleted from string s to form string t. If no character was deleted, returns an empty string. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in t: if char in char_count: char_count[char] -= 1 for char in char_count: if char_count[char] > 0: return char return ''"},{"question":"def encode_string(s: str, k: int) -> str: Encodes the input string by shifting each character k positions forward in the alphabet. The alphabet wraps around after 'z'. pass # Test cases def test_encode_string_with_k_2(): assert encode_string(\\"hello\\", 2) == \\"jgnnq\\" def test_encode_string_with_k_1(): assert encode_string(\\"world\\", 1) == \\"xpsme\\" def test_encode_string_at_alphabet_end(): assert encode_string(\\"xyz\\", 2) == \\"zab\\" def test_encode_string_wrapping_around(): assert encode_string(\\"abc\\", 3) == \\"def\\" def test_encode_string_full_alphabet(): assert encode_string(\\"abcdefghijklmnopqrstuvwxyz\\", 3) == \\"defghijklmnopqrstuvwxyzabc\\"","solution":"def encode_string(s: str, k: int) -> str: Encodes the input string by shifting each character k positions forward in the alphabet. The alphabet wraps around after 'z'. encoded_chars = [] for char in s: shifted_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) encoded_chars.append(shifted_char) return ''.join(encoded_chars)"},{"question":"def highest_average_score(scores: str) -> int: Calculate the highest average score among all players. Scores is a space-separated string of integers where each pair consists of a player identifier followed by a score. >>> highest_average_score(\\"1 50 2 60 1 40 2 80\\") 70 >>> highest_average_score(\\"1 50 1 60 1 70\\") 60 >>> highest_average_score(\\"1 50 2 50 1 50 2 50\\") 50 >>> highest_average_score(\\"1 50\\") 50 >>> highest_average_score(\\"1 10000 2 5000 1 10000 2 5000\\") 10000","solution":"def highest_average_score(scores): Calculate the highest average score among all players. Input: - scores: a space-separated string of integers. Output: - an integer representing the highest average score. from collections import defaultdict player_scores = defaultdict(list) scores_list = list(map(int, scores.split())) for i in range(0, len(scores_list), 2): player_id = scores_list[i] score = scores_list[i + 1] player_scores[player_id].append(score) max_average = 0 for player_id, scores in player_scores.items(): average_score = sum(scores) / len(scores) max_average = max(max_average, average_score) return int(max_average)"},{"question":"def count_unique_stamps(n: int, stamp_ids: List[int]) -> int: Returns the count of unique stamp types in Alyssa's collection. Parameters: n (int): The number of stamps. stamp_ids (List[int]): List of stamp IDs. Returns: int: Number of unique stamp types. >>> count_unique_stamps(7, [3, 5, 7, 3, 9, 5, 3]) 4 >>> count_unique_stamps(5, [1, 2, 3, 4, 5]) 5 >>> count_unique_stamps(5, [1, 1, 1, 1, 1]) 1","solution":"def count_unique_stamps(n, stamp_ids): Returns the count of unique stamp types. Parameters: n (int): The number of stamps. stamp_ids (list of int): List of stamp IDs. Returns: int: Number of unique stamp types. return len(set(stamp_ids))"},{"question":"def can_create_valid_route(m: int, r: int, p: int, restricted_pairs: List[Tuple[int, int]]) -> str: Determine if Alyssa and Ben can create a valid route that satisfies the restrictions. >>> can_create_valid_route(4, 3, 0, []) 'YES' >>> can_create_valid_route(4, 3, 2, [(1, 3), (2, 4)]) 'YES' >>> can_create_valid_route(3, 3, 3, [(1, 2), (2, 3), (1, 3)]) 'NO'","solution":"def can_create_valid_route(m, r, p, restricted_pairs): from itertools import permutations # Generate all possible permutations of length r all_routes = permutations(range(1, m + 1), r) # Convert restricted pairs into a set of tuples for fast lookup restricted_set = set((a, b) for a, b in restricted_pairs) # Check if any route is valid for route in all_routes: valid_route = True for i in range(r - 1): if (route[i], route[i + 1]) in restricted_set or (route[i + 1], route[i]) in restricted_set: valid_route = False break if valid_route: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def is_beautiful(s: str) -> bool: Returns True if the string can be rearranged such that no two adjacent characters are the same, otherwise False. >>> is_beautiful(\\"aabbcc\\") True >>> is_beautiful(\\"abab\\") True >>> is_beautiful(\\"aaab\\") False def count_beautiful_strings(n: int, strings: List[str]) -> int: Returns the number of beautiful strings in the given list of strings. >>> count_beautiful_strings(3, [\\"aabbcc\\", \\"abab\\", \\"aaab\\"]) 2 >>> count_beautiful_strings(1, [\\"a\\"]) 1 >>> count_beautiful_strings(2, [\\"aaa\\", \\"abac\\"]) 1","solution":"from collections import Counter def is_beautiful(s): Returns True if the string can be rearranged such that no two adjacent characters are the same, otherwise False. counter = Counter(s) max_freq = max(counter.values()) # The condition for a string to be beautiful is that the maximum frequency of any character # should not be more than (len(s) + 1) // 2 return max_freq <= (len(s) + 1) // 2 def count_beautiful_strings(n, strings): Returns the number of beautiful strings in the given list of strings. return sum(is_beautiful(s) for s in strings)"},{"question":"from typing import List def max_length_two_distinct(s: str) -> int: Returns the maximum length of a substring containing at most two distinct characters. >>> max_length_two_distinct(\\"eceba\\") == 3 >>> max_length_two_distinct(\\"ccaabbb\\") == 5 >>> max_length_two_distinct(\\"a\\") == 1 >>> max_length_two_distinct(\\"ab\\") == 2 >>> max_length_two_distinct(\\"aaa\\") == 3 >>> max_length_two_distinct(\\"abcabcabc\\") == 2 def process_test_cases(t: int, strings: List[str]) -> List[int]: Processes multiple test cases. >>> process_test_cases(3, [\\"eceba\\", \\"ccaabbb\\", \\"abaccc\\"]) == [3, 5, 4] >>> process_test_cases(2, [\\"a\\", \\"bbbbb\\"]) == [1, 5] >>> process_test_cases(1, [\\"abcabcabc\\"]) == [2]","solution":"def max_length_two_distinct(s): Returns the maximum length of a substring containing at most two distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 hashmap = {} max_len = 2 while right < n: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len def process_test_cases(t, strings): results = [] for s in strings: results.append(max_length_two_distinct(s)) return results"},{"question":"def max_candies(n: int, candies: List[int]) -> int: Determine the maximum number of candies you can collect by planning your jumps optimally. >>> max_candies(5, [2, 3, 5, 7, 8]) 25 >>> max_candies(3, [1, 2, 3]) 6 >>> max_candies(5, [5, 1, 1, 1, 10]) 15 >>> max_candies(1, [10]) 10 >>> max_candies(4, [4, 4, 4, 4]) 16","solution":"def max_candies(n, candies): dp = [candies[i] for i in range(n)] for i in range(n): for j in range(i + 1, n): if candies[j] - candies[i] >= 0: dp[j] = max(dp[j], dp[i] + candies[j]) return max(dp)"},{"question":"def remove_duplicates(s: str) -> str: Remove all duplicate characters from the input string while preserving the order of the first occurrence of each character and return the resulting string. >>> remove_duplicates(\\"programming\\") 'progamin' >>> remove_duplicates(\\"abacabadabacaba\\") 'abcd' >>> remove_duplicates(\\"hello\\") 'helo'","solution":"def remove_duplicates(s: str) -> str: Returns the input string with duplicates removed, keeping only the first occurrence of each character. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"class QueryProcessor: def __init__(self, array): Initialize the query processor with the given array. self.array = array def update(self, x: int, v: int) -> None: Update the element at position x to v. pass def sum_range(self, l: int, r: int) -> int: Return the sum of the elements from index l to r. pass def process_queries(self, queries: List[List[int]]) -> List[int]: Process a list of queries and return the results of sum queries. pass def process_input(data: str) -> str: Process the input data and return the results of the queries. pass # Unit Test def test_update_and_sum(): data = 5 3 1 2 3 4 5 2 1 3 1 2 10 2 2 4 expected_output = \\"6n17\\" assert process_input(data) == expected_output def test_full_range_query(): data = 5 2 1 1 1 1 1 2 1 5 2 1 3 expected_output = \\"5n3\\" assert process_input(data) == expected_output def test_single_update_query(): data = 5 2 10 20 30 40 50 1 3 100 2 1 5 expected_output = \\"220\\" assert process_input(data) == expected_output def test_multiple_updates(): data = 4 4 1 2 3 4 1 1 10 1 2 20 1 3 30 2 1 4 expected_output = \\"64\\" assert process_input(data) == expected_output def test_single_element_range_query(): data = 5 1 5 10 15 20 25 2 3 3 expected_output = \\"15\\" assert process_input(data) == expected_output","solution":"class QueryProcessor: def __init__(self, array): self.array = array def update(self, x, v): self.array[x - 1] = v def sum_range(self, l, r): return sum(self.array[l - 1:r]) def process_queries(self, queries): results = [] for query in queries: if query[0] == 1: self.update(query[1], query[2]) elif query[0] == 2: results.append(self.sum_range(query[1], query[2])) return results def process_input(data): lines = data.strip().split(\\"n\\") n, q = map(int, lines[0].split()) array = list(map(int, lines[1].split())) queries = [list(map(int, line.split())) for line in lines[2:]] qp = QueryProcessor(array) result = qp.process_queries(queries) return \\"n\\".join(map(str, result))"},{"question":"def longest_palindromic_prime_subsequence(n: int, arr: List[int]) -> int: Finds the length of the longest sub-sequence of a given list of integers that forms a palindromic prime sequence. >>> longest_palindromic_prime_subsequence(6, [2, 3, 5, 7, 11, 13]) == 0 >>> longest_palindromic_prime_subsequence(7, [2, 3, 5, 3, 7, 11, 7]) == 3 from solution import longest_palindromic_prime_subsequence def test_no_primes(): assert longest_palindromic_prime_subsequence(6, [4, 6, 8, 9, 10, 12]) == 0 def test_no_palindrome_with_primes(): assert longest_palindromic_prime_subsequence(6, [2, 3, 5, 7, 11, 13]) == 1 def test_single_prime_sequence(): assert longest_palindromic_prime_subsequence(1, [7]) == 1 def test_simple_palindrome(): assert longest_palindromic_prime_subsequence(7, [2, 3, 5, 3, 7, 11, 7]) == 3 def test_mixed_sequence(): assert longest_palindromic_prime_subsequence(9, [10, 2, 5, 2, 3, 5, 3, 2, 10]) == 5 def test_no_prime_in_palindrome(): assert longest_palindromic_prime_subsequence(3, [4, 6, 4]) == 0 def test_palindromic_primes_subsequence(): assert longest_palindromic_prime_subsequence(9, [2, 3, 5, 7, 5, 3, 2, 11, 13]) == 7","solution":"def is_prime(num): if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i != 0: continue return False return True def longest_palindromic_prime_subsequence(n, arr): primes = [num for num in arr if is_prime(num)] if not primes: return 0 def longest_palindromic_subseq_length(sequence): length = len(sequence) dp = [[0] * length for _ in range(length)] for i in range(length): dp[i][i] = 1 for sub_len in range(2, length + 1): for i in range(length - sub_len + 1): j = i + sub_len - 1 if sequence[i] == sequence[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][-1] return longest_palindromic_subseq_length(primes)"},{"question":"def max_disjoint_trees(n, m, edges): Returns the maximum number of disjoint trees (connected components without cycles) that can be formed in the reef with n sections and m potential paths. Args: n (int): Number of sections m (int): Number of potential paths edges (List[Tuple[int, int]]): List of potential paths Returns: int: Maximum number of disjoint trees >>> max_disjoint_trees(4, 0, []) 4 >>> max_disjoint_trees(4, 2, [(1, 2), (3, 4)]) 2 >>> max_disjoint_trees(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5)]) 1 >>> max_disjoint_trees(7, 5, [(1, 2), (1, 3), (4, 5), (5, 6), (6, 7)]) 2 >>> max_disjoint_trees(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 1 >>> max_disjoint_trees(8, 4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> max_disjoint_trees(3, 3, [(1, 1), (2, 2), (3, 3)]) 3 >>> max_disjoint_trees(5, 2, [(1, 2), (3, 4)]) 3 pass","solution":"def max_disjoint_trees(n, m, edges): Returns the maximum number of disjoint trees (connected components without cycles) that can be formed in the reef with n sections and m potential paths. # Helper function to perform DFS and mark all reachable nodes. def dfs(node, visited, adj): stack = [node] while stack: curr = stack.pop() for neighbor in adj[curr]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) if m == 0: return n # If there are no edges, each node is its own disjoint tree # Create adjacency list adj = {i: [] for i in range(1, n + 1)} for u, v in edges: adj[u].append(v) adj[v].append(u) # Find all disjoint trees using DFS visited = set() num_trees = 0 for node in range(1, n + 1): if node not in visited: num_trees += 1 visited.add(node) dfs(node, visited, adj) return num_trees"},{"question":"def longest_common_subsequence(a: str, b: str) -> str: Returns the longest common subsequence between strings a and b. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 'ace' >>> longest_common_subsequence(\\"abc\\", \\"def\\") '' >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 'abc' >>> longest_common_subsequence(\\"xyz\\", \\"abc\\") '' >>> longest_common_subsequence(\\"abcdxyz\\", \\"xyzabcd\\") 'abcd' >>> longest_common_subsequence(\\"a\\", \\"a\\") 'a' >>> longest_common_subsequence(\\"a\\", \\"b\\") '' >>> longest_common_subsequence(\\"abcdefghij\\", \\"cdgi\\") 'cdgi' >>> longest_common_subsequence(\\"blueribbon\\", \\"rib\\") 'rib' pass","solution":"def longest_common_subsequence(a: str, b: str) -> str: Returns the longest common subsequence between strings a and b. m, n = len(a), len(b) # Create a 2D array to store the length of LCS up to each pair of indices dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the LCS from the dp array i, j = m, n lcs = [] while i > 0 and j > 0: if a[i - 1] == b[j - 1]: lcs.append(a[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 # Reverse the lcs list as we constructed it from the end lcs.reverse() return ''.join(lcs)"},{"question":"from typing import List, Tuple def sort_books(books: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of books by genre first and then by publication year within each genre. Parameters: books (list of tuples): A list where each tuple contains the genre (str) and the publication year (int) of a book. Returns: list of tuples: The sorted list of books. >>> sort_books([(\\"Fiction\\", 1995), (\\"Non-Fiction\\", 2002), (\\"Fiction\\", 1987), (\\"Non-Fiction\\", 1998), (\\"Fiction\\", 1991), (\\"Non-Fiction\\", 1995)]) [('Fiction', 1987), ('Fiction', 1991), ('Fiction', 1995), ('Non-Fiction', 1995), ('Non-Fiction', 1998), ('Non-Fiction', 2002)] >>> sort_books([(\\"Sci-Fi\\", 2001), (\\"Sci-Fi\\", 1999), (\\"Sci-Fi\\", 2010)]) [('Sci-Fi', 1999), ('Sci-Fi', 2001), ('Sci-Fi', 2010)] >>> sort_books([(\\"Mystery\\", 2000), (\\"Fiction\\", 2000), (\\"Non-Fiction\\", 2000)]) [('Fiction', 2000), ('Mystery', 2000), ('Non-Fiction', 2000)] >>> sort_books([]) [] >>> sort_books([(\\"Romance\\", 1990)]) [('Romance', 1990)]","solution":"def sort_books(books): Sorts a list of books by genre first and then by publication year within each genre. Parameters: books (list of tuples): A list where each tuple contains the genre (str) and the publication year (int) of a book. Returns: list of tuples: The sorted list of books. return sorted(books, key=lambda x: (x[0], x[1]))"},{"question":"def minimum_maximum_difficulty(segments: List[Tuple[int, int]]) -> int: Returns the minimum possible maximum difficulty of any segment on the chosen path to the summit. segments: List of tuples [(length, difficulty), ...] representing each segment. >>> minimum_maximum_difficulty([(5, 3), (2, 5), (1, 2), (3, 4), (4, 3)]) 2 >>> minimum_maximum_difficulty([(5, 3), (2, 5), (1, 1), (3, 4), (4, 3)]) 1 >>> minimum_maximum_difficulty([(1, 10), (1, 9), (1, 8)]) 8 >>> minimum_maximum_difficulty([(10, 1)]) 1 >>> minimum_maximum_difficulty([(1, 5), (1, 7), (1, 5)]) 5","solution":"def minimum_maximum_difficulty(segments): Returns the minimum possible maximum difficulty of any segment on the chosen path to the summit. segments: List of tuples [(length, difficulty), ...] representing each segment. return min(difficulty for length, difficulty in segments)"},{"question":"from typing import List def min_moves_to_satisfy(arr: List[int]) -> int: Given an array of integers representing the heights of buildings in a row, find the minimum number of moves required to ensure that for every three consecutive buildings, the middle building is either the tallest or the shortest among the three. A move consists of increasing or decreasing the height of a building by 1 unit. Args: arr (List[int]): List of integers representing building heights. Returns: int: Minimum number of moves required. Examples: >>> min_moves_to_satisfy([5, 2, 6, 3, 4, 7]) 2 >>> min_moves_to_satisfy([3, 1, 3, 1, 3]) 0 def test_min_moves_to_satisfy(): assert min_moves_to_satisfy([5, 2, 6, 3, 4, 7]) == 2 assert min_moves_to_satisfy([3, 1, 3, 1, 3]) == 0 assert min_moves_to_satisfy([1, 2, 1, 2, 1]) == 0 assert min_moves_to_satisfy([1, 10, 1]) == 0 assert min_moves_to_satisfy([10, 1, 10]) == 0 assert min_moves_to_satisfy([1, 1000000, 1, 1000000, 1, 1000000, 1]) == 0 assert min_moves_to_satisfy([5, 4, 5, 4, 5, 4, 5]) == 0","solution":"def min_moves_to_satisfy(arr): n = len(arr) if n < 3: return 0 def calculate_moves(h1, h2, h3): Calculate moves needed to make h2 either the tallest or shortest among h1, h2, h3 if h2 > h1 and h2 > h3: return 0 elif h2 < h1 and h2 < h3: return 0 else: return min(abs(h2 - max(h1, h3)) + 1, abs(h2 - min(h1, h3)) + 1) total_moves = 0 for i in range(1, n - 1): moves = calculate_moves(arr[i - 1], arr[i], arr[i + 1]) total_moves += moves if moves > 0: if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: arr[i] = max(arr[i - 1], arr[i + 1]) + 1 elif arr[i] < arr[i - 1] and arr[i] < arr[i + 1]: arr[i] = min(arr[i - 1], arr[i + 1]) - 1 return total_moves"},{"question":"from typing import List def calculate_trapped_water(heights: List[int]) -> int: Calculate the total amount of rainwater trapped after rain. Each index in the list represents the height of the building at that position. >>> calculate_trapped_water([0, 2, 0, 3, 0, 4]) 5 >>> calculate_trapped_water([3, 0, 2, 0, 4]) 7 >>> calculate_trapped_water([0, 1, 0, 2]) 1 >>> calculate_trapped_water([1, 1, 1, 1]) 0 def test_no_buildings(): assert calculate_trapped_water([]) == 0 def test_single_building(): assert calculate_trapped_water([4]) == 0 def test_two_buildings(): assert calculate_trapped_water([3, 5]) == 0 def test_example_case_1(): assert calculate_trapped_water([0, 2, 0, 3, 0, 4]) == 5 def test_example_case_2(): assert calculate_trapped_water([3, 0, 2, 0, 4]) == 7 def test_example_case_3(): assert calculate_trapped_water([0, 1, 0, 2]) == 1 def test_example_case_4(): assert calculate_trapped_water([1, 1, 1, 1]) == 0 def test_mixed_heights(): assert calculate_trapped_water([2, 0, 2]) == 2 def test_increasing_heights(): assert calculate_trapped_water([1, 2, 3, 4, 5]) == 0 def test_decreasing_heights(): assert calculate_trapped_water([5, 4, 3, 2, 1]) == 0","solution":"from typing import List def calculate_trapped_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"from typing import List, Tuple def can_construct_from_s(s: str, t: str) -> bool: Determines if string t can be constructed by deleting some characters from s without rearranging. >>> can_construct_from_s(\\"abcde\\", \\"ace\\") True >>> can_construct_from_s(\\"axbycz\\", \\"abc\\") True >>> can_construct_from_s(\\"abcd\\", \\"bce\\") False # Implement the function here pass def process_queries(queries: List[Tuple[str, str]]) -> List[str]: Processes multiple queries to determine if each t can be constructed from the respective s. >>> process_queries([(\\"abcde\\", \\"ace\\"), (\\"axbycz\\", \\"abc\\"), (\\"abcd\\", \\"bce\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_queries([(\\"abc\\", \\"abc\\"), (\\"abc\\", \\"abcd\\"), (\\"abca\\", \\"aa\\"), (\\"abca\\", \\"aaa\\")]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] # Implement the function here pass","solution":"def can_construct_from_s(s, t): Determines if string t can be constructed by deleting some characters from s without rearranging. iter_s = iter(s) return all(char in iter_s for char in t) def process_queries(queries): Processes multiple queries to determine if each t can be constructed from the respective s. results = [] for s, t in queries: if can_construct_from_s(s, t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def reconstruct_matrix(n, row_queries, col_queries): Reconstruct a matrix based on the given row and column sum queries. There are two types of queries you can make: 1. Row sum: For a given row index i (1 ≤ i ≤ n), you can ask for the sum of the elements in row i. 2. Column sum: For a given column index j (1 ≤ j ≤ n), you can ask for the sum of the elements in column j. Args: - n (int): The size of the matrix (n x n). - row_queries (list): Sum queries for each row. - col_queries (list): Sum queries for each column. Returns: - matrix (list of lists): The reconstructed matrix. Example: >>> reconstruct_matrix(1, [4], [4]) [[4]] >>> reconstruct_matrix(2, [8, 8], [8, 8]) [[4, 4], [4, 4]] >>> reconstruct_matrix(3, [12, 12, 12], [12, 12, 12]) [[4, 4, 4], [4, 4, 4], [4, 4, 4]] >>> reconstruct_matrix(2, [6, 6], [8, 8]) [[3, 3], [4, 4]] >>> reconstruct_matrix(4, [20, 20, 20, 20], [20, 20, 20, 20]) [[5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]]","solution":"def reconstruct_matrix(n, row_queries, col_queries): Reconstructs a matrix based on given row and column sum queries. Args: - n (int): The size of the matrix (n x n). - row_queries (list): Sum queries for each row. - col_queries (list): Sum queries for each column. Returns: - matrix (list of lists): The reconstructed matrix. matrix = [[0] * n for _ in range(n)] # Distribute the sums evenly for simplicity (given the constraint) row_sum = row_queries[0] // n col_sum = col_queries[0] // n # Fill the matrix with reasonable values considering uniform distribution for i in range(n): for j in range(n): if row_sum == col_sum: matrix[i][j] = row_sum else: # Create compatible row and column values matrix[i][j] = row_sum if i == 0 else col_sum return matrix"},{"question":"def is_one_edit_distance(s: str, t: str) -> str: Determine if two strings are one edit distance apart. >>> is_one_edit_distance(\\"ab\\", \\"abc\\") \\"Yes\\" >>> is_one_edit_distance(\\"abc\\", \\"ab\\") \\"Yes\\" >>> is_one_edit_distance(\\"abc\\", \\"abd\\") \\"Yes\\" >>> is_one_edit_distance(\\"a\\", \\"b\\") \\"Yes\\" >>> is_one_edit_distance(\\"abcdef\\", \\"abghij\\") \\"No\\" >>> is_one_edit_distance(\\"abc\\", \\"abc\\") \\"No\\" from solution import is_one_edit_distance def test_is_one_edit_distance_insert(): assert is_one_edit_distance(\\"ab\\", \\"abc\\") == \\"Yes\\" assert is_one_edit_distance(\\"a\\", \\"ba\\") == \\"Yes\\" assert is_one_edit_distance(\\"abc\\", \\"abxc\\") == \\"Yes\\" def test_is_one_edit_distance_delete(): assert is_one_edit_distance(\\"abc\\", \\"ab\\") == \\"Yes\\" assert is_one_edit_distance(\\"ab\\", \\"a\\") == \\"Yes\\" assert is_one_edit_distance(\\"abxc\\", \\"abc\\") == \\"Yes\\" def test_is_one_edit_distance_replace(): assert is_one_edit_distance(\\"abc\\", \\"abd\\") == \\"Yes\\" assert is_one_edit_distance(\\"a\\", \\"b\\") == \\"Yes\\" assert is_one_edit_distance(\\"abxd\\", \\"abcd\\") == \\"Yes\\" def test_is_one_edit_distance_no(): assert is_one_edit_distance(\\"abc\\", \\"abcde\\") == \\"No\\" assert is_one_edit_distance(\\"a\\", \\"a\\") == \\"No\\" assert is_one_edit_distance(\\"abcdef\\", \\"abghij\\") == \\"No\\" def test_is_one_edit_distance_same_length(): assert is_one_edit_distance(\\"abc\\", \\"xbc\\") == \\"Yes\\" assert is_one_edit_distance(\\"abc\\", \\"axc\\") == \\"Yes\\" assert is_one_edit_distance(\\"abc\\", \\"abx\\") == \\"Yes\\" def test_is_one_edit_distance_none_needed(): assert is_one_edit_distance(\\"abc\\", \\"abc\\") == \\"No\\" assert is_one_edit_distance(\\"abcd\\", \\"abcd\\") == \\"No\\" assert is_one_edit_distance(\\"a\\", \\"a\\") == \\"No\\"","solution":"def is_one_edit_distance(s, t): Determine if two strings are one edit distance apart. len_s, len_t = len(s), len(t) # Early exit if the length difference is greater than 1 if abs(len_s - len_t) > 1: return \\"No\\" # Ensure s is the shorter string if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s i, j, edit_found = 0, 0, False while i < len_s and j < len_t: if s[i] != t[j]: if edit_found: return \\"No\\" edit_found = True if len_s == len_t: i += 1 else: i += 1 j += 1 return \\"Yes\\" if edit_found or len_s != len_t else \\"No\\""},{"question":"from typing import List def top_customers(T: int, purchases: List[str], N: int) -> List[str]: Determine the top 'N' customers by total purchase value for each month. >>> top_customers(7, [ ... \\"2021-01-13 23 300\\", ... \\"2021-01-22 45 200\\", ... \\"2021-01-10 23 150\\", ... \\"2021-02-01 23 500\\", ... \\"2021-02-14 34 700\\", ... \\"2021-01-28 45 100\\", ... \\"2021-03-03 55 600\\", ... ], 2) [\\"2021-01-01\\", \\"23 450\\", \\"45 300\\", \\"2021-02-01\\", \\"34 700\\", \\"23 500\\", \\"2021-03-01\\", \\"55 600\\"] >>> top_customers(1, [\\"2022-04-23 123 1000\\"], 1) [\\"2022-04-01\\", \\"123 1000\\"] >>> top_customers(2, [\\"2021-06-15 1 500\\", \\"2021-06-15 2 500\\"], 2) [\\"2021-06-01\\", \\"1 500\\", \\"2 500\\"] >>> top_customers(4, [ ... \\"2021-12-01 7 100\\", ... \\"2021-12-02 8 300\\", ... \\"2021-12-03 9 200\\", ... \\"2021-12-04 10 500\\", ... ], 2) [\\"2021-12-01\\", \\"10 500\\", \\"8 300\\"] >>> top_customers(4, [ ... \\"2023-01-01 5 100\\", ... \\"2023-01-02 3 200\\", ... \\"2023-02-15 5 300\\", ... \\"2023-02-16 3 400\\", ... ], 1) [\\"2023-01-01\\", \\"3 200\\", \\"2023-02-01\\", \\"3 400\\"]","solution":"def top_customers(T, purchases, N): from collections import defaultdict from datetime import datetime import heapq # Dictionary to store customer spending per month. sales_data = defaultdict(lambda: defaultdict(int)) # Process each purchase and accumulate the total order value per customer per month. for purchase in purchases: date_str, customer_id, order_value = purchase.split() date = datetime.strptime(date_str, \\"%Y-%m-%d\\") year_month = date.strftime(\\"%Y-%m\\") customer_id = int(customer_id) order_value = int(order_value) sales_data[year_month][customer_id] += order_value # Result to store top N customers per month. result = [] for month in sorted(sales_data.keys()): month_customers = sales_data[month] # Use a heap to get top N customers efficiently top_customers = heapq.nlargest(N, month_customers.items(), key=lambda x: (x[1], -x[0])) result.append(month + \\"-01\\") for customer_id, total_value in top_customers: result.append(f\\"{customer_id} {total_value}\\") return result"},{"question":"def decode_message(n: int, encoded_message: str, k: int) -> str: Decodes a message given the length of the message n, the encoded message, and the shift value k using a basic substitution cipher. >>> decode_message(10, \\"xyzabcdef\\", 3) 'uvwxyzabc' >>> decode_message(4, \\"abcd\\", 2) 'yzab' >>> decode_message(5, \\"hello\\", 0) 'hello' >>> decode_message(26, \\"abcdefghijklmnopqrstuvwxyz\\", 1) 'zabcdefghijklmnopqrstuvwxy' >>> decode_message(1, \\"a\\", 25) 'b' >>> decode_message(5, \\"vwxyz\\", 5) 'qrstu'","solution":"def decode_message(n, encoded_message, k): Decodes a message given the length of the message n, the encoded message, and the shift value k using a basic substitution cipher. decoded_message = [] for char in encoded_message: # Calculate the original character by shifting back k positions original_char = chr((ord(char) - ord('a') - k) % 26 + ord('a')) decoded_message.append(original_char) return ''.join(decoded_message)"},{"question":"from typing import List, Tuple def minConferenceRooms(n: int, sessions: List[Tuple[int, int]]) -> int: Determine the minimum number of conference rooms required to host all sessions without overlap. Parameters: n (int): The number of sessions. sessions (list): A list of tuples, where each tuple contains the start and end time of a session. Returns: int: The minimum number of conference rooms required. >>> minConferenceRooms(3, [(1, 4), (2, 5), (9, 12)]) 2 >>> minConferenceRooms(3, [(1, 2), (3, 4), (5, 6)]) 1 >>> minConferenceRooms(3, [(1, 10), (2, 9), (3, 8)]) 3 >>> minConferenceRooms(1, [(1, 10)]) 1 >>> minConferenceRooms(4, [(1, 4), (3, 5), (2, 8), (6, 7)]) 3 >>> minConferenceRooms(2, [(1, 10), (1, 10)]) 2 >>> minConferenceRooms(0, []) 0","solution":"import heapq def minConferenceRooms(n, sessions): Determine the minimum number of conference rooms required to host all sessions without overlap. Parameters: n (int): The number of sessions. sessions (list): A list of tuples, where each tuple contains the start and end time of a session. Returns: int: The minimum number of conference rooms required. if not sessions: return 0 # Sort sessions by start time sessions.sort(key=lambda x: x[0]) # Min-heap to keep track of end times of ongoing sessions heap = [] # Add the first session's end time to the heap heapq.heappush(heap, sessions[0][1]) # Iterate over the remaining sessions for i in range(1, n): # If the current session starts after or when the earliest session ends if sessions[i][0] >= heap[0]: # Remove the session that ended the earliest heapq.heappop(heap) # Add the current session's end time to the heap heapq.heappush(heap, sessions[i][1]) # The size of the heap is the number of rooms required return len(heap)"},{"question":"def verify_badge_ID(initial_id: str, encoded_id: str, increments: List[int]) -> str: Verify if the encoded badge ID is correctly derived from the initial badge ID using the provided increments. :param initial_id: a string representing the initial badge ID :param encoded_id: a string representing the encoded badge ID :param increments: a list of integers representing the increments for each digit position :return: \\"Valid\\" if the encoded_id is correctly derived, otherwise \\"Invalid\\" pass # Example Usage initial_id = \\"12345\\" encoded_id = \\"34567\\" increments = [2, 2, 2, 2, 2] print(verify_badge_ID(initial_id, encoded_id, increments)) # Output: Valid # Unit Tests from solution import verify_badge_ID def test_valid_case(): assert verify_badge_ID(\\"12345\\", \\"34567\\", [2, 2, 2, 2, 2]) == \\"Valid\\" def test_invalid_case(): assert verify_badge_ID(\\"12345\\", \\"34566\\", [2, 2, 2, 2, 2]) == \\"Invalid\\" def test_with_wrap_around(): assert verify_badge_ID(\\"99999\\", \\"11111\\", [2, 2, 2, 2, 2]) == \\"Valid\\" def test_with_no_increment(): assert verify_badge_ID(\\"12345\\", \\"12345\\", [0, 0, 0, 0, 0]) == \\"Valid\\" def test_large_input(): assert verify_badge_ID( \\"1234567890\\" * 100, \\"2345678901\\" * 100, [1] * 1000 ) == \\"Valid\\" def test_another_wrap_around(): assert verify_badge_ID(\\"2345678901\\" * 100, \\"3456789012\\" * 100, [1] * 1000) == \\"Valid\\"","solution":"def verify_badge_ID(initial_id, encoded_id, increments): Verify if the encoded badge ID is correctly derived from the initial badge ID using the provided increments. :param initial_id: a string representing the initial badge ID :param encoded_id: a string representing the encoded badge ID :param increments: a list of integers representing the increments for each digit position :return: \\"Valid\\" if the encoded_id is correctly derived, otherwise \\"Invalid\\" for initial_digit, encoded_digit, increment in zip(initial_id, encoded_id, increments): expected_digit = (int(initial_digit) + int(increment)) % 10 if expected_digit != int(encoded_digit): return \\"Invalid\\" return \\"Valid\\" # Example Usage initial_id = \\"12345\\" encoded_id = \\"34567\\" increments = [2, 2, 2, 2, 2] print(verify_badge_ID(initial_id, encoded_id, increments)) # Output: Valid"},{"question":"def rearrange_books(n: int, k: int, pages: List[int]) -> List[int]: Rearranges the bookshelf by moving the first k books to the end. Parameters: - n: int, the number of books - k: int, the number of books to move from the beginning to the end - pages: list of int, the number of pages in each book Returns: - list of int, the rearranged number of pages pass # Unit tests def test_rearrange_books_case_1(): assert rearrange_books(5, 2, [100, 200, 300, 400, 500]) == [300, 400, 500, 100, 200] def test_rearrange_books_case_2(): assert rearrange_books(4, 1, [150, 250, 350, 450]) == [250, 350, 450, 150] def test_rearrange_books_case_3(): assert rearrange_books(6, 3, [120, 130, 140, 150, 160, 170]) == [150, 160, 170, 120, 130, 140] def test_rearrange_books_no_rearrange(): assert rearrange_books(3, 0, [100, 200, 300]) == [100, 200, 300] def test_rearrange_books_all_rearrange(): assert rearrange_books(3, 3, [100, 200, 300]) == [100, 200, 300] def test_rearrange_books_single_book(): assert rearrange_books(1, 1, [500]) == [500]","solution":"def rearrange_books(n, k, pages): Rearranges the bookshelf by moving the first k books to the end. Parameters: - n: int, number of books - k: int, number of books to move from the beginning to the end - pages: list of int, number of pages in each book Returns: - list of int, rearranged number of pages return pages[k:] + pages[:k]"},{"question":"from typing import List, Tuple def max_performance(skills: List[int]) -> Tuple[int, int]: Determine the maximum performance score a team can achieve and the number of distinct teams that can have this maximum performance score. >>> max_performance([5, 6, 7, 8, 9, 10]) == (27, 1) >>> max_performance([1, 2, 3, 4, 5, 6]) == (15, 1) >>> max_performance([12, 15, 10, 14, 13, 11]) == (42, 1)","solution":"from typing import List, Tuple def max_performance(skills: List[int]) -> Tuple[int, int]: # Sort the skills in descending order skills.sort(reverse=True) # The best team will have the top 3 skills max_performance_score = sum(skills[:3]) # Count the distinct teams that achieve the maximum performance score num_teams = 0 n = len(skills) for i in range(n-2): for j in range(i+1, n-1): for k in range(j+1, n): if sum([skills[i], skills[j], skills[k]]) == max_performance_score: num_teams += 1 return max_performance_score, num_teams"},{"question":"def min_remaining_length(arr: List[int]) -> int: Returns the minimum length of the array after removing adjacent even-odd pairs as described. Args: arr (List[int]): The array of integers. Returns: int: The minimum length of the array after possible removals. Examples: >>> min_remaining_length([1, 2, 3, 4, 5, 6]) 0 >>> min_remaining_length([1, 1, 2, 2, 3]) 1 >>> min_remaining_length([2, 4, 6, 8]) 4","solution":"def min_remaining_length(arr): Returns the minimum length of the array after removing adjacent even-odd pairs as described. stack = [] for num in arr: if stack and (stack[-1] % 2 != num % 2): stack.pop() else: stack.append(num) return len(stack) # Example usage # if __name__ == \\"__main__\\": # n = int(input()) # arr = list(map(int, input().split())) # print(min_remaining_length(arr))"},{"question":"def uniquePathsWithObstacles(grid: List[List[int]]) -> int: Given a two-dimensional grid of dimensions MxN representing a chessboard where some cells can have obstacles, find a path from the top-left cell (0, 0) to the bottom-right cell (M-1, N-1), moving strictly either down or to the right at each step, while avoiding obstacles. If there is no possible path, return -1. >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> uniquePathsWithObstacles(grid) 2 >>> grid = [ ... [0, 1], ... [0, 0] ... ] >>> uniquePathsWithObstacles(grid) 1 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> uniquePathsWithObstacles(grid) -1 from solution import uniquePathsWithObstacles def test_no_obstacle(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 6 # 6 ways def test_with_obstacle(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 2 # 2 ways def test_single_path(): grid = [ [0, 1], [0, 0] ] assert uniquePathsWithObstacles(grid) == 1 # 1 way def test_no_path(): grid = [ [0, 1], [1, 0] ] assert uniquePathsWithObstacles(grid) == -1 # No way def test_starting_cell_is_obstacle(): grid = [ [1, 0], [0, 0] ] assert uniquePathsWithObstacles(grid) == -1 # No way def test_all_obstacles(): grid = [ [0, 1, 0], [1, 1, 1], [0, 1, 0] ] assert uniquePathsWithObstacles(grid) == -1 # No way def test_large_grid(): grid = [[0]*100 for _ in range(100)] assert uniquePathsWithObstacles(grid) != -1 # There should be a number of ways","solution":"from typing import List def uniquePathsWithObstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1: return -1 M, N = len(grid), len(grid[0]) dp = [[0 for _ in range(N)] for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1] if dp[M-1][N-1] > 0 else -1"},{"question":"def guess_secret_year(): Interact with the system to guess the secret year in the range 1000 to 9999 inclusive. You can make up to 10 guesses, reading the feedback from the system after each guess. The function outputs a 4-digit year guess and reads the system's response, which consists of the number of matches and misplaced digits. The goal is to guess the correct year within 10 attempts. After printing each guess, use \`sys.stdout.flush()\` to avoid buffering issues. The response format is two integers: matches and misplaced. The function should terminate when the correct year is guessed (response \\"4 0\\") or after 10 attempts.","solution":"import sys def guess_secret_year(): # Define initial possible year and the range of guesses guess = 1000 # Number of attempts attempts = 0 while attempts < 10: # Output the guessed year print(guess) sys.stdout.flush() # Ensure we're not buffering outputs # Read response from the system response = input().strip() # Parse the response matches, misplaced = map(int, response.split()) # If all 4 digits match, we've found the secret year if matches == 4: return # Increment the guess and the number of attempts guess += 1 attempts += 1 if __name__ == \\"__main__\\": guess_secret_year()"},{"question":"def smallest_string_length(s: str) -> int: Returns the length of the smallest string possible after removing 'ab' or 'ba' >>> smallest_string_length(\\"ababbba\\") 1 >>> smallest_string_length(\\"aaaabbbb\\") 0 from solution import smallest_string_length def test_example1(): assert smallest_string_length(\\"ababbba\\") == 1 def test_example2(): assert smallest_string_length(\\"aaaabbbb\\") == 0 def test_empty_string(): assert smallest_string_length(\\"\\") == 0 def test_single_characters(): assert smallest_string_length(\\"a\\") == 1 assert smallest_string_length(\\"b\\") == 1 def test_long_string_no_removal(): assert smallest_string_length(\\"aaaaaa\\") == 6 assert smallest_string_length(\\"bbbbbb\\") == 6 def test_alternating_characters(): assert smallest_string_length(\\"abababab\\") == 0 def test_mixed_characters(): assert smallest_string_length(\\"aabbaabbab\\") == 0 assert smallest_string_length(\\"abbaaab\\") == 1 def test_large_input(): input_string = \\"ab\\" * 50000 # length 100000 assert smallest_string_length(input_string) == 0","solution":"def smallest_string_length(s): Returns the length of the smallest string possible after removing 'ab' or 'ba' stack = [] for char in s: if stack and ((stack[-1] == 'a' and char == 'b') or (stack[-1] == 'b' and char == 'a')): stack.pop() else: stack.append(char) return len(stack)"},{"question":"def findUniqueElement(nums: List[int]) -> int: Finds the element that appears only once in the list where every other element appears exactly three times. >>> findUniqueElement([2, 2, 3, 2]) 3 >>> findUniqueElement([0, 1, 0, 1, 0, 1, 99]) 99 >>> findUniqueElement([-1, -1, -1, -2]) -2 >>> findUniqueElement([1, 2, 3, 1, 2, 1, 2]) 3 >>> findUniqueElement([4, 4, 4, 5]) 5 >>> nums = [5] * 33333 + [7] * 33333 + [8] * 33333 + [4] >>> findUniqueElement(nums) 4","solution":"def findUniqueElement(nums): Finds the element that appears only once in the list where every other element appears exactly three times. Args: nums (list of int): The input list of integers. Returns: int: The element that appears only once. # Using bitwise operators to achieve constant extra space ones = 0 twos = 0 for num in nums: # update \`twos\` with \`ones & num\` masks twos |= ones & num # update \`ones\` with current num ones ^= num # remove \`threes\` from ones and twos where a number has appeared three times common_mask = ~(ones & twos) ones &= common_mask twos &= common_mask return ones"},{"question":"def longest_special_subsequence_length(s: str) -> int: Determine the length of the longest possible special subsequence from the given string s, where characters are non-repeating and in alphabetical order. >>> longest_special_subsequence_length(\\"abacbd\\") 4 >>> longest_special_subsequence_length(\\"aaaaa\\") 1 >>> longest_special_subsequence_length(\\"efghijk\\") 7","solution":"def longest_special_subsequence_length(s): Determine the length of the longest possible special subsequence from the given string s, where characters are non-repeating and in alphabetical order. last_seen = set() special_subsequence = [] for char in s: if char not in last_seen: if not special_subsequence or special_subsequence[-1] < char: special_subsequence.append(char) last_seen.add(char) return len(special_subsequence)"},{"question":"from typing import List, Tuple def manhattan_pairs(n: int, d: int, points: List[Tuple[int, int]]) -> int: Find the number of unique pairs of points with Manhattan distance equal to d. >>> manhattan_pairs(3, 1, [(0, 0), (0, 1), (1, 0)]) 2 >>> manhattan_pairs(3, 1, [(0, 0), (2, 2), (3, 3)]) 0 >>> manhattan_pairs(5, 1, [(0, 0), (0, 1), (1, 0), (1, 1), (1, 2)]) 5 >>> manhattan_pairs(3, 0, [(0, 0), (1, 1), (2, 2)]) 0 >>> manhattan_pairs(3, 1000000000, [(0, 0), (0, 1000000000), (1000000000, 0)]) 2","solution":"from collections import defaultdict def manhattan_pairs(n, d, points): count = defaultdict(int) result = 0 for x, y in points: result += count[(x + d, y)] + count[(x - d, y)] + count[(x, y + d)] + count[(x, y - d)] count[(x, y)] += 1 return result"},{"question":"from typing import List def unique_permutations(s: str) -> List[str]: Generate all unique permutations of the given string. Args: s (str): Input string Returns: List of unique permutations >>> unique_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] >>> unique_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]","solution":"from itertools import permutations def unique_permutations(s): Generate all unique permutations of the given string. Args: s (str): Input string Returns: List of unique permutations # Using itertools.permutations to generate permutations perms = set(permutations(s)) # Converting each permutation tuple back to string unique_list = [''.join(p) for p in perms] return sorted(unique_list)"},{"question":"def closest_star(star_records: List[str]) -> str: Given a list of strings representing star information, return the name of the star that is closest to Earth. If there is a tie (i.e., multiple stars at the same minimum distance), return the name of the star that appears first in the list. >>> closest_star([\\"AlphaCentauri:4\\", \\"BarnardsStar:6\\", \\"ProximaCentauri:4\\"]) 'AlphaCentauri' >>> closest_star([\\"Betelgeuse:642\\", \\"Sirius:8\\", \\"Vega:25\\"]) 'Sirius' >>> closest_star([\\"Sirius:8\\", \\"Betelgeuse:642\\", \\"Vega:25\\"]) 'Sirius' >>> closest_star([\\"AlphaCentauri:4\\"]) 'AlphaCentauri' pass","solution":"from typing import List def closest_star(star_records: List[str]) -> str: min_distance = float('inf') closest_star_name = \\"\\" for record in star_records: star_name, distance_str = record.split(\\":\\") distance = int(distance_str) if distance < min_distance: min_distance = distance closest_star_name = star_name return closest_star_name"},{"question":"from typing import List, Tuple def find_max_weight_in_subtree(n: int, weights: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: You are given a tree with \`n\` vertices, rooted at vertex \`1\`. Each vertex is assigned a positive integer weight. Your task is to process \`Q\` queries, where in each query you are given an integer \`v\` and you must find the vertex with the highest weight in the subtree of vertex \`v\`. Args: n (int): The number of vertices in the tree. weights (List[int]): A list of positive integer weights for each vertex. edges (List[Tuple[int, int]]): A list of edges representing the tree. queries (List[int]): A list of queries representing the subtree root for each query. Returns: List[int]: A list of integers representing the maximum weight in the subtree for each query. Example: >>> find_max_weight_in_subtree(5, [2, 3, 1, 10, 4], [(1, 2), (1, 3), (2, 4), (3, 5)], [1, 2, 3]) [10, 10, 4]","solution":"def find_max_weight_in_subtree(n, weights, edges, queries): from collections import defaultdict def dfs(node, parent): subtree_nodes[node] = [node] for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) subtree_nodes[node].extend(subtree_nodes[neighbor]) tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) subtree_nodes = {} dfs(1, -1) results = [] for v in queries: max_weight = max(weights[node-1] for node in subtree_nodes[v]) results.append(max_weight) return results"},{"question":"def minimum_steps(m: int, n: int, grid: List[List[int]]) -> int: Calculate the minimum number of steps required for the robot to reach the destination with the ability to remove at most one obstacle on its path. >>> minimum_steps(3, 3, [[0, 1, 0], [0, 1, 0], [1, 0, 0]]) 4 >>> minimum_steps(3, 3, [[0, 1, 1], [1, 1, 1], [1, 1, 0]]) -1","solution":"from collections import deque def minimum_steps(m, n, grid): Calculate the minimum number of steps required for the robot to reach the destination with the ability to remove at most one obstacle on its path. if grid[0][0] == 1 and grid[m-1][n-1] == 1: return -1 # Robot cannot start or end in an obstacle directions = [(1, 0), (0, 1)] # Only move right or down visited = [[[False, False] for _ in range(n)] for _ in range(m)] visited[0][0][0] = True queue = deque([(0, 0, 0, False)]) # (x, y, distance, used_obstacle_removal) while queue: x, y, dist, used_obstacle_removal = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 0 and not visited[nx][ny][used_obstacle_removal]: visited[nx][ny][used_obstacle_removal] = True queue.append((nx, ny, dist + 1, used_obstacle_removal)) elif grid[nx][ny] == 1 and not used_obstacle_removal and not visited[nx][ny][1]: visited[nx][ny][1] = True queue.append((nx, ny, dist + 1, True)) return -1"},{"question":"def can_form_palindrome(s: str) -> str: Determine if the characters of the string can be rearranged to form a palindrome. :param s: Input string containing only lowercase Latin letters. :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' >>> can_form_palindrome(\\"\\") 'YES' >>> can_form_palindrome(\\"a\\") 'YES'","solution":"def can_form_palindrome(s): Determine if the characters of the string can be rearranged to form a palindrome. :param s: Input string containing only lowercase Latin letters. :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def balance_accounts(n: int, initial: List[int], final: List[int]) -> List[Tuple[int, int, int]]: Generate the sequence of transactions needed to balance the accounts. Each transaction is represented as a tuple (sender, receiver, amount). Parameters: n (int): number of accounts initial (List[int]): initial balances of the accounts final (List[int]): desired final balances of the accounts Returns: List[Tuple[int, int, int]]: a list of transactions to balance the accounts >>> balance_accounts(3, [10, 50, 30], [30, 20, 40]) [(2, 1, 30), (3, 1, 10)] >>> balance_accounts(2, [20, 30], [10, 40]) [(2, 1, 10)] pass","solution":"def balance_accounts(n, initial, final): # Determine the amount each account needs to send or receive transactions = [] # Calculate the net cash flow needed for each account net_balances = [final[i] - initial[i] for i in range(n)] # Create lists of accounts that need to send or receive funds senders = [] receivers = [] for i in range(n): if net_balances[i] < 0: senders.append((i, abs(net_balances[i]))) elif net_balances[i] > 0: receivers.append((i, net_balances[i])) s_index, r_index = 0, 0 while s_index < len(senders) and r_index < len(receivers): s_acc, s_amount = senders[s_index] r_acc, r_amount = receivers[r_index] transfer_amount = min(s_amount, r_amount) transactions.append((s_acc + 1, r_acc + 1, transfer_amount)) senders[s_index] = (s_acc, s_amount - transfer_amount) receivers[r_index] = (r_acc, r_amount - transfer_amount) if senders[s_index][1] == 0: s_index += 1 if receivers[r_index][1] == 0: r_index += 1 return transactions"},{"question":"def is_path_possible(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from the top-left corner to the bottom-right corner of the grid, considering only land cells ('.') and not crossing water cells ('#'). >>> is_path_possible(5, 5, [\\".....\\", \\".#.\\", \\".#.\\", \\".#.\\", \\".....\\"]) 'YES' >>> is_path_possible(5, 5, [\\".....\\", \\"#\\", \\".#.\\", \\".#.\\", \\".....\\"]) 'NO' >>> is_path_possible(1, 1, [\\".\\"]) 'YES' >>> is_path_possible(1, 1, [\\"#\\"]) 'NO' >>> is_path_possible(2, 2, [\\"..\\", \\"..\\"]) 'YES' >>> is_path_possible(2, 2, [\\"#.\\", \\".#\\"]) 'NO' >>> is_path_possible(3, 3, [\\"#..\\", \\"...\\", \\"...\\"]) 'NO' >>> is_path_possible(3, 3, [\\"...\\", \\"...\\", \\"..#\\"]) 'NO'","solution":"def is_path_possible(n, m, grid): Determines if there is a path from the top-left corner to the bottom-right corner of the grid, considering only land cells ('.') and not crossing water cells ('#'). if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0)]) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def minimum_total_time(n: int, speeds: List[int]) -> float: Calculates the minimum total time required to finish the relay race. Parameters: n (int): The number of friends. speeds (list): A list of integers representing the speeds of the friends. Returns: float: The minimum total time, rounded to two decimal places. >>> minimum_total_time(2, [2, 3]) 0.83 >>> minimum_total_time(1, [5]) 0.20 >>> minimum_total_time(3, [1, 1, 1]) 3.00 >>> minimum_total_time(4, [2, 3, 4, 5]) 1.28 >>> minimum_total_time(3, [3, 6, 9]) 0.61 >>> minimum_total_time(5, [1, 2, 3, 4, 5]) 2.28 >>> speeds = [i+1 for i in range(100)] >>> minimum_total_time(100, speeds) 5.19 pass","solution":"def minimum_total_time(n, speeds): Calculates the minimum total time required to finish the relay race. Parameters: n (int): The number of friends. speeds (list): A list of integers representing the speeds of the friends. Returns: float: The minimum total time, rounded to two decimal places. total_time = sum(1/speed for speed in speeds) return round(total_time, 2)"},{"question":"def count_segments(encoded_highway: str) -> int: Given an encoded highway string, return the total number of segments. >>> count_segments(\\"S\\") 1 >>> count_segments(\\"(S+S)\\") 2 >>> count_segments(\\"(S*(S+S))\\") 2 >>> count_segments(\\"((S+S)*(S+S))\\") 4 >>> count_segments(\\"((S*(S+S))*(S+S))\\") 4 >>> count_segments(\\"((S+S)+(S+S))\\") 4 def process_queries(queries: List[str]) -> List[int]: Process a list of queries where each query is an encoded highway string and return a list of total number of segments for each query. >>> process_queries([\\"S\\", \\"(S+S)\\", \\"(S*(S+S))\\", \\"((S+S)*(S+S))\\"]) [1, 2, 2, 4]","solution":"def count_segments(encoded_highway): Given an encoded highway string, return the total number of segments. def evaluate(expression): # Base case when the expression is just 'S' if expression == 'S': return 1 stack = [] i = 0 while i < len(expression): if expression[i] == '(': stack.append(i) elif expression[i] == ')': start = stack.pop() internal_expression = expression[start + 1:i] if '*' in internal_expression: parts = internal_expression.split('*') count = evaluate(parts[0]) * evaluate(parts[1]) elif '+' in internal_expression: parts = internal_expression.split('+') count = evaluate(parts[0]) + evaluate(parts[1]) expression = expression[:start] + str(count) + expression[i + 1:] i = start i += 1 return int(expression) return evaluate(encoded_highway) def process_queries(queries): results = [] for query in queries: results.append(count_segments(query)) return results"},{"question":"class EmployeeDatabase: def __init__(self): self.employees = {} # A dictionary to hold employee records def add_employee(self, name, age, department): Add a new employee to the dataset with the given name, age, and department. >>> db = EmployeeDatabase() >>> db.add_employee(\\"alice\\", 30, \\"hr\\") pass def update_employee(self, name, age=None, department=None): Update the age or department or both of an existing employee, identified by their unique name. >>> db = EmployeeDatabase() >>> db.add_employee(\\"bob\\", 25, \\"finance\\") >>> db.update_employee(\\"bob\\", 26) >>> db.update_employee(\\"bob\\", department=\\"hr\\") pass def query_by_department(self, department): Given a department name, return a list of all employees in that department sorted lexicographically by their name. >>> db = EmployeeDatabase() >>> db.add_employee(\\"alice\\", 30, \\"hr\\") >>> db.add_employee(\\"bob\\", 25, \\"finance\\") >>> db.add_employee(\\"charlie\\", 23, \\"hr\\") >>> db.query_by_department(\\"hr\\") == [\\"alice\\", \\"charlie\\"] pass def query_by_age_range(self, min_age, max_age): Given an age range [min_age, max_age], return a list of all employees whose ages fall within this range, sorted lexicographically by their name. >>> db = EmployeeDatabase() >>> db.add_employee(\\"alice\\", 30, \\"hr\\") >>> db.add_employee(\\"bob\\", 25, \\"finance\\") >>> db.add_employee(\\"charlie\\", 23, \\"hr\\") >>> db.query_by_age_range(24, 30) == [\\"alice\\", \\"bob\\"] pass def process_operations(operations): Given a list of operations, perform the actions described and return the results. >>> operations = [ ... \\"ADD alice 30 hr\\", ... \\"ADD bob 25 finance\\", ... \\"ADD charlie 23 hr\\", ... \\"UPDATE alice 31 hr\\", ... \\"QUERY_DEPARTMENT hr\\", ... \\"QUERY_DEPARTMENT finance\\", ... \\"QUERY_AGE_RANGE 24 31\\" ... ] >>> process_operations(operations) == [ ... [\\"alice\\", \\"charlie\\"], ... [\\"bob\\"], ... [\\"alice\\", \\"bob\\"] ... ] pass","solution":"class EmployeeDatabase: def __init__(self): self.employees = {} # A dictionary to hold employee records def add_employee(self, name, age, department): self.employees[name] = {'age': age, 'department': department} def update_employee(self, name, age=None, department=None): if name in self.employees: if age is not None: self.employees[name]['age'] = age if department is not None: self.employees[name]['department'] = department def query_by_department(self, department): result = sorted([name for name, details in self.employees.items() if details['department'] == department]) return result def query_by_age_range(self, min_age, max_age): result = sorted([name for name, details in self.employees.items() if min_age <= details['age'] <= max_age]) return result # Function to process operations def process_operations(operations): db = EmployeeDatabase() results = [] for operation in operations: parts = operation.split() command = parts[0] if command == 'ADD': name, age, department = parts[1], int(parts[2]), parts[3] db.add_employee(name, age, department) elif command == 'UPDATE': name = parts[1] age = int(parts[2]) if parts[2] != '?' else None department = parts[3] if parts[3] != '?' else None db.update_employee(name, age, department) elif command == 'QUERY_DEPARTMENT': department = parts[1] result = db.query_by_department(department) results.append(result) elif command == 'QUERY_AGE_RANGE': min_age, max_age = int(parts[1]), int(parts[2]) result = db.query_by_age_range(min_age, max_age) results.append(result) return results"},{"question":"def participant_rank(scores: List[int], score: int) -> int: Determine the rank of a participant based on their score compared to others. Args: scores (list of int): List of scores of all participants. score (int): Score of the participant whose rank is to be determined. Returns: int: Rank of the participant with the given score. Examples: >>> participant_rank([100, 50, 100, 75], 75) 3 >>> participant_rank([55, 30, 30, 75, 95, 85, 85], 30) 6","solution":"def participant_rank(scores, score): Determine the rank of a participant based on their score compared to others. Args: scores (list of int): List of scores of all participants. score (int): Score of the participant whose rank is to be determined. Returns: int: Rank of the participant with the given score. sorted_scores = sorted(scores, reverse=True) rank = 1 for i, s in enumerate(sorted_scores): if (i > 0 and s != sorted_scores[i-1]): rank = i + 1 if s == score: return rank"},{"question":"def sum_alternating_series(series: List[int]) -> int: Computes the sum of an alternating series of numbers. Given a series of integers, the function returns the sum where the sign of each element alternates, starting with a positive sign for the first element. Args: series (List[int]): A list of integers. Returns: int: The sum of the alternating series. Examples: >>> sum_alternating_series([5, 3, 8, 6, 2]) == 5 - 3 + 8 - 6 + 2 >>> sum_alternating_series([-1, -2, -3, -4, -5]) == -1 + 2 - 3 + 4 - 5 >>> sum_alternating_series([1]) == 1 >>> sum_alternating_series([10, -10, 10, -10]) == 10 + 10 + 10 + 10 >>> sum_alternating_series([42, 56, 78, 90]) == 42 - 56 + 78 - 90","solution":"from typing import List def sum_alternating_series(series: List[int]) -> int: Given a series of integers, this function computes the sum where the sign of each element alternates, starting with a positive sign for the first element. total_sum = 0 for index, value in enumerate(series): if index % 2 == 0: # Even index (0-based), positive sign total_sum += value else: # Odd index, negative sign total_sum -= value return total_sum"},{"question":"def min_operations_to_make_all_odd_or_even(n: int, arr: List[int]) -> int: Determine the minimum number of operations required to make all the elements of the array either odd or even. Each operation consists of changing any element in the array by adding or subtracting one. >>> min_operations_to_make_all_odd_or_even(5, [1, 2, 3, 4, 5]) 2 >>> min_operations_to_make_all_odd_or_even(3, [2, 4, 6]) 0","solution":"def min_operations_to_make_all_odd_or_even(n, arr): count_even = sum(1 for num in arr if num % 2 == 0) count_odd = n - count_even # The minimum operations required would be the smaller of count_even or count_odd return min(count_even, count_odd)"},{"question":"def generate_suggestions(n: int, k: int, products: List[str], prefix: str) -> List[str]: Generates up to k suggestions of product names that start with the given prefix. >>> generate_suggestions(5, 3, [\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\", \\"appeal\\"], \\"ap\\") [\\"ape\\", \\"appeal\\", \\"apple\\"] >>> generate_suggestions(5, 2, [\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\", \\"appeal\\"], \\"ap\\") [\\"ape\\", \\"appeal\\"] >>> generate_suggestions(5, 3, [\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\", \\"appeal\\"], \\"ban\\") [\\"banana\\"] >>> generate_suggestions(5, 3, [\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\", \\"appeal\\"], \\"x\\") [\\"No suggestions\\"] >>> generate_suggestions(5, 3, [\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\", \\"appeal\\"], \\"\\") [\\"ape\\", \\"appeal\\", \\"apple\\"] >>> generate_suggestions(5, 10, [\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\", \\"appeal\\"], \\"ap\\") [\\"ape\\", \\"appeal\\", \\"apple\\", \\"apricot\\"] >>> generate_suggestions(0, 3, [], \\"ap\\") [\\"No suggestions\\"] >>> generate_suggestions(1, 1, [\\"a\\"], \\"apple\\") [\\"No suggestions\\"] pass","solution":"def generate_suggestions(n, k, products, prefix): Generates up to k suggestions of product names that start with the given prefix. # Sort the products lexicographically products.sort() # Filter products that start with the prefix suggestions = [product for product in products if product.startswith(prefix)] # Return up to k suggestions return suggestions[:k] if suggestions else [\\"No suggestions\\"]"},{"question":"def minMoves(arr: List[int]) -> int: Given an array of integers, find the minimum number of moves to equalize all elements. In each move, you may increment any n-1 elements of the array by 1. Example: >>> minMoves([1, 2, 3]) 3 >>> minMoves([5, 6, 8, 8]) 7","solution":"def minMoves(arr): Returns the minimum number of moves to equalize all elements of the array. # Calculate the minimum value in the array min_val = min(arr) # Calculate the total number of moves required total_moves = sum(x - min_val for x in arr) return total_moves"},{"question":"def is_mountain_sequence(arr: List[int]) -> str: Determines if an array of integers forms a mountain sequence. A mountain sequence is a contiguous increasing sequence followed by a contiguous decreasing sequence. Both sequences must be at least one element long. >>> is_mountain_sequence([1, 3, 2]) == \\"Yes\\" >>> is_mountain_sequence([1, 5, 3, 2]) == \\"Yes\\" >>> is_mountain_sequence([1, 2, 3, 4, 3, 2, 1]) == \\"Yes\\" >>> is_mountain_sequence([1, 2, 3, 4]) == \\"No\\" >>> is_mountain_sequence([4, 3, 2, 1]) == \\"No\\" >>> is_mountain_sequence([1, 2, 2, 1]) == \\"No\\" >>> is_mountain_sequence([1, 2]) == \\"No\\" >>> is_mountain_sequence([1, 2, 2, 3, 2]) == \\"No\\" >>> is_mountain_sequence([1, 2, 3, 2, 4]) == \\"No\\" >>> is_mountain_sequence([3, 1]) == \\"No\\" >>> is_mountain_sequence([5, 5, 5, 5, 5]) == \\"No\\"","solution":"def is_mountain_sequence(arr): Determines if the given array forms a mountain sequence. :param arr: List[int] - A list of integers where each integer is between 1 and 100. :return: str - \\"Yes\\" if the array forms a mountain sequence, otherwise \\"No\\". n = len(arr) if n < 3: return \\"No\\" i = 0 # Traverse the increasing part while i < n - 1 and arr[i] < arr[i + 1]: i += 1 # Check if we are at end or start or the peak is at the first or last position if i == 0 or i == n - 1: return \\"No\\" # Traverse the decreasing part while i < n - 1 and arr[i] > arr[i + 1]: i += 1 # Check if we have reached the end of the array return \\"Yes\\" if i == n - 1 else \\"No\\""},{"question":"class Graph: def __init__(self, n, values): # Initialize the graph with n vertices and the given values pass def add_edge(self, u, v): Add an edge between vertex u and vertex v. pass def update_value(self, x, y): Update the value of vertex x to y. pass def dfs(self, node): Depth-first search to calculate the sum of reachable vertices' values from the given node. pass def sum_reachable(self, z): Sum of values for all vertices reachable from vertex z. pass def process_queries(n, q, values, edges, queries): Process the given queries on a graph defined by n vertices, values, and edges. Args: n (int): Number of vertices. q (int): Number of queries. values (List[int]): Values assigned to each vertex. edges (List[Tuple[int, int]]): List of edges in the graph. queries (List[Tuple[int, ...]]): List of queries of type 1 or type 2. Returns: List[int]: Results for all type 2 queries. pass def test_example_case(): n = 5 q = 3 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (3, 5)] queries = [(2, 1), (1, 3, 10), (2, 1)] assert process_queries(n, q, values, edges, queries) == [15, 22] def test_single_node(): n = 1 q = 2 values = [5] edges = [] queries = [(2, 1), (1, 1, 10)] assert process_queries(n, q, values, edges, queries) == [5] def test_update_value(): n = 4 q = 4 values = [1, 1, 1, 1] edges = [(1, 2), (2, 3), (3, 4)] queries = [(2, 2), (1, 2, 10), (1, 3, 5), (2, 2)] assert process_queries(n, q, values, edges, queries) == [4, 17] def test_disconnected_graph(): n = 6 q = 3 values = [5, 10, 15, 20, 25, 30] edges = [(1, 2), (3, 4), (4, 5)] queries = [(2, 1), (2, 4), (1, 5, 50)] assert process_queries(n, q, values, edges, queries) == [15, 60] def test_large_values(): n = 3 q = 2 values = [1_000_000_000, 1_000_000_000, 1_000_000_000] edges = [(1, 2), (2, 3)] queries = [(2, 1), (2, 2)] assert process_queries(n, q, values, edges, queries) == [3_000_000_000, 3_000_000_000]","solution":"class Graph: def __init__(self, n, values): self.n = n self.values = values self.adj_list = [[] for _ in range(n + 1)] self.visited = [False] * (n + 1) def add_edge(self, u, v): self.adj_list[u].append(v) self.adj_list[v].append(u) def update_value(self, x, y): self.values[x - 1] = y def dfs(self, node): stack = [node] total_sum = 0 while stack: curr = stack.pop() if not self.visited[curr]: self.visited[curr] = True total_sum += self.values[curr - 1] for neighbor in self.adj_list[curr]: if not self.visited[neighbor]: stack.append(neighbor) return total_sum def sum_reachable(self, z): self.visited = [False] * (self.n + 1) return self.dfs(z) def process_queries(n, q, values, edges, queries): graph = Graph(n, values) for u, v in edges: graph.add_edge(u, v) results = [] for query in queries: if query[0] == 1: graph.update_value(query[1], query[2]) elif query[0] == 2: result = graph.sum_reachable(query[1]) results.append(result) return results"},{"question":"from typing import List def rank_participants(performance: List[List[int]]) -> List[int]: Determine the ranking of participants given their performances. Participants are ranked by number of problems solved, then by total time taken. >>> rank_participants([[10, 20, 30], [15, 25], [5, 5, 5, 5], [40]]) [3, 1, 2, 4] >>> rank_participants([[5, 5, 5], [1, 2], [3]]) [1, 2, 3] >>> rank_participants([[10], [5, 5], [20]]) [2, 1, 3] >>> rank_participants([[]]) [1] >>> rank_participants([]) [] >>> rank_participants([[], []]) [1, 2] if __name__ == \\"__main__\\": def test_rank_participants(): performance1 = [ [10, 20, 30], [15, 25], [5, 5, 5, 5], [40] ] assert rank_participants(performance1) == [3, 1, 2, 4] performance2 = [ [5, 5, 5], [1, 2], [3] ] assert rank_participants(performance2) == [1, 2, 3] performance3 = [ [10], [5, 5], [20] ] assert rank_participants(performance3) == [2, 1, 3] performance4 = [ [] ] assert rank_participants(performance4) == [1] performance5 = [] assert rank_participants(performance5) == [] performance6 = [ [], [] ] assert rank_participants(performance6) == [1, 2] def test_rank_participants_time_considered(): performance = [ [30, 10, 20], # Participant 1: 3 problems, total time 60 [25, 15], # Participant 2: 2 problems, total time 40 [20, 20, 20], # Participant 3: 3 problems, total time 60 [50], # Participant 4: 1 problem, total time 50 [40] # Participant 5: 1 problem, total time 40 ] assert rank_participants(performance) == [1, 3, 2, 5, 4] test_rank_participants() test_rank_participants_time_considered()","solution":"def rank_participants(performance): if not performance: return [] participants = [] for idx, times in enumerate(performance): total_times = sum(times) solved_problems = len(times) participants.append((solved_problems, total_times, idx + 1)) # Sort participants by number of problems solved (descending), # then by total time taken (ascending), and then by original index (ascending). participants.sort(key=lambda x: (-x[0], x[1], x[2])) # Extracting only the original indices after sorting ranked_indices = [p[2] for p in participants] return ranked_indices"},{"question":"def can_plant_flowers(n: int, m: int, k: int, special_intersections: List[Tuple[int, int]]) -> str: Determine if flowers can be planted on all special intersections without forming a rectangle. >>> can_plant_flowers(4, 5, 0, []) \\"YES\\" >>> can_plant_flowers(4, 5, 3, [(1, 2), (3, 2), (2, 5)]) \\"YES\\" >>> can_plant_flowers(3, 3, 4, [(1, 1), (1, 3), (3, 1), (3, 3)]) \\"NO\\" >>> can_plant_flowers(10, 10, 2, [(1, 1), (2, 2)]) \\"YES\\" >>> can_plant_flowers(3, 3, 3, [(1, 1), (1, 2), (2, 1)]) \\"YES\\" >>> can_plant_flowers(5, 5, 5, [(1, 1), (1, 3), (3, 1), (3, 4), (5, 5)]) \\"YES\\" >>> can_plant_flowers(6, 6, 6, [(1, 1), (1, 3), (3, 1), (3, 3), (6, 1), (6, 3)]) \\"NO\\"","solution":"def can_plant_flowers(n, m, k, special_intersections): Determine if flowers can be planted on all special intersections without forming a rectangle. if k < 4: return \\"YES\\" # Create a dictionary to keep track of columns in each row where flowers exist row_to_columns = {} for (x, y) in special_intersections: if x not in row_to_columns: row_to_columns[x] = set() row_to_columns[x].add(y) # Check for any combination of 4 points forming a rectangle columns_checked = set() for row in row_to_columns: columns_in_row = list(row_to_columns[row]) columns_in_row.sort() for i in range(len(columns_in_row)): for j in range(i + 1, len(columns_in_row)): col1 = columns_in_row[i] col2 = columns_in_row[j] if (col1, col2) in columns_checked: return \\"NO\\" columns_checked.add((col1, col2)) return \\"YES\\""},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Computes the product of all elements except self for each element in the list. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([1, 0]) [0, 1] >>> product_except_self([0, 0]) [0, 0] >>> product_except_self([5]) [1] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def product_except_self(nums): Computes the product of all elements except self for each element in the list. :param nums: List[int] - list of integers :return: List[int] - list where each element is the product of all the other elements n = len(nums) # Initialize the result array with 1s result = [1] * n # Calculate the prefix product for each element prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] # Calculate the suffix product and multiply with the prefix product suffix = 1 for i in range(n-1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"from typing import List def group_books_by_height(heights: List[int]) -> List[List[int]]: Groups books by their heights and returns the groups in non-decreasing order. :param heights: List of integers representing the height of each book :return: List of lists, where each sublist contains books of the same height >>> group_books_by_height([4, 5, 4, 6, 5]) [[4, 4], [5, 5], [6]] >>> group_books_by_height([2, 2, 3, 3, 1, 1, 1]) [[1, 1, 1], [2, 2], [3, 3]] >>> group_books_by_height([]) [] >>> group_books_by_height([5] * 100) [[5] * 100] pass","solution":"from collections import defaultdict def group_books_by_height(heights): Groups books by their heights and returns the groups in non-decreasing order. :param heights: List of integers representing the height of each book :return: List of lists, where each sublist contains books of the same height height_map = defaultdict(list) # Populate the dictionary with book heights for height in heights: height_map[height].append(height) # Extract the groups in sorted order grouped_books = [height_map[key] for key in sorted(height_map)] return grouped_books"},{"question":"def find_min_additional_links(n: int, directs: List[int]) -> (int, List[Tuple[int, int]]): Determines the minimum number of additional direct communication links required and specifies one possible set of these new links to ensure complete communication coverage from any employee to every other employee. Parameters: n (int): The number of employees. directs (List[int]): The list where the i-th element is the id of the employee that employee i can currently inform directly. Returns: Tuple[int, List[Tuple[int, int]]]: The first element is the minimum number of new direct communication links needed. The second element is a list of new pairs of direct communication links. >>> find_min_additional_links(4, [2, 3, 4, 1]) (0, []) >>> find_min_additional_links(3, [2, 1, 1]) (1, [(1, 3)]) >>> find_min_additional_links(6, [2, 1, 4, 3, 6, 5]) (2, [(1, 3), (3, 5)]) >>> find_min_additional_links(1, [1]) (0, []) >>> find_min_additional_links(10, [2, 3, 4, 5, 1, 7, 8, 9, 10, 6]) (1, [(1, 7)]) pass","solution":"def find_min_additional_links(n, directs): # Create graph adjacency list adj = {i + 1: [] for i in range(n)} for i, emp in enumerate(directs): adj[i + 1].append(emp) # Finding connected components visited = set() components = [] def dfs(v, component): stack = [v] while stack: node = stack.pop() if node not in visited: visited.add(node) component.append(node) for neighbor in adj[node]: if neighbor not in visited: stack.append(neighbor) for i in range(1, n + 1): if i not in visited: component = [] dfs(i, component) components.append(component) # Number of components k = len(components) # If only one component, no new links are needed if k == 1: return 0, [] # To connect k components, we need (k - 1) links new_links = [] for i in range(k - 1): new_links.append((components[i][0], components[i + 1][0])) return k - 1, new_links"},{"question":"def longest_arithmetic_subsequence_length(n: int, arr: List[int]) -> int: Find the length of the longest arithmetic subsequence (LAS) from the given array. >>> longest_arithmetic_subsequence_length(7, [3, 6, 9, 12, 15, 18, 20]) 6 >>> longest_arithmetic_subsequence_length(5, [1, 2, 3, 4, 5]) 5","solution":"def longest_arithmetic_subsequence_length(n, arr): if n <= 1: return n dp = [{} for _ in range(n)] max_len = 1 for i in range(1, n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_len = max(max_len, dp[i][diff]) return max_len"},{"question":"from typing import Dict def fibonacci_recursive(n: int) -> int: Returns the nth Fibonacci number using a naive recursive approach. >>> fibonacci_recursive(10) 55 >>> fibonacci_recursive(20) 6765 def fibonacci_memoized(n: int, memo: Dict[int, int] = None) -> int: Returns the nth Fibonacci number using memoization. >>> fibonacci_memoized(10) 55 >>> fibonacci_memoized(20) 6765 # Your test cases print(fibonacci_recursive(10)) # Should return 55 print(fibonacci_memoized(10)) # Should return 55 print(fibonacci_recursive(20)) # Should return 6765 print(fibonacci_memoized(20)) # Should return 6765","solution":"def fibonacci_recursive(n): Returns the nth Fibonacci number using a naive recursive approach. if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n == 1 or n == 2: return 1 return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2) def fibonacci_memoized(n, memo=None): Returns the nth Fibonacci number using memoization. if n <= 0: raise ValueError(\\"n must be a positive integer\\") if memo is None: memo = {} if n in memo: return memo[n] if n == 1 or n == 2: return 1 memo[n] = fibonacci_memoized(n - 1, memo) + fibonacci_memoized(n - 2, memo) return memo[n]"},{"question":"def min_moves_to_make_sum_even(prices: List[int]) -> int: Returns the minimum number of moves required to make the sum of the prices even. >>> min_moves_to_make_sum_even([1, 2, 3, 4, 5]) 1 >>> min_moves_to_make_sum_even([2, 4, 6, 8, 10]) 0 >>> min_moves_to_make_sum_even([1, 1, 1, 1, 1]) 1 >>> min_moves_to_make_sum_even([10, 20, 30]) 0 >>> min_moves_to_make_sum_even([5]) 1 >>> min_moves_to_make_sum_even([1]) 1 >>> min_moves_to_make_sum_even([1, 3, 5, 7, 9]) 1","solution":"def min_moves_to_make_sum_even(prices): Returns the minimum number of moves required to make the sum of the prices even. total_sum = sum(prices) # If the sum is already even, no moves are needed if total_sum % 2 == 0: return 0 # If the sum is odd, we need exactly 1 move to make it even return 1"},{"question":"import re def sum_of_integers_in_string(s: str) -> int: Extracts all integers from a given string, including negative numbers, and returns their sum. >>> sum_of_integers_in_string(\\"a1b-2c3\\") 2 >>> sum_of_integers_in_string(\\"abc-123def45gh-67\\") -145 >>> sum_of_integers_in_string(\\"123abc\\") 123 >>> sum_of_integers_in_string(\\"abc123\\") 123 >>> sum_of_integers_in_string(\\"abc\\") 0","solution":"import re def sum_of_integers_in_string(s: str) -> int: # Use regular expression to find all sequences that represent integers numbers = re.findall(r'-?d+', s) # Convert found sequences to integers and sum them up return sum(map(int, numbers))"},{"question":"def min_trips_to_move_containers(n: int, w: int, containers: List[int]) -> int: Determine the minimum number of trips needed to move all containers from the stack. Args: n : int : number of containers w : int : maximum weight the forklift can carry in one trip containers : List[int] : weights of the containers, in order from the top of the stack to the bottom Returns: int : minimum number of trips needed Examples: >>> min_trips_to_move_containers(5, 10, [2, 3, 5, 8, 4]) 3 >>> min_trips_to_move_containers(6, 15, [1, 7, 3, 6, 5, 2]) 2","solution":"def min_trips_to_move_containers(n, w, containers): trips = 0 current_weight = 0 for weight in containers: if current_weight + weight <= w: current_weight += weight else: trips += 1 current_weight = weight if current_weight > 0: trips += 1 return trips"},{"question":"from typing import List def longest_distinct_path(grid: List[str]) -> int: Find the length of the longest path with all distinct characters in the grid. >>> longest_distinct_path([ ... \\"abcd\\", ... \\"efgh\\", ... \\"ijkl\\" ... ]) 12 >>> longest_distinct_path([\\"a\\"]) 1 >>> longest_distinct_path([ ... \\"aaa\\", ... \\"aaa\\", ... \\"aaa\\" ... ]) 1 >>> longest_distinct_path([ ... \\"ab\\", ... \\"cd\\" ... ]) 4 >>> longest_distinct_path([ ... \\"abcde\\", ... \\"fghij\\", ... \\"klmno\\", ... \\"pqrst\\", ... \\"uvwxy\\" ... ]) 25","solution":"def longest_distinct_path(grid): Find the length of the longest path with all distinct characters in the grid. def dfs(x, y, visited): max_length = len(visited) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] not in visited: max_length = max(max_length, dfs(nx, ny, visited | {grid[nx][ny]})) return max_length n = len(grid) m = len(grid[0]) longest_path = 0 for i in range(n): for j in range(m): longest_path = max(longest_path, dfs(i, j, {grid[i][j]})) return longest_path"},{"question":"def find_min_difference_subsequence(n: int, m: int, k: int, arr: List[int]) -> int: Finds the minimum difference between the maximum and minimum elements of any subsequence of length k. >>> find_min_difference_subsequence(6, 10, 3, [10, 1, 5, 3, 4, 8]) 2 >>> find_min_difference_subsequence(1, 1, 1, [1]) 0 from typing import List def test_example_case(): assert find_min_difference_subsequence(6, 10, 3, [10, 1, 5, 3, 4, 8]) == 2 def test_minimum_values(): assert find_min_difference_subsequence(1, 1, 1, [1]) == 0 def test_all_elements_same(): assert find_min_difference_subsequence(5, 10, 3, [5, 5, 5, 5, 5]) == 0 def test_descending_order(): assert find_min_difference_subsequence(5, 20, 3, [10, 8, 6, 4, 2]) == 4 def test_large_values(): assert find_min_difference_subsequence(5, 1000000000, 2, [1000000000, 999999999, 500000000, 100000000, 1]) == 1 def test_consecutive_elements(): assert find_min_difference_subsequence(7, 15, 4, [1, 2, 3, 4, 5, 6, 7]) == 3","solution":"def find_min_difference_subsequence(n, m, k, arr): Finds the minimum difference between the maximum and minimum elements of any subsequence of length k. arr.sort() min_diff = float('inf') for i in range(n - k + 1): min_diff = min(min_diff, arr[i + k - 1] - arr[i]) return min_diff"},{"question":"def find_single_number(nums: List[int]) -> int: Returns the single number that appears only once in the array where every other element appears twice. >>> find_single_number([2, 2, 3, 4, 4]) == 3 >>> find_single_number([1]) == 1 >>> find_single_number([-1, -1, -2, -2, -3]) == -3 >>> find_single_number([1, -1, 1, 2, 2]) == -1 >>> find_single_number([10**9, 10**9, -10**9, -10**9, 123456789]) == 123456789 >>> find_single_number([5, 5, 7, 8, 8, 7, 9]) == 9 >>> find_single_number([2, 1, 2, 1, 5, 4, 4]) == 5","solution":"def find_single_number(nums): Returns the single number that appears only once in the array where every other element appears twice. This solution uses bitwise XOR operation to achieve linear time complexity and constant space usage. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def reachable_nodes(n: int, m: int, edges: List[Tuple[int, int]], k: int, start_nodes: List[int]) -> int: Given a directed graph with n nodes and m edges, and a set of k starting nodes, find all the nodes that can be reached from at least one of the starting nodes using the given directed edges. Args: n (int): the number of vertices m (int): the number of edges edges (List[Tuple[int, int]]): the list of directed edges k (int): the number of starting nodes start_nodes (List[int]): the list of starting nodes Returns: int: the number of nodes that can be reached from at least one of the starting nodes >>> reachable_nodes(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (3, 6)], 2, [1, 3]) 6 >>> reachable_nodes(1, 0, [], 1, [1]) 1 >>> reachable_nodes(4, 2, [(1, 2), (3, 4)], 1, [1]) 2 >>> reachable_nodes(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)], 2, [1, 4]) 6 >>> reachable_nodes(4, 2, [(1, 2), (3, 4)], 1, [4]) 1","solution":"from collections import defaultdict, deque def reachable_nodes(n, m, edges, k, start_nodes): graph = defaultdict(list) reachable = set() # Create the directed graph for u, v in edges: graph[u].append(v) # Function to perform BFS from a start node def bfs(start): queue = deque([start]) while queue: node = queue.popleft() if node not in reachable: reachable.add(node) for neighbor in graph[node]: if neighbor not in reachable: queue.append(neighbor) # Perform BFS from each starting node for start in start_nodes: bfs(start) return len(reachable)"},{"question":"def find_flattened_terrain(m: int, delta: int, p: int, q: int, measurements: List[Tuple[int, int]]) -> Union[Tuple[int, int, int], int]: Finds the flattened terrain between two given points with a specified elevation difference threshold. Returns the start index, end index, and the minimum elevation difference found if such terrain exists. Otherwise, returns -1. Parameters: m (int): The number of measurements delta (int): The elevation difference threshold p (int): The starting index of the section q (int): The ending index of the section measurements (List[Tuple[int, int]]): The list of coordinates and their elevations Returns: Union[Tuple[int, int, int], int]: Either a tuple of (a, b, e) or -1 if no flattened terrain exists. >>> find_flattened_terrain(6, 10, 2, 5, [(1, 20), (2, 30), (3, 25), (4, 27), (5, 26), (6, 24)]) (2, 5, 5) >>> find_flattened_terrain(6, 20, 1, 6, [(1, 10), (2, 50), (3, 60), (4, 70), (5, 80), (6, 90)]) -1 >>> find_flattened_terrain(6, 8, 2, 4, [(1, 15), (2, 10), (3, 14), (4, 12), (5, 18), (6, 11)]) (2, 4, 4) >>> find_flattened_terrain(6, 10, 5, 2, [(1, 20), (2, 30), (3, 25), (4, 27), (5, 26), (6, 24)]) (2, 5, 5) >>> find_flattened_terrain(3, 10, 1, 2, [(1, 100), (2, 105), (3, 101)]) (1, 2, 5) >>> find_flattened_terrain(4, 10, 1, 3, [(1, 5), (2, 10), (3, 5), (4, 15)]) (1, 3, 5)","solution":"def find_flattened_terrain(m, delta, p, q, measurements): Finds the flattened terrain between two given points with a specified elevation difference threshold. Returns the start index, end index, and the minimum elevation difference found if such terrain exists. Otherwise, returns -1. if p > q: p, q = q, p # Ensure p is always less than q flattened_terrain = (-1, -1, float('inf')) elevations_in_range = [measurements[i-1][1] for i in range(p, q+1)] min_elevation = min(elevations_in_range) max_elevation = max(elevations_in_range) min_difference = max_elevation - min_elevation if min_difference <= delta: flattened_terrain = (p, q, min_difference) if flattened_terrain[0] == -1: return -1 else: return flattened_terrain"},{"question":"from typing import List def calculate_net_balance(transactions: List[str]) -> int: Calculate the net balance after processing all transactions. Args: transactions (List[str]): List of strings representing transactions. Returns: int: The net balance. >>> calculate_net_balance([\\"100,credit\\", \\"50,debit\\", \\"200,credit\\"]) 250 >>> calculate_net_balance([\\"100,debit\\", \\"50,debit\\", \\"200,debit\\"]) -350 >>> calculate_net_balance([\\"100,credit\\", \\"50,credit\\", \\"200,credit\\", \\"50,debit\\", \\"100,debit\\"]) 200 >>> calculate_net_balance([\\"100,credit\\"]) 100 >>> calculate_net_balance([\\"100,debit\\"]) -100 >>> calculate_net_balance([]) 0","solution":"from typing import List def calculate_net_balance(transactions: List[str]) -> int: Calculate the net balance after processing all transactions. Args: transactions (List[str]): List of strings representing transactions. Returns: int: The net balance. balance = 0 for transaction in transactions: value, t_type = transaction.split(',') value = int(value) if t_type == \\"credit\\": balance += value elif t_type == \\"debit\\": balance -= value return balance"},{"question":"def unique_paths(n: int, grid: List[List[str]]) -> int: This function calculates the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid while avoiding obstacles (#). Args: n: int - the size of the square grid. grid: List[List[str]] - the grid represented as a list of lists. Returns: int - the number of unique paths from top-left to bottom-right without crossing obstacles. Examples: >>> grid = [ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ] >>> unique_paths(3, grid) 6 >>> grid = [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ] >>> unique_paths(3, grid) 2 >>> grid = [ ... ['#', '.'], ... ['.', '.'] ... ] >>> unique_paths(2, grid) 0 >>> grid = [ ... ['.', '.'], ... ['.', '#'] ... ] >>> unique_paths(2, grid) 0 >>> grid = [ ... ['.', '#'], ... ['#', '.'] ... ] >>> unique_paths(2, grid) 0 >>> grid = [ ... ['.', '.', '#', '.'], ... ['#', '.', '#', '.'], ... ['.', '.', '.', '.'], ... ['.', '#', '.', '.'] ... ] >>> unique_paths(4, grid) 2 pass","solution":"def unique_paths(n, grid): This function calculates the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid while avoiding obstacles (#). # Edge case: if the start or end is an obstacle, no path is possible. if grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp = [[0 for _ in range(n)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def largest_uniform_subgrid(n: int, m: int, grid: List[str]) -> Union[str, Tuple[int, int, int, int]]: Find the largest rectangular subgrid where all the letters are the same. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): List of strings representing the grid. Returns: Union[str, Tuple[int, int, int, int]]: \\"NO\\" if no uniform subgrid exists, otherwise four integers representing the top-left and bottom-right coordinates of the subgrid. >>> largest_uniform_subgrid(3, 4, [\\"aaaa\\", \\"abab\\", \\"aaaa\\"]) (1, 1, 1, 4) >>> largest_uniform_subgrid(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) (1, 1, 1, 1)","solution":"def largest_uniform_subgrid(n, m, grid): def check_subgrid(r1, c1, r2, c2): char = grid[r1][c1] for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): if grid[r][c] != char: return False return True max_area = 0 result = \\"NO\\" for r1 in range(n): for c1 in range(m): for r2 in range(r1, n): for c2 in range(c1, m): if check_subgrid(r1, c1, r2, c2): area = (r2 - r1 + 1) * (c2 - c1 + 1) if area > max_area: max_area = area result = (r1 + 1, c1 + 1, r2 + 1, c2 + 1) return result"},{"question":"def min_rows_to_fertilize_garden(n: int, garden: List[str]) -> int: Returns the minimum number of rows in which the gardener needs to plant seeds to make the entire garden fertile. >>> min_rows_to_fertilize_garden(3, [\\"111\\", \\"111\\", \\"111\\"]) == 0 >>> min_rows_to_fertilize_garden(3, [\\"111\\", \\"000\\", \\"111\\"]) == 1 >>> min_rows_to_fertilize_garden(3, [\\"101\\", \\"000\\", \\"111\\"]) == 2 >>> min_rows_to_fertilize_garden(3, [\\"000\\", \\"000\\", \\"000\\"]) == 3 >>> garden = [ ... \\"1111111111\\", ... \\"0000000000\\", ... \\"1111111111\\", ... \\"0000000000\\", ... \\"1111111111\\", ... \\"0000000000\\", ... \\"1111111111\\", ... \\"0000000000\\", ... \\"1111111111\\", ... \\"0000000000\\"] >>> min_rows_to_fertilize_garden(10, garden) == 5","solution":"def min_rows_to_fertilize_garden(n, garden): Returns the minimum number of rows in which the gardener needs to plant seeds to make the entire garden fertile. # Counting the number of rows that contain at least one barren cell rows_with_barren = sum(1 for row in garden if '0' in row) return rows_with_barren"},{"question":"def determine_time_of_day(time_str: str) -> str: Determines the part of the day based on the input 24-hour formatted time string. Args: time_str: A string representing the time in \\"HH:MM\\" format. Returns: A string indicating the part of the day: \\"morning\\", \\"afternoon\\", \\"evening\\", or \\"night\\". >>> determine_time_of_day(\\"00:00\\") 'night' >>> determine_time_of_day(\\"06:00\\") 'morning' >>> determine_time_of_day(\\"12:00\\") 'afternoon' >>> determine_time_of_day(\\"18:00\\") 'evening' # Implement the function here","solution":"def determine_time_of_day(time_str): Determines the part of the day based on the input 24-hour formatted time string. Args: time_str: A string representing the time in \\"HH:MM\\" format. Returns: A string indicating the part of the day: \\"morning\\", \\"afternoon\\", \\"evening\\", or \\"night\\". hour = int(time_str.split(\\":\\")[0]) if 0 <= hour < 6: return \\"night\\" elif 6 <= hour < 12: return \\"morning\\" elif 12 <= hour < 18: return \\"afternoon\\" else: return \\"evening\\""},{"question":"import math from typing import List, Tuple def total_delivery_time(n: int, warehouse: Tuple[int, int], W: int, packages: List[Tuple[int, int, int]]) -> int: Calculates the total delivery time for a fleet of delivery drones. n: the number of packages. warehouse: a tuple (xi, yi) representing the coordinates of the warehouse. W: the maximum weight a drone can carry. packages: a list of tuples (pj, xj, yj) representing the weight and coordinates of each package. Returns the total delivery time for all packages. pass def test_total_delivery_time(): n = 1 warehouse = (0, 0) W = 5 packages = [(5, 3, 4)] assert total_delivery_time(n, warehouse, W, packages) == math.ceil(10) n = 3 warehouse = (1, 1) W = 10 packages = [(5, 4, 5), (7, -1, -1), (9, 10, 10)] total_dist = (math.sqrt((4-1)**2 + (5-1)**2) * 2 + math.sqrt((-1-1)**2 + (-1-1)**2) * 2 + math.sqrt((10-1)**2 + (10-1)**2) * 2) assert total_delivery_time(n, warehouse, W, packages) == math.ceil(total_dist) n = 3 warehouse = (0, 0) W = 5 packages = [(6, 3, 4), (10, 4, 5), (11, -1, -1)] assert total_delivery_time(n, warehouse, W, packages) == 0 n = 4 warehouse = (0, 0) W = 7 packages = [(3, 3, 4), (10, 2, 1), (7, 0, 8), (5, 5, 0)] total_dist = (math.sqrt((3-0)**2 + (4-0)**2) * 2 + math.sqrt((0-0)**2 + (8-0)**2) * 2 + math.sqrt((5-0)**2 + (0-0)**2) * 2) assert total_delivery_time(n, warehouse, W, packages) == math.ceil(total_dist) n = 0 warehouse = (0, 0) W = 10 packages = [] assert total_delivery_time(n, warehouse, W, packages) == 0","solution":"import math def total_delivery_time(n, warehouse, W, packages): Calculates the total delivery time for a fleet of delivery drones. n: the number of packages. warehouse: a tuple (xi, yi) representing the coordinates of the warehouse. W: the maximum weight a drone can carry. packages: a list of tuples (pj, xj, yj) representing the weight and coordinates of each package. Returns the total delivery time for all packages. xi, yi = warehouse total_time = 0 for weight, xj, yj in packages: if weight <= W: distance = math.sqrt((xi - xj) ** 2 + (yi - yj) ** 2) total_time += 2 * distance # going to the destination and coming back return math.ceil(total_time) # Example usage: # Input # n = 5 # warehouse = (0, 0) # W = 100 # packages = [(5, 1, 1), (50, 2, 3), (20, -1, 4), (100, 4, 5), (10, 3, 3)] # Output: 149 # assert total_delivery_time(n, warehouse, W, packages) == 149"},{"question":"from collections import Counter def can_form_palindrome(n: int, s: str) -> str: Determines if the characters in the string s can be rearranged to form a palindrome. Args: n (int): The length of the string. s (str): The string of lowercase letters. Returns: str: \\"YES\\" if it's possible to rearrange the characters to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(4, 'aabb') \\"YES\\" >>> can_form_palindrome(4, 'aabc') \\"NO\\" >>> can_form_palindrome(5, 'aabbb') \\"YES\\" >>> can_form_palindrome(5, 'aabcd') \\"NO\\" >>> can_form_palindrome(1, 'a') \\"YES\\" >>> can_form_palindrome(5, 'abcde') \\"NO\\" >>> can_form_palindrome(7, 'aabbccx') \\"YES\\" >>> can_form_palindrome(7, 'aabcdde') \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(n, s): Determines if the characters in the string s can be rearranged to form a palindrome. Args: n (int): The length of the string. s (str): The string of lowercase letters. Returns: str: \\"YES\\" if it's possible to rearrange the characters to form a palindrome, \\"NO\\" otherwise. count = Counter(s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List, Tuple def two_colorable(n: int, edges: List[Tuple[int, int]]) -> List[int]: Determines if the given graph can be colored using two colors such that no two adjacent vertices share the same color. >>> two_colorable(3, []) [0, 0, 0] >>> two_colorable(2, [(0, 1)]) [0, 1] or [1, 0] >>> two_colorable(3, [(0, 1), (1, 2)]) [0, 1, 0] or [1, 0, 1] >>> two_colorable(3, [(0, 1), (1, 2), (2, 0)]) [] >>> two_colorable(4, [(0, 1), (1, 2), (2, 3)]) [0, 1, 0, 1] or [1, 0, 1, 0] >>> two_colorable(4, [(0, 2), (0, 3), (1, 2), (1, 3)]) [0, 0, 1, 1] or [1, 1, 0, 0]","solution":"from typing import List, Tuple def two_colorable(n: int, edges: List[Tuple[int, int]]) -> List[int]: def dfs(v, c): color[v] = c for neighbor in adj_list[v]: if color[neighbor] == -1: if not dfs(neighbor, 1 - c): return False elif color[neighbor] == color[v]: return False return True adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) color = [-1] * n for i in range(n): if color[i] == -1: if not dfs(i, 0): return [] return color"},{"question":"def shortest_paths(n: int, m: int, s: int, roads: List[Tuple[int, int, int]]) -> List[int]: Compute the minimum travel times from the central building to all other buildings in the city. Arguments: n -- the number of buildings (1 ≤ n ≤ 200,000) m -- the number of roads (1 ≤ m ≤ 500,000) s -- the central building (1 ≤ s ≤ n) roads -- a list of tuples, where each tuple contains three integers u, v, w representing a road between buildings u and v with a travel time of w (1 ≤ u, v ≤ n and 1 ≤ w ≤ 1000) Returns: A list of n integers, where the ith integer is the minimum travel time from the central building s to building i (1-based indexing). If a building is unreachable from the central building, return -1 for that building. Example: >>> shortest_paths(5, 6, 1, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (3, 5, 5)]) [0, 2, 3, 6, 8] from heapq import heappop, heappush from typing import List, Tuple import heapq def test_shortest_paths_example(): n = 5 m = 6 s = 1 roads = [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (3, 5, 5)] assert shortest_paths(n, m, s, roads) == [0, 2, 3, 6, 8] def test_shortest_paths_single_building(): n = 1 m = 0 s = 1 roads = [] assert shortest_paths(n, m, s, roads) == [0] def test_shortest_paths_no_path(): n = 4 m = 2 s = 1 roads = [(1, 2, 5), (3, 4, 10)] assert shortest_paths(n, m, s, roads) == [0, 5, -1, -1] def test_shortest_paths_all_buildings_connected(): n = 4 m = 3 s = 1 roads = [(1, 2, 3), (1, 3, 2), (2, 4, 5)] assert shortest_paths(n, m, s, roads) == [0, 3, 2, 8] def test_shortest_paths_large_weights(): n = 3 m = 3 s = 2 roads = [(1, 2, 1000), (2, 3, 1000), (1, 3, 5000)] assert shortest_paths(n, m, s, roads) == [1000, 0, 1000]","solution":"import heapq def shortest_paths(n, m, s, roads): graph = [[] for _ in range(n)] for u, v, w in roads: graph[u-1].append((w, v-1)) graph[v-1].append((w, u-1)) dist = [float('inf')] * n dist[s-1] = 0 priority_queue = [(0, s-1)] while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > dist[u]: continue for weight, v in graph[u]: distance = current_distance + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return [d if d != float('inf') else -1 for d in dist] # Example usage # n = 5 # m = 6 # s = 1 # roads = [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (3, 5, 5)] # print(shortest_paths(n, m, s, roads)) # Output: [0, 2, 3, 6, 8]"},{"question":"def longest_zero_sum_subarray(arr: List[int]) -> (int, Tuple[int, int]): Returns the length of the longest contiguous subarray with sum zero and the starting and ending indices of this subarray. If no such subarray exists, it returns 0 and an empty tuple. >>> longest_zero_sum_subarray([15, -2, 2, -8, 1, 7, 10, 23, -5, -5]) (5, (1, 5)) >>> longest_zero_sum_subarray([0, 0, 0, 0, 0]) (5, (0, 4)) >>> longest_zero_sum_subarray([1, 2, -3, 3]) (3, (0, 2)) >>> longest_zero_sum_subarray([1, 2, 3]) (0, ()) >>> longest_zero_sum_subarray([-1, 1, -1, 1, -1, 1, -1]) (6, (0, 5)) >>> longest_zero_sum_subarray([1, -1, 2, -2, 3, -3]) (6, (0, 5)) from solution import longest_zero_sum_subarray def test_longest_zero_sum_subarray(): assert longest_zero_sum_subarray([15, -2, 2, -8, 1, 7, 10, 23, -5, -5]) == (5, (1, 5)) assert longest_zero_sum_subarray([0, 0, 0, 0, 0]) == (5, (0, 4)) assert longest_zero_sum_subarray([1, 2, -3, 3]) == (3, (0, 2)) assert longest_zero_sum_subarray([1, 2, 3]) == (0, ()) assert longest_zero_sum_subarray([-1, 1, -1, 1, -1, 1, -1]) == (6, (0, 5)) assert longest_zero_sum_subarray([1, -1, 2, -2, 3, -3]) == (6, (0, 5)) def test_longest_zero_sum_subarray_single_element(): assert longest_zero_sum_subarray([0]) == (1, (0, 0)) assert longest_zero_sum_subarray([1]) == (0, ()) def test_longest_zero_sum_subarray_two_elements(): assert longest_zero_sum_subarray([1, -1]) == (2, (0, 1)) assert longest_zero_sum_subarray([1, 1]) == (0, ())","solution":"def longest_zero_sum_subarray(arr): Returns the length of the longest contiguous subarray with sum zero and the starting and ending indices of this subarray. If no such subarray exists, it returns 0 and an empty tuple. n = len(arr) sum_map = {} max_len = 0 current_sum = 0 start_index = -1 end_index = -1 for i in range(n): current_sum += arr[i] if current_sum == 0: max_len = i + 1 start_index = 0 end_index = i if current_sum in sum_map: if max_len < i - sum_map[current_sum]: max_len = i - sum_map[current_sum] start_index = sum_map[current_sum] + 1 end_index = i else: sum_map[current_sum] = i if max_len == 0: return 0, () else: return max_len, (start_index, end_index)"},{"question":"def count_inversions(n, arr): Counts the number of inversions in the shuffled list. An inversion is a pair (a, b) where a appears before b and a > b. Args: n: int - The number of elements in the array. arr: List[int] - The shuffled list of book IDs. Returns: int - The number of inversions. from solution import count_inversions def test_count_inversions_example(): assert count_inversions(5, [2, 3, 8, 6, 1]) == 5 def test_count_inversions_sorted(): assert count_inversions(3, [1, 2, 3]) == 0 def test_count_inversions_reverse_sorted(): assert count_inversions(3, [3, 2, 1]) == 3 def test_count_inversions_single_element(): assert count_inversions(1, [1]) == 0 def test_count_inversions_two_elements(): assert count_inversions(2, [2, 1]) == 1 assert count_inversions(2, [1, 2]) == 0 def test_count_inversions_larger(): assert count_inversions(6, [10, 20, 10, 30, 20, 10]) == 5","solution":"def count_inversions(n, arr): Counts the number of inversions in the shuffled list. An inversion is a pair (a, b) where a appears before b and a > b. Args: n: int - The number of elements in the array. arr: List[int] - The shuffled list of book IDs. Returns: int - The number of inversions. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all the remaining elements in # the left subarray (arr[i+1], arr[i+2], ... arr[mid]) are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if there are any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if there are any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"def minimum_shelves(t: int, queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of shelves required to store all books, given the total number of books and the capacity of each shelf. >>> minimum_shelves(3, [(10, 3), (25, 5), (7, 7)]) [4, 5, 1] >>> minimum_shelves(3, [(1, 1), (1, 2), (1, 10)]) [1, 1, 1] from typing import List, Tuple def test_minimum_shelves(): queries = [(10, 3), (25, 5), (7, 7)] assert minimum_shelves(3, queries) == [4, 5, 1] def test_minimum_shelves_single_book(): queries = [(1, 1), (1, 2), (1, 10)] assert minimum_shelves(3, queries) == [1, 1, 1] def test_minimum_shelves_multiple_books(): queries = [(11, 2), (20, 4), (30, 5)] assert minimum_shelves(3, queries) == [6, 5, 6] def test_minimum_shelves_exact_fit(): queries = [(15, 3), (50, 5), (21, 7)] assert minimum_shelves(3, queries) == [5, 10, 3] def test_minimum_shelves_various_scenarios(): queries = [(0, 1), (10000000, 1), (10000000, 1000000)] assert minimum_shelves(3, queries) == [0, 10000000, 10]","solution":"def minimum_shelves(t, queries): results = [] for b, s in queries: shelves = b // s if b % s != 0: shelves += 1 results.append(shelves) return results"},{"question":"def uniquePaths(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left to bottom-right corner of a 2D grid, avoiding blocked cells. Args: grid (List[List[int]]): 2D list of integers representing the grid. 0 = open cell, 1 = blocked cell. Returns: int: Number of unique paths modulo 1000000007","solution":"def uniquePaths(grid): Returns the number of unique paths from the top-left to bottom-right corner of a 2D grid, avoiding blocked cells. m = len(grid) n = len(grid[0]) MOD = 1000000007 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[m-1][n-1]"},{"question":"def reverse_words(s: str) -> str: Returns the string with the order of words reversed. Parameters: s (str): The input string. Returns: str: The input string with words in reverse order. >>> reverse_words(\\"Hello how are you\\") \\"you are how Hello\\" >>> reverse_words(\\"Hello\\") \\"Hello\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"The quick Brown Fox\\") \\"Fox Brown quick The\\" >>> reverse_words(\\"Hello there!\\") \\"there! Hello\\" >>> reverse_words(\\"123 456 789\\") \\"789 456 123\\"","solution":"def reverse_words(s): Returns the string with the order of words reversed. Parameters: s (str): The input string. Returns: str: The input string with words in reverse order. return ' '.join(s.split()[::-1])"},{"question":"def final_string_length(s: str) -> int: Returns the length of the string after all possible adjacent lowercase-uppercase pairs have been removed. >>> final_string_length(\\"dabAcCaCBAcCcaDA\\") 10 >>> final_string_length(\\"abBA\\") 0 >>> final_string_length(\\"aabAAB\\") 6","solution":"def final_string_length(s): Returns the length of the string after all possible adjacent lowercase-uppercase pairs have been removed. stack = [] for char in s: if stack and char.swapcase() == stack[-1]: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def find_closest_indices(n: int, d: int, elements: List[int]) -> Tuple[int, int]: Finds two distinct indices in the list elements such that the absolute difference between the values at these indices is as close to the target value d as possible. Parameters: n (int): Number of elements in the list. d (int): The target difference. elements (list): List of integers. Returns: tuple: Two 1-based indices. Examples: >>> find_closest_indices(5, 3, [1, 8, 5, 12, 15]) (2, 3) >>> find_closest_indices(2, 1, [100, 105]) (1, 2) >>> find_closest_indices(4, 1000, [1, 1000, 5000, 10000]) (1, 2) >>> find_closest_indices(4, 50, [20, 70, 150, 130]) (1, 2) >>> find_closest_indices(6, 10, [1, 11, 2, 12, 10, 20])","solution":"def find_closest_indices(n, d, elements): Finds two distinct indices in the list elements such that the absolute difference between the values at these indices is as close to the target value d as possible. Parameters: n (int): Number of elements in the list. d (int): The target difference. elements (list): List of integers. Returns: tuple: Two 1-based indices. closest_diff = float('inf') result_indices = (0, 1) for i in range(n): for j in range(i + 1, n): current_diff = abs(elements[i] - elements[j]) if abs(current_diff - d) < closest_diff: closest_diff = abs(current_diff - d) result_indices = (i + 1, j + 1) return result_indices"},{"question":"def construct_array(n: int) -> List[int]: Construct an array of length n with distinct integers that sum to zero. >>> construct_array(3) == [1, 0, -1] >>> construct_array(4) == [-1, 1, -2, 2]","solution":"def construct_array(n): Construct an array of length n with distinct integers that sum to zero. result = [] if n % 2 == 0: # When n is even for i in range(1, n // 2 + 1): result.append(i) result.append(-i) else: # When n is odd result.append(0) for i in range(1, (n // 2) + 1): result.append(i) result.append(-i) return result"},{"question":"def find_pair_with_sum(lst: List[int], target: int) -> Tuple[int, int]: Finds a pair of elements in the list that sum up to the target value. Returns a tuple of the two integers or None if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4], 8) None","solution":"def find_pair_with_sum(lst, target): Finds a pair of elements in the list that sum up to the target value. Returns a tuple of the two integers or None if no such pair exists. seen = {} for num in lst: complement = target - num if complement in seen: return (complement, num) if complement < num else (num, complement) seen[num] = True return None"},{"question":"def min_groups(n: int, k: int) -> int: Determines the minimum number of groups needed to distribute n problems such that each group contains at least k problems. :param n: Total number of problems :param k: Minimum number of problems in each group :return: Minimum number of groups >>> min_groups(10, 5) 2 >>> min_groups(1, 1) 1 >>> min_groups(10, 3) 4 >>> min_groups(100000, 1) 100000 >>> min_groups(15, 4) 4 >>> min_groups(10, 10) 1 >>> min_groups(10, 2) 5 >>> min_groups(7, 1) 7","solution":"def min_groups(n, k): Determines the minimum number of groups needed to distribute n problems such that each group contains at least k problems. :param n: Total number of problems :param k: Minimum number of problems in each group :return: Minimum number of groups # Calculate the minimum number of groups return (n + k - 1) // k"},{"question":"def move_robots(n: int, r: int, initial_positions: List[Tuple[int, int]], commands: str) -> List[Tuple[int, int]]: Determine the final positions of robots on a grid after executing a series of commands. Parameters: n (int): Size of the grid (n x n). r (int): Number of robots. initial_positions (List[Tuple[int, int]]): Initial positions of the robots. commands (str): Series of commands for moving the robots. Returns: List[Tuple[int, int]]: Final positions of robots that are still on the grid. Example: >>> move_robots(5, 3, [(1, 1), (2, 3), (4, 4)], 'UDLR') [(2, 3), (4, 4)] >>> move_robots(5, 0, [], 'UDLR') [] >>> move_robots(2, 2, [(1, 1), (2, 2)], 'LLLL') [] >>> move_robots(5, 3, [(1, 5), (5, 1), (3, 3)], 'ULDR') [(3, 3)] >>> move_robots(5, 3, [(1, 1), (2, 2), (3, 3)], '') [(1, 1), (2, 2), (3, 3)] >>> move_robots(1, 1, [(1, 1)], 'UDLR') []","solution":"def move_robots(n, r, initial_positions, commands): directions = { 'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1) } positions = initial_positions.copy() for command in commands: dx, dy = directions[command] new_positions = [] for x, y in positions: new_x, new_y = x + dx, y + dy if 1 <= new_x <= n and 1 <= new_y <= n: new_positions.append((new_x, new_y)) positions = new_positions return positions"},{"question":"def subset_sum_exists(n: int, t: int, arr: List[int]) -> str: Determines if there exists a subset of the array such that the sum of its elements is exactly t. Returns \\"YES\\" if such a subset exists, otherwise returns \\"NO\\". >>> subset_sum_exists(5, 9, [3, 34, 4, 12, 5]) == \\"YES\\" >>> subset_sum_exists(5, 30, [3, 34, 4, 12, 5]) == \\"NO\\"","solution":"def subset_sum_exists(n, t, arr): Determines if there exists a subset of the array such that the sum of its elements is exactly t. Returns \\"YES\\" if such a subset exists, otherwise returns \\"NO\\". dp = [False] * (t + 1) dp[0] = True for num in arr: for j in range(t, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[t] else \\"NO\\""},{"question":"def largest_radius(A: int) -> int: Given the maximum area A for a square, returns the radius of the largest circle that can be inscribed within the square without exceeding the area. Args: A (int): the maximum area for the square piece of metal. Returns: int: the radius of the largest inscribed circle. Examples: >>> largest_radius(49) 3 >>> largest_radius(1) 0 >>> largest_radius(99) 4 >>> largest_radius(1000000000000000000) 500000000 >>> largest_radius(64) 4 >>> largest_radius(50) 3","solution":"import math def largest_radius(A): Given the maximum area A for a square, returns the radius of the largest circle that can be inscribed within the square without exceeding the area. # Calculate side of the square side_of_square = math.isqrt(A) # Calculate the radius of the largest circle (which would be half of the side of the square) radius_of_circle = side_of_square // 2 return radius_of_circle"},{"question":"def is_path_exists(n, m, grid, sx, sy, tx, ty): Determines if a path exists from the starting cell (sx, sy) to the target cell (tx, ty) on the given grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): Grid representation. sx (int): Starting row index. sy (int): Starting column index. tx (int): Target row index. ty (int): Target column index. Returns: bool: True if a path exists, False otherwise. def test_is_path_exists_open_path(): n = 3 m = 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] sx, sy = 0, 0 tx, ty = 2, 2 assert is_path_exists(n, m, grid, sx, sy, tx, ty) == True def test_is_path_exists_blocked(): n = 3 m = 3 grid = [ \\"...\\", \\"#\\", \\"...\\" ] sx, sy = 0, 0 tx, ty = 2, 2 assert is_path_exists(n, m, grid, sx, sy, tx, ty) == False def test_is_path_exists_same_start_target(): n = 1 m = 1 grid = [\\".\\"] sx, sy = 0, 0 tx, ty = 0, 0 assert is_path_exists(n, m, grid, sx, sy, tx, ty) == True def test_is_path_exists_start_blocked(): n = 2 m = 2 grid = [ \\"#.\\", \\"..\\" ] sx, sy = 0, 0 tx, ty = 1, 1 assert is_path_exists(n, m, grid, sx, sy, tx, ty) == False def test_is_path_exists_target_blocked(): n = 2 m = 2 grid = [ \\"..\\", \\".#\\" ] sx, sy = 0, 0 tx, ty = 1, 1 assert is_path_exists(n, m, grid, sx, sy, tx, ty) == False def test_is_path_exists_large_grid(): n = 100 m = 100 grid = ['.' * 100 for _ in range(100)] sx, sy = 0, 0 tx, ty = 99, 99 assert is_path_exists(n, m, grid, sx, sy, tx, ty) == True","solution":"def is_path_exists(n, m, grid, sx, sy, tx, ty): Determines if a path exists from the starting cell (sx, sy) to the target cell (tx, ty) on the given grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): Grid representation. sx (int): Starting row index. sy (int): Starting column index. tx (int): Target row index. ty (int): Target column index. Returns: bool: True if a path exists, False otherwise. if grid[sx][sy] == '#' or grid[tx][ty] == '#': return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up visited = [[False for _ in range(m)] for _ in range(n)] queue = [(sx, sy)] visited[sx][sy] = True while queue: x, y = queue.pop(0) if (x, y) == (tx, ty): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return False"},{"question":"class BankSystem: def __init__(self): self.accounts = {} def deposit(self, account_id, amount): if account_id not in self.accounts: self.accounts[account_id] = 0 self.accounts[account_id] += amount def withdraw(self, account_id, amount): if account_id in self.accounts and self.accounts[account_id] >= amount: self.accounts[account_id] -= amount def query(self, account_id): return self.accounts.get(account_id, 0) def process_operations(operations): Simulate a bank system that processes multiple operations on bank accounts. Args: operations (List[str]): A list of strings representing operations to be processed on bank accounts. Returns: List[int]: A list of results for each balance query operation. Example: >>> process_operations(['deposit 1 100', 'withdraw 1 50', 'query 1']) [50] >>> process_operations(['deposit 2 500', 'withdraw 2 300', 'query 2']) [200] bank_system = BankSystem() results = [] for operation in operations: parts = operation.strip().split() if parts[0] == \\"deposit\\": bank_system.deposit(int(parts[1]), int(parts[2])) elif parts[0] == \\"withdraw\\": bank_system.withdraw(int(parts[1]), int(parts[2])) elif parts[0] == \\"query\\": results.append(bank_system.query(int(parts[1]))) return results from solution import process_operations def test_process_operations(): operations = [ 'deposit 1 100', 'deposit 2 500', 'withdraw 1 50', 'query 1', 'query 2', 'withdraw 2 300', 'query 2', 'withdraw 2 300', 'query 2', ] expected_results = [ 50, 500, 200, 200, ] results = process_operations(operations) assert results == expected_results def test_initial_query(): operations = [ 'query 1', ] expected_results = [0] results = process_operations(operations) assert results == expected_results def test_no_withdraw_if_insufficient_funds(): operations = [ 'deposit 1 100', 'withdraw 1 200', 'query 1', ] expected_results = [100] results = process_operations(operations) assert results == expected_results def test_multiple_operations(): operations = [ 'deposit 1 100', 'deposit 1 200', 'withdraw 1 150', 'withdraw 1 200', 'query 1', ] expected_results = [150] results = process_operations(operations) assert results == expected_results def test_large_account_numbers(): operations = [ 'deposit 1000001 1000', 'query 1000001', ] expected_results = [1000] results = process_operations(operations) assert results == expected_results","solution":"class BankSystem: def __init__(self): self.accounts = {} def deposit(self, account_id, amount): if account_id not in self.accounts: self.accounts[account_id] = 0 self.accounts[account_id] += amount def withdraw(self, account_id, amount): if account_id in self.accounts and self.accounts[account_id] >= amount: self.accounts[account_id] -= amount def query(self, account_id): return self.accounts.get(account_id, 0) def process_operations(operations): bank_system = BankSystem() results = [] for operation in operations: parts = operation.strip().split() if parts[0] == \\"deposit\\": bank_system.deposit(int(parts[1]), int(parts[2])) elif parts[0] == \\"withdraw\\": bank_system.withdraw(int(parts[1]), int(parts[2])) elif parts[0] == \\"query\\": results.append(bank_system.query(int(parts[1]))) return results"},{"question":"from typing import List def calculate_ranks(scores: List[int]) -> List[int]: Calculate the rank for each participant based on their scores. Participants with the same scores share the same rank. >>> calculate_ranks([100, 50, 50, 25, 10]) [1, 2, 2, 3, 4] >>> calculate_ranks([100]) [1] >>> calculate_ranks([50, 50, 50, 50]) [1, 1, 1, 1] >>> calculate_ranks([60, 40, 80, 20]) [2, 3, 1, 4] >>> calculate_ranks([100, 90, 80, 70, 60]) [1, 2, 3, 4, 5] >>> calculate_ranks([75, 100, 80, 80, 50]) [3, 1, 2, 2, 4]","solution":"def calculate_ranks(scores): Calculate ranks based on scores in descending order. Participants with the same scores share the same rank. sorted_scores = sorted(set(scores), reverse=True) rank_dict = {score: rank + 1 for rank, score in enumerate(sorted_scores)} return [rank_dict[score] for score in scores]"},{"question":"def word_search(grid: List[List[str]], word: str) -> bool: Given a grid of characters and a target word, determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> grid = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> word_search(grid, \\"ABCCED\\") True >>> word_search(grid, \\"SEE\\") True >>> word_search(grid, \\"ABCB\\") False","solution":"def word_search(grid, word): if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or word[index] != grid[r][c]: return False temp, grid[r][c] = grid[r][c], '#' found = (dfs(r + 1, c, index + 1) or dfs(r - 1, c, index + 1) or dfs(r, c + 1, index + 1) or dfs(r, c - 1, index + 1)) grid[r][c] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"def decode_numbers(s: str) -> int: Create a function \`decode_numbers\` that accepts a string containing a sequence of digits and returns the number of ways to decode it using the mapping: 'A' = 1, 'B' = 2, ..., 'Z' = 26. >>> decode_numbers('12') == 2 >>> decode_numbers('226') == 3 >>> decode_numbers('0') == 0 >>> decode_numbers('1') == 1","solution":"def decode_numbers(s: str) -> int: if not s: return 0 n = len(s) # dp[i] will store the number of ways to decode the string s[0..i-1] dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] return dp[n]"},{"question":"def minimum_rounds(n: int, scores: List[int]) -> int: Return the minimum number of rounds required to determine a winner in the tournament. Parameters: n (int): The number of players scores (list of int): The scores of the players Returns: int: Minimum number of rounds required to determine a winner >>> minimum_rounds(1, [7]) 0 >>> minimum_rounds(2, [5, 3]) 1 >>> minimum_rounds(3, [5, 3, 6]) 2 >>> minimum_rounds(4, [3, 1, 4, 2]) 2 >>> minimum_rounds(8, [1, 2, 3, 4, 5, 6, 7, 8]) 3 >>> minimum_rounds(5, [1, 2, 3, 4, 5]) 3 pass","solution":"def minimum_rounds(n, scores): Return the minimum number of rounds required to determine a winner in the tournament. Parameters: n (int): The number of players scores (list of int): The scores of the players Returns: int: Minimum number of rounds required to determine a winner # The minimum number of rounds to determine the winner in such a tournament # is effectively the height of a balanced binary tree structure # with n nodes. # The number of levels (rounds) in such a tree is given by the ceiling of log2(n). import math return math.ceil(math.log2(n))"},{"question":"def maxProfit(prices: List[int]) -> int: Given an array of integers representing stock prices on different days, find the maximum profit you can achieve. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def most_active_user_within_period(activities, start_time, end_time): Identify the user with the highest number of activities within a given time frame. Parameters: activities (list of tuples): Each tuple contains a username (string) and a timestamp (integer). start_time (int): An integer representing the start of the time period. end_time (int): An integer representing the end of the time period. Returns: str: The username of the user with the highest number of activities within the specified time frame. If there is a tie, return the username that is lexicographically smallest. Examples: >>> activities = [(\\"alice\\", 100), (\\"bob\\", 200), (\\"alice\\", 150), (\\"alice\\", 300), (\\"bob\\", 250), (\\"charlie\\", 300), (\\"charlie\\", 350)] >>> start_time = 100 >>> end_time = 300 >>> most_active_user_within_period(activities, start_time, end_time) 'alice'","solution":"from collections import defaultdict def most_active_user_within_period(activities, start_time, end_time): Returns the username of the user with the highest number of activities within the specified time frame. user_activity_count = defaultdict(int) # Iterate through the activities and count user activities within the timeframe for username, timestamp in activities: if start_time <= timestamp <= end_time: user_activity_count[username] += 1 # Determine the user with the highest count of activities max_activities = 0 most_active_user = None for user, count in user_activity_count.items(): if count > max_activities or (count == max_activities and user < most_active_user): max_activities = count most_active_user = user return most_active_user"},{"question":"def search_dress_designs(n, m, designs, queries): Searches for dress designs that match given queries. :param n: Number of dress designs :param m: Number of queries :param designs: List of tuples where each tuple contains (id, color_id, length_id, style_id) :param queries: List of tuples where each tuple contains (query_color_id, query_length_id, query_style_id) :return: List of results for each query. Each result is either a sorted list of matching dress ids or \\"No matches found\\". pass # Test cases def test_search_dress_designs_case1(): designs = [ (1, 5, 3, 7), (2, 5, 2, 7), (3, 2, 3, 7), (4, 5, 3, 8), (5, 5, 3, 7) ] queries = [ (5, 3, 7), (2, 2, 8) ] expected = [ [1, 5], \\"No matches found\\" ] assert search_dress_designs(5, 2, designs, queries) == expected def test_search_dress_designs_case2(): designs = [ (1, 1, 1, 1), (2, 2, 2, 2), (3, 1, 1, 1) ] queries = [ (1, 1, 1), (2, 2, 2), (3, 3, 3) ] expected = [ [1, 3], [2], \\"No matches found\\" ] assert search_dress_designs(3, 3, designs, queries) == expected def test_search_dress_designs_case3(): designs = [ (1, 10, 10, 10) ] queries = [ (10, 10, 10), (10, 10, 11) ] expected = [ [1], \\"No matches found\\" ] assert search_dress_designs(1, 2, designs, queries) == expected def test_search_dress_designs_case4(): designs = [ (1, 4, 5, 6), (2, 4, 5, 6) ] queries = [ (4, 5, 6) ] expected = [ [1, 2] ] assert search_dress_designs(2, 1, designs, queries) == expected def test_search_dress_designs_case5(): designs = [ (1, 1, 1, 1), (2, 1, 1, 2), (3, 2, 1, 1), (4, 1, 2, 1), (5, 1, 1, 1) ] queries = [ (1, 1, 1), (1, 2, 1) ] expected = [ [1, 5], [4] ] assert search_dress_designs(5, 2, designs, queries) == expected","solution":"def search_dress_designs(n, m, designs, queries): Searches for dress designs that match given queries. :param n: Number of dress designs :param m: Number of queries :param designs: List of tuples where each tuple contains (id, color_id, length_id, style_id) :param queries: List of tuples where each tuple contains (query_color_id, query_length_id, query_style_id) :return: List of results for each query. Each result is either a sorted list of matching dress ids or \\"No matches found\\". design_dict = {} for design in designs: id, color_id, length_id, style_id = design if (color_id, length_id, style_id) not in design_dict: design_dict[(color_id, length_id, style_id)] = [] design_dict[(color_id, length_id, style_id)].append(id) results = [] for query in queries: query_color_id, query_length_id, query_style_id = query key = (query_color_id, query_length_id, query_style_id) if key in design_dict: results.append(sorted(design_dict[key])) else: results.append(\\"No matches found\\") return results"},{"question":"def largest_kxk_sum(matrix, n, m, k): Given a matrix of integers, find the largest sum of any square sub-matrix of size k x k, where k is a positive integer provided as input. :param matrix: List[List[int]], the n x m matrix :param n: int, number of rows in the matrix :param m: int, number of columns in the matrix :param k: int, size of the k x k sub-matrix :return: int, the largest sum of any k x k sub-matrix >>> largest_kxk_sum([ ... [1, 2, -1, 4, 5], ... [-8, 3, 4, 2, 1], ... [3, 8, -10, 5, -3], ... [1, -2, 3, 9, 6] ... ], 4, 5, 2) 17 >>> largest_kxk_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], 3, 3, 2) 4 >>> largest_kxk_sum([ ... [1, -2, 3], ... [-4, 5, -6], ... [7, -8, 9] ... ], 3, 3, 1) 9 >>> largest_kxk_sum([ ... [1, 2], ... [3, 4] ... ], 2, 2, 2) 10 >>> largest_kxk_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ], 3, 3, 2) -12 >>> largest_kxk_sum([[1]], 1, 1, 1) 1","solution":"def largest_kxk_sum(matrix, n, m, k): Find the largest sum of any k x k sub-matrix in the given n x m matrix. :param matrix: List[List[int]], the n x m matrix :param n: int, number of rows in the matrix :param m: int, number of columns in the matrix :param k: int, size of the k x k sub-matrix :return: int, the largest sum of any k x k sub-matrix max_sum = float('-inf') # Precompute the prefix sum matrix prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n+1): for j in range(1, m+1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) # Calculate the sum of every k x k sub-matrix for i in range(k, n + 1): for j in range(k, m + 1): sub_matrix_sum = (prefix_sum[i][j] - prefix_sum[i-k][j] - prefix_sum[i][j-k] + prefix_sum[i-k][j-k]) max_sum = max(max_sum, sub_matrix_sum) return max_sum"},{"question":"def is_balanced(expression: str) -> bool: Given an arithmetic expression, determine if the parentheses are balanced. Returns True if the parentheses in the expression are balanced, and False otherwise. >>> is_balanced(\\"(1 + (2 * 3) - (4 / 2))\\") == True >>> is_balanced(\\"(1 + 2) * (3 / 4))\\") == False >>> is_balanced(\\"((1 + 2) * 3 / 4\\") == False >>> is_balanced(\\"1 + 2 * 3 - 4 / 2\\") == True >>> is_balanced(\\"(1 + ((2 + 3) * (4 / 2)))\\") == True >>> is_balanced(\\"\\") == True >>> is_balanced(\\"((()))))\\") == False >>> is_balanced(\\"((())\\") == False >>> is_balanced(\\"()()()()\\") == True","solution":"def is_balanced(expression): Returns True if the parentheses in the expression are balanced, and False otherwise. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if len(stack) == 0: return False stack.pop() return len(stack) == 0"},{"question":"class TemperatureTracker: def __init__(self, temperatures): self.temperatures = temperatures self.prefix_sums = self._compute_prefix_sums() def _compute_prefix_sums(self): Compute the prefix sums of the temperatures list. pass def update(self, day, temperature): Update the temperature on a specific day. Parameters: day (int): The day of the temperature to update. temperature (int): The new temperature to set for the specified day. pass def get_average(self, start, end): Find the average temperature for a specified range of days. Parameters: start (int): The starting day of the range. end (int): The ending day of the range. Returns: float: The average temperature for the specified range. pass # Example to demonstrate usage if __name__ == \\"__main__\\": temperatures = [30, 25, 28, 32, 27] tracker = TemperatureTracker(temperatures) print(tracker.get_average(2, 4)) # Expected: 28.33 tracker.update(3, 35) print(tracker.get_average(2, 4)) # Expected: 30.67 # Unit Tests def test_temperature_tracker_initial_average(): temperatures = [30, 25, 28, 32, 27] tracker = TemperatureTracker(temperatures) assert tracker.get_average(2, 4) == 28.33 def test_temperature_tracker_update_and_average(): temperatures = [30, 25, 28, 32, 27] tracker = TemperatureTracker(temperatures) tracker.update(3, 35) assert tracker.get_average(2, 4) == 30.67 def test_temperature_tracker_full_range_average(): temperatures = [30, 25, 28, 32, 27] tracker = TemperatureTracker(temperatures) assert tracker.get_average(1, 5) == 28.4 def test_temperature_tracker_single_day_update(): temperatures = [30, 25, 28, 32, 27] tracker = TemperatureTracker(temperatures) tracker.update(2, 30) assert tracker.get_average(2, 2) == 30.00 def test_temperature_tracker_no_update_average(): temperatures = [30, 25, 28, 32, 27] tracker = TemperatureTracker(temperatures) assert tracker.get_average(4, 5) == 29.5","solution":"class TemperatureTracker: def __init__(self, temperatures): self.temperatures = temperatures self.prefix_sums = self._compute_prefix_sums() def _compute_prefix_sums(self): prefix_sums = [0] * (len(self.temperatures) + 1) for i in range(1, len(self.temperatures) + 1): prefix_sums[i] = prefix_sums[i - 1] + self.temperatures[i - 1] return prefix_sums def update(self, day, temperature): original_temp = self.temperatures[day - 1] diff = temperature - original_temp self.temperatures[day - 1] = temperature for i in range(day, len(self.temperatures) + 1): self.prefix_sums[i] += diff def get_average(self, start, end): sum_range = self.prefix_sums[end] - self.prefix_sums[start - 1] count = end - start + 1 return round(sum_range / count, 2)"},{"question":"def can_form_clusters(n: int, spots: List[int]) -> str: Determines if all puppies can form clusters with the same number of spots by only multiplying their spots by 2 or 3 any number of times. >>> can_form_clusters(4, [12, 18, 24, 36]) 'Possible' >>> can_form_clusters(3, [3, 7, 9]) 'Impossible' >>> can_form_clusters(2, [24, 36]) 'Possible' >>> can_form_clusters(3, [27, 54, 9]) 'Possible' >>> can_form_clusters(5, [2, 4, 8, 16, 32]) 'Possible' >>> can_form_clusters(3, [1, 1, 1]) 'Possible' >>> can_form_clusters(3, [2, 3, 5]) 'Impossible' >>> can_form_clusters(4, [6, 12, 36, 72]) 'Possible'","solution":"def can_form_clusters(n, spots): Determines if all puppies can form clusters with the same number of spots by only multiplying their spots by 2 or 3 any number of times. def normalize_spots(x): while x % 2 == 0: x //= 2 while x % 3 == 0: x //= 3 return x normalized_spots = [normalize_spots(spot) for spot in spots] # If all normalized spots are the same, it is possible to form clusters if all(spot == normalized_spots[0] for spot in normalized_spots): return \\"Possible\\" else: return \\"Impossible\\""},{"question":"def inventory_summary(n, identifiers): Returns the total number of computers and the breakdown of desktop and laptop counts. >>> inventory_summary(5, ['D001', 'L015', 'L022', 'D399', 'L089']) (5, 2, 3) >>> inventory_summary(3, ['D001', 'D002', 'D003']) (3, 3, 0) >>> inventory_summary(3, ['L001', 'L002', 'L003']) (3, 0, 3) >>> inventory_summary(5, ['D001', 'L015', 'L002', 'D004', 'L030']) (5, 2, 3) >>> inventory_summary(1, ['D000']) (1, 1, 0) >>> inventory_summary(1, ['L999']) (1, 0, 1)","solution":"def inventory_summary(n, identifiers): Returns the total number of computers and the breakdown of desktop and laptop counts. :param n: An integer representing the total number of computers. :param identifiers: A list of strings representing the unique identifiers of the computers. :return: A tuple containing (total_computers, desktop_count, laptop_count) desktop_count = 0 laptop_count = 0 for identifier in identifiers: if identifier[0] == 'D': desktop_count += 1 elif identifier[0] == 'L': laptop_count += 1 total_computers = n return total_computers, desktop_count, laptop_count"},{"question":"import random from typing import List def generate_grid(N: int, M: int) -> List[str]: Generates an N x M grid with randomly placed characters 'A', 'B', and 'C'. Ensures each character appears at least once in the grid. :param N: Number of rows. :param M: Number of columns. :return: A list of strings representing the grid. >>> len(generate_grid(3, 4)) 3 >>> len(generate_grid(3, 4)[0]) 4 >>> all(char in set(''.join(generate_grid(5, 5))) for char in 'ABC') True pass if __name__ == \\"__main__\\": import pytest def test_grid_size(): grid = generate_grid(3, 4) assert len(grid) == 3 assert all(len(row) == 4 for row in grid) def test_characters_presence(): grid = generate_grid(5, 5) all_chars = set(''.join(grid)) assert 'A' in all_chars assert 'B' in all_chars assert 'C' in all_chars def test_small_grid(): grid = generate_grid(1, 3) assert len(grid) == 1 assert all(len(row) == 3 for row in grid) all_chars = set(''.join(grid)) assert 'A' in all_chars assert 'B' in all_chars assert 'C' in all_chars def test_single_cell_grid(): grid = generate_grid(1, 1) assert len(grid) == 1 assert len(grid[0]) == 1 assert grid[0] in ['A', 'B', 'C'] pytest.main()","solution":"import random def generate_grid(N, M): Generates an N x M grid with randomly placed characters 'A', 'B', and 'C'. Ensures each character appears at least once in the grid. characters = ['A', 'B', 'C'] grid = [] # Pre-fill the grid with random characters for _ in range(N): row = [random.choice(characters) for _ in range(M)] grid.append(''.join(row)) # Ensure each character 'A', 'B', 'C' appears at least once # Place 'A', 'B', 'C' randomly in the grid if they are not present all_chars = set('ABC') present_chars = set(''.join(grid)) missing_chars = all_chars - present_chars for char in missing_chars: i, j = random.randint(0, N-1), random.randint(0, M-1) grid[i] = grid[i][:j] + char + grid[i][j+1:] return grid"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isBalanced(root: TreeNode) -> bool: Determine if a binary tree is height-balanced. Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the binary tree is height-balanced, False otherwise. >>> root = deserialize(\\"1 2 3 4 5 # # # # # #\\") >>> isBalanced(root) True >>> root = deserialize(\\"1 2 3 4 # # # 5 # # #\\") >>> isBalanced(root) False pass def deserialize(data: str) -> TreeNode: Deserialize string to binary tree. Args: data (str): Serialized binary tree. Returns: TreeNode: The root node of the binary tree. >>> deserialize(\\"1 2 3 4 5 # # # # # #\\").val 1 >>> deserialize(\\"#\\") None if not data: return None nodes = data.split() if nodes[0] == '#': return None root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): current = queue.pop(0) if nodes[i] != '#': current.left = TreeNode(int(nodes[i])) queue.append(current.left) i += 1 if i < len(nodes) and nodes[i] != '#': current.right = TreeNode(int(nodes[i])) queue.append(current.right) i += 1 return root","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isBalanced(root: TreeNode) -> bool: Determine if a binary tree is height-balanced. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) if abs(left_height - right_height) > 1 or not left_balanced or not right_balanced: return current_height, False return current_height, True _, balanced = check_balance(root) return balanced def deserialize(data: str) -> TreeNode: Deserialize string to binary tree. if not data: return None nodes = data.split() if nodes[0] == '#': return None root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): current = queue.pop(0) if nodes[i] != '#': current.left = TreeNode(int(nodes[i])) queue.append(current.left) i += 1 if i < len(nodes) and nodes[i] != '#': current.right = TreeNode(int(nodes[i])) queue.append(current.right) i += 1 return root"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the total amount of rainwater trapped along the street, given an array representing the heights of buildings. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([0, 1, 2, 3, 4, 5]) 0 >>> trap_rain_water([5, 4, 3, 2, 1, 0]) 0 >>> trap_rain_water([3, 3, 3, 3]) 0 >>> trap_rain_water([3, 0, 3]) 3 >>> trap_rain_water([3, 0, 2, 0, 4]) 7 >>> trap_rain_water([]) 0 >>> trap_rain_water([4, 1, 1, 4]) 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Compute left_max for each building left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Compute right_max for each building right_max[n-1] = heights[n-1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate total water trapped total_water = 0 for i in range(n): total_water += max(0, min(left_max[i], right_max[i]) - heights[i]) return total_water"},{"question":"def has_pair_with_sum(n: int, target: int, arr: List[int]) -> str: Determine whether there are two distinct indexes i and j in the array such that the sum of arr[i] and arr[j] equals the target value. >>> has_pair_with_sum(5, 10, [1, 2, 3, 7, 8]) 'YES' >>> has_pair_with_sum(4, 20, [1, 2, 3, 4]) 'NO' >>> has_pair_with_sum(1, 0, [0]) 'NO' >>> has_pair_with_sum(5, 1000000, [999999, 1, 500000, 500000, 999999]) 'YES' >>> has_pair_with_sum(5, 1000000, [1000000, 0, -1000000, 1, 999999]) 'YES' >>> has_pair_with_sum(5, -3, [-1, -2, -3, -4, -5]) 'YES' >>> has_pair_with_sum(3, 0, [0, 0, 0]) 'YES'","solution":"def has_pair_with_sum(n, target, arr): Returns 'YES' if there are two distinct indexes i and j in the array such that the sum of arr[i] and arr[j] equals the target value. Otherwise, returns 'NO'. seen = set() for number in arr: if target - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def smallest_divisor(nums: List[int], threshold: int) -> int: Finds the smallest positive integer divisor d such that the sum of Math.ceil(nums[i] / d) is less than or equal to the specified threshold, given the array of integers nums. Args: nums (List[int]): The array of integers. threshold (int): The specified threshold value. Returns: int: The smallest positive integer divisor d. Examples: >>> smallest_divisor([1, 2, 5, 9, 10], 7) 5 >>> smallest_divisor([10], 10) 1 >>> smallest_divisor([10], 1) 10 >>> smallest_divisor([1, 2, 3, 4, 5], 100) 1 >>> smallest_divisor([1], 1) 1 >>> smallest_divisor([1000000, 1000000], 2) 1000000 >>> smallest_divisor([1000000, 1000000, 1000000], 3) 1000000 from solution import smallest_divisor def test_smallest_divisor_example(): assert smallest_divisor([1, 2, 5, 9, 10], 7) == 5 def test_smallest_divisor_single_element(): assert smallest_divisor([10], 10) == 1 assert smallest_divisor([10], 1) == 10 def test_smallest_divisor_same_elements(): assert smallest_divisor([10, 10, 10], 3) == 10 assert smallest_divisor([10, 10, 10], 30) == 1 def test_smallest_divisor_large_thresh(): assert smallest_divisor([1, 2, 3, 4, 5], 100) == 1 def test_smallest_divisor_edge_case(): assert smallest_divisor([1], 1) == 1 def test_smallest_divisor_high_values(): assert smallest_divisor([1000000, 1000000], 2) == 1000000 assert smallest_divisor([1000000, 1000000, 1000000], 3) == 1000000","solution":"import math def smallest_divisor(nums, threshold): Finds the smallest positive integer divisor d such that the sum of Math.ceil(nums[i] / d) is less than or equal to the specified threshold, given the array of integers nums. def operation_sum(d): return sum(math.ceil(num / d) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if operation_sum(mid) <= threshold: right = mid else: left = mid + 1 return left"},{"question":"def count_even_sum_subarrays(nums: List[int]) -> int: Returns the number of contiguous subarrays with an even sum. >>> count_even_sum_subarrays([1]) == 0 >>> count_even_sum_subarrays([2]) == 1 >>> count_even_sum_subarrays([1, 3, 5]) == 2 >>> count_even_sum_subarrays([2, 4, 6]) == 6 >>> count_even_sum_subarrays([1, 2, 3, 4, 5]) == 6 >>> count_even_sum_subarrays([1, 2, 3, 4]) == 4","solution":"def count_even_sum_subarrays(nums): Returns the number of contiguous subarrays with an even sum. even_count = 0 odd_count = 0 current_sum = 0 result = 0 for num in nums: current_sum += num if current_sum % 2 == 0: result += 1 + even_count even_count += 1 else: result += odd_count odd_count += 1 return result # Example usage: # n = 5 # nums = [1, 2, 3, 4, 5] # print(count_even_sum_subarrays(nums)) # Output: 6"},{"question":"from typing import List, Tuple def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 pass def process_queries(t: int, queries: List[Tuple[int, int]]) -> List[int]: Processes multiple queries about grid sizes and returns the number of unique paths for each query. t: int - number of queries queries: list of tuples - each tuple contains two integers (m, n) representing the grid size >>> process_queries(3, [(3, 7), (3, 2), (7, 3)]) [28, 3, 28] >>> process_queries(2, [(1, 1), (2, 2)]) [1, 2] pass","solution":"from math import comb def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. return comb(m + n - 2, m - 1) def process_queries(t, queries): Processes multiple queries about grid sizes and returns the number of unique paths for each query. t: int - number of queries queries: list of tuples - each tuple contains two integers (m, n) representing the grid size results = [] for (m, n) in queries: results.append(unique_paths(m, n)) return results"},{"question":"from typing import List, Tuple def is_network_connected(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Given n railway stations and m direct rail connections between some pairs of stations, determine if the rail network is connected. A rail network is considered connected if there exists a path (direct or indirect) between any pair of stations. Args: n (int): Number of stations. m (int): Number of rail connections. connections (List[Tuple[int, int]]): List of tuples where each tuple (u, v) represents a direct rail connection between station u and station v. Returns: str: \\"YES\\" if the network is connected, otherwise \\"NO\\". >>> is_network_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YES' >>> is_network_connected(4, 2, [(1, 2), (2, 3)]) 'NO' >>> is_network_connected(1, 0, []) 'YES' >>> is_network_connected(3, 0, []) 'NO' >>> n = 100000 >>> m = 100000 >>> connections = [(i, i+1) for i in range(1, 100000)] >>> is_network_connected(n, m, connections) 'YES' >>> n = 100000 >>> m = 99999 >>> connections = [(i, i+1) for i in range(1, 99999)] >>> is_network_connected(n, m, connections) 'NO'","solution":"def is_network_connected(n, m, connections): from collections import defaultdict, deque if n == 1: return \\"YES\\" if m == 0: return \\"NO\\" graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) queue = deque([1]) visited[1] = True count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return \\"YES\\" if count == n else \\"NO\\""},{"question":"def generate_pattern(n: int): Generates a centered pyramid pattern with asterisks. Parameters: n (int): Number of lines in the pyramid pattern. Examples: >>> generate_pattern(1) * >>> generate_pattern(2) * * * >>> generate_pattern(3) * * * * * * >>> generate_pattern(4) * * * * * * * * * * >>> generate_pattern(5) * * * * * * * * * * * * * * *","solution":"def generate_pattern(n): Generates a centered pyramid pattern with asterisks. Parameters: - n (int): The number of lines in the pyramid pattern. Returns: - None, just prints the pattern. for i in range(1, n + 1): # calculate padding spaces padding = n - i # create the line with \`i\` asterisks separated by spaces pattern = ' '.join(['*'] * i) # print the padded pattern line print(' ' * padding + pattern)"},{"question":"def min_traversal_cost(n: int, edges: List[Tuple[int, int, int]], queries: List[int]) -> List[int]: Calculate the minimum traversal cost required to reach each target node from the root of the tree. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int, int]]): Each tuple contains three integers (u, v, w) representing an edge between nodes u and v with a weight w. queries (List[int]): The list of target nodes to find the minimum cost to reach from the root. Returns: List[int]: A list of minimum costs for each query. If a target node cannot be reached, the cost should be -1. Examples: >>> min_traversal_cost(5, [(1, 2, 4), (1, 3, 3), (2, 4, 2), (2, 5, 1)], [4, 5, 3]) [6, 5, 3] >>> min_traversal_cost(4, [(1, 2, 1), (3, 4, 1)], [4, 3]) [-1, -1]","solution":"def min_traversal_cost(n, edges, queries): from collections import defaultdict, deque import sys # Initialize the graph graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(start): costs = {i: sys.maxsize for i in range(1, n+1)} costs[start] = 0 queue = deque([start]) while queue: node = queue.popleft() current_cost = costs[node] for neighbour, weight in graph[node]: if current_cost + weight < costs[neighbour]: costs[neighbour] = current_cost + weight queue.append(neighbour) return costs # Calculate all costs from root node 1 costs_from_root = bfs(1) # Process each query results = [] for target in queries: if costs_from_root[target] == sys.maxsize: results.append(-1) else: results.append(costs_from_root[target]) return results"},{"question":"def kth_smallest_element(arr, k): Finds and returns the k-th smallest element in the array. >>> kth_smallest_element([3, 2, 1, 5, 4], 2) 2 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7","solution":"def kth_smallest_element(arr, k): Finds and returns the k-th smallest element in the array. # Helper function for partition in quickselect def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index # Helper function for quickselect def quickselect(left, right, k_smallest): if left == right: return arr[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"def check_traffic_lights(n: int, wait_times: List[int]) -> str: Verify if no two consecutive traffic lights have the same wait time. >>> check_traffic_lights(5, [30, 20, 30, 50, 20]) == \\"YES\\" >>> check_traffic_lights(4, [15, 15, 20, 25]) == \\"NO\\"","solution":"def check_traffic_lights(n, wait_times): Checks whether no two consecutive traffic lights have the same wait time. Parameters: n (int): Number of traffic lights. wait_times (list): List of wait times for the traffic lights. Returns: str: \\"YES\\" if no two consecutive traffic lights have the same wait time, \\"NO\\" otherwise. for i in range(n - 1): if wait_times[i] == wait_times[i + 1]: return \\"NO\\" return \\"YES\\""},{"question":"def minimize_partition_sum(nums: List[int], k: int) -> int: Partition the list into k non-empty contiguous subarrays such that the sum of the k subarrays is minimized. >>> minimize_partition_sum([1, 2, 3, 4, 5], 2) 9 >>> minimize_partition_sum([1, 1, 1, 1], 2) 2 >>> minimize_partition_sum([1, 2, 3, 4, 5], 1) 15 >>> minimize_partition_sum([4, 3, 2, 1], 4) 4 >>> minimize_partition_sum([7, 2, 5, 10, 8], 2) 18","solution":"def minimize_partition_sum(nums, k): # Function to compute the sum of the maximum elements of k partitions def can_partition(max_sum): partitions = 1 current_sum = 0 for num in nums: if current_sum + num > max_sum: partitions += 1 current_sum = num if partitions > k: return False else: current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"def max_packages(n, m, capacity, weight): Determine the maximum number of packages that can be delivered while respecting the weight limits of the trucks. Parameters: - n (int): number of trucks - m (int): number of packages - capacity (List[int]): list of integers representing the capacity of each truck - weight (List[int]): list of integers representing the weight of each package Returns: int: the maximum number of packages that can be delivered >>> max_packages(5, 7, [10, 8, 15, 7, 9], [8, 5, 4, 3, 7, 5, 6]) 7 >>> max_packages(5, 0, [10, 8, 15, 7, 9], []) 0 >>> max_packages(0, 5, [], [1, 2, 3, 4, 5]) 0 >>> max_packages(3, 3, [5, 5, 5], [5, 5, 5]) 3 >>> max_packages(2, 3, [5, 5], [10, 10, 10]) 0 >>> capacities = [1000] * 100 >>> weights = [10] * 100 >>> max_packages(100, 100, capacities, weights) == 100 True","solution":"def max_packages(n, m, capacity, weight): Returns the maximum number of packages that can be delivered given the capacities of trucks and weights of packages. # Sort capacities and weights to apply a greedy approach capacity.sort(reverse=True) weight.sort(reverse=True) # Initialize a list to keep track of what each truck carries truck_load = [0] * n package_count = 0 for w in weight: for i in range(n): if truck_load[i] + w <= capacity[i]: truck_load[i] += w package_count += 1 break return package_count # Example usage: # n = 5, m = 7 # capacity = [10, 8, 15, 7, 9] # weight = [8, 5, 4, 3, 7, 5, 6] # Output should be 7"},{"question":"from typing import List, Tuple, Union class DynamicArray: def __init__(self): pass def add(self, x): Adds an integer to the end of the array. pass def remove(self): Removes the last integer from the array. If the array is empty, do nothing. pass def find_median(self) -> Union[float, str]: Finds and returns the median of the integers in the array. Returns: - The median as an integer or float. - \\"Empty\\" if the array is empty. pass def process_operations(operations: List[Tuple[int, int]]) -> List[Union[float, str]]: Processes a series of operations to modify the array. Args: operations (List[Tuple[int, int]]): List of operations to be processed. Returns: List[Union[float, str]]: Results of the 'find_median' operations. >>> process_operations([(1, 1), (1, 2), (1, 3), (3,), (2,), (3,)]) [2.0, 1.5] >>> process_operations([(1, 1), (2,), (3,)]) [\\"Empty\\"] >>> process_operations([(1, 4), (3,)]) [4.0] >>> process_operations([(1, 1), (1, 3), (3,)]) [2.0] >>> process_operations([(1, 1), (1, 5), (1, 3), (3,)]) [3.0] pass def test_operations_example1(): operations = [(1, 1), (1, 2), (1, 3), (3,), (2,), (3,)] assert process_operations(operations) == [2.0, 1.5] def test_operations_empty_median(): operations = [(1, 1), (2,), (3,)] assert process_operations(operations) == [\\"Empty\\"] def test_operations_single_element(): operations = [(1, 4), (3,)] assert process_operations(operations) == [4.0] def test_operations_even_number_of_elements(): operations = [(1, 1), (1, 3), (3,)] assert process_operations(operations) == [2.0] def test_operations_odd_number_of_elements(): operations = [(1, 1), (1, 5), (1, 3), (3,)] assert process_operations(operations) == [3.0]","solution":"import bisect class DynamicArray: def __init__(self): self.arr = [] def add(self, x): bisect.insort(self.arr, x) def remove(self): if self.arr: self.arr.pop() def find_median(self): n = len(self.arr) if n == 0: return \\"Empty\\" mid = n // 2 if n % 2 == 1: return float(self.arr[mid]) else: return (self.arr[mid] + self.arr[mid - 1]) / 2.0 def process_operations(operations): da = DynamicArray() result = [] for op in operations: if op[0] == 1: da.add(op[1]) elif op[0] == 2: da.remove() elif op[0] == 3: result.append(da.find_median()) return result"},{"question":"def reconstruct_path(n: int, records: List[Tuple[int, int]]) -> List[int]: Reconstruct the order of key points during a hike from the starting point to the end point. >>> reconstruct_path(4, [(1, 2), (2, 3), (3, 4), (4, -1)]) [1, 2, 3, 4] >>> reconstruct_path(1, [(1, -1)]) [1] >>> reconstruct_path(5, [(1, 3), (3, 5), (5, 4), (4, 6), (6, -1)]) [1, 3, 5, 4, 6] >>> reconstruct_path(4, [(10, 20), (20, 30), (30, 40), (40, -1)]) [10, 20, 30, 40] >>> reconstruct_path(5, [(2, 3), (1, 2), (3, 5), (5, 4), (4, -1)]) [1, 2, 3, 5, 4]","solution":"def reconstruct_path(n, records): # Create dictionaries to store incoming and outgoing paths out_paths = {} in_paths = {} for a, b in records: if b != -1: out_paths[a] = b in_paths[b] = a # Find the starting point (no incoming paths) start = None for a, b in records: if a not in in_paths: start = a break # Reconstruct the path from start path = [] current = start while current != -1: path.append(current) current = out_paths.get(current, -1) return path # Example Usage # n = 4 # records = [(1, 2), (2, 3), (3, 4), (4, -1)] # print(reconstruct_path(n, records)) # Output: [1, 2, 3, 4]"},{"question":"def summarize_expenses(transactions: list) -> dict: Summarizes the total amount spent on each expense type. Args: transactions (list): A list of transactions, where each transaction is represented by a tuple (expense_type: int, amount: float). Returns: dict: A dictionary with expense types as keys and the total amount spent on that type as values. Examples: >>> summarize_expenses([(1, 5.0), (2, 7.5), (1, 3.0), (3, 8.0), (2, 1.5)]) {1: 8.0, 2: 9.0, 3: 8.0} >>> summarize_expenses([(1, 0.0), (2, 0.0), (1, 0.0)]) {1: 0.0, 2: 0.0} from solution import summarize_expenses def test_single_transaction(): transactions = [(1, 5.0)] assert summarize_expenses(transactions) == {1: 5.0} def test_multiple_types_single_transaction_each(): transactions = [(1, 5.0), (2, 7.5), (3, 8.0)] assert summarize_expenses(transactions) == {1: 5.0, 2: 7.5, 3: 8.0} def test_multiple_transactions_same_type(): transactions = [(1, 5.0), (1, 3.0)] assert summarize_expenses(transactions) == {1: 8.0} def test_multiple_transactions_mixed_types(): transactions = [(1, 5.0), (2, 7.5), (1, 3.0), (3, 8.0), (2, 1.5)] assert summarize_expenses(transactions) == {1: 8.0, 2: 9.0, 3: 8.0} def test_zero_amount_transactions(): transactions = [(1, 0.0), (2, 0.0), (1, 0.0)] assert summarize_expenses(transactions) == {1: 0.0, 2: 0.0} def test_large_amounts(): transactions = [(1, 1000000.0), (2, 2000000.0), (1, 3333333.33)] assert summarize_expenses(transactions) == {1: 4333333.33, 2: 2000000.0}","solution":"def summarize_expenses(transactions: list) -> dict: Summarizes the total amount spent on each expense type. Args: transactions (list): A list of transactions, where each transaction is represented by a tuple (expense_type: int, amount: float). Returns: dict: A dictionary with expense types as keys and the total amount spent on that type as values. expense_summary = {} for expense_type, amount in transactions: if expense_type in expense_summary: expense_summary[expense_type] += amount else: expense_summary[expense_type] = amount return expense_summary"},{"question":"def apply_price_cap(products, cap): Apply a price cap to a list of products and generate a summary report. Args: - products (list of dict): Each dictionary has keys \\"name\\", \\"category\\", \\"price\\". - cap (float): The maximum price allowed for any product. Returns: - tuple: A list of updated product dictionaries and a dictionary summarizing pre-cap and post-cap totals per category. >>> products = [ ... {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 1200.00}, ... {\\"name\\": \\"Headphones\\", \\"category\\": \\"Electronics\\", \\"price\\": 150.00}, ... {\\"name\\": \\"Coffee Mug\\", \\"category\\": \\"Kitchen\\", \\"price\\": 15.99}, ... {\\"name\\": \\"Blender\\", \\"category\\": \\"Kitchen\\", \\"price\\": 45.50}, ... {\\"name\\": \\"Desk Chair\\", \\"category\\": \\"Furniture\\", \\"price\\": 200.00} ... ] >>> cap = 100.00 >>> apply_price_cap(products, cap) ([ {'name': 'Laptop', 'category': 'Electronics', 'price': 100.0}, {'name': 'Headphones', 'category': 'Electronics', 'price': 100.0}, {'name': 'Coffee Mug', 'category': 'Kitchen', 'price': 15.99}, {'name': 'Blender', 'category': 'Kitchen', 'price': 45.5}, {'name': 'Desk Chair', 'category': 'Furniture', 'price': 100.0} ], { 'Electronics': {'pre_cap_total': 1350.0, 'post_cap_total': 200.0}, 'Kitchen': {'pre_cap_total': 61.49, 'post_cap_total': 61.49}, 'Furniture': {'pre_cap_total': 200.0, 'post_cap_total': 100.0} }) pass def test_apply_price_cap_basic(): products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 1200.00}, {\\"name\\": \\"Headphones\\", \\"category\\": \\"Electronics\\", \\"price\\": 150.00}, {\\"name\\": \\"Coffee Mug\\", \\"category\\": \\"Kitchen\\", \\"price\\": 15.99}, {\\"name\\": \\"Blender\\", \\"category\\": \\"Kitchen\\", \\"price\\": 45.50}, {\\"name\\": \\"Desk Chair\\", \\"category\\": \\"Furniture\\", \\"price\\": 200.00} ] cap = 100.00 expected_products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 100.00}, {\\"name\\": \\"Headphones\\", \\"category\\": \\"Electronics\\", \\"price\\": 100.00}, {\\"name\\": \\"Coffee Mug\\", \\"category\\": \\"Kitchen\\", \\"price\\": 15.99}, {\\"name\\": \\"Blender\\", \\"category\\": \\"Kitchen\\", \\"price\\": 45.50}, {\\"name\\": \\"Desk Chair\\", \\"category\\": \\"Furniture\\", \\"price\\": 100.00} ] expected_summary = { \\"Electronics\\": {\\"pre_cap_total\\": 1350.00, \\"post_cap_total\\": 200.00}, \\"Kitchen\\": {\\"pre_cap_total\\": 61.49, \\"post_cap_total\\": 61.49}, \\"Furniture\\": {\\"pre_cap_total\\": 200.00, \\"post_cap_total\\": 100.00} } updated_products, summary = apply_price_cap(products, cap) assert updated_products == expected_products assert summary == expected_summary def test_apply_price_cap_no_changes(): products = [ {\\"name\\": \\"Book\\", \\"category\\": \\"Books\\", \\"price\\": 15.00}, {\\"name\\": \\"Notebook\\", \\"category\\": \\"Stationery\\", \\"price\\": 5.00} ] cap = 20.00 expected_products = [ {\\"name\\": \\"Book\\", \\"category\\": \\"Books\\", \\"price\\": 15.00}, {\\"name\\": \\"Notebook\\", \\"category\\": \\"Stationery\\", \\"price\\": 5.00} ] expected_summary = { \\"Books\\": {\\"pre_cap_total\\": 15.00, \\"post_cap_total\\": 15.00}, \\"Stationery\\": {\\"pre_cap_total\\": 5.00, \\"post_cap_total\\": 5.00} } updated_products, summary = apply_price_cap(products, cap) assert updated_products == expected_products assert summary == expected_summary def test_apply_price_cap_all_changes(): products = [ {\\"name\\": \\"Luxury Watch\\", \\"category\\": \\"Accessories\\", \\"price\\": 300.00}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 800.00} ] cap = 250.00 expected_products = [ {\\"name\\": \\"Luxury Watch\\", \\"category\\": \\"Accessories\\", \\"price\\": 250.00}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 250.00} ] expected_summary = { \\"Accessories\\": {\\"pre_cap_total\\": 300.00, \\"post_cap_total\\": 250.00}, \\"Electronics\\": {\\"pre_cap_total\\": 800.00, \\"post_cap_total\\": 250.00} } updated_products, summary = apply_price_cap(products, cap) assert updated_products == expected_products assert summary == expected_summary def test_apply_price_cap_empty_list(): products = [] cap = 100.00 expected_products = [] expected_summary = {} updated_products, summary = apply_price_cap(products, cap) assert updated_products == expected_products assert summary == expected_summary def test_apply_price_cap_high_cap(): products = [ {\\"name\\": \\"Pen\\", \\"category\\": \\"Stationery\\", \\"price\\": 2.00}, {\\"name\\": \\"Pencil\\", \\"category\\": \\"Stationery\\", \\"price\\": 1.00} ] cap = 500.00 expected_products = [ {\\"name\\": \\"Pen\\", \\"category\\": \\"Stationery\\", \\"price\\": 2.00}, {\\"name\\": \\"Pencil\\", \\"category\\": \\"Stationery\\", \\"price\\": 1.00} ] expected_summary = { \\"Stationery\\": {\\"pre_cap_total\\": 3.00, \\"post_cap_total\\": 3.00} } updated_products, summary = apply_price_cap(products, cap) assert updated_products == expected_products assert summary == expected_summary","solution":"def apply_price_cap(products, cap): Apply a price cap to a list of products and generate a summary report. Args: - products (list of dict): Each dictionary has keys \\"name\\", \\"category\\", \\"price\\". - cap (float): The maximum price allowed for any product. Returns: - tuple: A list of updated product dictionaries and a dictionary summarizing pre-cap and post-cap totals per category. updated_products = [] summary = {} for product in products: category = product[\\"category\\"] original_price = product[\\"price\\"] capped_price = min(original_price, cap) # Update the product price if necessary updated_product = product.copy() updated_product[\\"price\\"] = capped_price updated_products.append(updated_product) if category not in summary: summary[category] = { \\"pre_cap_total\\": 0.0, \\"post_cap_total\\": 0.0, } summary[category][\\"pre_cap_total\\"] += original_price summary[category][\\"post_cap_total\\"] += capped_price return updated_products, summary"},{"question":"from typing import List def is_valid_parentheses(s: str) -> str: Determine if the string s contains a valid sequence of parentheses. >>> is_valid_parentheses(\\"()\\") \\"YES\\" >>> is_valid_parentheses(\\"([)]\\") \\"NO\\" >>> is_valid_parentheses(\\"([]{})\\") \\"YES\\" pass def process_inputs(T: int, strings: List[str]) -> List[str]: Process multiple strings to determine if each string contains a valid sequence of parentheses. >>> process_inputs(3, [\\"()\\", \\"([)]\\", \\"([]{})\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_inputs(2, [\\"{[()]}\\", \\"{[()]}\\"]) [\\"YES\\", \\"YES\\"] pass","solution":"def is_valid_parentheses(s): stack = [] mapping = {\\")\\": \\"(\\", \\"]\\": \\"[\\", \\"}\\": \\"{\\"} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\" def process_inputs(T, strings): results = [] for s in strings: results.append(is_valid_parentheses(s)) return results"},{"question":"def contains_nearby_almost_duplicate(nums: List[int], k: int, t: int) -> bool: Determine if there are two distinct indices \`i\` and \`j\` such that: - abs(nums[i] - nums[j]) <= t - abs(i - j) <= k :param nums: List[int] - List of integers :param k: int - Maximum allowed difference between indices :param t: int - Maximum allowed difference between elements :return: bool - True if such elements are found, False otherwise >>> contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 2, 3) False >>> contains_nearby_almost_duplicate([1, 2, 3, 1], 3, 0) True # Your code here from solution import contains_nearby_almost_duplicate def test_case_1(): nums = [1, 5, 9, 1, 5, 9] k = 2 t = 3 assert contains_nearby_almost_duplicate(nums, k, t) == False def test_case_2(): nums = [1, 2, 3, 1] k = 3 t = 0 assert contains_nearby_almost_duplicate(nums, k, t) == True def test_case_3(): nums = [1, 2, 3, 1, 2, 3] k = 2 t = 1 assert contains_nearby_almost_duplicate(nums, k, t) == True def test_case_4(): nums = [1, 2, 3, 1, 2, 3] k = 1 t = 0 assert contains_nearby_almost_duplicate(nums, k, t) == False def test_case_5(): nums = [] k = 0 t = 0 assert contains_nearby_almost_duplicate(nums, k, t) == False def test_case_6(): nums = [1, 2, 3, 4, 5] k = 3 t = 4 assert contains_nearby_almost_duplicate(nums, k, t) == True","solution":"def contains_nearby_almost_duplicate(nums, k, t): Determine if there are two distinct indices \`i\` and \`j\` such that: - abs(nums[i] - nums[j]) <= t - abs(i - j) <= k :param nums: List[int] - List of integers :param k: int - Maximum allowed difference between indices :param t: int - Maximum allowed difference between elements :return: bool - True if such elements are found, False otherwise if k <= 0 or t < 0 or len(nums) < 2: return False num_dict = {} width = t + 1 for i, num in enumerate(nums): bucket = num // width if bucket in num_dict: return True if (bucket - 1 in num_dict and abs(num_dict[bucket - 1] - num) < width): return True if (bucket + 1 in num_dict and abs(num_dict[bucket + 1] - num) < width): return True num_dict[bucket] = num if i >= k: del num_dict[nums[i - k] // width] return False"},{"question":"def remove_two_largest(lst): Write a function that takes a list of integers and returns a new list containing all the elements of the original list except the two largest ones. If the input list has fewer than three elements, return an empty list. >>> remove_two_largest([5, 3, 9, 1, 10, 6]) [5, 3, 1, 6] >>> remove_two_largest([3]) []","solution":"def remove_two_largest(lst): Returns a list excluding the two largest elements from the original list. If the input list has fewer than three elements, return an empty list. if len(lst) < 3: return [] first_largest = max(lst) lst.remove(first_largest) second_largest = max(lst) lst.remove(second_largest) return lst"},{"question":"def can_be_palindrome(s: str) -> str: Determine if the string \`s\` can be converted into a palindrome by changing at most two characters. >>> can_be_palindrome(\\"abcba\\") 'YES' >>> can_be_palindrome(\\"abcdba\\") 'YES' >>> can_be_palindrome(\\"abcdef\\") 'NO' pass def test_already_palindrome(): assert can_be_palindrome(\\"abcba\\") == \\"YES\\" def test_one_change_needed(): assert can_be_palindrome(\\"abccba\\") == \\"YES\\" assert can_be_palindrome(\\"abcdba\\") == \\"YES\\" def test_two_changes_needed(): assert can_be_palindrome(\\"abccda\\") == \\"YES\\" assert can_be_palindrome(\\"aabbcb\\") == \\"YES\\" assert can_be_palindrome(\\"aacdccaa\\") == \\"YES\\" def test_more_than_two_changes_needed(): assert can_be_palindrome(\\"abcdef\\") == \\"NO\\" assert can_be_palindrome(\\"abcdegf\\") == \\"NO\\" def test_empty_and_single_character(): assert can_be_palindrome(\\"\\") == \\"YES\\" assert can_be_palindrome(\\"a\\") == \\"YES\\"","solution":"def can_be_palindrome(s): Determine if the string \`s\` can be converted into a palindrome by changing at most two characters. n = len(s) mismatch_count = 0 for i in range(n//2): if s[i] != s[n-i-1]: mismatch_count += 1 if mismatch_count > 2: return \\"NO\\" return \\"YES\\""},{"question":"def min_boxes(n, m, weights): Determine the minimum number of boxes needed to store all the toys without exceeding the weight limit. :param n: int, number of toys :param m: int, weight limit of each box :param weights: list of int, weights of the toys :return: int, minimum number of boxes needed >>> min_boxes(5, 10, [2, 3, 4, 6, 5]) 3 >>> min_boxes(4, 10, [6, 8, 5, 7]) 4 >>> min_boxes(5, 10, [10, 10, 10, 10, 10]) 5 >>> min_boxes(4, 15, [1, 2, 2, 3]) 1 >>> min_boxes(6, 12, [6, 3, 8, 4, 2, 7]) 3 >>> min_boxes(1, 10, [11]) 1","solution":"def min_boxes(n, m, weights): Determine the minimum number of boxes needed to store all the toys without exceeding the weight limit. :param n: int, number of toys :param m: int, weight limit of each box :param weights: list of int, weights of the toys :return: int, minimum number of boxes needed from heapq import heappush, heappop # Sort weights in descending order to try to fit the heaviest items first weights.sort(reverse=True) # Min-heap to keep track of box capacities boxes = [] for weight in weights: # If no boxes yet or the lightest box cannot fit the current toy, add a new box if not boxes or boxes[0] + weight > m: heappush(boxes, weight) else: # Fit the toy into the existing box with least remaining capacity that can still hold it heappush(boxes, heappop(boxes) + weight) return len(boxes)"},{"question":"def findIndices(arr, target): Finds two indices in the array such that the elements at these indices add up to the target sum. Returns the indices in 1-based format. >>> findIndices([2, 7, 11, 15], 9) (1, 2) >>> findIndices([-1, -2, -3, -4, -5], -8) (3, 5) >>> findIndices([0, 4, 3, 0], 0) (1, 4) >>> findIndices([1000000000, 3, 5, 7, 2], 1000000005) (1, 3) >>> findIndices([10, 20], 30) (1, 2)","solution":"def findIndices(arr, target): Finds two indices in the array such that the elements at these indices add up to the target sum. Returns the indices in 1-based format. index_map = {} # Dictionary to store value to index mapping for i, num in enumerate(arr): complement = target - num if complement in index_map: return (index_map[complement] + 1, i + 1) index_map[num] = i"},{"question":"def is_almost_palindrome(s: str) -> bool: Determines if a string can become a palindrome by changing at most one character. Parameters: s (str): The input string consisting of lowercase letters. Returns: bool: True if the string is almost a palindrome, False otherwise. Examples: >>> is_almost_palindrome(\\"racecar\\") == True >>> is_almost_palindrome(\\"abca\\") == True >>> is_almost_palindrome(\\"abcdefg\\") == False >>> is_almost_palindrome(\\"aabbccddccbaa\\") == True >>> is_almost_palindrome(\\"\\") == True >>> is_almost_palindrome(\\"a\\") == True >>> is_almost_palindrome(\\"ab\\") == True >>> is_almost_palindrome(\\"aaabbb\\") == False","solution":"def is_almost_palindrome(s): Determines if a string can become a palindrome by changing at most one character. Parameters: s (str): The input string consisting of lowercase letters. Returns: bool: True if the string is almost a palindrome, False otherwise. def is_palindrome_range(start, end): Check if a given range in the string is a palindrome. return s[start:end + 1] == s[start:end + 1][::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing one mismatched character either from the left or the right return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left, right = left + 1, right - 1 return True"},{"question":"def is_prime(n: int) -> str: Returns 'true' if n is a prime number, otherwise returns 'false'. >>> is_prime(1) 'false' >>> is_prime(2) 'true' >>> is_prime(3) 'true' >>> is_prime(4) 'false' >>> is_prime(997) 'true' >>> is_prime(1000) 'false'","solution":"def is_prime(n): Returns 'true' if n is a prime number, otherwise returns 'false'. if n <= 1: return 'false' if n == 2: return 'true' if n % 2 == 0: return 'false' limit = int(n**0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return 'false' return 'true'"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor of a and b using the Euclidean algorithm. pass def euler_totient(n: int) -> int: Returns the value of Euler's Totient function φ(n), which counts the number of positive integers up to n that are relatively prime to n. >>> euler_totient(1) == 1 >>> euler_totient(10) == 4 >>> euler_totient(2) == 1 >>> euler_totient(3) == 2 >>> euler_totient(4) == 2 >>> euler_totient(5) == 4 >>> euler_totient(6) == 2 >>> euler_totient(7) == 6 >>> euler_totient(1000000) == 400000 >>> euler_totient(13) == 12 pass","solution":"def gcd(a, b): Returns the greatest common divisor of a and b using the Euclidean algorithm. while b != 0: a, b = b, a % b return a def euler_totient(n): Returns the value of Euler's Totient function φ(n), which counts the number of positive integers up to n that are relatively prime to n. if n == 1: return 1 result = 1 # Start with 1 because 1 is always relatively prime to any number. for i in range(2, n + 1): if gcd(n, i) == 1: result += 1 return result"},{"question":"def has_pair_with_sum(arr: List[int], n: int, k: int) -> str: Determine whether there exists a pair of distinct integers in the array such that their sum is exactly equal to k. Parameters: arr (list): List of integers. n (int): Size of the array. k (int): Target sum value. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_sum([1, 2, 3, 3], 4, 4) \\"YES\\" >>> has_pair_with_sum([5, -1, 4], 3, 5) \\"NO\\"","solution":"def has_pair_with_sum(arr, n, k): Determine whether there exists a pair of distinct integers in the array such that their sum is exactly equal to k. Parameters: arr (list): List of integers. n (int): Size of the array. k (int): Target sum value. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def generate_k_interesting_sequence(n: int, k: int) -> List[int]: Generate a k-interesting sequence of length n with the largest possible lexicographical order. Parameters: n (int): The length of the sequence. k (int): The subsequence length. Returns: List[int]: The k-interesting sequence. >>> generate_k_interesting_sequence(1, 1) [1] >>> generate_k_interesting_sequence(2, 1) [2, 1] >>> generate_k_interesting_sequence(3, 3) [3, 2, 1] >>> generate_k_interesting_sequence(4, 2) [4, 3, 2, 1] >>> generate_k_interesting_sequence(5, 1) [5, 4, 3, 2, 1]","solution":"def generate_k_interesting_sequence(n, k): Generate a k-interesting sequence of length n with the largest possible lexicographical order. Parameters: n (int): The length of the sequence. k (int): The subsequence length. Returns: List[int]: The k-interesting sequence. # Initialize the sequence with the largest possible values sequence = list(range(n, 0, -1)) return sequence"},{"question":"def manage_inventory(n, m, initial_stocks, operations): Manage the inventory of products with addition and query operations. Args: n (int): Number of products. m (int): Number of operations. initial_stocks (list): Initial stock quantities of the products. operations (list): List of tuples representing operations. Returns: list: Results of all query operations in the order they appeared. from solution import manage_inventory def test_manage_inventory_example_case(): result = manage_inventory(3, 5, [10, 20, 30], [(2, 2), (1, 1, 15), (2, 1), (1, 3, 10), (2, 3)]) assert result == [20, 25, 40] def test_manage_inventory_initial_stocks(): result = manage_inventory(3, 2, [10, 0, 5], [(2, 1), (2, 2)]) assert result == [10, 0] def test_manage_inventory_addition_operations(): result = manage_inventory(3, 3, [10, 20, 30], [(1, 1, 10), (1, 2, 10), (1, 3, 10)]) assert result == [] def test_manage_inventory_only_queries(): result = manage_inventory(3, 3, [10, 20, 30], [(2, 1), (2, 2), (2, 3)]) assert result == [10, 20, 30] def test_manage_inventory_alternating_operations(): result = manage_inventory(3, 6, [5, 15, 25], [(2, 1), (1, 1, 5), (2, 1), (1, 2, 5), (2, 2), (1, 3, 5)]) assert result == [5, 10, 20] def test_manage_inventory_large_operations(): result = manage_inventory(2, 4, [1000000000, 1000000000], [(1, 1, 1000000000), (2, 1), (1, 2, 1000000000), (2, 2)]) assert result == [2000000000, 2000000000]","solution":"def manage_inventory(n, m, initial_stocks, operations): Manage the inventory of products with addition and query operations. Args: n (int): Number of products. m (int): Number of operations. initial_stocks (list): Initial stock quantities of the products. operations (list): List of tuples representing operations. Returns: list: Results of all query operations in the order they appeared. stocks = initial_stocks[:] # Create a copy of initial stocks results = [] for operation in operations: if operation[0] == 1: # Addition operation p, q = operation[1], operation[2] stocks[p - 1] += q elif operation[0] == 2: # Query operation p = operation[1] results.append(stocks[p - 1]) return results"},{"question":"def min_difference_in_subarrays(n: int, m: int, arr: List[int]) -> int: Function to find the minimum difference between the maximum and minimum values of any subarray of length \`m\` from the array \`arr\`. >>> min_difference_in_subarrays(7, 3, [10, 100, 300, 200, 1000, 20, 30]) 20 >>> min_difference_in_subarrays(5, 2, [1, 5, 9, 12, 20]) 3 >>> min_difference_in_subarrays(8, 4, [10, 20, 30, 40, 1, 2, 3, 4]) 3 >>> min_difference_in_subarrays(4, 4, [10, 20, 30, 40]) 30 >>> min_difference_in_subarrays(6, 1, [5, 8, 12, 16, 21, 29]) 0","solution":"def min_difference_in_subarrays(n, m, arr): Function to find the minimum difference between the maximum and minimum values of any subarray of length \`m\` from the array \`arr\`. arr.sort() min_diff = float('inf') for i in range(n - m + 1): current_diff = arr[i + m - 1] - arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def smallest_absolute_difference(arr): Returns the smallest absolute difference between any two distinct integers in the array. >>> smallest_absolute_difference([1, 3, 6, 10, 15]) == 2 >>> smallest_absolute_difference([4, 2, 1, 3]) == 1 >>> smallest_absolute_difference([-1, -5, 10, 7]) == 3 >>> smallest_absolute_difference([-10, -5, -1, -20]) == 4 >>> smallest_absolute_difference([0, -1, 1, 50]) == 1","solution":"def smallest_absolute_difference(arr): Returns the smallest absolute difference between any two distinct integers in the array. arr.sort() min_diff = float('inf') for i in range(1, len(arr)): diff = abs(arr[i] - arr[i-1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"from typing import List, Tuple def shortest_travel_time(n: int, m: int, s: int, d: int, roads: List[Tuple[int, int, int]]) -> int: Determine the shortest time required to travel from a given starting intersection to a destination intersection using the roads. >>> shortest_travel_time(5, 6, 1, 5, [(1, 2, 2), (1, 3, 5), (2, 3, 1), (3, 4, 1), (2, 4, 2), (4, 5, 3)]) 7 >>> shortest_travel_time(3, 2, 1, 3, [(1, 2, 2), (2, 1, 2)]) -1 >>> shortest_travel_time(3, 3, 1, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 4)]) 4 >>> shortest_travel_time(4, 4, 1, 4, [(1, 2, 1), (2, 3, 1), (1, 3, 3), (3, 4, 1)]) 3 >>> shortest_travel_time(2, 2, 1, 2, [(1, 1, 1), (1, 2, 2)]) 2 >>> shortest_travel_time(3, 4, 1, 3, [(1, 2, 2), (2, 3, 2), (3, 2, 1), (2, 1, 1)]) 4","solution":"import heapq def shortest_travel_time(n, m, s, d, roads): graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) # Dijkstra's Algorithm heap = [(0, s)] distances = {i: float('inf') for i in range(1, n + 1)} distances[s] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return distances[d] if distances[d] != float('inf') else -1 # Example usage: # result = shortest_travel_time(5, 6, 1, 5, [(1, 2, 2), (1, 3, 5), (2, 3, 1), (3, 4, 1), (2, 4, 2), (4, 5, 3)]) # print(result) # Output: 7"},{"question":"def calculate_restoration_costs(n: int, m: int, grid: List[List[int]], plans: List[Tuple[int, int, int]]) -> List[int]: Calculates the energy required to restore attacked barriers in the grid. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (List[List[int]]): n x m grid representing the height of each barrier. plans (List[Tuple[int, int, int]]): List of attack plans where each plan is a tuple (x, y, k). Returns: List[int]: List of total restoration costs for each plan. >>> n = 3 >>> m = 3 >>> grid = [ ... [4, 3, 2], ... [2, 5, 7], ... [1, 8, 6] ... ] >>> plans = [(2, 2, 1), (3, 1, 2)] >>> calculate_restoration_costs(n, m, grid, plans) [5, 2] >>> n = 2 >>> m = 2 >>> grid = [ ... [100, 99], ... [10, 1] ... ] >>> plans = [(1, 1, 3), (2, 2, 10)] >>> calculate_restoration_costs(n, m, grid, plans) [300, 10]","solution":"def calculate_restoration_costs(n, m, grid, plans): Calculates the energy required to restore attacked barriers in the grid. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (List[List[int]]): n x m grid representing the height of each barrier. plans (List[Tuple[int, int, int]]): List of attack plans where each plan is a tuple (x, y, k). Returns: List[int]: List of total restoration costs for each plan. costs = [] for x, y, k in plans: original_height = grid[x-1][y-1] cost = original_height * k costs.append(cost) return costs"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes): node_dict = {} root = None for value, left, right in nodes: if value not in node_dict: node_dict[value] = TreeNode(value) if left != 0: if left not in node_dict: node_dict[left] = TreeNode(left) node_dict[value].left = node_dict[left] if right != 0: if right not in node_dict: node_dict[right] = TreeNode(right) node_dict[value].right = node_dict[right] if root is None: root = node_dict[value] return root def tree_depth(root): Determine the depth of a given binary tree. >>> tree_depth(TreeNode(1)) 1 def find_tree_depth(n, node_data): Calculate the depth of a binary tree given the node information. >>> n = 5 >>> node_data = [\\"1 2 3\\", \\"2 4 5\\", \\"3 0 0\\", \\"4 0 0\\", \\"5 0 0\\"] >>> find_tree_depth(n, node_data) 3","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes): node_dict = {} root = None for value, left, right in nodes: if value not in node_dict: node_dict[value] = TreeNode(value) if left != 0: if left not in node_dict: node_dict[left] = TreeNode(left) node_dict[value].left = node_dict[left] if right != 0: if right not in node_dict: node_dict[right] = TreeNode(right) node_dict[value].right = node_dict[right] if root is None: root = node_dict[value] return root def tree_depth(root): if not root: return 0 left_depth = tree_depth(root.left) right_depth = tree_depth(root.right) return max(left_depth, right_depth) + 1 def find_tree_depth(n, node_data): nodes = [] for data in node_data: nodes.append(tuple(map(int, data.split()))) root = build_tree(nodes) return tree_depth(root)"},{"question":"def min_cost_to_beautiful_string(n: int, s: str) -> int: Maria loves to play with strings in her free time. Recently, she came up with a new game where she takes a string consisting solely of the characters 'a', 'b', and 'c', and tries to transform it into a beautiful string through a series of operations. A string is considered beautiful if no two adjacent characters are the same. Maria can perform two types of operations on the string: 1. Replace any character with another character: This will cost her 1 unit per operation. 2. Remove any character: This will cost her 2 units per operation. Given an initial string, find the minimum cost for Maria to transform it into a beautiful string. Args: n (int): The length of the string. s (str): A string of length n, consisting only of the characters 'a', 'b', and 'c'. Returns: int: The minimum cost to transform the given string into a beautiful string. Example: >>> min_cost_to_beautiful_string(6, \\"aaabcc\\") 2 >>> min_cost_to_beautiful_string(3, \\"abc\\") 0","solution":"def min_cost_to_beautiful_string(n, s): min_cost = 0 i = 0 while i < n - 1: if s[i] == s[i + 1]: min_cost += 1 # Replacing the character with another one if i + 2 < n: if s[i] != 'a' and s[i + 2] != 'a': s = s[:i + 1] + 'a' + s[i + 2:] elif s[i] != 'b' and s[i + 2] != 'b': s = s[:i + 1] + 'b' + s[i + 2:] else: s = s[:i + 1] + 'c' + s[i + 2:] else: if s[i] != 'a': s = s[:i + 1] + 'a' elif s[i] != 'b': s = s[:i + 1] + 'b' else: s = s[:i + 1] + 'c' i += 1 return min_cost"},{"question":"def max_sales_sum(n: int, d: int, sales: List[List[int]]) -> List[int]: Find the maximum sales amount recorded by each member over any continuous subarray of k days. Parameters: n (int): Number of team members d (int): Number of days sales (List[List[int]]): 2D list representing sales amounts Returns: List[int]: List of maximum sales sums for each team member Example: >>> max_sales_sum(3, 4, [ ... [2, 1, 3, 4], ... [7, 3, 2, 1], ... [6, 5, 3, 8] ... ]) [10, 13, 22] from solution import max_sales_sum def test_example_case(): assert max_sales_sum(3, 4, [ [2, 1, 3, 4], [7, 3, 2, 1], [6, 5, 3, 8] ]) == [10, 13, 22] def test_single_member_single_day(): assert max_sales_sum(1, 1, [ [5] ]) == [5] def test_all_zero_sales(): assert max_sales_sum(3, 5, [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ]) == [0, 0, 0] def test_increasing_sales(): assert max_sales_sum(2, 3, [ [1, 2, 3], [4, 5, 6] ]) == [6, 15] def test_decreasing_sales(): assert max_sales_sum(2, 3, [ [3, 2, 1], [6, 5, 4] ]) == [6, 15] def test_mixed_sales(): assert max_sales_sum(2, 5, [ [1, -2, 3, -4, 5], [-1, 2, -3, 4, -5] ]) == [5, 4]","solution":"def max_sales_sum(n, d, sales): def max_subarray_sum(arr, length): max_sum = float('-inf') for k in range(1, length+1): current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, length): current_sum += arr[i] - arr[i-k] max_sum = max(max_sum, current_sum) return max_sum result = [] for i in range(n): result.append(max_subarray_sum(sales[i], d)) return result"},{"question":"def remove_vowels(s: str) -> str: Write a function that takes a single string s (1 ≤ |s| ≤ 100) containing only lowercase alphabets, and returns a string where all vowels are removed. The vowels are 'a', 'e', 'i', 'o', 'u'. If the resulting string is empty, return \\"No consonants\\". >>> remove_vowels(\\"hello\\") 'hll' >>> remove_vowels(\\"world\\") 'wrld' >>> remove_vowels(\\"aeiou\\") 'No consonants' >>> remove_vowels(\\"bcdfghjklmnpqrstvwxyz\\") 'bcdfghjklmnpqrstvwxyz'","solution":"def remove_vowels(s): Returns a string with all vowels removed from the input string s. If the resulting string is empty, returns \\"No consonants\\". vowels = set('aeiou') result = ''.join([char for char in s if char not in vowels]) return result if result else \\"No consonants\\""},{"question":"def max_workshops(k: int, l: int, available_slots: list[int], required_durations: list[int]) -> int: Determines the maximum number of workshops that can be scheduled. Parameters: k (int): total number of time slots. l (int): number of required workshop durations. available_slots (list of int): lengths of available contiguous time slots. required_durations (list of int): durations required for the workshops. Returns: int: Maximum number of workshops that can be scheduled. >>> max_workshops(5, 3, [10, 5, 5, 2, 5], [10, 5, 6]) 2 >>> max_workshops(4, 3, [1, 1, 1, 1], [2, 2, 2]) 0 >>> max_workshops(5, 5, [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]) 5 >>> max_workshops(3, 5, [10, 10, 10], [5, 5, 5, 5, 5]) 3 >>> max_workshops(5, 3, [10, 10, 10, 10, 10], [5, 5, 5]) 3 >>> max_workshops(4, 3, [1, 2, 3, 4], [2, 4, 1]) 3 >>> max_workshops(5, 5, [1000000000]*5, [7, 8, 9, 10, 11]) 5 # Sort available time slots and required durations. available_slots.sort() required_durations.sort() # Initialize pointers for both lists. i, j = 0, 0 max_scheduled = 0 while i < k and j < l: if available_slots[i] >= required_durations[j]: # Schedule this workshop max_scheduled += 1 j += 1 # Move to the next available slot i += 1 return max_scheduled","solution":"def max_workshops(k, l, available_slots, required_durations): Determines the maximum number of workshops that can be scheduled. Parameters: k (int): total number of time slots. l (int): number of required workshop durations. available_slots (list of int): lengths of available contiguous time slots. required_durations (list of int): durations required for the workshops. Returns: int: Maximum number of workshops that can be scheduled. # Sort available time slots and required durations available_slots.sort() required_durations.sort() # Initialize pointers for both lists i, j = 0, 0 max_scheduled = 0 while i < k and j < l: if available_slots[i] >= required_durations[j]: # Schedule this workshop max_scheduled += 1 j += 1 # Move to the next available slot i += 1 return max_scheduled"},{"question":"from typing import List def min_transformations_to_palindrome(s: str) -> int: Returns the minimum number of transformations required to make the string s a palindrome. >>> min_transformations_to_palindrome(\\"abca\\") 1 >>> min_transformations_to_palindrome(\\"racecar\\") 0 >>> min_transformations_to_palindrome(\\"abc\\") 2 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> process_test_cases([\\"abca\\", \\"racecar\\", \\"abc\\", \\"a\\", \\"ab\\", \\"aa\\"]) [1, 0, 2, 0, 1, 0] >>> process_test_cases([\\"abcd\\", \\"deed\\", \\"cba\\"]) [3, 0, 2]","solution":"def min_transformations_to_palindrome(s): Returns the minimum number of transformations required to make the string s a palindrome. def min_deletions_to_make_palindrome(s, l, r): if l >= r: return 0 if s[l] == s[r]: return min_deletions_to_make_palindrome(s, l + 1, r - 1) else: delete_l = min_deletions_to_make_palindrome(s, l + 1, r) delete_r = min_deletions_to_make_palindrome(s, l, r - 1) return 1 + min(delete_l, delete_r) return min_deletions_to_make_palindrome(s, 0, len(s) - 1) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(min_transformations_to_palindrome(s)) return results"},{"question":"def find_indices_with_target_diff(arr, target): Returns a pair of indices such that the absolute difference between the values at these indices is target. If no such pair exists, returns [-1, -1]. Parameters: arr (List[int]): The list of integers. target (int): The target difference. Returns: List[int]: The pair of indices or [-1, -1] if no pair exists. Examples: >>> find_indices_with_target_diff([1, 5, 3, 4, 2], 2) [0, 2] >>> find_indices_with_target_diff([1, 2, 3, 4, 5], 5) [-1, -1] >>> find_indices_with_target_diff([8, 7, 5, 1, 10], 3) [1, 2] from solution import find_indices_with_target_diff def test_example_1(): arr = [1, 5, 3, 4, 2] target = 2 result = find_indices_with_target_diff(arr, target) # Possible pair (1, 3) or (3, 1) with any order of smaller index first assert result in [[0, 2], [2, 0], [3, 4], [4, 3]] def test_example_2(): arr = [1, 2, 3, 4, 5] target = 5 result = find_indices_with_target_diff(arr, target) assert result == [-1, -1] def test_example_3(): arr = [8, 7, 5, 1, 10] target = 3 result = find_indices_with_target_diff(arr, target) # Possible pair (7, 10) or (10, 7) with any order of smaller index first assert result in [[1, 4], [4, 1], [2, 0], [0, 2]] def test_no_pair_exists(): arr = [1, 1, 1, 1, 1] target = 2 result = find_indices_with_target_diff(arr, target) assert result == [-1, -1] def test_single_element(): arr = [1] target = 0 result = find_indices_with_target_diff(arr, target) assert result == [-1, -1] def test_zero_target(): arr = [7, 10, 5, 5, 8, 3] target = 0 result = find_indices_with_target_diff(arr, target) # Possible pair (5, 5) with indices (2, 3) or (3, 2) assert result in [[2, 3], [3, 2]] def test_large_numbers(): arr = [1000000000, -1000000000] target = 2000000000 result = find_indices_with_target_diff(arr, target) assert result in [[0, 1], [1, 0]] def test_same_element_multiple_times(): arr = [4, 4, 4, 4] target = 0 result = find_indices_with_target_diff(arr, target) assert result in [[0, 1], [1, 0], [0, 2], [2, 0], [0, 3], [3, 0], [1, 2], [2, 1], [1, 3], [3, 1], [2, 3], [3, 2]]","solution":"def find_indices_with_target_diff(arr, target): Returns a pair of indices such that the absolute difference between the values at these indices is target. If no such pair exists, returns [-1, -1]. num_to_index = {} for i, num in enumerate(arr): if (num - target) in num_to_index: return [num_to_index[num - target], i] if (num + target) in num_to_index: return [num_to_index[num + target], i] num_to_index[num] = i return [-1, -1]"},{"question":"def max_coins(n: int, matrix: List[List[int]]) -> int: Returns the maximum number of coins that can be collected from the top-left to the bottom-right corner of the matrix by only moving right or down. >>> max_coins(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_coins(1, [[5]]) 5","solution":"def max_coins(n, matrix): Returns the maximum number of coins that can be collected from the top-left to the bottom-right corner of the matrix by only moving right or down. dp = [[0] * n for _ in range(n)] dp[0][0] = matrix[0][0] # Initialize first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize first column for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp matrix for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"def can_sort_binary_string(s: str) -> str: Determines if it is possible to sort a binary string (consisting only of '0' and '1') in non-decreasing order. The operations allowed are: 1. Swap any two consecutive \\"01\\" to \\"10\\". 2. Swap any two consecutive \\"10\\" to \\"01\\". 3. Swap any two consecutive \\"00\\" to \\"11\\". 4. Swap any two consecutive \\"11\\" to \\"00\\". Args: s (str): A binary string. Returns: str: \\"YES\\" if it's possible to sort the string in non-decreasing order, otherwise \\"NO\\". Examples: >>> can_sort_binary_string(\\"000\\") \\"YES\\" >>> can_sort_binary_string(\\"111\\") \\"YES\\" >>> can_sort_binary_string(\\"1100\\") \\"YES\\" >>> can_sort_binary_string(\\"1010\\") \\"YES\\" >>> can_sort_binary_string(\\"0110\\") \\"YES\\" >>> can_sort_binary_string(\\"10101\\") \\"NO\\" >>> can_sort_binary_string(\\"0\\") \\"YES\\" >>> can_sort_binary_string(\\"1\\") \\"YES\\" >>> can_sort_binary_string(\\"\\") \\"YES\\" >>> can_sort_binary_string(\\"01\\") \\"YES\\" >>> can_sort_binary_string(\\"10\\") \\"YES\\"","solution":"def can_sort_binary_string(s): Determines if the given binary string can be sorted in non-decreasing order using the allowed operations. count_0 = s.count('0') count_1 = s.count('1') # If every '0' can be swapped to the left and every '1' to the right, we can always sort it. return \\"YES\\" if count_0 + count_1 == len(s) else \\"NO\\""},{"question":"def is_star_possible(n: int, k: int) -> str: Determines if a non-degenerate star can be drawn using all vertices exactly once, and returns the sequence of vertices if possible. >>> is_star_possible(5, 2) 'YESn1 3 5 2 4' >>> is_star_possible(6, 2) 'NO' >>> is_star_possible(7, 3) 'YESn1 4 7 3 6 2 5' >>> is_star_possible(3, 1) 'NO' >>> is_star_possible(8, 4) 'NO'","solution":"def is_star_possible(n, k): Determines if a non-degenerate star can be drawn using all vertices exactly once, and returns the sequence of vertices if possible. if n % k == 0 or gcd(n, k) != 1: return \\"NO\\" sequence = [] current_vertex = 0 for _ in range(n): sequence.append(current_vertex + 1) current_vertex = (current_vertex + k) % n return f\\"YESn{' '.join(map(str, sequence))}\\" def gcd(a, b): Returns the greatest common divisor of a and b. while b: a, b = b, a % b return a"},{"question":"from typing import List, Tuple def check_travelers(a: int, b: int, r: int, travelers: List[Tuple[int, int]]) -> List[str]: Determines whether each traveler lies strictly inside the island. Parameters: a, b (int): The coordinates of the island's center. r (int): The radius of the island. travelers (list[tuple[int, int]]): List of tuples representing the coordinates of each traveler. Returns: list[str]: List of \\"APPROVED\\" or \\"DENIED\\" for each traveler. pass def test_travelers_inside_island(): assert check_travelers(5, 5, 4, [(4, 4), (6, 5), (5, 6)]) == [\\"APPROVED\\", \\"APPROVED\\", \\"APPROVED\\"] def test_travelers_on_boundary(): assert check_travelers(5, 5, 4, [(9, 5), (5, 9), (1, 5), (5, 1)]) == [\\"DENIED\\", \\"DENIED\\", \\"DENIED\\", \\"DENIED\\"] def test_travelers_outside_island(): assert check_travelers(5, 5, 4, [(10, 5), (5, 10), (0, 0)]) == [\\"DENIED\\", \\"DENIED\\", \\"DENIED\\"] def test_mixed_travelers(): assert check_travelers(5, 5, 4, [(3, 5), (4, 4), (8, 8)]) == [\\"APPROVED\\", \\"APPROVED\\", \\"DENIED\\"] def test_edge_cases(): assert check_travelers(1, 1, 1, [(2, 1), (1, 2), (0, 1), (1, 0), (2, 2)]) == [\\"DENIED\\", \\"DENIED\\", \\"DENIED\\", \\"DENIED\\", \\"DENIED\\"]","solution":"def check_travelers(a, b, r, travelers): Determines whether each traveler lies strictly inside the island. Parameters: a, b (int): The coordinates of the island's center. r (int): The radius of the island. travelers (list[tuple[int, int]]): List of tuples representing the coordinates of each traveler. Returns: list[str]: List of \\"APPROVED\\" or \\"DENIED\\" for each traveler. results = [] for x, y in travelers: distance_squared = (x - a) ** 2 + (y - b) ** 2 if distance_squared < r ** 2: results.append(\\"APPROVED\\") else: results.append(\\"DENIED\\") return results"},{"question":"def longest_subsequence(n: int, d: int, sequence: List[int]) -> int: Find the length of the longest subsequence such that the absolute difference between any two consecutive elements in the subsequence is no greater than d. Args: n : int : number of elements in the sequence d : int : maximum allowed absolute difference sequence : list of int : sequence of integers Returns: int : length of the longest valid subsequence >>> longest_subsequence(6, 2, [1, 3, 5, 7, 9, 11]) == 6 >>> longest_subsequence(5, 4, [10, 1, 4, 2, 7]) == 3 >>> longest_subsequence(1, 1, [5]) == 1 >>> longest_subsequence(5, 0, [2, 2, 2, 2, 2]) == 5 >>> longest_subsequence(6, 1000000000, [1, 100000000, 1000000000, 500, 250, 125]) == 6 >>> longest_subsequence(5, 3, [1, 10, 4, 25, 7]) == 3 pass","solution":"def longest_subsequence(n, d, sequence): Find the length of the longest subsequence such that the absolute difference between any two consecutive elements in the subsequence is no greater than d. Args: n : int : number of elements in the sequence d : int : maximum allowed absolute difference sequence : list of int : sequence of integers Returns: int : length of the longest valid subsequence # Initialize a dp array where dp[i] represents the length of the longest subsequence # ending at index i. dp = [1] * n for i in range(1, n): for j in range(i): if abs(sequence[i] - sequence[j]) <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage: # print(longest_subsequence(6, 2, [1, 3, 5, 7, 9, 11])) # Outputs: 6 # print(longest_subsequence(5, 4, [10, 1, 4, 2, 7])) # Outputs: 3"},{"question":"from typing import List, Tuple def subtree_sum(n: int, q: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Given a tree with \`n\` nodes rooted at node \`1\` and \`q\` queries, determine the sum of values of all nodes in the subtree of the given nodes. Parameters: n (int): The number of nodes in the tree. q (int): The number of queries. values (List[int]): The values of the nodes. edges (List[Tuple[int, int]]): The edges of the tree. queries (List[int]): The queries for the subtree sums. Returns: List[int]: The list of subtree sums for each query. pass def test_subtree_sum(): n, q = 5, 3 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] queries = [2, 3, 1] assert subtree_sum(n, q, values, edges, queries) == [11, 3, 15] def test_subtree_sum_single_node(): n, q = 1, 1 values = [5] edges = [] queries = [1] assert subtree_sum(n, q, values, edges, queries) == [5] def test_subtree_sum_large_values(): n, q = 3, 2 values = [1000000000, 1000000000, 1000000000] edges = [(1, 2), (1, 3)] queries = [1, 2] assert subtree_sum(n, q, values, edges, queries) == [3000000000, 1000000000] def test_subtree_sum_additional_cases(): n, q = 4, 2 values = [1, 10, 100, 1000] edges = [(1, 2), (1, 3), (3, 4)] queries = [1, 3] assert subtree_sum(n, q, values, edges, queries) == [1111, 1100]","solution":"from collections import defaultdict def subtree_sum(n, q, values, edges, queries): def dfs(node, parent): subtree_values[node] = values[node - 1] for neighbor in graph[node]: if neighbor != parent: dfs(neighbor, node) subtree_values[node] += subtree_values[neighbor] graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) subtree_values = [0] * (n + 1) dfs(1, -1) return [subtree_values[u] for u in queries]"},{"question":"def longest_subsequence_length(grades: List[int]) -> int: Returns the length of the longest subsequence where each grade differs by exactly 1 from the previous grade. >>> longest_subsequence_length([3, 4, 5, 6, 1, 2]) == 4 >>> longest_subsequence_length([10, 9, 5, 3, 2]) == 2 >>> longest_subsequence_length([4]) == 0 >>> longest_subsequence_length([5, 5, 5, 5]) == 1 >>> longest_subsequence_length([8, 7, 6, 5, 4, 3, 2, 1]) == 8 >>> longest_subsequence_length([1, 2, 3, 4, 5, 6, 7, 8]) == 8 >>> longest_subsequence_length([1, 2, 4, 5, 7, 8, 10]) == 2 >>> longest_subsequence_length([]) == 0 >>> longest_subsequence_length([2, 5]) == 1 >>> longest_subsequence_length([2, 3]) == 2","solution":"def longest_subsequence_length(grades): Returns the length of the longest subsequence where each grade differs by exactly 1 from the previous grade. if len(grades) < 2: return 0 max_length = 1 current_length = 1 for i in range(1, len(grades)): if abs(grades[i] - grades[i-1]) == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def maximum_tower_height(n: int, heights: List[int]) -> int: Given the heights of the blocks, determine the maximum possible height of the tower Lily can build under the constraint that blocks of the same parity (even or odd) must be placed consecutively. >>> maximum_tower_height(6, [1, 3, 5, 2, 8, 4]) 18 >>> maximum_tower_height(4, [2, 4, 6, 8]) 20 >>> maximum_tower_height(4, [1, 3, 5, 7]) 16 >>> maximum_tower_height(5, [2, 3, 4, 1, 5]) 15 >>> maximum_tower_height(1, [10]) 10 >>> maximum_tower_height(1000, list(range(1, 1001))) 500500","solution":"def maximum_tower_height(n, heights): Returns the maximum height of the tower that Lily can build, following the parity rules. even_heights = [h for h in heights if h % 2 == 0] odd_heights = [h for h in heights if h % 2 != 0] even_heights.sort(reverse=True) odd_heights.sort(reverse=True) max_height = sum(even_heights) + sum(odd_heights) return max_height"},{"question":"def is_isomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. >>> is_isomorphic(\\"egg\\", \\"add\\") True >>> is_isomorphic(\\"paper\\", \\"title\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False >>> is_isomorphic(\\"abc\\", \\"def\\") True >>> is_isomorphic(\\"ab\\", \\"aa\\") False >>> is_isomorphic(\\"a\\", \\"a\\") True >>> is_isomorphic(\\"ab\\", \\"ab\\") True >>> is_isomorphic(\\"abc\\", \\"ab\\") False >>> is_isomorphic(\\"aa\\", \\"bb\\") True >>> is_isomorphic(\\"abba\\", \\"xyyx\\") True >>> is_isomorphic(\\"aA\\", \\"bB\\") True","solution":"def is_isomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. Args: s (str): The first string. t (str): The second string. Returns: bool: True if the strings are isomorphic, False otherwise. if len(s) != len(t): return False s_to_t_mapping = {} t_to_s_mapping = {} for char_s, char_t in zip(s, t): if char_s in s_to_t_mapping and s_to_t_mapping[char_s] != char_t: return False if char_t in t_to_s_mapping and t_to_s_mapping[char_t] != char_s: return False s_to_t_mapping[char_s] = char_t t_to_s_mapping[char_t] = char_s return True"},{"question":"def product_except_self(nums): Given a list of integers nums, return a new list where each element is the product of all elements of nums except the one at the same index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] pass def parse_input_and_generate_output(input_string): Parse the input string, process it using the product_except_self function, and return the results in the required output format. >>> parse_input_and_generate_output(\\"1 2 3 4\\") \\"24 12 8 6\\" >>> parse_input_and_generate_output(\\"2 3 4 5\\") \\"60 40 30 24\\" pass","solution":"def product_except_self(nums): Given a list of integers nums, return a new list where each element is the product of all elements of nums except the one at the same index. length = len(nums) result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result def parse_input_and_generate_output(input_string): Parse the input string, process it using the product_except_self function, and return the results in the required output format. nums = list(map(int, input_string.split())) result = product_except_self(nums) return \\" \\".join(map(str, result))"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Handle q queries of reversing subarray from index l to index r and return the sum of the array modulo 10^9+7 after processing each query. Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [15, 15, 15] >>> process_queries(1, 1, [1000000], [(1, 1)]) [1000000 % (10**9 + 7)] >>> process_queries(4, 2, [1, 2, 3, 4], [(1, 2), (3, 4)]) [10, 10] >>> process_queries(6, 2, [1, 1, 1, 1, 1, 1], [(1, 6), (1, 6)]) [6, 6] >>> process_queries(3, 1, [10**6, 10**6, 10**6], [(1, 3)]) [(3 * 10**6) % (10**9 + 7)]","solution":"MOD = 10**9 + 7 def process_queries(n, q, array, queries): result = [] # Calculate initial sum current_sum = sum(array) % MOD for l, r in queries: # Reverse the subarray from index l to index r array[l-1:r] = reversed(array[l-1:r]) # The sum doesn't change when reversing subarray, so we can directly use current sum result.append(current_sum) return result"},{"question":"def can_form_amount(t: int, amounts: List[int]) -> List[str]: Determine whether it is possible to obtain a desired amount n using any combination of coins with denominations of 3 and 5 units. >>> can_form_amount(3, [11, 14, 1]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_form_amount(4, [8, 20, 7, 19]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] pass # Unit Tests def test_can_form_amount(): assert can_form_amount(3, [11, 14, 1]) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_all_no(): assert can_form_amount(3, [1, 2, 4]) == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_exact_flags(): assert can_form_amount(4, [3, 5, 10, 15]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] def test_mixed_values(): assert can_form_amount(4, [8, 20, 7, 19]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] def test_edge_case(): assert can_form_amount(1, [1000]) == [\\"YES\\"] def test_zero_amount(): assert can_form_amount(1, [0]) == [\\"YES\\"]","solution":"def can_form_amount(t, amounts): results = [] for n in amounts: if n % 3 == 0 or n % 5 == 0: results.append(\\"YES\\") else: for i in range(n//5 + 1): if (n - 5*i) % 3 == 0: results.append(\\"YES\\") break else: results.append(\\"NO\\") return results"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxRootToLeafPathSum(root: TreeNode) -> int: Determines the maximum sum of all the elements in any root-to-leaf path. Args: root (TreeNode): The root of the binary tree. Returns: int: Maximum sum of a root-to-leaf path. Examples: >>> # Example 1: >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(3) >>> node1.left = node2 >>> node1.right = node3 >>> maxRootToLeafPathSum(node1) 4 >>> # Example 2: >>> node4 = TreeNode(4) >>> node3 = TreeNode(3) >>> node5 = TreeNode(5) >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node4.left = node3 >>> node4.right = node5 >>> node3.left = node1 >>> node3.right = node2 >>> maxRootToLeafPathSum(node4) 9","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxRootToLeafPathSum(root: TreeNode) -> int: Determines the maximum sum of all the elements in any root-to-leaf path. if not root: return float('-inf') if not root.left and not root.right: return root.val left_max_sum = maxRootToLeafPathSum(root.left) right_max_sum = maxRootToLeafPathSum(root.right) return root.val + max(left_max_sum, right_max_sum)"},{"question":"def longest_sorted_subsequence(arr): Given a list of integers, returns the length of the longest subsequence such that elements in the subsequence are in sorted order but not necessarily contiguous in the array. >>> longest_sorted_subsequence([10]) == 1 >>> longest_sorted_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_sorted_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_sorted_subsequence([1, 3, 2, 5, 4, 10, 6, 9, 7, 8]) == 6 >>> longest_sorted_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 >>> longest_sorted_subsequence([1, 2, 2, 3, 3, 4, 4, 5, 5]) == 5 >>> longest_sorted_subsequence([]) == 0","solution":"def longest_sorted_subsequence(arr): Given a list of integers, returns the length of the longest subsequence such that elements in the subsequence are in sorted order but not necessarily contiguous in the array. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def min_insertions_to_valid(s: str) -> int: Returns the minimum number of insertions needed to make the bracket sequence valid. >>> min_insertions_to_valid(\\"(()\\") 1 >>> min_insertions_to_valid(\\"(()))\\") 1 >>> min_insertions_to_valid(\\")()(\\") 2","solution":"def min_insertions_to_valid(s): Returns the minimum number of insertions needed to make the bracket sequence valid. :param s: A string consisting of '(' and ')' characters. :return: An integer representing the minimum number of insertions required. left_brackets = 0 right_brackets_needed = 0 for char in s: if char == '(': left_brackets += 1 elif char == ')': if left_brackets > 0: left_brackets -= 1 else: right_brackets_needed += 1 return right_brackets_needed + left_brackets"},{"question":"def buildings_with_sunlight_view(heights): Determine which buildings have sunlight view from the left. :param heights: List of integers representing the heights of buildings :return: List of indices of buildings having the sunlight view >>> buildings_with_sunlight_view([4, 2, 3, 1, 5, 7, 6, 8]) == [0, 4, 5, 7] >>> buildings_with_sunlight_view([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [0] >>> buildings_with_sunlight_view([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == list(range(10)) >>> buildings_with_sunlight_view([4, 4, 4, 4, 4]) == [0] >>> buildings_with_sunlight_view([7]) == [0] >>> buildings_with_sunlight_view([7, 8]) == [0, 1] >>> buildings_with_sunlight_view([8, 7]) == [0] >>> buildings_with_sunlight_view([3, 1, 4, 1, 5, 2, 6, 1, 7]) == [0, 2, 4, 6, 8]","solution":"def buildings_with_sunlight_view(heights): Determine which buildings have sunlight view from the left. :param heights: List of integers representing the heights of buildings :return: List of indices of buildings having the sunlight view max_height = -1 indices = [] for i, height in enumerate(heights): if height > max_height: indices.append(i) max_height = height return indices"},{"question":"def shortest_paths(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[int]: Calculate the shortest path times from city 1 to all other cities. Parameters: n (int): Number of cities. m (int): Number of roads. roads (list): List of tuples (u, v, w) representing roads between cities with travel time w. Returns: list: List of shortest times from city 1 to all other cities. -1 if a city is unreachable. >>> shortest_paths(5, 6, [(1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 2), (3, 5, 3), (4, 5, 1)]) [0, 2, 3, 4, 5] >>> shortest_paths(4, 2, [(1, 2, 1), (2, 3, 1)]) [0, 1, 2, -1] >>> shortest_paths(1, 0, []) [0] >>> shortest_paths(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 3)]) [0, 1, 2] >>> shortest_paths(6, 7, [(1, 2, 1), (1, 3, 2), (2, 4, 1), (3, 4, 1), (4, 5, 1), (4, 6, 2), (5, 6, 2)]) [0, 1, 2, 2, 3, 4] pass","solution":"import heapq def shortest_paths(n, m, roads): Calculate the shortest path times from city 1 to all other cities. Parameters: n (int): Number of cities. m (int): Number of roads. roads (list): List of tuples (u, v, w) representing roads between cities with travel time w. Returns: list: List of shortest times from city 1 to all other cities. -1 if a city is unreachable. # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's Algorithm def dijkstra(source): min_heap = [(0, source)] # (distance, node) distances = [float('inf')] * (n + 1) distances[source] = 0 while min_heap: curr_distance, u = heapq.heappop(min_heap) if curr_distance > distances[u]: continue for v, weight in graph[u]: distance = curr_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return distances # Get shortest distances from city 1 distances = dijkstra(1) # Convert distances to required format result = [] for i in range(1, n + 1): result.append(distances[i] if distances[i] != float('inf') else -1) return result"},{"question":"class TreeNode: def __init__(self, x): self.value = x self.left = None self.right = None def sum_of_tree(root: TreeNode) -> int: Returns the sum of all values in the binary tree using DFS traversal. # Your code here # Test cases def test_sum_of_empty_tree(): assert sum_of_tree(None) == 0 def test_sum_of_single_node_tree(): root = TreeNode(5) assert sum_of_tree(root) == 5 def test_sum_of_balanced_tree(): 1 / 2 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert sum_of_tree(root) == 6 def test_sum_of_unbalanced_tree(): 1 / 2 / 3 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert sum_of_tree(root) == 6 def test_sum_of_complete_tree(): 1 / 2 3 / / 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert sum_of_tree(root) == 28 def test_sum_of_tree_with_negative_and_positive_values(): 1 / -2 3 / -4 5 root = TreeNode(1) root.left = TreeNode(-2) root.right = TreeNode(3) root.right.left = TreeNode(-4) root.right.right = TreeNode(5) assert sum_of_tree(root) == 3","solution":"class TreeNode: def __init__(self, x): self.value = x self.left = None self.right = None def sum_of_tree(root: TreeNode) -> int: Returns the sum of all values in the binary tree using DFS traversal. if root is None: return 0 return root.value + sum_of_tree(root.left) + sum_of_tree(root.right)"},{"question":"def is_peak(arr: List[int], x: int) -> str: Determine if a given integer x is a peak element of the array. The array first strictly increases, then strictly decreases. A peak element is defined as an element that is greater than its immediate neighbors. >>> is_peak([1, 3, 8, 12, 4, 2, 1], 12) \\"YES\\" >>> is_peak([1, 3, 8, 12, 4, 2, 1], 3) \\"NO\\" >>> is_peak([1, 3, 8, 12, 4, 2, 1], 5) \\"NO\\" # Your code here from typing import List def test_peak_element(): arr = [1, 3, 8, 12, 4, 2, 1] assert is_peak(arr, 12) == \\"YES\\" assert is_peak(arr, 3) == \\"NO\\" assert is_peak(arr, 5) == \\"NO\\" def test_no_peak(): arr = [1, 2, 3, 2, 1] assert is_peak(arr, 4) == \\"NO\\" assert is_peak(arr, 1) == \\"NO\\" def test_multiple_peaks(): arr = [1, 4, 7, 8, 7, 3, 2, 1] assert is_peak(arr, 8) == \\"YES\\" assert is_peak(arr, 7) == \\"NO\\" def test_single_peak(): arr = [1, 6, 5] assert is_peak(arr, 6) == \\"YES\\" assert is_peak(arr, 5) == \\"NO\\" def test_large_numbers(): arr = [1, 999999999, 1000000000, 999999999, 998] assert is_peak(arr, 1000000000) == \\"YES\\" assert is_peak(arr, 998) == \\"NO\\"","solution":"def find_peak_index(arr): Utility function to find the peak index in a mountain array. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left def is_peak(arr, x): Returns \\"YES\\" if x is a peak element in the mountain array arr, otherwise \\"NO\\". peak_index = find_peak_index(arr) if arr[peak_index] == x: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def transform_scores(scores: List[int]) -> List[int]: Transform the scores so that every player receives points proportional to their performance relative to the best performance in the game. The player with the highest points retains their points. Any other player has their points adjusted such that the ratio of their new points to the highest points matches the ratio of their original points to the highest points, rounded to the nearest integer. >>> transform_scores([50, 30, 70, 90, 100]) [50, 30, 70, 90, 100] >>> transform_scores([100, 100, 100]) [100, 100, 100] >>> transform_scores([42]) [42] >>> transform_scores([5, 10, 20, 40, 80]) [5, 10, 20, 40, 80] >>> transform_scores([2, 4, 8, 16, 32]) [2, 4, 8, 16, 32] >>> transform_scores([0, 10, 20, 30]) [0, 10, 20, 30]","solution":"from typing import List def transform_scores(scores: List[int]) -> List[int]: max_points = max(scores) transformed_scores = [ max_points if score == max_points else round(score / max_points * max_points) for score in scores ] return transformed_scores"},{"question":"def longestRepeatingSubarray(arr: List[int]) -> int: Find the length of the largest subarray that appears more than once in the array. >>> longestRepeatingSubarray([1, 2, 3, 2, 3, 4, 1]) 2 >>> longestRepeatingSubarray([1, 2, 3, 4, 5]) 0 >>> longestRepeatingSubarray([1, 1, 1, 1]) 3 >>> longestRepeatingSubarray([1, 2, 3, 1, 2, 3]) 3 >>> longestRepeatingSubarray([7, 7, 7, 7, 7, 7, 7]) 6 >>> longestRepeatingSubarray([1, 2, 3, 4, 4, 3, 2, 1]) 1 >>> longestRepeatingSubarray([1, 2, 3, 4, 5, 6, 3, 4, 5]) 3 >>> arr = [i for i in range(1, 2501)] + [i for i in range(1, 2501)] >>> longestRepeatingSubarray(arr) 2500","solution":"def longestRepeatingSubarray(arr): def check(L): seen = set() for i in range(n - L + 1): sub = tuple(arr[i:i + L]) if sub in seen: return True seen.add(sub) return False n = len(arr) left, right = 1, n while left <= right: mid = (left + right) // 2 if check(mid): left = mid + 1 else: right = mid - 1 return right"},{"question":"from typing import List def min_intervals_to_remove(intervals: List[List[int]]) -> int: Finds the minimum number of intervals to remove to eliminate all overlapping intervals. :param intervals: List of intervals, where each interval is represented as [start, end] :return: Integer, the minimum number of intervals to remove pass def test_example_case(): intervals = [ [1, 3], [2, 4], [3, 5], [5, 7], [6, 8], [8, 10] ] assert min_intervals_to_remove(intervals) == 2 def test_no_overlap_intervals(): intervals = [ [1, 2], [3, 4], [5, 6] ] assert min_intervals_to_remove(intervals) == 0 def test_all_overlap_intervals(): intervals = [ [1, 5], [2, 6], [3, 7], [4, 8] ] assert min_intervals_to_remove(intervals) == 3 def test_single_interval(): intervals = [ [1, 5] ] assert min_intervals_to_remove(intervals) == 0 def test_edge_case_intervals(): intervals = [ [1, 1000000000], [2, 999999999], [3, 999999998] ] assert min_intervals_to_remove(intervals) == 2","solution":"def min_intervals_to_remove(intervals): Finds the minimum number of intervals to remove to eliminate all overlapping intervals. :param intervals: List of intervals, where each interval is represented as [start, end] :return: Integer, the minimum number of intervals to remove if not intervals: return 0 # Sort intervals by end time intervals.sort(key=lambda x: x[1]) # Initialize the end of the first interval and the number of removals end = intervals[0][1] removals = 0 for i in range(1, len(intervals)): if intervals[i][0] < end: # If the start time of the current interval is less than the end time of the previous interval, they overlap removals += 1 else: # Update the end time to the end of the current interval end = intervals[i][1] return removals # Example intervention to check if the solution works n = 6 intervals = [ [1, 3], [2, 4], [3, 5], [5, 7], [6, 8], [8, 10] ] print(min_intervals_to_remove(intervals)) # Output should be 2"},{"question":"def reformat_name(name: str) -> str: Reformats a full name into initials followed by the last name. >>> reformat_name(\\"John Smith\\") == \\"J. Smith\\" >>> reformat_name(\\"Isabel Allende\\") == \\"I. Allende\\" >>> reformat_name(\\"John Ronald Reuel Tolkien\\") == \\"J.R.R. Tolkien\\" >>> reformat_name(\\"George Raymond Richard Martin\\") == \\"G.R.R. Martin\\" >>> reformat_name(\\"Fitzgerald Scott Key\\") == \\"F.S. Key\\" >>> reformat_name(\\"A B C D\\") == \\"A.B.C. D\\" >>> reformat_name(\\"X Y\\") == \\"X. Y\\" >>> reformat_name(\\"SmAugh thE GreAt\\") == \\"S.t. GreAt\\" >>> reformat_name(\\"EvErEt mCBoTh\\") == \\"E. mCBoTh\\"","solution":"def reformat_name(name): Reformats a full name into initials followed by the last name. Parameters: name (str): A string containing a full name. Returns: str: The reformatted name with initials followed by the last name. parts = name.split() last_name = parts[-1] initials = ''.join([part[0] + '.' for part in parts[:-1]]) return initials + ' ' + last_name"},{"question":"def max_value(W: int, G: int, weights: List[int], values: List[int]) -> int: Calculate the maximum score achievable without exceeding the weight capacity. Args: W (int): Maximum weight capacity of the inventory. G (int): Number of gems. weights (List[int]): Weights of the gems. values (List[int]): Values of the gems. Returns: int: Maximum score achievable. Examples: >>> max_value(10, 4, [5, 4, 6, 3], [10, 40, 30, 50]) 90 >>> max_value(5, 1, [3], [10]) 10 >>> max_value(2, 1, [3], [10]) 0","solution":"def max_value(W, G, weights, values): Function to calculate the maximum score achievable without exceeding the weight capacity using 0/1 knapsack problem. Args: W (int): Maximum weight capacity of the inventory. G (int): Number of gems. weights (List[int]): Weights of the gems. values (List[int]): Values of the gems. Returns: int: Maximum score achievable. # Create a 2D dp array where dp[i][w] represents the maximum value # achievable with the first i gems and capacity w dp = [[0] * (W + 1) for _ in range(G + 1)] for i in range(1, G + 1): for w in range(W + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[G][W]"},{"question":"def process_queries(n: int, m: int, sequence: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process each query to compute the sum of the segment and then multiply it by the given integer. :param n: Integer representing the length of the sequence. :param m: Integer representing the number of queries. :param sequence: List of integers representing the sequence. :param queries: List of tuples, each containing three integers (l, r, k) representing a query. :return: List of integers, each representing the result of the query. >>> process_queries(6, 3, [1, 2, 3, 4, 5, 6], [(1, 3, 2), (2, 5, 3), (1, 6, -1)]) [12, 42, -21] >>> process_queries(5, 2, [-1, -2, -3, -4, -5], [(1, 3, 1), (2, 5, -2)]) [-6, 28] >>> process_queries(7, 2, [1, -2, 3, -4, 5, -6, 7], [(3, 5, 2), (1, 7, -1)]) [8, -4] >>> process_queries(5, 1, [10, 20, 30, 40, 50], [(1, 5, 2)]) [300]","solution":"def process_queries(n, m, sequence, queries): Process each query to compute the sum of the segment and then multiply it by the given integer. :param n: Integer representing the length of the sequence. :param m: Integer representing the number of queries. :param sequence: List of integers representing the sequence. :param queries: List of tuples, each containing three integers (l, r, k) representing a query. :return: List of integers, each representing the result of the query. # Precompute prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + sequence[i - 1] results = [] for l, r, k in queries: segment_sum = prefix_sums[r] - prefix_sums[l - 1] results.append(segment_sum * k) return results"},{"question":"def min_max_capacity(k: int, n: int, books: List[int], capacity: List[int]) -> int: Determine the minimum possible maximum capacity used among all the lockers after distributing the books. Parameters: k (int): Number of book collections. n (int): Number of lockers. books (List[int]): List of integers where books[i] is the number of books in the i-th collection. capacity (List[int]): List of integers where capacity[j] is the maximum number of books locker j can hold. Returns: int: The minimum possible maximum capacity used. Examples: >>> min_max_capacity(4, 3, [2, 2, 3, 4], [5, 5, 5]) 5 >>> min_max_capacity(1, 1, [1], [1]) 1 >>> min_max_capacity(5, 5, [1, 2, 3, 4, 5], [5, 5, 5, 5, 5]) 5 >>> min_max_capacity(3, 2, [4, 4, 2], [6, 4]) 6 >>> min_max_capacity(4, 3, [10, 10, 10, 10], [30, 30, 30]) 30 >>> min_max_capacity(2, 2, [1000, 1000], [1000, 2000]) 1000 >>> min_max_capacity(6, 3, [1,1,1,1,1,1], [2, 2, 2]) 2","solution":"def min_max_capacity(k, n, books, capacity): def can_distribute(books, capacity, max_capacity): current_locker = 0 current_load = 0 for book in books: if current_load + book > max_capacity: current_locker += 1 current_load = 0 if current_locker >= len(capacity): return False if book > capacity[current_locker]: return False current_load += book return True left = max(max(books), min(capacity)) right = sum(books) while left < right: mid = (left + right) // 2 if can_distribute(books, capacity, mid): right = mid else: left = mid + 1 return left"},{"question":"def minimized_max_min_distance(n: int, points: List[int]) -> int: Determine the minimized maximum of the minimum distances between any point and its nearest facility. >>> minimized_max_min_distance(1, [5]) 0 >>> minimized_max_min_distance(3, [1, 5, 9]) 4 >>> minimized_max_min_distance(3, [1, 2, 100]) 49 >>> minimized_max_min_distance(4, [1, 10, 20, 30]) 9 def process_queries(queries: List[Tuple[int, List[int]]]) -> List[int]: Process multiple queries to find the minimized maximum of the minimum distances for each. >>> process_queries([(4, [1, 10, 20, 30]), (3, [1, 2, 100]), (3, [1, 5, 9]), (1, [5])]) [9, 49, 4, 0]","solution":"def minimized_max_min_distance(n, points): points.sort() # Edge case: When there's only one point, the minimized maximum minimum distance is 0 if n == 1: return 0 # The distance between the most distant points divided by (n-1) should minimize the maximum distance distance = points[-1] - points[0] min_distance = distance // (n - 1) return min_distance def process_queries(queries): results = [] for n, points in queries: result = minimized_max_min_distance(n, points) results.append(result) return results"},{"question":"def largest_empty_square(n: int, m: int, grid: List[List[int]]) -> int: Find the maximum size of the square that can be formed only with empty cells. >>> largest_empty_square(4, 4, [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [1, 0, 0, 0]]) 2 >>> largest_empty_square(1, 1, [[0]]) 1 >>> largest_empty_square(1, 1, [[1]]) 0 >>> largest_empty_square(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 3 >>> largest_empty_square(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> largest_empty_square(5, 5, [[1, 0, 1, 0, 0], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) 2","solution":"def largest_empty_square(n, m, grid): dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"from typing import List, Tuple def prefix_sums(arr: List[int]) -> List[int]: This function returns the prefix sums array for a given input array. >>> prefix_sums([3, 2, 4, 5, 1, 6]) == [0, 3, 5, 9, 14, 15, 21] >>> prefix_sums([1, 2, 3]) == [0, 1, 3, 6] pass def range_sum(prefix: List[int], i: int, j: int) -> int: This function returns the sum of the elements from index i to j (inclusive) using the prefix sums array. >>> prefix = prefix_sums([3, 2, 4, 5, 1, 6]) >>> range_sum(prefix, 1, 3) == 9 >>> range_sum(prefix, 2, 5) == 12 pass def solve(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: This function processes each query and returns the sum of elements for the respective queries. >>> n, q = 6, 3 >>> arr = [3, 2, 4, 5, 1, 6] >>> queries = [(1, 3), (2, 5), (1, 6)] >>> solve(n, q, arr, queries) == [9, 12, 21] pass","solution":"def prefix_sums(arr): This function returns the prefix sums array for a given input array. n = len(arr) prefix = [0] * (n + 1) for i in range(1, n + 1): prefix[i] = prefix[i - 1] + arr[i - 1] return prefix def range_sum(prefix, i, j): This function returns the sum of the elements from index i to j (inclusive) using the prefix sums array. return prefix[j] - prefix[i - 1] def solve(n, q, arr, queries): This function processes each query and returns the sum of elements for the respective queries. prefix = prefix_sums(arr) results = [] for i, j in queries: results.append(range_sum(prefix, i, j)) return results"},{"question":"def trap_rainwater(heights): Computes the total amount of rainwater trapped between buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: Total amount of rainwater trapped. Examples: >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 3]) 1 >>> trap_rainwater([3, 0, 2, 0, 4]) 7","solution":"def trap_rainwater(heights): Computes the total amount of rainwater trapped between buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: Total amount of rainwater trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def longest_sequence_before_skip(start: int, n: int, k: int, tickets: List[int]) -> int: Determine the longest contiguous sequence of tickets that could be dispensed before the first skip occurs. :param start: The starting serial number of the tickets. :param n: The total number of tickets to be dispensed. :param k: The interval of the skip. :param tickets: The list of actually dispensed ticket numbers. :return: The length of the longest contiguous sequence of tickets before the first skip. >>> longest_sequence_before_skip(50, 10, 4, [50, 51, 52, 57, 58, 59, 60, 61, 62, 63]) == 3 >>> longest_sequence_before_skip(10, 6, 2, [10, 11, 13, 14, 16, 17]) == 2 >>> longest_sequence_before_skip(100, 5, 3, [100, 103, 104, 107, 110]) == 1 >>> longest_sequence_before_skip(1, 7, 1, [1, 2, 3, 4, 5, 6, 7]) == 7 >>> longest_sequence_before_skip(20, 0, 1, []) == 0 >>> longest_sequence_before_skip(0, 2, 1, [0, 1]) == 2 pass","solution":"def longest_sequence_before_skip(start, n, k, tickets): Determine the longest contiguous sequence of tickets that could be dispensed before the first skip occurs. :param start: The starting serial number of the tickets. :param n: The total number of tickets to be dispensed. :param k: The interval of the skip. :param tickets: The list of actually dispensed ticket numbers. :return: The length of the longest contiguous sequence of tickets before the first skip. longest_sequence = 0 current_sequence = 0 expected_number = start for ticket in tickets: if ticket == expected_number: current_sequence += 1 expected_number += 1 else: break longest_sequence = max(longest_sequence, current_sequence) return longest_sequence # Example use with sample input input_start = 50 input_n = 10 input_k = 4 input_tickets = [50, 51, 52, 57, 58, 59, 60, 61, 62, 63] print(longest_sequence_before_skip(input_start, input_n, input_k, input_tickets)) # Output: 3"},{"question":"def calculate_max_bids(n: int, starting_bids: List[int], min_increments: List[int]) -> List[int]: Calculates the maximum possible winning bids for each item such that the total sum is maximized. Args: n (int): the number of items. starting_bids (list of int): the starting bids of the items. min_increments (list of int): the minimum increments for the items. Returns: list of int: the maximum possible winning bids for each item. >>> calculate_max_bids(3, [100, 200, 300], [10, 20, 30]) [110, 220, 330] >>> calculate_max_bids(1, [10000], [1000]) [11000]","solution":"def calculate_max_bids(n, starting_bids, min_increments): Calculates the maximum possible winning bids for each item such that the total sum is maximized. Args: n (int): the number of items. starting_bids (list of int): the starting bids of the items. min_increments (list of int): the minimum increments for the items. Returns: list of int: the maximum possible winning bids for each item. max_bids = [starting_bids[i] + min_increments[i] for i in range(n)] return max_bids"},{"question":"def shift_string(s: str) -> str: Takes in a string of lowercase letters and returns a new string with each character shifted to the next letter in the alphabetical order. Wraps around from 'z' to 'a'. >>> shift_string(\\"abcdz\\") 'bcdea' >>> shift_string(\\"xyz\\") 'yza'","solution":"def shift_string(s: str) -> str: Takes in a string of lowercase letters and returns a new string with each character shifted to the next letter in the alphabetical order. Wraps around from 'z' to 'a'. shifted = [] for char in s: if char == 'z': shifted.append('a') else: shifted.append(chr(ord(char) + 1)) return ''.join(shifted)"},{"question":"def raffle_winner(n: int, q: int, scenarios: List[Tuple[int, ...]]) -> List[int]: Determine the smallest ticket number that could win the raffle for each exclusion scenario. Parameters: n (int): The number of participants. q (int): The number of exclusion scenarios. scenarios (List[Tuple[int, ...]]): List of tuples representing exclusion scenarios, where the first integer in each tuple is the count of excluded tickets, followed by the ticket numbers to be excluded. Returns: List[int]: A list of the smallest ticket number that can win for each scenario, or 0 if all tickets are excluded. >>> raffle_winner(5, 3, [(2, 3, 4), (1, 5), (0,)]) [1, 1, 1] >>> raffle_winner(3, 1, [(3, 1, 2, 3)]) [0] >>> raffle_winner(4, 1, [(0,)]) [1] >>> raffle_winner(4, 2, [(1, 2), (1, 4)]) [1, 1] >>> raffle_winner(1, 1, [(0,)]) [1]","solution":"def raffle_winner(n, q, scenarios): results = [] for scenario in scenarios: k = scenario[0] if k == 0: results.append(1) continue excluded_tickets = set(scenario[1:]) for ticket in range(1, n+1): if ticket not in excluded_tickets: results.append(ticket) break else: results.append(0) return results"},{"question":"from typing import List class ChatServer: A simple chat server that allows users to send and receive messages. Methods: - __init__(): Initializes the server with no users. - add_user(user_id: str): Adds a new user to the server with the given user_id. - send_message(from_user: str, to_user: str, message: str): Sends a message from from_user to to_user. - receive_message(user_id: str) -> List[str]: Returns a list of all messages sent to the specified user_id. Example: >>> server = ChatServer() >>> server.add_user(\\"user1\\") >>> server.add_user(\\"user2\\") >>> server.send_message(\\"user1\\", \\"user2\\", \\"Hello!\\") >>> server.send_message(\\"user2\\", \\"user1\\", \\"Hey!\\") >>> server.receive_message(\\"user1\\") [\\"Hey!\\"] >>> server.receive_message(\\"user2\\") [\\"Hello!\\"] >>> server.send_message(\\"user1\\", \\"user3\\", \\"This message will be ignored because user3 does not exist.\\") >>> server.receive_message(\\"user1\\") []","solution":"from collections import defaultdict, deque from typing import List class ChatServer: def __init__(self): self.users = set() self.messages = defaultdict(deque) def add_user(self, user_id: str): self.users.add(user_id) def send_message(self, from_user: str, to_user: str, message: str): if to_user in self.users: self.messages[to_user].append(message) def receive_message(self, user_id: str) -> List[str]: if user_id in self.users: msgs = list(self.messages[user_id]) self.messages[user_id].clear() return msgs return []"},{"question":"def is_prime(n: int) -> str: Determines if a given number n is prime. >>> is_prime(29) \\"YES\\" >>> is_prime(100) \\"NO\\" >>> is_prime(2) \\"YES\\" >>> is_prime(3) \\"YES\\" >>> is_prime(1) \\"NO\\"","solution":"def is_prime(n): Determines if a given number n is prime. :param n: int, the number to check :return: str, 'YES' if n is prime, otherwise 'NO' if n <= 1: return \\"NO\\" if n <= 3: return \\"YES\\" if n % 2 == 0 or n % 3 == 0: return \\"NO\\" i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return \\"NO\\" i += 6 return \\"YES\\""},{"question":"def min_transport_cost(n, m, q, roads, queries): Calculate the minimum transportation cost between cities using given roads. :param n: number of cities :param m: number of roads :param q: number of queries :param roads: list of tuples (u, v, w) where u and v are cities and w is the transportation cost :param queries: list of tuples (a, b) where a and b are the cities in the query :return: list of minimum transportation costs for each query Test cases: >>> min_transport_cost(2, 1, 1, [(1, 2, 5)], [(1, 2)]) [5] >>> min_transport_cost(3, 2, 1, [(1, 2, 10), (2, 3, 20)], [(1, 3)]) [30] >>> min_transport_cost(3, 1, 1, [(1, 2, 5)], [(1, 3)]) [-1] >>> min_transport_cost(4, 5, 3, [(1, 2, 1), (2, 3, 4), (1, 3, 7), (3, 4, 2), (2, 4, 5)], [(1, 3), (1, 4), (3, 1)]) [5, 6, 5] >>> min_transport_cost(4, 5, 2, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 1), (1, 4, 10)], [(1, 4), (2, 4)]) [4, 2] import sys import itertools # Initialize the distance matrix with INF and 0 for diagonal elements INF = sys.maxsize dist = [[INF] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Fill the initial distances based on the given roads for u, v, w in roads: dist[u-1][v-1] = min(dist[u-1][v-1], w) dist[v-1][u-1] = min(dist[v-1][u-1], w) # Apply Floyd-Warshall algorithm for k, i, j in itertools.product(range(n), repeat=3): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Answer the queries results = [] for a, b in queries: if dist[a-1][b-1] == INF: results.append(-1) else: results.append(dist[a-1][b-1]) return results","solution":"def min_transport_cost(n, m, q, roads, queries): import sys import itertools # Initialize the distance matrix with INF and 0 for diagonal elements INF = sys.maxsize dist = [[INF] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Fill the initial distances based on the given roads for u, v, w in roads: dist[u-1][v-1] = min(dist[u-1][v-1], w) dist[v-1][u-1] = min(dist[v-1][u-1], w) # Apply Floyd-Warshall algorithm for k, i, j in itertools.product(range(n), repeat=3): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Answer the queries results = [] for a, b in queries: if dist[a-1][b-1] == INF: results.append(-1) else: results.append(dist[a-1][b-1]) return results"},{"question":"from collections import deque from typing import List, Tuple def shortestPathToDestination(grid: List[List[int]], start: Tuple[int, int]) -> int: Navigate from a starting cell to the nearest destination cell in the shortest possible distance in a 2D grid, while avoiding obstacles. >>> grid = [ ... [0, 0, 1, 0], ... [0, 1, 2, 0], ... [0, 0, 1, 0], ... [2, 0, 0, 0] ... ] >>> start = (0, 0) >>> shortestPathToDestination(grid, start) 4 >>> grid = [ ... [0, 1], ... [1, 2] ... ] >>> start = (0, 0) >>> shortestPathToDestination(grid, start) -1 # Add your implementation here","solution":"from collections import deque def shortestPathToDestination(grid, start): rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set([(start[0], start[1])]) while queue: x, y, distance = queue.popleft() if grid[x][y] == 2: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] != 1 and (nx, ny) not in visited: queue.append((nx, ny, distance + 1)) visited.add((nx, ny)) return -1"},{"question":"def generate_flowerbed(n: int) -> List[str]: Generates a grid of size n x n where each plot (i, j) is either 'A' or 'B', with no two adjacent plots in the same row or column having the same type of flower. >>> generate_flowerbed(1) [\\"A\\"] >>> generate_flowerbed(2) [\\"AB\\", \\"BA\\"] >>> generate_flowerbed(3) [\\"ABA\\", \\"BAB\\", \\"ABA\\"] >>> generate_flowerbed(4) [\\"ABAB\\", \\"BABA\\", \\"ABAB\\", \\"BABA\\"]","solution":"def generate_flowerbed(n): Generates a grid of size n x n where each plot (i, j) is either 'A' or 'B', with no two adjacent plots in the same row or column having the same type of flower. grid = [] for i in range(n): row = \\"\\" for j in range(n): if (i + j) % 2 == 0: row += 'A' else: row += 'B' grid.append(row) return grid"},{"question":"def manage_sequences(operations): Perform a list of operations on sequences. Operations can be: 1. Add a new integer to a specified sequence 2. Remove the last added integer from a specified sequence 3. Find the maximum integer in a specified sequence Args: operations (list of tuple): A list of operations to be performed where each operation is a tuple. Format: (t,) or (t, x, i) depending on the operation type. Returns: list: A list of results from operations of type 3 (find maximum integer in sequence). ... from solution import manage_sequences def test_manage_sequences_add_and_find_max(): operations = [ (1, 10, 1), (1, 20, 1), (3, 1) ] assert manage_sequences(operations) == [20] def test_manage_sequences_add_remove_and_find_max(): operations = [ (1, 10, 1), (1, 20, 1), (3, 1), (2, 1), (3, 1) ] assert manage_sequences(operations) == [20, 10] def test_manage_sequences_find_max_no_elements_present(): operations = [ (3, 1) ] assert manage_sequences(operations) == [\\"No elements present\\"] def test_manage_sequences_add_remove_all_elements(): operations = [ (1, 10, 1), (1, 20, 1), (2, 1), (2, 1), (3, 1) ] assert manage_sequences(operations) == [\\"No elements present\\"] def test_manage_sequences_operations_on_multiple_sequences(): operations = [ (1, 10, 1), (1, 20, 2), (1, 30, 1), (3, 1), (3, 2), (2, 1), (3, 1) ] assert manage_sequences(operations) == [30, 20, 10]","solution":"def manage_sequences(operations): Perform a list of operations on sequences. Operations can be: 1. Add a new integer to a specified sequence 2. Remove the last added integer from a specified sequence 3. Find the maximum integer in a specified sequence Args: operations (list of tuple): A list of operations to be performed where each operation is a tuple. Format: (t,) or (t, x, i) depending on the operation type. Returns: list: A list of results from operations of type 3 (find maximum integer in sequence). sequences = {} results = [] for operation in operations: t = operation[0] if t == 1: x, i = operation[1], operation[2] if i not in sequences: sequences[i] = [] sequences[i].append(x) elif t == 2: i = operation[1] if i in sequences and sequences[i]: sequences[i].pop() elif t == 3: i = operation[1] if i in sequences and sequences[i]: results.append(max(sequences[i])) else: results.append(\\"No elements present\\") return results"},{"question":"def find_unassigned_bib_numbers(n: int, k: int, assigned_bibs: List[int]) -> List[int]: Returns a list of unassigned bib numbers in ascending order. :param int n: Total number of participants. :param int k: Number of pre-assigned bib numbers. :param list assigned_bibs: List of pre-assigned bib numbers. :return: List of unassigned bib numbers in ascending order. :rtype: list >>> find_unassigned_bib_numbers(5, 2, [2, 4]) == [1, 3, 5] >>> find_unassigned_bib_numbers(3, 1, [1]) == [2, 3] >>> find_unassigned_bib_numbers(10, 0, []) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"def find_unassigned_bib_numbers(n, k, assigned_bibs): Returns a list of unassigned bib numbers in ascending order. :param int n: Total number of participants. :param int k: Number of pre-assigned bib numbers. :param list assigned_bibs: List of pre-assigned bib numbers. :return: List of unassigned bib numbers in ascending order. :rtype: list assigned_set = set(assigned_bibs) unassigned_bibs = [i for i in range(1, n + 1) if i not in assigned_set] return unassigned_bibs"},{"question":"def assign_rooms(n, m, capacities): Determine if it is possible to assign all participants to rooms given the capacities. Returns a tuple (possible: str, assignment: List[int]) >>> assign_rooms(5, 3, [2, 2, 1]) (\\"YES\\", [1, 1, 2, 2, 3]) >>> assign_rooms(5, 2, [2, 2]) (\\"NO\\", [])","solution":"def assign_rooms(n, m, capacities): Determine if it's possible to assign all participants to rooms given the capacities. Returns a tuple (possible: bool, assignment: List[int]) if sum(capacities) < n: return (\\"NO\\", []) assignment = [] room_index = 0 used_capacity = [0] * m for i in range(n): # Find a room with available capacity while used_capacity[room_index] >= capacities[room_index]: room_index = (room_index + 1) % m assignment.append(room_index + 1) used_capacity[room_index] += 1 return (\\"YES\\", assignment)"},{"question":"def minDistance(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. Allowed operations: insert a character, delete a character, replace a character. >>> minDistance(\\"kitten\\", \\"sitting\\") 3 >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"abc\\", \\"abc\\") 0","solution":"def minDistance(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. Allowed operations: insert a character, delete a character, replace a character. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"def num_ways_to_roll_sum(n: int, m: int, k: int) -> int: Returns the number of distinct ways to roll \`n\` dice each with \`m\` faces to achieve an exact sum \`k\`. >>> num_ways_to_roll_sum(2, 6, 7) 6 >>> num_ways_to_roll_sum(1, 6, 3) 1 >>> num_ways_to_roll_sum(2, 10, 20) 1 >>> num_ways_to_roll_sum(3, 6, 10) 27 >>> num_ways_to_roll_sum(2, 6, 1) 0 >>> num_ways_to_roll_sum(1, 4, 1) 1 >>> num_ways_to_roll_sum(1, 4, 4) 1 >>> num_ways_to_roll_sum(2, 4, 5) 4 >>> num_ways_to_roll_sum(0, 6, 0) 1 >>> num_ways_to_roll_sum(0, 6, 1) 0","solution":"def num_ways_to_roll_sum(n, m, k): Returns the number of ways to roll \`n\` dice each with \`m\` faces to achieve a sum \`k\`. # Create a DP table with dimensions (n+1)x(k+1) initialized to 0 dp = [[0] * (k + 1) for _ in range(n + 1)] # There is exactly 1 way to achieve sum 0 with 0 dice: roll nothing dp[0][0] = 1 # Iterate over the number of dice for dice in range(1, n + 1): # Iterate over the possible sums for target_sum in range(1, k + 1): # Iterate over the faces of the die for face in range(1, m + 1): if target_sum >= face: dp[dice][target_sum] += dp[dice - 1][target_sum - face] return dp[n][k]"},{"question":"def can_balance_sequence(n: int, arr: List[int]) -> str: Determines whether it is possible to make the sequence balanced using the given operation. Parameters: - n: the number of elements in the sequence - arr: a list of n integers representing the sequence Returns: - \\"YES\\" if it is possible to make the sequence balanced - \\"NO\\" otherwise >>> can_balance_sequence(3, [1, 2, 3]) \\"YES\\" >>> can_balance_sequence(4, [4, 4, 4, 4]) \\"YES\\" >>> can_balance_sequence(3, [1, 1, 5]) \\"NO\\" >>> can_balance_sequence(5, [10, 10, 10, 10, 10]) \\"YES\\" >>> can_balance_sequence(4, [1, 2, 3, 4]) \\"NO\\" >>> can_balance_sequence(2, [2, 4]) \\"YES\\" >>> can_balance_sequence(2, [10**9, 10**9]) \\"YES\\" >>> can_balance_sequence(4, [1, 2, 3, 7]) \\"NO\\"","solution":"def can_balance_sequence(n, arr): Determines whether it is possible to make the sequence balanced using the given operation. Parameters: - n: the number of elements in the sequence - arr: a list of n integers representing the sequence Returns: - \\"YES\\" if it is possible to make the sequence balanced - \\"NO\\" otherwise total_sum = sum(arr) # Check if the total sum is divisible by the number of elements if total_sum % n == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_coexisting_kibble_trees(n, m, k, trees): Determine the maximum number of Kibble Trees that can coexist without overlapping in any single cell of the grid. >>> max_coexisting_kibble_trees(5, 5, 3, [(1, 1, 3), (1, 3, 2), (3, 3, 1)]) 2 >>> max_coexisting_kibble_trees(3, 3, 1, [(1, 1, 3)]) 1 >>> max_coexisting_kibble_trees(4, 4, 2, [(1, 1, 2), (3, 3, 2)]) 2 >>> max_coexisting_kibble_trees(3, 3, 2, [(1, 1, 2), (1, 1, 2)]) 1 >>> max_coexisting_kibble_trees(4, 4, 2, [(1, 1, 2), (2, 2, 2)]) 1 >>> max_coexisting_kibble_trees(1000, 1000, 1, [(500, 500, 500)]) 1","solution":"def max_coexisting_kibble_trees(n, m, k, trees): # Create a grid to mark cells covered by kibble trees grid = [[0] * m for _ in range(n)] tree_cells = [] for r, c, d in trees: cells = set() for i in range(d): for j in range(d): if r + i - 1 < n and c + j - 1 < m: cells.add((r + i - 1, c + j - 1)) tree_cells.append(cells) max_trees = 0 def can_place(tree_index): for cell in tree_cells[tree_index]: if grid[cell[0]][cell[1]] == 1: return False return True def place_tree(tree_index): for cell in tree_cells[tree_index]: grid[cell[0]][cell[1]] = 1 def remove_tree(tree_index): for cell in tree_cells[tree_index]: grid[cell[0]][cell[1]] = 0 def backtrack(index, count): nonlocal max_trees if index == k: max_trees = max(max_trees, count) return if can_place(index): place_tree(index) backtrack(index + 1, count + 1) remove_tree(index) backtrack(index + 1, count) backtrack(0, 0) return max_trees"},{"question":"from typing import List def maxPairsForSquareTable(sticks: List[int]) -> int: Return the maximum number of pairs that can be formed with the sticks of equal lengths. >>> maxPairsForSquareTable([1, 2, 3, 3, 2, 2, 1, 4, 4, 3, 4, 4]) 5 >>> maxPairsForSquareTable([5, 5, 5, 5, 5, 5, 5, 5]) 4 >>> maxPairsForSquareTable([1, 2, 2, 3]) 1","solution":"from collections import Counter def maxPairsForSquareTable(sticks): Return the maximum number of pairs that can be formed with the sticks of equal lengths. counter = Counter(sticks) pairs = 0 for count in counter.values(): pairs += count // 2 return pairs"},{"question":"def is_divisible_pairs_exist(n: int, k: int, arr: List[int]) -> str: Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] is divisible by k. >>> is_divisible_pairs_exist(5, 7, [1, 2, 3, 4, 5]) 'YES' >>> is_divisible_pairs_exist(3, 7, [1, 2, 3]) 'NO' >>> is_divisible_pairs_exist(4, 5, [5, 5, 5, 5]) 'YES' >>> is_divisible_pairs_exist(4, 1000000000, [500000000, 500000000, 1, 999999999]) 'YES' >>> is_divisible_pairs_exist(1, 10, [9]) 'NO' >>> is_divisible_pairs_exist(5, 5, [1000000000, 1000000001, 1000000002, 1000000003, 1000000004]) 'YES' >>> is_divisible_pairs_exist(3, 10, [1, 2, 3]) 'NO' >>> is_divisible_pairs_exist(3, 2, [2, 2, 2]) 'YES'","solution":"def is_divisible_pairs_exist(n, k, arr): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] is divisible by k. # Create a dictionary to count the remainders remainder_count = {} for num in arr: remainder = num % k if remainder in remainder_count: remainder_count[remainder] += 1 else: remainder_count[remainder] = 1 # Check for any pair that sums to a multiple of k for num in arr: remainder = num % k complement = (k - remainder) % k # Special case for remainder 0 if remainder == 0: if remainder_count[remainder] > 1: return \\"YES\\" # If complement exists and it can form more than one pair elif complement in remainder_count: if complement != remainder or remainder_count[complement] > 1: return \\"YES\\" return \\"NO\\""},{"question":"def min_changes_to_palindrome(s: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string 's' and a list of queries, each query consists of two integers 'l' and 'r' (1 <= l <= r <= |s|). For each query, determine the minimum number of changes needed to make the substring from 'l' to 'r' (inclusive) a palindrome. Example: >>> min_changes_to_palindrome(\\"abac\\", [(1, 2), (2, 3)]) [1, 1] >>> min_changes_to_palindrome(\\"xyzzyx\\", [(1, 6), (1, 3), (4, 6)]) [0, 1, 1] :param s: The input string :param queries: List of queries, each query is a tuple (l, r) :return: List of minimum changes for each query pass # implement the function # Unit Tests import pytest def test_case_1(): s = \\"abac\\" queries = [(1, 2), (2, 3)] assert min_changes_to_palindrome(s, queries) == [1, 1] def test_case_2(): s = \\"xyzzyx\\" queries = [(1, 6), (1, 3), (4, 6)] assert min_changes_to_palindrome(s, queries) == [0, 1, 1] def test_case_3(): s = \\"a\\" queries = [(1, 1)] assert min_changes_to_palindrome(s, queries) == [0] def test_case_4(): s = \\"abcde\\" queries = [(1, 5), (1, 3), (3, 5)] assert min_changes_to_palindrome(s, queries) == [2, 1, 1] def test_case_5(): s = \\"abcd\\" queries = [(1, 2), (1, 3), (1, 4)] assert min_changes_to_palindrome(s, queries) == [1, 1, 2] def test_case_6(): s = \\"racecar\\" queries = [(1, 7), (2, 6), (3, 5)] assert min_changes_to_palindrome(s, queries) == [0, 0, 0] if __name__ == \\"__main__\\": pytest.main()","solution":"def min_changes_to_palindrome(s, queries): This function will take a string 's' and a list of queries, and for each query, it will find out the minimum number of character changes required to make the specified substring a palindrome. :param s: input string :param queries: list of queries, each query is a tuple (l, r) :return: list of results for each query results = [] for l, r in queries: l -= 1 # converting to 0-based indexing r -= 1 substring = s[l: r+1] changes = 0 # Check from both ends towards the middle for i in range((r - l + 1) // 2): if substring[i] != substring[-(i + 1)]: changes += 1 results.append(changes) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the input string s. If there are multiple substrings of the same length, returns the one that appears first. >>> longest_palindromic_substring(\\"babad\\") == \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"abcdefgh\\") == \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the input string s. If there are multiple substrings of the same length, returns the one that appears first. n = len(s) if n <= 1: return s start, max_length = 0, 1 def expand_around_center(left, right): nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start, max_length = left, current_length left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # Odd length palindromes expand_around_center(i, i + 1) # Even length palindromes return s[start:start + max_length]"},{"question":"from typing import List def max_possible_score(n: int, m: int, times: List[str], points: List[int]) -> int: Compute the maximum possible total score of all participants in the contest. Parameters: n (int): Number of participants m (int): Number of tasks performed times (List[str]): Completion times of tasks for each participant points (List[int]): Points for completing each task within the time limit Returns: int: Maximum possible total score >>> max_possible_score(2, 3, [\\"431\\", \\"212\\"], [4, 2, 5]) 9 >>> max_possible_score(1, 3, [\\"123\\"], [5, 10, 15]) 30 >>> max_possible_score(2, 3, [\\"899\\", \\"979\\"], [4, 2, 5]) 0 >>> max_possible_score(2, 3, [\\"123\\", \\"456\\"], [0, 0, 0]) 0 >>> max_possible_score(3, 3, [\\"321\\", \\"765\\", \\"543\\"], [10, 20, 30]) 60","solution":"def max_possible_score(n, m, times, points): max_scores = [0] * m for j in range(m): max_time_for_task = 0 for i in range(n): max_time_for_task = max(max_time_for_task, int(times[i][j])) if max_time_for_task <= 9: # a valid task completion time max_scores[j] = points[j] return sum(max_scores)"},{"question":"def subset_sum(n, k, arr): Determines if there exists a subset of the array \`arr\` of size \`n\` that sums up to \`k\`. Args: n (int): Size of the array. k (int): Target sum. arr (list of int): The array of integers. Returns: str: \\"YES\\" if a subset exists, \\"NO\\" otherwise. pass def solve(test_cases): Solves multiple test cases of the subset sum problem. Args: test_cases (list of tuples): Each tuple contains the values (n, k, arr). Returns: list of str: A list containing \\"YES\\" or \\"NO\\" for each test case. pass def test_subset_sum(): # Test case 1 n = 4 k = 10 arr = [4, 1, 2, 7] assert subset_sum(n, k, arr) == \\"YES\\" # Test case 2 n = 3 k = 5 arr = [2, 2, 2] assert subset_sum(n, k, arr) == \\"NO\\" # Test case 3 n = 1 k = 1 arr = [1] assert subset_sum(n, k, arr) == \\"YES\\" # Test case 4 n = 5 k = 11 arr = [1, 2, 3, 4, 5] assert subset_sum(n, k, arr) == \\"YES\\" # Test case 5 n = 5 k = 31 arr = [1, 2, 3, 4, 5] assert subset_sum(n, k, arr) == \\"NO\\" def test_solve(): # Test case 1 test_cases = [(4, 10, [4, 1, 2, 7]), (3, 5, [2, 2, 2])] assert solve(test_cases) == [\\"YES\\", \\"NO\\"] # Test case 2 test_cases = [(1, 1, [1]), (5, 11, [1, 2, 3, 4, 5])] assert solve(test_cases) == [\\"YES\\", \\"YES\\"] # Test case 3 test_cases = [(5, 31, [1, 2, 3, 4, 5])] assert solve(test_cases) == [\\"NO\\"]","solution":"def subset_sum(n, k, arr): Determines if there exists a subset of the array \`arr\` of size \`n\` that sums up to \`k\`. Args: n (int): Size of the array. k (int): Target sum. arr (list of int): The array of integers. Returns: str: \\"YES\\" if a subset exists, \\"NO\\" otherwise. dp = [False] * (k + 1) dp[0] = True for num in arr: for j in range(k, num - 1, -1): if dp[j - num]: dp[j] = True return \\"YES\\" if dp[k] else \\"NO\\" def solve(test_cases): results = [] for n, k, arr in test_cases: results.append(subset_sum(n, k, arr)) return results"},{"question":"def highest_point_reachable(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: Find the highest point reachable from any point in the grid where you can only move to adjacent cells with equal or higher altitude. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the altitudes of each cell. Returns: List[List[int]]: 2D list where each cell contains the highest altitude reachable from that cell. Examples: >>> highest_point_reachable(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[9, 9, 9], [9, 9, 9], [9, 9, 9]] >>> highest_point_reachable(1, 1, [[10]]) [[10]] >>> highest_point_reachable(2, 2, [[5, 5], [5, 5]]) [[5, 5], [5, 5]] >>> highest_point_reachable(2, 3, [[1, 3, 10], [2, 5, 8]]) [[10, 10, 10], [10, 10, 10]] >>> highest_point_reachable(3, 3, [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) [[9, 9, 9], [9, 9, 9], [9, 9, 9]]","solution":"def highest_point_reachable(n, m, grid): def dfs(x, y, visited): if (x, y) in visited: return grid[x][y] visited.add((x, y)) max_altitude = grid[x][y] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] >= grid[x][y]: max_altitude = max(max_altitude, dfs(nx, ny, visited)) grid[x][y] = max_altitude return max_altitude result = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): result[i][j] = dfs(i, j, set()) return result # Example input n = 3 m = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Get the result output = highest_point_reachable(n, m, grid) for row in output: print(\\" \\".join(map(str, row)))"},{"question":"from typing import List, Tuple def longest_distance(n: int, roads: List[Tuple[int, int]]) -> int: Given the number of regions and a list of roads connecting them, find the longest distance from the administrative center (region 1) to any other regional capital. >>> longest_distance(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 2 >>> longest_distance(3, [(1, 2), (1, 3)]) 1","solution":"from collections import deque, defaultdict def longest_distance(n, roads): # Create an adjacency list for the regions adj_list = defaultdict(list) for u, v in roads: adj_list[u].append(v) adj_list[v].append(u) # Perform BFS from the administrative center (region 1) def bfs(start): visited = [False] * (n + 1) distance = [-1] * (n + 1) queue = deque([start]) visited[start] = True distance[start] = 0 while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[node] + 1 queue.append(neighbor) return distance distance_from_center = bfs(1) return max(distance_from_center)"},{"question":"def opposite_house_number(x: int) -> int: Given a house number \`x\` on the left side of the street, find the house number directly opposite to it on the right side of the street. >>> opposite_house_number(1) 2 >>> opposite_house_number(5) 6 >>> opposite_house_number(13) 14 >>> opposite_house_number(50001) 50002 def test_opposite_house_number(): assert opposite_house_number(1) == 2 assert opposite_house_number(3) == 4 assert opposite_house_number(7) == 8 assert opposite_house_number(13) == 14 assert opposite_house_number(25) == 26 assert opposite_house_number(101) == 102 assert opposite_house_number(203) == 204 assert opposite_house_number(99999) == 100000 assert opposite_house_number(50001) == 50002 assert opposite_house_number(1) == 2 assert opposite_house_number(100001) == 100002","solution":"def opposite_house_number(x): Given a house number \`x\` on the left side of the street (odd numbered houses starting from 1), this function returns the house number directly opposite to it on the right side of the street (even numbered houses starting from 2). Parameters: x (int): An odd house number on the left side of the street. Returns: int: The house number directly opposite to \`x\` on the right side of the street. # The nth odd number is \`n * 2 - 1\`. # The nth even number is \`n * 2\`. n = (x + 1) // 2 # Get the position of the house \`x\` in the sequence of odd numbers. opposite_house = n * 2 # The house opposite to the nth odd number is the nth even number. return opposite_house"},{"question":"def largest_square_subgrid(grid, n, m): Find the maximum size of a square subgrid where all characters are the same. >>> grid = [['a', 'a', 'b', 'b'], ['a', 'a', 'b', 'b'], ['c', 'c', 'c', 'c']] >>> largest_square_subgrid(grid, 3, 4) 2 >>> grid = [['x', 'y', 'z'], ['x', 'y', 'z']] >>> largest_square_subgrid(grid, 2, 3) 1 >>> grid = [['a']] >>> largest_square_subgrid(grid, 1, 1) 1 >>> grid = [['a', 'a', 'a'], ['a', 'a', 'a'], ['a', 'a', 'a']] >>> largest_square_subgrid(grid, 3, 3) 3 >>> grid = [['a', 'b'], ['c', 'd']] >>> largest_square_subgrid(grid, 2, 2) 1","solution":"def largest_square_subgrid(grid, n, m): # Initialize the dp array dp = [[0]*m for _ in range(n)] max_size = 0 for i in range(n): for j in range(m): # The size of the square is 1 if we are at the first row or first column if i == 0 or j == 0: dp[i][j] = 1 else: # If the character matches with the left, top, and top-left diagonal characters if grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 # Update the max_size max_size = max(max_size, dp[i][j]) return max_size"},{"question":"def findPair(nums, target): Returns a list of two indices whose corresponding elements in \`nums\` add up to \`target\`. If no such pair exists, returns an empty list. Example: >>> findPair([2, 7, 11, 15], 9) [0, 1] >>> findPair([3, 2, 4], 6) [1, 2] >>> findPair([3, 3], 6) [0, 1] def test_example1(): assert findPair([2, 7, 11, 15], 9) == [0, 1] def test_example2(): assert findPair([3, 2, 4], 6) == [1, 2] def test_example3(): assert findPair([3, 3], 6) == [0, 1] def test_no_pair(): assert findPair([1, 2, 3, 4], 8) == [] def test_pair_at_the_end(): assert findPair([1, 2, 3, 4], 7) == [2, 3] def test_pair_at_the_beginning(): assert findPair([4, 3, 2, 1], 7) == [0, 1] def test_single_element(): assert findPair([1], 2) == [] def test_large_numbers(): assert findPair([100000, -99999], 1) == [0, 1]","solution":"def findPair(nums, target): Returns a list of two indices whose corresponding elements in \`nums\` add up to \`target\`. If no such pair exists, returns an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"\\") 0","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 hashmap = {} max_len = 2 while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def min_moves_to_reach_target(n: int, m: int, grid: List[str], r1: int, c1: int, r2: int, c2: int) -> int: Determine the minimum number of moves required to reach the target cell from the initial cell, or return -1 if it is not possible. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid grid (List[str]): The grid of size n x m filled with lowercase English letters r1 (int): Row index of initial cell (1-based) c1 (int): Column index of initial cell (1-based) r2 (int): Row index of target cell (1-based) c2 (int): Column index of target cell (1-based) Returns: int: Minimum number of moves to reach the target cell, or -1 if not possible Example: >>> min_moves_to_reach_target(4, 5, [\\"ababa\\", \\"bxbxb\\", \\"ababa\\", \\"bxbxb\\"], 1, 1, 4, 4) -1 >>> min_moves_to_reach_target(3, 3, [\\"aaa\\", \\"aba\\", \\"aaa\\"], 1, 1, 3, 3) 4","solution":"from collections import deque def min_moves_to_reach_target(n, m, grid, r1, c1, r2, c2): # Convert 1-based index to 0-based index r1, c1, r2, c2 = r1-1, c1-1, r2-1, c2-1 if (r1, c1) == (r2, c2): return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(r1, c1, 0)]) # Store current row, col, and distance visited = set((r1, c1)) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: if grid[nx][ny] == grid[x][y]: # Move only if the characters match if (nx, ny) == (r2, c2): return dist + 1 # Return distance if target is reached queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # Return -1 if target is not reachable"},{"question":"def count_days_with_max_diff(city1_temps: List[int], city2_temps: List[int]) -> int: Calculate the number of days with the highest temperature difference between two cities. Args: city1_temps (list of int): Temperatures of the first city. city2_temps (list of int): Temperatures of the second city. Returns: int: Number of days with the highest temperature difference. Examples: >>> count_days_with_max_diff([5, 6, 7, 4, 2], [1, 4, 3, 6, 8]) 1 >>> count_days_with_max_diff([1, 3, 5, 7, 9], [9, 8, 6, 7, 6]) 1 >>> count_days_with_max_diff([3, 3, 3, 3], [3, 3, 3, 3]) 4 >>> count_days_with_max_diff([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 5 >>> count_days_with_max_diff([0, 0, 0, 0], [0, 0, 0, 0]) 4","solution":"def count_days_with_max_diff(city1_temps, city2_temps): Calculate the number of days with the highest temperature difference between two cities. Args: city1_temps (list of int): Temperatures of the first city. city2_temps (list of int): Temperatures of the second city. Returns: int: Number of days with the highest temperature difference. differences = [abs(c1 - c2) for c1, c2 in zip(city1_temps, city2_temps)] max_diff = max(differences) return differences.count(max_diff)"},{"question":"from typing import List, Tuple def can_rearrange_with_constraints(T: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[Tuple[str, List[int]]]: Determine if you can rearrange the array such that no two adjacent elements have a difference greater than K. Parameters: T (int): the number of test cases cases (List[Tuple[Tuple[int, int], List[int]]]): a list of tuples, where each tuple contains another tuple of two integers (n, K) and a list of n integers Returns: List[Tuple[str, List[int]]]: for each test case, return \\"Yes\\" and an example of such rearrangement if possible, otherwise \\"No\\" >>> can_rearrange_with_constraints(3, [((3, 2), [1, 5, 3]), ((4, 3), [1, 2, 3, 4]), ((5, 1), [10, 20, 30, 40, 50])]) [('Yes', [1, 3, 5]), ('Yes', [1, 2, 3, 4]), ('No', [])] >>> can_rearrange_with_constraints(2, [((2, 1), [1, 3]), ((4, 0), [4, 4, 4, 4])]) [('No', []), ('Yes', [4, 4, 4, 4])]","solution":"def can_rearrange_with_constraints(T, cases): results = [] for i in range(T): n, K = cases[i][0] arr = cases[i][1] arr.sort() possible = True for j in range(n - 1): if abs(arr[j] - arr[j + 1]) > K: possible = False break if possible: results.append((\\"Yes\\", arr)) else: results.append((\\"No\\", [])) return results"},{"question":"from typing import List def min_cost_path(n: int, m: int, grid: List[List[int]]) -> int: Calculate the minimum cost to reach the bottom-right corner of the grid from the top-left corner. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the cost values of the cells. Returns: int: The minimum cost to reach the bottom-right corner. Examples: >>> min_cost_path(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path(1, 1, [[5]]) 5 >>> min_cost_path(1, 3, [[1, 2, 3]]) 6 >>> min_cost_path(3, 1, [[1], [2], [3]]) 6 >>> min_cost_path(2, 2, [[100, 200], [300, 400]]) 700 >>> min_cost_path(1000, 1000, [[1]*1000]*1000) 1999","solution":"def min_cost_path(n, m, grid): # Create a dp array to store the minimum cost for each cell dp = [[0 for _ in range(m)] for _ in range(n)] # Initialize the first cell with the given cost dp[0][0] = grid[0][0] # Fill the first row (only can come from left cells) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (only can come from top cells) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The cost to reach the bottom-right corner return dp[n-1][m-1]"},{"question":"def predict_outcome(board: str) -> str: Predicts the outcome of the game given the current sequence of letters on the blackboard. Parameters: board (str): a string representing the sequence of letters already written on the blackboard Returns: str: the result of the game in the format \\"Player loses\\" or \\"Game is still ongoing\\" Examples: >>> predict_outcome(\\"AAAB\\") 'Alice loses' >>> predict_outcome(\\"AABBAA\\") 'Game is still ongoing' >>> predict_outcome(\\"BBB\\") 'Bob loses' def test_game_ongoing(): assert predict_outcome(\\"\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"A\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"B\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"AB\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"BA\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"AAB\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"BBA\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"ABA\\") == \\"Game is still ongoing\\" assert predict_outcome(\\"AABB\\") == \\"Game is still ongoing\\" def test_alice_loses(): assert predict_outcome(\\"AAA\\") == \\"Alice loses\\" assert predict_outcome(\\"AAAB\\") == \\"Alice loses\\" assert predict_outcome(\\"AAABB\\") == \\"Alice loses\\" assert predict_outcome(\\"BAAAA\\") == \\"Alice loses\\" def test_bob_loses(): assert predict_outcome(\\"BBB\\") == \\"Bob loses\\" assert predict_outcome(\\"BBBA\\") == \\"Bob loses\\" assert predict_outcome(\\"AABBB\\") == \\"Bob loses\\" assert predict_outcome(\\"BBBBA\\") == \\"Bob loses\\"","solution":"def predict_outcome(board: str) -> str: Predicts the outcome of the game given the current sequence of letters on the blackboard. Parameters: board (str): a string representing the sequence of letters already written on the blackboard Returns: str: the result of the game in the format \\"Player loses\\" or \\"Game is still ongoing\\" if 'AAA' in board: return \\"Alice loses\\" elif 'BBB' in board: return \\"Bob loses\\" else: return \\"Game is still ongoing\\""},{"question":"from typing import List, Dict def largest_obstacle_free_subgrid(t: int, test_cases: List[Dict[str, any]]) -> List[int]: Determines the size of the largest rectangular subgrid that contains no obstacles. For each test case, prints the size of the largest rectangular subgrid containing no obstacles. >>> t = 2 >>> test_cases = [ {'n': 3, 'm': 4, 'grid': ['..#.', '.#..', '....']}, {'n': 2, 'm': 2, 'grid': ['#.', '.#']} ] >>> largest_obstacle_free_subgrid(t, test_cases) [4, 1] pass def test_largest_obstacle_free_subgrid(): t = 2 test_cases = [ {'n': 3, 'm': 4, 'grid': ['..#.', '.#..', '....']}, {'n': 2, 'm': 2, 'grid': ['#.', '.#']} ] assert largest_obstacle_free_subgrid(t, test_cases) == [4, 1] t = 1 test_cases = [ {'n': 4, 'm': 4, 'grid': ['....', '....', '....', '....']} ] assert largest_obstacle_free_subgrid(t, test_cases) == [16] t = 1 test_cases = [ {'n': 1, 'm': 1, 'grid': ['#']} ] assert largest_obstacle_free_subgrid(t, test_cases) == [0] t = 1 test_cases = [ {'n': 1, 'm': 4, 'grid': ['.#..']} ] assert largest_obstacle_free_subgrid(t, test_cases) == [2] t = 1 test_cases = [ {'n': 3, 'm': 3, 'grid': ['...', '..#', '...']} ] assert largest_obstacle_free_subgrid(t, test_cases) == [6] t = 1 test_cases = [ {'n': 2, 'm': 2, 'grid': ['..', '..']} ] assert largest_obstacle_free_subgrid(t, test_cases) == [4] if __name__ == \\"__main__\\": test_largest_obstacle_free_subgrid()","solution":"def largest_obstacle_free_subgrid(t, test_cases): def maxHist(row): stack = [] max_area = 0 index = 0 while index < len(row): if not stack or row[stack[-1]] <= row[index]: stack.append(index) index += 1 else: top = stack.pop() area = (row[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top = stack.pop() area = (row[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area results = [] for case in test_cases: n, m, grid = case['n'], case['m'], case['grid'] dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == '.': dp[i][j] = (dp[i - 1][j] + 1) if i > 0 else 1 else: dp[i][j] = 0 max_area = 0 for i in range(n): max_area = max(max_area, maxHist(dp[i])) results.append(max_area) return results"},{"question":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Returns the maximum sum of non-adjacent elements in the array nums. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([1, 2, 3, 4, 5]) 9 >>> max_non_adjacent_sum([-5, -1, -8, -9]) 0 >>> max_non_adjacent_sum([10, 5, 20, 15, 30, 25]) 60 >>> max_non_adjacent_sum([50]) 50 >>> max_non_adjacent_sum([1, -1, 1, -1, 1]) 3 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([-1, -2, -3, 5, -1, 4]) 9","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the array nums. if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include = max(0, nums[0]) # Sum including current element exclude = 0 # Sum excluding current element for num in nums[1:]: new_exclude = max(include, exclude) # New exclude becomes max of previous include and exclude include = exclude + num # New include becomes previous exclude + current num exclude = new_exclude # Update exclude to new_exclude return max(include, exclude)"},{"question":"def longest_unique_char_substring(n: int, s: str) -> int: Returns the length of the longest contiguous substring that can contain exactly one unique character after performing a single character replacement operation. Parameters: n (int): The length of the string. s (str): The input string. Returns: int: The length of the longest contiguous substring with exactly one unique character after one replacement. pass # Tests def test_example_case(): assert longest_unique_char_substring(4, \\"abca\\") == 3 def test_single_character(): assert longest_unique_char_substring(1, \\"a\\") == 1 def test_two_same_characters(): assert longest_unique_char_substring(2, \\"aa\\") == 2 def test_distinct_characters(): assert longest_unique_char_substring(3, \\"abc\\") == 2 def test_all_same_characters(): assert longest_unique_char_substring(5, \\"aaaaa\\") == 5 def test_intermixed_characters(): assert longest_unique_char_substring(5, \\"aabbc\\") == 3 def test_longer_string(): assert longest_unique_char_substring(6, \\"abacaba\\") == 4","solution":"def longest_unique_char_substring(n, s): Returns the length of the longest contiguous substring that can contain exactly one unique character after performing a single character replacement operation. Parameters: n (int): The length of the string. s (str): The input string. Returns: int: The length of the longest contiguous substring with exactly one unique character after one replacement. if n == 1: return 1 # If the string length is 1, the longest possible substring is always 1. max_len = 1 for i in range(n): # Get the frequency of characters in the whole string except the current character freq = [0] * 26 for j in range(n): if i != j: freq[ord(s[j]) - ord('a')] += 1 # Check the longest substring after replacing the character at index i with any other character for c in range(26): if freq[c] == 0: continue # Calculate the extended length of the substring with this replacement length = freq[c] + 1 max_len = max(max_len, length) return max_len"},{"question":"def edges_to_golden_fruit(m: int, k: int) -> int: Calculate the number of edges to traverse from the root to node k in a binary tree of height m. Args: m (int): Number of levels in the tree (1 ≤ m ≤ 20). k (int): 1-based index of the node (1 ≤ k ≤ 2^m). Returns: int: Number of edges from the root to the node k. Examples: >>> edges_to_golden_fruit(3, 7) 2 >>> edges_to_golden_fruit(1, 1) 0","solution":"def edges_to_golden_fruit(m, k): Calculate the number of edges to traverse from the root to node k in a binary tree of height m. Args: m (int): Number of levels in the tree (1 ≤ m ≤ 20). k (int): 1-based index of the node (1 ≤ k ≤ 2^m). Returns: int: Number of edges from the root to the node k. k_binary = bin(k)[2:] # Convert k to binary and strip the '0b' prefix return len(k_binary) - 1"},{"question":"def min_train_routes(n: int, m: int, p: int, edges: List[Tuple[int, int, int]]) -> Union[List[Tuple[int, int, int]], str]: In a country called Arithmus, determine if it is possible to add at most p new train routes to achieve full connectivity between all n cities. If possible, return the roads used; otherwise, return 'IMPOSSIBLE'. Args: n (int): The number of cities. m (int): The number of existing roads. p (int): The maximum number of new train routes to add. edges (List[Tuple[int, int, int]]): The existing roads, where each road is represented as a tuple (u, v, l). Returns: Union[List[Tuple[int, int, int]], str]: A list of roads (tuples) used if full connectivity is achieved with at most p new routes, or 'IMPOSSIBLE' if it's not feasible. Examples: >>> min_train_routes(4, 4, 1, [(1, 2, 5), (2, 3, 3), (3, 4, 7), (4, 1, 2)]) [(1, 2, 5), (2, 3, 3), (3, 4, 7), (4, 1, 2)] >>> min_train_routes(4, 2, 0, [(1, 2, 5), (3, 4, 7)]) 'IMPOSSIBLE' pass # Test cases to validate the solution def test_min_train_routes(): input_data = (4, 4, 1, [(1, 2, 5), (2, 3, 3), (3, 4, 7), (4, 1, 2)]) expected_result = [(1, 2, 5), (2, 3, 3), (3, 4, 7), (4, 1, 2)] assert min_train_routes(*input_data) == expected_result def test_min_train_routes_impossible(): input_data = (4, 2, 0, [(1, 2, 5), (3, 4, 7)]) expected_result = 'IMPOSSIBLE' assert min_train_routes(*input_data) == expected_result def test_min_train_routes_with_additional_roads(): input_data = (5, 4, 1, [(1, 2, 5), (2, 3, 3), (3, 4, 7), (4, 1, 2)]) result = min_train_routes(*input_data) assert \\"1 5 1\\" in result or \\"5 1 1\\" in result def test_min_train_routes_no_additional_needed(): input_data = (3, 3, 2, [(1, 2, 5), (2, 3, 3), (3, 1, 1)]) expected_result = [(1, 2, 5), (2, 3, 3), (3, 1, 1)] assert min_train_routes(*input_data) == expected_result","solution":"def find_connected_components(n, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v, l in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = [] def bfs(start): queue = deque([start]) visited[start] = True comp = [] while queue: node = queue.popleft() comp.append(node) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return comp for i in range(1, n + 1): if not visited[i]: components.append(bfs(i)) return components def min_train_routes(n, m, p, edges): components = find_connected_components(n, edges) if len(components) - 1 > p: return \\"IMPOSSIBLE\\" edges_used = set((u, v) for u, v, l in edges) new_routes = [] if len(components) == 1: return edges else: for i in range(len(components) - 1): city1 = components[i][0] city2 = components[i + 1][0] if (city1, city2) not in edges_used and (city2, city1) not in edges_used: new_routes.append((city1, city2, 1)) edges_used.add((city1, city2)) else: new_routes.append((city1, city2, 1)) all_edges = edges + [(u, v, l) for u, v, l in new_routes] return all_edges # Reading input from a function for dynamic testing def solve(input_data): input_lines = input_data.strip().split('n') n, m, p = map(int, input_lines[0].split()) edges = [] for i in range(1, m + 1): u, v, l = map(int, input_lines[i].split()) edges.append((u, v, l)) result = min_train_routes(n, m, p, edges) if result == \\"IMPOSSIBLE\\": return result else: return \\"n\\".join(f\\"{u} {v} {l}\\" for u, v, l in result)"},{"question":"from typing import List, Tuple class Graph: def __init__(self, n: int): Initialize the graph with n nodes. pass def add_edge(self, u: int, v: int, w: int): Add an edge between nodes u and v with weight w. pass def remove_edge(self, u: int, v: int): Remove the edge between nodes u and v. pass def shortest_path(self, start: int, end: int) -> int: Find the shortest path distance between nodes start and end. If there is no path, return -1. pass def graph_operations(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[str, int, int, int]]) -> List[int]: Perform operations on the graph based on the queries and return the result of PATH queries. pass if __name__ == \\"__main__\\": # Example usage n = 4 m = 3 edges = [(1, 2, 4), (2, 3, 3), (3, 4, 1)] queries = [ ('PATH', 1, 4), # Expected output: 8 ('ADD', 1, 3, 2), ('PATH', 1, 4), # Expected output: 3 ('REMOVE', 2, 3), ('PATH', 1, 4) # Expected output: 3 ] results = graph_operations(n, m, edges, queries) for result in results: print(result)","solution":"import heapq import sys from collections import defaultdict, deque class Graph: def __init__(self, n): self.n = n self.adj = defaultdict(list) self.dist = [[float('inf')] * n for _ in range(n)] def add_edge(self, u, v, w): self.adj[u].append((v, w)) self.adj[v].append((u, w)) self.dist[u-1][v-1] = w self.dist[v-1][u-1] = w def remove_edge(self, u, v): self.adj[u] = [(node, weight) for node, weight in self.adj[u] if node != v] self.adj[v] = [(node, weight) for node, weight in self.adj[v] if node != u] self.dist[u-1][v-1] = float('inf') self.dist[v-1][u-1] = float('inf') def shortest_path(self, start, end): dist = [float('inf')] * self.n dist[start-1] = 0 pq = [(0, start)] heapq.heapify(pq) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u-1]: continue for v, weight in self.adj[u]: distance = current_dist + weight if distance < dist[v-1]: dist[v-1] = distance heapq.heappush(pq, (distance, v)) return dist[end-1] if dist[end-1] != float('inf') else -1 def graph_operations(n, m, edges, queries): graph = Graph(n) for u, v, w in edges: graph.add_edge(u, v, w) result = [] for query in queries: if query[0] == 'ADD': _, u, v, w = query graph.add_edge(u, v, int(w)) elif query[0] == 'REMOVE': _, u, v = query graph.remove_edge(u, v) elif query[0] == 'PATH': _, u, v = query dist = graph.shortest_path(u, v) result.append(dist) return result"},{"question":"def decode_number(original: str, swaps: str) -> str: Decodes the given number based on the provided swaps. Args: original (str): The encoded number as a string. swaps (str): The swaps in format 'a:b,c:d'. Returns: str: The decoded number as a string. >>> decode_number(\\"102\\", \\"\\") == \\"102\\" >>> decode_number(\\"102\\", \\"1:2\\") == \\"202\\" >>> decode_number(\\"102\\", \\"1:2,2:3\\") == \\"203\\" >>> decode_number(\\"12345\\", \\"1:9\\") == \\"92345\\" >>> decode_number(\\"123\\", \\"1:2,2:3\\") == \\"233\\" >>> decode_number(\\"121212\\", \\"1:2,2:3\\") == \\"232323\\" >>> decode_number(\\"123\\", \\"1:2,2:1\\") == \\"213\\" >>> decode_number(\\"010101\\", \\"0:1,1:0\\") == \\"101010\\"","solution":"def decode_number(original, swaps): Decodes the given number based on the provided swaps. Args: original (str): The encoded number as a string. swaps (str): The swaps in format 'a:b,c:d'. Returns: str: The decoded number as a string. # Creating a dictionary to map swaps swap_dict = {} if swaps: for swap in swaps.split(','): a, b = swap.split(':') swap_dict[a] = b # Decode the number based on the swap dictionary decoded_number = [] for char in original: if char in swap_dict: decoded_number.append(swap_dict[char]) else: decoded_number.append(char) return ''.join(decoded_number)"},{"question":"def min_operations_to_divisibility(m: int, d: int, b: List[int]) -> int: Determine the minimum number of operations required to ensure that all elements of the array b are divisible by d. Args: m (int): The number of elements in the array. d (int): The divisor. b (List[int]): The list of integers. Returns: int: The minimum number of operations required to make all elements divisible by d. >>> min_operations_to_divisibility(3, 5, [10, 20, 5]) 0 >>> min_operations_to_divisibility(3, 5, [10, 22, 5]) 1 >>> min_operations_to_divisibility(4, 5, [10, 21, 1, 17]) 5 >>> min_operations_to_divisibility(3, 1, [2, 5, 3]) 0 >>> min_operations_to_divisibility(2, 4, [97, 345]) 2 >>> min_operations_to_divisibility(1, 4, [95]) 1","solution":"def min_operations_to_divisibility(m, d, b): Returns the minimum number of operations required to make all elements of the array b divisible by d. min_operations = 0 for val in b: remainder = val % d if remainder != 0: operations = (d - remainder) // 3 if (d - remainder) % 3 != 0: operations += 1 min_operations += operations return min_operations"},{"question":"from typing import List def maxSumOfAverages(nums: List[int], k: int) -> float: Given an array of n integers, divide the array into k non-empty contiguous subarrays such that the sum of the average of these subarrays is maximized. >>> maxSumOfAverages([9, 1, 2, 3, 9], 3) 20.0 >>> maxSumOfAverages([10], 1) 10.0 >>> maxSumOfAverages([1, 2, 3, 4, 5], 1) 3.0 >>> maxSumOfAverages([1, 2, 3, 4, 5], 5) 15.0 >>> maxSumOfAverages([10000] * 5, 3) 30000.0","solution":"from typing import List def maxSumOfAverages(nums: List[int], k: int) -> float: n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i+1] = prefix_sum[i] + nums[i] # dp[i][j] means the maximum sum of averages we can get by dividing the first i numbers into j parts dp = [[0.0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): dp[i][1] = prefix_sum[i] / i for j in range(2, k + 1): for i in range(1, n + 1): for x in range(j - 1, i): dp[i][j] = max(dp[i][j], dp[x][j - 1] + (prefix_sum[i] - prefix_sum[x]) / (i - x)) return dp[n][k]"},{"question":"def get_max_product_of_subarray(n: int, array: List[int]) -> int: Computes the maximum product of any subarray. Args: n (int): Number of elements in the array. array (List[int]): List of positive integers. Returns: int: The maximum product of any subarray. >>> get_max_product_of_subarray(5, [1, 2, 3, 4, 5]) 120 >>> get_max_product_of_subarray(4, [6, 2, 1, 8]) 96","solution":"def max_product_subarray(arr): Computes the maximum product of any subarray. n = len(arr) if n == 0: return 0 max_product = arr[0] min_product = arr[0] result = arr[0] for i in range(1, n): if arr[i] < 0: max_product, min_product = min_product, max_product max_product = max(arr[i], max_product * arr[i]) min_product = min(arr[i], min_product * arr[i]) result = max(result, max_product) return result def get_max_product_of_subarray(n, array): return max_product_subarray(array)"},{"question":"def is_balanced(s: str) -> str: Returns \\"YES\\" if the sequence of brackets is balanced, otherwise \\"NO\\". >>> is_balanced(\\"([{}])\\") \\"YES\\" >>> is_balanced(\\"([)]\\") \\"NO\\"","solution":"def is_balanced(s): Returns \\"YES\\" if the sequence of brackets is balanced, otherwise \\"NO\\". stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map.values(): # opening brackets stack.append(char) elif char in bracket_map: # closing brackets if stack == [] or bracket_map[char] != stack.pop(): return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def max_consecutive_identical(nums: List[int]) -> int: Determines the maximum count of consecutive identical integers in the list. >>> max_consecutive_identical([1]) == 1 >>> max_consecutive_identical([2, 2, 2, 2]) == 4 >>> max_consecutive_identical([1, 2, 3, 4]) == 1 >>> max_consecutive_identical([1, 1, 2, 2, 2, 3]) == 3 >>> max_consecutive_identical([5, 5, 5, 1, 1, 1, 1, 2, 2, 3]) == 4 >>> max_consecutive_identical([]) == 0","solution":"def max_consecutive_identical(nums): Determines the maximum count of consecutive identical integers in the list. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def longest_non_decreasing_subsequence_length(s: str) -> int: Returns the length of the longest non-decreasing subsequence in the string. >>> longest_non_decreasing_subsequence_length(\\"abacabadabacaba\\") 8 >>> longest_non_decreasing_subsequence_length(\\"zyx\\") 1","solution":"def longest_non_decreasing_subsequence_length(s: str) -> int: Returns the length of the longest non-decreasing subsequence in the string. # If the string is empty, the longest subsequence is 0. if not s: return 0 # Dynamic programming array to store lengths of longest non-decreasing subsequence dp = [1] * len(s) for i in range(1, len(s)): for j in range(i): if s[i] >= s[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List, Tuple def find_shortest_path(graph: List[Tuple[int, int]], start: int, end: int) -> List[int]: Returns the shortest path from start to end in the given product catalog graph. If no path exists, returns an empty list. >>> find_shortest_path([(0, 1), (1, 2)], 0, 2) [0, 1, 2] >>> find_shortest_path([(0, 1), (2, 3)], 0, 3) [] >>> find_shortest_path([(0, 1), (1, 2)], 1, 1) [1] >>> find_shortest_path([(0, 1), (0, 2), (1, 3), (2, 3)], 0, 3) [0, 1, 3] # or [0, 2, 3] # Unit Tests def test_direct_path(): graph = [(0, 1), (1, 2)] assert find_shortest_path(graph, 0, 2) == [0, 1, 2] def test_no_path(): graph = [(0, 1), (2, 3)] assert find_shortest_path(graph, 0, 3) == [] def test_same_start_end(): graph = [(0, 1), (1, 2)] assert find_shortest_path(graph, 1, 1) == [1] def test_multiple_shortest_path(): graph = [(0, 1), (0, 2), (1, 3), (2, 3)] result = find_shortest_path(graph, 0, 3) assert result in [[0, 1, 3], [0, 2, 3]] def test_larger_graph(): graph = [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5)] assert find_shortest_path(graph, 0, 5) == [0, 1, 3, 4, 5]","solution":"from collections import deque, defaultdict def find_shortest_path(graph, start, end): Returns the shortest path from start to end in the given graph. If no path exists, returns an empty list. if start == end: return [start] # Convert edge list to adjacency list adj_list = defaultdict(list) for u, v in graph: adj_list[u].append(v) adj_list[v].append(u) # BFS to find the shortest path queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: current_node, path = queue.popleft() for neighbor in adj_list[current_node]: if neighbor == end: return path + [neighbor] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] # Example usage: # graph = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3)] # start = 0 # end = 3 # print(find_shortest_path(graph, start, end)) # Output: [0, 1, 3] or [0, 2, 3]"},{"question":"def longest_substring_with_one_distinct_char(s: str, k: int) -> int: Determines the length of the longest substring which contains exactly one distinct character after performing at most k operations. >>> longest_substring_with_one_distinct_char(\\"aabc\\", 2) 4 >>> longest_substring_with_one_distinct_char(\\"aaabb\\", 1) 4 >>> longest_substring_with_one_distinct_char(\\"aaabb\\", 2) 5 >>> longest_substring_with_one_distinct_char(\\"abcde\\", 1) 2 >>> longest_substring_with_one_distinct_char(\\"abaccc\\", 1) 4 >>> longest_substring_with_one_distinct_char(\\"\\", 0) 0 >>> longest_substring_with_one_distinct_char(\\"abcde\\", 5) 5 >>> longest_substring_with_one_distinct_char(\\"aabbcc\\", 2) 4","solution":"def longest_substring_with_one_distinct_char(s, k): n = len(s) if n == 0: return 0 max_len = 0 left = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while (right - left + 1) - max(char_count.values()) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def longest_high_traffic_period(n: int, t: int, data_rates: List[int]) -> int: Determine the longest consecutive subsequence of data rates above the threshold. Parameters: n (int): The number of seconds the data is collected. t (int): The threshold traffic rate. data_rates (List[int]): The data rate measurements for each second in the period. Returns: int: The length of the longest sustained high traffic period. Examples: >>> longest_high_traffic_period(10, 5, [0, 7, 9, 5, 6, 3, 5, 7, 8, 5]) 2 >>> longest_high_traffic_period(5, 3, [4, 4, 4, 1, 4]) 3","solution":"def longest_high_traffic_period(n, t, data_rates): longest_period = 0 current_period = 0 for rate in data_rates: if rate > t: current_period += 1 longest_period = max(longest_period, current_period) else: current_period = 0 return longest_period"},{"question":"def max_tasks_on_time(durations: List[int], deadlines: List[int]) -> int: Schedule tasks in such a way that maximizes the number of tasks completed on time. Args: durations (List[int]): A list of integers where the ith integer represents the duration of the ith task. deadlines (List[int]): A list of integers where the ith integer represents the deadline of the ith task. Returns: int: The maximum number of tasks that can be completed on time. Examples: >>> max_tasks_on_time([4, 2, 3], [5, 2, 7]) 2 >>> max_tasks_on_time([1, 2, 1], [3, 4, 5]) 3","solution":"def max_tasks_on_time(durations, deadlines): tasks = sorted(zip(durations, deadlines), key=lambda x: x[1]) # Sort tasks by deadline current_time = 0 completed_tasks = 0 for duration, deadline in tasks: if current_time + duration <= deadline: current_time += duration completed_tasks += 1 return completed_tasks"},{"question":"def manage_server_capacities(n: int, m: int, q: int, capacities: List[int], connections: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Manage the capacities of servers and handle queries to update or retrieve capacities. Args: n: Number of servers m: Number of connections q: Number of queries capacities: List of initial capacities of servers connections: List of high-speed connections between servers queries: List of queries to update or retrieve server capacities Returns: List of results for the queries retrieving capacities Test Cases: >>> manage_server_capacities(5, 4, 5, [3, 6, 2, 7, 1], [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 3, 5), (2, 3), (1, 4, 2), (2, 4), (2, 1)]) [7, 9, 3] >>> manage_server_capacities(3, 2, 4, [10, 20, 30], [(1, 2), (2, 3)], [(2, 1), (1, 2, 10), (2, 2), (2, 3)]) [10, 30, 30] >>> manage_server_capacities(1, 0, 2, [5], [], [(2, 1), (1, 1, 3)]) [5] >>> manage_server_capacities(2, 1, 1, [0, 0], [(1, 2)], [(1, 1, 500)]) [] >>> manage_server_capacities(4, 3, 6, [100, 200, 300, 400], [(1, 2), (1, 3), (1, 4)], [(2, 1), (2, 2), (1, 3, 45), (2, 3), (1, 1, 100), (2, 1)]) [100, 200, 345, 200]","solution":"def manage_server_capacities(n, m, q, capacities, connections, queries): # Initializing the server capacities from the given list server_capacities = capacities[:] # Processing each query results = [] for query in queries: if query[0] == 1: # Add capacity operation _, x, val = query server_capacities[x - 1] += val elif query[0] == 2: # Query capacity operation _, x = query results.append(server_capacities[x - 1]) return results"},{"question":"def find_pair(numbers: List[int], target: int) -> Union[Tuple[int, int], None]: Determines if there are two distinct elements in the array that add up to the target sum. Args: numbers (list): A list of integers. target (int): The target sum. Returns: tuple: A tuple containing the indices of the two numbers that add up to the target sum, or None if no such pair exists. >>> find_pair([2, 7, 11, 15], 9) (0, 1) >>> find_pair([1, 2, 3, 4], 8) None >>> find_pair([1, 4, 5, 1], 6) (0, 2) # or (1, 3) >>> find_pair([3, 3], 6) (0, 1) >>> find_pair([5], 5) None >>> find_pair([100, 200, 300, 400], 700) (2, 3) >>> find_pair([0, 0, 1000, 0], 0) (0, 1) # or (0, 3)","solution":"def find_pair(numbers, target): Determines if there are two distinct elements in the array that add up to the target sum. Args: numbers (list): A list of integers. target (int): The target sum. Returns: tuple: A tuple containing the indices of the two numbers that add up to the target sum, or None if no such pair exists. num_to_index = {} for index, num in enumerate(numbers): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"def longest_subarray_with_sum_k(arr, k): Returns the length of the longest subarray that has a sum equal to k. >>> longest_subarray_with_sum_k([1, 2, 3, 5, -3], 5) 3 >>> longest_subarray_with_sum_k([1, 2, 3, 4], 7) 2 >>> longest_subarray_with_sum_k([2, 3, 7, 3, 1, 9], 12) 3 >>> longest_subarray_with_sum_k([1, 2, 3], 7) 0 >>> longest_subarray_with_sum_k([1, -1, 2, -2, 3, -3, 4], 4) 7 >>> longest_subarray_with_sum_k([5], 5) 1 pass def process_test_cases(test_cases): results = [] for n, k, arr in test_cases: results.append(longest_subarray_with_sum_k(arr, k)) return results","solution":"def longest_subarray_with_sum_k(arr, k): Returns the length of the longest subarray that has a sum equal to k. prefix_sum_indices = {} prefix_sum = 0 max_length = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum == k: max_length = i + 1 if (prefix_sum - k) in prefix_sum_indices: max_length = max(max_length, i - prefix_sum_indices[prefix_sum - k]) if prefix_sum not in prefix_sum_indices: prefix_sum_indices[prefix_sum] = i return max_length def process_test_cases(test_cases): results = [] for n, k, arr in test_cases: results.append(longest_subarray_with_sum_k(arr, k)) return results"},{"question":"def find_position_of_one(test_cases): Determine the position of 1 in the cyclic reordering of the sequence that achieves the lexicographically smallest permutation. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing an integer n and a list of n distinct integers. Returns: List[int]: The 1-based index positions of 1 in the smallest permutation for each test case. Example: >>> find_position_of_one([(4, [3, 1, 4, 2]), (5, [5, 3, 4, 1, 2]), (6, [6, 5, 4, 3, 2, 1])]) [2, 4, 6] >>> find_position_of_one([(1, [1])]) [1]","solution":"def find_position_of_one(test_cases): results = [] for case in test_cases: n = case[0] sequence = case[1] position = sequence.index(1) + 1 results.append(position) return results"},{"question":"def can_form_palindrome(s: str) -> str: Determines if it's possible to rearrange the string to form a palindrome. Parameters: s (str): The input string containing lowercase letters and digits. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(\\"a1b1a\\") \\"YES\\" >>> can_form_palindrome(\\"b1c2c1b\\") \\"NO\\" pass from can_form_palindrome import can_form_palindrome def test_single_character(): assert can_form_palindrome(\\"a\\") == \\"YES\\" def test_two_different_characters(): assert can_form_palindrome(\\"ab\\") == \\"NO\\" def test_even_length_palindrome(): assert can_form_palindrome(\\"aabb\\") == \\"YES\\" def test_odd_length_palindrome(): assert can_form_palindrome(\\"aabbc\\") == \\"YES\\" def test_cannot_form_palindrome(): assert can_form_palindrome(\\"abcdef\\") == \\"NO\\" def test_numbers_and_letters(): assert can_form_palindrome(\\"a1b2b1a\\") == \\"YES\\" assert can_form_palindrome(\\"a1b2b3a\\") == \\"NO\\" def test_long_palindrome(): assert can_form_palindrome(\\"abc123321cba\\") == \\"YES\\" def test_multiple_odd_counts(): assert can_form_palindrome(\\"aaabbbcccddd\\") == \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s): Determines if it's possible to rearrange the string to form a palindrome. Parameters: s (str): The input string containing lowercase letters and digits. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome, # at most one character can have an odd count. if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def process_operations(operations: List[str]) -> List[int]: Process a list of operations on an array of integers and return the results of 'sum' operations. Args: operations (List[str]): A list of operations to perform on the array of integers. The operations can be: - \\"add x\\": Add the integer x to the end of the array. - \\"remove\\": Remove the integer from the end of the array. - \\"sum l r\\": Calculate the sum of elements from the l-th to the r-th (inclusive, 1-based indexing) element in the array. Returns: List[int]: A list of results of each 'sum' operation. Example: >>> process_operations([\\"add 3\\", \\"add 5\\", \\"sum 1 2\\", \\"add 2\\", \\"remove\\", \\"sum 1 2\\", \\"add 6\\"]) [8, 8] >>> process_operations([\\"add 1\\", \\"add 2\\", \\"add 3\\", \\"sum 1 3\\", \\"remove\\", \\"sum 1 2\\"]) [6, 3] >>> process_operations([\\"add 10\\", \\"sum 1 1\\", \\"add 20\\", \\"remove\\", \\"sum 1 1\\"]) [10, 10] >>> process_operations([\\"add -1\\", \\"add -2\\", \\"add -3\\", \\"sum 1 3\\", \\"remove\\", \\"sum 1 2\\"]) [-6, -3] >>> process_operations([\\"sum 1 1\\", \\"remove\\", \\"sum 1 1\\"]) [0, 0]","solution":"def process_operations(operations): array = [] results = [] for operation in operations: op = operation.split() if op[0] == \\"add\\": array.append(int(op[1])) elif op[0] == \\"remove\\": if array: array.pop() elif op[0] == \\"sum\\": l = int(op[1]) - 1 r = int(op[2]) - 1 results.append(sum(array[l:r+1])) return results"},{"question":"def can_transform(a: List[int], b: List[int]) -> bool: Determines if array a can be transformed into array b using the specified operations. >>> can_transform([1, 2, 3], [3, 2, 1]) True >>> can_transform([1, 2, 3], [4, 2, 1]) False >>> can_transform([1, 1, 1, 1], [1, 1, 1, 1]) True >>> can_transform([1, 2, 3], [1, 2, 4]) False >>> can_transform([i for i in range(1000)], [i for i in range(999, -1, -1)]) True >>> can_transform([0, 0, 0, 0], [0, 0, 0, 0]) True","solution":"def can_transform(a, b): Determines if array a can be transformed into array b using the specified operations. return sorted(a) == sorted(b)"},{"question":"from typing import List, Tuple def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform string s1 into string s2. The operations available are: 1. Insert a single character into s1. 2. Delete a single character from s1. 3. Replace a single character in s1 with another character. pass def transform_strings(t: int, test_cases: List[Tuple[str, str]]) -> List[int]: Given t test cases, each having two strings s1 and s2, this function returns a list of integers representing the minimum number of operations required to transform s1 into s2 for each test case. Parameters: t : int : the number of test cases test_cases : List[Tuple[str, str]] : a list of tuples, each containing two strings (s1 and s2) Returns: List[int] : a list of integers denoting the minimum number of operations for each test case Example: >>> transform_strings(3, [(\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"lawn\\"), (\\"intention\\", \\"execution\\")]) [3, 2, 5] pass # Unit Tests def test_single_case(): assert transform_strings(1, [(\\"kitten\\", \\"sitting\\")]) == [3] def test_multiple_cases(): assert transform_strings(3, [ (\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"lawn\\"), (\\"intention\\", \\"execution\\") ]) == [3, 2, 5] def test_no_change_needed(): assert transform_strings(1, [(\\"apple\\", \\"apple\\")]) == [0] def test_insertion_needed(): assert transform_strings(1, [(\\"abc\\", \\"abcd\\")]) == [1] def test_deletion_needed(): assert transform_strings(1, [(\\"abcd\\", \\"abc\\")]) == [1] def test_replacement_needed(): assert transform_strings(1, [(\\"abc\\", \\"adc\\")]) == [1] def test_combination_operations(): assert transform_strings(1, [(\\"horse\\", \\"ros\\")]) == [3] def test_single_char_strings(): assert transform_strings(1, [(\\"a\\", \\"b\\")]) == [1]","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform string s1 into string s2. The operations available are: 1. Insert a single character into s1. 2. Delete a single character from s1. 3. Replace a single character in s1 with another character. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n] def transform_strings(t, test_cases): results = [] for case in test_cases: s1, s2 = case results.append(min_operations(s1, s2)) return results"},{"question":"def is_k_palindrome(k: int, s: str) -> str: Determine if the string s is a k-palindrome, meaning it can be turned into a palindrome by removing at most k characters. >>> is_k_palindrome(1, \\"abca\\") \\"YES\\" >>> is_k_palindrome(2, \\"abcde\\") \\"NO\\" >>> is_k_palindrome(0, \\"racecar\\") \\"YES\\" def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases to determine if each string is a k-palindrome. >>> process_test_cases(3, [(1, \\"abca\\"), (2, \\"abcde\\"), (0, \\"racecar\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [(2, \\"abcdba\\"), (5, \\"abcdef\\")]) [\\"YES\\", \\"YES\\"]","solution":"def is_k_palindrome(k, s): Determine if the string s is a k-palindrome, meaning it can be turned into a palindrome by removing at most k characters. def min_deletions_to_palindrome(s): n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] required_deletions = min_deletions_to_palindrome(s) return \\"YES\\" if required_deletions <= k else \\"NO\\" def process_test_cases(t, test_cases): results = [] for k, s in test_cases: result = is_k_palindrome(k, s) results.append(result) return results"},{"question":"def longest_substring_with_k_distinct(p: int, s: str) -> int: Returns the length of the longest substring with at most p distinct characters. >>> longest_substring_with_k_distinct(2, \\"abcba\\") 3 >>> longest_substring_with_k_distinct(1, \\"aaaa\\") 4 >>> longest_substring_with_k_distinct(3, \\"abcabcabc\\") 9 >>> longest_substring_with_k_distinct(2, \\"abcdefg\\") 2 >>> longest_substring_with_k_distinct(1, \\"abcde\\") 1","solution":"def longest_substring_with_k_distinct(p, s): Returns the length of the longest substring with at most p distinct characters. from collections import defaultdict char_count = defaultdict(int) l, r = 0, 0 max_length = 0 distinct_count = 0 while r < len(s): char_count[s[r]] += 1 if char_count[s[r]] == 1: distinct_count += 1 while distinct_count > p: char_count[s[l]] -= 1 if char_count[s[l]] == 0: distinct_count -= 1 l += 1 max_length = max(max_length, r - l + 1) r += 1 return max_length"},{"question":"def can_rearrange_to_satisfy_weights(n: int, m: int, A: List[int], B: List[int]) -> str: Determines if it is possible to rearrange the elements of both arrays such that the Weight of array A is strictly greater than the Weight of array B. >>> can_rearrange_to_satisfy_weights(3, 3, [1, 2, 3], [3, 6, 9]) == \\"NO\\" >>> can_rearrange_to_satisfy_weights(4, 6, [2, 4, 6, 8], [1, 2, 3, 4, 5, 6]) == \\"YES\\" >>> can_rearrange_to_satisfy_weights(2, 3, [5, 5], [1, 1, 1]) == \\"YES\\" >>> can_rearrange_to_satisfy_weights(5, 5, [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]) == \\"NO\\" >>> can_rearrange_to_satisfy_weights(3, 4, [1, 2, 3], [3, 3, 3, 3]) == \\"NO\\"","solution":"def can_rearrange_to_satisfy_weights(n, m, A, B): Determines if it is possible to rearrange the elements of both arrays such that the Weight of array A is strictly greater than the Weight of array B. weight_A = sum(A) / n weight_B = sum(B) / m return \\"YES\\" if weight_A > weight_B else \\"NO\\""},{"question":"def fizz_buzz(n: int) -> str: Generates a sequence of numbers from 1 to n with the following substitutions: - Numbers divisible by 3 and 5 are replaced with \\"FizzBuzz\\" - Numbers divisible by 3 (but not 5) are replaced with \\"Fizz\\" - Numbers divisible by 5 (but not 3) are replaced with \\"Buzz\\" - Other numbers remain unchanged >>> fizz_buzz(15) '1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz' >>> fizz_buzz(1) '1'","solution":"def fizz_buzz(n): Generates a sequence of numbers from 1 to n with the following substitutions: - Numbers divisible by 3 and 5 are replaced with \\"FizzBuzz\\" - Numbers divisible by 3 (but not 5) are replaced with \\"Fizz\\" - Numbers divisible by 5 (but not 3) are replaced with \\"Buzz\\" - Other numbers remain unchanged result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return \\" \\".join(result)"},{"question":"def number_of_dish_types(n: int, m: int, ingredients: List[int], teams: List[List[int]]) -> List[int]: For each team, determine the total number of different dish types they will prepare. >>> number_of_dish_types(5, 3, [2, 3, 1, 4, 5], [[3, 1, 2, 3], [2, 4, 5], [4, 1, 2, 4, 5]]) [3, 2, 4] >>> number_of_dish_types(4, 2, [1, 1, 1, 1], [[3, 1, 2, 3], [1, 4]]) [3, 1] >>> number_of_dish_types(3, 1, [10, 20, 30], [[2, 1, 3]]) [2] >>> number_of_dish_types(2, 2, [2, 2], [[1, 1], [1, 2]]) [1, 1] >>> number_of_dish_types(3, 2, [5, 7, 9], [[2, 1, 2], [1, 3]]) [2, 1] result = [] for team in teams: result.append(len(set(team))) return result def main(n: int, m: int, ingredients: List[int], teams_data: List[List[int]]) -> List[int]: Process the teams' data to determine the number of dish types for each team. teams = [team_data[1:] for team_data in teams_data] return number_of_dish_types(n, m, ingredients, teams)","solution":"def number_of_dish_types(n, m, ingredients, teams): result = [] for team in teams: result.append(len(set(team))) return result def main(n, m, ingredients, teams_data): teams = [team_data[1:] for team_data in teams_data] return number_of_dish_types(n, m, ingredients, teams)"},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. s1: str - source string s2: str - target string return: int - minimum number of operations required to transform s1 into s2 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"abcdef\\", \\"abcdef\\") 0 >>> min_operations(\\"abc\\", \\"abcd\\") 1 >>> min_operations(\\"abcdef\\", \\"abc\\") 3 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 from solution import min_operations def test_min_operations_example(): assert min_operations(\\"intention\\", \\"execution\\") == 5 def test_min_operations_same_strings(): assert min_operations(\\"abcdef\\", \\"abcdef\\") == 0 def test_min_operations_addition(): assert min_operations(\\"abc\\", \\"abcd\\") == 1 def test_min_operations_deletion(): assert min_operations(\\"abcdef\\", \\"abc\\") == 3 def test_min_operations_replacement(): assert min_operations(\\"kitten\\", \\"sitting\\") == 3 def test_min_operations_mixed_operations(): assert min_operations(\\"horse\\", \\"ros\\") == 3 assert min_operations(\\"abcdef\\", \\"azced\\") == 3 def test_min_operations_empty_strings(): assert min_operations(\\"\\", \\"\\") == 0 assert min_operations(\\"\\", \\"a\\") == 1 assert min_operations(\\"a\\", \\"\\") == 1 assert min_operations(\\"\\", \\"abcdef\\") == 6 assert min_operations(\\"abcdef\\", \\"\\") == 6 def test_min_operations_large_inputs(): assert min_operations(\\"a\\" * 1000, \\"b\\" * 1000) == 1000 assert min_operations(\\"abcd\\" * 500, \\"abcd\\" * 500) == 0","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. len1, len2 = len(s1), len(s2) # Create a 2D DP array, where dp[i][j] represents the minimum edit distance # to convert s1[0:i] to s2[0:j] dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Initialize first column and first row of the DP array for i in range(len1 + 1): dp[i][0] = i # If s2 is empty, we need i deletions for j in range(len2 + 1): dp[0][j] = j # If s1 is empty, we need j insertions # Fill the DP array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement return dp[len1][len2]"},{"question":"def longest_path_unique_letters(n: int, m: int, grid: List[str]) -> int: Given a rectangular grid of size n x m filled with lowercase letters, find the length of the longest path in the grid such that every cell in the path contains a unique letter. The path can move in four directions: up, down, left, and right. >>> longest_path_unique_letters(3, 4, [\\"abcf\\", \\"ghij\\", \\"klmn\\"]) 12 >>> longest_path_unique_letters(1, 1, [\\"a\\"]) 1 >>> longest_path_unique_letters(2, 2, [\\"aa\\", \\"aa\\"]) 1 >>> longest_path_unique_letters(1, 3, [\\"abc\\"]) 3 >>> longest_path_unique_letters(4, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) 16 # Your code here","solution":"def longest_path_unique_letters(n, m, grid): def dfs(x, y, visited): max_path_len = len(visited) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] not in visited: visited.add(grid[nx][ny]) max_path_len = max(max_path_len, dfs(nx, ny, visited)) visited.remove(grid[nx][ny]) return max_path_len max_length = 0 for i in range(n): for j in range(m): visited = set(grid[i][j]) max_length = max(max_length, dfs(i, j, visited)) return max_length"},{"question":"MOD = 1000000007 def unique_paths_with_obstacles(n: int, m: int, grid: List[List[int]]) -> int: Returns the number of unique paths from (0, 0) to (n-1, m-1) on the grid, considering blocked cells. The answer is taken modulo 1000000007. Example: >>> unique_paths_with_obstacles(3, 3, [[1, 0, 1], [1, 1, 1], [0, 1, 1]]) 2 >>> unique_paths_with_obstacles(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 6 >>> unique_paths_with_obstacles(3, 3, [[0, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> unique_paths_with_obstacles(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 0]]) 0 >>> unique_paths_with_obstacles(2, 2, [[1, 1], [1, 1]]) 2","solution":"MOD = 1000000007 def unique_paths_with_obstacles(n, m, grid): Returns the number of unique paths from (0, 0) to (n-1, m-1) on the grid, considering blocked cells. The answer is taken modulo 1000000007. if grid[0][0] == 0 or grid[n-1][m-1] == 0: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def minEncodedLength(s: str) -> int: Compute the length of the shortest possible encoding of the given string \`s\`. >>> minEncodedLength(\\"aabcaabc\\") len(\\"2[aabc]\\") >>> minEncodedLength(\\"abcabcabc\\") len(\\"3[abc]\\") >>> minEncodedLength(\\"abcdabcyz\\") len(\\"abcdabcyz\\") pass def test_min_encoded_length_examples(): assert minEncodedLength(\\"aabcaabc\\") == len(\\"2[aabc]\\") assert minEncodedLength(\\"abcabcabc\\") == len(\\"3[abc]\\") assert minEncodedLength(\\"abcdabcyz\\") == len(\\"abcdabcyz\\") def test_min_encoded_length_single_char(): assert minEncodedLength(\\"a\\") == len(\\"a\\") def test_min_encoded_length_no_repeat(): assert minEncodedLength(\\"abcdefg\\") == len(\\"abcdefg\\") def test_min_encoded_length_full_repeat(): assert minEncodedLength(\\"aaaaaa\\") == len(\\"6[a]\\") def test_min_encoded_length_partial_repeat(): assert minEncodedLength(\\"ababab\\") == len(\\"3[ab]\\") def test_min_encoded_length_mixed(): assert minEncodedLength(\\"aabbaabb\\") == len(\\"2[aabb]\\") def test_min_encoded_length_complex(): assert minEncodedLength(\\"abcabcabcde\\") == len(\\"3[abc]de\\")","solution":"def minEncodedLength(s: str) -> int: def encode_length(start, end): if end - start < 1: return 0 if end - start == 1: return 1 min_len = end - start # worst case: no encoding possible, original length sub = s[start:end] # Try every possible partition of sub into two for mid in range(start + 1, end): left_encoded = encode_length(start, mid) right_encoded = encode_length(mid, end) min_len = min(min_len, left_encoded + right_encoded) # Now try to find repeating patterns within the substring n = end - start for l in range(1, n): if n % l == 0: repeat_pattern = sub[:l] if repeat_pattern * (n // l) == sub: num_repeats = n // l pattern_length = encode_length(start, start + l) min_len = min(min_len, len(f'{num_repeats}[{repeat_pattern}]')) return min_len return encode_length(0, len(s))"},{"question":"from typing import List def distribute_candy(N: int, M: int, capacities: List[int]) -> List[int]: Distribute M pieces of candy among N people according to their capacities. >>> distribute_candy(3, 10, [5, 3, 8]) [5, 3, 2] >>> distribute_candy(2, 15, [8, 6]) [] pass def test_distribute_candy_basic(): assert distribute_candy(3, 10, [5, 3, 8]) == [5, 3, 2] or [5, 2, 3] assert distribute_candy(2, 15, [8, 6]) == [] def test_distribute_candy_single_person(): assert distribute_candy(1, 5, [5]) == [5] assert distribute_candy(1, 5, [3]) == [] def test_distribute_candy_equal_distribution(): assert distribute_candy(4, 8, [2, 2, 2, 2]) == [2, 2, 2, 2] def test_distribute_candy_not_possible(): assert distribute_candy(3, 20, [5, 5, 5]) == [] def test_distribute_candy_more_complex(): assert distribute_candy(3, 9, [5, 3, 7]) == [5, 3, 1] or [5, 1, 3] assert distribute_candy(5, 20, [5, 10, 3, 6, 4]) in [[5, 10, 3, 2, 0], [5, 10, 2, 3, 0]]","solution":"from typing import List def distribute_candy(N: int, M: int, capacities: List[int]) -> List[int]: # Check if the total capacity is less than M, which means distribution is impossible if sum(capacities) < M: return [] result = [0] * N for i in range(N): give = min(M, capacities[i]) result[i] = give M -= give return result"},{"question":"from typing import List def longest_increasing_subsequence(prices: List[int]) -> int: Returns the length of the longest increasing subsequence of stock prices. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([1, 3, 2, 3, 4, 8, 7]) 5 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([7, 3, 5, 3, 6, 7, 8]) 5 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3","solution":"from bisect import bisect_left from typing import List def longest_increasing_subsequence(prices: List[int]) -> int: Returns the length of the longest increasing subsequence of stock prices. if not prices: return 0 # The dynamic array to store the current longest increasing subsequence lis = [] for price in prices: pos = bisect_left(lis, price) if pos < len(lis): lis[pos] = price else: lis.append(price) return len(lis)"},{"question":"def max_robbery(n: int, money_in_houses: List[int]) -> int: Determine the maximum amount of money the thief can rob without triggering the alarm. >>> max_robbery(5, [2, 7, 9, 3, 1]) 12 >>> max_robbery(1, [10]) 10 >>> max_robbery(2, [10, 15]) 15 >>> max_robbery(4, [1, 2, 3, 1]) 4 >>> max_robbery(5, [10, 10, 10, 10, 10]) 30 >>> max_robbery(6, [10, 9, 8, 7, 6, 5]) 24 >>> max_robbery(6, [5, 6, 7, 8, 9, 10]) 24 >>> max_robbery(3, [1000, 2000, 3000]) 4000 >>> max_robbery(0, []) 0","solution":"def max_robbery(n, money_in_houses): if n == 0: return 0 if n == 1: return money_in_houses[0] # Initialize an array to store the maximum money that can be robbed up to each house dp = [0] * n dp[0] = money_in_houses[0] dp[1] = max(money_in_houses[0], money_in_houses[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money_in_houses[i]) return dp[-1] # Example usage: # n = 5 # money_in_houses = [2, 7, 9, 3, 1] # print(max_robbery(n, money_in_houses)) # Output: 12"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determines if a linked list has a cycle. Args: head (ListNode): The head of the linked list. Returns: bool: True if there is a cycle in the linked list, False otherwise. Examples: >>> node1 = ListNode(3) >>> node2 = ListNode(2) >>> node3 = ListNode(0) >>> node4 = ListNode(-4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 >>> hasCycle(node1) True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node2.next = node1 >>> hasCycle(node1) True >>> node1 = ListNode(1) >>> hasCycle(node1) False >>> hasCycle(None) False # Implementation Here","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Returns true if there is a cycle in the linked list, false otherwise. if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"from typing import List def birthday_cake_candles(candles: List[int]) -> int: Determines how many of the tallest candles can be blown out. :param candles: List of integers representing the height of candles :return: Integer representing the count of the tallest candles >>> birthday_cake_candles([4, 4, 1, 3]) 2 >>> birthday_cake_candles([3, 2, 1, 3]) 2 >>> birthday_cake_candles([2, 2, 2, 2, 2]) 5 >>> birthday_cake_candles([1]) 1 >>> birthday_cake_candles([1] * 99999 + [2]) 1 >>> birthday_cake_candles([]) 0 >>> birthday_cake_candles([1, 2, 3, 4, 5]) 1","solution":"from typing import List def birthday_cake_candles(candles: List[int]) -> int: Determines the number of tallest candles that can be blown out. :param candles: List of integers representing the height of candles :return: Integer representing the count of the tallest candles if not candles: return 0 tallest = max(candles) return candles.count(tallest)"},{"question":"def find_median(n: int, numbers: List[int]) -> Union[int, float]: Returns the median of the sorted list of numbers. >>> find_median(5, [3, 1, 4, 1, 5]) 3 >>> find_median(4, [1, 2, 3, 4]) 2.5","solution":"def find_median(n, numbers): Returns the median of the sorted list of numbers. :param n: int : number of elements in the list :param numbers: list : list of integers :return: float/int : median of sorted list numbers.sort() mid = n // 2 if n % 2 == 1: return numbers[mid] else: median = (numbers[mid - 1] + numbers[mid]) / 2 return round(median, 1) if median != int(median) else int(median)"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three numbers in the array. >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([0, 0, 2, 3, 4]) 24 >>> maximum_product_of_three([-1, -2, -3, -4]) -6 >>> maximum_product_of_three([-10, -10, 5, 2, 3, 7]) 700 >>> maximum_product_of_three([1000, -1000, 1000, 1000]) 1000000000","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three numbers in the array. # Sort the array nums.sort() # The maximum product can be either the product of the three largest numbers # or the product of the two smallest numbers (if they are negative) and the largest number return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])"},{"question":"def is_square(points): Determine if there exists a subarray of consecutive points that forms a square when connected in the given order. >>> is_square([(1, 1), (2, 1), (2, 2), (1, 2), (3, 3), (4, 4)]) \\"Yes\\" >>> is_square([(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) \\"No\\"","solution":"import math def is_square(points): def distance(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 def calculate_angle(p1, p2, p3): v1 = (p2[0] - p1[0], p2[1] - p1[1]) v2 = (p3[0] - p2[0], p3[1] - p2[1]) dot_product = v1[0] * v2[0] + v1[1] * v2[1] mag1 = math.sqrt(v1[0]**2 + v1[1]**2) mag2 = math.sqrt(v2[0]**2 + v2[1]**2) cos_theta = dot_product / (mag1 * mag2) return math.acos(cos_theta) n = len(points) for i in range(n - 3): p1, p2, p3, p4 = points[i], points[i + 1], points[i + 2], points[i + 3] d1 = distance(p1, p2) d2 = distance(p2, p3) d3 = distance(p3, p4) d4 = distance(p4, p1) angle1 = calculate_angle(p1, p2, p3) angle2 = calculate_angle(p2, p3, p4) angle3 = calculate_angle(p3, p4, p1) angle4 = calculate_angle(p4, p1, p2) if d1 == d2 == d3 == d4 and math.isclose(angle1, math.pi/2, abs_tol=1e-5) and math.isclose(angle2, math.pi/2, abs_tol=1e-5) and math.isclose(angle3, math.pi/2, abs_tol=1e-5) and math.isclose(angle4, math.pi/2, abs_tol=1e-5): return \\"Yes\\" return \\"No\\""},{"question":"def find_subarray_count(arr: List[int], k: int) -> int: Function to find the number of subarrays that sum up to a given value k. Parameters: arr (list): List of positive integers representing the array. k (int): The target sum. Returns: int: The number of subarrays that sum up to k. >>> find_subarray_count([1, 2, 3, 4, 5], 5) 2 >>> find_subarray_count([1, 1, 1, 1, 1], 3) 3 >>> find_subarray_count([3, 4, 7, 2, 1, 4, 3], 7) 4 >>> find_subarray_count([1, 2, 3], 7) 0 >>> find_subarray_count([5, 5, 5, 5], 10) 3","solution":"def find_subarray_count(arr, k): Function to find the number of subarrays that sum up to a given value k. Parameters: arr (list): List of positive integers representing the array. k (int): The target sum. Returns: int: The number of subarrays that sum up to k. from collections import defaultdict # Dictionary to store the cumulative sum frequencies prefix_sum_counts = defaultdict(int) # To count the subarrays that end at the current index and sum up to k current_sum = 0 count = 0 for num in arr: current_sum += num if current_sum == k: count += 1 if (current_sum - k) in prefix_sum_counts: count += prefix_sum_counts[current_sum - k] prefix_sum_counts[current_sum] += 1 return count"},{"question":"def min_removals_to_make_palindrome(s: str) -> int: Determine the minimum number of characters that need to be removed to make the string a palindrome. >>> min_removals_to_make_palindrome(\\"racecar\\") == 0 >>> min_removals_to_make_palindrome(\\"abc\\") == 2 >>> min_removals_to_make_palindrome(\\"abca\\") == 1 >>> min_removals_to_make_palindrome(\\"aebcbda\\") == 2 >>> min_removals_to_make_palindrome(\\"banana\\") == 1 >>> min_removals_to_make_palindrome(\\"abcdef\\") == 5 >>> min_removals_to_make_palindrome(\\"\\") == 0 >>> min_removals_to_make_palindrome(\\"abadac\\") == 3 >>> min_removals_to_make_palindrome(\\"google\\") == 2 >>> min_removals_to_make_palindrome(\\"palindrome\\") == 9","solution":"def min_removals_to_make_palindrome(s): Returns the minimum number of characters to be removed to make the string a palindrome. n = len(s) reverse_s = s[::-1] # Create a 2D list to store the length of longest common subsequence dp = [[0] * (n + 1) for _ in range(n + 1)] # Compute the length of longest common subsequence of s and its reverse for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == reverse_s[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest palindromic subsequence lps = dp[n][n] # Minimum number of removals = length of s - length of longest palindromic subsequence return n - lps"},{"question":"def process_numbers(numbers): Returns a tuple where the first element is the sum of all even numbers and the second element is the product of all odd numbers in the list. >>> process_numbers([4, 5, 2, 3, 9, 8]) (14, 135) >>> process_numbers([2, 4, 6, 8, 10]) (30, 0) >>> process_numbers([1, 3, 5, 7, 9]) (0, 945) >>> process_numbers([4]) (4, 0) >>> process_numbers([5]) (0, 5) >>> process_numbers([]) (0, 0) >>> process_numbers([0]) (0, 0) >>> process_numbers([4, -5, 2, -3, 9, -8]) (-2, 135)","solution":"def process_numbers(numbers): Returns a tuple where the first element is the sum of all even numbers and the second element is the product of all odd numbers in the list. sum_even = 0 product_odd = 1 odd_found = False for num in numbers: if num % 2 == 0: sum_even += num else: odd_found = True product_odd *= num if not odd_found: product_odd = 0 # Since no odd number present return (sum_even, product_odd)"},{"question":"def largest_non_symmetric_subset(n: int, points: List[Tuple[int, int]]) -> int: Returns the size of the largest subset of points such that no two points are symmetric with respect to the Y-axis. >>> largest_non_symmetric_subset(5, [(1, 2), (-1, 2), (2, 3), (-2, 3), (3, 1)]) 3 >>> largest_non_symmetric_subset(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> largest_non_symmetric_subset(4, [(1, 2), (-1, 2), (2, 2), (-2, 2)]) 2 >>> largest_non_symmetric_subset(6, [(1, 2), (-1, 2), (2, 3), (-2, 3), (5, 6), (6, 7)]) 4 >>> largest_non_symmetric_subset(4, [(10**9, 10**9), (-10**9, 10**9), (10**9, -10**9), (-10**9, -10**9)]) 2 >>> largest_non_symmetric_subset(1, [(0, 0)]) 1 >>> largest_non_symmetric_subset(5, [(1, 1)] * 5) 1","solution":"def largest_non_symmetric_subset(n, points): Returns the size of the largest subset of points such that no two points are symmetric with respect to the Y-axis. unique_points = set() for x, y in points: normalized_point = (min(x, -x), y) unique_points.add(normalized_point) return len(unique_points)"},{"question":"def min_operations_from_input(n: int, m: int, grid_values: List[int]) -> int: Determine the minimum number of operations required to reduce all values in the grid to zero. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid_values (List[int]): flattened 2D grid containing the values Returns: int: minimum number of operations required to make all values in the grid zero >>> min_operations_from_input(2, 3, [1, 2, 1, 0, 1, 1]) 2 >>> min_operations_from_input(1, 1, [5]) 5 >>> min_operations_from_input(3, 3, [3, 3, 3, 3, 3, 3, 3, 3, 3]) 3 >>> min_operations_from_input(2, 2, [0, 0, 0, 0]) 0 >>> min_operations_from_input(4, 4, [4, 1, 0, 2, 3, 5, 0, 0, 0, 0, 4, 0, 1, 6, 1, 2]) 6 grid = [list(map(int, grid_values[i * m : (i + 1) * m])) for i in range(n)] # Implement the function here to compute the minimum number of operations required","solution":"def min_operations(grid): n = len(grid) m = len(grid[0]) operations = 0 max_value = max(max(row) for row in grid) return max_value def min_operations_from_input(n, m, grid_values): grid = [list(map(int, grid_values[i * m : (i + 1) * m])) for i in range(n)] return min_operations(grid)"},{"question":"def can_make_equal(s: str, t: str) -> str: Determine whether string \`s\` can be made equal to string \`t\` using the described operation. Parameters: s (str): First string of length n t (str): Second string of length m Returns: str: \\"YES\\" if \`s\` can be rearranged to match \`t\`, \\"NO\\" otherwise Examples: >>> can_make_equal(\\"abcdef\\", \\"abcfde\\") 'YES' >>> can_make_equal(\\"abc\\", \\"bca\\") 'YES' >>> can_make_equal(\\"abcd\\", \\"abce\\") 'NO' from solution import can_make_equal def test_can_make_equal_example1(): assert can_make_equal(\\"abcdef\\", \\"abcfde\\") == \\"YES\\" def test_can_make_equal_example2(): assert can_make_equal(\\"abc\\", \\"bca\\") == \\"YES\\" def test_can_make_equal_example3(): assert can_make_equal(\\"abcd\\", \\"abce\\") == \\"NO\\" def test_can_make_equal_identical_strings(): assert can_make_equal(\\"test\\", \\"test\\") == \\"YES\\" def test_can_make_equal_empty_strings(): assert can_make_equal(\\"\\", \\"\\") == \\"YES\\" def test_can_make_equal_single_characters(): assert can_make_equal(\\"a\\", \\"a\\") == \\"YES\\" assert can_make_equal(\\"a\\", \\"b\\") == \\"NO\\" def test_can_make_equal_different_lengths(): assert can_make_equal(\\"abc\\", \\"abcd\\") == \\"NO\\" assert can_make_equal(\\"abcd\\", \\"abc\\") == \\"NO\\" def test_can_make_equal_with_repeated_characters(): assert can_make_equal(\\"aabbcc\\", \\"abcabc\\") == \\"YES\\" assert can_make_equal(\\"aabbcc\\", \\"abccba\\") == \\"YES\\" assert can_make_equal(\\"aabbcc\\", \\"aabbcd\\") == \\"NO\\"","solution":"def can_make_equal(s, t): Determine whether string s can be made equal to string t using the described operation. Parameters: s (str): First string t (str): Second string Returns: str: \\"YES\\" if s can be rearranged to match t, \\"NO\\" otherwise # We can make s equal to t if they both have the same characters in any order if sorted(s) == sorted(t): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List class ToDoList: def __init__(self): # Initialize the to-do list with necessary data structures pass def add(self, assignment_name: str, deadline: int): # Add a new assignment to the list pass def remove(self, assignment_name: str): # Remove an assignment from the list pass def next_deadline(self) -> str: # Return the assignment with the nearest deadline pass def count(self, due_days: int) -> int: # Return the number of assignments due in exactly due_days days pass def manage_assignments(operations: List[str]) -> List[str]: Manage the to-do list based on a series of operations Args: operations (List[str]): A list of operations to manage the to-do list Returns: List[str]: Results of each 'next_deadline' and 'count' operations to_do_list = ToDoList() results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"add\\": _, name, deadline = parts to_do_list.add(name, int(deadline)) elif command == \\"remove\\": _, name = parts to_do_list.remove(name) elif command == \\"next_deadline\\": results.append(to_do_list.next_deadline()) elif command == \\"count\\": _, due_days = parts results.append(str(to_do_list.count(int(due_days)))) return results def test_example_case(): operations = [ \\"add math 3\\", \\"add english 5\\", \\"next_deadline\\", \\"count 3\\", \\"add history 3\\", \\"add science 2\\", \\"next_deadline\\", \\"remove science\\", \\"next_deadline\\" ] expected = [ \\"math\\", \\"1\\", \\"science\\", \\"math\\" ] assert manage_assignments(operations) == expected def test_next_deadline_with_no_assignments(): operations = [ \\"next_deadline\\" ] expected = [ \\"none\\" ] assert manage_assignments(operations) == expected def test_count_with_no_assignments(): operations = [ \\"count 3\\" ] expected = [ \\"0\\" ] assert manage_assignments(operations) == expected def test_remove_non_existing_assignment(): operations = [ \\"add math 3\\", \\"remove science\\", \\"next_deadline\\" ] expected = [ \\"math\\" ] assert manage_assignments(operations) == expected def test_add_duplicate_assignment(): operations = [ \\"add math 3\\", \\"add math 5\\", \\"count 3\\", \\"count 5\\", \\"next_deadline\\" ] expected = [ \\"1\\", \\"0\\", \\"math\\" ] assert manage_assignments(operations) == expected","solution":"from collections import defaultdict import heapq class ToDoList: def __init__(self): self.assignments = {} self.deadline_heap = [] self.deadline_count = defaultdict(int) self.counter = 0 # to handle assignments with same deadline, we use a counter def add(self, assignment_name, deadline): if assignment_name in self.assignments: return # do not allow duplicate assignments self.assignments[assignment_name] = (deadline, self.counter) heapq.heappush(self.deadline_heap, (deadline, self.counter, assignment_name)) self.deadline_count[deadline] += 1 self.counter += 1 def remove(self, assignment_name): if assignment_name not in self.assignments: return deadline, _ = self.assignments.pop(assignment_name) self.deadline_count[deadline] -= 1 def next_deadline(self): while self.deadline_heap: deadline, count, assignment_name = heapq.heappop(self.deadline_heap) if assignment_name in self.assignments and self.assignments[assignment_name] == (deadline, count): heapq.heappush(self.deadline_heap, (deadline, count, assignment_name)) return assignment_name return \\"none\\" def count(self, due_days): return self.deadline_count[due_days] def manage_assignments(operations): to_do_list = ToDoList() results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"add\\": _, name, deadline = parts to_do_list.add(name, int(deadline)) elif command == \\"remove\\": _, name = parts to_do_list.remove(name) elif command == \\"next_deadline\\": results.append(to_do_list.next_deadline()) elif command == \\"count\\": _, due_days = parts results.append(str(to_do_list.count(int(due_days)))) return results"},{"question":"def most_common_sequence(events_str: str) -> str: Identify the most common sequence of two consecutive events that happens at exactly the same time over multiple days. >>> most_common_sequence( ... ... Eating 12:30 Playing 14:00 Studying 15:30 ... Playing 14:00 Eating 12:30 Reading 15:30 Playing 14:00 ... Eating 12:30 Playing 14:00 ... ... ) \\"Eating 12:30 -> Playing 14:00\\" >>> most_common_sequence( ... ... Event1 10:00 Event2 10:30 Event3 11:00 ... ... ) \\"Event1 10:00 -> Event2 10:30\\" >>> most_common_sequence( ... ... EventA 09:00 EventB 10:00 ... EventC 09:00 EventD 10:00 ... ... ) \\"EventA 09:00 -> EventB 10:00\\" >>> most_common_sequence( ... ... A 08:00 B 09:00 ... B 09:00 A 08:00 ... A 08:00 B 09:00 ... ... ) \\"A 08:00 -> B 09:00\\" >>> most_common_sequence( ... ... Event1 10:00 Event1 10:00 Event1 10:00 ... Event1 10:00 Event1 10:00 ... ... ) \\"Event1 10:00 -> Event1 10:00\\"","solution":"def most_common_sequence(events_str): from collections import defaultdict event_sequences = defaultdict(int) # Process each line separately for day in events_str.strip().split(\\"n\\"): events = day.strip().split() prev_event, prev_time = None, None for i in range(0, len(events), 2): event = events[i] time = events[i+1] if prev_event is not None: sequence = f\\"{prev_event} {prev_time} -> {event} {time}\\" event_sequences[sequence] += 1 prev_event, prev_time = event, time # Find the most common sequence most_common = None max_count = 0 for seq, count in event_sequences.items(): if count > max_count or (count == max_count and (most_common is None or seq < most_common)): most_common = seq max_count = count return most_common"},{"question":"from typing import List def can_be_beautiful_string(s: str) -> str: Determine if the string can be rearranged into a beautiful string by swapping arbitrary characters an unlimited number of times. >>> can_be_beautiful_string(\\"aabbcc\\") \\"YES\\" >>> can_be_beautiful_string(\\"aabccc\\") \\"NO\\" >>> can_be_beautiful_string(\\"abcabcabc\\") \\"YES\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each string can be rearranged into a beautiful string. >>> process_test_cases(3, [\\"aabbcc\\", \\"aabccc\\", \\"abcabcabc\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"a\\", \\"ab\\"]) [\\"YES\\", \\"YES\\"]","solution":"def can_be_beautiful_string(s): from collections import Counter char_counts = Counter(s) frequencies = list(char_counts.values()) first_count = frequencies[0] for count in frequencies: if count != first_count: return \\"NO\\" return \\"YES\\" def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(can_be_beautiful_string(s)) return results"},{"question":"def rob_houses(n: int, money: List[int]) -> int: Returns the maximum amount of money that can be robbed without robbing two adjacent houses. Parameters: n (int): Number of houses. money (list of int): Amount of money in each house. Returns: int: The maximum amount of money. >>> rob_houses(4, [1, 2, 3, 1]) 4 >>> rob_houses(5, [2, 7, 9, 3, 1]) 12","solution":"def rob_houses(n, money): Returns the maximum amount of money that can be robbed without robbing two adjacent houses. Parameters: n (int): Number of houses. money (list of int): Amount of money in each house. Returns: int: The maximum amount of money. if n == 0: return 0 if n == 1: return money[0] dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"def is_diagonal_dominant(matrix: List[List[int]]) -> str: Determines if the given matrix is diagonal-dominant. >>> is_diagonal_dominant([ [3, -1, 1], [1, 5, 1], [2, -1, 6] ]) \\"YES\\" >>> is_diagonal_dominant([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) \\"NO\\"","solution":"def is_diagonal_dominant(matrix): Determines if the given matrix is diagonal-dominant. Parameters: matrix (list of list of int): the matrix to check Returns: str: \\"YES\\" if the matrix is diagonal-dominant, otherwise \\"NO\\" n = len(matrix) for i in range(n): diag_elem = abs(matrix[i][i]) sum_other_elems = sum(abs(matrix[i][j]) for j in range(n) if i != j) if diag_elem < sum_other_elems: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def min_transfer_times(n: int, G: List[List[int]], s: int) -> List[int]: Calculate the minimum time required to transfer data from server s to all other servers using the network paths. Args: n: int - number of servers G: List[List[int]] - adjacency matrix where G[i][j] is the time to transfer data from server i to server j s: int - the source server Returns: List[int] - Minimum transfer time to every server from server s, with -1 representing an unreachable server Examples: >>> min_transfer_times(4, [[0, 3, -1, -1], [3, 0, 1, -1], [-1, 1, 0, 2], [-1, -1, 2, 0]], 0) [0, 3, 4, 6] >>> min_transfer_times(3, [[0, 1, -1], [1, 0, -1], [-1, -1, 0]], 0) [0, 1, -1]","solution":"from heapq import heappop, heappush import sys def dijkstra(n, G, s): dist = [float('inf')] * n dist[s] = 0 pq = [(0, s)] # priority queue of (cost, node) while pq: cur_dist, u = heappop(pq) if cur_dist > dist[u]: continue for v in range(n): if G[u][v] == -1: continue new_dist = cur_dist + G[u][v] if new_dist < dist[v]: dist[v] = new_dist heappush(pq, (new_dist, v)) return dist def min_transfer_times(n, G, s): dist = dijkstra(n, G, s) return [d if d != float('inf') else -1 for d in dist]"},{"question":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None def treeToCDLL(root: Node) -> Node: Convert a binary tree into a circular doubly linked list (CDLL) in-place. The left and right pointers in the tree nodes are used as previous and next pointers in the CDLL, respectively. >>> root = Node(4) >>> root.left = Node(2) >>> root.right = Node(5) >>> root.left.left = Node(1) >>> root.left.right = Node(3) >>> head = treeToCDLL(root) >>> collect_cdll_values(head) [1, 2, 3, 4, 5] >>> root = Node(1) >>> head = treeToCDLL(root) >>> collect_cdll_values(head) [1] >>> root = Node(3) >>> root.left = Node(2) >>> root.left.left = Node(1) >>> head = treeToCDLL(root) >>> collect_cdll_values(head) [1, 2, 3] >>> root = Node(1) >>> root.right = Node(2) >>> root.right.right = Node(3) >>> head = treeToCDLL(root) >>> collect_cdll_values(head) [1, 2, 3] >>> root = Node(5) >>> root.left = Node(3) >>> root.right = Node(8) >>> root.left.left = Node(2) >>> root.left.right = Node(4) >>> root.right.left = Node(7) >>> root.right.right = Node(9) >>> head = treeToCDLL(root) >>> collect_cdll_values(head) [2, 3, 4, 5, 7, 8, 9] >>> head = treeToCDLL(None) >>> collect_cdll_values(head) []","solution":"class Node: def __init__(self, data): self.data = data self.left = None # Previous pointer in CDLL self.right = None # Next pointer in CDLL def treeToCDLL(root: Node) -> Node: if not root: return None # Helper function to concatenate two doubly linked lists def concatenate(left_list: Node, right_list: Node) -> Node: if not left_list: return right_list if not right_list: return left_list # Find the last nodes of both lists left_last = left_list.left right_last = right_list.left # Connect the last node of left list with the first node of right list left_last.right = right_list right_list.left = left_last # Connect the last node of right list with the first node of left list right_last.right = left_list left_list.left = right_last return left_list # Recursive function to convert the binary tree to a doubly linked list def treeToCDLLHelper(node: Node) -> Node: if not node: return None # Recursively convert left and right subtrees left_list = treeToCDLLHelper(node.left) right_list = treeToCDLLHelper(node.right) # Make the single node circular node.left = node node.right = node # Concatenate the lists together combined_list = concatenate(left_list, node) combined_list = concatenate(combined_list, right_list) return combined_list head = treeToCDLLHelper(root) return head"},{"question":"from typing import List, Tuple, Union def possible_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> Union[str, Tuple[str, List[int]]]: Determine if it's possible to color the graph using two colors in such a way that no two adjacent nodes have the same color. If it's possible, return \\"YES\\" and one valid coloring as a list of n integers where each integer is 1 or 2. If it's not possible, return \\"NO\\". >>> possible_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) (\\"YES\\", [1, 2, 1, 2]) >>> possible_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\" >>> possible_bipartite(4, 2, [(1, 2), (3, 4)]) (\\"YES\\", [1, 2, 1, 2]) >>> possible_bipartite(1, 0, []) (\\"YES\\", [1]) >>> possible_bipartite(5, 0, []) (\\"YES\\", [1, 1, 1, 1, 1])","solution":"def possible_bipartite(n, m, edges): from collections import deque graph = [[] for _ in range(n)] for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) color = [-1] * n def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(n): if color[i] == -1: if not bfs(i): return \\"NO\\" valid_coloring = [c + 1 for c in color] return \\"YES\\", valid_coloring"},{"question":"from typing import List def find_triplet_sum(cards: List[int], s: int) -> str: Determines if there is a triplet in \`cards\` that sums up to \`s\`. Args: cards (list of int): List of card values. s (int): Targeted sum. Returns: str: \\"YES\\" if there exists three distinct values that sum up to \`s\`, otherwise \\"NO\\". >>> find_triplet_sum([1, 2, 3, 4, 5, 6, 7, 8], 15) \\"YES\\" >>> find_triplet_sum([5, 6, 7, 8, 9], 30) \\"NO\\" def test_find_triplet_sum_example_1(): assert find_triplet_sum([1, 2, 3, 4, 5, 6, 7, 8], 15) == \\"YES\\" def test_find_triplet_sum_example_2(): assert find_triplet_sum([5, 6, 7, 8, 9], 30) == \\"NO\\" def test_find_triplet_sum_large_numbers(): assert find_triplet_sum([10, 15, 20, 25, 30, 35, 40, 45], 100) == \\"YES\\" def test_find_triplet_sum_no_possible_triplet(): assert find_triplet_sum([1, 2, 3, 9, 10], 50) == \\"NO\\" def test_find_triplet_sum_with_negative_numbers(): assert find_triplet_sum([-10, -5, 0, 5, 10], 0) == \\"YES\\" def test_find_triplet_sum_with_all_negative_numbers(): assert find_triplet_sum([-10, -5, -3, -7, -2], -20) == \\"YES\\" def test_find_triplet_sum_single_card(): assert find_triplet_sum([1], 3) == \\"NO\\" def test_find_triplet_sum_two_cards(): assert find_triplet_sum([1, 2], 6) == \\"NO\\"","solution":"def find_triplet_sum(cards, s): Determines if there is a triplet in \`cards\` that sums up to \`s\`. Args: cards (list of int): List of card values. s (int): Targeted sum. Returns: str: \\"YES\\" if there exists three distinct values that sum up to \`s\`, otherwise \\"NO\\". cards.sort() n = len(cards) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: triplet_sum = cards[i] + cards[left] + cards[right] if triplet_sum == s: return \\"YES\\" elif triplet_sum < s: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def minimized_prime_array(t: int, test_cases: List[int]) -> List[str]: Given a list of test cases, returns the desired integer arrays where each element is the prime number 2, minimizing the product of elements and being lexicographically smallest. >>> minimized_prime_array(1, [3]) ['2 2 2'] >>> minimized_prime_array(1, [4]) ['2 2 2 2'] >>> minimized_prime_array(2, [3, 4]) ['2 2 2', '2 2 2 2'] >>> minimized_prime_array(1, [100000]) [\\"2 \\" * 99999 + '2'] >>> minimized_prime_array(3, [1, 2, 5]) [\\"2\\", \\"2 2\\", \\"2 2 2 2 2\\"]","solution":"def minimized_prime_array(t, test_cases): Given a list of test cases, returns the desired integer arrays where each element is the prime number 2, minimizing the product of elements and being lexicographically smallest. return [' '.join(['2'] * n) for n in test_cases]"},{"question":"def min_cost_to_connect_islands(n: int, m: int, t: int, ferries: List[Tuple[int, int, int]], express: List[Tuple[int, int]]) -> int: Determine the minimum cost required to connect all the islands using the provided ferry routes and express ferry routes. Args: n : int : number of islands m : int : number of initial ferry routes t : int : number of express ferry routes ferries : List[Tuple[int, int, int]] : list of tuples where each tuple contains 3 integers a, b, and c meaning there is a ferry route between islands a and b with the cost c express : List[Tuple[int, int]] : list of tuples where each tuple contains two integers x and y which means there is an express ferry between islands x and y Returns: int : the minimum cost required to connect all the islands Examples: >>> min_cost_to_connect_islands(4, 2, 1, [(1, 2, 4), (3, 4, 2)], [(2, 3)]) 6 >>> min_cost_to_connect_islands(4, 0, 3, [], [(1, 2), (2, 3), (3, 4)]) 0 >>> min_cost_to_connect_islands(4, 0, 0, [], []) 0 >>> min_cost_to_connect_islands(4, 3, 0, [(1, 2, 1), (2, 3, 1), (3, 4, 1)], []) 3 >>> min_cost_to_connect_islands(5, 4, 1, [(1, 2, 3), (1, 3, 5), (4, 5, 6), (1, 4, 9)], [(3, 5)]) 14","solution":"import heapq def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def min_cost_to_connect_islands(n, m, t, ferries, express): parent = [i for i in range(n)] rank = [0] * n edges = [] for a, b, c in ferries: edges.append((c, a - 1, b - 1)) # Convert to zero-based index # Add express routes with zero cost for x, y in express: edges.append((0, x - 1, y - 1)) # Convert to zero-based index # Sort edges by weight (cost) edges.sort() mst_cost = 0 for cost, u, v in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += cost return mst_cost"},{"question":"def bellman_ford(n: int, m: int, s: int, edges: List[Tuple[int, int, int]]) -> List[Union[int, str]]: Finds shortest path distances from a source node to all other nodes in a directed graph. Parameters: n (int): Number of nodes m (int): Number of edges s (int): Source node (1-indexed) edges (list of tuples): List of edges (u, v, w) Returns: list: Shortest distance from source to each node (0-indexed), 'infinity' if not reachable Examples: >>> bellman_ford(5, 7, 1, [(1, 2, -1), (1, 3, 4), (2, 3, 3), (2, 4, 2), (2, 5, 2), (4, 2, 1), (5, 4, -3)]) [0, -1, 2, -2, 1] >>> bellman_ford(4, 0, 1, []) [0, 'infinity', 'infinity', 'infinity'] import sys from typing import List, Tuple, Union def test_example_case(): n = 5 m = 7 s = 1 edges = [ (1, 2, -1), (1, 3, 4), (2, 3, 3), (2, 4, 2), (2, 5, 2), (4, 2, 1), (5, 4, -3) ] result = bellman_ford(n, m, s, edges) assert result == [0, -1, 2, -2, 1] def test_no_edges(): n = 4 m = 0 s = 1 edges = [] result = bellman_ford(n, m, s, edges) assert result == [0, 'infinity', 'infinity', 'infinity'] def test_negative_weight_edge(): n = 3 m = 3 s = 1 edges = [ (1, 2, 4), (1, 3, 5), (2, 3, -6) ] result = bellman_ford(n, m, s, edges) assert result == [0, 4, -2] def test_disconnected_graph(): n = 6 m = 3 s = 1 edges = [ (1, 2, 2), (1, 3, 4), (4, 5, 3) ] result = bellman_ford(n, m, s, edges) assert result == [0, 2, 4, 'infinity', 'infinity', 'infinity'] def test_single_node(): n = 1 m = 0 s = 1 edges = [] result = bellman_ford(n, m, s, edges) assert result == [0] def test_negative_cycle_detection(): n = 3 m = 3 s = 1 edges = [ (1, 2, 1), (2, 3, 1), (3, 1, -3) ] try: bellman_ford(n, m, s, edges) except ValueError as e: assert str(e) == \\"Graph contains a negative weight cycle\\" else: assert False, \\"Expected ValueError for negative weight cycle not raised\\"","solution":"def bellman_ford(n, m, s, edges): Finds shortest path distances from a source node to all other nodes in a directed graph. Parameters: n (int): Number of nodes m (int): Number of edges s (int): Source node (1-indexed) edges (list of tuples): List of edges (u, v, w) Returns: list: Shortest distance from source to each node (0-indexed), 'infinity' if not reachable # Initialize distance list dist = [float('inf')] * n dist[s-1] = 0 # Relax all edges (n-1) times for _ in range(n-1): for u, v, w in edges: if dist[u-1] != float('inf') and dist[u-1] + w < dist[v-1]: dist[v-1] = dist[u-1] + w # Check for negative weight cycles for u, v, w in edges: if dist[u-1] != float('inf') and dist[u-1] + w < dist[v-1]: raise ValueError(\\"Graph contains a negative weight cycle\\") # Replace 'inf' with string 'infinity' as requested dist = ['infinity' if x == float('inf') else x for x in dist] return dist"},{"question":"def find_decorated_roads(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> Union[List[Tuple[int, int]], int]: Determine whether it is possible to choose k roads such that the removal of any subset of these roads does not disconnect the town. :param n: Number of nodes (houses) :param m: Number of edges (roads) :param k: Number of roads to decorate :param edges: List of tuples, where each tuple (u, v) represents a bidirectional road :return: List of k tuples representing the roads to decorate, or -1 if impossible pass def process_input(input_data: str) -> Tuple[int, int, int, List[Tuple[int, int]]]: Process the input string and return the parameters for the problem. :param input_data: String containing the input data :return: Tuple containing the number of nodes, number of edges, number of roads to decorate, and a list of edges data = input_data.strip().split('n') n, m, k = map(int, data[0].strip().split()) edges = [tuple(map(int, line.strip().split())) for line in data[1:]] return n, m, k, edges # Unit tests def test_basic_example(): input_data = \\"4 5 2n1 2n1 3n2 3n2 4n3 4\\" n, m, k, edges = process_input(input_data) result = find_decorated_roads(n, m, k, edges) assert len(result) == 2 assert all(edge in edges for edge in result) def test_not_possible(): input_data = \\"4 5 5n1 2n1 3n2 3n2 4n3 4\\" n, m, k, edges = process_input(input_data) result = find_decorated_roads(n, m, k, edges) assert result == -1 def test_large_k_possible(): input_data = \\"4 5 3n1 2n1 3n2 3n2 4n3 4\\" n, m, k, edges = process_input(input_data) result = find_decorated_roads(n, m, k, edges) assert len(result) == 3 assert all(edge in edges for edge in result) def test_edge_case_minimum_values(): input_data = \\"1 1 1n1 1\\" n, m, k, edges = process_input(input_data) result = find_decorated_roads(n, m, k, edges) assert result == -1 def test_single_road(): input_data = \\"2 1 1n1 2\\" n, m, k, edges = process_input(input_data) result = find_decorated_roads(n, m, k, edges) assert len(result) == 1 assert result == [(1, 2)]","solution":"def find_decorated_roads(n, m, k, edges): Determine whether it is possible to choose k roads such that the removal of any subset of these roads does not disconnect the town. :param n: Number of nodes (houses) :param m: Number of edges (roads) :param k: Number of roads to decorate :param edges: List of tuples, where each tuple (u, v) represents a bidirectional road :return: List of k tuples representing the roads to decorate, or -1 if impossible if k > n - 1: return -1 # Use the first (n-1) edges if possible since they guarantee connectivity decorated_roads = edges[:k] return decorated_roads # Helper function to process input def process_input(input_data): data = input_data.strip().split('n') n, m, k = map(int, data[0].strip().split()) edges = [tuple(map(int, line.strip().split())) for line in data[1:]] return n, m, k, edges # Example usage: # n, m, k, edges = process_input(\\"4 5 2n1 2n1 3n2 3n2 4n3 4\\") # result = find_decorated_roads(n, m, k, edges) # print(result)"},{"question":"def isMatch(s: str, p: str) -> bool: Returns True if the pattern p matches the entire string s, otherwise False. >>> isMatch(\\"aa\\", \\"a\\") False >>> isMatch(\\"aa\\", \\"a*\\") True >>> isMatch(\\"ab\\", \\".*\\") True >>> isMatch(\\"\\", \\"\\") True >>> isMatch(\\"abc\\", \\"\\") False >>> isMatch(\\"\\", \\"a*\\") True >>> isMatch(\\"mississippi\\", \\"mis*is*p*.\\") False >>> isMatch(\\"mississippi\\", \\"mis*is*ip*.\\") True >>> isMatch(\\"aa\\", \\"aa\\") True >>> isMatch(\\"ab\\", \\".*c\\") False","solution":"def isMatch(s, p): Returns True if the pattern p matches the entire string s, otherwise False. # Dynamic Programming approach implementation dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # empty pattern matches empty string # Handle patterns like a*, a*b*, a*b*c* etc., which can match with empty string for j in range(2, len(p) + 1): dp[0][j] = dp[0][j - 2] if p[j - 1] == '*' else False for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 2] or ((s[i - 1] == p[j - 2] or p[j - 2] == '.') and dp[i - 1][j]) elif p[j - 1] == '.' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len(s)][len(p)]"},{"question":"def divide_and_reverse(lst: List[int], k: int) -> List[int]: Divides the list of integers into sublists of length k and reverses each sublist. If the list cannot be evenly divided, the remaining elements should also be reversed. >>> divide_and_reverse([1, 2, 3, 4, 5, 6, 7, 8], 3) [3, 2, 1, 6, 5, 4, 8, 7] >>> divide_and_reverse([9, 7, 8, 5, 3, 6, 1, 2], 4) [5, 8, 7, 9, 2, 1, 6, 3] >>> divide_and_reverse([1], 1) [1] >>> divide_and_reverse([1, 2, 3, 4, 5, 6], 2) [2, 1, 4, 3, 6, 5] >>> divide_and_reverse([1, 2, 3, 4, 5], 2) [2, 1, 4, 3, 5] >>> divide_and_reverse([1, 2, 3, 4, 5], 5) [5, 4, 3, 2, 1] >>> divide_and_reverse([1, 2, 3, 4], 1) [1, 2, 3, 4]","solution":"def divide_and_reverse(lst, k): Divides the list into sublists of length k and reverses each sublist. n = len(lst) result = [] for i in range(0, n, k): sublist = lst[i:i+k] result.extend(sublist[::-1]) return result"},{"question":"def find_first_occurrence(t: int, test_cases: List[str]) -> List[int]: Find the position of the first occurrence of the character c in the string s (0-indexed). If the character does not exist in the string, return -1. Args: t (int): Number of test cases. test_cases (List[str]): A list of strings where each string contains s followed by a space and then c. Returns: List[int]: A list of positions of the first occurrence of c in each s, or -1 if not found. Examples: >>> find_first_occurrence(3, [\\"hello l\\", \\"abcdefg x\\", \\"python p\\"]) [2, -1, 0] >>> find_first_occurrence(2, [\\"abcde z\\", \\"test t\\"]) [-1, 0] >>> find_first_occurrence(2, [\\"abracadabra a\\", \\"mississippi s\\"]) [0, 2] >>> t = 2 >>> long_string = \\"a\\" * 100000 + \\"b\\" >>> find_first_occurrence(2, [f\\"{long_string} b\\", f\\"{long_string} c\\"]) [100000, -1]","solution":"def find_first_occurrence(t, test_cases): results = [] for case in test_cases: s, c = case.split() position = s.find(c) results.append(position) return results # Example usage: # t = 2 # test_cases = [\\"hello l\\", \\"abcdefg x\\"] # print(find_first_occurrence(t, test_cases)) # Output: [2, -1]"},{"question":"from typing import List def search_matrix(matrix: List[List[int]], target: int) -> bool: Returns true if a given target integer is found in the matrix, and false otherwise. >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) True >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) False # Your code here","solution":"from typing import List def search_matrix(matrix: List[List[int]], target: int) -> bool: Returns true if target is found in the matrix. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 # Move left else: row += 1 # Move down return False"},{"question":"def findLongestPath(n: int, edges: List[Tuple[int, int]]) -> int: Write a function \`findLongestPath\` that takes an undirected tree (a connected acyclic graph) with \`n\` nodes and \`n-1\` edges and returns the length of the longest path in the tree. The longest path in a tree is called the diameter of the tree. >>> findLongestPath(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 >>> findLongestPath(4, [(1, 2), (1, 3), (2, 4)]) == 3 >>> findLongestPath(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 2 >>> findLongestPath(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 4 >>> findLongestPath(2, [(1, 2)]) == 1","solution":"def findLongestPath(n, edges): from collections import deque, defaultdict # Create an adjacency list representation of the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def bfs(start): visited = [-1] * (n + 1) queue = deque([(start, 0)]) visited[start] = 0 farthest_node = start while queue: current, distance = queue.popleft() for neighbor in tree[current]: if visited[neighbor] == -1: visited[neighbor] = distance + 1 queue.append((neighbor, distance + 1)) if visited[neighbor] > visited[farthest_node]: farthest_node = neighbor return farthest_node, visited[farthest_node] # First BFS to find one endpoint of the longest path node1, _ = bfs(1) # Second BFS from the found endpoint to determine the longest path _, longest_path_length = bfs(node1) return longest_path_length"}]`),j={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},D={class:"card-container"},z={key:0,class:"empty-state"},O=["disabled"],Y={key:0},C={key:1};function F(i,e,u,c,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",z,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",C,"Loading...")):(s(),n("span",Y,"See more"))],8,O)):l("",!0)])}const I=d(j,[["render",F],["__scopeId","data-v-e18eb14b"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/26.md","filePath":"grok/26.md"}'),P={name:"grok/26.md"},G=Object.assign(P,{setup(i){return(e,u)=>(s(),n("div",null,[w(I)]))}});export{M as __pageData,G as default};
