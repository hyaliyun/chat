import{_ as p,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function N(r,e,l,c,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=p(k,[["render",N],["__scopeId","data-v-e55678d8"]]),S=JSON.parse('[{"question":"Diffie-Hellman Key Exchange Enhancements **Context**: The Diffie-Hellman key exchange algorithm enables two parties to securely exchange cryptographic keys over a public channel. Your task is to enhance the current implementation by adding input validation, error handling, and key length flexibility. # Task 1. Implement the `validate_inputs` function to ensure that the inputs provided to the Diffie-Hellman key exchange are correct. 2. Implement the `generate_large_prime` function to generate a large prime number of specified bit length. 3. Modify the `diffie_hellman_key_exchange` function to use the newly validated inputs and generated primes. # Specifications Function 1: `validate_inputs(a, p)` - **Inputs**: - `a` (int): The proposed primitive root. - `p` (int): The proposed prime modulus. - **Outputs**: - Returns nothing. - Raises an appropriate error if `a` or `p` are invalid. Function 2: `generate_large_prime(bit_length)` - **Inputs**: - `bit_length` (int): The desired bit length of the prime number. - **Outputs**: - An integer that is a prime number of approximately `bit_length` bits. Updated Function 3: `diffie_hellman_key_exchange(a, p, option=None, bit_length=None)` - **Inputs**: - `a` (int): The proposed primitive root. - `p` (int or None): The proposed prime modulus (if `None`, generate one). - `option` (int): An optional parameter for debugging purposes. - `bit_length` (int or None): The desired bit length for the prime number (used if `p` is `None`). - **Outputs**: - Prints the shared key calculated by both parties. - Returns a boolean indicating if the key exchange was successful. # Constraints - Ensure the `a` is a primitive root of `p` if provided. - Generate a prime `p` of at least 256 bits if `p` is not supplied. # Example ```python try: diffie_hellman_key_exchange(2, 23) except ValueError as e: print(e) try: diffie_hellman_key_exchange(5, None, bit_length=256) except ValueError as e: print(e) ``` # Implementation Notes - Use existing helper functions such as `prime_check`, `find_primitive_root`, and `euler_totient` for validation. - Relate the complexity analysis to practical performance constraints for secure and efficient key exchanges.","solution":"import random from sympy import isprime, primerange def validate_inputs(a, p): Validate the inputs `a` and `p` for the Diffie-Hellman key exchange. if not (isinstance(a, int) and a > 0): raise ValueError(\\"Primitive root \'a\' must be a positive integer.\\") if not (isinstance(p, int) and p > 2 and isprime(p)): raise ValueError(\\"Prime modulus \'p\' must be a prime number greater than 2.\\") def generate_large_prime(bit_length): Generate a large prime number of the specified bit length. if not isinstance(bit_length, int) or bit_length < 2: raise ValueError(\\"Bit length must be an integer greater than 1.\\") min_val = 2**(bit_length - 1) max_val = 2**bit_length - 1 while True: candidate = random.randint(min_val, max_val) if isprime(candidate): return candidate def diffie_hellman_key_exchange(a, p=None, option=None, bit_length=None): Perform the Diffie-Hellman key exchange. if p is None: if bit_length is None: raise ValueError(\\"Bit length must be specified if prime modulus \'p\' is not provided.\\") p = generate_large_prime(bit_length) validate_inputs(a, p) # Simulate both parties generating their private keys private_a = random.randint(1, p - 2) private_b = random.randint(1, p - 2) # Calculate public keys public_A = pow(a, private_a, p) public_B = pow(a, private_b, p) # Calculate shared keys shared_key_a = pow(public_B, private_a, p) shared_key_b = pow(public_A, private_b, p) if shared_key_a == shared_key_b: return True # Successful key exchange else: return False # Failed key exchange"},{"question":"**Scenario**: You have been hired to work on an ancient computer system that uses a naive sorting method to order transactions. Your task is to implement a basic exchange-sort algorithm to sort transaction amounts. Despite its simplicity, the system requires you to sort the transaction amounts using the exchange sort for compatibility reasons. Ensure that your implementation handles different edge cases effectively. **Requirements**: 1. Function Name: `exchange_sort` 2. Input: A list `arr` of integers representing transaction amounts. 3. Output: The list sorted in ascending order. 4. Constraints: * The list may contain any number of integers (including an empty list). * The integers can be positive, negative, or zero. 5. Performance is not the primary concern, but the function should be correct and handle edge cases. **Function Signature**: ```python def exchange_sort(arr: list) -> list: pass ``` **Example Usage**: ```python print(exchange_sort([5, 3, 8, 4, 2])) # Output: [2, 3, 4, 5, 8] print(exchange_sort([-1, -5, 3, 2, 0])) # Output: [-5, -1, 0, 2, 3] print(exchange_sort([])) # Output: [] ``` Complete the function `exchange_sort` to satisfy the above constraints and handle all specified edge cases correctly.","solution":"def exchange_sort(arr): Sorts an array of integers using the exchange sort algorithm. :param arr: list of integers :return: sorted list of integers in ascending order n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: # Swap elements arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"- Linear Search Variations **Scenario**: As a software engineer, you need to search for elements within a dataset efficiently. While linear search is a straightforward method, its performance can be variable depending on the dataset’s structure. Objective You are required to enhance and modify the basic linear search algorithm to meet the following requirements: 1. **Modified Linear Search**: Implement a function that can efficiently handle cases where the array is: - Sorted. - Has multiple repeated elements. 2. **Function to Implement**: - `def optimized_linear_search(array, query, sorted=False):` - **Input**: - `array`: List of integers. - `query`: Integer representing the element to search for. - `sorted`: Boolean flag indicating whether the array is sorted. - **Output**: - Return the index of the query element if found. - Return the first occurrence if multiple identical elements exist. - Return -1 if the element is not present. Constraints & Requirements * Your implementation should be effective for both sorted and unsorted arrays. * Time complexity should remain O(n) for unsorted but try to achieve a more efficient search if the array is sorted. * Handle all edge cases, such as an empty array and arrays with repeated elements. * You cannot use any built-in search functions (like `index()`). Performance Requirements * Aim for O(log n) complexity if the array is sorted, where n is the length of the array. * Ensure your code is efficient and scalable to handle large datasets efficiently.","solution":"def optimized_linear_search(array, query, sorted=False): Performs an optimized linear search to find the index of `query` in `array`. If `sorted` is True, it attempts to use a more efficient search for sorted arrays. For multiple identical elements, the function returns the first occurrence. Args: - array (list of int): The list of integers to search through. - query (int): The integer to search for. - sorted (bool): Whether the array is sorted or not. Returns: - int: Index of the `query` element if found, otherwise -1. if sorted: # For a sorted array, we can stop early if we find an element greater # than the query since the rest of the array will also be greater. for index, element in enumerate(array): if element == query: return index elif element > query: break else: # For an unsorted array, we have to check every element. for index, element in enumerate(array): if element == query: return index return -1"},{"question":"**Title**: Find Target Range in a Sorted Array **Objective**: Write a Python function to find the starting and ending positions of a given target value in a sorted array. **Scenario**: You are a software developer for a search engine company. You are assigned to develop a function that can determine the range of indices in which a particular search term appears in a sorted list of database indices. This functionality will allow the search engine to quickly filter and organize results. **Function Signature**: ```python def search_range(nums: List[int], target: int) -> List[int]: Find the starting and ending position of the target in a sorted array. ``` **Input Format**: * A list of integers `nums` sorted in ascending order. * An integer `target`, the value whose range of occurrences needs to be found. **Output Format**: * A list of two integers representing the starting and ending positions of `target` in `nums`. If `target` is not found, return `[-1, -1]`. **Example**: ```python Input: nums = [5,7,7,8,8,8,10], target = 8 Output: [3, 5] Input: nums = [5,7,7,8,8,8,10], target = 11 Output: [-1, -1] ``` **Constraints**: * The function should have a time complexity of (O(log n)). * The function should handle edge cases, such as empty arrays, targets not present, and arrays with all elements equal to the target. * Do not use any linear search except for finding boundaries, if necessary. **Performance Requirements**: * Ensure minimal space usage, ideally (O(1)) auxiliary space. **Tips**: * Consider performing two separate binary searches—one to find the first occurrence and the other to find the last occurrence. * Verify edge conditions and return appropriate defaults when the target is not found. **Note**: Write your implementation based on the above constraints and expected behavior. Your solution should correctly and efficiently determine the range of positions for the target.","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_left(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_idx = find_left(nums, target) right_idx = find_right(nums, target) # If the target is not within the range of the array or if the positions don\'t # bracket the target correctly, return [-1, -1] if left_idx <= right_idx and left_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target: return [left_idx, right_idx] else: return [-1, -1]"},{"question":"# Context You are a professional burglar planning to rob houses in a neighborhood. Each house has a certain amount of money hidden inside, but there is a catch: robbing two adjacent houses will trigger an alarm, automatically alerting the police. You need to find a strategy to rob these houses such that you maximize your haul without setting off the alarm. # Problem Statement Write a function `max_loot` to determine the maximum amount of money you can rob without triggering the alarm. # Function Signature ```python def max_loot(houses: List[int]) -> int: pass ``` # Input * `houses`: A list of non-negative integers representing the amount of money hidden in each house on the street (`1 <= len(houses) <= 10^4`, `0 <= houses[i] <= 10^4`). # Output * Returns an integer representing the maximum amount of money you can rob without robbing two adjacent houses. # Example ```python assert max_loot([2, 3, 2]) == 4 # Rob houses with money 2 and 2. assert max_loot([1, 2, 3, 1]) == 4 # Rob houses with money 1 and 3. assert max_loot([4, 1, 2, 7, 5, 3, 1]) == 14 # Rob houses with money 4, 7, and 3. assert max_loot([]) == 0 # No houses to rob. assert max_loot([5]) == 5 # Only one house to rob. ``` # Constraints * You must ensure that no two adjacent houses are robbed. * The algorithm should run in O(n) time and use O(1) space.","solution":"from typing import List def max_loot(houses: List[int]) -> int: if not houses: return 0 n = len(houses) if n == 1: return houses[0] prev2 = 0 prev1 = houses[0] for i in range(1, n): current = max(prev1, prev2 + houses[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"Title: Cocktail Shaker Sort Implementation Context You have been tasked with sorting an array efficiently using a less commonly used but intriguing sorting method. This method, known as Cocktail Shaker Sort, is a bi-directional variant of Bubble Sort. This algorithm is particularly effective for lists that are nearly sorted as it can sort in both forward and backward directions in each pass. Problem Statement Implement the `cocktail_shaker_sort` function which sorts an array of integers using the Cocktail Shaker Sort algorithm. Your implementation should follow the bidirectional sorting mechanism. Function Signature ```python def cocktail_shaker_sort(arr: list) -> list: ``` Input - An array `arr` of integers (0 <= len(arr) <= 1000). The integers can be positive, negative, or zero. Output - The function should return a new list that contains all the elements from `arr`, sorted in non-decreasing order. Constraints - The algorithm must operate in-place with O(1) additional space complexity. - The algorithm should detect nearly sorted lists and perform early termination to improve efficiency. Example ```python assert cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([-2, -3, -1, 0, 2, 1]) == [-3, -2, -1, 0, 1, 2] assert cocktail_shaker_sort([1]) == [1] ``` Requirements - Focus on using the in-place Cocktail Shaker Sort approach. - Include edge-case handling for optimally detecting if the list is already sorted. - Ensure your solution passes the provided example tests. Good luck!","solution":"def cocktail_shaker_sort(arr: list) -> list: Sorts an array using the Cocktail Shaker Sort algorithm. Args: arr (list): A list of integers to be sorted. Returns: list: The sorted list in non-decreasing order. if len(arr) <= 1: return arr start = 0 end = len(arr) - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Backward pass for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Programming Assessment Question # Context: You have been hired by a text processing company to ensure that their input strings are correctly formatted according to specific patterns. Given a pattern and an input string, you are to write a function that determines whether the input string conforms to the given pattern. # Problem Statement: Write a function `does_pattern_match(pattern, input_str)` that takes in: - a `pattern` (string of lowercase letters) and - an `input_str` (string of words separated by single space) The function should return `True` if the input string follows the pattern, and `False` otherwise. # Constraints: - `pattern` contains only lowercase letters (a-z). - `input_str` contains lowercase words separated by a single space. - Both `pattern` and `input_str` are non-empty. # Function Signature: ```python def does_pattern_match(pattern: str, input_str: str) -> bool: pass ``` # Example Inputs and Outputs: 1. `does_pattern_match(\\"abba\\", \\"dog cat cat dog\\")` should return `True` 2. `does_pattern_match(\\"abba\\", \\"dog cat cat fish\\")` should return `False` 3. `does_pattern_match(\\"aaaa\\", \\"dog cat cat dog\\")` should return `False` 4. `does_pattern_match(\\"abba\\", \\"dog dog dog dog\\")` should return `False` 5. `does_pattern_match(\\"ab\\", \\"dog dog\\")` should return `False` # Edge Cases: - Different lengths: `does_pattern_match(\\"a\\", \\"dog cat\\")` should return `False` - Multiple words, single letter: `does_pattern_match(\\"a\\", \\"dog\\")` should return `True` - Case where same word maps to different pattern characters should return `False`. # Performance Requirements: - The solution should operate within O(n) time complexity where n is the length of the input string.","solution":"def does_pattern_match(pattern, input_str): Checks if the input_str follows the given pattern. words = input_str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: char_to_word[char] = word if word not in word_to_char: word_to_char[word] = char if char_to_word[char] != word or word_to_char[word] != char: return False return True"},{"question":"Problem Statement You are working as a software engineer at a company that processes large volumes of numeric data. One of the common tasks is to determine the number of digits in various integers efficiently. Implement a function named `num_digits` that calculates the number of digits in a given integer `n`. Function Signature ```python def num_digits(n: int) -> int: ``` Parameters - `n` (int): The input integer for which you need to determine the number of digits. Returns - `int`: The number of digits in the integer `n`. Constraints 1. The input integer `n` can be any integer including zero and negative numbers. 2. The function should run in O(1) time complexity. Example ```python assert num_digits(12345) == 5 assert num_digits(0) == 1 assert num_digits(-789) == 3 assert num_digits(1000000) == 7 assert num_digits(-9999999) == 7 ``` # Explanation 1. For `num_digits(12345)`, the number 12345 has 5 digits. 2. For `num_digits(0)`, the number 0 is considered to have 1 digit. 3. For `num_digits(-789)`, the number -789 has 3 digits because the sign is not counted. 4. For `num_digits(1000000)`, the number 1000000 has 7 digits. 5. For `num_digits(-9999999)`, the number -9999999 has 7 digits for the same reason as above. Ensure your implementation is robust and handles all edge cases properly.","solution":"def num_digits(n: int) -> int: Given an integer n, returns the number of digits in the integer. The function handles negative numbers by ignoring the \'-\' sign. # Take absolute value to ignore the sign, convert to string and count the characters return len(str(abs(n)))"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure: * **Name**: Deletion in a Binary Search Tree (BST) * **Type**: Data Structure / Tree Algorithms * **Main Purpose**: This algorithm is used to delete a node from a Binary Search Tree (BST) while maintaining its properties. # Complexity: * **Time Complexity**: O(h), where h is the height of the tree. * **Space Complexity**: O(h) due to the recursion stack. # Principles: 1. **Search**: First, locate the node to be deleted. 2. **Delete**: Once found, there are three cases to handle: * Node with no children (leaf node): Simply remove the node. * Node with one child: Replace the node with its only child. * Node with two children: Find the in-order predecessor (or successor), replace the node\'s value with it, and then delete that predecessor. # Characteristics & Applications: * **Properties**: It preserves the key properties of BST where left subtree values are less than the node and right subtree values are greater. * **Common Use Cases**: * Used in databases and file systems for quick data retrieval. * Essential in balanced trees (like AVL and Red-Black trees) for dynamic sets of ordered elements. * **Strengths/Limitations**: * Strength: Effective for quick search, insertion, and deletion operations. * Limitation: Performance degrades if the tree becomes unbalanced (approaches O(n) complexity). # Implementation Challenges: * **Edge Cases**: Handling nodes with zero, one, or two children correctly; managing pointers to maintain tree structure. * **Performance Bottlenecks**: If the tree is unbalanced, the height could be O(n) leading to slower operations. * **Error Scenarios**: Incorrectly adjusting pointers could corrupt the tree structure. * **Optimization Points**: Balancing the tree can lead to more efficient operations, using algorithms like AVL or Red-Black trees could help. <|Analysis End|> <|Question Begin|> # Deletion in a Binary Search Tree (BST) You are given a binary search tree (BST) with integers and a target key. Your task is to write a function `delete_node(root, key)` to delete the node with the provided key from the BST while maintaining its properties. # Function Signature: ```python def delete_node(root: TreeNode, key: int) -> TreeNode: pass ``` # Instructions: 1. **Input**: * `root`: The root node of a BST (The node class is already defined). * `key`: An integer representing the value to be deleted from the BST. 2. **Output**: * Return the root node reference of the BST after the deletion. 3. **Constraints**: * The number of nodes in the BST is between `1` and `10^4`. * The integer values of nodes are unique. # Example: ```python # Example input root = [5,3,6,2,4,null,7] key = 3 # Example output # After deleting node with key=3, one valid output BST could be: # root = [5,4,6,2,null,null,7] # Tree representation: # 5 # / # 4 6 # / #2 7 ``` # Notes: - The function should handle edge cases like deleting a node with no children, one child, or two children. - Consider scenarios where the tree might become unbalanced. - You may not assume the tree is balanced (i.e., it can be a degenerate tree). Implement the function paying careful attention to maintaining the BST properties.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def delete_node(root: TreeNode, key: int) -> TreeNode: if not root: return root if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left min_larger_node = find_min(root.right) root.val = min_larger_node.val root.right = delete_node(root.right, root.val) return root def find_min(node: TreeNode) -> TreeNode: while node.left: node = node.left return node"},{"question":"You are given two implementations of the binary exponentiation algorithm – one iterative and one recursive. Implement a function `modular_exponentiation` that calculates (a^n mod , mod) using the provided power functions and compare the outputs for correctness. The function should take three parameters: two integers (a) and (n), and an optional integer (mod). The function should return a tuple containing results from both iterative and recursive implementations and check if they match. # Input - `a` (int): the base number (1 ≤ a ≤ 10^9) - `n` (int): the exponent (0 ≤ n ≤ 10^9) - `mod` (int, optional): the modulo value (1 ≤ mod ≤ 10^9) # Output - A tuple of two integers: ( (result_{iterative}, result_{recursive}) ) # Constraints - Ensure the algorithm is efficient in terms of time and space. - Handle very large inputs within given constraints. # Function Signature ```python def modular_exponentiation(a: int, n: int, mod: int = None) -> tuple: pass ``` # Example ```python # Example 1 a = 2 n = 10 mod = 1000 print(modular_exponentiation(a, n, mod)) # Output: (24, 24) # Example 2 a = 3 n = 0 print(modular_exponentiation(a, n)) # Output: (1, 1) ``` # Notes - Ensure that the results from both implementations are the same. - Consider edge cases such as (n = 0) and large values of (a) and (n).","solution":"def iterative_power(a, n, mod=None): result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: # If n is odd, multiply the current base to the result result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result def recursive_power(a, n, mod=None): if n == 0: return 1 half = recursive_power(a, n // 2, mod) half = half if mod is None else half % mod half = half * half if mod is None else (half * half) % mod if n % 2 == 1: return half * a if mod is None else (half * a) % mod else: return half def modular_exponentiation(a: int, n: int, mod: int = None) -> tuple: iter_result = iterative_power(a, n, mod) recur_result = recursive_power(a, n, mod) return (iter_result, recur_result)"},{"question":"You are given a binary tree and asked to implement the core functionalities for the binary tree traversals, and depth calculations. Specifically, you will be required to: 1. Implement the function `min_depth_iterative` that calculates the minimum depth of the tree using an iterative approach. 2. Implement the function `pre_order_traversal` that prints the values of the nodes in the tree using pre-order traversal. # Input You will be given a binary tree represented by its root node `TreeNode`. # Output 1. `min_depth_iterative`: Return an integer representing the minimum depth of the binary tree. 2. `pre_order_traversal`: Print the values of each node in the tree using pre-order traversal (root, left, right). # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The values of the nodes are integers in the range [-10^5, 10^5]. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def create_sample_tree(): # Creating a binary tree as shown below: # 10 # / # 12 15 # / / # 25 30 36 # # 100 tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) return tree def min_depth_iterative(root): # Implement this function pass def pre_order_traversal(root): # Implement this function pass if __name__ == \'__main__\': tree = create_sample_tree() print(\\"Minimum Depth:\\", min_depth_iterative(tree)) # Expected output: 3 pre_order_traversal(tree) # Expected output: # 10 # 12 # 25 # 100 # 30 # 15 # 36 ``` # Notes 1. The `min_depth_iterative` function should return the minimum depth of the tree using an iterative approach. 2. The `pre_order_traversal` function should print the nodes in pre-order traversal.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth_iterative(root): Calculates the minimum depth of a binary tree using an iterative approach. if not root: return 0 queue = deque([(root, 1)]) # (node, current_depth) while queue: node, depth = queue.popleft() # If we reach a leaf node, we can return its depth if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def pre_order_traversal(root): Prints the values of each node in the tree in pre-order traversal (root, left, right). if root: print(root.val) pre_order_traversal(root.left) pre_order_traversal(root.right)"},{"question":"# Coding Challenge: Fenwick Tree Range Sum and Update Problem Statement You are given an array `arr` of integers. Your task is to implement a Fenwick Tree (Binary Indexed Tree) to perform the following operations efficiently: 1. Compute the prefix sum of elements up to a given index. 2. Update the value of a specified element in the array. You need to implement the following functions: 1. `get_sum(i):` This function should return the sum of the elements in `arr` from the start to index `i`. 2. `update_value(i, val):` This function should update the value of `arr[i]` to `val`. 3. `construct_bit_tree(arr):` This function should construct the Binary Indexed Tree from the given array `arr`. Input * `arr` - A list of integers (length n), which can be modified. * Multiple queries in the form: - `get_sum(i)` : Compute the sum from start to index `i`. - `update_value(i, val)` : Update the element at index `i` to `val`. Output * The return value of `get_sum(i)` should be a single integer which is the sum from the start of the array to the i-th element. * `update_value(i, val)` will not return anything. Constraints * 1 <= n <= 10^5 * -10^9 <= arr[i], val <= 10^9 * 0 <= i < n Example ```python # Create an array and the Fenwick Tree arr = [1, 2, 3, 4, 5] fenwick_tree = FenwickTree(arr) # Construct the Binary Indexed Tree bit_tree = fenwick_tree.construct_bit_tree(arr) # Perform some sum queries sum_1 = fenwick_tree.get_sum(bit_tree, 2) # Outputs 6 (1+2+3) # Update the array value at index 1 to 10 fenwick_tree.update_value(bit_tree, 1, 10) # Perform more sum queries sum_2 = fenwick_tree.get_sum(bit_tree, 2) # Outputs 14 (1+10+3) ``` Notes * The solution should efficiently handle multiple updates and sum queries. * Provide detailed comments explaining how each function works. * You are not allowed to use any built-in function that directly performs these operations but can use helper methods internally.","solution":"class FenwickTree: def __init__(self, arr): self.n = len(arr) self.fenwick_tree = [0] * (self.n + 1) self.arr = arr[:] # Make a copy to support the update operation self.construct_bit_tree(arr) def construct_bit_tree(self, arr): for i in range(self.n): self._update_bit(i, arr[i]) def _update_bit(self, i, delta): i += 1 # Fenwick Tree is 1-based index while i <= self.n: self.fenwick_tree[i] += delta i += i & -i def get_sum(self, i): i += 1 # Fenwick Tree is 1-based index result = 0 while i > 0: result += self.fenwick_tree[i] i -= i & -i return result def update_value(self, i, val): # Calculate the delta value delta = val - self.arr[i] self.arr[i] = val self._update_bit(i, delta)"},{"question":"# Question Proposal **Context**: You are tasked with designing a computer network. The cost to connect different computers varies, and you need to ensure that the entire network is connected at the minimum possible cost. To achieve this, you will implement Prim\'s algorithm to find the minimum spanning tree of the graph representing the network. **Problem**: Implement a function `prims_minimum_spanning(graph)` in Python that takes a graph represented as a dictionary where the keys are nodes and the values are lists of tuples representing the edges and their respective weights. The function should return the total weight of the Minimum Spanning Tree. **Function Signature**: ```python def prims_minimum_spanning(graph: dict) -> int: pass ``` **Input Format**: A dictionary `graph` where: - Each key is a node (integer or character), - Each value is a list of tuples, where each tuple contains two elements: - The first element is an integer representing the weight of the edge, - The second element is the adjacent node connected by the edge. **Output Format**: An integer representing the total weight of the Minimum Spanning Tree. **Example**: ```python graph = { \'a\': [(3, \'b\'), (8, \'c\')], \'b\': [(3, \'a\'), (5, \'d\')], \'c\': [(8, \'a\'), (2, \'d\'), (4, \'e\')], \'d\': [(5, \'b\'), (2, \'c\'), (6, \'e\')], \'e\': [(4, \'c\'), (6, \'d\')] } assert prims_minimum_spanning(graph) == 14 # MST total weight: 3 + 5 + 2 + 4 = 14 ``` **Constraints**: 1. The graph is connected. 2. Nodes can be represented as either integers or characters. 3. All edge weights are positive integers. # Guidelines: - Ensure to handle graphs with various types (integer nodes or character nodes). - Think about the efficiency of your implementation, especially with larger graphs. - Handle potential edge cases such as nodes with multiple identical minimum edges.","solution":"import heapq def prims_minimum_spanning(graph: dict) -> int: Returns the total weight of the Minimum Spanning Tree using Prim\'s Algorithm. if not graph: return 0 start_node = next(iter(graph)) min_heap = [(0, start_node)] total_weight = 0 visited = set() while min_heap: weight, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_weight += weight for edge_weight, neighbor in graph[node]: if neighbor not in visited: heapq.heappush(min_heap, (edge_weight, neighbor)) # Verify all nodes are visited to confirm that the graph is connected if len(visited) != len(graph): raise ValueError(\\"The graph is not connected, and a Minimum Spanning Tree is not possible.\\") return total_weight"},{"question":"Implement a Doubly Linked List Context: You are tasked with implementing a Doubly Linked List class to manage a dynamic sequence of values. This list should support operations to insert and delete nodes, as well as traverse the list in both forward and backward direction. Your implementation should be robust enough to handle edge cases such as empty lists, singleton lists, and insertions/deletions at various positions. Task: Implement a class `DoublyLinkedList` with the following methods: - **append(value)**: Insert a new node with the given value at the end of the list. - **prepend(value)**: Insert a new node with the given value at the beginning of the list. - **delete(value)**: Remove the first occurrence of the node containing the given value from the list. - **display_forward()**: Return a list of values representing the sequence of nodes from head to tail. - **display_backward()**: Return a list of values representing the sequence of nodes from tail to head. Class Definition: ```python class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): # Implement this method pass def prepend(self, value): # Implement this method pass def delete(self, value): # Implement this method pass def display_forward(self): # Implement this method: Return a list of values from head to tail pass def display_backward(self): # Implement this method: Return a list of values from tail to head pass ``` Example Use: ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.prepend(0) dll.delete(1) print(dll.display_forward()) # Output: [0, 2] print(dll.display_backward()) # Output: [2, 0] ``` Constraints and Notes: - Assume the values to be appended, prepended, or deleted are always integers. - Ensure that your implementation efficiently handles edge cases and performs within reasonable time limits for the given operations. - Focus on correctness and clarity in handling list updates to avoid corrupting the list structure.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def display_forward(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values def display_backward(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values"},{"question":"You are tasked with extending the functionality of the `BinaryHeap` class. In particular, you need to implement a method to merge two binary heaps into a single min-heap. This is useful in scenarios where we need to combine priority queues or other applications that need merged heaps. # Function to Implement Implement the following method in the `BinaryHeap` class: ```python def merge(self, other): Merges the current heap with another heap. Parameters: - other (BinaryHeap): The other heap to merge with this heap. This function should ensure that the resulting heap maintains the min-heap property. The merged heap should be stored in `self.heap`. ``` # Input and Output - **Input**: * `other`: An instance of `BinaryHeap` which needs to be merged with the current heap instance. - **Output**: * The `self.heap` array should contain the elements of both heaps merged into a single min-heap. The method returns nothing (`None`). # Constraints - Both heaps are min-heaps and have integer elements. - Duplicate values might exist in the heaps. - The total number of elements after the merge should not exceed 10^5. # Performance Requirements - The merge operation should complete in O(M log (N + M)) time, where N and M are the sizes of the two heaps. # Example 1. **Merge Example**: ```python # Assuming the following initial heaps heap1 = BinaryHeap() heap1.insert(10) heap1.insert(5) heap1.insert(14) heap2 = BinaryHeap() heap2.insert(3) heap2.insert(8) heap2.insert(17) # After merge heap1.merge(heap2) # The resulting heap1 should maintain the min-heap property # The exact order depends on underlying binary heap properties but could look like: # heap1.heap = [0, 3, 5, 10, 8, 14, 17] # with the first index often unused ``` Implement and test your `merge` method to ensure it works correctly for various test cases, including edge cases provided above.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.current_size = 0 def insert(self, k): self.heap.append(k) self.current_size += 1 self.perc_up(self.current_size) def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def perc_down(self, i): while (i * 2) <= self.current_size: min_child = self.min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def min_child(self, i): if (i * 2 + 1) > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def del_min(self): retval = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return retval def build_heap(self, alist): i = len(alist) // 2 self.current_size = len(alist) self.heap = [0] + alist[:] while i > 0: self.perc_down(i) i -= 1 def merge(self, other): Merges the current heap with another heap. Parameters: - other (BinaryHeap): The other heap to merge with this heap. This function should ensure that the resulting heap maintains the min-heap property. The merged heap should be stored in `self.heap`. # Merge the two heaps combined_heap = self.heap[1:] + other.heap[1:] # Build a new heap with the combined list self.build_heap(combined_heap)"},{"question":"# Scenario You are developing a new feature for a financial application that suggests combinations of savings plans to meet a specific savings goal. This feature requires determining all possible ways to sum up to a target amount using a set of predefined savings options, where each option can be chosen multiple times. # Task Write a function `combination_sum` that identifies all unique combinations of numbers from a given list that sum up to a given target number. The numbers can be used multiple times in each combination, and the solution should not contain duplicate combinations. # Function Signature ```python def combination_sum(candidates: List[int], target: int) -> List[List[int]]: pass ``` # Input * `candidates` (List[int]): A list of distinct positive integers representing the candidate savings plans. * `target` (int): A positive integer representing the target savings goal. # Output * Returns a list of lists, where each list is a unique combination of numbers from `candidates` that sum up to `target`. # Constraints * All numbers, including the target, are positive integers. * The list `candidates` does not contain duplicates. * The solution set must not contain duplicate combinations. # Performance Requirements * The algorithm should be efficient enough to handle typical use cases but does not need to be optimized for extremely large inputs, given the exponential time complexity inherent in the problem. # Example ```python # Example 1 candidates = [2, 3, 6, 7] target = 7 # possible combinations are: [7], [2, 2, 3] expected_output = [[7], [2, 2, 3]] # Example 2 candidates = [2, 3, 5] target = 8 # possible combinations are: [2, 2, 2, 2], [2, 3, 3], [3, 5] expected_output = [[2, 2, 2, 2], [2, 3, 3], [3, 5]] assert combination_sum(candidates, target) == expected_output ```","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Finds all unique combinations in candidates where the numbers sum up to target. The same number can be chosen from candidates an unlimited number of times. result = [] def backtrack(remain, comb, start): if remain == 0: result.append(list(comb)) return elif remain < 0: return for i in range(start, len(candidates)): comb.append(candidates[i]) backtrack(remain - candidates[i], comb, i) comb.pop() candidates.sort() backtrack(target, [], 0) return result"},{"question":"# Problem: Efficient Factorial Computation with Modulo Implement a function `efficient_factorial` that calculates the factorial of a non-negative integer n efficiently with consideration of large inputs which may exceed the usual integer limits. Additionally, the function should support taking a modulo value to avoid overflow. Input - `n` (int): A non-negative integer, 0 ≤ n ≤ 10^6. - `mod` (int, optional): A positive integer for modulo operation. If not provided, default is `None`. Output - Returns the factorial of `n` (n!) modulo `mod` if `mod` is provided, otherwise simply returns n!. Constraints - Input `n` will be a non-negative integer. - If `mod` is provided, it will be a positive integer. Examples 1. `efficient_factorial(5)` should return `120`. 2. `efficient_factorial(5, 3)` should return `0` because `120 % 3 == 0`. 3. `efficient_factorial(0)` should return `1`. 4. `efficient_factorial(10**6, 10**9+7)` should be computed efficiently without exceeding time limits. Notes - Implementing the solution iteratively is preferable for large inputs due to stack limitation of recursion. - Consider time efficiency to handle potential large values of `n` up to 10^6. ```python def efficient_factorial(n, mod=None): if not (isinstance(n, int) and n >= 0): raise ValueError(\\"\'n\' must be a non-negative integer.\\") if mod is not None and not (isinstance(mod, int) and mod > 0): raise ValueError(\\"\'mod\' must be a positive integer\\") result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result # Testing the function with given examples print(efficient_factorial(5)) # should return 120 print(efficient_factorial(5, 3)) # should return 0 print(efficient_factorial(0)) # should return 1 print(efficient_factorial(10**6, 10**9+7)) # should handle large input efficiently ```","solution":"def efficient_factorial(n, mod=None): Computes the factorial of a non-negative integer n. Optionally, returns the result modulo `mod` if `mod` is provided. Parameters: n (int): A non-negative integer. mod (int, optional): A positive integer for modulo operation. Defaults to None. Returns: int: The factorial of n or factorial of n modulo `mod`, if provided. if not (isinstance(n, int) and n >= 0): raise ValueError(\\"\'n\' must be a non-negative integer.\\") if mod is not None and not (isinstance(mod, int) and mod > 0): raise ValueError(\\"\'mod\' must be a positive integer\\") result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result"},{"question":"# Missing Number in Sequence Problem Statement Given a list of unique integers `nums` in the range [0, n], find the missing number from the sequence. The difference between consecutive integers cannot be more than 1. If the sequence is already complete, return the next integer in the sequence. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Input - `nums`: A list of unique integers within the range [0, n]. Output - Return the single missing number from the list. If no number is missing, return the next integer in the sequence. Constraints - The list `nums` will have unique integers. - All integers are within the range [0, n]. - The length of `nums` is n and 0 ≤ n ≤ 10^5. Examples 1. Input: `nums = [4, 1, 3, 0, 6, 5, 2]` Output: `7` 2. Input: `nums = [0, 1, 2, 3, 4, 5]` Output: `6` 3. Input: `nums = [0]` Output: `1` 4. Input: `nums = [1]` Output: `0` Context Imagine you are given a list of attendance sign-ins recorded as unique IDs within a certain range. Your task is to identify any attendee who forgot to sign in. If everyone signed in, you should determine the next ID for the next participant to sign in. Make sure your implementation is optimal in terms of time and space complexity.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the single missing number in a list of unique integers in the range [0, n]. If no number is missing, returns the next integer in the sequence. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"**Task**: Implement a k-largest element finder using the max heap implementation of Heap Sort. **Objective**: Use Heap Sort with a max heap to find and return the k-largest elements of a given list. **Input/Output Formats**: * **Input**: * An array of integers `arr`. * An integer `k`. * **Output**: * A sorted list of the k-largest elements in `arr` in descending order. **Constraints**: * 1 ≤ k ≤ len(arr) * All elements in arr are integers. **Performance Requirements**: * The implementation should sort the provided array within the constraints of Heap Sort (O(n log n)). **Example**: * **Input**: arr = [3, 2, 1, 5, 6, 4], k = 2 * **Output**: [6, 5] * **Input**: arr = [1, 2, 3, 4, 5, 6], k = 1 * **Output**: [6] **Scenario**: You are tasked with writing a utility that can find the k-largest elements in a dataset of numbers. This is particularly useful in scenarios where you need only the top performers in a competitive situation, such as finding the top k scores in an exam result list.","solution":"def heapify(arr, n, i): Helper function to maintain the max heap property. largest = i # Initialize largest as root left = 2 * i + 1 # left child right = 2 * i + 2 # right child # If left child is larger than root if left < n and arr[left] > arr[largest]: largest = left # If right child is larger than root if right < n and arr[right] > arr[largest]: largest = right # If largest is not root if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Recursively heapify the affected sub-tree heapify(arr, n, largest) def heap_sort(arr): Main function to perform heap sort. n = len(arr) # Build a maxheap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) def k_largest_elements(arr, k): Function to find the k-largest elements using heap sort. n = len(arr) heap_sort(arr) return arr[-k:][::-1]"},{"question":"Context You are tasked with developing a function to filter out salary data. Your company collects salary data across various departments and needs to analyze salaries within a specific range. Objective Write a function `filter_salaries(salaries, min_salary=None, max_salary=None)` that filters the input list of salaries to include only those values that are within the given minimum and maximum range. Input 1. `salaries`: A list of integers representing employee salaries. 2. `min_salary` (optional): An integer specifying the minimum salary limit (inclusive). Default is None, meaning no minimum limit. 3. `max_salary` (optional): An integer specifying the maximum salary limit (inclusive). Default is None, meaning no maximum limit. Output The function should return a list of integers containing only the salaries that fall within the specified range. Constraints * If `salaries` is an empty list, the function should return an empty list. * If both `min_salary` and `max_salary` are `None`, the function should return the original array. * You can assume the values in salary list will be non-negative integers. Examples ```python filter_salaries([50000, 60000, 70000, 80000, 90000], 60000, 80000) # Output: [60000, 70000, 80000] filter_salaries([30000, 50000, 70000, 90000], 45000, None) # Output: [50000, 70000, 90000] filter_salaries([60000, 70000, 80000], None, 75000) # Output: [60000, 70000] filter_salaries([], 30000, 60000) # Output: [] filter_salaries([100000], None, None) # Output: [100000] ``` Performance Requirements * The solution must execute in linear time, O(n), where n is the number of salaries. * Space complexity should be O(n) considering the new list creation, but responses addressing improvements in space utilization are encouraged. Implementation Implement the function `filter_salaries` as described above.","solution":"def filter_salaries(salaries, min_salary=None, max_salary=None): Filters the input list of salaries to include only those values that are within the given minimum and maximum range. Args: salaries (list of int): List of employee salaries. min_salary (int, optional): Minimum salary limit (inclusive), default is None. max_salary (int, optional): Maximum salary limit (inclusive), default is None. Returns: list of int: A list containing only the salaries that fall within the specified range. if min_salary is None and max_salary is None: return salaries filtered_salaries = [] for salary in salaries: if (min_salary is None or salary >= min_salary) and (max_salary is None or salary <= max_salary): filtered_salaries.append(salary) return filtered_salaries"},{"question":"# Context You have been hired by a digital library to help maintain their catalog of scanned books. Each book consists of several numbered pages, and sometimes, pages get misplaced during the scanning process. Your task is to write a function that identifies the ranges of missing page numbers given a range of page numbers. # Task Write a function `find_missing_pages` that takes in a list of integers `pages`, representing the scanned page numbers, as well as two integers `lo` and `hi`, representing the first and last possible page number, respectively. The function should return a list of tuples, where each tuple represents a range of missing page numbers between `lo` and `hi`. # Input Parameters * `pages`: A list of integers (sorted in ascending order) representing page numbers. * `lo`: An integer representing the first possible page number. * `hi`: An integer representing the last possible page number. # Output * A list of tuples, where each tuple ( (start, end) ) represents a range of missing page numbers (inclusive). # Constraints * 0 <= len(pages) <= 10^6 * `lo` <= `hi` * Each element in `pages` is unique and within the range `[lo, hi]` # Example ```python def find_missing_pages(pages, lo, hi): # Your code here # Example print(find_missing_pages([3, 5], 1, 10)) # Output: [(1, 2), (4, 4), (6, 10)] print(find_missing_pages([], 1, 5)) # Output: [(1, 5)] print(find_missing_pages([2, 3, 4], 1, 5))# Output: [(1, 1), (5, 5)] ``` # Explanation In the first example, the missing ranges are from 1 to 2, then 4, and from 6 to 10. In the second example, since no pages are provided, the entire range from 1 to 5 is missing. In the third example, pages 1 and 5 are missing, while 2, 3, and 4 are present.","solution":"def find_missing_pages(pages, lo, hi): Find the missing page ranges within the given boundaries. :param pages: List[int], sorted list of scanned page numbers. :param lo: int, the first possible page number. :param hi: int, the last possible page number. :return: List[Tuple[int, int]], list of tuples representing missing page ranges. missing_ranges = [] # If no pages are scanned, the whole range from lo to hi is missing if not pages: return [(lo, hi)] # Check the missing range before the first page if pages[0] > lo: missing_ranges.append((lo, pages[0] - 1)) # Check missing ranges between scanned pages for i in range(1, len(pages)): if pages[i] > pages[i - 1] + 1: missing_ranges.append((pages[i - 1] + 1, pages[i] - 1)) # Check the missing range after the last page if pages[-1] < hi: missing_ranges.append((pages[-1] + 1, hi)) return missing_ranges"},{"question":"# Question You are given a problem where you need to extend the functionality of the given Roman numeral to integer conversion function. The current function properly converts given traditional Roman numerals (from 1 to 3999) into their respective integer values. Your task is to enhance this function to handle extended Roman numerals up to 4999, adding support for an additional character. Traditional Roman numerals use combinations of characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', and \'M\'. The extended system with values up to 4999 includes one additional character: * N = 5000 # Function Definition: ```python def extended_roman_to_int(s: str) -> int: Converts an extended Roman numeral to an integer. Parameters: s (str): A string representing the extended Roman numeral. Returns: int: The integer value of the Roman numeral. ``` Input - The input is a string `s` representing the extended Roman numeral. It is guaranteed to be within the range from 1 to 4999. Output - Return the integer equivalent of the given Roman numeral. Example ```python print(extended_roman_to_int(\\"MML\\")) # Output: 2050 print(extended_roman_to_int(\\"NNMCIX\\")) # Output: 5000 + 1000 - 100 + 10 - 1 = 5909 ``` # Constraints 1. The input string will only contain valid Roman numeral characters. 2. The input is guaranteed to be a valid extended Roman numeral within the range of 1 to 4999. # Expectations - Handle the extended numeral correctly using the provided additional character. - Ensure your function maintains the time complexity of O(n). - Handle edge cases such as the smallest (\\"I\\") and the largest (\\"NIII\\") valid numerals.","solution":"def extended_roman_to_int(s: str) -> int: Converts an extended Roman numeral to an integer. Parameters: s (str): A string representing the extended Roman numeral. Returns: int: The integer value of the Roman numeral. roman_dict = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, } n = len(s) result = 0 for i in range(n): value = roman_dict[s[i]] if i < n - 1 and value < roman_dict[s[i + 1]]: result -= value else: result += value return result"},{"question":"You are given a directed graph represented by its adjacency matrix. The matrix `graph` is an `n x n` matrix where `graph[i][j]` denotes the weight of the edge from node `i` to node `j`. If there is no edge between `i` and `j`, `graph[i][j]` will be `float(\'inf\')`. Write a function `floyd_warshall` that calculates the shortest paths between all pairs of nodes and returns the distance matrix where `dist[i][j]` is the shortest distance from node `i` to node `j`. # Input - A 2D list `graph` where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. `float(\'inf\')` represents no direct edge between nodes `i` and `j`. # Output - A 2D list `dist` where `dist[i][j]` represents the shortest distance from node `i` to node `j`. # Constraints - The number of vertices `n` in the graph is such that `1 <= n <= 100`. # Example **Input**: ```python graph = [[0, 3, float(\'inf\'), 7], [8, 0, 2, float(\'inf\')], [5, float(\'inf\'), 0, 1], [2, float(\'inf\'), float(\'inf\'), 0]] ``` **Output**: ```python [[0, 3, 5, 6], [5, 0, 2, 3], [3, 6, 0, 1], [2, 5, 7, 0]] ``` **Note**: Ensure your implementation can handle graphs with negative weight edges but no negative weight cycles. # Additional Task Include a mechanism to detect the presence of any negative weight cycles in the graph. # Function Signature ```python def floyd_warshall(graph: List[List[float]]) -> List[List[float]]: pass ```","solution":"from typing import List def floyd_warshall(graph: List[List[float]]) -> List[List[float]]: Calculates the shortest paths between all pairs of nodes. Returns the distance matrix where dist[i][j] is the shortest distance from node i to node j. n = len(graph) dist = [[graph[i][j] for j in range(n)] for i in range(n)] for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Detect negative weight cycle for i in range(n): if dist[i][i] < 0: raise ValueError(\\"Graph contains a negative weight cycle\\") return dist"},{"question":"# Cloning an Undirected Graph You are provided with an implementation of an undirected graph represented by the `UndirectedGraphNode` class. Each node contains a label and a list of its neighbouring nodes. The objective is to write a function to clone the graph such that each node, along with its connections, is correctly duplicated without altering the original graph. Input - A reference to a node in the undirected graph to be cloned. If the input is `None`, return `None`. Output - Return a deep copy of the entire graph starting from the given node such that all connections are preserved in the clone. Constraints - Nodes in the graph will have unique labels. - A node may have a connection to itself. - The graph may contain cycles and multiple edges between nodes. Performance Requirements - Aim for a time complexity of O(V + E) where V is the number of vertices and E is the number of edges. - Space complexity should be at most O(V) due to the need to store the mapping between original nodes and their clones. Function Signature ```python def clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: pass ``` Example Visual representation of the graph input: ``` 1 / / 0 --- 2 / _/ ``` Input `node` would be a reference to node labeled `0`. Sample Output: A new graph with a similar structure starting from node labeled `0`. Notes Ensure the cloned graph maintains the same connections among nodes as the original graph. The function will be tested on various scenarios including empty graphs, graphs with single nodes, self-cycles, and complex interconnected nodes.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None old_to_new = {} def clone(node): if node in old_to_new: return old_to_new[node] copy = UndirectedGraphNode(node.label) old_to_new[node] = copy for neighbor in node.neighbors: copy.neighbors.append(clone(neighbor)) return copy return clone(node)"},{"question":"# Question: Enhanced Prime Checking with Performance Analysis Scenario You are a software developer working on a cryptography project where prime numbers are essential for generating keys. Your task is to implement an efficient prime-checking function to verify if a number is prime. However, given the importance of performance, you must also analyze the efficiency of your implementation. Instructions 1. **Function Implementation**: - Implement a function `is_prime(n: int) -> bool` that returns `True` if `n` is a prime number and `False` otherwise. - Optimize the function to minimize the number of divisibility checks. 2. **Performance Analysis**: - Calculate and compare the number of iterations for checking primes using a naive approach vs. the optimized approach. - For the purpose of illustration, assume that the naive approach checks all numbers up to n//2 for divisibility. - Implement a function `naive_prime_check(n: int) -> bool` using the naive method. 3. **Edge Cases and Constraints**: - Handle edge cases where n <= 1. - Your function should work efficiently for numbers as large as 10^6. - Provide a brief analysis of the time complexity of your implementation in comments. Input and Output Formats - **Input**: Single integer `n` where `1 <= n <= 10^6`. - **Output**: - `is_prime(n: int) -> bool` which returns `True` if n is prime or `False` otherwise. - A performance analysis output comparing naive vs optimized checks. Example ```python assert is_prime(11) == True assert is_prime(15) == False assert naive_prime_check(11) == True assert naive_prime_check(15) == False # Performance analysis may include print statements or documented comparisons. ``` Example Analysis ```python # For n = 29: # naive_prime_check iterates up to 14 checks. # is_prime optimizes using 5 checks by skipping multiples of 2, 3 and using 6k ± 1 rule. ``` Your task is to implement both the functions and provide comparative analysis on performance demonstrated through the number of checks or time taken.","solution":"import math def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. Optimized prime check by minimizing divisibility checks. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def naive_prime_check(n: int) -> bool: Returns True if n is a prime number, False otherwise. Naive approach that checks all division possibilities up to n // 2. if n <= 1: return False for i in range(2, n // 2 + 1): if n % i == 0: return False return True # Example analysis of performance in comments: # For n = 29: # naive_prime_check will iterate up to 14 checks. # is_prime will iterate using 3 checks by skipping multiples of 2, 3 and using 6k ± 1 rule."},{"question":"# Matrix Exponentiation with Trace Implementation Context Matrix exponentiation is a process used in various fields like computer graphics, algorithm design, and linear algebra. Efficient matrix exponentiation can significantly optimize the performance of algorithms that involve repeated matrix multiplication, such as in solving linear recurrence relations. Task You are asked to implement an optimized version of matrix exponentiation that not only performs the square matrix exponentiation but also tracks the intermediate steps of multiplication. Specifically, you will need to: 1. Implement the matrix exponentiation algorithm using repeated squaring. 2. Track and store each intermediate matrix result into a list during recursion. 3. Finally, return both the resultant matrix and the list of intermediate matrices. # Specifications - Implement the following function: ```python def matrix_exponentiation_trace(mat: list, n: int) -> tuple: Calculates mat^n by repeated squaring and tracks each intermediate matrix. Parameters: mat (list): A square matrix of size d x d. n (int): The power to raise the matrix to. Returns: tuple: A tuple containing the resultant matrix and a list of intermediate matrices. ``` **Input:** - `mat`: A list denoting the d x d square matrix. - `n`: An integer denoting the power to which the matrix is to be raised. **Output:** - A tuple containing: - The resultant matrix after exponentiation. - A list of intermediate matrices showing the steps involved in the computation. # Constraints - You may assume `mat` contains only integers and is a valid square matrix. - `1 <= d <= 10`, where d is the dimension of the square matrix. - `0 <= n <= 10^9`, where n is the power. # Example ```python mat = [ [1, 2], [3, 4] ] n = 3 result, intermediate_steps = matrix_exponentiation_trace(mat, n) print(result) # Expected Output: [[37, 54], [81, 118]] print(intermediate_steps) # Expected Output might include intermediate matrices such as # [[[1, 2], [3, 4]], intermediate matrices from recursion, etc.] ``` Note: - Ensure to handle the base case when n = 0, where the result should be the identity matrix of the same dimension. - Consider edge cases like when the matrix dimensions are minimal (d=1, n=0, etc.).","solution":"def matrix_exponentiation_trace(mat, n): Calculates mat^n by repeated squaring and tracks each intermediate matrix. Parameters: mat (list): A square matrix of size d x d. n (int): The power to raise the matrix to. Returns: tuple: A tuple containing the resultant matrix and a list of intermediate matrices. def matrix_mul(A, B): d = len(A) C = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): C[i][j] += A[i][k] * B[k][j] return C def matrix_identity(d): I = [[0] * d for _ in range(d)] for i in range(d): I[i][i] = 1 return I def matrix_pow(mat, n): if n == 0: return matrix_identity(len(mat)) if n == 1: return mat if n % 2 == 0: half_pow = matrix_pow(mat, n // 2) result = matrix_mul(half_pow, half_pow) intermediate_matrices.append(result) return result else: half_pow = matrix_pow(mat, (n - 1) // 2) intermediate_mul = matrix_mul(half_pow, half_pow) result = matrix_mul(intermediate_mul, mat) intermediate_matrices.append(result) return result intermediate_matrices = [mat] result_matrix = matrix_pow(mat, n) return result_matrix, intermediate_matrices"},{"question":"Scenario: You are part of a logistics optimization team responsible for minimizing costs in a delivery network. The network consists of multiple hubs (subsets) and central depots (universe set) that need to be covered. Your task is to implement an efficient solution that determines the minimum cost to cover all depots using available hubs. Problem Statement: Given a set (U) (central depots) containing (n) elements and a collection of subsets (S) (hubs) with their respective costs, write a function `efficient_set_cover` that uses an approximate greedy algorithm to determine a minimal cost subcollection of (S) that covers all elements of (U). **Function Signature**: ```python def efficient_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: Args: universe (set): Universe of elements {1, 2, ... , n} subsets (dict): Dictionary where keys are subset names and values are sets of elements in those subsets. costs (dict): Dictionary where keys are subset names and values are costs of those subsets. Returns: tuple: A tuple containing the list of selected subset names and the total minimal cost. pass ``` **Input**: - `universe`: Set of integers representing elements of the universe. - `subsets`: Dictionary where keys are strings (subset names) and values are sets of integers (elements in subsets). - `costs`: Dictionary where keys are strings (subset names) and values are integers (subset costs). **Output**: - A tuple containing: 1. List of subset names chosen for the cover. 2. Total minimal cost as an integer. **Constraints**: - Every element in the universe must be covered by at least one subset. - Subsets and costs dictionaries have the same keys. **Example**: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} efficient_set_cover(universe, subsets, costs) # Output: ([\'S3\', \'S2\'], 13) ``` **Note**: Ensure your solution considers edge cases, performance, and correct handling of invalid inputs.","solution":"def efficient_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: Args: universe (set): Universe of elements {1, 2, ... , n} subsets (dict): Dictionary where keys are subset names and values are sets of elements in those subsets. costs (dict): Dictionary where keys are subset names and values are costs of those subsets. Returns: tuple: A tuple containing the list of selected subset names and the total minimal cost. selected_subsets = [] covered = set() while covered != universe: best_subset, best_cost = None, float(\'inf\') for subset_name, subset_elements in subsets.items(): new_elements = subset_elements - covered if new_elements: cost_per_new_elem = costs[subset_name] / len(new_elements) if cost_per_new_elem < best_cost: best_cost = cost_per_new_elem best_subset = subset_name if best_subset is None: raise ValueError(\\"No valid subset to cover all elements of the universe.\\") covered.update(subsets[best_subset]) selected_subsets.append(best_subset) total_cost = sum(costs[subset] for subset in selected_subsets) return selected_subsets, total_cost"},{"question":"You are given an array of non-negative integers. Your task is to implement a function `enhanced_bucket_sort(arr: List[int]) -> List[int]` that sorts the input array using the bucket sort mechanism provided in the below description. Function Signature The function should have the following signature: ```python from typing import List def enhanced_bucket_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of non-negative integers, length `n` (0 <= n <= 10^5). # Output * A sorted list of integers in ascending order. # Constraints 1. 0 ≤ number of elements in the array ≤ 100000 2. 0 ≤ value of elements in the array ≤ 1000000 # Requirements 1. Implement bucket sort as described in the analysis. 2. **Optimization**: To improve average case performance, any sub-sort should be optimized for small data sets. Preferably, use insertion sort for sub-sorting. 3. Handle edge cases effectively. # Example ```python assert enhanced_bucket_sort([]) == [] assert enhanced_bucket_sort([5, 12, 8, 5, 6]) == [5, 5, 6, 8, 12] assert enhanced_bucket_sort([3, 1, 4]) == [1, 3, 4] assert enhanced_bucket_sort([12, 11, 12, 9]) == [9, 11, 12, 12] assert enhanced_bucket_sort([100, 95, 105, 94]) == [94, 95, 100, 105] ``` Notes - You should not use Python\'s built-in `sort()` method. - Explain and handle all identified edge cases within your code comments. - Strive for efficiency and clarity in your implementation.","solution":"from typing import List def insertion_sort(bucket: List[int]) -> List[int]: Helper function to perform insertion sort on a bucket. for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and key < bucket[j]: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def enhanced_bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] max_value = max(arr) bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] for i in range(len(arr)): index = arr[i] * bucket_count // (max_value + 1) buckets[index].append(arr[i]) sorted_array = [] for i in range(bucket_count): sorted_array.extend(insertion_sort(buckets[i])) return sorted_array"},{"question":"# Minimum Spanning Tree Using Kruskal\'s Algorithm and Disjoint Set Imagine you are tasked with designing a minimal cost infrastructure to connect several cities. You are given the number of cities and the possible routes between them with their associated costs. Your goal is to determine the minimum total cost to connect all the cities using Kruskal\'s algorithm for finding the Minimum Spanning Tree (MST). **Function Signature**: ```python def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: ``` **Input**: - `vertex_count` (int): the number of vertices (cities) in the graph. - `edges` (List[Tuple[int, int, int]]): a list of tuples where each tuple represents an edge in the format `(source, target, weight)`, where `source` and `target` are the vertices connected by that edge, and `weight` is the cost to connect them. **Output**: - (int): the sum of the weights of the edges in the minimum spanning tree. **Constraints**: - 1 ≤ vertex_count ≤ 10^5 - 0 ≤ number of edges ≤ 2 * 10^5 - 1 ≤ weight of each edge ≤ 10^4 **Example**: ```python print(minimum_spanning_tree(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)])) # Output: 14 print(minimum_spanning_tree(3, [(2, 1, 20), (3, 1, 20), (2, 3, 100)])) # Output: 40 ``` **Explanation**: 1. In the first example, the MST consists of the edges (1, 2), (3, 4), (3, 5), and (2, 4) with a total cost of 14. 2. In the second example, the MST consists of the edges (2, 1) and (3, 1) with a total cost of 40. # Constraints and Performance - Your implementation must efficiently handle the given constraints. - Ensure correct union-find operations to maintain the disjoint sets. # Notes - Implement the `minimum_spanning_tree` function using Kruskal\'s algorithm. - Use appropriate data structures (e.g., a Disjoint Set with path compression and union by size) to optimize the MST construction.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [0] * n def find(self, u: int) -> int: if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u: int, v: int): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: # Step 1: Sort all the edges by their weight (cost) edges.sort(key=lambda edge: edge[2]) # Step 2: Initialize disjoint set dsu = DisjointSet(vertex_count) total_cost = 0 edges_used = 0 for u, v, weight in edges: # Adjust for 0-based indexing of vertices u -= 1 v -= 1 if dsu.find(u) != dsu.find(v): dsu.union(u, v) total_cost += weight edges_used += 1 # If we have used vertex_count - 1 edges, we can stop if edges_used == vertex_count - 1: break return total_cost"},{"question":"**Scenario**: You are tasked with developing a monitoring system that ensures all required data points within a specific range are present in a dataset. Any gaps in the data must be identified for further investigation. To achieve this, write a function that identifies all missing integer ranges within a specified bounds, given a sorted input array. # Function Specification **Function Name**: `find_missing_ranges` **Input**: * `arr` (List[int]): A sorted list of unique integers. * `lo` (int): The lower bound of the range (inclusive). * `hi` (int): The upper bound of the range (inclusive). **Output**: * `List[Tuple[int, int]]`: A list of tuples, each representing a missing range within the inclusive bounds of `lo` and `hi`. # Constraints * The input array `arr` is sorted in ascending order. * The range is defined as `lo <= x <= hi`, where `x` is an integer. * Elements in `arr` are within the bounds of `lo` and `hi`. # Performance Requirements * The function should operate in linear time relative to the size of the input array. * The function should use constant space excluding the space required for the output list. # Example ```python def find_missing_ranges(arr, lo, hi): res = [] start = lo for n in arr: if n == start: start += 1 elif n > start: res.append((start, n-1)) start = n + 1 if start <= hi: res.append((start, hi)) return res # Example usage: print(find_missing_ranges([3, 5, 7, 8], 1, 10)) # Output: [(1, 2), (4, 4), (6, 6), (9, 10)] print(find_missing_ranges([], 1, 10)) # Output: [(1, 10)] print(find_missing_ranges([1, 2, 3, 4, 5], 1, 5)) # Output: [] ``` Write your function implementation for `find_missing_ranges` considering the above description and examples.","solution":"from typing import List, Tuple def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: This function identifies all missing integer ranges within a specified bounds, given a sorted input array. Parameters: arr (List[int]): A sorted list of unique integers. lo (int): The lower bound of the range (inclusive). hi (int): The upper bound of the range (inclusive). Returns: List[Tuple[int, int]]: A list of tuples, each representing a missing range within the inclusive bounds of `lo` and `hi`. res = [] start = lo for n in arr: if n > start: res.append((start, n - 1)) start = n + 1 if start <= hi: res.append((start, hi)) return res"},{"question":"# Quick Sort Improvement and Custom Pivot Selection **Problem Description**: You are given a list of integers that need to be sorted using an improved version of the Quick Sort algorithm with custom pivot selection to mitigate the risk of worst-case performance. Instead of always choosing the last element as the pivot, you will implement a strategy to choose a random element as the pivot. **Task**: Implement a function `quick_sort_improved(arr)` that sorts the given list of integers using Quick Sort with randomized pivot selection. **Function Signature**: `def quick_sort_improved(arr: List[int]) -> List[int]:` **Input**: * `arr`: A list of integers `arr` where 1 ≤ len(arr) ≤ 10^5. **Output**: * Returns the sorted list of integers. **Constraints**: 1. You must implement the random pivot selection. 2. Ensure that the function handles the sorting in-place. 3. Consider performance optimizations to handle large datasets effectively. **Edge Cases**: - The array could be empty. - The array could contain duplicate values. - Handle cases with small and large datasets efficiently. **Example**: ```python assert quick_sort_improved([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert quick_sort_improved([1]) == [1] assert quick_sort_improved([]) == [] assert quick_sort_improved([4, 4, 4, 4]) == [4, 4, 4, 4] ``` **Notes**: * You are not allowed to use Python\'s inbuilt sort functions. * You need to import `random` module for selecting the pivot.","solution":"import random from typing import List def quick_sort_improved(arr: List[int]) -> List[int]: Sorts a list of integers using Quick Sort algorithm with random pivot selection. Parameters: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list of integers. def quick_sort(arr, low, high): if low < high: p = partition(arr, low, high) quick_sort(arr, low, p - 1) quick_sort(arr, p + 1, high) def partition(arr, low, high): pivot_index = random.randint(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index if not arr: return [] quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# **Coding Assessment Question** Objective Write a function that determines if an integer has alternating bits in its binary representation. Demonstrate different approaches, focusing on both simplicity and performance. Input * A single integer `n` (0 ≤ n ≤ 2^31 - 1). Output * A boolean value (`True` or `False`) indicating whether the integer has alternating bits. Requirements 1. Implement the function `has_alternating_bits` which computes the result by iterating through the bits. 2. Implement the function `has_alternating_bits_fast` which uses efficient bitwise operations and predefined masks for the result. Constraints * The solution should be efficient with respect to both time and space. * The iterative approach should handle very large numbers reasonably well. * The optimized approach must ensure constant time complexity. Performance * The first solution should have a time complexity of O(number of bits in n). * The second solution should have a time complexity of O(1). Example ```python # Example 1 Input: 5 Output: True # Binary: 101 # Example 2 Input: 7 Output: False # Binary: 111 # Example 3 Input: 11 Output: False # Binary: 1011 # Example 4 Input: 10 Output: True # Binary: 1010 ``` Template ```python def has_alternating_bits(n: int) -> bool: first_bit = 0 second_bit = 0 while n: first_bit = n & 1 if n >> 1: second_bit = (n >> 1) & 1 if not first_bit ^ second_bit: return False else: return True n = n >> 1 return True def has_alternating_bits_fast(n: int) -> bool: mask1 = int(\'aaaaaaaa\', 16) # for bits ending with zero (...1010) mask2 = int(\'55555555\', 16) # for bits ending with one (...0101) return mask1 == (n + (n ^ mask1)) or mask2 == (n + (n ^ mask2)) ```","solution":"def has_alternating_bits(n: int) -> bool: Determines if an integer has alternating bits in its binary representation. Iterative approach. prev_bit = n & 1 n >>= 1 while n > 0: current_bit = n & 1 if current_bit == prev_bit: return False prev_bit = current_bit n >>= 1 return True def has_alternating_bits_fast(n: int) -> bool: Determines if an integer has alternating bits in its binary representation. Efficient bitwise approach. bits_shifted = n >> 1 all_ones = bits_shifted ^ n return (all_ones & (all_ones + 1)) == 0"},{"question":"Scenario You are working on a custom binary manipulation library for a high-performance computing application. As part of this task, you need to design a function to swap all pairs of adjacent bits in a 32-bit unsigned integer. Task Write a function `swap_bits(num: int) -> int` that swaps every pair of adjacent bits in the given 32-bit unsigned integer. # Function Signature ```python def swap_bits(num: int) -> int: pass ``` # Input * `num`: An integer `0 <= num <= 2^32 - 1` representing the 32-bit unsigned integer. # Output * Returns an integer representing the 32-bit unsigned integer after swapping each pair of adjacent bits. # Example ```python assert swap_bits(22) == 41 assert swap_bits(10) == 5 ``` # Constraints * You may assume that the input is always a non-negative integer within the specified range. * You should aim for an O(1) time complexity and O(1) space complexity solution. # Notes * `22` in binary is `00010110`. After swapping adjacent bits, it becomes `00101001`, which is `41`. * `10` in binary is `00001010`. After swapping adjacent bits, it becomes `00000101`, which is `5`.","solution":"def swap_bits(num: int) -> int: Swaps every pair of adjacent bits in the given 32-bit unsigned integer. # Mask for even bits: 0xAAAAAAAA (binary: 10101010101010101010101010101010) even_bits = num & 0xAAAAAAAA # Mask for odd bits: 0x55555555 (binary: 01010101010101010101010101010101) odd_bits = num & 0x55555555 # Right shift even bits even_bits >>= 1 # Left shift odd bits odd_bits <<= 1 # Combine shifted bits return even_bits | odd_bits"},{"question":"# Problem: Design a Circular Buffer-based Queue A company is designing a real-time notification system and needs a queue with a fixed capacity that efficiently handles enqueue and dequeue operations. To achieve this, you are required to implement a queue using a circular buffer. **Task**: You need to implement a `CircularBufferQueue` class by extending the `AbstractQueue` class, using the circular buffer approach. The class should support the following methods: 1. `enqueue(value)`: Adds `value` to the rear of the queue. 2. `dequeue()`: Removes and returns the front item from the queue. 3. `peek()`: Returns the front item without removing it. 4. `is_empty()`: Returns `True` if the queue is empty, otherwise `False`. 5. `__len__()`: Returns the number of items in the queue. 6. `__iter__()`: Returns an iterator to iterate over the elements from the front to the rear of the queue. **Expected Input and Output**: * `enqueue(value: Any)` -> None * `dequeue() -> Any` * `peek() -> Any` * `is_empty() -> bool` * `__len__() -> int` * `__iter__() -> Iterator[Any]` **Constraints**: * The maximum size of the queue is defined at initialization and cannot be changed. * Operations should maintain O(1) time complexity. **Performance Requirements**: * All methods except the `__iter__` must run in O(1) time complexity. Here is the skeleton code you need to complete: ```python class CircularBufferQueue(AbstractQueue): def __init__(self, capacity): super().__init__() self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 self._size = 0 def __iter__(self): count, index = 0, self._front while count < self._size: yield self._array[index] index = (index + 1) % self._capacity count += 1 def enqueue(self, value): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] ``` **Context**: This queue design is particularly useful in scenarios where a fixed-size buffer is necessary, such as in streaming data, where old data should be overwritten when the buffer is full.","solution":"class CircularBufferQueue: def __init__(self, capacity): self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 self._size = 0 def __iter__(self): count, index = 0, self._front while count < self._size: yield self._array[index] index = (index + 1) % self._capacity count += 1 def enqueue(self, value): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def is_empty(self): return self._size == 0 def __len__(self): return self._size"},{"question":"Given the implementation of Tarjan\'s algorithm for identifying strongly connected components (SCCs) in a directed graph, your task is to extend the functionality to not only identify the SCCs but also to return the size of the largest SCC within the graph. # Function Signature ```python def largest_scc_size(dict_graph: Dict[int, List[int]]) -> int: Finds the size of the largest strongly connected component in the given directed graph. :param dict_graph: A dictionary representing the adjacency list of the directed graph. :return: An integer, representing the size of the largest strongly connected component. ``` # Input - `dict_graph`: A dictionary where keys are integers representing vertices, and values are lists of integers representing the vertices that each key vertex points to. # Output - Return an integer which is the size of the largest SCC in the graph. # Example ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3] } assert largest_scc_size(graph) == 3 ``` # Constraints - The graph will have at least one vertex. - The number of vertices will not exceed 10^4. - The number of edges will not exceed 10^6. # Performance Requirement - The solution should run with a time complexity of O(V + E) and a space complexity of O(V) where V is the number of vertices and E is the number of edges. # Hint - Modify the provided Tarjan\'s algorithm to keep track of the size of each SCC and find the maximum size before returning it as the result.","solution":"def largest_scc_size(dict_graph): Finds the size of the largest strongly connected component in the given directed graph. :param dict_graph: A dictionary representing the adjacency list of the directed graph. :return: An integer, representing the size of the largest strongly connected component. index = 0 stack = [] indices = {} lowlink = {} on_stack = {} sccs = [] def strongconnect(v): nonlocal index indices[v] = index lowlink[v] = index index += 1 stack.append(v) on_stack[v] = True for w in dict_graph[v]: if w not in indices: strongconnect(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif on_stack[w]: lowlink[v] = min(lowlink[v], indices[w]) if lowlink[v] == indices[v]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == v: break sccs.append(scc) for v in dict_graph: if v not in indices: strongconnect(v) largest_scc = max(sccs, key=len, default=[]) return len(largest_scc)"},{"question":"# Coding Challenge: Implement a Median Finder using Two Heaps In this challenge, you must use two binary heaps (one min heap and one max heap) to create a data structure that supports finding the median of a dynamic dataset. Problem Scenario: You are implementing a system where data points are continuously added. You need to find the median value efficiently after each insertion. The median of a dataset is the middle value when the dataset is sorted. Requirements: - Implement a `MedianFinder` class with the following methods: - `add_num(num: int)`: Adds a number to the data structure. - `find_median() -> float`: Returns the median of all elements. Constraints: - All operations should run in O(log N) time. - The total number of elements can be up to (10^5). Expected Input and Output: - `add_num(num: int)`: No output - `find_median() -> float`: Returns a floating point value representing the median # Example Behavior: ```python mf = MedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2.0 ``` # Implementation Details: - Use a min heap to store the larger half of the numbers. - Use a max heap to store the smaller half of the numbers. - Ensure both heaps are balanced such that their sizes differ at most by 1. - The median is derived from the tops of both heaps. ```python import heapq class MedianFinder: def __init__(self): self.min_heap = [] # stores the larger half self.max_heap = [] # stores the smaller half def add_num(self, num: int): # Add to max heap heapq.heappush(self.max_heap, -num) # Balance the heaps - ensure all max_heap elements <= min_heap elements if self.max_heap and self.min_heap and -self.max_heap[0] > self.min_heap[0]: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Balance sizes - ensure min_heap size is about equal to max_heap size if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: # If even number of elements, average of top of both heaps if len(self.min_heap) == len(self.max_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 # If odd, top of max_heap return float(-self.max_heap[0]) ```","solution":"import heapq class MedianFinder: def __init__(self): self.min_heap = [] # stores the larger half self.max_heap = [] # stores the smaller half def add_num(self, num: int): # Add to max heap heapq.heappush(self.max_heap, -num) # Balance the heaps - ensure all max_heap elements <= min_heap elements if self.max_heap and self.min_heap and -self.max_heap[0] > self.min_heap[0]: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Balance sizes - ensure min_heap size is about equal to max_heap size if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: # If even number of elements, average of top of both heaps if len(self.min_heap) == len(self.max_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 # If odd, top of max_heap return float(-self.max_heap[0])"},{"question":"**Title**: Implement and Optimize Shell Sort **Background**: Shell Sort is a generalization of insertion sort that allows the exchange of items that are far apart. The method starts by sorting elements far apart from each other and progressively reduces the gap between elements to be sorted. Given the nature of Shell Sort, the choice of gap sequence can affect the efficiency of the algorithm. In this task, you need to implement Shell Sort with a provided gap sequence and then propose an optimized gap sequence. **Problem**: 1. Implement the Shell Sort algorithm using the gap sequence [n/2, n/4, ..., 1], where n is the size of the array. 2. Write a function to optimize the gap sequence and use the new sequence to sort the array. **Function Signature**: ```python def shell_sort(arr: list, gaps: list) -> list: Sorts an array using the Shell Sort algorithm and the specified gap sequence. Args: arr: List[int] - a list of integers to sort. gaps: List[int] - a list of gap values used in the Shell Sort algorithm. Returns: List[int] - a sorted list of integers. def find_optimized_gaps(n: int) -> list: Finds an optimized gap sequence for sorting an array of size n using Shell Sort. Args: n: int - the size of the array. Returns: List[int] - a list of optimized gap values. # Example usage: # arr = [9, 8, 3, 7, 5, 6, 4, 1] # gaps = find_optimized_gaps(len(arr)) # sorted_arr = shell_sort(arr, gaps) ``` **Constraints**: * The input array length will not exceed 10000. * Each element in the input array will be an integer within the range -1000000 to 1000000. **Performance Requirements**: * The algorithm should complete sorting for arrays of size up to 10000 within a reasonable time limit. **Assessment Criteria**: * Correctly implement Shell Sort using the specified gap sequence. * Efficiently find and use an optimized gap sequence. * Handle edge cases like empty arrays or arrays with identical elements. * Ensure the solution is robust and efficiently handles the input constraints.","solution":"def shell_sort(arr, gaps): Sorts an array using the Shell Sort algorithm and the specified gap sequence. Args: arr: List[int] - a list of integers to sort. gaps: List[int] - a list of gap values used in the Shell Sort algorithm. Returns: List[int] - a sorted list of integers. n = len(arr) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr def find_optimized_gaps(n): Finds an optimized gap sequence for sorting an array of size n using Shell Sort. Args: n: int - the size of the array. Returns: List[int] - a list of optimized gap values. gaps = [] k = 1 while True: gap = (3 ** k - 1) // 2 if gap > n: break gaps.insert(0, gap) k += 1 return gaps # Example usage: # arr = [9, 8, 3, 7, 5, 6, 4, 1] # gaps = find_optimized_gaps(len(arr)) # sorted_arr = shell_sort(arr, gaps)"},{"question":"# RSA Key Generation and Encryption/Decryption **Objective**: Implement RSA key generation, encryption, and decryption algorithms to understand asymmetric cryptographic systems. # Problem Statement: You are asked to implement the RSA key generation algorithm and then write functions for encrypting and decrypting data using the generated keys. Your implementation should be able to generate keys of specified bit lengths and handle encryption/decryption of provided integers. # Requirements: 1. **Key Generation Function**: Create a function `generate_key(k)` that generates a public/private key pair for encrypting and decrypting data. - `k` (int): Number of bits for the modulus. - Returns: `(n, e, d)` where n is the modulus, e is the public exponent, and d is the private exponent. 2. **Encryption Function**: Create a function `encrypt(data, e, n)` that encrypts the given data using the public key `(e, n)`. - `data` (int): The number to be encrypted. - `e` (int): The public exponent. - `n` (int): The modulus. - Returns: The encrypted data (int). 3. **Decryption Function**: Create a function `decrypt(encrypted_data, d, n)` that decrypts the given encrypted data using the private key `(d, n)`. - `encrypted_data` (int): The number to be decrypted. - `d` (int): The private exponent. - `n` (int): The modulus. - Returns: The decrypted data (int). # Constraints: - The bit length `k` for the modulus should be at least 8 and no more than 1024. - The data to be encrypted should be a non-negative integer less than `n`. - You may use the `pow` function with three arguments for efficient modular exponentiation. # Example Input/Output: ```python # Example Usage: n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Implementation: Implement the functions described above, ensuring they handle edge cases efficiently and securely.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(length): Generate an odd integer randomly. p = random.getrandbits(length) # Apply a mask to set MSB and LSB to 1 p |= (1 << length - 1) | 1 return p def generate_prime_number(length): Generate a prime number of the specified bit length. p = 4 # Keep generating while the number is not prime while not isprime(p): p = generate_prime_candidate(length) return p def generate_key(k): Generates an RSA public/private key pair. Arguments: k -- the number of bits for the modulus Returns: (n, e, d) tuple if k < 8 or k > 1024: raise ValueError(\\"bit length k must be between 8 and 1024\\") # Generate two distinct primes p and q p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) while q == p: q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # a commonly used prime exponent d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): Encrypts data using the RSA public key. Arguments: data -- the number to be encrypted e -- the public exponent n -- the modulus Returns: Encrypted data as an integer if data < 0 or data >= n: raise ValueError(\\"The data to be encrypted must be in the range [0, n-1]\\") return pow(data, e, n) def decrypt(encrypted_data, d, n): Decrypts data using the RSA private key. Arguments: encrypted_data -- the number to be decrypted d -- the private exponent n -- the modulus Returns: Decrypted data as an integer return pow(encrypted_data, d, n)"},{"question":"Given an array of integers, implement both Max Heap Sort and Min Heap Sort to sort the array in ascending order. You need to showcase your understanding by implementing the sorting algorithms and analyzing their performance. Implement two functions: 1. `max_heap_sort(arr: List[int], simulation: bool = False) -> List[int]`: Sorts the array using Max Heap Sort algorithm. 2. `min_heap_sort(arr: List[int], simulation: bool = False) -> List[int]`: Sorts the array using Min Heap Sort algorithm. # Input - A list of integers, `arr`. - A boolean flag `simulation` which, if True, prints the current state of the heap at each step of the algorithm. # Output - The sorted list of integers in ascending order. # Constraints 1. The array length `n` can be up to 10^5. 2. Each integer in the array can range between `-10^9` and `10^9`. 3. If `simulation` is set to `True`, print the heap state at each iteration step. # Performance - Designed to run within reasonable time limits under the given constraints. - Space complexity should remain O(1), excluding the input and output storage. # Example Execution For `max_heap_sort` with `simulation=True`: ```python arr = [4, 10, 3, 5, 1] result = max_heap_sort(arr, simulation=True) # expected print output: # iteration 0: 4 10 3 5 1 # ... (other iteration outputs) # Final sorted array: [1, 3, 4, 5, 10] ``` For `min_heap_sort` with `simulation=True`: ```python arr = [4, 10, 3, 5, 1] result = min_heap_sort(arr, simulation=True) # expected print output: # iteration 0: 4 10 3 5 1 # ... (other iteration outputs) # Final sorted array: [1, 3, 4, 5, 10] ```","solution":"def max_heapify(arr, n, i, simulation=False): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"heapify at {i}: {arr}\\") max_heapify(arr, n, largest, simulation) def max_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) if simulation: print(f\\"build max heap step {i}: {arr}\\") for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"extract {i}: {arr}\\") max_heapify(arr, i, 0, simulation) return arr def min_heapify(arr, n, i, simulation=False): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(f\\"heapify at {i}: {arr}\\") min_heapify(arr, n, smallest, simulation) def min_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) if simulation: print(f\\"build min heap step {i}: {arr}\\") for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"extract {i}: {arr}\\") min_heapify(arr, i, 0, simulation) arr.reverse() # Reverse the array to get ascending order return arr"},{"question":"# Coding Challenge Scenario/Context In your latest project, you are developing a module for a secure communication system. The system uses RSA encryption which requires frequent computation of large powers under a prime modulus. To optimize this, you must implement a function that efficiently computes the result of `(base^exponent) % mod`. Task Write a function `efficient_modular_exponential(base, exponent, mod)` that: 1. Computes ( (base^{exponent}) mod mod ) efficiently using the method of exponentiation by squaring. 2. Validates the input, ensuring that the exponent is non-negative and the modulus is positive. # Function Signature ```python def efficient_modular_exponential(base: int, exponent: int, mod: int) -> int: ``` # Input 1. An integer `base` (0 ≤ base ≤ 10^9) 2. An integer `exponent` (0 ≤ exponent ≤ 10^9) 3. An integer `mod` (1 ≤ mod ≤ 10^9) # Output - An integer representing ( (base^{exponent}) mod mod ). # Constraints - The function should handle large integers efficiently. - If `exponent` is negative, raise a `ValueError` with a message \\"Exponent must be non-negative.\\" - If `mod` is zero or negative, raise a `ValueError` with a message \\"Modulus must be positive.\\" # Performance Requirements The function should run in ( O(log n) ) time complexity, where ( n ) is the value of `exponent`. # Examples 1. `efficient_modular_exponential(2, 10, 1000)` should return `24` (since ( 2^{10} = 1024 ), and ( 1024 mod 1000 = 24 )). 2. `efficient_modular_exponential(3, 5, 13)` should return `8` (since ( 3^5 = 243 ), and ( 243 mod 13 = 8 )). **Note:** Ensure that your implementation handles large values and edge cases like `exponent` = 0 and `mod` = 1 effectively.","solution":"def efficient_modular_exponential(base: int, exponent: int, mod: int) -> int: if exponent < 0: raise ValueError(\\"Exponent must be non-negative.\\") if mod <= 0: raise ValueError(\\"Modulus must be positive.\\") result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"You are given a function that reverses an array and another function that reverses the order of words in a string. The main task is to implement a function that reverses individual words in a given string but keeps the words in their original order. # Function Signature ```python def reverse_individual_words(string: str) -> str: ``` # Input - `string`: A string containing words separated by spaces. The string may contain leading or trailing spaces. # Output - Returns a new string where each individual word is reversed, but the order of the words remains the same. # Constraints - The input string will only contain printable ASCII characters. - Maximum length of the string `string` is 10^5. # Example Example 1: Input: `\\"I am keon kim and I like pizza\\"` Output: `\\"I ma noek mik dna I ekil azzip\\"` Example 2: Input: `\\"hello world \\"` Output: `\\"olleh dlrow \\"` # Scenario/Context This problem simulates text manipulation tasks often required in natural language processing, where specific transformations of parts of the text are required without altering the global structure. # Requirements Your solution must: - Efficiently reverse individual words in the provided input string. - Preserve the original order of the words in the string. - Handle multiple spaces between words and preserve leading/trailing spaces.","solution":"def reverse_individual_words(string: str) -> str: Reverses each individual word in the given string, but keeps the words in their original order. Parameters: - string: a string containing words separated by spaces. Returns: - a new string with each word reversed, but the order of words preserved. return \' \'.join(word[::-1] for word in string.split(\' \'))"},{"question":"Scenario & Context: In a software application, data must often be sanitized before being processed or stored, especially when multiple sources may introduce redundant or duplicate entries. One common task in data sanitation is the removal of duplicate characters from strings while preserving the order of first appearances. Problem Statement: Write a function `delete_reoccurring_characters` that takes a single string as input and returns a new string with all duplicate characters removed, maintaining the order of their first appearance. Requirements: * **Input**: A string `s` containing only lowercase alphabetical characters. * **Output**: A new string with all repeating characters removed, only keeping the first occurrences. * **Constraints**: * The length of string `s` is between [0, 10^6]. Function Signature: ```python def delete_reoccurring_characters(s: str) -> str: ``` Example: ```python assert delete_reoccurring_characters(\\"abcabc\\") == \\"abc\\" assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"aabccba\\") == \\"abc\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" assert delete_reoccurring_characters(\\"abcdefg\\") == \\"abcdefg\\" ``` Instructions: * Ensure that the function adheres to the constraints provided. * Consider the edge cases, such as an empty string and strings with all identical characters. * Aim for an efficient solution with a time complexity of O(n) and space complexity of O(n).","solution":"def delete_reoccurring_characters(s: str) -> str: Returns a new string with all duplicate characters removed, keeping the first occurrences and maintaining the order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \\"\\".join(result)"},{"question":"As a computer science student, you are tasked with demonstrating your understanding of searching algorithms. You need to implement an efficient search algorithm for a sorted array of integers. While linear search works well for unsorted arrays, it is not efficient for sorted arrays. Instead, you should use binary search, which is more appropriate for this scenario. # Your Task Implement the function `binary_search` that uses the binary search algorithm to find the index of a given element in a sorted array. If the element is not found, the function should return -1. # Function Signature ```python def binary_search(array: List[int], query: int) -> int: pass ``` # Input - `array`: A list of integers in ascending order (e.g., [1, 2, 3, 4, 5]). - `query`: The integer value to be searched within the array. # Output - Return the index of the `query` element if found. Otherwise, return -1. # Constraints - The array will be non-empty and sorted in ascending order. - The array length will not exceed 10^6. - The elements in the array will be in the range -10^6 to 10^6. # Examples ```python # Example 1 array = [1, 2, 3, 4, 5] query = 3 assert binary_search(array, query) == 2 # Example 2 array = [1, 2, 3, 4, 5] query = 6 assert binary_search(array, query) == -1 # Example 3 array = [-10, -5, 0, 5, 10] query = -5 assert binary_search(array, query) == 1 ``` # Explanation In the first example, the element 3 is found at index 2. In the second example, the element 6 is not present, so -1 is returned. In the third example, the element -5 is found at index 1. Implement the `binary_search` function efficiently, considering the constraints and use binary search principles to optimize the search process.","solution":"from typing import List def binary_search(array: List[int], query: int) -> int: Perform binary search on a sorted array to find the index of the specified query. Parameters: array (List[int]): A list of integers sorted in ascending order. query (int): The integer to search for in the array. Returns: int: The index of the query in the array if found, otherwise -1. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Context: Given the importance of identifying prime numbers in various fields such as cryptography, data science, and competitive programming, it is crucial to implement an efficient function to check if a number is prime. Task: Write a function called `find_primes` that takes an integer `m` as input and returns a list of all prime numbers less than `m`. Ensure your implementation is efficient enough to handle larger values of `m`. Function Signature: ```python def find_primes(m: int) -> List[int]: ``` Input: * `m` (1 <= m <= 10^6): An integer denoting the upper limit for searching prime numbers (excluding `m` itself). Output: * A list of integers, each being a prime number less than the given `m`. Constraints: * The function should be efficient and optimized for larger values of `m`. * Handle edge cases where lower limits are specified (e.g., 1, 2). Scenario: You are developing a prime number generation feature for a cryptographic application that requires frequent checks on the primality of numbers up to a large range. Implementing this feature efficiently ensures that the application remains performant and secure. Examples: ```python >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> find_primes(2) [] >>> find_primes(1) [] ``` Note: * The function should not include debug prints or external libraries that are not part of the standard Python library.","solution":"from typing import List def find_primes(m: int) -> List[int]: Returns a list of all prime numbers less than m. if m <= 2: return [] sieve = [True] * m sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(m ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, m, start): sieve[multiple] = False return [num for num in range(2, m) if sieve[num]]"},{"question":"You are tasked with improving the implementation of the Counting Sort algorithm. The current implementation successfully handles arrays with negative numbers and sorts them in ascending order. However, there is a need to enhance its efficiency, especially in terms of space complexity. # Task: Implement an optimized version of the Counting Sort algorithm with the following constraints: 1. Input is a list `arr` of integers. 2. The list can contain negative integers. 3. Optimize the storage to minimize auxiliary space usage. 4. Maintain the stability of the sorting algorithm. 5. Handle arrays with mixed positive and negative values efficiently. # Input: - A list of integers `arr`, where `1 <= len(arr) <= 10^6`, and the elements within the list are within the range of -10^6 to 10^6. # Output: - A list of integers sorted in ascending order following the constraints and optimizations mentioned. # Example: ```python Example 1: Input: [4, 2, -3, 6, 1, -5, 2, -5, 9] Output: [-5, -5, -3, 1, 2, 2, 4, 6, 9] Example 2: Input: [3, 3, 3, 3, 3] Output: [3, 3, 3, 3, 3] Example 3: Input: [-1, -1, -1, -1] Output: [-1, -1, -1, -1] ``` # Complexities: - Your optimized solution should aim for a time complexity of O(n + k) and a reduced space complexity compared to the current solution. # Note: - Write a function `def optimized_counting_sort(arr):` which takes the list of integers `arr` as input and returns the sorted list.","solution":"def optimized_counting_sort(arr): Optimized Counting Sort algorithm to handle negative numbers and minimize space usage. :param arr: List[int] - list of integers to sort :return: List[int] - sorted list of integers if not arr: return arr # Find the maximum and minimum in the array to handle the range of numbers min_val = min(arr) max_val = max(arr) # Create a count array to store the frequency of each number # Note that we shift index by -min_val to handle negative numbers count_range = max_val - min_val + 1 count = [0] * count_range # Store each number count in the count array for num in arr: count[num - min_val] += 1 # Calculate the start index of each key for i in range(1, count_range): count[i] += count[i - 1] # Place the elements in sorted order in a result array result = [0] * len(arr) for num in reversed(arr): index = count[num - min_val] - 1 result[index] = num count[num - min_val] -= 1 return result"},{"question":"# OrderedStack Implementation Challenge You are to implement the `OrderedStack` class provided in the initial code snippet. The `OrderedStack` maintains the elements in non-decreasing order from the bottom to the top of the stack. **Task**: Complete the `OrderedStack` class by implementing the following methods: 1. `push(item)`: Inserts the item into the stack while maintaining the order. 2. `pop()`: Removes and returns the top item from the stack. 3. `peek()`: Returns the top item from the stack without removing it. 4. `is_empty()`: Returns `True` if the stack is empty, otherwise `False`. 5. `size()`: Returns the number of elements in the stack. **Constraints**: - You are not allowed to use any library function that changes the order of the stack directly (e.g., `sort`). - The elements to be pushed into the stack are comparable (they can be integers, characters, etc., but comparisons can be made). **Input/Output**: - **Input**: A sequence of operations to be performed on the stack. - **Output**: The result of the stack operations (pop, peek) in the sequence they appear. **Example**: ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(4) stack.push(2) print(stack.pop()) # Output: 4 print(stack.peek()) # Output: 3 print(stack.size()) # Output: 3 print(stack.is_empty()) # Output: False ``` **Edge Cases**: - Attempting to pop from an empty stack should raise an `IndexError`. - The stack should maintain order even if duplicate elements are pushed. Implement the `OrderedStack` in Python considering the above constraints and examples.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): temp_stack = [] # Pop elements until finding the right position for the item while self.stack and self.stack[-1] > item: temp_stack.append(self.stack.pop()) self.stack.append(item) # Push the elements back into the main stack while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack)"},{"question":"Question: Implement a Custom Sort for Library System **Scenario**: You are developing a library management system where the primary requirement is to sort the books based on titles in alphabetical order. The system should be efficient enough to handle frequent dynamic updates, such as adding new books, removing old books, and occasionally reordering the entire collection. A bidirectional sort might be beneficial due to frequent insertion/deletion operations. **Task**: Implement a function `custom_library_sort` using the Cocktail Shaker Sort algorithm to sort the list of book titles. The function should sort the titles in alphabetical order. **Function Signature**: ```python def custom_library_sort(book_titles: list) -> list: pass ``` **Input**: * `book_titles` (list of str): A list of book titles, where each title is a string. **Output**: * A list of strings: The list of book titles sorted in alphabetical order. **Constraints**: * Each title is non-empty and can have up to 100 characters. * The list can have up to 1,000 book titles. **Performance Requirements**: * The algorithm should sort the list in-place and return the sorted list. **Example**: ```python titles = [\\"The Hobbit\\", \\"A Tale of Two Cities\\", \\"1984\\", \\"War and Peace\\", \\"Harry Potter\\"] sorted_titles = custom_library_sort(titles) print(sorted_titles) # Output: [\'1984\', \'A Tale of Two Cities\', \'Harry Potter\', \'The Hobbit\', \'War and Peace\'] ``` Implement the function and ensure it handles all edge cases effectively.","solution":"def custom_library_sort(book_titles): Sorts a list of book titles in alphabetical order using the Cocktail Shaker Sort algorithm. if len(book_titles) <= 1: return book_titles n = len(book_titles) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the list from left to right for i in range(start, end): if book_titles[i] > book_titles[i + 1]: book_titles[i], book_titles[i + 1] = book_titles[i + 1], book_titles[i] swapped = True # If nothing moved, then the list is sorted. if not swapped: break # Otherwise, reset the swapped flag so that it # can be used in the next stage swapped = False # Move the end point back by one, because item with largest # value is now at the end of the array end -= 1 # Traverse the list from right to left for i in range(end - 1, start - 1, -1): if book_titles[i] > book_titles[i + 1]: book_titles[i], book_titles[i + 1] = book_titles[i + 1], book_titles[i] swapped = True # Increase the starting point, because the last stage would have # moved the smallest number to the start position start += 1 return book_titles"},{"question":"**Context**: You are working on a system that sends data over a network. The data consists of a list of strings. Your task is to ensure that the list can be transmitted as a single encoded string and decoded back into the original list of strings accurately. # Problem Statement: Write two functions `encode` and `decode`: 1. **encode**: Encodes a list of strings to a single string. 2. **decode**: Decodes the encoded string back to the original list of strings. Function Signatures: ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` Input and Output Formats: - **encode**: - Input: List of strings `strs` where `1 <= len(strs) <= 1000` and `1 <= len(str) <= 1000` for any `str` in `strs`. - Output: A single encoded string. - **decode**: - Input: A single encoded string `s`. - Output: A list of strings. Constraints: - Each string in the list can contain any character, including spaces and special characters. - The encoding must be robust enough to handle potential edge cases such as empty strings and strings with only numerical characters. Performance Requirements: - The implementation should be efficient with a time complexity of O(N) for both encoding and decoding, where N is the total length of all strings combined. # Example: ```python # Example usage: strs = [\\"apple\\", \\"banana\\", \\"carrot\\"] encoded_str = encode(strs) print(encoded_str) # \\"5:apple6:banana6:carrot\\" decoded_list = decode(encoded_str) print(decoded_list) # [\\"apple\\", \\"banana\\", \\"carrot\\"] ``` Notes: - Ensure your code handles various edge cases such as empty strings and lists. - Strongly consider readability and maintainability of the code.","solution":"def encode(strs): Encodes a list of strings to a single string. encoded_string = \'\' for string in strs: encoded_string += f\'{len(string)}@{string}\' return encoded_string def decode(s): Decodes the encoded string back to the original list of strings. decoded_list = [] i = 0 while i < len(s): # Find the position of the separator \'@\' j = i while s[j] != \'@\': j += 1 length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"# Scenario You are implementing a database manager that repeatedly performs efficient in-order traversals over a large Binary Search Tree (BST) without re-initializing the tree traversal state for each iteration. This task involves creating an iterator-based interface that alleviates the need for conventional recursive traversals, optimizing the retrieval of sorted elements. # Task Implement a class `BSTIterator` simulating the next and has_next operations of in-order traversal on a binary search tree (BST). Your implementation should handle various edge cases and perform efficiently with respect to both time and space complexity. Expected Inputs and Outputs - **Input**: A binary search tree node where each node is represented as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - **Expected Interface**: - **`__init__(self, root: TreeNode)`**: Initialize the BSTIterator with the root node of the BST. - **`has_next(self) -> bool`**: Returns `True` if the iterator has more elements, `False` otherwise. - **`next(self) -> int`**: Returns the next smallest number in the BST. Constraints: - All TreeNode values are unique. - The `next` method will be called only if `has_next` returns `True`. - The input tree has at most 10000 nodes. # Example ```python # Example Initialization # Create nodes of the binary tree root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Create the iterator iterator = BSTIterator(root) # Expected Outputs print(iterator.next()) # returns 3 print(iterator.next()) # returns 7 print(iterator.has_next()) # returns True print(iterator.next()) # returns 9 print(iterator.has_next()) # returns True print(iterator.next()) # returns 15 print(iterator.has_next()) # returns True print(iterator.next()) # returns 20 print(iterator.has_next()) # returns False ``` Implement the `BSTIterator` class demonstrating your understanding of in-order traversal by managing the stack explicitly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Question: Implement an Iterator for Pre-Order Traversal of a Binary Search Tree. You are required to implement an iterator class for a binary search tree (BST) that performs pre-order traversal in a lazy manner. The pre-order traversal sequence visits the root node first, then recursively visits the left subtree followed by the right subtree. Your task is to complete the class `PreOrderBSTIterator` using the structure provided below. Your implementation should include the following methods: 1. **`__init__(self, root)`**: Initialize the iterator with the root node of the BST. It\'s guaranteed that `root` will be a valid `TreeNode` object or `None` if the tree is empty. 2. **`has_next(self)`**: Returns `True` if there is a next node in the traversal, otherwise returns `False`. 3. **`next(self)`**: Returns the value of the next node in the pre-order traversal sequence. Constraints: - The input tree nodes will not exceed 10^4. - Each node has an integer value, and the values are unique within the BST. You should ensure that `next()` and `has_next()` operations run in average O(1) time complexity and that the space complexity of your iterator class is O(h), where h is the height of the tree. Here\'s the code structure to get you started: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class PreOrderBSTIterator: def __init__(self, root: TreeNode): # Initialize your data structure here pass def has_next(self) -> bool: # Return True iff there is a next node in the BST pass def next(self) -> int: # Return the next value in the pre-order traversal pass ``` Example: ```python # Constructing the tree # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15, TreeNode(9), TreeNode(20)) # Initializing the iterator iterator = PreOrderBSTIterator(root) # Traversing the BST pre-order while iterator.has_next(): print(iterator.next()) # Output should be 7, 3, 15, 9, 20 ``` Your implementation should handle various edge cases like an empty tree, and trees where nodes only have left or right children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class PreOrderBSTIterator: def __init__(self, root: TreeNode): self.stack = [] if root: self.stack.append(root) def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements in the traversal\\") current_node = self.stack.pop() if current_node.right: self.stack.append(current_node.right) if current_node.left: self.stack.append(current_node.left) return current_node.val"},{"question":"**Scenario**: You are a software developer tasked with implementing and optimizing the Quick Sort algorithm in a time-critical application where performance is crucial. **Task**: Implement an optimized Quick Sort algorithm to sort an array of integers in ascending order. Your implementation should include choosing a good pivot strategy to ensure better average-case performance and avoid the worst-case time complexity. # Function Signature ```python def optimized_quick_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers, where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. # Output - Returns a list of integers sorted in ascending order. # Constraints - Try to enhance the Quick Sort pivot selection to avoid the worst-case time complexity. - Minimize the recursion depth to avoid stack overflow issues. # Examples ```python # Example 1 input: [3, 6, 8, 10, 1, 2, 1] output: [1, 1, 2, 3, 6, 8, 10] # Example 2 input: [1, 4, 3, 9, 6, 2, 8, 5, 7] output: [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 3 input: [0, 0, 0, 0, 0, 0, 0] output: [0, 0, 0, 0, 0, 0, 0] ``` # Note Consider all possible edge cases including: - Arrays with duplicates. - Very large arrays. - Arrays with negative numbers. - Already sorted arrays. - Arrays with all elements being the same.","solution":"from typing import List from random import randint def optimized_quick_sort(arr: List[int]) -> List[int]: This function sorts an array of integers in ascending order using the optimized Quick Sort algorithm with a randomized pivot to avoid worst-case time complexity. def quick_sort_recursive(start, end): if start >= end: return # Choose a random pivot and swap with the first element pivot_index = randint(start, end) arr[start], arr[pivot_index] = arr[pivot_index], arr[start] pivot = arr[start] left = start + 1 right = end while True: while left <= right and arr[left] <= pivot: left += 1 while left <= right and arr[right] >= pivot: right -= 1 if left <= right: arr[left], arr[right] = arr[right], arr[left] else: break arr[start], arr[right] = arr[right], arr[start] quick_sort_recursive(start, right - 1) quick_sort_recursive(right + 1, end) quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"# Cocktail Shaker Sort Implementation Objective: Implement the Cocktail Shaker Sort algorithm to sort a given list of integers in non-decreasing order. Requirements: - Write a function `cocktail_shaker_sort` that takes a list of integers as input and returns the sorted list. - The algorithm should make use of bidirectional passes as described in the analysis. - The function should be optimized to recognize when the array is already sorted, exiting early if no swaps are performed in a pass. Constraints: - The input list can have up to 10,000 elements. - Elements of the list are integers within the range -10^6 to 10^6. - The solution must maintain O(1) additional space complexity (sorting in place). Input: - A list of integers `arr` (1 <= len(arr) <= 10,000). Output: - A list of integers sorted in non-decreasing order. Example: ```python # Example set of inputs input = [3, 2, 5, 4, 1] output = cocktail_shaker_sort(input) print(output) # Expected Output: [1, 2, 3, 4, 5] ``` # Notes: 1. Use the provided `cocktail_shaker_sort` function skeleton. 2. Ensure your solution is efficient and handles all edge cases mentioned in the analysis. 3. Include comments in your code to explain the logic and flow. ```python def cocktail_shaker_sort(arr): def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) swapped = True while swapped: swapped = False for i in range(1, n): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True if swapped == False: return arr swapped = False for i in range(n-1,0,-1): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True return arr ```","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers in non-decreasing order using Cocktail Shaker Sort. Parameters: arr (list): List of integers Returns: list: Sorted list of integers def swap(i, j): Helper function to swap elements at indices i and j in the list arr. arr[i], arr[j] = arr[j], arr[i] n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: swap(i, i + 1) swapped = True if not swapped: break swapped = False end -= 1 # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: swap(i, i - 1) swapped = True start += 1 return arr"},{"question":"# Combination Sum Problem Scenario You are a software developer tasked with creating a feature for a financial application. Your feature involves finding all possible ways to sum up to a specified target amount using a given list of coin denominations. Each combination should be unique in its order even if they sum to the same value. Implement a function `combination_sum` that finds the number of possible combinations of elements in a list that add up to a given target integer. The list will contain only positive integers with no duplicates. # Function Signature: ```python def combination_sum(nums: List[int], target: int) -> int: ``` # Input: * `nums`: A list of positive integers representing the denominations. * `target`: A positive integer representing the target amount. # Output: * An integer representing the number of possible unique combinations. # Constraints: * The input list `nums` contains 1 to 100 elements. * Each element of `nums` is between 1 and 50. * `target` is a positive integer between 1 and 1000. # Example: ```python nums = [1, 2, 3] target = 4 Output: 7 ``` Explanation: The possible combination ways are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1) # Performance Requirements Your method should aim for a time complexity of O(n * target), where `n` is the length of `nums` and `target` is the target sum. # Follow-up What if negative numbers are allowed in the given array? How does it change the problem? What limitation would you need to add to the question to handle negative numbers?","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: Returns the number of possible unique combinations that add up to the target amount. nums: List of positive integers representing the denominations. target: Positive integer representing the target amount. return: Integer representing the number of possible unique combinations. # Initialize a list of zeros with length target + 1 dp = [0] * (target + 1) # There is one way to reach a target of 0, which is to use no elements dp[0] = 1 # Iterate over all possible amounts from 1 to target for i in range(1, target + 1): # Iterate over all coin denominations for num in nums: if i >= num: dp[i] += dp[i - num] # The last element in dp will be the number of ways to reach the target sum return dp[target]"},{"question":"# Run-Length Compression and Decompression Assessment Context Run-Length Encoding (RLE) is used to compress repetitive sequences in data efficiently, whereas Run-Length Decoding is used to revert the compressed data back to its original form. Task Implement two functions: `encode_rle` for compressing a string using Run-Length Encoding and `decode_rle` for decompressing a Run-Length Encoded string back to its original form. Requirements 1. **Function Implementations**: - Write a function `encode_rle(input: str) -> str:` that takes a string `input` and returns its Run-Length Encoded string. - Write a function `decode_rle(input: str) -> str:` that takes a Run-Length Encoded string `input` and returns the original uncompressed string. 2. **Input and Output Formats**: - `encode_rle`: - Input: A string of characters (e.g., \\"aaabbc\\") - Output: A Run-Length Encoded string (e.g., \\"3a2b1c\\") - `decode_rle`: - Input: A valid Run-Length Encoded string (e.g., \\"3a2b1c\\") - Output: The original uncompressed string (e.g., \\"aaabbc\\") 3. **Constraints**: - The input to `encode_rle` will be a non-empty string with only alphabetical characters. - The input to `decode_rle` will be a correctly formatted Run-Length Encoded string. 4. **Edge Cases**: - Handle single character strings. - Handle strings with no repetitions. - Validate that the encode function should not produce an output longer than the input string in scenarios with no excessive repetition. 5. **Performance Requirements**: - Ensure the implemented functions run efficiently on input sizes up to 10^5 characters. Example ```python # Example usage: encoded = encode_rle(\'aaabbc\') # Output: \'3a2b1c\' decoded = decode_rle(\'3a2b1c\') # Output: \'aaabbc\' ``` Write code for `encode_rle` and `decode_rle` functions.","solution":"def encode_rle(input: str) -> str: Encodes the input string using Run-Length Encoding (RLE). if not input: return \\"\\" encoded_parts = [] previous_char = input[0] count = 1 for char in input[1:]: if char == previous_char: count += 1 else: encoded_parts.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 encoded_parts.append(f\\"{count}{previous_char}\\") return \\"\\".join(encoded_parts) def decode_rle(input: str) -> str: Decodes the Run-Length Encoded (RLE) string back to its original form. if not input: return \\"\\" decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded)"},{"question":"# Matrix Chain Multiplication Optimization Context You are working at a software development company tasked with optimizing mathematical operations for scientific computations involving matrices. You are required to implement a dynamic programming solution that determines the most efficient order to multiply a given sequence of matrices, minimizing the total number of scalar multiplications required. Problem Statement Implement a function `matrix_chain_order` that takes an array `p` of integers where the ith matrix has dimensions `p[i-1] x p[i]` and returns a tuple containing two matrices: 1. `matrix[i][j]`: the minimum number of scalar multiplications needed to compute the matrix product for the chain from the ith matrix to the jth matrix. 2. `sol[i][j]`: the position `k` that achieved the minimum cost for the chain from i to j. Additionally, implement a function `print_optimal_solution(sol, i, j)` that prints the optimal parenthesization of the matrix chain. Requirements - **Function 1**: `def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]:` * **Input**: A list of integers `p` with size n+1. * **Output**: Two lists `matrix` and `sol`, each of size `n x n`. - **Function 2**: `def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> None:` * **Input**: 2D List `sol`, and integers `i`, `j`. * **Output**: None. Prints the optimal multiplication sequence to the console. Example Given the dimensions array `p = [30, 35, 15, 5, 10, 20, 25]`: 1. The optimal multiplication sequence should minimize the total number of multiplications. 2. The output of the `matrix_chain_order` function should be two matrices: - `matrix` showing minimum multiplicative costs. - `sol` showing the split points. 3. The `print_optimal_solution` should print the order of multiplication in a readable format. ```python \'\'\' Input: p = [30, 35, 15, 5, 10, 20, 25] Output: No. of Operation required: 15125 Optimal Parenthesization: (((A1A2)(A3A4))((A5A6)A7)) \'\'\' ``` Feel free to offer additional helper functions if necessary to achieve the desired solution. Constraints - The length of array p will be less than or equal to 100. - The dimensions will be positive integers.","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(p) - 1 matrix = [[0 for _ in range(n)] for _ in range(n)] sol = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = (matrix[i][k] + matrix[k+1][j] + p[i]*p[k+1]*p[j+1]) if q < matrix[i][j]: matrix[i][j] = q sol[i][j] = k + 1 return matrix, sol def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i+1}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(sol, i, sol[i][j] - 1) print_optimal_solution(sol, sol[i][j], j) print(\\")\\", end=\\"\\")"},{"question":"# Priority Queue with Custom Operations Context: You are tasked with implementing a priority queue that can perform two operations efficiently: insertion of an element with an associated priority, and extraction of an element with the highest priority (highest integer value). The priority queue should be implemented using a linear array. Objective: Write a Python class `CustomPriorityQueue` with the following methods: 1. `push(item, priority)`: Adds the item with the given priority to the queue. If no priority is provided, the item itself should be used as its priority. 2. `pop()`: Removes and returns the item with the highest priority. Input and Output: 1. Method `push(item, priority)`: * **Input**: item (can be any data type), priority (integer) * **Output**: None 2. Method `pop()`: * **Output**: The item with the highest priority. If there are multiple items with the same highest priority, return the one that was added first. If the queue is empty, return an appropriate message (e.g., \\"Queue is empty\\"). Example Usage: ```python pq = CustomPriorityQueue() pq.push(\'apple\', 3) pq.push(\'banana\', 2) pq.push(\'cherry\', 5) pq.push(\'date\') print(pq.pop()) # Output: \'cherry\' print(pq.pop()) # Output: \'apple\' ``` Constraints: * The priority (if provided) will be an integer. * The queue may have up to 10^5 elements. * The `pop()` method should raise an appropriate exception or return a specific message if the queue is empty.","solution":"class CustomPriorityQueue: def __init__(self): self.queue = [] def push(self, item, priority=None): Adds the item with the given priority to the queue. If no priority is provided, the item itself is used as its priority. if priority is None: priority = item self.queue.append((item, priority)) def pop(self): Removes and returns the item with the highest priority. If there are multiple items with the same highest priority, return the one that was added first. If the queue is empty, return \\"Queue is empty\\". if not self.queue: return \\"Queue is empty\\" # Find the highest priority item max_priority = max(self.queue, key=lambda x: x[1])[1] for index, (item, priority) in enumerate(self.queue): if priority == max_priority: return self.queue.pop(index)[0]"},{"question":"You are tasked to write a function that processes a list of file paths, converting each to its absolute equivalent. The function should handle user home shortcuts (`~`) and provide full valid system paths suitable for file operations. Function Signature ```python def resolve_file_paths(files: List[str]) -> List[str]: pass ``` Input * `files` (List[str]): A list of file path strings that may be relative or contain user shortcuts (`~`). Output * A list of absolute paths corresponding to the input file paths. Constraints * The input list will contain between 1 and 1000 file paths. * Each file path string will have a maximum length of 255 characters. * Input file paths may be non-existent or improperly formatted. Example ```python files = [\\"~/documents/file.txt\\", \\"../dir1/dir2/file2.txt\\", \\"dir/file3.txt\\"] resolve_file_paths(files) # Example Output: # [\'/home/user/documents/file.txt\', \'/absolute/path/dir1/dir2/file2.txt\', \'/absolute/path/to/dir/file3.txt\'] ``` Notes * Consider edge cases such as input of empty strings, paths containing spaces, and improper formatting. * Assume that the function will run on a Unix-based system where the `~` tilde symbol represents the user\'s home directory. # Instructions 1. Implement the function `resolve_file_paths` to take in the list of file paths and return a list of their absolute paths. 2. Use standard library functions (`os.path.abspath` and `os.path.expanduser`) to simplify the implementation. 3. Ensure your code handles edge cases gracefully and does not fail unexpectedly.","solution":"import os from typing import List def resolve_file_paths(files: List[str]) -> List[str]: Converts a list of file paths into their absolute equivalents. Args: files (List[str]): A list of file paths that may be relative or contain user shortcuts (`~`). Returns: List[str]: A list of absolute paths corresponding to the input paths. return [os.path.abspath(os.path.expanduser(file)) for file in files]"},{"question":"You are tasked to implement a simulation-enhanced version of the Bubble Sort algorithm. The function should provide information about its inner workings and the sorting process. # Function Signature ```python def detailed_bubble_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers that you need to sort. - `simulation` (bool): A boolean flag that when set to `True`, prints the intermediate steps of the sorting process, otherwise prints nothing (default is `False`). # Output - Returns a sorted version of the input list. # Requirements 1. Implement the bubble sort algorithm that sorts the input list in ascending order. 2. If `simulation` is enabled, during each swap operation, print the current iteration number and the state of the list after the swap. 3. Consider edge cases such as empty list and single-element list. # Constraints - The length of the list `arr` will be in the range (0 leq |arr| leq 5000). - Each element in the list will be an integer in the range (-10^6) to (10^6). # Example ```python Input: [3, 2, 1], simulation=True Output: iteration 1 : 3 1 2 iteration 2 : 1 3 2 iteration 3 : 1 2 3 Input: [], simulation=True Output: [] Input: [1, 2, 3, 4, 5], simulation=False Output: [1, 2, 3, 4, 5] ``` # Note - Ensure the function handles all described edge cases correctly. - Make sure to optimize for cases where the list may already be sorted to minimize time complexity.","solution":"from typing import List def detailed_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array using bubble sort and provides a detailed simulation if enabled. Parameters: arr (List[int]): The list of integers to sort. simulation (bool): Flag to enable simulation output (default is False). Returns: List[int]: The sorted list. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: print(f\\"iteration {i * (n - 1) + j + 1} : {\' \'.join(map(str, arr))}\\") if not swapped: break return arr"},{"question":"# Prime Check Algorithm Assessment **Objective**: You are tasked with verifying the primality of a sequence of numbers efficiently using an optimized prime-check algorithm. **Task**: Write a function `batch_prime_check` that takes a list of integers and returns a list of True/False values indicating if the corresponding numbers are prime. ```python def batch_prime_check(numbers): Check primality of multiple numbers. Parameters: numbers (list): A list of integers to check for primality. Returns: list: A list of boolean values where True represents a prime number, and False represents a non-prime number. pass ``` **Input Format**: * `numbers`: A list of integers (the list length could be up to 10^6, and the integers can be in the range [-10^9, 10^9]). **Output Format**: * A list of boolean values. * Each boolean value should correspond to whether the number at that index in the input list is a prime number (True) or not (False). **Constraints**: * The function should run efficiently on large inputs with the constraints mentioned. * Use the prime-check algorithm provided as a basis and optimize it, if necessary, to handle large inputs effectively. **Example**: ```python batch_prime_check([2, 3, 4, 5, 6, 7, 8, 9, 10]) # Output: [True, True, False, True, False, True, False, False, False] ``` **Scenario**: This problem simulates a situation where you need to process a large dataset containing user IDs to determine prime IDs in a distributed system. Accurate and efficient performance is crucial to maintain system responsiveness.","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def batch_prime_check(numbers): Check primality of multiple numbers. Parameters: numbers (list): A list of integers to check for primality. Returns: list: A list of boolean values where True represents a prime number, and False represents a non-prime number. return [is_prime(number) for number in numbers]"},{"question":"# Question: You are given a singly linked list where each node contains an integer value. Write two functions to remove duplicate values from this linked list. Implement the `Node` class for the linked list. 1. **Function `remove_dups`:** This function should remove duplicates using an additional data structure (e.g., a hash set). 2. **Function `remove_dups_without_set`:** This function should remove duplicates without using any additional structure. # Requirements: * Your solution should include the implementation of the `Node` class. * You are required to implement both functions. * You are allowed to modify the linked list in place. # Functions to Implement: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the linked list using an additional data structure. :param head: The head node of the linked list. pass def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional data structures. :param head: The head node of the linked list. pass ``` # Input and Output: **Input:** * A singly linked list composed of `Node` objects, potentially with duplicate values. **Output:** * Both functions should modify the linked list in place and not return any value. # Constraints: * The values of the linked list nodes are integers and can be both positive and negative. * The linked list can have up to (10^5) nodes. # Example: Given the linked list: 1 -> 3 -> 2 -> 3 -> 4 -> 1 -> 5 -> None **Function `remove_dups` should output:** 1 -> 3 -> 2 -> 4 -> 5 -> None **Function `remove_dups_without_set` should output:** The same as above, but without additional space utilization.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the linked list using an additional data structure. :param head: The head node of the linked list. if head is None: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional data structures. :param head: The head node of the linked list. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"Question # Binary Search Tree (BST) Implementation and Utility Functions Implement a binary search tree that supports the following functionalities: 1. **Inserting elements** into the tree. 2. **Searching for an element** in the tree. 3. **Calculating the total number of elements** in the tree. 4. **Tree Traversals**: Implement methods to print the tree elements in Preorder, Inorder, and Postorder traversals. # Detailed Specifications 1. **insert(data)**: - Inserts `data` into the BST. If the element already exists, it should not insert again. - Returns `True` if the element was successfully inserted, `False` otherwise. 2. **search(data)**: - Searches for `data` in the BST. - Returns `True` if `data` is found, `False` otherwise. 3. **size()**: - Returns the total number of elements present in the tree. 4. **preorder()**: - Prints elements in Preorder traversal. 5. **inorder()**: - Prints elements in Inorder traversal. 6. **postorder()**: - Prints elements in Postorder traversal. # Example ```python tree = BST() tree.insert(10) tree.insert(6) tree.insert(15) tree.insert(4) tree.insert(9) tree.insert(20) # Traverse the tree tree.preorder() # Output: 10 6 4 9 15 20 tree.inorder() # Output: 4 6 9 10 15 20 tree.postorder() # Output: 4 9 6 20 15 10 # Search for an element print(tree.search(15)) # Output: True print(tree.search(99)) # Output: False # Get the size of the tree print(tree.size()) # Output: 6 ``` Your implementation should handle edge cases such as: - Inserting into an empty tree. - Searching for an element in an empty tree. - Calculating the size of an empty tree. # Constraints - Assume unique integers for elements during insertion (no duplicate elements handled explicitly). - The tree should be managed in memory during runtime; no persistent storage required. # Performance Requirements - Aim for an average time complexity of O(log N) for insert and search operations. Traversal operations should have a complexity of O(N). Write the necessary classes and methods to build this functionality from scratch without using any pre-existing libraries for tree structures.","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.count = 0 def insert(self, data): if self.root is None: self.root = TreeNode(data) self.count += 1 return True else: return self._insert_recursive(self.root, data) def _insert_recursive(self, node, data): if data < node.data: if node.left is None: node.left = TreeNode(data) self.count += 1 return True else: return self._insert_recursive(node.left, data) elif data > node.data: if node.right is None: node.right = TreeNode(data) self.count += 1 return True else: return self._insert_recursive(node.right, data) else: # If data is equal, do not insert again return False def search(self, data): return self._search_recursive(self.root, data) def _search_recursive(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search_recursive(node.left, data) else: return self._search_recursive(node.right, data) def size(self): return self.count def preorder(self): def _preorder(node): if node: elements.append(node.data) _preorder(node.left) _preorder(node.right) elements = [] _preorder(self.root) print(\\" \\".join(map(str, elements))) def inorder(self): def _inorder(node): if node: _inorder(node.left) elements.append(node.data) _inorder(node.right) elements = [] _inorder(self.root) print(\\" \\".join(map(str, elements))) def postorder(self): def _postorder(node): if node: _postorder(node.left) _postorder(node.right) elements.append(node.data) elements = [] _postorder(self.root) print(\\" \\".join(map(str, elements)))"},{"question":"Design a `WordDictionary` class that supports adding words and searching for words where the search can be a literal word or a regular expression made up of letters and the character `.`. Requirements: 1. Implement the `WordDictionary` class with the following methods: * `def add_word(self, word: str) -> None` * `def search(self, word: str) -> bool` Method Descriptions: 1. `add_word(word: str) -> None` * Adds a word into the data structure. 2. `search(word: str) -> bool` * Returns `True` if the word is in the data structure. * A word could contain the dot character `.` to represent any one letter. # Example: ```python wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") print(wordDictionary.search(\\"pad\\")) # Output: False print(wordDictionary.search(\\"bad\\")) # Output: True print(wordDictionary.search(\\".ad\\")) # Output: True print(wordDictionary.search(\\"b..\\")) # Output: True ``` # Constraints: * Words are composed of lowercase English letters and have a maximum length of 500. * Total number of `add_word` and `search` operations will not exceed 10,000. # Performance Requirements: * Ensure that both `add_word` and `search` operations can be performed efficiently to handle up to 10,000 operations promptly.","solution":"class WordDictionary: def __init__(self): self.words = [] def add_word(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re pattern = re.compile(\'^\' + word + \'\') for w in self.words: if pattern.match(w): return True return False"},{"question":"Given a binary tree, implement both iterative and recursive methods to return the postorder traversal of its nodes\' values. # Function Signature ```python def postorder_iterative(root: Node) -> [int]: pass def postorder_recursive(root: Node) -> [int]: pass ``` # Input - `root`: the root node of a binary tree. # Output - A list of integers representing the postorder traversal of the given binary tree\'s nodes. # Constraints - The number of nodes in the tree is at most 10^4. - The value of each node is a unique integer within the range [−10^4, 10^4]. # Example ```python Class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right root = Node(1, None, Node(2, Node(3))) assert postorder_iterative(root) == [3, 2, 1] assert postorder_recursive(root) == [3, 2, 1] ``` # Notes - Ensure your implementations can handle deep trees smoothly. - Consider edge scenarios such as an empty tree or tree with a single node.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> [int]: if not root: return [] stack = [] result = [] last_visited = None current = root while stack or current: if current: stack.append(current) current = current.left else: peek_node = stack[-1] if peek_node.right and last_visited != peek_node.right: current = peek_node.right else: result.append(peek_node.val) last_visited = stack.pop() return result def postorder_recursive(root: Node) -> [int]: result = [] def helper(node): if not node: return helper(node.left) helper(node.right) result.append(node.val) helper(root) return result"},{"question":"Context You are working on a system that needs to encode and decode lists of strings efficiently. Your task is to implement two functions, `encode` and `decode`, that will perform this operation. 1. **encode(strs)**: Encodes a list of strings to a single string. 2. **decode(s)**: Decodes a single string to a list of strings. Input and Output Format * **encode(strs)**: - **Input**: A list of strings, `strs`. - **Output**: A single encoded string. - **Constraints**: * `strs` is a list of strings where each string can contain any characters and can be of any length. * Assumption: The delimiter \':\' is not present in the strings or handle escaping of this character. * **decode(s)**: - **Input**: An encoded string `s`. - **Output**: A list of strings decoded from the input. - **Constraints**: * The input string `s` is guaranteed to be a valid encoded string produced by the `encode` function. Example ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your code here... def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your code here... # Example usage: encoded = encode([\\"hello\\", \\"world\\"]) print(encoded) # Expected Output: \\"5:hello5:world\\" decoded = decode(\\"5:hello5:world\\") print(decoded) # Expected Output: [\\"hello\\", \\"world\\"] ``` Requirements * Implement the encode and decode functions. * The functions should handle all edge cases effectively. * Ensure efficient performance considering time and space complexity. Additional Challenge (Optional) * Adjust the encode function to escape any presence of the delimiter \':\' within the original strings and modify the decode function to handle it correctly.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i, n = 0, len(s) result = [] while i < n: # find next \':\' j = i while s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"# Question: Implementing and Optimizing In-Order Traversal You are provided with a binary tree. Your task is to implement the in-order traversal for this tree. You need to complete two versions of the traversal: an iterative approach and a recursive approach. Also, you need to implement an additional function that would handle the output directly to verify correctness by comparing both methods. Tasks: 1. **Iterative In-Order Traversal**: Implement the function `inorder_iterative` that performs an in-order traversal of a binary tree iteratively. 2. **Recursive In-Order Traversal**: Implement the function `inorder_recursive` that performs an in-order traversal of a binary tree recursively. 3. **Verification**: Implement a function `compare_traversals` that will compare the results of both traversal methods and return `True` if they are the same, otherwise `False`. # Constraints: * The number of nodes in the binary tree: 1 <= n <= 10^4 * The value of the nodes: -10^5 <= node.val <= 10^5 * The binary tree might not be balanced. # Input: A variable `root` that is the root of the binary tree to be traversed. # Output: 1. For `inorder_iterative` and `inorder_recursive`: A list of node values in the order they were visited. 2. For `compare_traversals`: A boolean indicating if the two traversals yield the same results. # Implementation: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root): Iterative In-Order Traversal res = [] stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() res.append(root.val) root = root.right return res def inorder_recursive(root, res=None): Recursive In-Order Traversal if root is None: return [] if res is None: res = [] inorder_recursive(root.left, res) res.append(root.val) inorder_recursive(root.right, res) return res def compare_traversals(root): Compare Iterative and Recursive Traversal Results return inorder_iterative(root) == inorder_recursive(root) # Example Test Case if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert compare_traversals(n1) == True ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root): Iterative In-Order Traversal res = [] stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() res.append(root.val) root = root.right return res def inorder_recursive(root, res=None): Recursive In-Order Traversal if root is None: return [] if res is None: res = [] inorder_recursive(root.left, res) res.append(root.val) inorder_recursive(root.right, res) return res def compare_traversals(root): Compare Iterative and Recursive Traversal Results return inorder_iterative(root) == inorder_recursive(root)"},{"question":"# Cosine Similarity Calculation Question **Context**: In various applications such as text analysis and recommendation systems, calculating the similarity between entities represented as vectors is essential for tasks like clustering, classification, and searching. One common method to measure this similarity is the cosine similarity, which calculates the cosine of the angle between two non-zero vectors. # Task Implement a function to calculate the cosine similarity between two 1-dimensional integer lists. The function should handle edge cases gracefully, raise an error if vectors are of differing lengths, and should account for zero vectors. # Function Signature ```python def cosine_similarity(vec1: List[int], vec2: List[int]) -> float: ``` # Input * `vec1` (List[int]): The first vector. * `vec2` (List[int]): The second vector; must be of the same length as `vec1`. # Output * `float`: The cosine similarity score between `vec1` and `vec2`. # Constraints * Both vectors must be non-empty and have the same length. * Values are integers in the range of -1000 to 1000. * Length of vectors will not exceed 10^4. # Examples ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # output : 0.47140452079103173 cosine_similarity([1, 0, 0], [0, 1, 0]) # output : 0.0 (vectors are orthogonal) cosine_similarity([1, 1, 1], [1, 1, 1]) # output : 1.0 (exact match) ``` # Notes: 1. Vectors of different lengths should raise a ValueError with a clear message. 2. If either vector has only zero values, return 0.0 (since similarity cannot be defined).","solution":"from typing import List import math def cosine_similarity(vec1: List[int], vec2: List[int]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(x * y for x, y in zip(vec1, vec2)) magnitude1 = math.sqrt(sum(x * x for x in vec1)) magnitude2 = math.sqrt(sum(x * x for x in vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0.0 return dot_product / (magnitude1 * magnitude2)"},{"question":"You are tasked with enhancing and fully implementing the RSA encryption system described below. Your enhancements should focus on: 1. Improving the efficiency of prime number generation. 2. Optimizing the calculation of the modular inverse. # Task **Part 1: Efficient Prime Generation** Implement a more efficient version of the prime generation function `gen_prime(k)` that leverages the Miller-Rabin primality test. **Part 2: Optimized Modular Inversion** Implement an optimized version of the `modinv(a, m)` function using the Extended Euclidean Algorithm. **Constraints**: - `k` will be within the range of 4 to 1024. - Ensure the algorithm handles large values efficiently without causing integer overflow issues. # Input/Output Format - **Function 1**: ```python def gen_prime(k: int, seed=None) -> int: # return a k-bit prime number ``` - **Function 2**: ```python def modinv(a: int, m: int) -> int: # return modular inverse of a under modulus m ``` # Expected Performance - Efficient prime generation for values as large as 1024 bits. - Modular inverse calculation should be more efficient than the naive approach. # Scenario RSA encryption relies heavily on generating large prime numbers and computing modular inverses efficiently. By improving these core components, the encryption system becomes more robust and capable of handling secure communications in near real-time. Implement these functions and demonstrate their integration with the provided RSA encryption and decryption framework.","solution":"import random # Miller-Rabin Primality Test def is_prime(n, k=40): Test if a number is a prime if n == 2 or n == 3: return True if n <= 1 or n % 2 == 0: return False # Write (n - 1) as 2^s * d s, d = 0, n - 1 while d % 2 == 0: s += 1 d //= 2 # Witness loop for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(s - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def gen_prime(k, seed=None): Generate a k-bit prime number if seed is not None: random.seed(seed) while True: # Generate a random k-bit number num = random.getrandbits(k) # Ensure it is an odd number in the specified range num |= (1 << k - 1) | 1 if is_prime(num): return num # Optimized modular inversion using Extended Euclidean Algorithm def modinv(a, m): Calculate the modular inverse of a under modulo m def extended_gcd(aa, bb): Extended greatest common divisor algorithm last_remainder, remainder = abs(aa), abs(bb) x, last_x, y, last_y = 0, 1, 1, 0 while remainder: last_remainder, (quotient, remainder) = remainder, divmod(last_remainder, remainder) x, last_x = last_x - quotient * x, x y, last_y = last_y - quotient * y, y return last_remainder, last_x * (-1 if aa < 0 else 1), last_y * (-1 if bb < 0 else 1) g, x, _ = extended_gcd(a, m) if g != 1: raise ValueError(f\\"No modular inverse exists for {a} under modulo {m}\\") return x % m"},{"question":"# Longest Palindromic Substring Challenge # Background As a software developer, you are working on improving the search functionality of a text editor. One of the requirements is to highlight the longest palindromic substring within any given string. A palindrome is a string that reads the same forward and backward, like \\"radar\\" or \\"level\\". # Task Your task is to implement a function, `longest_palindrome`, that takes a single input string and returns the longest palindromic substring. You need to employ Manacher\'s Algorithm which operates in linear time. # Function Signature ```python def longest_palindrome(s: str) -> str: ``` # Input - A single string `s` (1 <= |s| <= 1000), where `|s|` denotes the length of the string. # Output - Return a single string which is the longest palindromic substring. # Examples ```python >>> longest_palindrome(\\"dasdasdasdasdasdadsa\\") \\"asdadsa\\" >>> longest_palindrome(\\"acdbbdaa\\") \\"dbbd\\" ``` # Constraints - If there are multiple solutions, return the leftmost one. - You must use Manacher\'s Algorithm to solve this problem. # Important Points - Ensure that the input string transformation and palindrome expansion logic correctly handle all edge cases. - Optimize your solution for performance, adhering to O(n) time complexity.","solution":"def longest_palindrome(s: str) -> str: # Transform the input string to handle even length palindromes uniformly T = \'#\' + \'#\'.join(s) + \'#\' n = len(T) P = [0] * n C = 0 # Center of the current palindrome R = 0 # Right boundary of the current palindrome for i in range(n): mirror = 2 * C - i # Mirror of the current position i if i < R: P[i] = min(R - i, P[mirror]) # Attempt to expand the palindrome centered at i while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and T[i + P[i] + 1] == T[i - P[i] - 1]: P[i] += 1 # Update the center and right boundary if i + P[i] > R: C = i R = i + P[i] # Find the maximum length and its center max_len = max(P) center = P.index(max_len) # Extract the longest palindromic substring start = (center - max_len) // 2 return s[start:start + max_len]"},{"question":"You are given an array of integers which is not sorted. Implement the Gnome Sort algorithm to sort the array in non-decreasing order. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers `arr` where (1 leq |arr| leq 10^6). # Output * The function should return a new list of integers sorted in non-decreasing order. # Constraints * The elements in `arr` are integers in the range ([-10^6, 10^6]). * The function must sort the array in-place and return it. # Performance Requirements * The algorithm must handle the worst-case time complexity of (O(n^2)). * The space complexity should remain (O(1)). # Examples ```python gnome_sort([34, 2, 10, -9]) # Output: [-9, 2, 10, 34] gnome_sort([5, 4, 3, 2, 1]) # Output: [1, 2, 3, 4, 5] gnome_sort([10]) # Output: [10] gnome_sort([]) # Output: [] ``` Your task is to implement the function according to the specifications provided above.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Perform gnome sort on the array and return the sorted array. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"You are tasked with writing a function `filter_elements(lst, N)` that filters elements in the list `lst` such that each element can appear at most `N` times, and the order of elements should be preserved. Your implementation should be efficient for large lists. # Function Signature ```python def filter_elements(lst: List[int], N: int) -> List[int]: ``` # Input * `lst`: A list of integers. Example: `[1, 2, 3, 1, 2, 1, 2, 3]` * `N`: An integer representing the maximum number of times each element can appear in the list. Example: `2` # Output * Returns a list of integers where each element from the original list appears at most `N` times and the order is preserved. Example: `[1, 2, 3, 1, 2, 3]` # Constraints * `0 ≤ len(lst) ≤ 10^5` * `0 ≤ N ≤ len(lst)` # Example ```python assert filter_elements([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert filter_elements([], 1) == [] assert filter_elements([4, 4, 4, 4], 0) == [] assert filter_elements([1, 2, 3], 1) == [1, 2, 3] ``` # Explanation * For the first example, the input list is `[1, 2, 3, 1, 2, 1, 2, 3]` and `N` is 2. After filtering, each number should appear at most 2 times without changing the order of original elements in the input list. Therefore, the result is `[1, 2, 3, 1, 2, 3]`. # Notes * Think about how to efficiently keep track of counts while iterating through the list. * Your solution should aim to have a linear time complexity with respect to the length of the input list.","solution":"from collections import defaultdict def filter_elements(lst, N): Filters elements in lst ensuring each element appears at most N times preserving the order. Parameters: lst (List[int]): The list of integers. N (int): The maximum number of appearances for each integer. Returns: List[int]: A list of integers filtered according to the specified conditions. if N == 0: return [] count = defaultdict(int) result = [] for number in lst: if count[number] < N: result.append(number) count[number] += 1 return result"},{"question":"# Context You are building a basic calculator for evaluating expressions provided as strings in postfix notation (Reverse Polish Notation - RPN). Postfix notation is a mathematical notation in which operators follow their operands (e.g., `3 4 +` means `3 + 4`). # Task Implement a function `evaluate_postfix(expression: str) -> int` that evaluates an expression in postfix notation and returns the result. You must use the provided Stack ADT implementation. # Input & Output Formats * **Input**: A string `expression` containing a postfix notation expression. * The expression may contain integers and the operators `+`, `-`, `*`, `/`. * Operands and operators are separated by spaces. * **Output**: An integer representing the evaluation result of the postfix expression. # Constraints * The expression will be valid and won\'t require additional validation. * Division should be integer division. # Example 1. **Input**: `\\"3 4 + 2 * 7 /\\"` **Output**: `2` **Explanation**: The steps to evaluate are as follows: ``` push(3), push(4), pop -> 4, pop -> 3, push(3 + 4), push(7), push(2), push(7 * 2), push(14), push(7), pop -> 7, pop -> 14, push(14 // 7) which is 2 ``` # Hints 1. Loop through the expression tokens. 2. Use the stack to push operands. 3. On encountering an operator, pop two operands from the stack, apply the operator, and push the result back onto the stack. 4. After processing all tokens, the result will be on the top of the stack. ```python def evaluate_postfix(expression: str) -> int: Evaluates an expression in postfix notation and returns the result. :param expression: str: Postfix expression :return: int: Evaluation result # Implement logic using Stack ADT pass ``` # Note You should demonstrate your understanding of both stack implementations provided (ArrayStack and LinkedListStack) to solve the problem, and then choose one that suits this context best to write your solution.","solution":"class Stack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Pop from an empty stack\\") return self.stack.pop() def is_empty(self): return len(self.stack) == 0 def evaluate_postfix(expression: str) -> int: Evaluates an expression in postfix notation and returns the result. :param expression: str: Postfix expression :return: int: Evaluation result stack = Stack() tokens = expression.split() for token in tokens: if token.isdigit() or (token[0] == \'-\' and token[1:].isdigit()): # Considering negative numbers stack.push(int(token)) else: operand2 = stack.pop() operand1 = stack.pop() if token == \'+\': result = operand1 + operand2 elif token == \'-\': result = operand1 - operand2 elif token == \'*\': result = operand1 * operand2 elif token == \'/\': result = int(operand1 / operand2) # Integer division stack.push(result) return stack.pop()"},{"question":"# Question: Generating Unique Combination Sets Scenario You are a software developer working for a company that deals with large sets of data. Your current task is to implement a function that generates all possible subsets from a given set of distinct integers. This function is crucial for the company\'s feature testing processes where all potential feature combinations need to be analyzed. Task Write a function **generate_subsets(nums)** that takes as input a list of distinct integers and returns a list of lists, where each list represents a unique subset of the input numbers. The function should generate all possible subsets. Input and Output Formats * **Input**: A list of distinct integers, (*nums*). * Example: ([1, 2, 3]) * **Output**: A list of lists where each sublist is a unique subset of the input list. * Example: ([[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]) Constraints * The input list length will not exceed 16 (i.e., (0 leq text{len(nums)} leq 16)). * The integers in the input list are unique. Performance Requirements * Time complexity should be (O(2^n)). * The solution must be efficient with respect to both time and space, given the size constraints. ```python def generate_subsets(nums): # Your code here pass ``` Hints * You may use either a backtracking strategy or an iterative approach to solve this problem. * Make sure to handle edge cases like an empty input list. * Consider the space complexity and try to avoid deep recursion if you can.","solution":"def generate_subsets(nums): Generates all possible subsets of a given list of distinct integers. result = [[]] # Start with the empty set for num in nums: # For each number in nums, add it to all existing subsets result += [current + [num] for current in result] return result"},{"question":"# Ternary Search Implementation **Context**: Ternary search is an efficient algorithm to find an element in a sorted array by repeatedly dividing the array into three segments and narrowing down the possible location of the key. **Objective**: Implement a function that uses ternary search to find an element in a sorted array of integers. **Function Signature**: ```python def ternary_search(arr: List[int], key: int) -> int: Find the given key in an array sorted in ascending order. :param arr: List[int] - a list of integers sorted in ascending order. :param key: int - the integer value to search for. :return: int - the index of the key in the array if found, otherwise -1. ``` **Input**: * `arr`: A list of integers sorted in ascending order. Length of the array is between 0 and 10^5. * `key`: An integer value to search for. **Output**: * An integer representing the index of the key in the array if found. Returns -1 if the key is not present in the array. **Constraints**: * The function must have a time complexity of O(log3(N)). * The array might be empty; handle this case gracefully. * The array can contain negative numbers. **Example**: ```python assert ternary_search([1, 2, 3, 4, 5], 3) == 2 assert ternary_search([1, 2, 3, 4, 5], 6) == -1 assert ternary_search([-5, -1, 0, 3, 7], -1) == 1 assert ternary_search([], 1) == -1 ``` **Note**: - Avoid using any standard searching functions like `bisect` from Python library. - You must divide the array into three parts and handle the search accordingly.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: Find the given key in an array sorted in ascending order. :param arr: List[int] - a list of integers sorted in ascending order. :param key: int - the integer value to search for. :return: int - the index of the key in the array if found, otherwise -1. def search(left, right): if left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(left, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, right) else: return search(mid1 + 1, mid2 - 1) return -1 return search(0, len(arr) - 1)"},{"question":"# Question: In a transportation logistics company, you have been tasked to build a system to find the shortest travel route between different warehouses. The city map is modeled as a weighted directed graph where nodes represent warehouses, and edges represent direct travel routes with non-negative travel times. Objective: Implement a function `shortest_path(matrix: List[List[int]], src: int) -> List[int]` that uses Dijkstra\'s algorithm to compute the minimum travel time from a source warehouse to all other warehouses. Input: * `matrix`: A `List[List[int]]` adjacency matrix representing the graph, where `matrix[i][j]` is the travel time from warehouse `i` to warehouse `j`. If there is no direct travel route from `i` to `j`, `matrix[i][j]` will be a large value representing infinity. * `src`: An integer representing the source warehouse. Output: * A list where the `i-th` element represents the shortest travel time from the source warehouse to the `i-th` warehouse. Constraints: * 1 <= number of warehouses <= 100 (You can assume the number of warehouses is represented by the size of the matrix). * All travel times are non-negative integers. Performance Requirements: * Your solution should have a time complexity of O(V^2). Example: ```python matrix = [ [0, 4, 8, float(\'inf\')], [float(\'inf\'), 0, 2, 6], [float(\'inf\'), float(\'inf\'), 0, 3], [float(\'inf\'), float(\'inf\'), float(\'inf\'), 0] ] src = 0 print(shortest_path(matrix, src)) # Output: [0, 4, 6, 9] ``` In this example, the shortest paths from warehouse 0 to each warehouse are: * To warehouse 0: cost 0 * To warehouse 1: cost 4 * To warehouse 2: cost 6 (via 1 -> 2 with total cost 4 + 2) * To warehouse 3: cost 9 (via 1 -> 2 -> 3 with total cost 4 + 2 + 3) Write your implementation here:","solution":"import heapq from typing import List def shortest_path(matrix: List[List[int]], src: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest path from a source warehouse to all other warehouses in a graph represented as an adjacency matrix. n = len(matrix) # distances array to store the minimum distance to each warehouse distances = [float(\'inf\')] * n distances[src] = 0 # priority queue to process the nodes pq = [(0, src)] while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for v in range(n): if matrix[u][v] != float(\'inf\'): distance = current_distance + matrix[u][v] if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances"},{"question":"In a system, processes are represented as vertices of a directed graph and resource holding/waiting relations as directed edges between these vertices. For the system to work without deadlocks, it\'s crucial to ensure no cycles exist in the graph. You are tasked with writing a function to determine if a directed graph contains any cycles. If a cycle is present, the system could enter a deadlock state. Function Details: ```python def contains_cycle(graph): Determines if there is a cycle in the given directed graph. :param graph: A dictionary where keys are vertices and values are lists of neighboring vertices, representing directed edges from the key vertex to each vertex in the list. Example: {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} :return: True if there\'s a cycle in the graph, False otherwise. # Example usage: graph = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} print(contains_cycle(graph)) # Expected output: True, because of the cycle B -> D -> E -> B graph2 = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [], \'D\': [\'E\'], \'E\': []} print(contains_cycle(graph2)) # Expected output: False, no cycle ``` Constraints: * The graph will be represented as an adjacency list in a dictionary. * All vertices are unique strings. * The graph might be disconnected. * The graph will not contain isolated self-loops (vertex pointing to itself). Your implementation should efficiently determine if there\'s a cycle and return the correct result.","solution":"def contains_cycle(graph): Determines if there is a cycle in the given directed graph. :param graph: A dictionary where keys are vertices and values are lists of neighboring vertices, representing directed edges from the key vertex to each vertex in the list. Example: {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} :return: True if there\'s a cycle in the graph, False otherwise. def dfs(vertex, visited, rec_stack): visited[vertex] = True rec_stack[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[vertex] = False return False visited = {vertex: False for vertex in graph} rec_stack = {vertex: False for vertex in graph} for vertex in graph: if not visited[vertex]: if dfs(vertex, visited, rec_stack): return True return False"},{"question":"# Context You are working on a text-processing module that needs to detect small substrings within larger repetitive blocks of text. One part of this module involves repeating a given string until another string is a substring within the repeated sequence. # Objective Write a function named `repeat_string_match` which aims to compute the minimum number of times a string `A` needs to be repeated such that another string `B` is a substring of this repeated sequence. # Function Signature ```python def repeat_string_match(A: str, B: str) -> int: ``` # Input * `A`: A string of length between 1 and 10000. * `B`: A string of length between 1 and 10000. # Output * Return an integer representing the minimum number of times `A` must be repeated so that `B` is a substring of the repeated sequence. If no amount of repetition of `A` can result in `B` being a substring, return -1. # Constraints * The length of `A` and `B` will be between 1 and 10000. # Examples ```python A = \\"abcd\\" B = \\"cdabcdab\\" # B is a substring of \\"abcdabcdabcd\\" but not \\"abcdabcd\\". Therefore, the function should return 3. assert repeat_string_match(A, B) == 3 A = \\"a\\" B = \\"aa\\" # Repeating \\"a\\" two times (\\"aa\\") will include B. Therefore, the function should return 2. assert repeat_string_match(A, B) == 2 A = \\"abc\\" B = \\"cabcabca\\" # B is a substring of \\"abcabcabcabc\\", hence the function should return 4. assert repeat_string_match(A, B) == 4 A = \\"abc\\" B = \\"xyz\\" # There\'s no repetition of \\"abc\\" that can include B. Therefore, the function should return -1. assert repeat_string_match(A, B) == -1 ``` # Constraints & Requirements * You cannot use direct library functions for pattern matching. * Aim to optimize for both time and space complexity. * Handle edge cases where the repetition number might be minimal or where `B` is not present despite multiple repetitions.","solution":"def repeat_string_match(A: str, B: str) -> int: This function computes the minimum number of times string A needs to be repeated for string B to be a substring. times = 1 repeated_A = A # The maximum times A needs to be repeated would be len(B) // len(A) + 2 max_repeats = len(B) // len(A) + 2 while times <= max_repeats: if B in repeated_A: return times repeated_A += A times += 1 return -1"},{"question":"Path Sum in a Binary Tree You are provided with a binary tree and a target sum. Your task is to find all root-to-leaf paths where each path’s sum equals the given target sum. A root-to-leaf path is defined as a path starting from the root and ending at any leaf node. Input * The root of a binary tree. Each node contains an integer value. * An integer `sum` representing the target path sum. Output * A list of lists, where each list represents a root-to-leaf path with elements whose sum equals the target `sum`. Constraints * The number of nodes in the tree is in the range [0, 1000]. * Each node’s value is in the range [-1000, 1000]. Requirements * Implement a function `path_sum(root, sum)` that returns all root-to-leaf paths where each path\'s sum equals the given sum. * Ensure that your implementation efficiently handles the constraints and edge cases. # Example Given the below binary tree and sum = 22, ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` You should return: ``` [ [5,4,11,2], [5,8,4,5] ] ``` Hints: - Consider implementing both DFS and BFS approaches and discuss their efficiency in the context of your solution. - Ensure to consider edge cases such as empty trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target): def dfs(node, current_path, remaining_sum): if not node: return current_path.append(node.val) # Check if it\'s a leaf node and the path sum equals target if not node.left and not node.right and node.val == remaining_sum: result.append(current_path[:]) # Recursive DFS on left and right children dfs(node.left, current_path, remaining_sum - node.val) dfs(node.right, current_path, remaining_sum - node.val) # Backtrack current_path.pop() result = [] dfs(root, [], target) return result"},{"question":"Ternary Search Enhancement You are given a sorted array of integers and you need to implement a function to find the index of a given element using the ternary search algorithm. In case the element is not found, the function should return -1. **Function Signature**: ```python def ternary_search_enhanced(left: int, right: int, key: int, arr: List[int]) -> int: ``` **Input**: - `left` (int): the starting index of the array segment to search. - `right` (int): the ending index of the array segment to search. - `key` (int): the element to search for. - `arr` (List[int]): a list of integers sorted in ascending order. **Output**: - (int): the index of `key` if found, otherwise -1. **Constraints**: - The array will be of length `n` where `1 <= n <= 10^6`. - The elements of array will be within the range `-10^9` to `10^9`. - `left` and `right` are valid indices of the array (0 <= left <= right < n). # Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7] result = ternary_search_enhanced(0, 6, 4, arr) print(result) # Output: 3 # Example 2 arr = [1, 2, 3, 4, 5, 6, 7] result = ternary_search_enhanced(0, 6, 8, arr) print(result) # Output: -1 # Example 3 arr = [5, 10, 15, 20, 25] result = ternary_search_enhanced(0, 4, 10, arr) print(result) # Output: 1 ``` **Explanation**: In example 1, the element `4` is found at index `3`. In example 2, the element `8` is not present in the array, so the function returns `-1`. In example 3, the element `10` is found at index `1`. # Notes - Carefully handle integer division to avoid precision issues. - Consider edge cases such as an element not being present and arrays of minimal length. This question assesses students\' ability to implement a search algorithm (ternary search) and understand its intricacies, as well as to handle edge cases and constraints effectively.","solution":"from typing import List def ternary_search_enhanced(left: int, right: int, key: int, arr: List[int]) -> int: while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Objective Implement an optimized version of a maximum flow algorithm using Dinic\'s method for a given flow network. Your implementation should maximize efficiency by correctly handling the residual graph and level graph to find augmenting paths efficiently. Problem Statement You are given a directed flow network with `n` vertices and `m` edges where each edge has a capacity. Your task is to implement Dinic\'s algorithm to compute the maximum flow from a given `source` vertex to a `sink` vertex. Function Signature ```python def compute_maximum_flow(n: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> int: ``` Input 1. `n` (int): Number of vertices in the graph. 2. `edges` (List[Tuple[int, int, int]]): A list of tuples where each tuple `(u, v, c)` represents an edge from vertex `u` to vertex `v` with capacity `c`. 3. `source` (int): The source vertex. 4. `sink` (int): The sink vertex. Output - `int`: The maximum flow from `source` to `sink`. Constraints - (1 leq n leq 500) - (0 leq u, v < n) - Edge capacities are non-negative and do not exceed (10^9). Example ```python n = 4 edges = [(0, 1, 100), (0, 2, 100), (1, 2, 1), (1, 3, 100), (2, 3, 100)] source = 0 sink = 3 assert compute_maximum_flow(n, edges, source, sink) == 200 ``` # Implementation Notes 1. You should implement helper functions to manage BFS and DFS as described in Dinic\'s algorithm. 2. Ensure efficient management of residual capacities and the level graph. 3. Provide thorough error handling for edge cases such as disconnected graphs or zero capacity edges.","solution":"from collections import deque, defaultdict from typing import List, Tuple class Dinic: def __init__(self, n): self.n = n self.edges = defaultdict(list) self.capacity = {} self.level = {} self.ptr = {} def add_edge(self, u, v, capacity): if (u, v) not in self.capacity: self.edges[u].append(v) self.edges[v].append(u) self.capacity[(u, v)] = 0 self.capacity[(v, u)] = 0 self.capacity[(u, v)] += capacity def bfs(self, source, sink): self.level = {i: -1 for i in range(self.n)} queue = deque([source]) self.level[source] = 0 while queue: node = queue.popleft() for neighbor in self.edges[node]: if self.level[neighbor] < 0 and self.capacity[(node, neighbor)] > 0: self.level[neighbor] = self.level[node] + 1 queue.append(neighbor) return self.level[sink] >= 0 def dfs(self, node, sink, flow): if node == sink or flow == 0: return flow for i in range(self.ptr[node], len(self.edges[node])): neighbor = self.edges[node][i] if self.level[neighbor] == self.level[node] + 1 and self.capacity[(node, neighbor)] > 0: pushed = self.dfs(neighbor, sink, min(flow, self.capacity[(node, neighbor)])) if pushed > 0: self.capacity[(node, neighbor)] -= pushed self.capacity[(neighbor, node)] += pushed return pushed self.ptr[node] += 1 return 0 def max_flow(self, source, sink): total_flow = 0 while self.bfs(source, sink): self.ptr = {i: 0 for i in range(self.n)} while True: flow = self.dfs(source, sink, float(\'inf\')) if flow == 0: break total_flow += flow return total_flow def compute_maximum_flow(n: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> int: dinic = Dinic(n) for u, v, capacity in edges: dinic.add_edge(u, v, capacity) return dinic.max_flow(source, sink)"},{"question":"You are tasked with writing a function to find special numbers within a specified range. These special numbers have the property that the sum of their digits raised to consecutive powers equals the number itself. # Function Specification **Function Name**: `find_special_numbers` **Input**: - `low`: an integer representing the lower bound of the range (inclusive). - `high`: an integer representing the upper bound of the range (inclusive). **Output**: - A list of integers that satisfy the property described. # Constraints - 1 ≤ `low` ≤ `high` ≤ 10^6 - The range specified by `low` and `high` can be large, you must ensure that your solution is efficient within these limits. # Requirements 1. **Efficient Implementation**: Your function should be optimized for performance especially when dealing with larger ranges. 2. **Edge Case Handling**: The function should appropriately handle edge cases, such as no valid numbers in the given range. 3. **Correctness**: Ensure that the output list contains only numbers that strictly meet the criteria. # Example ```python def find_special_numbers(low, high): result = [] for number in range(low, high + 1): exponent = 1 summation = 0 number_as_string = str(number) tokens = [int(digit) for digit in number_as_string] for digit in tokens: summation += digit ** exponent exponent += 1 if summation == number: result.append(number) return result # Example usage: assert find_special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_special_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_special_numbers(90, 150) == [135] print(find_special_numbers(1, 1000)) # Expected output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135, 175, 518, 598] ``` # Tips - Carefully consider the iteration and digit extraction processes to maintain efficient execution. - Test your function thoroughly with both small and large values to ensure reliability and performance.","solution":"def find_special_numbers(low, high): Find numbers within the given range that are equal to the sum of their digits raised to consecutive powers. def calculate_special_number_sum(number): str_num = str(number) return sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str_num)) result = [] for number in range(low, high + 1): if number == calculate_special_number_sum(number): result.append(number) return result"},{"question":"# Transitive Closure of a Directed Graph Context In computer science, the transitive closure of a directed graph is a measure that helps determine the reachability of nodes. It tells whether there is a path from node **i** to node **j** for all possible pairs of nodes (i, j) in the graph. Given a directed graph, implement an algorithm to compute its transitive closure using the Depth First Search (DFS) method. Problem Statement You are required to implement a class `Graph` that can: 1. Initialize a graph with a given number of vertices. 2. Add directed edges to the graph. 3. Compute and return the transitive closure matrix of the graph. The class should support the following operations: * `__init__(self, vertices: int)`: Constructor to initialize the graph with `vertices` vertices and prepare necessary structures. * `add_edge(self, source: int, target: int)`: Add a directed edge from `source` to `target`. * `transitive_closure(self) -> List[List[int]]`: Compute the transitive closure for the graph and return it as a 2D list. Input * The number of vertices (V) (1 <= V <= 100) * A list of edges where each edge is represented as a tuple ((source, target)) Output * The transitive closure matrix as a list of lists, where an entry ((i, j)) is 1 if there is a path from node (i) to node (j), and 0 otherwise. Constraints * The graph can have at most 100 vertices. * The edges are directed, and there can be up to (V^2) edges. Method Signature ```python class Graph: def __init__(self, vertices: int): pass def add_edge(self, source: int, target: int): pass def transitive_closure(self) -> List[List[int]]: pass ``` Example ```python # Example usage graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) closure = graph.transitive_closure() # Expected output # [ # [1, 1, 1, 1], # [1, 1, 1, 1], # [1, 1, 1, 1], # [0, 0, 0, 1] # ] ``` Implement the `Graph` class and the specified methods to solve this problem.","solution":"from typing import List class Graph: def __init__(self, vertices: int): self.vertices = vertices self.adj_matrix = [[0 for _ in range(vertices)] for _ in range(vertices)] def add_edge(self, source: int, target: int): self.adj_matrix[source][target] = 1 def transitive_closure(self) -> List[List[int]]: closure = [[0 for _ in range(self.vertices)] for _ in range(self.vertices)] def dfs(source: int, target: int): if closure[source][target] == 0: closure[source][target] = 1 for next_vertex in range(self.vertices): if self.adj_matrix[target][next_vertex] == 1: dfs(source, next_vertex) for i in range(self.vertices): dfs(i, i) return closure"},{"question":"# ZigZag Iterator for K Lists You are given a list of `k` lists (each list containing integers). Implement a `ZigZagIteratorK` class that facilitates iteration through the `k` lists in a zigzag order. The iterator should return one element from each of the lists in a round-robin fashion until all elements have been returned. If a list is exhausted, it should not participate in the further round of iteration. Implement the following methods for the `ZigZagIteratorK` class: 1. `__init__(self, vecs: List[List[int]])`: Initialize the iterator with `k` lists. 2. `next(self) -> int`: Return the next element in the zigzag order. 3. `has_next(self) -> bool`: Return `True` if there are more elements to return. # Constraints * The elements in each list are integers. * Your implementation should be efficient with regard to time and space complexity for large numbers of lists and elements. # Example ```python vecs = [[1, 3, 5], [2, 4, 6, 8], [7, 9]] iterator = ZigZagIteratorK(vecs) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 2, 7, 3, 4, 9, 5, 6, 8] ``` # Notes 1. Use the input/output examples to verify your implementation. 2. Ensure that you handle edge cases, such as empty lists or lists with different lengths. 3. Be mindful of performance considerations while applying operations on lists in each iteration.","solution":"from collections import deque from typing import List class ZigZagIteratorK: def __init__(self, vecs: List[List[int]]): self.queue = deque((i, 0) for i in range(len(vecs)) if vecs[i]) # Each tuple is (list index, element index) self.vecs = vecs def next(self) -> int: if self.has_next(): list_idx, elem_idx = self.queue.popleft() result = self.vecs[list_idx][elem_idx] if elem_idx + 1 < len(self.vecs[list_idx]): self.queue.append((list_idx, elem_idx + 1)) return result else: raise ValueError(\\"No more elements\\") def has_next(self) -> bool: return bool(self.queue)"},{"question":"Given two strings `word_a` and `word_b`, write a function `min_operations_to_transform(word_a, word_b)` to calculate the minimum number of operations required to transform `word_a` into `word_b`. The allowed operations are: 1. Inserting a character 2. Deleting a character 3. Substituting one character for another Return the minimum number of operations required. # Input Format * Two strings, `word_a` and `word_b`, with lengths `length_a` and `length_b` respectively. # Output Format * An integer representing the minimum number of operations required to transform `word_a` into `word_b`. # Constraints * `1 <= length_a, length_b <= 1000` * The strings will consist only of lowercase/uppercase English letters. # Example ```python assert min_operations_to_transform(\\"kitten\\", \\"sitting\\") == 3 assert min_operations_to_transform(\\"intention\\", \\"execution\\") == 5 assert min_operations_to_transform(\\"ab\\", \\"abc\\") == 1 ``` # Note * For the first example: - kitten -> sitten (substitution) - sitten -> sittin (substitution) - sittin -> sitting (insertion) * For the second example: - intention -> exention (substitution) - exention -> exection (substitution) - exection -> execute (substitution) - execute -> execution (insertion) * For the third example: - ab -> abc (insertion) Implement the function `min_operations_to_transform(word_a, word_b)` that follows the dynamic programming approach discussed in the analysis. ```python def min_operations_to_transform(word_a, word_b): # Implement the function to return the minimum number of operations. ```","solution":"def min_operations_to_transform(word_a, word_b): Calculate the minimum number of operations required to transform `word_a` into `word_b`. The allowed operations are: 1. Inserting a character 2. Deleting a character 3. Substituting one character for another length_a = len(word_a) length_b = len(word_b) # Create a table to store results of subproblems dp = [[0] * (length_b + 1) for _ in range(length_a + 1)] # Initialize dp table for i in range(length_a + 1): for j in range(length_b + 1): if i == 0: dp[i][j] = j # If word_a is empty, insert all characters of word_b elif j == 0: dp[i][j] = i # If word_b is empty, delete all characters of word_a elif word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[length_a][length_b]"},{"question":"# Lowest Common Ancestor in a BST Given a binary search tree (BST), your task is to find the lowest common ancestor (LCA) of two given nodes in the BST. Scenario: You are working on a hierarchical project management tool that uses a BST to store various projects and their dependencies. Your tool needs to determine the closest common dependency between any two given projects efficiently. Task: Write a function `lowest_common_ancestor(root, p, q)` that returns the lowest common ancestor of two nodes `p` and `q` in a Binary Search Tree. You are guaranteed that both `p` and `q` are present in the BST. Function Signature: ```python def lowest_common_ancestor(root, p, q): :type root: Node :type p: Node :type q: Node :rtype: Node ``` Input: - `root`: The root of the BST. - `p` and `q`: The two nodes for which the LCA needs to be found. Output: - Return the node representing the lowest common ancestor of `p` and `q`. Example: ```python class Node: def __init__(self, x): self.val = x self.left = None self.right = None # Constructing the example tree # _______6______ # / # ___2__ ___8__ # / / # 0 _4 7 9 # / # 3 5 # Example nodes: root = Node(6) root.left = Node(2) root.right = Node(8) root.left.left = Node(0) root.left.right = Node(4) root.left.right.left = Node(3) root.left.right.right = Node(5) root.right.left = Node(7) root.right.right = Node(9) p = root.left # Node 2 q = root.right # Node 8 # The lowest common ancestor of nodes 2 and 8 is 6. print(lowest_common_ancestor(root, p, q).val) # Output: 6 p = root.left # Node 2 q = root.left.right # Node 4 # The lowest common ancestor of nodes 2 and 4 is 2. print(lowest_common_ancestor(root, p, q).val) # Output: 2 ``` **Constraints**: - All Node values are unique. - `p` and `q` will exist in the BST. **Additional Requirements**: - Make sure your solution is efficient with an expected time complexity of O(H) where H is the height of the tree.","solution":"class Node: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root, p, q): Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. :type root: Node :type p: Node :type q: Node :rtype: Node # Start from the root of the tree current = root while current: # If both nodes p and q are smaller than current, LCA must be in the left subtree if p.val < current.val and q.val < current.val: current = current.left # If both nodes p and q are greater than current, LCA must be in the right subtree elif p.val > current.val and q.val > current.val: current = current.right else: # We have found the split point, i.e., the LCA node. return current"},{"question":"**Red-Black Tree Subtree Deletion Challenge** # Objective Write a function that deletes all nodes in a red-black tree that have values within a given range [low, high]. # Task Implement the given functionality in Python following the below specifications: # Input - A list of integers representing the values to be inserted into the Red-Black tree. For example: ```python values = [10, 15, 5, 20, 25, 3, 7] ``` - A range specified by two integers `low` and `high` defining the inclusive bounds. For example: ```python low = 5 high = 20 ``` # Output - Perform an in-order traversal of the red-black tree after deleting the specified range and return a list of dictionaries with each node\'s value and color. # Function Signature ```python def delete_range(rb_tree: RBTree, low: int, high: int) -> List[Dict[str, int]]: pass ``` # Constraints - The tree must retain all red-black properties post-deletion. - Node values will be unique. - The node color should be retained in the output. - The resultant tree should not contain any values within the specified range. # Example ```python # List of values to be inserted into the Red-Black tree values = [10, 15, 5, 20, 25, 3, 7] # Range to be deleted low = 5 high = 20 # Expected Output after in-order traversal # [ # {\\"val\\": 3, \\"color\\": <0 or 1>}, # {\\"val\\": 25, \\"color\\": <0 or 1>} # ] ``` # Context Imagine a scenario where the red-black tree is being used to manage a dynamic set of data (e.g., managing account balances). A directive comes in to purge records within a certain range (e.g., identify and remove fraudulent accounts with balances in a specific range). This operation must be done efficiently to ensure the red-black tree maintains its balanced state, and further operations on the tree remain performant. # Notes: Refer to the provided code snippet of the Red-Black tree implementation for understanding tree operations like insertion, deletion, and maintaining balance through rotations.","solution":"class Node: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color # 0 for black, 1 for red self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = Node(0, 0) self.root = self.TNULL def in_order_traversal(self, node, nodes): if node != self.TNULL: self.in_order_traversal(node.left, nodes) nodes.append({\\"val\\": node.val, \\"color\\": node.color}) self.in_order_traversal(node.right, nodes) def search_tree(self, node, key): if node == self.TNULL or key == node.val: return node if key < node.val: return self.search_tree(node.left, key) return self.search_tree(node.right, key) def balance_delete(self, node): # Implementation of balance_delete function goes here pass def rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.val == key: z = node if node.val <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Cannot find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.balance_delete(x) def delete_node(self, data): self.delete_node_helper(self.root, data) def minimum(self, node): while node.left != self.TNULL: node = node.left return node def insert(self, key): node = Node(key, 1) node.parent = None node.left = self.TNULL node.right = self.TNULL y = None x = self.root while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.fix_insert(node) def fix_insert(self, k): # Implementation of fix_insert function goes here pass def delete_range(rb_tree, low, high): def delete_range_util(node): if node == rb_tree.TNULL: return if low <= node.val <= high: rb_tree.delete_node(node.val) # delete the current node and adjust it then recurse from the node in place of deleted one. delete_range_util(rb_tree.root) elif node.val < low: delete_range_util(node.right) else: delete_range_util(node.left) delete_range_util(rb_tree.root) nodes = [] rb_tree.in_order_traversal(rb_tree.root, nodes) return nodes"},{"question":"Scenario In cryptography, calculating the Euler totient function φ(n) is crucial as it is a part of algorithms such as RSA. Given an integer n, you need to implement an efficient function that calculates φ(n). Your goal is to ensure your implementation handles all edge cases and operates efficiently for large values of n. Task Implement a function `calculate_totient(n: int) -> int` that calculates and returns the Euler totient function φ(n) for a given integer n. # Input - A single integer n (1 ≤ n ≤ 10^6). # Output - An integer representing the Euler totient function φ(n). # Constraints - The function should handle edge cases (e.g., smallest positive integer, large primes). - The function must operate within a feasible time frame for large values up to 10^6. # Example ```python assert calculate_totient(1) == 1 assert calculate_totient(9) == 6 assert calculate_totient(15) == 8 assert calculate_totient(24) == 8 assert calculate_totient(36) == 12 assert calculate_totient(1000000) == 400000 ``` # Additional Information You should consider performance and optimization techniques to ensure your function runs efficiently, even for the upper limit of n.","solution":"def calculate_totient(n: int) -> int: Calculate the Euler totient function φ(n) for a given integer n. φ(n) is defined as the number of integers k in the range 1 ≤ k ≤ n for which gcd(n, k) = 1. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"You are designing an application where a robot needs to climb a certain number of stairs to reach its charging station. The robot can climb either 1 step or 2 steps at a time. Your task is to write an efficient function to calculate the number of distinct ways the robot can reach the top of the stairs. # Requirements: 1. **Input**: A single integer `steps` (1 ≤ steps ≤ 10^5) representing the total number of steps. 2. **Output**: A single integer representing the number of distinct ways to reach the top of the stairs. 3. **Performance**: Your solution should be efficient in both time (O(n) complexity) and space (preferably O(1) space complexity). # Function Signature: ```python def count_ways_to_climb(steps: int) -> int: pass ``` # Example: ```plaintext Input: 2 Output: 2 Explanation: There are two ways to climb to the top: 1. 1 step + 1 step 2. 2 steps Input: 3 Output: 3 Explanation: There are three ways to climb to the top: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step ``` # Special Considerations: - Ensure that your solution handles very large inputs efficiently. - Consider edge cases such as the smallest possible input (`steps = 1`). Write the function `count_ways_to_climb` to solve the problem effectively.","solution":"def count_ways_to_climb(steps: int) -> int: if steps == 1: return 1 elif steps == 2: return 2 prev1, prev2 = 2, 1 for _ in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Task: Implement a function that uses the modular exponential algorithm to compute ((base^{exponent}) % mod). Ensure that the function handles edge cases properly and performs efficiently. # Function Signature: ```python def secure_modular_exponential(base: int, exponent: int, mod: int) -> int: pass ``` # Input: - `base` (int): The base of the exponentiation (0 <= base <= 10^9). - `exponent` (int): The exponent to which the base is raised (0 <= exponent <= 10^9). - `mod` (int): The modulus, which should be a positive integer (1 <= mod <= 2^31 - 1). # Output: - Returns an integer, the result of ((base^{exponent}) % mod). # Constraints: 1. If `mod` is zero, the function should raise a `ValueError` with the message \\"Invalid modulus\\". 2. If `exponent` is negative, the function should raise a `ValueError` with the message \\"Exponent must be non-negative\\". # Example: ```python assert secure_modular_exponential(2, 5, 13) == 6 assert secure_modular_exponential(10, 0, 7) == 1 assert secure_modular_exponential(0, 10, 3) == 0 try: secure_modular_exponential(2, -1, 3) except ValueError as e: assert str(e) == \\"Exponent must be non-negative\\" ``` # Notes: - Think about how you can utilize properties of modular arithmetic to keep the computation within reasonable bounds. - Ensure that the solution handles large numbers efficiently considering the provided constraints.","solution":"def secure_modular_exponential(base: int, exponent: int, mod: int) -> int: if mod <= 0: raise ValueError(\\"Invalid modulus\\") if exponent < 0: raise ValueError(\\"Exponent must be non-negative\\") result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: # If exponent is odd, multiply base with result result = (result * base) % mod exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % mod # Square the base return result"},{"question":"# Stutter Stack Elements Problem Statement You have been provided with two methods, `first_stutter` and `second_stutter`, which stutter the elements of a stack. That is, each element in the stack is replaced with two occurrences of itself. The two methods use different auxiliary data structures to achieve the same result. Your task is to implement a function `optimized_stutter` that performs the stutter operation in an optimized manner. Your function should strive to use minimal additional space and maintain the stack\'s original order where each element is replaced with two occurrences of that element. **Function Signature** ```python def optimized_stutter(stack: list) -> list: # Implement your function here pass ``` **Input:** * `stack` (list of integers): The stack of integers, where the last element of the list represents the top of the stack. **Output:** * It should return the modified stack after stuttering the elements. **Constraints:** * Stack size (`n`) is in the range `[0, 10^5]`. * Stack elements are integers in the range `[-10^9, 10^9]`. **Example:** ```python stack = [3, 7, 1, 14, 9] print(optimized_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` **Requirements:** * Your function should be able to handle an empty stack without errors. * Ensure an efficient solution to handle large input sizes. Consider the space and time complexity of your solution and strive for an optimal balance.","solution":"def optimized_stutter(stack): This function stutters the elements of the input stack. Each element in the stack will be replaced with two occurrences of itself. :param stack: list of integers :return: list of integers with stuttered elements n = len(stack) stack.extend([0] * n) # Extend the stack to twice its original size # We need to process the original elements while avoiding the newly extended portion # We\'ll copy backwards from the original final position j = len(stack) - 1 # This is now pointing to the last position after extending for i in range(n - 1, -1, -1): stack[j] = stack[i] stack[j - 1] = stack[i] j -= 2 # Move two steps backwards in the extended stack return stack"},{"question":"# Insertion Sort with Step Tracking **Scenario**: You are tasked with helping a sorting robot sort a list of integers. The robot uses the Insertion Sort algorithm but requires your help to track each step it takes during the sorting process. This helps in debugging and understanding the sorting process better. **Task**: Implement the `tracked_insertion_sort` function that accepts a list of integers `arr` and returns a tuple containing the sorted list and a list of lists representing each step after an element has been positioned correctly. **Function Signature**: ```python def tracked_insertion_sort(arr: List[int]) -> Tuple[List[int], List[List[int]]]: ``` **Input**: - `arr`: A list of integers that need to be sorted. (0 <= len(arr) <= 1000) **Output**: - A tuple containing: - A list of integers sorted in ascending order. - A list of lists where each inner list represents the array status after each insertion step. **Constraints**: - The input list can be empty. - The algorithm should have a time complexity of O(n^2) and a space complexity of O(1). **Example**: 1. Input: `[4, 3, 2, 1]` Output: `([1, 2, 3, 4], [[4, 3, 2, 1], [3, 4, 2, 1], [2, 3, 4, 1], [1, 2, 3, 4]])` 2. Input: `[1, 2, 3, 4]` Output: `([1, 2, 3, 4], [[1, 2, 3, 4]])` 3. Input: `[1]` Output: `([1], [[1]])` **Notes**: - The first list in the output steps represents the initial state of the array before sorting begins. - Ensure your solution tracks the complete insertion process and includes all intermediate steps.","solution":"from typing import List, Tuple def tracked_insertion_sort(arr: List[int]) -> Tuple[List[int], List[List[int]]]: Perform an insertion sort on the list and track each step. Args: arr: List[int] - the input list to be sorted. Returns: Tuple[List[int], List[List[int]]] - a tuple containing the sorted list and a list of steps. steps = [arr.copy()] n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Record the current state of \'arr\' steps.append(arr.copy()) return arr, steps"},{"question":"# Question Given two non-negative integers, implement a function `add(x, y)` that returns their sum without using the \'+\' operator. Instead of directly adding the numbers, use bitwise operations to achieve the result. Function Signature ```python def add(x: int, y: int) -> int: ``` Input * Two non-negative integers `x` and `y`. Output * An integer which is the result of adding `x` and `y`. Constraints - `0 <= x, y <= 10^9` Performance Requirements - The solution should have O(n) time complexity where n is the number of bits required to represent the largest number. - Constant space complexity O(1). # Example Input ```python x = 5 y = 10 ``` Output ```python 15 ``` # Explanation To add 5 and 10 without using the \'+\' operator: 1. Use bitwise AND (`&`) to find the carry. 2. Use bitwise XOR (`^`) to perform the addition ignoring carry. 3. Left shift the carry and add again until carry is 0. This problem is relevant in contexts where direct arithmetic operations are restricted or in designing circuits for performing fast addition operations.","solution":"def add(x: int, y: int) -> int: Adds two non-negative integers using bitwise operations without using the \'+\' operator. while y != 0: carry = x & y # find carry bits x = x ^ y # perform addition ignoring carry y = carry << 1 # shift carry to the left by 1 bit return x"},{"question":"# Coding Assessment: Stack ADT Implementation and Use Case Context Stacks are a fundamental data structure used in various computing tasks, from parsing expressions to implementing undo operations in applications. You\'ve been provided with an abstract definition of a stack and two different implementations using array and linked list, respectively. Task You will implement a modified version of the `LinkedListStack` that includes a new method `reverse()` which reverses the elements in the stack using only stack operations (`push`, `pop`). Requirements 1. **Class Definition**: * Define a `LinkedListStack` class that inherits from `AbstractStack`. * Ensure to include the methods `push`, `pop`, and `peek`. 2. **New Method**: * Implement the `reverse()` method that reverses the elements of the stack in place. * **Hint**: Consider using auxiliary stacks to facilitate the reversal. 3. **Constraints**: * The solution should work efficiently with time complexity O(n) for reversing the stack. 4. **Edge Cases**: * Handle scenarios where the stack is empty without raising errors. * Ensure the top pointer is maintained correctly after reversing. Example: ```python stack = LinkedListStack() stack.push(1) stack.push(2) stack.push(3) stack.reverse() print([element for element in stack]) # Output should be: [1, 2, 3] ``` Implementation ```python # Complete the implementation of the reverse method inside LinkedListStack class class LinkedListStack(AbstractStack): def __init__(self): super().__init__() self.head = None def __iter__(self): probe = self.head while True: if probe is None: return yield probe.value probe = probe.next def push(self, value): node = StackNode(value) node.next = self.head self.head = node self._top += 1 def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self.head.value self.head = self.head.next self._top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.head.value def reverse(self): # Your implementation here pass # Example usage stack = LinkedListStack() stack.push(1) stack.push(2) stack.push(3) stack.reverse() print([element for element in stack]) # Output should be: [1, 2, 3] ```","solution":"class StackNode: def __init__(self, value): self.value = value self.next = None class LinkedListStack: def __init__(self): self.head = None self._top = -1 def __iter__(self): probe = self.head while probe is not None: yield probe.value probe = probe.next def push(self, value): node = StackNode(value) node.next = self.head self.head = node self._top += 1 def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") value = self.head.value self.head = self.head.next self._top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.head.value def is_empty(self): return self.head is None def reverse(self): if self.is_empty(): return auxiliary_stack = [] while not self.is_empty(): auxiliary_stack.append(self.pop()) for value in auxiliary_stack: self.push(value) # Example usage stack = LinkedListStack() stack.push(1) stack.push(2) stack.push(3) stack.reverse() print([element for element in stack]) # Output should be: [1, 2, 3]"},{"question":"# Question: Merge Two Sorted Linked Lists Scenario: You are working on a project that involves combining multiple data streams. Each data stream is represented as a sorted linked list of integers. Your task is to merge two of these sorted linked lists into one while maintaining the order. Problem Statement: Write a function `merge_two_lists` that takes in two sorted linked lists and returns a new sorted linked list. You need to implement this both iteratively and recursively. Function Signature: ```python class Node: def __init__(self, x): self.val = x self.next = None def merge_two_lists(l1: Node, l2: Node) -> Node: # Implement the iterative solution here def merge_two_lists_recursive(r1: Node, r2: Node) -> Node: # Implement the recursive solution here ``` Input Format: * `l1` and `l2`, where each represents the head of a sorted linked list. Output Format: * Return the head of the new sorted linked list. Constraints: * The number of nodes in both linked lists combined will not exceed 200. * The values of the nodes are between -1000 and 1000. Performance Requirements: * The function should handle the merging in O(n + m) time complexity where n and m are the lengths of the input linked lists. * The iterative implementation should use constant extra space O(1). * The recursive implementation should handle large inputs without causing stack overflow. # Examples: 1. Given inputs: ``` l1: 1 -> 2 -> 4 l2: 1 -> 3 -> 4 ``` Output: ``` 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` 2. Given inputs: ``` l1: -5 -> -3 -> 0 l2: -10 -> -2 -> 5 ``` Output: ``` -10 -> -5 -> -3 -> -2 -> 0 -> 5 ``` Notes: * You are required to handle edge cases such as one or both of the input lists being empty. * Ensure the solution maintains the order of elements and correctly links all nodes.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def merge_two_lists(l1: Node, l2: Node) -> Node: Merges two sorted linked lists iteratively. dummy = Node(0) current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next def merge_two_lists_recursive(l1: Node, l2: Node) -> Node: Merges two sorted linked lists recursively. if not l1: return l2 if not l2: return l1 if l1.val <= l2.val: l1.next = merge_two_lists_recursive(l1.next, l2) return l1 else: l2.next = merge_two_lists_recursive(l1, l2.next) return l2"},{"question":"# Question Objective: Write a function to find the next higher number with the same set of digits as the given number. If no such number is possible, return -1. Specifications: 1. Implement the function as follows: ```python def next_permutation(num: int) -> int: pass ``` 2. **Input**: * `num` (Integer): A positive integer for which the next permutation is to be found. 3. **Output**: * Returns an integer representing the next permutation or `-1` if no such permutation exists. 4. **Constraints**: * The input number will be a positive integer such that `1 <= num <= 10^9`. Example Scenarios: 1. **Example 1:** * Input: `num = 38276` * Output: `38627` * Explanation: The next greater number with the same set of digits is 38627. 2. **Example 2:** * Input: `num = 99999` * Output: `-1` * Explanation: There is no permutation of 99999 that is greater than itself. 3. **Example 3:** * Input: `num = 54321` * Output: `-1` * Explanation: The number is in descending order, so no greater permutation is possible. 4. **Example 4:** * Input: `num = 12345` * Output: `12354` * Explanation: The next greater permutation is 12354. Requirements: * Ensure the function is efficient, with both time and space complexities in mind. * Consider the use of Python\'s built-in functions and efficient data structures to handle the operations. Optional: * Develop test cases to ensure the correctness of the algorithm and edge cases handling. * Explain how you optimized your code and why the chosen implementation is efficient.","solution":"def next_permutation(num: int) -> int: Finds the next higher number with the same set of digits as the given number. If no such number is possible, returns -1. digits = list(str(num)) n = len(digits) # Step 1: Find the largest index i such that digits[i] < digits[i + 1] i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such index exists, the permutation is the highest and return -1 if i == -1: return -1 # Step 2: Find the largest index j > i such that digits[i] < digits[j] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the digits at indices i and j digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits from i + 1 to the end of the list digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert list back to integer next_num = int(\\"\\".join(digits)) # Return the next permutation return next_num"},{"question":"You need to implement a function that combines the concepts of GCD using Euclid\'s algorithm and counting the number of trailing zeros using bitwise operations. Given two non-negative integers, your task is to: 1. Compute their greatest common divisor (GCD) using bitwise operations. 2. Compute the least common multiple (LCM). 3. Count the number of trailing zeros in the binary representation of the LCM. # Function Signature ```python def gcd_lcm_trailing_zeros(a: int, b: int) -> (int, int, int): Computes the GCD using bitwise operations, LCM, and the number of trailing zeros in the LCM. Parameters: a (int): First non-negative integer. b (int): Second non-negative integer. Returns: (int, int, int): Tuple containing the GCD, LCM, and the number of trailing zeros in LCM. pass ``` # Input * Two non-negative integers `a` and `b`. # Output * A tuple containing three elements: - GCD of the two integers using bitwise operations. - LCM of the two integers. - The number of trailing zeros in the binary representation of the LCM. # Constraints * `0 <= a, b <= 10^9` # Example ```python assert gcd_lcm_trailing_zeros(12, 18) == (6, 36, 2) assert gcd_lcm_trailing_zeros(0, 5) == (5, 5, 0) assert gcd_lcm_trailing_zeros(10, 15) == (5, 30, 1) ``` # Hint 1. Use bitwise operations to compute GCD. 2. Use the relationship LCM(a, b) = abs(a * b) / GCD(a, b) for LCM. 3. Use bitwise operations to count the trailing zeros in LCM.","solution":"def gcd_lcm_trailing_zeros(a: int, b: int) -> (int, int, int): Computes the GCD using bitwise operations, LCM, and the number of trailing zeros in the LCM. Parameters: a (int): First non-negative integer. b (int): Second non-negative integer. Returns: (int, int, int): Tuple containing the GCD, LCM, and the number of trailing zeros in LCM. def gcd(x, y): while y: x, y = y, x % y return x if a == 0: return (b, b, trailing_zeros(b)) if b == 0: return (a, a, trailing_zeros(a)) g = gcd(a, b) lcm = abs(a * b) // g zeros = trailing_zeros(lcm) return (g, lcm, zeros) def trailing_zeros(n): if n == 0: return 0 count = 0 while (n & 1) == 0: count += 1 n >>= 1 return count"},{"question":"Keyboard Row Words Implement a function `find_keyboard_row(words)` that takes a list of words and returns the words that can be typed using letters of the alphabet on only one row of an American QWERTY keyboard. Function Signature: ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` # Input * A list `words` containing n (1 ≤ n ≤ 1000) non-empty strings where each string is composed of letters from the English alphabet. # Output * Returns a list of strings that can be fully typed using the letters in exactly one row of a QWERTY keyboard. # Examples ``` Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Constraints: * Words are case-insensitive but the output must retain the original case of the input words. * Only alphabet characters will be present in the list. Optimal Solution Requirements: * The function must run efficiently and handle the worst-case input within reasonable time and space limits. # Scenario You are developing a typing tutor assistance tool that can help users by recommending words that can be effortlessly typed using only one row of keys on a QWERTY keyboard. This can help typists to practice and improve their speed by focusing on one row of keys at a time. # Notes Ensure you handle edge cases such as case insensitivity and words made up of characters from different rows. Good luck and happy coding!","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_be_typed_on_one_row(word): lower_word = set(word.lower()) return lower_word <= row1 or lower_word <= row2 or lower_word <= row3 return [word for word in words if can_be_typed_on_one_row(word)]"},{"question":"You are tasked with enhancing the provided code snippets by incorporating a more efficient algorithm to compute the nth Fibonacci number. Your implementation should support large n (up to 10^18) while maintaining optimal performance. To achieve this, you will use Matrix Exponentiation, which ensures a logarithmic time complexity for computation. # Instructions 1. **Input Format**: - An integer n (0 ≤ n ≤ 10^18), representing the position of the Fibonacci number to be found. 2. **Output Format**: - A single integer, the nth Fibonacci number. 3. **Constraints**: - Your function should handle very large values of n efficiently. - Ensure that the solution is optimized for both time and space. 4. **Performance Requirements**: - Time complexity should be O(log n). - Space complexity should be kept within reasonable limits to handle large computations. # Function Signature ```python def fib_matrix_exponentiation(n: int) -> int: pass # Example Usage # fib_matrix_exponentiation(10) should return 55 # fib_matrix_exponentiation(1000000000000000000) should return the nth Fibonacci number, correctly handling large n. ``` # Context Fibonacci numbers are integral in various mathematical and computer science applications. Leveraging matrix exponentiation for Fibonacci sequence generation offers substantial performance benefits over traditional methods, ensuring practical feasibility even for very large inputs.","solution":"def fib_matrix_exponentiation(n: int) -> int: Returns the nth Fibonacci number using matrix exponentiation. def matrix_mult(A, B): return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % MOD, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % MOD], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % MOD, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % MOD] ] def matrix_pow(M, power): result = [[1, 0], [0, 1]] # Identity matrix base = M while power: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result MOD = 10**9 + 7 # To prevent overflow issues if n == 0: return 0 elif n == 1: return 1 F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0] # Example usage: # print(fib_matrix_exponentiation(10)) should return 55 # print(fib_matrix_exponentiation(100)) should return a large Fibonacci number"},{"question":"# Objective Given a collection of equal-length words, your task is to construct all possible word squares where the kth row and column contain identical strings. You need to implement this by leveraging prefix-based backtracking. # Function Signature ```python def word_squares(words): # your implementation here ``` # Input - An array of strings `words`, where each string has the same length. - Word lengths vary between 1 and 5, inclusive. - The array contains between 1 and 1000 words, inclusive. # Output - A list of lists, where each list represents a valid word square with rows containing the same strings as columns. # Constraints - All words are lowercase English letters. - Words are unique within the input list. # Example ```python words = [\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"] word_squares(words) ``` Output: ```python [ [\\"wall\\", \\"area\\", \\"lead\\", \\"lady\\"], [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] ] ``` # Explanation The resulting list contains two sets of valid word squares: 1. \\"wall\\", \\"area\\", \\"lead\\", \\"lady\\" 2. \\"ball\\", \\"area\\", \\"lead\\", \\"lady\\" # Notes - The order of the word squares in the output does not matter. - Ensure to handle edge cases such as minimal and maximal input sizes. - Efficiently use prefix-based lookup to reduce the combinatorial search space.","solution":"class WordSquares: def __init__(self, words): self.words = words self.N = len(words[0]) self.build_prefix_hashmap() def build_prefix_hashmap(self): self.prefix_map = {} for word in self.words: for i in range(self.N + 1): prefix = word[:i] if prefix in self.prefix_map: self.prefix_map[prefix].append(word) else: self.prefix_map[prefix] = [word] def get_words_with_prefix(self, prefix): if prefix in self.prefix_map: return self.prefix_map[prefix] else: return [] def backtracking(self, step, word_square): if step == self.N: self.results.append(list(word_square)) return prefix = \'\'.join([word_square[i][step] for i in range(step)]) for candidate in self.get_words_with_prefix(prefix): word_square.append(candidate) self.backtracking(step + 1, word_square) word_square.pop() def find_word_squares(self): self.results = [] for word in self.words: word_square = [word] self.backtracking(1, word_square) return self.results def word_squares(words): word_squares_instance = WordSquares(words) return word_squares_instance.find_word_squares()"},{"question":"# Context You are working on a software that needs to validate if the contents inside a stack are a sequence of consecutive integers starting from the bottom of the stack. You are to implement a solution that ensures the order and integrity of the stack\'s content are restored after validation. # Task Implement the function `is_consecutive_using_stack` that checks if the stack contains a sequence of consecutive integers starting from the bottom of the stack. ```python def is_consecutive_using_stack(stack): Checks if the given stack contains consecutives integers starting from bottom of stack. Args: stack (list[int]): A list of integers representing the stack, with the last element being the top. Returns: bool: True if the integers are consecutive, False otherwise. ``` # Input and Output Formats **Input:** * A list of integers `stack` representing the stack - Example: [3, 4, 5, 6, 7] **Output:** * `True` if integers are consecutive from bottom of stack, `False` otherwise. - Example: True **Constraints:** * The length of the stack would not exceed 10^5. * Each element in the stack is an integer. # Performance Requirements * Optimize your approach for O(n) time complexity and O(n) space complexity. # Example ```python assert is_consecutive_using_stack([3, 4, 5, 6, 7]) == True assert is_consecutive_using_stack([3, 4, 6, 7]) == False assert is_consecutive_using_stack([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == True assert is_consecutive_using_stack([1, 3, 5, 7, 9, 11]) == False ```","solution":"def is_consecutive_using_stack(stack): Checks if the given stack contains consecutive integers starting from the bottom of the stack. Args: stack (list[int]): A list of integers representing the stack, with the last element being the top. Returns: bool: True if the integers are consecutive, False otherwise. if not stack: return False for i in range(len(stack) - 1): if stack[i] + 1 != stack[i + 1]: return False return True"},{"question":"# Word Search II Using Trie and Backtracking **Objective**: Implement a function that identifies all words from a given list that can be found in a given 2D board of characters. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring cells. The same letter cell may not be used more than once in a word. **Function Signature**: `def find_words(board: List[List[str]], words: List[str]) -> List[str]:` # Input * `board`: A 2D list of characters representing the board (e.g., `[[\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\']]`). * `words`: A list of strings representing the words to search for (e.g., `[\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"]`). # Output * A list of strings representing the words found in the board, where each word in the list must exist on the board according to the described adjacency rules. # Constraints * The board and words list have at least one and no more than 300 elements. * The length of each word in the list does not exceed 10. * Characters are limited to lowercase English letters. # Performance Requirement * The implemented solution should be optimized in terms of time and space complexity given the constraints. # Function Implementation Implement the function based on the guidelines provided. Make sure to handle edge cases such as: * The board being completely empty. * No words from the list existing on the board. * Words overlapping partially or entirely. # Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] print(find_words(board, words)) # Output: [\\"oath\\", \\"eat\\"] ``` # Notes * Use Trie for efficient prefix matching. * Use backtracking for exploring potential paths on the board. * Ensure no character reuse in paths.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.word = None class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word = word # Store words at the end nodes def find_words(board: List[List[str]], words: List[str]) -> List[str]: def dfs(node, i, j): char = board[i][j] if char not in node.children: return next_node = node.children[char] if next_node.word: result.add(next_node.word) next_node.word = None # To avoid duplicate results board[i][j] = \'#\' # Mark the cell as visited for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] != \'#\': dfs(next_node, x, y) board[i][j] = char # Reset the cell # Initialize the Trie and insert all words trie = Trie() for word in words: trie.insert(word) result = set() for i in range(len(board)): for j in range(len(board[0])): dfs(trie.root, i, j) return list(result)"},{"question":"You have been hired by a software company to optimize their search function within their ranked product lists. The product rankings are stored as sorted arrays (in increasing order of rankings), and your task is to implement an efficient function to find the position of the last occurrence of a product rating (rank). Write a function `find_last_occurrence` to find the index of the last occurrence of a target rating in a sorted array of ratings. Function Signature ```python def find_last_occurrence(ratings: List[int], target: int) -> int: pass ``` Input * A list of integers `ratings` of length `n`, where `1 <= n <= 10^5` and the list is sorted in non-decreasing order. * An integer `target`, the rating to search for within `ratings`. Output * Return the integer index of the last occurrence of `target` in the list. * If the `target` is not found, return `-1`. Constraints * The function should strive for O(log n) time complexity. * Assume all elements in `ratings` are integers and may have duplicates. Example ```python assert find_last_occurrence([1, 1, 2, 2, 2, 3, 4], 2) == 4 assert find_last_occurrence([5, 6, 6, 7, 7, 7, 8], 7) == 5 assert find_last_occurrence([1, 2, 3, 4, 5], 6) == -1 assert find_last_occurrence([], 1) == -1 ``` Hint Utilize Binary Search algorithm to maintain an O(log n) time complexity. Consider edge cases such as when `ratings` is empty or when the `target` is not present in the list. Be cautious with off-by-one errors when determining the last occurrence.","solution":"from typing import List def find_last_occurrence(ratings: List[int], target: int) -> int: Finds the index of the last occurrence of `target` in the sorted list `ratings`. Returns -1 if `target` is not found in the list. left, right = 0, len(ratings) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if ratings[mid] <= target: if ratings[mid] == target: result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"# Sudoku Solver Coding Assessment Context You are tasked with implementing a Sudoku solver. This problem highlights your understanding of backtracking algorithms and hash tables. A standard 9x9 Sudoku board is initially provided with some cells filled. Your goal is to complete the board according to Sudoku rules: 1. Each row must contain numbers from 1 to 9 without repetition. 2. Each column must contain numbers from 1 to 9 without repetition. 3. Each of the nine 3x3 sub-grids must contain numbers from 1 to 9 without repetition. Task Implement a Sudoku solver that completes an incomplete Sudoku board. The board is represented by a 9x9 grid, with empty cells denoted by a period (`.`). Input - A 9x9 list of lists, `board`, representing the Sudoku grid. - Each element in the list is either a string (number from \\"1\\" to \\"9\\") indicating a filled cell or a period (\\".\\") indicating an empty cell. Output - The same `board`, but modified in-place to represent the completed Sudoku. Function Signature ```python def solveSudoku(board: List[List[str]]) -> None: Modify board in-place to complete the Sudoku puzzle. ``` Constraints - The input board will have a unique solution. - The input board is always a valid partial Sudoku grid. Requirements 1. Do not use built-in libraries that provide direct Sudoku solving capabilities. 2. Efficiency is important; assume the solution must run under typical competitive programming constraints. Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solveSudoku(board) # Expected output: # [ # [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], # [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], # [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], # [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], # [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], # [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], # [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], # [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], # [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] # ] ``` Ensure that your implementation is efficient and adheres to the constraints provided.","solution":"from typing import List def solveSudoku(board: List[List[str]]) -> None: def is_valid(board, row, col, num): # Check if the number is in the row for i in range(9): if board[row][i] == num: return False # Check if the number is in the column for i in range(9): if board[i][col] == num: return False # Check if the number is in the 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return True solve(board)"},{"question":"You are given two 1-dimensional lists representing feature vectors. Your task is to write a Python function that calculates and returns the cosine similarity between these two vectors. The cosine similarity is defined as the dot product of the vectors divided by the product of their L2 norms. # Function Signature ```python def cosine_similarity(vec1: list, vec2: list) -> float: ``` # Input Constraints 1. Both input lists will contain only integers or floating-point numbers. 2. The lengths of the input lists (`vec1` and `vec2`) will be in the range [1, 10^6]. 3. Both input lists will be of the same length. # Output * The function should return a single floating-point number representing the cosine similarity between the two vectors. # Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 0, 0], [1, 2, 3]) # Should raise an error due to zero vector cosine_similarity([1, 2, 3], [1, 2, 3]) # Output: 1.0 ``` # Additional Requirements 1. Ensure that the function raises a `ValueError` if the two vectors are of different lengths. 2. Handle and raise a `ZeroDivisionError` if any of the vectors is a zero vector. # Hint To handle zero vectors, you can include a check before performing any division to ensure neither vector\'s L2 norm is zero.","solution":"import math def cosine_similarity(vec1: list, vec2: list) -> float: Calculate the cosine similarity between two feature vectors. :param vec1: First feature vector :param vec2: Second feature vector :return: Cosine similarity between vec1 and vec2 :raises ValueError: If vec1 and vec2 have different lengths :raises ZeroDivisionError: If either vec1 or vec2 is a zero vector if len(vec1) != len(vec2): raise ValueError(\\"The input vectors must have the same length.\\") dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(v1 * v1 for v1 in vec1)) norm_vec2 = math.sqrt(sum(v2 * v2 for v2 in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: raise ZeroDivisionError(\\"One of the vectors is a zero vector, leading to division by zero.\\") return dot_product / (norm_vec1 * norm_vec2)"},{"question":"# BST Implementation and Operations **Objective**: Implement a Binary Search Tree (BST) with the following operations: insertion, search, and in-order traversal. Your implementation should demonstrate understanding of binary tree properties, handling common edge cases and ensuring performance efficiency. **Input/Output**: - **insert**: * Input: Single integer value to insert into the BST. * Output: None. - **search**: * Input: Single integer value to search for in the BST. * Output: Boolean indicating whether the value is present in the BST. - **in_order_traversal**: * Input: None. * Output: List of integers representing the values in in-order traversal of the BST. **Constraints**: 1. Values to be inserted will be unique integers within the range [-10^6, 10^6]. 2. The operations should be efficient even for large datasets (You need to handle up to 10^5 insertions). **Scenario**: You are developing a database indexing module that uses a BST to store record keys, enabling efficient retrieval and update of records. Write the following functions to manage this BST: * `insert(val)` - Inserts a new key into the BST. * `search(val)` - Checks if a key exists in the BST. * `in_order_traversal()` - Returns a list of keys in ascending order. # Function signatures ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: # Implementation here def search(self, val: int) -> bool: # Implementation here def in_order_traversal(self) -> list: # Implementation here ``` **Implementation Tips**: 1. For insertion, start from the root and find the correct leaf node position where the new value should be placed. 2. For searching, traverse the tree from root to the appropriate leaf where the value might exist. 3. For in-order traversal, recursively visit the left subtree, then the current node, and then the right subtree. Good Luck!","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node: TreeNode, val: int) -> None: if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node: TreeNode, val: int) -> bool: if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def in_order_traversal(self) -> list: result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node: TreeNode, result: list) -> None: if node: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result)"},{"question":"Please implement a function `fizzbuzz_advanced(n, div1, div2, div1_word, div2_word, joint_word)` that returns a list of numbers from 1 to `n`, where `n` is a positive integer parameter. The function should replace certain values in the list according to these rules: - Replace numbers divisible by `div1` with `div1_word`. - Replace numbers divisible by `div2` with `div2_word`. - Replace numbers divisible by both `div1` and `div2` with `joint_word`. # Input and Output Format Input - `n` (integer): A positive integer, `n >= 1`, representing the length of the list. - `div1` (integer): The first divisor. - `div2` (integer): The second divisor. - `div1_word` (string): The word to replace numbers divisible by `div1`. - `div2_word` (string): The word to replace numbers divisible by `div2`. - `joint_word` (string): The word to replace numbers divisible by both `div1` and `div2`. Output - A list of integers and strings with the described replacements. Constraints - `n` is always a positive integer greater than or equal to 1. - `div1` and `div2` are positive integers. - `div1_word`, `div2_word`, and `joint_word` are non-empty strings. Examples ```python def fizzbuzz_advanced(n, div1, div2, div1_word, div2_word, joint_word): # Your code goes here... # Example 1: # Input: 15, 3, 5, \\"Fizz\\", \\"Buzz\\", \\"FizzBuzz\\" # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] # Example 2: # Input: 10, 2, 3, \\"Two\\", \\"Three\\", \\"TwoThree\\" # Output: [1, \\"Two\\", \\"Three\\", \\"Two\\", 5, \\"TwoThree\\", 7, \\"Two\\", \\"Three\\", \\"Two\\"] ``` Implement the `fizzbuzz_advanced` function, considering the provided input constraints and expected behavior. # Notes - Ensure you handle edge cases such as invalid input types or values. - Your solution should be efficient with respect to both time and space complexity.","solution":"def fizzbuzz_advanced(n, div1, div2, div1_word, div2_word, joint_word): Generates a list from 1 to n with replacements: - Numbers divisible by div1 are replaced with div1_word. - Numbers divisible by div2 are replaced with div2_word. - Numbers divisible by both div1 and div2 are replaced with joint_word. Parameters: n (int): Length of the list. div1 (int): First divisor. div2 (int): Second divisor. div1_word (str): Replacement for div1 multiples. div2_word (str): Replacement for div2 multiples. joint_word (str): Replacement for multiples of both div1 and div2. Returns: list: Modified list according to the rules. result = [] for i in range(1, n + 1): if i % div1 == 0 and i % div2 == 0: result.append(joint_word) elif i % div1 == 0: result.append(div1_word) elif i % div2 == 0: result.append(div2_word) else: result.append(i) return result"},{"question":"Implement and Optimize Jump Search for Specific Use Case **Scenario**: You are given a large sorted list of integers representing unique IDs of customers in a database. You need to implement a search function that efficiently finds the index of a given customer\'s ID. The function should handle edge cases and scenario-specific constraints efficiently. **Problem Statement**: Write a function `custom_jump_search(arr, target)` that takes in a sorted list of integers `arr` and an integer `target` representing the customer ID to search for. Implement the Jump Search algorithm to return the index of the target ID in the list. Optimize the function specifically for cases where the list has around 1000 to 10,000 elements. **Function Signature**: ```python def custom_jump_search(arr: list[int], target: int) -> int: pass ``` **Input**: * `arr` (list of int): A sorted list of unique integers within the range of 1 <= len(arr) <= 10^5. * `target` (int): The integer value to search for within the list. **Output**: * Return an integer, the index of `target` in `arr`. * If `target` is not found, return -1. **Constraints**: - The array is sorted. - Each integer in the list is unique. - Your solution should be optimized to handle arrays up to 100,000 elements efficiently. **Examples**: 1. `custom_jump_search([1, 3, 5, 7, 9], 7)` should return `3` 2. `custom_jump_search([1, 3, 5, 7, 9], 10)` should return `-1` 3. `custom_jump_search([i for i in range(1, 1001)], 500)` should return `499` **Performance Requirements**: - Aim for a time complexity of O(√n) and space complexity of O(1). - Ensure your algorithm handles large arrays (up to 100,000 elements) within reasonable time constraints.","solution":"import math def custom_jump_search(arr: list[int], target: int) -> int: Perform Jump Search to find the index of `target` in `arr`. Parameters: arr (list of int): sorted list of unique integers target (int): the integer value to search for within the list Returns: int: the index of `target` in `arr`, or -1 if not found n = len(arr) step = int(math.sqrt(n)) prev = 0 while prev < n and arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 for idx in range(prev, min(step, n)): if arr[idx] == target: return idx return -1"},{"question":"You are given a list of integers and you need to analyze the digit distribution within the list. Write a function `digit_distribution(numbers)` which takes a list of integers as input and returns a dictionary where the keys are the digit lengths and the values are the counts of numbers with that many digits. # Input Format * `numbers`: A list of integers. Each integer can be positive, negative, or zero. The list will contain at least one integer and at most 10^5 integers. # Output Format * A dictionary where each key is a digit length (positive integer) and the corresponding value is the count of numbers having that many digits in their absolute form. # Constraints * The input list can contain numbers in the range of -10^9 to 10^9. # Performance Requirements * Your solution should be efficient, making use of the provided `num_digits()` function to ensure optimal performance. # Example ```python def digit_distribution(numbers): # Your implementation here # Example Usage print(digit_distribution([123, -4567, 890, -12, 0])) # Expected Output: {3: 2, 4: 1, 2: 1, 1: 1} ``` # Explanation In the provided example: * Number 123 has 3 digits. * Number -4567 has 4 digits. * Number 890 has 3 digits. * Number -12 has 2 digits. * Number 0 has 1 digit. Hence, the function should return `{3: 2, 4: 1, 2: 1, 1: 1}`.","solution":"def digit_distribution(numbers): Analyze the digit distribution within the list of integers. Args: numbers: List of integers. Returns: A dictionary where the keys are the digit lengths and the values are the counts of numbers with that many digits. def num_digits(x): x = abs(x) return 1 if x == 0 else len(str(x)) distribution = {} for number in numbers: length = num_digits(number) if length in distribution: distribution[length] += 1 else: distribution[length] = 1 return distribution"},{"question":"# Matrix Multiplication Problem Objective Implement an efficient function to perform matrix multiplication of two compatible matrices. Function Signature ```python def multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: ``` Input 1. A list of lists of integers `multiplicand` of size `m x n`. 2. A list of lists of integers `multiplier` of size `n x p`. Output 1. A list of lists of integers representing the product of the given matrices in size `m x p`. Constraints 1. Matrices are non-empty and contain only integer elements. 2. Dimensions of the matrices are such that multiplication is valid: the number of columns in `multiplicand` is equal to the number of rows in `multiplier`. Requirements - The solution must handle large matrices efficiently. - Raise an appropriate exception if the matrices cannot be multiplied due to incompatible dimensions. Example ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = multiply(multiplicand, multiplier) # Expected result: # [ # [58, 64], # [139, 154] # ] ``` Notes - Ensure your implementation follows the provided structure and has efficient performance.","solution":"def multiply(multiplicand, multiplier): Multiplies two matrices multiplicand and multiplier. :param multiplicand: List of lists of integers of size m x n. :param multiplier: List of lists of integers of size n x p. :return: List of lists of integers representing the product matrix of size m x p. Raises: ValueError: If the matrices cannot be multiplied due to incompatible dimensions. # Get dimensions of the input matrices m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) # Check if multiplication is possible if len(multiplier) != n: raise ValueError(f\\"Cannot multiply matrices of dimensions {m}x{n} and {len(multiplier)}x{p}\\") # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Matrix Inversion Coding Challenge You are provided with code snippets related to the inversion of an invertible n x n matrix. Your task is to implement a function to invert an n x n matrix using these existing helper functions. Ensure that your function addresses the potential edge cases and optimizes for performance. # Function Specification **Function Name**: `invert_and_optimize_matrix` **Inputs**: * `matrix` (list of lists of integers): An n x n square matrix, where 2 ≤ n ≤ 10. **Outputs**: * `list of lists of floats`: The inverse of the input matrix. * If the input matrix is singular or an error occurs, return: * `[[-4]]` for singular matrices. * `[[-1]]` for non-matrix arrays. * `[[-2]]` for non-square matrices. * `[[-3]]` for a matrix smaller than 2x2. # Example ```python matrix = [[1, 2], [3, 4]] output = invert_and_optimize_matrix(matrix) # expected output: [[-2.0, 1.0], [1.5, -0.5]] ``` # Constraints * The matrix dimensions are guaranteed to be between 2 and 10. * The elements of the matrix are integers. * Aim to minimize both time and space complexity within the constraints. # Brief Scenario Assume you are working on a project in a scientific computing environment. Properly handling edge cases and ensuring efficient computation are crucial because these matrices represent data transformations in real-time control systems. Complete the function and ensure it meets the outlined requirements.","solution":"import numpy as np def invert_and_optimize_matrix(matrix): try: # Check for non-matrix arrays (not lists of lists) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] # Check for non-square matrices n = len(matrix) if n < 2: return [[-3]] for row in matrix: if len(row) != n: return [[-2]] # Convert to numpy array for matrix inversion np_matrix = np.array(matrix) # Check for singular matrix if np.linalg.det(np_matrix) == 0: return [[-4]] # Compute the inverse using numpy function inverse_matrix = np.linalg.inv(np_matrix) # Convert the result back to a list of lists return inverse_matrix.tolist() except Exception as e: # Handle any other unexpected errors return [[-1]]"},{"question":"You are given an unsorted array `nums`, you need to reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]...` (a \\"wiggle\\" pattern). Implement a function `wiggle_sort(nums)` that will transform the array into such a pattern. # Input - An unsorted list of integers `nums`. # Output - The function should reorder the input list `nums` in place. - The array should display a wiggle pattern: `nums[0] < nums[1] > nums[2] < nums[3]...` # Constraints - Consider edge cases where the input list is empty or contains only one element. - Preserve the time complexity of O(n) and space complexity of O(1). # Example ```python array = [3, 5, 2, 1, 6, 4] wiggle_sort(array) print(array) # The output should be: [3, 5, 1, 6, 2, 4] or any other valid wiggle pattern ``` Note: The expected output is not unique; any valid wiggle pattern is acceptable. # Performance Requirements - The function must operate in `O(n)` time complexity. - Use in-place modifications to achieve `O(1)` space complexity.","solution":"def wiggle_sort(nums): Reorders the input list nums in place to have a \\"wiggle\\" pattern. for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): # Swap elements to satisfy wiggle condition nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"Problem Statement You are given a set of islands represented on a 2D grid initially filled with water. Each operation turns a specific water cell into a land cell. Your task is to implement a function that returns the number of islands after each operation. An island is defined as a group of adjacent lands connected horizontally or vertically. You need to keep track of unions formed by adjacent lands using the Union-Find data structure. Function Signature ```python def num_islands(positions: List[List[int]]) -> List[int]: pass ``` Input - `positions`: A list of lists, where each sublist contains two integers `[x, y]` representing the coordinates to turn from water to land. Output - A list of integers, where each integer represents the number of islands after each operation. Constraints - Assume grid dimensions are sufficiently large to accommodate any position in the input data. - Positions are provided in no particular order. Example ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] output = num_islands(positions) print(output) # Output: [1, 1, 2, 3] ``` Explanation 1. After turning (0, 0) into land: Number of islands = 1 2. After turning (0, 1) into land: Number of islands = 1 (connected to (0, 0)) 3. After turning (1, 2) into land: Number of islands = 2 (separate from others) 4. After turning (2, 1) into land: Number of islands = 3 (separate from others). Implement the function with optimal time and space complexity using the Union-Find data structure defined in the provided code snippet.","solution":"from typing import List class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 def add(self, p): if p not in self.parent: self.parent[p] = p self.rank[p] = 0 self.count += 1 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def num_islands(positions: List[List[int]]) -> List[int]: uf = UnionFind() results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for pos in positions: r, c = pos point = (r, c) uf.add(point) for dr, dc in directions: nr, nc = r + dr, c + dc neighbor = (nr, nc) if neighbor in uf.parent: uf.union(point, neighbor) results.append(uf.count) return results"},{"question":"Scenario You are tasked with organizing a painting workshop that involves painting objects in three different colors: red, white, and blue. You have a list of these objects represented by the integers 0, 1, and 2 respectively. Your goal is to sort these objects so that all objects of the same color are adjacent and ordered as red (0), white (1), then blue (2). Problem Write a Python function `sort_colors(nums)` that takes a list of integers (nums) containing only 0, 1, and 2. The function should sort the list in place without using any library sorting functions. Example **Input:** ```python nums = [2, 0, 2, 1, 1, 0] ``` **Output:** ```python [0, 0, 1, 1, 2, 2] ``` Constraints - The length of the list `nums` will be in the range [1, 300]. - Each integer in `nums` will be either 0, 1, or 2. Requirements - The function must run in O(n) time complexity. - The function must use O(1) extra space. Function Signature ```python def sort_colors(nums): # Your code here ```","solution":"def sort_colors(nums): Sorts the input list nums in place so that all 0s come first, then all 1s, and finally all 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Palindromic Sentence Detection: Advanced Context: You are tasked with writing a function to determine whether a given sentence (including spaces and punctuation) is a palindrome, considering only alphanumeric characters and ignoring case differences. The importance of this function lies in determining the symmetry in textual data which has several applications in natural language processing and data analysis. Task: Implement a function `is_palindrome_sentence(s: str) -> bool` that takes a string `s` as input and returns `True` if the string is a palindrome considering only alphanumeric characters (case-insensitive) and `False` otherwise. Input: - `s`: A string (0 <= len(s) <= 10^5) which can include spaces, punctuation, digits, and letters from the English alphabet. Output: - A Boolean value indicating whether the string is a palindrome. Constraints: - The function should efficiently handle large strings (up to 100,000 characters). Example: 1. Input: `\\"Able , was I saw eLba\\"` - Output: `True` 2. Input: `\\"race a car\\"` - Output: `False` 3. Input: `\\"\\"` - Output: `True` Notes: 1. Consider an empty string as a valid palindrome. **Additional Requirements**: 1. **Performance**: Use a method that balances time and space complexity. The expected time complexity is O(n) and space complexity should remain O(1) where possible. 2. **Edge Cases**: Handle strings with only non-alphanumeric characters appropriately. Implement the `is_palindrome_sentence` function clearly and efficiently. ```python def is_palindrome_sentence(s: str) -> bool: # Your implementation here pass # Example Test Case assert is_palindrome_sentence(\\"Able , was I saw eLba\\") == True assert is_palindrome_sentence(\\"race a car\\") == False assert is_palindrome_sentence(\\"\\") == True ```","solution":"def is_palindrome_sentence(s: str) -> bool: Returns True if the input string is a palindrome considering only alphanumeric characters and ignoring case differences, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"You are given a real-time data stream composed of tuples, where each tuple contains a number and a sign (+ or -). Implement the function `one_sparse(array)` to determine if the stream is 1-sparse, meaning all elements cancel each other out in such a way that there is only a unique number left. If the stream is determined to be 1-sparse, return that unique number. Otherwise, return `None`. # Function Signature ```python def one_sparse(array: List[Tuple[int, str]]) -> Union[int, None]: ``` # Input - `array`: A list of tuples. Each tuple is composed of an integer and a sign character (\'+\' or \'-\'). # Output - Returns the unique integer if the stream is 1-sparse. Returns `None` otherwise. # Constraints - The input array can be empty. - The numbers in the tuples are non-negative integers. # Example ```python # Example 1 input_data = [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] assert one_sparse(input_data) == 4 # The number 4 is the only number not cancelled out. # Example 2 input_data = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] assert one_sparse(input_data) == 2 # The number 2 is the only number present. # Example 3 input_data = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] assert one_sparse(input_data) == None # The numbers do not cancel out to exactly one unique number. ``` # Notes - Ensure that the list of tuples is processed efficiently. - Consider edge cases such as an empty array, or all elements cancelling out to leave none. - Validate the correctness and performance of your implementation with different test cases.","solution":"from typing import List, Tuple, Union def one_sparse(array: List[Tuple[int, str]]) -> Union[int, None]: count = {} for number, sign in array: if sign == \'+\': count[number] = count.get(number, 0) + 1 elif sign == \'-\': count[number] = count.get(number, 0) - 1 non_zero_counts = [num for num, c in count.items() if c != 0] if len(non_zero_counts) == 1: return non_zero_counts[0] else: return None"},{"question":"# Scenario You are in charge of designing an algorithm for a fitness app that tracks a user\'s climbing exercises. To motivate users, the app calculates the number of distinct ways they can complete a climb of `n` steps, with the option to take either one or two steps at a time. # Problem Statement Write a function `count_ways(n: int) -> int` that calculates the number of distinct ways to climb `n` steps. # Input and Output Format * **Input**: A single integer `n` (1 ≤ n ≤ 10^4) representing the number of steps. * **Output**: An integer representing the number of distinct ways to reach the top. # Constraints * The function must perform efficiently for large values of `n`. * Consider edge cases such as the smallest value of `n = 1`. # Example Input/Output Example 1 Input: `n = 2` Output: `2` Explanation: There are two ways to climb to the top (1+1, 2). Example 2 Input: `n = 3` Output: `3` Explanation: There are three ways to climb to the top (1+1+1, 1+2, 2+1). # Function Signature ```python def count_ways(n: int) -> int: # your code here ``` # Requirements Implement the function `count_ways` that: * Uses O(1) additional space. * Has a time complexity of O(n).","solution":"def count_ways(n: int) -> int: Returns the number of distinct ways to climb n steps, taking either 1 or 2 steps at a time. if n == 1: return 1 if n == 2: return 2 a, b = 1, 2 for _ in range(3, n + 1): a, b = b, a + b return b"},{"question":"**Scenario**: In a software application that handles large datasets, making efficient queries to determine preceding values in an ordered set is crucial. To achieve this, the dataset is organized using a Binary Search Tree (BST). **Task**: Implement a function `predecessor` within a BST to find the in-order predecessor of a node. The in-order predecessor of a given node in a BST is the node with the highest value less than the given node. **Function Signature**: ```python def predecessor(root: TreeNode, node: TreeNode) -> TreeNode: pass ``` **Input**: 1. `root` (TreeNode): The root node of a BST. 2. `node` (TreeNode): The node for which we need to find the in-order predecessor. **Output**: - Returns the in-order predecessor node of the given `node`. - If no predecessor exists (i.e., the given `node` has the smallest value in the BST), return `None`. **Constraints**: 1. `root` and `node` are guaranteed to be TreeNode objects. 2. Assume the TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 3. The tree is a valid Binary Search Tree. **Example**: ```python # Example usage: # Constructing the BST # 20 # / # 10 30 # / # 5 15 # The in-order predecessor of node with value 15 is 10. tree_root = TreeNode(20, TreeNode(10, TreeNode(5), TreeNode(15)), TreeNode(30)) target_node = tree_root.left.right # Node with value 15 print(predecessor(tree_root, target_node).val) # Output should be 10 ``` **Notes**: - Focus on iterative traversal without recursion for space efficiency. - Test your implementation with edge cases including smallest and largest nodes in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def predecessor(root: TreeNode, node: TreeNode) -> TreeNode: Find the in-order predecessor of the given node in the BST. Parameters: root (TreeNode): The root of the BST. node (TreeNode): The node for which to find the in-order predecessor. Returns: TreeNode: The in-order predecessor node, or None if no predecessor exists. predecessor_node = None current = root while current: if node.val > current.val: predecessor_node = current current = current.right elif node.val <= current.val: current = current.left if node.left: predecessor_node = node.left while predecessor_node.right: predecessor_node = predecessor_node.right return predecessor_node"},{"question":"# Prime Number Checker with Enhancements Context Prime number checks are fundamental in numerous fields including cryptography, data security, and algorithm design. However, they can be inefficient for large numbers. Enhancing the basic prime-check algorithm can yield substantial performance benefits in specific scenarios. Task Implement an enhanced version of the `prime_check` function. Your implementation should include additional optimizations and error handling to handle large inputs more effectively. Requirements 1. **Function Signature**: `def enhanced_prime_check(n: int) -> bool:` 2. **Input**: A single integer `n` (0 <= n <= 10^12). 3. **Output**: Return `True` if `n` is a prime number, otherwise return `False`. 4. **Constraints**: - The function must be capable of handling very large numbers efficiently. - Consider edge cases including: - n = 0 - n = 1 - n = 2 - n = 3 - n = a very large prime number (e.g., 999999937) - n = a very large non-prime number (e.g., 999999938) Evaluation Criteria - **Correctness**: Correct results for all edge cases and typical inputs. - **Performance**: Efficient handling of large numbers. - **Code Quality**: Clear, readable, and maintainable code with appropriate comments.","solution":"def enhanced_prime_check(n: int) -> bool: Checks if a given number n is a prime number. :param n: integer to check if prime :return: True if n is a prime number, False otherwise if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Context You are tasked with creating a library for handling various arithmetic operations needed in a number theory module. One of the crucial operations is to compute the Least Common Multiple (LCM) of multiple integers. Given that the LCM of two numbers can be derived from their Greatest Common Divisor (GCD), you\'ll first need to implement a function to find the GCD of two integers using bitwise operations. # Problem Statement Write a function `multi_lcm` that takes a list of non-negative integers and returns their Least Common Multiple (LCM). Implement the `multi_lcm` function as follows: 1. Use the provided `gcd_bit` function for calculating GCD between two numbers. 2. Use the relationship LCM(a, b) = abs(a * b) / GCD(a, b). 3. Extend this concept to compute the LCM for a list of more than two numbers. **Function Signature** ```python def multi_lcm(arr: List[int]) -> int: pass ``` **Input** - `arr`: A list of non-negative integers (0 ≤ arr[i] ≤ 10^6, 1 ≤ len(arr) ≤ 10^4) **Output** - Returns the Least Common Multiple of the integers in the list. **Constraints** - The input list will contain at least one element. - You may assume that non-zero values always exist in the list (no all-zero lists). **Example** ```python from typing import List def trailing_zero(x): count = 0 while x and not x & 1: count += 1 x >>= 1 return count def gcd_bit(a, b): tza = trailing_zero(a) tzb = trailing_zero(b) a >>= tza b >>= tzb while b: if a < b: a, b = b, a a -= b a >>= trailing_zero(a) return a << min(tza, tzb) def multi_lcm(arr: List[int]) -> int: def lcm(a, b): return abs(a * b) // gcd_bit(a, b) result = arr[0] for num in arr[1:]: result = lcm(result, num) return result # Example Usage print(multi_lcm([4, 6, 8])) # Output: 24 print(multi_lcm([5, 10, 20])) # Output: 20 ``` # Notes - Ensure the function is optimized for the constraints. - Handle large products carefully to avoid overflow issues.","solution":"from typing import List def trailing_zero(x): count = 0 while x and not x & 1: count += 1 x >>= 1 return count def gcd_bit(a, b): if a == 0: return b if b == 0: return a tza = trailing_zero(a) tzb = trailing_zero(b) a >>= tza b >>= tzb while b: if a < b: a, b = b, a a -= b a >>= trailing_zero(a) return a << min(tza, tzb) def multi_lcm(arr: List[int]) -> int: def lcm(a, b): return abs(a * b) // gcd_bit(a, b) if a and b else 0 result = arr[0] for num in arr[1:]: result = lcm(result, num) return result"},{"question":"# Maximum Subarray Sum with Validation Objective: Write a function to find the maximum sum of a contiguous subarray within a given one-dimensional numeric array. Ensure your implementation handles edge cases and validates input properly. Input: - A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. Output: - An integer representing the maximum sum of any contiguous subarray within the input array. Constraints: - The function should handle cases where the array is composed entirely of negative numbers. - The function should handle single-element arrays. - The function does not need to handle empty arrays. Function Signature: ```python def max_subarray_sum(arr: List[int]) -> int: ``` Example: ```python assert max_subarray_sum([1, 2, -3, 4, 5, -7, 23]) == 25 assert max_subarray_sum([-1, -2, -3, -4]) == -1 assert max_subarray_sum([5]) == 5 assert max_subarray_sum([5, -2, 2, 3, -1, 2]) == 9 ``` Additional Context: Kadane\'s Algorithm is widely used in financial analysis, game scoring, and various optimization problems. Demonstrate your understanding of this algorithm by implementing a robust and optimized solution.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: if not arr: raise ValueError(\\"Array should contain at least one element.\\") max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Scenario You are working for a data storage company that frequently needs to compress and decompress text data. To accomplish this, you have decided to use Run-Length Encoding (RLE) due to its simplicity and efficiency for certain types of data. Based on the principles of RLE, you are required to implement two core functions: one to encode data and another to decode it. # Question Implement two functions, `encode_rle` and `decode_rle`, that perform Run-Length Encoding and Decoding, respectively. # Function Signature ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` # Input and Output Formats `encode_rle`: * **Input**: A string `input` containing the data to be encoded. * **Output**: A string representing the run-length encoded form of the input data. `decode_rle`: * **Input**: A string `input` containing the run-length encoded data. * **Output**: A string representing the original decompressed data. # Constraints * The input strings for both functions will only contain alphanumeric characters. * The maximum length of input strings will be 10,000 characters. # Example Example 1: ```python encoded_string = encode_rle(\\"aaabcccc\\") print(encoded_string) # Output: \\"3a1b4c\\" decoded_string = decode_rle(\\"3a1b4c\\") print(decoded_string) # Output: \\"aaabcccc\\" ``` Example 2: ```python encoded_string = encode_rle(\\"abcd\\") print(encoded_string) # Output: \\"1a1b1c1d\\" decoded_string = decode_rle(\\"1a1b1c1d\\") print(decoded_string) # Output: \\"abcd\\" ``` # Performance Requirements Both functions should have a time complexity of O(n), where n is the length of the input string. # Notes * Ensure to handle edge cases such as empty input strings, single-character strings, and strings with no consecutive repeating characters. * Provide thorough test cases covering possible edge cases in your submission.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i - 1]}\\") count = 1 # Append the last run encoded.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \'\'.join(decoded)"},{"question":"# Question You are given a text string and a pattern string. Using the Knuth-Morris-Pratt (KMP) algorithm, find all starting positions in the text where the pattern is found as a substring. Function Signature ```python def find_pattern_occurrences(text: str, pattern: str) -> List[int]: ``` Input * `text` (string): The string in which to search for the pattern. * `pattern` (string): The string pattern to search for in the text. Output * `List[int]`: A list of starting indexes where the pattern is found in the text. If the pattern is not found, return an empty list. Constraints 1. The function should return the starting positions in the ascending order. 2. Time Complexity: O(N + M), where N and M are the lengths of `text` and `pattern` respectively. 3. Space Complexity: O(M). Example ```python find_pattern_occurrences(\'hello there hero!\', \'he\') # Expected output: [0, 7, 12] ``` ```python find_pattern_occurrences(\'ababcababc\', \'ababc\') # Expected Output: [0, 5] ``` Notes: * Create a helper function to generate the pi table (prefix function) for the pattern. * Handle edge cases such as an empty pattern or text.","solution":"from typing import List def compute_pi(pattern: str) -> List[int]: pi = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while (j > 0 and pattern[i] != pattern[j]): j = pi[j - 1] if pattern[i] == pattern[j]: j += 1 pi[i] = j return pi def find_pattern_occurrences(text: str, pattern: str) -> List[int]: if not pattern or not text: return [] pi = compute_pi(pattern) j = 0 results = [] for i in range(len(text)): while (j > 0 and text[i] != pattern[j]): j = pi[j - 1] if text[i] == pattern[j]: j += 1 if j == len(pattern): results.append(i - j + 1) j = pi[j - 1] return results"},{"question":"# Spiral Matrix Traversal **Context**: You are tasked with developing a navigation system for a robot that is required to traverse a 2D plane in a specific spiral pattern starting from the top-left point. **Task**: Given a matrix of m x n elements (m rows and n columns), implement a function `spiral_traversal(matrix)` that returns all the elements of the matrix in spiral order. Example ```python Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] The output should be [1, 2, 3, 6, 9, 8, 7, 4, 5]. ``` Function Signature ```python def spiral_traversal(matrix): # Your code here ``` Input * The function `spiral_traversal(matrix)` takes the following input: * `matrix` (List[List[int]]): A 2D list of integers representing the matrix. Output * The function should return a list of integers representing the matrix elements in spiral order. Constraints * The number of rows and columns in the matrix will be in the range [0, 100]. **Implement the `spiral_traversal(matrix)` function that returns the elements in the spiral order as described. Consider edge cases such as empty matrices, single row/column matrices, and non-square matrices.**","solution":"def spiral_traversal(matrix): Perform a spiral traversal on a given m x n matrix. :param matrix: List[List[int]], 2D list of integers representing the matrix. :return: List[int], elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse downwards for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse upwards for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"Context You are given two sorting algorithms: Max Heap Sort and Min Heap Sort. These algorithms sort an array using heap structures (max heap and min heap respectively). Your task is to implement a new variant of heap sort called \\"Min-Max Heap Sort\\" that combines elements of both max heap and min heap. # Task Problem Statement Implement a function `min_max_heap_sort` that sorts an array in ascending order by alternating between building a max heap and a min heap on successive iterations. Your function should simulate building a max heap for odd iterations and a min heap for even iterations until the array is sorted. Function Signature ```python def min_max_heap_sort(arr: list, simulation: bool=False) -> list: pass ``` Expected Input and Output * **Input**: * `arr`: List[int] - A list of integers to sort. * `simulation`: bool - A flag to print the state of the array after each iteration (default is False). * **Output**: * List[int] - The sorted list of integers. Constraints * The function should handle arrays with up to 10^5 elements. * You are not allowed to use any built-in sorting functions. Performance Requirements * Your implementation should maintain time complexity of O(n log n) in the average case. Example ```python # Example usage: arr = [14, 3, 2, 8, 15, 17, 9] result = min_max_heap_sort(arr, simulation=True) print(result) # Expected output (the exact intermediate steps may vary): # iteration 0 : 14 3 2 8 15 17 9 # iteration 1 : 17 3 2 8 15 14 9 # iteration 2 : 14 15 17 9 2 3 8 # ... # [2, 3, 8, 9, 14, 15, 17] ```","solution":"def heapify(arr, n, i, is_max_heap): largest_or_smallest = i left = 2 * i + 1 right = 2 * i + 2 if is_max_heap: if left < n and arr[i] < arr[left]: largest_or_smallest = left if right < n and arr[largest_or_smallest] < arr[right]: largest_or_smallest = right else: if left < n and arr[i] > arr[left]: largest_or_smallest = left if right < n and arr[largest_or_smallest] > arr[right]: largest_or_smallest = right if largest_or_smallest != i: arr[i], arr[largest_or_smallest] = arr[largest_or_smallest], arr[i] heapify(arr, n, largest_or_smallest, is_max_heap) def build_heap(arr, n, is_max_heap): start_idx = n // 2 - 1 for i in range(start_idx, -1, -1): heapify(arr, n, i, is_max_heap) def min_max_heap_sort(arr, simulation=False): n = len(arr) is_max_heap = True steps = 0 while True: build_heap(arr, n, is_max_heap) if simulation: print(f\\"iteration {steps} :\\", *arr) is_heapified = True for i in range(n): if i * 2 + 1 < n and ((is_max_heap and arr[i] < arr[i * 2 + 1]) or (not is_max_heap and arr[i] > arr[i * 2 + 1])): is_heapified = False break if i * 2 + 2 < n and ((is_max_heap and arr[i] < arr[i * 2 + 2]) or (not is_max_heap and arr[i] > arr[i * 2 + 2])): is_heapified = False break if is_heapified: break is_max_heap = not is_max_heap steps += 1 return sorted(arr)"},{"question":"# Binary Tree Serialization and Deserialization Coding Challenge Context You\'re given a task of storing and transmitting binary tree structures. To achieve this, you need to convert a binary tree into a string representation, and then be able to reconstruct the exact same binary tree from that string. Using serialization and deserialization, this task makes it feasible to handle binary tree data in a simple and effective manner. Task Write functions `serialize` and `deserialize` for binary trees using preorder traversal. The serialized format should use space-separated node values in preorder, with `#` marking null nodes. Specifications **Function: `serialize`** - **Input**: `root` (TreeNode): The root node of the binary tree. - **Output**: A `string` representing the serialized binary tree. **Function: `deserialize`** - **Input**: `data` (string): The string representation of the binary tree (output of `serialize`). - **Output**: The `TreeNode` representing the root node of the reconstructed binary tree. Constraints - The input binary tree can be empty (i.e., the root is `None`). - The tree nodes contain integer values. - The maximum depth of the binary tree (`N`) will be within reasonable limits to avoid stack overflow or memory issues. Example ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None # Example usage: # Constructing the binary tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) print(serialized) # Output might be similar to \\"1 2 # # 3 4 # # 5 # #\\" deserialized_root = deserialize(serialized) print(deserialize(serialize(root)).val == root.val) # Output: True ``` Implement the `serialize` and `deserialize` functions based on the above example.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): Encodes a tree to a single string. def dfs(node): if not node: result.append(\'#\') return result.append(str(node.val)) dfs(node.left) dfs(node.right) result = [] dfs(root) return \' \'.join(result) def deserialize(data): Decodes your encoded data to tree. def dfs(): val = next(val_iter) if val == \'#\': return None node = TreeNode(int(val)) node.left = dfs() node.right = dfs() return node val_iter = iter(data.split()) return dfs()"},{"question":"**Question**: A fictional coding platform uses a particular form of string encoding to compress repetitive sequences within strings. Given the encoded string, your task is to decode it into its original form. The encoding rule is: k[encoded_string], where the `encoded_string` inside the square brackets is repeated exactly `k` times. You can assume that `k` is always a positive integer. **Example**: ``` s = \\"3[a]2[bc]\\" return \\"aaabcbc\\" ``` **Additional Examples**: ``` s = \\"3[a2[c]]\\" return \\"accaccacc\\" s = \\"2[abc]3[cd]ef\\" return \\"abcabccdcdcdef\\" ``` **Function Signature**: ```python def decode_string(s: str) -> str: :type s: str :rtype: str ``` **Input**: * The input string `s` will only contain digits (`0-9`), English letters (`a-z`), square brackets (`[]`). * The input string is always a valid encoded string (no white spaces, square brackets are well-formed). * The string does not contain any digits that are not part of the repeat count (e.g., no scenarios like `3a` or `2[4]`). **Output**: * The function should return the decoded string as a string. **Constraints**: * 1 <= length of `s` <= 30,000 Implement the function to decode the encoded string. Take into consideration edge cases such as nested encodings and multiple-digit repeat counts.","solution":"def decode_string(s: str) -> str: def helper(idx): decoded = \\"\\" while idx < len(s) and s[idx] != \']\': if s[idx].isdigit(): k = 0 while s[idx].isdigit(): k = k * 10 + int(s[idx]) idx += 1 idx += 1 # to skip the \'[\' sub_str, idx = helper(idx) decoded += sub_str * k idx += 1 # to skip the \']\' else: decoded += s[idx] idx += 1 return decoded, idx decoded_string, _ = helper(0) return decoded_string"},{"question":"You have been asked to implement a `selection_sort` function following the selection sort algorithm to sort an array in ascending order. Additionally, given the quadratic nature of the algorithm, you\'re tasked with analyzing its behavior and understanding the scenarios in which it might be inefficient. # Function Signature ```python def selection_sort(arr: list[int]) -> list[int]: Sorts the array arr in ascending order using the selection sort algorithm. ``` # Input * A list of integers `arr` where: * 1 ≤ len(arr) ≤ 5000 * -10^6 ≤ arr[i] ≤ 10^6 for each integer `arr[i]`. # Output * The function should return a new list containing the sorted integers in ascending order. # Example ```python assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert selection_sort([1, 2, 3, 4]) == [1, 2, 3, 4] assert selection_sort([]) == [] assert selection_sort([10, 5, 3, -1, 0, -10]) == [-10, -1, 0, 3, 5, 10] ``` # Task Requirements 1. Implement the `selection_sort` function that sorts the array as described. 2. Ensure that your function handles edge cases, such as already sorted arrays, arrays with duplicate values, empty arrays, and arrays containing negative values correctly. # Constraints * The algorithm must adhere to the selection sort principles. * It should have a time complexity of O(n^2) and space complexity of O(1). # Guidelines 1. Identify and select the minimum element from the unsorted portion of the list. 2. Swap it with the first unsorted element. 3. Repeat this process for every element in the unsorted portion of the list until the entire list is sorted. 4. Return the sorted list.","solution":"def selection_sort(arr: list[int]) -> list[int]: Sorts the array arr in ascending order using the selection sort algorithm. n = len(arr) for i in range(n): # Assume the minimum is the first element min_idx = i # Find the minimum element in the remaining unsorted array for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first unsorted element arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"# Find the Additional Character You are given two strings, `s` and `t`, both containing only lowercase letters. String `t` is generated by randomly shuffling `s` and then adding one more letter at a random position. Write a function, `find_difference(s, t)`, that finds the letter that was added to `t`. **Function Signature**: ```python def find_difference(s: str, t: str) -> str: pass ``` # Example ```python s = \\"abcd\\" t = \\"abecd\\" find_difference(s, t) # returns \\"e\\" ``` # Input Constraints - `s` and `t` consist of only lowercase letters (a-z). - `t` is exactly one character longer than `s`. # Expected Output The function should return the single character that was added to `t`. # Performance Requirements - The function should run in O(n) time complexity, where n is the length of the longer string `t`. - The space complexity should be O(1), using a constant amount of extra memory. # Notes - The problem leverages the properties of the XOR operation, which ensures that characters present in both strings cancel each other out, leaving the extra character. - Consider edge cases such as all characters being distinct or repeated characters within the input strings.","solution":"def find_difference(s: str, t: str) -> str: Finds the extra letter in t that is not in s. result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"# Problem: Enhanced RandomizedSet with Frequency Count Develop a data structure that supports the following operations with improvements: 1. **insert(val)**: Inserts an item `val` to the set if not already present. Returns `True` if the item was successfully added, otherwise `False`. 2. **remove(val)**: Removes an item `val` from the set if present. Returns `True` if the item was successfully removed, otherwise `False`. 3. **getRandom()**: Returns a random element from the current set. Each element must have the same probability of being returned. 4. **getFrequency(val)**: Returns the number of occurrences of `val` in the set. Returns `0` if the element isn\'t present. Your design should achieve average O(1) time complexity for the insert, remove, getRandom, and getFrequency operations. # Input & Output Implement a class `EnhancedRandomizedSet` with the following methods: ```python class EnhancedRandomizedSet: def __init__(self): # Initialize data structures here pass def insert(self, val: int) -> bool: # Your implementation here pass def remove(self, val: int) -> bool: # Your implementation here pass def get_random(self) -> int: # Your implementation here pass def get_frequency(self, val: int) -> int: # Your implementation here pass ``` # Examples ```python if __name__ == \\"__main__\\": ers = EnhancedRandomizedSet() print(ers.insert(1)) # Output: True print(ers.insert(2)) # Output: True print(ers.insert(3)) # Output: True print(ers.insert(2)) # Output: False (duplicate) print(ers.remove(3)) # Output: True print(ers.remove(3)) # Output: False (already removed) print(ers.get_random()) # Output: Random element from {1, 2} print(ers.get_frequency(1)) # Output: 1 print(ers.get_frequency(3)) # Output: 0 ``` # Constraints 1. All integer inputs are in the range (-10^9) to (10^9). 2. Expected operation count for any input data set is not more than (10^5). **Performance Requirements**: Your design should operate close to O(1) time complexity for each method on average.","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.vals = [] self.val_indices = {} self.value_counts = {} def insert(self, val: int) -> bool: if val in self.value_counts: return False self.value_counts[val] = 1 self.val_indices[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: if val not in self.value_counts: return False last_element = self.vals[-1] index_to_remove = self.val_indices[val] self.vals[index_to_remove] = last_element self.val_indices[last_element] = index_to_remove self.vals.pop() del self.val_indices[val] del self.value_counts[val] return True def get_random(self) -> int: return random.choice(self.vals) def get_frequency(self, val: int) -> int: return self.value_counts.get(val, 0)"},{"question":"Context A certain embedded system project requires an efficient way to manage control flags in a single integer. You have to provide functions that can manipulate individual bits effectively. Problem Statement Implement a set of bit manipulation functions that can: - Retrieve the value of a bit at a given index. - Set the value of a bit at a given index to `1`. - Clear the value of a bit at a given index (set it to `0`). - Update the value of a bit at a given index to either `0` or `1`. # Function Definitions 1. **get_bit(num, i)** - **Input**: - `num` (int): The integer from which to get the bit. - `i` (int): Index of the bit to retrieve. - **Output**: - `bool`: `True` if the bit at index `i` is `1`, `False` otherwise. 2. **set_bit(num, i)** - **Input**: - `num` (int): The integer in which to set the bit. - `i` (int): Index of the bit to set. - **Output**: - `int`: The new integer value after setting the bit at index `i` to `1`. 3. **clear_bit(num, i)** - **Input**: - `num` (int): The integer in which to clear the bit. - `i` (int): Index of the bit to clear. - **Output**: - `int`: The new integer value after clearing the bit at index `i`. 4. **update_bit(num, i, bit)** - **Input**: - `num` (int): The integer in which to update the bit. - `i` (int): Index of the bit to update. - `bit` (int: 0 or 1): The new value of the bit at index `i`. - **Output**: - `int`: The new integer value after updating the bit at index `i`. # Constraints - Index `i` should be between `0` and `31` (since we are assuming a 32-bit integer). - Bit values allowed are `0` and `1`. - Handle positive and negative integers appropriately. # Example Usage ```python num = 13 # Binary: 1101 print(get_bit(num, 0)) # Output: True (1 in binary) print(get_bit(num, 1)) # Output: False (0 in binary) print(set_bit(num, 1)) # Output: 15 (1111 in binary) print(clear_bit(num, 2)) # Output: 9 (1001 in binary) print(update_bit(num, 0, 0)) # Output: 12 (1100 in binary) print(update_bit(num, 1, 1)) # Output: 15 (1111 in binary) ``` Note Make sure to handle invalid inputs gracefully, such as out-of-range bit indices or invalid bit values.","solution":"def get_bit(num, i): if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range 0 to 31\\") return bool(num & (1 << i)) def set_bit(num, i): if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range 0 to 31\\") return num | (1 << i) def clear_bit(num, i): if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range 0 to 31\\") return num & ~(1 << i) def update_bit(num, i, bit): if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range 0 to 31\\") if bit not in [0, 1]: raise ValueError(\\"Bit must be either 0 or 1\\") mask = ~(1 << i) num_cleared = num & mask return num_cleared | (bit << i)"},{"question":"# Question: Implement Advanced Pattern Searching using KMP Algorithm **Context**: You are developing a search functionality for a large text document repository where efficiency and performance are key. Your task is to leverage the Knuth-Morris-Pratt (KMP) algorithm to locate all occurrences of a given pattern within a piece of text efficiently. **Task**: Write a Python function `search_patterns` that accepts two strings, `text` and `pattern`, and returns a list of starting indices where the pattern is found in the text using the Knuth-Morris-Pratt (KMP) algorithm. **Function Signature**: ```python def search_patterns(text: str, pattern: str) -> List[int]: pass ``` **Input**: - `text`: A string `text` where we need to search for the pattern. (0 <= len(text) <= 10^6) - `pattern`: A string `pattern` which needs to be searched in the `text`. (0 <= len(pattern) <= 10^4) **Output**: - A list of integers representing the starting indices where the pattern is found in text. If the pattern is not found, return an empty list. **Constraints**: - You must use the Knuth-Morris-Pratt (KMP) algorithm. - Your implementation should handle various edge cases like empty strings or no matches gracefully. **Examples**: ```python print(search_patterns(\\"hello there hero!\\", \\"he\\")) # Output: [0, 7, 12] print(search_patterns(\\"aaaaa\\", \\"aa\\")) # Output: [0, 1, 2, 3] print(search_patterns(\\"abcde\\", \\"f\\")) # Output: [] print(search_patterns(\\"abc\\", \\"\\")) # Output: [] print(search_patterns(\\"\\", \\"abc\\")) # Output: [] ``` **Note**: - Ensure the function is optimized to handle large texts and patterns within specified constraints. - Consider all relevant edge cases and document them in comments within your code.","solution":"from typing import List def search_patterns(text: str, pattern: str) -> List[int]: Uses the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of the given pattern in the text. Args: text (str): The text to search within. pattern (str): The pattern to search for. Returns: List[int]: A list of starting indices where the pattern is found in the text. if not pattern: return [] # No pattern to search for if not text: return [] # No text to search within # KMP algorithm helper function to create the longest prefix which is also suffix array (LPS) def compute_lps(pattern: str) -> List[int]: m = len(pattern) lps = [0] * m length = 0 i = 1 while i < m: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps n = len(text) m = len(pattern) lps = compute_lps(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: indices.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Matrix Exponentiation - Fast Fibonacci Computation **Objective**: Implement a function that uses matrix exponentiation to compute large Fibonacci numbers efficiently. **Description**: The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Matrix representation can be utilized to achieve an O(log(n)) time complexity for retrieving the nth Fibonacci number. The transformation matrix T: ``` | 1 1 | | 1 0 | ``` When raised to the power of n, it allows us to compute Fibonacci numbers in logarithmic time. **Function Signature**: ```python def fast_fibonacci(n: int) -> int: pass ``` **Input**: - `n` (0 <= n <= 10^9): The position in the Fibonacci sequence you need to compute. **Output**: - Returns the nth Fibonacci number. **Constraints**: - Use the provided `matrix_exponentiation` and `multiply` functions as part of your solution. - The computation needs to be efficient in handling very large values of `n`. **Examples**: ```python # Example 1 print(fast_fibonacci(0)) # Output: 0 # Example 2 print(fast_fibonacci(1)) # Output: 1 # Example 3 print(fast_fibonacci(10)) # Output: 55 # Example 4 print(fast_fibonacci(50)) # Output: 12586269025 ``` **Hint**: You will need to define the transformation matrix and utilize matrix exponentiation to get the desired Fibonacci number from the resultant matrix. **Implementation Notes**: - Carefully handle matrix multiplication and exponentiation within your function. - Ensure your function can handle the maximum constraint efficiently.","solution":"def matrix_multiply(A, B): Multiplies two 2x2 matrices A and B. return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_exponentiation(matrix, power): Raises the 2x2 matrix to the given power using exponentiation by squaring. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power: if power % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) power //= 2 return result def fast_fibonacci(n): Computes the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 T = [[1, 1], [1, 0]] T_n = matrix_exponentiation(T, n - 1) return T_n[0][0] # The top left element of the matrix T^n-1 gives F(n)"},{"question":"# RSA Encryption/Decryption Implementation **Objective**: Implement a simplified version of RSA encryption and decryption in Python. Your task is to write functions for `key generation`, `encryption`, and `decryption`. **Context**: Alice wants to send a secure message to Bob using RSA encryption. Alice generates a public-private key pair and shares the public key with Bob. Bob encrypts the message using the public key and sends it back to Alice. Alice then decrypts the message using her private key. **Requirements**: 1. Implement the `generate_key(k: int) -> tuple` function for generating RSA key pairs: - Input: `k` - an integer indicating the number of bits in the modulus `n`. - Output: A tuple `(n, e, d)` where: - `n` is the modulus - `e` is the public exponent - `d` is the private exponent 2. Implement the `encrypt(data: int, e: int, n: int) -> int` function for encrypting data: - Input: - `data` - the integer message to be encrypted. - `e` - the public exponent. - `n` - the modulus. - Output: The encrypted message as an integer. 3. Implement the `decrypt(data: int, d: int, n: int) -> int` function for decrypting data: - Input: - `data` - the encrypted message. - `d` - the private exponent. - `n` - the modulus. - Output: The decrypted message as an integer. **Constraints**: - The input message `data` is a non-negative integer. - The bit-length `k` of the modulus `n` is at least 16 bits. **Extra Information**: You may use the helper functions provided to ensure your implementation follows the RSA principles. Pay special attention to handling large numbers and optimizing primality tests. **Example**: ```python n, e, d = generate_key(16) message = 42 encrypted_message = encrypt(message, e, n) decrypted_message = decrypt(encrypted_message, d, n) assert decrypted_message == message ``` **Note**: Your implementation should handle edge cases such as small prime generation, invalid keys, and large input sizes gracefully.","solution":"import random import sympy def generate_key(k: int) -> tuple: Generates RSA key pair. :param k: Number of bits for the modulus. :return: tuple (n, e, d) where: n is the modulus, e is the public exponent, d is the private exponent. # Step 1: Generate two distinct prime numbers p and q p = sympy.randprime(2**(k-1), 2**k) q = sympy.randprime(2**(k-1), 2**k) # Ensure p and q are distinct while p == q: q = sympy.randprime(2**(k-1), 2**k) # Step 2: Compute n = p * q n = p * q # Step 3: Compute φ(n) = (p-1) * (q-1) phi = (p - 1) * (q - 1) # Step 4: Choose e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1 e = random.choice([65537, 3, 17, 257]) # Commonly used prime exponent values while sympy.gcd(e, phi) != 1: e = random.randrange(2, phi) # Step 5: Compute d such that (d * e) mod φ(n) = 1 d = pow(e, -1, phi) return n, e, d def encrypt(data: int, e: int, n: int) -> int: Encrypts data using RSA encryption. :param data: The integer message to be encrypted. :param e: The public exponent. :param n: The modulus. :return: The encrypted integer message. return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypts data using RSA encryption. :param data: The encrypted message. :param d: The private exponent. :param n: The modulus. :return: The decrypted integer message. return pow(data, d, n)"},{"question":"You are given a directed graph with weighted edges represented as an adjacency matrix, where the element at index (i, j) represents the weight of the edge from vertex i to vertex j. If the element is \'inf\', this means there is no direct edge between the two vertices. Write a function `floyd_warshall(graph)` that takes a 2D list (graph) as its input and returns the shortest distances between all pairs of vertices. The output should be a 2D list where the element at index (i, j) represents the shortest distance from vertex i to vertex j. # Input * graph: A 2D list of n x n integers/floats where `graph[i][j]` is the weight of the edge from `i` to `j`. # Output * A 2D list of n x n integers/floats representing the shortest distances between each pair of vertices. # Constraints * 1 ≤ n ≤ 100 (n is the number of vertices) * `graph[i][i] = 0` for all i. * If there\'s no edge between vertex i and j, the graph[i][j] will be a large number e.g. `float(\'inf\')`. * The edges weights can be positive or negative but there will be no negative weight cycles. # Example ```python graph = [ [0, 3, float(\'inf\'), 7], [8, 0, 2, float(\'inf\')], [5, float(\'inf\'), 0, 1], [2, float(\'inf\'), float(\'inf\'), 0] ] print(floyd_warshall(graph)) # Output: # [ # [0, 3, 5, 6], # [5, 0, 2, 3], # [3, 6, 0, 1], # [2, 5, 7, 0] # ] ``` # Function Signature ```python def floyd_warshall(graph): # your code here ``` # Notes - Ensure that your function can handle the edge cases such as isolated nodes (nodes having `inf` distance to other nodes) and graphs with negative edge weights. - You can assume that the given graph will not have negative weight cycles.","solution":"def floyd_warshall(graph): Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices. Parameters: graph (list of list of int/float): The input adjacency matrix where graph[i][j] is the weight of the edge from i to j. Returns: list of list of int/float: A matrix where the element at index (i, j) represents the shortest distance from vertex i to vertex j. n = len(graph) dist = [[graph[i][j] for j in range(n)] for i in range(n)] for k in range(n): for i in range(n): for j in range(n): if dist[i][k] + dist[k][j] < dist[i][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"# Problem: Advanced Elias Coding Algorithm Given the definitions and understanding of Elias Gamma and Elias Delta codings, your task is to implement a more advanced version of these codings that includes both encoding and decoding of positive integers. This added feature should be able to verify the correctness of the coding process by performing round-trip encoding and decoding. Function Signature: ```python def elias_gamma_encode(x: int) -> str: Encodes an integer x using Elias Gamma coding. pass def elias_gamma_decode(encoded: str) -> int: Decodes a binary string encoded using Elias Gamma coding back to the integer. pass def elias_delta_encode(x: int) -> str: Encodes an integer x using Elias Delta coding. pass def elias_delta_decode(encoded: str) -> int: Decodes a binary string encoded using Elias Delta coding back to the integer. pass ``` Input - The functions `elias_gamma_encode` and `elias_delta_encode` will receive a single positive integer `x`, where (1 leq x leq 10^6). - The functions `elias_gamma_decode` and `elias_delta_decode` will receive a string of binary digits. Output - The encoding functions will output the Elias encoded string of binary digits. - The decoding functions will output the decoded integer value from its Elias encoded binary string. Constraints - Any integer or binary string input is guaranteed to be valid, fitting the expected input range. - The performance of both encoding and decoding functions should be efficient, ideally operating within (O(log(n))) or better. Example ```python # Elias Gamma print(elias_gamma_encode(10)) # Example output: \\"0001010\\" print(elias_gamma_decode(\\"0001010\\")) # Example output: 10 # Elias Delta print(elias_delta_encode(10)) # Example output: \\"001010\\" print(elias_delta_decode(\\"001010\\")) # Example output: 10 ``` Note Ensure that your implementation handles edge cases correctly, such as the minimum and maximum integer limits given in constraints. Also, verify the round-trip consistency where `elias_gamma_decode(elias_gamma_encode(x))` should return `x` and the same for `elias_delta_decode(elias_delta_encode(x))`.","solution":"def elias_gamma_encode(x: int) -> str: Encodes an integer x using Elias Gamma coding. if x <= 0: raise ValueError(\\"Elias Gamma encoding is only defined for positive integers.\\") binary_representation = bin(x)[2:] # Get the binary representation of x without \'0b\' prefix n = len(binary_representation) - 1 # Number of leading zeros is (n - 1) # Elias Gamma code is: (n zeros) followed by binary representation of x elias_gamma = \'0\' * n + binary_representation return elias_gamma def elias_gamma_decode(encoded: str) -> int: Decodes a binary string encoded using Elias Gamma coding back to the integer. n = 0 while encoded[n] == \'0\': n += 1 # The length of the binary part of the encoded number. length = n + 1 binary_representation = encoded[n:n + length] return int(binary_representation, 2) def elias_delta_encode(x: int) -> str: Encodes an integer x using Elias Delta coding. if x <= 0: raise ValueError(\\"Elias Delta encoding is only defined for positive integers.\\") binary_representation = bin(x)[2:] # Get the binary representation of x without \'0b\' prefix length_of_x = len(binary_representation) # Length of x in binary, l = log2(x) + 1 # Encode the length of x in binary using Elias Gamma coding elias_gamma_of_length = elias_gamma_encode(length_of_x) # Elias Delta code is elias_gamma(length_of_x) followed by binary_representation omitting the leading \'1\' elias_delta = elias_gamma_of_length + binary_representation[1:] return elias_delta def elias_delta_decode(encoded: str) -> int: Decodes a binary string encoded using Elias Delta coding back to the integer. n = 0 while encoded[n] == \'0\': n += 1 length_of_elias_gamma = n + 1 gamma_part = encoded[:2 * length_of_elias_gamma - 1] length_of_x = elias_gamma_decode(gamma_part) binary_representation = \'1\' + encoded[2 * length_of_elias_gamma - 1: 2 * length_of_elias_gamma - 1 + length_of_x - 1] return int(binary_representation, 2)"},{"question":"# Cycle Sort Implementation and Optimization **Scenario**: You are tasked to sort a list of integers with minimal memory writes, particularly useful when dealing with flash memory storage. Given the need for efficient write operations, your task is to implement a sorting function with minimal memory writes using cycle sort. **Task**: Implement the function `cycle_sort` that takes a list of integers and returns the list sorted in ascending order. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers with length `N` (1 ≤ N ≤ 1000). **Output**: - A list of integers sorted in ascending order. **Constraints**: - Your solution should aim to minimize memory writes. - Ensure that it operates in-place, i.e., without using extra space. **Performance Requirements**: - The time complexity should ideally be O(N^2), taking into account the inherent complexity of cycle sort. - The space complexity should remain O(1). **Example**: ```python Input: [3, 2, 1, 4, 5] Output: [1, 2, 3, 4, 5] Input: [5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5] Input: [1, 2, 3] Output: [1, 2, 3] ``` **Additional Notes**: Provide edge cases to consider, such as arrays that include duplicate values or are already sorted, to test your function against.","solution":"def cycle_sort(arr): n = len(arr) # Go through the array to find cycles to rotate. writes = 0 for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item in the correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Context: You have been hired by a tech company that is working on optimizing storage systems. The company is particularly interested in minimizing write operations due to the hardware constraints of their storage systems. Therefore, understanding and implementing sorting algorithms that can sort data with minimal write operations is crucial. # Task: You are provided with an unsorted list of integers. Your task is to write an efficient function that sorts the list using the Cycle Sort algorithm. This algorithm should minimize the number of write operations. # Function Signature: `def cycle_sort(arr: List[int]) -> List[int]:` # Input: - `arr` (List[int]): A list of integers to be sorted. Length of the list can be up to 10^3. # Output: - Returns a new list (List[int]) that contains all elements from the input list, sorted in non-decreasing order. # Constraints: 1. Do not use any built-in sorting functions. 2. The implemented function should handle arrays where: * The array could be already sorted. * The array could be in reverse order. * The array could contain duplicates. 3. Aim to minimize the number of write operations. # Performance Requirement: Despite the O(N^2) complexity, ensure minimizing write operations is the focus. # Example: ```python # Example 1: arr = [3, 1, 2, 4] print(cycle_sort(arr)) # Expected output [1, 2, 3, 4] # Example 2: arr = [5, 2, 2, 8, 3, 3, 1] print(cycle_sort(arr)) # Expected output [1, 2, 2, 3, 3, 5, 8] # Example 3: arr = [1, 2, 3, 4, 5] print(cycle_sort(arr)) # Expected output [1, 2, 3, 4, 5] ``` # Edge Cases: - Handle an empty array. - Handle an array with all identical elements. # Additional Notes: Focus on the correctness of the Cycle Sort implementation and the minimization of write operations. The efficiency improvements in terms of time complexity are secondary to the primary goal of reducing write operations.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Function to sort an array using Cycle Sort algorithm, which minimizes the number of write operations. writes = 0 # Traverse array elements for cycle_start in range(len(arr) - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Put the item to the correct position if pos != cycle_start: arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Question Implement a function `load_factor_resizable_hash_table` that computes the load factor of a given `ResizableHashTable` instance. The load factor is defined as the number of elements in the hash table divided by the size of the hash table. You will need to ensure that the hash table is dynamically resized as elements are added or removed to maintain an efficient average-case performance. # Input The function will take a `ResizableHashTable` object as input. ```python def load_factor_resizable_hash_table(hash_table: ResizableHashTable) -> float: pass ``` # Output The function should return a float representing the load factor of the hash table. # Constraints * The hash table can hold integer keys and values. * The size of the hash table will always be a power of two due to resizing. * The hash table will use linear probing to resolve collisions. * You should not directly modify the methods of `HashTable` or `ResizableHashTable` classes except to access needed information. # Example ```python rht = ResizableHashTable() rht.put(1, \\"a\\") rht.put(2, \\"b\\") rht.put(3, \\"c\\") # Current size of the hash table is 8 (initial size after instantiation) # Current number of elements is 3 assert load_factor_resizable_hash_table(rht) == 3 / 8 ``` # Additional Details Make sure to handle empty hash tables correctly and ensure your function works efficiently even after multiple resizes have occurred.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.size = initial_size self.table = [None] * self.size self.count = 0 def put(self, key, value): if self.count >= self.size * 0.75: self.resize() index = self.hash_function(key) while self.table[index] is not None: index = (index + 1) % self.size self.table[index] = (key, value) self.count += 1 def hash_function(self, key): return key % self.size def resize(self): old_table = self.table new_size = self.size * 2 self.table = [None] * new_size self.size = new_size self.count = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def load_factor_resizable_hash_table(hash_table: ResizableHashTable) -> float: Returns the load factor of a given ResizableHashTable. return hash_table.count / hash_table.size"},{"question":"# Task Write a Python function that moves all zero elements in an array to the end while maintaining the order of non-zero elements. The function should modify the array in place and use O(1) additional space. # Scenario Imagine you are building a feature for a text editor where unnecessary zero elements need to be moved to the end of a list while preserving the order of other elements. This specifically helps in data processing of text that accidentally includes zero elements. # Specifications - **Function Name**: `move_zeros_in_place` - **Input**: - A list of elements, which may include integers, booleans, strings, etc. - **Output**: - The function should return `None`. The input list should be modified in place. # Constraints - Do not use extra space for another list. Operate within the list provided. - The function should work efficiently with a linear time complexity of O(n). # Example ```python def move_zeros_in_place(array): # Your implementation here # Example Usage array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_in_place(array) print(array) # Expected Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] ``` # Notes - Handle edge cases such as arrays with no zeros, all zeros, and mixed data types. - Ensure boolean `False` is not treated as a zero.","solution":"def move_zeros_in_place(array): Moves all zero elements in the array to the end while maintaining the order of non-zero elements. Modifies the array in place. Parameters: array (list): List of elements that may include integers, booleans, strings, etc. Returns: None non_zero_index = 0 for i in range(len(array)): if array[i] != 0 or isinstance(array[i], bool): array[non_zero_index] = array[i] non_zero_index += 1 for i in range(non_zero_index, len(array)): array[i] = 0"},{"question":"Stuttering Stack Scenario: You have been hired to work on a text processing system where specific values must be duplicated in the order they appear before further processing. To ensure correctness, you need to implement a function that processes a stack and replaces every value in the stack with two occurrences of that value. The user of your function might utilize this function repetitively in a large application dealing with text segments or structured data streams. Function Signature: ```python def stutter_stack(input_stack): :param input_stack: list :return: list ``` Expected Input and Output: - **Input**: A list representing a stack where `input_stack` is the original stack provided as a list of elements. - **Output**: The same list modified in place such that each element is followed immediately by a duplicate of itself. Constraints: - The input stack can contain integers or strings. - A stack with no elements should simply return an empty list. - Elements are not to be reordered, only duplicated in place. Performance Requirements: - The solution should be efficient both in time and space usage. - Avoid unnecessary operations to enhance performance. Example: ```python input_stack = [3, 7, 1, 14, 9] output_stack = stutter_stack(input_stack) print(output_stack) # Expected output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Additional Details: - Use either a stack or queue as intermediate storage. - Properly handle edge cases like empty stacks or single-element stacks.","solution":"def stutter_stack(input_stack): Duplicates each element in the input stack by following it immediately with a duplicate of itself. The input list is modified in place. :param input_stack: list of elements :return: list with duplicate elements i = 0 while i < len(input_stack): input_stack.insert(i + 1, input_stack[i]) i += 2 return input_stack"},{"question":"# Question: Roman Numeral Converter You are tasked with designing a function that converts an integer into its Roman numeral representation. The input integer will be guaranteed to be within the range from 1 to 3999. Function Signature ```python def int_to_roman(num: int) -> str: ``` Input - `num` (int): An integer within the range from 1 to 3999 (inclusive). Output - Returns a string representing the corresponding Roman numeral. Constraints - 1 ≤ `num` ≤ 3999 # Example ```python assert int_to_roman(1994) == \\"MCMXCIV\\" assert int_to_roman(58) == \\"LVIII\\" assert int_to_roman(4) == \\"IV\\" assert int_to_roman(3999) == \\"MMMCMXCIX\\" ``` # Performance Requirements - The solution should have constant time complexity O(1). # Scenario You\'re developing a historical calculator that will display numbers in Roman numerals. The users can input any number within the range from 1 to 3999 and your function must quickly and precisely convert and display it as a Roman numeral.","solution":"def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"# Context In machine learning and data analysis, it\'s common to work with high-dimensional sparse vectors. A sparse vector is a vector in which most of the elements are zero. Efficient storage and computation with such vectors can significantly improve performance, especially when dealing with large datasets. # Problem Statement You are given two high-dimensional sparse vectors. Your task is to convert these vectors to a more memory-efficient format and calculate their dot product. You will implement two functions: one to represent the sparse vector in a compressed format, and another to compute the dot product from the compressed representations. # Function 1: `vector_to_index_value_list` This function converts a vector to a list of tuples, each containing the index and value of non-zero elements. **Input**: - A list of floats `vector`. **Output**: - A list of tuples `(index, value)` representing non-zero elements. # Function 2: `dot_product` This function computes the dot product between two sparse vectors represented by lists of tuples. **Input**: - Two lists of tuples `iv_list1` and `iv_list2`, each containing `(index, value)` pairs representing non-zero elements of the sparse vectors. **Output**: - A float representing the dot product of the two vectors. # Constraints and Notes - The vectors can have a large length (up to 10^6 elements), but the number of non-zero elements will be relatively small (up to 10^3 elements). - The two vectors will always be of the same length. # Example ```python # Function 1 vector = [1.0, 0.0, 0.0, 2.0] result = vector_to_index_value_list(vector) # Expected output: [(0, 1.0), (3, 2.0)] # Function 2 iv_list1 = [(0, 1.0), (3, 2.0)] iv_list2 = [(0, 1.5), (3, 3.0)] result = dot_product(iv_list1, iv_list2) # Expected output: 7.5 ``` # Implementation Implement both functions following the described specifications. Ensure your implementation handles edge cases and performs efficiently given the constraints.","solution":"def vector_to_index_value_list(vector): Converts a vector to a list of tuples, each containing the index and value of non-zero elements. Args: vector (list of float): The input vector. Returns: list of (index, value) tuples: The list of index-value pairs for non-zero elements. return [(i, v) if v != 0 else None for i, v in enumerate(vector) if v != 0] def dot_product(iv_list1, iv_list2): Computes the dot product between two sparse vectors represented by lists of tuples. Args: iv_list1 (list of (index, value) tuples): The first sparse vector in index-value format. iv_list2 (list of (index, value) tuples): The second sparse vector in index-value format. Returns: float: The dot product of the two vectors. dict1 = {index: value for index, value in iv_list1} dict2 = {index: value for index, value in iv_list2} # Compute the dot product for common indices only return sum(dict1[idx] * dict2[idx] for idx in dict1 if idx in dict2)"},{"question":"# Selection Sort Implementation and Reflection You are assigned the task of improving and analyzing the Selection Sort algorithm provided below. Selection Sort is a simple sorting algorithm with a quadratic time complexity that sorts an array by repeatedly finding the minimum element from the unsorted part and putting it at the beginning. Task: 1. Implement the `optimized_selection_sort` function in Python. 2. The function should sort an array of integers in ascending order. 3. Introduce an early stopping mechanism to improve the algorithm\'s performance when the array is already sorted. 4. Finally, reflect on the potential benefits and drawbacks of this improvement. Function Signature: ```python def optimized_selection_sort(arr: list) -> list ``` Input: - A list `arr` of integers that needs to be sorted. Output: - A new list sorted in ascending order. Constraints: - Do not use any built-in sort functions. - Try to maintain the space complexity as O(1). - The original list may contain duplicated values. - Reflect on: - Situations where the optimization made a significant difference. - Would the optimization process still impact overall efficiency positively for large datasets? Example: ```python # Example 1 input_array = [64, 25, 12, 22, 11] output_array = optimized_selection_sort(input_array) print(output_array) # Output: [11, 12, 22, 25, 64] # Example 2 input_array = [5, 4, 3, 2, 1] output_array = optimized_selection_sort(input_array) print(output_array) # Output: [1, 2, 3, 4, 5] # Example 3 input_array = [2, 1, 2, 1, 2] output_array = optimized_selection_sort(input_array) print(output_array) # Output: [1, 1, 2, 2, 2] ``` Hints: - Keep track of whether any swapping happened in each iteration. If no swapping happens, the array is already sorted. - Reflect on how effective this optimization is for different sizes and states of input arrays.","solution":"def optimized_selection_sort(arr): Sorts an array of integers using an optimized selection sort algorithm. Introduces early stopping if the array is found to be already sorted during the process. :param arr: List of integers to be sorted. :return: List of integers sorted in ascending order. n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] # Check if the array is already sorted sorted = True for k in range(i+1, n-1): if arr[k] > arr[k+1]: sorted = False break if sorted: break return arr"},{"question":"# Question: Validate Pattern String Mapping Given a pattern and a string `str`, your task is to implement a function that checks if `str` follows the same pattern. # Function Signature ```python def word_pattern(pattern: str, str: str) -> bool: ``` # Parameters * `pattern` (str): A string containing only lowercase letters. * `str` (str): A string containing lowercase letters separated by a single space. # Returns * `bool`: Returns `True` if `str` follows the same pattern as `pattern`, otherwise `False`. # Description Ensure that there is a one-to-one mapping (bijection) between a character in the `pattern` and a non-empty word in `str`. For `str` to follow the pattern: * Each character in `pattern` must map to exactly one word in `str`. * No two characters in `pattern` should map to the same word. * The number of words in `str` must match the number of characters in `pattern`. # Constraints * You may assume `pattern` contains only lowercase letters. * `str` contains lowercase letters separated by a single space. * 1 <= len(pattern), len(str) <= 10^4 # Examples Example 1 - Input: `pattern = \\"abba\\"`, `str = \\"dog cat cat dog\\"` - Output: `True` Example 2 - Input: `pattern = \\"abba\\"`, `str = \\"dog cat cat fish\\"` - Output: `False` Example 3 - Input: `pattern = \\"aaaa\\"`, `str = \\"dog cat cat dog\\"` - Output: `False` Example 4 - Input: `pattern = \\"abba\\"`, `str = \\"dog dog dog dog\\"` - Output: `False` Example 5 - Input: `pattern = \\"abc\\"`, `str = \\"dog cat fish\\"` - Output: `True` # Notes - Consider all edge cases where the length of both `pattern` and `str` do not match. - Ensure efficiency, especially with constraints close to the upper limit.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char else: if char_to_word[char] != word: return False return True"},{"question":"You are working on optimizing a software system that requires efficient storage and manipulation of multiple boolean flags. These flags are represented as individual bits within integers. Your task is to write a function that leverages low-level bit manipulation to maximize performance. Complete the following function: ```python def manipulate_bits(num, operations): num: (int) An integer that contains the bits to manipulate. operations: (List[Tuple[str, int, Optional[int]]]) A list of tuples where each tuple represents an operation to perform on the bits of num. Each tuple is of the form (operation, index, value), where: * \'operation\' is a string, one of \'get\', \'set\', \'clear\', or \'update\'. * \'index\' is an integer representing the bit position to operate on. * \'value\' is an integer (either 0 or 1) only used for the \'update\' operation. Returns: The modified integer after all operations have been applied. def get_bit(num, i): return (num & (1 << i)) != 0 def set_bit(num, i): return num | (1 << i) def clear_bit(num, i): mask = ~(1 << i) return num & mask def update_bit(num, i, bit): mask = ~(1 << i) return (num & mask) | (bit << i) # Write your code here to process all operations # and return the modified num # Example usage: num = 42 operations = [(\'get\', 1, None), (\'set\', 2, None), (\'clear\', 3, None), (\'update\', 4, 1)] print(manipulate_bits(num, operations)) ``` Input * `num`: An integer representing the initial set of bits. * `operations`: A list of operations to perform on `num`. Each operation is a tuple consisting of: - A string (`\'get\'`, `\'set\'`, `\'clear\'`, or `\'update\'`). - An integer index `i` indicating the bit position. - A value `bit`, which is only relevant for the `\'update\'` operation and is either 0 or 1. Output * For the `\'get\'` operation, the function should return a list of booleans indicating whether the bit at each specified index is 1 (`True`) or 0 (`False`). * For the `\'set\'`, `\'clear\'`, and `\'update\'` operations, the function should return the modified integer `num` after applying all operations sequentially. Constraints * Assume `0 <= index < 32` (for a 32-bit integer). * Operations are provided in the order they should be executed.","solution":"def manipulate_bits(num, operations): num: (int) An integer that contains the bits to manipulate. operations: (List[Tuple[str, int, Optional[int]]]) A list of tuples where each tuple represents an operation to perform on the bits of num. Each tuple is of the form (operation, index, value), where: * \'operation\' is a string, one of \'get\', \'set\', \'clear\', or \'update\'. * \'index\' is an integer representing the bit position to operate on. * \'value\' is an integer (either 0 or 1) only used for the \'update\' operation. Returns: The modified integer after all \'set\', \'clear\', and \'update\' operations have been applied. For \'get\' operations, the corresponding boolean results are returned as a list in sequence. def get_bit(num, i): return (num & (1 << i)) != 0 def set_bit(num, i): return num | (1 << i) def clear_bit(num, i): mask = ~(1 << i) return num & mask def update_bit(num, i, bit): mask = ~(1 << i) return (num & mask) | (bit << i) get_results = [] for op in operations: if op[0] == \'get\': get_results.append(get_bit(num, op[1])) elif op[0] == \'set\': num = set_bit(num, op[1]) elif op[0] == \'clear\': num = clear_bit(num, op[1]) elif op[0] == \'update\': num = update_bit(num, op[1], op[2]) return get_results if get_results else num"},{"question":"# Rotating an NxN Matrix You are given an `n x n` 2D matrix representing an image. Write a function `rotate_matrix(matrix)` that rotates the matrix by 90 degrees clockwise, achieving this in-place. Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the matrix by 90 degrees clockwise in-place. :param matrix: List of List of integers representing an n x n matrix. :return: None. The matrix is modified in place. ``` Input: - A 2D list `matrix` where `matrix[i][j]` represents the element in the ith row and jth column. Output: - The function should not return anything. The matrix should be modified in place. Constraints: - The matrix will be an `n x n` matrix. - 1 <= n <= 20 - -1000 <= matrix[i][j] <= 1000 Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Performance Requirements: - The function should run efficiently within the given constraints. - The algorithm must operate in-place with O(1) additional space complexity. Scenario: A software engineer is implementing a graphic manipulation tool that processes images represented as NxN pixel matrices. In one of the editing modes, the tool needs to rotate images 90 degrees clockwise based on user input. The rotation must be performed directly on the pixel matrix with the constraint of minimal memory usage. Notes: - Consider special cases such as single-element matrices and ensure that they are handled gracefully. - Inline comments and a brief explanation of the logic would be helpful for code reviewers.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the matrix by 90 degrees clockwise in-place. :param matrix: List of List of integers representing an n x n matrix. :return: None. The matrix is modified in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i+1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Scenario Suppose you are working on a software project that requires efficient sorting of medium-sized datasets but you do not need the absolute fastest algorithm. You opt for Shell Sort due to its simplicity and adequate performance improvement over simpler algorithms like insertion sort and bubble sort. # Task Implement the Shell Sort algorithm with an optimized gap sequence to sort an array of integers. Here, you will use the Knuth sequence for the gaps which is defined by the formula: (h = 3*h + 1), starting from 1. Write a function `optimized_shell_sort` which performs Shell Sort using the Knuth sequence. # Requirements 1. **Input**: A list of integers `arr`. 2. **Output**: The input list sorted in ascending order. 3. **Constraints**: * The input list contains no more than 10,000 integers. * Each integer in the list is between (-10^6) and (10^6). # Function Signature ```python def optimized_shell_sort(arr: list) -> list: pass ``` # Example ```python # Example input arr = [34, 8, 64, 51, 32, 21] # Expected output print(optimized_shell_sort(arr)) # Output: [8, 21, 32, 34, 51, 64] ``` **Note**: Your solution should handle edge cases such as empty lists, single-element lists, and already sorted lists efficiently. Focus on correctness and optimal performance by leveraging the Knuth sequence for gaps.","solution":"def optimized_shell_sort(arr: list) -> list: Sorts a list of integers using Shell Sort with the Knuth sequence. n = len(arr) h = 1 # Generate the maximum Knuth sequence value for the given array length while h < n // 3: h = 3 * h + 1 # Perform the shell sort while h >= 1: for i in range(h, n): temp = arr[i] j = i while j >= h and arr[j - h] > temp: arr[j] = arr[j - h] j -= h arr[j] = temp h = h // 3 return arr"},{"question":"# Binary Search Challenge Objective Implement a function `binary_search` using both iterative and recursive methods to find a target value in a sorted array. Additionally, validate that your functions handle various edge cases correctly. Detailed Description 1. **Iterative Method**: * Implement the `binary_search` function that takes an array and a target value as inputs and returns the index of the target in the array or `None` if the target does not exist in the array. 2. **Recursive Method**: * Implement the `binary_search_recur` function that takes an array, a range within the array (`low` and `high` indices), and a target value as inputs and returns the index of the target in the array or `-1` if the target does not exist. 3. **Edge Cases**: * Test with an empty array. * Test with an array where the target value does not exist. * Test with all elements being the same. * Test at the range boundaries (start and end of the array). Function Signatures ```python def binary_search(array, query): Iterative Binary Search Args: array (List[int]): Sorted list of integers query (int): Element to find Returns: int: Index of the found element or None if not found pass def binary_search_recur(array, low, high, val): Recursive Binary Search Args: array (List[int]): Sorted list of integers low (int): Starting index high (int): Ending index val (int): Element to find Returns: int: Index of the found element or -1 if not found pass ``` Input and Output Specifications * **Input**: * `binary_search(array, query)` * `array` (List of integers): The sorted array to search. * `query` (integer): The value to search for. * `binary_search_recur(array, low, high, val)` * `array` (List of integers): The sorted array to search. * `low` (integer): The lower index of the current search range. * `high` (integer): The upper index of the current search range. * `val` (integer): The value to search for. * **Output**: * For `binary_search`: Return the index of the query element or `None` if not found. * For `binary_search_recur`: Return the index of the query element or `-1` if not found. Constraints * The input array will have a maximum length of (10^5). * The elements of the array and the target value will be bounded by ([-10^9, 10^9]). Performance Requirements * Both functions should be efficient enough to handle the upper constraint limits. Example ```python # Example usage of binary_search array = [1, 2, 3, 4, 5, 6, 7, 8, 9] query = 5 print(binary_search(array, query)) # Output: 4 # Example usage of binary_search_recur array = [1, 2, 3, 4, 5, 6, 7, 8, 9] val = 5 print(binary_search_recur(array, 0, len(array)-1, val)) # Output: 4 ``` Additional Notes * Ensure the functions handle all edge cases as specified. * Write your test cases to validate your implementations.","solution":"def binary_search(array, query): Iterative Binary Search Args: array (List[int]): Sorted list of integers query (int): Element to find Returns: int: Index of the found element or None if not found low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return None def binary_search_recur(array, low, high, val): Recursive Binary Search Args: array (List[int]): Sorted list of integers low (int): Starting index high (int): Ending index val (int): Element to find Returns: int: Index of the found element or -1 if not found if low > high: return -1 mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: return binary_search_recur(array, mid + 1, high, val) else: return binary_search_recur(array, low, mid - 1, val)"},{"question":"Reverse Words in a String Problem Statement Given a string `S` consisting of multiple words separated by spaces, write a function `reverse_words_in_string(S)` that reverses the order of the words. Ensure that unnecessary spaces are managed correctly and only a single space separates words in the output. Input * A string `S` (1 <= |S| <= 10^4), where `S` consists of printable ASCII characters and spaces. Expected Output * A string with the words in reversed order and single spacing between words. Constraints * You may not use additional libraries for reversing or rotating. * Preserve the order of characters within each word. Example * **Input**: `\\" Hello world from OpenAI \\"` * **Output**: `\\"OpenAI from world Hello\\"` Function Signature ```python def reverse_words_in_string(S: str) -> str: # Your implementation here pass ``` Requirements 1. Strip leading and trailing spaces from the input string. 2. Ensure only one space separates the reversed words. 3. Handle edge cases appropriately. Testing ```python assert reverse_words_in_string(\\" the sky is blue \\") == \\"blue is sky the\\" assert reverse_words_in_string(\\" OpenAI is great \\") == \\"great is OpenAI\\" assert reverse_words_in_string(\\"good\\") == \\"good\\" assert reverse_words_in_string(\\"\\") == \\"\\" ``` ** Performance Requirements: The function should run efficiently within the given constraints and handle up to 10,000 characters promptly.","solution":"def reverse_words_in_string(S: str) -> str: Reverses the order of words in a string, ensuring that only a single space separates words in the output. Leading and trailing spaces in the input string are removed. # Step 1: Split the string into words words = S.strip().split() # Step 2: Reverse the list of words reversed_words = words[::-1] # Step 3: Join the list into a string with a single space separator result = \' \'.join(reversed_words) return result"},{"question":"# Minimum Spanning Tree Using Kruskal\'s Algorithm Context You are tasked with implementing a part of a network design project. You\'re given multiple undirected, connected graphs representing different network scenarios, with each node representing a computer and each edge representing a possible cable connection with an associated cost. The goal is to determine the minimum cost to connect all computers in each scenario. Task Implement the function `kruskal_mst(vertex_count, edges)` that calculates the total minimum cost (the sum of the weights) of the Minimum Spanning Tree (MST) using Kruskal\'s Algorithm. Function Signature ```python def kruskal_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: Args: vertex_count (int): Number of vertices in the graph. edges (List[Tuple[int, int, int]]): Each tuple consists of (u, v, weight). Returns: int: The sum of weights of the minimum spanning tree. ``` Input * `vertex_count` - An integer `n` (1 <= n <= 5000), the number of nodes. * `edges` - A list of `m` tuples (1 <= m <= 100000), where each tuple contains three integers `u`, `v`, and `weight` representing an edge between node `u` and node `v` with an edge weight. (`1 <= u, v <= n` and `1 <= weight <= 10000`). Output The function should return a single integer, which is the sum of the weights of the MST. Constraints * The graph is guaranteed to be connected. * Each input graph has `n-1` or more edges ensuring MST is possible. Example ```python assert kruskal_mst(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)]) == 14 assert kruskal_mst(3, [(2, 1, 20), (3, 1, 20), (2, 3, 100)]) == 40 ``` Notes 1. Use Kruskal\'s Algorithm to sort edges and build the MST. 2. Implement and use the Disjoint Set data structure with path compression and union by rank for efficiency. 3. Ensure proper zero-based indexing for Python list operations.","solution":"from typing import List, Tuple # Disjoint Set (Union-Find) class with path compression and union by rank class DisjointSet: def __init__(self, vertex_count): self.parent = list(range(vertex_count)) self.rank = [0] * vertex_count def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: # Union by rank if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: Args: vertex_count (int): Number of vertices in the graph. edges (List[Tuple[int, int, int]]): Each tuple consists of (u, v, weight). Returns: int: The sum of weights of the minimum spanning tree. # Sort edges by their weight edges.sort(key=lambda x: x[2]) # Initialize disjoint set ds = DisjointSet(vertex_count) mst_cost = 0 mst_edges_count = 0 for u, v, weight in edges: # Convert u and v to zero-based index u -= 1 v -= 1 if ds.find(u) != ds.find(v): ds.union(u, v) mst_cost += weight mst_edges_count += 1 if mst_edges_count == vertex_count - 1: break return mst_cost"},{"question":"You are tasked with developing a function to check if a given string can be segmented into space-separated words from a provided dictionary. The function should employ a dynamic programming approach to efficiently solve the problem. # Function Specification Write a function `can_segment_word(word, word_dict)` that takes the following parameters: * `word` (str): A non-empty string consisting of lowercase letters. * `word_dict` (List[str]): A list of non-empty words without duplicates. # Output The function should return a boolean value: * `True` if the given string can be segmented into one or more space-separated words from the dictionary. * `False` otherwise. # Constraints 1. The input string \'word\' consists of lowercase English letters. 2. The dictionary `word_dict` contains no duplicate words. 3. The length of `word` is at most 10,000. 4. The length of `word_dict` is at most 10,000. 5. The words in `word_dict` consist of lowercase English letters only and the length of each word is at most 100. # Example ```python word = \\"applepenapple\\" word_dict = [\\"apple\\", \\"pen\\"] # Expected output: True # Explanation: The string can be segmented as \\"apple pen apple\\". word = \\"catsandog\\" word_dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] # Expected output: False # Explanation: The string cannot be fully segmented using the provided dictionary. ``` # Task Implement the `can_segment_word` function using a dynamic programming approach. Ensure you handle edge cases and optimize for performance where possible.","solution":"def can_segment_word(word, word_dict): Determines if the word can be segmented into space-separated words from the provided dictionary :param word: (str) The input string consisting of lowercase letters :param word_dict: (List[str]) List of non-empty words without duplicates :return: (bool) True if the word can be segmented, otherwise False word_set = set(word_dict) dp = [False] * (len(word) + 1) dp[0] = True # Base condition: An empty string can always be segmented for i in range(1, len(word) + 1): for j in range(i): if dp[j] and word[j:i] in word_set: dp[i] = True break return dp[len(word)]"},{"question":"# Implementation Task You are tasked with implementing a Binary Heap (Min Heap) in Python. The binary heap should support the following operations efficiently: 1. **insert(val)**: Insert the value `val` into the heap. 2. **remove_min()**: Remove and return the minimum element from the heap. 3. **peek_min()**: Return the minimum element without removing it from the heap. 4. **heapify(array)**: Transform the given array into a heap. Implement the `BinaryHeap` class with the provided methods, paying close attention to maintaining the min heap properties: ```python class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): Helper function to percolate up pass def insert(self, val): Insert a value in the heap pass def min_child(self, i): Helper function to find the minimum child index pass def perc_down(self, i): Helper function to percolate down pass def remove_min(self): Remove and return the minimum element pass def peek_min(self): Return the minimum element without removing it pass def heapify(self, array): Transform an array into a heap pass ``` # Requirements - **Function signatures**: - `def insert(self, val):` - `def remove_min(self):` - `def peek_min(self):` - `def heapify(self, array):` - **Input constraints**: - Inserted values can be any integers. - Remove operations on an empty heap should return `None` to indicate no element to remove. # Test Cases Ensure your implementation passes the following test cases: 1. Inserting into an empty heap and checking the minimum. 2. Removing the minimum from a populated heap. 3. Transforming a random array into a valid heap. Example: ```python bh = BinaryHeap() bh.insert(10) bh.insert(20) bh.insert(5) assert bh.peek_min() == 5 assert bh.remove_min() == 5 assert bh.peek_min() == 10 bh.heapify([4, 10, 3, 5]) assert bh.peek_min() == 3 assert bh.remove_min() == 3 assert bh.peek_min() == 4 ``` Ensure your code is efficient and handles edge cases gracefully.","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): Insert a value in the heap self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while (i * 2) <= self.current_size: min_child = self.min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def remove_min(self): Remove and return the minimum element if self.current_size == 0: return None min_elem = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_elem def peek_min(self): Return the minimum element without removing it if self.current_size == 0: return None return self.heap[1] def heapify(self, array): Transform an array into a heap self.current_size = len(array) self.heap = [0] + array[:] i = len(array) // 2 while i > 0: self.perc_down(i) i -= 1"},{"question":"Context You are a software developer and you are asked to work on a text editor that involves finding and displaying differences between text files. One of the core functionalities is to determine the minimum number of deletions required to make two strings identical. Task Write a function `min_distance_optimized(word1, word2)` that computes the minimum number of steps required to make two given strings the same, by only deleting characters. Aim to optimize the space complexity of your solution. Function Signature ```python def min_distance_optimized(word1: str, word2: str) -> int: ``` Input * `word1`: a string representing the first word (0 <= len(word1) <= 1000). * `word2`: a string representing the second word (0 <= len(word2) <= 1000). Output * Returns an integer representing the minimum number of deletion steps to make the string identical. Constraints * You should optimize for space complexity. * Strings consist of lowercase English characters only. Example ```python assert min_distance_optimized(\\"sea\\", \\"eat\\") == 2 assert min_distance_optimized(\\"leetcode\\", \\"etco\\") == 4 assert min_distance_optimized(\\"\\", \\"abc\\") == 3 assert min_distance_optimized(\\"abc\\", \\"\\") == 3 assert min_distance_optimized(\\"a\\", \\"a\\") == 0 assert min_distance_optimized(\\"a\\", \\"b\\") == 2 ``` Keep in mind to handle edge cases and to provide explanations through comments in your code. Performance Requirement - Time complexity should be `O(m*n)`. - Optimize the space complexity to `O(min(m, n))` where `m` and `n` are the lengths of the input strings `word1` and `word2`.","solution":"def min_distance_optimized(word1: str, word2: str) -> int: Calculate the minimum number of steps to make two strings identical by deleting characters. This solution uses dynamic programming with optimized space complexity. # Ensure word1 is the longer of the two words for optimized space usage if len(word1) < len(word2): word1, word2 = word2, word1 # Get lengths of the two words len1, len2 = len(word1), len(word2) # Create a previous and current row for the DP table prev = [0] * (len2 + 1) # Fill the DP table for i in range(1, len1 + 1): curr = [0] * (len2 + 1) for j in range(1, len2 + 1): if word1[i-1] == word2[j-1]: curr[j] = prev[j-1] + 1 # Characters match, increment LCS count else: curr[j] = max(prev[j], curr[j-1]) # Choose the max of left or top value in the DP table prev = curr # Update the previous row to the current row # Minimum deletions = Total length of both words - 2 * length of LCS lcs_length = prev[len2] return (len1 - lcs_length) + (len2 - lcs_length)"},{"question":"# RSA Encryption Algorithm You are required to implement a secure message exchange system using the RSA encryption algorithm. The system should allow the generation of public and private keys, encryption of messages using the public key, and decryption of messages using the corresponding private key. # Requirements Implement the following functions: 1. **generate_key**(k, seed=None): * Input: * `k` (int): The number of bits in the modulus `n`. * `seed` (optional int): Random seed for reproducibility (defaults to None). * Output: * Tuple `(n, e, d)` where: * `n` (int): The modulus for both the public and private keys. * `e` (int): The public exponent. * `d` (int): The private exponent. * Complexity: The function should efficiently generate the key parameters. 2. **encrypt**(data, e, n): * Input: * `data` (int): The message to be encrypted. * `e` (int): The public exponent. * `n` (int): The modulus. * Output: * `encrypted_data` (int): The encrypted message. * Complexity: The function should perform encryption efficiently. 3. **decrypt**(data, d, n): * Input: * `data` (int): The encrypted message to be decrypted. * `d` (int): The private exponent. * `n` (int): The modulus. * Output: * `decrypted_data` (int): The decrypted message. * Complexity: The function should perform decryption efficiently. # Constraints * 1 ≤ k ≤ 1024. * Messages to encrypt `data` are non-negative integers less than `n`. * Ensure that the keys generated are valid and functional. # Example Usage ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Notes * You should handle and optimize the generation of prime numbers and modular inversion. * Ensure your code is efficient for larger key sizes within the provided constraints.","solution":"import random from sympy import isprime, mod_inverse def generate_large_prime(bits): while True: prime_candidate = random.getrandbits(bits) if isprime(prime_candidate): return prime_candidate def generate_key(k, seed=None): if seed is not None: random.seed(seed) p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = mod_inverse(e, phi) return n, e, d def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# Invert a Matrix **Objective**: Implement a function to find the inverse of an ( n times n ) matrix, given the matrix is invertible (i.e., it has a non-zero determinant). **Function Signature**: ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` **Instructions**: 1. The function should accept an ( n times n ) matrix (a list of lists) and return its inverse. 2. Ensure that the matrix is square and has a valid (non-zero) determinant. 3. If the matrix is not square, not invertible, or invalid, raise an appropriate exception. 4. Use the cofactor expansion method for this inversion. **Input**: * A list of lists representing a square matrix, where each sublist contains floats representing matrix elements. * The matrix will have dimensions ( n times n ), where ( n geq 2 ). **Output**: * A list of lists representing the inverse of the input matrix. **Constraints**: * The matrix is guaranteed to be invertible if it is square and has non-zero determinant. * Matrix dimension ( n cap [2, 100] ). **Performance Requirements**: * Time complexity should be ( O(n^3) ). * Space complexity should be ( O(n^2) ) for storing intermediate and final matrices. **Example**: ```python matrix = [ [4, 7], [2, 6] ] assert invert_matrix(matrix) == [ [0.6, -0.7], [-0.2, 0.4] ] ``` **Notes**: * Implementing helper functions like `get_determinant`, `get_minor`, and any additional necessary functions is encouraged for code readability. * Proper error handling will be part of the evaluation criteria.","solution":"from typing import List def get_determinant(matrix: List[List[float]]) -> float: Compute the determinant of a square matrix. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(n): determinant += ((-1) ** c) * matrix[0][c] * get_determinant(get_minor(matrix, 0, c)) return determinant def get_minor(matrix: List[List[float]], row: int, col: int) -> List[List[float]]: Get the minor of a matrix excluding the specified row and column. return [row[:col] + row[col+1:] for row in (matrix[:row] + matrix[row+1:])] def get_matrix_of_minors(matrix: List[List[float]]) -> List[List[float]]: Compute the matrix of minors for a given square matrix. minors = [] n = len(matrix) for i in range(n): minors_row = [] for j in range(n): minor = get_minor(matrix, i, j) minors_row.append(get_determinant(minor)) minors.append(minors_row) return minors def transpose(matrix: List[List[float]]) -> List[List[float]]: Transpose a matrix. return list(map(list, zip(*matrix))) def get_cofactor_matrix(matrix: List[List[float]]) -> List[List[float]]: Compute the cofactor matrix of a given square matrix. n = len(matrix) minors = get_matrix_of_minors(matrix) cofactors = [] for i in range(n): cofactor_row = [] for j in range(n): cofactor_row.append(((-1) ** (i + j)) * minors[i][j]) cofactors.append(cofactor_row) return cofactors def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: Compute the inverse of a square matrix. n = len(matrix) if n != len(matrix[0]): raise ValueError(\\"Matrix must be square to find its inverse.\\") determinant = get_determinant(matrix) if determinant == 0: raise ValueError(\\"Matrix is not invertible because its determinant is zero.\\") cofactor_matrix = get_cofactor_matrix(matrix) adjugate = transpose(cofactor_matrix) inverse_matrix = [] for row in adjugate: inverse_row = [element / determinant for element in row] inverse_matrix.append(inverse_row) return inverse_matrix"},{"question":"# Matrix Multiplication Context You are working on a scientific computation project that involves performing matrix multiplications to analyze large datasets. Efficient and error-free matrix multiplications are crucial for your project\'s success. Task Implement a function `matrix_multiplication` that: 1. Takes two matrices as input. 2. Returns their product if the dimensions are compatible. 3. Raises an exception with an appropriate message if the matrices cannot be multiplied due to incompatible dimensions. Function Signature ```python def matrix_multiplication(multiplicand: list, multiplier: list) -> list: Perform matrix multiplication of two matrices. :param multiplicand: List[List[int]] - a 2D list representing the first matrix. :param multiplier: List[List[int]] - a 2D list representing the second matrix. :return: List[List[int]] - a 2D list representing the product matrix. :raises Exception: if multiplicand and multiplier have incompatible dimensions. ``` Input and Output * **Input**: Two matrices represented as 2D lists. For example: ```python multiplicand = [[1, 2, 3], [4, 5, 6]] multiplier = [[7, 8], [9, 10], [11, 12]] ``` * **Output**: A new 2D list after multiplication: ```python result = [[58, 64], [139, 154]] ``` Constraints * Assume the elements in the matrices are integers. * The matrices will have at least one element. * Do not use any external libraries or advanced frameworks; a straightforward approach is expected. * The matrices should follow standard dimensions rules for multiplication, i.e., if `multiplicand` is of size (m x n), `multiplier` must be of size (n x p). Performance Consideration * The function should handle matrices of various sizes efficiently. * Aim for a solution within O(m * n * p) time complexity, as this is the expected standard level of performance for this problem.","solution":"def matrix_multiplication(multiplicand: list, multiplier: list) -> list: Perform matrix multiplication of two matrices. :param multiplicand: List[List[int]] - a 2D list representing the first matrix. :param multiplier: List[List[int]] - a 2D list representing the second matrix. :return: List[List[int]] - a 2D list representing the product matrix. :raises Exception: if multiplicand and multiplier have incompatible dimensions. # Check if multiplication is possible if len(multiplicand[0]) != len(multiplier): raise Exception(\\"Incompatible dimensions for matrix multiplication\\") # Dimensions of the resulting matrix result_rows = len(multiplicand) result_cols = len(multiplier[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(result_cols)] for _ in range(result_rows)] # Perform matrix multiplication for i in range(result_rows): for j in range(result_cols): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You are given a `m x n` grid filled with the following values: - `0` representing an empty land. - `1` representing a building. Your task is to find the shortest distance from all buildings to the closest empty land such that you minimize the travel distance. The distance is defined as the sum of the distances from all buildings to the chosen empty land. If it is not possible to find such empty place, return -1. # Input * An integer grid `matrix` of size `m x n`, where `0 <= m, n <= 1000`. # Output * Return an integer that represents the minimum distance if a valid empty land exists; otherwise, return `-1`. # Constraints * Buildings (1s) are connected to empty lands via 4 possible directions (up, down, left, right). * There can be multiple buildings in the grid. # Example ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_distance(grid) == 7 # Explanation: If you choose the bottom-left corner as the empty land, the total distance is 7. [building1->3, building2->3, building3->1] grid = [ [1, 0] ] assert shortest_distance(grid) == 1 # Explanation: The only possible empty land is at distance 1 from the building. grid = [ [1, 1] ] assert shortest_distance(grid) == -1 # Explanation: No empty land is available. ``` # Function Signature ```python def shortest_distance(grid: List[List[int]]) -> int: pass ``` # Additional Notes * Pay attention to performance considerations and edge cases as described in the analysis. * Assume proper imports and error handling within this function scope.","solution":"from collections import deque from typing import List def shortest_distance(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) total_buildings = 0 total_distance = [[0] * n for _ in range(m)] reachable_buildings = [[0] * n for _ in range(m)] def bfs(start_x, start_y): visited = [[False] * n for _ in range(m)] distance = [[0] * n for _ in range(m)] queue = deque([(start_x, start_y, 0)]) visited[start_x][start_y] = True while queue: x, y, dist = queue.popleft() for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True total_distance[nx][ny] += dist + 1 reachable_buildings[nx][ny] += 1 queue.append((nx, ny, dist + 1)) for i in range(m): for j in range(n): if grid[i][j] == 1: total_buildings += 1 bfs(i, j) min_dist = float(\\"inf\\") for i in range(m): for j in range(n): if grid[i][j] == 0 and reachable_buildings[i][j] == total_buildings: min_dist = min(min_dist, total_distance[i][j]) return min_dist if min_dist != float(\\"inf\\") else -1"},{"question":"# Array Filtering Challenge Scenario: You are working on a data analysis application where you often need to filter numerical datasets based on given range criteria. You need to implement a function that filters an array such that only the numbers within a specified range are retained. Task: Write a function `filter_by_range(arr, min_value=None, max_value=None)` that takes the following parameters: - `arr`: A list of integers. - `min_value`: An integer representing the minimum value (inclusive) for filtering the array. If `None`, no lower limit is applied. - `max_value`: An integer representing the maximum value (inclusive) for filtering the array. If `None`, no upper limit is applied. The function should return a new list containing only the values from the input list `arr` that fall within the range `[min_value, max_value]`. Examples: ```python # Example 1 input_arr = [10, 20, 30, 40, 50] min_value, max_value = 15, 35 output = filter_by_range(input_arr, min_value, max_value) print(output) # Output: [20, 30] # Example 2 input_arr = [1, 3, 5, 7, 9] min_value, max_value = None, 6 output = filter_by_range(input_arr, min_value, max_value) print(output) # Output: [1, 3, 5] # Example 3 input_arr = [2, 4, 6, 8, 10] min_value, max_value = 3, None output = filter_by_range(input_arr, min_value, max_value) print(output) # Output: [4, 6, 8, 10] ``` Constraints: - Do not use any external libraries (e.g., NumPy or Pandas). - Ensure the function handles edge cases such as empty arrays and arrays where all values fall outside the specified range. - The function should work efficiently for large arrays, with a time complexity of O(n). Notes: - Assume all elements in `arr` are integers. - Aim for a clear and maintainable implementation.","solution":"def filter_by_range(arr, min_value=None, max_value=None): Returns a list of integers from `arr` that are within the range [min_value, max_value]. Parameters: - arr (list of int): The input list of integers. - min_value (int or None): The minimum value (inclusive) for filtering the array. - max_value (int or None): The maximum value (inclusive) for filtering the array. Returns: - list of int: The list of integers from `arr` within the specified range. filtered = [] for num in arr: if (min_value is None or num >= min_value) and (max_value is None or num <= max_value): filtered.append(num) return filtered"},{"question":"Custom Sort using Gnome Sort Variant You are given a list of integers. Your task is to write a Python function that implements a modified version of the Gnome Sort algorithm to sort the list. However, the twist is that you need to sort the even and odd numbers of the list separately. The even numbers should be sorted in non-decreasing order at the beginning of the list, followed by the odd numbers sorted in non-increasing order. Example ```python Input: [34, 2, 1, 45, 33, 4, 11, 22] Output: [2, 4, 22, 34, 45, 33, 11, 1] Input: [10, 20, 5, 3, 8, 15, 7] Output: [8, 10, 20, 15, 7, 5, 3] ``` Function Signature ```python def custom_gnome_sort(arr): pass ``` Constraints - The list may contain up to 10,000 elements. - All elements are integers within the range of -1,000,000 to 1,000,000. Instructions - Implement and test the `custom_gnome_sort` function. - The function should modify the input list in place and also return it. - You must use the core principles of the Gnome Sort algorithm. Note Implementing another sorting algorithm (like Quicksort or Mergesort) to solve the problem directly will not be accepted. The essence of the task is to demonstrate understanding of Gnome Sort through modification and application to different requirements.","solution":"def custom_gnome_sort(arr): def gnome_sort(sublist): index = 0 while index < len(sublist): if index == 0: index += 1 if sublist[index] >= sublist[index - 1]: index += 1 else: sublist[index], sublist[index - 1] = sublist[index - 1], sublist[index] index -= 1 # Separate the even and odd numbers evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] # Sort the even numbers in non-decreasing order gnome_sort(evens) # Sort the odd numbers in non-increasing order and then reverse them gnome_sort(odds) odds.reverse() # Combine the sorted evens and odds sorted_arr = evens + odds # Update the original list for i in range(len(arr)): arr[i] = sorted_arr[i] return arr"},{"question":"You are given a non-negative integer represented as a non-empty array of digits, arranged such that the most significant digit is at the head of the list. Write a function that increments the integer by one and returns the resulting array of digits. Implement the function `plus_one(digits: List[int]) -> List[int]` which accepts a list of integers representing the digits of the number and returns the incremented result in the same format. # Input * `digits`: A list of integers `digits` where each element `digits[i]` is a digit between 0 and 9. # Output * A list of integers representing the incremented value. # Constraints * The input array `digits` will have at least one element, and all elements will be between 0 and 9. * You are not allowed to convert the array into an integer directly to solve the problem. # Performance Requirements * The algorithm should run in O(n) time where n is the number of digits. * Try to optimize for in-place modifications to minimize space usage. # Examples 1. Input: `digits = [1, 2, 3]` Output: `[1, 2, 4]` 2. Input: `digits = [4, 3, 2, 1]` Output: `[4, 3, 2, 2]` 3. Input: `digits = [9]` Output: `[1, 0]` 4. Input: `digits = [9, 9, 9]` Output: `[1, 0, 0, 0]` # Edge Cases 1. All digits are `9`: Input `[9, 9, 9]` should produce `[1, 0, 0, 0]`. 2. Single-digit `9`: Input `[9]` should produce `[1, 0]`. Implement the function and provide test cases to demonstrate its correctness and efficiency.","solution":"def plus_one(digits): Increments the number represented by the digits array by one and returns the resulting digits array. n = len(digits) carry = 1 for i in range(n-1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 carry = 1 else: digits[i] = new_digit carry = 0 break if carry == 1: digits.insert(0, 1) return digits"},{"question":"# Knapsack Problem Optimization You are provided with weights and values of `n` items and a knapsack with a maximum capacity. Implement a function to determine the maximum value that can be obtained by putting items into the knapsack. Your task is to modify the given dynamic programming approach to handle larger datasets more efficiently if possible and ensure handling multiple test cases. Given: * `n`: the number of items * `capacity`: the maximum weight the knapsack can carry * `values`: a list of integers representing the values of the items * `weights`: a list of integers representing the weights of the items **Function Signature:** ```python def knapsack(n: int, capacity: int, values: List[int], weights: List[int]) -> int: ``` **Inputs:** - `n` is an integer (1 leq n leq 1000) - `capacity` is an integer (1 leq mathrm{capacity} leq 10000) - `values` is a list of `n` integers, (1 leq mathrm{values}[i] leq 1000) - `weights` is a list of `n` integers, (1 leq mathrm{weights}[i] leq 1000) **Output:** - Returns an integer representing the maximum value that can be obtained. **Example:** ```python assert knapsack(4, 5, [60, 50, 70, 30], [5, 3, 4, 2]) == 80 assert knapsack(3, 8, [10, 40, 30], [5, 4, 6]) == 40 ``` **Performance Requirements:** 1. The code should efficiently handle up to the upper constraint limits. 2. Aim to maintain the current time complexity if possible. **Scenario:** You are part of an expedition team with a limited carrying capacity. Each member can carry a number of valuable items of various weights. Determine the highest possible total value of items the team can carry based on your available weight capacity.","solution":"from typing import List def knapsack(n: int, capacity: int, values: List[int], weights: List[int]) -> int: # Initializing a list for the dynamic programming approach dp = [0] * (capacity + 1) # Iterating through all items for i in range(n): # Iterating through the knapsack capacity from high to low for w in range(capacity, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[capacity]"},{"question":"Context: In a disease monitoring system, each patient ID is stored in a singly linked list. Each node in the list represents a unique patient ID. Sometimes, we need to remove a specific patient from the monitoring system, provided we have access to the node representing the patient to be removed. We need to perform the removal operation in constant time. Design a function that deletes a given node from the singly linked list efficiently. Task: Write a function `delete_patient_node(node: Node) -> None` which, given a node (except the tail) to delete from the singly linked list, removes the node. Function Signature: ```python def delete_patient_node(node: Node) -> None: pass ``` Input: * `node` - A reference to the node to be deleted. This is a valid node and not the tail node in the list. Output: * The function should modify the list in place and not return anything. Constraints: * The node will always be a valid, non-tail node in the list. * The node will not be `None`. Example: Suppose the linked list is as below: * Before deletion: `1 -> 2 -> 3 -> 4` * Given node (with value `3`) to delete. After calling the function, the linked list should be: * After deletion: `1 -> 2 -> 4` Requirements: 1. The function must run in constant time O(1). 2. The function must not use any extra space, hence O(1) space complexity.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_patient_node(node: Node) -> None: Deletes the given node from the singly linked list. Parameters: node (Node): The node to be deleted. This node is guaranteed to be non-tail node. if node and node.next: node.val = node.next.val node.next = node.next.next"},{"question":"# Question Implement a function `limited_repetition_elements(lst, N)` that takes a list `lst` and an integer `N` and returns a new list that contains each number from the original list at most `N` times, without changing the order of appearance. You must implement an efficient version of the function using a hash table to ensure the solution runs in O(n) time complexity. Input * A list of integers `lst` where 0 ≤ len(lst) ≤ 10^5 and -1000 ≤ lst[i] ≤ 1000 for all i. * An integer `N` where 0 ≤ N ≤ len(lst). Output * A list of integers with each element appearing at most `N` times following their original order. # Constraints * Your solution should run with a time complexity of O(n). * Ensure to handle edge cases like an empty list, `N` equals to zero, and lists with identical elements. # Example ```python limited_repetition_elements([1,2,3,1,2,1,2,3], 2) # Output: [1,2,3,1,2,3] limited_repetition_elements([20,37,20,21], 1) # Output: [20,37,21] limited_repetition_elements([], 2) # Output: [] limited_repetition_elements([4,4,4,4], 3) # Output: [4,4,4] limited_repetition_elements([4,4,4,4], 0) # Output: [] ``` # Function Signature ```python def limited_repetition_elements(lst, N): pass ``` Implement the function `limited_repetition_elements` to pass the example cases and constraints.","solution":"def limited_repetition_elements(lst, N): Takes a list lst and an integer N and returns a new list that contains each number from the original list at most N times, maintaining the original order. if N == 0: return [] count = {} result = [] for element in lst: if element in count: if count[element] < N: count[element] += 1 result.append(element) else: count[element] = 1 result.append(element) return result"},{"question":"# Coding Challenge: Implement a Combined Endianness Conversion Function Problem Statement You are tasked with implementing a combined function that can convert integers to a specified endianness representation in bytes and vice versa. This single function should handle both big-endian and little-endian conversions based on an additional parameter. Function Signature ```python def convert_endian(num, is_big_endian=True, to_bytes=True): Convert an integer to its byte representation or vice versa, considering the endianness. :param num: An integer if `to_bytes` is True, a bytes object if `to_bytes` is False. :param is_big_endian: Boolean flag indicating if the conversion should use big-endian format. :param to_bytes: Boolean flag indicating conversion direction. True for integer to bytes, False otherwise. :return: A bytes object if `to_bytes` is True, an integer if `to_bytes` is False. pass ``` Input 1. `num`: An integer when `to_bytes` is True, or a bytes object when `to_bytes` is False. 2. `is_big_endian`: A boolean indicating the endianness format. True for big-endian, False for little-endian. 3. `to_bytes`: A boolean indicating the conversion direction. True for converting an integer to bytes, False for bytes to integer. Output * Depending on the value of `to_bytes`: - If `to_bytes` is True: A bytes object representing the integer `num` in the specified endianness. - If `to_bytes` is False: An integer reconstructed from the bytes object `num`, considering the specified endianness. Constraints * Assume integers are non-negative. * The implementation should handle large integers efficiently. * Do not use Python\'s built-in library functions (`int.to_bytes` or `int.from_bytes`). Example ```python >>> convert_endian(305419896, is_big_endian=True, to_bytes=True) b\'x12x34x56x78\' >>> convert_endian(b\'x12x34x56x78\', is_big_endian=True, to_bytes=False) 305419896 >>> convert_endian(305419896, is_big_endian=False, to_bytes=True) b\'x78x56x34x12\' >>> convert_endian(b\'x78x56x34x12\', is_big_endian=False, to_bytes=False) 305419896 ``` Notes * Ensure edge cases such as zero conversion are handled correctly. * Aim for optimized performance, particularly for large integers.","solution":"def convert_endian(num, is_big_endian=True, to_bytes=True): Convert an integer to its byte representation or vice versa, considering the endianness. :param num: An integer if `to_bytes` is True, a bytes object if `to_bytes` is False. :param is_big_endian: Boolean flag indicating if the conversion should use big-endian format. :param to_bytes: Boolean flag indicating conversion direction. True for integer to bytes, False otherwise. :return: A bytes object if `to_bytes` is True, an integer if `to_bytes` is False. if to_bytes: hex_string = hex(num)[2:] if len(hex_string) % 2: hex_string = \'0\' + hex_string byte_array = bytes.fromhex(hex_string) if is_big_endian: return byte_array else: return byte_array[::-1] else: if not is_big_endian: num = num[::-1] return int.from_bytes(num, \'big\')"},{"question":"# Matrix Transformation Problem Given an n x n matrix, implement four transformation functions to: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix from the top-left to bottom-right diagonal. 4. Invert the matrix from the bottom-left to top-right diagonal. Each function should take a single n x n matrix and return the transformed matrix. Your implementation should ensure clarity, correctness, and efficiency. Input - A 2D list `matrix` representing an n x n matrix where 1 <= n <= 20. Output - A 2D list representing the transformed matrix based on the specific function requested. # Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Rotate clockwise # Expected Output # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Rotate counterclockwise # Expected Output # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] # Top left invert # Expected Output # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] # Bottom left invert # Expected Output # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Constraints - In your code, focus on making the solution clean and easy to understand. - Ensure to handle edge cases like empty matrices and single-element matrices.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the matrix from the top-left to bottom-right diagonal. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the matrix from the bottom-left to top-right diagonal. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"# Context In combinatorial mathematics, a permutation of an arrangement of objects often needs to be computed in lexicographical order. As part of this, you may need to find the next permutation sequence of a given number. # Problem Statement Write a function named `next_bigger(num: int) -> int` that takes a positive integer `num` and returns the next higher number that has the exact same set of digits. If no such number exists, return `-1`. # Input - A single integer `num` (1 ≤ num ≤ 10^9). # Output - An integer representing the next higher permutation with the same digits, or `-1` if no such permutation exists. # Constraints - Your function should handle at least up to 9 digits efficiently. - The expected time complexity is O(n), where n is the number of digits in `num`. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(99999) == -1 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 ``` # Implementation Notes Ensure to address edge cases such as: - When the input number is the highest permutation of its digits. - When all digits are the same. - When handling large numbers close to the upper constraint.","solution":"def next_bigger(num: int) -> int: Returns the next higher number that has the exact same set of digits as num. If no such number exists, returns -1. digits = list(str(num)) n = len(digits) # Step 1: Find the largest index k such that digits[k] < digits[k + 1] k = n - 2 while k >= 0 and digits[k] >= digits[k + 1]: k -= 1 if k == -1: return -1 # Step 2: Find the largest index l greater than k such that digits[k] < digits[l] l = n - 1 while digits[k] >= digits[l]: l -= 1 # Step 3: Swap digits[k] and digits[l] digits[k], digits[l] = digits[l], digits[k] # Step 4: Reverse the sequence from digits[k + 1] to the end digits = digits[:k + 1] + digits[k + 1:][::-1] return int(\\"\\".join(digits))"},{"question":"**Objective**: Write a Python function to identify the two unique numbers in a list where every other number appears exactly twice. Context In an array of numbers, every element except for two appears exactly twice. Your task is to identify these two unique numbers using the XOR-based strategy. Function Signature ```python def find_two_unique_numbers(nums: List[int]) -> List[int]: :param nums: List[int] - List of integers where exactly two elements appear once and all other elements appear twice. :return: List[int] - A list containing the two unique elements. ``` Input - A list `nums` of integers (1 <= len(nums) <= 3 * 10^4). Output - A list containing the two unique numbers. Constraints - The numbers only appear either once or twice. - The function must run in O(N) time complexity. - The function must use constant space, O(1). Example ```python assert find_two_unique_numbers([1, 2, 1, 3, 2, 5]) == [3, 5] or find_two_unique_numbers([1, 2, 1, 3, 2, 5]) == [5, 3] assert find_two_unique_numbers([4, 1, 2, 1, 2, 3, 4, 6]) == [3, 6] or find_two_unique_numbers([4, 1, 2, 1, 2, 3, 4, 6]) == [6, 3] ``` Description 1. Use XOR operation to cancel out the pairs and isolate A^B where A and B are the unique numbers. 2. Identify a bit where A and B differ. 3. Use this bit to partition the array into two groups. 4. Apply XOR within each group to find the unique numbers. Hints 1. XOR of a number with itself is 0. 2. XOR of a number with 0 is the number itself. 3. Finding the rightmost set bit can help partition the numbers. Write the function `find_two_unique_numbers` to achieve the objective.","solution":"from typing import List def find_two_unique_numbers(nums: List[int]) -> List[int]: Identify the two unique numbers in a list where every other number appears exactly twice. :param nums: List[int] - List of integers where exactly two elements appear once and all other elements appear twice. :return: List[int] - A list containing the two unique elements. # Step 1: XOR all the numbers together. The result will be A ^ B where A and B are the unique numbers. xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find a bit set in the xor_all result. To find the rightmost set bit, we can use: rightmost_set_bit = xor_all & -xor_all # Step 3: Partition the numbers into two groups based on the rightmost set bit. # Group1 will have the bit and Group2 will not have the bit set. unique1, unique2 = 0, 0 for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num # Step 4: The result, unique1 and unique2 are the two unique numbers. return [unique1, unique2]"},{"question":"# Radix Sorting Implementation and Analysis Scenario You are tasked with implementing the radix sort algorithm to sort a list of non-negative integers in increasing order. Your implementation should handle typical edge cases and provide a detailed examination of the algorithm\'s process. Task Write a function `perform_radix_sort` in Python to sort a given list. Additionally, provide a detailed explanation of the algorithm\'s mechanics and performance considerations based on the input list. ``` def perform_radix_sort(arr): Implement radix sort to arrange arr in ascending order. Args: arr (List[int]): List of non-negative integers to sort. Returns: List[int]: Sorted list in ascending order. # Your code here return arr ``` Explanation Requirements 1. Explain the main steps the algorithm performs. 2. Describe any key mechanisms involved in each sorting iteration. 3. Outline any potential edge cases and how your implementation addresses them. 4. Discuss the expected time and space complexity of your solution. Constraints - The list contains non-negative integers. - The length of the list is in the range of 1 to (10^6). - The integers in the list are in the range of 0 to (10^9). Performance Requirement Your implementation should be efficient in both time and space, given the large range of possible list lengths and integer values.","solution":"def counting_sort_for_radix(arr, exp): A helper function to perform counting sort on arr based on the digit represented by exp. Args: arr (List[int]): List of non-negative integers to sort. exp (int): The digit position to sort by. Returns: List[int]: Partially sorted list. n = len(arr) # Output array, initialized to 0 output = [0] * n # Initialize count array to 0 for digits 0 to 9 count = [0] * 10 # Store the count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that it contains the position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr now contains sorted numbers for i in range(n): arr[i] = output[i] return arr def perform_radix_sort(arr): implements radix sort to arrange arr in ascending order. Args: arr (List[int]): List of non-negative integers to sort. Returns: List[int]: Sorted list in ascending order. if not arr: # Handling the edge case of empty array return arr # Find the maximum number to know the number of digits max_num = max(arr) # Perform counting sort for every digit exp = 1 while max_num // exp > 0: counting_sort_for_radix(arr, exp) exp *= 10 return arr"},{"question":"You are given an array of integers `nums` where every element appears exactly three times except for one element that appears exactly once. Write a function to find that single one. ***Constraint***: - Your algorithm should run in O(n) time and use a constant amount of extra space. # Function Signature ```python def single_non_triplicate(nums: List[int]) -> int: pass ``` # Input - `nums`: A list of integers where each integer except one appears exactly three times. # Output - The unique integer which appears exactly once in the list. # Example ```python # Example 1 nums = [2, 2, 3, 2] assert single_non_triplicate(nums) == 3 # Example 2 nums = [0, 1, 0, 1, 0, 1, 99] assert single_non_triplicate(nums) == 99 ``` # Explanation Consider the input `[2, 2, 3, 2]`, every element except one (3) appears exactly three times. The function should return 3. In the case of `[0, 1, 0, 1, 0, 1, 99]`, zero and one appear three times each, while 99 appears only once, so the solution should return 99. # Assumptions - The input list `nums` is non-empty. - There is exactly one element that appears once, and all other elements appear exactly three times. Implement the function with these constraints and examples in mind.","solution":"def single_non_triplicate(nums): Finds the element that appears exactly once in a list where every other element appears exactly three times. ones, twos = 0, 0 for num in nums: # If num appears in ones, move it to twos twos |= ones & num # XOR num with ones ones ^= num # Create a mask for elements that appears three times threes = ones & twos # Remove elements that appear three times from ones and twos ones &= ~threes twos &= ~threes return ones"},{"question":"Given an input string consisting of repeated characters, implement functions for Run-Length Encoding (RLE) and decoding of this string as described below. Function Signature: ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` Input: * `encode_rle` function will take a single argument: * `input` (string): A string consisting of any printable ascii characters. * `decode_rle` function will take a single argument: * `input` (string): A string representing the run-length encoded data. Output: * `encode_rle` function should return a string, which is the run-length encoded version of the input. * `decode_rle` function should return a string, which is the decoded original string. Constraints: * The input strings will have at most length 10^5. * Characters in the input string for encoding will be printable ASCII characters. * The format of the input string for decoding will always be a valid run-length encoded string. Example: ```python # Example 1: input_string = \\"aaabbc\\" encoded_string = encode_rle(input_string) print(encoded_string) # Output: \\"3a2b1c\\" decoded_string = decode_rle(encoded_string) print(decoded_string) # Output: \\"aaabbc\\" # Example 2: input_string = \\"a\\" encoded_string = encode_rle(input_string) print(encoded_string) # Output: \\"1a\\" decoded_string = decode_rle(encoded_string) print(decoded_string) # Output: \\"a\\" ``` # Requirements: * Your solution must correctly handle edge cases such as: * Empty string * Strings with a single character * Strings with no repeated characters * Ensure that the implementation handles the given constraints efficiently.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] last_char = input[0] count = 1 for char in input[1:]: if char == last_char: count += 1 else: encoded.append(f\\"{count}{last_char}\\") last_char = char count = 1 # Append the final set of characters encoded.append(f\\"{count}{last_char}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] i = 0 length = len(input) while i < length: count = \\"\\" while i < length and input[i].isdigit(): count += input[i] i += 1 char = input[i] decoded.append(char * int(count)) i += 1 return \'\'.join(decoded)"},{"question":"# Question You are required to implement a version of the Priority Queue with the following attributes and functionalities: 1. **Attributes**: - `priority_queue_list`: List to store queue nodes. 2. **Functionalities**: - `__init__(self, items=None, priorities=None)`: Initializes the queue with the optional items and priorities, or empty. - `size(self)`: Returns the current size of the queue. - `push(self, item, priority=None)`: Inserts an item with an optional priority. If no priority is provided, uses the item\'s value. - `pop(self)`: Removes and returns the item with the lowest priority. # Input and Output - **Function Signature**: ```python class PriorityQueue: def __init__(self, items=None, priorities=None): pass def size(self) -> int: pass def push(self, item: int, priority: int = None) -> None: pass def pop(self) -> int: pass ``` - **Example**: ```python pq = PriorityQueue() pq.push(4) pq.push(2, 1) pq.push(5, 10) print(pq.size()) # Output: 3 print(pq.pop()) # Output: 2 print(pq.pop()) # Output: 4 print(pq.size()) # Output: 1 ``` # Constraints * Empty queue `pop()` should handle gracefully. * Priority values can be positive or negative integers. # Requirements 1. **Efficiency**: Ensure your implementation is capable of handling up to 100,000 elements efficiently for push and pop operations. 2. **Correctness**: Ensure that elements are correctly prioritized and the queue maintains the correct ordering after each operation. Write clear and concise code that implements these functionalities.","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self.priority_queue_list, (priority, item)) def pop(self): if self.size() > 0: return heapq.heappop(self.priority_queue_list)[1] else: return None"},{"question":"# Question: Implement Enhanced Ternary Search You are given a sorted array `arr` of unique integers and a target integer `key`. Your task is to implement an enhanced version of the ternary search algorithm to find the index of `key` in `arr`. Function Signature ```python def enhanced_ternary_search(arr: List[int], key: int) -> int: ``` Input * `arr`: A list of unique integers sorted in ascending order. * `key`: An integer representing the target value to search for. Output * Return the index of `key` if it is present in `arr`, otherwise return -1. Constraints 1. The array length will be between 1 and 10^5. 2. Each integer in the array will be within the range [-10^9, 10^9]. 3. The key will be within the range [-10^9, 10^9]. Example Scenarios 1. Given `arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]` and `key = 1`, the function should return `0`. 2. Given `arr = [2, 4, 8, 16, 32, 64, 128]` and `key = 32`, the function should return `4`. 3. Given `arr = [-10, -5, 0, 3, 7, 10, 15, 20]` and `key = 7`, the function should return `4`. 4. Given `arr = [1, 3, 5, 7, 9]` and `key = 2`, the function should return `-1`. Additional Instructions 1. Ensure your solution is optimized for performance, taking advantage of the properties of the ternary search. 2. Consider edge cases, such as when the array is empty or contains just one element.","solution":"def enhanced_ternary_search(arr, key): Performs an enhanced ternary search on a sorted array of unique integers. Parameters: arr (List[int]): A list of unique integers sorted in ascending order. key (int): The target value to search for. Returns: int: The index of \'key\' in \'arr\' if present, -1 otherwise. left, right = 0, len(arr) - 1 while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"**Objective**: Implement and analyze the Shell Sort algorithm. **Context**: You are part of a team developing a software that efficiently sorts lists of numbers. One of the sorting mechanisms under consideration is the Shell Sort. Your task is to implement it from scratch and optimize it for performance. **Task**: Write a function `optimized_shell_sort` that sorts a list of integers. An optimized gap sequence is crucial for performance improvement – use Ciura’s gap sequence which is known to be effective. **Input**: - A list of integers `arr`, where ( 0 leq len(arr) leq 10^5 ). **Output**: - A sorted list of integers in non-decreasing order. **Constraints**: - The array length can be zero, which should result in an empty list output. - Elements can be negative, zero, or positive integers. - Optimize the function to handle larger inputs efficiently. **Requirements**: - The function must use Shell Sort with the Ciura\'s gap sequence `[701, 301, 132, 57, 23, 10, 4, 1]`. ```python def optimized_shell_sort(arr): \'\'\' Optimized Shell Sort using Ciura\'s gap sequence. \'\'\' gaps = [701, 301, 132, 57, 23, 10, 4, 1] n = len(arr) for gap in gaps: # Perform gapped insertion sort for this gap size. for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr # Sample Input arr = [64, 34, 25, 12, 22, 11, 90] # Sample Output # [11, 12, 22, 25, 34, 64, 90] ``` **Edge Cases to Consider**: - An empty list should return an empty list. - A list with a single element should return the same list.","solution":"def optimized_shell_sort(arr): \'\'\' Optimized Shell Sort using Ciura\'s gap sequence. \'\'\' gaps = [701, 301, 132, 57, 23, 10, 4, 1] n = len(arr) for gap in gaps: # Perform gapped insertion sort for this gap size. for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Flatten Nested Arrays You have been given an array that contains zero or more nested arrays, and your task is to flatten this array into a single-dimensional array. The order of elements should be preserved as they appear in the original nested array. Write a function `flatten_array(nested_array)` that takes a potentially deeply nested array and returns a new array with all the elements in a single dimension. Input - `nested_array`: A list that can contain arbitrarily nested lists of integers, strings, or other primitive types. Output - A list of elements in a single dimension, preserving the original order. # Constraints - Do not use any library function other than basic Python functions. - Elements of the nested array are either `int`, `float`, `str`, or lists containing these types. - Assume the max depth of nesting will not cause stack overflow for simplicity. # Performance Requirements - Your solution should have a time complexity of O(n), where n is the total number of elements across all nested arrays. - Your solution should mind the space complexity limits for handling large output arrays. # Example Input: ```python nested_array = [1, [2, 3, [4, 5]], [6, [7, 8, [9]], 10], 11] ``` Output: ```python [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] ``` Input: ```python nested_array = [\\"a\\", [\\"b\\", [\\"c\\", \\"d\\"], \\"e\\"], \\"f\\"] ``` Output: ```python [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"] ```","solution":"def flatten_array(nested_array): Flattens a deeply nested array into a single-dimensional array while preserving order. :param nested_array: A list which may contain nested lists of integers, strings, or other primitive types :return: A single-dimensional list with all elements result = [] def _flatten(current_array): for item in current_array: if isinstance(item, list): _flatten(item) else: result.append(item) _flatten(nested_array) return result"},{"question":"You have been tasked with improving and extending a basic Hash Table implementation that uses linear probing for collision resolution. The new Hash Table class should have the capability to: - Auto-resize when it becomes 70% full. - Handle rehashing when full to maintain performance. # Task Implement a class `AdvancedHashTable` that extends the provided `ResizableHashTable`. Your implementation should add the following: - A method `resize_and_rehash` to resize the table to twice its current size. - A method `find_next_prime` to find the next prime number greater than double the current size for the new size of the hash table. - A method `optimal_put` that efficiently handles rehashing and insertion to minimize clustering and collision issues. # Specifications 1. **Class Definition**: `AdvancedHashTable` should have the following method definitions: - `resize_and_rehash()` - `find_next_prime(n)` - `optimal_put(key, value)` 2. **Methods**: - `resize_and_rehash`: Resizes the hash table once it reaches its load factor of 0.7 and rehashes the existing items using the new size found by `find_next_prime`. - `find_next_prime(n)`: Finds the next prime number greater than `n`. This will be used to determine the new size for `resize_and_rehash`. - `optimal_put(key, value)`: Acts as an optimized version of `put` with improved linear probing. # Constraints 1. Assume the hash table will store integers as keys and values. 2. The initial size of the hash table should be `11`. 3. The auto-resize threshold is 0.7 (i.e., resize when the table is 70% full). 4. New size after resizing should always be the next prime greater than double the current size for better performance. # Input Format - Keys are integers. - Values are integers. # Output Format - No direct output format. Methods should handle internal states of the hash table correctly. # Example ```python ht = AdvancedHashTable() ht.optimal_put(12, 100) print(ht.get(12)) # Should return 100 ht.del_(12) print(ht.get(12)) # Should return None # Demonstrate resizing for i in range(8): ht.optimal_put(i, i*10) # At this point, the hash table should resize as it hits 70% capacity ```","solution":"class AdvancedHashTable: def __init__(self): self.size = 11 self.count = 0 self.load_factor = 0.7 self.table = [None] * self.size def put(self, key, value): index = self._hash(key) initial_index = index while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.size if index == initial_index: return self.table[index] = (key, value) self.count += 1 if self.count / self.size > self.load_factor: self.resize_and_rehash() def get(self, key): index = self._hash(key) initial_index = index while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size if index == initial_index: return None return None def del_(self, key): index = self._hash(key) initial_index = index while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return index = (index + 1) % self.size if index == initial_index: return def resize_and_rehash(self): old_table = self.table new_size = self.find_next_prime(2 * self.size) self.size = new_size self.table = [None] * self.size self.count = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def find_next_prime(self, n): def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True prime = n while not is_prime(prime): prime += 1 return prime def optimal_put(self, key, value): self.put(key, value) def _hash(self, key): return key % self.size"},{"question":"# Hailstone Sequence Analyzer You are tasked with enhancing the classic hailstone sequence function. The standard hailstone algorithm takes a starting integer `n` and generates the sequence by the rules of the Collatz conjecture. # Task: Create a function `hailstone_info` that not only computes the hailstone sequence for a given integer `n` but also returns additional information about the sequence: - The length of the sequence. - The maximum value reached in the sequence. # Function Signature: ```python def hailstone_info(n: int) -> (list, int, int): Generate the hailstone sequence for the given integer n, and return the sequence, its length, and the maximum value reached. Parameters: - n: An integer representing the starting point of the hailstone sequence (1 <= n <= 10^6). Returns: - sequence: A list containing the hailstone sequence. - length: An integer representing the length of the sequence. - max_value: The maximum value reached in the sequence. ``` # Example: ```python hailstone_info(7) # should return: # ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 17, 52) ``` # Constraints: 1. The function must handle edge cases such as the smallest possible input (n=1). 2. The function must be efficient and able to handle inputs up to 1,000,000 within reasonable time constraints. # Notes: Encourage students to consider edge cases and optimize their solution for performance without compromising the correctness.","solution":"def hailstone_info(n: int) -> (list, int, int): Generate the hailstone sequence for the given integer n, and return the sequence, its length, and the maximum value reached. Parameters: - n: An integer representing the starting point of the hailstone sequence (1 <= n <= 10^6). Returns: - sequence: A list containing the hailstone sequence. - length: An integer representing the length of the sequence. - max_value: The maximum value reached in the sequence. if n <= 0: raise ValueError(\\"The input must be a positive integer.\\") sequence = [] max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 if n > max_value: max_value = n sequence.append(1) length = len(sequence) return sequence, length, max_value"},{"question":"You are implementing a function to determine if one string is a rotated version of another string. This problem is crucial in several applications such as pattern recognition in text files, manipulation of circular buffers, and detecting sequences in cyclic data structures. Function Signature: ```python def is_rotated(s1: str, s2: str) -> bool: ``` # Input: * `s1` (str): The original string. * `s2` (str): The string that may be a rotated version of `s1`. # Output: * (bool): Return `True` if `s2` is a rotated version of `s1`, otherwise return `False`. # Constraints: * The length of `s1` and `s2` will be at most (10^4). * Both `s1` and `s2` consist of lowercase letters only. # Example: ```python is_rotated(\\"hello\\", \\"llohe\\") -> True is_rotated(\\"hello\\", \\"helol\\") -> False is_rotated(\\"abcde\\", \\"cdeab\\") -> True is_rotated(\\"abcde\\", \\"abced\\") -> False is_rotated(\\"abc\\", \\"abc\\") -> True is_rotated(\\"\\", \\"\\") -> True is_rotated(\\"a\\", \\"a\\") -> True is_rotated(\\"a\\", \\"b\\") -> False ``` # Explanation: 1. For strings \\"hello\\" and \\"llohe\\", rotating \\"hello\\" right by 2 steps results in \\"llohe\\", so the function returns `True`. 2. For strings \\"hello\\" and \\"helol\\", any rotation of \\"hello\\" does not match \\"helol\\", so the function returns `False`. 3. This logic should be efficiently implemented to handle large inputs within the given constraints. You should focus on implementing the most optimal solution with minimal time and space complexity, and consider edge cases to ensure your solution is robust.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotated version of s1. # Check if lengths are different, immediately return False if len(s1) != len(s2): return False # Extension of s1 to check for rotation in a single pass return s2 in (s1 + s1)"},{"question":"# ZigZag Iterator Extension **Context**: You\'ve been given the task to extend the functionality of the ZigZag Iterator to handle multiple lists, not just two. This new iterator should iterate over multiple lists in a round-robin fashion until all lists are exhausted. This extended iterator is referred to as the `MultiZigZagIterator`. **Objective**: Implement the `MultiZigZagIterator` class with an initializer that can take a list of lists, and two methods: `next` to return the next element in the sequence, and `has_next` to check if there are any remaining elements to be returned. # Function Signatures: ```python class MultiZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` **Expected Behavior**: - Initialize the iterator with multiple lists. - Alternate elements from each list in the sequence. - Handle lists of different lengths gracefully. # Constraints: - You may assume that the input lists contain only integers. - Ensure that your implementation efficiently handles up to 10^4 elements in total across all input lists. # Example: ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] it = MultiZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) print(result) # Expected Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Additional Notes: - Focus on the algorithm\'s scalability and efficiency. - Robustly handle edge cases, such as empty lists or single-element lists.","solution":"from collections import deque class MultiZigZagIterator: def __init__(self, lists): Initialize the MultiZigZagIterator with a list of lists. :type lists: List[List[int]] self.queue = deque((lst, i) for i, lst in enumerate(lists) if lst) self.pointers = [0] * len(lists) def next(self): Return the next element in the sequence. :rtype: int if self.queue: lst, idx = self.queue.popleft() element = lst[self.pointers[idx]] self.pointers[idx] += 1 if self.pointers[idx] < len(lst): self.queue.append((lst, idx)) return element else: raise StopIteration def has_next(self): Return whether there are any remaining elements. :rtype: bool return bool(self.queue)"},{"question":"**Problem Statement**: Write a function `move_zeros_to_end` that takes a list `lst` as input and returns a new list where all the zeros are moved to the end, while the order of the non-zero elements is preserved. **Function Signature**: ```python def move_zeros_to_end(lst: list) -> list: ``` **Input and Output**: - **Input**: A list `lst` of arbitrary elements including integers, strings, and boolean values. - Example: `[False, 4, 0, 3, 0, True, 1, \\"zero\\", 0.0]` - **Output**: A list where all zeros are moved to the end. - Example: `[False, 4, 3, True, 1, \\"zero\\", 0.0, 0, 0]` **Constraints**: - The function should only move the integer value `0` to the end. - The function should not consider boolean `False` or other falsy values like empty strings or none as zeros. - The function\'s time complexity should be O(n) and space complexity O(n). **Performance Requirements**: - Efficient handling of lists up to 10^6 elements. **Edge Cases**: - An empty list should return an empty list. - A list with no zero should remain unchanged. - A list with all elements as zeros should return a list of zeros maintaining the same length. **Example**: ```python assert move_zeros_to_end([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] ``` * Write a function `move_zeros_to_end` using the provided function signature that adheres to the specified constraints and edge cases.","solution":"def move_zeros_to_end(lst): Moves all zeros in the list to the end while preserving the order of non-zero elements. if not lst: return [] # Collect all non-zero elements and zeros separately non_zeros = [x for x in lst if x != 0 or type(x) == bool] zero_count = len(lst) - len(non_zeros) # Append zeros at the end result = non_zeros + [0] * zero_count return result"},{"question":"# Maximum Pipeline Flow in a Network Context You are tasked with finding the maximum flow in a network of pipelines, where the capacity of each pipeline is represented by an adjacency matrix. Your task is to implement an algorithm that computes this maximum flow using Depth-First Search (DFS) to identify augmenting paths. Prompt Given an n * n adjacency matrix `graph`, where `graph[i][j]` represents the capacity of the pipeline from node `i` to node `j`. Write a function `maximum_pipeline_flow(graph)` that returns the maximum flow from the source (node 0) to the sink (last node). Function Signature ```python def maximum_pipeline_flow(graph: List[List[int]]) -> int: pass ``` Input * `graph`: List of lists representing an n x n adjacency matrix `graph` (0 <= n <= 100). The capacity values will be non-negative integers. Output * Return an integer which is the maximum flow from the source to the sink. Constraints * For any `n * n` adjacency matrix: * `0 <= graph[i][j] <= 10^5` * `graph[i][j]` indicates the capacity from node `i` to node `j`, and `graph[i][j] = 0` means there is no direct edge from `i` to `j`. Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_pipeline_flow(graph)) # Output: 23 ``` Notes * Ensure the implementation uses DFS for finding augmenting paths. * Handle potential edge cases such as no connection between source and sink. * Pay attention to the efficiency and correctness of your algorithm to handle larger input sizes.","solution":"from typing import List def maximum_pipeline_flow(graph: List[List[int]]) -> int: def bfs(source, sink, parent): visited = [False] * len(graph) queue = [] queue.append(source) visited[source] = True while queue: u = queue.pop(0) for ind, val in enumerate(graph[u]): if visited[ind] == False and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u return visited[sink] source = 0 sink = len(graph) - 1 parent = [-1] * len(graph) max_flow = 0 while bfs(source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are required to implement an improved version of the Merge Sort algorithm that optimizes space usage by performing in-place merging of subarrays. **Function Signature:** ```python def merge_sort_in_place(arr: List[int]) -> None: Perform an in-place merge sort on the provided array. Parameters: arr (List[int]): A list of integers to be sorted. Returns: None: The list is sorted in place. ``` # Constraints: * The input array will contain at most (10^5) elements. * The elements of the array will be integers within the range ([-10^9, 10^9]). * You should not use any additional list to perform the merge operation. # Instructions: * Implement the function `merge_sort_in_place` to modify the input list in place to sort it. * Your algorithm should retain the O(n log n) time complexity while minimizing the additional space complexity to O(1). # Example: **Input:** ```python arr = [38, 27, 43, 3, 9, 82, 10] merge_sort_in_place(arr) print(arr) ``` **Output:** ```python [3, 9, 10, 27, 38, 43, 82] ``` # Additional Notes: - Be mindful of edge cases such as empty arrays, single-element arrays, and arrays with all identical elements. - Ensure your implementation does not exceed the given constraints and performs efficiently with large inputs.","solution":"from typing import List def merge_sort_in_place(arr: List[int]) -> None: Perform an in-place merge sort on the provided array. Parameters: arr (List[int]): A list of integers to be sorted. Returns: None: The list is sorted in place. def merge_in_place(arr, start, mid, end): # Begin two pointers to maintain two subarrays to merge start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return # Two pointers to maintain start of both arrays to merge while start <= mid and start2 <= end: # If element 1 is in right place if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort(arr, l, r): if l < r: mid = l + (r - l) // 2 merge_sort(arr, l, mid) merge_sort(arr, mid + 1, r) merge_in_place(arr, l, mid, r) merge_sort(arr, 0, len(arr)-1)"},{"question":"You are tasked with enhancing the given implementation of Dijkstra\'s algorithm to improve its efficiency by changing the data structure used to find the minimum distance vertex that hasn\'t been processed yet. # Objective Refactor the given Dijkstra\'s algorithm to use a priority queue (min-heap) instead of a linear search to improve its performance. # Function Signature ```python def improved_dijkstra(graph: List[List[int]], src: int) -> List[int]: Parameters: graph (List[List[int]]): A 2D list representing a directed graph with edge weights, where graph[i][j] is the weight of the edge from vertex i to vertex j. If there is no edge, the weight is represented by a value <= 0 (excluding self-loops). src (int): The source vertex for calculating the shortest paths to other vertices. Returns: List[int]: A list where the value at each index represents the shortest distance from the source vertex to that index. ``` # Input and Output * The function should accept a **2D list `graph`** representing the adjacency matrix of the graph and an **integer `src`** representing the source vertex. * Return a list of minimum distances from the source vertex `src` to all other vertices. If a vertex is unreachable, its corresponding distance should be `float(\\"inf\\")`. # Constraints * The number of vertices `V` is between 1 and 1000. * The edge weights are non-negative integers. # Example ```python graph = [ [0, 6, 0, 1, 0], [6, 0, 5, 2, 2], [0, 5, 0, 0, 5], [1, 2, 0, 0, 1], [0, 2, 5, 1, 0] ] src = 0 print(improved_dijkstra(graph, src)) # Output: [0, 3, 7, 1, 2] ``` # Notes * Ensure to handle edge cases where the graph is empty or contains self-loops. * Document your code and explain any assumptions or decisions you make while implementing the solution.","solution":"import heapq from typing import List def improved_dijkstra(graph: List[List[int]], src: int) -> List[int]: Parameters: graph (List[List[int]]): A 2D list representing a directed graph with edge weights, where graph[i][j] is the weight of the edge from vertex i to vertex j. If there is no edge, the weight is represented by a value <= 0 (excluding self-loops). src (int): The source vertex for calculating the shortest paths to other vertices. Returns: List[int]: A list where the value at each index represents the shortest distance from the source vertex to that index. If a vertex is unreachable, its corresponding distance should be float(\\"inf\\"). V = len(graph) dist = [float(\\"inf\\")] * V # Initialize distances with infinity dist[src] = 0 min_heap = [(0, src)] # Priority queue of (distance, vertex) while min_heap: current_distance, u = heapq.heappop(min_heap) # If the retrieved distance is not up-to-date, skip processing this node if current_distance > dist[u]: continue for v in range(V): weight = graph[u][v] if weight > 0: distance = current_distance + weight if distance < dist[v]: dist[v] = distance heapq.heappush(min_heap, (distance, v)) return dist"},{"question":"# Matrix Chain Multiplication Order Calculation You are given an array `p` where the (i^{th}) element represents the number of rows in the (i^{th}) matrix and the ((i+1)^{th}) element represents the number of columns in the (i^{th}) matrix. Your task is to write a function that calculates the minimum number of scalar multiplications needed to multiply the sequence of matrices, using dynamic programming. Function Signature ```python def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: ``` # Input * `p`: A list of integers representing the matrix dimensions, where (p[i]) is the number of rows in matrix (i) and (p[i+1]) is the number of columns in matrix (i), such that the number of matrices is (len(p) - 1). # Output * Returns a tuple: * The first element is a 2D list `m` where `m[i][j]` stores the minimum number of multiplications needed to compute the product of matrices (A_i) to (A_j). * The second element is a 2D list `s` used to store the index at which the optimal split for matrices product computation occurs. # Constraints * (2 leq len(p) leq 100) * (1 leq p[i] leq 500) # Example Given the following example: ```python p = [30, 35, 15, 5, 10, 20, 25] ``` You should accomplish the following: 1. Implement the function `matrix_chain_order`. 2. Your function should return the minimal number of multiplications and the optimal solution matrix. 3. Implement another function called `print_optimal_solution` to print the optimal multiplication sequence based on the `s` matrix generated. Example of second function: Function Signature: ```python def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: ``` Example: ```python matrix, sol = matrix_chain_order([30, 35, 15, 5, 10, 20, 25]) print(\\"No. of Operations required:\\", (matrix[1][len(p) - 1])) print_optimal_solution(sol, 1, len(p) - 1) # Should print the optimal order ``` # Notes * Ensure your code is clean and well-documented. * Handle all edge cases mentioned in the analysis. * Make sure your code runs within the given constraints effectively.","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(p) - 1 # m[i][j] will hold the minimum number of multiplications needed to compute the matrix A[i] to A[j] m = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # s[i][j] will store the index of the k that achieved the optimal cost s = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for l in range(2, n + 1): # l is the chain length for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"Context: You are working on a text processing application that needs to highlight specific symbols within words. Given a list of words and a list of symbols, replace the part of each word that matches any symbol with the symbol surrounded by square brackets `[ ]`. If a word matches multiple symbols, prioritize the symbol with the longest length. Function Signature: ```python def highlight_words(words: List[str], symbols: List[str]) -> List[str]: pass ``` Input: - `words` (List[str]): A list of words that need to be processed. - `symbols` (List[str]): A list of symbols to search for within the words. Output: - `List[str]`: A list of words where the longest matching symbols are replaced with the symbol enclosed in square brackets `[ ]`. Constraints: - The words and symbols contain only alphabetical characters. - If a word contains multiple non-overlapping matches of the same length, replace the first occurrence. - The length of each word is between 1 and 100 characters. - The number of words and symbols is between 1 and 1000. Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] # Result: # [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Notes: 1. Be mindful of the performances since the given list can be relatively large. 2. Prioritize a solution that ensures the longest symbol match is being used.","solution":"from typing import List def highlight_words(words: List[str], symbols: List[str]) -> List[str]: # Sort symbols by length in descending order to prioritize longer matches symbols.sort(key=len, reverse=True) def replace_symbol(word): for symbol in symbols: if symbol in word: return word.replace(symbol, f\\"[{symbol}]\\", 1) # Replace only the first occurrence return word return [replace_symbol(word) for word in words]"},{"question":"# Linked List Duplicate Removal You\'ve been tasked with implementing two approaches to remove duplicate values from an unsorted singly linked list. **Scenario**: You are working with a data stream where duplicates frequently occur, and you need to ensure unique entries in the list for quick lookup and deduplication. **Function Definitions**: 1. `def remove_dups(head: Node) -> None` 2. `def remove_dups_without_set(head: Node) -> None` **Expected Input and Output**: * **Input**: * `head`: Head node of a singly linked list where each node contains a string value. * **Output**: * Modify the linked list in place to remove duplicate values. Functions return `None`. # Constraints: 1. Each string value in the linked list contains only alphabetical characters (a-z, A-Z). 2. The length of the linked list can be up to 10^5 nodes for `remove_dups` and up to 10^3 nodes for `remove_dups_without_set`. # Performance Requirements: 1. `remove_dups` should have a time complexity of O(N) and space complexity of O(N). 2. `remove_dups_without_set` should have a time complexity of O(N^2) and space complexity of O(1). **Edge Cases**: 1. An empty linked list should not cause an error. 2. A linked list where all elements are duplicates. ```python class Node: def __init__(self, val: str) -> None: self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates using a hashset. # Your implementation here def remove_dups_without_set(head: Node) -> None: Removes duplicates without using a hashset (runner technique). # Your implementation here def print_linked_list(head: Node) -> None: Utility function to print the linked list. # Provided utility, no change needed: string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) # Example usage: a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) print_linked_list(a1) remove_dups_without_set(a1) print_linked_list(a1) ``` **Your task is to implement the functions `remove_dups` and `remove_dups_without_set` according to the described specifications.**","solution":"class Node: def __init__(self, val: str) -> None: self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates using a hashset. if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates without using a hashset (runner technique). current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Coding Challenge Scenario You are tasked with implementing a Union-Find data structure to represent a grid of water and land. This grid starts as all water, and you will be given a series of positions to \\"turn into land.\\" After each position is turned to land, you need to efficiently determine the number of separate islands (disconnected components of land). Challenge Implement the `num_islands` function that processes a list of addLand positions on a 2D grid (`n` x `m`) of water (represented by 0) and land (represented by 1). The function should return the number of islands after each addLand operation. **Function Signature**: ```python def num_islands(positions: List[Tuple[int, int]]) -> List[int]: ``` **Parameters**: - `positions` (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers representing the row and column to turn into land. **Output**: - Returns a list of integers, describing the number of islands after each addLand operation. **Constraints**: - The grid size `n` x `m` is practically large enough. - Operations are given as a list of `positions`. No position will be repeated. - An island is formed by connecting adjacent lands horizontally or vertically. **Example**: ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] assert num_islands(positions) == [1, 1, 2, 3] ``` **Performance Requirements**: - The `addLand` operation and the union-find operations should be efficient, preferably near constant time due to path compression and union by size. **Notes**: - Land that is added adjacent (horizontally or vertically) to existing land will form or merge islands. - The efficiency of your solution is paramount since the grid can be large, and there may be numerous addLand operations.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def add_land(self): self.count += 1 def num_islands(positions: List[Tuple[int, int]]) -> List[int]: if not positions: return [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] rows, cols = max(p[0] for p in positions) + 1, max(p[1] for p in positions) + 1 uf = UnionFind(rows * cols) grid = [[0] * cols for _ in range(rows)] results = [] for x, y in positions: if grid[x][y] == 1: results.append(uf.count) continue grid[x][y] = 1 uf.add_land() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: uf.union(x * cols + y, nx * cols + ny) results.append(uf.count) return results"},{"question":"# Question: Implement a Substring Search Using Rabin-Karp You are asked to implement the Rabin-Karp algorithm to find the starting index of the first occurrence of a given substring (word) in a given string (text). If the substring is not found, return -1. Function Signature ```python def find_substring(word: str, text: str) -> int: pass ``` # Input - **`word`**: A non-empty string representing the substring to be searched. (1 <= len(word) <= 1000) - **`text`**: A non-empty string where the search is performed. (1 <= len(text) <= 10000) # Output - Return the starting index of the first occurrence of **`word`** in **`text`**. - If **`word`** is not found in **`text`**, return `-1`. # Constraints - Both `word` and `text` consist only of lowercase English letters (\'a\' to \'z\'). # Performance Requirements - Aim for an average-case time complexity of O(n + m). # Example ```python assert find_substring(\\"abc\\", \\"abcdeabc\\") == 0 assert find_substring(\\"abc\\", \\"ababc\\") == 2 assert find_substring(\\"abc\\", \\"xyz\\") == -1 assert find_substring(\\"a\\", \\"aaa\\") == 0 ``` # Edge Cases - If `word` is longer than `text`, return -1. - Handle cases where either `word` or `text` is an empty string gracefully. - Ensure efficient handling of large texts with repetitive patterns. # Note Ensure to solve the problem using efficient hash recalculation technique as demonstrated in the Rabin-Karp algorithm while considering and mitigating hash collision for better average performance.","solution":"def find_substring(word: str, text: str) -> int: Implement the Rabin-Karp algorithm to find the starting index of the first occurrence of `word` in `text`. Return -1 if `word` is not found in `text`. # Lengths of the word and the text m = len(word) n = len(text) # Base case: if word is longer than the text if m > n: return -1 # Constants for the hash function d = 256 # number of characters in the input alphabet q = 101 # A prime number to mod the hash values (chosen arbitrarily for hashing) # Initial hash values for word and text word_hash = 0 text_hash = 0 h = 1 # The value of h would be \\"pow(d, M-1)%q\\" for _ in range(m-1): h = (h * d) % q # Calculate the hash value of word and first window of text for i in range(m): word_hash = (d * word_hash + ord(word[i])) % q text_hash = (d * text_hash + ord(text[i])) % q # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current window of text and word if word_hash == text_hash: # Check the characters one by one if text[i:i+m] == word: return i # Calculate hash value for next window of text # Remove leading digit and add trailing digit if i < n - m: text_hash = (d * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % q # We might get negative values of t, converting it to positive if text_hash < 0: text_hash = text_hash + q return -1"},{"question":"# Segment Tree Implementation Challenge You are tasked with implementing a Segment Tree that supports efficient range queries and updates. The Segment Tree must be able to handle any commutative associative function (e.g., max, sum, gcd). Input 1. An integer array `arr` of length (N). 2. A commutative associative function `function` which takes two elements of `arr` and returns one element of the same type. Functions to Implement 1. **Initialization**: * Initialize the Segment Tree with the array `arr` and the function `function`. 2. **Update**: * `update(index, value)`: Update the element at position `index` to `value`. 3. **Query**: * `query(left, right)`: Return the result of applying the function over the range `[left, right]`. Output 1. The result of `query` function calls based on the provided test cases. 2. The state of the Segment Tree after performing the update operations. Example Test Case ```python # Initialization arr = [2, 4, 5, 3, 4] function = max segment_tree = SegmentTree(arr, function) # Perform queries print(segment_tree.query(2, 4)) # Output: 5 # Perform update segment_tree.update(3, 6) print(segment_tree.query(0, 3)) # Output: 6 # Another example with a different function arr = [4, 5, 2, 3, 4, 43, 3] function = lambda a, b: a + b segment_tree = SegmentTree(arr, function) # Perform queries print(segment_tree.query(0, 6)) # Output: 64 # Perform update segment_tree.update(2, -10) print(segment_tree.query(0, 6)) # Output: 52 # Another example with a tuple array arr = [(1, 2), (4, 6), (4, 5)] function = lambda a, b: (a[0] + b[0], a[1] + b[1]) segment_tree = SegmentTree(arr, function) # Perform queries print(segment_tree.query(0, 2)) # Output: (9, 13) # Perform update segment_tree.update(2, (-1, 2)) print(segment_tree.query(0, 2)) # Output: (4, 10) ``` Constraints 1. All indices for the query and update operations are 0-based. 2. The function provided will always be a valid commutative associative function. 3. The array will have at least one element and at most (10^5) elements. Implement the required class and methods to satisfy the above problem statement.","solution":"class SegmentTree: def __init__(self, arr, func): Initialize the Segment Tree with the array and the function. self.n = len(arr) self.tree = [None] * (2 * self.n) self.func = func # Initialize the leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): Update the element at position index to value. # Update the leaf node index += self.n self.tree[index] = value # Update the internal nodes while index > 1: index //= 2 self.tree[index] = self.func(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left, right): Return the result of applying the function over the range [left, right]. result = None left += self.n right += self.n + 1 while left < right: if left % 2 == 1: result = self.tree[left] if result is None else self.func(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = self.tree[right] if result is None else self.func(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"# Flatten Nested Arrays You are given a nested array, which could contain elements that are integers, floats, strings, or further nested arrays. Your task is to implement a function that takes such a nested array and returns a single flat array containing all the elements in the same order. # Function Signature ```python def flatten_array(nested_array: List[Union[int, float, str, list]]) -> List[Union[int, float, str]]: pass ``` # Input * `nested_array`: A list containing a mixture of integers, floats, strings, and other lists. # Output * A single list containing all the nested elements in a flat structure. # Constraints * The input list can be nested up to an arbitrary depth, but it is guaranteed not to contain circular references. * Avoid using built-in libraries that directly provide flattening functionalities. * Consider the performance of your solution, aiming for linear time complexity relatively to the number of elements. # Example ```python assert flatten_array([1, [2, 3, [4, [5]], 6], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_array([\'a\', [\'b\', \'c\', [\'d\', \'e\']], \'f\']) == [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] assert flatten_array([[], [[], []], []]) == [] ``` # Additional Notes * Handle edge cases such as empty arrays. * Ensure that the solution correctly handles arrays with mixed types. * Write your solution without using auxiliary functions unless they are encapsulated in the main function definition.","solution":"from typing import List, Union def flatten_array(nested_array: List[Union[int, float, str, list]]) -> List[Union[int, float, str]]: Function to flatten a nested array. flat_list = [] def _flatten(sub_array): for element in sub_array: if isinstance(element, list): _flatten(element) else: flat_list.append(element) _flatten(nested_array) return flat_list"},{"question":"Implement a `SeparateChainingHashTable`, an advanced data structure that supports dynamic resizing when the number of key-value pairs exceeds a load factor threshold. This implementation should handle collisions using separate chaining and resize the hash table when necessary. # Function Signature ```python class SeparateChainingHashTable: def __init__(self, size: int = 11, load_factor: float = 0.75): pass # Initialize the hash table with specified size and load factor def put(self, key: Any, value: Any) -> None: pass # Insert or update the key-value pair def get(self, key: Any) -> Optional[Any]: pass # Retrieve the value associated with the key def del_(self, key: Any) -> None: pass # Delete the key-value pair def __len__(self) -> int: pass # Return the number of key-value pairs def __getitem__(self, key: Any) -> Optional[Any]: pass # Retrieve the value using indexing syntax def __setitem__(self, key: Any, value: Any) -> None: pass # Insert/update the key-value pair using indexing syntax def __delitem__(self, key: Any) -> None: pass # Delete the key-value pair using indexing syntax ``` # Requirements 1. **Initialization:** Accepts an optional `size` for the initial bucket count and an optional `load_factor`. 2. **Resizing (Rehashing):** When the number of elements exceeds the product of the `size` and `load_factor`, resize the table to 2x the current size and rehash all existing elements. 3. **Methods:** Implement `put`, `get`, `del_`, `__len__`, `__getitem__`, `__setitem__`, and `__delitem__` with functionalities as described above. 4. **Handling Collisions:** Utilize separate chaining (linked lists) to handle hash collisions. # Constraints - Keys are immutable and hashable (e.g., integers, strings, tuples). - Values can be any data type. - Implement resizing logic efficiently to avoid performance degradation. # Example ```python htable = SeparateChainingHashTable() htable.put(\'key1\', \'value1\') htable.put(\'key2\', \'value2\') htable.put(\'key3\', \'value3\') print(htable.get(\'key1\')) # Output: value1 print(len(htable)) # Output: 3 htable.del_(\'key2\') print(htable.get(\'key2\')) # Output: None htable[\'key4\'] = \'value4\' print(htable[\'key4\']) # Output: value4 del htable[\'key1\'] print(htable.get(\'key1\')) # Output: None while len(htable) < 10: htable.put(f\'key{len(htable)}\', f\'value{len(htable)}\') print(len(htable)) # Output: 10 (Triggers resizing) ```","solution":"class SeparateChainingHashTable: def __init__(self, size: int = 11, load_factor: float = 0.75): self.size = size self.load_factor = load_factor self.num_elements = 0 self.buckets = [[] for _ in range(size)] def _hash(self, key): return hash(key) % self.size def _resize(self): new_size = self.size * 2 new_buckets = [[] for _ in range(new_size)] for bucket in self.buckets: for key, value in bucket: new_index = hash(key) % new_size new_buckets[new_index].append((key, value)) self.size = new_size self.buckets = new_buckets def put(self, key, value): index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.num_elements += 1 if self.num_elements > self.size * self.load_factor: self._resize() def get(self, key): index = self._hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def del_(self, key): index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.num_elements -= 1 return def __len__(self): return self.num_elements def __getitem__(self, key): return self.get(key) def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): self.del_(key)"},{"question":"# Queue Implementation and Customization You have been provided with an abstract class `AbstractQueue` and its two implementations, `ArrayQueue` and `LinkedListQueue`. Using these provided classes, your task is to: 1. **Implement a new method** in `ArrayQueue` and `LinkedListQueue`: - `get_max()`: This method should return the maximum element currently in the queue without removing it. If the queue is empty, it should raise an `IndexError`. 2. **Write a function** `test_custom_queue()` that: - Creates instances of both `ArrayQueue` and `LinkedListQueue`. - Enqueues a series of integer values into each instance. - Uses the `get_max()` method to find and return the maximum values from both queues. Expected Input and Output Formats: * The `get_max()` method should have the following input and output: * Input: No parameters. * Output: Integer (maximum value) or raise `IndexError` if the queue is empty. * The `test_custom_queue()` function should return a tuple with the maximum values of the elements from each queue. Constraints: * Assume all values inserted will be comparable (e.g., integers). ```python # Define get_max() for ArrayQueue and LinkedListQueue def get_max(self): # Implement logic here pass ArrayQueue.get_max = get_max LinkedListQueue.get_max = get_max # Test function def test_custom_queue(): array_queue = ArrayQueue() linked_list_queue = LinkedListQueue() # Enqueue a series of integer values values = [5, 1, 3, 2, 4] for value in values: array_queue.enqueue(value) linked_list_queue.enqueue(value) # Retrieve and return the maximum values from both queues max_array = array_queue.get_max() max_linked_list = linked_list_queue.get_max() return (max_array, max_linked_list) # Run test function print(test_custom_queue()) ``` In your implementation: - You need to pass the test cases for maximum value retrieval. - Handle potential edge cases, like calling `get_max()` on an empty queue.","solution":"class AbstractQueue: def enqueue(self, item): raise NotImplementedError def dequeue(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayQueue(AbstractQueue): def __init__(self): self.items = [] def enqueue(self, item): self.items.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") return self.items.pop(0) def is_empty(self): return len(self.items) == 0 def get_max(self): if self.is_empty(): raise IndexError(\\"max from empty queue\\") return max(self.items) class LinkedListQueue(AbstractQueue): class Node: def __init__(self, data=None): self.data = data self.next = None def __init__(self): self.front = None self.rear = None def enqueue(self, item): new_node = self.Node(item) if self.rear is None: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") temp = self.front self.front = temp.next if self.front is None: self.rear = None return temp.data def is_empty(self): return self.front is None def get_max(self): if self.is_empty(): raise IndexError(\\"max from empty queue\\") max_value = self.front.data current = self.front while current: if current.data > max_value: max_value = current.data current = current.next return max_value def test_custom_queue(): array_queue = ArrayQueue() linked_list_queue = LinkedListQueue() # Enqueue a series of integer values values = [5, 1, 3, 2, 4] for value in values: array_queue.enqueue(value) linked_list_queue.enqueue(value) # Retrieve and return the maximum values from both queues max_array = array_queue.get_max() max_linked_list = linked_list_queue.get_max() return (max_array, max_linked_list) # Uncomment this line to check functionality # print(test_custom_queue())"},{"question":"# Merge String Checker You are tasked with writing a function that checks if a specifically given string `s` can be formed by interleaving two other strings, `part1` and `part2`, in their respective orders. Function Prototype ```python def is_merge(s: str, part1: str, part2: str) -> bool: # Your implementation goes here ``` Input - `s`: a string of length `n` (1 <= n <= 1000) - `part1` and `part2`: strings whose combined length is also `n` Output - Return `True` if `s` can be formed by interleaving `part1` and `part2`; otherwise, return `False`. Constraints - Characters in `part1` and `part2` must preserve their order in `s`. - You must implement the function using an approach that ensures time complexity of O(n^2). Examples 1. `is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\")` should return `True`. 2. `is_merge(\\"abc\\", \\"a\\", \\"bc\\")` should return `True`. 3. `is_merge(\\"abc\\", \\"ac\\", \\"b\\")` should return `True`. 4. `is_merge(\\"abc\\", \\"ab\\", \\"ac\\")` should return `False`. Context Imagine you\'re working on a software that processes data streams and you need to validate that the interleaving parts received are correctly sequenced into a larger combined stream without breaking their internal order. This function is critical to ensure data integrity during such processes.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: Checks if the string s can be formed by interleaving part1 and part2. len_s, len_part1, len_part2 = len(s), len(part1), len(part2) # If the combined length of part1 and part2 is not equal to s, return False if len_s != len_part1 + len_part2: return False # Create a 2D dp array dp = [[False] * (len_part2 + 1) for _ in range(len_part1 + 1)] # Initialize the dp array dp[0][0] = True for i in range(len_part1 + 1): for j in range(len_part2 + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len_part1][len_part2]"},{"question":"# Scenario You are a data scientist tasked with analyzing a large dataset to locate specific records. The dataset is represented as an array of integers, and you need to determine the index of a given target value within this array. However, the dataset is not sorted, so you must employ an algorithm that can search through unsorted arrays. # Task Write a function `find_positions` that uses the linear search approach to locate all occurrences of a target value within a given array and returns a list of their indices. If the target value is not found, return an empty list. # Function Signature ```python def find_positions(array: list, target: int) -> list: pass ``` # Input - `array`: A list of integers representing the dataset. (1 ≤ length of `array` ≤ 10^6) - `target`: An integer representing the value you need to find in the array. # Output - A list of integers representing the indices in `array` where `target` is found. Return an empty list if `target` is not present in `array`. # Constraints - You must use a linear search approach. - You should consider performance and edge cases. # Example ```python assert find_positions([1, 2, 3, 2, 4, 2, 5], 2) == [1, 3, 5] assert find_positions([1, 3, 5, 7], 4) == [] assert find_positions([], 1) == [] assert find_positions([2, 2, 2, 2, 2, 2], 2) == [0, 1, 2, 3, 4, 5] ``` # Note The function should efficiently handle the upper limit of the input size.","solution":"def find_positions(array: list, target: int) -> list: Uses a linear search approach to locate all occurrences of a target value within a given array and returns a list of their indices. If the target value is not found, returns an empty list. positions = [] for index, value in enumerate(array): if value == target: positions.append(index) return positions"},{"question":"Context You have been hired to work on a spatial analysis tool. One of the primary functions of this tool is to identify the k points that are closest to a given origin. Your task is to write a function that efficiently finds these k closest points. Task Implement a function `k_closest(points, k, origin=(0, 0))` that takes in: - `points`: a list of tuples where each tuple represents the coordinates of a point (x, y). - `k`: an integer representing the number of closest points to find. - `origin`: a tuple representing the coordinates of the origin point (default is (0, 0)). The function should return a list of the k closest points to the origin. If there are multiple points with the same distance, returning any of them is acceptable. Input and Output Formats - **Input**: - `points`: List of `N` tuples, where each tuple is of the form `(x, y)` and `N` is the total number of points. - `k`: A non-negative integer (0 ≤ k ≤ N). - `origin`: A tuple `(x, y)` representing the origin point. - **Output**: A list of `k` tuples, where each tuple is one of the k closest points to the origin. Constraints - You should use a max heap to optimize the solution. - The function should have a time complexity of `O(k + (n-k)logk)` and space complexity of `O(k)`. - If `k = 0`, the function should return an empty list. - If `k >= N`, return the original list of points. Example ```python points = [(1, 2), (3, 4), (-1, -2), (2, 2)] k = 2 origin = (0, 0) print(k_closest(points, k, origin)) # Output: [(1, 2), (2, 2)] ``` Additional Information 1. You need to implement the distance calculation using squared Euclidean distance to avoid floating-point operations. 2. You are encouraged to use the `heapq` library for heap operations.","solution":"import heapq from typing import List, Tuple def squared_distance(point: Tuple[int, int], origin: Tuple[int, int]) -> int: Calculate the squared Euclidean distance between a point and the origin. return (point[0] - origin[0])**2 + (point[1] - origin[1])**2 def k_closest(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: Find the k closest points to the origin. if k == 0: return [] if k >= len(points): return points max_heap = [] for point in points: dist = squared_distance(point, origin) heapq.heappush(max_heap, (-dist, point)) if len(max_heap) > k: heapq.heappop(max_heap) return [point for _, point in max_heap]"},{"question":"You are tasked with writing a function that converts an integer to a Roman numeral. A Roman numeral is a combination of the following symbols: - I, V, X, L, C, D, M Each symbol has a value: I=1, V=5, X=10, L=50, C=100, D=500, M=1000. Roman numerals are usually written from largest to smallest from left to right, except in specific subtractive combinations. # Requirements Create a function `convert_to_roman(num)` which takes an integer `num` as input and returns the Roman numeral representation as a string. # Input Format * A single integer `num`. # Output Format * A string representing the Roman numeral of the input integer. # Constraints * The integer `num` is guaranteed to be within the range from 1 to 3999. # Performance Requirements * The function should have constant time complexity, O(1). # Scenarios for Edge Handling 1. When `num` is at its lower bound (1), the function should return \\"I\\". 2. When `num` is at its upper bound (3999), the function should return \\"MMMCMXCIX\\". # Additional Considerations Ensure that the function handles the subtractive combinations in Roman numerals (e.g., IV for 4, IX for 9, XL for 40, etc.). Example ```python def convert_to_roman(num): :type num: int :rtype: str m = [\\"\\", \\"M\\", \\"MM\\", \\"MMM\\"] c = [\\"\\", \\"C\\", \\"CC\\", \\"CCC\\", \\"CD\\", \\"D\\", \\"DC\\", \\"DCC\\", \\"DCCC\\", \\"CM\\"] x = [\\"\\", \\"X\\", \\"XX\\", \\"XXX\\", \\"XL\\", \\"L\\", \\"LX\\", \\"LXX\\", \\"LXXX\\", \\"XC\\"] i = [\\"\\", \\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\"] return m[num // 1000] + c[(num % 1000) // 100] + x[(num % 100) // 10] + i[num % 10] ``` # Example Usage ```python print(convert_to_roman(58)) # Output: \\"LVIII\\" print(convert_to_roman(1994)) # Output: \\"MCMXCIV\\" print(convert_to_roman(4)) # Output: \\"IV\\" print(convert_to_roman(3999)) # Output: \\"MMMCMXCIX\\" ```","solution":"def convert_to_roman(num): Convert an integer to its Roman numeral representation. :param num: int :return: str # Define the Roman numeral representations for each place value m = [\\"\\", \\"M\\", \\"MM\\", \\"MMM\\"] c = [\\"\\", \\"C\\", \\"CC\\", \\"CCC\\", \\"CD\\", \\"D\\", \\"DC\\", \\"DCC\\", \\"DCCC\\", \\"CM\\"] x = [\\"\\", \\"X\\", \\"XX\\", \\"XXX\\", \\"XL\\", \\"L\\", \\"LX\\", \\"LXX\\", \\"LXXX\\", \\"XC\\"] i = [\\"\\", \\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\"] # Build the Roman numeral string thousands = m[num // 1000] hundreds = c[(num % 1000) // 100] tens = x[(num % 100) // 10] ones = i[num % 10] # Combine all parts and return the result return thousands + hundreds + tens + ones"},{"question":"# Scenario: You are working on a legacy system where data is retrieved and processed using stacks. One of the needs of the system is to validate that the data in a stack is sorted in ascending order from bottom to top. Given the existing constraints, you need to implement a function `is_sorted` that verifies this order. # Problem: Write a function `is_sorted(stack)` which accepts a stack as its parameter and returns `True` if the elements in the stack are in ascending order from bottom to top, and `False` otherwise. # Function Signature: ```python def is_sorted(stack: list) -> bool: ``` # Input: - `stack`: a list of integers representing the stack where the first element is at the bottom of the stack and the last element is at the top. # Output: - Returns `True` if the stack is sorted in ascending order from bottom to top, otherwise returns `False`. # Constraints: - The stack contains at most 100,000 integers (`1 <= len(stack) <= 100,000`). - The integers in the stack can range from `-1,000,000` to `1,000,000`. # Requirements: - You must not alter the original order of elements in the stack. # Example: ```python stack1 = [1, 2, 3, 4, 5, 6] print(is_sorted(stack1)) # Output: True stack2 = [6, 3, 5, 1, 2, 4] print(is_sorted(stack2)) # Output: False stack3 = [] print(is_sorted(stack3)) # Output: True stack4 = [1] print(is_sorted(stack4)) # Output: True ``` # Notes: - Consider edge cases such as an empty stack or a stack with a single element. - Ensure to handle large input sizes efficiently within the constraints provided.","solution":"def is_sorted(stack: list) -> bool: Check if the stack is sorted in ascending order from bottom to top. Args: stack (list): A list of integers representing the stack. Returns: bool: True if the stack is sorted in ascending order, False otherwise. n = len(stack) for i in range(1, n): if stack[i-1] > stack[i]: return False return True"},{"question":"# Strongly Connected Components in a Graph Context A software development company is designing an internal tool for analyzing dependencies in their codebase. Each module in the system either directly or indirectly depends on other modules, forming a directed graph. To maintain code modularity and diagnose potential issues, they need to identify clusters of modules that are strongly interconnected, meaning each module in a cluster can reach every other module in that cluster directly or indirectly. Task Implement a method that identifies the number of strongly connected components (SCCs) in a directed graph using Kosaraju’s algorithm. Function Signature ```python class Kosaraju: def kosaraju(self, V: int, adj: List[List[int]]) -> int: ``` Input - `V` (int): The number of vertices (modules). - `adj` (List[List[int]]): A list of adjacency lists where `adj[i]` contains the vertices to which vertex `i` has a directed edge. Output - Returns an integer representing the number of strongly connected components in the graph. Constraints - `1 <= V <= 10^4` (number of vertices) - `0 <= E <= 10^5` (number of edges) - The graph might have self-loops and parallel edges. Example # Input ```python V = 6 adj = [ [2], [0], [3], [1, 4], [5], [4] ] ``` # Output ```python 2 ``` Explanation 1. The SCCs are: - {0, 1, 2, 3} - {4, 5} # Note You need to ensure that the solution correctly handles various edge cases and performs well within the given constraints. Do not use any libraries other than standard Python libraries.","solution":"from typing import List class Kosaraju: def kosaraju(self, V: int, adj: List[List[int]]) -> int: # Function to perform DFS and fill the stack def dfs(v: int, visited: List[bool], stack: List[int]): visited[v] = True for neighbour in adj[v]: if not visited[neighbour]: dfs(neighbour, visited, stack) stack.append(v) # Function to perform DFS based on the transposed graph def dfs_transpose(v: int, visited: List[bool], transpose: List[List[int]]): visited[v] = True scc.append(v) for neighbour in transpose[v]: if not visited[neighbour]: dfs_transpose(neighbour, visited, transpose) # Step 1: Fill the stack with vertices in the order of finishing stack = [] visited = [False] * V for i in range(V): if not visited[i]: dfs(i, visited, stack) # Step 2: Create the transposed graph transpose = [[] for _ in range(V)] for i in range(V): for neighbour in adj[i]: transpose[neighbour].append(i) # Step 3: Process all vertices in order defined by the stack visited = [False] * V count_scc = 0 # Count of strongly connected components while stack: v = stack.pop() if not visited[v]: scc = [] dfs_transpose(v, visited, transpose) count_scc += 1 return count_scc"},{"question":"Intersection of Two Linked Lists You are given the heads of two singly linked-lists `headA` and `headB`. Write a function to find the node at which the two lists intersect. If the two linked lists have no intersection at all, return `None`. # Function Signature ```python class Node: def __init__(self, val=0): self.val = val self.next = None def get_intersection_node(headA: Node, headB: Node) -> Node: pass ``` # Input Format - Two linked lists `headA` and `headB`. # Output Format - The node at which the intersection of the two linked lists begins, or `None` if there is no intersection. # Constraints - The number of nodes in both linked lists is at most 10^5. - The values of the nodes are not necessary to solve the problem, only the node itself can be used to determine intersection. # Example ```text Example 1: A: 4 -> 1 -> 8 -> 4 -> 5 B: 5 -> 0 -> 1 -> 8 -> 4 -> 5 Output: Node with value 8 (intersection at node 8) ``` ```text Example 2: A: 2 -> 6 -> 4 B: 1 -> 5 Output: None (no intersection) ``` # Notes 1. The intersection node is the same object in memory (i.e., both pointers point to the same location in memory), not just nodes with the same value. 2. You should solve it with O(N) time complexity and O(1) memory complexity.","solution":"class Node: def __init__(self, val=0): self.val = val self.next = None def get_intersection_node(headA: Node, headB: Node) -> Node: Finds the intersection node of two singly linked lists if one exists. :param headA: The head of the first linked list. :param headB: The head of the second linked list. :return: The intersection node or None if no intersection exists. if not headA or not headB: return None pointerA, pointerB = headA, headB # Traverse both lists, and switch to the other head when reaching the end while pointerA is not pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"# Question Title: Implement and Optimize a Resizable Hash Table Context You are tasked with creating an efficient hash table with dynamic resizing capabilities, supporting basic operations like insertion, deletion, and lookup. It\'s critical to ensure that it handles collisions gracefully and adjusts its size dynamically to accommodate a growing number of elements. Functional Requirements You must implement the following functions: 1. **put(key, value)**: Adds a new key-value pair to the hash table or updates the value if the key already exists. 2. **get(key)**: Retrieves the value associated with the given key, or returns None if the key does not exist. 3. **del_(key)**: Removes the key-value pair for the given key if it exists. 4. **resize(new_size)**: Resizes the hash table to the new_size while maintaining all existing key-value pairs. Expected Input and Output * **Inputs**: * For `put(key, value)`: `key` is an integer and `value` is any data type. * For `get(key)`: `key` is an integer. * For `del_(key)`: `key` is an integer. * For `resize(new_size)`: `new_size` is an integer greater than the current count of elements. * **Outputs**: * For `put(key, value)`: No output. * For `get(key)`: The value associated with the key or None. * For `del_(key)`: No output. * For `resize(new_size)`: No output. Constraints and Limitations * Keys are assumed to be non-negative integers. * You should implement linear probing for collision resolution. * Resize the hash table when the number of elements exceeds 2/3 of its current size to twice its original size. * Your implementation must handle rehashing during resizing. Performance Requirements * Average time complexity for `put`, `get`, and `del_` operations should be O(1). * The `resize` operation should rebalance the table efficiently. Scenario Imagine a cache system that stores web pages with unique integer IDs as keys. The caching mechanism needs to be highly performant, and it’s essential to handle rapid insertions and deletions gracefully. As pages get added frequently, the cache should automatically resize to avoid performance degradation. Your task is to implement this resizable hash table. Write a `ResizableHashTable` class that meets the requirements above.","solution":"class ResizableHashTable: An implementation of a hash table with dynamic resizing. def __init__(self, initial_size=10): self.size = initial_size self.count = 0 self.table = [None] * self.size def _hash(self, key): Simple hash function. return key % self.size def _rehash(self, old_hash): Linear probing rehash function. return (old_hash + 1) % self.size def put(self, key, value): Adds a new key-value pair or updates the value if the key already exists. if self.count > self.size * 2 // 3: self.resize(self.size * 2) hash_index = self._hash(key) original_index = hash_index while self.table[hash_index] is not None and self.table[hash_index][0] != key: hash_index = self._rehash(hash_index) if hash_index == original_index: raise Exception(\\"Hash Table is full, cannot insert more items.\\") if self.table[hash_index] is None: self.count += 1 self.table[hash_index] = (key, value) def get(self, key): Retrieves the value associated with the given key, or None if it does not exist. hash_index = self._hash(key) original_index = hash_index while self.table[hash_index] is not None: if self.table[hash_index][0] == key: return self.table[hash_index][1] hash_index = self._rehash(hash_index) if hash_index == original_index: break return None def del_(self, key): Removes the key-value pair for the given key if it exists. hash_index = self._hash(key) original_index = hash_index while self.table[hash_index] is not None: if self.table[hash_index][0] == key: self.table[hash_index] = None self.count -= 1 self._rehash_all_keys() return hash_index = self._rehash(hash_index) if hash_index == original_index: break def _rehash_all_keys(self): Rehash all keys to ensure there are no gaps after deletion. old_table = self.table[:] self.table = [None] * self.size self.count = 0 for pair in old_table: if pair is not None: self.put(pair[0], pair[1]) def resize(self, new_size): Resizes the hash table to the new_size while maintaining all existing pairs. old_table = self.table[:] self.size = new_size self.table = [None] * self.size self.count = 0 for pair in old_table: if pair is not None: self.put(pair[0], pair[1])"},{"question":"Optimized Bubble Sort **Context:** You are given an unsorted list of integers and you need to sort the list using an optimized version of the Bubble Sort algorithm. The optimized version should minimize the number of comparisons when the list becomes sorted part-way through the process. **Task:** Write a Python function `optimized_bubble_sort(arr)` that accepts a list of integers `arr` and returns the sorted list. Your implementation should include the following optimizations: 1. **Early Termination:** If the list is found to be sorted before completing all the passes, terminate the sorting process early. 2. **Backward Pass:** Similarly, after each forward pass, perform a backward pass to bubble up the smallest elements towards the beginning of the list. This should further minimize the number of comparisons needed when the remaining part of the list is already sorted. **Input:** - `arr`: A list of integers (e.g., `[64, 34, 25, 12, 22, 11, 90]`). **Output:** - A sorted list of integers (e.g., `[11, 12, 22, 25, 34, 64, 90]`). **Constraints:** - The input list `arr` can contain up to 10^6 elements. - The elements of `arr` are integers. **Performance Requirements:** - Your solution should handle the above constraints efficiently to avoid timeouts for large inputs. **Example:** ```python def optimized_bubble_sort(arr): # Your implementation here # Test the function with example input print(optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90])) # Expected Output: [11, 12, 22, 25, 34, 64, 90] ```","solution":"def optimized_bubble_sort(arr): Sorts a list of integers using an optimized bubble sort algorithm which includes early termination and backward passes. n = len(arr) while True: swapped = False # Forward pass for i in range(0, n-1): if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] swapped = True if not swapped: break swapped = False # Backward pass for i in range(n-2, -1, -1): if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] swapped = True if not swapped: break return arr"},{"question":"Context: Imagine you are a computer scientist working on search algorithms optimized for specific conditions. You\'ve been given a challenge to apply the Jump Search algorithm to find a target number within a sorted array. Jump Search is ideal for scenarios where data is large and sorted, but traditional binary search might not be optimal due to specific access constraints or patterns. Task: Write a function `optimized_jump_search` which implements the Jump Search algorithm to find a target value\'s index in a given sorted array. Function Signature: ```python def optimized_jump_search(arr: List[int], target: int) -> int: ``` Input: - `arr`: A sorted list of integers. - `target`: The target integer to find within the array. Output: - Return the index of the target if found. - Return `-1` if the target is not present in the array. Constraints: - `1 <= len(arr) <= 10^6` - `-10^9 <= arr[i], target <= 10^9` Example: ```python >>> optimized_jump_search([1, 3, 7, 15, 20, 25, 30, 35, 40], 20) 4 >>> optimized_jump_search([2, 4, 8, 16, 32, 64, 128], 10) -1 ``` Requirements: - Ensure your implementation is efficient, handling the upper constraint of array size. - Consider edge cases like very small or unusually ordered arrays. - Avoid using built-in functions that defeat the purpose of demonstrating the algorithm understanding.","solution":"import math from typing import List def optimized_jump_search(arr: List[int], target: int) -> int: n = len(arr) step = int(math.sqrt(n)) prev = 0 while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 while arr[prev] < target: prev += 1 if prev == min(step, n): return -1 if arr[prev] == target: return prev return -1 # Example usage (not a part of solution code, just for reference): # print(optimized_jump_search([1, 3, 7, 15, 20, 25, 30, 35, 40], 20)) # Should return 4 # print(optimized_jump_search([2, 4, 8, 16, 32, 64, 128], 10)) # Should return -1"},{"question":"# Question: Implement Secure Diffile-Hellman Key Exchange The Diffie-Hellman key exchange algorithm allows two parties to securely exchange cryptographic keys over a public channel. Given an interface for the Diffie-Hellman key exchange, you are required to implement a secure and efficient key exchange mechanism. Your task is to complete the following functions: 1. `generate_large_prime(n)`: Implement a function that generates a large prime number with `n` digits. 2. `find_primitive_root(p)`: Given a prime number `p`, find and return the smallest primitive root of `p`. 3. `diffie_hellman_key_exchange(a, p)`: Simulate the Diffie-Hellman key exchange between two parties, Alice and Bob, using the prime `p` and its primitive root `a`. # Function Signatures ```python def generate_large_prime(n: int) -> int: pass def find_primitive_root(p: int) -> int: pass def diffie_hellman_key_exchange(a: int, p: int) -> bool: pass ``` # Details and Constraints 1. `generate_large_prime(n)` - Input: A positive integer `n` indicating the number of digits. - Output: A large prime number with `n` digits. 2. `find_primitive_root(p)` - Input: A prime number `p`. - Output: The smallest primitive root of `p`. 3. `diffie_hellman_key_exchange(a, p)` - Input: Integers `a` (primitive root) and `p` (prime number). - Output: Boolean value indicating if the key exchange was successful. 4. Validity checks: - Ensure `p` is large enough (at least 1000 digits). - Ensure `a` is correctly verified as a primitive root of `p` using your implementation. # Example ```python n = 4 large_prime = generate_large_prime(n) primitive_root = find_primitive_root(large_prime) success = diffie_hellman_key_exchange(primitive_root, large_prime) print(success) # Should output True if successful ``` # Performance Requirements: - Use efficient algorithms for prime number generation (like probabilistic methods for large primes) and verification. - Avoid brute force methods for finding primitive roots. - Ensure modular exponentiation is implemented efficiently. # Additional Points - Provide a brief explanation of your approach. - Handle edge cases where prime number generation might fail. - Document any assumptions or simplifications for your implementation.","solution":"import random from sympy import isprime, primerange def generate_large_prime(n: int) -> int: Generates a large prime number with `n` digits. lower_bound = 10**(n-1) upper_bound = 10**n - 1 while True: num = random.randint(lower_bound, upper_bound) if isprime(num): return num def find_primitive_root(p: int) -> int: Finds the smallest primitive root of a given prime number `p`. def is_primitive_root(a, p): if pow(a, 1, p) == 0: return False powers = set() for i in range(1, p): powers.add(pow(a, i, p)) return len(powers) == p-1 for root in range(2, p): if is_primitive_root(root, p): return root raise ValueError(\\"No primitive root found\\") def diffie_hellman_key_exchange(a: int, p: int) -> bool: Simulates the Diffie-Hellman key exchange. # Private keys private_key_alice = random.randint(2, p - 2) private_key_bob = random.randint(2, p - 2) # Public keys public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Shared secret keys shared_secret_alice = pow(public_key_bob, private_key_alice, p) shared_secret_bob = pow(public_key_alice, private_key_bob, p) return shared_secret_alice == shared_secret_bob"},{"question":"# Question You are tasked with writing a function `next_bigger(num: int) -> int` that takes a non-negative integer `num` as input and returns the next higher number formed by the exact same set of digits as the original number. If no such number exists, return -1. Implement the function according to the following rules: 1. Identify the pivot: the rightmost position where the digit is smaller than the digit immediately after it. 2. Identify the smallest digit to the right of the pivot that is larger than the pivot digit. 3. Swap these two digits. 4. Reverse the digits to the right of the pivot point. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Input - A non-negative integer `num` where `0 <= num <= 10^18`. # Output - A non-negative integer which is the next higher permutation of the input number\'s digits, or -1 if no such permutation exists. # Constraints - The input number will not have leading zeros. - The input number can have up to 18 digits. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(99999) == -1 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(1528452) == 1528524 assert next_bigger(5) == -1 ```","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) # Convert number to list of digits length = len(digits) # Step 1: Find the pivot for i in range(length-2, -1, -1): if digits[i] < digits[i + 1]: pivot = i break else: return -1 # If no pivot, there is no higher permutation # Step 2: Find the smallest digit to the right of the pivot which is larger than the pivot digit for j in range(length-1, pivot, -1): if digits[j] > digits[pivot]: swap_index = j break # Step 3: Swap the pivot digit with the identified smallest larger digit digits[pivot], digits[swap_index] = digits[swap_index], digits[pivot] # Step 4: Reverse the digits to the right of the pivot digits = digits[:pivot+1] + digits[pivot+1:][::-1] return int(\'\'.join(digits))"},{"question":"# Scenario In a linguistic laboratory, researchers are working on an interesting problem of transforming one word into another by changing one letter at a time. Each intermediate word must also be a valid dictionary word. They want to find the shortest possible sequence of valid transformations. # Question Given two words (`begin_word` and `end_word`), and a dictionary represented by `word_list`, write a function to determine the length of the shortest transformation sequence from `begin_word` to `end_word`. Return -1 if no such transformation exists. Implement the following function: ```python def ladder_length(begin_word, end_word, word_list): Function to find the length of the shortest transformation sequence. :param begin_word: str - the word to start the transformation. :param end_word: str - the word to transform to. :param word_list: List[str] - a list of valid dictionary words. :return: int - the length of the shortest transformation sequence or -1 if not possible. pass ``` # Input * `begin_word`: A string representing the starting word (1 <= len(begin_word) <= 100) * `end_word`: A string representing the ending word (1 <= len(end_word) <= 100) * `word_list`: A list of strings representing the dictionary of words (1 <= len(word_list) <= 5000) # Output * An integer representing the length of the shortest transformation sequence. # Constraints * All words in the input list, including `begin_word` and `end_word`, are of the same length. * All words consist of lowercase alphabetic characters only. # Example ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] # One shortest transformation is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\" # Output: 5 print(ladder_length(begin_word, end_word, word_list)) # Output: 5 ``` # Note * Return -1 if there is no such transformation sequence possible. * The transformation sequence may contain words that belong to the word list but not listed in this example.","solution":"from collections import deque def ladder_length(begin_word, end_word, word_list): Function to find the length of the shortest transformation sequence. :param begin_word: str - the word to start the transformation. :param end_word: str - the word to transform to. :param word_list: List[str] - a list of valid dictionary words. :return: int - the length of the shortest transformation sequence or -1 if not possible. if end_word not in word_list: return -1 word_set = set(word_list) queue = deque([(begin_word, 1)]) while queue: current_word, length = queue.popleft() if current_word == end_word: return length for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, length + 1)) return -1"},{"question":"Set Cover Problem **Scenario** Imagine you are working as a systems engineer in charge of network setup for a large company. Your task is to determine the minimum cost for the subset of network setups (subsets) that covers all departments (universe) in the company. However, you need the flexibility to work on both small-scale exact solutions and large-scale approximate solutions. **Question** Given a universe of elements and a collection of subsets with associated costs, write two functions that find the minimum cost subcollection of subsets that cover all elements in the universe: 1. **Optimal Solution**: This function should implement an exact algorithm to find the minimum cost subcollection. This solution is expected to work for small inputs due to its exponential complexity. 2. **Greedy Solution**: This function should use a greedy approximation algorithm to find a subcollection with minimal cost, suitable for large inputs. Implement the following functions: ```python def optimal_set_cover(universe, subsets, costs): Finds the minimum cost subcollection of subsets that covers all elements of the universe. Args: universe (set): Set of all elements to be covered. subsets (dict): Dictionary of subsets where keys are subset names and values are sets of elements. costs (dict): Dictionary of costs where keys are subset names and values are costs of those subsets. Returns: list: The optimal subset names that cover the universe with the minimum cost. pass def greedy_set_cover(universe, subsets, costs): Finds an approximate minimum cost subcollection of subsets using a greedy algorithm to cover all elements of the universe. Args: universe (set): Set of all elements to be covered. subsets (dict): Dictionary of subsets where keys are subset names and values are sets of elements. costs (dict): Dictionary of costs where keys are subset names and values are costs of those subsets. Returns: list: The subset names that cover the universe with the minimal cost using the greedy algorithm. pass ``` # Input * `universe` - a set of elements that need to be covered. * `subsets` - a dictionary where keys are subset names and values are sets of elements. * `costs` - a dictionary where keys are subset names and values are the associated costs. # Output * A list of subset names that form the minimum cost cover for `optimal_set_cover`. * A list of subset names that form the approximate minimum cost cover for `greedy_set_cover`. # Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} print(optimal_set_cover(universe, subsets, costs)) # Expected output: [\'S3\', \'S2\'] print(greedy_set_cover(universe, subsets, costs)) # Expected output: [\'S3\', \'S2\'] ``` # Constraints 1. The universe will always have at least one element. 2. Each subset will have a unique name. 3. Costs will be positive integers. 4. Universe and subsets elements are positive integers. # Performance Requirements For the `optimal_set_cover`, it\'s acceptable to have exponential time complexity (O(2^n)) where (n) is the number of subsets. For the `greedy_set_cover`, the time complexity should be polynomial, ideally (O(m cdot |U|)) where (m) is the number of subsets and (|U|) is the size of the universe.","solution":"from itertools import combinations def optimal_set_cover(universe, subsets, costs): Finds the minimum cost subcollection of subsets that covers all elements of the universe. Args: universe (set): Set of all elements to be covered. subsets (dict): Dictionary of subsets where keys are subset names and values are sets of elements. costs (dict): Dictionary of costs where keys are subset names and values are costs of those subsets. Returns: list: The optimal subset names that cover the universe with the minimum cost. subset_names = list(subsets.keys()) best_cost = float(\'inf\') best_cover = None for r in range(1, len(subset_names) + 1): for comb in combinations(subset_names, r): covered = set() cost = 0 for name in comb: covered |= subsets[name] cost += costs[name] if covered >= universe and cost < best_cost: best_cost = cost best_cover = comb return list(best_cover) def greedy_set_cover(universe, subsets, costs): Finds an approximate minimum cost subcollection of subsets using a greedy algorithm to cover all elements of the universe. Args: universe (set): Set of all elements to be covered. subsets (dict): Dictionary of subsets where keys are subset names and values are sets of elements. costs (dict): Dictionary of costs where keys are subset names and values are costs of those subsets. Returns: list: The subset names that cover the universe with the minimal cost using the greedy algorithm. remaining_elements = universe.copy() selected_subsets = [] while remaining_elements: best_subset = None best_cost_effectiveness = float(\'inf\') for name, subset in subsets.items(): covered_elements = remaining_elements & subset if covered_elements: cost_effectiveness = costs[name] / len(covered_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = name if best_subset is None: raise ValueError(\\"No subset can cover the remaining elements, which should not happen under valid inputs.\\") selected_subsets.append(best_subset) remaining_elements -= subsets[best_subset] return selected_subsets"},{"question":"# Linked List Cycle Detection You are given a singly linked list. Write a function `has_cycle(head)` that determines whether the list contains a cycle. A cycle is present if there is a node in the list that can be reached again by continuously following the `next` pointer. # Function Signature ```python def has_cycle(head): :param head: Node: The head node of the linked list. :return: bool: True if there is a cycle, False otherwise. ``` # Input Format - The function receives a single parameter `head` which is the head node of a singly linked list. # Output Format - The function should return a boolean value: `True` if the linked list contains a cycle, and `False` otherwise. # Constraints - Do not use extra space for cycle detection; you must achieve constant space complexity O(1). # Example Example 1: Input: ```plaintext 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle back to node with value 2) ``` Output: ```plaintext True ``` Example 2: Input: ```plaintext 1 -> 2 -> 3 -> 4 -> 5 ``` Output: ```plaintext False ``` # Hints - Consider using a two-pointer technique where one pointer moves twice as fast as the other. ```python class Node: def __init__(self, x): self.val = x self.next = None def has_cycle(head): :param head: Node: The head node of the linked list. :return: bool: True if there is a cycle, False otherwise. # Implementation of the cycle detection algorithm if not head: return False runner = head walker = head while runner.next and runner.next.next: runner = runner.next.next walker = walker.next if runner == walker: return True return False ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def has_cycle(head): Determines if the linked list has a cycle. :param head: Node: The head node of the linked list. :return: bool: True if there is a cycle, False otherwise. if not head: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Question: Secure Key Exchange You are tasked with implementing a secure key exchange system similar to Diffie-Hellman where two parties (Alice and Bob) can exchange keys over an insecure channel. **Function Signature**: `secure_key_exchange(p: int, a: int) -> bool` # Input - `p`: A large prime number. - `a`: A number which must be a primitive root of `p`. # Output - A boolean indicating if the shared keys calculated by both parties are the same. # Constraints 1. `p` should be a prime number. 2. `a` should be a primitive root of `p`. # Steps 1. **Prime Check**: Verify if `p` is a prime number. 2. **Primitive Root Validation**: Ensure `a` is a primitive root of `p`. 3. **Key Generation**: - Alice and Bob independently generate their private and public keys. 4. **Shared Key Calculation**: - Both parties calculate the shared secret using their private keys and the other party\'s public key. 5. **Comparison**: Return `True` if both shared secrets match, indicating a successful key exchange. # Example ```python def secure_key_exchange(p: int, a: int) -> bool: # Prime checking logic here # Primitive root validation here # Key exchange logic here pass assert secure_key_exchange(23, 5) == True # Assume correct values for `p` and `a` ``` # Notes - Make sure to handle edge cases such as invalid prime numbers or non-primitive roots gracefully by returning `False`. - Optimize your solution for large prime numbers as much as possible.","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_primitive_root(a, p): Helper function to check if `a` is a primitive root of `p`. if not is_prime(p): return False required_set = set(num for num in range(1, p)) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set def secure_key_exchange(p: int, a: int) -> bool: Function to conduct a secure key exchange based on modified Diffie-Hellman method if not is_prime(p) or not is_primitive_root(a, p): return False # choose private keys for Alice and Bob alice_private_key = 6 bob_private_key = 15 # calculate public keys alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) # calculate shared secret keys alice_shared_secret = pow(bob_public_key, alice_private_key, p) bob_shared_secret = pow(alice_public_key, bob_private_key, p) return alice_shared_secret == bob_shared_secret"},{"question":"# Problem Description As a developer, you are tasked with creating a function to search for a substring within a given string. This needs to be optimized and handle large texts efficiently. Your solution needs to implement a more complex algorithm than a basic linear search. **Task**: Write a function `str_search(haystack: str, needle: str) -> int` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Requirements - **Input**: - `haystack`: A string in which we will search for `needle` (1 <= len(haystack) <= 10^6). - `needle`: The substring to search for within `haystack` (0 <= len(needle) <= 10^5). - **Output**: - An integer index representing the first position of `needle` in `haystack`. - If `needle` is an empty string, return 0. - If `needle` is not found, return -1. # Constraints - Your function should be efficient and handle large inputs within a reasonable time frame. Consider optimization strategies like the Knuth-Morris-Pratt (KMP) algorithm or the Rabin-Karp algorithm. # Example - Example 1: - Input: haystack = \\"hello\\", needle = \\"ll\\" - Output: 2 - Example 2: - Input: haystack = \\"aaaaa\\", needle = \\"bba\\" - Output: -1 # Additional Notes - Think about potential edge cases like empty `needle`, `needle` longer than `haystack`. - Ensure your solution handles large strings efficiently.","solution":"def str_search(haystack: str, needle: str) -> int: Uses the Knuth-Morris-Pratt (KMP) algorithm to find the first occurrence of the substring \'needle\' in \'haystack\'. Returns the index of the first occurrence of \'needle\' in \'haystack\', or -1 if \'needle\' is not part of \'haystack\'. If \'needle\' is an empty string, returns 0. if needle == \\"\\": return 0 n, m = len(haystack), len(needle) # Compute the LPS (Longest Prefix Suffix) array for the needle lps = [0] * m j = 0 # length of the previous longest prefix suffix i = 1 while i < m: if needle[i] == needle[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # Perform the KMP search algorithm i = 0 # index for haystack j = 0 # index for needle while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Find the Unique Number Given an array of integers `nums`, every element appears twice except for one. Write a function `find_single_number(nums)` to find the single number that is not duplicated. Your algorithm should have a linear runtime complexity (O(n)). Please, do this without using extra memory for another data structure (space complexity O(1)). Function Signature ```python def find_single_number(nums: List[int]) -> int: pass ``` # Input * A list of integers `nums` where every element appears twice except for one unique element, with `1 <= len(nums) <= 10^5` and `-10^9 <= nums[i] <= 10^9`. # Output * Return the single integer that does not appear twice. # Example Example 1: ```python find_single_number([2, 2, 1]) ``` * Output: `1` * Explanation: 1 is the single number, while 2 appears twice. Example 2: ```python find_single_number([4, 1, 2, 1, 2]) ``` * Output: `4` * Explanation: 4 is the single number, while 1 and 2 appear twice. # Constraints * The algorithm should run in O(n) time. * The algorithm should use O(1) extra space. * The list will always have exactly one element that appears once.","solution":"def find_single_number(nums): Finds the single number in the list that does not appear twice. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"You are tasked with writing a method to find the `k-th` smallest element in a Red-Black Tree (RBT). The k-th smallest element in a binary search tree is the k-th smallest element when all elements are sorted in ascending order. # Task: Implement a function `find_kth_smallest` in the Red-Black Tree class provided, which accepts an integer `k` and returns the k-th smallest element in the RBT. # Function Signature: ```python def find_kth_smallest(self, k: int) -> int: ``` # Input: - `k` (int): An integer representing the position (1-based index) of the element to find in the sorted order of the tree. # Output: - Return the value of the k-th smallest element. - If `k` is out of the bounds (less than 1 or greater than the number of nodes in the tree), return `None`. # Constraints: 1. `k` will be a positive integer. 2. The tree will have unique integer values. # Example: ```python # Create an instance of the Red-Black Tree rbt = RBTree() # Insert nodes into the tree nodes = [20, 15, 25, 10, 5, 1, 30, 35] for node in nodes: rbt.insert(RBNode(node, 1)) # Find the k-th smallest element print(rbt.find_kth_smallest(3)) # Output: 10 print(rbt.find_kth_smallest(1)) # Output: 1 print(rbt.find_kth_smallest(8)) # Output: 35 print(rbt.find_kth_smallest(10)) # Output: None ``` # Notes: - You may need to augment your Red-Black Tree with additional information to maintain the size of the subtrees to achieve this efficiently. - Consider how you can use properties of the binary search tree and Red-Black Tree to find the k-th smallest element in a time-efficient manner.","solution":"class RBNode: def __init__(self, data, color, left=None, right=None, parent=None): self.data = data self.color = color # 1 -> Red, 0 -> Black self.left = left self.right = right self.parent = parent self.size = 1 # Initial size of the node\'s subtree is 1 (itself) class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) # Our NULL node which is black self.TNULL.size = 0 # The size of TNULL is 0 self.root = self.TNULL def insert(self, key): # Ordinary Binary Search Insertion new_node = RBNode(key, 1, left=self.TNULL, right=self.TNULL, parent=None) node = self.root parent = None while node != self.TNULL: parent = node parent.size += 1 # Increase the size of every parent node during insertion if new_node.data < node.data: node = node.left else: node = node.right new_node.parent = parent if parent is None: self.root = new_node elif new_node.data < parent.data: parent.left = new_node else: parent.right = new_node # Fix the tree self.insert_fix(new_node) def insert_fix(self, k): # Fix the tree for Red-Black property. # Needs to be done as per the standard Red-Black Tree implementations. # Skipping for simplicity here. Assume the tree is properly balanced after each insert. pass def find_kth_smallest(self, k): return self._find_kth_smallest_node(self.root, k) def _find_kth_smallest_node(self, node, k): if node == self.TNULL or k <= 0 or k > self.root.size: return None left_size = node.left.size if k == left_size + 1: return node.data elif k <= left_size: return self._find_kth_smallest_node(node.left, k) else: return self._find_kth_smallest_node(node.right, k - left_size - 1)"},{"question":"# Bit Manipulation Challenge Objective Given a 32-bit integer, perform a set of bit manipulation tasks to verify and modify specific bit values within the integer. You need to implement four functions that manipulate bits at specific positions as explained below. Functions to Implement * `get_bit(num: int, i: int) -> bool`: Returns whether the bit at position `i` is set to 1 (True) or 0 (False) in `num`. * `set_bit(num: int, i: int) -> int`: Sets the bit at position `i` to 1 and returns the new integer. * `clear_bit(num: int, i: int) -> int`: Clears the bit at position `i` by setting it to 0 and returns the new integer. * `update_bit(num: int, i: int, bit: int) -> int`: Updates the bit at position `i` to the value `bit` (0 or 1) and returns the new integer. Input Format * `num`: A 32-bit integer. * `i`: A non-negative integer representing the bit position (0-based index). * `bit`: An integer representing the bit value, which is either `0` or `1` (only for `update_bit` function). Output Format * For `get_bit`: A boolean value indicating the state of the bit at position `i`. * For `set_bit`, `clear_bit`, `update_bit`: The new integer value after performing the bit manipulation. Constraints * The bit position `i` will be between 0 and 31 inclusive. * The integer `num` is a valid 32-bit signed integer. * The function will not be called with invalid inputs. Examples 1. `get_bit(5, 0)` should return `True` (5 is 101 in binary). 2. `set_bit(5, 1)` should return `7` (5 is 101, setting bit at position 1 results in 111 which is 7). 3. `clear_bit(5, 2)` should return `1` (5 is 101, clearing bit at position 2 results in 001 which is 1). 4. `update_bit(5, 1, 0)` should return `5` (5 is 101, updating bit at position 1 to 0 results in 101 which is 5). Implementation Skeleton ```python def get_bit(num: int, i: int) -> bool: # Your code here def set_bit(num: int, i: int) -> int: # Your code here def clear_bit(num: int, i: int) -> int: # Your code here def update_bit(num: int, i: int, bit: int) -> int: # Your code here ```","solution":"def get_bit(num: int, i: int) -> bool: Returns whether the bit at position i is set to 1 (True) or 0 (False) in num. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the bit at position i to 1 and returns the new integer. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears the bit at position i by setting it to 0 and returns the new integer. return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Updates the bit at position i to the value bit (0 or 1) and returns the new integer. value = (1 << i) if bit: return num | value else: return num & ~value"},{"question":"Problem Statement Given a positive integer `n`, write a function `integer_decompositions(n)` that returns the number of ways `n` can be decomposed into sums of non-negative integers. Ensure that your function uses a dynamic programming approach with a time complexity of O(n^2). # Input - A single integer `n` (1 ≤ n ≤ 100). # Output - An integer representing the number of decompositions of `n` into sums of non-negative integers. # Example ```python # Example 1 input: 4 output: 5 # Explanation: # 4 = 4 # 4 = 3 + 1 # 4 = 2 + 2 # 4 = 2 + 1 + 1 # 4 = 1 + 1 + 1 + 1 # Example 2 input: 7 output: 15 # Explanation: # 7 = 7 # 7 = 6 + 1 # 7 = 5 + 2 # 7 = 5 + 1 + 1 # 7 = 4 + 3 # 7 = 4 + 2 + 1 # 7 = 4 + 1 + 1 + 1 # 7 = 3 + 3 + 1 # 7 = 3 + 2 + 2 # 7 = 3 + 2 + 1 + 1 # 7 = 3 + 1 + 1 + 1 + 1 # 7 = 2 + 2 + 2 + 1 # 7 = 2 + 2 + 1 + 1 + 1 # 7 = 2 + 1 + 1 + 1 + 1 + 1 # 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Constraints - The function must run in O(n^2) time complexity. - The approach must use dynamic programming principles. **Notes**: - You can assume that the input will always be a valid integer within the given range. - It is advised to handle inputs with smaller values to ensure the implementation is accurate. ```python def integer_decompositions(n): # Your code here pass ``` Coding it Up Implement the function `integer_decompositions` following the provided definitions and constraints. Test your function with the examples provided.","solution":"def integer_decompositions(n): Returns the number of ways n can be decomposed into sums of non-negative integers. dp = [1] + [0] * n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Question: You are given an unsorted array `nums`. Your task is to reorder it in-place such that `nums[0] < nums[1] > nums[2] < nums[3]...`. # Requirements * Implement the function `wiggle_sort(nums: List[int]) -> None` that takes a list of integers as input and modifies the list in-place to meet the wiggle condition. * You are not allowed to return any value from this function. * Your solution should have O(n) time complexity and O(1) space complexity. # Constraints * The input list, `nums`, will have a length in the range `1 <= len(nums) <= 10^4`. * The values in the list, `nums`, will be integers in the range `-10^4 <= nums[i] <= 10^4`. # Example ```python def wiggle_sort(nums: List[int]) -> None: for i in range(len(nums)): if (i % 2 == 1) == (nums[i-1] > nums[i]): nums[i-1], nums[i] = nums[i], nums[i-1] # Example usage array = [3, 5, 2, 1, 6, 4] print(\\"Original array:\\", array) wiggle_sort(array) print(\\"Wiggle sorted array:\\", array) ``` # Explanation Given the input `[3, 5, 2, 1, 6, 4]`, after `wiggle_sort`, the output should make the sequence alternate between smaller and larger values: `[3, 5, 1, 6, 2, 4]`. * The element at index 0 (`3`) is less than the element at index 1 (`5`). * The element at index 1 (`5`) is greater than the element at index 2 (`1`). * The element at index 2 (`1`) is less than the element at index 3 (`6`). * And so on. # Note - Use comparisons and swaps effectively to achieve the desired wiggle pattern. - The function should handle edge cases such as very small arrays gracefully.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Modify the list nums in-place to satisfy the wiggle property. nums[0] < nums[1] > nums[2] < nums[3] ... for i in range(1, len(nums)): if (i % 2 == 1) == (nums[i-1] > nums[i]): nums[i-1], nums[i] = nums[i], nums[i-1]"},{"question":"You are given a binary tree and a target sum. Your task is to implement a function to find all root-to-leaf paths where each path\'s sum equals the given sum. Multiple solutions using different traversal strategies are provided to give you context. You need to implement one specific approach: BFS (Breadth-First Search) using a queue. Input: * The first input is the root of a binary tree. Each node contains an integer value. * The second input is an integer `sum`, representing the target sum for the path from the root to a leaf node. Output: * A list of lists, where each list represents a path from root to leaf whose values sum to the target sum. Constraints: - The node values and the sum can be negative. - The input tree can be large, thus performance and memory management are crucial. Requirements: 1. You must use an iterative BFS approach. 2. The solution should handle all edge cases efficiently. Example: Input: ```python root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) sum = 22 ``` Output: ```python [[5, 4, 11, 2], [5, 8, 4, 5]] ``` Note: - The example binary tree used above should lead to these paths as they sum up to 22. # Implementation ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum_bfs(root, sum): if root == None: return [] res = [] queue = [(root, 0, [root.val])] while queue: node, cum_sum, path = queue.pop(0) current_sum = cum_sum + node.val # Check if it\'s a leaf node and sums to the required value if node.left is None and node.right is None and current_sum == sum: res.append(path) if node.left is not None: queue.append((node.left, current_sum, path + [node.left.val])) if node.right is not None: queue.append((node.right, current_sum, path + [node.right.val])) return res ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum_bfs(root, target_sum): if root is None: return [] results = [] queue = [(root, root.val, [root])] while queue: current_node, current_sum, path = queue.pop(0) if not current_node.left and not current_node.right and current_sum == target_sum: results.append([node.val for node in path]) if current_node.left: queue.append((current_node.left, current_sum + current_node.left.val, path + [current_node.left])) if current_node.right: queue.append((current_node.right, current_sum + current_node.right.val, path + [current_node.right])) return results"},{"question":"**Merging Two Sorted Linked Lists** # Scenario You\'re part of a development team working on a feature to merge data from two sorted logs into one unified log. Each log represents a sorted linked list. Your task is to write a function that efficiently merges these sorted linked lists into a single sorted linked list. # Task Write a function `merge_two_lists(l1, l2)` that takes two sorted linked lists as input and returns a new sorted linked list by merging the given lists. # Function Signature ```python def merge_two_lists(l1: Node, l2: Node) -> Node: # Your implementation here ``` # Input - `l1`: A `Node` object representing the head of the first sorted linked list (can be `None` if empty). - `l2`: A `Node` object representing the head of the second sorted linked list (can be `None` if empty). # Output - `Node` object representing the head of the new merged sorted linked list. # Example ```python # Setting up the linked lists: 1 -> 2 -> 4 and 1 -> 3 -> 4 l1 = Node(1) l1.next = Node(2) l1.next.next = Node(4) l2 = Node(1) l2.next = Node(3) l2.next.next = Node(4) # Calling the function merged_head = merge_two_lists(l1, l2) # The merged list should be: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` # Constraints - The lists are sorted in non-decreasing order and can be empty. - Do not use extra space like auxiliary lists. Aim for an optimal solution with O(n + m) time complexity. # Tips - Consider both iterative and recursive approaches. - Pay attention to edge cases such as when one or both of the lists are empty.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1: Node, l2: Node) -> Node: Merges two sorted linked lists into one sorted linked list. :param l1: Node - head of the first sorted linked list :param l2: Node - head of the second sorted linked list :return: Node - head of the merged sorted linked list dummy = Node(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If either list has remaining nodes, append them if l1: current.next = l1 if l2: current.next = l2 return dummy.next"},{"question":"# Context In genomic sequences analysis, one often needs to check if a sequence can be constructed by repeating a smaller motif. This helps in identifying repetitive regions which might be of biological significance. # Task You are given a non-empty string and your task is to determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together. # Function Signature ```python def is_repeated_substring(s: str) -> bool: :param s: str - non-empty input string to check for repeated pattern :return: bool - True if the string can be formed by repeating a substring, False otherwise ``` # Input * A single string `s` of length `n` (1 ≤ n ≤ 10^4). # Output * Return a boolean value **True** if the string can be formed by repeating a substring, otherwise return **False**. # Constraints * The string consists of lowercase English letters only. # Examples ```python assert is_repeated_substring(\\"abab\\") == True assert is_repeated_substring(\\"aba\\") == False assert is_repeated_substring(\\"abcabcabcabc\\") == True assert is_repeated_substring(\\"xyz\\") == False assert is_repeated_substring(\\"a\\") == False ``` # Explanation * For the input \\"abab\\", it can be seen as \\"ab\\" repeated twice, hence the function should return True. * For the input \\"xyz\\", there is no smaller substring that repeats to form the entire string, so the function should return False.","solution":"def is_repeated_substring(s: str) -> bool: Determines if a string can be formed by repeating a smaller substring multiple times. :param s: str - non-empty input string to check for repeated pattern :return: bool - True if the string can be formed by repeating a substring, False otherwise n = len(s) # Try every possible length of the repeating substring from 1 to n//2 for i in range(1, n // 2 + 1): # If the length of the substring divides the length of s perfectly if n % i == 0: # Construct the repeated substring sub = s[:i] if sub * (n // i) == s: return True return False"},{"question":"**Problem Statement** You are to implement a function that will determine the number of digits in a given integer. This function should be efficient and account for both positive and negative integers, including zero. The goal is to employ mathematical properties to ensure constant time complexity. # **Function Signature** ```python def num_digits(n: int) -> int: ``` # **Input** - A single integer `n` where -10^18 ≤ `n` ≤ 10^18. # **Output** - A single integer representing the number of digits in `n`. # **Constraints** - Function must run in O(1) time. - Consider edge cases such as: - Zero - Negative numbers # **Example** ```python num_digits(0) Output: 1 num_digits(12345) Output: 5 num_digits(-12345) Output: 5 num_digits(-1000000000000000000) Output: 19 ``` # **Explanation** - For zero, the output is `1` as it is a single digit number. - For positive and negative numbers, the number of digits is determined based on the absolute value. The implemented function must efficiently utilize mathematical properties such as logarithms to ensure constant time complexity.","solution":"def num_digits(n: int) -> int: Function to determine the number of digits in an integer n. Parameters: n (int): The integer whose digits are to be counted. Returns: int: The number of digits in the integer n. if n == 0: return 1 return len(str(abs(n)))"},{"question":"# Question: Matrix Transformation Functions You are tasked with implementing a series of matrix transformation functions, some of which rotate the matrix by 90 degrees and others invert the matrix along specific diagonals. Your goal is to ensure each function processes the matrix efficiently and handles edge cases appropriately. # Implement the following functions: 1. **rotate_clockwise**: Rotates a given matrix 90 degrees clockwise. 2. **rotate_counterclockwise**: Rotates a given matrix 90 degrees counterclockwise. 3. **top_left_invert**: Inverts a given matrix along its top-left to bottom-right diagonal. 4. **bottom_left_invert**: Inverts a given matrix along its bottom-left to top-right diagonal. Input: - A 2D list `matrix` representing an n x n matrix where `1 <= n <= 1000`. Output: - Returns a new transformed matrix after applying the specified transformation. Examples: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] top_left_invert(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] bottom_left_invert(matrix) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Constraints: - Ensure your functions handle edge cases such as empty matrices without throwing errors. - Each transformation should have `O(n^2)` time complexity.","solution":"def rotate_clockwise(matrix): Rotates a given matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): Rotates a given matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix): Inverts a given matrix along its top-left to bottom-right diagonal. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix): Inverts a given matrix along its bottom-left to top-right diagonal. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"You are given a task to implement two functions: `encode` and `decode` which are used to encode a list of strings into a single string and then decode it back to the original list of strings. This task tests your understanding of string manipulation techniques and algorithm efficiency. Function Specifications 1. **encode**: - **Input**: A list of strings `strs` (e.g., `[\\"hello\\", \\"world\\"]`) - **Output**: A single encoded string representing the list (e.g., `encoded_str = \\"5:hello5:world\\"`) - **Constraints**: The length of the strings will not exceed 200 characters and the total number of strings won\'t exceed 1000. 2. **decode**: - **Input**: An encoded string `s` (e.g., `encoded_str = \\"5:hello5:world\\"`) - **Output**: The original list of strings `strs` (e.g., `[\\"hello\\", \\"world\\"]`) - **Constraints**: The input string `s` will be valid, meaning it was created by the `encode` function. # Edge Cases to Consider * Encoding/decoding an empty list of strings. * Strings containing special characters such as colons. * Consistent handling of very large or empty string values in the list. # Provide Detailed Implementation and Analysis In addition to your implementation, include a brief analysis of the algorithm used, highlighting the time and space complexity, as well as potential improvements or alternative methods for optimal performance. ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your implementation here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your implementation here ``` Your solution will be evaluated based on the correctness, efficiency, and clarity of your code. Be sure to handle all edge cases and provide a thorough explanation of your implementation.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_str = \\"\\" for string in strs: length = len(string) encoded_str += f\\"{length}:{string}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_list = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"# Binary Search Challenge - Last Occurrence Scenario: You are given a sorted array of integers in increasing order and a target integer. Your task is to implement a function that returns the index of the last occurrence of the target integer in the array using a binary search approach. If the target is not present in the array, the function should return -1. This problem tests your understanding and implementation of the binary search algorithm. Function Signature: ```python def find_last_occurrence(array: List[int], target: int) -> int: ``` Input: * `array`: A list of integers sorted in increasing order. * `target`: An integer to find the last occurrence of. Output: * Return an integer, the index of the last occurrence of the target integer in the array. If the target is not present, return -1. Constraints: * The length of the array will not exceed (10^5). * The array elements and the target integer can be any integer between (-10^9) and (10^9). Example: ```python >>> find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) 3 >>> find_last_occurrence([1, 3, 3, 5, 7], 3) 2 >>> find_last_occurrence([2, 4, 4, 4, 6], 8) -1 >>> find_last_occurrence([], 3) -1 ``` Notes: * Make sure your solution handles all edge cases, including empty arrays and target values not present in the array. * Aim for an efficient solution with a time complexity of O(log n).","solution":"def find_last_occurrence(array, target): Returns the index of the last occurrence of target in array, or -1 if target is not present. low, high = 0, len(array) - 1 last_occurrence = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: last_occurrence = mid low = mid + 1 # continue searching to the right elif array[mid] < target: low = mid + 1 else: high = mid - 1 return last_occurrence"},{"question":"# Fibonacci Sequence Generator Implement a function `fib_optimized(n)` that computes the n-th Fibonacci number in an optimized manner, leveraging the technique of your choice between recursion with memoization and iterative approach. Your solution should handle large values of n efficiently. Function Signature ```python def fib_optimized(n: int) -> int: Computes the n-th Fibonacci number. Args: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. ``` Input/Output * **Input**: A single integer `n` (0 <= n <= 10^6). * **Output**: An integer representing the n-th Fibonacci number. Constraints * Ensure that your solution handles cases for large values of n efficiently. * Pay attention to both time and space complexity. Examples 1. ```python fib_optimized(10) # Output: 55 ``` 2. ```python fib_optimized(20) # Output: 6765 ``` 3. ```python fib_optimized(50) # Output: 12586269025 ``` In your implementation, consider the trade-offs between time complexity (how fast your function runs) and space complexity (how much memory your function uses). Make sure to handle edge cases like `n = 0` and `n = 1` correctly, and validate that `n` is non-negative.","solution":"def fib_optimized(n): Computes the n-th Fibonacci number using an iterative approach. Args: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Nearest Neighbor Algorithm Enhancement Your task is to enhance the provided Nearest Neighbor algorithm by implementing a version that efficiently handles larger datasets. You will implement a `KD-Tree` to reduce the time complexity of the nearest neighbor search. Task Details 1. **Input**: - `point`: A tuple representing the target point. - `points`: A list of tuples representing the training dataset. 2. **Output**: - The closest point from the dataset to the target point. 3. **Constraints**: - The dataset can contain up to (10^5) points. - Each point can have up to 10 dimensions. - All values in the points are floating-point numbers within the range [-10^6, 10^6]. 4. **Performance Requirements**: - Aim for a search time complexity better than O(n), where n is the number of points. 5. **Scenario**: You are developing an application that, given a GPS coordinate, can quickly find the nearest city from a database of GPS coordinates of cities around the world. Efficiency is crucial as the database contains a significant number of entries. Function Signature ```python def nearest_neighbor_enhanced(target: tuple, points: list) -> tuple: # Your code here ``` Example Given the target point `(1.0, 2.0)` and the point set `[(2.0, 3.0), (1.5, 2.5), (0.0, 1.0)]`, your function should return `(1.5, 2.5)`. ```python print(nearest_neighbor_enhanced((1.0, 2.0), [(2.0, 3.0), (1.5, 2.5), (0.0, 1.0)])) # Output: (1.5, 2.5) ``` Utilize the properties of the `KD-Tree` for this task, ensuring accurate and efficient searches for the nearest neighbor.","solution":"from scipy.spatial import KDTree def nearest_neighbor_enhanced(target, points): Finds the nearest neighbor using KDTree for a target point from a given list of points. Args: target : tuple The target point for which we are finding the nearest neighbor. points : list of tuples The list of points from which we have to find the nearest neighbor. Returns: tuple The closest point to the target from the dataset. kdtree = KDTree(points) _, idx = kdtree.query(target) return points[idx]"},{"question":"# Problem Context You have been provided with two hash table implementations: a basic `HashTable` and a `ResizableHashTable` that dynamically resizes. Your task is to enhance the `ResizableHashTable` class. # Task Implement a method that allows resizing down once the number of elements falls below one-third of the table size to maintain efficient memory usage. Additionally, ensure that no operation leads to data loss during resizing. # Expected Function Details 1. **reduce_size(self)**: Decreases the table size by half if the number of elements is less than one-third of the current size. Expected Inputs/Outputs * **Input**: None * **Output**: None Function Constraints * After resizing down, the hash table must maintain its integrity with all elements accessible as before. * The new size must be at least the minimum size defined by `MIN_SIZE`. # Constraints - The keys are non-negative integers. - The values associated can be any Python object. - The resizing mechanism should ensure that all key-value pairs are rehashed properly according to the new size. # Performance Requirements - Ensure the resizing operation maintains its efficiency even under large-scale data storage. # Example Suppose initially, the hash table (`ResizableHashTable`) has 8 slots, and you insert elements such that the load factor leads to resizing. Ensure the down-sizing method correctly reduces size when many elements are deleted.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.MIN_SIZE = 8 self.size = initial_size self.count = 0 self.table = [None] * self.size def _hash(self, key): return key % self.size def put(self, key, value): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: break idx = (idx + 1) % self.size if self.table[idx] is None: self.count += 1 self.table[idx] = (key, value) if self.count / self.size > 0.7: self._resize(self.size * 2) def get(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size return None def delete(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.count -= 1 if self.size > self.MIN_SIZE and self.count < self.size // 3: self.reduce_size() return True idx = (idx + 1) % self.size return False def reduce_size(self): if self.size // 2 < self.MIN_SIZE: return new_size = self.size // 2 new_table = [None] * new_size for item in self.table: if item is not None: key, value = item idx = key % new_size while new_table[idx] is not None: idx = (idx + 1) % new_size new_table[idx] = (key, value) self.size = new_size self.table = new_table def _resize(self, new_size): new_table = [None] * new_size for item in self.table: if item is not None: key, value = item idx = key % new_size while new_table[idx] is not None: idx = (idx + 1) % new_size new_table[idx] = (key, value) self.size = new_size self.table = new_table"},{"question":"Problem Statement You are given two singly linked lists that merge at some point into a single linked list. Implement a function `find_intersection(head1, head2)` that takes in the heads of these two linked lists and returns the node at which they intersect. If they do not intersect, return `None`. **Function Signature**: ```python def find_intersection(head1: Node, head2: Node) -> Node: pass ``` Input - `head1`: The head node of the first singly linked list. - `head2`: The head node of the second singly linked list. **Constraints**: - Nodes in the given linked lists will have unique values. - The linked lists can be of different lengths. - The length of both linked lists is at most 10^4. - Do not modify the linked lists. Output - Return the reference of the intersecting node if it exists; otherwise, return `None`. Example ```python # Linked list representation: # List A: 1 -> 3 -> 5 -> 7 -> 9 -> 11 # List B: 2 -> 4 -> 6 -> 7 -> 9 -> 11 # Intersecting node: 7 # Create some dummy nodes to form the example lists a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) # Setup next pointers a1.next = b1; b1.next = c1; c1.next = d a2.next = b2; b2.next = c2; c2.next = d d.next = e; e.next = f print(find_intersection(a1, a2).val) # Should output 7 ``` Notes - Perform thorough testing including edge cases. - Consider linked lists with no intersection. - Ensure the function operates within the given constraints efficiently.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_intersection(head1: Node, head2: Node) -> Node: Returns the node where the two linked lists intersect, or None if they do not intersect. if not head1 or not head2: return None # Initialize two pointers for both linked lists pointer1 = head1 pointer2 = head2 # Traverse both lists. When one pointer reaches the end, switch to the other list\'s head. # If there is an intersection, they will meet there. # If not, they both will reach the end (None) at the same time. while pointer1 != pointer2: pointer1 = pointer1.next if pointer1 else head2 pointer2 = pointer2.next if pointer2 else head1 return pointer1"},{"question":"# Linked List Intersection Detection Objective: Write a function that determines if two singly linked lists intersect and returns the intersection node. The intersection is defined based on reference, not the value. # Input: * Two instances of singly linked lists. # Output: * The node where the two lists intersect. If the lists do not intersect, return `None`. # Constraints: * You can assume there are no cycles anywhere in the entire linked structure. # Example: ``` LinkedList1: 1 -> 3 -> 5 7 -> 9 -> 11 / LinkedList2: 2 -> 4 -> 6 ``` * The function should return the node that holds the value `7` (i.e., `intersection(a1, a2)`). # Function Signature: ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None def intersection(h1, h2): # Your code here # Test your code with custom test cases. ``` # Performance Requirements: * The solution should have a time complexity of O(n + m) and a space complexity of O(1), where n and m are the lengths of the two lists. # Implementation Example: * Consider the nodes built and linked as shown in the example, and verify the function returns the correct intersection node. Good luck and happy coding!","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def intersection(h1, h2): Determines if two singly linked lists intersect and returns the intersection node. :param h1: Node, the head of the first linked list :param h2: Node, the head of the second linked list :return: Node, the intersection node or None if no intersection # Get the lengths of both linked lists def get_length(head): length = 0 current = head while current is not None: length += 1 current = current.next return length len1 = get_length(h1) len2 = get_length(h2) # Align the starts of both lists current1, current2 = h1, h2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next elif len2 > len1: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find the intersection while current1 is not None and current2 is not None: if current1 is current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"# Quick Sort Enhancement You are required to enhance the quick sort algorithm to use the \\"median-of-three\\" technique to choose a pivot, which helps in improving the worst-case performance on nearly sorted data. Additionally, implement edge case handling and optimized base case for sub-arrays with fewer than 10 elements using insertion sort. **Function Signature** ```python def enhanced_quick_sort(arr): Sorts an array using quick sort with median-of-three pivot selection and falls back to insertion sort for small sub-arrays. Parameters: arr (list): The list of elements to be sorted. Returns: list: Sorted list in ascending order. ``` **Input** *An unsorted list of integers.* **Output** *A list of integers sorted in ascending order.* **Constraints** * The length of the list (n) will be in the range [0, 10^5]. * The values of the list elements (x) will be in the range [-10^9, 10^9]. **Performance Requirements** * Expected time complexity is O(n log(n)) on average. # Function Details - **Insertion Sort for Small Sub-arrays**: Use insertion sort for arrays with fewer than 10 elements. - **Median-of-Three Pivot**: The pivot is chosen as the median of the first, middle, and last elements of the array. # Example ```python # Example Input arr = [34, 7, 23, 32, 5, 62] # Example Output enhanced_quick_sort(arr) # Output: [5, 7, 23, 32, 34, 62] ``` *Implement the required `enhanced_quick_sort` function and all helper functions.*","solution":"def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, left, right): mid = (left + right) // 2 if arr[left] > arr[mid]: arr[left], arr[mid] = arr[mid], arr[left] if arr[left] > arr[right]: arr[left], arr[right] = arr[right], arr[left] if arr[mid] > arr[right]: arr[mid], arr[right] = arr[right], arr[mid] return mid def partition(arr, left, right): pivot_index = median_of_three(arr, left, right) pivot = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] i = left - 1 for j in range(left, right): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[right] = arr[right], arr[i + 1] return i + 1 def quick_sort(arr, left, right): if right - left < 10: insertion_sort(arr, left, right) else: if left < right: pi = partition(arr, left, right) quick_sort(arr, left, pi - 1) quick_sort(arr, pi + 1, right) def enhanced_quick_sort(arr): if len(arr) == 0: return arr quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Implement and Optimize Merge Sort for Large Data You are given an array of integers, `arr`, which needs to be sorted in ascending order using the merge sort algorithm. While merge sort is efficient, it tends to use significant extra space. Your task is to: 1. Implement the merge sort algorithm. 2. Optimize the merge operation to reduce space complexity wherever possible. # Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input: * A single list of integers, `arr` with length `n` where ( 0 leq n leq 10^5 ). # Output: * A single list of integers, sorted in non-decreasing order. # Constraints: * Utilize in-place operations as much as possible to minimize additional space usage. * Switch to an alternative internal sorting algorithm (e.g., insertion sort) for sub-arrays smaller than `20` elements within your merge sort implementation. # Example: ```python >>> arr = [6, 5, 12, 10, 9, 1] >>> merge_sort(arr) [1, 5, 6, 9, 10, 12] ``` # Additional Notes: * Be sure to consider edge cases such as empty arrays and arrays with all duplicate values. * Use a divide-and-conquer approach by splitting the array into smaller sub-arrays, sorting the sub-arrays recursively, and then merging the sorted sub-arrays effectively.","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], left: int, mid: int, right: int) -> None: left_copy = arr[left:mid+1] right_copy = arr[mid+1:right+1] left_copy_index = 0 right_copy_index = 0 sorted_index = left while left_copy_index < len(left_copy) and right_copy_index < len(right_copy): if left_copy[left_copy_index] <= right_copy[right_copy_index]: arr[sorted_index] = left_copy[left_copy_index] left_copy_index += 1 else: arr[sorted_index] = right_copy[right_copy_index] right_copy_index += 1 sorted_index += 1 while left_copy_index < len(left_copy): arr[sorted_index] = left_copy[left_copy_index] left_copy_index += 1 sorted_index += 1 while right_copy_index < len(right_copy): arr[sorted_index] = right_copy[right_copy_index] right_copy_index += 1 sorted_index += 1 def merge_sort_util(arr: List[int], left: int, right: int) -> None: if left < right: if right - left <= 20: insertion_sort(arr, left, right) else: mid = (left + right) // 2 merge_sort_util(arr, left, mid) merge_sort_util(arr, mid + 1, right) merge(arr, left, mid, right) def merge_sort(arr: List[int]) -> List[int]: merge_sort_util(arr, 0, len(arr) - 1) return arr"},{"question":"# Scenario You are tasked with optimizing resource allocation in a project where each resource has a benefit value and usage cost. Due to budget constraints, you need to maximize the total benefit without exceeding the budget. # Task Write a function `maximize_benefit` to determine the maximum benefit obtainable given a list of available resources, each defined by a benefit value and usage cost, and a fixed project budget. # Input * An integer `budget` representing the maximum budget available. * A list of tuples `resources`, where each tuple `(benefit, cost)` indicates the benefit value and usage cost of a resource. # Output * An integer representing the maximum summed benefit obtainable without exceeding the budget. # Function Signature ```python def maximize_benefit(budget: int, resources: List[Tuple[int, int]]) -> int: ``` # Constraints * `0 <= budget <= 10^4` * `0 <= len(resources) <= 1000` * Each resource tuple `(benefit, cost)` contains non-negative integers with `0 <= benefit, cost <= 1000`. # Example ```python budget = 5 resources = [(60, 5), (50, 3), (70, 4), (30, 2)] print(maximize_benefit(budget, resources)) # Output: 80 (select items with benefits 50 and 30) ``` # Notes Ensure that your solution efficiently handles the constraints and edge cases, such as zero budget or an empty list of resources.","solution":"from typing import List, Tuple def maximize_benefit(budget: int, resources: List[Tuple[int, int]]) -> int: Function to determine the maximum benefit obtainable given a list of resources and a budget. n = len(resources) dp = [[0 for _ in range(budget + 1)] for _ in range(n + 1)] for i in range(1, n + 1): benefit, cost = resources[i-1] for w in range(1, budget + 1): if cost > w: dp[i][w] = dp[i-1][w] else: dp[i][w] = max(dp[i-1][w], dp[i-1][w-cost] + benefit) return dp[n][budget]"},{"question":"# String Reversal using Different Approaches Context In text processing, one of the standard operations is to reverse given strings for various purposes such as finding palindromes, encoding/decoding tasks, and more. Given this common necessity, it is essential to understand different approaches to achieve this in a programming language, particularly Python for this task. Task Implement four functions to reverse a given string using different approaches: one using recursion, one using an iterative two-pointer technique, one using Python\'s `reversed()` function, and finally, the slicing approach. Specifications * **Input**: A non-empty string `s` of length up to 10^5 characters. * **Output**: The reversed string. Function Signatures ```python def reverse_recursive(s: str) -> str: pass def reverse_iterative(s: str) -> str: pass def reverse_pythonic(s: str) -> str: pass def reverse_ultra_pythonic(s: str) -> str: pass ``` Requirements 1. **reverse_recursive**: * Should use recursion to reverse the string. * Optimize for both time and space complexities. 2. **reverse_iterative**: * Use iteration and the two-pointer technique. * Ensure the method is efficient in terms of space. 3. **reverse_pythonic**: * Utilize Python\'s built-in `reversed()` function. * Make sure the code is concise and clear. 4. **reverse_ultra_pythonic**: * Use Python\'s slicing feature to reverse the string. * Ensure the code is minimal and highly readable. Constraints * The input string will contain only ASCII characters. * The performance for time complexity should aim to be O(n) for iterative, Pythonic, and ultra-Pythonic implementations. Example ```python s = \\"hello\\" reverse_recursive(s) == \\"olleh\\" reverse_iterative(s) == \\"olleh\\" reverse_pythonic(s) == \\"olleh\\" reverse_ultra_pythonic(s) == \\"olleh\\" ``` Implement the functions and ensure they pass comprehensive test cases including empty strings, single characters, and long strings up to the provided limit.","solution":"def reverse_recursive(s: str) -> str: Reverse the string using a recursive approach. if len(s) <= 1: return s return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s: str) -> str: Reverse the string using an iterative two-pointer technique. chars = list(s) left, right = 0, len(chars) - 1 while left < right: chars[left], chars[right] = chars[right], chars[left] left += 1 right -= 1 return \'\'.join(chars) def reverse_pythonic(s: str) -> str: Reverse the string using Python\'s built-in reversed() function. return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s: str) -> str: Reverse the string using Python\'s slicing feature. return s[::-1]"},{"question":"# Run-Length Encoding and Decoding Given the explanation of the Run-Length Encoding (RLE) and Run-Length Decoding (RLD) algorithms, implement the following functions to perform data compression and decompression: 1. **`encode_rle(input: str) -> str`**: This function takes an input string and returns its RLE-encoded version. 2. **`decode_rle(input: str) -> str`**: This function takes an RLE-encoded string and returns the original decompressed version. Input: - For `encode_rle`: A string of data (0 ≤ length ≤ 10^5), consisting of lowercase alphabets. - For `decode_rle`: A valid RLE-encoded string (0 ≤ length ≤ 10^5), consisting of digit and lowercase alphabet pairs. Output: - For `encode_rle`: A string representing the RLE-encoded data. - For `decode_rle`: The original uncompressed string. Constraints: - Ensure to handle edge cases like empty strings, strings with no consecutive characters, etc. - Maintain the linear time complexity (O(n)) for both encoding and decoding functions. Example: ```python assert encode_rle(\\"aaabbbbbcc\\") == \\"3a5b2c\\" assert decode_rle(\\"3a5b2c\\") == \\"aaabbbbbcc\\" assert encode_rle(\\"abcd\\") == \\"1a1b1c1d\\" assert decode_rle(\\"1a1b1c1d\\") == \\"abcd\\" assert encode_rle(\\"\\") == \\"\\" assert decode_rle(\\"\\") == \\"\\" ``` Write implementations for `encode_rle` and `decode_rle` using the provided description and verify the correctness with the given examples and edge cases.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 # Append the last sequence encoded.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded)"},{"question":"# **Search Algorithm Evaluation Problem** **Context**: To understand the efficiency and effectiveness of different search algorithms, we frequently need to implement and compare them with basic methods. One such basic method is Linear Search, which checks each element in the array one by one until it finds a match or concludes there isn\'t one. **Task**: Write a function `custom_linear_search` that takes a list of integers and a target integer as its input, and returns the index of the target integer in the list using the linear search method. If the target integer is not found in the list, the function should return -1. Your implementation should include careful consideration for edge cases to ensure robustness. **Function Signature**: ```python def custom_linear_search(arr: list, target: int) -> int: # Your implementation here pass ``` **Input**: - `arr`: A list of integers where each integer represents an element in the array. The array can be empty. - `target`: An integer representing the element you need to find in the array. **Output**: - Return an integer. The index of the found element within the array, or -1 if the target is not present. **Constraints**: - The function must implement linear search. - The list `arr` can contain up to 10^4 integers. - The `target` integer can be any integer value that fits within a typical integer range. - Optimize the function to be efficient and handle edge cases, such as an empty array or the absence of the target element. **Examples**: ```python # Example 1 assert custom_linear_search([34, 8, 23, 4, 68], 23) == 2 # Example 2 assert custom_linear_search([1, 2, 3, 4, 5], 6) == -1 # Example 3 assert custom_linear_search([], 10) == -1 # Example 4 assert custom_linear_search([10, 20, 30, 40, 50], 30) == 2 # Example 5 assert custom_linear_search([7, 7, 7, 7, 7], 7) == 0 ``` Ensure your implementation is correct and consider edge cases and performance constraints.","solution":"def custom_linear_search(arr: list, target: int) -> int: Perform a linear search to find the target in the list. Parameters: arr (list): A list of integers. target (int): An integer to find in the list. Returns: int: The index of the target element if found, otherwise -1. for index, value in enumerate(arr): if value == target: return index return -1"},{"question":"You are given a Trie (Prefix Tree) data structure implementation to store and search for words efficiently. Your task is to implement two additional functionalities: 1. Implement a function `count_words_with_prefix(prefix: str) -> int` that counts the number of words in the trie that start with the given prefix. 2. Implement a function `delete_word(word: str) -> bool` that removes a word from the trie and returns True if the word was successfully removed, and False if the word was not found in the trie. # Function Signatures ```python class Trie: __init__(self): def insert(self, word: str): def search(self, word: str) -> bool: def starts_with(self, prefix: str) -> bool: # Function to implement def count_words_with_prefix(self, prefix: str) -> int: # Function to implement def delete_word(self, word: str) -> bool: ``` # Expected Input and Output Formats `count_words_with_prefix` - **Input**: A single string `prefix`. - **Output**: An integer representing the number of words that start with the given prefix. `delete_word` - **Input**: A single string `word`. - **Output**: A boolean value, True if the word is successfully removed, False otherwise. # Constraints - All inputs consist of lowercase letters (a-z). - Matching words or prefixes in the trie must be case-sensitive. # Performance Requirements - Optimize for both time and space complexity where possible. # Example ```python # Creating a Trie and inserting words trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"application\\") trie.insert(\\"appetite\\") # Searching for words with the prefix \'app\' print(trie.count_words_with_prefix(\\"app\\")) # Output: 4 # Deleting a word from the trie print(trie.delete_word(\\"application\\")) # Output: True print(trie.search(\\"application\\")) # Output: False print(trie.count_words_with_prefix(\\"app\\")) # Output: 3 ``` # Notes 1. Ensure to handle edge cases such as deleting a word not present in the trie or handling empty prefixes. 2. Think about how the structure of a Trie might help in implementing the `count_words_with_prefix` function efficiently. 3. For the `delete_word` function, ensure that no unnecessary nodes remain in the trie once a word is deleted.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.word_count = 0 # Tracks the number of words with this prefix class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word_count += 1 # Increment the word count for each prefix node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def count_words_with_prefix(self, prefix: str) -> int: node = self.root for char in prefix: if char not in node.children: return 0 node = node.children[char] return node.word_count def delete_word(self, word: str) -> bool: def delete(node, word, depth): if not node: return False if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return True # Successfully deleted the end of word return False char = word[depth] if char in node.children and delete(node.children[char], word, depth + 1): if node.children[char].word_count == 0: # No words with this prefix anymore del node.children[char] return True return False node = self.root for char in word: if char in node.children: node.children[char].word_count -= 1 node = node.children[char] else: return False # Word not found in the Trie return delete(self.root, word, 0)"},{"question":"# Josephus Problem Implementation Task **Scenario:** You are responsible for organizing a circular elimination game. Participants are arranged in a circular manner, and every kth person is eliminated after counting k members. This process continues until all participants are eliminated. **Goal:** You need to write a function that takes in a list of participants and an integer k to simulate their elimination in the Josephus problem style and returns the order in which participants are eliminated. # Function Signature ```python def josephus_list(participants: List[int], k: int) -> List[int]: ``` # Input 1. `participants` (List[int]): A list of integers representing participants. 2. `k` (int): An integer indicating every kth member to be removed. # Output - Returns a list of integers representing the order in which participants are eliminated. # Constraints - The `participants` list will have at least one participant. - The value of `k` will be at least 1 and at most `len(participants)`. # Example - Input: `participants = [1, 2, 3, 4, 5, 6, 7, 8, 9], k = 3` - Output: `[3, 6, 9, 4, 8, 5, 2, 7, 1]` **Explanation:** Starting with participant 3, every 3rd participant is removed in each iteration. The order of elimination follows the sequence shown in the output. **Notes:** 1. Ensure your function handles edge cases and is efficient in its operations. 2. Do NOT modify the input list `participants` in place unless absolutely necessary.","solution":"from typing import List def josephus_list(participants: List[int], k: int) -> List[int]: Solves the Josephus problem by eliminating every kth member in the order until all are eliminated. Parameters: participants (List[int]): List of participants. k (int): Every kth member to be removed. Returns: List[int]: The order of elimination of participants. elimination_order = [] index = 0 while participants: index = (index + k - 1) % len(participants) elimination_order.append(participants.pop(index)) return elimination_order"},{"question":"# Question: Implementing and Using Binary Search for Insertion You are asked to implement the `binary_search_insert` function which uses binary search to determine the correct insertion index for a specified value within a sorted array. Function Signature ```python def binary_search_insert(sorted_array: List[int], value: int) -> int: pass ``` # Input - `sorted_array`: A list of integers in non-decreasing order. - `value`: An integer that you want to find the insertion index for. # Output - An integer representing the position where the value would be inserted to maintain the sorted order of the array. # Examples ```python binary_search_insert([1, 3, 5, 6], 5) # Output: 2 binary_search_insert([1, 3, 5, 6], 2) # Output: 1 binary_search_insert([1, 3, 5, 6], 7) # Output: 4 binary_search_insert([1, 3, 5, 6], 0) # Output: 0 binary_search_insert([], 8) # Output: 0 ``` # Constraints - The `sorted_array` can have a size in the range [0, 10^6]. - The `value` can be any integer within the typical 32-bit signed integer range. # Performance Requirement - The solution should have a time complexity of O(log n). # Scenario Context To aid in understanding a scenario where the function might be used, consider a situation where you are maintaining a leaderboard which must be updated frequently as new scores are submitted. Efficiently finding out where to insert new scores into a sorted list of existing scores is crucial for maintaining such a dynamically updated data structure. # Requirements - Implement the `binary_search_insert` function. - Ensure you handle edge cases effectively (e.g., when the array is empty or contains duplicate values).","solution":"from typing import List def binary_search_insert(sorted_array: List[int], value: int) -> int: Uses binary search to find the correct insertion index for the specified value within a sorted array. Parameters: sorted_array (List[int]): A list of integers in non-decreasing order. value (int): An integer to find the insertion index for. Returns: int: The insertion index to maintain the sorted order. left, right = 0, len(sorted_array) while left < right: mid = (left + right) // 2 if sorted_array[mid] < value: left = mid + 1 else: right = mid return left"},{"question":"# Context You are part of a team developing a new file system that represents files in a hierarchical list. One important feature is to reverse the list of files within a directory to create a \\"most recently added first\\" view for users. To integrate this feature, you need to write a function that can reverse a singly linked list of file nodes. # Task Implement a function `reverse_file_list(head)` that reverses a singly linked list of files. # Expected Input and Output - **Input**: The function `reverse_file_list(head)` takes a single argument: - `head` (ListNode): a reference to the head of a singly linked list. - **Output**: The function should return a reference to the head of the reversed singly linked list. # Constraints - The linked list may be empty. - Each node in the linked list contains a unique integer identifier for the file. - The length of the list will not exceed 10^4 nodes. # Performance Requirements - The function should run in O(n) time complexity. - The function should have O(1) additional space complexity besides the recursion stack if using a recursive approach. # Sample Usage ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example Linked List: 1 -> 2 -> 3 -> 4 node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 new_head = reverse_file_list(node1) # Expected Output: 4 -> 3 -> 2 -> 1 ``` # Requirements - Implement both iterative and recursive solutions to reverse the singly linked list. - Ensure proper handling of edge cases such as an empty list and a single-node list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_file_list(head): Reverses a singly linked list of file nodes. :param head: ListNode - The head of the singly linked list. :return: ListNode - The head of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Context You are given a task to search for the presence of a specific word within a large body of text using the Rabin-Karp algorithm. Implementing the algorithm efficiently will save time compared to direct string matching, especially when dealing with large texts and multiple pattern searches. Task Write a function `find_pattern(pattern: str, text: str) -> int` that uses the Rabin-Karp algorithm to find the first occurrence of the `pattern` in the `text`. If the `pattern` exists in the `text`, the function should return the starting index of the first occurrence; otherwise, it should return `-1`. Function Signature ```python def find_pattern(pattern: str, text: str) -> int: pass ``` Expected Input and Output Formats * **Input**: * `pattern` - a non-empty string of length `m` (1 ≤ m ≤ 10^4). * `text` - a string of length `n` (1 ≤ n ≤ 10^5) where `m` ≤ `n`. * **Output**: * Returns the zero-based starting index of the first occurrence of the `pattern` in the `text`. * If the `pattern` does not exist in the `text`, returns `-1`. Constraints * Only lowercase English letters (\'a\' - \'z\') are allowed in `pattern` and `text`. Example ```python # Example 1: pattern = \\"test\\" text = \\"this is a test text\\" find_pattern(pattern, text) -> 10 # Example 2: pattern = \\"a\\" text = \\"abcabc\\" find_pattern(pattern, text) -> 0 # Example 3: pattern = \\"notfound\\" text = \\"this is a test text\\" find_pattern(pattern, text) -> -1 ``` Performance Requirements * The implementation should run in O(n + m) average time complexity. * Handle edge cases such as empty string inputs, pattern larger than text, efficiently. Additional Notes * You can use the rolling hash class as given in the code snippet or implement your own hash function. * Pay attention to potential hash collisions and ensure robust handling to avoid false positives.","solution":"def find_pattern(pattern: str, text: str) -> int: Uses the Rabin-Karp algorithm to find the first occurrence of the pattern in the text. Returns the starting index of the first occurrence if found, otherwise returns -1. # Base parameters for the Rabin-Karp algorithm base = 256 prime = 101 m = len(pattern) n = len(text) # Early exit if pattern length is greater than text length if m > n: return -1 # Compute the hash value for the pattern and the first window of the text pattern_hash = 0 text_hash = 0 h = 1 for i in range(m-1): h = (h * base) % prime for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(n - m + 1): if pattern_hash == text_hash: # Verify the characters if hash matches for j in range(m): if text[i + j] != pattern[j]: break else: return i if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime if text_hash < 0: text_hash += prime return -1"},{"question":"# Problem: You are given an array of integers sorted in ascending order and a target integer. Your task is to return the 1-based indices of the two distinct elements in the array that sum up to the target value. The solution should utilize a binary search strategy for efficiency. Implement a function `find_indices_with_sum` to achieve this. Write the function prototype: ```python def find_indices_with_sum(numbers: list[int], target: int) -> list[int]: ``` # Inputs: - `numbers` (list[int]): A list of integers sorted in ascending order. - `target` (int): The target sum. # Outputs: - list[int]: Indices of the two elements that add up to the target (1-based indexing). # Constraints: - The input array will contain only positive integers. - There will be exactly one solution guaranteed. - The input array will contain at most 10^4 elements. # Performance Requirements: - Time Complexity: Expected to be O(n log n) - Space Complexity: Should not exceed O(1) extra space. # Example: Example 1: Input: ```python numbers = [2, 7, 11, 15] target = 9 ``` Output: ```python [1, 2] ``` Example 2: Input: ```python numbers = [1, 2, 3, 4, 5] target = 6 ``` Output: ```python [1, 5] ``` # Edge Cases: - Minimal and maximal constraints, e.g., empty list, single element list. - Multiple solutions, ensure returning smallest lexicographical pair. - Consider lists where large numbers need careful reference e.g., target sums beyond individual elements. Hint: Implement the solution using a nested loop where the inner loop utilizes binary search to identify the pairing element efficiently.","solution":"def find_indices_with_sum(numbers: list[int], target: int) -> list[int]: Returns the 1-based indices of the two distinct elements in the array that sum up to the target value. def binary_search(arr, x, start): A helper function to find the index of x in arr[start:] using binary search. low, high = start, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == x: return mid elif arr[mid] < x: low = mid + 1 else: high = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(numbers, complement, i + 1) if j != -1: return [i + 1, j + 1] return []"},{"question":"You are tasked with writing a function that determines the minimal number of bit flips required to transform one integer into another. Your solution should optimize performance both in terms of time and space. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` # Input - `a` (int): A non-negative integer. - `b` (int): Another non-negative integer. # Output - `int`: The minimal number of bit flips to convert `a` to `b`. # Constraints 1. Both `a` and `b` will be non-negative integers. 2. The values of `a` and `b` will be within the range of a 32-bit unsigned integer. # Example ```python assert count_flips_to_convert(29, 15) == 2 assert count_flips_to_convert(4, 10) == 3 assert count_flips_to_convert(0, 0) == 0 assert count_flips_to_convert(1023, 0) == 10 ``` # Scenario Consider a scenario where you need to analyze and compare binary data in network packets. To efficiently identify differences between packet headers (which may be represented as integers), you want to know the number of bits that differ between two headers. Your task is to implement the function `count_flips_to_convert` that accomplishes this efficiently.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bit flips required to transform integer a into integer b. Args: a (int): A non-negative integer. b (int): Another non-negative integer. Returns: int: The minimal number of bit flips to convert a to b. # XOR the numbers to find bits that differ xor = a ^ b # Count the number of 1s in the result (which represents differing bits) count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"# Simplifying Unix-Style File Paths As a software developer, you are tasked with implementing a function to simplify Unix-style file paths. These paths are used in file systems to reference file locations. Task Write a function `simplify_path(path)` that accepts a string representing an absolute Unix-style file path and returns the simplified canonical path. Input * A string `path` representing the Unix-style file path. The path contains only characters `a-z`, `A-Z`, `0-9`, `/`, `.` and `..`. Output * A simplified absolute path as a string. Constraints * The input string `path` is non-empty. * The input path always starts with a \'/\' and does not end with a \'/\' unless it\'s the root directory. Examples ```python assert simplify_path(\\"/home/\\") == \\"/home\\" assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" assert simplify_path(\\"/../\\") == \\"/\\" assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" assert simplify_path(\\"/home/../../..\\") == \\"/\\" assert simplify_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" ``` Explanation * For `path = \\"/home/\\"`, return `\\"/home\\"`: It is already a simplified, canonical path. * For `path = \\"/a/./b/../../c/\\"`, return `\\"/c\\"`: Navigates to `/a`, `b`, goes back up twice and then to `c`. * For `path = \\"/../\\"`, return `\\"/\\"`: Goes back to the root directory. * For `path = \\"/home//foo/\\"`, return `\\"/home/foo\\"`: Multiple slashes are treated as a single slash. # Requirements * Your solution should achieve a time complexity of O(n), where n is the length of the input path. * You should use a stack data structure to assist with path simplification.","solution":"def simplify_path(path): Simplifies the given Unix-style file path to its canonical form. Parameters: path (str): The Unix-style file path to simplify. Returns: str: The simplified canonical file path. stack = [] # Split the path by \'/\' components = path.split(\'/\') for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) # Assemble the canonical path simplified_path = \'/\' + \'/\'.join(stack) return simplified_path"},{"question":"# Coding Challenge: Detect Circular Dependencies **Context**: You are part of a software engineering team developing a module that manages package dependencies for a programming environment. In this system, packages may have dependencies on other packages, forming a directed graph. A potential issue you need to address is the detection of circular dependencies, which could cause infinite installation loops. **Task**: Write a function `detect_cycle_in_dependencies(dependencies)` that takes a dictionary representing the package dependencies and returns `True` if there is a circular dependency, and `False` otherwise. **Function Signature**: ```python def detect_cycle_in_dependencies(dependencies: Dict[str, List[str]]) -> bool: pass ``` **Input**: - `dependencies`: A dictionary where keys are package names (strings) and values are lists of package names that are dependencies of the key package. **Output**: - Return `True` if the input contains a cycle, otherwise return `False`. **Constraints**: - Each package name will be a non-empty string. - Package names are case-sensitive. - There will be at most 10^3 packages. - The dependency list for each package will have at most 10^3 entries. **Example**: ```python dependencies = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert detect_cycle_in_dependencies(dependencies) == True dependencies = { \'X\': [\'Y\'], \'Y\': [\'Z\'], \'Z\': [] } assert detect_cycle_in_dependencies(dependencies) == False ``` **Notes**: 1. Consider scenarios where some packages have no dependencies. 2. Handle cases where the input dictionary is empty. 3. Ensure your function performs efficiently within the given constraints.","solution":"def detect_cycle_in_dependencies(dependencies): This function detects if there is a cycle in the given dependencies. Parameters: dependencies (dict): A dictionary where keys are package names (strings) and values are lists of package names that are dependencies of the key package. Returns: bool: True if there is a circular dependency, False otherwise. def visit(node): if node in temp_mark: return True if node in perm_mark: return False temp_mark.add(node) for neighbor in dependencies.get(node, []): if visit(neighbor): return True temp_mark.remove(node) perm_mark.add(node) return False temp_mark = set() perm_mark = set() for pkg in dependencies: if visit(pkg): return True return False"},{"question":"# Question: Sum to Zero Triplets **Objective**: Implement an algorithm to find unique triplets within an array of integers that sum up to zero. **Scenario**: You\'ve been tasked with developing a function to identify all unique combinations of three distinct elements in an array that sum up to zero. This is to aid in financial analytics where balances need to be adjusted by identifying such triplets. **Function Specification**: ```python def find_zero_sum_triplets(nums: List[int]) -> Set[Tuple[int, int, int]]: :param nums: List[int] - An array of integers which may include positive, negative, and zero values. :return: Set[Tuple[int, int, int]] - A set of unique triplets (three integers) each of which sums to zero. ``` **Input**: - `nums`: A list of integers which might contain both positive and negative numbers as well as zero. **Output**: - Return a set containing unique triplets that sum up to zero. **Constraints**: - You must not return duplicate triplets. - Ensure the solution returns within a reasonable time for input arrays up to size 1000. **Requirements**: - Time complexity should ideally be O(n^2). - Adequately handle edge cases such as arrays with fewer than three elements and those that do not contain any valid triplets. **Example**: ```python # Example assert find_zero_sum_triplets([-1, 0, 1, 2, -1, -4]) == {(-1, 0, 1), (-1, -1, 2)} assert find_zero_sum_triplets([0, 0, 0, 0]) == {(0, 0, 0)} assert find_zero_sum_triplets([]) == set() ``` Use the provided example and constraints to guide your implementation. Pay special attention to optimizing performance and handling duplicates appropriately.","solution":"from typing import List, Set, Tuple def find_zero_sum_triplets(nums: List[int]) -> Set[Tuple[int, int, int]]: nums.sort() triplets = set() for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplets.add((nums[i], nums[left], nums[right])) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplets"},{"question":"# Question: Implement a Selection Sort Algorithm You are tasked with implementing the Selection Sort algorithm to sort an array of numbers. Your implementation should sort the given array in ascending order by repeatedly finding the minimum element from the unsorted part and moving it to the front. # Function Specification **Function Name**: `selection_sort` **Input**: A list of integers `arr`. An optional boolean parameter `simulation` to print the array at each iteration for demonstration purposes (default is `False`). **Output**: A list of integers sorted in ascending order. **Constraints**: - The list `arr` can contain 0 or more integers. - If `simulation` is `True`, print the state of the array at the end of each outward loop iteration in the format: ``` iteration <iteration_number>: <array_elements> ``` # Example ```python selection_sort([64, 25, 12, 22, 11], simulation=True) ``` **Output**: ``` iteration 0: 11 25 12 22 64 iteration 1: 11 12 25 22 64 iteration 2: 11 12 22 25 64 iteration 3: 11 12 22 25 64 iteration 4: 11 12 22 25 64 ``` **Algorithm**: - Iterate from `i = 0` to `len(arr) - 1`: - Find the index of the minimum element from `arr[i]` to `arr[len(arr) - 1]`. - Swap the minimum element with the element at index `i`. - If `simulation` is `True`, print the array after the swap. # Your Task Complete the function `selection_sort` described above to sort the given array according to the specifications. Ensure to handle edge cases like an empty array.","solution":"def selection_sort(arr, simulation=False): n = len(arr) for i in range(n): # Find the minimum element in the unsorted part min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element of the unsorted part arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print the state of the array if simulation is True if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Quick Sort Implementation Challenge Scenario You are a software engineer tasked to sort a large dataset efficiently. Your project involves processing large arrays of integers and ensuring they are sorted in ascending order for subsequent analysis steps. Speed and memory efficiency are crucial for your solution. Problem Statement Implement the Quick Sort algorithm to sort an array of integers in ascending order. Your solution should efficiently handle large arrays and avoid performance degradation in worst-case scenarios. Detailed Requirements 1. **Function Signature**: Implement a function `quick_sort(arr: List[int]) -> List[int]`. 2. **Input**: A list of integers `arr` which may contain duplicate values. 3. **Output**: A new list with the integers sorted in ascending order. Constraints * The length of the list ( n ) satisfies ( 0 leq n leq 10^6 ). * The integer values within the list fit within the typical range for programming languages (say -10^9 to 10^9). Performance Requirements * Time Complexity: Your solution should aim for O(n log(n)) on average. * Space Complexity: Optimize for O(log(n)) additional space due to recursion. Edge Cases * The function should handle an empty list. * Ensure the function correctly handles lists with one element or all identical elements. * Optimize the pivot selection to avoid worst-case time complexity scenarios. ```python def quick_sort(arr): Sorts an array of integers using the Quick Sort algorithm and returns the sorted array. :param arr: List[int] - A list of integers to sort. :return: List[int] - A new list with integers sorted in ascending order. # Implementation of Quick Sort # Your code goes here ``` Example Input: ```python arr = [3, 6, 8, 10, 1, 2, 1] ``` Output: ```python [1, 1, 2, 3, 6, 8, 10] ```","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Quick Sort algorithm and returns the sorted array. :param arr: List[int] - A list of integers to sort. :return: List[int] - A new list with integers sorted in ascending order. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Problem Description You are provided with an algorithm that adds two positive integers using bitwise operations. To further reinforce your understanding of bitwise operations, implement a function that multiplies two positive integers without using the \'*\' operator. # Function Signature ```python def multiply_bitwise_operator(a: int, b: int) -> int: pass ``` # Input Format - The function will receive two positive integers `a` and `b` where (1 leq a, b leq 10^9). # Output Format - The function should return a single integer which is the product of `a` and `b`. # Constraints - You must not use the \'*\' operator or the `math.prod` function. - Aim for an efficient solution with a time complexity of (O(n)), where (n) is the number of bits in the larger number. # Example **Example 1:** ```python multiply_bitwise_operator(2, 3) ``` Output: ``` 6 ``` **Example 2:** ```python multiply_bitwise_operator(7, 8) ``` Output: ``` 56 ``` # Considerations - Think about the properties of bitwise shifts and addition: you can express multiplication as repeated addition. - Keep in mind edge cases, such as one of the integers being zero. # Task Implement the `multiply_bitwise_operator` function so that it multiplies two positive integers using bitwise operations only. Ensure that your implementation is efficient and handles edge cases properly.","solution":"def multiply_bitwise_operator(a: int, b: int) -> int: Multiplies two positive integers using bitwise operations. result = 0 while b > 0: if b & 1: # Check if the least significant bit is 1 result = add_bitwise(result, a) a = a << 1 # Left shift a by 1 (equivalent to multiplying by 2) b = b >> 1 # Right shift b by 1 (equivalent to dividing by 2) return result def add_bitwise(x: int, y: int) -> int: Adds two integers using bitwise operations. while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"# Cosine Similarity Calculation Scenario: You are working on a machine learning application that includes a feature for text similarity detection. This requires measuring the similarity between text documents represented as high-dimensional vectors. Implement a function to calculate the cosine similarity between any two such vectors, ensuring efficiency and handling potential edge cases. Function Definition: ```python def cosine_similarity(vec1, vec2): Calculates the cosine similarity between two equal-length vectors. :param vec1: list of integers/floats - First vector :param vec2: list of integers/floats - Second vector :return: float - Cosine similarity between the two vectors :raises ValueError: If the input vectors are of different lengths Example: >>> cosine_similarity([1, 2, 3], [4, 5, 6]) 0.9746318461970762 ``` Constraints: 1. Both vectors must be of the same length. 2. Vectors must contain only numeric elements (integers or floats). 3. Handle possible division by zero scenarios gracefully. Performance Requirements: 1. The time complexity should be O(n) where n is the number of elements in the vectors. 2. The space complexity should be O(1) in terms of additional space used beyond input vectors. Ensure your implementation passes the following edge cases: * Vectors of differing lengths. * Vectors with zero magnitude. * Vectors containing all zeros. * Sparse vectors with many zero elements.","solution":"import math def cosine_similarity(vec1, vec2): Calculates the cosine similarity between two equal-length vectors. :param vec1: list of integers/floats - First vector :param vec2: list of integers/floats - Second vector :return: float - Cosine similarity between the two vectors :raises ValueError: If the input vectors are of different lengths if len(vec1) != len(vec2): raise ValueError(\\"The input vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"You are given a list of student records in the form of dictionaries. Each dictionary contains two keys: \\"name\\" and \\"score\\". Given a student\'s name, your task is to find the score of the student using a search algorithm. If the student does not exist in the list, return -1. Write a function: ```python def find_student_score(records, name): Find the score of the given student in the records. Parameters: records (list of dict): A list of student records, where each record is a dictionary with keys \\"name\\" and \\"score\\". name (str): The name of the student to search for. Returns: int: The score of the student, or -1 if the student is not found. ``` # Input - A list of dictionaries `records`, where each dictionary has: - `name (str)`: the name of the student. - `score (int)`: the score of the student. - A string `name`, the name of the student whose score needs to be found. # Output - An integer: the score of the student if found, otherwise -1. # Example Given the following records: ```python records = [ {\\"name\\": \\"Alice\\", \\"score\\": 90}, {\\"name\\": \\"Bob\\", \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"score\\": 92} ] name = \\"Bob\\" find_student_score(records, name) ``` The function should return: ``` 85 ``` Given the following records: ```python records = [ {\\"name\\": \\"Alice\\", \\"score\\": 90}, {\\"name\\": \\"Bob\\", \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"score\\": 92} ] name = \\"David\\" find_student_score(records, name) ``` The function should return: ``` -1 ``` # Constraints 1. The length of `records` will be in the range [0, 10^5]. 2. Each `name` in records is unique and will have a length in the range [1, 100]. 3. `score` will be a non-negative integer and will be less than or equal to 100. # Notes - Focus on the clarity and efficiency of your implementation. - Consider edge cases such as empty lists or names not present in the list.","solution":"def find_student_score(records, name): Find the score of the given student in the records. Parameters: records (list of dict): A list of student records where each record is a dictionary with keys \\"name\\" and \\"score\\". name (str): The name of the student to search for. Returns: int: The score of the student, or -1 if the student is not found. for record in records: if record[\'name\'] == name: return record[\'score\'] return -1"},{"question":"# Question: MST for Custom Weighted Graph Given a connected and undirected graph with weighted edges, determine the minimum cost to construct a spanning tree using Kruskal\'s algorithm. Implement the function `minimum_spanning_tree(n, edges)` that computes the total weight of the minimum spanning tree for the provided graph, where: - **Input**: - `n` (int): Number of vertices in the graph ((1 leq n leq 1000)). - `edges` (List[Tuple[int, int, int]]): List of tuples where each tuple represents an edge in the format ((u, v, weight)), with (u) and (v) as vertices connected by the edge and `weight` as the edge\'s weight ((1 leq weight leq 10000)). - **Output**: - **int**: The total weight of the minimum spanning tree. - Return -1 if it\'s impossible to form a connected graph (i.e., if the graph is disconnected). **Constraints**: - Ensure your implementation handles large inputs efficiently. **Example**: ```python edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] n = 5 print(minimum_spanning_tree(n, edges)) # Output: 14 ``` **Details**: - Vertices are 1-indexed. - Handle conversion from 1-indexed to 0-indexed internally if necessary. - Ensure efficient implementation using appropriate data structures. **Hints**: - Utilize a disjoint set (union-find) to manage connected components. - Sort edges by weight and add them to the MST if they don\'t form a cycle.","solution":"def minimum_spanning_tree(n, edges): Determines the minimum cost to construct a spanning tree using Kruskal\'s algorithm. Parameters: n (int): Number of vertices in the graph. edges (List[Tuple[int, int, int]]): List of tuples representing the edges in the format (u, v, weight). Returns: int: The total weight of the minimum spanning tree, or -1 if it\'s impossible to form a connected graph. # Implementing the Union-Find data structure with path compression and union by rank. parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Convert 1-indexed to 0-indexed edges = [(u-1, v-1, weight) for u, v, weight in edges] # Sort edges by their weights edges.sort(key=lambda edge: edge[2]) mst_weight = 0 edges_used = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight edges_used += 1 # If we used exactly (n-1) edges, then we have a spanning tree if edges_used == n - 1: return mst_weight else: return -1"},{"question":"You are tasked to determine the minimum number of perfect squares which sum up to a given positive integer. The theorem guarantees that this number will always be between 1 and 4. Your implementation should be able to handle edge cases and should optimize the checks to ensure the solution is computed efficiently. # Function Signature ```python def num_perfect_squares(number: int) -> int: pass ``` # Input * `number`: A positive integer (1 ≤ number ≤ 10^4) # Output * Returns the minimum number of perfect squares that sum up to the given `number`. # Constraints - The input integer is positive. - The theorem guarantees the result will be between 1 to 4. # Example Cases 1. `num_perfect_squares(9)` should return `1` (9 = 3^2) 2. `num_perfect_squares(10)` should return `2` (10 = 3^2 + 1^2) 3. `num_perfect_squares(12)` should return `3` (12 = 2^2 + 2^2 + 2^2) 4. `num_perfect_squares(31)` should return `4` (31 = 5^2 + 2^2 + 1^2 + 1^2) # Requirements - Your solution should efficiently find the minimum count of perfect squares. - Ensure you handle special cases, particularly those involving properties like 4^a(8b + 7). # Hints 1. Consider mathematical properties and theorems that can reduce the required number of checks. 2. Use modular arithmetic for initial filtering. 3. Look for optimization in perfect square detection.","solution":"import math def num_perfect_squares(number: int) -> int: Returns the minimum number of perfect squares that sum up to the given number. # Check if number is a perfect square if int(math.sqrt(number)) ** 2 == number: return 1 # Check the Legendre\'s three-square theorem (n = 4^a * (8b + 7)) for minimum 4 squares while number % 4 == 0: number //= 4 if number % 8 == 7: return 4 # Check if a number can be expressed as a sum of two squares for i in range(1, int(math.sqrt(number)) + 1): if int(math.sqrt(number - i * i)) ** 2 == number - i * i: return 2 # Otherwise, the number can be expressed as a sum of three squares return 3"},{"question":"# Question: Optimized Soring Algorithm Objective Write a Python function, `optimized_sort`, that aims to perform better than the traditional Exchange Sort for larger datasets. Function Signature ```python def optimized_sort(arr: list) -> list: pass ``` Instructions 1. **Input**: A single list of integers, `arr`. You can assume the input list will have no more than 1000 elements. 2. **Output**: Return a list of integers sorted in ascending order. 3. **Constraints**: * You must implement an efficient sorting algorithm: selecting an algorithm with an average time complexity better than (O(n^2)) is preferable. * The sorting algorithm should be stable, maintaining the relative order of records with equal values. 4. **Edge Case Considerations**: * The function should handle and return an empty list if provided. * The function should work correctly if the input list contains one element or multiple elements with the same value. 5. **Performance Requirements**: * The solution should be optimized for time complexity, specifically aiming to use (O(n log n)) operations. Example ```python # Example 1 input_array = [5, 3, 8, 6, 2, 7] print(optimized_sort(input_array)) # Expected Output: [2, 3, 5, 6, 7, 8] # Example 2 input_array = [9, 1, 4, 3, 0, 2, 5, 7] print(optimized_sort(input_array)) # Expected Output: [0, 1, 2, 3, 4, 5, 7, 9] # Example 3 input_array = [10, -3, 0, -10, 5] print(optimized_sort(input_array)) # Expected Output: [-10, -3, 0, 5, 10] # Example 4 input_array = [] print(optimized_sort(input_array)) # Expected Output: [] ``` Notes * Consider using algorithms such as Merge Sort or Tim Sort (which is used internally by Python\'s built-in sort function for its efficiency). * Document your code and provide a brief explanation of the chosen sorting approach.","solution":"def optimized_sort(arr: list) -> list: Returns a sorted list of integers in ascending order using an efficient sorting algorithm. The algorithm selected is Timsort, which is used internally by Python\'s built-in sorted() function and the list.sort() method. Timsort has an average and worst-case time complexity of O(n log n). :param arr: A list of integers :return: A list of integers sorted in ascending order return sorted(arr)"},{"question":"# Assessing Polynomial and Monomial Operations You are provided with two classes, `Monomial` and `Polynomial`, representing basic algebraic structures. Your task is to implement the missing method `__truediv__` for the `Polynomial` class according to the guidelines below. # Objective: Implement the division of two polynomials where division is defined by: 1. Dividing each monomial in the numerator by the divisor monomial. 2. Ensuring the divisor monomial is the entire polynomial or a single monomial. 3. Handling division by systems of multiple monomials up to implementation avoidance. # Implementation Requirements: - Implement the method in Python. - Maintain the existing structure of the classes. - Ensure the result is a simplified polynomial after division. # Input: - `self`: A polynomial object calling the division. - `other`: Another polynomial or monomial object to be divided with. # Output: - A polynomial representing the quotient of the division. # Constraints: - Division by zero should raise a `ValueError`. - Division by a polynomial of multiple monomials is not supported and should raise a `ValueError`. # Examples: ```python # Example 1: # p1 = x^2 + 2x # p2 = x # Result: x + 2 poly1 = Polynomial([Monomial({1: 2}), Monomial({1: 1}, 2)]) result1 = poly1.__truediv__(Monomial({1: 1})) print(result1) # Polynomial([Monomial({1: 1}), Monomial({}, 2)]) # Example 2: # p1 = x^3 - 3x + 2 # p2 = 1 # Result: x^3 - 3x + 2 (Division by 1 doesn\'t change the polynomial) poly2 = Polynomial([Monomial({1: 3}), Monomial({1: 1}, -3), Monomial({}, 2)]) result2 = poly2.__truediv__(Monomial({}, 1)) print(result2) # Polynomial([Monomial({1: 3}), Monomial({1: 1}, -3), Monomial({}, 2)]) ```","solution":"class Monomial: def __init__(self, terms, coefficient=1): self.terms = terms # A dictionary where keys are variables and values are their exponents self.coefficient = coefficient def __truediv__(self, other): if other.coefficient == 0: raise ValueError(\\"Division by zero monomial is not allowed.\\") # Perform division for coefficients new_coefficient = self.coefficient / other.coefficient # Perform division for terms new_terms = self.terms.copy() for var, exponent in other.terms.items(): if var in new_terms: new_terms[var] -= exponent if new_terms[var] == 0: del new_terms[var] else: new_terms[var] = -exponent return Monomial(new_terms, new_coefficient) class Polynomial: def __init__(self, monomials): self.monomials = monomials def __truediv__(self, other): if isinstance(other, Polynomial): if len(other.monomials) != 1: raise ValueError(\\"Division by a polynomial with multiple monomials is not supported.\\") other = other.monomials[0] if isinstance(other, Monomial): if other.coefficient == 0: raise ValueError(\\"Division by zero monomial is not allowed.\\") result_monomials = [monomial / other for monomial in self.monomials] return Polynomial(result_monomials) raise ValueError(\\"Unsupported type for division\\") def __repr__(self): return \\" + \\".join([f\\"{monomial.coefficient}{\'\'.join([f\'{var}^{exp}\' for var, exp in monomial.terms.items()])}\\" for monomial in self.monomials]) # Create polynomial and monomial objects for testing poly1 = Polynomial([Monomial({1: 2}), Monomial({1: 1}, 2)]) poly2 = Monomial({1: 1}) result1 = poly1 / poly2 print(result1) # Polynomial([Monomial({1: 1}), Monomial({}, 2)]) poly3 = Polynomial([Monomial({1: 3}), Monomial({1: 1}, -3), Monomial({}, 2)]) poly4 = Monomial({}, 1) result2 = poly3 / poly4 print(result2) # Polynomial([Monomial({1: 3}), Monomial({1: 1}, -3), Monomial({}, 2)])"},{"question":"Advanced Shell Sort Shell Sort is an advanced sorting algorithm that arranges elements spaced apart by a gap, then progressively reduces the gap, ultimately performing insertion sort on the mostly sorted array. You are tasked with implementing an optimized version of Shell Sort using a more efficient gap sequence to improve its performance. The gap sequence chosen is the Hibbard sequence, where gaps are of the form (2^k - 1) in decreasing order. Requirements: * **Function Signature**: `def optimized_shell_sort(arr: List[int]) -> List[int]:` * **Input**: A list of integers `arr` (1 ≤ len(arr) ≤ 1000, -10^6 ≤ arr[i] ≤ 10^6). * **Output**: A sorted list in non-decreasing order. * **Constraints**: * Use the Hibbard gap sequence for sorting. * Maintain overall space complexity of O(1). * Provide a solution with improved runtime efficiency within practical limits. Example: ```python assert optimized_shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert optimized_shell_sort([5,2,9,1,5,6]) == [1, 2, 5, 5, 6, 9] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([1]) == [1] ```","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers using Shell Sort with the Hibbard gap sequence. if not arr: return arr n = len(arr) # Generate Hibbard\'s gap sequence: 2^k - 1 in decreasing order k = 1 gaps = [] while (2 ** k - 1) < n: gaps.append(2 ** k - 1) k += 1 gaps.reverse() # Perform Shell Sort using the Hibbard gap sequence for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Minimum Spanning Tree Challenge using Kruskal\'s Algorithm Objective Implement a function to compute the minimum spanning tree\'s weight for a given connected, undirected graph using Kruskal’s Algorithm. # Function Signature ```python def compute_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: pass ``` Input * `vertex_count` (int): Number of vertices ( V ) in the graph. * `edges` (List[Tuple[int, int, int]]): List of tuples ((u, v, weight)) representing an edge between vertex ( u ) and vertex ( v ) with the given weight. Output * Returns an integer representing the sum of the weights of the minimum spanning tree. Example **Input:** ```python vertex_count = 5 edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] ``` **Output:** ```python 14 ``` Constraints * ( 1 leq text{vertex_count} leq 1000 ) * ( 0 leq text{weight} leq 10^5 ) * The graph is connected and undirected. # Requirements * Ensure that the solution handles edge cases like graphs with identical edge weights. * The function should be optimized for large inputs by using efficient methods for sorting and union-find operations. * Clear error handling in case of invalid inputs is expected. # Notes * Assume that the input graph is always connected, so an MST will always exist. * Vertices are 1-indexed in the input but your function\'s implementation should use 0-indexed for internal processing.","solution":"def compute_mst(vertex_count, edges): Computes the weight of the minimum spanning tree for a graph using Kruskal\'s Algorithm. :param vertex_count: int - Number of vertices in the graph. :param edges: List[Tuple[int, int, int]] - List of tuples representing edges and their weights. :return: int - Total weight of the minimum spanning tree. parent = list(range(vertex_count)) rank = [0] * vertex_count def find(v): if parent[v] != v: parent[v] = find(parent[v]) # Path compression return parent[v] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: # Union by rank if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Convert edges to 0-indexed edges = [(u-1, v-1, weight) for u, v, weight in edges] # Sort edges by weight edges.sort(key=lambda x: x[2]) mst_weight = 0 mst_edges = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight mst_edges += 1 if mst_edges == vertex_count - 1: break return mst_weight"},{"question":"Hailstone Sequence Analyzer You are given an integer `n`. Your task is to implement a function `analyze_hailstone(n)` that produces two main outputs: the hailstone sequence starting at `n`, and the number of steps taken to reach 1. Function Signature ```python def analyze_hailstone(n: int) -> (list, int): ``` Input * A single integer `n` where 1 ≤ n ≤ 10^6. Output * A tuple containing: * A list representing the hailstone sequence from `n` to 1. * An integer representing the total number of steps taken to reach 1. Example ```python assert analyze_hailstone(5) == ([5, 16, 8, 4, 2, 1], 5) assert analyze_hailstone(1) == ([1], 0) ``` Constraints * Ensure your solution efficiently handles the upper limit constraints. * Optimize for minimizing the memory footprint where possible, and be cautious about integer overflow scenarios. Notes: * Pay attention to edge cases such as `n` being 1, as it directly returns the sequence `[1]` with 0 steps. * Consider using memoization if needed to optimize your solution for repeated calls.","solution":"def analyze_hailstone(n: int) -> (list, int): Analyzes the hailstone sequence starting from n and calculates the number of steps to reach 1. Parameters: n (int): The starting point of the hailstone sequence (1 ≤ n ≤ 10^6) Returns: tuple: A list representing the hailstone sequence and an integer for the number of steps to reach 1. sequence = [n] steps = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 sequence.append(n) steps += 1 return sequence, steps"},{"question":"You have been tasked with generating a custom sequence of numbers from 1 to N based on specific rules. Write a function, `fizzbuzz_sequence(N: int) -> List[Union[int, str]]`, that returns a list containing the numbers from 1 to N. However, for multiples of 3, the number should be replaced with the string \\"Fizz\\", for multiples of 5 with \\"Buzz\\", and for multiples of both 3 and 5 with \\"FizzBuzz\\". # Requirements and Constraints - **Input**: An integer N (1 ≤ N ≤ 10^6). - **Output**: A list where each element is either an integer or a string (\\"Fizz\\", \\"Buzz\\", or \\"FizzBuzz\\") based on the rules described. - **Performance**: The solution should have a time complexity of O(N) and a space complexity of O(N). # Example ```python # Input N = 15 # Output [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Function Signature ```python def fizzbuzz_sequence(N: int) -> List[Union[int, str]]: ``` # Notes - The function **must** validate the input and handle cases where N is less than 1 by raising a ValueError. - Ensure the implementation can handle the upper constraint efficiently. - Think about potential optimizations and code readability when designing your solution.","solution":"from typing import List, Union def fizzbuzz_sequence(N: int) -> List[Union[int, str]]: Generate a FizzBuzz sequence from 1 to N. Replace multiples of 3 with \\"Fizz\\", multiples of 5 with \\"Buzz\\", and multiples of both 3 and 5 with \\"FizzBuzz\\". Args: - N (int): The upper range of the sequence (1 ≤ N ≤ 10^6). Returns: - List[Union[int, str]]: The FizzBuzz sequence. Raises: - ValueError: If N is less than 1. if N < 1: raise ValueError(\\"The input N must be at least 1.\\") result = [] for i in range(1, N + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Question: Find the Index to Maximize Continuous 1s in a Binary Array Objective You are given a binary array, where each element is either 0 or 1. You need to determine the index of a `0` that, if replaced by `1`, would maximize the length of the longest contiguous subarray of `1`s. Function Specification ```python def max_ones_index(arr: List[int]) -> int: Find the index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array. If there is no 0 in the array, return -1. :param arr: List[int] : Input binary array :return: int : Index of 0 to be replaced, or -1 if no 0 exists ``` Input - **arr**: A list of integers representing a binary array. (1 ≤ len(arr) ≤ 10^5) Output - An integer index of the `0` that should be replaced with `1` to maximize the longest contiguous sequence of `1`s. - If there are multiple possible answers, return the leftmost index. - If there is no `0` in the array, return `-1`. Constraints - The array will have at least one element. Example - Input: `[1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]` - Output: `3` - Input: `[1, 1, 1, 1, 1]` - Output: `-1` - Input: `[0, 1, 0, 1, 1, 1]` - Output: `2` Notes - Be sure to handle edge cases such as arrays without any `0`.","solution":"def max_ones_index(arr): Find the index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array. If there is no 0 in the array, return -1. max_count = 0 # For storing the maximum number of 1s we can have max_index = -1 # Index of 0 to be replaced last_zero = -1 # To track the index of the last 0 left = 0 # Left pointer to count number of contiguous 1\'s for right in range(len(arr)): # Expand the window by moving right pointer if arr[right] == 0: left = last_zero + 1 last_zero = right # Calculate the length of current window current_count = right - left + 1 # Update max_count and index if we find a better solution if current_count > max_count: max_count = current_count max_index = last_zero return max_index"},{"question":"Context: You are tasked with implementing an ordered stack that maintains elements in sorted order upon insertion. The highest element is always at the top of the stack. This structure is useful for scenarios requiring both stack operations and ordered retrievals. Task: Implement the OrderedStack class in Python, ensuring that all elements remain sorted in descending order after each insertion. Specifications: - **Class**: `OrderedStack` - **Methods**: 1. `__init__(self)`: Initializes an empty stack. 2. `is_empty(self)`: Returns `True` if the stack is empty, `False` otherwise. 3. `push(self, item)`: Adds a new item to the stack while maintaining sorted order. 4. `pop(self)`: Removes and returns the top item of the stack. Raises `IndexError` if the stack is empty. 5. `peek(self)`: Returns the top item of the stack without removing it. 6. `size(self)`: Returns the number of items in the stack. Input and Output: - `push(item)`: Receives an integer `item` to add to the stack. No return value. - `pop()`: Returns the integer that is removed from the stack. - `peek()`: Returns the integer at the top of the stack. - `size()`: Returns an integer representing the number of items in the stack. - `is_empty()`: Returns a boolean indicating whether the stack is empty. Constraints: - The stack operates with integer values. - Negative and duplicate integers are allowed. - The stack should not exceed a length of 10^6. Performance Requirements: Ensure the `push` operation maintains a complexity of O(n). # Example: ```python stack = OrderedStack() stack.push(5) stack.push(3) stack.push(7) stack.push(6) assert stack.pop() == 7 assert stack.peek() == 6 assert stack.size() == 3 assert not stack.is_empty() ``` # Notes: 1. You must handle edge cases such as pushing to an empty stack and popping from an empty stack. 2. Ensure the implementation is optimal within the given constraints.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): # Insert item in descending sorted order i = len(self.stack) - 1 while i >= 0 and self.stack[i] < item: i -= 1 self.stack.insert(i + 1, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[0] def size(self): return len(self.stack)"},{"question":"# Binary Tree Paths Scenario You are working for a company that needs to analyze the decision paths taken in their proprietary binary decision tree represented in Python. Each node on this tree represents a decision point. Your task is to write a function that will list all paths from the root to the leaf nodes of the tree. Your Task Implement a function named `binary_tree_paths` that accepts the root of a binary tree and returns a list of all paths from the root to leaf nodes as strings. Function Signature ```python def binary_tree_paths(root): # your code here ``` Input - `root` (TreeNode): The root of the binary tree. A `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output - `List[str]`: A list of all paths, each path is represented as a string where nodes are separated by \'->\'. Constraints - The number of nodes in the tree is in the range of `[0, 100]`. - The value of a node is an integer in the range of `[-1000, 1000]`. Example Example 1: ```python Input: root = [1,2,3,null,5] Output: [\\"1->2->5\\", \\"1->3\\"] Explanation: 1 / 2 3 5 There are two paths from root to leaf nodes: 1. 1->2->5 2. 1->3 ``` Example 2: ```python Input: root = [1] Output: [\\"1\\"] Explanation: 1 There is only one path from root to leaf nodes: 1. 1 ``` Additional Notes - Use the Depth-First Search (DFS) approach as an initial strategy to solve this problem. - Consider different edge cases such as trees with a single path or an empty tree. - Try to optimize your solution where possible to handle larger trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): if not root: return [] def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \'\', paths) return paths"},{"question":"# Question You are tasked with enhancing the efficiency of a Fibonacci sequence calculator. Your goal is to implement an optimized version of the Fibonacci function for calculating the n-th Fibonacci number. Given an integer `n`, write a function `fib_optimized(n)` that returns the n-th Fibonacci number using an iterative approach to ensure efficient execution both in terms of time and space. Function Signature ```python def fib_optimized(n: int) -> int: ``` # Requirements * **Input**: A single integer `n` (0 <= n <= 10^6) * **Output**: The n-th Fibonacci number. # Constraints * Your solution should be efficient and compute the result in linear time, O(n). * Your solution should use O(1) additional space. # Examples ```python fib_optimized(0) -> 0 fib_optimized(1) -> 1 fib_optimized(10) -> 55 fib_optimized(50) -> 12586269025 fib_optimized(100) -> 354224848179261915075 ``` # Explanation * **fib_optimized(0)=0**: The 0-th Fibonacci number is 0. * **fib_optimized(1)=1**: The 1-st Fibonacci number is 1. * **fib_optimized(10)=55**: The sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. * **fib_optimized(50)** and **fib_optimized(100)** should return quickly due to the efficiency of the algorithm.","solution":"def fib_optimized(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Scenario You are building an application where you need to verify the lengths of various numeric inputs provided by the users. It is crucial for the correct functioning of the application that the length of each input (in terms of the number of digits) is accurately counted. To ensure this, you need to implement the `count_digits` function that exhibits the properties and constraints described below. Function Requirements **Function Signature**: ```python def count_digits(n: int) -> int: ``` **Inputs**: - `n` (int): The integer whose digits are to be counted. Can be negative or positive. **Outputs**: - Returns an integer representing the number of digits in the absolute value of `n`. **Constraints**: - The function must operate in constant time O(1). - The function should handle zero correctly. - The function should correctly handle negative numbers. - The function should be robust enough to handle the highest and lowest values representable by an integer. **Example**: ```python assert count_digits(0) == 1 assert count_digits(123) == 3 assert count_digits(-456) == 3 assert count_digits(99999) == 5 ``` **Instructions**: 1. Implement the `count_digits` function. 2. Ensure your implementation adheres to the specified constraints. 3. Test your function using the provided examples and any additional edge cases you can think of.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the absolute value of the integer n. return len(str(abs(n)))"},{"question":"**Two Sum Problem using Various Algorithms** Given an array of integers sorted in ascending order, find two numbers such that they add up to a specific target number. Implement three functions to solve this problem using: 1. Binary Search. 2. Hash Tables. 3. Two Pointers. # Function Signature ```python def two_sum_binary_search(numbers: List[int], target: int) -> List[int]: pass def two_sum_hash_table(numbers: List[int], target: int) -> List[int]: pass def two_sum_two_pointers(numbers: List[int], target: int) -> List[int]: pass ``` # Input 1. `numbers`: A list of integers sorted in ascending order. 2. `target`: An integer representing the target sum. # Output A list with two integers representing the indices (1-based) of the two numbers that add up to `target`. Both indices should be valid in the context of `numbers`. # Example Input ```python numbers = [2, 7, 11, 15], target = 9 ``` Output ```python [1, 2] # Because numbers[0] + numbers[1] == 2 + 7 == 9. Note: Indices are 1-based. ``` # Constraints - The array is non-empty. - Each input will have exactly one solution. - No element is used more than once. - The solution should be both efficient in terms of time and space. # Requirements 1. **Binary Search Implementation**: - Ensure function uses binary search to find the complement. - Solve in (O(n log n)) time complexity. 2. **Hash Table Implementation**: - Use a dictionary to quickly find the complement. - Solve in (O(n)) time complexity. 3. **Two Pointers Implementation**: - Use two pointers to scan from the start and end of the array. - Solve in (O(n)) time complexity. # Additional Challenge Discuss why one of the methods might be preferred over the others in different scenarios, particularly considering time and space efficiency.","solution":"from typing import List def two_sum_binary_search(numbers: List[int], target: int) -> List[int]: def binary_search(array, start, end, value): while start <= end: mid = start + (end - start) // 2 if array[mid] == value: return mid elif array[mid] < value: start = mid + 1 else: end = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(numbers, i + 1, len(numbers) - 1, complement) if j != -1: return [i + 1, j + 1] return [] def two_sum_hash_table(numbers: List[int], target: int) -> List[int]: num_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in num_to_index: return [num_to_index[complement] + 1, i + 1] num_to_index[num] = i return [] def two_sum_two_pointers(numbers: List[int], target: int) -> List[int]: left, right = 0, len(numbers) - 1 while left < right: curr_sum = numbers[left] + numbers[right] if curr_sum == target: return [left + 1, right + 1] elif curr_sum < target: left += 1 else: right -= 1 return []"},{"question":"You are given a singly linked list. Your objective is to write a function `is_sorted` that determines if the linked list is sorted in increasing order. If the list is sorted, the function should return `True`, otherwise, it should return `False`. An empty linked list should be considered sorted. # Function Signature ```python def is_sorted(head: ListNode) -> bool: ``` # Input - `head`: The head node of a singly linked list, where each node contains an integer value. # Output - Returns `True` if the linked list is sorted in increasing order, `False` otherwise. # Constraints - The list may contain any integer values (both positive and negative). - The length of the list is between 0 and 10^5. # Performance Requirements - The function should run in O(n) time complexity, where n is the number of nodes in the linked list. - The function should use only O(1) additional space. # Example ```python # Example 1: # Input: head = 1 -> 2 -> 3 -> 4 # Output: True # Example 2: # Input: head = 1 -> 2 -> -1 -> 3 # Output: False # Example 3: # Input: head = None # Output: True ``` # Additional Information Describe and handle edge cases such as: - An empty linked list should return `True`. - A linked list with a single node should return `True`. # Context You are working on a data integrity check system for a data processing pipeline. Ensuring that your dataset maintains sorted order in certain phases of the pipeline is crucial for the performance of subsequent data operations. Implementing this function as a safeguard can save unnecessary processing and help in maintaining data integrity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: Determines if the linked list is sorted in increasing order. :param head: The head node of a singly linked list. :return: True if the list is sorted in increasing order, False otherwise. if not head: # An empty list is considered sorted. return True current = head while current.next: if current.val > current.next.val: # If current value is greater than next value, list is not sorted. return False current = current.next return True"},{"question":"Pythagorean Triple Calculation Objective: You are tasked with implementing a function that determines the missing side length of a right-angled triangle using the Pythagorean theorem. Given the lengths of two sides and a placeholder for the third side, your function should correctly compute the length of the unknown side. Function Signature: ```python def calculate_third_side(opposite, adjacent, hypotenuse): Calculate the missing side length of a right-angled triangle. Parameters: opposite (float or str): Length of the opposite side or \'?\' if unknown. adjacent (float or str): Length of the adjacent side or \'?\' if unknown. hypotenuse (float or str): Length of the hypotenuse or \'?\' if unknown. Returns: float: The computed length of the missing side. # Implement the function here. ``` Input Format: - Three parameters where one of them is `?` indicating the unknown side. The other two are floating numbers representing known lengths. Output Format: - A floating number representing the length of the missing side. Constraints: - Only one of the sides will be missing and indicated by `?`. - The known side lengths are non-negative floats. - The relationship among sides follows the Pythagorean theorem. Example: ```python # Example 1 print(calculate_third_side(3, 4, \'?\')) # Output: 5.0 # Example 2 print(calculate_third_side(3, \'?\', 5)) # Output: 4.0 # Example 3 print(calculate_third_side(\'?\', 4, 5)) # Output: 3.0 ``` Requirements: - Handle edge cases such as invalid inputs and impossible triangle dimensions. - Ensure the function has constant time and space complexity. Performance Requirements: - The solution must run in O(1) time and utilize O(1) space.","solution":"import math def calculate_third_side(opposite, adjacent, hypotenuse): Calculate the missing side length of a right-angled triangle. Parameters: opposite (float or str): Length of the opposite side or \'?\' if unknown. adjacent (float or str): Length of the adjacent side or \'?\' if unknown. hypotenuse (float or str): Length of the hypotenuse or \'?\' if unknown. Returns: float: The computed length of the missing side. if hypotenuse == \'?\': # Hypotenuse is unknown return math.sqrt(float(opposite) ** 2 + float(adjacent) ** 2) elif opposite == \'?\': # Opposite side is unknown return math.sqrt(float(hypotenuse) ** 2 - float(adjacent) ** 2) elif adjacent == \'?\': # Adjacent side is unknown return math.sqrt(float(hypotenuse) ** 2 - float(opposite) ** 2) else: return None # This should not happen as per given constraints"},{"question":"# Question: Implement `EnhancedRandomizedSet` Implement a variation of the `RandomizedSet` data structure called `EnhancedRandomizedSet` that provides the following additional functionalities along with the existing ones: 1. `get_max()`: Returns the maximum element in the set. 2. `get_min()`: Returns the minimum element in the set. Your implementation should maintain the average time complexity O(1) for insert, remove, and get_random operations. However, you may allow O(n) time complexity for maintaining max and min if needed. Expected Input and Output Formats * `insert(val: int) -> bool`: Inserts a value into the set and returns `True` if the value was not present, otherwise returns `False`. * `remove(val: int) -> bool`: Removes a value from the set and returns `True` if the value was present, otherwise returns `False`. * `get_random() -> int`: Returns a random value from the set. * `get_max() -> int`: Returns the maximum value in the set. * `get_min() -> int`: Returns the minimum value in the set. Constraints - Values inserted will be integers. - Remove and retrieval methods should not be called on an empty set. - You may assume methods will be called in an order where the set is never empty when `get_random`, `get_max`, or `get_min` is called. Implementation Outline Using the provided code structure for `RandomizedSet`, implement the `EnhancedRandomizedSet` with additional max and min functionalities: ```python import random class EnhancedRandomizedSet: def __init__(self): self.nums = [] self.idxs = {} self.max_val = None self.min_val = None def insert(self, val): # Implement this method pass def remove(self, val): # Implement this method pass def get_random(self): # Implement this method pass def get_max(self): # Implement this method pass def get_min(self): # Implement this method pass if __name__ == \\"__main__\\": ers = EnhancedRandomizedSet() print(\\"insert 1: \\", ers.insert(1)) print(\\"insert 2: \\", ers.insert(2)) print(\\"insert 3: \\", ers.insert(3)) print(\\"insert 4: \\", ers.insert(4)) print(\\"max: \\", ers.get_max()) print(\\"min: \\", ers.get_min()) print(\\"remove 3: \\", ers.remove(3)) print(\\"max: \\", ers.get_max()) print(\\"min: \\", ers.get_min()) print(\\"remove 1: \\", ers.remove(1)) print(\\"random: \\", ers.get_random()) ```","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.nums = [] self.indexes = {} self.max_val = None self.min_val = None def insert(self, val): if val in self.indexes: return False self.indexes[val] = len(self.nums) self.nums.append(val) # Update max and min values if self.max_val is None or val > self.max_val: self.max_val = val if self.min_val is None or val < self.min_val: self.min_val = val return True def remove(self, val): if val not in self.indexes: return False idx, last = self.indexes[val], self.nums[-1] self.nums[idx], self.indexes[last] = last, idx self.nums.pop() del self.indexes[val] # Update max and min values if self.nums: if val == self.max_val: self.max_val = max(self.nums) if val == self.min_val: self.min_val = min(self.nums) else: self.max_val = self.min_val = None return True def get_random(self): return random.choice(self.nums) def get_max(self): return self.max_val def get_min(self): return self.min_val"},{"question":"# Scenario: You are a software engineer working on a system that involves frequent insertions, deletions, and searches in a collection of data. The collection must remain balanced to ensure efficient query performance. # Task: Implement a Red-Black Tree to maintain the collection. Write a function `find_kth_smallest` that will return the k-th smallest element in the tree. This will help in efficient range querying and accessing elements in sorted order. # Specifications: - Implement the function `find_kth_smallest(tree, k)` where: - `tree` is an instance of `RBTree`. - `k` is an integer representing the k-th smallest element to find. - You must implement the function to perform in O(log n) time complexity due to tree balancing nature. # Input: 1. Example 1: ```python rb_tree = RBTree() elements = [20, 15, 25, 10, 22, 30, 5] for element in elements: rb_tree.insert(RBNode(element, 1)) k = 3 ``` 2. Example 2: ```python rb_tree = RBTree() elements = [50, 40, 60, 35, 45, 55, 65] for element in elements: rb_tree.insert(RBNode(element, 1)) k = 5 ``` # Output: The function should return: 1. The k-th smallest element. # Constraints: 1. `k` is always a valid integer within the bounds of the number of elements in the tree. 2. The tree will not contain duplicate values. # Example: ```python # Example call rb_tree = RBTree() elements = [20, 15, 25, 10, 22, 30, 5] for element in elements: rb_tree.insert(RBNode(element, 1)) print(find_kth_smallest(rb_tree, 3)) # Output should be 15 ``` # Note: Ensure the implementation maintains the Red-Black Tree properties post any operations.","solution":"class RBNode: def __init__(self, data, count=1): self.data = data self.count = count # Subtree node count self.color = \'red\' # New nodes are red by default self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NIL_LEAF = RBNode(None, 0) # Sentinel NIL leaf self.NIL_LEAF.color = \'black\' self.root = self.NIL_LEAF # Insert function for Red-Black Tree with additional subtree count maintenance def insert(self, node): node.left = node.right = self.NIL_LEAF node.color = \'red\' self._insert_node(self.root, node) self._fix_insert(node) def _insert_node(self, root, node): if root == self.NIL_LEAF: if self.root == self.NIL_LEAF: # For the root node self.root = node node.color = \'black\' return if node.data < root.data: if root.left == self.NIL_LEAF: root.left = node node.parent = root else: self._insert_node(root.left, node) else: if root.right == self.NIL_LEAF: root.right = node node.parent = root else: self._insert_node(root.right, node) root.count += 1 # Increment count of nodes in subtree def _fix_insert(self, k): while k != self.root and k.parent.color == \'red\': if k.parent == k.parent.parent.left: u = k.parent.parent.right if u.color == \'red\': k.parent.color = \'black\' u.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.right: k = k.parent self._left_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self._right_rotate(k.parent.parent) else: u = k.parent.parent.left if u.color == \'red\': k.parent.color = \'black\' u.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.left: k = k.parent self._right_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self._left_rotate(k.parent.parent) self.root.color = \'black\' def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL_LEAF: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y y.count = x.count x.count = x.left.count + x.right.count + 1 def _right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL_LEAF: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y y.count = x.count x.count = x.left.count + x.right.count + 1 def find_kth_smallest(self, k): return self._find_kth_smallest(self.root, k) def _find_kth_smallest(self, node, k): if node == self.NIL_LEAF: return None left_count = node.left.count if k <= left_count: return self._find_kth_smallest(node.left, k) elif k > left_count + 1: return self._find_kth_smallest(node.right, k - left_count - 1) else: return node.data"},{"question":"Comb Sort is an efficient version of Bubble Sort. It sorts a list by comparing elements separated by a gap, and systematically reducing the gap to 1, at which point it effectively turns into Bubble Sort. Your task is to implement this sorting algorithm. # Task: Implement a function `comb_sort` that sorts a given list of integers in ascending order using the Comb Sort algorithm. # Function Signature: ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input: - A single list `arr` of integers where 1 <= len(arr) <= 10^5. # Output: - The function should return a list of integers sorted in ascending order. # Constraints and Requirements: - The function should complete in **reasonable time** for the largest input sizes. - Utilize the Comb Sort algorithm as described, which involves reducing gap sizes and swapping out-of-order elements. - Implement the function without using Python’s inbuilt sort function or any other higher-level sorting algorithms. # Example: ```python # Example 1 input: [8, 4, 1, 56, 3, -44, 23, -6, 28, 0] output: [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] # Example 2 input: [5, 3, 1, 2, 4] output: [1, 2, 3, 4, 5] ``` # Explanation: For example, the input list `[8, 4, 1, 56, 3, -44, 23, -6, 28, 0]` will be sorted to `[-44, -6, 0, 1, 3, 4, 8, 23, 28, 56]`. # Notes: - Implement the gap reduction and element swapping as per Comb Sort description. - Ensure your algorithm handles edge cases optimally and performs well within the constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: Advanced Topological Sorting Context You are a project manager overseeing a set of tasks that must be performed in a specific order due to their dependencies. Each task depends on the completion of other tasks before it can begin. Your goal is to develop a system that determines a valid order to complete all tasks. Problem Statement Given a directed acyclic graph (DAG) representing the task dependencies where vertices represent tasks and edges represent dependencies (`u → v` means task `u` must be completed before task `v`), write a function `find_topological_order` to determine one possible topological ordering of the tasks. Function Signature ```python def find_topological_order(tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: pass ``` Input - `tasks` (int): The number of tasks labeled from `0` to `tasks - 1`. - `dependencies` (List[Tuple[int, int]]): A list of directed edges `(u, v)`, representing that task `u` must be completed before task `v`. Output - Returns a list of task labels in a possible topological order such that for each directed edge `(u, v)`, task `u` precedes task `v`. Constraints 1. `1 <= tasks <= 10,000` 2. `0 <= len(dependencies) <= 100,000` 3. The given graph will be a DAG. # Example ```python tasks = 6 dependencies = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)] assert find_topological_order(tasks, dependencies) == [5, 4, 2, 3, 1, 0] # One possible solution ``` # Challenge Create an efficient solution with time complexity of `O(V + E)` and space complexity of `O(V)`, where no additional cyclic dependencies check is necessary except those implicit in the topological sorting algorithm.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_topological_order(tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: Finds one of the possible topological orderings of the tasks. # Initialize the graph and in-degree of each vertex graph = defaultdict(list) in_degree = [0] * tasks # Build the graph and compute in-degrees of nodes for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Initialize the queue with nodes of in-degree 0 queue = deque([i for i in range(tasks) if in_degree[i] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) # For each outgoing edge from the current node for neighbor in graph[node]: in_degree[neighbor] -= 1 # Decrease the in-degree of the neighbor if in_degree[neighbor] == 0: queue.append(neighbor) if len(topological_order) != tasks: raise ValueError(\\"Graph has at least one cycle\\") return topological_order"},{"question":"# Moving Average with Sliding Window Scenario & Context You are developing a real-time monitoring system for keeping track of incoming data points and providing an up-to-date average of the most recent values. This can be used in various applications like stock price analysis, environmental sensor readings, etc., where the latest trend is more important than the entire history. Problem Implement a class `MovingAverage` that calculates the moving average of the last `n` numbers. The class should support the following operations: - **Initialization**: Accepts a size parameter `n` which defines the window size. - **next(val)**: Processes the next data point and returns the moving average of the last `n` values. Requirements - **Function Signature**: ```python class MovingAverage: def __init__(self, size: int): # initialize def next(self, val: int) -> float: # process next value and return moving average ``` - **Input**: - An integer `size` for the window size at initialization. - A series of integers passed to the `next` method to calculate the moving average. - **Output**: - A float representing the moving average at each call to `next`. - **Constraints**: - 1 <= size <= 1000 - -10^5 <= val <= 10^5 - At least one next operation will be called. Performance Requirements - Each call to `next` should run in O(1) time. - The implementation should use O(n) space where n is the size of the sliding window. Example ```python obj = MovingAverage(3) print(obj.next(1)) # Output: 1.0 print(obj.next(10)) # Output: 5.5 (average of [1, 10]) print(obj.next(3)) # Output: 4.66667 (average of [1, 10, 3]) print(obj.next(5)) # Output: 6.0 (average of [10, 3, 5]) ``` Implement the `MovingAverage` class to meet the above requirements.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque() self.window_sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.window_sum -= self.queue.popleft() self.queue.append(val) self.window_sum += val return self.window_sum / len(self.queue)"},{"question":"**Question**: You are given a sequence of matrices, and your task is to determine the most efficient way to multiply these matrices together. The task involves finding the minimum number of scalar multiplications needed to compute the product of the sequence. The Matrix Chain Multiplication problem is a classic example of dynamic programming. In this problem, you will write two functions: 1. `matrix_chain_order(array)`: This function will compute the minimum number of scalar multiplications needed to multiply the given sequence of matrices. 2. `print_optimal_solution(optimal_solution, i, j)`: This function will print the optimal order of matrix multiplications. **Function Definitions**: ```python def matrix_chain_order(array): Finds the minimum number of scalar multiplications needed to multiply a given sequence of matrices. Arguments: array -- List of integers representing the matrix dimensions in sequence. Returns: tuple of two matrices (matrix, sol) - matrix: 2D list where matrix[i][j] gives minimum number of multiplications needed to compute the product of matrices Ai...Aj-1. - sol: 2D list to record the optimal split points. def print_optimal_solution(optimal_solution, i, j): Prints the optimal order to multiply the given sequence of matrices. Arguments: optimal_solution -- 2D list from `matrix_chain_order` recording the optimal split points. i -- Starting matrix index. j -- Ending matrix index. ``` **Requirements**: - Your function should avoid nesting the multiplication operations beyond necessary limits. - Constraints: 1 < len(array) < 100; 1 <= array[i] <= 1000 for all i in array. **Example**: ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"No. of operations required: \\" + str(matrix[1][len(array)-1])) print(\\"Optimal order:\\") print_optimal_solution(optimal_solution, 1, len(array)-1) ``` Output: ``` No. of operations required: 15125 Optimal order: ((A1 (A2 A3)) ((A4 A5) A6)) ```","solution":"def matrix_chain_order(array): Finds the minimum number of scalar multiplications needed to multiply a given sequence of matrices. Arguments: array -- List of integers representing the matrix dimensions in sequence. Returns: tuple of two matrices (matrix, sol) - matrix: 2D list where matrix[i][j] gives minimum number of multiplications needed to compute the product of matrices Ai...Aj-1. - sol: 2D list to record the optimal split points. n = len(array) matrix = [[0 for _ in range(n)] for _ in range(n)] sol = [[0 for _ in range(n)] for _ in range(n)] for chain_length in range(2, n): for i in range(1, n-chain_length+1): j = i + chain_length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = matrix[i][k] + matrix[k+1][j] + array[i-1]*array[k]*array[j] if q < matrix[i][j]: matrix[i][j] = q sol[i][j] = k return matrix, sol def print_optimal_solution(optimal_solution, i, j): Prints the optimal order to multiply the given sequence of matrices. Arguments: optimal_solution -- 2D list from `matrix_chain_order` recording the optimal split points. i -- Starting matrix index. j -- Ending matrix index. if i == j: print(\\"A\\" + str(i), end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(optimal_solution, i, optimal_solution[i][j]) print(\\" \\", end=\\"\\") print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"Context: Imagine you are building a search engine for a dictionary application. You need to support adding words and searching for words efficiently, with the ability for search queries to include \'.\' as a wildcard character that can represent any letter. Task: Implement the `WordDictionary` class with the following methods: 1. `add_word(word: str) -> None`: Adds the word to the data structure. 2. `search(word: str) -> bool`: Returns `True` if there\'s any string in the data structure that matches the given `word` or regular expression. The regular expression can contain \'.\' where each \'.\' can be any letter. Your implementation should be memory efficient and handle large datasets effectively. Input and Output Formats: * Your class should have the following structure: ```python class WordDictionary: def __init__(self): # Initialize your data structure pass def add_word(self, word: str) -> None: # Add a word to your data structure pass def search(self, word: str) -> bool: # Search for a word that matches the pattern pass ``` * `add_word(word: str)` accepts a single argument `word`, a non-empty string of lowercase letters. * `search(word: str)` accepts a single argument `word`, a string containing lowercase letters and/or \'.\', and returns a boolean value indicating if a matching word exists in the data structure. Constraints: * The length of `word` for `add_word` and `search` operations will not exceed 500 characters. * The total number of `add_word` operations will not exceed 10^5. * The total number of `search` operations will not exceed 10^4. Performance Requirements: * Your solution should be efficient in both time and space. Aim to maintain feasible performance even with upper constraint limits. Example: ```python wordDictionary = WordDictionary() # Add words wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") # Search operations print(wordDictionary.search(\\"pad\\")) # Return False print(wordDictionary.search(\\"bad\\")) # Return True print(wordDictionary.search(\\".ad\\")) # Return True print(wordDictionary.search(\\"b..\\")) # Return True ``` Notes: * Your implementation should handle edge cases such as empty strings and strings containing only wildcards. * Ensure efficient handling of wildcard searches using any optimizations or alternative methods you find suitable.","solution":"class WordDictionary: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for x in node: if x != \'#\' and search_in_node(word[i+1:], node[x]): return True return False elif char not in node: return False else: node = node[char] return \'#\' in node return search_in_node(word, self.trie)"},{"question":"# Ternary Search Function Implementation Background You are tasked with implementing the ternary search algorithm to efficiently find the index of a target value within a given sorted array. This algorithm divides the array into three parts and determines in which part the target value lies, effectively reducing the search space with every comparison. Objective Write a function `ternary_search` that searches for a given integer in a sorted array of integers and returns its index, if found. If the target value is not present in the array, the function should return -1. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int ``` Inputs * `left` (int): Left boundary of the current search space (initially 0). * `right` (int): Right boundary of the current search space (initially len(arr) - 1). * `key` (int): The target value to search for. * `arr` (List[int]): The sorted array of integers. Output * (int): The index of the target value if found; otherwise, -1. Constraints 1. 0 <= arr.length <= 10^4 2. -10^9 <= arr[i] <= 10^9 for each `arr[i]` Example ```python >>> ternary_search(0, 8, 25, [1, 3, 7, 9, 11, 15, 19, 25, 37]) 7 >>> ternary_search(0, 5, 13, [2, 4, 6, 8, 10, 12]) -1 ``` Notes * Ensure that your solution handles edge cases like empty arrays, single-element arrays, and the absence of the target value. * Avoid using built-in search functions; the focus is on implementing the ternary search logic.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on a sorted list to find the index of the target value. :param left: Left boundary of the search space. :param right: Right boundary of the search space. :param key: The target value to search for. :param arr: The sorted array of integers. :return: The index of the target value if found; otherwise, -1. while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Question: Implement a B-tree and Extend Its Methods You are required to implement and extend a B-tree data structure to store and manage sorted data efficiently, focusing on key operations, specifically insertion, deletion, and searching for keys. You will need to handle proper rebalancing with node splits and merges to maintain the B-tree’s properties. Functional Requirements: 1. **Initialization**: * Implement a `BTree` class constructor, accepting an integer `t` (degree), dictating the minimum and maximum number of keys per node. 2. **Insertion** (`insert_key` method): * Implement insertion ensuring the tree remains balanced. 3. **Search** (`find` method): * Implement search to check if a key exists in the B-tree. 4. **Deletion** (`remove_key` method): * Implement deletion maintaining B-tree properties. Additional Requirements: 1. **Traversal** (`traverse_tree` method): * Implement an in-order traversal of the tree, printing keys in ascending order. Input/Output * **Input**: - `insert_key(key: int)` - add a new key to the tree. - `find(key: int) -> bool` - return `True` if the key exists in the tree. - `remove_key(key: int)` - remove a key from the tree. - `traverse_tree()` - print the tree in in-order traversal. * **Output**: - `find(key)` - print \\"True\\" or \\"False\\" based on existence of key. - `traverse_tree()` - print space-separated keys in ascending order. Constraints: 1. `1 <= t <= 5` ensures manageable node degree sizes. 2. `-10^5 <= key <= 10^5` ensures key range within commonly used limits. Here is the class structure you need to implement: ```python class Node: def __init__(self): self.keys = [] self.children = [] @property def is_leaf(self): return len(self.children) == 0 class BTree: def __init__(self, t_val=2): pass def insert_key(self, key): pass def find(self, key) -> bool: pass def remove_key(self, key): pass def traverse_tree(self): pass ``` Use the provided structure and complete the methods so they fulfill the described requirements. Example Usage: ```python btree = BTree(3) # Insert keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Traversal (should print keys in order) btree.traverse_tree() # Output: 5 6 7 10 12 17 20 30 # Find keys print(btree.find(6)) # Output: True print(btree.find(15)) # Output: False # Remove keys btree.remove_key(6) btree.traverse_tree() # Output: 5 7 10 12 17 20 30 ``` Notes: * Ensure that the tree remains balanced after every insertion and deletion. * Properly handle edge cases like attempting to remove non-existent keys.","solution":"class Node: def __init__(self, t): self.keys = [] self.children = [] self.t = t @property def is_leaf(self): return len(self.children) == 0 class BTree: def __init__(self, t_val=2): self.root = Node(t_val) self.t = t_val def traverse_tree(self): self._traverse(self.root) print() def _traverse(self, node): for i in range(len(node.keys)): if not node.is_leaf: self._traverse(node.children[i]) print(node.keys[i], end=\\" \\") if not node.is_leaf: self._traverse(node.children[len(node.keys)]) def find(self, key) -> bool: return self._find(self.root, key) def _find(self, node, key) -> bool: i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.is_leaf: return False return self._find(node.children[i], key) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t - 1): temp = Node(self.t) self.root = temp temp.children.append(root) self._split_child(temp, 0) self._insert_non_full(temp, key) else: self._insert_non_full(root, key) def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.is_leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t - 1): self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def _split_child(self, parent, i): t = self.t node = parent.children[i] new_node = Node(t) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[t - 1]) new_node.keys = node.keys[t:(2 * t - 1)] node.keys = node.keys[0:(t - 1)] if not node.is_leaf: new_node.children = node.children[t:(2 * t)] node.children = node.children[0:t] def remove_key(self, key): self._remove(self.root, key) if len(self.root.keys) == 0: if not self.root.is_leaf: self.root = self.root.children[0] else: self.root = Node(self.t) def _remove(self, node, key): t = self.t if key in node.keys: index = node.keys.index(key) if node.is_leaf: node.keys.pop(index) else: if len(node.children[index].keys) >= t: pred = self._get_predecessor(node, index) node.keys[index] = pred self._remove(node.children[index], pred) elif len(node.children[index + 1].keys) >= t: succ = self._get_successor(node, index) node.keys[index] = succ self._remove(node.children[index + 1], succ) else: self._merge(node, index) self._remove(node.children[index], key) else: i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if node.is_leaf: return flag = (i == len(node.keys)) if len(node.children[i].keys) < t: if i > 0 and len(node.children[i - 1].keys) >= t: self._borrow_from_prev(node, i) elif i < len(node.children) - 1 and len(node.children[i + 1].keys) >= t: self._borrow_from_next(node, i) else: if i < len(node.children) - 1: self._merge(node, i) else: self._merge(node, i - 1) if flag and i > len(node.keys): self._remove(node.children[i - 1], key) else: self._remove(node.children[i], key) def _get_predecessor(self, node, index): current = node.children[index] while not current.is_leaf: current = current.children[len(current.keys)] return current.keys[-1] def _get_successor(self, node, index): current = node.children[index + 1] while not current.is_leaf: current = current.children[0] return current.keys[0] def _borrow_from_prev(self, parent, index): child = parent.children[index] sibling = parent.children[index - 1] child.keys.insert(0, parent.keys[index - 1]) if not sibling.is_leaf: child.children.insert(0, sibling.children.pop()) parent.keys[index - 1] = sibling.keys.pop() def _borrow_from_next(self, parent, index): child = parent.children[index] sibling = parent.children[index + 1] child.keys.append(parent.keys[index]) if not sibling.is_leaf: child.children.append(sibling.children.pop(0)) parent.keys[index] = sibling.keys.pop(0) def _merge(self, parent, index): child = parent.children[index] sibling = parent.children.pop(index + 1) child.keys.append(parent.keys.pop(index)) child.keys.extend(sibling.keys) if not sibling.is_leaf: child.children.extend(sibling.children)"},{"question":"# Problem: Minimum Cost Cable Network You are tasked with designing a cable network to connect a set of buildings in a campus. The goal is to minimize the total cost of the cables needed to connect all buildings. Each potential cable between two buildings has a specified cost. Using the list of all potential cables and their costs, compute the minimum cost required to connect all buildings. # Input You will be given a connected undirected graph in the form of a dictionary where: - Keys represent nodes (buildings). - Values are lists of pairs, where each pair represents an adjacent node and the cost to connect to that node. # Output Return the minimum cost to connect all the buildings. # Function Signature ```python def min_cost_cable_network(graph: Dict[int, List[List[int]]]) -> int: pass ``` # Constraints 1. The graph will be connected (i.e., there will be a path between any pair of nodes). 2. There will be no negative edge costs. 3. The number of nodes will be between 1 and 1000. 4. The number of edges will be between 1 and 10,000. 5. Each edge\'s cost will be a positive integer not exceeding 1,000. # Example ```python graph = { 1: [[3, 2], [8, 3]], 2: [[3, 1], [5, 4]], 3: [[8, 1], [2, 4], [4, 5]], 4: [[5, 2], [2, 3], [6, 5]], 5: [[4, 3], [6, 4]] } print(min_cost_cable_network(graph)) # Output: 14 ``` # Explanation In the given example, the minimum cost to connect all buildings is 14. The edges included in this MST are (1-2), (2-4), (4-3), and (3-5) with respective costs 3, 5, 2, and 4.","solution":"def min_cost_cable_network(graph): import heapq def prims_algorithm(graph): # Number of nodes in the graph n = len(graph) # Priority queue to store the edges based on cost pq = [] # Starting with node 1 (or any arbitrary node present in the graph) start_node = next(iter(graph)) visited = set() visited.add(start_node) # Add all edges of the starting node to the priority queue for cost, node in graph[start_node]: heapq.heappush(pq, (cost, start_node, node)) total_cost = 0 num_edges = 0 while pq and num_edges < n - 1: cost, u, v = heapq.heappop(pq) if v not in visited: visited.add(v) total_cost += cost num_edges += 1 for edge_cost, neighbor in graph[v]: if neighbor not in visited: heapq.heappush(pq, (edge_cost, v, neighbor)) return total_cost return prims_algorithm(graph)"},{"question":"**Scenario**: You have two datasets represented as lists and you need to process elements from these datasets in an alternating manner, ensuring that every element is considered exactly once. **Task**: Implement a class `ZigZagIterator` that iterates over two input lists alternately. If one list is exhausted, the iterator should continue with the remaining elements of the other list. **Function Signature**: ```python class ZigZagIterator: def __init__(self, v1, v2): Initializes the iterator with two lists. :param v1: List[int] - First list of integers. :param v2: List[int] - Second list of integers. def next(self) -> int: Returns the next integer in the zig-zag sequence. :return: int - The next integer. def has_next(self) -> bool: Checks if there are more elements to iterate over. :return: bool - True if there are more elements, else False. ``` # Input - Two lists of integers `v1` and `v2`. # Output - For `next()`: The next element in the zigzag order. - For `has_next()`: Boolean value indicating if there are more elements to be returned. # Constraints - The elements of both lists can be negative, zero, or positive integers. - The lists may be of different lengths, including lengths of zero. # Example ```python v1 = [1, 2] v2 = [3, 4, 5, 6] it = ZigZagIterator(v1, v2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be: [1, 3, 2, 4, 5, 6] ``` Consider handling edge cases where one or both input lists are empty.","solution":"class ZigZagIterator: def __init__(self, v1, v2): Initializes the iterator with two lists. :param v1: List[int] - First list of integers. :param v2: List[int] - Second list of integers. self.v1_index = 0 self.v2_index = 0 self.v1 = v1 self.v2 = v2 self.turn = 1 # 1 for v1\'s turn, 2 for v2\'s turn def next(self) -> int: Returns the next integer in the zig-zag sequence. :return: int - The next integer. if not self.has_next(): raise Exception(\\"No more elements\\") if self.turn == 1 and self.v1_index < len(self.v1): res = self.v1[self.v1_index] self.v1_index += 1 self.turn = 2 # Switch turn to v2 elif self.turn == 2 and self.v2_index < len(self.v2): res = self.v2[self.v2_index] self.v2_index += 1 self.turn = 1 # Switch turn to v1 elif self.v1_index < len(self.v1): res = self.v1[self.v1_index] self.v1_index += 1 else: res = self.v2[self.v2_index] self.v2_index += 1 return res def has_next(self) -> bool: Checks if there are more elements to iterate over. :return: bool - True if there are more elements, else False. return self.v1_index < len(self.v1) or self.v2_index < len(self.v2)"},{"question":"# Question Problem Statement: You are given an integer, positive or negative, not including floating-point numbers. You need to determine the number of digits in that integer. This must be achieved using a mathematical approach (hint: logarithmic functions) rather than converting the number to a string. Function Signature: ```python def num_digits(n: int) -> int: ``` Input: * An integer `n` where ( n in [-10^{18}, 10^{18}] ) Output: * An integer representing the number of digits in `n`. Example: ```python assert num_digits(12345) == 5 assert num_digits(-987654) == 6 assert num_digits(0) == 1 ``` Constraints: * You may not use string conversions to solve this problem. * Ensure the solution is efficient and runs in constant time O(1). Additional Notes: * Consider edge cases such as `n = 0` and negative numbers. * Remember to handle very large input values of `n` both positively and negatively.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the integer n. if n == 0: return 1 # Use absolute value for negative numbers and log10 return int(math.log10(abs(n))) + 1"},{"question":"# Missing Ranges One common problem in numerical sequences is finding the gaps within a specified range. Given a sorted list of integers and two boundary values `lo` and `hi`, your task is to find all missing ranges that fall between these two boundaries. Function Signature ```python def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` Input 1. `arr` (List[int]): A sorted list of integers. 2. `lo` (int): The lower boundary of the range. 3. `hi` (int): The upper boundary of the range. Output * Returns a list of tuples where each tuple represents a missing range as a pair of integers `(start, end)`. Example ```python missing_ranges([3, 5], 1, 10) ``` * Expected Output: `[(1, 2), (4, 4), (6, 10)]` Constraints * The elements in `arr` are unique and sorted in ascending order. * `lo` <= `hi`. * `arr` elements fall within the range `[lo, hi]` or should be considered part of the range. Performance Requirements * The function should have a time complexity of O(n) where \'n\' is the length of the input array `arr`. * Space complexity should be kept minimal (O(1) additional space, excluding the space required for the result). Edge Cases * If `arr` is empty, return a range from `lo` to `hi`. * If `lo` is greater than `hi`, return an empty list. * Consider scenarios where the input array is either fully within the bounds or partially within. Implement the function described above to generate the correct missing ranges.","solution":"from typing import List, Tuple def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: result = [] # Check if we need to add range from lo to first element of arr if not arr or lo < arr[0]: if not arr: result.append((lo, hi)) else: if lo < arr[0]: result.append((lo, arr[0] - 1)) # Check for missing ranges between elements in arr for i in range(1, len(arr)): if arr[i] - arr[i-1] > 1: result.append((arr[i-1] + 1, arr[i] - 1)) # Check if we need to add range from last element of arr to hi if arr and arr[-1] < hi: result.append((arr[-1] + 1, hi)) return result"},{"question":"# Binary Search Assessment Question Context You are working as a developer where fast data retrieval is crucial. Your task is to implement a function utilizing the concept of binary search to quickly find elements in a list. Task Implement a function called `find_closest_element` that not only finds the element in the sorted array but also, if the element is not present, returns the closest element to the target query. Your function should handle cases where the target is out of bounds of the array\'s values. # Function Signature ```python def find_closest_element(array: list[int], target: int) -> int: ``` # Input - `array`: A list of integers sorted in ascending order. - Constraints: `1 <= len(array) <= 10^5`, `-10^9 <= array[i] <= 10^9` - `target`: An integer value to search for within `array`. - Constraints: `-10^9 <= target <= 10^9` # Output - Returns the closest integer to the target within the array. If two numbers are equally close, return the smaller number. # Performance Requirements - Your implementation should aim for O(log n) complexity for the search operation. # Example ```python assert find_closest_element([1, 3, 8, 10, 15], 12) == 10 assert find_closest_element([1, 3, 8, 10, 15], 5) == 3 assert find_closest_element([1, 3, 8, 10, 15], 14) == 15 assert find_closest_element([1, 3, 8, 10, 15], 17) == 15 ``` Notes 1. Explain how your binary search logic adjusts to return the closest value if the exact target is not found. 2. Ensure that the nearest value is correctly handled even for targets outside the array\'s bounds.","solution":"def find_closest_element(array, target): Returns the closest element to the target in a sorted array. If two elements are equally close, the smaller element is returned. n = len(array) # Edge cases for when the target is out of the bounds of the array. if target <= array[0]: return array[0] if target >= array[-1]: return array[-1] # Binary search initialization left, right = 0, n - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return array[mid] elif array[mid] < target: left = mid + 1 else: right = mid - 1 # After the loop, left is the index of the smallest number larger than the target # and right is the index of the largest number smaller than the target. if (target - array[right]) <= (array[left] - target): return array[right] else: return array[left]"},{"question":"You are implementing a system to monitor a continuous stream of transactions, each represented as a tuple with a number and a sign (`+` or `-`). Your task is to determine if the stream is 1-sparse, meaning after cancelling out matching positive and negative values, only a single unique number remains. If the stream meets the criteria, return that number; otherwise, return `None`. # Function Signature ```python def one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: Determines if the stream of number-sign tuples is 1-sparse and returns the unique number if true. :param stream: List[Tuple[int, str]] representing the stream. :return: The unique number if 1-sparse, otherwise None. ``` # Input - `stream`: A list of tuples where each tuple contains a non-negative integer and a sign (`+` or `-`). # Output - Returns the unique number if the stream is 1-sparse. - Returns `None` if the stream is not 1-sparse. # Constraints - All integers in the stream are non-negative. - The number of tuples `n` in the stream is such that (1 leq n leq 10^6). # Example ```python # Example 1 stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] assert one_sparse(stream) == 4 # Example 2 stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] assert one_sparse(stream) == 2 # Example 3 stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] assert one_sparse(stream) == None ``` # Explanation - In the first example, after canceling out the values, the unique number 4 remains. - In the second example, the number 2 repeats, but all others cancel out, revealing the stream is 1-sparse with the unique number 2. - In the third example, varying sums lead to no unique number prevailing, so the output is `None`. Implement the function using the provided guidelines and considerations.","solution":"from typing import List, Tuple, Optional from collections import defaultdict def one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: Determines if the stream of number-sign tuples is 1-sparse and returns the unique number if true. :param stream: List[Tuple[int, str]] representing the stream. :return: The unique number if 1-sparse, otherwise None. balance = defaultdict(int) for number, sign in stream: if sign == \'+\': balance[number] += 1 elif sign == \'-\': balance[number] -= 1 unique_number = None for number, count in balance.items(): if count != 0: if unique_number is None: unique_number = number else: # More than one number has non-zero balance, so not 1-sparse return None return unique_number"},{"question":"# Scenario You are on a team developing a real-time monitoring system for an IoT smart home device. A critical component is to compute the moving average of sensor readings (such as temperature) over a specified rolling window size. # Task Implement the `ExponentialMovingAverage` class that computes the exponential moving average (EMA) for a sequence of integers given a smoothing factor α (alpha). The exponential moving average gives more weight to recent observations, which allows for more responsiveness to changes in the data compared to a simple moving average. # Class Definition ```python class ExponentialMovingAverage: def __init__(self, alpha): Initialize the ExponentialMovingAverage with a given smoothing factor alpha. :type alpha: float pass def next(self, val): Calculate the exponential moving average with the next value in the stream. :type val: int :rtype: float pass ``` # Input * `alpha`: (float) The smoothing factor, ( 0 < alpha leq 1 ). * `val`: (int) Streaming integer values. # Output * The method `next` should return a float representing the EMA considering the current value in the stream. # Constraints * `alpha` will be a float between 0 and 1. * The next values will be integers. * Assume the method `next` will be called multiple times with different values and should maintain the state of the EMA calculation. # Example ```python # Example usage: ema = ExponentialMovingAverage(0.5) assert ema.next(1) == 1.0 # EMA = 1 assert ema.next(10) == 5.5 # EMA = 0.5*10 + (1-0.5)*1 = 5.5 assert ema.next(3) == 4.25 # EMA = 0.5*3 + (1-0.5)*5.5 = 4.25 assert ema.next(5) == 4.625 # EMA = 0.5*5 + (1-0.5)*4.25 = 4.625 ``` # Notes * Ensure that your implementation properly initializes and updates the EMA state. * Consider the potential edge cases, like the initial calculation when no past data exists.","solution":"class ExponentialMovingAverage: def __init__(self, alpha): Initialize the ExponentialMovingAverage with a given smoothing factor alpha. :type alpha: float self.alpha = alpha self.ema = None def next(self, val): Calculate the exponential moving average with the next value in the stream. :type val: int :rtype: float if self.ema is None: self.ema = val else: self.ema = self.alpha * val + (1 - self.alpha) * self.ema return self.ema"},{"question":"# Matrix Inversion Challenge **Context**: Matrix inversion is a critical operation in linear algebra, involving multiple complex steps. You are tasked with developing a function that inverts an n x n matrix using the algorithm provided. **Objective**: Write a function `invert_matrix(m)` that inverts an n x n matrix. Your solution should handle input validations, edge cases, and adhere to efficiency practices. # Function Specification ```python def invert_matrix(m): Inverts an n x n matrix. Parameters: m (list[list[int/float]]): An n x n matrix of integers or floats. Returns: list[list[int/float]]: The inverted n x n matrix, or error indicators as per the edge cases. ``` # Input and Output - **Input**: - A square matrix `m` where each element is an integer or float. - **Output**: - The inverted matrix or specific error indicators in certain invalid scenarios: - `[[-1]]` if the input is not a matrix. - `[[-2]]` if the matrix is not square. - `[[-3]]` if the matrix is too small to be inverted. - `[[-4]]` if the matrix is square but singular (determinant is 0). # Constraints - The given matrix will have dimensions n x n where 2 ≤ n ≤ 10. - All elements of the matrix are valid numbers (integers or floats). # Example Usage ```python matrix = [ [4, 7], [2, 6] ] inverted_matrix = invert_matrix(matrix) # Expected Output: [ # [0.6, -0.7], # [-0.2, 0.4] # ] invalid_matrix = [ [1, 2, 3], [0, 1, 4] ] inverted_matrix = invert_matrix(invalid_matrix) # Expected Output: [[-2]] # since the matrix is not square ``` **Task**: Implement the `invert_matrix ` function defined as per the given specification, ensuring that it correctly handles all specified input and output cases.","solution":"import numpy as np def invert_matrix(m): Inverts an n x n matrix. Parameters: m (list[list[int/float]]): An n x n matrix of integers or floats. Returns: list[list[int/float]]: The inverted n x n matrix, or error indicators as per the edge cases. # Check if input is a list if not isinstance(m, list) or not all(isinstance(row, list) for row in m): return [[-1]] # Check if matrix is square num_rows = len(m) if not all(len(row) == num_rows for row in m): return [[-2]] # Check if matrix is too small to be inverted if num_rows < 2: return [[-3]] # Convert to numpy array for easier manipulation matrix_np = np.array(m, dtype=float) det = np.linalg.det(matrix_np) # Check if matrix is singular if det == 0: return [[-4]] # Calculate inverse inverted_matrix = np.linalg.inv(matrix_np) # Convert back to list inverted_matrix_list = inverted_matrix.tolist() return inverted_matrix_list"},{"question":"# Comb Sort Enhancement Assignment Scenario: You have been tasked with enhancing a basic implementation of the Comb Sort algorithm to handle large datasets more efficiently without sacrificing the simplicity of the algorithm. Your goal is to optimize the performance considering the gap shrink factor and implement additional features to account for typical and edge cases. Task: 1. Implement an enhanced version of the Comb Sort algorithm: - Optimize gap shrinking to minimize operations while ensuring efficient sorting. - Introduce condition to switch directly to Insertion Sort or Bubble Sort when the gap becomes small enough. 2. Ensure your function correctly handles arrays of various sizes, including empty arrays and arrays with only one element. 3. Validate the solution with a set of test cases, considering typical and edge cases. Function signature: ```python def enhanced_comb_sort(arr: list) -> list: # Your implementation here pass ``` Input and Output: - **Input**: A list of integers `arr` which can be of any length (0 <= len(arr) <= 10^6). - **Output**: A sorted list of integers, in ascending order. Constraints: - The implementation should aim for average complexity of (O(n log n)). - Ensure minimal additional space usage; adheres to in-place sorting principles. - Target datasets range from small to large sizes up to 1 million elements. Example: ```python assert enhanced_comb_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert enhanced_comb_sort([]) == [] assert enhanced_comb_sort([1]) == [1] assert enhanced_comb_sort([2, 1]) == [1, 2] assert enhanced_comb_sort([4, 3, 2, 1, 0]) == [0, 1, 2, 3, 4] ```","solution":"def enhanced_comb_sort(arr: list) -> list: Enhanced Comb Sort algorithm that optimizes gap shrinking and switches to insertion sort for small gaps. def insertion_sort(sub_arr, start): for i in range(start + 1, len(sub_arr)): key = sub_arr[i] j = i - 1 while j >= start and key < sub_arr[j]: sub_arr[j + 1] = sub_arr[j] j -= 1 sub_arr[j + 1] = key n = len(arr) if n <= 1: return arr gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True insertion_sort(arr, 0) else: sorted = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Question: Anagram List Checker **Context**: You are working on a text-processing software, and one of the features is to identify pairs of anagrams within a list of words. An anagram of a word is another word that contains the same characters, only the order of characters can be different. **Task**: Write a function `find_anagram_pairs(words)` that finds and returns all pairs of words in the list that are anagrams of each other. ```python def find_anagram_pairs(words): :type words: List[str] :rtype: List[Tuple[str, str]] pass ``` **Input**: - A list of strings `words` of length n, where 1 ≤ n ≤ 10^5. - Each string will contain only lowercase English letters and will have length ≤ 100. **Output**: - A list of tuples where each tuple contains two strings that are anagrams of each other. The order of pairs in the output list does not matter. **Constraints**: - The function should have an efficient time complexity and handle large inputs. - Ensure the function handles edge cases such as an empty list or single-element list correctly. **Examples**: ```python # Example 1 words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goolge\\", \\"googol\\"] Output: [(\'listen\', \'silent\'), (\'listen\', \'enlist\'), (\'silent\', \'enlist\'), (\'google\', \'goolge\')] # Example 2 words = [\\"abc\\", \\"def\\", \\"ghi\\"] Output: [] # Example 3 words = [\\"\\", \\"\\"] Output: [(\'\', \'\')] ``` **Notes**: - Ensure that duplicate pairs are not included; for example, (\'listen\', \'silent\') should be equivalent to (\'silent\', \'listen\') and should appear only once.","solution":"def find_anagram_pairs(words): Finds and returns all pairs of words in the list that are anagrams of each other. :type words: List[str] :rtype: List[Tuple[str, str]] from collections import defaultdict # Dictionary to store sorted word as key and list of original words as value anagram_dict = defaultdict(list) # Group words by their sorted tuple of characters for word in words: sorted_word = tuple(sorted(word)) anagram_dict[sorted_word].append(word) # Generate pairs from grouped anagrams anagram_pairs = [] for word_list in anagram_dict.values(): if len(word_list) > 1: # Create all pairwise combinations for i in range(len(word_list)): for j in range(i + 1, len(word_list)): anagram_pairs.append((word_list[i], word_list[j])) return anagram_pairs"},{"question":"# Context: You are tasked with implementing a word search feature for a crossword puzzle game. The objective is to determine which words from a given list can be found within the crossword puzzle. The puzzle is represented as a 2D grid of characters, and words can be constructed by moving sequentially in any direction (up, down, left, right). Characters cannot be reused within the same word. # Problem Statement: Write a function `find_words(board: List[List[str]], words: List[str]) -> List[str]` that takes a 2D list representing the board of characters and a list of words. The function should return the list of all words from the `words` list that can be formed in the board. # Input: * `board` - a list of lists of characters, where 1 ≤ len(board), len(board[0]) ≤ 12. * `words` - a list of strings, where each string\'s length is between 1 and 15. The total number of words will not exceed 1000. # Output: * Return a list of strings representing words from the list that can be found in the board. # Constraints: * Each character in the board can only be used once per word. * Words can be constructed in any direction (up, down, left, right, but not diagonally). # Requirements: * The solution must be efficient when dealing with larger boards and numerous words. * Optimize for time and memory usage. # Example: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] print(find_words(board, words)) # Output: [\\"oath\\", \\"eat\\"] ``` **Explanation**: * \\"oath\\" can be formed by the path [(0,0) -> (1,0) -> (2,0) -> (3,0)] * \\"eat\\" can be formed by the path [(1,1) -> (1,2) -> (1,3)] * \\"pea\\" and \\"rain\\" cannot be formed from any path in the board. # Additional Notes: * Consider edge cases such as an empty board, an empty list of words, or very small and very large inputs. Handle these gracefully. Good luck, and happy coding!","solution":"from typing import List def find_words(board: List[List[str]], words: List[str]) -> List[str]: def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = \'#\' found = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1) board[i][j] = temp return found def exist(board, word): for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False result = [] for word in words: if exist(board, word): result.append(word) return result"},{"question":"# Context You are given a 2D matrix where each row and each column is sorted in ascending order. Your task is to implement an efficient algorithm to search for a given key in this matrix. If the key exists, return its position in the matrix; otherwise, return an indication that the key is not found. # Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Tuple[bool, Tuple[int, int]]: pass ``` # Input 1. **matrix** (_List[List[int]]_): A 2D list representing the sorted matrix. Each element is an integer. 2. **key** (_int_): The target value to search for in the matrix. # Output - **Tuple[bool, Tuple[int, int]]**: The function returns a tuple, where the first element is a boolean indicating whether the key was found, and the second element is a tuple representing the position (row index, column index) of the key if found, or (-1, -1) if the key is not found. # Constraints - The number of rows and columns in the matrix are positive integers. - The matrix is non-empty (at least one element). - The elements in the matrix are unique. # Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_in_sorted_matrix(matrix, key) == (True, (1, 2)) key = 10 assert search_in_sorted_matrix(matrix, key) == (False, (-1, -1)) ``` # Description Implement the function `search_in_sorted_matrix` which takes a matrix and a key as arguments, and returns whether the key is present in the matrix. If present, return the position as zero-based indices; otherwise, return `(-1, -1)`.","solution":"def search_in_sorted_matrix(matrix, key): Search for a key in a 2D matrix where each row and each column is sorted in ascending order. Parameters: matrix (List[List[int]]): 2D list of integers. key (int): The target value to search for. Returns: Tuple[bool, Tuple[int, int]]: Tuple of boolean indicating if the key was found, and tuple of (row index, column index) if found, or (-1, -1) if not found. if not matrix or not matrix[0]: return False, (-1, -1) rows = len(matrix) cols = len(matrix[0]) # Start searching from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return True, (row, col) elif matrix[row][col] > key: col -= 1 # Move left else: row += 1 # Move down return False, (-1, -1)"},{"question":"# Matrix Transformations Problem Statement You are given a `n x m` matrix where `n` is the number of rows and `m` is the number of columns. You need to implement several transformations on this matrix. The transformations to be implemented include: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix by transposing it diagonally from the top-left to the bottom-right. 4. Invert the matrix by transposing it diagonally from the bottom-left to the top-right. Requirements Write four separate functions that perform these matrix transformations: 1. `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]` 2. `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]` 3. `top_left_invert(matrix: List[List[int]]) -> List[List[int]]` 4. `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]` Ensure the functions handle various edge cases such as: - Single element matrices. - Empty matrices. - Rectangular (non-square) matrices. Input * Each function will take a 2D list `matrix`, where `matrix[i][j]` is an integer. * The 2D list can have varying numbers of rows and columns. Output * Each function will return a new 2D list representing the transformed matrix. Constraints * The matrix will have at most 1000 rows and 1000 columns. * The elements in the matrix are all integers between `-10^6` and `10^6`. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Rotate 90 degrees clockwise print(rotate_clockwise(matrix)) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 3, 1] # ] # Rotate 90 degrees counterclockwise print(rotate_counterclockwise(matrix)) # Expected output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] # Transpose top-left to bottom-right print(top_left_invert(matrix)) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] # Transpose bottom-left to top-right print(bottom_left_invert(matrix)) # Expected output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ```","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) m = len(matrix[0]) if n > 0 else 0 return [[matrix[n-1-j][i] for j in range(n)] for i in range(m)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) m = len(matrix[0]) if n > 0 else 0 return [[matrix[j][m-1-i] for j in range(n)] for i in range(m)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: return [list(row) for row in zip(*matrix)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) m = len(matrix[0]) if n > 0 else 0 return [[matrix[n-1-r][m-1-c] for r in range(n)] for c in range(m)]"},{"question":"# Gnome Sort with Modifications Gnome Sort is a simple, yet inefficient sorting algorithm suitable mainly for educational purposes. Your task is to modify and enhance the gnome_sort function to handle both basic and advanced input characteristics. Requirements: 1. Modify the original gnome_sort function to print the internal state of the array after every swap operation. 2. Introduce functionality to handle the following edge cases gracefully: * An empty array should return an empty array. * Arrays with all identical elements should be left unchanged. * Improve performance for nearly sorted arrays by incorporating a more efficient checking mechanism. Input Format: * A list of integers, `arr`. Output Format: * Return the sorted list of integers. * Additionally, print the intermediate state of the list after every swap operation. Constraints: * Array length (0 leq n leq 10^5) * Array elements ( text{can be any } -10^6 text{ to } 10^6 text{ integers}) Example: ```python Input: [34, 2, 10, -9] During sorting: [-9, 34, 10, 2] [-9, 10, 34, 2] [-9, 10, 2, 34] Output: [-9, 2, 10, 34] ``` Note: Ensure that you handle edge cases and optimize the sort for nearly sorted arrays where possible.","solution":"def gnome_sort(arr): Sorts the array using the gnome sort algorithm and prints the internal state of the array after every swap operation. :param arr: a list of integers :return: sorted list of integers n = len(arr) if n <= 1: return arr index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] print(arr) # Print intermediate state index -= 1 return arr"},{"question":"# Question: Implement an Efficient Ordered Stack **Context**: You have designed an OrderedStack that always maintains its elements in descending order. Now, you need to optimize its operations further. **Task**: Implement a new version of an ordered stack with the following requirements for optimized performance: 1. `push(item)`: Insert an item maintaining all elements in descending order efficiently. 2. `pop()`: Remove and return the topmost item. 3. `peek()`: Return the topmost item without removing it. 4. `is_empty()`: Check if the stack is empty. 5. `size()`: Return the current size of the stack. # Expected Input and Output **input**: One or more command strings that invoke the above methods. ```python commands = [\\"push 5\\", \\"push 1\\", \\"peek\\", \\"pop\\", \\"size\\"] ``` **output**: Outputs corresponding to commands. ```python outputs = [None, None, 5, 5, 1] ``` # Constraints: - Each element is an integer within the range [−10^4, 10^4]. - Operation sequences will not call `pop` or `peek` on an empty stack. - The maximum number of operations will be 10^4. Implement the provided methods under the class name `EfficientOrderedStack`: ```python class EfficientOrderedStack: def __init__(self): self.items = [] # Additional attribute to optimize operations def is_empty(self): return self.items == [] def push(self, item): # Implement efficient push method here def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[-1] def size(self): return len(self.items) ``` Test this implementation with several sequences of operations ensuring efficient performance and correct ordering.","solution":"class EfficientOrderedStack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): # To maintain descending order, find the correct position to insert if self.is_empty(): self.items.append(item) else: # Use binary search to find the correct insertion point lo, hi = 0, len(self.items) while lo < hi: mid = (lo + hi) // 2 if self.items[mid] < item: hi = mid else: lo = mid + 1 self.items.insert(lo, item) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop(0) # maintain descending order by popping from the front def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[0] # peek the front element def size(self): return len(self.items)"},{"question":"You are tasked with creating a function that sorts a list of integers using the Cocktail Shaker Sort algorithm. Your function should handle edge cases effectively and work efficiently within the algorithm\'s constraints. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers `arr` (0 <= length of arr <= 10^4, -10^9 <= arr[i] <= 10^9) # Output - Return a list of integers sorted in ascending order. # Constraints - The function should perform sorting in-place (you can return the same array after sorting). - You should consider edge cases like an empty array or an array with one element. # Example ```python # Example 1 input_arr = [5, 3, 8, 4, 2] output_arr = cocktail_shaker_sort(input_arr) print(output_arr) # Output: [2, 3, 4, 5, 8] # Example 2 input_arr = [1, 2, 3, 4, 5] output_arr = cocktail_shaker_sort(input_arr) print(output_arr) # Output: [1, 2, 3, 4, 5] # Example 3 input_arr = [] output_arr = cocktail_shaker_sort(input_arr) print(output_arr) # Output: [] # Example 4 input_arr = [7] output_arr = cocktail_shaker_sort(input_arr) print(output_arr) # Output: [7] ``` # Explanation In Example 1, the array `[5, 3, 8, 4, 2]` is sorted into `[2, 3, 4, 5, 8]` using the cocktail shaker sort algorithm. Example 2 shows a presorted array which remains unchanged. Example 3 handles an empty array case. Example 4 demonstrates sorting an array with a single element. Note that you need to ensure the function can handle large arrays (up to 10^4 elements) without significant performance issues.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the list from left to right as in bubble sort for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Otherwise, reset the flag so that it can be used in the next stage swapped = False end -= 1 # Traverse the list from right to left (backwards) for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start += 1 return arr"},{"question":"Extended Operations on Red-Black Tree You are given the implementation of a Red-Black Tree and its core operations like insertion, deletion, and rotations. Your task is to extend its functionality by implementing a new method `find_kth_smallest`, which finds the k-th smallest element in the Red-Black Tree. # Function Signature ```python def find_kth_smallest(tree: RBTree, k: int) -> int: pass ``` # Input - `tree`: An instance of `RBTree` which holds the red-black tree structure. - `k`: An integer representing the k-th position (1-indexed) in terms of smallest elements. # Output - Returns an integer value denoting the k-th smallest value in the red-black tree. If `k` is out of bounds (i.e., larger than the number of elements in the tree), return `None`. # Constraints - The tree can have up to `10^5` nodes. - `1 ≤ k ≤ 10^5`. # Example ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: rb.insert(RBNode(child, 1)) print(find_kth_smallest(rb, 3)) # Output should be 4 print(find_kth_smallest(rb, 1)) # Output should be 1 print(find_kth_smallest(rb, 9)) # Output should be 15 print(find_kth_smallest(rb, 10)) # Output should be None (k is out of bounds) ``` # Analysis - The tree traversal to find the k-th smallest element should be implemented efficiently. - Consider in-order traversal as it visits nodes in ascending order but optimize to stop early when the k-th element is found. - Ensure that the solution respects the constraints in terms of time complexity.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color self.left = left or self self.right = right or self self.parent = parent # To track the size of the subtree rooted at each node self.size = 1 class RBTree: def __init__(self): self.NIL_LEAF = RBNode(key=None, color=0) # Dummy node for leaves self.root = self.NIL_LEAF def insert(self, key): node = RBNode(key, 1, self.NIL_LEAF, self.NIL_LEAF) if self.root == self.NIL_LEAF: self.root = node else: self._insert(node) self._fix_insert(node) def _insert(self, node): temp = self.root while True: temp.size += 1 # Increase size on all ancestors if node.key < temp.key: if temp.left == self.NIL_LEAF: temp.left = node break temp = temp.left else: if temp.right == self.NIL_LEAF: temp.right = node break temp = temp.right node.parent = temp def _fix_insert(self, node): # Fixing method for red-black tree insertion pass def find_kth_smallest(self, k): def _find_kth_smallest(node, k): if node == self.NIL_LEAF: return None left_size = node.left.size if node.left != self.NIL_LEAF else 0 if k == left_size + 1: return node.key elif k <= left_size: return _find_kth_smallest(node.left, k) else: return _find_kth_smallest(node.right, k - left_size - 1) if k <= 0 or k > self.root.size: return None return _find_kth_smallest(self.root, k)"},{"question":"**Question: Kosaraju’s Algorithm Implementation** You are given a directed graph with `V` vertices and a list of `E` directed edges. Write a function that implements Kosaraju\'s Algorithm to find the number of Strongly Connected Components (SCCs) in the graph. # Function Signature ```python def find_sccs(V: int, edges: List[Tuple[int, int]]) -> int: ``` # Input: * `V` (int): Number of vertices in the graph. * `edges` (List[Tuple[int, int]]): List of tuples where each tuple (u, v) represents a directed edge from vertex `u` to vertex `v`. # Output: * Return the number of strongly connected components in the graph. # Constraints: * 1 ≤ V ≤ 10^5 * 1 ≤ E ≤ 10^6 * 0 ≤ u, v < V # Examples: ```python assert find_sccs(6, [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)]) == 2 assert find_sccs(5, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)]) == 3 assert find_sccs(3, [(0, 1), (1, 2), (2, 0)]) == 1 ``` # Explanation: In the first example, there are two SCCs: * SCC 1: [0, 1, 2, 3] * SCC 2: [4, 5] In the second example, there are three SCCs: * SCC 1: [0, 1, 2] * SCC 2: [3] * SCC 3: [4] Your task is to write the `find_sccs` function to compute the number of strongly connected components in the given directed graph.","solution":"from typing import List, Tuple, Dict def find_sccs(V: int, edges: List[Tuple[int, int]]) -> int: def dfs(v: int, graph: Dict[int, List[int]], visited: set, stack: List[int] = None): visited.add(v) for next_v in graph[v]: if next_v not in visited: dfs(next_v, graph, visited, stack) if stack is not None: stack.append(v) def reverse_graph(V: int, edges: List[Tuple[int, int]]) -> Dict[int, List[int]]: rev_graph = {i: [] for i in range(V)} for (u, v) in edges: rev_graph[v].append(u) return rev_graph graph = {i: [] for i in range(V)} for (u, v) in edges: graph[u].append(v) visited = set() stack = [] for i in range(V): if i not in visited: dfs(i, graph, visited, stack) rev_graph = reverse_graph(V, edges) visited.clear() scc_count = 0 while stack: node = stack.pop() if node not in visited: dfs(node, rev_graph, visited) scc_count += 1 return scc_count"},{"question":"Task Write a function `calculate_mode` which identifies the mode(s) of a list of integers. The mode is the number that appears most frequently in a data set. If there are multiple modes, return all of them in a list. # Function Signature ```python def calculate_mode(numbers: list) -> list: ``` # Input - `numbers` (list of int): A list of integers `0 <= len(numbers) <= 10^5` # Output - Returns a list of integers which are the mode(s) of the input list. The returned modes should be in ascending order. # Performance Requirements - Your solution should work efficiently for a list of length up to 100,000. # Constraints & Considerations - If the input list is empty, return an empty list. - If multiple numbers have the same frequency (and are the highest frequency), return all these numbers in ascending order. - You must utilize the histogram function predefined in the prompt code. # Example 1. `calculate_mode([1, 2, 3, 3, 4, 4])` returns `[3, 4]`: - Both 3 and 4 appear twice. 2. `calculate_mode([1, 1, 2, 2, 3, 3, 4])` returns `[1, 2, 3]`: - 1, 2, and 3 appear twice each. 3. `calculate_mode([6, 8, 8, 10, 10, 10, 3, 3])` returns `[10]`: - 10 appears three times, more than any other number. # Remarks Make sure to analyze the given histogram function as a part of the solution and utilize it effectively to create the mode calculation function.","solution":"from collections import Counter def calculate_mode(numbers): if not numbers: return [] number_counts = Counter(numbers) max_count = max(number_counts.values()) modes = [number for number, count in number_counts.items() if count == max_count] return sorted(modes)"},{"question":"You are given an integer array `nums` and an integer `target`. Write a function `n_sum` to find all unique n-tuplets (four elements in this case) in the array which sum to the given `target`. The function should be flexible enough to allow different definitions of sum and comparisons using closure functions and should be efficient enough to handle moderately large input sizes. # Function Signature ```python def n_sum(n: int, nums: list, target: int, **kv) -> list: ``` # Input - `n` (int): Number of elements in each tuple. - `nums` (list[object]): List of elements. - `target` (int): Target sum value. - Optional closure functions: - `sum_closure`: A function that takes two elements of `nums` and returns their summed result. - `compare_closure`: A function that takes an element from `nums` and `target`, and returns -1 if element < target, 1 if element > target, else 0. - `same_closure`: A function that takes two elements from `nums` and returns `True` if they are considered the same, else `False`. # Output - `list[list[object]]`: A list of lists, where each sublist contains `n` elements that sum up to `target`. Each sublist should be unique. # Constraints - Each input list should accommodate up to 10^3 elements. - Elements in input list `nums` can contain negative or positive integers. - You can assume that there won\'t be integer overflow. - The solution should handle duplicates properly without redundant tuples. # Example ```python Given: n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 return [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] Given: n = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 def sum(a, b): return [a[0] + b[1], a[1] + b[0]] def compare(num, target): return -1 if num[0] < target else(1 if num[0] > target else 0) return [[-9, 5], [8, 4]] (since -9 + 4 = -5) ``` Write the implementation of the `n_sum` function following the provided function signature and requirements.","solution":"from itertools import combinations def n_sum(n: int, nums: list, target: int, sum_closure=None, compare_closure=None, same_closure=None) -> list: Finds all unique n-tuples in `nums` that sum to `target` using the given closure functions. if sum_closure is None: sum_closure = lambda x, y: x + y if compare_closure is None: compare_closure = lambda x, y: -1 if x < y else (1 if x > y else 0) if same_closure is None: same_closure = lambda x, y: x == y def find_n_sum(nums, target, N, result, results): Recursive function to find N sums. if len(nums) < N or N < 2: return if N == 2: left, right = 0, len(nums) - 1 while left < right: current_sum = sum_closure(nums[left], nums[right]) comparison = compare_closure(current_sum, target) if comparison == 0: results.append(result + [nums[left], nums[right]]) left += 1 right -= 1 while left < right and same_closure(nums[left], nums[left - 1]): left += 1 while left < right and same_closure(nums[right], nums[right + 1]): right -= 1 elif comparison < 0: left += 1 else: right -= 1 else: for i in range(len(nums) - N + 1): if i == 0 or not same_closure(nums[i], nums[i - 1]): find_n_sum(nums[i + 1:], target - nums[i], N - 1, result + [nums[i]], results) nums.sort() results = [] find_n_sum(nums, target, n, [], results) return results"},{"question":"# Problem Context You are working on a task scheduling system where multiple tasks are linked, representing dependencies between them. Each task must be executed only after all its dependent tasks have been completed. You need to develop an algorithm that will generate a valid sequence of task execution. # Task Write a function called `task_scheduler` that takes a dictionary representing the graph of tasks with their dependencies and returns a list representing a valid topological ordering of the tasks. If the tasks cannot be ordered due to a cyclic dependency, the function should raise a `ValueError`. # Detailed Guidelines 1. Implement a function `task_scheduler(graph: Dict[str, List[str]]) -> List[str]`. 2. The input `graph` is a dictionary where keys are task identifiers (strings), and values are lists of task identifiers, representing dependencies. 3. The function should return a list of task identifiers in a valid topological order. 4. If the graph has a cycle, raise a `ValueError` with the message \\"cycle\\". 5. Your implementation should handle both small and large graphs efficiently. # Input/Output Format - **Input**: - A dictionary `graph` of type `Dict[str, List[str]]` where the keys are task identifiers and the values are lists of dependencies (also task identifiers). - Example: `{\'A\': [\'B\', \'C\'], \'B\': [\'C\'], \'C\': []}` - **Output**: - A list of strings representing the tasks in a valid topological order. - Example for above input: `[\'C\', \'B\', \'A\']` # Constraints - The number of tasks (vertices) `V` and number of dependencies (edges) `E` such that (1 leq V, E leq 10^5). - Task identifiers are unique, non-empty strings. # Example Example 1 ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\'], \'C\': [] } assert task_scheduler(graph) == [\'C\', \'B\', \'A\'] ``` Example 2 ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } try: task_scheduler(graph) # This should raise a ValueError except ValueError as e: assert str(e) == \\"cycle\\" ```","solution":"from collections import defaultdict, deque from typing import Dict, List def task_scheduler(graph: Dict[str, List[str]]) -> List[str]: Returns a valid topological ordering of tasks given their dependencies. If the graph has a cycle, raises a ValueError. # Create an in-degree dictionary and adjacency list in_degree = defaultdict(int) adj_list = defaultdict(list) # Initialize the graph data for task, dependencies in graph.items(): for dep in dependencies: adj_list[dep].append(task) in_degree[task] += 1 if task not in in_degree: in_degree[task] = 0 # Find all nodes with in-degree 0 queue = deque([task for task in in_degree if in_degree[task] == 0]) topological_order = [] while queue: current_task = queue.popleft() topological_order.append(current_task) # Decrement the in-degree of each neighbor for neighbor in adj_list[current_task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If topological_order includes all tasks, return the order if len(topological_order) == len(in_degree): return topological_order else: raise ValueError(\\"cycle\\")"},{"question":"# Skyline Problem: Implementing Efficient Skyline Outline Finder A city\'s skyline is defined by the outer contour of a silhouette formed by buildings when viewed side-on from a distance. Each building is represented as a triplet [Li, Ri, Hi], where: - Li and Ri are the x-coordinates of the left and right edges of the i-th building, respectively, - Hi is its height. Given a list of N buildings in the format `[[Li, Ri, Hi], ...]`, your task is to compute their collective skyline\'s key points. These key points are the critical points where there\'s a change in height across the skyline, including the point at the end of the last building where the height returns to zero. # Requirements: - Implement a function `get_skyline(buildings: List[List[int]]) -> List[List[int]]` to achieve this. - Buildings are represented as perfect rectangles grounded at a height of 0. - The input list is sorted by Li. - The number of buildings in the input list ranges from 0 to 10000. - Ensure the output list is sorted by x-position and there are no consecutive identical height points in the result. - **Expected Time Complexity**: O(N log N) - **Expected Space Complexity**: O(N) # Function Signature: ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` # Example: **Input**: ```python [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] ``` **Output**: ```python [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` # Explanation: - The buildings form the skyline as [2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]. - These points indicate where there are changes in the height of the skyline, providing its outer contour when viewed from a distance. Please ensure your function passes all edge cases such as overlapping buildings, multiple buildings starting at the same x-coordinate, and buildings ending exactly where another begins.","solution":"from heapq import heappush, heappop from typing import List def get_skyline(buildings: List[List[int]]) -> List[List[int]]: Compute the skyline formed by the given list of buildings. # Process the buildings to create events events = [] for l, r, h in buildings: events.append((l, -h, r)) # Start of building (negative height for max-heap) events.append((r, 0, 0)) # End of building # Sort events by x, then by height events.sort() # Initialize the result list and a max-heap result = [] max_heap = [(0, float(\'inf\'))] # (height, end position) # Traverse all events for x, h, r in events: while max_heap[0][1] <= x: heappop(max_heap) if h != 0: heappush(max_heap, (h, r)) max_height = -max_heap[0][0] if not result or result[-1][1] != max_height: result.append([x, max_height]) return result"},{"question":"Your task is to implement a function that determines if a binary tree is balanced. A binary tree is considered balanced if, for any node in the tree, the height difference between the left and right subtrees is no more than one. Function Signature ```python def is_balanced(root): pass ``` Input - `root`: The root node of a binary tree. Each node contains `val`, `left`, and `right`. Output - Return `True` if the tree is balanced, otherwise return `False`. Constraints - You must implement the function using a recursive approach with the post-order traversal method. - You are not allowed to use any external libraries. - Aim for time complexity of O(N) and space complexity of O(H) where N is the number of nodes and H is the height of the tree. Example Consider the following binary tree: ```plaintext 1 / 2 3 / 4 5 ``` - For the root node (1), the height of the left subtree (2 -> 4, 5) is 2, and the height of the right subtree (3) is 1. The difference is 1 which is permissible. - For node 2, the left and right subtrees (4, 5) both have height 1. The difference is 0 which is permissible. Thus, the function should return `True`. Test Cases 1. An empty tree should return `True`. 2. A tree with only one node should return `True`. 3. A highly unbalanced tree such as one where all nodes are aligned in a single path (either left or right) should return `False` if the height difference exceeds 1 at any node. # Note Ensure to handle all edge cases where the tree might be skewed or have multiple levels of depth differences exceeding the required condition.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. A binary tree is balanced if the height difference between the left and right subtrees is no more than one for any node in the tree. Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. def check_height(node): if not node: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"# Bucket Sort Implementation with Optimized Subsorting You are given an array of non-negative integers. Your task is to implement the Bucket Sort algorithm which sorts it in ascending order. For this implementation, replace the simple insertion sort used in the example with a more efficient sorting algorithm for each bucket. Task Write a function `bucket_sort(arr: List[int]) -> List[int]` which sorts the input list using the Bucket Sort algorithm with an efficient sorting approach within each bucket to handle potential performance degradation. Input/Output - **Input**: A list of non-negative integers `arr` where `0 ≤ arr[i] ≤ 10^6` and `0 ≤ len(arr) ≤ 10^5`. - **Output**: A list of non-negative integers, sorted in ascending order. Constraints - You must use the Bucket Sort algorithm as the primary sorting mechanism. - Use a more efficient sorting algorithm within each bucket instead of insertion sort. Example Input: ```python arr = [10, 3, 8, 4, 2, 9, 12, 5, 2, 11] ``` Output: ```python [2, 2, 3, 4, 5, 8, 9, 10, 11, 12] ``` Notes - Consider edge cases such as when `arr` is empty or contains all same elements. - Ensure your algorithm handles large ranges in the input list efficiently. - Your implementation should consider the preprocessing stages (e.g., distributing elements into buckets, sorting buckets, and merging them) effectively to ensure a time-efficient solution.","solution":"from typing import List import itertools def bucket_sort(arr: List[int]) -> List[int]: Sorts a list of non-negative integers using the Bucket Sort algorithm with each bucket being sorted using an efficient sorting method (quick sort). if not arr: return arr # Decide the number of buckets num_buckets = len(arr) max_val = max(arr) # Create buckets and distribute the elements buckets = [[] for _ in range(num_buckets)] for num in arr: index = (num * num_buckets) // (max_val + 1) buckets[index].append(num) # Sort each bucket using Python\'s built-in Timsort (equivalent to quicksort for practical purposes) for bucket in buckets: bucket.sort() # Concatenate buckets into the final sorted array sorted_arr = list(itertools.chain(*buckets)) return sorted_arr"},{"question":"# Maximum Flow Challenge: Implement the Edmonds-Karp Algorithm Introduction You\'re given the task of finding the maximum flow in a directed, weighted graph. The graph is represented as an n x n adjacency matrix, where the value at `graph[i][j]` represents the capacity of the edge from vertex `i` to vertex `j`. Assume that the first vertex (index 0) is the source and the last vertex (index n-1) is the sink. Your objective is to implement the Edmonds-Karp algorithm, which is an optimized version of the Ford-Fulkerson method, using Breadth-First Search (BFS) to find augmenting paths. By utilizing BFS, you will ensure that the shortest augmenting path in terms of the number of edges is always found, which can lead to better performance compared to the DFS implementation. Core Requirements - Implement a function `maximum_flow_bfs(graph: List[List[int]]) -> int` to calculate the maximum flow. - The function should take an n x n adjacency matrix `graph` as input. - It should return an integer representing the maximum flow from the source (vertex 0) to the sink (vertex n-1). Input Format - `graph`: A list of lists, which is an n x n adjacency matrix of integers, where `graph[i][j]` is the capacity of the edge from vertex `i` to vertex `j`. Output Format - An integer representing the maximum flow from the source to the sink. Constraints 1. Graph will have a maximum of 100 vertices (`1 <= n <= 100`). 2. Edge capacities are non-negative integers. Example ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] print(maximum_flow_bfs(graph)) # Output should be: 23 ``` Function Signature ```python from typing import List def maximum_flow_bfs(graph: List[List[int]]) -> int: # Your code here pass ``` Notes - Focus on implementing the BFS part to find augmenting paths and updating the residual capacity graph. - Ensure that your implementation handles edge cases effectively, such as no initial path from source to sink. - Consider the performance implications on larger graphs with varying capacities. Optimize where possible.","solution":"from typing import List from collections import deque def bfs(graph: List[List[int]], s: int, t: int, parent: List[int]) -> bool: visited = [False] * len(graph) queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for ind, val in enumerate(graph[u]): if not visited[ind] and val > 0: # checking for available capacity queue.append(ind) visited[ind] = True parent[ind] = u if ind == t: return True return False def maximum_flow_bfs(graph: List[List[int]]) -> int: source = 0 sink = len(graph) - 1 parent = [-1] * len(graph) max_flow = 0 while bfs(graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"Coding Assessment Question: Combination Sum with Constraints # Scenario You are working on a financial planning tool that offers various demographic groups to select from multiple investment options. Each option has a fixed investment amount, and users can endlessly combine these options to achieve their desired investment target. You are given a list of such investment options (without duplicates) and a target investment amount. Your task is to write a program that identifies all unique combinations of investment options that sum up to the target value. # Task Implement a function `combination_sum(candidates, target)` as follows: * **Input**: - `candidates`: A list of positive integers representing different investment options. - `target`: A positive integer representing the investment target that users need to achieve. * **Output**: - Return a list of lists, where each inner list represents a unique combination of the investment options that sum up to the `target`. # Constraints - All investment options (including the target) are positive integers. - You can use the same investment option unlimited times. - The solution set must not contain duplicate combinations. # Examples ```python combination_sum([2, 3, 6, 7], 7) ``` Expected Output: ```python [ [7], [2, 2, 3] ] ``` ```python combination_sum([2, 5, 3], 8) ``` Expected Output: ```python [ [3, 5], [2, 3, 3], [2, 2, 2, 2] ] ``` # Performance Requirements - Time Complexity: Should be efficient such that it avoids unnecessary calculations and recursion depth issues where possible. - Space Complexity: Manageable and should ensure no excessive memory usage during execution. Write a program that fulfills these criteria and efficiently finds all unique combinations of candidates meeting the target sum.","solution":"def combination_sum(candidates, target): def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(candidates)): current_combination.append(candidates[i]) backtrack(i, current_combination, current_sum + candidates[i]) current_combination.pop() result = [] candidates.sort() backtrack(0, [], 0) return result"},{"question":"# K-th to Last Element in a Linked List You are given a singly linked list and an integer k. Your task is to write a function that returns the k-th to last element of the list. If the k-th element does not exist, your function should raise an exception. You are required to use the optimal approach using pointers for this task. Function Signature ```python def kth_to_last(head: Node, k: int) -> Node: ``` Input: - `head` - The head node of a singly linked list of Node type. - `k` - An integer, representing which k-th last element to find (1-indexed). Output: - The function returns the k-th to last node in the singly linked list. Constraints: - The list can have up to 10^5 elements. - 0 < k <= length of list Examples: ```python # The linked list looks like: A -> B -> C -> D -> E -> F -> G head = Node(\\"A\\") head.next = Node(\\"B\\") head.next.next = Node(\\"C\\") head.next.next.next = Node(\\"D\\") head.next.next.next.next = Node(\\"E\\") head.next.next.next.next.next = Node(\\"F\\") head.next.next.next.next.next.next = Node(\\"G\\") # Example call assert kth_to_last(head, 3).val == \\"E\\" # returns the node with value \\"E\\" assert kth_to_last(head, 1).val == \\"G\\" # returns the node with value \\"G\\" ``` Notes: - Raise an IndexError if `k` is larger than the number of elements in the list.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: Returns the k-th to last node in a singly linked list. Parameters: head (Node): The head of the singly linked list. k (int): The position (1-indexed) from the end. Returns: Node: The k-th to last node. Raises: IndexError: If the k-th position does not exist. if k <= 0: raise IndexError(\\"k must be greater than 0\\") first = head second = head # Move first k-steps ahead for _ in range(k): if not first: raise IndexError(\\"k is larger than the length of the list\\") first = first.next while first: first = first.next second = second.next return second"},{"question":"You are required to implement a `BinaryHeap` class supporting min-heap operations. The `BinaryHeap` should be able to handle integer elements. The provided class signature includes necessary methods that you need to complete. # Objectives: 1. Implement the `perc_up` method to maintain the heap property by moving an element up in the tree until the min-heap property is restored. 2. Implement the `insert` method to add a new element while maintaining the heap property. 3. Implement the `perc_down` method to maintain the heap property by moving an element down in the tree until the min-heap property is restored. 4. Implement the `min_child` method to find the smaller of two children. 5. Implement the `remove_min` method to remove the smallest element from the heap. # Input and Output: 1. **Insert Method**: `insert(val)` - **Input**: An integer `val` to be inserted into the heap. - **Output**: None. 2. **Remove Min Method**: `remove_min()` - **Input**: None. - **Output**: Integer, the smallest element in the heap. 3. **perc_up method**: `perc_up(i)` - **Input**: Index `i` of the newly inserted element. - **Output**: None. 4. **perc_down method**: `perc_down(i)` - **Input**: Index `i` of the element to be percolated down. - **Output**: None. 5. **min_child method**: `min_child(i)` - **Input**: Index `i` of the parent node. - **Output**: Index of the smaller child. # Scenario: You have a project management tool where tasks are prioritized by their urgency. You need to manage the tasks using a Binary Heap so that the lowest priority (most urgent) task can be accessed quickly. # Example: ```python heap = BinaryHeap() heap.insert(10) heap.insert(5) heap.insert(30) heap.insert(2) print(heap.remove_min()) # Output: 2 print(heap.remove_min()) # Output: 5 ``` # Constraints: 1. The heap should handle up to 100,000 elements efficiently. 2. Values stored in the heap will be integers between `-10^9` and `10^9`. # Additional Requirement: Ensure your implementation can handle edge cases such as attempting to remove an element from an empty heap.","solution":"class BinaryHeap: def __init__(self): self.heapList = [0] # Initialize with a dummy element at index 0 for easier index calculation self.currentSize = 0 def perc_up(self, i): while i // 2 > 0: if self.heapList[i] < self.heapList[i // 2]: self.heapList[i], self.heapList[i // 2] = self.heapList[i // 2], self.heapList[i] i = i // 2 def insert(self, val): self.heapList.append(val) self.currentSize += 1 self.perc_up(self.currentSize) def perc_down(self, i): while (i * 2) <= self.currentSize: min_child = self.min_child(i) if self.heapList[i] > self.heapList[min_child]: self.heapList[i], self.heapList[min_child] = self.heapList[min_child], self.heapList[i] i = min_child def min_child(self, i): if i * 2 + 1 > self.currentSize: return i * 2 else: if self.heapList[i * 2] < self.heapList[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def remove_min(self): if self.currentSize == 0: raise IndexError(\\"remove_min() called on empty heap\\") min_val = self.heapList[1] self.heapList[1] = self.heapList[self.currentSize] self.currentSize -= 1 self.heapList.pop() self.perc_down(1) return min_val"},{"question":"# Coding Challenge: Stack Management **Objective:** Implement a function `remove_min` that accepts a stack as input and removes the smallest value from the stack while preserving the order of the remaining elements. **Input and Output Formats:** - The function must accept a list `stack` representing the stack, where the last element of the list is the top of the stack. - Return the modified stack with the smallest element removed. **Constraints:** - The input stack may contain integer values, both positive and negative. - Handle edge cases such as: * Empty stack. * Multiple occurrences of the minimum element. * Stack with all same-value elements. - Time complexity should be O(n) and space complexity should not exceed O(n) for auxiliary structures. **Performance Requirements:** Ensure that the solution does not involve any excessive memory usage or redundant operations. **Function Signature:** ```python def remove_min(stack: list) -> list: # your implementation here pass ``` **Example:** ```python # Example 1: stack = [2, 8, 3, -6, 7, 3] result = remove_min(stack) print(result) # Output: [2, 8, 3, 7, 3] # Example 2: stack = [] result = remove_min(stack) print(result) # Output: [] # Example 3: stack = [10, 10, 10] result = remove_min(stack) print(result) # Output: [10, 10] ``` **Scenario:** You are tasked with building a software module that processes data maintained in stack structures. The requirements mandate that some operations remove specific elements while maintaining the element order. This necessitates effectively managing stack operations, as outlined in the function `remove_min`.","solution":"def remove_min(stack: list) -> list: Removes the smallest value from the stack while preserving the order of the remaining elements. :param stack: List representing the stack, where the last element is the top of the stack. :return: Modified stack with the smallest element removed. if not stack: return [] # Find the smallest element in the stack min_value = min(stack) # Create a new stack without the first occurrence of the smallest element new_stack = [] min_removed = False for value in stack: if value == min_value and not min_removed: min_removed = True else: new_stack.append(value) return new_stack"},{"question":"# Question: Fast Fourier Transform Implementation Scenario You are working as a signal processing engineer, and you frequently deal with transforming signals to the frequency domain. One of the most common tasks is to compute the discrete Fourier transform (DFT) of a signal efficiently. You decide to implement the Cooley-Tukey FFT algorithm, which is known for its efficiency with input lengths that are powers of 2. Task Implement the Cooley-Tukey FFT algorithm in Python. Your function should recursively divide the input array into smaller parts, compute their FFTs, and then combine these results to get the final transformed array. Function Signature ```python def fft(x: list) -> list: Perform the Fast Fourier Transform on a list of complex numbers. :param x: List of complex numbers (Length N, where N is a power of 2) :return: List of complex numbers representing the DFT of the input ``` Input - A list of complex numbers `x` of length (N) where (N) is a power of 2. Output - A list of complex numbers representing the discrete Fourier transform of the input array. Example ```python input_data = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output = fft(input_data) print(output) # Example output: [8+8j, 2j, 2-2j, -2+0j] ``` Constraints - Do not use any libraries for performing the FFT (such as `numpy` or `scipy`). You need to implement the algorithm from scratch. - It is guaranteed that the length of the input list will be a power of 2. Performance - The solution should run within time complexity O(N log N) and space complexity O(N). Note Consider using complex arithmetic provided by Python\'s `cmath` module for operations involving complex numbers, specifically for computing the twiddle factors.","solution":"import cmath def fft(x: list) -> list: Perform the Fast Fourier Transform on a list of complex numbers. :param x: List of complex numbers (Length N, where N is a power of 2) :return: List of complex numbers representing the DFT of the input N = len(x) # Base case if N <= 1: return x # Recursive case for even and odd indexed elements even_terms = fft(x[0::2]) odd_terms = fft(x[1::2]) # Combine the results combined = [0] * N for k in range(N//2): t_exp = cmath.exp(-2j * cmath.pi * k / N) * odd_terms[k] combined[k] = even_terms[k] + t_exp combined[k + N//2] = even_terms[k] - t_exp return combined"},{"question":"# Password Strength Checker **Objective**: You are tasked with developing a function that determines the minimum number of additional characters required to make a given password string \\"strong\\" as per specified criteria. **Problem Statement**: Design a function `strong_password(n: int, password: str) -> int` that checks if a given password meets the following conditions: 1. Its length is at least 6. 2. It contains at least one digit. 3. It contains at least one lowercase English character. 4. It contains at least one uppercase English character. 5. It contains at least one special character. The special characters are: `!@#%^&*()-+` If the password does not meet all these conditions, the function should return the minimum number of characters needed to make the password strong. The function should be efficient with time complexity of O(n) and space complexity of O(1). **Input Format**: - An integer `n` representing the length of the password. - A string `password` of length `n` consisting of characters from lowercase and uppercase English alphabet, digits, or special characters. **Output Format**: - The minimum number of additional characters required to make the password string strong. **Constraints**: - The length of the input string `password` is between 1 and 100 (inclusive). - The password string will contain only printable ASCII characters. **Examples**: Example 1: ```plaintext Input: n = 3, password = \\"Ab1\\" Output: 3 Explanation: Adding three characters would make the password strong (e.g., `Ab1hK`). ``` Example 2: ```plaintext Input: n = 11, password = \\"#Algorithms\\" Output: 1 Explanation: Adding one digit would make the password strong. ``` **Function Signature**: ```python def strong_password(n: int, password: str) -> int: # Your implementation here pass ```","solution":"def strong_password(n: int, password: str) -> int: Determines the minimum number of additional characters required to make a password string \\"strong\\" as per the specified criteria. # Track the presence of required characters has_digit = any(char.isdigit() for char in password) has_lowercase = any(char.islower() for char in password) has_uppercase = any(char.isupper() for char in password) has_special_char = any(char in \\"!@#%^&*()-+\\" for char in password) # Calculate missing character types missing_types = 4 - sum([has_digit, has_lowercase, has_uppercase, has_special_char]) # Calculate the number of characters needed to reach at least length 6 length_needed = max(0, 6 - n) # The result is the maximum of missing character types and length_needed return max(missing_types, length_needed)"},{"question":"You are required to implement a function `advanced_swap_pair` that swaps the odd and even bits in a given non-negative 64-bit integer. This function should utilize bitwise operations to ensure high efficiency. Function Signature ```python def advanced_swap_pair(num: int) -> int: ``` Input * `num` (0 <= `num` <= 2^64 - 1): A non-negative 64-bit integer. Output * Returns an integer after swapping each pair of adjacent bits in `num`. Constraints * Your implementation should aim to achieve O(1) time complexity. * Ensure that the function handles the full range of 64-bit integers. # Requirements 1. **Bitwise Operations**: Implement the function using bitwise operations: AND, OR, masks, and shifts. 2. **Edge Cases**: Ensure that the function handles edge cases, such as very small numbers (e.g., 0) and very large numbers close to the maximum 64-bit integer. 3. **Performance**: Demonstrate that the function operates in constant time, irrespective of the input value. Example ```python # Example 1: input_num = 22 # Binary representation: 0000 0000 0000 0000 0000 0000 0001 0110 # After swap: 0000 0000 0000 0000 0000 0000 0010 1001 # Expected Output: 41 # Example 2: input_num = 10 # Binary representation: 0000 0000 0000 0000 0000 0000 0000 1010 # After swap: 0000 0000 0000 0000 0000 0000 0000 0101 # Expected Output: 5 output = advanced_swap_pair(input_num) print(output) # Should print the swapped bit integer ```","solution":"def advanced_swap_pair(num: int) -> int: Swap the odd and even bits in a non-negative 64-bit integer. Args: num (int): A non-negative 64-bit integer. Returns: int: The integer obtained after swapping each pair of adjacent bits in num. # Mask all odd bits (e.g., 0b101010...) odd_mask = 0xAAAAAAAAAAAAAAAA # Mask all even bits (e.g., 0b010101...) even_mask = 0x5555555555555555 # Extract the odd bits and shift them right by 1 to swap them to even positions odd_bits = (num & odd_mask) >> 1 # Extract the even bits and shift them left by 1 to swap them to odd positions even_bits = (num & even_mask) << 1 # Combine the shifted odd and even bits to get the final swapped result return odd_bits | even_bits"},{"question":"# Matrix Multiplication You have been provided with two matrices, and your task is to write a function that computes the product of these matrices using a straightforward nested loop approach. Make sure your implementation checks for valid matrix dimensions and handles potential edge cases. Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: :param multiplicand: List[List[int]] - The first matrix (multiplicand). :param multiplier: List[List[int]] - The second matrix (multiplier). :return: List[List[int]] - The resultant matrix after multiplication. ``` Input - `multiplicand`: A list of lists of integers representing the first matrix. - `multiplier`: A list of lists of integers representing the second matrix. Output - A list of lists of integers representing the resultant matrix after multiplying the input matrices. Constraints 1. The number of columns in `multiplicand` must be equal to the number of rows in `multiplier`. 2. Matrices can contain negative integers. 3. Dimensions for both matrices should be between 1 and 100 (inclusive). Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] result = multiply(multiplicand, multiplier) # result should be [[19, 22], [43, 50]] ``` **Note**: Ensure to handle the case when the matrices are incompatible for multiplication and raise an appropriate exception in such cases.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: # Ensure the number of columns in the multiplicand is equal to the number of rows in the multiplier if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Incompatible matrices for multiplication.\\") # Initialize the result matrix with zeros result = [[0] * len(multiplier[0]) for _ in range(len(multiplicand))] # Perform matrix multiplication for i in range(len(multiplicand)): # iterating over rows of multiplicand for j in range(len(multiplier[0])): # iterating over columns of multiplier for k in range(len(multiplier)): # iterating over rows of multiplier / columns of multiplicand result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Objective You are the lead developer at a company creating an auto-completion system. Your task is to implement the core component, which is a Trie, that can efficiently handle operations like insert, search, and prefix matching. # Functionality Requirements Implement the following methods in the Trie class: 1. **insert(word)**: Inserts a string `word` into the trie. 2. **search(word)**: Returns `True` if the string `word` is present in the trie, otherwise returns `False`. 3. **starts_with(prefix)**: Returns `True` if there is any string in the trie that starts with the string `prefix`, otherwise returns `False`. # Input/Output Specifications * **Input**: * For `insert(word)`, `word` is a non-empty string of lowercase letters a-z. * For `search(word)`, `word` is a string of lowercase letters a-z. * For `starts_with(prefix)`, `prefix` is a string of lowercase letters a-z. * **Output**: * For `insert(word)`, there is no output (null or void). * For `search(word)`, return boolean value `True` if the word exists, otherwise `False`. * For `starts_with(prefix)`, return boolean value `True` if there exists a word with the given prefix, otherwise `False`. # Constraints * All strings are composed of lowercase English letters (a-z). * The total number of calls for the insert, search, and starts_with functions does not exceed 10^5. * Each string\'s length will not exceed 100 characters. # Example ```python trie = Trie() trie.insert(\\"apple\\") trie.search(\\"apple\\") # returns True trie.search(\\"app\\") # returns False trie.starts_with(\\"app\\") # returns True trie.insert(\\"app\\") trie.search(\\"app\\") # returns True ``` # Edge Cases 1. Searching for an empty string should return False. 2. Prefix that does not match any inserted words should return False. 3. Insertion of duplicate words should not affect the structure negatively.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self._search_prefix(word) return node is not None and node.is_end_of_word def starts_with(self, prefix): return self._search_prefix(prefix) is not None def _search_prefix(self, prefix): node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node"},{"question":"You are tasked with writing an efficient Heap Sort function that sorts an array of integers. Unlike typical Heap Sort implementations which use either a max-heap or min-heap exclusively, your task requires you to implement a hybrid approach that uses a max-heap to partially sort the array and a min-heap to complete the sorting process. # Function Signature ```python def hybrid_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr`: A list of integers to be sorted. * `simulation`: A boolean flag, default to `False`. When `True`, print the array after each modification step during the sorting process. # Output * Return a sorted list of integers in ascending order. # Constraints * The input list, `arr`, can have up to `10^5` elements. * Each element in the list falls in the range of `-10^6` to `10^6`. # Example ```python input_arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] hybrid_heap_sort(input_arr) # Expected output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Details 1. **Initial Max-Heap Sort**: * Build a max heap from the input array. * Perform partial sort by continually moving the peak of the heap (maximum element) to the end of the array and reducing the heap size. 2. **Completion with Min-Heap**: * Continue sorting the partially sorted array using a min-heap approach. * Mimic the process of a typical min-heap sort to finalize the ordering. # Edge Case Handling * Ensure to handle empty arrays. * Correctly manage single element arrays. * Provide proper handling of duplicate elements. # Guidelines * Use the existing `max_heap_sort` and `min_heap_sort` functions as references to your solution. * The goal is to implement both phases of heap sorting within the `hybrid_heap_sort` function itself without invoking external functions. * Maintain efficient performance with a target complexity of O(n log(n)).","solution":"import heapq from typing import List def hybrid_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: def print_simulation(arr): if simulation: print(arr) # Phase 1: Max-Heap sort n = len(arr) # Build a max heap for i in range(n // 2 - 1, -1, -1): heapify_max(arr, n, i) print_simulation(arr) # Extract elements from the max heap for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify_max(arr, i, 0) print_simulation(arr) # Phase 2: Min-Heap sort (in reverse order) reverse_sorted = arr[::-1] heapq.heapify(reverse_sorted) print_simulation(reverse_sorted) sorted_arr = [] while reverse_sorted: sorted_arr.append(heapq.heappop(reverse_sorted)) print_simulation(reverse_sorted) return sorted_arr def heapify_max(arr: List[int], n: int, i: int): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify_max(arr, n, largest)"},{"question":"You are given a sorted array of integers in ascending order. Implement two functions to perform Binary Search: one using the iterative approach (`binary_search`) and another using the recursive approach (`binary_search_recur`). Function Specifications 1. **binary_search(array, query)** - **Input**: - `array`: List of `int`. A sorted array of integers. - `query`: `int`. The value to search for in the array. - **Output**: - Returns the index of the `query` element if found, else returns `None`. - **Constraints**: - `1 <= len(array) <= 10^5` - `-10^9 <= array[i], query <= 10^9` 2. **binary_search_recur(array, low, high, val)** - **Input**: - `array`: List of `int`. A sorted array of integers. - `low`: `int`. Starting index of the search range. - `high`: `int`. Ending index of the search range. - `val`: `int`. The value to search for in the array. - **Output**: - Returns the index of the `val` element if found, otherwise returns `-1`. - **Constraints**: - `1 <= len(array) <= 10^5` - `-10^9 <= array[i], val <= 10^9` Example ```python # Example usage: array = [1, 3, 5, 7, 9, 11, 13, 15] query = 7 # For iterative approach print(binary_search(array, query)) # Output: 3 # For recursive approach print(binary_search_recur(array, 0, len(array) - 1, query)) # Output: 3 ``` Notes - Consider edge cases such as an empty array, a single element array, and the query not present in the array. - Ensure your implementation handles large inputs efficiently. - Your solution will be tested against a variety of cases including stress tests to ensure performance constraints are met.","solution":"def binary_search(array, query): Performs binary search on a sorted array iteratively. Returns the index of query if found, else returns None. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return None def binary_search_recur(array, low, high, val): Performs binary search on a sorted array recursively. Returns the index of val if found, else returns -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: return binary_search_recur(array, mid + 1, high, val) else: return binary_search_recur(array, low, mid - 1, val)"},{"question":"You are given an array of `m` integers, and you need to identify all unique `k`-tuples such that the sum of `k` elements equals a given target. The algorithm should be flexible enough to handle sum and comparison functions as arguments. Function Signature: ```python def k_sum(k: int, arr: List[int], target: int, sum_func: Optional[Callable[[int, int], int]] = None, compare_func: Optional[Callable[[int, int], int]] = None) -> List[List[int]]: ``` # Input 1. `k`: An integer, the number of elements in each tuple that should sum to the target. 2. `arr`: A list of integers, the input array. 3. `target`: An integer, the sum target. 4. `sum_func`: A closure (optional), a function that takes two integers and returns their sum (default is simple addition). 5. `compare_func`: A closure (optional), a function that compares two integers and returns `-1`, `0`, or `1` (default is simple comparison). # Output Returns a list of unique `k`-tuples where each tuple\'s sum equals the target. # Constraints * `2 <= k <= 4` * All integers within the array are between `-1000` and `1000`. * Array has at most `2000` elements. # Example: **Example 1:** ```python Input: k = 4 arr = [1, 0, -1, 0, -2, 2] target = 0 Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` **Example 2:** ```python Input: k = 2 arr = [-3, 0, 3, 3, 8, -9] target = -6 sum_func = lambda x, y: x + y compare_func = lambda x, y: -1 if x < y else (1 if x > y else 0) Output: [[-9, 3], [3, -6]] ``` **Example 3:** ```python Input: k = 2 arr = [4, 6, 2, -5, 9, -2] target = 4 Output: [[-2, 6], [-5, 9]] ``` # Notes * Implement the algorithm following the recursive strategy as outlined in the provided analysis. * Use efficient sorting and optimizing strategies as discussed. * Validate all edge cases and handle possible error scenarios. Good Luck!","solution":"from typing import List, Callable, Optional def k_sum(k: int, arr: List[int], target: int, sum_func: Optional[Callable[[int, int], int]] = None, compare_func: Optional[Callable[[int, int], int]] = None) -> List[List[int]]: if sum_func is None: sum_func = lambda x, y: x + y if compare_func is None: compare_func = lambda x, y: -1 if x < y else (1 if x > y else 0) def find_k_sum(start, end, k, target): if k == 2: return two_sum(start, end, target) else: res = [] for i in range(start, end - k + 2): if i > start and compare_func(arr[i], arr[i - 1]) == 0: continue for subset in find_k_sum(i + 1, end, k - 1, target - arr[i]): res.append([arr[i]] + subset) return res def two_sum(start, end, target): res = [] l, r = start, end while l < r: current_sum = sum_func(arr[l], arr[r]) cmp = compare_func(current_sum, target) if cmp == 0: res.append([arr[l], arr[r]]) l += 1 r -= 1 while l < r and compare_func(arr[l], arr[l - 1]) == 0: l += 1 while l < r and compare_func(arr[r], arr[r + 1]) == 0: r -= 1 elif cmp < 0: l += 1 else: r -= 1 return res arr.sort() return find_k_sum(0, len(arr) - 1, k, target)"},{"question":"# Question: Filter Words Typed Using a Singular Keyboard Row Your task is to write a function `find_keyboard_row` that filters a list of words and returns only those words that can be typed using letters from only one row of an American QWERTY keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` Input * `words` (List[str]): A list of strings where each string represents a word consisting of alphabetical characters (both uppercase and lowercase). Output * `List[str]`: A list of strings which are words from the input list that can be typed using letters from only one row of an American QWERTY keyboard. Constraints * The function should be case insensitive. Treat uppercase and lowercase letters as equivalent. * The input list may contain zero or more words. # Example ```python # Example 1: input_words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] output_words = find_keyboard_row(input_words) print(output_words) # Output: [\\"Alaska\\", \\"Dad\\"] # Example 2: input_words = [\\"Row\\", \\"Mid\\", \\"Tap\\"] output_words = find_keyboard_row(input_words) print(output_words) # Output: [\\"Row\\"] ``` # Additional Context (if any) * Words on a keyboard row can be represented by their corresponding sets of characters: - Top row: {\'q\', \'w\', \'e\', \'r\', \'t\', \'y\', \'u\', \'i\', \'o\', \'p\'} - Middle row: {\'a\', \'s\', \'d\', \'f\', \'g\', \'h\', \'j\', \'k\', \'l\'} - Bottom row: {\'z\', \'x\', \'c\', \'v\', \'b\', \'n\', \'m\'} * This problem checks fundamental understanding of set operations and their application to solve constraint-based filtering problems.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: # Define the sets for each keyboard row top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") def valid_word(word): # Lowercase the word for comparison word_set = set(word.lower()) # Check if word set is a subset of any row set return word_set.issubset(top_row) or word_set.issubset(middle_row) or word_set.issubset(bottom_row) # Filter and return words that are valid return [word for word in words if valid_word(word)]"},{"question":"# Context: You are tasked with writing a function that increments a given non-negative integer represented as a list of digits by one. The list of digits is in big-endian format, meaning the most significant digit is at the head of the list. # Problem Statement: Write a function `increment_digits(digits)` that takes a list of non-negative digits (0-9) and returns a list where one has been added to the integer represented by the digits. Function Signature: ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` # Input: * **digits**: List[int], a list of integers representing a non-negative number. The list\'s length is between 1 and 10^6. # Output: * **result**: List[int], a list of integers representing the incremented result. # Constraints: * Each element of `digits` is between 0 and 9, inclusive. * The resulting list should correctly handle carry over. * The function should aim for O(n) time complexity and O(1) extra space usage. # Example: ```python print(increment_digits([1, 2, 3])) # Output: [1, 2, 4] print(increment_digits([9, 9, 9])) # Output: [1, 0, 0, 0] print(increment_digits([0])) # Output: [1] ``` # Guidelines: * Ensure the function is optimized in terms of both time and space complexity. * Properly handle edge cases such as digits leading with zero or having multiple consecutive nines. * Avoid using additional space for storing digits unless necessary.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: Increments the given list of digits by one. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If all digits were 9, we need an extra digit at the beginning. return [1] + digits"},{"question":"**Title**: Implement the Deletion Operation in a Red-Black Tree and its Fix-Up Mechanism # Background A Red-Black Tree is a self-balancing binary search tree where nodes follow a specific set of properties to ensure the tree remains approximately balanced over time. This significantly improves the efficiency of insertions, deletions, and lookups. # Problem Statement You are given an implementation of a Red-Black Tree, with functionalities including insertion, search, and deletion. However, the deletion fix-up mechanism is already provided to handle node removal properly according to the red-black tree properties. Your task is to focus on the `delete` method implementation and make necessary adjustments to ensure that nodes are correctly removed from the tree while maintaining the red-black properties. # Core Requirements 1. **Function Implementation**: * Implement the `delete` method where `node` is an instance of the `RBNode` class. * Ensure the deletion should maintain the tree balanced by valid use of value, color swap, and rotations if required. 2. **Red-Black Tree Properties**: * After deletion, the resulting tree must follow all Red-Black properties. # Input/Output Specifications 1. **Input**: * Function `delete(node: RBNode) -> None` * `node`: Instance of `RBNode` class representing the node to be deleted. 2. **Output**: * None - The tree must be updated in-place. # Constraints 1. All `RBNode` values are unique in the tree. 2. Input `node` is guaranteed to be a node in the tree. # Example Example 1: Initial Tree: After Deleting 8: 11 11 / / 2 14 2 14 / / 1 7 15 1 7 15 / / 5 8 5 / 4 # Resources You are allowed to use the given class definitions and methods to develop, test, and ensure correctness. # Skeleton Code ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None def transplant(self, node_u, node_v): if node_u.parent is None: self.root = node_v elif node_u is node_u.parent.left: node_u.parent.left = node_v elif node_u is node_u.parent.right: node_u.parent.right = node_v if node_v: node_v.parent = node_u.parent def minimum(self, node): temp_node = node while temp_node.left: temp_node = temp_node.left return temp_node def delete_fixup(self, node): # Fix-up logic based on the initial implementation go here pass def delete(self, node): # Implement the deletion logic here. pass rb = RBTree() # Add test cases to insert and delete elements in the Red Black Tree ```","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.TNULL = RBNode(0, False) self.TNULL.left = None self.TNULL.right = None self.root = self.TNULL def transplant(self, node_u, node_v): if node_u.parent is None: self.root = node_v elif node_u == node_u.parent.left: node_u.parent.left = node_v else: node_u.parent.right = node_v if node_v: node_v.parent = node_u.parent def minimum(self, node): while node.left != self.TNULL: node = node.left return node def delete_fixup(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self.left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self.right_rotate(x.parent) s = x.parent.left if s.right.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0 def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.val == key: z = node if node.val <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Cannot find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.transplant(y, y.right) y.right = z.right y.right.parent = y self.transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.delete_fixup(x) def delete(self, val): self.delete_node_helper(self.root, val) def insert(self, key): node = RBNode(key, True, None, self.TNULL, self.TNULL) y = None x = self.root while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.fix_insert(node) def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0"},{"question":"Context You are designing a system that involves transferring lists of strings across different services via a network. To ensure the data is compact and can be reconstructed accurately, you need to develop an encoding and decoding mechanism. Objective Write two functions, `encode` and `decode`, that will encode a list of strings to a single string and decode it back to the original list of strings respectively. Function Signatures ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` Requirements 1. **Encoding Function**: - Input: A list of strings `strs`. - Output: A single encoded string such that no information is lost. - Ensure the encoded string uses a format that can be decoded back to the original list. 2. **Decoding Function**: - Input: A single encoded string `s`. - Output: The original list of strings. Constraints - Each string in the list can contain any characters, including colons (\':\'). - Strings can be of varying lengths. - The list can contain an empty string. Examples ```python # Example 1: original_list = [\\"hello\\", \\"world\\"] encoded_string = encode(original_list) print(encoded_string) # e.g., \\"5:hello5:world\\" decoded_list = decode(encoded_string) print(decoded_list) # [\\"hello\\", \\"world\\"] # Example 2: original_list = [\\"abc\\", \\"\\", \\"def\\"] encoded_string = encode(original_list) print(encoded_string) # e.g., \\"3:abc0:3:def\\" decoded_list = decode(encoded_string) print(decoded_list) # [\\"abc\\", \\"\\", \\"def\\"] ``` Performance Requirements - The solution should be efficient in both time and space, handle large lists and strings gracefully, and maintain correctness across all edge cases.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s: str) -> List[str]: Decodes a single string back to a list of strings. i, n = 0, len(s) result = [] while i < n: j = s.find(\':\', i) length = int(s[i:j]) result.append(s[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"# Minimum Spanning Tree with Kruskal\'s Algorithm **Context**: You are working as a network engineer for a smart city project. You need to design an efficient network to connect various infrastructure points (nodes) with the minimum cost. Each connection between nodes has a specified cost, and your goal is to create a network that connects all points while minimizing the total connection cost. **Task**: Implement a function `minimum_spanning_tree(vertex_count, edges)` that uses Kruskal\'s Algorithm to compute the minimum spanning tree of a connected, undirected, and weighted graph. **Function Signature**: ```python def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: Args: vertex_count (int): Number of vertices in the graph edges (List[Tuple[int, int, int]]): A list of edges, where each edge is a tuple (u, v, weight) Returns: int: The sum of the weights of the minimum spanning tree. ``` **Input**: - `vertex_count`: an integer value `n` where `1 <= n <= 1000` representing the number of vertices. - `edges`: a list of tuples where each tuple consists of three integers `(u, v, weight)` representing an edge between vertex `u` and vertex `v` with the given `weight`. The length of this list will be between `1` to `10000`. - Vertices are indexed starting from `0`. **Output**: - Return an integer representing the sum of the weights of the minimum spanning tree. **Example**: ```python vertex_count = 5 edges = [(0, 1, 3), (0, 2, 8), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 6)] minimal_spanning_tree(vertex_count, edges) # Output: 14 ``` **Constraints**: - The graph is connected. - At most one edge between any pair of vertices. - No negative weights. **Notes**: 1. Ensure efficient handling of union and find operations using path compression and union by rank. 2. Sort the edges to process in non-decreasing order of weight. 3. Handle all necessary edge cases, including minimum and maximum constraints. **Hint**: Utilize a disjoint set (union-find) data structure for efficiently managing the merging of sets and checking for cycles during the processing of edges.","solution":"def find(parent, i): Function to find the set of an element i with path compression. if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): Function to perform union of two sets x and y by rank. root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimum_spanning_tree(vertex_count, edges): Function to compute the minimum spanning tree using Kruskal\'s algorithm. # Sort all the edges in non-decreasing order of their weight. edges = sorted(edges, key=lambda x: x[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(vertex_count): parent.append(node) rank.append(0) mst_weight = 0 mst_edges = 0 # Number of edges to be taken is vertex_count-1 for edge in edges: u, v, weight = edge # Find the roots of the vertices of the current edge root_u = find(parent, u) root_v = find(parent, v) # If including this edge does not cause a cycle, # include it in the result and increment the index of MST edges if root_u != root_v: mst_weight += weight mst_edges += 1 union(parent, rank, root_u, root_v) # Terminate if we have included vertex_count-1 edges if mst_edges == vertex_count - 1: break return mst_weight"},{"question":"# Scenario You are tasked with developing a sorting utility for a small company. As part of the utility, you need to implement the Selection Sort algorithm to sort an array of integers in ascending order. # Task Write a Python function `optimized_selection_sort(arr)` that sorts the given list of integers using the selection sort algorithm but includes optimization to skip iterations when the array is already sorted. # Function Signature ```python def optimized_selection_sort(arr: list[int]) -> list[int]: pass ``` # Input - A list `arr` of integers, where (1 ≤ text{len}(arr) ≤ 10^3). - Elements of the array can be any integers (positive or negative). # Output - A list of integers sorted in ascending order. # Constraints - Ensure that your implementation does not exceed a time complexity of O(n^2) for the worst case. # Example ```python print(optimized_selection_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] print(optimized_selection_sort([3, 1, 2])) # Output: [1, 2, 3] print(optimized_selection_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ``` # Additional Considerations - Ensure the function can handle arrays of size (10^3). - Handle edge cases such as an empty array or an array with one element.","solution":"def optimized_selection_sort(arr: list[int]) -> list[int]: Sorts a list of integers in ascending order using an optimized version of the Selection Sort algorithm. Parameters: - arr: list[int]: The list of integers to be sorted. Returns: - list[int]: The sorted list in ascending order. n = len(arr) for i in range(n): min_idx = i is_sorted = True for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j if arr[j] < arr[j - 1]: is_sorted = False if is_sorted: break arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"You are tasked with implementing a variant of the Gnome Sort algorithm, named \\"Bi-directional Gnome Sort\\". In this version, instead of moving strictly left to right through the array, the algorithm will switch directions every time it reaches the end of the array or makes a swap that pushes it to the start of the array. # Objective Write a function `bi_directional_gnome_sort(arr)` that sorts an array of integers using the Bi-directional Gnome Sort algorithm. # Input - An array `arr` of integers with length `n` where `1 <= n <= 10^5`. # Output - A sorted array `arr` in non-decreasing order. # Constraints - The array contains integers ranging from `-10^9` to `10^9`. # Example ```python bi_directional_gnome_sort([34, 2, 10, -9]) # Output: [-9, 2, 10, 34] bi_directional_gnome_sort([1, 20, -5, 100, 0, 3]) # Output: [-5, 0, 1, 3, 20, 100] ``` # Notes - Ensure that your implementation handles edge cases, such as empty arrays and arrays with a single element. - Aim for clarity and simplicity in your code.","solution":"def bi_directional_gnome_sort(arr): Sorts the array using the Bi-directional Gnome Sort algorithm. if len(arr) <= 1: return arr idx = 0 direction = 1 # 1 for forward, -1 for backward while idx < len(arr): if idx == 0: direction = 1 idx += 1 elif idx == len(arr): direction = -1 idx -= 1 elif arr[idx] >= arr[idx - 1]: if direction == 1: idx += 1 else: idx -= 1 else: arr[idx], arr[idx - 1] = arr[idx - 1], arr[idx] idx -= 1 if direction == 1 else 1 return arr # Example Usage: # This can be removed for actual unit testing scenario. print(bi_directional_gnome_sort([34, 2, 10, -9])) # Output: [-9, 2, 10, 34] print(bi_directional_gnome_sort([1, 20, -5, 100, 0, 3])) # Output: [-5, 0, 1, 3, 20, 100]"},{"question":"**Question**: Implement a `pigeonhole_sort` function that sorts a list of integers within a specific range efficiently. Your task is to understand when this algorithm is suitable and handle some common edge cases effectively. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` # Input - **arr**: A list of integers (arr) where (1 leq text{len}(arr) leq 10^6) and integers in (arr) are within a feasible range for this algorithm. # Output - **Return**: A list of integers sorted in non-decreasing order. # Constraints 1. The elements of `arr` will be within a range of at most (10^6). 2. The function should handle empty lists efficiently. 3. Do not use any built-in sorting functions. # Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert pigeonhole_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] assert pigeonhole_sort([]) == [] ``` # Context In a software development assessment, efficient sorting of data collected from users is critical. You\'re tasked to optimize the sorting function to handle large datasets within a feasible range using the provided Pigeonhole Sort algorithm.","solution":"def pigeonhole_sort(arr): Sorts a list of integers using the pigeonhole sort algorithm. if not arr: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for number in arr: holes[number - min_value] += 1 sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([min_value + index] * count) return sorted_arr"},{"question":"Implement a Min-Heap with Fixed Size Context You are tasked with implementing a Min-Heap data structure with a fixed maximum size. The min-heap should be capable of performing standard operations efficiently while ensuring that the heap property is maintained. Objective Implement a class `FixedSizeMinHeap` that supports the following operations: 1. `insert(value)`: Inserts a new element into the heap. 2. `remove_min()`: Removes and returns the minimum element from the heap. 3. `get_min()`: Returns the minimum element without removing it from the heap. 4. `is_full()`: Returns True if the heap is full, False otherwise. Constraints - The heap can hold a maximum of `max_size` elements. - Attempting to insert into a full heap should raise an `OverflowError`. - Removing the minimum element from an empty heap should raise an `IndexError`. Input and Output Formats - **Input**: The inputs are the sequence of operations on the heap. Initial size limit (max_size) will be specified during the heap creation. - **Output**: Expected outputs are the result of `remove_min()` calls and any exceptions raised due to invalid operations. Detailed Requirements - Implement the `FixedSizeMinHeap` class. - Ensure the operations `insert`, `remove_min`, `get_min`, and `is_full` function correctly. Example Usage ```python heap = FixedSizeMinHeap(5) heap.insert(4) heap.insert(2) heap.insert(9) print(heap.get_min()) # Output: 2 print(heap.remove_min()) # Output: 2 print(heap.is_full()) # Output: False heap.insert(6) heap.insert(1) heap.insert(3) print(heap.is_full()) # Output: True ``` Notes - Do not use built-in heap functions from Python\'s `heapq` module. - Focus on maintaining the heap property and efficient implementation of the operations.","solution":"class FixedSizeMinHeap: def __init__(self, max_size): self.max_size = max_size self.size = 0 self.heap = [] def insert(self, value): if self.is_full(): raise OverflowError(\\"Heap is full\\") self.heap.append(value) self.size += 1 self._heapify_up(self.size - 1) def remove_min(self): if self.size == 0: raise IndexError(\\"Heap is empty\\") min_value = self.heap[0] self.heap[0] = self.heap[self.size - 1] self.heap.pop() self.size -= 1 self._heapify_down(0) return min_value def get_min(self): if self.size == 0: raise IndexError(\\"Heap is empty\\") return self.heap[0] def is_full(self): return self.size == self.max_size def _heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent) def _heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < self.size and self.heap[left] < self.heap[smallest]: smallest = left if right < self.size and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"You are given two strings `str_a` and `str_b`. Your task is to implement a function `is_match(str_a, str_b)` that returns `True` if the string `str_a` matches the pattern `str_b`, otherwise returns `False`. The pattern string `str_b` may contain the special characters `\'.\'` and `\'*\'`. - `\'.\'` matches any single character. - `\'*\'` matches zero or more of the preceding element. The matching should cover the entire input string (not a substring). # Function Signature ```python def is_match(str_a: str, str_b: str) -> bool: ``` # Input * `str_a`: A string representing the text, with a length of ( |str_a| leq 1000 ). * `str_b`: A string representing the pattern, with a length of ( |str_b| leq 1000 ). # Output * Return `True` if `str_a` matches `str_b`, otherwise return `False`. # Examples ```python print(is_match(\\"aa\\", \\"a\\")) # Output: False print(is_match(\\"aa\\", \\"aa\\")) # Output: True print(is_match(\\"aaa\\", \\"aa\\")) # Output: False print(is_match(\\"aa\\", \\"a*\\")) # Output: True print(is_match(\\"aa\\", \\".*\\")) # Output: True print(is_match(\\"ab\\", \\".*\\")) # Output: True print(is_match(\\"aab\\", \\"c*a*b\\")) # Output: True ``` # Constraints * `str_a` and `str_b` will contain only lowercase alphabetical characters. * The function should be efficient enough to handle inputs close to the constraint limits.","solution":"def is_match(str_a: str, str_b: str) -> bool: Returns True if str_a matches the pattern str_b, otherwise returns False. # dp[i][j] will be True if str_a[0..i-1] matches str_b[0..j-1] dp = [[False] * (len(str_b) + 1) for _ in range(len(str_a) + 1)] # Empty pattern matches empty string dp[0][0] = True # Only \'*\' can match empty string. For example, \\"a*\\" can match an empty string but \\"a\\" and \\"a.\\" cannot. for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the table for i in range(1, len(str_a) + 1): for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'.\' or str_b[j - 1] == str_a[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif str_b[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (str_b[j - 2] == str_a[i - 1] or str_b[j - 2] == \'.\')) return dp[len(str_a)][len(str_b)]"},{"question":"Given a directed graph and a starting node, implement the following graph traversal algorithms: 1. Iterative Depth First Search (DFS). 2. Iterative Breadth First Search (BFS). 3. Recursive Depth First Search (DFS). Ensure that all implementations handle disconnected graphs and cycles properly. Use the provided function signatures and specifications. # Input * `graph`: A dictionary of lists representing adjacency list of the graph. `graph[node]` is a list of neighboring nodes. * `start`: An initial starting node for the traversal. # Output * A list of nodes in the order they are visited. * Order of nodes may vary based on implementation specifics but should reflect depth-first or breadth-first nature correctly. # Constraints * The graph is not necessarily connected. * Graph nodes are represented uniquely. * The number of nodes does not exceed 10^3. * The number of edges does not exceed 10^4. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } start = \'A\' # Example output for DFS assert dfs_traverse(graph, start) == [\'A\', \'C\', \'F\', \'B\', \'E\', \'D\'] # one possible correct order # Example output for BFS assert bfs_traverse(graph, start) == [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] # one possible correct order ``` # Function Signatures ```python def dfs_traverse(graph, start): # Your code here pass def bfs_traverse(graph, start): # Your code here pass def dfs_traverse_recursive(graph, start, visited=None): # Your code here pass ``` Use the provided template functions to complete the task and meet the specified requirements.","solution":"def dfs_traverse(graph, start): Iterative Depth-First Search (DFS) traversal of the graph. visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph.get(node, []))) return visited def bfs_traverse(graph, start): Iterative Breadth-First Search (BFS) traversal of the graph. visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph.get(node, [])) return visited def dfs_traverse_recursive(graph, start, visited=None): Recursive Depth-First Search (DFS) traversal of the graph. if visited is None: visited = [] if start not in visited: visited.append(start) for neighbor in graph.get(start, []): dfs_traverse_recursive(graph, neighbor, visited) return visited"},{"question":"# Maze Pathfinder Coding Assessment Context You are a software engineer working on a navigation system for a robotic vacuum cleaner. The robot operates in a grid-like environment where it needs to find the shortest path from the top-left corner to the bottom-right corner without bumping into obstacles. Task Implement the function `find_shortest_path` to solve for the minimum number of steps required to navigate from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) of a grid. The robot can only step on cells marked with a 1, representing open spaces, and must avoid cells marked with a 0, representing obstacles. If no path exists, return -1. Input and Output Specifications - **Input**: A 2D list `grid` of dimensions `n x m`, where each element is either 0 or 1. - Example: `[[1, 0, 1], [1, 0, 1], [1, 1, 1]]` - **Output**: An integer representing the minimum number of steps from (0, 0) to (n-1, m-1). Return -1 if no such path exists. Constraints - The grid will have at least one cell and at most 1000 cells (i.e., `1 <= n, m <= 1000`). - The robot can move up, down, left, or right but cannot move diagonally. Example Scenarios 1. **Scenario 1**: - Input: `[[1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1]]` - Output: `14` 2. **Scenario 2**: - Input: `[[1, 0, 0], [0, 1, 1], [0, 1, 1]]` - Output: `-1` Notes - Ensure that your solution is efficient and handles all given constraints. - Pay special attention to edge cases such as starting position or target position being blocked, or entirely blocked paths.","solution":"from collections import deque def find_shortest_path(grid): Finds the shortest path from the top-left to the bottom-right of the grid. if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 n = len(grid) m = len(grid[0]) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # right, left, down, up queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() # Check if we\'ve reached the bottom-right cell if row == n - 1 and col == m - 1: return steps # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"# Question Given a binary search tree (BST), write a function to find the kth smallest element in it. The BST is structured such that every node has an integer value greater than its left child and less than its right child. Function Signature ```python def kth_smallest_element(root: TreeNode, k: int) -> int: pass ``` # Input * `root`: A `TreeNode` object, which is the root of the BST. * `k`: An integer `k` (1 <= k <= number of nodes in BST). # Output * Return the value of the kth smallest element in the BST. # Constraints * Assume the tree nodes have unique values. # Example ```python # Example Tree # 5 # / # 3 7 # / # 2 4 8 # Example 1 root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right = TreeNode(7) root.right.right = TreeNode(8) assert kth_smallest_element(root, 3) == 4 ``` # Notes This problem tests the ability to traverse and manipulate binary search trees efficiently. Students should implement an in-order traversal mechanism to locate and retrieve the kth smallest element.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_element(root: TreeNode, k: int) -> int: def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) inorder = inorder_traversal(root) return inorder[k - 1]"},{"question":"Objective You are required to implement a function to find the indices of two numbers in an array that add up to a given target value. This question will assess your understanding of dictionary usage and efficient algorithm implementation. Context A security system verifies transaction amounts by ensuring that every transaction amount can be matched with another one such that their sum equals a specified value. Your task is to write the core functionality for this system. Function Signature ```python def transaction_pair_indices(transactions: List[int], target: int) -> Tuple[int, int]: pass ``` Input and Output * **Input**: * `transactions` (List[int]): A list of integers representing transaction amounts. * `target` (int): An integer target sum. * **Output**: * Return a tuple of two integers representing the indices of the two elements in the transactions list whose sum is equal to the target. * If no such pair exists, return `None`. Constraints * Each input list will have exactly one solution. * You may not use the same element twice for a pair. * The input list can have a length ranging from 0 to 10^5. Examples ```python # Example 1 transactions = [2, 7, 11, 15] target = 9 # Output: (0, 1) # Example 2 transactions = [1, 3, 4, 2] target = 6 # Output: (2, 3) ``` Performance Requirements Your solution should exhibit O(n) time complexity and O(n) space complexity, where n is the length of the transactions array.","solution":"from typing import List, Tuple, Optional def transaction_pair_indices(transactions: List[int], target: int) -> Optional[Tuple[int, int]]: Returns the indices of two numbers in an array that add up to a given target value. :param transactions: List[int] - A list of integers representing transaction amounts. :param target: int - An integer target sum. :return: Tuple[int, int] - A tuple of indices of the two numbers that add up to the target, or None if no such pair exists. # Dictionary to store the complement and its index complement_map = {} for index, amount in enumerate(transactions): complement = target - amount if complement in complement_map: return (complement_map[complement], index) complement_map[amount] = index # If no pair found, return None return None"},{"question":"Counting Left Children Nodes in a Binary Tree Write a function `count_left_node` that returns the number of left children in a binary tree. A left child is defined as any node that is a direct left descendant of its parent. Function Signature: ```python def count_left_node(root: Node) -> int: ``` # Input - `root`: A `Node` object representing the root of the binary tree. If the tree is empty, `root` will be `None`. # Output - An integer indicating the number of left children in the tree. # Constraints - The number of nodes (`n`) in the tree is in the range `[0, 10^4]`. - The value within each node is a unique integer. - You may assume that class `Node` is already defined with attributes `left` and `right`, and possibly `value`. # Example Consider the following binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` For this tree, the function call `count_left_node(root)` should return `4` (nodes with values 6, 3, 7, and 10 are all left children). # Additional Information - You can assume the `Node` class is given as follows: ```python class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Important Considerations - Ensure to handle edge cases properly such as: - Empty trees where `root` is `None`. - Trees that only have one node. - Consider tree traversal mechanisms to gather left children nodes effectively. # Testing A sample test case using `unittest` might look like the one provided in the code snippets. ```python import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_count_left_node(self): self.assertEqual(4, count_left_node(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` You are encouraged to write additional test cases to validate your solution against different tree configurations.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_left_node(root: Node) -> int: Returns the number of left children in the binary tree. A left child is any node that is a direct left descendant of its parent. if not root: return 0 count = 0 def dfs(node): nonlocal count if node.left: count += 1 dfs(node.left) if node.right: dfs(node.right) dfs(root) return count"},{"question":"You are asked to implement a dynamic hash table using the separate chaining method provided above as a base. The task is to enhance the `SeparateChainingHashTable` class to support dynamic resizing to maintain efficient operations even as the number of elements grows significantly. The resizing should happen automatically when the load factor (number of elements divided by the number of buckets) exceeds 0.75, by doubling the number of buckets and rehashing all elements. Furthermore, you should add functionality to retrieve all keys sorted by their hash values. Implement the following additional functionalities: 1. **Dynamic Resizing**: Automatically resize and rehash the table when the load factor exceeds 0.75. 2. **Retrieve Sorted Keys**: Implement a method `sorted_keys` that returns all keys in the table, sorted by their hash values. # Input and Output Format - **put(key, value)**: Add a key-value pair to the hash table. - **get(key)**: Retrieve the value associated with the key. - **del_(key)**: Delete the key-value pair from the hash table. - **sorted_keys()**: Return a list of all keys in the table, sorted by their hash values. # Constraints - Assume `key` is always a string, and `value` is any valid Python object. - The initial size of the hash table is given, but resizing must dynamically happen upon inserting elements. # Example ```python # Initial Setup table = SeparateChainingHashTable(size=11) # Inserting elements table.put(\'apple\', 1) table.put(\'banana\', 2) table.put(\'cherry\', 3) table.put(\'date\', 4) # Getting key values assert table.get(\'apple\') == 1 assert table.get(\'banana\') == 2 # Deleting a key table.del_(\'banana\') assert table.get(\'banana\') is None # Check Sorted Keys table.put(\'elderberry\', 5) table.put(\'fig\', 6) print(table.sorted_keys()) # [\'apple\', \'cherry\', \'date\', \'elderberry\', \'fig\'] ``` Implement the methods to handle dynamic resizing and key sorting in the provided `SeparateChainingHashTable` class.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.buckets = [[] for _ in range(size)] self.num_elements = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): idx = self._hash(key) for pair in self.buckets[idx]: if pair[0] == key: pair[1] = value return self.buckets[idx].append([key, value]) self.num_elements += 1 if self.load_factor() > 0.75: self._resize() def get(self, key): idx = self._hash(key) for pair in self.buckets[idx]: if pair[0] == key: return pair[1] return None def del_(self, key): idx = self._hash(key) bucket = self.buckets[idx] for i, pair in enumerate(bucket): if pair[0] == key: del bucket[i] self.num_elements -= 1 return return None def load_factor(self): return self.num_elements / self.size def _resize(self): old_buckets = self.buckets self.size *= 2 self.buckets = [[] for _ in range(self.size)] self.num_elements = 0 for bucket in old_buckets: for key, value in bucket: self.put(key, value) def sorted_keys(self): keys = [] for bucket in self.buckets: for pair in bucket: keys.append(pair[0]) keys.sort(key=lambda k: self._hash(k)) return keys"},{"question":"# Question Consider the provided code snippets which check if a singly linked list is a palindrome using different methods. Your task is to implement a new method `is_palindrome_deque` which uses a deque to check if the singly linked list is a palindrome. Specifications * **Function Signature:** `def is_palindrome_deque(head: ListNode) -> bool:` * **Input:** * `head`: A pointer to the head of a singly linked list. * **Output:** * `bool`: Return `True` if the linked list is a palindrome, otherwise `False`. Constraints * The linked list can contain up to (10^5) nodes. * Node values are non-negative integers. Performance Requirements * Aim for O(n) time complexity. * Ensure any additional space complexity does not exceed O(n). Example ```plaintext Input: 1 -> 2 -> 3 -> 2 -> 1 Output: True Input: 1 -> 2 -> 3 -> 4 -> 2 -> 1 Output: False ``` Edge Cases * An empty list should return `True`. * A single-node list should return `True`. Hint: Use the `collections.deque` to implement the functionality that will allow symmetric checks from both ends efficiently.","solution":"from collections import deque class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome_deque(head: ListNode) -> bool: if not head: return True deque_values = deque() current = head while current: deque_values.append(current.val) current = current.next while len(deque_values) > 1: if deque_values.popleft() != deque_values.pop(): return False return True"},{"question":"# Coding Challenge: Atbash Cipher Implementation Objective Implement and test a function that encrypts a given string using the Atbash cipher. Problem Statement You are given a string `s` and your task is to write a function `atbash(s)` that returns the Atbash cipher of the string. The Atbash cipher is a substitution cipher where \'A\' is mapped to \'Z\', \'B\' to \'Y\', and so on. For lowercase letters, \'a\' is mapped to \'z\', \'b\' to \'y\', etc. Non-alphabetic characters should remain unchanged. Function Signature ```python def atbash(s: str) -> str: pass ``` Input - `s` (str): The input string containing any printable characters. Output - (str): The encrypted string using the Atbash cipher. Constraints - The input string can contain uppercase and lowercase letters, digits, punctuation, and whitespace. - The length of the string `s` will be between 0 and 1000 characters. Example ```python print(atbash(\\"Attack at dawn\\")) # Output: \\"Zggzxp zg wzdm\\" print(atbash(\\"Hello, World!\\")) # Output: \\"Svool, Dliow!\\" print(atbash(\\"ABCDE\\")) # Output: \\"ZYXWV\\" print(atbash(\\"xyz\\")) # Output: \\"cba\\" ``` Performance Requirements - The implementation should have a time complexity of O(n), where n is the length of the string. - Space complexity should be O(n), creating a new string for the result. Notes - You must handle all non-alphabetic characters correctly by leaving them unchanged. - Ensure that the function is case-sensitive, preserving the case of each letter.","solution":"def atbash(s: str) -> str: Returns the Atbash cipher of the given string. Parameters: s (str): The input string to be encrypted. Returns: str: The encrypted string using the Atbash cipher. result = [] for char in s: if \'A\' <= char <= \'Z\': result.append(chr(155 - ord(char))) elif \'a\' <= char <= \'z\': result.append(chr(219 - ord(char))) else: result.append(char) return \'\'.join(result)"},{"question":"Pattern Matching Algorithm # Description You are given a pattern string and an input string. Your task is to determine if the input string follows the same pattern defined by the pattern string. Following means there is a one-to-one mapping between each letter in the pattern and a non-empty substring in the input string. # Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: ``` # Input * **pattern** (str): A non-empty string containing only lowercase letters. * **string** (str): A non-empty string containing only lowercase letters. # Output * **bool**: Return `True` if the string follows the pattern and `False` otherwise. # Constraints * You may assume both pattern and string contain only lowercase letters. # Examples ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False assert pattern_match(\\"abba\\", \\"dogcatcatdog\\") == True assert pattern_match(\\"aaaa\\", \\"aaaaaaaaaaaa\\") == True assert pattern_match(\\"aaaa\\", \\"abcdefgh\\") == False assert pattern_match(\\"abc\\", \\"xyz\\") == True assert pattern_match(\\"aaa\\", \\"aaabbb\\") == False ``` # Explanation 1. **Example 1**: \\"abab\\" -> \\"redblueredblue\\" - a: \\"red\\" - b: \\"blue\\" - The pattern \\"abab\\" can map to part \\"redblue\\" and then map the remaining part \\"redblue\\" thus follows the pattern. 2. **Example 2**: \\"aaaa\\" -> \\"asdasdasdasd\\" - a: \\"asd\\" - Follows the repetition pattern. 3. **Example 3**: \\"aabb\\" -> \\"xyzabcxzyabc\\" - No suitable mapping as different pattern parts would require different substrings. Implement the function by considering the recursive backtracking strategy and make sure to maintain the bijection property between pattern characters and non-empty substrings of the input string.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, p_to_s, s_to_p): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False p_char = pattern[p_idx] for end in range(s_idx + 1, len(string) + 1): sub_str = string[s_idx:end] if p_char not in p_to_s and sub_str not in s_to_p: p_to_s[p_char] = sub_str s_to_p[sub_str] = p_char if backtrack(p_idx + 1, s_idx + len(sub_str), p_to_s, s_to_p): return True del p_to_s[p_char] del s_to_p[sub_str] elif p_char in p_to_s and p_to_s[p_char] == sub_str: if backtrack(p_idx + 1, s_idx + len(sub_str), p_to_s, s_to_p): return True return False return backtrack(0, 0, {}, {})"},{"question":"# Word Square Construction **Scenario**: You are tasked with developing an algorithm to solve a crossword puzzle problem. Given a list of words, you need to find all possible \\"word squares\\" that can be formed. A word square is a set of words that reads the same horizontally and vertically. **Problem**: Design a function `word_squares(words)` that takes a list of words and returns all word squares that can be formed from it. **Input**: - A list of words without duplicates, where each word has the same length. - Word length is between 1 and 5. - The number of words is between 1 and 1000. - Each word contains only lowercase English alphabet characters (`a-z`). **Output**: - A list of lists, where each inner list represents a valid word square. **Constraints**: - Each word square should read the same both horizontally and vertically. **Examples**: ```python # Example 1 input = [\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"] output = [ [\\"wall\\",\\"area\\",\\"lead\\",\\"lady\\"], [\\"ball\\",\\"area\\",\\"lead\\",\\"lady\\"] ] # Example 2 input = [\\"den\\",\\"end\\",\\"ned\\"] output = [] ``` **Function Signature**: ```python def word_squares(words: List[str]) -> List[List[str]]: # your code here ``` **Guidance**: - Consider using a prefix-based method to streamline the search for valid word squares. - Utilize recursive backtracking to construct potential word squares, pruning invalid branches early. - Ensure your implementation is optimal in terms of both time and space complexity.","solution":"from typing import List, Dict from collections import defaultdict def build_prefix_dict(words: List[str]) -> Dict[str, List[str]]: prefix_dict = defaultdict(list) for word in words: for i in range(len(word)): prefix_dict[word[:i]].append(word) return prefix_dict def search_word_squares(step: int, word_length: int, square: List[str], prefix_dict: Dict[str, List[str]], results: List[List[str]]): if step == word_length: results.append(square[:]) return prefix = \'\'.join(square[i][step] for i in range(step)) for candidate in prefix_dict.get(prefix, []): square.append(candidate) search_word_squares(step + 1, word_length, square, prefix_dict, results) square.pop() def word_squares(words: List[str]) -> List[List[str]]: if not words: return [] word_length = len(words[0]) prefix_dict = build_prefix_dict(words) results = [] for word in words: search_word_squares(1, word_length, [word], prefix_dict, results) return results"},{"question":"# String Reversal Challenge **Objective**: Implement a function that reverses an input string using at least one of the following approaches: recursion, iteration, built-in functions, or slicing. Analyze the space and time complexity of the method you choose. **Function Signature**: ```python def reverse_string(s: str) -> str: pass ``` **Input**: - `s` (str): A non-null string which can be of length from 0 to 1000. **Output**: - A string that is the reverse of the input string. **Constraints**: - You cannot use any external libraries other than built-in string manipulation methods in Python. - Your implementation should handle edge cases effectively. **Example**: ```python print(reverse_string(\\"hello\\")) # Output: \\"olleh\\" print(reverse_string(\\"\\")) # Output: \\"\\" print(reverse_string(\\"A\\")) # Output: \\"A\\" print(reverse_string(\\"racecar\\"))# Output: \\"racecar\\" print(reverse_string(\\"123456789\\")) # Output: \\"987654321\\" ``` **Requirements**: - For the provided input, your function must meet the performance requirements and handle additional edge cases such as very large strings. **Assessment Criteria**: - Correctness: Does the function return the accurately reversed string for various test cases? - Efficiency: Is the function optimized for both time and space? - Clarity: Is the code well-structured and easy to understand? - Edge Cases: Are all edge cases appropriately handled?","solution":"def reverse_string(s: str) -> str: Reverses the input string \'s\' using string slicing. Parameters: s (str): Input string to be reversed. Returns: str: The reversed string. return s[::-1]"},{"question":"Context: You are working for a tech company that deals extensively with network data processing. Efficiently counting the number of active connections is crucial as each connection represented as a bit in a large integer. To optimize this, you need an efficient way to count active bits (1s) in the binary representation. Problem Statement: Write a function that takes an unsigned integer and returns the number of \'1\' bits it contains (also known as the Hamming weight). You are required to implement the function using Brian Kernighan\'s Algorithm. Make sure your solution is efficient in terms of both time and space complexities. Function Signature: ```python def hamming_weight(n: int) -> int: pass ``` Expected Input and Output Formats: * **Input**: * An unsigned integer `n`, where 0 <= n < 2^32. * **Output**: * An integer that represents the number of \'1\' bits in the binary representation of `n`. Constraints: * You must use Brian Kernighan’s Algorithm. * The solution should handle edge cases like `0` effectively. * Optimize for the scenario where `n` might be very large (closer to 2^32). # Example: *Example 1*: ```python input: 11 output: 3 ``` Explanation: The binary representation of 11 is `00000000000000000000000000001011`, which has 3 \'1\' bits. *Example 2*: ```python input: 128 output: 1 ``` Explanation: The binary representation of 128 is `00000000000000000000000010000000`, which has 1 \'1\' bit.","solution":"def hamming_weight(n: int) -> int: Takes an unsigned integer and returns the number of \'1\' bits in its binary representation using Brian Kernighan\'s Algorithm. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"Problem Statement You are given an array of words and an array of symbols. Your task is to display each word with its matched symbol surrounded by square brackets. If a word matches more than one symbol, choose the one with the longest length. Implement the function `match_words_with_symbols(words, symbols)` that takes: - `words`: a list of strings representing the words. - `symbols`: a list of strings representing the symbols. Your function should return a list of strings where each word has its matched symbol (if any) surrounded by square brackets. # Constraints: - The length of `symbols` array will not exceed 1000. - The length of `words` array will not exceed 1000. - The length of each word/symbol will not exceed 100. # Example: ``` Input: words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Notes: - If no symbol matches a word, the word should be returned as is. - The function should be optimized for performance, with a complexity better than O(n^2).","solution":"def match_words_with_symbols(words, symbols): Matches words with their corresponding symbols and encloses the matched symbol in square brackets. If a word matches more than one symbol, the longest symbol is selected. Args: words: List[str] - List of words to be matched. symbols: List[str] - List of symbols to match against the words. Returns: List[str] - List of words with the matched symbols surrounded by square brackets. def find_longest_symbol(word, symbols_by_length): for length in sorted(symbols_by_length.keys(), reverse=True): for symbol in symbols_by_length[length]: if symbol in word: return symbol return None # Group symbols by their length for efficient searching symbols_by_length = {} for symbol in symbols: symbols_by_length.setdefault(len(symbol), []).append(symbol) result = [] for word in words: matched_symbol = find_longest_symbol(word, symbols_by_length) if matched_symbol: word = word.replace(matched_symbol, f\'[{matched_symbol}]\', 1) result.append(word) return result"},{"question":"# Euler\'s Totient Function: Advanced Implementation **Context:** Euler\'s Totient function is a fundamental concept in number theory, which counts the number of integers up to a given integer n that are coprime with n. Understanding its implementation is crucial in fields like cryptography and solving various mathematical problems involving integers. **Task:** Write a function that efficiently calculates Euler\'s Totient function for every integer from 1 to a given integer m. Use the results to return a list of totient values ϕ(1) through ϕ(m). # Requirements * **Function Signature:** ```python def optimized_totients(m: int) -> List[int]: pass ``` * **Input:** * `m` (1 ≤ m ≤ 10^6): an integer for which the totient values from 1 to m need to be calculated. * **Output:** * A list of integers representing the totient values from 1 to m, i.e., the list should have m elements where the ith element is ϕ(i+1). * **Constraints:** * The solution should have a time complexity of O(m log log m) for efficient performance. * **Performance Requirements:** * Ensure that the solution is optimized and can handle the upper limit efficiently within the constraints. # Example * Input: `m = 10` * Output: `[1, 1, 2, 2, 4, 2, 6, 4, 6, 4]` * Explanation: The totient values are: * ϕ(1) = 1 * ϕ(2) = 1 * ϕ(3) = 2 * ϕ(4) = 2 * ϕ(5) = 4 * ϕ(6) = 2 * ϕ(7) = 6 * ϕ(8) = 4 * ϕ(9) = 6 * ϕ(10) = 4 # Hint Consider utilizing a sieve-like method similar to the Sieve of Eratosthenes for preprocessing the totient values up to m.","solution":"from typing import List def optimized_totients(m: int) -> List[int]: Returns a list of Euler\'s Totient values from 1 to m. # Initialize a list for totients with values equal to indices totients = list(range(m + 1)) # Implement the sieve-like approach to calculate Euler\'s Totient function for i in range(2, m + 1): if totients[i] == i: # i is a prime for j in range(i, m + 1, i): totients[j] = totients[j] * (i - 1) // i return totients[1:] # We ignore the value at index 0"},{"question":"Red-Black Tree Operations **Context**: A Red-Black tree provides a way to keep elements in a balanced binary search.tree A typical Red-Black tree has operations for insertion, deletion, and searching elements, which all run in O(log n) time due to the balanced nature of the tree. **Objective**: Implement a subset of operations and demonstrate understanding of handling properties and edge cases of Red-Black trees. Tasks 1. **Implement the `search` Operation**: - Write a function `search(self, val: int) -> Optional[RBNode]` in the `RBTree` class that finds a node with the given value. 2. **Implement the `validate` Operation**: - Write a function `validate(self) -> bool` in the `RBTree` class that checks whether the tree structurally adheres to Red-Black tree properties. - Assure that the root is black. - Ensure no two consecutive red nodes exist. - Bi-directionally validate the black height for all paths from the root to the leaves. **Function Signatures**: ```python class RBTree: # ... existing methods .. def search(self, val: int) -> Optional[RBNode]: pass def validate(self) -> bool: pass ``` Input and Output Formats - **search(self, val: int) -> Optional[RBNode]**: - **Input**: - `val` (int): The value to search in the Red-Black Tree. - **Output**: - Returns the `RBNode` containing the value or `None` if not found. - **validate(self) -> bool**: - **Output**: - Returns `True` if the tree is a valid Red-Black Tree, otherwise `False`. Constraints - Your solution should efficiently handle trees with up to 10,000 nodes. - Assume all values inserted are unique integers. Example ```python # Create a Red-Black Tree instance. rb_tree = RBTree() # Insert elements into the tree. for value in [20, 15, 25, 10, 18, 22, 30, 5, 12, 19]: rb_tree.insert(RBNode(value, 1)) # Perform a search operation. found_node = rb_tree.search(18) print(found_node.val if found_node else \\"Not Found\\") # Expected Output: 18 # Validate the Red-Black Tree. is_valid = rb_tree.validate() print(is_valid) # Expected Output: True ``` Note: Your implementation must correctly handle the specified tasks while maintaining the Red-Black tree properties and edge cases.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.nil = RBNode(0, 0) self.root = self.nil def search(self, val: int) -> RBNode: current = self.root while current != self.nil and current.val != val: if val < current.val: current = current.left else: current = current.right return current if current != self.nil else None def validate(self) -> bool: if self.root == self.nil: return True if self.root.color != 0: return False return (self._validate_properties(self.root) and self._validate_black_height(self.root) != -1) def _validate_properties(self, node): if node == self.nil: return True if node.color == 1: if node.left.color == 1 or node.right.color == 1: return False return (self._validate_properties(node.left) and self._validate_properties(node.right)) def _validate_black_height(self, node): if node == self.nil: return 1 left_black_height = self._validate_black_height(node.left) right_black_height = self._validate_black_height(node.right) if left_black_height == -1 or right_black_height == -1 or left_black_height != right_black_height: return -1 return left_black_height + (1 if node.color == 0 else 0)"},{"question":"You are given a binary tree struct/declaration as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your task is to implement a function that calculates the minimum depth of a binary tree. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. # Function Signature ```python def calculate_minimum_depth(root: TreeNode) -> int: pass ``` # Input: - `root`: TreeNode, the root of the binary tree. # Output: - Returns an integer representing the minimum depth of the binary tree. # Constraints: - The number of nodes in the tree is in the range `[0, 10000]`. - `-1000 <= Node.val <= 1000` # Performance Requirements: - Should handle the entire range of node counts efficiently. # Example: ```python # Example 1 node1 = TreeNode(3) node2 = TreeNode(9) node3 = TreeNode(20) node4 = TreeNode(15) node5 = TreeNode(7) node1.left = node2 node1.right = node3 node3.left = node4 node3.right = node5 assert calculate_minimum_depth(node1) == 2 # Example 2 node1 = TreeNode(1) assert calculate_minimum_depth(node1) == 1 # Example 3 node1 = TreeNode(2) node2 = TreeNode(3) node3 = TreeNode(4) node4 = TreeNode(5) node5 = TreeNode(6) node1.right = node2 node2.right = node3 node3.right = node4 node4.right = node5 assert calculate_minimum_depth(node1) == 5 ``` Implement the `calculate_minimum_depth` function to pass the provided examples and constraints, demonstrating a solid understanding of tree traversal methods and their complexities.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_minimum_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) # Queue for BFS, stores tuple (node, depth) while queue: node, depth = queue.popleft() # If this is a leaf node if not node.left and not node.right: return depth # Add children to queue if they exist if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Modular Exponentiation in Cryptography In cryptographic applications, efficient computation of large powers modulo a number is often required. One commonly used method is modular exponentiation using the Exponentiation by Squaring algorithm. Write a function `secure_modular_exponentiation(base: int, exponent: int, mod: int) -> int` to compute ( (base^{exponent}) % mod ). This function should handle large inputs efficiently by employing the Exponentiation by Squaring technique. Function Signature ```python def secure_modular_exponentiation(base: int, exponent: int, mod: int) -> int: ``` Input * `base` (integer): The base of the exponentiation. * `exponent` (integer): The exponent (must be non-negative). * `mod` (integer): The modulus (must be positive). Output * Returns an integer representing ( (base^{exponent}) % mod ). Constraints * `0 <= base <= 10^9` * `0 <= exponent <= 10^9` * `1 <= mod <= 10^9` Example ```python # Example 1: assert secure_modular_exponentiation(2, 5, 13) == 6 # Example 2: assert secure_modular_exponentiation(3, 10, 7) == 4 # Example 3: assert secure_modular_exponentiation(10, 0, 17) == 1 # Any number to the power of 0 is 1. ``` Note You need to handle the size efficiently, particularly given the large constraints for `base`, `exponent`, and `mod`. Your implementation should avoid overflow and ensure that intermediate results are always within the modulus.","solution":"def secure_modular_exponentiation(base: int, exponent: int, mod: int) -> int: Computes (base^exponent) % mod using the Exponentiation by Squaring method. result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: # If exponent is odd, multiply the base with result result = (result * base) % mod exponent = exponent >> 1 # Right shift exponent by 1 (divide by 2) base = (base * base) % mod # Square the base return result"},{"question":"You are given two implementations (`first_stutter` and `second_stutter`) that double every element in a stack by using a secondary stack or queue as auxiliary storage. For both implementations, the original stack is manipulated such that each element\'s value is doubled in place. Your task is to implement the function `optimized_stutter(stack)` that achieves the same result but with optimized performance in terms of time and/or space complexity. Function Signature: ```python def optimized_stutter(stack: list) -> list: pass ``` Input: - `stack`: A list of integers representing a stack, with the last element being the top of the stack. Output: - The original list modified such that each element in the stack has been replaced with two occurrences of that element. Constraints: - Do not use additional collections (like other stacks, queues) with O(n) space for auxiliary storage. - Aim for better or equal performance compared to the provided solutions. Examples: 1. Input: `[3, 7, 1, 14, 9]` Output: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` 2. Input: `[1, 2, 3]` Output: `[1, 1, 2, 2, 3, 3]` 3. Input: `[]` Output: `[]`","solution":"def optimized_stutter(stack: list) -> list: This function modifies the input \'stack\' such that each element is doubled in place. n = len(stack) index = 0 while index < 2 * n: stack.insert(index + 1, stack[index]) index += 2 return stack"},{"question":"# Segment Tree Implementation and Query **Objective**: Implement a Segment Tree data structure and demonstrate proficiency in range queries. # Description Given an array of integers, implement a Segment Tree to support efficient range queries using a custom aggregation function. # Requirements: 1. **Initialization**: - Constructor should accept the array and a function. - The function should accept two values and return a single value of the same type. 2. **Range Query**: - Method `query(L, R)` to return the aggregate value from index L to R (inclusive) using the provided function. # Example Function Implementations for Aggregation: - **Sum**: `lambda x, y: x + y` - **Maximum**: `lambda x, y: max(x, y)` # Input * The input consists of an array `arr` of integers. * A function `fn` to aggregate the values. * Multiple queries in the format `query(L, R)`. # Output * Each call to `query(L, R)` should return the aggregated value over the range from index L to R. # Constraints * 1 <= length of array <= 10^5 * 0 <= L <= R < length of array # Example ```python # Example usage arr = [2, 4, 5, 3, 4] fn = lambda x, y: max(x, y) my_tree = SegmentTree(arr, fn) # Queries result1 = my_tree.query(2, 4) # Expected output: 5 result2 = my_tree.query(0, 3) # Expected output: 5 ``` # Function Signature ```python class SegmentTree: def __init__(self, arr, function): # your code here def make_tree(self, i, l, r): # your code here def __query(self, i, L, R, l, r): # your code here def query(self, L, R): # your code here ```","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [None] * (4 * self.n) self.build(arr, 0, 0, self.n - 1) def build(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(arr, left_child, start, mid) self.build(arr, right_child, mid + 1, end) self.tree[node] = self.function(self.tree[left_child], self.tree[right_child]) def query_util(self, node, start, end, L, R): if start > R or end < L: return None if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_result = self.query_util(2 * node + 1, start, mid, L, R) right_result = self.query_util(2 * node + 2, mid + 1, end, L, R) if left_result is None: return right_result if right_result is None: return left_result return self.function(left_result, right_result) def query(self, L, R): return self.query_util(0, 0, self.n - 1, L, R)"},{"question":"# Binary Search Tree Predecessor Finder Scenario: You have been hired to implement a functionality in a database system that leverages a Binary Search Tree (BST) for efficient data management. The system needs to find the predecessor of a given node in a BST. Based on your implementation, other functionalities like batch-processing can run optimized queries on the tree. Problem Statement: Write a function `find_predecessor(root, node_val)` that takes a root of a Binary Search Tree and a target node value `node_val`. The function should return the value of the predecessor of the node with value `node_val`. The predecessor is defined as the largest value in the BST that is smaller than `node_val`. If no such predecessor exists, the function should return `None`. Function Signature: ```python def find_predecessor(root: TreeNode, node_val: int) -> int: ``` # Input: - `root`: The root of the BST, a TreeNode. - `node_val`: An integer representing the value of the target node. # Output: - If the predecessor exists, return the value of the predecessor as an integer. - If no predecessor exists, return `None`. # Constraints: - The number of nodes of the tree will be in the range [1, 10^4]. - The value of nodes will be unique and in the range [-10^4, 10^4]. # Example: ```python # Example 1 # 5 # / # 3 7 # / # 2 4 8 # # node_val = 7 # Predecessor is 5 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(8) assert find_predecessor(root, 7) == 5 # Example 2 # 5 # / # 3 7 # / # 2 4 8 # # node_val = 3 # Predecessor is 2 assert find_predecessor(root, 3) == 2 # Example 3 # 5 # / # 3 7 # / # 2 4 8 # # node_val = 2 # Predecessor is None assert find_predecessor(root, 2) == None ``` Hints: - Use an iterative approach to navigate through the BST. - Consider keeping track of the potential predecessor during the tree traversal.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_predecessor(root, node_val): Returns the predecessor of the node with value `node_val` in the BST. predecessor = None current = root while current: if node_val <= current.val: current = current.left else: predecessor = current.val current = current.right return predecessor"},{"question":"Implement an optimized prime-checking function and utilize it to filter out all prime numbers from a given list of integers. **Objective**: Write a function, `filter_primes(nums: List[int]) -> List[int]`, that utilizes an efficient algorithm to identify and return only the prime numbers from the input list. # Function Signature ```python def filter_primes(nums: List[int]) -> List[int]: pass ``` # Input * A list of integers: `nums` (1 ≤ len(nums) ≤ 10^5, -10^6 ≤ nums[i] ≤ 10^6) # Output * A list of integers containing only the prime numbers from the input list in the same order they were presented. # Constraints * Consider both positive and negative integers. * Negative integers and zero are not considered prime. * Needs to handle relatively large input sizes efficiently. # Example ```python filter_primes([2, 4, 5, -7, 11, 15, 23]) => [2, 5, 11, 23] filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9]) => [2, 3, 5, 7] ``` # Requirements * Ensure your implementation leverages an efficient prime-checking function. * The solution should aim for minimal time complexity, ideally O(n√m), where `n` is the length of the input list, and `m` is the average value of the numbers in the list.","solution":"from typing import List import math def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(math.sqrt(n)) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_primes(nums: List[int]) -> List[int]: return [num for num in nums if is_prime(num)]"},{"question":"# Bit Manipulation for IP Addressing You are working on a system that requires efficient manipulation of integer representations of IP addresses. An IP address can be represented as a 32-bit integer. You need to create a function that allows you to extract the first octet (8 bits) of an IP address represented as a 32-bit integer, set a specific bit in the address, clear a specific bit in the address, and update a specific bit in the address. Implement a class `IPAddressManipulator` with the following methods: * `get_octet(ip_address)`: Extracts and returns the first octet (8 bits) of the IP address. * `set_bit(ip_address, i)`: Sets the bit at index `i` in the IP address and returns the new IP address. * `clear_bit(ip_address, i)`: Clears the bit at index `i` in the IP address and returns the new IP address. * `update_bit(ip_address, i, bit)`: Updates the bit at index `i` to the value of `bit` (which should be 0 or 1) and returns the new IP address. # Method Definitions - **`get_octet(ip_address: int) -> int`**: - **Input**: A 32-bit integer representing the IP address. - **Output**: An integer representing the first octet (ranged from 0 to 255). - **`set_bit(ip_address: int, i: int) -> int`**: - **Input**: A 32-bit integer `ip_address`, and an integer `i` specifying the bit index. - **Output**: The new 32-bit integer after setting the `i-th` bit of `ip_address`. - **`clear_bit(ip_address: int, i: int) -> int`**: - **Input**: A 32-bit integer `ip_address`, and an integer `i` specifying the bit index. - **Output**: The new 32-bit integer after clearing the `i-th` bit of `ip_address`. - **`update_bit(ip_address: int, i: int, bit: int) -> int`**: - **Input**: A 32-bit integer `ip_address`, an integer `i` specifying the bit index, and an integer `bit` (0 or 1). - **Output**: The new 32-bit integer after updating the `i-th` bit of `ip_address` to `bit`. # Constraints 1. `0 <= i < 32` 2. `bit` can only be `0` or `1`. # Performance Requirements - The function calls should execute in constant time, O(1). # Example ```python manipulator = IPAddressManipulator() ip = manipulator.set_bit(0b11000000101010000000000100000001, 9) first_octet = manipulator.get_octet(ip) new_ip = manipulator.clear_bit(ip, 31) updated_ip = manipulator.update_bit(new_ip, 7, 1) print(bin(ip)) # Output: \'0b11000000101010000000000100100001\' print(first_octet) # Output: 192 print(bin(new_ip)) # Output: \'0b1000000101010000000000100100001\' print(bin(updated_ip)) # Output: \'0b1000000101010000000001100100001\' ```","solution":"class IPAddressManipulator: @staticmethod def get_octet(ip_address: int) -> int: Extracts and returns the first octet (8 bits) of the IP address. return (ip_address >> 24) & 0xFF @staticmethod def set_bit(ip_address: int, i: int) -> int: Sets the bit at index i in the IP address. return ip_address | (1 << i) @staticmethod def clear_bit(ip_address: int, i: int) -> int: Clears the bit at index i in the IP address. return ip_address & ~(1 << i) @staticmethod def update_bit(ip_address: int, i: int, bit: int) -> int: Updates the bit at index i to the value of bit (which should be 0 or 1). mask = ~(1 << i) return (ip_address & mask) | (bit << i)"},{"question":"# Special Number Finder You are tasked with writing a function that finds all numbers within a specified range which satisfy the following property: the sum of each digit raised to the power of its position (starting from 1) equals the number itself. Function Signature ```python def special_numbers(low: int, high: int) -> List[int]: pass ``` Input - **low (int)**: The starting range (inclusive). - **high (int)**: The ending range (inclusive). Output - **List[int]**: A list of numbers within the range that satisfy the given property. Constraints - 1 ≤ low ≤ high ≤ 10000 Example ```python assert special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert special_numbers(1, 150) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` Notes - Ensure your solution is efficient enough to handle the upper range limit within reasonable time. - Handle edge cases where the range is very small or all numbers within the range do not satisfy the property.","solution":"from typing import List def special_numbers(low: int, high: int) -> List[int]: def is_special_number(number: int) -> bool: str_num = str(number) total = sum(int(digit) ** (index + 1) for index, digit in enumerate(str_num)) return total == number return [num for num in range(low, high + 1) if is_special_number(num)]"},{"question":"You are given a pattern and a string. Write a function to determine if the string follows the same pattern. The pattern and the string will follow these constraints: 1. Pattern includes only lowercase letters. 2. String includes only lowercase words separated by a single space. **Objective**: Create a function `word_pattern(pattern: str, s: str) -> bool` that returns `true` if the string `s` follows the same pattern as `pattern`, and `false` otherwise. # Input * `pattern`: A string containing only lowercase letters. * `s`: A string containing only lowercase words separated by a single space. # Output * Return `true` if `s` follows the `pattern`, `false` otherwise. # Examples Example 1: ```python Input: pattern = \\"abba\\", s = \\"dog cat cat dog\\" Output: true ``` Example 2: ```python Input: pattern = \\"abba\\", s = \\"dog cat cat fish\\" Output: false ``` Example 3: ```python Input: pattern = \\"aaaa\\", s = \\"dog cat cat dog\\" Output: false ``` Example 4: ```python Input: pattern = \\"abba\\", s = \\"dog dog dog dog\\" Output: false ``` # Constraints * The length of `pattern` will be in the range [1, 500]. * The length of `s` will be in the range [1, 3000]. # Guidelines - Ensure that your implementation handles edge cases, such as different lengths of pattern and words in the string. - Aim for an efficient solution with minimal time and space complexity while maintaining clarity. ```python def word_pattern(pattern: str, s: str) -> bool: # Your implementation here ```","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p not in pattern_to_word: pattern_to_word[p] = w if w not in word_to_pattern: word_to_pattern[w] = p if pattern_to_word[p] != w or word_to_pattern[w] != p: return False return True"},{"question":"# Next Lexicographical Permutation Challenge **Objective**: Implement a function that determines the next higher permutation of a given integer using the same set of digits. **Context**: Consider you have a lock system that can be set using a specific permutation of a given sequence of digits. If you need to find the next higher permutation to reset your lock, this function will help you identify it quickly. **Function Specification**: ```python def next_bigger(num: int) -> int: Given a number, returns the next higher number which has the exact same set of digits as the original number. If no such number exists, returns -1. ``` **Input and Output**: * **Input**: A non-negative integer `num`. * **Output**: An integer representing the next higher permutation. If no such permutation exists, return -1. **Constraints**: * `0 ≤ num ≤ 10^9` **Examples**: 1. `next_bigger(38276)` should return `38627` 2. `next_bigger(12345)` should return `12354` 3. `next_bigger(99999)` should return `-1` 4. `next_bigger(5)` should return `-1` **Notes**: - The function should handle edge cases such as when all digits are in descending order or when provided with a single digit. - Performance needs to be optimized, avoiding unnecessary computations. **Implementation Approach**: 1. Traverse the number from the end and find the first decreasing digit. 2. If such a digit is found, find the smallest digit larger than this digit to its right. 3. Swap these two digits. 4. Reverse the sequence of digits to the right of the original position of the first decreasing digit. **Scenario**: Imagine you are working on a feature for an electronic locker system where the next permutation unlocks enhanced features. This function will significantly reduce the computation time for setting the next lock permutation, providing a crucial performance boost to your application. Implement the `next_bigger` function in Python to reflect the above requirements and conditions.","solution":"def next_bigger(num: int) -> int: num_list = list(str(num)) n = len(num_list) # Step 1: Find the first decreasing element from the end i = n - 2 while i >= 0 and num_list[i] >= num_list[i + 1]: i -= 1 # If no such element exists, the digits are in descending order if i == -1: return -1 # Step 2: Find the smallest element larger than num_list[i] from the right part j = n - 1 while num_list[j] <= num_list[i]: j -= 1 # Step 3: Swap these two elements num_list[i], num_list[j] = num_list[j], num_list[i] # Step 4: Reverse the part of the list after the initial decrease point num_list = num_list[:i+1] + num_list[i+1:][::-1] # Convert list back to integer next_bigger_num = int(\'\'.join(num_list)) return next_bigger_num"},{"question":"Enhanced Sorting Context You have been tasked to enhance and implement a variation of a basic sorting algorithm known as Exchange Sort. Your version should optimize the number of comparisons and swaps by stopping early if the list becomes sorted before finishing all iterations. Task Write a function `enhanced_exchange_sort(arr)` that sorts an input list of integers in ascending order using an optimized version of Exchange Sort. Your implementation should take advantage of an early stopping condition if the list is already sorted in between iterations. Function Signature ```python def enhanced_exchange_sort(arr: list[int]) -> list[int]: pass ``` Input - `arr`: A list of integers with up to 10^4 elements. Elements may be positive, negative, or zero. Output - A new list of integers sorted in ascending order. Constraints - Perform the sorting in-place with O(1) additional space complexity. - Aim to minimize the time complexity by stopping the sorting process early when possible. Example ```python # Example 1 input: [64, 34, 25, 12, 22, 11, 90] output: [11, 12, 22, 25, 34, 64, 90] # Example 2 input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] # Example 3 input: [] output: [] ``` Notes - Your function should handle edge cases such as empty lists and lists with a single element efficiently. - Ensure that your solution maintains O(n^2) performance in the worst case but attempts to improve efficiency with the early stopping condition.","solution":"def enhanced_exchange_sort(arr: list[int]) -> list[int]: Sorts an input list of integers in ascending order using an optimized version of Exchange Sort. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: # If no two elements were swapped by inner loop, then break break return arr"},{"question":"# Linked List Intersection Scenario: Consider you are working with a transportation system where various routes intersect at certain key points (nodes). Your task is to identify these intersection points efficiently. Problem Statement: Given two singly linked lists, write a function `find_intersection(head1: Node, head2: Node) -> Optional[Node]` that identifies and returns the first intersecting node of the two lists, if any. Function Signature: ```python def find_intersection(head1: Node, head2: Node) -> Optional[Node]: pass ``` Input: * `head1` and `head2`: Pointers to the heads of the two singly linked lists. Output: * Returns the node at which the two linked lists intersect, or `None` if there is no intersection. Example: ```python # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f print(find_intersection(a1, a2).val) # should return 7 ``` Constraints: 1. Assume that there are no cycles in the linked lists. 2. The linked lists retain their original structure after the function is called. 3. The function should aim for an O(N+M) time complexity. Notes: The students should consider edge cases such as empty lists, non-intersecting lists, and lists where the intersection is at the head node.","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: Find the intersection point of two singly linked lists. if not head1 or not head2: return None # Get the lengths of the two lists def get_length(head: Node) -> int: length = 0 while head: length += 1 head = head.next return length length1 = get_length(head1) length2 = get_length(head2) # Align the heads of both lists so that they can be traversed together while length1 > length2: head1 = head1.next length1 -= 1 while length2 > length1: head2 = head2.next length2 -= 1 # Traverse both lists together to find the intersection point while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"String Rotation Detection **Problem Statement**: Given two strings, `original` and `potential`, write a function `is_rotated_version` which determines if `potential` is a rotation of `original`. For example, \\"abc\\" and \\"cab\\" are rotations of each other, but \\"abc\\" and \\"acb\\" are not. ```python def is_rotated_version(original: str, potential: str) -> bool: pass ``` **Input**: - `original` (a string): The original string. - `potential` (a string): The string to check if it is a rotation of the original. **Output**: - A boolean value: True if `potential` is a rotation of `original`, False otherwise. **Examples**: ```python assert is_rotated_version(\\"hello\\", \\"llohe\\") == True assert is_rotated_version(\\"hello\\", \\"olleh\\") == False assert is_rotated_version(\\"abc\\", \\"cab\\") == True assert is_rotated_version(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotated_version(\\"rotation\\", \\"tationro\\") == True assert is_rotated_version(\\"abcd\\", \\"dabc\\") == True assert is_rotated_version(\\"abcd\\", \\"acdb\\") == False ``` **Constraints**: - Do not assume any properties about the character set of the input strings. - You should optimize for both time and space complexity given the problem constraints. **Evaluation**: - The function should handle edge cases effectively, including empty strings and strings of varying lengths. - Efficient handling is especially necessary for large strings. **Hints**: 1. Consider utilizing the properties of string concatenation to create a straightforward solution. 2. Remember to check the lengths of the strings early to avoid unnecessary computation.","solution":"def is_rotated_version(original: str, potential: str) -> bool: Determines if potential is a rotation of original. if len(original) != len(potential): return False concatenated = original + original return potential in concatenated"},{"question":"**Scenario**: You are tasked with writing a function that processes a linked list, where the sorting order matters for data operations downstream. Specifically, the function should swap every two adjacent nodes in a linked list, reflecting a common data shuffling task required for specific operational contexts. # Problem Statement: Write a function `swap_pairs` that takes the head of a linked list and swaps every two adjacent nodes, returning the head of the modified list. Function Signature: ```python def swap_pairs(head: Node) -> Node: ``` # Input: * `head`: the head of a singly linked list of integers. # Output: * The head of the new linked list after pair-wise node swapping. # Constraints: * The function should operate in O(n) time complexity, where n is the number of nodes in the linked list. * The function must use O(1) extra space. * Node values cannot be modified, only the nodes can be re-linked. * The linked list is not empty and contains at least one node. # Example: ```python # Example 1: Input: 1 -> 2 -> 3 -> 4 Output: 2 -> 1 -> 4 -> 3 # Example 2: Input: 1 -> 2 -> 3 Output: 2 -> 1 -> 3 # Example 3: Input: 1 Output: 1 ``` # Notes: 1. Implement all necessary helper classes and functions. 2. Ensure your code handles edge cases, such as lists with an odd number of nodes.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def swap_pairs(head: Node) -> Node: if not head or not head.next: return head # Initialize a dummy node to help with edge cases dummy = Node(0) dummy.next = head prev = dummy current = head while current and current.next: # Nodes to be swapped first = current second = current.next # Swapping prev.next = second first.next = second.next second.next = first # Move pointers forward prev = first current = first.next return dummy.next # Helper function to convert list to linked list def list_to_linked_list(elements): if not elements: return None head = Node(elements[0]) current = head for element in elements[1:]: current.next = Node(element) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): elements = [] current = head while current: elements.append(current.value) current = current.next return elements"},{"question":"Problem Statement You have been given an array of integers where every element appears an even number of times, except for one element which appears an odd number of times. Write a function `find_odd_occurrence` to identify and return this element. Your solution should have a linear time complexity and should not use extra memory beyond a few constant storage variables (i.e., optimize for O(1) space complexity). # Function Signature ```python def find_odd_occurrence(nums: List[int]) -> int: This function should return the single integer that appears an odd number of times. :param nums: List[int] - a list of integers where each integer except one appears an even number of times. :return: int - the integer that appears an odd number of times. pass ``` # Input - `nums`: List of integers, where it\'s guaranteed that exactly one element occurs an odd number of times while all others occur an even number of times. # Output - An integer representing the element that occurs an odd number of times. # Constraints - All integers in the array fit within the standard 32-bit integer range. - The length of the array is between 1 and 10^6. # Example ```python print(find_odd_occurrence([2, 3, 2, 4, 4, 2, 2])) # Output: 3 print(find_odd_occurrence([10, 20, 20, 30, 10, 30, 10])) # Output: 10 print(find_odd_occurrence([7])) # Output: 7 ``` # Notes - Leverage the properties of the XOR operation to achieve the desired linear runtime and constant space complexity. - Focus on edge cases like an empty array or an array with a single element.","solution":"from typing import List def find_odd_occurrence(nums: List[int]) -> int: This function returns the single integer that appears an odd number of times. :param nums: List[int] - a list of integers where each integer except one appears an even number of times. :return: int - the integer that appears an odd number of times. result = 0 for num in nums: result ^= num return result"},{"question":"# Histogram Construction You are tasked with implementing a function that takes a list of numbers and returns the histogram of the list as a dictionary. A histogram is a representation of the distribution of numerical data, often used to estimate the probability distribution of a continuous variable. Implement the function `calculate_histogram` that computes this histogram. Function Signature ```python def calculate_histogram(input_list: list) -> dict: ``` Input * `input_list` (list): A list of integers (can be empty). Output * (dict): A dictionary where each key is a unique integer from the input list, and each value is the count of occurrences of that integer. Constraints * The elements of the list will always be integers. * The list can have up to 10^5 elements. Example 1. For the input `[3, 3, 2, 1]`, the function should return `{1: 1, 2: 1, 3: 2}`. 2. For the input `[2, 3, 5, 5, 5, 6, 4, 3, 7]`, the function should return `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}`. 3. For the input `[]`, the function should return `{}`. Edge Cases 1. An empty list should return an empty dictionary. 2. Lists with all identical elements should properly calculate the frequency of that element. Implement the function `calculate_histogram` according to the specified requirements and make sure to thoroughly test it with edge cases and large data sets.","solution":"def calculate_histogram(input_list: list) -> dict: Returns the histogram of the input list as a dictionary where keys are unique numbers and values are their respective counts. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"Implement Advanced Min Heap Operations Background: You have learned about the basic operations of a Min Heap such as insertion and removal. Now, it\'s time to extend your understanding by implementing some advanced operations, which will help you further explore the capabilities of a Min Heap and how to handle specific scenarios. Task: You are required to extend the `BinaryHeap` class by implementing the following advanced operations: 1. **peek_min()**: Fetch the minimum element without removing it from the heap. 2. **heapify(arr)**: Given an array, transform it into a valid binary min heap. Specifications: 1. **peek_min()**: - **Input**: None - **Output**: Return the smallest element in the heap without removing it. - **Constraints**: If the heap is empty, return `None`. 2. **heapify(arr)**: - **Input**: A list of integers `arr` - **Output**: None. Transform the internal representation of the heap to hold the elements of `arr` such that it forms a valid min heap. - **Constraints**: The array might contain up to 10^5 elements. These operations should maintain the integrity and properties of a min heap. Example Usage: ```python # Creating an instance of BinaryHeap heap = BinaryHeap() # heapify operation arr = [10, 20, 15, 30, 40] heap.heapify(arr) print(heap.heap) # Should output the array form of a valid min heap # peek_min operation min_val = heap.peek_min() print(min_val) # Should print the minimum value in the heap ``` Implementation: Complete the following class with the specified methods: ```python class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] # Existing methods: perc_up, insert, min_child, perc_down, remove_min def peek_min(self): # Your implementation here pass def heapify(self, arr): # Your implementation here pass ```","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: tmp = self.heap[i // 2] self.heap[i // 2] = self.heap[i] self.heap[i] = tmp i = i // 2 def insert(self, k): self.heap.append(k) self.current_size = self.current_size + 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: tmp = self.heap[i] self.heap[i] = self.heap[mc] self.heap[mc] = tmp i = mc def remove_min(self): retval = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size = self.current_size - 1 self.heap.pop() self.perc_down(1) return retval def peek_min(self): if self.current_size == 0: return None return self.heap[1] def heapify(self, arr): self.current_size = len(arr) self.heap = [0] + arr[:] i = len(arr) // 2 while i > 0: self.perc_down(i) i = i - 1"},{"question":"Problem Statement You are tasked with writing a function that, given a string as input, deletes any reoccurring characters and returns a new string. The order of characters in the new string should be the same as their first appearance in the input string. # Input - A single string `s` (1 <= len(s) <= 10^6), possibly containing special characters and spaces. # Output - A single string with all consecutive reoccurring characters removed. # Constraints - The function should maintain the order of characters as they first appear in the given string. - You should aim to achieve a time complexity of O(n) and space complexity of O(n). # Examples ```python assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"hello\\") == \\"helo\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" assert delete_reoccurring_characters(\\"abcdef\\") == \\"abcdef\\" assert delete_reoccurring_characters(\\"aabccddeeff\\") == \\"abcdef\\" ``` # Requirements - Implement the function in Python: ```python def delete_reoccurring_characters(s: str) -> str: # Your code here ``` # Additional Notes Think about possible edge cases, such as: - Input with all characters being unique. - Input being an empty string. - String containing numbers and special characters.","solution":"def delete_reoccurring_characters(s: str) -> str: Removes all reoccurring characters from the input string preserving the order of their first appearance. :param s: Input string :return: String with reoccurring characters removed seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**String Reversal Challenge** In this task, you are asked to implement a string reversal function in Python without using any of the built-in Python methods that directly reverse strings. You can choose to implement the function either iteratively or recursively. # Function Signature ```python def reverse_string(s: str) -> str: Reverse the input string without using built-in Python methods like reversed() or slicing. Args: s (str): Input string Returns: str: Reversed string ``` # Input * A single string `s` with a length `n` where (0 leq n leq 1000). # Output * The reversed string. # Constraints * The function should handle strings containing letters (both uppercase and lowercase), numbers, spaces, and punctuation. * Avoid using Python built-in methods like `reversed()` and slicing `[::-1]` to reverse the string. * Your implementation must handle the case where `s` is an empty string or has only one character. # Examples ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"Python is fun!\\") == \\"!nuf si nohtyP\\" assert reverse_string(\\"A\\") == \\"A\\" assert reverse_string(\\"\\") == \\"\\" ``` # Notes * Implement an efficient solution with a clear performance advantage for larger strings. * Consider edge cases such as strings of length 1 or empty strings.","solution":"def reverse_string(s: str) -> str: Reverse the input string without using built-in Python methods like reversed() or slicing. Args: s (str): Input string Returns: str: Reversed string result = [] for char in s: result.insert(0, char) return \'\'.join(result)"},{"question":"# Matrix Transformation Functions You are given a square matrix represented as a list of lists in Python. Your task is to implement the following transformation functions: 1. **rotate_clockwise(matrix)**: Rotates the matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotates the matrix 90 degrees counterclockwise. 3. **bottom_left_invert(matrix)**: Inverts the matrix 180 degrees. Input * `matrix`: A list of lists where `matrix[i][j]` represents the element in the ith row and jth column of the matrix. The input matrix is always a square matrix (e.g., 2x2, 3x3). Output Each function must return a new matrix after performing the required transformation. Constraint * The dimension of the matrix (n x n) (1 ≤ n ≤ 100). # Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] bottom_left_invert(matrix) # Output: # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ``` # Implementation Requirements 1. Your implementations should be efficient in terms of time and space complexity. 2. Handle matrix indexing without using try-except blocks for index validation. 3. Ensure correct handling of empty matrices. Provide the implementation of these functions in Python.","solution":"def rotate_clockwise(matrix): n = len(matrix) return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): n = len(matrix) return [[matrix[j][n - 1 - i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix): n = len(matrix) return [[matrix[n - 1 - i][n - 1 - j] for j in range(n)] for i in range(n)]"},{"question":"# Question: Clone an Undirected Graph Given an undirected graph, write a function to clone the graph. Each node in the graph contains a unique label and a list of its neighbors. You need to implement the function `clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode` that returns a deep copy of the graph starting from the given node. **Parameters:** - `node`: a reference to the starting node of the graph. **Returns:** - A deep copy of the graph starting from the given node. # Input Format * A serialized graph string `graph_str`. - Nodes are labeled uniquely. - Use `#` as a separator for each node, and `,` as a separator for node label and each neighbor of the node. # Output Format * A serialized graph string representation of the cloned graph. # Constraints * The number of nodes in the graph is in the range `[0, 100]`. * Node values are unique integers within the range `[0, 100]`. # Example ```plaintext Input: \\"0,1,2#1,2#2,2\\" Output: \\"0,1,2#1,2#2,2\\" ``` The graph represents: ``` 1 / / 0 --- 2 / _/ ``` # Instructions 1. Parse the `graph_str` to create the graph. 2. Implement the `clone_graph` function using either BFS or DFS. 3. Serialize the cloned graph back to a string format. 4. Return the serialized string of the cloned graph. # Solution Template ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) def clone_graph(node): def dfs(node, dic): for neighbor in node.neighbors: if neighbor not in dic: neighbor_copy = neighbor.shallow_copy() dic[neighbor] = neighbor_copy dic[node].add_neighbor(neighbor_copy) dfs(neighbor, dic) else: dic[node].add_neighbor(dic[neighbor]) if not node: return None node_copy = node.shallow_copy() dic = {node: node_copy} dfs(node, dic) return node_copy # Add additional helper functions to parse and serialize graph strings here. # Main function to parse the input, call clone_graph and return the serialized result. def clone_undirected_graph(graph_str): # Parsing graph_str to create nodes and edges. # Implement graph serialization here. pass ```","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) def clone_graph(node): def dfs(node, dic): for neighbor in node.neighbors: if neighbor not in dic: neighbor_copy = neighbor.shallow_copy() dic[neighbor] = neighbor_copy dic[node].add_neighbor(neighbor_copy) dfs(neighbor, dic) else: dic[node].add_neighbor(dic[neighbor]) if not node: return None node_copy = node.shallow_copy() dic = {node: node_copy} dfs(node, dic) return node_copy def parse_graph(graph_str): if not graph_str: return None node_dict = {} nodes = graph_str.split(\'#\') for node_info in nodes: parts = node_info.split(\',\') node_label = int(parts[0]) if node_label not in node_dict: node_dict[node_label] = UndirectedGraphNode(node_label) for neighbor_label in parts[1:]: neighbor_label = int(neighbor_label) if neighbor_label not in node_dict: node_dict[neighbor_label] = UndirectedGraphNode(neighbor_label) node_dict[node_label].add_neighbor(node_dict[neighbor_label]) return node_dict[int(nodes[0].split(\',\')[0])] def serialize_graph(node): if not node: return \\"\\" visited = set() node_list = [] def bfs(node): queue = [node] visited.add(node) while queue: current = queue.pop(0) node_repr = [str(current.label)] for neighbor in current.neighbors: node_repr.append(str(neighbor.label)) if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) node_list.append(\',\'.join(node_repr)) bfs(node) return \'#\'.join(node_list) def clone_undirected_graph(graph_str): original_node = parse_graph(graph_str) cloned_node = clone_graph(original_node) return serialize_graph(cloned_node)"},{"question":"# Question **Matrix Inversion Function** Given the task of inverting an n x n matrix, write a Python function `invert_matrix(matrix)` that inverts a given matrix. The input matrix is a list of lists, where each sub-list represents a row of the matrix. If the given matrix is invalid (not a square matrix, singular, too small, or improperly formatted), the function should return appropriate error codes as specified: - [[-1]]: If the matrix is not an array or poorly formatted. - [[-2]]: If the matrix is not a square matrix. - [[-3]]: If the matrix is too small to invert (size ( < 2 )). - [[-4]]: If the matrix is singular (determinant is zero). **Function Signature**: ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` # Input * `matrix`: A list of lists (2D list) where each sub-list represents a row of the matrix. Each element in the sub-list is a floating-point number. # Output * A list of lists representing the inverted matrix if the matrix is invertible. # Constraints * The matrix will have dimensions ( n times n ) where ( 2 leq n leq 10 ). * The values in the matrix will be floating-point numbers. # Example Example 1 Input: ```python matrix = [ [2, 5], [1, 3] ] invert_matrix(matrix) ``` Output: ```python [ [3.0, -5.0], [-1.0, 2.0] ] ``` Example 2 Input: ```python matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] invert_matrix(matrix) ``` Output: ```python [ [-24.0, 18.0, 5.0], [ 20.0, -15.0, -4.0], [ -5.0, 4.0, 1.0] ] ``` # Note * Ensure numerical stability and handle floating-point precision issues in your implementation. * You can take advantage of any helper functions that you deem necessary to complete your solution.","solution":"import numpy as np def invert_matrix(matrix): Inverts a given n x n matrix. Parameters: matrix (list of lists): The input matrix to invert. Returns: list of lists: The inverted matrix or appropriate error code. try: # Check if the matrix is not a list or poorly formatted if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] # Check if the matrix is square if any(len(row) != len(matrix) for row in matrix): return [[-2]] n = len(matrix) # Check if the matrix is too small to invert if n < 2: return [[-3]] # Convert list of lists to numpy array for easier manipulation np_matrix = np.array(matrix, dtype=float) # Check if the matrix is singular (determinant is zero) if np.linalg.det(np_matrix) == 0: return [[-4]] # Compute the inverse of the matrix inv_matrix = np.linalg.inv(np_matrix) # Convert numpy array back to list of lists inv_matrix_list = inv_matrix.tolist() return inv_matrix_list except Exception: return [[-1]]"},{"question":"As a software engineer, you are required to implement a library function for efficient power calculations. The function must compute the power `a^n` efficiently and support an optional modulus operation to avoid overflow and reduce the result size. Implement the function in two different ways: 1. Using an **iterative approach**. 2. Using a **recursive approach**. # Function Signature ```python def power_iterative(a: int, n: int, mod: int = None) -> int: pass def power_recursive(a: int, n: int, mod: int = None) -> int: pass ``` # Input - `a` (int): The base number (1 ≤ |a| ≤ 10^9) - `n` (int): The exponent (0 ≤ n ≤ 10^9) - `mod` (int, optional): The modulus (1 ≤ mod ≤ 10^9) # Output - Both functions should return the computed power `a^n` optionally reduced by the modulus `mod` (if provided). # Constraints - Handle edge cases such as `n = 0` and modulus conditions properly. - Ensure these functions are optimized for both time and space. - Provide thorough comments and documentation within your code, explaining your logic and handling of edge cases. # Performance Requirements - Ensure that the time complexity of your solutions is O(log n). - The iterative implementation should have a space complexity of O(1). - The recursive implementation should have a space complexity of O(log n). # Example Scenarios **Example 1:** - `power_iterative(2, 10)` should return `1024` - `power_recursive(2, 10)` should return `1024` **Example 2:** - `power_iterative(2, 10, 1000)` should return `24` - `power_recursive(2, 10, 1000)` should return `24` # Additional Notes Test your implementations thoroughly against edge cases including large inputs and ensure they perform within the required constraints efficiently.","solution":"def power_iterative(a: int, n: int, mod: int = None) -> int: Computes the power a^n using an iterative approach. Optionally reduces the result by modulus \'mod\' if provided. result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result % mod if mod is not None else result def power_recursive(a: int, n: int, mod: int = None) -> int: Computes the power a^n using a recursive approach. Optionally reduces the result by modulus \'mod\' if provided. if n == 0: return 1 half_power = power_recursive(a, n // 2, mod) result = half_power * half_power if n % 2 == 1: result = result * a if mod is not None: result %= mod return result"},{"question":"Alternating Bits Verification Context: Bob is working on a project that involves processing binary streams. He\'s particularly interested in ensuring that certain binary numbers have an alternating bit pattern (0s and 1s alternating without exception). To automate this, he needs a program to check if a given integer meets this requirement. Problem Statement: Write a function `has_alternating_bits(n: int) -> bool` that takes a single positive integer `n` as an input and returns `True` if the integer\'s binary representation consists of alternating bits (either 1010... or 0101...), and `False` otherwise. Input: * A single integer `n` (1 ≤ n ≤ 10^9). Output: * A boolean value `True` if the binary representation of `n` has alternating bits, `False` otherwise. Constraints: * Your solution should aim to be efficient with a complexity consideration depending on the imposed constraints. * The function must handle edge cases properly. Examples: 1. `has_alternating_bits(5)` should return `True` because the binary form of 5 is `101`. 2. `has_alternating_bits(7)` should return `False` because the binary form of 7 is `111`. 3. `has_alternating_bits(11)` should return `False` because the binary form of 11 is `1011`. 4. `has_alternating_bits(10)` should return `True` because the binary form of 10 is `1010`. Note: Optimize the function for performance if possible, considering that up to 1 billion operations might be needed. You are encouraged to implement a solution using both bitwise iterative approach, as well as with pattern matching through masks, and note which performs better.","solution":"def has_alternating_bits(n: int) -> bool: Returns True if the binary representation of n has alternating bits, False otherwise. last_bit = n & 1 n >>= 1 # Shift right by 1 while n > 0: current_bit = n & 1 if current_bit == last_bit: return False # If two consecutive bits are the same last_bit = current_bit n >>= 1 # Shift right by 1 return True"},{"question":"# Flatten Nested Arrays You are tasked with implementing a function to flatten nested arrays. Given an input list that can contain nested lists to any depth, your function should return a new list containing all the elements in a flattened structure. Function Signature ```python def flatten_array(input_list: list) -> list: pass ``` # Input - `input_list`: A list which can contain nested lists, non-list elements (such as integers, strings), and may be empty. # Output - A single flat list containing all elements from the nested structures in the original order. # Constraints - Non-list elements in the input can include integers and strings. - The strings within the nested lists should be left intact (i.e., they should not be flattened character by character). # Example ```python # Example 1 input_list = [1, [2, 3], [4, [5, 6]], 7] print(flatten_array(input_list)) # Output: [1, 2, 3, 4, 5, 6, 7] # Example 2 input_list = [\'a\', [\'b\', \'c\'], [[\'d\'], [\'e\', [\'f\']]], \'g\'] print(flatten_array(input_list)) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\'] ``` # Performance Requirements - Your solution should efficiently handle deeply nested structures. - Aim for O(n) time complexity and O(n) space complexity, where n is the total number of elements in the array. # Test Cases 1. `input_list = []` should return `[]`. 2. `input_list = [1, 2, 3]` should return `[1, 2, 3]`. 3. `input_list = [[\'a\', \'b\', [\'c\']]]` should return `[\'a\', \'b\', \'c\']`. 4. `input_list = [[], [[]], [[[]]]]` should return `[]`. Implement the function `flatten_array` using the guidelines above.","solution":"def flatten_array(input_list: list) -> list: def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(input_list))"},{"question":"Problem: Implement a DAG (Directed Acyclic Graph) Checker # Introduction Given the provided `DirectedGraph` class structure, you are required to add a method to determine if the graph is a Directed Acyclic Graph (DAG). A Directed Acyclic Graph is a graph with directed edges and no cycles. # Task Implement a method `is_dag()` in the `DirectedGraph` class that returns whether the graph is a DAG. # Input - The graph represented using the `DirectedGraph` class. # Output - `True` if the graph is a Directed Acyclic Graph. - `False` otherwise. # Constraints - The graph will have no more than 1000 nodes. - Each node name is a unique string of length up to 10 characters. # Example ```python load_dict = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } graph = DirectedGraph(load_dict) print(graph.is_dag()) # Output: True load_dict = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } graph = DirectedGraph(load_dict) print(graph.is_dag()) # Output: False ``` # Notes - You are allowed to use additional methods within the `DirectedGraph` class to help implement `is_dag`. - Consider depth-first search (DFS) for detecting cycles in the graph.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.graph = adjacency_list def is_dag(self): Checks if the graph is a Directed Acyclic Graph (DAG). visited = set() rec_stack = set() def dfs(v): visited.add(v) rec_stack.add(v) for neighbor in self.graph.get(v, []): if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for node in self.graph: if node not in visited: if dfs(node): return False return True"},{"question":"# Problem Context You are working as a software developer for a company that processes hierarchical data structures. One of your tasks is to develop a function that helps in verifying if a particular structure is part of a larger dataset. The dataset is modeled as binary trees. # Problem Statement Given two binary trees `source` and `target`, determine if `target` is a subtree of `source`. A binary tree `target` is a subtree of `source` if there exists a node in `source` such that the subtree of this node is identical to `target`. # Function Signature ```python def is_subtree(source: Optional[TreeNode], target: Optional[TreeNode]) -> bool: ``` # Input * `source`: The root node of the larger binary tree (type `Optional[TreeNode]`). * `target`: The root node of the smaller binary tree (type `Optional[TreeNode]`). # Output * Return `True` if `target` is a subtree of `source`, `False` otherwise. # Example ```python # Example 1 source = TreeNode(3, TreeNode(4, TreeNode(1), TreeNode(2)), TreeNode(5)) target = TreeNode(4, TreeNode(1), TreeNode(2)) print(is_subtree(source, target)) # Output: True # Example 2 source = TreeNode(3, TreeNode(4, TreeNode(1), TreeNode(2, TreeNode(0))), TreeNode(5)) target = TreeNode(4, TreeNode(1), TreeNode(2)) print(is_subtree(source, target)) # Output: False ``` # Constraints * The number of nodes in the `source` tree is `m`. * The number of nodes in the `target` tree is `n`. * 1 <= n <= m <= 1000 * Tree node values are integers and can be negative. # Notes * The provided TreeNode class and the example usage: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Performance Requirements * The solution should handle cases where one tree is significantly larger than the other efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(source: TreeNode, target: TreeNode) -> bool: if not target: return True if not source: return False def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) if is_same_tree(source, target): return True return is_subtree(source.left, target) or is_subtree(source.right, target)"},{"question":"# Task You are required to extend the functionality of the `ArrayStack` class to include a `min()` function that returns the minimum element in the stack in constant time O(1). You must implement both methods and ensure that they interact correctly with the existing stack operations. # Requirements 1. Implement the `min()` function in the `ArrayStack` class. 2. Modify the `push(value)` and `pop()` methods to maintain the correct minimum value of the stack at any point. 3. Follow the given function signatures: ```python def min(self): pass def push(self, value): pass def pop(self): pass ``` # Constraints * The stack values will always be integers. * You may assume the stack will not exceed memory limits. * The stack will never be empty when `min()` is called, so you do not need to handle an empty stack in `min()`. * The `pop()` method should raise an `IndexError` with the message \\"Stack is empty\\" if attempted on an empty stack. * Likewise, the `peek()` method should raise an `IndexError` with the message \\"Stack is empty\\" if attempted on an empty stack. # Example ```python stack = ArrayStack() stack.push(3) stack.push(5) print(stack.min()) # Output: 3 stack.push(2) stack.push(1) print(stack.min()) # Output: 1 stack.pop() print(stack.min()) # Output: 2 ``` Implement the modified `ArrayStack` class that satisfies the above requirements.","solution":"class ArrayStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Stack is empty\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def min(self): if not self.min_stack: raise IndexError(\\"Min stack is empty\\") return self.min_stack[-1] def peek(self): if not self.stack: raise IndexError(\\"Stack is empty\\") return self.stack[-1]"},{"question":"Context: Gnome Sort is a relatively unknown but simple sorting algorithm. Contrary to commonly used algorithms like quicksort or mergesort, Gnome Sort shines in its straightforward implementation while maintaining decent performance for small or nearly-sorted datasets. Your task is to implement this sorting algorithm, ensuring it handles various edge cases efficiently. Task: Write a function `gnome_sort(arr)` that sorts a given list of integers in non-decreasing order using the Gnome Sort algorithm. Ensure your implementation is robust and takes into account various edge cases such as duplicate elements and varying list lengths. Function Signature: ```python def gnome_sort(arr: List[int]) -> List[int]: ``` Input: * `arr` - A list of integers (e.g., `arr = [34, 2, 78, 1, 45, 23]`). Output: * A list of integers sorted in non-decreasing order (e.g., `[1, 2, 23, 34, 45, 78]`). Constraints: * The length of the list `arr` is between 1 and 1000 inclusive. * Each integer in `arr` is between -10^6 and 10^6 inclusive. Example: ```python assert gnome_sort([34, 2, 78, 1, 45, 23]) == [1, 2, 23, 34, 45, 78] assert gnome_sort([]) == [] assert gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert gnome_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert gnome_sort([3, -1, -4, 2, 1, 0]) == [-4, -1, 0, 1, 2, 3] ```","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using the Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Implement Cosine Similarity with Enhanced Error Handling As a data scientist, you are often required to compute similarity measures between vectors in various high-dimensional spaces. One metric that is widely used is the Cosine Similarity, which quantifies the cosine of the angle between two non-zero vectors. In this task, you are required to implement an enhanced version of the cosine similarity function. Your function should not only compute the cosine similarity but also handle additional error scenarios and offer optimizations. # Requirements 1. Implement a function `enhanced_cosine_similarity(vec1, vec2)` that: - Takes in two lists of numbers as inputs. - Returns the cosine similarity between the two vectors. - Includes additional checks to handle: * Zero vectors to avoid division by zero. * Non-numeric data within the vectors. 2. Expected input and output formats: - **Input**: * `vec1`: List of floats or integers. * `vec2`: List of floats or integers. - **Output**: * A float value representing the cosine similarity. 3. Constraints: - The two input lists must have the same length (handled via exception). - If any vector is a zero vector, the function should return `None` to indicate undefined similarity due to division by zero. - If the vectors contain non-numeric values, the function should raise a `TypeError`. # Function Signature ```python def enhanced_cosine_similarity(vec1: list, vec2: list) -> float: pass ``` # Example ```python try: print(enhanced_cosine_similarity([1, 1, 1], [1, 2, -1])) # Output: 0.47140452079103173 print(enhanced_cosine_similarity([0, 0, 0], [1, 1, 1])) # Output: None print(enhanced_cosine_similarity([1, \'a\', 1], [1, 2, -1])) # Raises TypeError except ValueError as ve: print(str(ve)) except TypeError as te: print(str(te)) ``` # Notes - Ensure your code is well-structured and documented. - Add tests for edge cases and validate the input data types.","solution":"import math def enhanced_cosine_similarity(vec1: list, vec2: list) -> float: Calculate the cosine similarity between two vectors, with additional error handling for: - Zero vectors (returns None) - Non-numeric data within the vectors (raises TypeError) :param vec1: List of floats or integers representing the first vector :param vec2: List of floats or integers representing the second vector :return: Float value representing the cosine similarity, or None if undefined if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length.\\") for v in vec1 + vec2: if not isinstance(v, (int, float)): raise TypeError(\\"Vectors must contain numeric values only.\\") dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) norm1 = math.sqrt(sum(v1 * v1 for v1 in vec1)) norm2 = math.sqrt(sum(v2 * v2 for v2 in vec2)) if norm1 == 0 or norm2 == 0: return None return dot_product / (norm1 * norm2)"},{"question":"# Question: Binary Tree Depth Calculation and Traversal **Context**: A binary tree is a hierarchical structure with at most two children for each node. Understanding the depth of a tree is fundamental for various tree operations. In this task, you\'ll need to demonstrate your understanding of binary tree traversal and depth calculation by implementing functions to handle these operations. **Problem**: Implement the following functions: 1. `min_depth_recursive(root)`: - Input: A root node of a binary tree. - Output: An integer representing the minimum depth. - Purpose: Calculate the minimum depth of a binary tree using a recursive approach. 2. `min_depth_iterative(root)`: - Input: A root node of a binary tree. - Output: An integer representing the minimum depth. - Purpose: Calculate the minimum depth of a binary tree using an iterative approach with level-order traversal. 3. `print_tree(root)`: - Input: A root node of a binary tree. - Output: None. Prints the values of all nodes in the tree using pre-order traversal. **Function Signatures**: ```python def min_depth_recursive(root: TreeNode) -> int: pass def min_depth_iterative(root: TreeNode) -> int: pass def print_tree(root: TreeNode) -> None: pass ``` **Constraints**: - The binary tree can be empty (`root` can be `None`). - You can assume that the `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Example**: ```python tree = TreeNode(3) tree.left = TreeNode(9) tree.right = TreeNode(20) tree.right.left = TreeNode(15) tree.right.right = TreeNode(7) print(min_depth_recursive(tree)) # Output: 2 print(min_depth_iterative(tree)) # Output: 2 print_tree(tree) # Output: # 3 # 9 # 20 # 15 # 7 ``` **Performance Requirements**: - Aim for O(N) time complexity and O(H) space complexity for the recursive approach, where N is the number of nodes and H is the height of the tree. - Aim for O(N) time complexity and O(W) space complexity for the iterative approach, where W is the width of the tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_recursive(root: TreeNode) -> int: if not root: return 0 if not root.left: return min_depth_recursive(root.right) + 1 if not root.right: return min_depth_recursive(root.left) + 1 return min(min_depth_recursive(root.left), min_depth_recursive(root.right)) + 1 def min_depth_iterative(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_tree(root: TreeNode) -> None: if not root: return print(root.val) print_tree(root.left) print_tree(root.right)"},{"question":"Optimized Exchange Sort Write a function named `optimized_exchange_sort` that sorts an array of integers. The function should make specific optimizations to reduce unnecessary comparisons and swaps, and potentially improve the average runtime while maintaining the simplicity of Exchange Sort. # Input: * A list of integers `arr` where `1 <= len(arr) <= 10^3`. # Output: * A list of integers sorted in non-decreasing order. # Constraints: * The function should optimize the inner loop to skip over already sorted regions, aiming to perform fewer comparisons and swaps. * You should not use Python\'s built-in sort functions. * Consider the simplicity of the base algorithm while making your improvements. # Performance Requirements: * Typically, the function should aim to perform fewer comparisons than the standard Exchange Sort on average, particularly for nearly sorted inputs. # Example: ```python def optimized_exchange_sort(arr): # Your implementation here # Example usage: arr = [64, 34, 25, 12, 22, 11, 90] print(optimized_exchange_sort(arr)) # Output: [11, 12, 22, 25, 34, 64, 90] arr = [3, 8, 2, 5, 1, 7, 6, 4] print(optimized_exchange_sort(arr)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ```","solution":"def optimized_exchange_sort(arr): Sorts an array of integers using an optimized exchange sort that skips over already sorted regions. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: # Swap if elements are in wrong order arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True # If no elements were swapped, break the loop early if not swapped: break return arr"},{"question":"Context You are tasked with identifying strongly connected components in a directed graph for a complex network analysis project. Given a graph, you need to implement Kosaraju\'s algorithm to determine the number of strongly connected components in the graph. Problem Statement Implement the function `find_strongly_connected_components(V, edges)` using Kosaraju\'s algorithm to find strongly connected components in a directed graph. Function Signature ```python def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: ``` Input * `V` (int): The number of vertices in the graph. * `edges` (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a tuple `(u, v)` indicating a directed edge from vertex `u` to vertex `v`. Output * Returns an integer representing the number of strongly connected components in the graph. Constraints * (1 leq V leq 10^5) * (0 leq text{len(edges)} leq 5 times 10^5) Example ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] print(find_strongly_connected_components(V, edges)) # Output should be 2 ``` Additional Notes To solve this problem: 1. Implement a DFS to compute the finishing times of each vertex. 2. Transpose the graph (reverse all edges). 3. Perform a second DFS based on decreasing finishing times to count SCCs.","solution":"from typing import List, Tuple def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque def dfs(v, graph, visited, stack): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor, graph, visited, stack) stack.append(v) def reverse_graph(edges): reversed_edges = defaultdict(list) for src, dest in edges: reversed_edges[dest].append(src) return reversed_edges def fill_order(V, graph): visited = [False] * V stack = deque() for i in range(V): if not visited[i]: dfs(i, graph, visited, stack) return stack def dfs_for_scc(v, graph, visited): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs_for_scc(neighbor, graph, visited) # Step 1: Create the original graph graph = defaultdict(list) for src, dest in edges: graph[src].append(dest) # Step 2: Fill vertices in stack according to their finishing times stack = fill_order(V, graph) # Step 3: Create a reversed graph reversed_graph = reverse_graph(edges) # Step 4: Process all vertices in order defined by stack visited = [False] * V scc_count = 0 while stack: vertex = stack.pop() if not visited[vertex]: dfs_for_scc(vertex, reversed_graph, visited) scc_count += 1 return scc_count"},{"question":"# Summary You are to write a function to determine the number of ways a positive integer can be decomposed into sums of smaller integers. # Detailed Description Write a function `integer_partitions(n: int) -> int` that computes the number of ways a given positive integer can be partitioned using sums of smaller integers. **Function Signature**: ```python def integer_partitions(n: int) -> int: Finds the number of ways to partition the integer `n` into sums of smaller integers. :param n: integer to decompose :return: number of ways to partition `n` ``` # Input and Output * **Input**: An integer `n` (1 <= n <= 100). * **Output**: An integer, the number of ways `n` can be decomposed. # Examples Example 1: * **Input**: `n = 4` * **Output**: `5` * **Explanation**: The possible decompositions are: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Example 2: * **Input**: `n = 7` * **Output**: `15` * **Explanation**: The possible decompositions are: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 # Constraints * The input integer `n` will be between `1` and `100` inclusive. **Implementation Notes**: * Use the dynamic programming approach to ensure efficient computation. * Consider edge cases such as very small values of `n`.","solution":"def integer_partitions(n: int) -> int: Finds the number of ways to partition the integer `n` into sums of smaller integers. :param n: integer to decompose :return: number of ways to partition `n` # DP table to store the number of partitions. dp = [0] * (n + 1) dp[0] = 1 for num in range(1, n + 1): for i in range(num, n + 1): dp[i] += dp[i - num] return dp[n]"},{"question":"Given a singly linked list, write a function `unique_linked_list(head)` to remove duplicates such that each element appears only once. Your function should strive to achieve an optimal balance between time and space complexity. You are provided with two example implementations of removing duplicates, each making different trade-offs: 1. `remove_dups(head)` which uses extra space for efficiency. 2. `remove_dups_without_set(head)` which optimizes for space but can be slower for large lists. You are required to implement the function `unique_linked_list` which should aim to achieve a good balance between time and space usage. # Input - A singly linked list of integers, `head` (html element representing the head node which could be `null` representing an empty list). # Output - A singly linked list where all duplicate elements are removed. # Examples Example 1 Input: `1 -> 2 -> 3 -> 2 -> 1 -> 4` Output: `1 -> 2 -> 3 -> 4` Example 2 Input: `5 -> 5 -> 5 -> 5` Output: `5` # Constraints 1. The linked list can have at most ( 10^6 ) nodes. 2. The values within the nodes of the linked list are integers. # Function Signature ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def unique_linked_list(head: Node) -> Node: # Your code here ``` Make sure to consider edge cases, optimize for large inputs, and balance time and space efficiency.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def unique_linked_list(head: Node) -> Node: if head is None: return head current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"# Diffie-Hellman Key Exchange Implementation You are tasked with implementing a secure key exchange mechanism using the Diffie-Hellman protocol. This protocol allows two parties, Alice and Bob, to establish a shared secret key over an unsecured communication channel. Problem Statement Implement a function `diffie_hellman_key_exchange(a: int, p: int) -> bool` that performs the Diffie-Hellman key exchange. The function should return `True` if both parties compute the same shared secret and `False` otherwise. Input - `a` (int): An integer that is the supposed primitive root modulo `p`. - `p` (int): A large prime number. Output - `True` if the key exchange is successful (both parties compute the same shared secret). - `False` otherwise. Constraints - ( 1 leq a leq p-1 ) - ( p ) is a prime number with at least 5 digits. Example ```python # Primitive root 5 for prime 11 diffie_hellman_key_exchange(5, 11) ``` Expected Experience To successfully solve this task, students should: 1. Ensure ( p ) is a valid prime using provided methods. 2. Verify ( a ) is a primitive root using techniques for checking order. 3. Correctly implement the key exchange following the Diffie-Hellman procedure. 4. Handle possible error situations such as invalid inputs for ( a ) and ( p ).","solution":"def diffie_hellman_key_exchange(a: int, p: int) -> bool: Perform the Diffie-Hellman key exchange protocol and return True if both parties compute the same shared secret, else False. # Check that p is a valid prime number. if not is_prime(p): return False # Check that a is a valid integer in the range [1, p-1]. if a < 1 or a > p - 1: return False # Generate private keys for Alice and Bob (secret keys) from random import randint private_key_Alice = randint(1, p - 1) private_key_Bob = randint(1, p - 1) # Calculate the public values public_value_Alice = pow(a, private_key_Alice, p) public_value_Bob = pow(a, private_key_Bob, p) # Calculate the shared secret keys shared_secret_Alice = pow(public_value_Bob, private_key_Alice, p) shared_secret_Bob = pow(public_value_Alice, private_key_Bob, p) # Both shared secrets should be equal return shared_secret_Alice == shared_secret_Bob def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"You are given an array of integers. Your task is to implement a `SegmentTree` class that supports efficient range queries and updates. Specifically, the SegmentTree class should support the following operations: 1. **Build a segment tree**: Construct a segment tree from the given array based on a custom binary function (e.g., sum, minimum, maximum). 2. **Range Query**: Provide the result of applying the custom function over any specified subrange of the array. 3. **Range Update**: Update values within a specified subrange by adding a given value. # Class Definition ```python class SegmentTree: def __init__(self, arr, function): Initializes the segment tree with the given array and function. Args: arr (List[int]): The input array. function (Callable[[int, int], int]): A binary function (e.g., sum, min, max). pass def query(self, L, R): Returns the result of applying the custom function over the range [L, R]. Args: L (int): The start of the query range. R (int): The end of the query range. Returns: int: The result of the query. pass def update_range(self, L, R, value): Updates the values within the range [L, R] by adding the given value. Args: L (int): The start of the update range. R (int): The end of the update range. value (int): The value to add to each element in the range. pass ``` # Example Usage ```python # Define the binary function def custom_sum(x, y): return x + y # Initialize the segment tree with an array and the custom sum function arr = [1, 3, 5, 7, 9, 11] st = SegmentTree(arr, custom_sum) # Perform range queries print(st.query(1, 3)) # Output: 15 print(st.query(0, 5)) # Output: 36 # Update ranges st.update_range(1, 3, 2) # Perform range queries after updates print(st.query(1, 3)) # Output: 21 print(st.query(0, 5)) # Output: 42 ``` # Constraints * 1 ≤ `len(arr)` ≤ 10^5 * 1 ≤ `L`, `R` ≤ len(arr) - 1 * -10^6 ≤ `value` ≤ 10^6 # Notes - Ensure to handle edge cases where the query range may partially exceed the array bounds. - Optimize your implementation for both time and space efficiency.","solution":"class SegmentTree: def __init__(self, arr, function): Initializes the segment tree with the given array and function. self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L, R): Returns the result of applying the custom function over the range [L, R]. L += self.n R += self.n + 1 res = None while L < R: if L % 2: if res is None: res = self.tree[L] else: res = self.function(res, self.tree[L]) L += 1 if R % 2: R -= 1 if res is None: res = self.tree[R] else: res = self.function(res, self.tree[R]) L //= 2 R //= 2 return res def update_range(self, L, R, value): Updates the values within the range [L, R] by adding the given value. for i in range(L, R + 1): pos = i + self.n self.tree[pos] += value while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1])"},{"question":"# Strongly Connected Component Assessment Given a directed graph represented by `N` vertices and `M` edges, you are to determine if the graph is a strongly connected component. A graph is considered strongly connected if there is a path in each direction between each pair of vertices in the graph. You need to implement the following methods: 1. `__init__(self, vertex_count: int)`: Initializes the graph with a specified number of vertices. 2. `add_edge(self, source: int, target: int)`: Adds a directed edge from `source` to `target`. 3. `is_strongly_connected(self) -> bool`: Determines if the graph is strongly connected. # Input - An integer `N`, indicating the number of vertices. - An integer `M`, indicating the number of edges. - `M` pairs of integers `(u, v)`, representing a directed edge from `u` to `v`. # Output - Boolean `True` if the graph is a strongly connected, otherwise `False`. # Constraints - `1 <= N <= 10^3` - `0 <= M <= N*(N-1)` # Example ```python graph = Graph(5) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(3, 4) graph.add_edge(4, 0) print(graph.is_strongly_connected()) # Output: True graph = Graph(5) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) print(graph.is_strongly_connected()) # Output: False ``` # Function Signature ```python class Graph: def __init__(self, vertex_count: int): # Implement initialization def add_edge(self, source: int, target: int): # Implement edge addition def is_strongly_connected(self) -> bool: # Implement strongly connected calculation ```","solution":"class Graph: def __init__(self, vertex_count: int): self.vertex_count = vertex_count self.adjacency_list = [[] for _ in range(vertex_count)] def add_edge(self, source: int, target: int): self.adjacency_list[source].append(target) def is_strongly_connected(self) -> bool: def dfs(vertex: int, visited: set, graph: list): stack = [vertex] while stack: v = stack.pop() if v not in visited: visited.add(v) for neighbor in graph[v]: stack.append(neighbor) def transpose(graph: list) -> list: transposed_graph = [[] for _ in range(len(graph))] for v in range(len(graph)): for neighbor in graph[v]: transposed_graph[neighbor].append(v) return transposed_graph visited = set() dfs(0, visited, self.adjacency_list) if len(visited) != self.vertex_count: return False transposed_graph = transpose(self.adjacency_list) visited.clear() dfs(0, visited, transposed_graph) return len(visited) == self.vertex_count"},{"question":"You are given a singly linked list where each node contains an integer value. Implement an efficient function to find the k-th element from the end of the list. The function should return the value of the k-th node from the end. # Function Signature ```python def kth_to_last(head: Node, k: int) -> int: pass ``` # Input - `head`: The head node of a singly linked list. Each node contains an integer value. - `k`: An integer representing the position from the end (0-based index). # Output - Return the value of the k-th node from the end. If k is not valid (e.g., larger than the list length), return None. # Constraints - `0 <= k <= 10^6` - The linked list length `n` will not exceed `10^6`. # Example ```python # Define the Node class as given in the initial code class Node: def __init__(self, val: int = 0, next: \'Node\' = None): self.val = val self.next = next # Example Linked List: 1 -> 2 -> 3 -> 4 -> 5 # k = 2, the expected value is 4 (2nd from last) # Construct the linked list n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5 print(kth_to_last(n1, 2)) # Output should be 4 ``` # Notes - Ensure your solution is optimal. The solution using two pointers is expected to be efficient.","solution":"class Node: def __init__(self, val: int = 0, next: \'Node\' = None): self.val = val self.next = next def kth_to_last(head: Node, k: int) -> int: Returns the k-th element from the end of the linked list. :param head: Node, the head of the singly linked list :param k: int, the position from the end (0-based index) :return: int, the value of the k-th node from the end, or None if not valid if head is None: return None # Initialize two pointers slow = fast = head # Move fast pointer k nodes ahead for i in range(k): if fast.next: fast = fast.next else: return None # If k is greater than the length of the list # Move both pointers until fast reaches the end of the list while fast.next: slow = slow.next fast = fast.next return slow.val"},{"question":"# Coding Assessment Task: Implement and Optimize Comb Sort You have been given the task of sorting an array of integers using Comb Sort. Despite its simplicity, implementing Comb Sort correctly and understanding its underlying principles can demonstrate your grasp of sorting algorithms. Task 1. **Implement the Comb Sort Algorithm**: * Write a function `comb_sort(arr: List[int]) -> List[int]` that sorts an array of integers in ascending order. 2. **Optimize the Algorithm**: * Research and experiment with different shrink factors to potentially improve performance. * Optionally, combine Comb Sort with another sorting algorithm for the final stages (e.g., switch to Insertion Sort when the gap is 1). Input * A list of integers `arr` of length `N` where `1 <= N <= 10^5`. * Elements in `arr` are of range `-10^9 <= arr[i] <= 10^9`. Output * Return a sorted list in ascending order. Constraints * Ensure your solution is efficient enough to handle the upper limits of the input size within a reasonable time frame. * Consider edge cases like an empty array or an array with all identical elements. * Document any assumptions or optimizations you make in your solution. Example ```python assert comb_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert comb_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert comb_sort([]) == [] assert comb_sort([5, -1, 0, 12, 8]) == [-1, 0, 5, 8, 12] ``` Note: Pay close attention to the choice of shrink factor as it significantly influences the performance of the algorithm.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Function to sort an array of integers using the comb sort algorithm. def get_next_gap(gap: int) -> int: # Shrink factor of 1.3 found to be efficient from various studies. new_gap = int(gap / 1.3) if new_gap < 1: return 1 return new_gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: Implement an Optimized Truncated Mean Function Context: You are working as a data analyst, and your task is to create a reliable average calculation method for datasets with potential outliers. To achieve a more representative mean, you implement a truncated mean function which removes a defined percentage of the highest and lowest values before calculating the mean. Task: Write a function, `trimmean_optimized(arr: List[int], per: float) -> float`, that takes an array of integers and a percentage to trim, and returns the truncated mean. Details: - **Input:** - `arr`: A list of integers representing the dataset. - `per`: A float representing the percentage of elements to trim (equally from top and bottom of the sorted list). - **Output:** - Returns the mean of the remaining elements after trimming the specified percentage. Constraints: - 0 <= `per` < 50 - The array will have at least 3 elements. - All elements will be integers. - Ensure your function avoids unnecessary operations and handles edge cases effectively. Performance: - The function should preferably run in O(n log n) time or better depending on the size of the list. Example: ```python from typing import List def trimmean_optimized(arr: List[int], per: float) -> float: # Calculate the ratio of elements to trim on each side ratio = per / 200 # Compute number of elements to trim from the sorted array n = len(arr) trim_count = int(n * ratio) # Sort the array arr.sort() # Slice the array to remove extremes trimmed_arr = arr[trim_count: n - trim_count] # Calculate the mean of the remaining elements trimmed_sum = sum(trimmed_arr) trimmed_mean = trimmed_sum / len(trimmed_arr) if trimmed_arr else 0 return trimmed_mean # Example Usage assert abs(trimmean_optimized([2, 8, 10, 17, 23, 50], 20) - 14.5) < 1e-5 assert abs(trimmean_optimized([4, 4, 4, 4, 4, 4, 4], 10) - 4.0) < 1e-5 ``` Note: Ensure that the function handles edge cases and performance considerations as outlined.","solution":"from typing import List def trimmean_optimized(arr: List[int], per: float) -> float: Calculate the truncated mean by removing a specified percentage of the highest and lowest values and calculating the mean of the remaining elements. :param arr: List of integers representing the dataset. :param per: Percentage to trim equally from top and bottom of the sorted list. :return: Mean of the remaining elements after trimming. # Ensure the percentage is within constraints if per < 0 or per >= 50: raise ValueError(\\"Percentage must be between 0 and 50\\") # Calculate the number of elements to trim from each end n = len(arr) trim_count = int(n * per / 100) # Sort the array sorted_arr = sorted(arr) # Slice the array to remove the extremes trimmed_arr = sorted_arr[trim_count:n-trim_count] # Calculate the mean of the remaining elements trimmed_mean = sum(trimmed_arr) / len(trimmed_arr) return trimmed_mean"},{"question":"You are tasked with extending the Bubble Sort algorithm to include functionality that tracks the number of comparisons made during the sorting process. In addition, you need to write a function that can visualize the sorting process, showing the array at each iteration until it is sorted. # Requirements 1. **Function Signature**: `def advanced_bubble_sort(arr: list, visualize: bool = False) -> tuple:` 2. **Input**: - `arr`: A list of integers to be sorted. - `visualize`: A boolean flag that indicates whether to print the intermediate states of the array. 3. **Output**: - The sorted array. - The number of comparisons made during the sorting process. 4. **Constraints**: - The input list can have up to 1000 elements. - Elements of the list are integers in the range from `-10^6` to `10^6`. 5. **Performance**: Ensure the solution does not exceed O(N^2) time complexity. # Example ```python # Example 1 arr = [4, 3, 2, 1] sorted_array, comparisons = advanced_bubble_sort(arr, True) print(sorted_array) # Output: [1, 2, 3, 4] print(comparisons) # Output: 6 (for this specific example) # Example 2 arr = [1, 2, 3, 4] sorted_array, comparisons = advanced_bubble_sort(arr, False) print(sorted_array) # Output: [1, 2, 3, 4] print(comparisons) # Output: 3 ``` # Requirements Implement the function such that: - It returns a tuple where the first element is the sorted array and the second element is the total number of comparisons made. - It optionally prints the array at each sorting iteration when `visualize` is set to `True`. # Constraints and Limitations - Assume the input is well-formed; i.e., no need to handle non-list inputs or lists with non-integer elements. - Focus on correct handling of edge cases as mentioned in the analysis.","solution":"def advanced_bubble_sort(arr: list, visualize: bool = False) -> tuple: Performs bubble sort on the input list and returns the sorted list along with the number of comparisons made. Parameters: arr (list): A list of integers to be sorted. visualize (bool): A boolean flag indicating whether to print the intermediate states of the list. Returns: tuple: A tuple containing the sorted list and the number of comparisons made. n = len(arr) comparisons = 0 for i in range(n): swapped = False if visualize: print(f\\"Iteration {i}: {arr}\\") for j in range(0, n-i-1): comparisons += 1 if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr, comparisons"},{"question":"You are tasked with implementing a function `is_match` that performs regular expression matching with support for the special characters \'.\' and \'*\'. - `.` matches any single character. - `*` matches zero or more of the preceding element. The function should determine if the entire input string `s` matches the pattern `p`. Function Signature ```python def is_match(s: str, p: str) -> bool: ... ``` Input - `s`: a string `s` of length `n` (0 ≤ n ≤ 1000). - `p`: a string `p` of length `m` (0 ≤ m ≤ 1000). Output - A boolean value indicating whether the input string `s` matches the pattern `p`. Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Constraints - Your implementation should have a time complexity of O(n * m) and space complexity of O(n * m). Notes - Ensure to consider edge cases and optimize for performance and memory usage. - Handle all types and edge cases specified in the examples. Write a solution for the implementation that adheres to the given constraints and correctness requirements.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p, including \'.\' and \'*\' support. m, n = len(s), len(p) # dp[i][j] will be True if the first i characters in s match the first j characters in p dp = [[False] * (n + 1) for _ in range(m + 1)] # Both s and p are empty dp[0][0] = True # Deals with patterns like a*, a*b*, a*b*c* (they can match an empty string) for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if (p[j - 2] == s[i - 1] or p[j - 2] == \'.\') else False) return dp[m][n]"},{"question":"# Gnome Sort Implementation and Enhancement You are provided with an implementation of the Gnome Sort algorithm. This sorting algorithm is simple but known to have poor performance on large datasets due to its O(n^2) worst-case time complexity. Your task is to implement the Gnome Sort algorithm, and then enhance it with early termination to improve its performance on nearly sorted lists. Requirements: 1. **Implement the base Gnome Sort**: - Function Signature: `def gnome_sort(arr: List[int]) -> List[int]` - Input: A list of integers `arr`. - Output: The list sorted in non-decreasing order. 2. **Enhance with Early Termination**: - Early termination condition: If a pass through the list finds no swaps, terminate early as the list is already sorted. 3. **Edge Case Handling**: - Ensure that your function handles edge cases correctly, such as empty lists, single element lists, and lists with all identical elements. 4. **Performance Constraint**: - The enhanced version should ideally perform better than the basic implementation on nearly sorted lists. # Example: ```python # Example Input arr = [34, 2, 10, -9] # Example Output sorted_arr = gnome_sort(arr) print(sorted_arr) # Output: [-9, 2, 10, 34] ``` Constraints: - Do not use any built-in sorting functions.","solution":"def gnome_sort(arr): Perform Gnome Sort on the provided list and enhance it with early termination. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list of integers. index = 0 n = len(arr) while index < n: # If the element is at the start of the array or the current element is # greater than or equal to the previous element, move to the next element. if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: # Swap the elements and move one step back. arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 # Early termination condition check. if index == n - 1: if arr == sorted(arr): # Check if the list is already sorted break return arr"},{"question":"You are given a list of students\' names in an unsorted array. Your task is to find the first occurrence of a specific student\'s name in the list using a linear search algorithm. If the student\'s name is not found, return -1. **Function Signature:** ```python def find_student_index(names: List[str], target: str) -> int: pass ``` **Input:** - `names` (List[str]): A list of students\' names (1 <= len(names) <= 10^5). - `target` (str): A student\'s name to search for in the list. **Output:** - Return the index (0-based) of the first occurrence of the target student\'s name. - If the student\'s name is not found, return -1. **Constraints:** - Each name in the list will be a non-empty string of at least 1 and at most 100 characters. - All names consist of lowercase English letters only. **Performance Requirements:** - The algorithm should run in O(n) time complexity, where n is the length of the `names` list. **Example:** ```python # Example 1 names = [\'alice\', \'bob\', \'charlie\', \'david\'] target = \'charlie\' # Output: 2 # Example 2 names = [\'alice\', \'bob\', \'charlie\', \'david\'] target = \'eve\' # Output: -1 # Example 3 names = [] target = \'alice\' # Output: -1 ``` **Scenario:** Consider a teacher who needs to quickly find the position of a specific student in a long list of names. This function will help the teacher efficiently locate the student or confirm their absence in the list.","solution":"from typing import List def find_student_index(names: List[str], target: str) -> int: Finds the first occurrence of the target student\'s name in the list. Parameters: - names (List[str]): List of students\' names. - target (str): The student\'s name to search for. Returns: - int: Index of the first occurrence of the target name, or -1 if not found. for index, name in enumerate(names): if name == target: return index return -1"},{"question":"You are tasked to help a vending machine maintain records of different ways to provide change for various denominations of currency stored inside. You need to write a function to determine the number of ways to make change for a given value using an infinite supply of several coin denominations. Function Signature ```python def count(coins: List[int], value: int) -> int: ``` Input 1. `coins`: A list of integers where each integer represents the value of different coins available, with infinite supply for each type of coin. 2. `value`: An integer representing the amount for which you need to calculate the number of ways to make the change. Output An integer representing the number of ways to create the `value` using the coin denominations provided. Constraints - All coins are positive integers. - The `value` is a non-negative integer. - Ensure the function runs efficiently even for higher values and multiple coins. Examples 1. **Input**: `coins = [1, 2, 3]`, `value = 4` **Output**: `4` **Explanation**: The possible combinations are [1, 1, 1, 1], [1, 1, 2], [2, 2], and [1, 3]. 2. **Input**: `coins = [2, 5, 3, 6]`, `value = 10` **Output**: `5` **Explanation**: The possible combinations are [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], and [5, 5]. Ensure your solution caters for the edge cases, maintain an optimal performance, and follow structured and efficient coding principles. Consider the time and space complexity and validate against varied input scenarios for robustness.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Returns the number of ways to make change for a given value using the provided coin denominations. # Initialize a list to store the number of ways to make change for each value from 0 to value dp = [0] * (value + 1) # Base case: there\'s one way to make change for 0 (use no coins) dp[0] = 1 # Iterate over each coin for coin in coins: # Update the dp array for values from coin to value for x in range(coin, value + 1): dp[x] += dp[x - coin] return dp[value]"},{"question":"You are tasked with designing a function that performs multiple transformations on a given matrix, incorporating both rotation and inversion operations. The goal is to amalgamate these operations in a single function, showcasing your understanding of matrix manipulation. # Function Definition You need to implement a function: ```python def transform_matrix(matrix: List[List[int]], operations: List[str]) -> List[List[int]]: ``` - `matrix` (List[List[int]]): A 2D list representing the input matrix. - `operations` (List[str]): A list of strings where each string is an operation to be performed. Each operation is one of the following: - `\\"rotate_clockwise\\"`: Rotate the matrix 90 degrees clockwise. - `\\"rotate_counterclockwise\\"`: Rotate the matrix 90 degrees counterclockwise. - `\\"top_left_invert\\"`: Invert the matrix from top-left (equivalent to just copying the matrix). - `\\"bottom_left_invert\\"`: Invert the matrix from bottom-left. # Expected Output Return the transformed matrix after performing all the given operations sequentially. # Constraints - The matrix can contain integer values and may not be square. - The matrix will have at least one row and one column. - The operations list is non-empty. - The operations are performed in the order they appear in the list. # Example ```python # Input matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # List of operations operations = [\\"rotate_clockwise\\", \\"bottom_left_invert\\"] # Function call result = transform_matrix(matrix, operations) # Expected Output # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1], # ] ``` # Notes * You can use the provided code snippets for individual matrix transformations and combine them within your `transform_matrix` function. * Ensure to handle edge cases like non-rectangular matrices and apply transformations correctly. * Think about optimizing your solution to handle large matrices efficiently.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: return [list(reversed(col)) for col in zip(*matrix)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: return rotate_clockwise(rotate_clockwise(rotate_clockwise(matrix))) def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: return matrix def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: return matrix[::-1] def transform_matrix(matrix: List[List[int]], operations: List[str]) -> List[List[int]]: for op in operations: if op == \\"rotate_clockwise\\": matrix = rotate_clockwise(matrix) elif op == \\"rotate_counterclockwise\\": matrix = rotate_counterclockwise(matrix) elif op == \\"top_left_invert\\": matrix = top_left_invert(matrix) elif op == \\"bottom_left_invert\\": matrix = bottom_left_invert(matrix) return matrix"},{"question":"Context You are developing an application for a transportation company where you need to find the minimum cost to travel from the start station to the destination station using a given cost matrix. The cost matrix describes the direct cost of traveling from one station to another, and it is a Directed Acyclic Graph (DAG) where travel is only permissible in one direction from lower-index stations to higher-index stations. Problem Statement Write a function `find_min_cost_path(cost_matrix: List[List[int]]) -> int` that takes as an input a 2D list `cost_matrix` where: - `cost_matrix[i][j]` represents the cost of traveling directly from station (i) to station (j) for (i < j). - Values where (i geq j) are represented by `-1` or `INF`. - Your function should return the minimum cost to travel from station 0 to station (N-1). Input * A list of lists `cost_matrix` where (2 leq N leq 100) (N is the number of stations). Output * Return a single integer which is the minimum cost to travel from station 0 to station (N-1). Constraints * The input matrix represents a directed acyclic graph (DAG). * No valid path is represented by returning -1. Example ```python cost_matrix = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] result = find_min_cost_path(cost_matrix) print(result) # Output: 65 ``` Explanation The minimum cost path is from station 0 to station 1 to station 3, giving a total cost of (15 + 50 = 65). Note: Remember to handle cases where no path exists by returning -1.","solution":"from typing import List def find_min_cost_path(cost_matrix: List[List[int]]) -> int: N = len(cost_matrix) # Initialize distance array with infinity distance = [float(\'inf\')] * N # Starting point is station 0 distance[0] = 0 # Finding the shortest path from station 0 to station N-1 for i in range(N): for j in range(i+1, N): if cost_matrix[i][j] != -1: if distance[j] > distance[i] + cost_matrix[i][j]: distance[j] = distance[i] + cost_matrix[i][j] # If distance[N-1] is still infinity, it means there\'s no valid path return distance[N-1] if distance[N-1] != float(\'inf\') else -1"},{"question":"**Context**: In low-level systems and embedded applications, you might often encounter situations where using certain arithmetic operators directly is not feasible. In those cases, bitwise operations can serve as valuable tools for performing arithmetic operations. **Task**: Write a function `bitwise_addition(a: int, b: int) -> int` that takes two positive integers and returns their sum, calculated using only bitwise operations and without using the \'+\' operator. Input Format: * Two positive integers `a` and `b` (0 <= a, b <= 10^9). Output Format: * A single integer representing the sum of `a` and `b`. Constraints: * Your function should not use the \'+\' operator (or any other arithmetic operator) directly for addition. * Aim for optimal performance - your solution should run in constant space. Example: ```python # Example usage print(bitwise_addition(2, 3)) # Output: 5 print(bitwise_addition(15, 25)) # Output: 40 ``` Detailed Explanation: The bitwise operators used are: * `&` (AND operator) - to compute the carry bits. * `^` (XOR operator) - to calculate the sum bits ignoring the carry. * `<<` (LEFT SHIFT operator) - to shift the carries left by one position to add in the correct place in the next iteration. Implement the `bitwise_addition` function: ```python def bitwise_addition(a: int, b: int) -> int: while b: carry = a & b a = a ^ b b = carry << 1 return a ```","solution":"def bitwise_addition(a: int, b: int) -> int: Returns the sum of a and b using bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"# Question: Implement Flatten Arrays Scenario Imagine you are working on a data processing pipeline where data arrives in the form of deeply nested arrays. For the next step of the processing, you need to flatten these nested arrays into a single list to make iterating over elements more efficient. Your task is to implement a function that can handle such nested structures and return a single, flat array. Function Specifications You are to implement a function `flatten_array` that flattens a nested array. * **Function Signature**: ```python def flatten_array(nested_array: list) -> list: ``` * **Input**: * `nested_array`: A list which may contain non-empty elements and other nested lists. * **Output**: * Returns a single list with all the elements from the nested array in a flattened structure. * **Constraints**: * Elements inside the nested arrays may include any object type, hence flattening should be applied to nested arrays only. * Strings should be treated as atomic (do not flatten them). * **Example**: ```python print(flatten_array([1, [2, [3, 4], [[5]]], 6])) # Output: [1, 2, 3, 4, 5, 6] print(flatten_array([1, \'two\', [3, \'four\', [5]]])) # Output: [1, \'two\', 3, \'four\', 5] ``` * **Notes**: * Your function needs to deal efficiently with deeply nested structures. * Implement it recursively, ensuring to handle edge cases such as empty arrays and mixed types as described.","solution":"def flatten_array(nested_array): Flattens a nested array into a single list. Parameters: nested_array (list): The list that may contain nested lists. Returns: list: A flattened list containing all non-list elements from the nested_array. flat_list = [] def _flatten(sublist): for item in sublist: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_array) return flat_list"},{"question":"# Polynomial Arithmetic Simplification Problem Statement Design and implement a class `Polynomial` that simplifies polynomial operations using the provided `Monomial` class. The Polynomial class should contain methods to add, subtract, multiply, divide polynomials and monomials, and also evaluate the polynomial for given variable substitutions. Detailed Requirements 1. **Initialization**: - Initialize a Polynomial with a list of Monomials or numerical values (integer, float, Fraction). 2. **Addition**: - Implement `__add__` method to add a Polynomial with another Polynomial, a Monomial, or a numerical value. 3. **Subtraction**: - Implement `__sub__` method to subtract another Polynomial, a Monomial, or a numerical value from the Polynomial. 4. **Multiplication**: - Implement `__mul__` method to multiply the Polynomial with another Polynomial, a Monomial, or a numerical value. 5. **Division**: - Implement `__truediv__` method to divide the Polynomial by a Monomial or a numerical value. 6. **Evaluation**: - Implement a `subs` method to evaluate the polynomial given a dictionary of variable substitutions. Input and Output Formats - The input will be through instantiation and method calls on the `Polynomial` class. - Outputs should be instances of the `Polynomial` class except for the evaluation method which returns a numerical value. Constraints - The class should handle polynomials with up to 10 variables and no more than 100 terms. - Rational arithmetic precision must be maintained using the `Fraction` class. Example ```python p1 = Polynomial([ Monomial({1:1}, 2), Monomial({2:3, 1:-1}, -1) ]) p2 = Polynomial([ Monomial({1:2}, 3), Monomial({2:1}, 1) ]) print(p1 + p2) # Simplified polynomial: 2(a_1) + (-1)(a_2)^3(a_1)^(-1) + 3(a_1)^2 + (a_2) print(p1 * p2) # Simplified polynomial: 6(a_1)^3 + (-3)(a_1)(a_2)^3 + 2(a_1)^3 + (-2)(a_2)^3(a_1)^2 print(p1.subs({1: 2, 2: 3})) # Evaluated value ``` Remember to ensure your code maintains mathematical integrity, precision using fractions, and handles possible edge cases like addition/subtraction with zero terms.","solution":"from fractions import Fraction from collections import defaultdict class Monomial: def __init__(self, exponents: dict, coefficient=1): self.exponents = exponents self.coefficient = Fraction(coefficient) def __eq__(self, other): return self.exponents == other.exponents and self.coefficient == other.coefficient def __mul__(self, other): if isinstance(other, (int, Fraction)): return Monomial(self.exponents, self.coefficient * other) elif isinstance(other, Monomial): new_exponents = defaultdict(int, self.exponents) for var, exp in other.exponents.items(): new_exponents[var] += exp return Monomial(dict(new_exponents), self.coefficient * other.coefficient) def __truediv__(self, other): if isinstance(other, (int, Fraction)): return Monomial(self.exponents, self.coefficient / Fraction(other)) elif isinstance(other, Monomial): new_exponents = defaultdict(int, self.exponents) for var, exp in other.exponents.items(): new_exponents[var] -= exp return Monomial(dict(new_exponents), self.coefficient / other.coefficient) def __str__(self): terms = [f\'{self.coefficient}\'] for var, exp in sorted(self.exponents.items()): if exp != 0: terms.append(f\'(a_{var}^{exp})\') return \' * \'.join(terms) class Polynomial: def __init__(self, terms): self.terms = [] for term in terms: if isinstance(term, Monomial): self.terms.append(term) elif isinstance(term, (int, float, Fraction)): self.terms.append(Monomial({}, term)) else: raise ValueError(\\"Invalid term type\\") def __add__(self, other): if isinstance(other, Polynomial): return Polynomial(self.terms + other.terms).simplify() elif isinstance(other, Monomial): return Polynomial(self.terms + [other]).simplify() elif isinstance(other, (int, float, Fraction)): return Polynomial(self.terms + [Monomial({}, other)]).simplify() def __sub__(self, other): if isinstance(other, Polynomial): other_terms = [Monomial(m.exponents, -m.coefficient) for m in other.terms] return Polynomial(self.terms + other_terms).simplify() elif isinstance(other, Monomial): return Polynomial(self.terms + [Monomial(other.exponents, -other.coefficient)]).simplify() elif isinstance(other, (int, float, Fraction)): return Polynomial(self.terms + [Monomial({}, -other)]).simplify() def __mul__(self, other): if isinstance(other, Polynomial): result = [] for m1 in self.terms: for m2 in other.terms: result.append(m1 * m2) return Polynomial(result).simplify() elif isinstance(other, Monomial): return Polynomial([m * other for m in self.terms]).simplify() elif isinstance(other, (int, float, Fraction)): return Polynomial([m * other for m in self.terms]).simplify() def __truediv__(self, other): if isinstance(other, Monomial): return Polynomial([m / other for m in self.terms]) elif isinstance(other, (int, float, Fraction)): return Polynomial([m / other for m in self.terms]) else: raise ValueError(\\"Can only divide by Monomial or numerical value\\") def subs(self, substitutions): total = Fraction(0) for m in self.terms: coeff = m.coefficient for var, exp in m.exponents.items(): if var in substitutions: coeff *= substitutions[var] ** exp else: coeff = 0 break total += coeff return total def simplify(self): combined_terms = defaultdict(Fraction) for term in self.terms: key = frozenset(term.exponents.items()) combined_terms[key] += term.coefficient self.terms = [Monomial(dict(k), coeff) for k, coeff in combined_terms.items() if coeff != 0] return self def __str__(self): if not self.terms: return \\"0\\" return \\" + \\".join(str(m) for m in self.terms)"},{"question":"# Single Unique Number Finder You are given an array of integers where every element appears exactly twice, except for one element which appears exactly once. Write a function to find that single one. Function Signature ```python def find_single_number(nums: List[int]) -> int: Returns the single number that does not occur twice, or 0 if the input array does not meet the problem constraints. :param nums: List of integers where every element appears twice except for one. :return: The single integer that appears once. ``` Input * `nums`: A list of integers `[n1, n2, ..., nm]` where `1 <= m <= 10^5`. Output * An integer representing the single number that appears only once in the array. Constraints * The array will always have at least one number that appears only once, and all other numbers will appear exactly twice. * Your algorithm should have a linear runtime complexity. * You should not use any extra memory. Example ```python # Example 1 assert find_single_number([2, 2, 1]) == 1 # Example 2 assert find_single_number([4, 1, 2, 1, 2]) == 4 ``` Explanation In the first example, 2 appears twice, but 1 appears only once, so the function returns 1. In the second example, 1 and 2 appear twice, but 4 appears only once, so the function returns 4.","solution":"def find_single_number(nums): Returns the single number that does not occur twice. :param nums: List of integers where every element appears twice except for one. :return: The single integer that appears once. result = 0 for num in nums: result ^= num return result"},{"question":"You are provided with an array of words and an array of symbols. Your task is to display each word with its longest matched symbol surrounded by square brackets. If the word does not match any symbols, it should remain unchanged. # Input 1. An array of strings `words` where each element is a word. 2. An array of strings `symbols` where each element is a symbol. # Output - An array of strings where each word has its longest matched symbol surrounded by square brackets. If there is no match, the word remains unchanged. # Example **Input**: ```python words = [\\"Amazon\\", \\"Microsoft\\", \\"Google\\"] symbols = [\\"i\\", \\"Am\\", \\"cro\\", \\"Na\\", \\"le\\", \\"abc\\"] ``` **Output**: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Constraints - The length of `words` will not exceed 10^3. - The length of `symbols` will not exceed 10^3. - The length of each word and symbol will not exceed 100. # Function Signature ```python def match_symbols(words: list, symbols: list) -> list: pass ``` # Explanation 1. Use a Trie (Prefix Tree) to store the symbols for efficient retrieval and longest match search. 2. Traverse each word and try to find the longest symbol using the Trie structure. 3. Replace the found symbol in the word with the symbol surrounded by square brackets. 4. Ensure to check for edge cases such as no matching symbols and overlapping symbols for the longest match. Implement the function `match_symbols` to solve the problem efficiently.","solution":"def match_symbols(words: list, symbols: list) -> list: def find_longest_symbol(word): longest_symbol = \\"\\" for symbol in symbols: if symbol in word: if len(symbol) > len(longest_symbol): longest_symbol = symbol elif len(symbol) == len(longest_symbol) and word.index(symbol) < word.index(longest_symbol): longest_symbol = symbol return longest_symbol result = [] for word in words: longest_symbol = find_longest_symbol(word) if longest_symbol: word = word.replace(longest_symbol, f\\"[{longest_symbol}]\\") result.append(word) return result"},{"question":"# Question: You are given a task to classify a given input vector based on its nearest neighbor from a training set. The training set is a collection of vectors, each associated with a class label. Use the Euclidean distance metric to find the nearest neighbor. Function Signature ```python def classify_vector(vector: tuple, training_set: dict) -> object: Classifies the input vector based on its nearest neighbor in the training set. Arguments: vector : tuple -- the input vector to classify training_set : dict -- the training set where keys are tuples representing vectors and values are the associated class labels Returns: object -- the class label of the nearest neighbor ``` Input * `vector`: A tuple representing the input vector to classify. The vector can be of any dimension. * `training_set`: A dictionary where the keys are tuples representing vectors, and the values are the class labels associated with each vector. Output * The function should return the class label of the vector in the training set that is closest to the input vector based on Euclidean distance. Constraints * The input \'vector\' and keys in \'training_set\' will have the same length. * Training set will always contain at least one vector. * Vector components are guaranteed to be numeric (integers or floats). Example ```python vector = (2.5, 4.1) training_set = { (1.0, 2.0): \'A\', (3.0, 4.0): \'B\', (2.5, 6.0): \'C\' } print(classify_vector(vector, training_set)) # Output should be \'B\' ```","solution":"import math def classify_vector(vector, training_set): Classifies the input vector based on its nearest neighbor in the training set. Arguments: vector : tuple -- the input vector to classify training_set : dict -- the training set where keys are tuples representing vectors and values are the associated class labels Returns: object -- the class label of the nearest neighbor def euclidean_distance(v1, v2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) nearest_vector = min(training_set.keys(), key=lambda train_vec: euclidean_distance(vector, train_vec)) return training_set[nearest_vector]"},{"question":"You are a part of a software team working on implementing a cryptographic component for a secure communication tool. A crucial part of this tool involves computing large power moduli to ensure data integrity and security. Your task is to implement the `modular_exponential` function efficiently. This function must compute (base^exponent) % mod using the exponentiation by squaring method. This will help in maintaining performance even with very large numbers. Function Signature ```python def modular_exponential(base: int, exponent: int, mod: int) -> int: pass ``` Expected Input and Output: - **Input**: - `base` (int): The base number (1 <= base <= 10^9) - `exponent` (int): The exponent number (0 <= exponent <= 10^9) - `mod` (int): The modulo (1 <= mod <= 10^9) - **Output**: - (int): The result of (base^exponent) % mod Constraints: - The exponent will always be a non-negative integer. - The base and mod will always be positive integers. Performance Requirements: - The implementation should run efficiently for large values of `exponent`. - Time complexity should be O(log exponent). - Space complexity should be O(1). Example Scenarios: - Example 1: - Input: `base = 2`, `exponent = 10`, `mod = 1000` - Output: `result = 24` - Example 2: - Input: `base = 2`, `exponent = 11`, `mod = 25` - Output: `result = 23` Additional Notes: - Handle a scenario where the base is zero; for example, `modular_exponential(0, 10, 1000)` should return 0. - Be sure to consider efficiency in your solution. Good luck! Prove your understanding of the modular exponential algorithm and optimization techniques.","solution":"def modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base^exponent) % mod using the exponentiation by squaring method. result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Scenario: You are working as a software engineer tasked with developing an efficient search feature for a text processing tool. You decide to incorporate the Rabin-Karp algorithm due to its average-case efficiency with a rolling hash mechanism. # Challenge Implement the Rabin-Karp algorithm to search for a pattern in a given text. Additionally, extend the solution to return all occurrences of the pattern in the text. This will involve modifying the provided base rolling hash mechanism. # Specifications: 1. Implement the `rabin_karp_extended` function to return a list of the starting indexes of all occurrences of the pattern within the text. 2. Ensure your solution handles various edge cases and runs efficiently for larger inputs. # Requirements: * **Function Name**: `rabin_karp_extended` * **Input**: * `text` (str) - The text in which to search for the pattern. * `pattern` (str) - The pattern to be searched within the text. * **Output**: * `List[int]` - A list of starting indices where the pattern is found in the text. If the pattern is not found, return an empty list. * **Constraints**: * 1 ≤ len(pattern) ≤ len(text) ≤ 10^6 # Example: ```python def rabin_karp_extended(text, pattern): # Implementation here # Example usage: text = \\"abracadabra\\" pattern = \\"abra\\" print(rabin_karp_extended(text, pattern)) # Output: [0, 7] text = \\"aaaaa\\" pattern = \\"aa\\" print(rabin_karp_extended(text, pattern)) # Output: [0, 1, 2, 3] text = \\"abcd\\" pattern = \\"ef\\" print(rabin_karp_extended(text, pattern)) # Output: [] ``` Notes: - Take special care of edge cases where text or pattern might be empty or where the pattern length exceeds the text length. - Focus on the efficiency of your implementation to handle large inputs effectively.","solution":"def rabin_karp_extended(text, pattern): Implementation of the Rabin-Karp algorithm to find all occurrences of the pattern in the given text. Returns a list of starting indices where the pattern is found in the text. if not text or not pattern or len(pattern) > len(text): return [] n = len(text) m = len(pattern) base = 256 prime = 101 hpattern = 0 htext = 0 multiplier = 1 matches = [] for i in range(m - 1): multiplier = (multiplier * base) % prime for i in range(m): hpattern = (hpattern * base + ord(pattern[i])) % prime htext = (htext * base + ord(text[i])) % prime for i in range(n - m + 1): if hpattern == htext: if text[i:i + m] == pattern: matches.append(i) if i < n - m: htext = (base * (htext - ord(text[i]) * multiplier) + ord(text[i + m])) % prime if htext < 0: htext += prime return matches"},{"question":"# Matrix Inversion Coding Challenge **Context**: You are tasked with implementing a function to invert an `n x n` matrix using the classical method involving minors, cofactors, and adjugation. This function should be robust and handle typical edge cases such as non-square matrices and singular matrices. **Function Signature**: ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` **Expected Inputs and Output**: * **Input**: * A 2D list `matrix` representing an `n x n` matrix of floats. * The matrix is guaranteed to have at least 2 rows and columns. * **Output**: * A 2D list representing the inverted matrix if the matrix is invertible. * Return a special matrix `[[ -1 ]]` for invalid matrices, `[[ -2 ]]` for non-square matrices, and `[[ -4 ]]` for singular matrices. **Constraints**: * The matrix elements are real numbers. * You should not use any library functions for matrix inversion. **Edge Cases to Handle**: 1. Matrices that are not square. 2. Singular matrices (determinant equals zero). 3. Extremely large or extremely small values (floating-point precision). **Performance Requirements**: * Aim for a solution with time complexity (O(n^3)) and space complexity (O(n^2)). Here\'s your task: * Implement the core function `invert_matrix` that uses helper functions to: * Compute the matrix of minors. * Generate the matrix of cofactors. * Perform matrix adjugation. * Multiply the adjugate by the reciprocal of the determinant. **Helper Functions** that you might need to implement: * `def get_determinant(matrix: List[List[float]]) -> float`: Recursively calculate the determinant. * `def get_matrix_of_minors(matrix: List[List[float]]) -> List[List[float]]`: Generate the matrix of minors. * `def transpose_matrix(matrix: List[List[float]]) -> List[List[float]]`: Transpose the matrix. * `def multiply_matrix_by_scalar(matrix: List[List[float]], scalar: float) -> List[List[float]]`: Multiply the matrix by a scalar. **Example**: ```python matrix = [ [4, 7], [2, 6] ] # Expected Output: # [[0.6, -0.7], # [-0.2, 0.4]] inverted_matrix = invert_matrix(matrix) ```","solution":"from typing import List def get_determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0.0 for c in range(n): minor = [[matrix[i][j] for j in range(n) if j != c] for i in range(1, n)] determinant += ((-1) ** c) * matrix[0][c] * get_determinant(minor) return determinant def get_matrix_of_minors(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) minors = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): minor = [ [matrix[x][y] for y in range(n) if y != j] for x in range(n) if x != i ] minors[i][j] = get_determinant(minor) return minors def transpose_matrix(matrix: List[List[float]]) -> List[List[float]]: return [list(row) for row in zip(*matrix)] def multiply_matrix_by_scalar(matrix: List[List[float]], scalar: float) -> List[List[float]]: return [[element * scalar for element in row] for row in matrix] def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) # Check if the matrix is square if any(len(row) != n for row in matrix): return [[-2]] determinant = get_determinant(matrix) if determinant == 0: return [[-4]] # Compute the matrix of minors minors = get_matrix_of_minors(matrix) # Compute the cofactor matrix cofactors = [[minors[i][j] * ((-1) ** (i + j)) for j in range(n)] for i in range(n)] # Transpose the cofactor matrix to get the adjugate adjugate = transpose_matrix(cofactors) # Multiply the adjugate by the reciprocal of the determinant to get the inverse inverse = multiply_matrix_by_scalar(adjugate, 1.0 / determinant) return inverse"},{"question":"You are tasked with implementing a modified version of the Bitonic Sort algorithm. This version will sort arrays of integers both in increasing and decreasing order. Additionally, it must handle edge cases where the array size is not a power of two by padding the array with a maximum integer value until the closest power of two is reached. # Requirements: 1. **Function Name**: `modified_bitonic_sort` 2. **Input**: * An array of integers `arr` (not necessarily of size power of two). * A boolean `reverse`, which indicates whether the array should be sorted in descending order (`True`) or ascending order (`False`). 3. **Output**: * The sorted array. 4. **Constraints**: * If the input array size is not a power of two, pad it with `float(\'inf\')` for ascending (`reverse=False`) or `-float(\'inf\')` for descending (`reverse=True`) until the closest power of two is reached. Remove the padded elements before returning the sorted result. * The array can be of any length (including zero or one). # Example: ```python def modified_bitonic_sort(arr, reverse=False): # Your code here pass # Test Cases print(modified_bitonic_sort([3, 7, 2, 8, 1, 5, 4], False)) # Output: [1, 2, 3, 4, 5, 7, 8] print(modified_bitonic_sort([3, 7, 2, 8, 1, 5, 4], True)) # Output: [8, 7, 5, 4, 3, 2, 1] print(modified_bitonic_sort([], False)) # Output: [] print(modified_bitonic_sort([42], False)) # Output: [42] print(modified_bitonic_sort([6, 3], True)) # Output: [6, 3] ``` # Notes: * Ensure that you handle edge cases where the input array might be empty or of size one. * Properly adjust the array size for non-power-of-two cases by padding appropriately before the sort. * Write clear and concise code considering the time complexity and space optimization.","solution":"import math def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction and arr[i] > arr[i + k]) or (not direction and arr[i] < arr[i + k]): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, True) bitonic_sort(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def next_power_of_two(n): return 1 << (n - 1).bit_length() def modified_bitonic_sort(arr, reverse=False): n = len(arr) if n == 0 or n == 1: return arr pow_two = next_power_of_two(n) padding_value = float(\'inf\') if not reverse else -float(\'inf\') arr.extend([padding_value] * (pow_two - n)) bitonic_sort(arr, 0, pow_two, not reverse) result = arr[:n] return result"},{"question":"# Scenario: You are tasked with designing a search component for a library\'s book tracking system. The system maintains a list of book IDs, and you must efficiently locate the position of a specific book ID within this list. Given the simplicity and diversity of the books list, you decide to start with a linear search approach. # Task: Write a function `find_book_position` that takes in an array of integers representing book IDs and an integer representing the book ID to search for. Your function should return the index of the book ID if it\'s found, or -1 if the book ID does not exist in the array. # Input: - An array of integers `book_ids` (1 ≤ book_ids.length ≤ 10^4) representing the book IDs. - An integer `target_id` representing the book ID to be found. # Output: - Return an integer representing the index of the `target_id` in the `book_ids` array. If the target ID is not found, return -1. # Constraints: - The array might include negative IDs or repeated IDs. - Handling input as efficiently as possible is necessary but does not need optimization beyond linear search. # Example: ```python >> find_book_position([1001, 1002, 1003, 1004, 1005], 1003) 2 >> find_book_position([1001, 1002, 1003, 1004, 1005], 1006) -1 ``` # Note: You should consider edge cases such as an empty array or a book ID that is not present in the list at all.","solution":"def find_book_position(book_ids, target_id): Returns the index of the target_id in the book_ids list. If target_id is not found, returns -1. for index, book_id in enumerate(book_ids): if book_id == target_id: return index return -1"},{"question":"You are given a file containing a sequence of alphabets. You need to write two functions: one to encode this sequence and another to decode it. The encoding should use Run-Length Encoding (RLE), and the decoding should reverse this operation. The encoded sequence should be saved into another file, and decoding should retrieve the original file content. # Requirements: 1. Write a function `encode_file(input_filename: str, encoded_filename: str) -> None`: - **Input**: - `input_filename (str)`: The name of the file with the original data. - `encoded_filename (str)`: The name of the file where the encoded data will be saved. - **Output**: This function saves the encoded data to the specified file. 2. Write a function `decode_file(encoded_filename: str, decoded_filename: str) -> None`: - **Input**: - `encoded_filename (str)`: The name of the file with the encoded data. - `decoded_filename (str)`: The name of the file where the decoded data will be saved. - **Output**: This function saves the decoded data to the specified file which should match the original input data. # Constraints: * The input file will contain only alphabetic characters (both upper-case and lower-case). * The length of the file\'s content can be up to 1,000,000 characters. # Performance Requirements: * Your solution should strive for an efficient O(n) time complexity for both encoding and decoding. # Example: * Suppose `data.txt` contains: `AAAABBBCCDAA` * After encoding, `encoded.txt` should contain: `4A3B2C1D2A` * After decoding using `encoded.txt`, `decoded.txt` should contain: `AAAABBBCCDAA` # Implementation: Write the `encode_file` and `decode_file` functions to meet the requirements stated above.","solution":"def encode_file(input_filename: str, encoded_filename: str) -> None: Encodes the contents of the input file using Run-Length Encoding (RLE) and saves the encoded data to the specified output file. with open(input_filename, \'r\') as infile: data = infile.read() encoded_data = [] i = 0 while i < len(data): count = 1 while i + 1 < len(data) and data[i] == data[i + 1]: i += 1 count += 1 encoded_data.append(f\\"{count}{data[i]}\\") i += 1 with open(encoded_filename, \'w\') as outfile: outfile.write(\\"\\".join(encoded_data)) def decode_file(encoded_filename: str, decoded_filename: str) -> None: Decodes the contents of the encoded file using Run-Length Encoding (RLE) and saves the decoded data to the specified output file. with open(encoded_filename, \'r\') as infile: encoded_data = infile.read() decoded_data = [] i = 0 while i < len(encoded_data): count = 0 while i < len(encoded_data) and encoded_data[i].isdigit(): count = count * 10 + int(encoded_data[i]) i += 1 if i < len(encoded_data): decoded_data.append(encoded_data[i] * count) i += 1 with open(decoded_filename, \'w\') as outfile: outfile.write(\\"\\".join(decoded_data))"},{"question":"# Randomized Set Data Structure Implementation **Scenario**: You are working on a game development project where you need to maintain a collection of items such that you can efficiently: 1. Insert new items. 2. Remove existing items. 3. Retrieve a random item from the collection. You need a data structure that supports these operations with average O(1) time complexity to ensure the game\'s performance is optimal. **Task**: Implement a class `RandomizedSet` that supports the following methods: - `insert(val)`: Inserts an item `val` to the set if it is not already present. Returns `True` if the item was inserted, `False` otherwise. - `remove(val)`: Removes an item `val` from the set if present. Returns `True` if the item was removed, `False` otherwise. - `random_element()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. **Constraints**: - All values (val) will be integers and unique in the set. - The set can handle integers in the range -10^6 to 10^6. **Example**: ```python rs = RandomizedSet() assert rs.insert(1) == True # Insert 1: returns True assert rs.insert(2) == True # Insert 2: returns True assert rs.insert(1) == False # Attempt to insert 1 again: returns False assert rs.random_element() in [1, 2] # Randomly returns either 1 or 2 assert rs.remove(1) == True # Remove 1: returns True assert rs.remove(1) == False # Attempt to remove 1 again: returns False assert rs.random_element() == 2 # Randomly returns 2 ``` Implement the `RandomizedSet` class and ensure all methods meet the specified requirements.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val): if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val): if val not in self.dict: return False last_element = self.list[-1] idx_to_remove = self.dict[val] self.list[idx_to_remove] = last_element self.dict[last_element] = idx_to_remove self.list.pop() del self.dict[val] return True def random_element(self): return random.choice(self.list)"},{"question":"# Moving Average Calculation **Scenario**: You are a data analyst for a financial company monitoring real-time stock prices. Your task is to implement an efficient method to calculate the moving average of stock prices over a fixed number of days. This moving average helps in smoothing out the price data, thus identifying trends more easily. **Instructions**: Write a Python class `MovingAverage` that calculates the moving average from a stream of integers representing stock prices. Class `MovingAverage`: - **Constructor**: - `__init__(size: int)`: Initializes the data structure with the size of the sliding window. - **Function**: - `next(val: int) -> float`: Takes an integer `val` representing the next stock price, adds it to the sliding window, and returns the current moving average of the numbers within the window. Constraints: - The window size will always be a positive integer. - The stream of integers (`val`) will always be non-negative and fits within the typical integer range. - Ensure that the class efficiently handles a stream without excessive computation. Example: ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ``` **Note**: - The resulting value should be a floating-point number. - The output should be precise up to at least one decimal point. **Hints**: - Consider maintaining a running sum to optimize the computation of the average. - Make use of Python\'s `collections.deque` which helps maintain the sliding window efficiently.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage with a fixed window size. self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: Add the next value to the sliding window and return the moving average. if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"Efficient Text Search Scenario You are working as a software developer in a company that processes large texts. One of the tasks you routinely perform is to search for specific patterns within these texts. To do this efficiently, given the large volume of text data, you decide to implement the Knuth-Morris-Pratt (KMP) algorithm which is known for its linear time complexity for string matching. Task Write a function to find all the start indices of a given pattern in a provided text using the Knuth-Morris-Pratt (KMP) algorithm. Function Signature ```python def kmp_search(text: str, pattern: str) -> List[int]: Search for all occurrences of the \'pattern\' in the \'text\' and return the starting indices. Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search in the text. Returns: List[int]: A list of starting indices (0-based) where pattern is found in the text. Constraints: 1 <= len(text) <= 10^5 1 <= len(pattern) <= 10^4 Examples: >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> kmp_search(\\"AABAACAADAABAABA\\", \\"AABA\\") [0, 9, 12] pass ``` Additional Information Consider edge cases such as: 1. Empty inputs (either text or pattern). 2. Patterns that do not exist in the text. 3. Patterns that are longer than the text. 4. Text or pattern consisting of repeating characters. Implement and optimize the `kmp_search` function ensuring all these edge cases are accounted for, while maintaining expected time and space complexity.","solution":"from typing import List def kmp_search(text: str, pattern: str) -> List[int]: Search for all occurrences of the \'pattern\' in the \'text\' and return the starting indices. Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search in the text. Returns: List[int]: A list of starting indices (0-based) where pattern is found in the text. if not text or not pattern: return [] if len(pattern) > len(text): return [] # Preprocess the pattern to create the longest prefix suffix (LPS) array def compute_lps_array(pattern: str) -> List[int]: lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps_array(pattern) i = 0 # index for text j = 0 # index for pattern result = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Ternary Search Implementation Background Ternary Search is a search algorithm that divides the large search space into three smaller chunks, compared to two in Binary Search. This algorithm is primarily effective on a sorted array. It reduces the search domain to one-third each recursive call and continues narrowing until the element is found or deemed absent. Given the following function: ```python def ternary_search(left, right, key, arr): ``` Where: * `left`: the starting index of the array segment currently under investigation. * `right`: the ending index of the array segment currently under investigation. * `key`: the element we are searching for. * `arr`: the sorted array where the search will be conducted. Task Implement the above `ternary_search` function which returns the index of the `key` in the array if found, and `-1` otherwise. Input and Output * Input: - `left`: Integer, the starting index (0 ≤ left < n). - `right`: Integer, the ending index (0 < right ≤ n-1). - `key`: Integer, the element to search for. - `arr`: List of integers, the sorted array. * Output: - Integer, the index of the `key` in the array if found; otherwise `-1`. Constraints 1. The array `arr` must be sorted in ascending order. 2. Assume no duplicates in the array. Example Consider the array `arr = [1, 2, 4, 5, 6, 8, 9]`: * If `key = 5`, the function should return `3`. * If `key = 10`, the function should return `-1`. ```python # Function Signature def ternary_search(left, right, key, arr): # Your implementation here ``` Notes * Pay attention to the exit conditions to prevent infinite loops or out-of-bound errors. * Consider edge cases such as: * An array with a single element. * An empty array. * Element not present within the array range.","solution":"def ternary_search(left, right, key, arr): Performs a ternary search on a sorted array for a given key. Arguments: left : int : the starting index of the array segment right : int : the ending index of the array segment key : int : the element to search for arr : list of ints : the sorted array Returns: int : the index of the key in the array if found, otherwise -1 if right >= left: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(left, mid1 - 1, key, arr) elif key > arr[mid2]: return ternary_search(mid2 + 1, right, key, arr) else: return ternary_search(mid1 + 1, mid2 - 1, key, arr) return -1"},{"question":"You are required to implement the `top_1` function which determines the mode(s) of an array of integers. The function should return a list containing all the values that are most frequent in the array. Function Signature ```python def top_1(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): A list of integers. It may contain duplicates and can be empty. The length of the array `n` satisfies (0 leq n leq 10^6). Output - A list of integers containing all the most frequent elements in the input array. If the input array is empty, return an empty list. Constraints - The performance should be efficient enough to handle large arrays up to one million elements. Example ```python assert top_1([1, 1, 2, 2, 3, 4]) == [1, 2] assert top_1([1, 2, 3, 4, 5, 6, 6]) == [6] assert top_1([10]) == [10] assert top_1([]) == [] ``` Additional Context The array may contain negative numbers or zeros. Values that occur with the highest frequency must be returned in the same order they first appeared in the array.","solution":"from typing import List from collections import Counter def top_1(arr: List[int]) -> List[int]: Determines the mode(s) of an array of integers. Returns a list containing all the values that are most frequent in the array. if not arr: return [] frequency = Counter(arr) max_freq = max(frequency.values()) modes = [num for num, freq in frequency.items() if freq == max_freq] return modes"},{"question":"# Digit Power Sum Identification Scenario You are tasked with writing a function that identifies special numbers within a given range. These are numbers for which the sum of each digit raised to consecutive powers (starting from 1) equals the number itself. This concept is named \\"Eureka numbers.\\" # Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` # Input * `low` (integer): The lower bound of the range (inclusive). * `high` (integer): The upper bound of the range (inclusive). # Output * List of integers: A list of numbers within the specified range that satisfy the condition. # Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Constraints * `1 <= low <= high <= 10^6` # Explanation Write a function `sum_dig_pow` which takes two integers `low` and `high` and returns a list of numbers between this range (inclusive) for which the sum of each digit raised to consecutive powers equals the number itself. The range constraints ensure a broad yet feasible computational task, testing efficiency and correctness under upper limits. **Performance Requirements**: While exact performance bounds aren\'t strict, it should efficiently handle large ranges (e.g., up to one million).","solution":"def sum_dig_pow(low, high): Finds and returns a list of numbers within the specified range such that the sum of each digit of the number raised to consecutive powers equals the number itself. result = [] for num in range(low, high + 1): if is_eureka(num): result.append(num) return result def is_eureka(num): Checks if a number is a Eureka number. digits = [int(d) for d in str(num)] return sum(d ** (i + 1) for i, d in enumerate(digits)) == num"},{"question":"# Question: Implement RLE with Improved Handling for Large Data As an engineer at a data compression startup, you have been tasked with improving the company\'s run-length encoding implementation to better handle large datasets. ESPECIALLY when the data does not compress well, such as repeated patterns of length one or two. Functions to Implement: 1. **encode_rle(input: str) -> str** - Input - `input`: a string representing the data to be encoded. - Output - Returns the encoded string using run-length encoding. - Constraints - The input string length will not exceed 10^6. 2. **decode_rle(input: str) -> str** - Input - `input`: a string representing the data to be decoded. - Output - Returns the decoded string using run-length decoding. - Constraints - The encoded string length will not exceed 10^6. Performance Requirements: - The encoding and decoding processes should each have a time complexity of O(n), where n is the length of the input string. Example: 1. **Encoding** ```python assert encode_rle(\\"aaaabbbcc\\") == \\"4a3b2c\\" assert encode_rle(\\"abc\\") == \\"1a1b1c\\" ``` 2. **Decoding** ```python assert decode_rle(\\"4a3b2c\\") == \\"aaaabbbcc\\" assert decode_rle(\\"1a1b1c\\") == \\"abc\\" ``` Detailed Scenario: In a push for better performance, your company\'s product has to handle more significant data efficiently. Clients are pushing for maximum compression with minimal loss of time. Your task is to implement the `encode_rle` and `decode_rle` functions, keeping edge cases and efficiency in mind. **Considerations:** - Pay attention to potential edge cases such as empty input and very short sequences. - Ensure that your implementation can handle large datasets without excessive memory use or time delays.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"**Single Number Detection with Linear Complexity** **Problem Statement:** Given an array of integers where every element appears exactly twice except for one element that appears an odd number of times, write a function that finds and returns the element that appears an odd number of times. Your solution must have a linear runtime complexity and should not use any extra memory. **Function Signature:** ```python def single_number(nums: List[int]) -> int: ``` **Input:** - `nums`: A list of integers where each integer appears exactly twice except for one which appears an odd number of times. - `1 <= len(nums) <= 3 * 10^4` - `-3 * 10^4 <= nums[i] <= 3 * 10^4` **Output:** - An integer representing the single element that appears an odd number of times. **Constraints:** - Your algorithm must have a linear runtime complexity (O(n)). - You are not allowed to use any additional data structures (like a set or dictionary) or extra memory. **Example:** ```python assert single_number([2, 2, 1]) == 1 assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([1]) == 1 assert single_number([0, 1, 0, 1, 99]) == 99 ``` **Explanation:** The algorithm uses bitwise XOR to determine the single number. The XOR operation has the property that `a ^ a = 0` and `a ^ 0 = a`. Thus, when XOR is applied iteratively across the array, duplicate pairs cancel out to zero, and the remaining number is the single occurrence number.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single number that appears an odd number of times in an array where every other element appears exactly twice. result = 0 for num in nums: result ^= num return result"},{"question":"Problem Statement You are given a binary search tree consisting of nodes with integer values. Your task is to implement the function `binary_search_tree_to_list(root)` which converts the binary search tree into a doubly linked list in-place. The doubly linked list should preserve the in-order sequence of the binary search tree. The doubly linked list should be represented by modifying the pointers `left` and `right` within the tree nodes: - `left` should point to the previous node in the doubly linked list. - `right` should point to the next node in the doubly linked list. Implement the function and ensure the conversion is done efficiently both in terms of time and space. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_search_tree_to_list(root: TreeNode) -> TreeNode: # Your implementation here ``` Input * The input is the root node of a binary search tree, `root`, where each node has the attributes `val`, `left`, and `right`. Output * The function should return the head of the doubly linked list. Constraints * The node values are distinct integers. * The number of nodes in the tree is between `0` and `10^4`. Example Consider the given binary search tree: ``` 4 / 2 5 / 1 3 ``` Calling `binary_search_tree_to_list(root)` should convert it to a doubly linked list in the following in-order sequence: ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Here, each node\'s `left` points to the previous node and `right` points to the next node in the sequence. Additional Notes * You should handle edge cases like an empty tree (null root) and trees with a single node. * Ensure that your implementation is efficient and can handle large inputs up to the constraint limits.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_search_tree_to_list(root: TreeNode) -> TreeNode: def inorder_traversal(node): nonlocal last, head if not node: return # Traverse the left subtree inorder_traversal(node.left) # If last is None, it means this is the leftmost node (first node in the list) if last: # Modify the pointers last.right = node node.left = last else: head = node # Move last to the current node last = node # Traverse the right subtree inorder_traversal(node.right) if not root: return None last, head = None, None inorder_traversal(root) return head"},{"question":"# Question: Advanced GCD and Bitwise Operations Function Implementation You are given a task to write a function that combines the concepts of the greatest common divisor (GCD) and bitwise operations. The function should compute the GCD of two non-negative integers using bitwise operators. This task is to assess your understanding and ability to implement bitwise operations efficiently. Function Signature ```python def advanced_gcd_bitwise(a: int, b: int) -> int: Calculate the greatest common divisor of two non-negative integers using bitwise operations. :param a: Non-negative integer :param b: Non-negative integer :return: The GCD of a and b pass ``` # Function Description You need to implement a function `advanced_gcd_bitwise` that computes the GCD of two non-negative integers using bitwise operations. # Requirements: 1. The function should leverage bitwise operations to optimize the GCD calculation process. 2. Do not use the standard arithmetic operations except for absolute value and comparison. 3. Ensure the function handles edge cases where `a` or `b` is zero. 4. Consider both the iterative and recursive approach and explain the thought process behind your implementation. # Input Format: - Two non-negative integers `a` and `b`. # Output Format: - Return the GCD of `a` and `b`. # Constraints: - (0 le a, b le 10^9) # Example: ```python print(advanced_gcd_bitwise(48, 18)) # Output: 6 print(advanced_gcd_bitwise(101, 10)) # Output: 1 ``` # Hints: - Utilize the properties of bitwise operations such as shifting and AND. - Consider implementing a helper function to count trailing zeros as it can be helpful in your solution.","solution":"def advanced_gcd_bitwise(a: int, b: int) -> int: Calculate the greatest common divisor of two non-negative integers using bitwise operations. :param a: Non-negative integer :param b: Non-negative integer :return: The GCD of a and b def gcd(x, y): if x == 0: return y if y == 0: return x # Finding common factors of two numbers using bitwise shifts # Trailing zeros count shift = 0 while ((x | y) & 1) == 0: x >>= 1 y >>= 1 shift += 1 while (x & 1) == 0: x >>= 1 while y != 0: while (y & 1) == 0: y >>= 1 if x > y: x, y = y, x y -= x return x << shift return gcd(a, b)"},{"question":"# Rabin-Karp Enhanced String Matching You are given two strings, `text` and `word`. Your task is to identify all starting indexes where `word` appears in `text` using an enhanced version of the Rabin-Karp algorithm. Implement the function `find_occurrences` to return a list of all such starting indexes. # Function Signature ```python def find_occurrences(text: str, word: str) -> List[int]: pass ``` # Input - `text` (string): The text in which to search for the occurrences. 1 ≤ len(text) ≤ 10^5. - `word` (string): The word to search for within the text. 1 ≤ len(word) ≤ 10^4. # Output - List of starting indices where the word is found in text. If the word is not found, return an empty list. # Constraints - The comparison should ignore hash collisions by direct string matching after hash comparison. - Handle large inputs efficiently to maintain a linear average-case time complexity. # Example ```python # Example 1: text = \\"this is a test text\\" word = \\"test\\" # Output: [10] # Example 2: text = \\"abababab\\" word = \\"abab\\" # Output: [0, 2, 4] # Example 3: text = \\"hello world\\" word = \\"ooo\\" # Output: [] ``` # Edge Cases - If `word` is empty, return an empty list. - If `word` is longer than `text`, return an empty list. # Additional Notes - Ensure to consider rolling hash and modulo arithmetic while computing the hash. - Verify potential matches to prevent false positives due to hash collisions.","solution":"def find_occurrences(text, word): Returns a list of starting indices where word is found in text using Rabin-Karp algorithm. if len(word) == 0 or len(word) > len(text): return [] base = 256 # Number of characters in the input alphabet prime = 101 # A prime number to use for modulo calculations word_hash = 0 # Hash value for word text_hash = 0 # Hash value for text positions = [] # List to store the positions of matches n = len(text) m = len(word) h = 1 # The value of h would be \\"pow(base, m-1)%prime\\" for i in range(m-1): h = (h * base) % prime # Calculate the hash value of the word and the first window of text for i in range(m): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current window of text and word if word_hash == text_hash: # Check for characters one by one if text[i:i + m] == word: positions.append(i) # Calculate hash value for next window of text: Remove leading digit, add trailing digit if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # We might get negative value of text_hash, converting it to positive if text_hash < 0: text_hash = text_hash + prime return positions"},{"question":"# Exponentiation Problem **Problem Statement:** You are tasked with designing a function to compute the power of a given base using binary exponentiation method. Your solution should account for both regular and modular calculations efficiently. **Function Signature:** ```python def power(a: int, n: int, mod: int = None) -> int: pass ``` **Inputs:** * `a` (int): The base number (1 ≤ a ≤ 10^9). * `n` (int): The exponent (0 ≤ n ≤ 10^9). * `mod` (int): An optional integer modulus (1 ≤ mod ≤ 10^9, if provided). **Outputs:** * Returns the result of ( a^n ). If `mod` is provided, return ( (a^n) mod mod ). **Constraints:** * You must use the binary exponentiation method. * Handle edge cases where `n` is zero or very large. **Example:** ```python assert power(2, 10) == 1024 assert power(2, 10, 1000) == 24 assert power(3, 0) == 1 assert power(3, 7) == 2187 assert power(3, 7, 100) == 87 ``` **Detailed Requirements:** 1. **Iterative Implementation:** * Your function must include an efficient iterative implementation. * Ensure modulo calculations are done during intermediate operations if `mod` is provided to avoid overflows and maintain efficiency. 2. **Recursive Implementation:** (Optional Bonus) * Implement a recursive version as an additional bonus task. * Ensure that the recursive depth does not lead to excessive stack memory usage. **Test Cases:** * Include tests for edge cases like `a` and `n` being at their minimum and maximum. For example, test with zero exponent and maximum base value to validate performance and correctness.","solution":"def power(a: int, n: int, mod: int = None) -> int: Computes the power a^n using binary exponentiation. If mod is provided, returns (a^n) % mod. result = 1 base = a if mod: base = base % mod while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n = n // 2 return result # Adding tests here to check the function interactively def _test(): assert power(2, 10) == 1024 assert power(2, 10, 1000) == 24 assert power(3, 0) == 1 assert power(3, 7) == 2187 assert power(3, 7, 100) == 87 print(\\"All interactive tests passed.\\") _test()"},{"question":"# Binary Tree Path Finder As a software developer, you must implement a function that computes all root-to-leaf paths in a given binary tree. Each path should be returned as a string formatted using \'->\' to separate node values from root to leaf. Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` Input * `root`: A reference to the root node of a binary tree. Output * `List[str]`: A list of strings, where each string is a path from the root to a leaf. Constraints * The number of nodes in the tree is in the range [0, 1000]. * The node values are integer values which can be positive, negative, or zero. Example ```python # Example 1 Input: root = [1, 2, 3, None, 5] Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2 Input: root = [1] Output: [\\"1\\"] ``` Scenario/Context In navigating the structure of a binary tree for a navigation or routing system, it is essential to list all unique paths from the starting point to the end points efficiently. This is useful in various applications like network routing, genealogy tracking, or decision-making pathways. Tips 1. Ensure to handle edge cases such as when the tree is empty. 2. Optimize your recursive function to avoid excessive memory usage. 3. Consider verifying all paths result in correct formatting and order. Implement the function: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> List[str]: # Your code goes here ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def build_paths(node: TreeNode, path: str, paths: List[str]): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' build_paths(node.left, path, paths) build_paths(node.right, path, paths) paths = [] build_paths(root, \'\', paths) return paths"},{"question":"You are working on a program that involves frequent calculations of the number of digits in various integers. To optimize this, you need to write a highly efficient function. The function should handle both positive and negative integers as well as zero. Task Implement a function `num_digits(n: int) -> int` that returns the number of digits in the given integer `n`. Input * An integer `n` where `-10^15 <= n <= 10^15`. Output * An integer representing the number of digits in `n`. Examples ```python assert num_digits(123) == 3 assert num_digits(-7890) == 4 assert num_digits(0) == 1 assert num_digits(1000000000000000) == 16 ``` Constraints * The function should have a time complexity of O(1). * Ensure the function handles 0 correctly by returning 1. Additional Information The function uses mathematical properties, specifically logarithms, to determine the number of digits. Consider edge cases such as the smallest possible integer and zero. Ensure your implementation is robust to handle any integer within the provided constraints.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the given integer n. Handles both positive and negative integers, as well as zero. if n == 0: return 1 # Convert to positive to simplify digit counting n = abs(n) # Count the number of digits return len(str(n))"},{"question":"# Reversing Words in a Sentence You need to write a function that reverses the order of words in a given sentence, maintaining the in-place reversal for optimal space efficiency. A word is defined as a contiguous sequence of non-space characters. The words in the sentence will be separated by one or more spaces. Input: - A string `s` composed of upper and lower case letters and spaces. Output: - A string with the words in `s` reversed. Leading or trailing spaces should be removed, and any additional spaces between words should be reduced to a single space. Example: ```python Input: \\" Hello World! This is a test. \\" Output: \\"test. a is This World! Hello\\" ``` # Constraints - The length of the input string will not exceed 1000 characters. - No special characters other than letters and spaces. # Requirements 1. **Readability:** Ensure the code is clean, well-commented, and readable. 2. **Performance:** Aim for an O(n) time complexity solution and O(1) additional space complexity. 3. **Edge Cases:** Handle empty strings, excessively spaced strings, and all valid input constraints. # Function Signature ```python def reverse_words(s: str) -> str: # Your implementation here ```","solution":"def reverse_words(s: str) -> str: Reverses the order of words in a given sentence, reducing multiple spaces to a single space. # Split the string by spaces and filter out empty words words = s.split() # Reverse the list of words and join them with a single space reversed_sentence = \' \'.join(reversed(words)) return reversed_sentence"},{"question":"# Context: You have recently learned about various sorting algorithms in your Data Structures course. Some are efficient and widely used, while others serve as good conceptual lessons in algorithm design. Now, one of the most inefficacious yet interesting sorting algorithms, Bogo Sort, is presented for your programming challenge. # Task: Implement a function called `efficient_bogo_sort` that simulates an optimized version (as much as possible) of the Bogo Sort algorithm. The aim is to detect if the input array is already sorted before initiating the Bogo Sort process. **If the array is already sorted, return it right away without further action.** # Specification: - Function Name: `efficient_bogo_sort` - Input: A list of integers `arr`. - Output: A sorted list of integers. # Constraints: 1. The function should handle arrays of up to `n = 10` elements efficiently considering limitations of Bogo Sort. 2. Should avoid infinite execution on unsorted arrays by giving up after 750 shuffles, returning the best possible attempt. # Performance Requirements: - Though we optimize with an initial check and limit iterations, performance isn\'t guaranteed due to the nature of the algorithm. Focus on adhering to these constraints. # Example: ```python print(efficient_bogo_sort([3,2,1])) # Possible Output: [1, 2, 3] print(efficient_bogo_sort([1, 2, 3])) # Output: [1,2,3] ``` # Evaluation Criteria: - Correctness: Accurate sorting of arrays. - Efficiency: Early termination on sorted arrays. - Adherence to constraints and limits.","solution":"import random def efficient_bogo_sort(arr): Simulates an optimized version of Bogo Sort algorithm. If the array is already sorted, returns it right away. If unsorted, shuffles up to 750 times and returns the best attempt. :param arr: List of integers to be sorted. :return: Sorted list of integers. def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True if is_sorted(arr): return arr best_attempt = list(arr) best_sortedness = sum(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) for _ in range(750): random.shuffle(arr) if is_sorted(arr): return arr current_sortedness = sum(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) if current_sortedness > best_sortedness: best_attempt = list(arr) best_sortedness = current_sortedness return best_attempt"},{"question":"# Task Implement a function, `enhanced_shell_sort(arr: List[int]) -> List[int]`, which sorts an array of integers using the Shell Sort algorithm. Optimize the algorithm by using Marcin Ciura\'s gap sequence instead of the simple `n//2` reduction approach. Validate that your function correctly handles various edge cases such as empty arrays, single-element arrays, and arrays with identical elements. # Input Format * A list of integers, `arr`, where (0 leq text{len}(arr) leq 10^5). * Each integer in the list can range from (-10^9) to (10^9). # Output Format * A list of integers, which is the sorted version of the input list `arr`. # Constraints * Optimize for time complexity to be as close to (O(n log n)) as possible. * No additional data structures should be used for sorting (in-place sorting). # Performance Requirements Your implementation should handle large arrays efficiently within a reasonable time limit. # Example Input ```python arr = [23, -1, 4, 16, 75, 3, 50] ``` Output ```python [-1, 3, 4, 16, 23, 50, 75] ``` # Notes * Utilize Marcin Ciura\'s gap sequence for enhancement: `[701, 301, 132, 57, 23, 10, 4, 1]`. * Ensure to handle edge cases effectively.","solution":"from typing import List def enhanced_shell_sort(arr: List[int]) -> List[int]: Sort an array using the Shell Sort algorithm with Marcin Ciura\'s gap sequence. gaps = [701, 301, 132, 57, 23, 10, 4, 1] n = len(arr) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Context: You are given methods to serialize and deserialize a binary tree. Serialization converts the tree into a string, and deserialization converts the string back into the original tree structure. This serialization method uses pre-order traversal and denotes null nodes with \\"#\\". # Task: **Function Implementation:** - Implement a function to check whether two binary trees are structurally identical by comparing their serialized forms. # Input: - Two binary tree roots `root1` and `root2`. # Output: - Return `True` if the trees are structurally identical, otherwise return `False`. # Constraints: - The number of nodes in each tree is in the range [0, 1000]. - Each node\'s value is in the range [-1000, 1000]. # Example Usage: ```python # Tree 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root1.right.left = TreeNode(4) root1.right.right = TreeNode(5) # Tree 2 root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) root2.right.left = TreeNode(4) root2.right.right = TreeNode(5) # Should return True print(are_trees_identical(root1, root2)) # Tree 3 root3 = TreeNode(1) root3.left = TreeNode(2) # Should return False print(are_trees_identical(root1, root3)) ``` # Function Signature: ```python def are_trees_identical(root1: TreeNode, root2: TreeNode) -> bool: pass ``` # Notes: - Use the existing `serialize` function provided to help in your implementation. - Ensure that edge cases such as empty trees and single-node trees are handled correctly.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): Encodes a tree to a single string. :type root: TreeNode :rtype: str def helper(node): if node is None: return \\"#\\" return str(node.val) + \\",\\" + helper(node.left) + \\",\\" + helper(node.right) return helper(root) def are_trees_identical(root1, root2): Checks if two binary trees are structurally identical by comparing their serialized forms. :type root1: TreeNode :type root2: TreeNode :rtype: bool return serialize(root1) == serialize(root2)"},{"question":"# Question: You are tasked with implementing the K-Nearest Neighbors (K-NN) algorithm after analyzing the nearest neighbor algorithm. The K-NN algorithm classifies a given input vector by considering the \'k\' closest points from the training set and choosing the most common label among them. # Function Signature: ```python def k_nearest_neighbors(x, tSet, k): Classifies the input vector \'x\' by finding the k nearest neighbors from the training set \'tSet\' and returning the majority label. Args: x (tuple): A vector representing the input data point. tSet (dict): A dictionary where keys are vectors (tuples) representing training data points and values are their respective labels. k (int): The number of nearest neighbors to consider. Returns: label: The label of the majority among the k nearest neighbors. ``` # Input: - `x`: A tuple of numbers representing the input data point. - `tSet`: A dictionary where each key is a tuple representing a training data point and each value is the corresponding label. - `k`: An integer representing the number of nearest neighbors to consider. # Output: - Return the label, which is the most common among the k-nearest neighbors. # Constraints: - The dimensionality of the input vector `x` and the keys in `tSet` will always be the same. - `1 <= k <= len(tSet)`. # Example: ```python x = (1, 2) tSet = { (2, 3): \'A\', (3, 4): \'B\', (1, 3): \'A\', (5, 5): \'B\', (1, 1): \'A\' } k = 3 print(k_nearest_neighbors(x, tSet, k)) # Output: \'A\' ``` # Notes: - Ensure that you handle cases where the input vector `x` is equidistant to multiple points correctly. - Optimize the classification procedure for efficiency.","solution":"import math from collections import Counter def k_nearest_neighbors(x, tSet, k): Classifies the input vector \'x\' by finding the k nearest neighbors from the training set \'tSet\' and returning the majority label. Args: x (tuple): A vector representing the input data point. tSet (dict): A dictionary where keys are vectors (tuples) representing training data points and values are their respective labels. k (int): The number of nearest neighbors to consider. Returns: label: The label of the majority among the k nearest neighbors. # Calculate the distance between x and all points in the training set. distances = [] for train_point, label in tSet.items(): distance = math.sqrt(sum((x_i - train_i) ** 2 for x_i, train_i in zip(x, train_point))) distances.append((distance, label)) # Sort the distances list by distance and get labels of the k nearest neighbors. distances.sort(key=lambda item: item[0]) nearest_labels = [label for _, label in distances[:k]] # Find the most common label among the k nearest neighbors. most_common_label = Counter(nearest_labels).most_common(1)[0][0] return most_common_label"},{"question":"Context In cryptographic algorithms, it is often essential to compute modular inverses and solve certain class equations efficiently. To enable these computations, we need to find integers (s) and (t) such that: [ num1 times s + num2 times t = text{GCD}(num1, num2) ] This is known as finding Bézout coefficients and can be achieved using the extended Euclidean algorithm. Task Write a function `extended_gcd(num1, num2)` that returns a tuple ((s, t, text{gcd})), where (num1 times s + num2 times t = text{GCD}(num1, num2)). Input - `num1` (an integer) - `num2` (an integer) Output - A tuple `(s, t, gcd)` where `s` and `t` are the Bézout coefficients, and `gcd` is the greatest common divisor of `num1` and `num2`. # Constraints - ( -10^9 leq num1, num2 leq 10^9 ) - ( num1 neq 0 ) or ( num2 neq 0 ) Example ```python # Example 1: num1 = 56 num2 = 15 # Output: (-1, 4, 1) # Explanation: 56*(-1) + 15*4 = 1 (which is the GCD) # Example 2: num1 = 101 num2 = 10 # Output: (1, -10, 1) # Explanation: 101*1 + 10*(-10) = 1 (which is the GCD) ``` # Performance Requirements - The function should run efficiently for large integers, adhering to the constraints. - Avoid precision errors by using integer arithmetic.","solution":"def extended_gcd(num1, num2): Returns a tuple (s, t, gcd) such that num1 * s + num2 * t = GCD(num1, num2). This uses the extended Euclidean algorithm. if num1 == 0: return (0, 1, num2) else: s, t, gcd = extended_gcd(num2 % num1, num1) return (t - (num2 // num1) * s, s, gcd)"},{"question":"# **Coding Assessment Question** **Objective** You are provided with an unsorted array. Your task is to implement the Cycle Sort algorithm as described in the analysis to sort the array in ascending order. **Function Signature** ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` **Input** - `arr`: A list of integers (1 <= len(arr) <= 10^5; -10^6 <= arr[i] <= 10^6) **Output** - Returns a sorted list of integers. **Constraints** - You should maintain an in-place sort and achieve O(1) auxiliary space. - You must minimize the number of write operations to the array. **Performance Requirements** - Ensure the function handles up to 100,000 elements efficiently with optimized performance. - Avoid unnecessary comparisons and ensure the function can handle arrays with duplicate and negative integers. **Example** ```python assert cycle_sort([3, 1, 2]) == [1, 2, 3] assert cycle_sort([1, 4, 4, 2]) == [1, 2, 4, 4] assert cycle_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert cycle_sort([1, -1, 0]) == [-1, 0, 1] ``` **Implementation Requirements** - You must implement the algorithm from scratch following the principles of Cycle Sort. - Handle edge cases such as arrays with all elements being the same and arrays already sorted in ascending or descending order. Good luck with your implementation!","solution":"def cycle_sort(arr): Implements the Cycle Sort algorithm to sort the array in ascending order. Cycle sort is an in-place sorting algorithm, which minimizes the number of write operations. writes = 0 # keep the count of writes # Traverse the array and place the elements at their correct position for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the current item pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue if pos == cycle_start: continue # Otherwise, put the item to the right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"You are given an array of integers that needs to be sorted using heap sort. However, the twist is that you must implement both max-heap sort and min-heap sort, and compare their performance under different input conditions. # Requirements 1. Implement heap sorting using both max-heap and min-heap approaches. 2. Write a function to generate performance metrics (time taken and iterations) for each approach. # Tasks 1. **Max-Heap Sort**: * Implement the function `max_heap_sort(arr, simulation=False)` as given in the code snippet. * You may use the helper function `max_heapify` provided. 2. **Min-Heap Sort**: * Implement the function `min_heap_sort(arr, simulation=False)` as given in the code snippet. * Utilize the helper function `min_heapify` provided. 3. **Performance Metrics**: * Implement a function `compare_heap_sorts(arr)` that: - Accepts an input array. - Sorts the array using both max-heap sort and min-heap sort. - Returns a dictionary containing the time taken and the number of iterations performed by each method. # Function Signature ```python def max_heap_sort(arr: list, simulation: bool=False) -> list: pass def min_heap_sort(arr: list, simulation: bool=False) -> list: pass def compare_heap_sorts(arr: list) -> dict: Args: - arr: List[int], the input array to be sorted. Returns: A dictionary with the following format: { \\"max_heap_sort\\": { \\"time_taken\\": float, \\"iterations\\": int }, \\"min_heap_sort\\": { \\"time_taken\\": float, \\"iterations\\": int } } pass ``` # Constraints * You may assume that the input array does not contain any duplicate values. * You must use the provided heap sort templates. * You are allowed to use the `time` module to measure execution time. * The array `arr` will have at most 10^5 elements, and each element will be within the range of [-10^6, 10^6]. # Example ```python array = [3, 1, 5, 4, 2] compare_heap_sorts(array) # Expected Output (values will differ due to system performance): # { # \\"max_heap_sort\\": { # \\"time_taken\\": <some_float_value>, # \\"iterations\\": <some_int_value>, # }, # \\"min_heap_sort\\": { # \\"time_taken\\": <some_float_value>, # \\"iterations\\": <some_int_value>, # } # } ``` # Note Ensure that your implementation is efficient and correctly manages different array sizes.","solution":"import time def max_heapify(arr, n, i, simulation_count): largest = i left = 2 * i + 1 right = 2 * i + 2 if simulation_count is not None: simulation_count[0] += 1 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest, simulation_count) def min_heapify(arr, n, i, simulation_count): smallest = i left = 2 * i + 1 right = 2 * i + 2 if simulation_count is not None: simulation_count[0] += 1 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest, simulation_count) def max_heap_sort(arr, simulation=False): n = len(arr) simulation_count = [0] if simulation else None for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation_count) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0, simulation_count) if simulation: return arr, simulation_count[0] return arr def min_heap_sort(arr, simulation=False): n = len(arr) simulation_count = [0] if simulation else None for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation_count) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0, simulation_count) if simulation: return arr, simulation_count[0] return arr def compare_heap_sorts(arr): arr_copy = arr[:] # Max Heap Sort start_time = time.time() _, max_iterations = max_heap_sort(arr[:], simulation=True) max_time_taken = time.time() - start_time # Min Heap Sort start_time = time.time() _, min_iterations = min_heap_sort(arr_copy, simulation=True) min_time_taken = time.time() - start_time return { \\"max_heap_sort\\": { \\"time_taken\\": max_time_taken, \\"iterations\\": max_iterations }, \\"min_heap_sort\\": { \\"time_taken\\": min_time_taken, \\"iterations\\": min_iterations } }"},{"question":"# String Merging Problem Problem Statement You are given a target string `s`, and two other strings `part1` and `part2`. Write a function to determine if `s` can be formed by interleaving the characters of `part1` and `part2` in a way that the characters of `part1` and `part2` appear in the same order within `s`. Input * `s`: target string of length `n`. * `part1`: first part string of length `m`. * `part2`: second part string of length `k`. Output * Return `True` if `s` can be formed by interleaving `part1` and `part2` while maintaining their respective orders, otherwise return `False`. Constraints 1. Let `n`, `m`, `k` be non-negative integers. 2. String lengths satisfy ( n = m + k ). Example ```python # Example 1 s = \\"codewars\\" part1 = \\"cdw\\" part2 = \\"oears\\" # Expected output: True # Explanation: \'codewars\' can be formed by interleaving \'cdw\' and \'oears\': # c o d e w a r s = codewars # c d w = cdw # o e a r s = oears # Example 2 s = \\"aabcc\\" part1 = \\"abc\\" part2 = \\"ac\\" # Expected output: True # Explanation: \'aabcc\' can be formed by interleaving \'abc\' and \'ac\': # a a b c c = aabcc # a b c = abc # a c = ac ``` Function Signature ```python def can_merge_strings(s: str, part1: str, part2: str) -> bool: # Implement the function here pass ``` # Task Implement the `can_merge_strings` function using either a recursive approach with memoization or an iterative approach. Make sure to handle edge cases effectively and aim for optimal performance.","solution":"def can_merge_strings(s: str, part1: str, part2: str) -> bool: Determine if the string `s` can be formed by interleaving `part1` and `part2` while maintaining the order of characters in `part1` and `part2`. # lengths of the input strings n, m, k = len(s), len(part1), len(part2) # Edge case: if lengths don\'t add up, return False if n != m + k: return False # dp[i][j] will be True if s[:i+j] can be formed by interleaving part1[:i] and part2[:j] dp = [[False] * (k + 1) for _ in range(m + 1)] # Initialize the DP table dp[0][0] = True # Fill the DP table for i in range(m + 1): for j in range(k + 1): if i > 0 and dp[i - 1][j] and part1[i - 1] == s[i + j - 1]: dp[i][j] = True if j > 0 and dp[i][j - 1] and part2[j - 1] == s[i + j - 1]: dp[i][j] = True return dp[m][k]"},{"question":"# Context Imagine you\'re developing a feature for an application that needs to frequently maintain a sorted list of user scores. To efficiently insert new scores into the sorted list, you need to identify the correct position for each new score. # Problem Description Write a function `search_insert(array, val)` that takes a sorted list of integers `array` and an integer value `val`. Your function should determine the proper index at which `val` should be inserted to maintain the sorted order of `array`. If `val` is already present, return the index of its first occurrence. # Function Signature ```python def search_insert(array: List[int], val: int) -> int: # Your code here ``` Input/Output Format * **Input**: - `array`: A sorted list of integers (can be empty). - `val`: An integer to be inserted. * **Output**: - An integer representing the index where `val` should be inserted. Constraints * The length of `array` is between `0` to `10^5`. * The integers in `array` range between `-10^6` and `10^6`. * `val` is an integer within the same range as the elements in `array`. Examples ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 assert search_insert([], 3) == 0 ``` Notes - Ensure that your function runs in O(log n) time complexity. - Make sure to handle edge cases such as an empty array, values outside the range of the array, and scenarios where `val` equals the first or the last element.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Find the index at which val should be inserted in a sorted list array. If val is already present, return the index of its first occurrence. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 elif array[mid] > val: right = mid - 1 else: return mid return left"},{"question":"**Question: Design a Data Structure Supporting O(1) Operations** You have been provided with a partial implementation of a data structure `RandomizedSet` that supports the following operations in average O(1) time complexity: - **insert(val)**: Inserts an item `val` to the set if not already present. - **remove(val)**: Removes an item `val` from the set if present. - **random_element**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Your task is to complete the implementation of the `RandomizedSet` class. Ensure that all operations maintain an average time complexity of O(1). **Constraints**: - All values inserted into the `RandomizedSet` are integers. - The expected number of operations (insert, remove, and random_element) will not exceed (10^5). # Function Definitions: 1. **insert(self, val: int) -> bool**: - **Input**: An integer value `val`. - **Output**: Returns `True` if the element was successfully inserted; otherwise, returns `False` if the element already exists in the set. 2. **remove(self, val: int) -> bool**: - **Input**: An integer value `val`. - **Output**: Returns `True` if the element was successfully removed; otherwise, returns `False` if the element does not exist in the set. 3. **random_element(self) -> int**: - **Output**: Returns a random integer element from the set. All elements must have the same probability of being returned. # Example: ```python # Initialize an empty RandomizedSet rset = RandomizedSet() # Insert elements print(rset.insert(1)) # Output: True print(rset.insert(2)) # Output: True print(rset.insert(2)) # Output: False (already exists) # Remove element print(rset.remove(1)) # Output: True print(rset.remove(3)) # Output: False (does not exist) # Get random element print(rset.random_element()) # Output could be 2 print(rset.random_element()) # Output could be 2 (since it\'s the only element left) ``` Implement the `RandomizedSet` class such that it supports these operations efficiently.","solution":"import random class RandomizedSet: def __init__(self): Initialize the data structure. self.dict = {} self.list = [] def insert(self, val: int) -> bool: Inserts a value to the set. Returns True if the value was not present, False otherwise. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set. Returns True if the value was present, False otherwise. if val not in self.dict: return False # Move the last element to the place idx of the element to delete last_element = self.list[-1] idx = self.dict[val] self.list[idx] = last_element self.dict[last_element] = idx # Remove the last element from list self.list.pop() # Remove the element from dict del self.dict[val] return True def random_element(self) -> int: Get a random element from the set. return random.choice(self.list)"},{"question":"# Stooge Sort Implementation & Analysis Scenario You are tasked with designing an algorithm to sort a collection of integers. One potential algorithm you\'ve encountered is Stooge Sort. As inefficient as it might be, it offers a good exercise in understanding recursive processes. Implement a function `stooge_sort(arr)` that takes a list of integers `arr` as input and sorts it in ascending order using the Stooge Sort algorithm. Additionally, as part of your assignment, analyze its performance and deliberate on its practical applications. Function Signature ```python def stooge_sort(arr: List[int]) -> List[int]: # your code here ``` Input - A list of integers `arr` where `1 <= len(arr) <= 10^4` and `-10^9 <= arr[i] <= 10^9`. Output - A sorted list of integers in ascending order. Constraints - Perform the sort using the Stooge Sort algorithm as described above. - Consider the limitations of Python\'s recursion depth and optimize accordingly. - The function should handle all edge cases, such as empty lists and lists with one element. Performance Requirements - Understand this is a theoretical exercise. Though not efficient, ensure correct implementation. - Your final solution should be able to handle input sizes up to 300 to avoid hitting recursive stack limits. Example ```python input: [3, 5, 1, 4, 2] output: [1, 2, 3, 4, 5] input: [10, 9, 8, 7] output: [7, 8, 9, 10] input: [1] output: [1] input: [] output: [] ``` Additional Task Provide a short paragraph at the end of your implementation describing: 1. The practical implications of using Stooge Sort. 2. Why more efficient algorithms like MergeSort or QuickSort are preferred in realistic scenarios.","solution":"def stooge_sort(arr, l=0, h=None): if h is None: h = len(arr) - 1 if l >= h: return arr # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stooge_sort(arr, l, h - t) # Recursively sort the last 2/3 of the array stooge_sort(arr, l + t, h) # Recursively sort the first 2/3 of the array again stooge_sort(arr, l, h - t) return arr # Analysis: # Stooge Sort is highly inefficient with a time complexity of O(n^(log 3 / log 1.5)), # where n is the number of elements in the array. It is only of theoretical interest # and not used in practice due to its performance compared to more efficient # algorithms like MergeSort or QuickSort. MergeSort runs in O(n log n) time, # and QuickSort, while having an average-case time complexity of O(n log n), has # a worst-case time complexity of O(n^2). However, with proper implementation # (like using randomized pivot selection), it can be very efficient in practice."},{"question":"# Binary Search Challenge You are provided with two sorted arrays of integers. Your task is to determine the number of common elements between the two arrays using the Binary Search algorithm. Implement the function `count_common_elements(arr1, arr2)` that returns the number of common elements in the two sorted arrays `arr1` and `arr2`. The function signature ```python def count_common_elements(arr1, arr2): pass ``` Input * `arr1` - A sorted list of integers. * `arr2` - A sorted list of integers. Output An integer representing the number of common elements in both arrays. Constraints * 1 ≤ len(arr1), len(arr2) ≤ 10^5 * -10^9 ≤ arr1[i], arr2[i] ≤ 10^9 Example Input: ```python arr1 = [1, 3, 4, 6, 7, 9] arr2 = [1, 2, 4, 5, 9, 10] ``` Output: ``` 3 ``` Explanation: The common elements are `1, 4, 9`. Additional Information * The function should efficiently find the common elements leveraging the properties of the Binary Search algorithm. * You should not use any built-in functions for finding common elements directly (e.g., set intersections). * Consider edge scenarios such as empty arrays or arrays with no common elements.","solution":"def binary_search(arr, target): Function to perform binary search on a sorted array. Returns True if target is found, otherwise returns False. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return True elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return False def count_common_elements(arr1, arr2): Returns the number of common elements in two sorted arrays arr1 and arr2. count = 0 for element in arr1: if binary_search(arr2, element): count += 1 return count"},{"question":"# Problem Description You are given an array of integers which you need to sort in ascending order using the merge sort algorithm. The provided merge sort algorithm splits the array until each sub-array contains a single element, then merges the sub-arrays by comparing the elements and sorting them. You need to implement this algorithm ensuring that the array is sorted correctly. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input - `arr` (List[int]): An array of integers that can have up to 10^5 elements. The integer values range from -10^9 to 10^9. # Output - Return a sorted array in ascending order. # Constraints - 0 <= len(arr) <= 10^5 - -10^9 <= arr[i] <= 10^9 for any i in array # Example ```python >>> merge_sort([4, 1, 7, 3, 2, 9, 8]) [1, 2, 3, 4, 7, 8, 9] >>> merge_sort([12]) [12] >>> merge_sort([]) [] ``` # Notes - Consider handling the edge cases such as an empty array or an array with a single element. - Avoid unnecessary copying of sub-arrays to enhance performance.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append any remaining elements in left or right merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged"},{"question":"You are provided with the definition of Euler\'s Totient Function, also known as the phi-function, which counts the number of integers between 1 and n inclusive that are coprime to n (two numbers are coprime if their greatest common divisor (GCD) equals 1). Task: Write a function `phi_values(max_n)` that takes an integer `max_n` (1 <= max_n <= 10^6) and returns a list where the i-th element (0-indexed) is the value of the Euler\'s Totient Function for i. Input: * An integer `max_n` representing the maximum number for which phi values need to be calculated. Output: * A list of integers where each element `i` corresponds to the value of the Totient Function for i. Performance Requirements: * Your implementation should efficiently handle the upper constraint (max_n = 10^6) under reasonable time. Example: ```python >>> phi_values(10) [0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4] ``` Constraints: 1 <= max_n <= 10^6 # Function Signature ```python def phi_values(max_n: int) -> list: pass ``` # Criteria for Assessment - **Correctness**: Ensure the function correctly computes the totient values. - **Efficiency**: The algorithm should handle the upper constraint efficiently. - **Edge Handling**: Properly handle edge cases, such as small values of `max_n`.","solution":"def phi_values(max_n: int) -> list: phi = list(range(max_n + 1)) for i in range(2, max_n + 1): if phi[i] == i: # i is a prime number for j in range(i, max_n + 1, i): phi[j] = phi[j] * (i - 1) // i return phi"},{"question":"Implement a function `reverse_sentence(sentence: str) -> str` that reverses the order of words in a given sentence. # Scenario Consider a text editing software feature designed to reverse the order of words in a sentence while keeping words themselves in the correct order. # Requirements 1. **Function Signature**: ```python def reverse_sentence(sentence: str) -> str: ``` 2. **Input**: * `sentence`: A string containing words separated by spaces. 3. **Output**: * Returns a **new string** with the words in reversed order. # Constraints * The sentence will contain alphabets and punctuation marks. * Words are separated by one or more spaces. * The input string can have leading or trailing spaces. # Performance The solution should aim for a time complexity of O(n) and a space complexity of O(n), where n is the number of characters in the sentence. # Example ```python assert reverse_sentence(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverse_sentence(\\" Hello, world! \\") == \\"world! Hello,\\" assert reverse_sentence(\\"a\\") == \\"a\\" assert reverse_sentence(\\" This is a test . \\") == \\". test a is This\\" ```","solution":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A string containing words separated by spaces. Returns: str: A new string with the words in reversed order. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"**Problem Statement**: You are tasked with designing and implementing a variation of the Selection Sort algorithm. The twist is that instead of finding the minimum element in each step, your algorithm should find the maximum element and place it at the end of the unsorted portion of the array. This alternate approach should result in an array sorted in descending order. Your implemented function should also output the state of the array after each iteration, similar to the provided `selection_sort` function, allowing the user to visualize the sorting process. # Requirements: * Implement the function `selection_sort_descending(arr, simulation=False)`. * **Input**: - An unsorted list `arr` containing integers. - A boolean flag `simulation` which, when set to `True`, prints the state of the array after each iteration. * **Output**: - The input list sorted in descending order. - If `simulation=True`, print the array after each sorting pass. # Constraints: - The list `arr` should contain integers. - The function should take an optional boolean flag parameter `simulation` that defaults to `False`. # Example Usage: Input: ```python arr = [64, 34, 25, 12, 22, 11, 90] ``` With `simulation=True`, your function should print: ``` iteration 0 : 64 34 25 12 22 11 90 iteration 1 : 64 90 25 12 22 11 34 iteration 2 : 90 64 25 12 22 11 34 iteration 3 : 90 64 34 12 22 11 25 iteration 4 : 90 64 34 25 22 11 12 iteration 5 : 90 64 34 25 22 11 12 iteration 6 : 90 64 34 25 22 12 11 ``` Output: ```python [90, 64, 34, 25, 22, 12, 11] ``` # Implementation You are expected to write the function `selection_sort_descending` following the criteria and aspects discussed in the algorithm analysis.","solution":"def selection_sort_descending(arr, simulation=False): Sorts the array in descending order using selection sort algorithm. Args: arr (list): List of integers to sort. simulation (bool): If set to True, prints the array after each iteration. Returns: list: Sorted list in descending order. n = len(arr) for i in range(n): # Assume the max element is the first element max_idx = i for j in range(i + 1, n): if arr[j] > arr[max_idx]: max_idx = j # Swap the found max element with the first element arr[i], arr[max_idx] = arr[max_idx], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"**Problem Statement**: Your task is to implement a function that counts the number of ways to partition a given positive integer. A partition of a positive integer is a way of writing it as a sum of positive integers. For instance, the partitions of 4 are `4, 3+1, 2+2, 2+1+1, 1+1+1+1`. **Function Signature**: ```python def count_partitions(n: int) -> int: This function returns the number of unique ways to partition the integer n. ``` **Input**: - An integer `n` where (1 leq n leq 100). **Output**: - An integer representing the number of unique partitions of `n`. **Constraints**: - Ensure your solution runs efficiently within the given constraints. - You may assume `n` will be within the given range and integer type. **Examples**: ```python assert count_partitions(4) == 5 assert count_partitions(7) == 15 assert count_partitions(1) == 1 ``` **Explanation**: - For `n=4`, the partitions are: `4`, `3+1`, `2+2`, `2+1+1`, `1+1+1+1`, which count up to 5. - For `n=7`, the partitions count up to 15 different ways as illustrated in the example provided. - For `n=1`, the only partition is `1`. **Hints**: - Utilize a dynamic programming approach to optimize the computation process. - Consider using a 2D DP array to store the number of ways to partition integers up to `n`. Implement the function adhering to the requirements above.","solution":"def count_partitions(n: int) -> int: This function returns the number of unique ways to partition the integer n. # Create a table to store results of subproblems dp = [0] * (n + 1) dp[0] = 1 # Base case: There\'s one way to partition 0 (using no parts) # Iterate over all integers 1 through n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Problem Statement:** Write an efficient Python function `find_primitive_root(n)` that returns all primitive roots of the given positive integer `n`. If `n` has no primitive roots, return an empty list. This function determines the existence of primitive roots using Euler\'s Totient Function and Order Calculation principles. # Function Signature ```python def find_primitive_root(n: int) -> List[int]: ``` # Input * `n` (int): A positive integer `n` (1 ≤ n ≤ 10^5). # Output * Returns a list of integers representing the primitive roots of `n`. Return an empty list if no primitive roots exist. # Constraints * The algorithm should be optimized with time complexity considerations of O(n^2 * log(n)). * Handle edge cases appropriately. * Do not use library functions for prime checks beyond what Python\'s standard library provides. # Example ```python print(find_primitive_root(7)) # Output: [3, 5] print(find_primitive_root(1)) # Output: [0] print(find_primitive_root(10)) # Output: [] ``` # Context Primitive roots are integral in areas such as cryptography and number theory. Finding the primitive root involves ensuring that an integer `a` and `n` are coprime and that `a` generates all numbers coprime with `n` in the smallest k steps. # Edge Cases to Consider * n = 1 * No primitive roots (e.g., n = 10) * Large values of `n` within the upper constraint to ensure efficiency. # Guidelines 1. Implement helper functions for `find_order` and `euler_totient`. 2. Utilize these helper functions within `find_primitive_root` to determine all primitive roots if they exist.","solution":"from typing import List def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a def euler_totient(n: int) -> int: result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_order(a: int, n: int) -> int: if gcd(a, n) != 1: return -1 order = 1 current = a while current != 1: current = (current * a) % n order += 1 return order def find_primitive_root(n: int) -> List[int]: if n == 1: return [0] if n in (2, 4): return [1] if n == 2 else [3] if n % 2 == 0 and n % 4 != 0: return [] phi_n = euler_totient(n) primitive_roots = [] for a in range(2, n): if gcd(a, n) == 1 and find_order(a, n) == phi_n: primitive_roots.append(a) return primitive_roots"},{"question":"# Flatten Arrays Context: You are given an array that contains either integers, strings, or other arrays nested at any level of depth. Your goal is to flatten this complex array structure into a single, one-dimensional array containing all the elements in the original nested array. Task: Implement a function `flatten_array` that takes a nested array as input and produces a flattened array as output. Additionally, implement an efficient iterative version that uses a generator to yield elements one-by-one. # Function Definition: ```python def flatten_array(nested_array: list) -> list: This function takes a nested array and returns a single flattened list. Parameters: nested_array (list): A list which may contain integers, strings, or other nested lists. Returns: list: A single flattened list containing all the elements. def flatten_helper(arr): for ele in arr: if not isinstance(ele, str) and isinstance(ele, Iterable): yield from flatten_helper(ele) else: yield ele return list(flatten_helper(nested_array)) ``` **Constraints:** - Do not use built-in functions like `itertools.chain`. - List should be flattened in the order elements appear in the nested structure. **Examples:** ```python assert flatten_array([1, 2, [3, 4, [5, 6]], 7, 8, [9, [10, 11]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] assert flatten_array([\'a\', [\'b\', \'c\', [\'d\', \'e\']], \'f\']) == [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] assert flatten_array([1, [2, [3, [4, [5]]]]]) == [1, 2, 3, 4, 5] assert flatten_array([]) == [] assert flatten_array([[[[\'x\']]], \'y\']) == [\'x\', \'y\'] ```","solution":"from collections.abc import Iterable def flatten_array(nested_array): This function takes a nested array and returns a single flattened list. Parameters: nested_array (list): A list which may contain integers, strings, or other nested lists. Returns: list: A single flattened list containing all the elements. def flatten_helper(arr): for ele in arr: if not isinstance(ele, str) and isinstance(ele, Iterable): yield from flatten_helper(ele) else: yield ele return list(flatten_helper(nested_array))"},{"question":"# ZigZag Iterator with Multiple Lists Context: You are developing a generalized ZigZag Iterator to alternate elements from multiple input lists. Unlike the simple version, which handles only two lists, this extended version should work with any number of lists provided at initialization. Problem Statement: Implement the `ZigZagIterator` class that should iterate over multiple lists in a zigzag manner. That is, it should draw one element from each list in turn, moving to the next list after each element, and wrapping around to the start of the list of lists. The iteration should stop when all the elements from all lists are exhausted. Implementation: The `ZigZagIterator` class should have the following methods: - `__init__(self, lists: List[List[int]]) -> None`: Initializes the data structure with the list of lists. - `next(self) -> int`: Returns the next element in the sequence. - `has_next(self) -> bool`: Returns `True` if there are more elements to iterate over, `False` otherwise. Constraints: - The input lists may contain differing numbers of elements. - The overall number of elements across all lists will not exceed 10^4. - Each individual element of the lists is an integer within the range of small to large positive and negative values. Example: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = ZigZagIterator([l1, l2, l3]) result = [] while it.has_next(): result.append(it.next()) print(result) ``` Output: ``` [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Write your `ZigZagIterator` class to pass the above example and any additional tests demonstrating correct functionality.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]) -> None: self.queue = deque() for lst in lists: if lst: self.queue.append(deque(lst)) def next(self) -> int: if self.has_next(): current_list = self.queue.popleft() value = current_list.popleft() if current_list: # if there are still elements in the current list self.queue.append(current_list) return value raise StopIteration(\\"There are no more elements in the iterator\\") def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"# Queue ADT Implementation Challenge **Context**: You are tasked with implementing a queue-like system for a printing service where documents are added to a print queue and processed in the order they arrive. To manage the print jobs efficiently, you need to implement the core functionalities of a queue. **Objective**: Using the given abstract class `AbstractQueue`, implement two versions of the queue: 1. A `CircularArrayQueue` which uses a circular array. 2. An `EnhancedLinkedListQueue` which uses a linked list. **Function Requirements**: 1. `enqueue(item)`: Add a new item to the rear of the queue. 2. `dequeue()`: Remove the front item from the queue and return it. 3. `peek()`: Return the front element of the queue without removing it. 4. `is_empty()`: Check if the queue is empty. 5. `__iter__()`: Return an iterator over the elements in the queue. **Constraints**: * The `CircularArrayQueue` should use a dynamic expansion strategy if it runs out of space. * The `EnhancedLinkedListQueue` should optimize for memory usage and handle large inputs efficiently. **Performance Requirements**: * Enqueue and Dequeue operations should have average O(1) time complexity. * Account for handling large queuing operations gracefully without unnecessary performance degradation. **Input and Output Format**: * **Input**: Methods such as `enqueue(item)`, `dequeue()`, `peek()`, `is_empty()`, `__iter__()`. * **Output**: Corresponding returns from these methods (e.g., values, boolean). **Edge Cases to Consider**: * Dequeueing from an empty queue should raise an `IndexError`. * Handling dynamic resizing in `CircularArrayQueue` without data loss. * Properly managing memory in `EnhancedLinkedListQueue`. **Code Template**: ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): # Your initialization code here def enqueue(self, value): # Your enqueue code here def dequeue(self): # Your dequeue code here def peek(self): # Your peek code here def __iter__(self): # Your iteration code here class EnhancedLinkedListQueue(AbstractQueue): def __init__(self): # Your initialization code here def enqueue(self, value): # Your enqueue code here def dequeue(self): # Your dequeue code here def peek(self): # Your peek code here def __iter__(self): # Your iteration code here # Example usage: # q = CircularArrayQueue() # q.enqueue(1) # print(q.dequeue()) # should return 1 ``` Implement the `CircularArrayQueue` and `EnhancedLinkedListQueue` classes so that they meet the specified requirements. The final implementation should correctly maintain the queue properties and handle edge cases effectively.","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * self.capacity self.front_idx = 0 self.rear_idx = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: self._resize() self.queue[self.rear_idx] = value self.rear_idx = (self.rear_idx + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.queue[self.front_idx] self.queue[self.front_idx] = None self.front_idx = (self.front_idx + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty queue\\") return self.queue[self.front_idx] def is_empty(self): return self.size == 0 def __iter__(self): for i in range(self.size): yield self.queue[(self.front_idx + i) % self.capacity] def _resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front_idx + i) % self.capacity] self.queue = new_queue self.front_idx = 0 self.rear_idx = self.size self.capacity = new_capacity class EnhancedLinkedListQueue: class Node: def __init__(self, value=None, next=None): self.value = value self.next = next def __init__(self): self.front = None self.rear = None self.size = 0 def enqueue(self, value): new_node = EnhancedLinkedListQueue.Node(value) if self.rear is not None: self.rear.next = new_node self.rear = new_node if self.front is None: self.front = new_node self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.front.value self.front = self.front.next if self.front is None: self.rear = None self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty queue\\") return self.front.value def is_empty(self): return self.size == 0 def __iter__(self): current = self.front while current: yield current.value current = current.next"},{"question":"Context You are tasked with developing a feature for a navigation system where users need to find various paths between landmarks in a city. The landmarks and connections between them are represented as a graph. Your responsibility is to implement a function that identifies a specific path, all possible paths, and the shortest path between two landmarks. Objective Implement these three functions: 1. `find_path(graph, start, end)` 2. `find_all_paths(graph, start, end)` 3. `find_shortest_path(graph, start, end)` Each of these functions will appear as independent scenarios, and must handle various inputs including edge cases and different graph structures. Graph Representation The graph is represented as a dictionary where keys are landmark names (strings), and values are lists of landmark names it directly connects to. Functions and Constraints 1. **find_path(graph, start, end):** * **Input**: * `graph`: Dictionary of the graph structure. * `start`: Starting landmark\'s name (string). * `end`: Ending landmark\'s name (string). * **Output**: A list of landmark names that form a path from `start` to `end`. Return `None` if no path exists. * **Constraints**: * Assume there are no negative weights or self-loops. * Function should be efficient to handle graphs with up to 1000 vertices. 2. **find_all_paths(graph, start, end):** * **Input**: * `graph`: Dictionary of the graph structure. * `start`: Starting landmark\'s name (string). * `end`: Ending landmark\'s name (string). * **Output**: A list of lists, where each list is a possible path between `start` and `end`. Return an empty list if no path exists. * **Constraints**: * Function should efficiently handle up to 500 vertices due to potential path explosion. 3. **find_shortest_path(graph, start, end):** * **Input**: * `graph`: Dictionary of the graph structure. * `start`: Starting landmark\'s name (string). * `end`: Ending landmark\'s name (string). * **Output**: A list of landmark names that form the shortest path from `start` to `end`. Return `None` if no path exists. * **Constraints**: * Assume no negative weights and no disconnected graphs. * Function should provide results in a time-efficient manner for graphs with up to 1000 vertices. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(find_path(graph, \'A\', \'F\')) # Output might be: [\'A\', \'B\', \'E\', \'F\'] print(find_all_paths(graph, \'A\', \'F\')) # Output might be: [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\'], ...] print(find_shortest_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] ``` Notes * Handle edge cases like cycles, disconnected graphs, and identical start and end nodes effectively. * Ensure that your function scales well with input size within the given constraints. * Test and validate your implementation with various graph structures to ensure accuracy.","solution":"def find_path(graph, start, end, path=None): Find any path from start to end in the graph. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, start=node, end=end, path=path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=None): Find all paths from start to end in the graph. if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths from collections import deque def find_shortest_path(graph, start, end): Find the shortest path from start to end in the graph using BFS. if start == end: return [start] visited = set() queue = deque([[start]]) while queue: path = queue.popleft() node = path[-1] if node == end: return path elif node not in visited: for adjacent in graph.get(node, []): new_path = list(path) new_path.append(adjacent) queue.append(new_path) visited.add(node) return None"},{"question":"You’ve been tasked with extending the functionality of a Binary Search Tree (BST) class that allows for additional operations. You should implement methods for deletion, depth calculation, and checking if the tree is balanced. # Core Requirements: 1. **Delete Node**: - Remove a node with specified value. - Maintain the BST property after deletion. 2. **Calculate Depth**: - Compute the maximum depth (height) of the tree. 3. **Is Balanced**: - Determine if the tree is height-balanced (a tree is height-balanced if, for every node, the height difference between the left and right subtree is no more than 1). # Functions & Constraints: - **Input**: Value(s) for operations will be integers. - **Output**: Depends on the function being implemented; either updated tree structure, depth value, or boolean. # Definitions: - **Tree Depth**: The longest path from the root to a leaf. - **Balanced Tree**: For every node, the difference in height between its left and right subtree is no more than 1. # Example Scenario: Given BST: ``` 10 / 5 15 ``` 1. **Delete Node**: - Input: delete(5) - Output: BST root with node 5 removed: ``` 10 15 ``` 2. **Calculate Depth**: - Input: depth() - Output: 2 3. **Is Balanced**: - Input: is_balanced() - Output: True # Implementation Specification: ```python # Extending existing BST class with new methods class BST: # ... existing methods def delete(self, data): Removes the node with \'data\' value, maintains BST properties. # Your code here def depth(self): Calculates and returns the maximum depth of the tree. # Your code here def is_balanced(self): Determines if the tree is height-balanced. # Your code here # The tree setup for testing: import unittest class TestBSTExtensions(unittest.TestCase): def setUp(self): self.tree = BST() # Same setup as original tree with root 10... def test_delete(self): # Test delete operation self.tree.delete(9) self.assertFalse(self.tree.search(9)) self.assertTrue(self.tree.is_balanced()) def test_depth(self): # Test depth calculation self.assertEqual(self.tree.depth(), 4) def test_is_balanced(self): # Test if tree is balanced self.assertTrue(self.tree.is_balanced()) self.tree.insert(100) self.assertFalse(self.tree.is_balanced()) if __name__ == \'__main__\': unittest.main() ```","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert_recursive(node.right, value) else: node.right = TreeNode(value) def search(self, value): return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if not node: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def delete(self, value): self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, root, key): if not root: return root if key < root.value: root.left = self._delete_recursive(root.left, key) elif key > root.value: root.right = self._delete_recursive(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = self._min_value_node(root.right) root.value = temp.value root.right = self._delete_recursive(root.right, temp.value) return root def _min_value_node(self, node): current = node while current.left: current = current.left return current def depth(self): return self._depth_recursive(self.root) def _depth_recursive(self, node): if not node: return 0 left_depth = self._depth_recursive(node.left) right_depth = self._depth_recursive(node.right) return max(left_depth, right_depth) + 1 def is_balanced(self): return self._is_balanced_recursive(self.root) != -1 def _is_balanced_recursive(self, node): if not node: return 0 left_depth = self._is_balanced_recursive(node.left) if left_depth == -1: return -1 right_depth = self._is_balanced_recursive(node.right) if right_depth == -1: return -1 if abs(left_depth - right_depth) > 1: return -1 return max(left_depth, right_depth) + 1"},{"question":"# Scenario Comb Sort is a simple sorting algorithm that improves upon Bubble Sort by using a larger gap between compared elements initially. This results in the movement of elements over a more extended range initially, making the sort more efficient. # Objective Implement a function `comb_sort_with_custom_gap` that sorts an array of integers but allows the initial gap and shrink factor to be specified. # Function Signature ```python def comb_sort_with_custom_gap(arr: List[int], initial_gap: int, shrink_factor: float) -> List[int]: pass ``` # Input - `arr`: A list of integers that need to be sorted. - `initial_gap`: An integer representing the initial gap used for comparison. - `shrink_factor`: A float representing the factor by which the gap is reduced every iteration. # Output - Returns the sorted list of integers. # Constraints - `1 <= len(arr) <= 10^5` - `2 <= initial_gap <= len(arr)` - `1.1 <= shrink_factor <= 4.0` - The function should operate with a time complexity of (O(n log n)) on average. - No built-in sorting functions are allowed. # Example ```python arr = [5, 3, 6, 2, 10] initial_gap = 3 shrink_factor = 1.3 comb_sort_with_custom_gap(arr, initial_gap, shrink_factor) # Output: [2, 3, 5, 6, 10] ``` # Explanation In the example above: 1. The initial gap is set to 3. 2. The array is sorted by repeatedly reducing the gap by the shrink factor of 1.3 and performing comparison-swaps accordingly, until the entire array is sorted.","solution":"from typing import List def comb_sort_with_custom_gap(arr: List[int], initial_gap: int, shrink_factor: float) -> List[int]: Sorts an array of integers using Comb Sort with a custom initial gap and shrink factor. n = len(arr) gap = initial_gap is_sorted = False while gap > 1 or not is_sorted: gap = max(1, int(gap // shrink_factor)) is_sorted = True # Assume the array is sorted for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] is_sorted = False # Found a pair out of order return arr"},{"question":"# Question: Implementing an Efficient Sorting Algorithm Given the inefficiency of Bogo Sort, your task is to implement a more efficient sorting algorithm. You will replace Bogo Sort with the Merge Sort algorithm to ensure better performance. Algorithm Description: - **Merge Sort** is a divide-and-conquer sorting algorithm. - **Divide**: Split the array into two halves. - **Conquer**: Recursively sort each half. - **Combine**: Merge the two sorted halves into a single sorted array. Time Complexity: - **Best, Average, and Worst Case Complexity**: O(n log n) Instructions: 1. Implement the function `merge_sort(arr)` that takes a list of integers `arr` and returns a sorted list. 2. You are not allowed to use built-in sorting functions. 3. Use the merge sort algorithm principles: - Define a `merge` helper function to merge two sorted lists. - Recursively divide and sort the input list. - Merge the sorted halves. # Function Signature: ```python def merge_sort(arr: list) -> list: # Your code here ``` Input: - `arr`: a list of integers (with 0 <= len(arr) <= 1000). Output: - A sorted list of integers. Constraints: - You must implement the Merge Sort algorithm. - Performance should be optimized for O(n log n) complexity. Example: ```python assert merge_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ```","solution":"def merge_sort(arr): Sort a list using the merge sort algorithm. :param arr: List of integers to sort :return: Sorted list of integers if len(arr) <= 1: return arr def merge(left, right): Merge two sorted lists into one sorted list. :param left: Sorted list :param right: Sorted list :return: Merged and sorted list result = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: result.append(left[left_idx]) left_idx += 1 else: result.append(right[right_idx]) right_idx += 1 result.extend(left[left_idx:]) result.extend(right[right_idx:]) return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"Two-Sum Variants Background You are given an array of integers `numbers` that is sorted in ascending order. Your task is to find two numbers such that they add up to a specific target number. You need to implement three different functions using different techniques to solve the problem, and each should return the indices of the two numbers such that they add up to the target. The indices must be 1-based (i.e., the index of the first element is 1, the index of the second element is 2, and so on). Requirements 1. **Function using Binary Search:** ```python def two_sum(numbers, target): \'\'\' numbers: List[int] - A list of integers sorted in ascending order. target: int - The target sum. return: List[int] - A list containing the 1-based indices of the two numbers that add up to the target. \'\'\' pass ``` 2. **Function using Hash Table:** ```python def two_sum1(numbers, target): \'\'\' numbers: List[int] - A list of integers. target: int - The target sum. return: List[int] - A list containing the 1-based indices of two numbers that add up to the target. \'\'\' pass ``` 3. **Function using Two Pointers:** ```python def two_sum2(numbers, target): \'\'\' numbers: List[int] - A list of integers sorted in ascending order. target: int - The target sum. return: List[int] - A list containing the 1-based indices of two numbers that add up to the target. \'\'\' pass ``` Input and Output Format * **Input:** ```plaintext list: numbers = [List of integers sorted in ascending order] int: target = target sum ``` * **Output:** ```plaintext list: [index1, index2] ``` Constraints - `2 <= len(numbers) <= 3 * 10^4` - `-1000 <= numbers[i] <= 1000` - `-1000 <= target <= 1000` - Assumes there is exactly one solution and you may not use the same element twice. Example Given the following inputs: * `numbers = [2, 7, 11, 15]` * `target = 9` The outputs for different functions should be: * `two_sum(numbers, target)` should return `[1, 2]` * `two_sum1(numbers, target)` should return `[1, 2]` * `two_sum2(numbers, target)` should return `[1, 2]` You need to implement all three functions in Python to successfully solve the problem using distinct algorithms suitable for different scenarios.","solution":"# Function using Binary Search def two_sum(numbers, target): def binary_search(arr, left, right, x): while left <= right: mid = left + (right - left) // 2 if arr[mid] == x: return mid elif arr[mid] < x: left = mid + 1 else: right = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] idx = binary_search(numbers, i + 1, len(numbers) - 1, complement) if idx != -1: return [i + 1, idx + 1] # Function using Hash Table def two_sum1(numbers, target): seen = {} for i, num in enumerate(numbers): complement = target - num if complement in seen: return [seen[complement] + 1, i + 1] seen[num] = i # Function using Two Pointers def two_sum2(numbers, target): left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1"},{"question":"# Question: Implement a Modified Shell Sort Suppose you are given an array of integers that needs to be sorted. You are required to implement a modified version of Shell Sort that uses a different gap sequence. Traditionally, Shell Sort uses a fixed gap sequence (like n/2, n/4, ... , 1). However, your task is to use the gap sequence of the form (3^k - 1) / 2 where k starts from 1 and (3^k - 1) / 2 is less than n. # Detailed Requirements 1. **Input**: An unsorted list of integers of arbitrary length. - (1 leq text{len(arr)} leq 10^5) - ( -10^9 leq text{arr[i]} leq 10^9 ) 2. **Output**: The sorted list in non-decreasing order. 3. **Constraints**: - You must use the gap sequence ((3^k - 1) / 2) for your implementation. - The function signature should be: ```python def modified_shell_sort(arr: List[int]) -> List[int]: ``` 4. **Performance**: The algorithm should be implemented efficiently to handle the upper constraint on input size. # Example ```python # Example 1: arr = [12, 34, 54, 2, 3] print(modified_shell_sort(arr)) # Output: [2, 3, 12, 34, 54] # Example 2: arr = [3, 0, -2, 5, -1, 1, -1] print(modified_shell_sort(arr)) # Output: [-2, -1, -1, 0, 1, 3, 5] ``` # Notes - Make sure to handle edge cases such as empty arrays and arrays with duplicate elements correctly. - Consider how different gap sequences might affect performance to more effectively sort large arrays.","solution":"from typing import List def modified_shell_sort(arr: List[int]) -> List[int]: Sorts the list of integers using a modified Shell Sort algorithm with the gap sequence (3^k - 1) / 2. n = len(arr) gaps = [] k = 1 while True: gap = (3**k - 1) // 2 if gap >= n: break gaps.append(gap) k += 1 # Perform the shell sort using the computed gap sequence for gap in reversed(gaps): for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Question: Implement and Compare Multiple Longest Common Prefix Algorithms **Description**: You are given an array of strings, and your task is to implement three different algorithms to determine the longest common prefix string amongst the array of strings. The algorithms are Horizontal Scanning, Vertical Scanning, and Divide and Conquer. **Function Signature**: ```python def longest_common_prefix_horizontal(strs: List[str]) -> str: # Horizontal scanning implementation pass def longest_common_prefix_vertical(strs: List[str]) -> str: # Vertical scanning implementation pass def longest_common_prefix_divide_and_conquer(strs: List[str]) -> str: # Divide and conquer implementation pass ``` **Input**: - `strs`: A list of strings `[\'str1\', \'str2\', ..., \'strN\']`. **Output**: - Return the longest common prefix string. **Constraints**: - The input strings will consist only of lowercase English letters. - `1 <= len(strs) <= 200` - `0 <= len(stri) <= 200` **Performance Requirements**: - Your implementations should handle edge cases and be optimized for efficiency. - Use O(N * M) time complexity, where N is the number of strings, and M is the average length of the strings. **Examples**: ```python # Example 1 input = [\\"flower\\",\\"flow\\",\\"flight\\"] output = \\"fl\\" # Example 2 input = [\\"dog\\",\\"racecar\\",\\"car\\"] output = \\"\\" ``` **Notes**: - Compare the implementations in terms of efficiency and readability. - Analyze which approach is best suited for different types of input. Ready your solution with tests for provided examples including edge cases.","solution":"from typing import List def longest_common_prefix_horizontal(strs: List[str]) -> str: if not strs: return \\"\\" prefix = strs[0] for string in strs[1:]: while string.find(prefix) != 0: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix def longest_common_prefix_vertical(strs: List[str]) -> str: if not strs: return \\"\\" for i in range(len(strs[0])): char = strs[0][i] for string in strs[1:]: if i >= len(string) or string[i] != char: return strs[0][:i] return strs[0] def longest_common_prefix_divide_and_conquer(strs: List[str]) -> str: if not strs: return \\"\\" def common_prefix(str1, str2): min_len = min(len(str1), len(str2)) for i in range(min_len): if str1[i] != str2[i]: return str1[:i] return str1[:min_len] def divide_and_conquer(l, r): if l == r: return strs[l] else: mid = (l + r) // 2 lcpLeft = divide_and_conquer(l, mid) lcpRight = divide_and_conquer(mid + 1, r) return common_prefix(lcpLeft, lcpRight) return divide_and_conquer(0, len(strs) - 1)"},{"question":"Scenario You are a software developer tasked with writing a utility function for a system that requires frequent checks to determine if given integers are powers of two. This check is crucial for memory alignment operations in performance-critical sections of the system. Objective Implement a function `is_power_of_two(n)` that checks if the given integer `n` is a power of two using bitwise operations. Function Signature ```python def is_power_of_two(n: int) -> bool: :param n: a non-negative integer :return: True if n is a power of two, False otherwise ``` Input and Output Formats - **Input**: A single non-negative integer `n`. - **Output**: Boolean `True` if `n` is a power of two, else `False`. Constraints - `0 <= n <= 10^9` Examples - `is_power_of_two(0)` should return `False` - `is_power_of_two(1)` should return `True` - `is_power_of_two(2)` should return `True` - `is_power_of_two(3)` should return `False` - `is_power_of_two(16)` should return `True` - `is_power_of_two(18)` should return `False` Notes Ensure that the function handles edge cases such as `0` and very large integers correctly.","solution":"def is_power_of_two(n: int) -> bool: :param n: a non-negative integer :return: True if n is a power of two, False otherwise if n <= 0: return False # A number is a power of two if it has exactly one bit set in its binary form. return (n & (n - 1)) == 0"},{"question":"# Word Squares Backtracking Challenge You are assigned to develop an algorithm that constructs all possible word squares from a given list of words. A word square is a set of words that when arranged in a square, both the words in rows and in columns match. Consider the following example: ``` Given the word list: [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] One possible word square is: b a l l a r e a l e a d l a d y ``` In this word square, the words read the same horizontally and vertically. # Task Write a function `word_squares(words: List[str]) -> List[List[str]]` that takes a list of words and returns a list of all possible word squares. The function should ensure no duplicates in the final list and handle the words efficiently. Input * A list of words consisting of lowercase English alphabets. * The list length is between 1 and 1000. * Each word has the same length. * Word lengths are between 1 and 5. Output * A list of word squares, where each word square is represented by a list of words. * Words within each square must match both horizontally and vertically. * The order of squares in the output list does not matter. Constraints * Words have no duplicates. * Ensure efficient handling to avoid time complexity issues. # Example ```python from typing import List def word_squares(words: List[str]) -> List[List[str]]: import collections n = len(words[0]) fulls = collections.defaultdict(list) for word in words: for i in range(n): fulls[word[:i]].append(word) def build(square): if len(square) == n: squares.append(square) return prefix = \\"\\".join(square[i][len(square)] for i in range(len(square))) for word in fulls[prefix]: build(square + [word]) squares = [] for word in words: build([word]) return squares # Here is an example to test your solution print(word_squares([\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"])) # Expected Output: # [ # [\\"wall\\", \\"area\\", \\"lead\\", \\"lady\\"], # [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] # ] ```","solution":"from typing import List import collections def word_squares(words: List[str]) -> List[List[str]]: Generate all possible word squares from a given list of words. n = len(words[0]) fulls = collections.defaultdict(list) for word in words: for i in range(n): fulls[word[:i]].append(word) def build(square): if len(square) == n: squares.append(square[:]) return prefix = \\"\\".join(square[i][len(square)] for i in range(len(square))) for word in fulls[prefix]: build(square + [word]) squares = [] for word in words: build([word]) return squares"},{"question":"Custom Heap Sort Context You are tasked to create your custom variant of heap sort, which enables flexible priority by allowing the comparison function to be passed as an argument. This will determine the sorting order. Objective Implement a function, `custom_heap_sort`, that sorts an array either in ascending or descending order depending on a comparison function provided. Additionally, the function should allow a simulation mode to demonstrate intermediate steps during the heap construction process. Function Signature ```python def custom_heap_sort(arr, compare_fn, simulation=False): Custom Heap Sort that sorts an array based on a comparison function. Args: arr (list): Array to be sorted. compare_fn (function): Comparison function to determine priority. simulation (bool): If true, print intermediate steps. Returns: list: Sorted array. ``` Inputs * `arr` (list): The list of numbers that needs to be sorted. * `compare_fn` (function): A comparison function that takes two arguments and returns: * A positive number if the first argument should come after the second. * A zero if they are considered equal. * A negative number if the first argument should come before the second. * `simulation` (bool, optional): A boolean flag to print intermediate steps, default is `False`. Example Usage ```python def compare_asc(a, b): return a - b def compare_desc(a, b): return b - a # For ascending order. print(custom_heap_sort([5, 3, 8, 4, 2], compare_asc)) # Iteration prints will be shown if simulation is True. # For descending order. print(custom_heap_sort([5, 3, 8, 4, 2], compare_desc)) # Iteration prints will be shown if simulation is True. ``` Constraints 1. The array may be empty. 2. The elements in the array are integers. 3. The length of the array `n` is such that `1 <= n <= 10^5`. Requirements * The function must operate in O(n log n) time complexity. * Ensure the solution works for both large inputs and edge cases effectively. Guidelines 1. Implement a heapify function that uses the provided comparison function to maintain heap properties. 2. During heapify, swap elements as needed to maintain the desired heap structure. 3. Simulate intermediate states if `simulation`=True to assist in debugging or understanding the process. 4. Handle edge cases appropriately, such as empty arrays or arrays with all identical elements.","solution":"def custom_heap_sort(arr, compare_fn, simulation=False): def heapify(n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and compare_fn(arr[i], arr[left]) < 0: largest = left if right < n and compare_fn(arr[largest], arr[right]) < 0: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"Heapifying: {arr}\\") heapify(n, largest) n = len(arr) # Build heap for i in range(n // 2 - 1, -1, -1): heapify(n, i) # Extract elements from heap for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"Swapping {i} and 0: {arr}\\") heapify(i, 0) return arr def compare_asc(a, b): return a - b def compare_desc(a, b): return b - a"},{"question":"# Single Non-Paired Element Finder Your task is to implement a function that finds the single element in an array where every other element appears exactly twice. Function Signature: ```python def find_single_element(nums: List[int]) -> int: ``` Input: - `nums` (List[int]): A non-empty list of integers where every element appears twice except for exactly one element. Output: - Returns an integer that is the single element in the list. Constraints: - Your algorithm should run in O(n) time complexity. - Implement the function without using extra memory (O(1) space complexity). # Example: ```python assert find_single_element([2, 2, 1]) == 1 assert find_single_element([4, 1, 2, 1, 2]) == 4 assert find_single_element([1]) == 1 assert find_single_element([-1, -1, -2]) == -2 ``` # Notes: - Consider the properties of the XOR operation which can help you solve this problem efficiently. - Make sure to handle edge cases such as a single-element array or arrays including negative elements. # Scenario: Imagine that you are a detective trying to identify a single rogue agent amongst a group of paired agents who have infiltrated an organization. Each pair of agents has been issued identical identification numbers. Your task is to find the rogue agent\'s identification number using the least amount of memory possible while analyzing all the IDs.","solution":"from typing import List def find_single_element(nums: List[int]) -> int: unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"As an expression evaluator enthusiast, you have been given a string containing digits (0-9) and a target value. Your task is to write a function `find_operations` that generates all valid combinations of the input digits, where the digits are combined with binary operators (`+`, `-`, `*`) to form expressions that evaluate to the given target value. The function should return a list of all valid expressions. # Function Signature ```python def find_operations(num: str, target: int) -> list[str]: ``` # Input - `num: str`: A non-empty string containing only digits 0-9. - `target: int`: An integer target value. # Output - `list of str`: Each string should be a valid expression involving all the digits from the input string, combined with binary operators (`+`, `-`, `*`), that evaluates to the target value. # Constraints: - The length of `num` will be <= 10. - Your solution should handle cases with digits having leading zeros, e.g., \\"105\\" can be split into \\"1*0+5\\". # Performance Requirements: - Implement an efficient recursive function with a time complexity of O(4^n) and space complexity of O(n). # Examples: - `find_operations(\\"123\\", 6)` should return `[\\"1+2+3\\", \\"1*2*3\\"]` - `find_operations(\\"232\\", 8)` should return `[\\"2*3+2\\", \\"2+3*2\\"]` - `find_operations(\\"105\\", 5)` should return `[\\"1*0+5\\", \\"10-5\\"]` - `find_operations(\\"00\\", 0)` should return `[\\"0+0\\", \\"0-0\\", \\"0*0\\"]` - `find_operations(\\"3456237490\\", 9191)` should return `[]` # Additional Requirements: - Ensure that your function handles invalid inputs gracefully. - Include appropriate error checking for edge cases, such as empty strings and overly large input strings. # Example function call: ```python print(find_operations(\\"105\\", 5)) ``` # Example output: ```python [\\"1*0+5\\", \\"10-5\\"] ```","solution":"def find_operations(num: str, target: int) -> list[str]: def helper(index, prev_operand, current_operand, value, expression): if index == len(num): if value == target and current_operand == 0: results.append(\\"\\".join(expression[1:])) return current_operand = current_operand * 10 + int(num[index]) str_op = str(current_operand) if current_operand > 0: helper(index + 1, prev_operand, current_operand, value, expression) expression.append(\'+\') expression.append(str_op) helper(index + 1, current_operand, 0, value + current_operand, expression) expression.pop() expression.pop() if len(expression) > 0: expression.append(\'-\') expression.append(str_op) helper(index + 1, -current_operand, 0, value - current_operand, expression) expression.pop() expression.pop() expression.append(\'*\') expression.append(str_op) helper(index + 1, prev_operand * current_operand, 0, value - prev_operand + (prev_operand * current_operand), expression) expression.pop() expression.pop() results = [] helper(0, 0, 0, 0, []) return results"},{"question":"# Scenario Imagine you are working with a custom file system where writing to storage is significantly more time-consuming than reading from it. To minimize the number of write operations, you decide to use the Cycle Sort algorithm. Implement this algorithm to help minimize the wear and tear on the storage device. # Task Write a function `cycle_sort(arr)` that takes a list `arr` of integers as input and sorts the list in ascending order using the Cycle Sort algorithm. The function should return the sorted list. # Input * `arr`: A list of integers, where 1 ≤ len(arr) ≤ 10^5 and -10^6 ≤ arr[i] ≤ 10^6. # Output * The sorted list in ascending order. # Constraints * You must not use built-in sorting functions. * Aim to minimize the number of write operations to the list. # Performance Requirements * Your implementation should ideally operate in O(N^2) time complexity. * Minimize space usage to O(1) by performing the sort in-place. # Example ```python # Example 1: arr = [3, 1, 2, 3, 4] print(cycle_sort(arr)) # Output: [1, 2, 3, 3, 4] # Example 2: arr = [10, -1, 2, -10, -5] print(cycle_sort(arr)) # Output: [-10, -5, -1, 2, 10] # Example 3: arr = [1, 3, 2, 2, 1] print(cycle_sort(arr)) # Output: [1, 1, 2, 2, 3] ```","solution":"def cycle_sort(arr): n = len(arr) if n <= 1: return arr writes = 0 for cycleStart in range(0, n - 1): item = arr[cycleStart] pos = cycleStart for i in range(cycleStart + 1, n): if arr[i] < item: pos += 1 if pos == cycleStart: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Scenario You are given a stack that contains several integers. You need to write a function that modifies the stack by duplicating each value so that every element in the stack appears twice consecutively in the order they originally appeared. # Function Specification Implement the function `stutter_stack(stack)` following these specific requirements: Input: - A list implementation of a stack (int list) where the end of the list represents the top of the stack. Output: - The same list with each value duplicated consecutively. # Constraints: - The number of elements in the stack, ( n ), will be between 0 and 1000. - Each element in the stack will be an integer within the range ([-1000, 1000]). # Example: ```python stack = [3, 7, 1, 14, 9] stutter_stack(stack) # After function execution # stack should be: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Performance Requirements: - Your solution should aim for O(n) time complexity. - Auxiliary space usage should also be O(n) due to the duplication utility required.","solution":"def stutter_stack(stack): Modifies the input stack such that each element in the stack appears twice consecutively in the order they originally appeared. Args: stack (list[int]): A list of integers representing the stack. Returns: None: The function modifies the stack in place. i = 0 while i < len(stack): stack.insert(i, stack[i]) i += 2"},{"question":"# RSA Encryption Implementation In this task, you will use the RSA key generation algorithm to securely encrypt and decrypt a message. The key generation algorithm has been provided for you. Your job is to implement the `rsa_encrypt` and `rsa_decrypt` functions to demonstrate the RSA algorithm. # Input and Output formats * The inputs to `rsa_encrypt` will be a message (string) and the public key components `e` and `n`. * The inputs to `rsa_decrypt` will be the encrypted message (list of integers) and the private key components `d` and `n`. The functions should have the following signatures: ```python def rsa_encrypt(message, e, n): # Your implementation here def rsa_decrypt(encrypted_message, d, n): # Your implementation here ``` # Example: ```python n, e, d = generate_key(16) message = \\"hello\\" encrypted_message = rsa_encrypt(message, e, n) print(\\"Encrypted:\\", encrypted_message) # encrypted_message should be a list of integers. decrypted_message = rsa_decrypt(encrypted_message, d, n) print(\\"Decrypted:\\", decrypted_message) # decrypted_message should be the original string \\"hello\\". ``` # Constraints and Notes: * All characters in the message are ASCII. * You need to convert characters to their integer ASCII values before encryption and convert the decrypted integers back to characters. * Ensure that your code handles encryption and decryption correctly, retaining upper and lower case letters, spaces, and common punctuation.","solution":"def rsa_encrypt(message, e, n): Encrypts a message using the public key. :param message: The message to be encrypted (string). :param e: The public exponent (integer). :param n: The modulus (integer). :return: The encrypted message as a list of integers. return [(ord(char) ** e) % n for char in message] def rsa_decrypt(encrypted_message, d, n): Decrypts a message using the private key. :param encrypted_message: The message to be decrypted (list of integers). :param d: The private exponent (integer). :param n: The modulus (integer). :return: The decrypted message as a string. return \'\'.join([chr((char ** d) % n) for char in encrypted_message])"},{"question":"# Matrix Rotation Problem Given an n x n 2D matrix representing an image, rotate the image by 90 degrees clockwise in-place. Input: - An n x n matrix `mat` where `n` is the number of rows (and columns). Output: - The modified matrix `mat` rotated by 90 degrees clockwise. Constraints: - The matrix will always have equal number of rows and columns (a square matrix). - Do not use extra space for another 2D matrix and try to solve this problem in-place. Example: ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(mat) # The resulting matrix should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Function Signature: ```python def rotate(mat: List[List[int]]) -> None: # Implement the function to rotate the given matrix in-place ``` Explanation: 1. **Reverse Matrix**: - Before: `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - After Reversing: `[[7, 8, 9], [4, 5, 6], [1, 2, 3]]` 2. **Transpose Matrix**: - After Transposing: `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]` Note: - Your solution should modify the matrix in-place and not return anything.","solution":"from typing import List def rotate(mat: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in-place. if not mat or not mat[0]: return n = len(mat) # Reverse the rows of the matrix mat.reverse() # Transpose the matrix for i in range(n): for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j]"},{"question":"# Context: You are tasked with developing a system that needs to efficiently store and compute the dot product of very large, sparse vectors. The existing CSV files provided each contain high-dimensional vectors representative of text data from a large corpus. These vectors consist predominantly of zeroes and a few non-zero elements, making it inefficient to store them in the usual full-length format. # Problem Statement: Write a function to convert these full-length vectors to a sparse representation and another function to compute the dot product of two such sparse vectors. # Functions: 1. **sparse_representation(vector)** * **Input**: A list of floating-point numbers (e.g., `[0.0, 0.0, 3.2, 0.0]`). * **Output**: A list of tuples, each containing an index and a non-zero value (e.g., `[(2, 3.2)]`). 2. **sparse_dot_product(sparse_vector1, sparse_vector2)** * **Input**: Two lists of tuples representing sparse vectors (e.g., `[(0, 1.5), (3, 4.1)]` and `[(0, 2.0), (3, 1.1)]`). * **Output**: A floating-point number representing the dot product of the two vectors (e.g., `6.15` for the given example). # Constraints: * The input vector length for `sparse_representation` can be up to 10^6. * The sparse vectors for `sparse_dot_product` will each contain up to 10^4 tuples. * Floating-point precision issues should be handled appropriately. # Example: ```python # Input vector = [0.0, 0.0, 1.2, 0.0, 3.4] sparse_vector1 = sparse_representation(vector) # Expected output: [(2, 1.2), (4, 3.4)] sparse_vector2 = sparse_representation([0.0, 3.4, 0.0, 0.0, 1.2]) # Dot Product Calculation result = sparse_dot_product(sparse_vector1, sparse_vector2) # Expected output: 4.08 (1.2 * 1.2 + 3.4 * 3.4) print(sparse_vector1) print(result) ``` # Note: As the provided vectors can be very large and predominantly sparse, you are expected to ensure your implementation is efficient both in terms of time and space.","solution":"def sparse_representation(vector): Converts a full-length vector to its sparse representation. Parameters: vector (list of float): The input full-length vector. Returns: list of tuples: Each tuple contains an index and a non-zero value. return [(index, value) for index, value in enumerate(vector) if value != 0.0] def sparse_dot_product(sparse_vector1, sparse_vector2): Computes the dot product of two sparse vectors. Parameters: sparse_vector1 (list of tuples): The first sparse vector. sparse_vector2 (list of tuples): The second sparse vector. Returns: float: The dot product of the two vectors. dict1 = dict(sparse_vector1) dict2 = dict(sparse_vector2) dot_product = 0.0 for index1, value1 in dict1.items(): if index1 in dict2: dot_product += value1 * dict2[index1] return dot_product"},{"question":"# Question Scenario: You are given an array of integers and are tasked with identifying the most frequently occurring element(s) in the array. It is possible that there are multiple elements that occur at the highest frequency, in which case, all should be returned. Task: Write a function `find_modes(arr)` that takes in a list of integers and returns a list of the most frequently occurring element(s). Function Signature: ```python def find_modes(arr: List[int]) -> List[int]: ``` Input: * The function takes a list of integers `arr` (0 <= len(arr) <= 10^6). The elements of `arr` are 32-bit integers. Output: * The function should return a list of integers representing the mode(s). Constraints: * Return modes in the order they first appear in the input array. * You must ensure your function runs in O(n) time complexity. Example: ```python # Example 1 assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] # Example 2 assert find_modes([4, 4, 4, 2, 2, 3, 3, 3]) == [4, 3] # Example 3 assert find_modes([]) == [] # Example 4 assert find_modes([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` Notes: * Your solution should handle edge cases such as empty lists or lists where all elements are the same. * Ensure your function is both time and space efficient to handle large input sizes within the constraints.","solution":"from typing import List from collections import defaultdict def find_modes(arr: List[int]) -> List[int]: if not arr: return [] frequency = defaultdict(int) max_freq = 0 for num in arr: frequency[num] += 1 if frequency[num] > max_freq: max_freq = frequency[num] modes = [] seen = set() for num in arr: if frequency[num] == max_freq and num not in seen: modes.append(num) seen.add(num) return modes"},{"question":"As a part of the new feature for a text-editing application, you have been asked to implement an advanced word lookup system that can handle words with wildcard searches (where `.` can represent any letter). # Instructions: You need to implement a class called `AdvancedWordDictionary` that allows adding words and searching words, including ones that contain wildcards. Specifically, you should: 1. Design the class `AdvancedWordDictionary` with the following methods: - `add_word(word: str) -> None`: Adds a word into the data structure. - `search(word: str) -> bool`: Returns `True` if the word (including wildcards) exists in the data structure, and `False` otherwise. # Constraints: 1. The `word` will consist of lowercase English letters (`a` to `z`) and/or dots (`.`). 2. Input words and searches will be non-empty and will each have a length of at most 20. # Expected Input and Output: * `add_word(\\"bad\\")` -> None * `add_word(\\"dad\\")` -> None * `add_word(\\"mad\\")` -> None * `search(\\"pad\\")` -> `False` (no match found) * `search(\\"bad\\")` -> `True` (exact match found) * `search(\\".ad\\")` -> `True` (match found: \\"bad\\", \\"dad\\", \\"mad\\") * `search(\\"b..\\")` -> `True` (match found: \\"bad\\") # Example Usage: ```python awd = AdvancedWordDictionary() awd.add_word(\\"bad\\") awd.add_word(\\"dad\\") awd.add_word(\\"mad\\") print(awd.search(\\"pad\\")) # Output: False print(awd.search(\\"bad\\")) # Output: True print(awd.search(\\".ad\\")) # Output: True print(awd.search(\\"b..\\")) # Output: True ``` # Implementation Question: Using your understanding of tries (prefix trees) or hash-based dictionaries, design and implement the `AdvancedWordDictionary` class to efficiently support the above functionalities. Discuss the complexity of your implementation in line with the constraints.","solution":"class AdvancedWordDictionary: def __init__(self): self.words = {} def add_word(self, word: str) -> None: current = self.words for char in word: if char not in current: current[char] = {} current = current[char] current[\'\'] = True def search(self, word: str) -> bool: return self._search_in_node(word, 0, self.words) def _search_in_node(self, word, index, node): if index == len(word): return \'\' in node if word[index] == \'.\': for key in node: if key != \'\' and self._search_in_node(word, index + 1, node[key]): return True return False else: if word[index] not in node: return False return self._search_in_node(word, index + 1, node[word[index]])"},{"question":"# Problem: Custom GCD Computation and Usage in Array Analysis As a software engineer at a coding platform, you are tasked with creating utilities that can handle various numerical operations efficiently. You are required to use a specific GCD algorithm that leverages bitwise operations and trailing zero counting. Additionally, you\'ll use these utilities to analyze properties of arrays of integers. Part 1: GCD Using Bitwise Operations Implement a function `gcd_bitwise(a, b)` that computes the greatest common divisor of two non-negative integers `a` and `b` using bitwise operations without relying on direct modulo operations. **Function Signature:** ```python def gcd_bitwise(a: int, b: int) -> int: ``` **Input:** - `a`: A non-negative integer, where 0 <= a <= 10^9 - `b`: A non-negative integer, where 0 <= b <= 10^9 **Output:** - An integer which is the GCD of `a` and `b`. **Constraints:** - You must use a bitwise operation approach. - Minimize the number of loops and condition checks for optimization. Part 2: Analyzing Number of Trailing Zeros in Array Next, implement a function `analyze_trailing_zeros(arr)` that accepts an array of integers and returns a list where each element corresponds to the number of trailing zeros in the binary representation of the respective element in the input array. **Function Signature:** ```python def analyze_trailing_zeros(arr: List[int]) -> List[int]: ``` **Input:** - `arr`: A list of non-negative integers, where 0 <= arr[i] <= 10^9 and 0 < len(arr) <= 10^5 **Output:** - A list of integers where each integer represents the count of trailing zeros in the binary representation of the respective element in `arr`. **Scenario Context:** In a coding competition platform, you have to provide utility functions to find the GCD of two given numbers and to detect trailing zeros within binary numbers in an array. These utilities will be frequently used in programming contests to simplify problems and optimize solutions involving number theory.","solution":"def gcd_bitwise(a: int, b: int) -> int: Computes the greatest common divisor of a and b using bitwise operations. if a == 0: return b if b == 0: return a # Count the number of trailing zeros in both a and b. shift = min((a&-a).bit_length() - 1, (b&-b).bit_length() - 1) # Remove all trailing zeros from a while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a # Restore the common factors of 2 return a << shift def analyze_trailing_zeros(arr): Returns a list of the counts of trailing zeros in the binary representation of each integer in the input array. result = [] for num in arr: if num == 0: result.append(32) # Assumes 32-bit integers, could also use float(\'inf\') else: result.append((num & -num).bit_length() - 1) return result"},{"question":"# Question: Climbing Stairs Problem with Constraints Given a staircase with `steps` steps, you can climb to the top by taking either 1 step or 2 steps at a time. Your task is to write a function to determine the number of distinct ways you can climb to the top. Function Signature ```python def climb_stairs_with_constraints(steps: int) -> int: pass ``` # Input - An integer `steps` (1 ≤ steps ≤ 10^6): the total number of steps to reach the top. # Output - An integer representing the number of distinct ways to reach the top of the staircase. # Constraints - You can only take 1 or 2 steps at a time. - Your solution should consider performance and avoid excessive memory usage. # Example ```plaintext Input: 3 Output: 3 Explanation: There are 3 ways to reach the top of a 3-step staircase. - 1 step + 1 step + 1 step - 1 step + 2 steps - 2 steps + 1 step ``` # Requirements - The function should run efficiently for large values of `steps` (up to 10^6). - Discuss edge cases and error handling within your function implementation. Provide a detailed explanation of your approach and consider constraints, optimizations, and edge cases in your solution.","solution":"def climb_stairs_with_constraints(steps: int) -> int: Returns the number of distinct ways to reach the top of a staircase of given steps, where you can take 1 or 2 steps at a time. if steps <= 0: return 0 if steps == 1: return 1 if steps == 2: return 2 # We use two variables to store the number of ways to reach the step (2 steps before and 1 step before) prev2, prev1 = 1, 2 for _ in range(3, steps + 1): current = prev1 + prev2 prev2, prev1 = prev1, current return prev1"},{"question":"# Merge Sort Implementation and Validation **Question**: You are tasked with implementing the Merge Sort algorithm from scratch, ensuring that the sorting is done in-place to optimize space complexity. **Function Specification**: Implement the following function: ```python def merge_sort(arr): Sorts an array in ascending order using the Merge Sort algorithm. :param arr: List[int] - list of integers to be sorted :return: List[int] - returns the sorted list of integers Note: The sorting should be performed in-place with minimum additional space used. ``` # Constraints: - Do NOT use any sorted() or sort() helper functions. - Only use standard libraries. - The length of the input list, `n`, is within the range [1, 10^5]. - Each element in the list, `a[i]`, is an integer within the range [-10^9, 10^9]. - The function should achieve an average time complexity of O(n log(n)) and the goal is to optimize space complexity as much as possible. **Example:** ```python arr = [38, 27, 43, 3, 9, 82, 10] print(merge_sort(arr)) # Output: [3, 9, 10, 27, 38, 43, 82] arr = [1] print(merge_sort(arr)) # Output: [1] arr = [5, 3, 2, 6, 5] print(merge_sort(arr)) # Output: [2, 3, 5, 5, 6] ``` # Additional Details: 1. You are provided two helper functions: - `merge_sort(arr)` performs the recursive sorting. - `merge(left, right, merged)` merges two sorted subarrays into one sorted array. 2. You may modify the provided helper functions as long as the sort remains in-place and space complexity is considered. **Task**: Write optimized code to complete the `merge_sort` function as described, and ensure it handles edge cases where the input list has 0, 1 or all identical elements.","solution":"def merge_sort(arr): Sorts an array in ascending order using the Merge Sort algorithm. :param arr: List[int] - list of integers to be sorted :return: List[int] - returns the sorted list of integers Note: The sorting should be performed in-place with minimum additional space used. if len(arr) > 1: mid = len(arr) // 2 # Finding the mid of the array left_half = arr[:mid] # Dividing the array elements right_half = arr[mid:] merge_sort(left_half) # Sorting the first half merge_sort(right_half) # Sorting the second half i = j = k = 0 # Copy data to temp arrays left_half[] and right_half[] while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 # Checking if any element was left while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr # return arr to be printed if needed"},{"question":"Scenario Stooge Sorting Company specializes in an old-fashioned sorting algorithm—Stooge Sort. Despite its inefficiency, they need to demonstrate this sorting method in their data processing software to showcase algorithm performance differences. Problem Statement You are tasked with implementing the Stooge Sort algorithm to sort an array of integers. This algorithm, while not efficient, should work correctly for any given input array. Your function will be tested against various arrays, including edge cases, to ensure proper sorting behavior. Function Signature ```python def stoogesort(arr: list, l: int, h: int) -> None: ``` Expected Input and Output * **Input**: A list of integers `arr`, an integer `l` indicating the starting index, and an integer `h` indicating the ending index. * **Output**: The function modifies the array `arr` in place to be sorted in ascending order. The function does not return anything. Constraints * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9 for all 0 <= i < len(arr) * You may assume that the array `arr` and the indices `l` and `h` are always valid. Example ```python # Example 1 arr = [5, 3, 1, 2, 6] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 5, 6] # Example 2 arr = [10, -1, 0, 7] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [-1, 0, 7, 10] ``` Performance Requirements * Write an efficient code even though Stooge Sort is inherently inefficient. * Ensure the function handles edge cases and recursion depth appropriately. Implement the Stooge Sort function to correctly sort an array and demonstrate your understanding of sorting algorithms through this less conventional but interesting method.","solution":"def stoogesort(arr: list, l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t)"},{"question":"# Breadth-First Search using Queue ADT Background Breadth-First Search (BFS) is a classic graph traversal algorithm that explores nodes layer-wise starting from a given node. It is ideal for finding the shortest path in an unweighted graph. BFS uses a queue to manage the exploration process. Problem Statement Implement the BFS algorithm using the provided `ArrayQueue` or `LinkedListQueue` classes. You need to write a `bfs(graph, start_node)` function where `graph` is represented using an adjacency list and `start_node` is the node from which the traversal begins. The function should return a list of nodes in the order they are visited. # Constraints - The graph can have at most 1000 vertices. - Each vertex is connected to at most 100 vertices. # Input - `graph`: A dictionary where keys are node identifiers and values are lists of connected nodes. - `start_node`: The node identifier from which BFS traversal begins. # Output - A list of node identifiers in the order they are visited in BFS traversal. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start_node = \'A\' bfs(graph, start_node) # Output: [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] ``` # Requirements 1. Use either `ArrayQueue` or `LinkedListQueue` for the queue operations. 2. Handle cases where the graph is empty or the `start_node` does not exist in the graph. 3. Ensure BFS terminates and returns the correct order.","solution":"class ArrayQueue: def __init__(self): self._queue = [] def enqueue(self, item): self._queue.append(item) def dequeue(self): if not self.is_empty(): return self._queue.pop(0) def is_empty(self): return len(self._queue) == 0 def bfs(graph, start_node): Perform BFS traversal on the given graph starting from start_node. :param graph: Dictionary representing the adjacency list of the graph. :param start_node: The node from which BFS traversal begins. :return: List of nodes in the order they are visited. if start_node not in graph: return [] visited = set() queue = ArrayQueue() result = [] queue.enqueue(start_node) visited.add(start_node) while not queue.is_empty(): node = queue.dequeue() result.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.enqueue(neighbor) visited.add(neighbor) return result"},{"question":"# Context: In various applications, you might need to limit the number of times an element appears in a list to prevent duplication or to meet certain constraints. # Problem Statement: Write a function `delete_nth(array: list[int], n: int) -> list[int]` that takes in a list `array` and an integer `n`. The function should return a new list containing each number from the input list at most `n` times without reordering the elements. # Input: - `array`: A non-empty list of integers with length up to 10^6. - `n`: An integer (0 <= n <= 10^6). # Output: - A list of integers where each integer appears at most `n` times, preserving the original order. # Constraints: - Time complexity should be O(n). - Space complexity should be O(n). # Example: ```python delete_nth([1,2,3,1,2,1,2,3], 2) ``` - Expected output: `[1, 2, 3, 1, 2, 3]` because `1` and `2` appear at most `2` times. # Note: - Consider edge cases such as empty lists or when `n` is zero. # Implementation: Implement the function in Python. ```python def delete_nth(array: list[int], n: int) -> list[int]: # Your code here pass ```","solution":"def delete_nth(array: list[int], n: int) -> list[int]: result = [] counts = {} for num in array: current_count = counts.get(num, 0) if current_count < n: result.append(num) counts[num] = current_count + 1 return result"},{"question":"You are given an array of integers which may include negative numbers. Implement a modified version of Counting Sort that can handle both positive and negative numbers efficiently. # Function Signature: ```python def modified_counting_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr` : List of integers where -10^6 <= arr[i] <= 10^6 and 1 <= len(arr) <= 10^6. # Output: * Returns a sorted list of integers. # Constraints: * The array could have positive as well as negative numbers. * The algorithm should run in linear time, O(n + k), where n is the number of elements and k is the range of the list. # Example: ```python assert modified_counting_sort([4, -1, 0, -2, 3, 2]) == [-2, -1, 0, 2, 3, 4] assert modified_counting_sort([10, -3, 5, -2, 1]) == [-3, -2, 1, 5, 10] assert modified_counting_sort([-5, -1, -5, -3]) == [-5, -5, -3, -1] ``` # Guidelines: * Think about transforming the array to a purely positive array first. * Use a count array to tally occurrences of numbers. * Then, convert the tally to the cumulative count. * Sort the array using the cumulative counts. * Finally, transform back to include negative numbers if you initially converted them. # Performance Considerations: * Ensure that the function is optimized for space and time to fit within constraints.","solution":"from typing import List def modified_counting_sort(arr: List[int]) -> List[int]: Sorting an array that contains both positive and negative numbers using a modified counting sort. if len(arr) == 0: return [] # Find the maximum and minimum values in arr min_val = min(arr) max_val = max(arr) # Calculate the range of the values range_of_elements = max_val - min_val + 1 # Initialize the count array with zeros count = [0] * range_of_elements # Store the counts of each element in arr for num in arr: count[num - min_val] += 1 # Update count array to have positions of elements for i in range(1, len(count)): count[i] += count[i - 1] # Arrange the output array sorted_arr = [0] * len(arr) for num in reversed(arr): sorted_arr[count[num - min_val] - 1] = num count[num - min_val] -= 1 return sorted_arr"},{"question":"# Cycle Sort Algorithm Implementation Problem Statement: You are given an unsorted array of integers and need to sort this array in-place using an algorithm called Cycle Sort, which aims to minimize the number of writes to the array. Function Signature: ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` Input/Output Requirements: * **Input**: * A list of integers (arr) which can contain duplicate elements. The size of the list is (N) where (1 leq N leq 10^5). * **Output**: * A sorted list of integers (arr). Constraints: * The list must be sorted in-place with the Cycle Sort algorithm. * Try to handle the array within (O(1)) additional space. * Ensure minimal writes to the array. Example Cases: # Case 1: **Input**: `[3, 1, 5, 2, 4]` **Output**: `[1, 2, 3, 4, 5]` # Case 2: **Input**: `[5, 4, 3, 2, 1]` **Output**: `[1, 2, 3, 4, 5]` # Case 3: **Input**: `[1, 2, 2, 2, 1]` **Output**: `[1, 1, 2, 2, 2]` Performance and Edge Case Considerations: * Ensure your solution handles the largest possible input sizes efficiently within the given constraints. * Consider edge cases such as empty arrays, arrays with one element, or arrays with all identical elements. * Your implementation should account for the possibility of duplicate elements and sort them correctly. Scenario: Imagine a system required to sort user rankings efficiently, minimizing the number of modifications due to a storage medium with limited write cycles. Applying Cycle Sort would ensure that each user\'s ranking is moved little as possible while ensuring correct order. Solution Requirements: Implement the `cycle_sort` function to sort the array as per the given constraints and guidelines: ```python from typing import List def cycle_sort(arr: List[int]) -> List[int]: len_arr = len(arr) # Finding cycle to rotate. for cur in range(len_arr - 1): item = arr[cur] # Finding an index to put items in. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # Case if there is not a cycle if index == cur: continue # Putting the item immediately right after the duplicate item or on the right. while item == arr[index]: index += 1 arr[index], item = item, arr[index] # Rotating the remaining cycle. while index != cur: # Finding where to put the item. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # After item is duplicated, put it in place or put it there. while item == arr[index]: index += 1 arr[index], item = item, arr[index] return arr ```","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts the array using Cycle Sort algorithm to minimize the number of writes. len_arr = len(arr) for cur in range(len_arr - 1): item = arr[cur] # Find the position where we put the element pos = cur for i in range(cur + 1, len_arr): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cur: continue # Skip duplicates while pos < len_arr and arr[pos] == item: pos += 1 # Swap the item to its right position if pos < len_arr: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cur: pos = cur for i in range(cur + 1, len_arr): if arr[i] < item: pos += 1 while pos < len_arr and arr[pos] == item: pos += 1 if pos < len_arr: arr[pos], item = item, arr[pos] return arr"},{"question":"# Question Statement You are given two functions that implement the Extended Euclidean Algorithm and calculate the modular inverse. Your task is to extend this functionality to solve a set of linear congruences using the Chinese Remainder Theorem (CRT). # Problem Description Given a list of n pairwise coprime integers (m_1, m_2, ldots, m_n) and a corresponding list of integers (a_1, a_2, ldots, a_n), find an integer x such that: [ x equiv a_1 (mod m_1) ] [ x equiv a_2 (mod m_2) ] [ vdots ] [ x equiv a_n (mod m_n) ] The integer x must be the smallest non-negative solution. # Input Format - List of integers `a` where `a[i]` represents the residue for the i-th congruence. - List of integers `m` where `m[i]` is the modulus for the i-th congruence. The integers are pairwise coprime. # Output Format - Return an integer x which is the smallest non-negative solution to the given set of linear congruences. # Constraints - (1 le n le 10^5) - (1 le a[i], m[i] le 10^9) # Example **Input:** ```python a = [2, 3, 2] m = [3, 5, 7] ``` **Output:** ```python x = 23 ``` **Explanation:** The integer 23 satisfies the following systems: [ 23 equiv 2 (mod 3) ] [ 23 equiv 3 (mod 5) ] [ 23 equiv 2 (mod 7) ] # Function Signature ```python def chinese_remainder_theorem(a: List[int], m: List[int]) -> int: pass ``` # Notes - You may use the provided `extended_gcd` and `modular_inverse` functions. - Ensure the solution is efficient and handles large values and edge cases effectively. - Validate input for emptiness and ensure lists a and m are of the same length.","solution":"from typing import List, Tuple def extended_gcd(a: int, b: int) -> Tuple[int, int, int]: if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def modular_inverse(a: int, m: int) -> int: gcd, x, y = extended_gcd(a, m) if gcd != 1: raise ValueError(f\\"No modular inverse exists for {a} and {m}\\") return x % m def chinese_remainder_theorem(a: List[int], m: List[int]) -> int: if not a or not m or len(a) != len(m): raise ValueError(\\"Lists \'a\' and \'m\' should be non-empty and of the same length.\\") x = 0 M = 1 for mi in m: M *= mi for ai, mi in zip(a, m): Mi = M // mi yi = modular_inverse(Mi, mi) x += ai * Mi * yi return x % M"},{"question":"# ZigZagIterator: Advanced Implementation Problem Statement Design and implement a class, `ZigZagIterator`, that can iterate over two lists in a ZigZag manner. The iterator should effectively handle scenarios where the lengths of input lists may differ. Function Signature ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): pass def next(self) -> int: pass def has_next(self) -> bool: pass ``` The `ZigZagIterator` class should include: * An **initializer** to set up the structure. * A `next()` method that returns the next element in the ZigZag sequence. * A `has_next()` method that returns `True` if there are more elements in the sequence, and `False` otherwise. Input/Output Format * **Input**: Two lists of integers, `v1` and `v2`. * **Output**: Using the functions described above, the next values in the zigzag iteration pattern. Constraints * `0 <= len(v1), len(v2) <= 10^4` * `v1` and `v2` only contain integers. * The functions should handle edge cases like empty lists. Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` Performance Requirements * Your implementation should be efficient, aiming for O(n) time complexity, where n is the total number of elements in the input lists. * Use O(n) space for storing elements, but seek to optimize space usage if possible. Key Considerations * Ensure your implementation correctly handles cases with different list lengths. * Avoid adding unnecessary complexity; focus on clarity and efficiency. * Consider edge cases such as one or both lists being empty.","solution":"from collections import deque class ZigZagIterator: def __init__(self, v1: list[int], v2: list[int]): self.queue = deque() if v1: self.queue.append((v1, 0)) if v2: self.queue.append((v2, 0)) def next(self) -> int: list_ref, index = self.queue.popleft() result = list_ref[index] if index + 1 < len(list_ref): self.queue.append((list_ref, index + 1)) return result def has_next(self) -> bool: return bool(self.queue)"},{"question":"You are given sparse vectors, where the vectors contain mostly zero elements. Your task is to: 1. Design a function to convert these vectors into a compressed format that stores only non-zero elements along with their indices. 2. Implement a function to calculate the dot product of two sparse vectors represented in this compressed format. # Requirements Part 1: Compressed Format Conversion Write a function `vector_to_index_value_list(vector)` which: - Takes a list `vector` of floating-point numbers. - Returns a list of tuples `(index, value)`, where `value` is non-zero and appears at position `index` in the original vector. Part 2: Dot Product Calculation Write a function `dot_product(iv_list1, iv_list2)` which: - Takes two lists `iv_list1` and `iv_list2`, each consisting of `(index, value)` tuples. - Returns the dot product of the two original vectors from which these compressed formats were derived. # Method Signatures ```python def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: pass def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: pass ``` # Input Constraints * The input vectors to `vector_to_index_value_list` can have lengths up to `10^6`. * The input lists to `dot_product` will have indexed values sorted by index, and the total number of non-zero entries combined from both lists will not exceed `10^6`. # Output * The function `vector_to_index_value_list` should output a list of `(index, value)` tuples. * The function `dot_product` should output a single floating-point number which is the dot product of the two vectors. # Example ```python # Example usage: vector1 = [1.0, 0.0, 2.5, 0.0, 0.0, 10.0] vector2 = [0.0, 3.0, 2.5, 0.0, 1.0, 0.0] iv_list1 = vector_to_index_value_list(vector1) iv_list2 = vector_to_index_value_list(vector2) print(iv_list1) # Output: [(0, 1.0), (2, 2.5), (5, 10.0)] print(iv_list2) # Output: [(1, 3.0), (2, 2.5), (4, 1.0)] print(dot_product(iv_list1, iv_list2)) # Output: 6.25 (since 2.5*2.5 = 6.25 from the shared index 2) ``` # Notes * Ensure your solution handles edge cases such as vectors with all zeroes. * Aim to optimize the performance for very large vectors with minimal non-zero values. * When implementing the dot product, make use of the sorted nature of index-value lists for efficient traversal.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Convert a vector into a compressed format that stores only non-zero elements along with their indices. return [(index, value) for index, value in enumerate(vector) if value != 0.0] def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Calculate the dot product of two sparse vectors represented in compressed format. i, j = 0, 0 result = 0.0 while i < len(iv_list1) and j < len(iv_list2): index1, value1 = iv_list1[i] index2, value2 = iv_list2[j] if index1 == index2: result += value1 * value2 i += 1 j += 1 elif index1 < index2: i += 1 else: j += 1 return result"},{"question":"# Question Implement a function `reverse_words_ext(input_string: str) -> str` that reverses the order of words in a given input string, making sure to handle special cases such as multiple spaces between words and leading or trailing spaces. Input * `input_string` (str): A string which may contain multiple words and multiple spaces. Output * A reversed word order string with exactly one space between words and no leading or trailing spaces. # Constraints - The length of the input string will not exceed 10^4. - The input string may contain uppercase and lowercase English letters and spaces. - The function should preserve the original capitalization of the words. # Example # Input: ```python input_string = \\" Hello world! This is an example string. \\" ``` # Output: ```python \\"string. example an is This world! Hello\\" ``` # Explanation In the given example, the function should: - Trim leading and trailing spaces. - Split the string on spaces. - Reverse the list of words. - Join them ensuring only single spaces between words.","solution":"def reverse_words_ext(input_string): Reverses the order of words in the given input string, ensuring exactly one space between words and no leading or trailing spaces. Args: input_string (str): A string that may contain multiple words and multiple spaces. Returns: str: A string with the words in reverse order, separated by a single space. # Strip leading and trailing spaces, split by spaces, filter empty strings, reverse the list words = input_string.strip().split() return \' \'.join(reversed(words))"},{"question":"# Permutation Generator with Constraints You have been provided with a recursive function `permute` that generates all possible permutations of a sequence of distinct numbers. However, in certain situations, generating all permutations at once might be inefficient in terms of time and memory. Your task is to write a function that generates permutations of a list iteratively, without using recursion, and yields each permutation one at a time. # Constraints * You cannot use any built-in library functions for permutations. * The function must handle lists of up to 9 elements efficiently. * You must ensure each permutation is yielded only once. # Input and Output Format * **Input**: A list of distinct integers `elements`, with at most 9 elements. * **Output**: Yields each permutation of the list one at a time. # Example ```python elements = [1, 2, 3] Expected output: [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1] ``` # Function Signature ```python def permute_iterative(elements): # Your implementation here pass ``` # Task Context Considering the high complexity of generating all permutations, your task is to implement an iterative approach that yields each permutation immediately, which can be useful in applications where permutations need to be processed one-by-one without holding all of them in memory.","solution":"def permute_iterative(elements): Iteratively generates permutations of the input list. :param elements: List of distinct integers :yield: Yields each permutation one at a time n = len(elements) indexes = list(range(n)) cycles = list(range(n, 0, -1)) yield elements[:] while n: for i in reversed(range(n)): cycles[i] -= 1 if cycles[i] == 0: indexes[i:] = indexes[i+1:] + indexes[i:i+1] cycles[i] = n - i else: j = cycles[i] indexes[i], indexes[-j] = indexes[-j], indexes[i] yield [elements[index] for index in indexes] break else: return"},{"question":"You are tasked with finding the first occurrence of a specific element within an unordered list of integers. Implement the function `find_element_index` that takes two parameters: a list of integers and a query integer. Your function should return the index of the query integer if it is present in the list. If the query integer is not present, return -1. # Function Signature ```python def find_element_index(array: List[int], query: int) -> int: ``` # Input - `array`: A list of integers representing the array. The length of the array can be from 0 to 10^6. - `query`: An integer representing the element to be found in the array. # Output - Return an integer representing the first occurrence of the query element in the array. If the query element is not present, return -1. # Constraints - The elements in the array can be both positive and negative integers. - The array can be empty. - The query element may or may not be present in the array. # Performance Requirements - The function should run in O(n) time complexity where n is the length of the array. - Space complexity should be O(1). # Example ```python print(find_element_index([10, 15, 20, 25, 30], 25)) # Output: 3 print(find_element_index([7, 5, 9, 8], 6)) # Output: -1 print(find_element_index([], 1)) # Output: -1 print(find_element_index([1, 2, 3, 4, 5], 3)) # Output: 2 ``` **Note**: The function should be designed to perform efficiently and handle edge cases, such as an empty list or the query element not being present.","solution":"from typing import List def find_element_index(array: List[int], query: int) -> int: Finds the first occurrence of the query element in the array. Parameters: array (List[int]): List of integers where the search is performed. query (int): The integer to be found in the array. Returns: int: The index of the first occurrence of the query element, or -1 if it is not found. for index, element in enumerate(array): if element == query: return index return -1"},{"question":"Context In this task, you\'ll work with real-time data streams to identify unique elements after cancelling out pairs. This method efficiently compacts streams to a single remaining element if it meets specific conditions, leveraging bitwise operations for fast processing. Objective Implement a function to determine if a stream of non-negative number-sign tuples is 1-sparse (has only one unique remaining number after all other numbers cancel out) and return that unique number. Function Signature ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: pass ``` Input * `array`: A list of tuples where each tuple contains a non-negative integer and a sign (\'+\'/\'-\'). Output * An integer representing the unique non-cancelled number if the stream is 1-sparse. * Return `None` if there\'s no unique non-cancelled number or if the stream is not 1-sparse. Constraints * Numbers in the tuples will be non-negative integers. * The sign will only be \'+\' or \'-\'. Example ```python # Example 1: input_stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] print(one_sparse(input_stream)) # Output: 4 # Example 2: input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] print(one_sparse(input_stream)) # Output: 2 # Example 3: input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] print(one_sparse(input_stream)) # Output: None ``` Scenarios and Constraints 1. Design the function to handle asynchronous streams continuously without prior knowledge of the input length. 2. Utilize bitwise operations to track the sum of bits efficiently.","solution":"from typing import List, Tuple, Optional def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: # We\'ll use a dictionary to track the count of each number count_dict = {} for number, sign in array: if sign == \'+\': count_dict[number] = count_dict.get(number, 0) + 1 elif sign == \'-\': count_dict[number] = count_dict.get(number, 0) - 1 # Iterate through the dictionary to find the unique non-cancelled number unique_number = None for number, count in count_dict.items(): if count != 0: if unique_number is not None: # More than one unique number found return None unique_number = number return unique_number"},{"question":"You are provided with a class `Interval` that represents a range of real numbers, and various methods to perform operations such as checking membership and merging overlapping intervals. Your task is to write a function that takes a list of intervals, represented as tuples, and returns a list of non-overlapping intervals after merging. # Requirements - **Function Signature**: ```python def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` - **Input**: - `intervals`: A list of tuples, where each tuple (start, end) represents an interval `(0 <= start <= end)`. - **Output**: - A list of merged, non-overlapping intervals represented as tuples. - **Constraints**: - Every interval will have its start and end as integers. - The input list can be empty. - The intervals may overlap or be adjacent. # Example - **Example 1**: ```python intervals = [(1, 3), (2, 4), (5, 7)] merge_intervals(intervals) ``` **Output**: ```python [(1, 4), (5, 7)] ``` **Explanation**: Intervals (1, 3) and (2, 4) overlap and are merged to form (1, 4). The interval (5, 7) does not overlap with any other interval. - **Example 2**: ```python intervals = [(1, 5), (6, 10), (10, 15)] merge_intervals(intervals) ``` **Output**: ```python [(1, 5), (6, 15)] ``` **Explanation**: Intervals (6, 10) and (10, 15) are adjacent and thus merged to (6, 15). # Additional Information When merging, ensure the resulting list is also sorted by the start of the intervals.","solution":"def merge_intervals(intervals): Merge overlapping intervals, returning a list of non-overlapping intervals. :param intervals: List of tuples, where each tuple (start, end) represents an interval :return: List of merged, non-overlapping intervals represented as tuples if not intervals: return [] # Sort the intervals by their start times intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"# Question: Encode and Decode Strings You are required to implement two functions to encode and decode a list of strings. The encoding function will convert a list of strings into a single string that can be transmitted over a network or stored, and the decoding function will revert the encoded string back into the original list of strings. Function Signature ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` Input - `encode`: A list of strings `strs` where each string can include any characters. - `decode`: A single encoded string `s` representing a list of strings. Output - `encode`: A single string that is the encoded representation of the list of strings. - `decode`: A list of original strings that were encoded. Constraints 1. The encoded format should be efficient and reasonably compact. 2. Both functions should handle edge cases like lists containing empty strings, strings with colons, and very large strings. 3. The original contents of strings in the list must be preserved exactly after encoding and decoding. Examples ```python # Example 1: input_list = [\\"hello\\", \\"world\\"] encoded_str = encode(input_list) print(encoded_str) # Example: \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] # Example 2: input_list = [\\"\\", \\"abc\\", \\"123\\"] encoded_str = encode(input_list) print(encoded_str) # Example: \\"0:3:abc3:123\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"\\", \\"abc\\", \\"123\\"] ``` Additional Notes * Focus on ensuring that the delimiter used in encoding does not interfere with the content of the strings. * Optimize for performance and ensure the solution scales well with larger inputs. * Consider how to handle special characters and strings with internal colons and numbers.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. Args: - strs (List[str]): A list of strings to encode. Returns: - str: The encoded string. encoded = \\"\\" for string in strs: length = len(string) encoded += f\\"{length}:{string}\\" return encoded def decode(s: str) -> List[str]: Decodes a single string to a list of strings. Args: - s (str): The encoded string. Returns: - List[str]: The list of decoded strings. strs = [] i = 0 while i < len(s): # Find the position of the next \':\' which separates the length and string j = s.find(\':\', i) length = int(s[i:j]) j += 1 strs.append(s[j:j+length]) i = j + length return strs"},{"question":"# Context You are tasked with completing a Red-Black Tree implementation for an application that tracks user actions in real-time. The application requires efficient insertion, deletion, and retrieval of user actions to maintain performance. # Problem You need to implement a function that returns the in-order traversal of the Red-Black Tree. The result should contain nodes\' values and their corresponding colors. # Function Signature ```python def inorder_traversal(rb_tree: RBTree) -> List[dict]: Perform an in-order traversal of the Red-Black Tree. Parameters: rb_tree (RBTree): The Red-Black Tree instance. Returns: List[dict]: A list of dictionaries with \'val\' and \'color\' keys for each node. ``` # Input * An instance of `RBTree` which may contain several `RBNode`s. # Output * A list of dictionaries, where each dictionary represents a node in the Red-Black Tree containing: * `val`: The value of the node. * `color`: The color of the node (0 for black, 1 for red). # Constraints * The Red-Black Tree will contain between 0 and 1,000,000 nodes. * The values inserted in the Red-Black Tree will be unique integers. # Example ```python # Given an initialized and populated RBTree object \'rb\' expected_output = [ {\'val\': 1, \'color\': 0}, {\'val\': 2, \'color\': 1}, {\'val\': 4, \'color\': 0}, ... ] assert inorder_traversal(rb) == expected_output ``` # Requirements: * Implement the full `inorder_traversal` function. * The traversal should follow in-order sequence (left-root-right).","solution":"class RBNode: def __init__(self, val, color): self.val = val self.color = color # 0 for black, 1 for red self.left = None self.right = None class RBTree: def __init__(self): self.root = None def inorder_traversal(rb_tree): Perform an in-order traversal of the Red-Black Tree. Parameters: rb_tree (RBTree): The Red-Black Tree instance. Returns: List[dict]: A list of dictionaries with \'val\' and \'color\' keys for each node. def in_order(node): if not node: return [] return in_order(node.left) + [{\'val\': node.val, \'color\': node.color}] + in_order(node.right) return in_order(rb_tree.root)"},{"question":"**Question: Anagram Checker for Extended Character Sets** You are given two strings, and you need to determine if they are anagrams. Unlike the simplified version that only accounts for lowercase \'a\' to \'z\', your implementation should work for any printable ASCII character. # Input: * Two strings, `s1` and `s2`, where each string can contain any printable ASCII character. # Output: * Return `True` if the two strings are anagrams, and `False` otherwise. # Example: ```python # Example 1 s1 = \\"apple\\" s2 = \\"pleap\\" print(anagram(s1, s2)) # Output: True # Example 2 s1 = \\"apple\\" s2 = \\"cherry\\" print(anagram(s1, s2)) # Output: False # Example 3 s1 = \\"AaBb\\" s2 = \\"bBaA\\" print(anagram(s1, s2)) # Output: True # Example 4 s1 = \\"Anagram!\\" s2 = \\"nag a ram\\" print(anagram(s1, s2)) # Output: True ``` Function Signature ```python def anagram(s1: str, s2: str) -> bool: # Your code here return ``` # Constraints: * The length of `s1` and `s2` will not exceed 100,000 characters. **Performance Requirements**: * Your solution should aim for linear time complexity, O(n), where `n` is the length of the strings. * Space complexity should be O(1), using a fixed-size data structure (e.g., an array or dictionary) regardless of the string length. Consider edge cases such as: * Differently cased characters. * Special characters and spaces. * Empty strings as input. Note that you must handle all printable ASCII characters, ensure that your method performs fast even for large inputs, and return accurate results for all edge cases mentioned above.","solution":"def anagram(s1: str, s2: str) -> bool: Determine if the two strings s1 and s2 are anagrams. from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Task Description Write a function `normalize_path(paths: List[str]) -> List[str]` that takes a list of file paths and returns a list of their normalized absolute paths. Use the principles depicted in the given code snippet to expand user home directory shortcuts and convert relative paths to absolute ones. # Input * `paths` (List[str]): A list of file path strings. Each element can be a relative path, an absolute path, or a path with a home directory shortcut (`~`). # Output * A list of strings where each element is the absolute path corresponding to the input paths. # Constraints * No path exceeds 4096 characters. * The list will have at most 1000 paths. # Performance Requirements * Your solution should handle the average case efficiently. It should not have prohibitively high runtime or memory usage. # Example ```python input_paths = [\\"~/documents\\", \\"./project\\", \\"/etc/hosts\\"] print(normalize_path(input_paths)) # Expected output might be something like: # [\'/home/username/documents\', \'/current/working/directory/project\', \'/etc/hosts\'] ``` # Notes 1. Use the `os` module to resolve the paths correctly. 2. Handle all edge cases such as invalid or non-existent paths gracefully.","solution":"import os from typing import List def normalize_path(paths: List[str]) -> List[str]: Takes a list of file paths and returns a list of their normalized absolute paths. return [os.path.abspath(os.path.expanduser(path)) for path in paths]"},{"question":"# Scenario You have been tasked with determining the nth digit in a theoretical sequence formed by and concatenating positive integers. For instance, the sequence starts with \\"123456789101112131415...\\" and so on. Your objective is to write a function that will tell which digit appears at the nth position. # Challenge Write a function `find_nth_digit` that takes an integer `n` as its input and returns the digit found at position `n` in the concatenated sequence of all natural numbers. # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input and Output * **Input**: An integer `n` (1 <= n <= 2*10^9) * **Output**: An integer representing the digit at position `n` in the sequence. # Examples ```python assert find_nth_digit(3) == 3 # \'1 2 3\' -> The third digit is 3. assert find_nth_digit(11) == 0 # \'123456789 10 11\' -> The eleventh digit is the first \'0\' in 10. assert find_nth_digit(12) == 1 # \'1234567891 0 11\' -> The twelfth digit is the \'1\' in 10. ``` # Constraints * Ensure your solution is optimized to handle large values rapidly given the constraints. * Avoid unnecessary memory usage and handle edge cases effectively. # Notes * Pay attention to potential issues with floating point division accuracy. * Ensure your solution properly adjusts for transitioning between numeric length segments (such as from single-digit to double-digit numbers).","solution":"def find_nth_digit(n: int) -> int: length = 1 # The length of the numbers we are currently counting through (1 for 1-9, 2 for 10-99, etc.) count = 9 # The initial count of digits in numbers of the current length start = 1 # The starting number of the current length while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length # Identify the actual number digit_index = (n - 1) % length # Identify the digit in that number return int(str(start)[digit_index])"},{"question":"**Title**: Efficient Fibonacci Number Calculation **Objective**: Write a function to calculate the n-th Fibonacci number in a highly efficient manner. Your solution should demonstrate your understanding of dynamic programming and space optimization techniques. **Function Signature**: ```python def efficient_fibonacci(n: int) -> int: pass ``` **Input**: - An integer `n` (0 <= n <= 10^18). **Output**: - An integer representing the n-th Fibonacci number. **Constraints**: - You must implement a solution with time complexity no worse than O(log n). - The space complexity should be O(1). **Performance Requirements**: - Your solution should be able to handle large inputs efficiently, up to the maximum constraint value of 10^18 without any performance issues. # Example ```python assert efficient_fibonacci(0) == 0 assert efficient_fibonacci(1) == 1 assert efficient_fibonacci(10) == 55 assert efficient_fibonacci(50) == 12586269025 ``` # Scenario Imagine you are working on a high-performance financial application where Fibonacci numbers are used to model some complex financial scenarios. These calculations need to be efficient and handle very large values of `n` quickly. Your task is to enhance the current function to meet these performance needs. # Guidelines - Consider using matrix exponentiation or another suitable algorithm to achieve the required time complexity. - Ensure edge cases (e.g., n = 0 and n = 1) are handled correctly. - Properly document your approach and thought process in the comments within your code.","solution":"def efficient_fibonacci(n: int) -> int: Calculate the nth Fibonacci number using matrix exponentiation. The time complexity is O(log n) and the space complexity is O(1). if n == 0: return 0 if n == 1: return 1 def multiply_matrices(m1, m2): Multiplies two 2x2 matrices return [ [m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0], m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]], [m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0], m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]], ] def matrix_power(matrix, power): Computes matrix to the power in logarithmic time result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result # Base transformation matrix for Fibonacci sequence transformation_matrix = [[1, 1], [1, 0]] # Raise the transformation matrix to the (n-1)th power result_matrix = matrix_power(transformation_matrix, n - 1) # The top left element of the result matrix is the nth Fibonacci number return result_matrix[0][0]"},{"question":"# Decoded String Conversion You are tasked with writing a function that decodes an encoded string into its expanded form. The encoding pattern used is `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated `k` times. Here, `k` is a positive integer. Input Format * **s**: A well-formed, encoded string. Output Format * A single string representing the decoded and expanded form. Constraints: * The input string `s` contains no spaces. * The input string is assumed to be well-formed with matching brackets. * Digit characters in the input string are used exclusively for the repeat numbers. # Function Signature ```python def decode_string(s: str) -> str: pass ``` # Examples 1. `s = \\"3[a]2[bc]\\"`, return `\\"aaabcbc\\"` 2. `s = \\"3[a2[c]]\\"`, return `\\"accaccacc\\"` 3. `s = \\"2[abc]3[cd]ef\\"`, return `\\"abcabccdcdcdef\\"` # Example Walkthrough: `\\"3[a2[c]]\\"` would be expanded as follows: 1. `2[c]` is decoded first, giving `\\"cc\\"`. 2. Thus, the string become `\\"3[acc]\\"`. 3. `\\"acc\\"` is repeated 3 times to give `\\"accaccacc\\"`. Implement the function `decode_string(s: str) -> str` using the algorithm provided above, ensuring that the function handles nested and repeated patterns correctly and efficiently.","solution":"def decode_string(s: str) -> str: Decodes an encoded string with the pattern k[encoded_string]. stack = [] curr_num = 0 curr_str = \'\' for char in s: if char.isdigit(): curr_num = curr_num * 10 + int(char) # In case there are multi-digit numbers elif char == \'[\': stack.append((curr_str, curr_num)) curr_str = \'\' curr_num = 0 elif char == \']\': last_str, num = stack.pop() curr_str = last_str + num * curr_str else: curr_str += char return curr_str"},{"question":"# Implementing a Circular Queue **Context**: A circular queue (or ring buffer) is a data structure that utilizes a fixed-size buffer in a circular manner. When the buffer is full, new elements wrap around to the beginning of the buffer. This is useful in situations where a fixed size is advantageous, such as managing streaming data or buffering data for hardware communication. **Objective**: Implement a circular queue with capacity management, ensuring efficient use of space by reusing vacant slots. # Task 1. Implement a class `CircularQueue`. Specifications: * `__init__(self, k: int)`: - Initializes the queue to be empty with a maximum size of `k`. * `enqueue(self, value: int) -> bool`: - Adds an element to the circular queue. Returns `True` if the operation is successful, else `False`. * `dequeue(self) -> bool`: - Removes an element from the circular queue. Returns `True` if the operation is successful, else `False`. * `Front(self) -> int`: - Gets the front item from the queue. If the queue is empty, returns -1. * `Rear(self) -> int`: - Gets the last item from the queue. If the queue is empty, returns -1. * `isEmpty(self) -> bool`: - Checks whether the queue is empty. * `isFull(self) -> bool`: - Checks whether the queue is full. # Constraints and Considerations: - You may assume that all operations are valid: for example, no dequeue or getFront operations will be called on an empty queue. - The number of elements in the queue will not exceed its fixed capacity. # Example: ```python # Create a queue with capacity of 3 cq = CircularQueue(3) # Enqueue elements cq.enqueue(1) # returns True cq.enqueue(2) # returns True cq.enqueue(3) # returns True cq.enqueue(4) # returns False (queue is full) # Get front and rear elements cq.Front() # returns 1 cq.Rear() # returns 3 # Dequeue elements cq.dequeue() # returns True cq.enqueue(4) # returns True # After these operations, the elements in the circular queue are [2, 3, 4] # Get front and rear elements cq.Front() # returns 2 cq.Rear() # returns 4 ``` Implement the `CircularQueue` class below: ```python class CircularQueue: def __init__(self, k: int): # Your initialization code here def enqueue(self, value: int) -> bool: # Your enqueue logic here def dequeue(self) -> bool: # Your dequeue logic here def Front(self) -> int: # Your front retrieval logic here def Rear(self) -> int: # Your rear retrieval logic here def isEmpty(self) -> bool: # Check if queue is empty def isFull(self) -> bool: # Check if queue is full ```","solution":"class CircularQueue: def __init__(self, k: int): Initialize the circular queue with a fixed capacity. self.queue = [None] * k # fixed-size list self.head = -1 self.tail = -1 self.max_size = k self.current_size = 0 def enqueue(self, value: int) -> bool: Add an element to the circular queue. Returns True if the operation is successful, else False. if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = 0 else: self.tail = (self.tail + 1) % self.max_size self.queue[self.tail] = value self.current_size += 1 return True def dequeue(self) -> bool: Remove an element from the circular queue. Returns True if the operation is successful, else False. if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.max_size self.current_size -= 1 return True def Front(self) -> int: Get the front item from the queue. If the queue is empty, returns -1. if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: Get the last item from the queue. If the queue is empty, returns -1. if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: Check whether the queue is empty. return self.current_size == 0 def isFull(self) -> bool: Check whether the queue is full. return self.current_size == self.max_size"},{"question":"# Coding Challenge Question: Digit-Power Summation Numbers You are given the task of identifying numbers within a specified range that exhibit a unique property. Specifically, these numbers should equal the sum of their digits raised to consecutively increasing powers (starting from 1). For example: - **89** is such a number because 8^1 + 9^2 = 89. - Similarly, **135** is such a number because 1^1 + 3^2 + 5^3 = 135. Your task is to implement the function `find_digit_power_sum(low, high)` that takes two integers, `low` and `high`, and returns a list of all numbers within this range (inclusive) that possess this property. # Function Signature ```python def find_digit_power_sum(low: int, high: int) -> List[int]: ``` # Input - `low` (int): Lower bound of the range (1 ≤ low ≤ high ≤ 10000). - `high` (int): Upper bound of the range. # Output - Returns a list of integers that display the described property within the given range. # Constraints - The function should run efficiently for given constraints. # Examples ```python assert find_digit_power_sum(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_digit_power_sum(10, 100) == [89] assert find_digit_power_sum(100, 150) == [135] ``` You are expected to handle the input range effectively and optimize your solution to work within the given constraints. Consider edge cases and optimize your implementation to avoid unnecessary repetitions and computations where possible.","solution":"from typing import List def find_digit_power_sum(low: int, high: int) -> List[int]: def is_digit_power_sum(n: int) -> bool: digits = list(map(int, str(n))) return n == sum(digit ** (i + 1) for i, digit in enumerate(digits)) result = [] for number in range(low, high + 1): if is_digit_power_sum(number): result.append(number) return result"},{"question":"You are working on a system that interacts with hardware requiring integer data to be represented in both big-endian and little-endian byte formats. Your task is to implement two functions that take a byte sequence and convert it to its corresponding integer representation based on the endian format. You will also implement two functions that convert integers to their bytes representation. Functions to Implement 1. `int_to_bytes_big_endian(num: int) -> bytes` * Input: Non-negative integer `num` * Output: `bytes` object representing the integer in big-endian format. * Constraints: The integer `num` will be non-negative and can be very large. 2. `int_to_bytes_little_endian(num: int) -> bytes` * Input: Non-negative integer `num` * Output: `bytes` object representing the integer in little-endian format. * Constraints: The integer `num` will be non-negative and can be very large. 3. `bytes_big_endian_to_int(bytestr: bytes) -> int` * Input: `bytestr` is a non-empty `bytes` object representing an integer in big-endian format. * Output: Integer representation of the byte sequence. * Constraints: The input `bytestr` represents non-negative integers. 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` * Input: `bytestr` is a non-empty `bytes` object representing an integer in little-endian format. * Output: Integer representation of the byte sequence. * Constraints: The input `bytestr` represents non-negative integers. Example ```python assert int_to_bytes_big_endian(1024) == b\'x04x00\' assert int_to_bytes_little_endian(1024) == b\'x00x04\' assert bytes_big_endian_to_int(b\'x04x00\') == 1024 assert bytes_little_endian_to_int(b\'x00x04\') == 1024 ``` Performance * Ensure efficient execution for large integers, avoiding unnecessary operations that slow down the execution. * Take care of the space complexity to prevent excess memory usage, especially for large integers. Notes * Assume inputs are valid as per the constraints. * Consider optimization opportunities for performance improvements in your implementation.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, \'big\') def int_to_bytes_little_endian(num: int) -> bytes: if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, \'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: return int.from_bytes(bytestr, \'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: return int.from_bytes(bytestr, \'little\')"},{"question":"# Coding Challenge: Advanced FizzBuzz Variations Description Write a function called `advanced_fizzbuzz()` that generates a list of numbers from 1 to N inclusive with the following replacements: - If a number is divisible by 3, 5, and 7 simultaneously, replace it with \\"FizzBuzzBazz\\". - If a number is divisible by 3 and 5, replace it with \\"FizzBuzz\\". - If a number is divisible by 3 and 7, replace it with \\"FizzBazz\\". - If a number is divisible by 5 and 7, replace it with \\"BuzzBazz\\". - If a number is divisible by 3, replace it with \\"Fizz\\". - If a number is divisible by 5, replace it with \\"Buzz\\". - If a number is divisible by 7, replace it with \\"Bazz\\". - Else, keep the number as is. Function Signature ```python def advanced_fizzbuzz(n: int) -> List[Union[int, str]]: pass ``` Input - An integer `n` where 1 <= n <= 10^5. Output - A list of integers and/or strings based on the criteria mentioned. Constraints - The input value `n` will always be a positive integer. - The replacement values must be exact strings including the proper capitalization. Example ```python advanced_fizzbuzz(15) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Bazz\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Bazz\', \'FizzBuzz\'] ``` Additional Notes - Ensure the function handles the upper edge case where `n` can be very large efficiently. - Pay attention to the order of combination rules to ensure correct replacements.","solution":"from typing import List, Union def advanced_fizzbuzz(n: int) -> List[Union[int, str]]: result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0 and i % 7 == 0: result.append(\\"FizzBuzzBazz\\") elif i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0 and i % 7 == 0: result.append(\\"FizzBazz\\") elif i % 5 == 0 and i % 7 == 0: result.append(\\"BuzzBazz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") elif i % 7 == 0: result.append(\\"Bazz\\") else: result.append(i) return result"},{"question":"# Question You are tasked with writing a function to facilitate conversion between integer values and their corresponding network byte order (big-endian) and host byte order (little-endian) representations. You\'ll implement two additional functionalities using the provided code snippets for reference. Function 1: `convert_host_to_network_order(num)` This function converts an integer from host byte order (little-endian) to network byte order (big-endian). - **Input**: - `num` (int): A non-negative integer value. - **Output**: - `bytes`: A byte array representing the integer in network byte order (big-endian). Function 2: `convert_network_to_host_order(bytestr)` This function converts a byte array from network byte order (big-endian) to host byte order (little-endian). - **Input**: - `bytestr` (bytes): A byte array representing a big-endian encoded integer. - **Output**: - `int`: The integer represented by the given byte array in host byte order (little-endian). Constraints: - The input integer will be non-negative. - The byte array will not be empty. - Consider edge cases like when the integer is 0 or a very large number. # Example ```python # Example 1: num = 259 network_bytes = convert_host_to_network_order(num) # Should output: b\'x01x03\' host_int = convert_network_to_host_order(network_bytes) # Should output: 259 # Example 2: num = 1 network_bytes = convert_host_to_network_order(num) # Should output: b\'x01\' host_int = convert_network_to_host_order(network_bytes) # Should output: 1 ``` Implementation: Implement the following functions: ```python def convert_host_to_network_order(num): # Implement this function def convert_network_to_host_order(bytestr): # Implement this function ```","solution":"def convert_host_to_network_order(num): Converts an integer from host byte order (little-endian) to network byte order (big-endian). return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'big\') or b\'x00\' def convert_network_to_host_order(bytestr): Converts a byte array from network byte order (big-endian) to host byte order (little-endian). return int.from_bytes(bytestr, byteorder=\'big\')"},{"question":"# Radix Sort Implementation with Enhanced Functionality **Context**: You\'ve been given the task to sort a list of non-negative integers using the Radix Sort algorithm. Radix Sort processes the integers digit by digit and arranges them efficiently. To accommodate the variety of input data more robustly, you need to handle some specific scenarios such as duplicate numbers, very large digits, and possibly missing values. **Objective**: Write a function `enhanced_radix_sort` that sorts an input list of non-negative integers and outputs the sorted list. The function must include mechanisms to handle empty lists and provide simulation details by iteration if required. **Function Signature**: ```python def enhanced_radix_sort(arr: list[int], simulation: bool = False) -> list[int]: ``` **Input**: - `arr`: A list of non-negative integers. - `simulation`: A boolean flag enabling step-by-step simulation output, default is `False`. **Output**: - Returns a new list of sorted integers. **Constraints**: - The integers in `arr` are non-negative and fit within standard integer ranges. - List size `len(arr)` can range from `0` to `10^6`. - Digits can range up to the length of the maximum element in the list. **Performance Requirement**: - The solution is expected to operate within the time complexity of O(nk + n). **Example**: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(enhanced_radix_sort(arr)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] # With simulation enabled enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True) ``` **Extra Credit**: - Modify the function to handle sorting of negative integers. - Optimize the function to use in-place sorting to save memory.","solution":"def enhanced_radix_sort(arr, simulation=False): Perform radix sort on a list of non-negative integers. Parameters: arr (list): A list of non-negative integers. simulation (bool): If True, print step-by-step simulation. Defaults to False. Returns: list: The sorted list of non-negative integers. if len(arr) == 0: return arr # Function to get the maximum number of digits in the largest number def get_max_digits(arr): max_num = max(arr) return len(str(max_num)) # Function to do counting sort based on the digit represented by exp def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 if simulation: print(f\\"Count after counting digits at exp {exp}: {count}\\") # Change count[i] so that count[i] contains actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(len(arr)): arr[i] = output[i] if simulation: print(f\\"Array after sorting digits at exp {exp}: {arr}\\") max_digits = get_max_digits(arr) exp = 1 while max_digits > 0: counting_sort(arr, exp, simulation) exp *= 10 max_digits -= 1 return arr"},{"question":"# Path Splitting Functionality **Context**: In many file system or URL manipulations, it\'s important to extract the directory path and file name from a given path string. For example, in web development and Unix-based systems, paths are often used to specify locations of resources or files. **Objective**: Write a function that splits a given path into its directory and file name components using optimized string manipulation. Function Signature ```python def split_path(path: str) -> list: Function to split the given path into directory and file name components. Parameters: path (str): A string representing the full path (either a URL or file path). Returns: list: A list of two strings: - The directory path (string preceding the last \'/\'). - The file name (string following the last \'/\'). ``` Input * `path` (str): The string representing the full path. It might be a URL or a Unix-style file path. Output * A list containing two elements: - `part[0]`: The directory path. If the input path does not contain a \'/\', this part should be an empty string. - `part[1]`: The file name. If the input path does not contain a file name (e.g., ends with \'/\'), this part should be an empty string. Constraints 1. The function should handle different lengths of path, including an empty string. 2. Assume the input will not be `None`. 3. Consider both URLs and Unix-style paths as input. 4. You do not need to handle Windows-style paths with `` as the separator. Example ```python >>> split_path(\\"https://algorithms/unix/test.py\\") [\'https://algorithms/unix\', \'test.py\'] >>> split_path(\\"algorithms/unix/test.py\\") [\'algorithms/unix\', \'test.py\'] >>> split_path(\\"algorithms/test.py\\") [\'algorithms\', \'test.py\'] >>> split_path(\\"test.py\\") [\'\', \'test.py\'] >>> split_path(\\"https://algorithms/unix/\\") [\'https://algorithms/unix\', \'\'] ``` *Note*: The focus of this task is on handling paths, ensuring robust handling of edge cases, and providing a clear, efficient implementation.","solution":"def split_path(path: str) -> list: Function to split the given path into directory and file name components. Parameters: path (str): A string representing the full path (either a URL or file path). Returns: list: A list of two strings: - The directory path (string preceding the last \'/\'). - The file name (string following the last \'/\'). if not path: return [\\"\\", \\"\\"] last_slash_index = path.rfind(\'/\') if last_slash_index == -1: return [\\"\\", path] directory_path = path[:last_slash_index] file_name = path[last_slash_index+1:] return [directory_path, file_name]"},{"question":"# Problem: Pattern Matching in Genomic Sequences You are tasked with developing a pattern matching algorithm to search for occurrences of a specific sequence within a genomic DNA string. The objective is to efficiently locate the start position of the pattern within the genomic DNA, if it exists. # Function Signature ```python def find_pattern(pattern: str, genomic_sequence: str) -> int: pass ``` # Input * `pattern`: A string representing the DNA sequence we are searching for (not empty, length <= 100, composed of characters \'A\', \'T\', \'C\', \'G\'). * `genomic_sequence`: A string representing the DNA sequence in which we are searching (not empty, length <= 10^6, composed of characters \'A\', \'T\', \'C\', \'G\'). # Output * Returns an integer representing the starting index of the first occurrence of the pattern in the genomic sequence. If the pattern does not exist in the genomic sequence, return -1. # Constraints * The match should be case-sensitive. * You should implement a solution with a pattern matching algorithm, taking into account edge cases and time complexity. # Examples ```python assert find_pattern(\\"ATG\\", \\"GCTAGCTAGGATGGA\\") == 9 assert find_pattern(\\"TGC\\", \\"TGCTGCTGCTG\\") == 0 assert find_pattern(\\"AAC\\", \\"CCCGGGTTTAAA\\") == -1 ``` # Performance Requirements Your solution should strive to minimize false positives and efficiently handle large input sizes with minimal hash collisions. # Implementation Guide 1. Implement a Rolling Hash class similar to the one provided. 2. Use the `RollingHash` class to compute the hash of the pattern and the moving hash of the genomic sequence. 3. Compare hashes and confirm matches by direct string comparison. 4. Handle edge cases like empty inputs and pattern length greater than sequence length appropriately.","solution":"def find_pattern(pattern: str, genomic_sequence: str) -> int: Returns the starting index of the first occurrence of the pattern in the genomic sequence. If the pattern does not exist, it returns -1. m = len(pattern) n = len(genomic_sequence) if m > n: return -1 # Base value for the rolling hash function base = 256 prime = 101 # Initial hash values for pattern and the first window of the text pattern_hash = 0 window_hash = 0 h = 1 # Calculate the hash value of the pattern and the first window for i in range(m - 1): h = (h * base) % prime for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime window_hash = (base * window_hash + ord(genomic_sequence[i])) % prime # Slide the pattern over the text one by one for i in range(n - m + 1): if pattern_hash == window_hash: # Check for spurious hits if genomic_sequence[i:i + m] == pattern: return i if i < n - m: window_hash = (base * (window_hash - ord(genomic_sequence[i]) * h) + ord(genomic_sequence[i + m])) % prime if window_hash < 0: window_hash += prime return -1"},{"question":"**FizzBuzz Challenge with Input Validation** # Problem Statement Implement a function `fizzbuzz(n)` that returns a list containing the numbers from 1 to `n` inclusive with the following substitutions: - For multiples of 3, the list should contain \\"Fizz\\" instead of the number. - For multiples of 5, the list should contain \\"Buzz\\" instead of the number. - For numbers which are multiples of both 3 and 5, the list should contain \\"FizzBuzz\\" instead of the number. Additionally, your function should handle invalid input as follows: - Raise a `ValueError` if `n` is less than 1. - Raise a `TypeError` if `n` is not an integer. # Function Signature ```python def fizzbuzz(n: int) -> list: ``` # Input - An integer `n` (1 ≤ n): The upper bound of the range to generate the FizzBuzz sequence. # Output - A list of length `n`, where each element follows the rules described above. # Constraints - 1 ≤ n ≤ 10^6 # Examples ```python fizzbuzz(5) # Output: [1, 2, \'Fizz\', 4, \'Buzz\'] fizzbuzz(15) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Performance Requirement - Your solution should run efficiently for values of `n` up to 1,000,000.","solution":"def fizzbuzz(n): Returns a list of numbers from 1 to n with substitutions: - \'Fizz\' for multiples of 3, - \'Buzz\' for multiples of 5, - \'FizzBuzz\' for multiples of both 3 and 5. if not isinstance(n, int): raise TypeError(\'Input must be an integer\') if n < 1: raise ValueError(\'Input must be greater than or equal to 1\') result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Question: Advanced GCD and LCM Calculation You are tasked with implementing a function that calculates the Least Common Multiple (LCM) of two non-negative integers using an advanced GCD calculation method based on bitwise operations. Below is the detailed requirement for the task. Function Signature ```python def advanced_lcm(a: int, b: int) -> int: pass ``` Input - `a` (int): The first non-negative integer. - `b` (int): The second non-negative integer. Output - (int): Returns the least common multiple of `a` and `b`. Constraints - The inputs `a` and `b` are non-negative integers, where `0 <= a, b <= 10^6`. - Do not use the built-in `math.gcd` or `math.lcm` functions. Performance Requirements - The solution should operate efficiently with a time complexity of O(log(min(a, b))) and constant space complexity O(1). Context In various scenarios such as computing the synchronization of two repetitive events or simplifying ratios, it is crucial to determine the LCM using the efficient calculation of GCD. For this task, utilize the bitwise operations demonstrated in the `gcd_bit` function to implement a more efficient LCM calculation. Example ```python assert advanced_lcm(12, 15) == 60 assert advanced_lcm(0, 5) == 0 assert advanced_lcm(6, 8) == 24 assert advanced_lcm(10**6, 10**6) == 10**6 ``` **Hints:** 1. Extend the `gcd_bit` function provided in the initial snippets to integrate with the LCM calculation. 2. Ensure to handle edge cases correctly, especially when one of the integers is zero.","solution":"def advanced_gcd(a: int, b: int) -> int: Returns the greatest common divisor of a and b using bitwise operations. if a == b: return a if a == 0: return b if b == 0: return a # a and b are both even if (a & 1) == 0 and (b & 1) == 0: return advanced_gcd(a >> 1, b >> 1) << 1 # a is even and b is odd elif (a & 1) == 0: return advanced_gcd(a >> 1, b) # a is odd and b is even elif (b & 1) == 0: return advanced_gcd(a, b >> 1) # both a and b are odd, a >= b elif a >= b: return advanced_gcd((a - b) >> 1, b) # both a and b are odd, a < b else: return advanced_gcd(a, (b - a) >> 1) def advanced_lcm(a: int, b: int) -> int: Returns the least common multiple of a and b using the advanced gcd calculation. if a == 0 or b == 0: return 0 gcd_val = advanced_gcd(a, b) return (a // gcd_val) * b"},{"question":"**Objective**: Implement the Counting Sort algorithm to sort an array of integers, which may include both positive and negative values. **Constraints**: 1. The elements of the array can be both positive and negative integers. 2. The array will contain at most 10^5 integers. 3. Each integer in the array will be between -10^9 and 10^9. **Input**: - A list of integers `arr` of size `n`. **Output**: - A list of integers sorted in non-decreasing order. **Scenario**: You are a software engineer working on a data processing system. One of the requirements is to efficiently sort large arrays of integer data for further analysis. You decide to use Counting Sort due to its linear time complexity under specific conditions. **Example**: ```python Input: arr = [-5, -10, 0, 3, 8, 5, -2] Output: [-10, -5, -2, 0, 3, 5, 8] ``` # Instructions: 1. Your function should be named `custom_counting_sort`. 2. You should take a single parameter `arr`, which is a list of integers. 3. You should return a list of integers sorted in non-decreasing order. # Function Signature: ```python def custom_counting_sort(arr: List[int]) -> List[int]: # your code here ``` **Constraints to be maintained**: - Ensure the algorithm runs efficiently and handles the given constraints.","solution":"def custom_counting_sort(arr): if not arr: return arr # Find the minimum and maximum values in arr min_val = min(arr) max_val = max(arr) # Initialize count array count_range = max_val - min_val + 1 count_array = [0] * count_range # Populate the count array for num in arr: count_array[num - min_val] += 1 # Write the sorted values back to arr sorted_arr = [] for i in range(count_range): sorted_arr.extend([i + min_val] * count_array[i]) return sorted_arr"},{"question":"You are asked to create a flexible `ZigZagIterator` class that can iterate over multiple input lists (not restricted to two) in a zigzag fashion. This iterator should not be confined to exactly two lists but should work for any number of input lists provided during initialization. # Implementation Details: - **Constructor**: Initialize the iterator with any number of input lists. - **next** method**: Return the next element in zigzag order. - **has_next method**: Return True if there are any remaining elements, otherwise False. # Requirements: 1. **Input**: Multiple lists of integers. 2. **Output for `next`**: The next integer in the zigzag order. 3. **Output for `has_next`**: A boolean indicating if there are more elements to process. # Example: ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] it = ZigZagIterator(*lists) output = [] while it.has_next(): output.append(it.next()) print(output) # Output should be [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Constraints: 1. The number of lists will be at least one and at most 1000. 2. The total number of elements across all lists will not exceed 10000. # Performance Requirements: - Your solution should efficiently manage iteration across potentially large input sets with minimal delay.","solution":"from collections import deque class ZigZagIterator: def __init__(self, *lists): self.queue = deque((lst for lst in lists if lst)) self.indices = {id(lst): 0 for lst in self.queue} def next(self): if not self.has_next(): raise Exception(\\"No more elements\\") current = self.queue.popleft() cur_id = id(current) idx = self.indices[cur_id] val = current[idx] idx += 1 if idx < len(current): self.indices[cur_id] = idx self.queue.append(current) return val def has_next(self): return bool(self.queue)"},{"question":"Context You are developing a search tool for a library\'s digital archive, where you often need to search through sorted lists of publication years. The distribution of publication years is relatively uniform over large time spans, making interpolation search a potentially suitable algorithm. Task Implement the interpolation search algorithm by writing a function that efficiently searches for a given year in a sorted list of publication years. Your implementation should handle edge cases gracefully and ensure optimal performance for uniformly distributed data. Function Specification **Function Name**: `find_publication_year` **Input**: - `years`: A sorted list of integers representing the years of publication. - `target_year`: An integer representing the year to search for. **Output**: - Return the index of `target_year` in the `years` list if found, otherwise return -1. Constraints: 1. The list `years` will be sorted in non-decreasing order. 2. The length of `years` is between 0 and 10^6. 3. `target_year` will be an integer between 0 and 10^9. Performance Requirements: - Average time complexity should ideally be O(log2(log2 n)). - Worst-case scenarios should gracefully fall back without significant delay but may require up to O(n) time. Example ```python def find_publication_year(years: List[int], target_year: int) -> int: # Your efficient implementation here pass # Example Usage: years = [1880, 1890, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970] print(find_publication_year(years, 1930)) # Output: 5 print(find_publication_year(years, 1980)) # Output: -1 ``` **Additional Notes**: - Ensure your function handles empty lists and large ranges of years effectively. - Consider edge cases, performance bottlenecks, and error scenarios in your implementation.","solution":"def find_publication_year(years, target_year): Performs an interpolation search for the target year in the sorted list of years. Args: - years (list of int): The sorted list of publication years. - target_year (int): The year to search for. Returns: - int: The index of the target year if found, otherwise -1. if not years: return -1 low = 0 high = len(years) - 1 while low <= high and target_year >= years[low] and target_year <= years[high]: if low == high: if years[low] == target_year: return low return -1 pos = low + ((high - low) // (years[high] - years[low] + 1) * (target_year - years[low])) if years[pos] == target_year: return pos if years[pos] < target_year: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Graph Traversal using DFS and BFS **Scenario**: Imagine you are developing a navigation system that requires searching through a roadmap represented as a graph. Each city is a node, and the roads between them are edges. Depending on the specific use case, you might need to traverse this graph in different ways to find various solution paths. **Task**: Implement functions to traverse the graph using both Depth-First Search (DFS) and Breadth-First Search (BFS). The graph is represented as an adjacency list where keys are node values, and values are lists of adjacent nodes. **Function Signatures**: `def dfs_traverse(graph: dict, start: str) -> set` `def bfs_traverse(graph: dict, start: str) -> set` **Input**: - `graph`: A dictionary where keys are nodes, and values are lists of adjacent nodes. - `start`: A string representing the starting node for traversal. **Output**: - Return a set of nodes visited during the traversal. **Constraints**: - The graph can have up to 10^4 nodes. - The start node is guaranteed to be in the graph. - The graph may contain cycles. **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' assert dfs_traverse(graph, start) == {\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'} assert bfs_traverse(graph, start) == {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} ``` **Notes**: - The returned sets should contain all the nodes reachable from the start node. - The order of nodes in the sets does not matter for the purpose of this assessment. - Handling disconnected components or isolated nodes will not be required as the start node is always in a connected component.","solution":"def dfs_traverse(graph, start): Perform depth-first search (DFS) traversal of the graph starting from the start node. :param graph: Dictionary representing the graph as an adjacency list :param start: String representing the starting node :return: Set of visited nodes visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend([neighbor for neighbor in graph[node] if neighbor not in visited]) return visited def bfs_traverse(graph, start): Perform breadth-first search (BFS) traversal of the graph starting from the start node. :param graph: Dictionary representing the graph as an adjacency list :param start: String representing the starting node :return: Set of visited nodes visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend([neighbor for neighbor in graph[node] if neighbor not in visited]) return visited"},{"question":"# Question: Enhanced Greatest Common Divisor and Trailing Zero Computation Problem Statement You are tasked with enhancing and improving existing number-theoretic functions. Your task includes the development of optimized and robust versions for calculating the greatest common divisor (GCD), least common multiple (LCM), and counting trailing zeros in binary format. Specifically, you need to: 1. Write a function `optimized_gcd(a, b)` to compute the GCD of two integers with improved error handling and efficiency. 2. Write a function `advanced_lcm(a, b)` to compute the LCM of two integers using your `optimized_gcd`. 3. Write a function `count_trailing_zeros(n)` to count the number of trailing zeros in the binary representation of a non-negative integer, ensuring your implementation is efficient and covers edge cases. Function Specifications 1. **optimized_gcd(a, b)** - **Input**: Two integers `a` and `b` (can be negative, zero, or positive). - **Output**: Integer - the greatest common divisor of `a` and `b`. - **Constraints**: - At least one of `a` or `b` must be non-zero. - **Requirements**: - Use the Euclidean algorithm with additional checks for negative inputs. 2. **advanced_lcm(a, b)** - **Input**: Two nonzero integers `a` and `b`. - **Output**: Integer - the least common multiple of `a` and `b`. - **Constraints**: - Both `a` and `b` must be non-zero. - **Requirements**: - Utilize your `optimized_gcd` function. 3. **count_trailing_zeros(n)** - **Input**: A non-negative integer `n`. - **Output**: Integer - the count of trailing zeros in the binary representation of `n`. - **Constraints**: - `n` is a non-negative integer. - **Requirements**: - Efficiently handle edge cases when `n` is zero. ```python def optimized_gcd(a, b): # TODO: Implement the function here def advanced_lcm(a, b): # TODO: Implement the function here def count_trailing_zeros(n): # TODO: Implement the function here ``` Example Usage 1. **optimized_gcd** ```python assert optimized_gcd(48, 18) == 6 assert optimized_gcd(-48, 18) == 6 assert optimized_gcd(0, 18) == 18 assert optimized_gcd(18, 0) == 18 assert optimized_gcd(0, 0) # should raise an appropriate exception ``` 2. **advanced_lcm** ```python assert advanced_lcm(4, 5) == 20 assert advanced_lcm(0, 5) # should raise an appropriate exception ``` 3. **count_trailing_zeros** ```python assert count_trailing_zeros(40) == 3 # binary: 101000 assert count_trailing_zeros(34) == 1 # binary: 100010 assert count_trailing_zeros(0) == 0 # binary: 0 ``` Performance Requirements * Your implementations should be efficient and handle very large inputs gracefully.","solution":"def optimized_gcd(a, b): Compute the greatest common divisor of a and b using the Euclidean algorithm. Handles negative inputs and ensures at least one of the numbers is non-zero. if a == 0 and b == 0: raise ValueError(\\"At least one of the integers must be non-zero\\") a, b = abs(a), abs(b) while b: a, b = b, a % b return a def advanced_lcm(a, b): Compute the least common multiple of a and b using the relationship between GCD and LCM. Both a and b must be non-zero. if a == 0 or b == 0: raise ValueError(\\"Both integers must be non-zero\\") return abs(a * b) // optimized_gcd(a, b) def count_trailing_zeros(n): Count the number of trailing zeros in the binary representation of a non-negative integer n. if n == 0: return 0 count = 0 while n & 1 == 0: n >>= 1 count += 1 return count"},{"question":"# Word Search with Wildcards Using Trie Data Structure You are to implement a WordDictionary class using a Trie data structure, which supports two primary operations: adding words and searching for words with optional wildcards. Function Requirements 1. **add_word(word: str) -> None** - Adds a word into the data structure. 2. **search(word: str) -> bool** - Searches for the word in the data structure using \'.\' as a wildcard character that can match any single letter. Input and Output 1. **add_word(word: str) -> None** - Input: A string `word` containing only lowercase letters (1 <= len(word) <= 100). - Output: None 2. **search(word: str) -> bool** - Input: A string `word` containing only lowercase letters and \'.\' characters (1 <= len(word) <= 100). - Output: A boolean value `True` if the word can be found in the data structure, else `False`. Constraints 1. All inputs are case-insensitive and contain only lowercase letters. 2. The \'.\' character can be used to represent any single letter. 3. The number of add_word and search operations will not exceed 10^4. # Example ```python dictionary = WordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") print(dictionary.search(\\"pad\\")) # Output: False print(dictionary.search(\\"bad\\")) # Output: True print(dictionary.search(\\".ad\\")) # Output: True print(dictionary.search(\\"b..\\")) # Output: True print(dictionary.search(\\"..d\\")) # Output: True print(dictionary.search(\\"b...\\")) # Output: False ``` You need to implement the given class and its methods to satisfy the constraints and requirements mentioned above.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(word, 0, self.root) def _search_recursive(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, index + 1, child): return True else: if char in node.children: return self._search_recursive(word, index + 1, node.children[char]) else: return False return False"},{"question":"You are given a set of words to be stored in a data structure that allows for efficient word search and prefix-based search. Implement a Trie data structure with the following functionalities: 1. `insert(word)`: Inserts a word into the Trie. 2. `search(word)`: Returns `True` if the word is in the Trie, `False` otherwise. 3. `starts_with(prefix)`: Returns `True` if there is any word in the Trie that starts with the given prefix, `False` otherwise. # Input and Output Formats - `insert(word)`: - **Input**: A string `word` consisting of lowercase letters (`1 <= len(word) <= 100`). - **Output**: None - `search(word)`: - **Input**: A string `word` consisting of lowercase letters (`1 <= len(word) <= 100`). - **Output**: A boolean indicating if the word is present in the Trie. - `starts_with(prefix)`: - **Input**: A string `prefix` consisting of lowercase letters (`1 <= len(prefix) <= 100`). - **Output**: A boolean indicating if there is any word in the Trie that starts with the given prefix. # Constraints - All inputs consist of lowercase letters `a-z`. - The functions should run efficiently even with a large number of words and prefixes. # Example ```python # Initializes the trie trie = Trie() # Insert words into the trie trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apt\\") trie.insert(\\"bat\\") # Search for words assert trie.search(\\"apple\\") == True assert trie.search(\\"app\\") == True assert trie.search(\\"apt\\") == True assert trie.search(\\"bat\\") == True assert trie.search(\\"batman\\") == False # Check for prefixes assert trie.starts_with(\\"app\\") == True assert trie.starts_with(\\"bat\\") == True assert trie.starts_with(\\"bats\\") == False assert trie.starts_with(\\"cat\\") == False ``` # Implementation Implement your solution in Python. ```python import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word): current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def starts_with(self, prefix): current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True ``` Implement these methods in the `Trie` class to create a fully functional Trie data structure. Test your implementation against the provided examples and edge cases.","solution":"import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word): current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def starts_with(self, prefix): current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True"},{"question":"You are working on a text-analysis tool that helps detect spelling errors and suggests corrections. One fundamental operation required is calculating the edit distance between two words, which will help you determine how similar two words are. Your task is to implement a function `edit_distance(word_a, word_b)` that computes the edit distance between two given words, `word_a` and `word_b`. The function should return the minimum number of operations required to convert `word_a` into `word_b`. The operations allowed are insertion, deletion, or substitution of a single character. # Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: ``` # Input * `word_a`: A non-empty string (1 ≤ |word_a| ≤ 1000) * `word_b`: A non-empty string (1 ≤ |word_b| ≤ 1000) # Output * An integer representing the minimum number of operations required to convert `word_a` into `word_b`. # Constraints * Both `word_a` and `word_b` will only contain lowercase English letters. # Example ```python assert edit_distance(\\"food\\", \\"money\\") == 4 assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"abc\\", \\"yabd\\") == 2 ``` # Notes - The solution should efficiently handle the given constraint on input size (|word_a|, |word_b| ≤ 1000). - You may consider optimizing the space complexity if necessary. - Don\'t forget to handle edge cases such as empty strings or strings consisting of the same characters. # Tips - Start by defining the function prototype and initializing the base cases for the DP table. - Iteratively fill the DP table using the recurrence relation provided. - Finally, return the value at the bottom-right corner of the DP table, which represents the edit distance for the full lengths of `word_a` and `word_b`.","solution":"def edit_distance(word_a: str, word_b: str) -> int: m = len(word_a) n = len(word_b) # Create a table to store results of sub-problems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If word_a is empty, insert all chars of word_b elif j == 0: dp[i][j] = i # If word_b is empty, remove all chars of word_a elif word_a[i-1] == word_b[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"# Anagram Validity Check Objective: Write a function that checks if one string is an anagram of another. Two strings are anagrams if they consist of the same characters with the same frequency. Your solution should efficiently determine this. Function Signature: ```python def is_anagram(s: str, t: str) -> bool: :param s: First input string. :param t: Second input string. :return: True if t is an anagram of s, otherwise False. ``` Input: - `s` (str): A string containing only lowercase alphabets (1 ≤ |s| ≤ 10^5). - `t` (str): A string containing only lowercase alphabets (1 ≤ |t| ≤ 10^5). Output: - Return `True` if `t` is an anagram of `s`, otherwise `False`. Constraints: - The strings contain only lowercase alphabets. - Consider using an efficient data structure for counting character frequency. Scenario: Let\'s consider you are working in a company that processes textual data. To maintain data integrity, you need to validate that certain strings appearing in your database logs are anagrams of secret keywords stored securely. Implementing this function will enable automated checks for such validations. Example: ```python assert(is_anagram(\\"anagram\\", \\"nagaram\\") == True) assert(is_anagram(\\"rat\\", \\"car\\") == False) assert(is_anagram(\\"iceman\\", \\"cinema\\") == True) assert(is_anagram(\\"eleven\\", \\"twelve\\") == False) ``` Hint: Consider using a single dictionary to keep track of character counts, increasing counts for one string and decreasing for the other.","solution":"def is_anagram(s: str, t: str) -> bool: Checks if string t is an anagram of string s. if len(s) != len(t): return False count_s = {} for char in s: if char in count_s: count_s[char] += 1 else: count_s[char] = 1 for char in t: if char in count_s: count_s[char] -= 1 if count_s[char] == 0: del count_s[char] else: return False return len(count_s) == 0"},{"question":"# Scenario: You are given a set of scores from multiple student exams. However, some scores might be negative due to penalties. You want to sort these scores using an efficient counting sort algorithm. Write a function `sort_scores` that takes a list of integers representing the scores and returns a sorted list. # Function Signature: ```python def sort_scores(scores: List[int]) -> List[int]: ``` # Input: - `scores` (List[int]): A list of integers representing the exam scores, which may include negative integers. # Output: - List[int]: A sorted list of scores in non-decreasing order. # Constraints: - The range of scores will not exceed 10^6 in absolute value. - The length of the list `scores` will not exceed 10^5. # Requirements: 1. The function should handle negative scores. 2. Maintain stable sorting properties if scores have equal values. 3. Aim for linear time complexity in most scenarios (O(n + k)). # Example: ```python # Example 1 inputs = [6, -2, 3, 1, 2] print(sort_scores(inputs)) # Output: [-2, 1, 2, 3, 6] # Example 2 inputs = [87, 45, 10, -42, -5, 96, -42, 3] print(sort_scores(inputs)) # Output: [-42, -42, -5, 3, 10, 45, 87, 96] ``` Use the given guidelines to construct the `sort_scores` function demonstrating the correct application of the counting sort algorithm.","solution":"def sort_scores(scores): Sorts a list of scores using the counting sort algorithm, which handles negative numbers as well. if not scores: return [] max_score = max(scores) min_score = min(scores) # Initialize the counting array with zeros count_range = max_score - min_score + 1 count = [0] * count_range # Fill the counting array for score in scores: count[score - min_score] += 1 # Accumulate the counts index = 0 result = [] for i in range(count_range): while count[i] > 0: result.append(i + min_score) count[i] -= 1 return result"},{"question":"# Question: Maximum Depth of Binary Tree You are tasked with writing a function to find the maximum depth of a given binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. # Function Signature: ```python def max_depth(root: TreeNode) -> int: pass ``` # Input: - `root` (TreeNode): The root node of a binary tree. # Output: - Returns an integer indicating the maximum depth of the binary tree. # Constraints: - Node count will not exceed 10^4. - The value of each node is an integer following the constraint `-10^5 <= Node.val <= 10^5`. # Scenario/Context: Your task is to implement the function that calculates the maximum depth of a binary tree. This function must efficiently compute the depth using a BFS approach to ensure both time and space efficiency. # Example: Consider the following binary tree structure: ``` 10 / 12 15 / / 25 30 36 100 ``` Calling `max_depth` on this tree should return `4`, as the longest path from the root to the farthest leaf node (10 -> 12 -> 25 -> 100) includes four nodes. # Additional Information: - Ensure edge cases like empty trees (should return 0) and single node trees are handled correctly. - Optimize memory usage where possible.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 from collections import deque queue = deque([(root, 1)]) # (node, depth) max_depth = 0 while queue: node, depth = queue.popleft() if node: max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"# Question: You are given a graph in an undirected form. Each node in the graph contains a unique label and a list of its neighboring nodes. Implement a function to clone this graph using a Depth-First Search (DFS) algorithm. The graph can be disconnected, so any solution should handle multiple disconnected components. Function Signature: ```python def clone_graph_disconnected(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': pass ``` Input: * An `UndirectedGraphNode` representing the starting node of the graph, or `None` if the graph is empty. Output: * The starting node of the deeply cloned graph. # Constraints: * The graph can contain self-loops (a node with an edge to itself). * Multiple edges between the same pair of nodes can exist. * The number of nodes and edges in the graph is arbitrary. # Requirements: * The algorithm should operate in O(V + E) time complexity. * You may assume the labels of the nodes in the graph are unique integers. # Example: ```python # Representation of the graph: # 0 - 1 # | | # 2 - 3 # Creating the original graph node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node3 = UndirectedGraphNode(3) node0.neighbors = [node1, node2] node1.neighbors = [node0, node3] node2.neighbors = [node0, node3] node3.neighbors = [node1, node2] # Cloning the graph cloned_node = clone_graph_disconnected(node0) # Expected result is a graph that has the same structure as the original one: # 0 - 1 # | | # 2 - 3 assert cloned_node.label == 0 assert len(cloned_node.neighbors) == 2 assert set(n.label for n in cloned_node.neighbors) == {1, 2} ``` # Note: The provided `UndirectedGraphNode` class definition and utility functions (e.g., for adding neighbors) can be considered available during implementation.","solution":"class UndirectedGraphNode: def __init__(self, label:int): self.label = label self.neighbors = [] def clone_graph_disconnected(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None old_to_new = {} def dfs(node): if node in old_to_new: return old_to_new[node] clone = UndirectedGraphNode(node.label) old_to_new[node] = clone for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone nodes = [node] visited = set() # This handles visiting all nodes even in disconnected graph for start_node in nodes: if start_node not in visited: visited.add(start_node) if start_node not in old_to_new: cloned_component = dfs(start_node) nodes.extend(start_node.neighbors) return old_to_new[node]"},{"question":"# Question: Implement a Function to Count Digits Scenario You are building a module for a numerical analysis tool that needs to frequently determine the number of digits in integers. This functionality is crucial for various features like formatting, parsing, and validating numeric data. Task Write a function `count_digits` that calculates and returns the number of digits in a given integer. Requirements * **Input**: A single integer `n` (where -10^9 ≤ n ≤ 10^9). * **Output**: An integer representing the number of digits. Function Signature ```python def count_digits(n: int) -> int: pass ``` Constraints * You must handle all integers within the given range, including negative numbers and zero. * Achieve constant time complexity O(1) using mathematical properties. Example ```python assert count_digits(12345) == 5 assert count_digits(-12345) == 5 assert count_digits(0) == 1 assert count_digits(-1) == 1 assert count_digits(1000000000) == 10 ``` Additional Notes * Use the `math.log10()` function to compute the number of digits. * Ensure your solution is optimized for efficiency and includes edge case handling.","solution":"import math def count_digits(n: int) -> int: Returns the number of digits in the given integer n. if n == 0: return 1 n = abs(n) return math.floor(math.log10(n)) + 1"},{"question":"**Problem Statement**: As a data analyst, you need to identify groups of integer elements from a list that sum up to a specific target value. Your task is to implement an application that employs a generalized n-sum solver. **Function to Implement**: ```python def find_n_sum(n, nums, target, sum_closure=None, compare_closure=None): n: int - The size of the group to form (e.g., pairs, triplets, etc.) nums: list - List of integers to search from. target: int - Target sum value. sum_closure: callable, optional - Function to compute sum of two elements. compare_closure: callable, optional - Function to compare sum with target. Returns: list of lists - All unique n-tuples that sum up to the target. pass ``` **Input/Output**: - **Input**: - `n` (int): The number of elements in each group. - `nums` (list): List of integers. - `target` (int): The target sum value. - `sum_closure` (callable, optional): Function to compute the sum of two elements, defaults to sum of integers. - `compare_closure` (callable, optional): Function to compare computed sum with target, defaults to standard comparison. - **Output**: - A list of unique lists, where each inner list represents an n-tuple sum up to the target. **Constraints**: - 1 <= len(nums) <= 10^3 - -10^6 <= nums[i] <= 10^6 - -10^6 <= target <= 10^6 - The input list may contain duplicate integers. **Example**: ```python find_n_sum(3, [1, 0, -1, 0, -2, 2], 0) # Expected Output: [[-2, 0, 2], [-1, 0, 1]] find_n_sum(2, [2, 7, 11, 15], 9) # Expected Output: [[2, 7]] find_n_sum(4, [1, 0, -1, 0, -2, 2], 0) # Expected Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` **Explanation**: 1. Your implementation should accurately determine and return all unique n-tuples adding up to the `target`. 2. The `sum_closure` function, when provided, should accept two elements from the list and return their sum. 3. The `compare_closure` function, when provided, should take the computed sum and the target, returning `-1`, `0`, or `1` to indicate if the computed sum is less than, equal to, or greater than the target.","solution":"def find_n_sum(n, nums, target, sum_closure=None, compare_closure=None): def two_sum(nums, start, target, result, results): lo, hi = start, len(nums) - 1 while lo < hi: curr_sum = nums[lo] + nums[hi] if curr_sum < target: lo += 1 elif curr_sum > target: hi -= 1 else: results.append(result + [nums[lo], nums[hi]]) lo += 1 hi -= 1 while lo < hi and nums[lo] == nums[lo - 1]: lo += 1 while lo < hi and nums[hi] == nums[hi + 1]: hi -= 1 def k_sum(nums, start, k, target, result, results): if k == 2: two_sum(nums, start, target, result, results) return for i in range(start, len(nums) - k + 1): if i > start and nums[i] == nums[i - 1]: continue k_sum(nums, i + 1, k - 1, target - nums[i], result + [nums[i]], results) nums.sort() results = [] k_sum(nums, 0, n, target, [], results) return results"},{"question":"# Binary Tree Postorder Traversal Context: You are working on a tree data structure and need to perform postorder traversal on a binary tree. You are required to implement a function that returns the postorder traversal of its nodes\' values for both an iterative and a recursive approach. Function Signature: ```python def postorder_iterative(root: Node) -> List[int]: pass def postorder_recursive(root: Node) -> List[int]: pass ``` Input: - The function will receive a `Node` object, which represents the root of a binary tree. - Each node in the tree contains an integer value (`val`) and pointers to its left and right children (`left` and `right`). Output: - The function should return a list of integers representing the postorder traversal of the binary tree. Constraints: - The number of nodes in the tree is between 0 and 1000. - Each node\'s value is a unique integer. Performance Requirements: - Both functions must run with a time complexity of O(n), where n is the number of nodes in the tree. - The space complexity should also be O(n) due to the stack or recursive call overhead. Example: Given the following binary tree: ``` 1 / 2 3 / 4 5 ``` The postorder traversal should return `[4, 5, 2, 3, 1]`. Notes: 1. You can use the provided `Node` class. 2. Ensure you handle edge cases, such as an empty tree or a single node tree. 3. Consider the performance trade-offs between the iterative and recursive implementations. 4. The iterative function should not use any recursive calls and should use a stack instead.","solution":"# Definition for a binary tree node. class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list[int]: Returns the postorder traversal of the binary tree using an iterative approach. if root is None: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] # reverse the output list to get the correct postorder def postorder_recursive(root: Node) -> list[int]: Returns the postorder traversal of the binary tree using a recursive approach. def helper(node): if node: helper(node.left) helper(node.right) result.append(node.val) result = [] helper(root) return result"},{"question":"# Question **Scenario**: You are tasked with implementing an algorithm to help a library manage their books more efficiently by sorting them based on their unique IDs. Given the simple and easy-to-understand nature of Gnome Sort, you decide to utilize it for this purpose. **Task**: Implement the Gnome Sort algorithm for sorting an array of integers. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers, representing the unique IDs of books. Output - A sorted list of integers in non-decreasing order. Constraints - The length of the array `n` will be in the range `[0, 10^4]`. - Each integer in the array will be in the range `[-10^4, 10^4]`. # Requirements - Implement the Gnome Sort algorithm to ensure that the array is sorted in-place. - Avoid using any built-in sorting functions. Example ```python gnome_sort([34, 2, 78, 1, 56]) ``` Expected output: ```python [1, 2, 34, 56, 78] ``` # Hints - Pay attention to handling cases where the list is already sorted or contains only one element. - Ensure your solution efficiently manages the indexing to prevent unnecessary computations.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts the provided list of integers using the Gnome Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list of integers. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"You are provided with a digital map application that needs to calculate the shortest path from a given starting location to all other locations on a map. Implement a function using Dijkstra\'s algorithm for this purpose. The map is represented by a directed, weighted graph. The weights denote the time (in minutes) to travel between locations. # Input 1. An integer `n` representing the number of locations (vertices) in the graph. 2. A 2D list `edges` where each element is a triplet ((u, v, w)) representing a directed edge from location `u` to location `v` with a travel time of `w` minutes. 3. An integer `src` representing the starting location. # Output * A list of integers where the `i`-th element is the shortest travel time from `src` to location `i`. If location `i` is inaccessible from `src`, it should be represented by `float(\\"inf\\")`. # Constraints * (1 le n le 500) * (0 le w le 1000) * (0 le u, v < n) * All nodes are indexed starting from 0. # Example ```python Input: n = 5 edges = [ (0, 1, 10), (1, 2, 10), (2, 3, 10), (3, 4, 10), (0, 4, 25) ] src = 0 Output: [0, 10, 20, 30, 25] ``` # Function Signature ```python def dijkstra_shortest_path(n: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: pass ```","solution":"import heapq from typing import List, Tuple def dijkstra_shortest_path(n: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: Finds the shortest path from src to all other locations using Dijkstra\'s algorithm. :param n: Number of locations (vertices) in the graph :param edges: List of edges where each edge is represented as (u, v, w) u is the source vertex, v is the destination vertex, w is the weight of the edge :param src: Starting location (vertex) :return: List of shortest travel times from src to each location, where inaccessible locations are represented by float(\'inf\') # Initialize distances with infinity distances = [float(\'inf\')] * n distances[src] = 0 # Create a priority queue and add the source node with distance 0 priority_queue = [(0, src)] # Adjacency list representation of the graph graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If we find a greater distance in the priority queue, skip it if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Question: **Title**: Converting Integers to Byte Arrays with Configurable Endianness Objective: Write a function `int_to_custom_endian(num, endian=\'big\')` that converts an integer to a byte array of the specified endianness and a function `custom_endian_to_int(bytestr, endian=\'big\')` that converts a byte array back to an integer. Details: - **Function 1**: `int_to_custom_endian(num, endian=\'big\')` - **Input**: - `num` (int): The integer to convert. - `endian` (str): A string either \'big\' or \'little\', indicating the endianness of the output byte array. - **Output**: A byte array representing the integer in the specified endianness. - **Function 2**: `custom_endian_to_int(bytestr, endian=\'big\')` - **Input**: - `bytestr` (bytes or bytearray): The byte array to convert back to an integer. - `endian` (str): A string either \'big\' or \'little\', indicating the endianness of the byte array. - **Output**: An integer represented by the byte array. Constraints and Performance Requirements: - Assume `0 <= num <= 2**64 - 1` for integer values. - The allowed `endian` values are strictly \'big\' and \'little\'. - Your implementation should be efficient in terms of both time and space complexity. Example Usage: ```python # Example 1 print(int_to_custom_endian(305419896, \'big\')) # > b\'x12x34x56x78\' print(custom_endian_to_int(b\'x12x34x56x78\', \'big\')) # > 305419896 # Example 2 print(int_to_custom_endian(305419896, \'little\')) # > b\'xV4x12\' print(custom_endian_to_int(b\'xV4x12\', \'little\')) # > 305419896 ``` Hints: - Use bitwise operations to break down the integer into its bytes. - Pay attention to how bytes should be ordered based on the specified endianness. - Consider edge cases like very small or very large numbers and empty byte arrays.","solution":"def int_to_custom_endian(num, endian=\'big\'): Converts an integer to a byte array of the specified endianness. Parameters: - num (int): The integer to convert. - endian (str): A string either \'big\' or \'little\', indicating the endianness of the output byte array. Returns: - bytes: A byte array representing the integer in the specified endianness. byte_length = (num.bit_length() + 7) // 8 # Calculate the number of bytes needed return num.to_bytes(byte_length, endian) def custom_endian_to_int(bytestr, endian=\'big\'): Converts a byte array back to an integer of the specified endianness. Parameters: - bytestr (bytes or bytearray): The byte array to convert back to an integer. - endian (str): A string either \'big\' or \'little\', indicating the endianness of the byte array. Returns: - int: An integer represented by the byte array. return int.from_bytes(bytestr, endian)"},{"question":"# In-order Tree Traversal with Alternatives Your task is to implement two versions of in-order traversal for a binary tree: an iterative version and a recursive version. Both methods should return the in-order traversal of the binary tree as a list of node values. Input * A binary tree represented by its root node. Output * A list of integers representing the in-order traversal of the tree. Constraints * The binary tree can have up to 10,000 nodes. Example Given a binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` The in-order traversal of this tree is `[25, 50, 75, 100, 125, 150, 175]`. Function Signatures ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> List[int]: pass def inorder_recursive(root: Node) -> List[int]: pass ``` Requirements * Implement `inorder_iterative(root: Node) -> List[int]` which performs an iterative in-order traversal. * Implement `inorder_recursive(root: Node) -> List[int]` which performs a recursive in-order traversal. Notes * Consider the edge case where the tree is empty (i.e., `root = None`). The functions should return an empty list. * Write optimal solutions that handle the constraints efficiently.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list: result, stack = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> list: def helper(node, res): if node: helper(node.left, res) res.append(node.val) helper(node.right, res) result = [] helper(root, result) return result"},{"question":"# Gnome Sort Implementation Challenge You are tasked with implementing the Gnome Sort algorithm to sort a list of integers. The Gnome Sort algorithm is a simple sorting algorithm that iterates through the list and whenever an element is found out of order compared to its previous element, it swaps them and moves back one step. This ensures that the smaller elements \\"bubble\\" up while larger elements \\"sink\\" down to their correct positions. **Function Signature** ```python def gnome_sort(arr: list[int]) -> list[int]: ``` **Input** - `arr`: A list of integers which can contain both positive and negative numbers. **Output** - Return a list of integers sorted in non-decreasing order. **Constraints** - The list can be of any length, including zero. - The list can contain both positive and negative integers, as well as duplicates. **Performance Requirements** - The implementation should work efficiently even for edge cases like an already sorted array or an array with identical elements. **Example** ```python assert gnome_sort([3, 2, 1]) == [1, 2, 3] assert gnome_sort([4, 1, 3, 2]) == [1, 2, 3, 4] assert gnome_sort([7, -5, 3, 4, -8]) == [-8, -5, 3, 4, 7] assert gnome_sort([]) == [] assert gnome_sort([5, 5, 5, 5]) == [5, 5, 5, 5] assert gnome_sort([1]) == [1] ``` **Note** - Pay special attention to edge cases. - Ensure the implementation adheres to the Gnome Sort algorithm principles.","solution":"def gnome_sort(arr: list[int]) -> list[int]: index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"You are given a sorted array of integers in increasing order and a target number. Your task is to implement a function `last_occurrence` that finds the last occurrence of the target number in the sorted array. If the target number does not exist in the array, the function should return -1. Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: pass ``` Input - `array` : A list of integers sorted in increasing order. `1 <= len(array) <= 10^5` and `-10^6 <= array[i] <= 10^6`. - `query` : An integer where `-10^6 <= query <= 10^6`. Output - The index (0-based) of the last occurrence of the `query` in the `array`. If the `query` is not in the array, return -1. Example 1. **Input**: `array = [1, 2, 2, 2, 3, 4, 5]`, `query = 2` **Output**: `3` 2. **Input**: `array = [1, 3, 5, 7, 9]`, `query = 5` **Output**: `2` 3. **Input**: `array = [1, 2, 2, 2, 3, 4, 5]`, `query = 6` **Output**: `-1` Constraints - You must implement a binary search to maintain O(log n) time complexity. - Consider edge cases such as empty arrays, single-element arrays, and elements that are not present in the array. Notes - Ensure your code handles all possible edge cases. - Avoid any unnecessary use of additional data structures to ensure space efficiency.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Function to find the last occurrence of the target number in a sorted array. If the target number does not exist in the array, return -1. left, right = 0, len(array) - 1 last_occ = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: last_occ = mid left = mid + 1 # continue to search in the right half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return last_occ"},{"question":"# Question: Detect Strongly Connected Components in a Programming Dependency Graph You are tasked with analyzing a programming dependency graph using Tarjan\'s algorithm. The goal is to find all strongly connected components (SCCs) in the provided graph, which represents programming modules and their dependencies. # Background A software project contains various modules where some modules depend on others. Such dependencies can be modeled using a directed graph. Your task is to find all SCCs in this graph. An SCC is a maximal subgraph where each module can reach every other module within the same subgraph directly or indirectly. # Task Implement the `find_sccs` function using Tarjan\'s algorithm to detect all SCCs in the directed graph. # Input * `graph_dict`: A dictionary where each key-value pair represents a module and its list of dependent modules. For example: ```python { \'A\': [\'B\'], \'B\': [\'C\', \'E\'], \'C\': [\'D\'], \'D\': [\'B\'], \'E\': [\'F\'], \'F\': [] } ``` # Output A list of lists where each sublist contains modules forming a strongly connected component. Each SCC should be sorted in lexicographical order. The list of SCCs does not need to be in any specific order. # Constraints * Each module is represented as a unique string identifier. * The graph does not contain duplicate edges and does not have self-loops. # Example **Input**: ```python graph_dict = { \'A\': [\'B\'], \'B\': [\'C\', \'E\'], \'C\': [\'D\'], \'D\': [\'B\'], \'E\': [\'F\'], \'F\': [] } ``` **Output**: ```python [[\'A\'], [\'B\', \'C\', \'D\'], [\'E\'], [\'F\']] ``` # Implementation Note The function signature should be: ```python def find_sccs(graph_dict): # Your code here ``` **Performance Requirement**: The solution should run in linear time relative to the size of the graph (O(V + E)).","solution":"def find_sccs(graph_dict): Find and return the list of strongly connected components in the graph using Tarjan\'s algorithm. index = 0 stack = [] indices = {} lowlink = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph_dict[node]: if neighbor not in indices: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: lowlink[node] = min(lowlink[node], indices[neighbor]) if lowlink[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph_dict: if node not in indices: strongconnect(node) return sccs"},{"question":"You are tasked with identifying numbers in a given range that satisfy a special property. Specifically, you are to find numbers such that when each of their digits is raised to a consecutive power starting from 1, and the results are summed, the sum equals the original number. For example, 89 is such a number because 8^1 + 9^2 = 8 + 81 = 89. # Function Specification Write a function `find_special_numbers(low, high)` that takes two integers, `low` and `high`, and returns a list of all numbers between `low` and `high` (inclusive) which meet the described condition. Input * An integer `low` (1 ≤ low ≤ 10^5) representing the lower bound of the range. * An integer `high` (low ≤ high ≤ 10^5) representing the upper bound of the range. Output * A list of integers with the special property described above, sorted in ascending order. Constraints * Both `low` and `high` are positive integers within the range mentioned. # Example Usage 1. `find_special_numbers(1, 10)` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9]`. 2. `find_special_numbers(1, 100)` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]`. # Additional Notes * Ensure that your function handles edge cases efficiently. * Aim for readable and optimal code. * Provide a few test cases to demonstrate the correctness and efficiency of your implementation.","solution":"def find_special_numbers(low, high): def is_special_number(num): digits = [int(d) for d in str(num)] total_sum = sum(digit ** (i + 1) for i, digit in enumerate(digits)) return total_sum == num return [num for num in range(low, high + 1) if is_special_number(num)]"},{"question":"# Question: Implement Range Query for Red-Black Tree You are provided with the implementation of a Red-Black Tree data structure. Your task is to add a method to perform a range query on this Red-Black Tree. A range query finds and returns all the node values that lie within a given range `[low, high]`. Function Specification - **Function Name**: `range_query` - **Parameters**: - `self`: Reference to the instance of the Red-Black Tree. - `low` (int): The lower bound of the range. - `high` (int): The upper bound of the range. - **Output**: List of node values (int) that lie within the range `[low, high]` inclusive. - **Constraints**: - Assume that the tree does not contain duplicate values. - The values of `low` and `high` will always be such that `low <= high`. Example ```python # Given the Red-Black Tree with the following inserted nodes: rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) # Calling the range_query method result = rb.range_query(5, 14) print(result) # Output should be [5, 7, 8, 11, 14] (The order does not matter) ``` Ensure your implementation respects the following: 1. Efficient traversal of the tree to minimize unnecessary comparisons. 2. Correct handling of edge cases such as empty tree or range values that do not match any node. 3. Maintaining the integrity of the tree during the query process.","solution":"class Node: def __init__(self, data, color=\\"RED\\"): self.data = data self.color = color self.parent = None self.left = None self.right = None class RBTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = \\"BLACK\\" self.root = self.TNULL def insert(self, key): node = Node(key) node.parent = None node.data = key node.left = self.TNULL node.right = self.TNULL node.color = \\"RED\\" y = None x = self.root while x != self.TNULL: y = x if node.data < x.data: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.data < y.data: y.left = node else: y.right = node if node.parent == None: node.color = \\"BLACK\\" return if node.parent.parent == None: return self.fix_insert(node) def fix_insert(self, k): while k.parent.color == \\"RED\\": if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == \\"RED\\": u.color = \\"BLACK\\" k.parent.color = \\"BLACK\\" k.parent.parent.color = \\"RED\\" k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \\"BLACK\\" k.parent.parent.color = \\"RED\\" self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == \\"RED\\": u.color = \\"BLACK\\" k.parent.color = \\"BLACK\\" k.parent.parent.color = \\"RED\\" k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \\"BLACK\\" k.parent.parent.color = \\"RED\\" self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = \\"BLACK\\" def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def range_query(self, low, high): result = [] self._range_query_helper(self.root, low, high, result) return result def _range_query_helper(self, node, low, high, result): if node == self.TNULL: return if low < node.data: self._range_query_helper(node.left, low, high, result) if low <= node.data <= high: result.append(node.data) if high > node.data: self._range_query_helper(node.right, low, high, result)"},{"question":"# Question: Maximum Depth of Binary Tree Given a binary tree, implement a function to find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Function Signature ```python def max_height(root: TreeNode) -> int: pass ``` Input - `root` is the TreeNode representing the root of the binary tree. Output - Return an integer representing the maximum depth of the binary tree. # Constraints - The number of nodes in the tree is in the range [0, 10,000]. - The node values are all unique integers. - The depth of the binary tree will not exceed 10,000. # Example ```python # Example Binary Tree # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(max_height(root)) # Output: 3 ``` # Notes - Consider edge cases like an empty tree or a highly skewed tree. - Utilize both recursive and iterative methods to calculate the height. - Ensure your function is optimized for both time and space constraints. Scenario Imagine you are working on a project where you need to dynamically calculate the depth of nested commenting structures (represented as binary trees) within a forum. This function will help determine the depth to understand discussion depth dynamics.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_height(root: TreeNode) -> int: Returns the maximum depth of the binary tree. :param root: TreeNode, the root of the binary tree. :return: int, the maximum depth of the binary tree. if not root: return 0 else: left_depth = max_height(root.left) right_depth = max_height(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Scenario You have been hired to optimize a shopping cart module for an e-commerce website. The shopping cart should support quick lookups, item insertions, and maintaining the collection in sorted order by item ID. Given that you have prior experience with Binary Search Trees (BST), you decide to implement a BST to handle the operations efficiently. Implement the modified version of a BST with the following additional functionalities: 1. **Insert**: Insert an item ID into the BST. 2. **Search**: Search for an item ID in the BST. 3. **Size**: Get the number of items in the BST. 4. **Traversal**: Return the item IDs in Preorder, Inorder, and Postorder sequences. 5. **Find Min and Max**: Return the minimum and maximum item IDs in the BST. # Requirements * Expected Input and Output Formats: - **Insert**: (item_id: int) -> None - **Search**: (item_id: int) -> bool - **Size**: () -> int - **Traversal**: - (order: str) -> List[int] (order can be \'preorder\', \'inorder\', \'postorder\') - **Find Min**: () -> int - **Find Max**: () -> int * Constraints: - Item IDs are integers (consider positive and reasonable range, e.g., within 32-bit signed integer). - Assume no duplicate item IDs are inserted. * Performance Requirements: - Ensure efficient execution for the given operations. ```python class Node: def __init__(self, data): self.data = data self.left = None self.right = None class ModifiedBST: def __init__(self): self.root = None # Implement the functions as described def insert(self, item_id: int) -> None: pass def search(self, item_id: int) -> bool: pass def size(self) -> int: pass def traversal(self, order: str) -> List[int]: pass def find_min(self) -> int: pass def find_max(self) -> int: pass # Include function definitions and necessary private helper methods. # Ensure you provide test cases demonstrating the functionality. ``` # Testing * Ensure you write test cases to verify: - Item insertion. - Searching existing and non-existing items. - Correct traversal orders. - Correct calculation of tree size. - Proper functioning of finding minimum and maximum item IDs.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class ModifiedBST: def __init__(self): self.root = None self._size = 0 def insert(self, item_id: int) -> None: if not self.root: self.root = Node(item_id) else: self._insert_recursive(self.root, item_id) self._size += 1 def _insert_recursive(self, node, item_id): if item_id < node.data: if node.left: self._insert_recursive(node.left, item_id) else: node.left = Node(item_id) else: if node.right: self._insert_recursive(node.right, item_id) else: node.right = Node(item_id) def search(self, item_id: int) -> bool: return self._search_recursive(self.root, item_id) def _search_recursive(self, node, item_id): if not node: return False if node.data == item_id: return True elif item_id < node.data: return self._search_recursive(node.left, item_id) else: return self._search_recursive(node.right, item_id) def size(self) -> int: return self._size def traversal(self, order: str) -> list: if order == \'preorder\': return self._preorder_traversal(self.root, []) elif order == \'inorder\': return self._inorder_traversal(self.root, []) elif order == \'postorder\': return self._postorder_traversal(self.root, []) else: raise ValueError(\\"Traversal order must be \'preorder\', \'inorder\', or \'postorder\'\\") def _preorder_traversal(self, node, result): if node: result.append(node.data) self._preorder_traversal(node.left, result) self._preorder_traversal(node.right, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.data) self._inorder_traversal(node.right, result) return result def _postorder_traversal(self, node, result): if node: self._postorder_traversal(node.left, result) self._postorder_traversal(node.right, result) result.append(node.data) return result def find_min(self) -> int: if not self.root: raise ValueError(\\"BST is empty\\") current = self.root while current.left: current = current.left return current.data def find_max(self) -> int: if not self.root: raise ValueError(\\"BST is empty\\") current = self.root while current.right: current = current.right return current.data"},{"question":"# Binary Tree to Doubly Linked List Conversion Scenario You are given a binary tree and tasked with converting it into a sorted doubly linked list. The nodes in the doubly linked list should be sorted in increasing order. Each node in the doubly linked list should have two pointers: `left` (pointing to the previous node) and `right` (pointing to the next node). The conversion should be performed in-place, meaning you cannot create new nodes for the linked list. Function Signature ```python from tree.tree import TreeNode def bin_tree_to_list(root: TreeNode) -> TreeNode: # Your implementation here ``` Input * `root` : TreeNode : The root of the binary tree. Output * TreeNode : The head of the sorted doubly linked list. Constraints * The input tree can contain between 0 and 100,000 nodes. * Node values are unique and will fit within standard integer ranges (-2<sup>31</sup> to 2<sup>31</sup>-1). Example Consider the following binary tree: ``` 4 / 2 5 / 1 3 ``` The corresponding sorted doubly linked list should be: ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Performance Requirements * The solution must run in O(n) time complexity, where n is the number of nodes in the tree. * The solution must use O(h) space complexity for the recursive stack, where h is the height of the tree. Guidelines 1. Traverse the binary tree using in-order traversal. 2. Convert the binary tree to a doubly linked list in-place. 3. Return the head of the doubly linked list. You are expected to handle edge cases properly and ensure that the doubly linked list does not contain any cycles.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None def in_order_traversal(node): nonlocal last, head if not node: return # Traverse left subtree in_order_traversal(node.left) # Process current node if last: last.right = node node.left = last else: head = node last = node # Traverse right subtree in_order_traversal(node.right) last, head = None, None in_order_traversal(root) return head"},{"question":"# Context You are working on a software application that involves encryption, which requires frequent prime number validation. The efficiency and correctness of your prime checking function are crucial for the security and performance of the system. # Task Write a function `enhanced_prime_check(n: int) -> bool` that checks if a given number `n` is prime. This function should be optimized for performance, especially for large values of `n`. Additionally, the function should be capable of handling edge cases effectively. # Requirements 1. **Input Format**: - A single integer `n` where 1 <= n <= 10**12. 2. **Output Format**: - Return `True` if `n` is a prime number. - Return `False` otherwise. 3. **Constraints**: - The function must handle large values efficiently. - Consider edge cases in your implementation. 4. **Performance Requirements**: - Aim for an average case time complexity of O(√n) or better. # Example ```python assert enhanced_prime_check(1) == False assert enhanced_prime_check(2) == True assert enhanced_prime_check(17) == True assert enhanced_prime_check(18) == False assert enhanced_prime_check(982451653) == True # Large prime ``` # Additional Notes - Consider additional optimizations or alternative algorithms to handle very large numbers within practical limits.","solution":"def enhanced_prime_check(n: int) -> bool: Check if the given number `n` is prime. A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Missing Number Finder You are provided with a sequence of unique integers ranging from 0 to n, where one number is missing. The difference between consecutive integers in the sequence cannot be more than 1. Your task is to implement a function to find the missing number. If the sequence contains all numbers from 0 to n, your function should return the next integer, `n+1`. Function Signature ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Input - `nums`: A list of unique integers in the range `[0, n]`. - Minimum length (`len(nums)`): 1 - Maximum length (`len(nums)`): 10^5 # Output - An integer representing the missing number in the sequence, or `n+1` if the sequence is complete. # Constraints - The input list will always contain unique integers. - The integers in `nums` will only be in the inclusive range `[0, n]`. - The list will be shuffled. # Example 1. **Input**: [4, 1, 3, 0, 6, 5, 2] **Output**: 7 2. **Input**: [0, 1, 2, 3, 4, 5, 6] **Output**: 7 # Explanation 1. In the example `[4, 1, 3, 0, 6, 5, 2]`, the integers from 0 to 6 are present, thus the missing number is 7. 2. In `[0, 1, 2, 3, 4, 5, 6]`, all numbers from 0 to 6 are present, so the function should return the next integer, 7.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number in a sequence that should contain integers from 0 to n. If the sequence contains all numbers from 0 to n, returns n + 1. n = len(nums) total_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = total_sum - actual_sum return missing_number"},{"question":"# Base Conversion Extension You have been given two functions, `int_to_base` and `base_to_int`, that are responsible for converting integers to their string representations in a given base and converting strings in a given base back to integers, respectively. Your task is to extend and optimize these functions to handle two additional requirements: 1. **Hexadecimal Case Insensitivity**: Modify the `base_to_int` function to handle both uppercase and lowercase hexadecimal digits (`A-F` and `a-f`). Ensure that the function can accurately convert both uppercase and lowercase inputs for any base. 2. **Base Range Validations & Error Handling**: Enhance both functions to include proper error handling. Ensure the following: * Raise a `ValueError` if the base is outside the range [2, 36]. * Raise a `ValueError` if `int_to_base` is provided a negative number and the base is not 10. Input & Output Formats **Function 1: int_to_base** * **Input**: * `num` (int): an integer to convert. Can be negative, zero, or positive. * `base` (int): the base for conversion. Valid bases are integers between 2 and 36. * **Output**: * A string representing the number in the specified base. **Function 2: base_to_int** * **Input**: * `str_to_convert` (str): string representation of a number in a given base. * `base` (int): the base of the string representation. Valid bases are integers between 2 and 36. * **Output**: * An integer that corresponds to the string representation in the given base. # Example ```python # Example 1 int_to_base(255, 16) -> \'FF\' base_to_int(\'ff\', 16) -> 255 # Example 2 int_to_base(-10, 10) -> \'-10\' int_to_base(-10, 2) -> ValueError: \'Negative numbers can only be converted in base 10.\' # Example 3 base_to_int(\'10\', 2) -> 2 base_to_int(\'10\', 1) -> ValueError: \'Base must be between 2 and 36\' ``` # Constraints * You must not use Python\'s built-in `int` or `str` functions for the conversions. * The inputs will always be valid integers or strings that can be converted, respecting the respective base. Good luck, and remember to handle edge cases and invalid inputs gracefully!","solution":"def int_to_base(num, base): Converts an integer to a string representation in a specified base. if base < 2 or base > 36: raise ValueError(\'Base must be between 2 and 36\') if num < 0 and base != 10: raise ValueError(\'Negative numbers can only be converted in base 10.\') digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" if num == 0: return \'0\' result = \\"\\" is_negative = num < 0 num = abs(num) while num: result = digits[num % base] + result num //= base if is_negative: result = \'-\' + result return result def base_to_int(str_to_convert, base): Converts a string representation of a number in a specified base to an integer. if base < 2 or base > 36: raise ValueError(\'Base must be between 2 and 36\') str_to_convert = str_to_convert.upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" num = 0 for char in str_to_convert: num = num * base + digits.index(char) return num"},{"question":"**Binomial Coefficient Calculator** You are given a function that calculates the binomial coefficient, ( C(n, k) ), using recursion. The binomial coefficient ( C(n, k) ) defines the number of ways to choose ( k ) elements from a set of ( n ) elements without regard to the order of selection. Write a Python function to replace the recursive calculation with an iterative approach to reduce the potential stack overflow issue due to deep recursion and improve efficiency. Input: * Two integers, ( n ) and ( k ), where ( n geq k geq 0 ). Output: * An integer representing ( C(n, k) ), the binomial coefficient. # Constraints: * The implementation should handle large values of ( n ) and ( k ), and be optimized for high performance. * Consider the symmetric property ( C(n, k) = C(n, n-k) ) to reduce redundant computations. # Example: ```python def iterative_binomial_coefficient(n, k): # Your code goes here # Examples and usage: print(iterative_binomial_coefficient(5, 0)) # Output: 1 print(iterative_binomial_coefficient(8, 2)) # Output: 28 print(iterative_binomial_coefficient(500, 300)) # Output: 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Hint: Use the iterative approach starting from the base case, progressively calculating the necessary coefficients up to ( C(n, k) ).","solution":"def iterative_binomial_coefficient(n, k): Calculate the binomial coefficient C(n, k) iteratively. if k > n - k: # Take advantage of symmetry property C(n, k) == C(n, n-k) k = n - k res = 1 for i in range(k): res *= (n - i) res //= (i + 1) return res"},{"question":"# Dijkstra\'s Path Reconstructing Given the class definition for Dijkstra\'s single-source shortest-path algorithm, modify the existing `dijkstra` method such that it not only returns the shortest distances from the source node to all other nodes but also returns the actual shortest path for each node. # Function Signature ```python def dijkstra(self, src: int) -> Tuple[List[float], List[List[int]]]: # your code here ``` # Input - `src` (an integer representing the source vertex) # Output - A tuple containing: - A list of distances where the value at index `i` represents the shortest distance from the source to vertex `i`. - A list of lists where each sub-list represents the shortest path from the source to that particular vertex. # Constraints 1. The graph is represented as a 2D list of size vertex_count x vertex_count where graph[i][j] holds the weight of the edge from vertex `i` to vertex `j`. 2. The weights of all the edges in the graph are non-negative. 3. There are no negative cycles in the graph. # Examples ```python graph = [[0, 2, 0, 1], [2, 0, 3, 2], [0, 3, 0, 1], [1, 2, 1, 0]] d = Dijkstra(4) d.graph = graph assert d.dijkstra(0) == ([0, 2, 2, 1], [[0], [0, 1], [0, 3, 2], [0, 3]]) ``` # Hint Think about how you can keep track of the path while updating the distances.","solution":"import heapq from typing import List, Tuple class Dijkstra: def __init__(self, vertex_count: int): self.vertex_count = vertex_count self.graph = [[0] * vertex_count for _ in range(vertex_count)] def dijkstra(self, src: int) -> Tuple[List[float], List[List[int]]]: distances = [float(\'inf\')] * self.vertex_count distances[src] = 0 priority_queue = [(0, src)] paths = [[] for _ in range(self.vertex_count)] paths[src] = [src] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor in range(self.vertex_count): if self.graph[current_vertex][neighbor] > 0: distance = current_distance + self.graph[current_vertex][neighbor] if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) paths[neighbor] = paths[current_vertex] + [neighbor] return distances, paths"},{"question":"# Question: Tree Structure Pretty Printer Scenario You are given a nested dictionary structure representing a tree. Each key in the dictionary can map to a list of sub-elements, which may include either string values or further nested dictionaries. Your task is to write a function that prints the nested dictionary in a well-formatted manner. Function Signature ```python def pretty_print_tree(tree): # Your implementation here ``` Expected Input and Output * **Input**: A dictionary where keys are strings and values are lists containing strings or further dictionaries. * **Output**: None. Print the tree structure directly to the console. Example ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', {\'Accessory\': [\'Mouse\'], \'Screen\': [\'19 inch\']}], \'c\': [\'Charlie\', \'Sports\', 3], \'d\': [\'David\', \'Computer\', 3] } pretty_print_tree(tree) ``` Should output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> Accessory -> Mouse Screen -> 19 inch c -> Charlie -> Sports -> 3 d -> David -> Computer -> 3 ``` Constraints * The dictionary will have a maximum of 100 keys. * Each value list can contain between 1 to 10 sub-elements. * Sub-elements can be either strings, integers, or nested dictionaries. # Requirements * You are required to handle both strings and nested dictionaries within the same list. * You must ensure proper indentation for nested dictionaries. * Your solution should be efficient and avoid multiple lookups of the same element within loops.","solution":"def pretty_print_tree(tree, indent=\\"\\"): Prints the nested dictionary structure in a well-formatted tree manner. for key, values in tree.items(): print(f\\"{indent}{key} -> {\', \'.join([str(v) for v in values if not isinstance(v, dict)])}\\") for value in values: if isinstance(value, dict): pretty_print_tree(value, indent + \\" \\") # Testing the function with the example provided if __name__ == \\"__main__\\": tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', {\'Accessory\': [\'Mouse\'], \'Screen\': [\'19 inch\']}], \'c\': [\'Charlie\', \'Sports\', 3], \'d\': [\'David\', \'Computer\', 3] } pretty_print_tree(tree)"},{"question":"# Coding Challenge: Power Set Generation You are tasked with generating all possible subsets (the power set) of a given set of distinct integers. The solution should be efficient and handle edge cases gracefully. Function Signature ```python def generate_power_set(nums: List[int]) -> List[List[int]]: pass ``` Input * A list of distinct integers `nums` with `0 <= len(nums) <= 15`. Output * A list containing all possible subsets of `nums`. * Each subset should be represented as a list of integers. Constraints * The solution set must not contain duplicate subsets. * Subsets can be returned in any order. Examples 1. **Example 1**: * Input: `nums = [1, 2, 3]` * Output: `[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]` 2. **Example 2**: * Input: `nums = [0]` * Output: `[[], [0]]` 3. **Example 3**: * Input: `nums = []` * Output: `[[]]` Requirements 1. Implement the function using either the backtracking approach or the iterative approach, as demonstrated in the initial code snippets. 2. Ensure the function handles edge cases such as an empty input set and single-element sets. Good luck!","solution":"from typing import List def generate_power_set(nums: List[int]) -> List[List[int]]: Generates all possible subsets (the power set) of a given list of distinct integers. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list containing all possible subsets of nums. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"# Scenario You are a software engineer tasked with developing a tool for processing sentences in a manner that they need to reverse the order of the words in the sentence. However, the tool also requires the ability to efficiently handle large texts and various edge cases. # Task Implement a Python function `reverse_words_in_sentence(sentence: str) -> str` that reverses the order of words in a given sentence, preserving the spaces between words. # Input - A single string `sentence` containing words separated by spaces. - The sentence can contain multiple spaces between words and leading/trailing spaces. # Output - A single string where the order of words is reversed, and only a single space separates the original words regardless of their initial spacing. - No leading or trailing spaces should be present in the output. # Constraints - The input string length will not exceed 10,000 characters. - Words are separated by spaces and consist of alphabets (both uppercase and lowercase). # Performance Requirements - The solution should be efficient in terms of both time complexity and space complexity. # Examples ```python assert reverse_words_in_sentence(\\" I am keen on cooking \\") == \\"cooking on keen am I\\" assert reverse_words_in_sentence(\\" Hello World \\") == \\"World Hello\\" assert reverse_words_in_sentence(\\"Python is fun\\") == \\"fun is Python\\" ``` # Notes - Consider edge cases where the sentence might have multiple spaces between words or at the ends.","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverses the order of words in a given sentence, preserving a single space between words. Leading and trailing spaces are removed in the process. :param sentence: A string containing words separated by spaces. :return: A string with the words in reverse order and a single space between them. words = sentence.split() reversed_words = words[::-1] return \\" \\".join(reversed_words)"},{"question":"You are given a list of distinct integers. Write a function `generate_permutations` that returns all possible permutations of the list. Your task is to implement this function using an in-place, backtracking approach to minimize space usage. # Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: ``` # Input * `nums` (a list of distinct integers): The input list for which permutations are to be generated. * Constraints: 1 <= len(nums) <= 9 # Output * The function should return a list of lists, where each list represents a permutation of the input list. # Example ```python generate_permutations([1, 2, 3]) ``` Expected Output: ``` [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Challenge Implement this function in a way that avoids creating additional auxiliary data structures proportional to the number of permutations. Aim to use in-place swaps during the permutation generation. # Clarifications * You should not use any in-built functions for permutation generation. * You are encouraged to use backtracking with swapping to achieve the solution.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: def backtrack(start): # If we reach the end of the array, we found a permutation if start == len(nums): result.append(nums[:]) # append a copy for i in range(start, len(nums)): # swap the current element with the element at the current index nums[start], nums[i] = nums[i], nums[start] # recurse on the next part of the list backtrack(start + 1) # backtrack nums[start], nums[i] = nums[i], nums[start] result = [] backtrack(0) return result"},{"question":"Enhanced Search Implementation **Scenario:** You are working in a data science company that deals with large datasets. To efficiently search through the datasets, you need to implement a search algorithm that performs well with uniformly distributed data. Your task is to implement an enhanced version of the interpolation search algorithm that handles extreme edge cases and integrates with binary search for improved performance on non-uniformly distributed data. **Task:** Write a Python function `enhanced_interpolation_search` that takes a sorted list of integers and a search key, and returns the index of the search key if found, otherwise -1. Your implementation should: 1. Handle edge cases efficiently. 2. Use interpolation search for uniform distribution prediction. 3. Fall back to binary search if interpolation predictions are not efficient. **Input:** * `array` (List[int]): A sorted list of integers in non-decreasing order. * `search_key` (int): The integer key to be searched. **Output:** * (int): The index of `search_key` if found, otherwise -1. **Constraints:** * The array length will not exceed 10^6. * The integer values in the array and search key will range between -10^9 and 10^9. **Examples:** ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: # your implementation goes here # Example usage assert enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert enhanced_interpolation_search([], 10) == -1 assert enhanced_interpolation_search([1], 1) == 0 ``` **Requirements:** 1. The function must handle cases with uniform and non-uniform distributions efficiently. 2. Implement interpolation with graceful degradation to binary search. **Tip:** Consider creating a helper function for binary search to integrate within your main function.","solution":"def binary_search(array, search_key, low, high): while low <= high: mid = (low + high) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1 def enhanced_interpolation_search(array, search_key): low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero if array[low] == array[high]: if array[low] == search_key: return low else: break # Probing the position with interpolation formula pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Check if the probing index is out of bounds if pos < low or pos > high: break if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 # Fall back to binary search if not found with interpolation search return binary_search(array, search_key, low, high)"},{"question":"# Linked List De-duplication Objective You are given a singly linked list. Your task is to implement the function `remove_duplicates` in Python that removes all duplicate values from the linked list. Function Signature ```python def remove_duplicates(head: Node) -> None: pass ``` Constraints 1. You are **not allowed** to use any additional storage like hash sets or lists. 2. The solution should be implemented in O(N^2) time complexity and O(1) space complexity. Input * `head`: The head node of the singly linked list. Output * The function should modify the linked list in place and remove any duplicate values. * The original order of the linked list must be preserved. Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None def print_linked_list(head): node = head while node: print(node.val, end=\\" -> \\" if node.next else \\"\\") node = node.next print() # Example 1 a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates(a1) print_linked_list(a1) # Expected Output: \\"A -> B -> C -> D -> F -> G\\" # Example 2 h = Node(\\"H\\") h1 = Node(\\"H\\") h.next = h1 remove_duplicates(h) print_linked_list(h) # Expected Output: \\"H\\" ``` Notes * You need to handle the cases where the linked list may have multiple duplicates. * Ensure that your implementation works for cases of varying list sizes, including the edge cases of empty linked lists and lists where all elements are the same.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> None: if not head: return current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"You are given an undirected graph with `n` nodes and `m` edges. The graph is represented as an adjacency list. Your task is to implement a function that counts the number of connected components in the graph. A connected component is a maximal set of nodes such that there is a path between any two nodes in this set. # Function Signature ```python def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int ``` # Input * `n` (1 ≤ n ≤ 1000): An integer representing the number of nodes. * `edges` (0 ≤ m ≤ 1000): A list of `m` tuples, where each tuple `(u, v)` represents an edge between nodes `u` and `v`. # Output * Returns an integer representing the number of connected components in the graph. # Example Input ```python n = 7 edges = [(1, 2), (2, 4), (4, 5), (5, 6), (3, 7)] ``` # Example Output ```python 2 ``` # Instructions 1. **Create an adjacency list** for the graph based on the given edges. 2. **Implement a depth-first search (DFS)** to traverse the graph and mark nodes as visited. 3. Iterate through each node, and if it hasn’t been visited, initiate a DFS from that node to traverse all reachable nodes, increasing the component count. 4. **Handle edge cases** such as isolated nodes and graphs with no edges properly. 5. **Avoid excessive recursion depth** for large graphs by considering an iterative version of DFS if necessary. # Constraints 1. Nodes are numbered from `1` to `n`. 2. The graph may contain isolated nodes and multiple disconnected components. 3. The solution should be efficient enough to handle the maximum constraints comfortably. # Example Code ```python from typing import List, Tuple # Helper function for DFS def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: adjacency_list = [[] for _ in range(n + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) component_count = 0 for i in range(1, n + 1): if not visited[i]: visited[i] = True dfs(i, visited, adjacency_list) component_count += 1 return component_count ```","solution":"from typing import List, Tuple def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) # Create adjacency list adjacency_list = [[] for _ in range(n + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) component_count = 0 # Iterate through each node to initiate DFS if not visited for i in range(1, n + 1): if not visited[i]: visited[i] = True dfs(i, visited, adjacency_list) component_count += 1 return component_count"},{"question":"# In-Order Successor in BST Problem Description You are given the root of a binary search tree (BST) and a target node within the tree. Your task is to write a function `in_order_successor` that finds the in-order successor of the target node in the BST. The in-order successor of a node in a BST is defined as the smallest node in the BST that has a value greater than the given node. Function Signature ```python def in_order_successor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: ``` Input 1. `root`: The root of the binary search tree (`TreeNode`). 2. `node`: The target node for which the in-order successor needs to be found (`TreeNode`). Output * Return the `TreeNode` that is the in-order successor of the given `node`. * Return `None` if there is no in-order successor. Constraints * The number of nodes in the tree is in the range: [1, 10^4]. * `-10^5 <= Node.val <= 10^5`. * All nodes\' values are unique. * The given node is guaranteed to be in the BST. Example ```plaintext Input: 20 / 10 30 / 5 15 35 Target Node: 15 Output: 20 ``` Note - You must handle edge cases where the target node is the largest in the tree. - Optimize the function assuming a balanced tree for average-case performance, though ensure it works efficiently on skewed trees as well.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def in_order_successor(root: TreeNode, node: TreeNode) -> TreeNode: Finds the in-order successor of a given node in a BST. successor = None current = root while current: if node.val < current.val: successor = current current = current.left else: current = current.right return successor"},{"question":"Josephus Problem Variant You have a group of people standing in a circle, and you need to eliminate every k-th person until only one person remains. Your task is to write a function that simulates this process and returns the elimination sequence followed by the last remaining person\'s position. # Function Signature ```python def josephus_elimination_sequence(n: int, k: int) -> List[int]: pass ``` # Input: * `n` (1 ≤ n ≤ 1000): The number of people standing in a circle, labeled from 1 to n. * `k` (1 ≤ k ≤ n): The fixed step count at which people are eliminated. # Output: * A list of integers representing the elimination sequence followed by the last remaining person\'s position. # Example: ```python assert josephus_elimination_sequence(9, 3) == [3, 6, 9, 4, 8, 5, 2, 7, 1] assert josephus_elimination_sequence(5, 2) == [2, 4, 1, 5, 3] ``` # Additional Constraints: 1. Your solution should have minimal time complexity. 2. Ensure proper handling of indices within the list to simulate the circular behavior. # Notes: * Be mindful of edge cases such as `n = 1` or `k = 1`. * Avoid excessive space usage and ensure your solution can handle up to the maximum constraints efficiently.","solution":"from typing import List def josephus_elimination_sequence(n: int, k: int) -> List[int]: Simulates the Josephus problem and returns the elimination sequence followed by the last remaining person\'s position. :param n: The number of people standing in a circle, labeled from 1 to n. :param k: The fixed step count at which people are eliminated. :return: List of integers representing the elimination sequence followed by the last remaining person\'s position. result = [] people = list(range(1, n + 1)) index = 0 while len(people) > 0: index = (index + k - 1) % len(people) result.append(people.pop(index)) return result"},{"question":"# Question: Implementing Auto-Rehashing Separate Chaining Hash Table **Background**: Given the Separate Chaining Hash Table implementation, you are asked to extend its functionality. The provided implementation does not resize the hash table dynamically, which can impact performance when the number of stored keys increases. **Objective**: Your task is to modify the `SeparateChainingHashTable` to dynamically resize the hash table when a certain load factor is exceeded. This will involve expanding the table size and rehashing all existing entries. # Specifications 1. **Existing Methods**: - You should not modify the behavior of existing methods (`put`, `get`, `del_`, etc.). - You should extend or wrap the necessary methods to incorporate resizing. 2. **New Added Methods**: - Implement a `resize` method that doubles the table size and rehashes all the existing keys. 3. **Dynamic Resizing Trigger**: - Trigger resizing when the load factor (number of entries/table size) exceeds 0.75. 4. **Input and Output**: - The `put(key, value)` method should continue to work as expected, outputting nothing. - The `get(key)` method should return the corresponding value. - Add tests to ensure that after resizing, all existing and new keys can be accessed correctly. # Constraints - Assume keys are always hashable and values can be any type. - Implement appropriate error handling if needed. # Example ```python # initialize the hashtable table = SeparateChainingHashTable(size=4) table.put(\'one\', 1) table.put(\'two\', 2) table.put(\'three\', 3) table.put(\'four\', 4) # After inserting one more element, the table should resize table.put(\'five\', 5) # The above put operation should trigger a resize. # ensure all values are accessible after resizing assert table.get(\'one\') == 1 assert table.get(\'two\') == 2 ... ``` # Implementation Note Use the given `SeparateChainingHashTable` class as a base for your modifications. Create additional helper methods if required.","solution":"class SeparateChainingHashTable: def __init__(self, size=4): self._table = [[] for _ in range(size)] self._size = size self._count = 0 def _hash(self, key): return hash(key) % self._size def _resize(self): old_table = self._table self._size *= 2 self._table = [[] for _ in range(self._size)] self._count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def put(self, key, value): if self._count / self._size > 0.75: self._resize() hashed_key = self._hash(key) for idx, (k, v) in enumerate(self._table[hashed_key]): if k == key: self._table[hashed_key][idx] = (key, value) return self._table[hashed_key].append((key, value)) self._count += 1 def get(self, key): hashed_key = self._hash(key) for k, v in self._table[hashed_key]: if k == key: return v return None def del_(self, key): hashed_key = self._hash(key) for idx, (k, v) in enumerate(self._table[hashed_key]): if k == key: del self._table[hashed_key][idx] self._count -= 1 return True return False"},{"question":"# Flatten Nested Arrays Context You are provided with a nested array, which can be of arbitrary depth. Your task is to write a function that flattens this array into a single, one-dimensional array containing all the elements in the same order as they were encountered in the nested structure. Your task is to implement two functions: 1. `flatten(input_arr: list) -> list`: A function that takes a nested array and returns a flat list. 2. `flatten_iter(iterable: Iterable) -> Iterable`: A generator function that takes a nested iterable and yields elements in a flattened order. Function Signature ```python def flatten(input_arr: list) -> list: # implementation here def flatten_iter(iterable: Iterable) -> Iterable: # implementation here ``` Input 1. `input_arr`: A list that may contain nested lists of arbitrary depth. 2. `iterable`: An iterable object that may contain nested iterables. Output 1. `flatten(input_arr: list) -> list`: A one-dimensional list with all elements from the input array. 2. `flatten_iter(iterable: Iterable) -> Iterable`: A generator that yields each element in a flattened order. Constraints - Elements within the input may be of different types including integers, floats, strings, or other iterables. - The implementation should correctly handle empty arrays and arrays containing only empty sub-arrays. Example For the input `[1, [2, [3, [4, [5]]]], 6]`: - `flatten([1, [2, [3, [4, [5]]]], 6])` should return `[1, 2, 3, 4, 5, 6]`. - `list(flatten_iter([1, [2, [3, [4, [5]]]], 6]))` should yield `[1, 2, 3, 4, 5, 6]`. Edge Cases - Empty list: `flatten([])` should return `[]`. - Nested empty lists: `flatten([[], [[]]])` should return `[]`. Performance Requirements 1. Both functions should handle large input sizes (with multiple levels of nesting) efficiently. 2. Avoid excessive memory use wherever possible.","solution":"def flatten(input_arr): Flattens a nested list into a one-dimensional list. result = [] for element in input_arr: if isinstance(element, list): result.extend(flatten(element)) else: result.append(element) return result def flatten_iter(iterable): Generator function that flattens a nested iterable into a one-dimensional iterable. for element in iterable: if isinstance(element, (list, tuple, set)): yield from flatten_iter(element) else: yield element"},{"question":"# Traversal on Weighted Graphs Context: You\'ve been given an unweighted graph where nodes represent cities and edges represent paths between these cities. You need to find a way to traverse this graph to collect specific information from each city. Two previously learned methods are DFS and BFS. Now, your task is to implement traversal on a weighted graph. Problem: Implement a traversal of a weighted graph similar to DFS and BFS but specifically designed for weighted edges. This new traversal method is called Weighted Depth-First Search (WDFS) and Weighted Breadth-First Search (WBFS). 1. **Weighted Depth-First Search (WDFS)**: - Traverse the graph using a stack but always pick the next node with the smallest edge weight. 2. **Weighted Breadth-First Search (WBFS)**: - Traverse the graph using a queue but always prioritize nodes connected with smaller edge weights on the current level. Include all necessary error handling and edge case considerations. Function Signatures: * Implement the functions `weighted_dfs_traverse(graph, start)` and `weighted_bfs_traverse(graph, start)`. # Input: `graph`: A dictionary where keys are nodes, and values are lists of tuples (neighbor, weight) representing edges and their weights. Example: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'D\', 2)], \'C\': [(\'D\', 3)], \'D\': [] } ``` `start`: A starting node. # Output: A set of visited nodes in the order they were visited. # Constraints: 1. The graph is connected. 2. Weights are non-negative integers. # Example: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'D\', 2)], \'C\': [(\'D\', 3)], \'D\': [] } start = \'A\' print(weighted_dfs_traverse(graph, start)) # Expected Output: {\'A\', \'B\', \'D\', \'C\'} print(weighted_bfs_traverse(graph, start)) # Expected Output: {\'A\', \'B\', \'C\', \'D\'} ```","solution":"def weighted_dfs_traverse(graph, start): Traverse the graph using Weighted Depth-First Search (WDFS). visited = set() stack = [(start, 0)] # (node, weight) while stack: # Sort the stack based on weights and then pop from the end (smallest weight first) stack.sort(key=lambda x: x[1]) node, _ = stack.pop() if node not in visited: visited.add(node) for neighbor, weight in graph[node]: if neighbor not in visited: stack.append((neighbor, weight)) return visited def weighted_bfs_traverse(graph, start): Traverse the graph using Weighted Breadth-First Search (WBFS). from collections import deque visited = set() queue = deque([(start, 0)]) # (node, weight) while queue: # Sort the queue based on weights queue = deque(sorted(queue, key=lambda x: x[1])) node, _ = queue.popleft() if node not in visited: visited.add(node) for neighbor, weight in graph[node]: if neighbor not in visited: queue.append((neighbor, weight)) return visited"},{"question":"# Scenario Given an array of integers, you are required to determine the most frequent value(s) in the array. This is useful in various real-world scenarios like analyzing survey results, detecting common patterns in sensor inputs, or summarizing frequently accessed data points in a database. # Problem Statement Write a function `find_mode` that receives an array of integers and returns a list of integers representing the mode(s) of the array. The mode is defined as the value(s) that appear most frequently in the array. If there are multiple modes, return all of them in any order. # Function Signature ```python def find_mode(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers. The array can be empty or contain duplicate integers. # Output - List[int]: A list of integers that are the mode of the input array. If the array is empty, return an empty list. # Constraints - The length of the array can be up to 10^6. - The integers in the array can range from -10^6 to 10^6. - Your solution should run in O(n) time complexity and use O(n) additional space. # Example ```python # Example 1: input = [1, 1, 2, 2, 3, 4] output = [1, 2] # Example 2: input = [4, 5, 6, 7, 4, 7, 6] output = [4, 6, 7] # Example 3: input = [] output = [] # Example 4: input = [3] output = [3] # Example 5: input = [5, 5, 5, 5, 5] output = [5] ``` # Notes Be sure to handle: - Cases where the array is empty. - Cases where all elements are the same. - Cases with multiple modes.","solution":"from typing import List from collections import Counter def find_mode(arr: List[int]) -> List[int]: Returns the mode(s) of the input array. if not arr: return [] count = Counter(arr) max_count = max(count.values()) return [num for num, freq in count.items() if freq == max_count]"},{"question":"# Context You are part of a software team developing an educational tool that visualizes sorting algorithms. One feature your users have requested is to visualize the Selection Sort algorithm with step-by-step debugging information. # Problem Statement Write a function `visual_selection_sort` that performs the Selection Sort algorithm on a given list of integers and returns the sorted list. The function should also generate and return a list of tuples, where each tuple represents the state of the list after each iteration of the outer loop. # Function Signature ```python def visual_selection_sort(arr: List[int]) -> Tuple[List[int], List[Tuple[int]]]: pass ``` # Input * `arr`: A list of integers to be sorted. # Output * A tuple with two elements: * The sorted list of integers. * A list of tuples where each tuple represents the state of the list after each iteration of the outer loop of the Selection Sort algorithm. # Constraints * The input list will contain at most 1000 integers. * Each integer in the input list will be in the range ([-10^6, 10^6]). # Example ```python arr = [3, 1, 4, 1, 5, 9, 2, 6] sorted_arr, history = visual_selection_sort(arr) print(sorted_arr) # Output: [1, 1, 2, 3, 4, 5, 6, 9] print(history) # Output: # [ # (1, 3, 4, 1, 5, 9, 2, 6), # (1, 1, 4, 3, 5, 9, 2, 6), # (1, 1, 2, 3, 5, 9, 4, 6), # (1, 1, 2, 3, 5, 9, 4, 6), # (1, 1, 2, 3, 4, 9, 5, 6), # (1, 1, 2, 3, 4, 5, 9, 6), # (1, 1, 2, 3, 4, 5, 6, 9) # ] ``` # Notes * The `history` should contain the state of the list after each pass through the outer loop of the selection sort. # Performance Requirements * The function should be efficient enough to handle input lists up to the maximum constraints.","solution":"from typing import List, Tuple def visual_selection_sort(arr: List[int]) -> Tuple[List[int], List[Tuple[int]]]: n = len(arr) history = [] for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] history.append(tuple(arr)) return arr, history"},{"question":"Rabin-Karp Implementation Context You are tasked with implementing an optimized search function for a text editor. The goal is to locate a specific pattern within a larger body of text quickly and efficiently. You are required to apply the Rabin-Karp algorithm for this purpose. This task will assess your understanding of both hashing mechanisms and efficient substring searching. Problem Statement Write a Python function `find_pattern` that implements the Rabin-Karp algorithm to find the first occurrence of a pattern string in a given text string. Your function should return the starting index of the first occurrence of the pattern in the text, or `None` if the pattern is not present. Function Signature ```python def find_pattern(pattern: str, text: str) -> int: # Your code here ``` Parameters - `pattern (str)`: The pattern string to search for. - `text (str)`: The text string in which to search for the pattern. Returns - `int`: The starting index of the first occurrence of the pattern in the text, or `None` if the pattern is not found. Example ```python # Example 1 pattern = \\"abc\\" text = \\"ababcabc\\" print(find_pattern(pattern, text)) # Output: 2 # Example 2 pattern = \\"needle\\" text = \\"haystack\\" print(find_pattern(pattern, text)) # Output: None ``` Constraints - You are encouraged to handle edge cases, such as empty strings and patterns longer than the text. - Consider performance implications for large inputs. Notes - Ensure your implementation uses a rolling hash approach to optimize the matching process. - Be mindful of potential hash collisions and ensure correctness by validating the match directly once a hash collision is detected.","solution":"def find_pattern(pattern: str, text: str) -> int: Implements the Rabin-Karp algorithm to find the first occurrence of \'pattern\' in \'text\'. :param pattern: The pattern string to search for. :param text: The text string in which to search for the pattern. :return: The starting index of the first occurrence of the pattern in the text, or None if the pattern is not found. if not pattern or not text or len(pattern) > len(text): return None base = 256 # Number of characters in the input alphabet prime = 101 # A prime number to use for modulo operation m = len(pattern) n = len(text) pattern_hash = 0 text_hash = 0 h = 1 # The value of h would be \\"pow(base, m-1) % prime\\" for i in range(m - 1): h = (h * base) % prime # Calculate the hash value of pattern and first window of text for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current window of text and pattern if pattern_hash == text_hash: # If the hash values match, then check characters one by one if text[i:i+m] == pattern: return i # Calculate hash value for next window of text: Remove leading digit, add trailing digit if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # We might get negative value of text_hash, converting it to positive if text_hash < 0: text_hash = text_hash + prime return None"},{"question":"# B-Tree Insertion Assessment Question Objective Implement a function `boss_key_inserter` which inserts a list of keys into a B-Tree and checks if the insertion maintains the B-Tree properties. Description You are required to implement a function that: 1. Creates a B-Tree with a given degree (t). 2. Inserts a series of keys into the B-Tree. 3. Checks if all B-Tree properties are maintained after each insertion. Function Signature ```python def boss_key_inserter(t: int, keys: list[int]) -> bool: # Implementation here ``` Input * An integer `t` representing the degree of the B-Tree (2 ≤ t ≤ 10). * A list of integers `keys` representing the keys to insert into the B-Tree (1 ≤ len(keys) ≤ 1000, -10^6 ≤ keys[i] ≤ 10^6). Output * Return a boolean. `True` if all properties of the B-Tree are maintained after all insertions, else `False`. Constraints * All insertions should maintain B-Tree properties: * Every node should have at most `2t-1` keys. * Every non-root node should have at least `t-1` keys. * All leaves appear on the same depth level. * The tree should remain balanced. Example ```python # Example 1 print(boss_key_inserter(3, [10, 20, 30, 40, 50, 60, 70])) # Expected Output: True # Example 2 print(boss_key_inserter(2, [20, 10, 30, 40, 50, 70, 60, 80, 90, 100])) # Expected Output: True ```","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] def is_full(self): return len(self.keys) == 2 * self.t - 1 def split_child(self, i, y): t = y.t z = BTreeNode(t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:(t - 1)] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def insert_non_full(self, k): i = len(self.keys) - 1 if self.leaf: while i >= 0 and k < self.keys[i]: i -= 1 self.keys.insert(i + 1, k) else: while i >= 0 and k < self.keys[i]: i -= 1 i += 1 if self.children[i].is_full(): self.split_child(i, self.children[i]) if k > self.keys[i]: i += 1 self.children[i].insert_non_full(k) class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def insert(self, k): r = self.root if r.is_full(): s = BTreeNode(self.t, False) self.root = s s.children.append(r) s.split_child(0, r) s.insert_non_full(k) else: r.insert_non_full(k) def check_properties(self): return self._check_properties(self.root) def _check_properties(self, node): if not node.leaf: for child in node.children: if len(child.keys) < self.t - 1 or len(child.keys) > 2 * self.t - 1: return False if not self._check_properties(child): return False return True def boss_key_inserter(t, keys): bt = BTree(t) for key in keys: bt.insert(key) if not bt.check_properties(): return False return True"},{"question":"# Bogo Sort Implementation You are given a list of integers that you need to sort using the Bogo Sort algorithm; this algorithm repeatedly shuffles the list until it is sorted. Function Signature ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array using Bogo Sort algorithm. Args: arr (List[int]): A list of integers to sort. simulation (bool): If set to True, prints each shuffle iteration. Returns: List[int]: The sorted list of integers. ``` Input - A list `arr` of integers, where 1 <= len(arr) <= 10, and each integer in the list is between 0 and 1000. - An optional boolean `simulation` that, when `True`, prints the array at each iteration of the shuffle step. Output - The sorted list of integers in ascending order. # Example ```python example = [3, 2, 1] print(bogo_sort(example)) # Output: [1, 2, 3] ``` **Note**: If the `simulation` parameter is set to `True`, the output should also include printed lines of each shuffle iteration. # Constraints & Performance Requirements - Due to its highly inefficient nature, the length of the array `arr` should be kept small. - Ensure the function halts once the list is sorted. **Optimization/Hint**: Although Bogo Sort is purely academic and not meant for actual sorting of large datasets, ensure your solution handles small inputs effectively and includes the provided constraints.","solution":"import random from typing import List def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array using Bogo Sort algorithm. Args: arr (List[int]): A list of integers to sort. simulation (bool): If set to True, prints each shuffle iteration. Returns: List[int]: The sorted list of integers. def is_sorted(arr: List[int]) -> bool: for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True while not is_sorted(arr): if simulation: print(f\\"Shuffling: {arr}\\") random.shuffle(arr) if simulation: print(f\\"Sorted: {arr}\\") return arr"},{"question":"# Search in Rotated Sorted Array **Problem Statement**: You are given an array of integers `nums` that is sorted in ascending order but then rotated at some unknown pivot. Additionally, you are provided a target integer `target`. Your task is to search for the target value in the rotated sorted array and return its index. If the target is not found, return -1. Your algorithm\'s runtime complexity must be in the order of O(log n). **Function Signature**: ```python def search(nums: List[int], target: int) -> int: pass ``` **Input**: - `nums` (List[int]): A rotated sorted array of integers. - `target` (int): The target value to search for. **Output**: - (int): The index of the target in `nums` if present, otherwise -1. **Constraints**: - `1 <= len(nums) <= 10^4` - `-10^4 <= nums[i] <= 10^4` - All values of `nums` are unique. **Examples**: ```python assert search([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert search([4, 5, 6, 7, 0, 1, 2], 3) == -1 assert search([1], 0) == -1 assert search([1], 1) == 0 ``` **Scenario**: In a server where array data sets can be cyclically rote and requested often, you need an efficient solution that can still manage to provide fast lookup times despite the array rotation, to keep search operation optimal and safeguard server response times. **Note**: - Please do not use any existing library functions for search, as the focus here is to implement the search algorithm yourself from scratch. - Provide a solution using both iterative and recursion methods.","solution":"from typing import List def search(nums: List[int], target: int) -> int: A function to search for a target value in a rotated sorted array. Args: nums: List[int] - A rotated sorted array of integers. target: int - The target value to search for. Returns: int - The index of the target in nums if present, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid # If the left side is normally ordered if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # If the right side is normally ordered else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given an undirected graph represented as a list of edges where each edge is a tuple (u, v) representing a connection between vertices u and v. Implement a function `find_cycles` that uses the Union-Find data structure to detect if there\'s a cycle in the graph. A graph contains a cycle if adding an edge connects two vertices that are already in the same set. # Function Signature ```python def find_cycles(edges: List[Tuple[int, int]]) -> bool: pass ``` # Input * List of edges `edges`, where each edge is represented as a tuple `(u, v)`. The vertices are represented as integers. * 1 <= number of edges <= 10^5 * 1 <= u, v <= 10^5 # Output * Return `True` if there is at least one cycle in the graph, `False` otherwise. # Example ```python edges = [(1, 2), (2, 3), (3, 4), (4, 2)] assert find_cycles(edges) == True # This graph contains a cycle: 2 -> 3 -> 4 -> 2 edges = [(1, 2), (2, 3), (3, 4)] assert find_cycles(edges) == False # This graph does not contain any cycles. ``` # Constraints * The implementation should be efficient enough to handle up to 100,000 edges. * The vertices can have values ranging up to 100,000. # Notes Your solution should efficiently utilize the Union-Find data structure with path compression and union by rank for optimal performance.","solution":"def find_cycles(edges): Given an undirected graph represented as a list of edges, detects if there is a cycle in the graph using the Union-Find data structure. def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 parent = {} rank = {} # Initialize parent and rank for each vertex for edge in edges: u, v = edge if u not in parent: parent[u] = u rank[u] = 0 if v not in parent: parent[v] = v rank[v] = 0 # Process each edge for edge in edges: u, v = edge if find(parent, u) == find(parent, v): return True union(parent, rank, u, v) return False"},{"question":"# Task You are to write a function `judge_circle_complete(moves)` that takes a string of moves and returns whether the robot returns to its starting position. However, the function should handle erroneous inputs and provide informative error messages for invalid input characters. # Details: - **Input**: A string `moves` representing the sequence of moves. Each move is represented by one of the characters \'R\' (Right), \'L\' (Left), \'U\' (Up), \'D\' (Down). - **Output**: A boolean value; `True` if the robot returns to the starting point, `False` otherwise. If the input contains invalid characters, raise a `ValueError` with an informative error message. # Constraints: - The input string can be empty or have up to 10^4 characters. - The string can only contain the characters \'R\', \'L\', \'U\', and \'D\'. # Examples: ```python judge_circle_complete(\\"UD\\") # Output: True judge_circle_complete(\\"LL\\") # Output: False judge_circle_complete(\\"RRDDUUL\\") # Output: True judge_circle_complete(\\"RRDD@\\") # Raises ValueError: \\"Invalid character \'@\' in move sequence.\\" judge_circle_complete(\\"\\") # Output: True ``` # Implementation Notes: 1. You will need to count the occurrences of each valid move. 2. Ensure that the counts of opposing moves are equal for the robot to return to the start. 3. Validate the input to make sure it only contains valid move characters.","solution":"def judge_circle_complete(moves): Determines if the robot returns to its initial position after executing a sequence of moves. Parameters: moves (str): A string representing the sequence of moves. Returns: bool: True if the robot returns to its initial position, False otherwise. Raises: ValueError: If an invalid character is found in the move sequence. valid_moves = {\'R\', \'L\', \'U\', \'D\'} position = [0, 0] # [x, y] where x is horizontal movement and y is vertical movement for move in moves: if move not in valid_moves: raise ValueError(f\\"Invalid character \'{move}\' in move sequence.\\") if move == \'R\': position[0] += 1 elif move == \'L\': position[0] -= 1 elif move == \'U\': position[1] += 1 elif move == \'D\': position[1] -= 1 return position == [0, 0]"},{"question":"You are given an array of integers, which we assume are non-negative. Implement the Bucket Sort algorithm to sort this array. You will need to both distribute the integers into buckets and sort the values within each bucket using insertion sort. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: List[int] - a list of non-negative integers. # Output * List[int] - a sorted list of integers. # Constraints * `0 <= len(arr) <= 10^5` * `0 <= arr[i] <= 10^9` for any valid index `i`. # Performance Requirements Your implementation should achieve an average case time complexity of (O(n)) where (n) is the number of elements in the array. # Example ```python input: [3, 6, 8, 2, 5, 10, 15, 1, 14, 9] output: [1, 2, 3, 5, 6, 8, 9, 10, 14, 15] input: [4, 3, 2, 1] output: [1, 2, 3, 4] input: [] output: [] ```","solution":"from typing import List def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr # Determine the number of buckets bucket_size = len(arr) max_val = max(arr) # Create empty buckets buckets = [[] for _ in range(bucket_size)] # Distribute input array values into buckets for i in range(len(arr)): index = int(arr[i] * bucket_size / (max_val + 1)) buckets[index].append(arr[i]) # Sort individual buckets for i in range(bucket_size): buckets[i] = insertion_sort(buckets[i]) # Concatenate buckets to get sorted array sorted_arr = [] for i in range(bucket_size): sorted_arr.extend(buckets[i]) return sorted_arr"},{"question":"You are required to implement a Binary Search Tree (BST), extending it to support some additional functionalities. Given a BST class, implement methods for the following functionalities: `Insert`, `Search`, `Delete` (for deleting a node), and `Level-Order Traversal` (breadth-first traversal). --- **BST Class Requirements**: 1. **Insert**: Inserts a new element into the BST. - **Input**: `BST.insert(data: int)` - **Output**: `None` - **Constraints**: Ensure no duplicates. 2. **Search**: Search for an element in the BST. - **Input**: `BST.search(data: int) -> bool` - **Output**: `True` if element exists, `False` otherwise. 3. **Delete**: Deletes an element from the BST. You need to handle three cases: - Node with only one child or no child. - Node with two children: Use inorder successor. - **Input**: `BST.delete(data: int) -> bool` - **Output**: `True` if deletion successful, `False` if element not found. 4. **Level-Order Traversal**: Print the BST nodes in level order. - **Input**: `BST.level_order() -> List[int]` - **Output**: List of elements in level-order. --- **Assumptions**: - The BST will only contain integer values. - The BST will stay within reasonable size limits for the operational complexity to perform within acceptable time. **Example**: Given the following sequence of operations on an initially empty BST: ```python bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(7) bst.insert(2) bst.insert(12) print(bst.search(7)) # Output: True print(bst.search(5)) # Output: False print(bst.level_order()) # Output: [10, 6, 15, 2, 7, 12] bst.delete(6) print(bst.level_order()) # Output: [10, 7, 15, 2, 12] ``` --- **Constraints**: - No duplicate insertions. - The tree remains a valid BST after each insertion and deletion.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root.val == key: return # BST does not allow duplicate keys elif key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if key < root.val: return self._search(root.left, key) return self._search(root.right, key) def delete(self, key): self.root, deleted = self._delete(self.root, key) return deleted def _delete(self, root, key): if not root: return root, False deleted = False if key < root.val: root.left, deleted = self._delete(root.left, key) elif key > root.val: root.right, deleted = self._delete(root.right, key) else: deleted = True if not root.left: return root.right, deleted elif not root.right: return root.left, deleted min_larger_node = self._get_min(root.right) root.val = min_larger_node.val root.right, _ = self._delete(root.right, min_larger_node.val) return root, deleted def _get_min(self, root): while root.left: root = root.left return root def level_order(self): if not self.root: return [] result = [] queue = [self.root] while queue: current = queue.pop(0) result.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result"},{"question":"# Flip Bit to Win You are given an integer `n` and you can flip exactly one bit from 0 to 1. Your task is to write a function that finds the length of the longest sequence of 1s you can create by flipping exactly one bit. # Task Implement the function `max_consecutive_ones(n: int) -> int` that takes an integer `n` as input and returns the length of the longest sequence of 1s that can be formed by flipping at most one bit from 0 to 1. # Input Format - A single integer `n`, which could be positive or negative. # Output Format - A single integer denoting the length of the longest sequence of 1s. # Constraints - `n` ranges from `-2^31` to `2^31 - 1` (i.e., standard 32-bit signed integer range). - The function should handle both positive and negative numbers correctly. # Example Input ```python n = 1775 ``` Output ```python 8 ``` Input ```python n = -1 ``` Output ```python 32 ``` (Note: In the above input, -1 in 32-bit signed integer representation is a string of 32 ones in binary) # Explanation For the first example, the binary representation of 1775 is 11011101111, and the longest sequence of 1s that can be created by flipping one 0 to 1 is of length 8. For the second example, the binary representation of -1 in a 32-bit system is a sequence of all 1s (32 ones). Hence, the longest sequence of 1s is 32. **Write your function below:** ```python def max_consecutive_ones(n: int) -> int: # Your code goes here ```","solution":"def max_consecutive_ones(n: int) -> int: if n == -1: return 32 # as it represents 111...111 in 32-bit system current_length = 0 previous_length = 0 max_length = 1 # at least we can have one 1 while n != 0: if n & 1 == 1: current_length += 1 else: # Update to compute lengths if the current bit is 0 previous_length = 0 if (n & 2) == 0 else current_length current_length = 0 # Calculate the maximum length by flipping a bit max_length = max(max_length, previous_length + current_length + 1) n >>= 1 return max_length"},{"question":"# String Decoding Problem Context: You\'re tasked with decoding a certain type of encoded message. The encoding follows the rule k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. An encoded_string may contain further nested encoded sequences. Write a function `decode_string(s: str) -> str` that decodes the encoded string described and returns the decoded string. Input: - A single string `s` representing the encoded message. - The string is guaranteed to be well-formed and does not contain any invalid characters or formatting errors. Output: - A single string representing the decoded message. Constraints: - The input string will only contain digits, square brackets, and lowercase letters. - The digits indicate the number of times the following sequence in brackets should be repeated. - There are no extra whitespaces, and all brackets are properly matched. - The input will not contain sequences like \'3a\' or \'2[4]\'. Examples: Example 1: ``` Input: \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" ``` Example 2: ``` Input: \\"3[a2[c]]\\" Output: \\"accaccacc\\" ``` Example 3: ``` Input: \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\" ``` Requirements: - The function should be efficient and work within the constraints provided. - Handle multiple levels of nested encoded sequences.","solution":"def decode_string(s: str) -> str: def decode_inner(index, string): res = \\"\\" while index < len(string): if string[index].isdigit(): k = 0 while string[index].isdigit(): k = k * 10 + int(string[index]) index += 1 index += 1 # Skip \'[\' temp, index = decode_inner(index, string) res += temp * k elif string[index] == \']\': return res, index + 1 else: res += string[index] index += 1 return res, index decoded_string, _ = decode_inner(0, s) return decoded_string"},{"question":"**Matrix Multiplication Problem** You are given two matrices, `multiplicand` and `multiplier`, represented as two-dimensional lists. Your task is to implement a function `multiply` that takes these two input matrices and returns their matrix product. # Function Signature: ```python def multiply(multiplicand: list, multiplier: list) -> list: ``` # Input: - `multiplicand`: A list of lists where each sublist represents a row in the matrix. The matrix has dimensions `m x n`. - `multiplier`: A list of lists where each sublist represents a row in the matrix. The matrix has dimensions `n x p`. # Output: - A list of lists representing the resulting matrix of dimensions `m x p`. # Constraints: - The number of columns in the multiplicand (n) must be equal to the number of rows in the multiplier (n). - Elements in the input matrices are integers. - Matrices can have up to 100 rows and 100 columns. - If the matrices have incompatible dimensions, the function should raise an Exception with a message: \\"Multiplicand matrix not compatible with Multiplier matrix.\\" # Performance Requirements: - The algorithm should run in O(m * n * p) time complexity and use O(m * p) space complexity for the result matrix. # Example: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = multiply(multiplicand, multiplier) print(result) # Expected Output: [[58, 64], [139, 154]] ``` # Explanation: 1. Multiplicand is a 2x3 matrix and Multiplier is a 3x2 matrix. 2. The resulting matrix (product) will be of dimensions 2x2. 3. Each element of the result matrix is calculated as a dot product of rows from multiplicand and columns from multiplier. The function should handle various cases including incompatible matrices and should efficiently compute the result for matrices within the given size constraints.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: # Get the dimensions of the input matrices m = len(multiplicand) # Number of rows in multiplicand n1 = len(multiplicand[0]) if multiplicand else 0 # Number of columns in multiplicand n2 = len(multiplier) # Number of rows in multiplier p = len(multiplier[0]) if multiplier else 0 # Number of columns in multiplier # Check for compatibility if n1 != n2: raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n1): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Priority Queue Implementation You are required to implement a Priority Queue data structure where the insertion operation should have a constant time complexity O(1) and the extract operation should have a logarithmic time complexity O(log n). Therefore, your task is to modify the above implementation of the priority queue using a heap to achieve this performance. To achieve this, you\'ll need to employ the heapq module in Python which provides an implementation of the min-heap. # Function Requirements 1. **Initialization**: - The priority queue should be initialized with optionally provided items and their associated priorities. 2. **Insertion Operation**: - The `push()` method should insert elements into the priority queue in O(1) time. 3. **Extract Min Operation**: - The `pop()` method should remove and return the element with the lowest priority in O(log n) time. # Input - `__init__(self, items=None, priorities=None)`: Initializes the priority queue. - `items`: (Optional) List or iterable of items to be added to the queue. - `priorities`: (Optional) List of priorities corresponding to the items. - `push(self, item, priority)`: Adds an item with the given priority to the priority queue. - `item`: The item to be added to the queue. - `priority`: The priority associated with the item. - `pop(self)`: Removes and returns the item with the lowest priority from the queue. # Output - The `pop` method should return the item with the lowest priority. # Constraints - Items and priorities passed to the initialization and `push` method are not guaranteed to be in any order. - Items and priorities are both positive integers. # Example ```python pq = PriorityQueue([\'task1\', \'task2\', \'task3\'], [2, 1, 3]) print(pq.pop()) # Output: \'task2\' (since it has the highest priority - 1) pq.push(\'task4\', 0) print(pq.pop()) # Output: \'task4\' (since it now has the highest priority - 0) print(pq.pop()) # Output: \'task1\' (next highest priority is 2) ``` # Your Task Implement the `PriorityQueue` class following the above specifications. ```python import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): Initialize the priority queue. self.heap = [] if items and priorities: for item, priority in zip(items, priorities): heapq.heappush(self.heap, (priority, item)) def push(self, item, priority): Insert an item with a given priority. heapq.heappush(self.heap, (priority, item)) def pop(self): Remove and return the item with the lowest priority. if not self.heap: raise IndexError(\\"pop from empty priority queue\\") priority, item = heapq.heappop(self.heap) return item # Example usage: # pq = PriorityQueue([\'task1\', \'task2\', \'task3\'], [2, 1, 3]) # print(pq.pop()) # Output: \'task2\' # pq.push(\'task4\', 0) # print(pq.pop()) # Output: \'task4\' # print(pq.pop()) # Output: \'task1\' ```","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): Initialize the priority queue. self.heap = [] if items and priorities: for item, priority in zip(items, priorities): heapq.heappush(self.heap, (priority, item)) def push(self, item, priority): Insert an item with a given priority. heapq.heappush(self.heap, (priority, item)) def pop(self): Remove and return the item with the lowest priority. if not self.heap: raise IndexError(\\"pop from empty priority queue\\") priority, item = heapq.heappop(self.heap) return item"},{"question":"You are given two strings, `haystack` and `needle`. Write a function `find_first_occurrence(haystack: str, needle: str) -> int` that returns the index of the first occurrence of the substring `needle` in `haystack`, or -1 if `needle` is not a part of `haystack`. The function should adhere to the following criteria: 1. If `needle` is an empty string, return 0. 2. If `needle`\'s length is greater than `haystack`\'s length, return -1. 3. The function should be case-sensitive. # Input - `haystack`: A string of length `n` (1 ≤ `n` ≤ 10^5). - `needle`: A string of length `m` (0 ≤ `m` ≤ 10^4). # Output - Return an integer, the index of the first occurrence of `needle` in `haystack`. - Return -1 if `needle` is not present in `haystack`. # Examples ```python assert find_first_occurrence(\\"hello\\", \\"ll\\") == 2 assert find_first_occurrence(\\"aaaaa\\", \\"bba\\") == -1 assert find_first_occurrence(\\"hello\\", \\"\\") == 0 assert find_first_occurrence(\\"a\\", \\"a\\") == 0 assert find_first_occurrence(\\"mississippi\\", \\"issip\\") == 4 ``` # Constraints - Implement your function making sure that the solution provides a balance between clarity and efficiency. - Time complexity should be thoughtfully considered due to input size constraints. # Additional Notes - You are encouraged to think about more optimized algorithms if the basic approach proves inefficient for large inputs. - Handle edge cases properly as specified in the examples.","solution":"def find_first_occurrence(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not a part of haystack. Parameters: - haystack (str): The string in which to search. - needle (str): The substring to search for. Returns: - int: The index of the first occurrence of needle in haystack, or -1 if not found. if needle == \\"\\": return 0 if len(needle) > len(haystack): return -1 return haystack.find(needle)"},{"question":"# Combination Calculation using Recursion and Memoization You are given functions that calculate the binomial coefficient (nCr), which determines the number of ways to choose r items from n items without regard to order. The code snippets provided demonstrate two methods to achieve this: simple recursion and memoization. Your task is to implement a function that calculates the binomial coefficient using the memoization approach, ensuring optimal efficiency for large values of `n` and `r`. Implement the following function: ```python def combination_memo(n, r): # Implement the memoized version of combination calculation ``` # Input: - `n` (integer): Total number of items (0 <= n <= 100). - `r` (integer): Number of items to choose (0 <= r <= n). # Output: - (integer): The number of ways to choose `r` items from `n` items. # Constraints: - Use a dictionary or other suitable data structure to memoize the results of subproblems. - Your function should handle edge cases such as `n = r` and `r = 0` efficiently. # Example: ```python # Example 1 n = 5 r = 2 print(combination_memo(n, r)) # Output: 10 # Example 2 n = 10 r = 5 print(combination_memo(n, r)) # Output: 252 ``` # Explanation: 1. In the first example, there are 10 ways to choose 2 items out of 5. 2. In the second example, there are 252 ways to choose 5 items out of 10. Ensure you test your function with various edge cases to validate its performance and correctness.","solution":"def combination_memo(n, r): Calculates the binomial coefficient (nCr) using memoization. memo = {} def helper(n, r): if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = helper(n-1, r-1) + helper(n-1, r) return memo[(n, r)] return helper(n, r)"},{"question":"# Hailstone Sequence Analysis and Extension **Objective**: Given a function that generates the hailstone sequence for a given number `n`, your task is to extend its functionality to include both the sequence and additional properties. # Problem Statement Implement a function `hailstone_info(n: int) -> dict` that generates the hailstone sequence starting from `n` and returns a dictionary with the following details: - **sequence**: The full hailstone sequence as a list. - **length**: The total number of terms in the sequence. - **peak**: The highest number in the sequence. # Input - **n**: A positive integer (1 ≤ n ≤ 10^6). # Output - A dictionary with three keys: - `sequence`: a list of integers representing the hailstone sequence. - `length`: an integer representing the number of terms in the sequence. - `peak`: an integer representing the highest number in the sequence. # Example ```python hailstone_info(7) # Output: # { # \'sequence\': [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], # \'length\': 17, # \'peak\': 52 # } ``` # Constraints - The function should be efficient and work within reasonable time limits for the maximum value of `n`. - Consider edge cases such as the smallest possible value of `n`. # Notes - You are not allowed to use any global variables. - Ensure your code is clear, well-documented, and includes necessary error checking.","solution":"def hailstone_info(n: int) -> dict: Given an integer n (1 ≤ n ≤ 10^6), this function returns a dictionary containing the hailstone sequence starting from n, the length of the sequence, and the highest number in the sequence. :param n: A positive integer from which the hailstone sequence starts :return: A dictionary containing keys \'sequence\', \'length\', and \'peak\' if n < 1 or n > 10**6: raise ValueError(\\"Input should be a positive integer between 1 and 10^6\\") sequence = [] peak = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 if n > peak: peak = n sequence.append(1) # Adding the final term 1 return { \\"sequence\\": sequence, \\"length\\": len(sequence), \\"peak\\": peak }"},{"question":"# Binary Tree Path Finder Context You are tasked with devising a utility that traces all paths from the root to the leaves of a binary tree, presenting each path as a string of node values separated by \'->\'. This tool will be instrumental in visualizing and analyzing possible routes in a given binary structure. Task Implement a function `binary_tree_paths(root)` that takes the root of a binary tree and returns a list of all root-to-leaf paths. Input - `root`: The root node of the binary tree. Each node has attributes `val`, `left`, and `right`. Output - A list of strings, where each string represents a path from the root to a leaf. Constraints - Each node contains an integer value. - The maximum number of nodes in the tree is 10^4. - A path must start at the root and end at a leaf. - You may assume all node values are unique. Example Given a binary tree like: ``` 1 / 2 3 5 ``` Calling `binary_tree_paths(root)` should return: ```python [\\"1->2->5\\", \\"1->3\\"] ``` Requirements - **Efficiency**: Your implementation should aim for O(N) time complexity. - **Edge Handling**: Properly handle edge cases such as an empty tree or a tree with a single node. - **No global variables** should be used, ensure the function works as a self-contained module. Implementation Challenges - Constructing paths correctly as strings while traversing. - Managing the recursive stack depth for deep trees. Implement the function below: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): # Your implementation here pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \\"\\") return paths"},{"question":"# Binary Search Tree Predecessor Search Given the root of a Binary Search Tree (BST) and a node, write a function `predecessor` to find the predecessor of the given node. The predecessor of a node is the largest node in the BST that is smaller than the given node. Function Signature ```python def predecessor(root: TreeNode, node: TreeNode) -> TreeNode: pass ``` Input * `root` (TreeNode): The root of the binary search tree. * `node` (TreeNode): The node whose predecessor we need to find. Output * Returns the predecessor node of the given node if it exists, otherwise returns `None`. Constraints * Do not use parent pointers. * Each node will have a unique value. * Height of the tree is bounded by the input size. Example: Consider the following BST: ``` 15 / 10 20 / / 8 12 16 25 / 6 ``` If the function is called as `predecessor(root, TreeNode(10))`, it should return `TreeNode(8)`. # Note * There could be multiple testcases where the node might not have a predecessor, or the node might be the smallest element. # Additional Clarifications * Avoid using unnecessary space. Solution should be efficient in terms of both time and space complexity.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def predecessor(root: TreeNode, node: TreeNode) -> TreeNode: Finds the predecessor of the given node in the BST. Args: root (TreeNode): The root of the binary search tree. node (TreeNode): The node whose predecessor we need to find. Returns: TreeNode: The predecessor node, or None if no predecessor exists. predecessor = None current = root while current: if node.value > current.value: predecessor = current current = current.right elif node.value < current.value: current = current.left else: if current.left: predecessor = current.left while predecessor.right: predecessor = predecessor.right break return predecessor"},{"question":"**Question**: You are overseeing the management of a parking lot with specific constraints. The parking lot has exactly one empty spot, and the goal is to transform the lot from its initial arrangement to the specified final arrangement with the least number of moves. Each move involves moving a car into the empty spot. # Input: - `initial`: A list of integers representing the initial state of the parking lot, where 0 indicates the empty spot. - `final`: A list of integers representing the target state. # Output: - The minimum number of moves required. - A list of lists where each inner list represents the state of the parking lot after each step. # Constraints: - Each list contains only distinct integers. - `initial` and `final` have the same length. # Performance Requirement: - Your function should efficiently handle transformations with typical input sizes up to 10. # Function Signature: ```python def garage(initial: List[int], final: List[int]) -> Tuple[int, List[List[int]]]: pass ``` # Context: Imagine that you are an automated parking management system tasked with rearranging parked cars to fit a reservation order. Given the initial layout and the required final layout, determine the step-by-step procedure to achieve this rearrangement. # Example: ```python # Initial state of the parking lot initial = [1, 2, 3, 0, 4] # Final state of the parking lot final = [0, 3, 2, 1, 4] # Expected Output: # Number of moves required: 4 # Sequence of changes: # [ # [0, 2, 3, 1, 4], # [2, 0, 3, 1, 4], # [2, 3, 0, 1, 4], # [0, 3, 2, 1, 4] # ] ``` **Your task** is to implement the `garage` function to achieve this result.","solution":"def garage(initial, final): Transforms the initial state of the parking lot to the final state. Parameters: initial (List[int]): Initial state of the parking lot with 0 representing the empty spot. final (List[int]): Desired final state of the parking lot with 0 representing the empty spot. Returns: Tuple[int, List[List[int]]]: A tuple containing: - The minimum number of moves required. - The sequence of changes represented as a list of lists. current = initial[:] final_pos = {car: i for i, car in enumerate(final)} moves = [] # The empty slot in initial empty_idx = current.index(0) while current != final: if current[empty_idx] != final[empty_idx]: # Find the car that should be in the current empty slot car_to_move = final[empty_idx] car_idx = current.index(car_to_move) # Swap the car into the empty slot current[empty_idx], current[car_idx] = current[car_idx], current[empty_idx] moves.append(current[:]) # Update the empty slot empty_idx = car_idx else: for i in range(len(current)): if current[i] != final[i] and current[i] != 0: # Move this car to the current empty slot current[empty_idx], current[i] = current[i], current[empty_idx] moves.append(current[:]) # Update the empty slot empty_idx = i break return len(moves), moves"},{"question":"# Context You are working on a software that helps users manage bookings. One crucial function is to merge overlapping time intervals to simplify the booking schedules. Your task is to implement this merging functionality. # Problem Statement Write a function `merge_booking_intervals` that takes a list of tuples, where each tuple represents a booking interval `[start, end]`, and returns a list of merged intervals where overlapping intervals are combined. Function Signature ```python def merge_booking_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` Input * `intervals`: A list of tuples `[(start1, end1), (start2, end2), ...]`, where each tuple represents an interval. * `0 <= start, end <= 10^9` * `1 <= len(intervals) <= 10^4` Output * A list of merged intervals `[(start1, end1), (start2, end2), ...]` such that no two intervals overlap, sorted by their start times. Constraints * Merge intervals that overlap or touch at the boundaries. * The output intervals should be sorted by their start times. # Examples Example 1 ```python intervals = [(1, 3), (2, 6), (8, 10), (15, 18)] merge_booking_intervals(intervals) # Returns [(1, 6), (8, 10), (15, 18)] ``` Example 2 ```python intervals = [(1, 4), (4, 5)] merge_booking_intervals(intervals) # Returns [(1, 5)] ``` # Requirements 1. Implement the function `merge_booking_intervals`. 2. Include at least one test case demonstrating the result for boundary-touching intervals. 3. Ensure your solution handles large volumes efficiently.","solution":"from typing import List, Tuple def merge_booking_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges a list of overlapping booking intervals. if not intervals: return [] # Sort the intervals based on their start times intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current_start, current_end in intervals[1:]: last_merged_start, last_merged_end = merged_intervals[-1] # If the current interval overlaps with the last merged one, merge them if current_start <= last_merged_end: merged_intervals[-1] = (last_merged_start, max(last_merged_end, current_end)) else: merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"# Question: Implement Cocktail Shaker Sort with Early Exit Optimization Context You are asked to implement an optimized version of Cocktail Shaker Sort for an automated sorting module. The goal is to include an early exit mechanism that stops the sorting process as soon as no swaps are needed after both forward and backward passes. Task Write a function `optimized_cocktail_shaker_sort` that sorts an array of integers in non-decreasing order using the Cocktail Shaker Sort algorithm. Ensure that the function stops as soon as it detects that the array is fully sorted (i.e., no swaps are made in both forward and backward passes). Function Signature ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> None: pass ``` Input * The function accepts a list of integers `arr` which may contain both positive and negative numbers. The list can have from 0 up to (10^5) elements. Output * The function sorts the list `arr` in place (modifies the input list), with no return value. Constraints * Do not use any extra space for another array (in-place sorting required). * Aim for the simplest possible implementation with minimal runtime complexity enhancements. * Ensure the algorithm performs efficiently even for edge cases like already sorted or reversely sorted arrays. Example ```python >>> arr = [3, 5, 2, 1, 4] >>> optimized_cocktail_shaker_sort(arr) >>> print(arr) [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> optimized_cocktail_shaker_sort(arr) >>> print(arr) [1, 2, 3, 4, 5] >>> arr = [] >>> optimized_cocktail_shaker_sort(arr) >>> print(arr) [] >>> arr = [5, 4, 3, 2, 1] >>> optimized_cocktail_shaker_sort(arr) >>> print(arr) [1, 2, 3, 4, 5] ```","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> None: Sorts a list of integers in non-decreasing order using optimized Cocktail Shaker Sort. The function modifies the input list in place and does not return any value. n = len(arr) if n < 2: return start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Move the end point back by one end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Move the starting point forward by one start += 1"},{"question":"# Problem Description You are required to implement a Python class for handling a **Doubly Linked List**. Your class should support the following operations efficiently: 1. **Insertion at the front** (`insert_front(value)`): Add a node with the specified value at the beginning of the list. 2. **Insertion at the end** (`insert_end(value)`): Add a node with the specified value at the end of the list. 3. **Deletion from the front** (`delete_front()`): Remove the node from the beginning of the list. 4. **Deletion from the end** (`delete_end()`): Remove the node from the end of the list. 5. **Searching for a value** (`search(value)`): Return `True` if the value is present in the list, otherwise `False`. 6. **Traversal** (`traverse()`): Return a list of all elements in the doubly linked list, starting from the head. # Constraints - Your methods should handle edge cases such as operations on an empty list. - Operations should aim to be efficient adhering to the performance advantages of linked lists. - The list should maintain the property of being doubly linked by ensuring nodes correctly reference their next and previous nodes. # Input/Output Format ```python class DoublyLinkedList: def __init__(self): # Initialize your data structure here def insert_front(self, value): # Add a node with the specified value at the front def insert_end(self, value): # Add a node with the specified value at the end def delete_front(self): # Remove the node from the front def delete_end(self): # Remove the node from the end def search(self, value): # Return True if value is found, otherwise False def traverse(self): # Return the list of all elements from the head node ``` # Example ```python # Creating a Doubly Linked List dll = DoublyLinkedList() # Inserting elements dll.insert_front(10) dll.insert_end(20) dll.insert_front(5) # Traversing print(dll.traverse()) # Output: [5, 10, 20] # Searching for elements print(dll.search(10)) # Output: True print(dll.search(15)) # Output: False # Deleting elements dll.delete_front() dll.delete_end() print(dll.traverse()) # Output: [10] ``` # Performance Requirements - Ensure that insertion and deletion operations are O(1). - Search and traversal operations should be O(n). Implement the `DoublyLinkedList` class according to the specification above.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_front(self, value): new_node = Node(value) if self.head is None: # List is empty self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_end(self, value): new_node = Node(value) if self.tail is None: # List is empty self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_front(self): if self.head is None: # List is empty return if self.head == self.tail: # List has only one element self.head = self.tail = None else: self.head = self.head.next self.head.prev = None def delete_end(self): if self.tail is None: # List is empty return if self.head == self.tail: # List has only one element self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None def search(self, value): current = self.head while current is not None: if current.value == value: return True current = current.next return False def traverse(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result"},{"question":"You are given an undirected graph represented as an adjacency list. Implement a function that not only finds the shortest path but also ensures that the path avoids a specified set of \\"unwanted\\" nodes. The function should return the shortest path between the start and end nodes that does not pass through any unwanted nodes. # Input * `graph` (dict): A dictionary where the keys are nodes and the values are lists of neighboring nodes. * `start` (str): The node to start from. * `end` (str): The node to end at. * `unwanted_nodes` (set): A set of nodes that should be avoided. # Output * A list of nodes representing the shortest path avoiding unwanted nodes. If no such path exists, return None. # Function Signature ```python def find_shortest_path_avoiding_nodes(graph, start, end, unwanted_nodes): pass ``` # Constraints * The graph contains at least 2 nodes and no more than 1000 nodes. * All values in the adjacency list are unique. * The start and end nodes are distinct and always present in the graph. * Unwanted nodes may or may not be present in the graph; if present, they must be avoided. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' end = \'F\' unwanted_nodes = {\'B\'} print(find_shortest_path_avoiding_nodes(graph, start, end, unwanted_nodes)) # Output should be [\'A\', \'C\', \'F\'] ``` # Notes * Your solution should use a BFS-based approach for optimal performance. * Consider edge cases where no path is possible due to blockages. * Ensure that the function is efficient and could handle up to the upper limit of 1000 nodes.","solution":"from collections import deque def find_shortest_path_avoiding_nodes(graph, start, end, unwanted_nodes): Finds the shortest path in an undirected graph avoiding unwanted nodes. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The target node. :param unwanted_nodes: A set of nodes to avoid. :return: A list of nodes representing the shortest path avoiding unwanted nodes, or None if no such path exists. # Edge case: if start or end is an unwanted node, return None if start in unwanted_nodes or end in unwanted_nodes: return None # Initialize BFS queue = deque([(start, [start])]) visited = set(start) while queue: current_node, path = queue.popleft() # Check if we have reached the end node if current_node == end: return path # Explore neighbors for neighbor in graph.get(current_node, []): if neighbor not in visited and neighbor not in unwanted_nodes: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) # If no path is found return None"},{"question":"# Path Sum in Binary Tree You are given a binary tree and an integer sum. Your task is to find all the root-to-leaf paths where each path\'s sum of node values equals the given sum. Input - A binary tree represented by its root node `TreeNode root`. - An integer `sum` representing the target sum for the path. Output - Return a list of lists, where each list represents a path from root to leaf with the given sum. Constraints - The number of nodes in the tree is in the range `[0, 5000]`. - -1000 <= Node.val <= 1000 - -1000 <= sum <= 1000 Performance Requirement - The solution should be efficient with respect to both time and space complexity, typically running within O(N) time complexity where N is the number of nodes in the tree. # Implementation Details You need to implement the following function: ```python def path_sum(root: TreeNode, sum: int) -> List[List[int]]: # Your implementation here ``` # Example Example 1: Input: ```python root = [5,4,8,11,null,13,4,7,2,null,null,5,1] sum = 22 ``` Output: ```python [ [5,4,11,2], [5,8,4,5] ] ``` Example 2: Input: ```python root = [1,2,3] sum = 5 ``` Output: ```python [] ``` Example 3: Input: ```python root = [] sum = 0 ``` Output: ```python [] ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: Optional[TreeNode], sum: int) -> List[List[int]]: def dfs(node, current_sum, path, result): if not node: return current_sum += node.val path.append(node.val) # If it\'s a leaf node and the current sum equals the target sum if not node.left and not node.right and current_sum == sum: result.append(list(path)) else: dfs(node.left, current_sum, path, result) dfs(node.right, current_sum, path, result) # Backtrack path.pop() result = [] dfs(root, 0, [], result) return result"},{"question":"You are tasked with implementing a modified version of interpolation search that works efficiently even when the array is not uniformly distributed. Ensure to handle edge cases such as sparse distribution and non-uniform elements correctly. **Function Signature:** ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: pass ``` # Input Format - `array`: A list of integers in increasing order. - `search_key`: The integer value to be searched in the array. # Output Format - Returns the index of `search_key` if found, else `-1`. # Constraints - The array will have at most (10^6) elements. - Array elements and the search key will be in the range of (-10^9) to (10^9). # Example ```python assert optimized_interpolation_search([10, 20, 30, 40, 50], 30) == 2 assert optimized_interpolation_search([1, 4, 7, 9, 13], 4) == 1 assert optimized_interpolation_search([1, 3, 5, 6, 7, 9, 11], 8) == -1 assert optimized_interpolation_search([], 3) == -1 assert optimized_interpolation_search([1, 2, 3, 4, 5, 6], 0) == -1 ``` # Performance Requirements - Your solution should be optimized for large datasets and handle edge cases efficiently. # Additional Notes - Interpolation may not work well with very sparse datasets or highly skewed distributions. Provide optimizations or fallback mechanisms to handle such cases.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: Perform an optimized interpolation search on a given sorted array. Args: array: List of integers in increasing order. search_key: The integer value to be searched in the array. Returns: The index of the search_key if found, else -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Estimation of position using interpolation formula pos = low + int(((search_key - array[low]) * (high - low)) / (array[high] - array[low])) if pos < low or pos > high: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Merging Sorted Linked Lists You are given two sorted singly linked lists. Your task is to write a function to merge these two lists into a single sorted list and return the head of the new list. The merging should be done by splicing the nodes of the original lists together. Function Signature ```python def merge_two_lists(list1: Node, list2: Node) -> Node: ``` Input Format - `list1`: The head node of the first sorted linked list. - `list2`: The head node of the second sorted linked list. Each node of the linked list will be defined as follows: ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output Format - Return the head node of the merged sorted linked list. Constraints - The number of nodes in both lists is in the range `[0, 10^4]`. - The node values are in the range `[-10^4, 10^4]`. Example **Input**: 1 -> 2 -> 4, 1 -> 3 -> 4 **Output**: 1 -> 1 -> 2 -> 3 -> 4 -> 4 **Additional examples**: 1. **Input**: - List 1: 5, - List 2: 1 -> 2 -> 3 - **Output**: 1 -> 2 -> 3 -> 5 2. **Input**: - List 1: (empty), - List 2: 1 -> 2 -> 3 - **Output**: 1 -> 2 -> 3 3. **Input**: - List 1: -5 -> -3 -> -1, - List 2: 2 -> 4 -> 6 - **Output**: -5 -> -3 -> -1 -> 2 -> 4 -> 6 Performance Considerations - Ensure that the function operates within the time complexity of O(n + m) and utilizes space optimally.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(list1: Node, list2: Node) -> Node: Merges two sorted linked lists into a single sorted linked list. Args: list1: Node - The head node of the first sorted linked list. list2: Node - The head node of the second sorted linked list. Returns: Node - The head node of the merged sorted linked list. dummy = Node() tail = dummy while list1 and list2: if list1.val < list2.val: tail.next = list1 list1 = list1.next else: tail.next = list2 list2 = list2.next tail = tail.next if list1: tail.next = list1 elif list2: tail.next = list2 return dummy.next"},{"question":"# Scenario You are a data analyst working with a large dataset that contains repeated readings of several metrics. To effectively analyze the data distribution, you need to generate a histogram representation of the readings. Your task is to implement a function that will take a list of readings and return a dictionary representing the histogram of these readings. # Function Specification **Function Name**: `calculate_histogram` **Input**: * A list of integers `readings`. **Output**: * A dictionary where the keys are unique integers from the input list, and the values are the frequencies of these integers in the list. # Constraints * The list will contain at most `10^6` elements. * The elements in the list will be between `-10^6` and `10^6`. # Example **Example 1**: ```python readings = [3, 3, 2, 1] calculate_histogram(readings) # Expected output: {1: 1, 2: 1, 3: 2} ``` **Example 2**: ```python readings = [2, 3, 5, 5, 5, 6, 4, 3, 7] calculate_histogram(readings) # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` **Example 3**: ```python readings = [] calculate_histogram(readings) # Expected output: {} ```","solution":"def calculate_histogram(readings): Returns a histogram for the input list of readings. :param readings: List of integers :return: Dictionary where keys are unique integers from the input list, and values are their frequencies histogram = {} for reading in readings: if reading in histogram: histogram[reading] += 1 else: histogram[reading] = 1 return histogram"},{"question":"Scenario: You are developing a financial analysis dashboard that processes large datasets of transaction values. One of the requirements is to filter transactions within specified bounds to analyze data that falls within typical ranges, excluding extreme values. Your task is to implement a function that meets these criteria and handles multiple edge cases effectively. Objective: Write a function `filterTransactions(transactions, min_val=None, max_val=None)` that filters out transaction values that fall outside the provided minimum and maximum limits. Function Signature: ```python def filterTransactions(transactions: List[float], min_val: Optional[float] = None, max_val: Optional[float] = None) -> List[float]: ``` Input: - `transactions`: A list of float numbers representing transaction values. (List[float]) - `min_val`: An optional float representing the minimum transaction value to include. If not provided, there is no lower bound. (Optional[float]) - `max_val`: An optional float representing the maximum transaction value to include. If not provided, there is no upper bound. (Optional[float]) Output: - Returns a list of float numbers that include only transactions within the given bounds. (List[float]) Constraints: - The transactions list can be empty or have up to 10^6 elements. - Transaction values can be positive or negative. Examples: 1. `filterTransactions([100.0, 200.0, 300.0, 400.0], 150.0, 350.0)` returns `[200.0, 300.0]` 2. `filterTransactions([-50.0, 20.0, 70.0, 1000.0], None, 100.0)` returns `[-50.0, 20.0, 70.0]` 3. `filterTransactions([-10.0, -5.0, 0.0, 5.0, 10.0], -5.0, 5.0)` returns `[-5.0, 0.0, 5.0]` 4. `filterTransactions([], 10.0, 50.0)` returns `[]` Make sure your solution is efficient and handles all the edge cases effectively.","solution":"from typing import List, Optional def filterTransactions(transactions: List[float], min_val: Optional[float] = None, max_val: Optional[float] = None) -> List[float]: Filters the transaction values that fall outside the provided minimum and maximum limits. :param transactions: List of transaction values. :param min_val: Minimum transaction value to include. If not provided, no lower bound. :param max_val: Maximum transaction value to include. If not provided, no upper bound. :return: List of transaction values within the specified bounds. if min_val is not None and max_val is not None: return [t for t in transactions if min_val <= t <= max_val] elif min_val is not None: return [t for t in transactions if t >= min_val] elif max_val is not None: return [t for t in transactions if t <= max_val] else: return transactions"},{"question":"# Trie Implementation and its Applications Objective You are required to implement and utilize a Trie data structure to perform multiple operations involving a collection of strings. The tasks involve inserting strings into the Trie, searching for specific words, and querying for the existence of words starting with a given prefix. Tasks 1. Implement a Trie with the following methods: - `insert(word: str) -> None`: Inserts the string `word` into the trie. - `search(word: str) -> bool`: Returns `True` if the string `word` is present in the trie, otherwise returns `False`. - `starts_with(prefix: str) -> bool`: Returns `True` if there is any string in the trie that starts with the given `prefix`, otherwise returns `False`. 2. Utilize the implemented Trie to solve the following problem: Given a list of words and a list of query prefixes, return the list of words starting with each prefix in the corresponding order of queries. Inputs 1. List of strings, `words`, where each `word` is composed of lowercase English letters (\'a\' - \'z\'). 2. List of query prefixes, `queries`. Output A list of lists, where each inner list contains words from the `words` list that start with the corresponding prefix from `queries`. Example ```python words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\"] queries = [\\"ap\\", \\"ba\\", \\"ca\\"] output = [ [\\"apple\\", \\"app\\", \\"apricot\\"], # Words starting with \\"ap\\" [\\"banana\\"], # Words starting with \\"ba\\" [] # No words starting with \\"ca\\" ] ``` Constraints - The number of words and queries are up to 10^4. - Each word and prefix can have up to 100 characters. Implement the required Trie class and functions to solve the above query.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.words = [] # To store words for prefix searches class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.words.append(word) node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def get_words_with_prefix(self, prefix: str) -> list: node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return node.words def find_words_with_prefixes(words: list, queries: list) -> list: trie = Trie() for word in words: trie.insert(word) return [trie.get_words_with_prefix(query) for query in queries]"},{"question":"# Coding Exercise: Sum of Digits of the Largest Number Scenario You are given a list of integers. Your task is to identify the integer with the maximum number of digits and then compute the sum of all its digits. This requires an understanding of number digit counting and basic summing techniques. Task Write a function `sum_of_largest_number_digits(numbers: list) -> int` that fulfills the following requirements: Requirements 1. **Input Format**: A list of integers which can include positive, negative, and zero values. The list will have at least one integer. 2. **Output Format**: An integer that represents the sum of the digits of the number with the maximum number of digits. 3. **Constraints**: * The list contains at least one number and at most 10^5 numbers. * The numbers can be as large as the integer limits specifications of the language in use. 4. **Function Signature**: ```python def sum_of_largest_number_digits(numbers: list) -> int: ``` Example ``` Input: [123, -4567, 89, -12] Output: 22 # since -4567 has the most digits, 4+5+6+7=22 Input: [0, 99, 999] Output: 27 # since 999 has the most digits, 9+9+9=27 Input: [-5, 33, -121] Output: 4 # since -121 has the most digits, 1+2+1=4 ``` Explanation 1. Find the number with the maximum digits using the `num_digits` function provided. 2. Sum the digits of this number (considering its absolute value to handle negative numbers correctly). 3. Return the result as the output. Constraints - **Performance Requirement**: The function should run efficiently for large input sizes, considering the constraints. Write clear, readable, and well-documented code to ensure your logic is easily understandable.","solution":"def sum_of_largest_number_digits(numbers: list) -> int: This function takes a list of integers and returns the sum of the digits of the number with the maximum number of digits. def num_digits(n): Helper function to count the digits in a number. return len(str(abs(n))) # Find the number with the maximum digits max_digits_num = max(numbers, key=lambda x: num_digits(x)) # Summing the digits of the absolute value of the number with max digits return sum(int(digit) for digit in str(abs(max_digits_num)))"},{"question":"# Palindrome Verification Challenge You are given several variations of algorithms designed to check whether a given string is a palindrome. Each algorithm ignores non-alphanumeric characters and is case-insensitive. Your task is to create a function that takes a string as input and returns whether the input string is a palindrome using a **deque-based approach**. # Requirements: 1. Only consider alphanumeric characters and ignore cases. 2. Use the deque data structure to efficiently manage the checking process. 3. Ensure that your solution handles edge cases such as empty strings and strings with only non-alphanumeric characters. # Input Format - A single string `s` (0 ≤ |s| ≤ 10^5), consisting of printable ASCII characters. # Output Format - Return `True` if the string is a palindrome, otherwise return `False`. # Constraints - Strive for an optimal solution with O(n) time complexity and O(n) space complexity. # Performance Requirements - Efficient memory usage and runtime, given the potential length of the string. # Example ```python assert is_palindrome_deque(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_deque(\\"race a car\\") == False assert is_palindrome_deque(\\"\\") == True assert is_palindrome_deque(\\" \\") == True ``` # Implementation Notes - You\'ll need to design a helper function `remove_punctuation(s)` to preprocess the string by removing non-alphanumeric characters and converting it to lowercase. - Your primary function `is_palindrome_deque(s)` should utilize a deque to conduct the palindrome check efficiently. Happy coding!","solution":"from collections import deque import re def is_palindrome_deque(s): Returns True if the string s is a palindrome, ignoring spaces, punctuations, and is case-insensitive. # Preprocess the string: remove non-alphanumeric characters and convert to lowercase s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Use deque to check for palindrome deq = deque(s) while len(deq) > 1: if deq.popleft() != deq.pop(): return False return True"},{"question":"You are required to implement a function called `comb_sort_descending` that sorts an array of integers in descending order using the Comb Sort algorithm. # Function Signature ```python def comb_sort_descending(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers, `arr` (0 <= len(arr) <= 10^5) # Output - The list of integers sorted in descending order. # Constraints - Values in the list can be any valid integers. - You must perform in-place sorting, meaning you should not allocate additional memory for another array. # Example ```python # Example 1 input = [10, 3, 2, 5, 8] output = [10, 8, 5, 3, 2] # Example 2 input = [1, 2, 3, 4, 5] output = [5, 4, 3, 2, 1] ``` # Explanation - For Example 1: Initially, the array is [10, 3, 2, 5, 8]. After sorting, it becomes [10, 8, 5, 3, 2]. - For Example 2: Initially, the array is [1, 2, 3, 4, 5]. After sorting, it becomes [5, 4, 3, 2, 1]. # Notes - Consider edge cases such as empty arrays, single-element arrays, and arrays with identical elements. - Ensure to detail edge cases in your solution with appropriate comments.","solution":"def comb_sort_descending(arr): Sorts a list of integers in descending order using the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: gap = 1 return gap n = len(arr) gap = n swapped = True # Keep running while at least one swap occurred or gap is greater than 1 while gap != 1 or swapped: # Get the next gap size gap = get_next_gap(gap) swapped = False # Compare all elements with current gap for i in range(0, n - gap): if arr[i] < arr[i + gap]: # Swap arr[i] and arr[i + gap] arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"**Scenario**: In a research project, you are required to frequently compute large Fibonacci numbers efficiently to model biological growth processes. Due to the limitations of computational resources, you need to write a function that returns the n-th Fibonacci number while maintaining a balance between time and space complexity. **Problem**: Given a number `n`, write a function `optimized_fib(n)` to compute the n-th Fibonacci number with a time complexity of O(n) and space complexity of O(1). **Function Signature**: ```python def optimized_fib(n: int) -> int: ``` **Input**: - An integer `n` (0 <= n <= 10^6) representing the position in the Fibonacci sequence. **Output**: - An integer representing the n-th Fibonacci number. **Constraints**: - The input integer n will be non-negative. - You must not use any external libraries. - You should ensure that the solution is efficient by avoiding excessive use of memory while maintaining a linear time complexity. **Performance Requirements**: - The solution should ideally compute the result in less than 1 second for the maximum input size. **Example**: ```python assert optimized_fib(0) == 0 assert optimized_fib(1) == 1 assert optimized_fib(10) == 55 assert optimized_fib(50) == 12586269025 assert optimized_fib(100) == 354224848179261915075 ``` **Hints**: - Consider how you can re-use variables to save space. - Analyze the iterative approach of the provided solutions to guide your implementation.","solution":"def optimized_fib(n: int) -> int: Returns the n-th Fibonacci number. This function uses an iterative approach to achieve a time complexity of O(n) and space complexity of O(1). if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"You are given an array of integers where exactly two elements appear only once and all other elements appear exactly twice. You need to identify these two unique elements. Implement a function that solves this with a time complexity of O(N) and space complexity of O(1). # Function Signature: ```python def find_unique_pair(nums: List[int]) -> List[int]: # Implementation here ``` # Input: - `nums` (List[int]): A list of integers where exactly two elements appear only once and all others appear exactly twice. # Output: - List[int]: A list containing the two unique elements. The order of the result does not matter. # Constraints: - The list will contain at least two unique elements. - All other elements will appear exactly twice. - The solution must run in O(N) time and use O(1) extra space. # Examples: ```python assert find_unique_pair([1, 2, 1, 3, 2, 5]) == [3, 5] or find_unique_pair([1, 2, 1, 3, 2, 5]) == [5, 3] assert find_unique_pair([4, 6, 4, 7]) == [6, 7] or find_unique_pair([4, 6, 4, 7]) == [7, 6] ```","solution":"from typing import List def find_unique_pair(nums: List[int]) -> List[int]: Finds the two unique elements that appear only once in the array. All other elements appear exactly twice. The implementation uses XOR to isolate the unique elements. # Step 1: XOR all elements in the list. The result is the XOR of the two unique elements. xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a bit that is set in xor_result (this bit is different in the two unique numbers). mask = 1 while (xor_result & mask) == 0: mask <<= 1 # Step 3: Divide the elements into two groups and find the unique element in each group. unique1 = 0 unique2 = 0 for num in nums: if num & mask: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"You have been provided with a function `is_match` that matches an input string `s` with a pattern string `p` containing special characters `.` (matching any single character) and `*` (matching zero or more of the preceding element). # Objective Your task is to implement this function ensuring it covers all edge cases and performs efficiently. # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Input - **s**: A non-null string containing only lowercase alphabetic characters (1 ≤ |s| ≤ 200). - **p**: A non-null string containing only lowercase alphabetic characters and the special characters `.` and `*` (1 ≤ |p| ≤ 200). # Output - **Returns**: A boolean `True` if the entire input string matches the pattern, `False` otherwise. # Constraints - The pattern should match the entire input string, not just a partial substring. - Assume that the input string and pattern will only be alphanumeric and contain the characters `.` and `*`. - The implementation should run within time constraints even for the longest valid input. # Examples 1. `is_match(\\"aa\\", \\"a\\") → False` 2. `is_match(\\"aa\\", \\"a*\\") → True` 3. `is_match(\\"ab\\", \\".*\\") → True` 4. `is_match(\\"aab\\", \\"c*a*b\\") → True` # Hints 1. Use a 2D dynamic programming table where each cell represents if the substring of `s` up to index i matches the substring of `p` up to index j. 2. Handle the special cases for `.` and `*` dynamically as you populate the DP table. Implement the function `is_match` ensuring it fulfills the above requirements and handles diverse test cases effectively.","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) # DP table where dp[i][j] represents if s[:i] matches p[:j] dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Deals with patterns like a*, a*b*, a*b*c* etc. for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if (p[j - 2] == s[i - 1] or p[j - 2] == \'.\') else False) return dp[m][n]"},{"question":"# Question: First Non-Repeating Character Index Given a string, your task is to write a function `first_unique_char(s)` that identifies the index of the first non-repeating character in the string. If no such character exists, return -1. Input * A single string `s` (1 ≤ len(s) ≤ 10^5) consisting of lowercase English letters. Output * An integer representing the index of the first non-repeating character, or -1 if no such character exists. Constraints * The function should handle large inputs efficiently. * Aim for a time complexity of O(n) and space complexity of O(1) considering the constraints on character set. Example 1. Input: `s = \\"leetcode\\"` Output: `0` 2. Input: `s = \\"loveleetcode\\"` Output: `2` 3. Input: `s = \\"aabb\\"` Output: `-1` Implementation Details Write an efficient implementation that counts the frequency of each character and then iterates through the string to find the first character with a frequency of one.","solution":"def first_unique_char(s): Returns the index of the first non-repeating character in the string s. If no such character exists, return -1. from collections import Counter # Create a frequency dictionary of characters char_count = Counter(s) # Find the first character that has a frequency of 1 for idx, char in enumerate(s): if char_count[char] == 1: return idx # If no unique character found, return -1 return -1"},{"question":"As a software engineer, you are given the task to enhance the priority queue implementation focusing on optimizing the insertion operation. The current implementation has an insertion complexity of O(n), which is not suitable for performance-critical applications. You need to implement a priority queue using a min-heap, which can optimize the insertion operations. # Implementing a Min-Heap Priority Queue Requirements: 1. You need to implement a class `MinHeapPriorityQueue` with the following functionalities: * `push(item, priority)` - Insert an item with an associated priority. * `pop()` - Remove and return the item with the lowest priority. * `size()` - Return the number of items in the priority queue. Input & Output: * `push(item, priority)`: - Input: `item` can be any data type and `priority` is an integer. - Output: None * `pop()`: - Input: None - Output: The item with the lowest priority. * `size()`: - Input: None - Output: Number of items in the priority queue (an integer). Constraints: 1. `push` will only be called with valid data types. 2. The number of `push` operations will be between 1 and 10^5. 3. The number of `pop` operations will be between 1 and 10^5. 4. Priority values are within the range of -10^6 to 10^6. # Example: ```python pq = MinHeapPriorityQueue() pq.push(\\"task1\\", 3) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 2) assert pq.size() == 3 assert pq.pop() == \\"task2\\" assert pq.pop() == \\"task3\\" assert pq.pop() == \\"task1\\" assert pq.size() == 0 ``` Note: Implementing the min-heap will optimize the `push` operation to have a time complexity of O(log n), and the `pop` operation will also have a time complexity of O(log n). # Your solution should look like: ```python class MinHeapPriorityQueue: def __init__(self): # Initialize your data structures here def push(self, item, priority): # Implement the push operation here def pop(self): # Implement the pop operation here def size(self): # Implement the size operation here ```","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): self.heap = [] self.count = 0 def push(self, item, priority): heapq.heappush(self.heap, (priority, self.count, item)) self.count += 1 def pop(self): if self.size() > 0: return heapq.heappop(self.heap)[2] return None def size(self): return len(self.heap)"},{"question":"**Scenario**: You are tasked with creating a script that performs file operations based on user input paths. A key part of this task is to ensure that all provided file paths are resolved to their absolute paths to avoid confusion and errors. **Task**: Implement a function `get_absolute_paths` that takes a list of file paths and returns their absolute paths. Your function should handle relative paths, user home directory shorthands (`~`), and ensure that each path in the returned list is an absolute path. # Function Signature ```python def get_absolute_paths(file_paths: List[str]) -> List[str]: pass ``` # Input - `file_paths`: A list of strings where each string is a file path. The list will have at least one file path and each path is guaranteed to be a valid string (i.e., no `null` or `NaN` values). # Output - Returns a list of strings where each string is the absolute path corresponding to the input paths. # Constraints - Convert paths to absolute paths. - Handle user home directory shorthands (`~`). - The function should be efficient in terms of both time and space complexity. # Example ```python # Example Input file_paths = [\\"~/file.txt\\", \\"docs/report.pdf\\", \\"/usr/local/bin/script.py\\"] # Example Output [\\"/home/user/file.txt\\", \\"/home/user/docs/report.pdf\\", \\"/usr/local/bin/script.py\\"] ``` # Notes - Assume the current user home directory for `~` expansion is `/home/user`. - Assume paths are provided in Unix-style format.","solution":"import os from typing import List def get_absolute_paths(file_paths: List[str]) -> List[str]: Convert a list of file paths to their absolute paths. :param file_paths: List of file paths as strings :return: List of absolute file paths absolute_paths = [] for path in file_paths: # Expand the user home directory shorthand (~) expanded_path = os.path.expanduser(path) # Convert to an absolute path absolute_path = os.path.abspath(expanded_path) absolute_paths.append(absolute_path) return absolute_paths"},{"question":"# Question You are implementing a job scheduler that manages tasks using a queue data structure. The scheduler must be able to handle tasks efficiently using operations like adding a new task (enqueue), processing/removing the next task (dequeue), checking the next task to be processed (peek), and ensuring the queue is not empty. **Function Implementation Requirements:** Write a Python class `JobSchedulerQueue` that provides a queue implementation with the following methods: - `enqueue(self, task)`: Adds a new task. - `dequeue(self)`: Removes and returns the next task to be processed. - `peek(self)`: Returns the next task to be processed without removing it. - `is_empty(self)`: Checks if the queue is empty and returns a boolean value. - `size(self)`: Returns the number of tasks. - `expand(self)`: (Optional for array-based implementation) Expands the size of the queue when needed. **Input and Output Formats:** - **enqueue(self, task):** - Input: `task` (string) - Name of the task to be added. - Output: None - **dequeue(self):** - Input: None - Output: `task` (string) - Name of the task to be processed. - **peek(self):** - Input: None - Output: `task` (string) - Name of the task to be processed. - **is_empty(self):** - Input: None - Output: `result` (boolean) - True if the queue is empty, otherwise False. - **size(self):** - Input: None - Output: `result` (integer) - Number of tasks in the queue. **Constraints:** - You must handle edge cases like `dequeue` and `peek` operations on an empty queue. **Example:** ```python scheduler = JobSchedulerQueue() scheduler.enqueue(\'Task1\') scheduler.enqueue(\'Task2\') print(scheduler.peek()) # Output: \'Task1\' print(scheduler.dequeue()) # Output: \'Task1\' print(scheduler.size()) # Output: 1 print(scheduler.is_empty()) # Output: False ``` # Implementation Notes: - You may choose to implement `JobSchedulerQueue` using an array or a linked list approach.","solution":"class JobSchedulerQueue: def __init__(self): # Initializing queue using a list self.queue = [] def enqueue(self, task): Adds a new task to the queue. self.queue.append(task) def dequeue(self): Removes and returns the next task to be processed. Raises an error if the queue is empty. if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") return self.queue.pop(0) def peek(self): Returns the next task to be processed without removing it. Raises an error if the queue is empty. if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.queue[0] def is_empty(self): Checks if the queue is empty and returns a boolean value. return len(self.queue) == 0 def size(self): Returns the number of tasks in the queue. return len(self.queue)"},{"question":"# Coding Challenge: Enhanced Binary Search Tree with Deletion **Scenario**: You are a software engineer at a tech firm working on an advanced database system. One of your tasks is to implement an enhanced Binary Search Tree (BST) that supports dynamic data operations efficiently. The BST should not only support insertion, search, and traversal but also be able to handle deletions of nodes. **Objective**: Enhance the provided Binary Search Tree implementation to include node deletion and ensure it works correctly with the existing operations like insertion, search, size, and various tree traversals. **Task**: 1. Implement a `delete` method in the BST class that removes a node with the specified value from the tree. 2. Update the `TestSuite` to include tests for the `delete` method. Method Signature ```python def delete(self, key: int) -> bool: Deletes a node with the given key if it exists. Returns True if the deletion was successful, False if the node was not found. pass ``` Points to Consider - Ensure the tree properties are maintained after deletion. - Handle edge cases such as: - Deleting a node with no children. - Deleting a node with one child. - Deleting a node with two children. - Deleting the root node. - Optimize for performance and handle any potential errors. **Input/Output**: - Input: `delete(key: int) -> bool` - Output: Returns `True` if the node with the specified key was successfully deleted, `False` if the node was not found in the tree. **Example Usage**: ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(5) print(tree.delete(10)) # Output: True (Node 10 deleted) print(tree.delete(20)) # Output: False (Node 20 not found) ``` **Constraints**: - The value of `key` will be an integer. - The tree can contain both positive and negative integer values. # Tests: Extend the existing test class `TestSuite` to include the following: ```python def test_delete(self): self.assertTrue(self.tree.delete(15)) self.assertTrue(self.tree.delete(6)) self.assertFalse(self.tree.delete(100)) ``` Implement the `delete` function considering all edge cases and maintaining the complexity as close to O(log N) as possible for balanced trees.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root if key < root.val: return self._search(root.left, key) return self._search(root.right, key) def delete(self, key): self.root, deleted = self._delete(self.root, key) return deleted def _delete(self, root, key): if root is None: return root, False deleted = False if key < root.val: root.left, deleted = self._delete(root.left, key) elif key > root.val: root.right, deleted = self._delete(root.right, key) else: deleted = True if root.left is None: return root.right, deleted elif root.right is None: return root.left, deleted min_larger_node = self._get_min(root.right) root.val = min_larger_node.val root.right, _ = self._delete(root.right, min_larger_node.val) return root, deleted def _get_min(self, root): while root.left is not None: root = root.left return root def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, root, result): if root is not None: self._inorder(root.left, result) result.append(root.val) self._inorder(root.right, result) def size(self): return self._size(self.root) def _size(self, root): if root is None: return 0 return 1 + self._size(root.left) + self._size(root.right)"},{"question":"# Question: Maximum Flow in a Transportation Network Context: A transportation company needs to optimize its freight routes to ensure that goods are transported from a central warehouse to multiple distribution centers with maximum efficiency. You are tasked with implementing a scheduling system that utilizes maximum flow algorithms to determine the optimal flow of goods through the transportation network. Task: Implement a function to compute the maximum flow from a source node (central warehouse) to a sink node (distribution center) using any of the provided maximum flow algorithms (Ford-Fulkerson, Edmonds-Karp, or Dinic\'s). Your function must handle large networks efficiently and return the maximum flow value. Requirements: 1. **Function Name**: `compute_max_flow`. 2. **Input**: * `capacity`: A 2D list representing the capacity of each edge in a graph where `capacity[i][j]` is the capacity from node `i` to node `j`. * `source`: An integer representing the index of the source node. * `sink`: An integer representing the index of the sink node. 3. **Output**: * An integer representing the maximum flow from `source` to `sink`. 4. **Constraints**: * All capacities are non-negative integers. * There are no negative cycles in the graph. * The number of vertices (V) in the graph is up to 300. * The number of edges (E) in the graph is up to 10,000. 5. **Performance**: Aim for a solution that minimizes computational complexity, making it suitable for large networks within the given constraints. Example: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(compute_max_flow(capacity, source, sink)) # Output: 23 ```","solution":"from collections import deque def bfs(capacity, source, sink, parent): Breadth-First Search to find if there\'s a path from source to sink. Returns True if there is a path, False otherwise. visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(capacity[u]): if not visited[v] and cap > 0: # if not visited and there\'s an available capacity queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def compute_max_flow(capacity, source, sink): Computes the maximum flow from source to sink using the Edmonds-Karp algorithm. # This array is used to store the path to be found by BFS parent = [-1] * len(capacity) max_flow = 0 # There is no flow initially while bfs(capacity, source, sink, parent): # Find the maximum flow this time path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] # update capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are given two strings, `s` and `t`, where `t` is generated by shuffling `s` and adding an extra character at a random position. Write a function `find_added_character(s: str, t: str) -> str` that identifies the extra character added to `t`. # Function Signature ```python def find_added_character(s: str, t: str) -> str: ``` # Input - `s` and `t`: Two strings consisting of only lowercase English letters. String `t` is guaranteed to be generated by shuffling string `s` and adding a single extra character. # Output - Return a single character representing the extra character added to `t`. # Constraints - Both strings only contain lowercase English letters (a-z). - 0 ≤ |s| ≤ 10^5 - |t| = |s| + 1 # Example ```python assert find_added_character(\\"abcd\\", \\"abecd\\") == \'e\' assert find_added_character(\\"\\", \\"y\\") == \'y\' assert find_added_character(\\"a\\", \\"aa\\") == \'a\' ``` # Explanation - In the first example, `t` is `abecd`, which is a shuffled version of `abcd` with the character `e` added. - In the second example, `t` is `y`, indicating `y` is the added character. - In the third example, `t` is `aa`, meaning another `a` was added. Implement the given function in the most efficient way considering the constraints.","solution":"def find_added_character(s: str, t: str) -> str: Identifies the extra character added to t. # Using collections.Counter to count occurrences of each character in s and t from collections import Counter # Count the characters in both strings count_s = Counter(s) count_t = Counter(t) # The extra character will have a count difference of one in t compared to s for char in count_t: if count_t[char] != count_s.get(char, 0): return char"}]'),O={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},z={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,c,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const P=p(O,[["render",j],["__scopeId","data-v-d841f6ba"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/46.md","filePath":"drive/46.md"}'),B={name:"drive/46.md"},G=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,G as default};
