import{_,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as u,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},A={class:"review-title"},R={class:"review-content"};function L(n,e,l,m,i,a){return s(),r("div",q,[t("div",T,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const E=_(k,[["render",L],["__scopeId","data-v-0952f163"]]),N=JSON.parse(`[{"question":"def is_palindrome_recursive(s: str) -> bool: Checks if a given string is a palindrome using a recursive approach. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome_recursive(\\"\\") == True >>> is_palindrome_recursive(\\"a\\") == True >>> is_palindrome_recursive(\\"abba\\") == True >>> is_palindrome_recursive(\\"abcd\\") == False >>> is_palindrome_recursive(\\"racecar\\") == True >>> is_palindrome_recursive(\\"hello\\") == False >>> is_palindrome_recursive(\\"Aba\\") == False","solution":"def is_palindrome_recursive(s): Checks if a given string is a palindrome using a recursive approach. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Define the base case: An empty string or a single character string is a palindrome if len(s) <= 1: return True # Check the characters at the beginning and end of the string if s[0] == s[-1]: # Call the function recursively with the substring excluding the checked characters return is_palindrome_recursive(s[1:-1]) # If the characters do not match, it's not a palindrome return False"},{"question":"def analyze_numbers(numbers: List[int]) -> Dict[int, Dict[str, Union[int, List[int]]]]: Analyzes the input list of numbers and returns a dictionary with information about the frequency and indices of each unique number. Arguments: numbers -- list of integers Returns: dict -- a dictionary where keys are the unique integers from the list, and values are dictionaries with 'frequency' and 'indices'. >>> analyze_numbers([1, 2, 2, 3, 1, 2, 4]) {1: {'frequency': 2, 'indices': [0, 4]}, 2: {'frequency': 3, 'indices': [1, 2, 5]}, 3: {'frequency': 1, 'indices': [3]}, 4: {'frequency': 1, 'indices': [6]}} >>> analyze_numbers([5, 6, 7]) {5: {'frequency': 1, 'indices': [0]}, 6: {'frequency': 1, 'indices': [1]}, 7: {'frequency': 1, 'indices': [2]}} >>> analyze_numbers([8, 8, 8, 8]) {8: {'frequency': 4, 'indices': [0, 1, 2, 3]}} >>> analyze_numbers([]) {} >>> analyze_numbers([-1, -2, -2, -3, -1, -2, -4]) {-1: {'frequency': 2, 'indices': [0, 4]}, -2: {'frequency': 3, 'indices': [1, 2, 5]}, -3: {'frequency': 1, 'indices': [3]}, -4: {'frequency': 1, 'indices': [6]}} >>> analyze_numbers([1, -1, 2, -2, 1, -2, 0]) {1: {'frequency': 2, 'indices': [0, 4]}, -1: {'frequency': 1, 'indices': [1]}, 2: {'frequency': 1, 'indices': [2]}, -2: {'frequency': 2, 'indices': [3, 5]}, 0: {'frequency': 1, 'indices': [6]}}","solution":"def analyze_numbers(numbers): Analyzes the input list of numbers and returns a dictionary with information about the frequency and indices of each unique number. Arguments: numbers -- list of integers Returns: dict -- a dictionary where keys are the unique integers from the list, and values are dictionaries with 'frequency' and 'indices'. result = {} for index, number in enumerate(numbers): if number not in result: result[number] = {'frequency': 0, 'indices': []} result[number]['frequency'] += 1 result[number]['indices'].append(index) return result"},{"question":"def sort_students(student_scores): Sorts the list of student scores first by score in descending order and then by name alphabetically if scores are the same. Args: student_scores (list of tuple): A list where each tuple contains a student's name (str) and score (int). Returns: list of tuple: The sorted list of student scores. Example: >>> sort_students([('Alice', 88), ('Bob', 95), ('Charlie', 88), ('David', 95)]) [('Bob', 95), ('David', 95), ('Alice', 88), ('Charlie', 88)] >>> sort_students([]) [] >>> sort_students([('Alice', 88)]) [('Alice', 88)] >>> sort_students([('Adam', 88), ('Adam', 95), ('Adam', 78)]) [('Adam', 95), ('Adam', 88), ('Adam', 78)] >>> sort_students([('Charlie', 88), ('Alice', 88), ('Bob', 88)]) [('Alice', 88), ('Bob', 88), ('Charlie', 88)] >>> sort_students([('Zoe', 90), ('John', 45), ('Abby', 67), ('Rachel', 74)]) [('Zoe', 90), ('Rachel', 74), ('Abby', 67), ('John', 45)]","solution":"def sort_students(student_scores): Sorts the list of student scores first by score in descending order and then by name alphabetically if scores are the same. Args: student_scores (list of tuple): A list where each tuple contains a student's name (str) and score (int). Returns: list of tuple: The sorted list of student scores. # Sort primarily by score in descending order and secondarily by name in ascending order return sorted(student_scores, key=lambda student: (-student[1], student[0]))"},{"question":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. Parameters: arr1 (list of int): First sorted array. arr2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 2, 3], [2, 2, 4, 5]) [1, 2, 2, 2, 2, 3, 4, 5] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([2], [1]) [1, 2] >>> merge_sorted_arrays([1, 2, 3, 5], [0, 6, 7, 8, 9, 10]) [0, 1, 2, 3, 5, 6, 7, 8, 9, 10] >>> merge_sorted_arrays([0, 6, 7, 8, 9, 10], [1, 2, 3, 5]) [0, 1, 2, 3, 5, 6, 7, 8, 9, 10]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list of int): First sorted array. arr2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements from both arrays, if any while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"import numpy as np def intersection(array1: np.ndarray, array2: np.ndarray) -> np.ndarray: Returns a numpy array containing unique elements that are present in both array1 and array2. >>> array1 = np.array([1, 2, 3, 4, 5]) >>> array2 = np.array([4, 5, 6, 7, 8]) >>> intersection(array1, array2) array([4, 5]) >>> array1 = np.array([1, 2, 3]) >>> array2 = np.array([4, 5, 6]) >>> intersection(array1, array2) array([]) >>> array1 = np.array([1, 2, 3]) >>> array2 = np.array([1, 2, 3]) >>> intersection(array1, array2) array([1, 2, 3]) >>> array1 = np.array([1, 4, 5, 10]) >>> array2 = np.array([9, 4, 8]) >>> intersection(array1, array2) array([4]) def test_intersection_common_elements(): array1 = np.array([1, 2, 3, 4, 5]) array2 = np.array([4, 5, 6, 7, 8]) result = intersection(array1, array2) expected = np.array([4, 5]) assert np.array_equal(result, expected) def test_intersection_no_common_elements(): array1 = np.array([1, 2, 3]) array2 = np.array([4, 5, 6]) result = intersection(array1, array2) expected = np.array([]) assert np.array_equal(result, expected) def test_intersection_all_elements_common(): array1 = np.array([1, 2, 3]) array2 = np.array([1, 2, 3]) result = intersection(array1, array2) expected = np.array([1, 2, 3]) assert np.array_equal(result, expected) def test_intersection_single_common_element(): array1 = np.array([1, 4, 5, 10]) array2 = np.array([9, 4, 8]) result = intersection(array1, array2) expected = np.array([4]) assert np.array_equal(result, expected)","solution":"import numpy as np def intersection(array1, array2): Returns a numpy array containing unique elements that are present in both array1 and array2. # Find the intersection of the two arrays result = np.intersect1d(array1, array2) return result"},{"question":"from collections import OrderedDict class LRUCache: This class implements a Least Recently Used (LRU) Cache using OrderedDict. It supports \`get\` and \`put\` operations to retrieve and insert values. When the cache reaches its capacity, it invalidates the least recently used item before inserting a new one. def __init__(self, capacity: int): Initialize the LRU Cache with a given capacity. pass def get(self, key: int) -> int: Retrieve the value of the key if the key exists in the cache, otherwise return -1. pass def put(self, key: int, value: int) -> None: Insert the value if the key is not already present. When the cache reaches its capacity, invalidate the least recently used item before inserting the new item. pass def test_cache_capacity_one(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 cache.put(2, 2) assert cache.get(1) == -1 assert cache.get(2) == 2 def test_cache_usage(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) assert cache.get(2) == -1 assert cache.get(3) == 3 def test_cache_overwrite(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(2, 20) assert cache.get(2) == 20 assert cache.get(1) == 1 def test_cache_eviction_order(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # Access key 1 to make it recently used cache.put(3, 3) # Least recently used key 2 should be evicted assert cache.get(2) == -1 assert cache.get(1) == 1 assert cache.get(3) == 3 def test_cache_replace(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == -1 cache.put(4, 4) assert cache.get(2) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU Cache with a given capacity. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Retrieve the value of the key if the key exists in the cache, otherwise return -1. if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: Insert the value if the key is not already present. When the cache reaches its capacity, invalidate the least recently used item before inserting the new item. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"from typing import List, Tuple def top_n_frequent_strings(strings: List[str], N: int) -> List[Tuple[str, int]]: Create a function that takes a list of strings (which can include repeated strings) and a positive integer N, and returns the N most frequently occurring strings along with their frequencies. If two or more strings have the same frequency, they should be sorted in alphabetical order. The function should handle large lists efficiently. Args: strings (List[str]): The list of strings (which can include repeated strings). N (int): A positive integer specifying the number of most frequently occurring strings to return. Returns: List[Tuple[str, int]]: A list of tuples containing the N most frequently occurring strings and their frequencies. Example usage: >>> top_n_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2) [('apple', 3), ('banana', 2)] >>> top_n_frequent_strings([\\"apple\\", \\"banana\\", \\"cherry\\", \\"banana\\", \\"cherry\\", \\"apple\\"], 2) [('apple', 2), ('banana', 2)] >>> top_n_frequent_strings([\\"apple\\", \\"banana\\", \\"banana\\", \\"cherry\\", \\"cherry\\", \\"banana\\"], 2) [('banana', 3), ('cherry', 2)] >>> top_n_frequent_strings([\\"apple\\"], 1) [('apple', 1)] >>> top_n_frequent_strings([], 2) [] >>> top_n_frequent_strings([\\"apple\\", \\"banana\\", \\"banana\\", \\"cherry\\", \\"cherry\\", \\"banana\\"], 10) [('banana', 3), ('cherry', 2), ('apple', 1)] >>> top_n_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 0) [] >>> top_n_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], -3) []","solution":"from collections import Counter from typing import List, Tuple def top_n_frequent_strings(strings: List[str], N: int) -> List[Tuple[str, int]]: Returns the N most frequently occurring strings along with their frequencies. If two or more strings have the same frequency, they are sorted in alphabetical order. Args: strings (List[str]): The list of strings (which can include repeated strings). N (int): The number of most frequently occurring strings to return. Returns: List[Tuple[str, int]]: A list of tuples containing the N most frequently occurring strings and their frequencies. if N <= 0: return [] # Count the frequencies of each string counted_strings = Counter(strings) # Get the N most common elements, with ties resolved alphabetically most_common_strings = counted_strings.most_common() most_common_strings.sort(key=lambda x: (-x[1], x[0])) return most_common_strings[:N]"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Check if two strings are anagrams of each other. Two strings are anagrams if they can be written using the exact same characters (whitespace and punctuation included), just with a different arrangement. The solution does not use any libraries or helper functions for sorting or counting. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False >>> are_anagrams(\\"a gentleman\\", \\"elegant man\\") True >>> are_anagrams(\\"the#quick!brown?fox\\", \\"brown!fox?the#quick\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") False","solution":"def are_anagrams(s1, s2): Check if two strings are anagrams of each other. Two strings are anagrams if they can be written using the exact same characters (whitespace and punctuation included), just with a different arrangement. The solution does not use any libraries or helper functions for sorting or counting. if len(s1) != len(s2): return False # Initialize a dictionary to count characters char_count = {} # Count characters in s1 for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Subtract the count of characters in s2 for char in s2: if char in char_count: char_count[char] -= 1 else: return False # Check if all counts are zero for count in char_count.values(): if count != 0: return False return True"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Determine if \`s\` can be segmented into a space-separated sequence of one or more dictionary words. >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"a\\", [\\"a\\"]) True >>> word_break(\\"b\\", [\\"a\\"]) False >>> word_break(\\"aaaaaaa\\", [\\"aaaa\\", \\"aaa\\"]) True >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) True >>> word_break(\\"\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"abcabcab\\", [\\"abc\\", \\"bca\\"]) False >>> word_break(\\"abababab\\", [\\"ab\\", \\"aba\\"]) True","solution":"from typing import List def word_break(s: str, wordDict: List[str]) -> bool: word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # base case: an empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def max_gold(grid: List[List[int]]) -> int: Compute the maximum amount of gold collected starting from any cell in the first row and ending in any cell in the last row. >>> max_gold([ ... [0, 1, 4, 2], ... [4, 3, 6, 5], ... [1, 2, 5, 3], ... [2, 8, 7, 6] ... ]) 23 >>> max_gold([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 0 >>> max_gold([[5]]) 5 >>> max_gold([ ... [1, 0, 0, 0], ... [0, 2, 0, 0], ... [0, 0, 3, 0], ... [0, 0, 0, 4] ... ]) 10 >>> max_gold([ ... [100, 100, 100, 100], ... [100, 100, 100, 100], ... [100, 100, 100, 100], ... [100, 100, 100, 100] ... ]) 400","solution":"from typing import List def max_gold(grid: List[List[int]]) -> int: n = len(grid) # Create a dp array to store the maximum gold collected from each cell to the bottom dp = [[0] * n for _ in range(n)] # Initialize the dp array with the values of the gold in the last row for j in range(n): dp[n-1][j] = grid[n-1][j] # Fill the dp array bottom-up for i in range(n-2, -1, -1): for j in range(n): if j > 0 and j < n-1: dp[i][j] = grid[i][j] + max(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]) elif j == 0: dp[i][j] = grid[i][j] + max(dp[i+1][j], dp[i+1][j+1]) else: dp[i][j] = grid[i][j] + max(dp[i+1][j-1], dp[i+1][j]) # The answer is the maximum value in the first row of dp array return max(dp[0])"},{"question":"def isSubsequence(s: str, t: str) -> bool: Determine if string t can be obtained by deleting some characters from string s without changing the order of the remaining characters. :param s: The original string from which characters can be deleted. :param t: The target string to obtain. :return: True if t can be obtained from s, otherwise False. Example: >>> isSubsequence(\\"abcde\\", \\"ace\\") True >>> isSubsequence(\\"abcde\\", \\"aec\\") False","solution":"def isSubsequence(s: str, t: str) -> bool: Determine if string t can be obtained by deleting some characters from string s without changing the order of the remaining characters. :param s: The original string from which characters can be deleted. :param t: The target string to obtain. :return: True if t can be obtained from s, otherwise False. t_index = 0 t_length = len(t) for char in s: if t_index < t_length and char == t[t_index]: t_index += 1 return t_index == t_length"},{"question":"def elements_appear_twice(lst): Returns a list of elements that appear exactly twice in the input list. Parameters: lst (List[int]): A list of integers. Returns: List[int]: A list containing elements that appear exactly twice in lst.","solution":"def elements_appear_twice(lst): Returns a list of elements that appear exactly twice in the input list. Parameters: lst (List[int]): A list of integers. Returns: List[int]: A list containing elements that appear exactly twice in lst. element_counter = {} # Count the occurrences of each element in lst for num in lst: if num in element_counter: element_counter[num] += 1 else: element_counter[num] = 1 # Collect and return elements that appear exactly twice result = [num for num, count in element_counter.items() if count == 2] return result"},{"question":"def highest_paid_employee(employees): Returns the name of the highest-paid employee. If there are multiple employees with the highest salary, returns a list of their names in alphabetical order. Args: employees (list): A list of dictionaries with 'name' and 'salary' keys. Returns: str or list: The name of the highest-paid employee or a list of names if there are multiple employees with the highest salary. # Test cases def test_single_highest_paid(): employees = [ {'name': 'Alice', 'salary': 5000}, {'name': 'Bob', 'salary': 4000}, {'name': 'Charlie', 'salary': 3000}, ] assert highest_paid_employee(employees) == 'Alice' def test_multiple_highest_paid(): employees = [ {'name': 'Alice', 'salary': 4000}, {'name': 'Bob', 'salary': 4000}, {'name': 'Charlie', 'salary': 3000}, ] assert highest_paid_employee(employees) == ['Alice', 'Bob'] def test_empty_list(): employees = [] assert highest_paid_employee(employees) == None def test_alphabetical_order(): employees = [ {'name': 'Charlie', 'salary': 5000}, {'name': 'Bob', 'salary': 5000}, {'name': 'Alice', 'salary': 5000}, ] assert highest_paid_employee(employees) == ['Alice', 'Bob', 'Charlie'] def test_single_employee(): employees = [ {'name': 'Alice', 'salary': 5000}, ] assert highest_paid_employee(employees) == 'Alice'","solution":"def highest_paid_employee(employees): Returns the name of the highest-paid employee. If there are multiple employees with the highest salary, returns a list of their names in alphabetical order. Args: employees (list): A list of dictionaries with 'name' and 'salary' keys. Returns: str or list: The name of the highest-paid employee or a list of names if there are multiple employees with the highest salary. if not employees: return None max_salary = max(employee['salary'] for employee in employees) highest_paid = [employee['name'] for employee in employees if employee['salary'] == max_salary] if len(highest_paid) == 1: return highest_paid[0] return sorted(highest_paid)"},{"question":"from typing import List def find_missing_numbers(arr: List[int]) -> List[int]: Returns an array of integers that are missing from the range defined by the minimum and maximum values in the input array. >>> find_missing_numbers([]) == [] >>> find_missing_numbers([1, 2, 3, 4, 5]) == [] >>> find_missing_numbers([4, 7, 9, 4, 8]) == [5, 6] >>> find_missing_numbers([1, 1, 1, 1, 1]) == [] >>> find_missing_numbers([-3, -1, 2, 3, 7]) == [-2, 0, 1, 4, 5, 6] >>> find_missing_numbers([5]) == []","solution":"from typing import List def find_missing_numbers(arr: List[int]) -> List[int]: Returns an array of integers that are missing from the range defined by the minimum and maximum values in the input array. if not arr: return [] min_val = min(arr) max_val = max(arr) full_range = set(range(min_val, max_val + 1)) arr_set = set(arr) missing_numbers = sorted(full_range - arr_set) return missing_numbers"},{"question":"def unique_characters_strings(strings): Given a list of strings, return a list of all strings that consist of unique characters. E.g.: >>> unique_characters_strings([\\"hello\\", \\"world\\", \\"python\\", \\"abc\\"]) [\\"world\\", \\"python\\", \\"abc\\"] >>> unique_characters_strings([\\"aaa\\", \\"bbb\\", \\"ccc\\"]) [] >>> unique_characters_strings([\\"\\", \\"xyz\\", \\"test\\", \\"unit\\"]) [\\"\\", \\"xyz\\", \\"unit\\"] # Your code starts here def test_unique_characters_strings(): assert unique_characters_strings([\\"hello\\", \\"world\\", \\"python\\", \\"abc\\"]) == [\\"world\\", \\"python\\", \\"abc\\"] assert unique_characters_strings([\\"aaa\\", \\"bbb\\", \\"ccc\\"]) == [] assert unique_characters_strings([\\"\\", \\"xyz\\", \\"test\\", \\"unit\\"]) == [\\"\\", \\"xyz\\", \\"unit\\"] assert unique_characters_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"aab\\"]) == [\\"a\\", \\"ab\\", \\"abc\\"] assert unique_characters_strings([]) == [] assert unique_characters_strings([\\"123\\", \\"112\\", \\"321\\"]) == [\\"123\\", \\"321\\"] assert unique_characters_strings([\\"A\\", \\"a\\", \\"Aa\\", \\"aa\\"]) == [\\"A\\", \\"a\\", \\"Aa\\"] assert unique_characters_strings([\\"a!\\", \\"@!\\"]) == [\\"a!\\", \\"@!\\"]","solution":"def unique_characters_strings(strings): Given a list of strings, return a list of all strings that consist of unique characters. E.g.: >>> unique_characters_strings([\\"hello\\", \\"world\\", \\"python\\", \\"abc\\"]) [\\"world\\", \\"python\\", \\"abc\\"] >>> unique_characters_strings([\\"aaa\\", \\"bbb\\", \\"ccc\\"]) [] >>> unique_characters_strings([\\"\\", \\"xyz\\", \\"test\\", \\"unit\\"]) [\\"\\", \\"xyz\\", \\"unit\\"] result = [] for s in strings: if len(s) == len(set(s)): result.append(s) return result"},{"question":"def findMissingPositive(nums: List[int]) -> int: Find the first missing positive integer in an unsorted array. Args: nums (List[int]): The input array Returns: int: The smallest missing positive integer Examples: >>> findMissingPositive([3, 4, -1, 1]) 2 >>> findMissingPositive([1, 2, 3]) 4 >>> findMissingPositive([-1, -2, 3, 4]) 1 # Implement the function here. # Unit Tests def test_example_case(): assert findMissingPositive([3, 4, -1, 1]) == 2 def test_all_positive_sequential(): assert findMissingPositive([1, 2, 3]) == 4 def test_all_positive_with_gap(): assert findMissingPositive([1, 2, 4, 5]) == 3 def test_contains_negative_numbers(): assert findMissingPositive([-1, -2, 3, 4]) == 1 def test_all_negatives(): assert findMissingPositive([-1, -2, -3]) == 1 def test_empty_array(): assert findMissingPositive([]) == 1 def test_single_element_missing_one(): assert findMissingPositive([2]) == 1 def test_single_element_one(): assert findMissingPositive([1]) == 2 def test_duplicates(): assert findMissingPositive([1, 1, 0, -1, 3, 2]) == 4","solution":"def findMissingPositive(nums): n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for j in range(n): if nums[j] != j + 1: return j + 1 return n + 1 # Example usage arr = [3, 4, -1, 1] print(findMissingPositive(arr)) # Expected output: 2"},{"question":"class LRUCache: LRUCache class that simulates the functioning of a limited-capacity LRU (Least Recently Used) Cache. Methods: - get(key): Returns the value of the key if the key exists in the cache, otherwise returns -1. - put(key, value): Insert or sets the value for the key. If the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item. >>> lru_cache = LRUCache(2) >>> lru_cache.put(1, 1) >>> lru_cache.put(2, 2) >>> lru_cache.get(1) == 1 >>> lru_cache.put(3, 3) >>> lru_cache.get(2) == -1 >>> lru_cache.put(4, 4) >>> lru_cache.get(1) == -1 >>> lru_cache.get(3) == 3 >>> lru_cache.get(4) == 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) new_node = Node(key, value) self._add(new_node) self.cache[key] = new_node if len(self.cache) > self.capacity: lru = self.tail.prev self._remove(lru) del self.cache[lru.key]"},{"question":"def filter_greater_than_threshold(numbers: List[int], threshold: int) -> List[int]: Returns a new list with the integers from the original list that are greater than the given threshold. Args: numbers (list of int): List of integers. threshold (int): The threshold value. Returns: list of int: List of integers greater than the threshold. >>> filter_greater_than_threshold([1, 2, 3, 4, 5], 3) [4, 5] >>> filter_greater_than_threshold([1, 2, 3], 3) [] >>> filter_greater_than_threshold([-5, 0, 5, 10], -1) [0, 5, 10] >>> filter_greater_than_threshold([5, 10, 15], 0) [5, 10, 15] >>> filter_greater_than_threshold([], 3) []","solution":"def filter_greater_than_threshold(numbers, threshold): Returns a new list with the integers from the original list that are greater than the given threshold. Args: numbers (list of int): List of integers. threshold (int): The threshold value. Returns: list of int: List of integers greater than the threshold. return [num for num in numbers if num > threshold]"},{"question":"def second_smallest(nums: List[int]) -> int: Returns the second smallest integer in the list. If the list has fewer than two distinct integers, return None. >>> second_smallest([3, 1, 4, 1, 2]) == 2 >>> second_smallest([4, 1, 4, 3, 1, 2, 2]) == 2 >>> second_smallest([4, 1]) == 4 >>> second_smallest([5, 5, 5]) == None >>> second_smallest([10]) == None >>> second_smallest([]) == None >>> second_smallest([-10, -30, -20]) == -20 >>> second_smallest([-1, -2, 0, 2, 1]) == -1","solution":"def second_smallest(nums): Returns the second smallest integer in the list. If the list has fewer than two distinct integers, return None. if len(nums) < 2: return None first_smallest = second_smallest = float('inf') # Iterate through the list to find the smallest and second smallest integers for num in nums: if num < first_smallest: second_smallest = first_smallest first_smallest = num elif first_smallest < num < second_smallest: second_smallest = num # Check if second_smallest was updated if second_smallest == float('inf'): return None return second_smallest"},{"question":"def binary_search(sorted_list, target): Implements the binary search algorithm to find the index of the target value within a sorted list. If the target does not exist in the list, returns -1. >>> binary_search([1, 2, 3, 4, 5, 6], 4) == 3 >>> binary_search(['apple', 'banana', 'cherry', 'date'], 'cherry') == 2 >>> binary_search([], 5) == -1 >>> binary_search([1], 1) == 0 >>> binary_search(['a'], 'b') == -1 pass","solution":"def binary_search(sorted_list, target): Implements the binary search algorithm to find the index of the target value within a sorted list. If the target does not exist in the list, returns -1. left, right = 0, len(sorted_list) - 1 while left <= right: middle = (left + right) // 2 if sorted_list[middle] == target: return middle elif sorted_list[middle] < target: left = middle + 1 else: right = middle - 1 return -1"},{"question":"import random def generate_random_list(size, lower_bound, upper_bound): Generate a list of \`size\` random integers between \`lower_bound\` and \`upper_bound\`. return [random.randint(lower_bound, upper_bound) for _ in range(size)] def filter_odd_numbers(input_list): Filter out and return only the odd numbers from the provided list \`input_list\`. >>> filter_odd_numbers([1, 2, 3, 4, 5]) [1, 3, 5] >>> filter_odd_numbers([2, 4, 6]) [] def find_max_number(input_list): Find and return the maximum number in the provided list \`input_list\`. >>> find_max_number([1, 2, 3, 4, 5]) 5 >>> find_max_number([1]) 1 >>> find_max_number([]) None def sort_descending(input_list): Sort and return the provided list \`input_list\` in descending order. >>> sort_descending([3, 1, 2, 5, 4]) [5, 4, 3, 2, 1] >>> sort_descending([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> sort_descending([3, 3, 1, 2, 6, 5, 7, 4]) [7, 6, 5, 4, 3, 3, 2, 1]","solution":"import random def generate_random_list(size, lower_bound, upper_bound): Generate a list of \`size\` random integers between \`lower_bound\` and \`upper_bound\`. return [random.randint(lower_bound, upper_bound) for _ in range(size)] def filter_odd_numbers(input_list): Filter out and return only the odd numbers from the provided list \`input_list\`. return [x for x in input_list if x % 2 != 0] def find_max_number(input_list): Find and return the maximum number in the provided list \`input_list\`. if not input_list: # handle empty list case return None return max(input_list) def sort_descending(input_list): Sort and return the provided list \`input_list\` in descending order. return sorted(input_list, reverse=True)"},{"question":"from typing import List def n_largest_unique_elements(lst: List[int], n: int) -> List[int]: Returns the n largest unique elements from the list in descending order. If the list contains fewer than n unique elements, return all unique elements in descending order. If the list is empty or n is zero, return an empty list. >>> n_largest_unique_elements([1, 2, 3, 4, 5], 3) [5, 4, 3] >>> n_largest_unique_elements([5, 4, 3, 2, 1], 3) [5, 4, 3] >>> n_largest_unique_elements([1, 1, 2, 2, 3], 5) [3, 2, 1] >>> n_largest_unique_elements([4, 4, 4], 2) [4] >>> n_largest_unique_elements([], 3) [] >>> n_largest_unique_elements([1, 2, 3], 0) [] >>> n_largest_unique_elements([1, 1, 2, 2, 3, 3], 2) [3, 2] >>> n_largest_unique_elements([1, 1, 1, 1, 1], 1) [1]","solution":"def n_largest_unique_elements(lst, n): Returns the n largest unique elements from the list in descending order. If the list contains fewer than n unique elements, return all unique elements in descending order. If the list is empty or n is zero, return an empty list. if n == 0 or not lst: return [] # Get the unique elements unique_elements = list(set(lst)) # Sort in descending order unique_elements.sort(reverse=True) # Return the first n elements return unique_elements[:n]"},{"question":"def has_unique_characters(s: str) -> bool: Determines if the provided string contains only unique characters. Args: s (str): The input string to be checked. Returns: bool: True if all characters in the string are unique, False otherwise. >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"aabbcc\\") False >>> has_unique_characters(\\"1234567890\\") True >>> has_unique_characters(\\"11234567890\\") False >>> has_unique_characters(\\"!@#%^&*()\\") True >>> has_unique_characters(\\"!@#%^&*()!\\") False","solution":"def has_unique_characters(s): Determines if the provided string contains only unique characters. Args: s (str): The input string to be checked. Returns: bool: True if all characters in the string are unique, False otherwise. return len(set(s)) == len(s)"},{"question":"from typing import List def min_cost_traverse(grid: List[List[int]]) -> int: Returns the minimum cost to traverse from any cell in the top row to any cell in the bottom row. >>> min_cost_traverse([ ... [10, 5, 20], ... [30, 15, 10], ... [25, 10, 5] ... ]) 20 >>> min_cost_traverse([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 12 pass def test_basic_case(): grid = [ [10, 5, 20], [30, 15, 10], [25, 10, 5] ] assert min_cost_traverse(grid) == 20 def test_simple_case(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_cost_traverse(grid) == 12 def test_single_column(): grid = [ [5], [1], [2], [3] ] assert min_cost_traverse(grid) == 11 def test_single_row(): grid = [ [5, 6, 7] ] assert min_cost_traverse(grid) == 5 def test_large_values(): grid = [ [100, 1, 100], [1, 100, 1], [100, 1, 100] ] assert min_cost_traverse(grid) == 3 def test_universal_cost(): grid = [ [2, 2], [2, 2] ] assert min_cost_traverse(grid) == 4 def test_all_zeros(): grid = [ [0, 0], [0, 0] ] assert min_cost_traverse(grid) == 0","solution":"from typing import List def min_cost_traverse(grid: List[List[int]]) -> int: Returns the minimum cost to traverse from any cell in the top row to any cell in the bottom row. n = len(grid) m = len(grid[0]) # Initialize a DP table with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Fill the first row of the dp table with the values of the first row of the grid for j in range(m): dp[0][j] = grid[0][j] # Fill the rest of the dp table for i in range(1, n): for j in range(m): # Initialize the minimum cost to a very large number min_cost = float('inf') # Check the cell directly above min_cost = min(min_cost, dp[i-1][j]) # Check the cell diagonally left above if j > 0: min_cost = min(min_cost, dp[i-1][j-1]) # Check the cell diagonally right above if j < m - 1: min_cost = min(min_cost, dp[i-1][j+1]) dp[i][j] = grid[i][j] + min_cost # The result is the minimum value in the last row of the dp table return min(dp[n-1])"},{"question":"def reverse_words(sentence): Return a sentence with the order of words reversed. >>> reverse_words('hello world') 'world hello' >>> reverse_words('a b c') 'c b a' >>> reverse_words('') ''","solution":"def reverse_words(sentence): Return a sentence with the order of words reversed. :param sentence: string, input sentence :return: string, sentence with the order of words reversed # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a new sentence return ' '.join(reversed_words)"},{"question":"import re def are_anagrams(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams of each other, else returns False. This function is case-insensitive and ignores spaces and punctuation. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"conversation\\", \\"voices rant on\\") True >>> are_anagrams(\\"a gentleman\\", \\"elegant man!\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Hello\\", \\"oLleH\\") True >>> are_anagrams(\\"123 abc!!!\\", \\"cba 321!!\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"notempty\\", \\"\\") False >>> are_anagrams(\\"same\\", \\"same\\") True","solution":"import re def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams of each other, else returns False. This function is case-insensitive and ignores spaces and punctuation. # Remove any non-alphabetic characters and convert to lower case cleaned_str1 = re.sub(r'[^a-zA-Z]', '', str1).lower() cleaned_str2 = re.sub(r'[^a-zA-Z]', '', str2).lower() # Sort the characters of both strings and compare return sorted(cleaned_str1) == sorted(cleaned_str2)"},{"question":"def sorted_squares(nums): Returns a list of the squares of each integer in the input list, sorted in non-decreasing order. The function works in O(n) time complexity. >>> sorted_squares([-4, -1, 0, 3, 10]) == [0, 1, 9, 16, 100] >>> sorted_squares([-7, -3, -2, -1]) == [1, 4, 9, 49] >>> sorted_squares([1, 2, 3, 5, 6]) == [1, 4, 9, 25, 36] >>> sorted_squares([5]) == [25] >>> sorted_squares([-5]) == [25] >>> sorted_squares([]) == [] >>> sorted_squares([-10000, -5000, 5000, 10000]) == [25000000, 25000000, 100000000, 100000000]","solution":"def sorted_squares(nums): Returns a list of the squares of each integer in the input list, sorted in non-decreasing order. The function works in O(n) time complexity. n = len(nums) left, right = 0, n - 1 result = [0] * n position = n - 1 while left <= right: left_square = nums[left] ** 2 right_square = nums[right] ** 2 if left_square > right_square: result[position] = left_square left += 1 else: result[position] = right_square right -= 1 position -= 1 return result"},{"question":"def count_integers(int_list): Returns a dictionary where the keys are the unique integers from the list and the values are the counts of each integer. >>> count_integers([3, 5, 3, 2, 5, 3]) {3: 3, 5: 2, 2: 1} >>> count_integers([1, 2, 3, 4, 5]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> count_integers([1, 1, 1, 1, 1]) {1: 5} >>> count_integers([-1, -2, -1, 3, 2, -1]) {-1: 3, -2: 1, 3: 1, 2: 1} >>> count_integers([]) {} >>> count_integers([5]) {5: 1}","solution":"def count_integers(int_list): Returns a dictionary where the keys are the unique integers from the list and the values are the counts of each integer. counts = {} for num in int_list: if num in counts: counts[num] += 1 else: counts[num] = 1 return counts"},{"question":"import numpy as np import pandas as pd from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor from sklearn.model_selection import train_test_split from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error from sklearn.impute import SimpleImputer from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.feature_selection import SelectFromModel import matplotlib.pyplot as plt def build_and_evaluate_model(dataset, use_random_forest=True): Build and evaluate a regression model (Random Forest or Gradient Boosting) on the given dataset. Parameters: dataset (pd.DataFrame): The dataset containing house prices and associated features. use_random_forest (bool): Flag to choose the regressor (True for Random Forest, False for Gradient Boosting). Returns: dict: A dictionary containing R-squared, MAE, RMSE values. >>> data = { ... 'region': ['A', 'B', 'A', 'B', 'C', 'C', 'A', 'B', 'C', 'A'], ... 'size': [1200, 1300, 1000, 1100, 1050, 1150, 1250, 1350, 1250, 1450], ... 'bedrooms': [3, 4, 2, 2, 3, 3, 4, 4, 4, 3], ... 'price': [300000, 350000, 200000, 250000, 230000, 300000, 320000, 340000, 330000, 400000] ... } >>> dataset = pd.DataFrame(data) >>> result = build_and_evaluate_model(dataset, use_random_forest=True) >>> 'R-squared' in result True >>> 'MAE' in result True >>> 'RMSE' in result True >>> result = build_and_evaluate_model(dataset, use_random_forest=False) >>> 'R-squared' in result True >>> 'MAE' in result True >>> 'RMSE' in result True # Your code implementation here","solution":"import numpy as np import pandas as pd from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor from sklearn.model_selection import train_test_split from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error from sklearn.impute import SimpleImputer from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.feature_selection import SelectFromModel import matplotlib.pyplot as plt def build_and_evaluate_model(dataset, use_random_forest=True): Build and evaluate a regression model (Random Forest or Gradient Boosting) on the given dataset. Parameters: dataset (pd.DataFrame): The dataset containing house prices and associated features. use_random_forest (bool): Flag to choose the regressor (True for Random Forest, False for Gradient Boosting). Returns: dict: A dictionary containing R-squared, MAE, RMSE values. # Separate features and target X = dataset.drop('price', axis=1) y = dataset['price'] # Identify categorical and numerical columns categorical_cols = X.select_dtypes(include=['object']).columns numerical_cols = X.select_dtypes(exclude=['object']).columns # Preprocessing for numerical data numerical_transformer = SimpleImputer(strategy='mean') # Preprocessing for categorical data categorical_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='most_frequent')), ('onehot', OneHotEncoder(handle_unknown='ignore')) ]) # Bundle preprocessing for numerical and categorical data preprocessor = ColumnTransformer( transformers=[ ('num', numerical_transformer, numerical_cols), ('cat', categorical_transformer, categorical_cols) ]) # Choose the model if use_random_forest: model = RandomForestRegressor(random_state=42) else: model = GradientBoostingRegressor(random_state=42) # Create and evaluate the pipeline clf = Pipeline(steps=[ ('preprocessor', preprocessor), ('feature_selection', SelectFromModel(RandomForestRegressor(random_state=42))), ('regressor', model) ]) # Split the dataset X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Fit the model clf.fit(X_train, y_train) # Make predictions y_pred = clf.predict(X_test) # Calculate evaluation metrics r2 = r2_score(y_test, y_pred) mae = mean_absolute_error(y_test, y_pred) rmse = np.sqrt(mean_squared_error(y_test, y_pred)) # Plot actual vs predicted values plt.figure(figsize=(10, 6)) plt.scatter(y_test, y_pred, alpha=0.5) plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2) plt.xlabel('Actual') plt.ylabel('Predicted') plt.title('Actual vs Predicted House Prices') plt.show() # Return performance metrics return {'R-squared': r2, 'MAE': mae, 'RMSE': rmse}"},{"question":"def reverse_words(sentence: str) -> str: Reverse the words in a given sentence without altering the word order. Reduces multiple spaces to a single space in the output and trims any leading or trailing spaces. >>> reverse_words(\\"The quick brown fox\\") \\"The quick brown fox\\" >>> reverse_words(\\" The sky is blue \\") \\"The sky is blue\\" >>> reverse_words(\\" hello world \\") \\"hello world\\" >>> reverse_words(\\"hello\\") \\"hello\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" \\") \\"\\" >>> reverse_words(\\" hello \\") \\"hello\\"","solution":"def reverse_words(sentence): Reverses the words in the given sentence without altering the word order. Reduces multiple spaces to a single space in the output. result = [] word = [] i = 0 length = len(sentence) while i < length: if sentence[i] != ' ': word.append(sentence[i]) elif word: result.append(''.join(word)) word = [] i += 1 if word: result.append(''.join(word)) return ' '.join(result)"},{"question":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None self.count = 1 class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a value into the BST. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) def find(self, value: int) -> bool: Check if a value exists in the BST. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.find(5) True >>> bst.find(8) False def find_kth_smallest(self, k: int) -> int: Return the k-th smallest value in the BST. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.insert(6) >>> bst.insert(8) >>> bst.find_kth_smallest(1) 2","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None self.count = 1 # To keep track of the size of the subtree including this node class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int) -> None: if value < node.value: if not node.left: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if not node.right: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) node.count += 1 def find(self, value: int) -> bool: return self._find_recursive(self.root, value) def _find_recursive(self, node: TreeNode, value: int) -> bool: if not node: return False if node.value == value: return True elif value < node.value: return self._find_recursive(node.left, value) else: return self._find_recursive(node.right, value) def find_kth_smallest(self, k: int) -> int: return self._find_kth_smallest_recursive(self.root, k) def _find_kth_smallest_recursive(self, node: TreeNode, k: int) -> int: left_count = node.left.count if node.left else 0 if k == left_count + 1: return node.value elif k <= left_count: return self._find_kth_smallest_recursive(node.left, k) else: return self._find_kth_smallest_recursive(node.right, k - left_count - 1)"},{"question":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: Implement a function \`longest_consecutive_subsequence\` that accepts a list of integers and returns the length of the longest consecutive subsequence present in the list. A subsequence is a sequence derived from another sequence where elements appear in the same order but not necessarily consecutively. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_subsequence([9, 1, 8, 2, 3, 5, 4, 6, 7]) == 9 >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([1, 3, 5, 7, 9]) == 1 def test_example_cases(): assert longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 assert longest_consecutive_subsequence([9, 1, 8, 2, 3, 5, 4, 6, 7]) == 9 assert longest_consecutive_subsequence([]) == 0 assert longest_consecutive_subsequence([1, 3, 5, 7, 9]) == 1 def test_single_element(): assert longest_consecutive_subsequence([7]) == 1 def test_identical_elements(): assert longest_consecutive_subsequence([5, 5, 5, 5]) == 1 def test_negative_numbers(): assert longest_consecutive_subsequence([-1, -2, -3, -5, -4, -8]) == 5 def test_mixed_numbers(): assert longest_consecutive_subsequence([-1, 0, 1, -2, 2, -3, 3]) == 7 def test_large_range(): assert longest_consecutive_subsequence(list(range(10**6 - 1000, 10**6))) == 1000 assert longest_consecutive_subsequence(list(range(-10**6, -10**6 + 1000))) == 1000","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest consecutive subsequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"import csv def calculate_total_sales(input_csv, output_csv): Create a Python script that reads a CSV file containing sales data, calculates the total sales for each product category, and writes the results to a new CSV file. The sales data CSV file has the following columns: 'ProductID', 'Category', 'ProductName', 'QuantitySold', and 'PricePerUnit'. The output CSV file should have columns: 'Category' and 'TotalSales'. >>> import os >>> input_csv = 'test_input_basic.csv' >>> output_csv = 'test_output_basic.csv' >>> >>> # Create test input CSV file >>> with open(input_csv, mode='w', newline='') as infile: >>> writer = csv.writer(infile) >>> writer.writerow(['ProductID', 'Category', 'ProductName', 'QuantitySold', 'PricePerUnit']) >>> writer.writerow(['1', 'Electronics', 'Smartphone', '10', '299.99']) >>> writer.writerow(['2', 'Electronics', 'TV', '5', '499.99']) >>> writer.writerow(['3', 'Furniture', 'Chair', '15', '59.99']) >>> >>> calculate_total_sales(input_csv, output_csv) >>> >>> # Read output CSV file and check contents >>> with open(output_csv, mode='r') as outfile: >>> reader = csv.DictReader(outfile) >>> result = {row['Category']: float(row['TotalSales']) for row in reader} >>> >>> assert result == {'Electronics': 10*299.99 + 5*499.99, 'Furniture': 15*59.99}","solution":"import csv def calculate_total_sales(input_csv, output_csv): try: sales_data = {} # Read the input CSV file with open(input_csv, mode='r') as infile: reader = csv.DictReader(infile) # Process each row for row in reader: try: category = row['Category'] quantity_sold = int(row['QuantitySold']) price_per_unit = float(row['PricePerUnit']) total_sale = quantity_sold * price_per_unit if category in sales_data: sales_data[category] += total_sale else: sales_data[category] = total_sale except (KeyError, ValueError): continue # Skip row if there are missing fields or incorrect data types # Write the results to the output CSV file with open(output_csv, mode='w', newline='') as outfile: fieldnames = ['Category', 'TotalSales'] writer = csv.DictWriter(outfile, fieldnames=fieldnames) writer.writeheader() for category, total_sales in sales_data.items(): writer.writerow({'Category': category, 'TotalSales': total_sales}) except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"def product_excluding_self(nums): Returns a new list where each integer is replaced with the product of all other integers in the original list, excluding the integer at that position. Args: nums (list): List of integers. Returns: list: List of integers after transformation. >>> product_excluding_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_excluding_self([5]) [1] >>> product_excluding_self([10, 2]) [2, 10] >>> product_excluding_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_excluding_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_excluding_self([]) []","solution":"def product_excluding_self(nums): Returns a new list where each integer is replaced with the product of all other integers in the original list, excluding the integer at that position. Args: nums (list): List of integers. Returns: list: List of integers after transformation. if not nums: return [] # Step 1: Create prefix and suffix products n = len(nums) prefix_products = [1] * n suffix_products = [1] * n # Calculate prefix products for i in range(1, n): prefix_products[i] = prefix_products[i-1] * nums[i-1] # Calculate suffix products for i in range(n-2, -1, -1): suffix_products[i] = suffix_products[i+1] * nums[i+1] # Step 2: Build the result array result = [1] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. >>> is_prime(2) True >>> is_prime(4) False def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([-10, -3, 0, 1, 11, 17, 20]) [11, 17]","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [num for num in numbers if isinstance(num, int) and is_prime(num)]"},{"question":"def shift_to_next_multiple_of_5(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is shifted to its next multiple of 5. :param numbers: List of integers :return: New list of integers, shifted to the next multiple of 5 >>> shift_to_next_multiple_of_5([12, 48, 7]) [15, 50, 10] >>> shift_to_next_multiple_of_5([-8, -3, -23]) [-5, 0, -20] >>> shift_to_next_multiple_of_5([0, 5, -10, 19, -18]) [0, 5, -10, 20, -15] >>> shift_to_next_multiple_of_5([10, -15, 0, -20, 5]) [10, -15, 0, -20, 5] >>> shift_to_next_multiple_of_5([]) []","solution":"def shift_to_next_multiple_of_5(numbers): Takes a list of integers and returns a new list where each integer is shifted to its next multiple of 5. :param numbers: List of integers :return: New list of integers, shifted to the next multiple of 5 return [(n + 5) // 5 * 5 if n % 5 != 0 else n for n in numbers]"},{"question":"def swap_dict_keys_values(d: dict) -> dict: Returns a new dictionary with the keys and values swapped. If the original dictionary has duplicate values, only one of the corresponding keys will be kept in the new dictionary. >>> swap_dict_keys_values({'a': 1, 'b': 2, 'c': 3}) {1: 'a', 2: 'b', 3: 'c'} >>> swap_dict_keys_values({'a': 1, 'b': 2, 'c': 3, 'd': 2}) {1: 'a', 2: 'd', 3: 'c'} >>> swap_dict_keys_values({}) {} >>> swap_dict_keys_values({'a': 1}) {1: 'a'} >>> swap_dict_keys_values({'a': 1, 'b': 1, 'c': 1}) {1: 'a'}","solution":"def swap_dict_keys_values(d): Returns a new dictionary with the keys and values swapped. If the original dictionary has duplicate values, only one of the corresponding keys will be kept in the new dictionary. return {v: k for k, v in d.items()}"},{"question":"from typing import List, Tuple def job_scheduler(jobs: List[Tuple[int, int]], max_workers: int) -> List[int]: Simulates a simplified job scheduler system. Args: jobs (List[Tuple[int, int]]): A list of tuples where each tuple contains a unique job identifier and the duration of the job. max_workers (int): The maximum number of jobs that can run simultaneously. Returns: List[int]: The order of job identifiers representing the optimized execution plan. >>> job_scheduler([(1, 3), (2, 5), (3, 2), (4, 1)], 2) [4, 3, 1, 2] >>> job_scheduler([(1, 3)], 1) [1] >>> job_scheduler([(1, 2), (2, 2), (3, 2)], 2) [1, 2, 3] >>> job_scheduler([(1, 3), (2, 3), (3, 3), (4, 3)], 2) [1, 2, 3, 4] >>> job_scheduler([(i, 1) for i in range(1, 101)], 5) list(range(1, 101))","solution":"from typing import List, Tuple import heapq def job_scheduler(jobs: List[Tuple[int, int]], max_workers: int) -> List[int]: Returns the order of job execution to minimize overall completion time. jobs: List of tuples each containing (job_id, duration) max_workers: Maximum number of workers that can run jobs simultaneously # Sort jobs by duration first, then by job_id secondarily jobs.sort(key=lambda x: (x[1], x[0])) result = [] workers = [] # Initialize time and index current_time = 0 index = 0 while index < len(jobs) or workers: while index < len(jobs) and len(workers) < max_workers: heapq.heappush(workers, (current_time + jobs[index][1], jobs[index][0])) index += 1 # Run the next job to completion next_completion_time, job_id = heapq.heappop(workers) result.append(job_id) # Update current_time to the time that job completes current_time = next_completion_time return result"},{"question":"def index_of_largest(nums: List[int]) -> int: Returns the index of the first occurrence of the largest integer in the list. Parameters: nums (list): List of integers Returns: int: Index of the first occurrence of the largest integer >>> index_of_largest([1, 3, 7, 7, 2, 5]) == 2 >>> index_of_largest([10]) == 0 >>> index_of_largest([5, 5, 5, 5]) == 0 >>> index_of_largest([-1, -4, -3, -1]) == 0 >>> index_of_largest([]) == -1 >>> index_of_largest([100, 200, 300, 400, 500]) == 4 >>> index_of_largest([5, 1, 2, 3, 4]) == 0","solution":"def index_of_largest(nums): Returns the index of the first occurrence of the largest integer in the list. Parameters: nums (list): List of integers Returns: int: Index of the first occurrence of the largest integer if not nums: return -1 max_val = max(nums) return nums.index(max_val)"},{"question":"def list_even_numbers(start: int, end: int) -> list: Implement a function that takes two integer inputs: a start value and an end value. The function should compute and return a list containing all the even numbers within this range, inclusive of the start and end values if they are even. If there are no even numbers in the range, the function should return an empty list. >>> list_even_numbers(3, 10) # returns [4, 6, 8, 10] >>> list_even_numbers(4, 10) # returns [4, 6, 8, 10] >>> list_even_numbers(5, 7) # returns [6] >>> list_even_numbers(1, 1) # returns [] pass def test_list_even_numbers(): assert list_even_numbers(3, 10) == [4, 6, 8, 10] assert list_even_numbers(4, 10) == [4, 6, 8, 10] assert list_even_numbers(5, 7) == [6] assert list_even_numbers(1, 1) == [] assert list_even_numbers(0, 0) == [0] assert list_even_numbers(2, 2) == [2] assert list_even_numbers(1, 2) == [2] assert list_even_numbers(10, 20) == [10, 12, 14, 16, 18, 20] assert list_even_numbers(11, 15) == [12, 14] assert list_even_numbers(-2, 2) == [-2, 0, 2] assert list_even_numbers(-10, -2) == [-10, -8, -6, -4, -2] def test_list_even_numbers_edge_cases(): assert list_even_numbers(0, 1) == [0] assert list_even_numbers(1, 3) == [2] assert list_even_numbers(-1, 1) == [0] assert list_even_numbers(-1, -1) == [] assert list_even_numbers(-2, -1) == [-2] # To run the tests, you would typically use the following command in your terminal: # pytest <test-file-name>.py","solution":"def list_even_numbers(start: int, end: int) -> list: Returns a list of all even numbers in the inclusive range from start to end. return [n for n in range(start, end + 1) if n % 2 == 0]"},{"question":"def find_longest_palindrome(s: str) -> str: Returns the longest palindromic substring within the input string s. Example: >>> find_longest_palindrome(\\"babad\\") \\"bab\\" # \\"aba\\" is also a valid answer.","solution":"def find_longest_palindrome(s: str) -> str: Returns the longest palindromic substring within the input string s. if not s: return \\"\\" n = len(s) start, max_length = 0, 1 for i in range(n): if i - max_length >= 1 and s[i-max_length-1:i+1] == s[i-max_length-1:i+1][::-1]: start = i - max_length - 1 max_length += 2 elif i - max_length >= 0 and s[i-max_length:i+1] == s[i-max_length:i+1][::-1]: start = i - max_length max_length += 1 return s[start:start + max_length]"},{"question":"def max_profit(prices): Write a function that takes a list of stock prices for a single stock, in chronological order, and returns the maximum profit possible from buying on one day and selling on another. If no profit is possible, return 0. Ensure your function runs in O(n) time complexity. >>> max_profit([10, 8, 9, 20]) 12 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 1, 5, 3, 6, 4]) 5 pass import unittest class TestMaxProfit(unittest.TestCase): def test_no_prices(self): self.assertEqual(max_profit([]), 0) def test_one_price(self): self.assertEqual(max_profit([10]), 0) def test_only_loss(self): self.assertEqual(max_profit([10, 9, 8]), 0) def test_gain(self): self.assertEqual(max_profit([10, 8, 9, 20]), 12) def test_early_buy_late_sell(self): self.assertEqual(max_profit([1, 2, 3, 4, 5]), 4) def test_interleaved(self): self.assertEqual(max_profit([7, 1, 5, 3, 6, 4]), 5) if __name__ == \\"__main__\\": unittest.main()","solution":"def max_profit(prices): min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform a level order traversal on a binary tree and return the values of the nodes level by level. >>> root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> level_order_traversal(None) [] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> level_order_traversal(root) [[1], [2, 3]] >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> level_order_traversal(root) [[1], [2, 3], [4]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Perform a level order traversal on a binary tree and return the values of the nodes level by level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Write a Python function that takes a list of integers and returns the product of all the elements in the list except the element at the current position. For example, given the list [1, 2, 3, 4], the function should return [24, 12, 8, 6]. You should not use division in your solution. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([3, 7]) [7, 3] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([5, 6, 7, 8, 9]) [3024, 2520, 2160, 1890, 1680] >>> product_except_self([]) [] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6]","solution":"def product_except_self(nums): Returns a list of the product of all elements except the one at the current position. length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length output = [1] * length # Calculate left products for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate output array for i in range(length): output[i] = left_products[i] * right_products[i] return output"},{"question":"def sum_of_digits(int_list): Accepts a list of integers and returns a new list where each integer is replaced by the sum of its digits. >>> sum_of_digits([123, 456, -789]) [6, 15, -24] >>> sum_of_digits([0, 34, -12]) [0, 7, -3]","solution":"def sum_of_digits(int_list): def digit_sum(n): return sum(int(d) for d in str(abs(n))) * (1 if n >= 0 else -1) return [digit_sum(x) for x in int_list]"},{"question":"from typing import List def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the resultant matrix. >>> matrix1 = [ ... [1, 2], ... [3, 4] ... ] >>> matrix2 = [ ... [5, 6], ... [7, 8] ... ] >>> matrix_multiply(matrix1, matrix2) [[19, 22], [43, 50]] >>> matrix1 = [ ... [2, 0], ... [1, 3] ... ] >>> matrix2 = [ ... [4, 5], ... [6, 7] ... ] >>> matrix_multiply(matrix1, matrix2) [[8, 10], [22, 26]]","solution":"from typing import List def matrix_multiply(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the resultant matrix. >>> matrix1 = [ ... [1, 2], ... [3, 4] ... ] >>> matrix2 = [ ... [5, 6], ... [7, 8] ... ] >>> matrix_multiply(matrix1, matrix2) [[19, 22], [43, 50]] >>> matrix1 = [ ... [2, 0], ... [1, 3] ... ] >>> matrix2 = [ ... [4, 5], ... [6, 7] ... ] >>> matrix_multiply(matrix1, matrix2) [[8, 10], [22, 26]] rows_m1 = len(matrix1) cols_m1 = len(matrix1[0]) cols_m2 = len(matrix2[0]) product = [[0] * cols_m2 for _ in range(rows_m1)] for i in range(rows_m1): for j in range(cols_m2): for k in range(cols_m1): product[i][j] += matrix1[i][k] * matrix2[k][j] return product"},{"question":"import numpy as np import matplotlib.pyplot as plt from sklearn.datasets import make_blobs from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score def get_clustering_evaluation(X, n_clusters=3): Performs K-Means clustering and returns the inertia and silhouette score. >>> X, _ = make_blobs(n_samples=300, centers=3, cluster_std=[1.0, 2.5, 0.5], random_state=42) >>> inertia, silhouette = get_clustering_evaluation(X, n_clusters=3) >>> isinstance(inertia, float) True >>> inertia > 0 True >>> isinstance(silhouette, float) True >>> 0 <= silhouette <= 1 True kmeans = KMeans(n_clusters=n_clusters, random_state=42) y_kmeans = kmeans.fit_predict(X) inertia = kmeans.inertia_ silhouette = silhouette_score(X, y_kmeans) return inertia, silhouette # Example usage of function and plot X, y = make_blobs(n_samples=300, centers=3, cluster_std=[1.0, 2.5, 0.5], random_state=42) kmeans = KMeans(n_clusters=3, random_state=42) y_kmeans = kmeans.fit_predict(X) # Plot the clusters and centroids plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='viridis') centroids = kmeans.cluster_centers_ plt.scatter(centroids[:, 0], centroids[:, 1], c='red', s=200, alpha=0.75, marker='X') plt.title('K-Means Clustering') plt.xlabel('Feature 1') plt.ylabel('Feature 2') plt.show()","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.datasets import make_blobs from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score # Generate synthetic dataset with 3 clusters and different standard deviations X, y = make_blobs(n_samples=300, centers=3, cluster_std=[1.0, 2.5, 0.5], random_state=42) # Create and fit the KMeans model kmeans = KMeans(n_clusters=3, random_state=42) y_kmeans = kmeans.fit_predict(X) # Compute the inertia and silhouette score inertia = kmeans.inertia_ silhouette = silhouette_score(X, y_kmeans) # Plot the clusters and centroids plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='viridis') centroids = kmeans.cluster_centers_ plt.scatter(centroids[:, 0], centroids[:, 1], c='red', s=200, alpha=0.75, marker='X') plt.title('K-Means Clustering') plt.xlabel('Feature 1') plt.ylabel('Feature 2') plt.show() def get_clustering_evaluation(X, n_clusters=3): Performs K-Means clustering and returns the inertia and silhouette score. kmeans = KMeans(n_clusters=n_clusters, random_state=42) y_kmeans = kmeans.fit_predict(X) inertia = kmeans.inertia_ silhouette = silhouette_score(X, y_kmeans) return inertia, silhouette"},{"question":"def describe_characters(s): Analyzes the character composition of the input string. For an input string composed of digits and lowercase letters, returns a list where each element describes the character at the corresponding position in the format: \\"Position X: Character (type)\\" If the input string contains any uppercase letters, return an error message. >>> describe_characters(\\"a1b2c3\\") [\\"Position 1: a (letter)\\", \\"Position 2: 1 (digit)\\", \\"Position 3: b (letter)\\", \\"Position 4: 2 (digit)\\", \\"Position 5: c (letter)\\", \\"Position 6: 3 (digit)\\"] >>> describe_characters(\\"z9y8x7\\") [\\"Position 1: z (letter)\\", \\"Position 2: 9 (digit)\\", \\"Position 3: y (letter)\\", \\"Position 4: 8 (digit)\\", \\"Position 5: x (letter)\\", \\"Position 6: 7 (digit)\\"] >>> describe_characters(\\"A1b2\\") ERROR","solution":"def describe_characters(s): Analyzes the character composition of the input string. For an input string composed of digits and lowercase letters, returns a list where each element describes the character at the corresponding position in the format: \\"Position X: Character (type)\\" If the input string contains any uppercase letters, return an error message. result = [] for i, char in enumerate(s): if char.isupper(): return \\"ERROR\\" if char.isdigit(): char_type = \\"digit\\" else: char_type = \\"letter\\" result.append(f\\"Position {i+1}: {char} ({char_type})\\") return result"},{"question":"def count_inversions(arr): Counts the number of inversion pairs in the given list using a modified merge sort algorithm. >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([2, 1]) 1 >>> count_inversions([2, 4, 1, 3, 5]) 3 >>> count_inversions([5, 4, 3, 2, 1]) 10 >>> count_inversions([]) 0 >>> count_inversions([1]) 0 >>> count_inversions([3, 1, 2, 5, 4]) 3","solution":"def count_inversions(arr): Counts the number of inversion pairs in the given list using a modified merge sort algorithm. def merge_and_count(arr, temp_arr, left, mid, right): Helper function to merge two halves and count inversions i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all elements left to i in the left subarray # are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): Helper function to divide the array and count inversions inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"def longest_increasing_subsequence(nums: List[int]) -> List[int]: Returns the longest increasing subsequence of the provided list of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) [2, 3, 7, 101] >>> longest_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2, 2]) [-1, 3, 4, 5] >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> longest_increasing_subsequence([3, 2]) [3] or [2] >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) [3, 7, 40, 80] >>> longest_increasing_subsequence([]) [] >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) [5] or [4] or [3] or [2] or [1] >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) [2] >>> longest_increasing_subsequence([10, 9, 20, 5, 6, 3, 10, 11]) [5, 6, 10, 11] >>> longest_increasing_subsequence([1]) [1] >>> longest_increasing_subsequence([2, 2, 1, 2]) [1, 2]","solution":"def longest_increasing_subsequence(nums): Returns the longest increasing subsequence of the provided list of integers. if not nums: return [] # Length of the input list n = len(nums) # List to store the longest subsequence ending at each index lis = [[] for _ in range(n)] # The longest subsequence for the first element is the element itself lis[0].append(nums[0]) for i in range(1, n): for j in range(i): # If nums[i] is greater than nums[j] and the subsequence ending at j is longer, update the subsequence at i if nums[i] > nums[j] and len(lis[i]) < len(lis[j]) + 1: lis[i] = lis[j][:] lis[i].append(nums[i]) # Find the subsequence with the maximum length max_lis = [] for l in lis: if len(l) > len(max_lis): max_lis = l return max_lis"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression represented as a string and returns the result as an integer. >>> evaluate_expression(\\"3+5 / 2\\") 5 >>> evaluate_expression(\\"(2+6* 3+5- (3*14/7+2)*5)+3\\") -12 # Example usage: print(evaluate_expression(\\"3+5 / 2\\")) # Output: 5 print(evaluate_expression(\\"(2+6* 3+5- (3*14/7+2)*5)+3\\")) # Output: -12 from solution import evaluate_expression def test_evaluate_expression_simple_addition(): assert evaluate_expression(\\"3+5\\") == 8 def test_evaluate_expression_with_spaces(): assert evaluate_expression(\\"3 + 5 / 2\\") == 5 def test_evaluate_expression_complex_expression_1(): assert evaluate_expression(\\"(2+6*3+5-(3*14/7+2)*5)+3\\") == -12 def test_evaluate_expression_complex_expression_2(): assert evaluate_expression(\\"10 + 2 * 6\\") == 22 def test_evaluate_expression_complex_expression_3(): assert evaluate_expression(\\"100 * 2 + 12\\") == 212 def test_evaluate_expression_complex_expression_4(): assert evaluate_expression(\\"100 * ( 2 + 12 )\\") == 1400 def test_evaluate_expression_complex_expression_5(): assert evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100 def test_evaluate_expression_division(): assert evaluate_expression(\\"8 / 2\\") == 4 def test_evaluate_expression_all_operations(): assert evaluate_expression(\\"3+2*2-4/2\\") == 5","solution":"def evaluate_expression(expression: str) -> int: def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_op(op, a, b): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(op, val1, val2)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(op, val1, val2)) ops.append(tokens[i]) i += 1 while len(ops) != 0: op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(op, val1, val2)) return values[-1] return evaluate(expression)"},{"question":"def closest_points(points: list[list[int]], k: int) -> list[list[int]]: Find the k points that are closest to the origin (0, 0, 0) from a list of 3D points. >>> closest_points([[1, 2, 3], [3, 3, 3], [1, 1, 1], [5, 1, 2]], 2) [[1, 1, 1], [1, 2, 3]] >>> closest_points([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]], 3) [[1, 0, 0], [0, 1, 0], [0, 0, 1]] pass","solution":"def closest_points(points: list[list[int]], k: int) -> list[list[int]]: def distance_from_origin(point): x, y, z = point return x**2 + y**2 + z**2 points.sort(key=distance_from_origin) return points[:k]"},{"question":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Returns a new list with all duplicate elements removed while maintaining the original order of the first occurrence of each element. Example: >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 4, 5, 6, 7, 8]) [4, 5, 6, 7, 8] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 3, 2, 1, 4, 2, 3, 5, 4, 6]) [1, 3, 2, 4, 5, 6]","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Returns a new list with all duplicate elements removed while maintaining the original order of the first occurrence of each element. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def k_largest_elements(lst: List[int], k: int) -> List[int]: Returns the \`k\` largest elements from the list sorted in descending order. >>> k_largest_elements([3, 2, 6, 8, 1, 4], 3) == [8, 6, 4] >>> k_largest_elements([3, 2, 6, 8, 1, 4], 10) == [8, 6, 4, 3, 2, 1] >>> k_largest_elements([3, 2, 6, 8, 1, 4], 0) == [] >>> k_largest_elements([], 3) == [] >>> k_largest_elements([-3, -1, -7, -4, -2], 2) == [-1, -2] >>> k_largest_elements([3, -2, 6, -8, 1, 4], 3) == [6, 4, 3] >>> k_largest_elements([3, 5, 3, 1, 5], 2) == [5, 5]","solution":"def k_largest_elements(lst, k): Returns the k largest elements from the list sorted in descending order. Args: lst: List of integers. k: An integer representing the number of largest elements to return. Returns: A list of k largest integers from lst sorted in descending order. if not lst or k <= 0: return [] return sorted(lst, reverse=True)[:k]"},{"question":"def length_of_longest_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with at most two distinct elements. >>> length_of_longest_subarray([1, 2, 1, 2, 3, 4, 3, 2, 2, 3]) 4 >>> length_of_longest_subarray([1, 2, 1, 2, 1, 2, 1, 2]) 8 >>> length_of_longest_subarray([1, 2, 3, 4, 5]) 2 >>> length_of_longest_subarray([1, 1, 1, 1]) 4 >>> length_of_longest_subarray([1, 2, 3, 2, 2]) 4 >>> length_of_longest_subarray([]) 0 >>> length_of_longest_subarray([1]) 1 >>> length_of_longest_subarray([1, 2]) 2 >>> length_of_longest_subarray([1, 2, 3]) 2 >>> length_of_longest_subarray([2, 2, 2, 2, 2]) 5","solution":"def length_of_longest_subarray(arr): Returns the length of the longest subarray with at most two distinct elements. :param arr: List[int] - List of integers. :return: int - Length of the longest subarray with at most two distinct elements. if len(arr) < 2: return len(arr) max_length = 0 start = 0 freq_map = {} for end in range(len(arr)): freq_map[arr[end]] = freq_map.get(arr[end], 0) + 1 while len(freq_map) > 2: freq_map[arr[start]] -= 1 if freq_map[arr[start]] == 0: del freq_map[arr[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def flatten_nested_list(nested_list): Flattens a nested list of integers into a single list of integers. >>> flatten_nested_list([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([1, [2, 3], 4]) [1, 2, 3, 4] >>> flatten_nested_list([[[1], 2], [3, 4], 5]) [1, 2, 3, 4, 5]","solution":"def flatten_nested_list(nested_list): Flattens a nested list of integers into a single list of integers. result = [] for element in nested_list: if isinstance(element, list): result.extend(flatten_nested_list(element)) else: result.append(element) return result"},{"question":"def sort_dict_by_value_then_key(data): Sorts a dictionary by its values in descending order, and by the keys in ascending alphabetical order if there are duplicate values. Returns a list of tuples. Parameters: data (dict): The dictionary to be sorted. Returns: List[Tuple]: A sorted list of tuples (key, value). Raises: ValueError: If the input is not a dictionary. >>> sort_dict_by_value_then_key({'apple': 10, 'banana': 5, 'cherry': 10, 'date': 7}) [('apple', 10), ('cherry', 10), ('date', 7), ('banana', 5)] >>> sort_dict_by_value_then_key({}) []","solution":"def sort_dict_by_value_then_key(data): Sorts a dictionary by its values in descending order, and by the keys in ascending alphabetical order if there are duplicate values. Returns a list of tuples. Parameters: data (dict): The dictionary to be sorted. Returns: List[Tuple]: A sorted list of tuples (key, value). Raises: ValueError: If the input is not a dictionary. if not isinstance(data, dict): raise ValueError('Input must be a dictionary') sorted_items = sorted(data.items(), key=lambda item: (-item[1], item[0])) return sorted_items"},{"question":"class Student: A class representing a student. The Student has a name, grade, and GPA. GPA must be in the range 0.0 to 4.0. >>> student = Student() >>> student.name '' >>> student.grade '' >>> student.gpa 0.0 >>> student.update_grade(\\"A\\") >>> student.grade 'A' >>> student.update_gpa(3.7) >>> student.gpa 3.7 >>> student.change_name(\\"John Doe\\") >>> student.name 'John Doe' >>> student.is_honors() False >>> student.update_gpa(3.8) >>> student.is_honors() True def __init__(self, name='', grade='', gpa=0.0): pass def update_grade(self, new_grade): pass def update_gpa(self, new_gpa): pass def is_honors(self): pass def change_name(self, new_name): pass","solution":"class Student: def __init__(self, name='', grade='', gpa=0.0): self.name = name self.grade = grade self.gpa = gpa def update_grade(self, new_grade): self.grade = new_grade def update_gpa(self, new_gpa): if 0.0 <= new_gpa <= 4.0: self.gpa = new_gpa else: raise ValueError(\\"GPA must be between 0.0 and 4.0\\") def is_honors(self): return self.gpa >= 3.5 def change_name(self, new_name): self.name = new_name"},{"question":"def optimized_categorize_products(sales): Categorizes products based on their average monthly sales. Parameters: sales (dict): A dictionary where the keys are product IDs and values are lists of integers representing monthly sales. Returns: dict: A new dictionary with product IDs as keys and their categories ('High Performing' or 'Low Performing') as values. pass # Test cases import pytest def test_optimized_categorize_products_high_performing(): sales = { \\"A001\\": [160, 170, 180, 190, 200, 150, 165, 175, 185, 195, 205, 215], \\"A002\\": [200, 210, 220, 225, 230, 240, 245, 250, 255, 260, 270, 275], } expected = { \\"A001\\": \\"High Performing\\", \\"A002\\": \\"High Performing\\", } assert optimized_categorize_products(sales) == expected def test_optimized_categorize_products_low_performing(): sales = { \\"A001\\": [80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135], \\"A002\\": [50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105], } expected = { \\"A001\\": \\"Low Performing\\", \\"A002\\": \\"Low Performing\\" } assert optimized_categorize_products(sales) == expected def test_optimized_categorize_products_mixed(): sales = { \\"A001\\": [160, 150, 155, 145, 150, 140, 150, 160, 170, 180, 190, 200], # High Performing \\"A002\\": [140, 135, 130, 125, 120, 115, 110, 105, 100, 95, 90, 85], # Low Performing } expected = { \\"A001\\": \\"High Performing\\", \\"A002\\": \\"Low Performing\\", } assert optimized_categorize_products(sales) == expected def test_optimized_categorize_products_edge_case(): sales = { \\"A001\\": [150] * 12, # Exactly 150 average, which is not high performing } expected = { \\"A001\\": \\"Low Performing\\", } assert optimized_categorize_products(sales) == expected","solution":"def optimized_categorize_products(sales): Categorizes products based on their average monthly sales. Parameters: sales (dict): A dictionary where the keys are product IDs and values are lists of integers representing monthly sales. Returns: dict: A new dictionary with product IDs as keys and their categories ('High Performing' or 'Low Performing') as values. return { product: \\"High Performing\\" if sum(monthly_sales) / 12 > 150 else \\"Low Performing\\" for product, monthly_sales in sales.items() }"},{"question":"def balanced_parentheses(s: str) -> bool: Check if the input string has balanced parentheses. Parameters: s (str): The input string containing parentheses. Returns: bool: True if the parentheses are balanced, False otherwise. >>> balanced_parentheses(\\"(){}[]\\") True >>> balanced_parentheses(\\"{[()]}\\") True >>> balanced_parentheses(\\"{[(])}\\") False >>> balanced_parentheses(\\"{{[[(())]]}}\\") True >>> balanced_parentheses(\\"}{\\") False >>> balanced_parentheses(\\"\\") True >>> balanced_parentheses(\\"((()))\\") True >>> balanced_parentheses(\\"[[]]\\") True >>> balanced_parentheses(\\"{{}}\\") True >>> balanced_parentheses(\\"((())\\") False >>> balanced_parentheses(\\"[[[]]]\\") True >>> balanced_parentheses(\\"{{}}}\\") False >>> balanced_parentheses(\\"a(b)c[d]e{f}g\\") True >>> balanced_parentheses(\\"a(b)c[d]e{f}g]\\") False","solution":"def balanced_parentheses(s): Check if the input string has balanced parentheses. Parameters: s (str): The input string containing parentheses. Returns: bool: True if the parentheses are balanced, False otherwise. stack = [] matching_parentheses = { ')': '(', ']': '[', '}': '{' } for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return False return len(stack) == 0"},{"question":"def move_zeroes(nums): Moves all zeros in the list \`nums\` to the end while maintaining the order of non-zero elements. Parameters: nums (list): The list of integers. Returns: None: The function modifies the input list in-place. pass # Unit Tests def test_move_zeroes_example_1(): nums = [0, 1, 0, 3, 12] move_zeroes(nums) assert nums == [1, 3, 12, 0, 0] def test_move_zeroes_example_2(): nums = [1, 0, 2, 0, 4] move_zeroes(nums) assert nums == [1, 2, 4, 0, 0] def test_move_zeroes_example_3(): nums = [0, 0, 0, 0, 1] move_zeroes(nums) assert nums == [1, 0, 0, 0, 0] def test_move_zeroes_example_4(): nums = [4, 2, 4, 0, 0] move_zeroes(nums) assert nums == [4, 2, 4, 0, 0] def test_move_zeroes_all_zeros(): nums = [0, 0, 0, 0, 0] move_zeroes(nums) assert nums == [0, 0, 0, 0, 0] def test_move_zeroes_no_zeros(): nums = [1, 2, 3, 4, 5] move_zeroes(nums) assert nums == [1, 2, 3, 4, 5] def test_move_zeroes_already_sorted(): nums = [1, 2, 3, 0, 0] move_zeroes(nums) assert nums == [1, 2, 3, 0, 0]","solution":"def move_zeroes(nums): Moves all zeros in the list \`nums\` to the end while maintaining the order of non-zero elements. Parameters: nums (list): The list of integers. Returns: None: The function modifies the input list in-place. # Index to place the next non-zero element place_index = 0 # Traverse the list and move the non-zero elements to the front for num in nums: if num != 0: nums[place_index] = num place_index += 1 # Fill the remaining positions with zeros for i in range(place_index, len(nums)): nums[i] = 0"},{"question":"def calculate_average_grades(students_grades): Calculates the average grade for each student and returns a dictionary with the student names as keys and their respective average grades as values rounded to two decimal places. If a student has an empty list of grades, their average grade will be set to 0.0. Parameters: students_grades (dict): A dictionary where keys are student names and values are lists of grades. Returns: dict: A dictionary with student names as keys and their average grades as values. from solution import calculate_average_grades def test_calculate_average_grades(): students_grades = { \\"Alice\\": [90, 85, 82], \\"Bob\\": [78, 81, 86, 89], \\"Charlie\\": [], \\"Diana\\": [100, 95, 90, 85, 80, 75], } expected_output = { \\"Alice\\": 85.67, \\"Bob\\": 83.5, \\"Charlie\\": 0.0, \\"Diana\\": 87.5, } assert calculate_average_grades(students_grades) == expected_output def test_calculate_empty_grades_dict(): students_grades = {} expected_output = {} assert calculate_average_grades(students_grades) == expected_output def test_calculate_single_grade(): students_grades = { \\"Eve\\": [75] } expected_output = { \\"Eve\\": 75.0 } assert calculate_average_grades(students_grades) == expected_output def test_calculate_single_student_multiple_grades(): students_grades = { \\"Frank\\": [45, 67, 89] } expected_output = { \\"Frank\\": 67.0 } assert calculate_average_grades(students_grades) == expected_output def test_all_students_with_empty_grades(): students_grades = { \\"George\\": [], \\"Helen\\": [], } expected_output = { \\"George\\": 0.0, \\"Helen\\": 0.0, } assert calculate_average_grades(students_grades) == expected_output","solution":"def calculate_average_grades(students_grades): Calculates the average grade for each student and returns a dictionary with the student names as keys and their respective average grades as values rounded to two decimal places. If a student has an empty list of grades, their average grade will be set to 0.0. Parameters: students_grades (dict): A dictionary where keys are student names and values are lists of grades. Returns: dict: A dictionary with student names as keys and their average grades as values. average_grades = {} for student, grades in students_grades.items(): if grades: average_grades[student] = round(sum(grades) / len(grades), 2) else: average_grades[student] = 0.0 return average_grades"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. Consider empty strings as valid palindromes. Args: s (str): The input string. Returns: bool: True if the string is a valid palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True >>> is_palindrome(\\"!!\\") True >>> is_palindrome(\\"A!Z@z#A\\") True >>> is_palindrome(\\"civic\\") True >>> is_palindrome(\\"MadamInEdenImAdam\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"Not a palindrome\\") False","solution":"def is_palindrome(s): Determines if a given string is a valid palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. Args: s (str): The input string. Returns: bool: True if the string is a valid palindrome, False otherwise. # Removing non-alphanumeric characters and converting to lowercase cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Checking if the cleaned string is a palindrome return cleaned_s == cleaned_s[::-1]"},{"question":"def calculate_final_price(products: list) -> list: Calculate the final price for each product after applying the tax. Parameters: products (list): List of dictionaries where each dictionary contains product information. Returns: list: New list with each dictionary containing an additional key \\"final_price\\" with calculated final price. Example: >>> calculate_final_price([ {\\"product\\": \\"Laptop\\", \\"price\\": 1000, \\"tax_rate\\": 0.18}, {\\"product\\": \\"Smartphone\\", \\"price\\": 700, \\"tax_rate\\": 0.12}, {\\"product\\": \\"Tablet\\", \\"price\\": 300, \\"tax_rate\\": 0.15}, {\\"product\\": \\"Headphones\\", \\"price\\": 100, \\"tax_rate\\": 0.08} ]) [ {\\"product\\": \\"Laptop\\", \\"price\\": 1000, \\"tax_rate\\": 0.18, \\"final_price\\": 1180.0}, {\\"product\\": \\"Smartphone\\", \\"price\\": 700, \\"tax_rate\\": 0.12, \\"final_price\\": 784.0}, {\\"product\\": \\"Tablet\\", \\"price\\": 300, \\"tax_rate\\": 0.15, \\"final_price\\": 345.0}, {\\"product\\": \\"Headphones\\", \\"price\\": 100, \\"tax_rate\\": 0.08, \\"final_price\\": 108.0} ]","solution":"def calculate_final_price(products): Calculate the final price for each product after applying the tax. Parameters: products (list): List of dictionaries where each dictionary contains product information. Returns: list: New list with each dictionary containing an additional key \\"final_price\\" with calculated final price. for product in products: price = product['price'] tax_rate = product['tax_rate'] final_price = price + (price * tax_rate) product['final_price'] = round(final_price, 2) # rounding to 2 decimal places return products"},{"question":"def minChangesToUnique(s: str) -> int: Determine the minimum number of changes needed to make all characters unique. >>> minChangesToUnique(\\"aab\\") 1 >>> minChangesToUnique(\\"abc\\") 0 >>> minChangesToUnique(\\"aaa\\") 2 >>> minChangesToUnique(\\"z\\") 0 >>> minChangesToUnique(\\"xy\\") 0 >>> minChangesToUnique(\\"tt\\") 1 >>> minChangesToUnique(\\"abab\\") 2 >>> minChangesToUnique(\\"abcdefg\\") 0 >>> minChangesToUnique(\\"kkkkkkk\\") 6 >>> minChangesToUnique(\\"a\\"*99 + \\"b\\") 98","solution":"def minChangesToUnique(s): Determine the minimum number of changes needed to make all characters unique. from collections import Counter # Count the frequency of each character char_count = Counter(s) # Calculate the number of repeats for each character repeats = [count - 1 for count in char_count.values() if count > 1] # Total number of changes needed is the sum of repeats return sum(repeats)"},{"question":"def detect_cycle(arr: List[int]) -> bool: Detect if there is a repeating cycle of integers in the list entered. >>> detect_cycle([1, 2, 3, 1, 2, 3]) True >>> detect_cycle([4, 1, 2, 3, 4, 1, 2, 3]) True >>> detect_cycle([1, 2, 3, 4, 5, 6]) False >>> detect_cycle([1, 1, 1, 1, 1]) True","solution":"def detect_cycle(arr): Detects if there is a repeating cycle of integers in the list entered. n = len(arr) if n == 0: return False # Check all possible cycle lengths for cycle_length in range(1, n // 2 + 1): # Assume there is a cycle initially cycle_detected = True for i in range(n - cycle_length): if arr[i] != arr[i + cycle_length]: cycle_detected = False break if cycle_detected: return True return False"},{"question":"def binary_search(arr, target, increasing=True): Performs a binary search on a sorted array of integers. :param arr: List of sorted integers :param target: Integer to search for :param increasing: Boolean flag, True if the array is sorted in increasing order, False if in decreasing order :return: The index of the target if found, otherwise -1 >>> binary_search([1, 3, 5, 7, 9, 11], 5, True) 2 >>> binary_search([1, 3, 5, 7, 9, 11], 6, True) -1 >>> binary_search([11, 9, 7, 5, 3, 1], 7, False) 2 >>> binary_search([11, 9, 7, 5, 3, 1], 6, False) -1 >>> binary_search([], 5, True) -1","solution":"def binary_search(arr, target, increasing=True): Performs a binary search on a sorted array of integers. :param arr: List of sorted integers :param target: Integer to search for :param increasing: Boolean flag, True if the array is sorted in increasing order, False if in decreasing order :return: The index of the target if found, otherwise -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid if increasing: # Array sorted in increasing order if target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Array sorted in decreasing order if target < arr[mid]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Determines if a binary tree is a valid binary search tree (BST). Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the binary tree is a valid BST, False otherwise. Example: >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> is_valid_bst(root) True >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(3) >>> root.right.right = TreeNode(6) >>> is_valid_bst(root) False def test_valid_bst(): # Test with a valid BST root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) assert is_valid_bst(root) == True def test_invalid_bst(): # Test with an invalid BST root = TreeNode(5) root.left = TreeNode(1) root.right = TreeNode(4) root.right.left = TreeNode(3) root.right.right = TreeNode(6) assert is_valid_bst(root) == False def test_empty_tree(): # Test with an empty tree assert is_valid_bst(None) == True def test_single_node(): # Test with a single node tree root = TreeNode(1) assert is_valid_bst(root) == True def test_large_valid_bst(): # Test with a larger valid BST root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(12) root.right.right = TreeNode(17) assert is_valid_bst(root) == True def test_large_invalid_bst(): # Test with a larger invalid BST root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(12) root.right.right = TreeNode(8) # Invalid node for BST assert is_valid_bst(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determines if a binary tree is a valid binary search tree (BST). Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the binary tree is a valid BST, False otherwise. def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"def process_numbers(numbers): Given a list of integers, return a new list consisting of only the odd numbers, each multiplied by three. Parameters: numbers (list of int): A list of integers. Returns: list of int: A list of odd numbers each multiplied by three. >>> process_numbers([1, 2, 3, 4, 5]) [3, 9, 15] >>> process_numbers([10, 13, 19, 20]) [39, 57] >>> process_numbers([]) [] >>> process_numbers([2, 4, 6, 8, 10]) [] >>> process_numbers([1, 3, 5, 7]) [3, 9, 15, 21] >>> process_numbers([2, 9, 4, 3, 5]) [27, 9, 15] >>> process_numbers([10**6, 10**6 + 1]) [(10**6 + 1) * 3] >>> process_numbers([-3, -2, -1]) [-9, -3] >>> process_numbers([i for i in range(10001)]) [i * 3 for i in range(10001) if i % 2 != 0] result = [] # Your code here return result","solution":"def process_numbers(numbers): Given a list of integers, return a new list consisting of only the odd numbers, each multiplied by three. Parameters: numbers (list of int): A list of integers. Returns: list of int: A list of odd numbers each multiplied by three. return [num * 3 for num in numbers if num % 2 != 0]"},{"question":"def count_pairs(arr, k): This function counts the number of unique pairs (i, j) in the list such that arr[i] + arr[j] = k and i < j. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The count of unique pairs whose sum is equal to k. Example usage: >>> count_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_pairs([-1, 1, 2, -2, 0], 0) 2","solution":"def count_pairs(arr, k): This function counts the number of unique pairs (i, j) in the list such that arr[i] + arr[j] = k and i < j. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The count of unique pairs whose sum is equal to k. seen = {} pairs = set() for i, num in enumerate(arr): complement = k - num if complement in seen: pairs.add((min(complement, num), max(complement, num))) seen[num] = i return len(pairs)"},{"question":"import json import jsonschema from jsonschema import validate import logging # Initialize logger logger = logging.getLogger('invalid_entries_logger') logger.setLevel(logging.ERROR) fh = logging.FileHandler('invalid_entries.log') formatter = logging.Formatter('%(asctime)s - %(message)s') fh.setFormatter(formatter) logger.addHandler(fh) def read_and_validate_json(file_path, schema): Reads a JSON file, validates its content against a given schema, and logs invalid entries. :param file_path: Path to the JSON file containing user information :param schema: JSON schema to validate the data against :return: Parsed JSON data if valid, None otherwise Example usage: >>> user_schema = { ... \\"type\\": \\"object\\", ... \\"properties\\": { ... \\"name\\": {\\"type\\": \\"string\\"}, ... \\"age\\": {\\"type\\": \\"integer\\", \\"minimum\\": 0}, ... \\"email\\": {\\"type\\": \\"string\\", \\"format\\": \\"email\\"} ... }, ... \\"required\\": [\\"name\\", \\"age\\", \\"email\\"] ... } >>> read_and_validate_json('valid_user.json', user_schema) {\\"name\\": \\"John Doe\\", \\"age\\": 30, \\"email\\": \\"john.doe@example.com\\"}","solution":"import json import jsonschema from jsonschema import validate import logging # Initialize logger logger = logging.getLogger('invalid_entries_logger') logger.setLevel(logging.ERROR) fh = logging.FileHandler('invalid_entries.log') formatter = logging.Formatter('%(asctime)s - %(message)s') fh.setFormatter(formatter) logger.addHandler(fh) def read_and_validate_json(file_path, schema): Reads a JSON file, validates its content against a given schema, and logs invalid entries. :param file_path: Path to the JSON file containing user information :param schema: JSON schema to validate the data against :return: Parsed JSON data if valid, None otherwise try: with open(file_path, 'r') as file: data = json.load(file) validate(instance=data, schema=schema) return data except jsonschema.exceptions.ValidationError as ve: logger.error(f\\"Validation error: {ve.message}\\") except json.JSONDecodeError as jde: logger.error(f\\"JSON decode error: {jde.msg}\\") except Exception as e: logger.error(f\\"Unexpected error: {str(e)}\\") return None"},{"question":"from typing import List def three_sum(nums: List[int], target_sum: int) -> List[List[int]]: Returns all unique triplets in the list that add up to the target sum. >>> three_sum([1, 0, -1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5], 15) [] >>> three_sum([1, 2, -2, -1, 0, -1, 1, 2], 2) [[-2, 2, 2], [-1, 1, 2], [0, 1, 1]] >>> three_sum([1, 1, -2, 1, -1, -1, 0, 2, -2], 0) [[-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1]] >>> three_sum([0, 0, 0, 0, 0], 0) [[0, 0, 0]]","solution":"def three_sum(nums, target_sum): Returns a list of all unique triplets in nums that add up to target_sum. nums.sort() result = [] length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, length - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target_sum: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target_sum: left += 1 else: right -= 1 return result"},{"question":"def sort_products_by_price(products): Sorts the list of products by their price in descending order. >>> products = [ {'product_id': 'P001', 'name': 'Laptop', 'price': 1500, 'quantity': 10, 'category': 'Electronics'}, {'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}, {'product_id': 'P003', 'name': 'Desk Chair', 'price': 120, 'quantity': 20, 'category': 'Furniture'}, ] >>> sort_products_by_price(products) [{'product_id': 'P001', 'name': 'Laptop', 'price': 1500, 'quantity': 10, 'category': 'Electronics'}, {'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}, {'product_id': 'P003', 'name': 'Desk Chair', 'price': 120, 'quantity': 20, 'category': 'Furniture'}] pass def search_products_by_category(products, category): Searches for products based on their category. >>> products = [ {'product_id': 'P001', 'name': 'Laptop', 'price': 1500, 'quantity': 10, 'category': 'Electronics'}, {'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}, {'product_id': 'P003', 'name': 'Desk Chair', 'price': 120, 'quantity': 20, 'category': 'Furniture'}, ] >>> search_products_by_category(products, 'Electronics') [{'product_id': 'P001', 'name': 'Laptop', 'price': 1500, 'quantity': 10, 'category': 'Electronics'}, {'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}] pass def search_products_within_price_range(products, min_price, max_price): Searches for products within a specified price range. >>> products = [ {'product_id': 'P001', 'name': 'Laptop', 'price': 1500, 'quantity': 10, 'category': 'Electronics'}, {'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}, {'product_id': 'P003', 'name': 'Desk Chair', 'price': 120, 'quantity': 20, 'category': 'Furniture'}, ] >>> search_products_within_price_range(products, 100, 1000) [{'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}, {'product_id': 'P003', 'name': 'Desk Chair', 'price': 120, 'quantity': 20, 'category': 'Furniture'}] pass def search_products(products, category=None, min_price=None, max_price=None, min_quantity=None): Searches for products with multiple filters such as category, price range, and minimum quantity in stock. >>> products = [ {'product_id': 'P001', 'name': 'Laptop', 'price': 1500, 'quantity': 10, 'category': 'Electronics'}, {'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}, {'product_id': 'P003', 'name': 'Desk Chair', 'price': 120, 'quantity': 20, 'category': 'Furniture'}, ] >>> search_products(products, category='Electronics', min_price=500, max_price=1500, min_quantity=10) [{'product_id': 'P001', 'name': 'Laptop', 'price': 1500, 'quantity': 10, 'category': 'Electronics'}, {'product_id': 'P002', 'name': 'Phone', 'price': 800, 'quantity': 15, 'category': 'Electronics'}] pass","solution":"def sort_products_by_price(products): Sorts the list of products by their price in descending order. return sorted(products, key=lambda x: x['price'], reverse=True) def search_products_by_category(products, category): Searches for products based on their category. return [product for product in products if product['category'] == category] def search_products_within_price_range(products, min_price, max_price): Searches for products within a specified price range. return [product for product in products if min_price <= product['price'] <= max_price] def search_products(products, category=None, min_price=None, max_price=None, min_quantity=None): Searches for products with multiple filters such as category, price range, and minimum quantity in stock. result = products if category is not None: result = [product for product in result if product['category'] == category] if min_price is not None and max_price is not None: result = [product for product in result if min_price <= product['price'] <= max_price] if min_quantity is not None: result = [product for product in result if product['quantity'] >= min_quantity] return result"},{"question":"import curses from typing import Tuple class Calculator: def __init__(self, value: float = 0.0): Initialize the calculator with a starting value. :param value: The starting value of the calculator. self.value = value def add(self, number: float) -> None: Add a number to the current value. :param number: The number to add. self.value += number def subtract(self, number: float) -> None: Subtract a number from the current value. :param number: The number to subtract. self.value -= number def multiply(self, number: float) -> None: Multiply the current value by a number. :param number: The number to multiply by. self.value *= number def divide(self, number: float) -> None: Divide the current value by a number. :param number: The number to divide by. :raises ZeroDivisionError: If an attempt is made to divide by zero. if number == 0: raise ZeroDivisionError(\\"Cannot divide by zero.\\") self.value /= number def reset(self) -> None: Reset the calculator's value to 0. self.value = 0.0 def get_value(self) -> float: Get the current value of the calculator. :return: The current value. return self.value class CalculatorCLI: def __init__(self): self.calculator = Calculator() self.screen, self.height, self.width = self.init_screen() def init_screen(self) -> Tuple: Initialize the screen for the calculator. Returns a tuple of the screen and its dimensions. screen = curses.initscr() curses.noecho() curses.cbreak() screen.keypad(True) screen.nodelay(True) height, width = screen.getmaxyx() return screen, height, width def end_screen(self) -> None: End the session and restore the terminal to its original state. curses.nocbreak() self.screen.keypad(False) curses.echo() curses.endwin() def handle_input(self) -> str: Handle user input from the keyboard. Returns a string representing the command. key = self.screen.getch() if key in range(48, 58): # numbers 0-9 return chr(key) elif key == curses.KEY_UP: return 'add' elif key == curses.KEY_DOWN: return 'subtract' elif key == curses.KEY_LEFT: return 'multiply' elif key == curses.KEY_RIGHT: return 'divide' elif key == ord('r'): return 'reset' elif key == ord('q'): return 'quit' else: return '' def clear_screen(self) -> None: Clear the command line area. self.screen.clear() def draw_interface(self) -> None: Draw the calculator interface on the command line. self.screen.addstr(0, 0, \\"Command-line Calculator\\") self.screen.addstr(1, 0, \\"Current value: \\" + str(self.calculator.get_value())) self.screen.addstr(2, 0, \\"Key commands: \\") self.screen.addstr(3, 0, \\" UP key - Add\\") self.screen.addstr(4, 0, \\" DOWN key - Subtract\\") self.screen.addstr(5, 0, \\" LEFT key - Multiply\\") self.screen.addstr(6, 0, \\" RIGHT key - Divide\\") self.screen.addstr(7, 0, \\" r key - Reset\\") self.screen.addstr(8, 0, \\" q key - Quit\\") def run(self) -> None: Run the calculator command line interface. while True: self.clear_screen() self.draw_interface() command = self.handle_input() try: if command == 'add': self.screen.addstr(self.height - 1, 0, \\"Enter number to add: \\") curses.echo() number = float(self.screen.getstr().decode(\\"utf-8\\")) curses.noecho() self.calculator.add(number) elif command == 'subtract': self.screen.addstr(self.height - 1, 0, \\"Enter number to subtract: \\") curses.echo() number = float(self.screen.getstr().decode(\\"utf-8\\")) curses.noecho() self.calculator.subtract(number) elif command == 'multiply': self.screen.addstr(self.height - 1, 0, \\"Enter number to multiply: \\") curses.echo() number = float(self.screen.getstr().decode(\\"utf-8\\")) curses.noecho() self.calculator.multiply(number) elif command == 'divide': self.screen.addstr(self.height - 1, 0, \\"Enter number to divide: \\") curses.echo() number = float(self.screen.getstr().decode(\\"utf-8\\")) curses.noecho() self.calculator.divide(number) elif command == 'reset': self.calculator.reset() elif command == 'quit': break except ValueError: self.screen.addstr(self.height - 1, 0, \\"Invalid input. Please enter a number.\\") except ZeroDivisionError as e: self.screen.addstr(self.height - 1, 0, str(e)) self.end_screen() if __name__ == '__main__': cli = CalculatorCLI() cli.run() # Unit tests for the Calculator class def test_initial_value(): calc = Calculator() assert calc.get_value() == 0.0 def test_add(): calc = Calculator(5) calc.add(3) assert calc.get_value() == 8.0 def test_subtract(): calc = Calculator(5) calc.subtract(3) assert calc.get_value() == 2.0 def test_multiply(): calc = Calculator(5) calc.multiply(3) assert calc.get_value() == 15.0 def test_divide(): calc = Calculator(9) calc.divide(3) assert calc.get_value() == 3.0 def test_divide_by_zero(): calc = Calculator(9) try: calc.divide(0) except ZeroDivisionError as e: assert str(e) == \\"Cannot divide by zero.\\" def test_reset(): calc = Calculator(5) calc.reset() assert calc.get_value() == 0.0","solution":"class Calculator: def __init__(self, value: float = 0.0): Initialize the calculator with a starting value. :param value: The starting value of the calculator. self.value = value def add(self, number: float) -> None: Add a number to the current value. :param number: The number to add. self.value += number def subtract(self, number: float) -> None: Subtract a number from the current value. :param number: The number to subtract. self.value -= number def multiply(self, number: float) -> None: Multiply the current value by a number. :param number: The number to multiply by. self.value *= number def divide(self, number: float) -> None: Divide the current value by a number. :param number: The number to divide by. :raises ZeroDivisionError: If an attempt is made to divide by zero. if number == 0: raise ZeroDivisionError(\\"Cannot divide by zero.\\") self.value /= number def reset(self) -> None: Reset the calculator's value to 0. self.value = 0.0 def get_value(self) -> float: Get the current value of the calculator. :return: The current value. return self.value"},{"question":"def generate_spiral(n: int) -> List[List[int]]: Creates an nxn spiral matrix. Args: n (int): The size of the matrix to be generated. Returns: List[List[int]]: An nxn spiral matrix. >>> generate_spiral(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral(1) [[1]] >>> generate_spiral(2) [[1, 2], [4, 3]] >>> generate_spiral(0) [] >>> generate_spiral(-3) [] pass","solution":"def generate_spiral(n): Creates an nxn spiral matrix. Args: n (int): The size of the matrix to be generated. Returns: List[List[int]]: An nxn spiral matrix. if n <= 0: return [] # Initialize an nxn matrix filled with zeros matrix = [[0] * n for _ in range(n)] # Define the boundaries for the spiral top, bottom = 0, n - 1 left, right = 0, n - 1 num = 1 # Start the number from 1 while top <= bottom and left <= right: # Traverse from left to right along the top boundary for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Move the top boundary downwards # Traverse from top to bottom along the right boundary for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Move the right boundary to the left # Traverse from right to left along the bottom boundary for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Move the bottom boundary upwards # Traverse from bottom to top along the left boundary for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 # Move the left boundary to the right return matrix"},{"question":"def filter_and_sort_even_numbers(numbers: List[int]) -> List[int]: Write a function that takes an unsorted list of integers and returns a new list that contains only the even numbers from the original list, sorted in ascending order. >>> filter_and_sort_even_numbers([5, 3, 2, 8, 1, 12]) [2, 8, 12] >>> filter_and_sort_even_numbers([4, 2, 8, 6]) [2, 4, 6, 8] >>> filter_and_sort_even_numbers([9, 3, 11, 5]) [] >>> filter_and_sort_even_numbers([]) [] >>> filter_and_sort_even_numbers([2]) [2] >>> filter_and_sort_even_numbers([3]) [] >>> filter_and_sort_even_numbers([4, -2, -8, 6]) [-8, -2, 4, 6] >>> filter_and_sort_even_numbers([1000, 5000, 2000, 3000]) [1000, 2000, 3000, 5000]","solution":"def filter_and_sort_even_numbers(numbers): Returns a list of even numbers, sorted in ascending order from the given unsorted list of integers. even_numbers = [num for num in numbers if num % 2 == 0] return sorted(even_numbers)"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequent character in the string s. In case of a tie, returns the character that appears first in the string. >>> most_frequent_character('programming') 'g' >>> most_frequent_character('aabbbccdd') 'b' >>> most_frequent_character('abcdabcd') 'a' >>> most_frequent_character('abacabad') 'a' >>> most_frequent_character('bbbaaaccc') 'b' >>> most_frequent_character('zxyzzxy') 'z' >>> most_frequent_character('abcd') 'a' >>> most_frequent_character('') '' >>> most_frequent_character('!@#!!@#') '!' >>> most_frequent_character('%%%') ''","solution":"def most_frequent_character(s): Returns the most frequent character in the string s. In case of a tie, returns the character that appears first in the string. from collections import defaultdict char_count = defaultdict(int) first_appearance = {} for index, char in enumerate(s): char_count[char] += 1 if char not in first_appearance: first_appearance[char] = index # Find the character with the highest frequency max_count = -1 most_frequent_char = '' for char in char_count: if (char_count[char] > max_count or (char_count[char] == max_count and first_appearance[char] < first_appearance[most_frequent_char])): max_count = char_count[char] most_frequent_char = char return most_frequent_char"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Identify if there exists a pair of numbers in the list that adds up to the target sum. >>> has_pair_with_sum([1, 2, 3, 4, 5], 8) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False","solution":"def has_pair_with_sum(nums, target): Returns True if there are two numbers in the list that add up to the target sum, otherwise False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"class Command: def execute(self): raise NotImplementedError def undo(self): raise NotImplementedError class MoveCommand(Command): def __init__(self, shape, x, y): self.shape = shape self.x = x self.y = y self.previous_x = shape.x self.previous_y = shape.y def execute(self): Executes the move command by moving the shape to the new coordinates. pass def undo(self): Undoes the move command by moving the shape back to the previous coordinates. pass class ResizeCommand(Command): def __init__(self, shape, width, height): self.shape = shape self.width = width self.height = height self.previous_width = shape.width self.previous_height = shape.height def execute(self): Executes the resize command by resizing the shape to the new dimensions. pass def undo(self): Undoes the resize command by resizing the shape back to the previous dimensions. pass class ColorCommand(Command): def __init__(self, shape, color): self.shape = shape self.color = color self.previous_color = shape.color def execute(self): Executes the color command by changing the shape's color to the new color. pass def undo(self): Undoes the color command by changing the shape's color back to the previous color. pass class RotateCommand(Command): def __init__(self, shape, angle): self.shape = shape self.angle = angle self.previous_angle = shape.angle def execute(self): Executes the rotate command by rotating the shape to the new angle. pass def undo(self): Undoes the rotate command by rotating the shape back to the previous angle. pass class Shape: def __init__(self, x, y, width, height, color, angle): self.x = x self.y = y self.width = width self.height = height self.color = color self.angle = angle def move(self, x, y): self.x = x self.y = y def resize(self, width, height): self.width = width self.height = height def change_color(self, color): self.color = color def rotate(self, angle): self.angle = angle class CommandHistory: def __init__(self): self.history = [] self.redo_stack = [] def execute_command(self, command): command.execute() self.history.append(command) self.redo_stack.clear() def undo(self): if self.history: command = self.history.pop() command.undo() self.redo_stack.append(command) def redo(self): if self.redo_stack: command = self.redo_stack.pop() command.execute() self.history.append(command)","solution":"class Command: def execute(self): raise NotImplementedError def undo(self): raise NotImplementedError class MoveCommand(Command): def __init__(self, shape, x, y): self.shape = shape self.x = x self.y = y self.previous_x = shape.x self.previous_y = shape.y def execute(self): self.shape.move(self.x, self.y) def undo(self): self.shape.move(self.previous_x, self.previous_y) class ResizeCommand(Command): def __init__(self, shape, width, height): self.shape = shape self.width = width self.height = height self.previous_width = shape.width self.previous_height = shape.height def execute(self): self.shape.resize(self.width, self.height) def undo(self): self.shape.resize(self.previous_width, self.previous_height) class ColorCommand(Command): def __init__(self, shape, color): self.shape = shape self.color = color self.previous_color = shape.color def execute(self): self.shape.change_color(self.color) def undo(self): self.shape.change_color(self.previous_color) class RotateCommand(Command): def __init__(self, shape, angle): self.shape = shape self.angle = angle self.previous_angle = shape.angle def execute(self): self.shape.rotate(self.angle) def undo(self): self.shape.rotate(self.previous_angle) class Shape: def __init__(self, x, y, width, height, color, angle): self.x = x self.y = y self.width = width self.height = height self.color = color self.angle = angle def move(self, x, y): self.x = x self.y = y def resize(self, width, height): self.width = width self.height = height def change_color(self, color): self.color = color def rotate(self, angle): self.angle = angle class CommandHistory: def __init__(self): self.history = [] self.redo_stack = [] def execute_command(self, command): command.execute() self.history.append(command) self.redo_stack.clear() def undo(self): if self.history: command = self.history.pop() command.undo() self.redo_stack.append(command) def redo(self): if self.redo_stack: command = self.redo_stack.pop() command.execute() self.history.append(command)"},{"question":"def most_frequent_character(s: str) -> str: Create a function that takes a string as input and returns the most frequently occurring character in that string. In case of a tie, return the character that appears first in the string. Consider both uppercase and lowercase characters as distinct. >>> most_frequent_character(\\"character\\") 'c' >>> most_frequent_character(\\"Programming\\") 'r' >>> most_frequent_character(\\"aabbbcc\\") 'b' def test_single_character_string(): assert most_frequent_character(\\"a\\") == \\"a\\" def test_mixed_characters(): assert most_frequent_character(\\"character\\") == \\"c\\" assert most_frequent_character(\\"Programming\\") == \\"r\\" assert most_frequent_character(\\"aabbbcc\\") == \\"b\\" def test_case_sensitivity(): assert most_frequent_character(\\"aAaAa\\") == \\"a\\" # 'a' appears more frequently than 'A' assert most_frequent_character(\\"AaAa\\") == \\"A\\" # Both 'A' and 'a' appear twice, 'A' appears first def test_first_appearance_tiebreaker(): assert most_frequent_character(\\"abac\\") == \\"a\\" # 'a' and 'b' appear twice, but 'a' appears first def test_all_characters_same(): assert most_frequent_character(\\"aaaa\\") == \\"a\\"","solution":"def most_frequent_character(s: str) -> str: from collections import Counter # Count occurrences of all characters in the string count = Counter(s) # Initialize variables to track the most frequent character most_frequent = None max_count = 0 # Iterate through the string to find the most frequent character for char in s: if count[char] > max_count: most_frequent = char max_count = count[char] return most_frequent"},{"question":"def findLowestFrequencyChar(s): Finds the character with the lowest frequency in the given string \`s\`. If there are multiple characters with the same lowest frequency, return the lexicographically smallest one. Args: s (str): A string containing only lowercase alphabetic characters. Returns: str: The character with the lowest frequency. >>> findLowestFrequencyChar(\\"aabbbcccc\\") \\"a\\" >>> findLowestFrequencyChar(\\"abac\\") \\"b\\" >>> findLowestFrequencyChar(\\"xyzxy\\") \\"z\\"","solution":"def findLowestFrequencyChar(s): Finds the character with the lowest frequency in the given string \`s\`. If there are multiple characters with the same lowest frequency, return the lexicographically smallest one. Args: s (str): A string containing only lowercase alphabetic characters. Returns: str: The character with the lowest frequency. # Create an empty dictionary to store the frequency of each character freq = {} # Iterate through each character in the string for char in s: # Increment the frequency count for the character if char in freq: freq[char] += 1 else: freq[char] = 1 # Initialize variables to track the lowest frequency and the associated character lowest_freq = float('inf') lowest_char = '' # Iterate through the frequency dictionary for key in freq: # Update the lowest frequency and character if a new lower frequency or lexicographically smaller character is found if freq[key] < lowest_freq or (freq[key] == lowest_freq and key < lowest_char): lowest_freq = freq[key] lowest_char = key return lowest_char # Example usage: # Input: \\"aabbbcccc\\" # Output: \\"a\\" print(findLowestFrequencyChar(\\"aabbbcccc\\"))"},{"question":"class Flight: A class to simulate basic airline reservation operations. Methods: book_seat(seat_number: int, passenger_name: str) -> str cancel_booking(seat_number: int) -> str check_available_seats() -> List[int] generate_manifest() -> Dict[int, str] get_booking_by_passenger(passenger_name: str) -> List[int] Example: >>> flight = Flight(\\"AB123\\", 3) >>> flight.book_seat(1, 'Alice') 'Seat 1 booked successfully for Alice.' >>> flight.book_seat(1, 'Bob') 'Seat already booked.' >>> flight.cancel_booking(2) 'No such booking exists.' >>> flight.check_available_seats() [2, 3] >>> flight.generate_manifest() {1: 'Alice'} >>> flight.get_booking_by_passenger('Alice') [1] def __init__(self, flight_number: str, total_seats: int): Initializes a Flight object with a specific flight number and total seats. Args: flight_number (str): The flight number. total_seats (int): Total number of seats available on the flight. pass def book_seat(self, seat_number: int, passenger_name: str) -> str: Books a seat for a passenger. Args: seat_number (int): The seat number to be booked. passenger_name (str): The name of the passenger. Returns: str: A message indicating the booking status. pass def cancel_booking(self, seat_number: int) -> str: Cancels a booking based on seat number. Args: seat_number (int): The seat number whose booking is to be canceled. Returns: str: A message indicating whether the cancellation was successful or not. pass def check_available_seats(self) -> list: Checks available seats on the flight. Returns: list: A list of available seat numbers. pass def generate_manifest(self) -> dict: Generates a manifest of all passengers on the flight. Returns: dict: A dictionary with seat numbers as keys and passenger names as values. pass def get_booking_by_passenger(self, passenger_name: str) -> list: Retrieves bookings based on passenger name. Args: passenger_name (str): The name of the passenger. Returns: list: A list of seat numbers booked by the passenger. pass","solution":"class Flight: def __init__(self, flight_number, total_seats): self.flight_number = flight_number self.total_seats = total_seats self.bookings = {} self.available_seats = set(range(1, total_seats + 1)) def book_seat(self, seat_number, passenger_name): if seat_number <= 0 or seat_number > self.total_seats: return \\"Invalid seat number.\\" if seat_number not in self.available_seats: return \\"Seat already booked.\\" self.bookings[seat_number] = passenger_name self.available_seats.remove(seat_number) return f\\"Seat {seat_number} booked successfully for {passenger_name}.\\" def cancel_booking(self, seat_number): if seat_number in self.bookings: passenger_name = self.bookings.pop(seat_number) self.available_seats.add(seat_number) return f\\"Booking for seat {seat_number} by {passenger_name} has been canceled.\\" else: return \\"No such booking exists.\\" def check_available_seats(self): return list(self.available_seats) def generate_manifest(self): return self.bookings def get_booking_by_passenger(self, passenger_name): return [seat for seat, name in self.bookings.items() if name == passenger_name]"},{"question":"import time import threading import random import logging # Setup logging logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') # Mock API to fetch stock prices def fetch_stock_price(stock_symbol): Mock function to fetch real-time stock price. # Simulate network delay and price fluctuation time.sleep(1) price = round(100 + random.random() * 10, 2) # Mock price between 100 and 110 return price class TradingPlatform: def __init__(self, initial_balance=10000): self.balance = initial_balance self.portfolio = {} self.transactions = [] self.lock = threading.Lock() self.running = True def buy_stock(self, stock_symbol, price, amount): with self.lock: cost = price * amount if self.balance >= cost: # Implement buying logic here pass else: logging.error(f\\"Insufficient balance to buy {amount} shares of {stock_symbol} at {price:.2f}\\") def sell_stock(self, stock_symbol, price, amount): with self.lock: if self.portfolio.get(stock_symbol, 0) >= amount: # Implement selling logic here pass else: logging.error(f\\"Insufficient shares to sell {amount} of {stock_symbol}\\") def monitor_stock(self, stock_symbol, buy_threshold, sell_threshold): while self.running: try: price = fetch_stock_price(stock_symbol) logging.info(f\\"Current price of {stock_symbol} is {price:.2f}\\") # Buy if the price is below the buy_threshold if price <= buy_threshold: self.buy_stock(stock_symbol, price, 1) # Sell if the price is above the sell_threshold elif price >= sell_threshold: self.sell_stock(stock_symbol, price, 1) except Exception as e: logging.error(f\\"Error fetching price for {stock_symbol}: {e}\\") def stop(self): self.running = False def account_summary(self): return { 'balance': self.balance, 'portfolio': self.portfolio, 'transactions': self.transactions, }","solution":"import time import threading import random import logging # Setup logging logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') # Mock API to fetch stock prices def fetch_stock_price(stock_symbol): Mock function to fetch real-time stock price. # Simulate network delay and price fluctuation time.sleep(1) price = round(100 + random.random() * 10, 2) # Mock price between 100 and 110 return price class TradingPlatform: def __init__(self, initial_balance=10000): self.balance = initial_balance self.portfolio = {} self.transactions = [] self.lock = threading.Lock() self.running = True def buy_stock(self, stock_symbol, price, amount): with self.lock: cost = price * amount if self.balance >= cost: self.balance -= cost self.portfolio[stock_symbol] = self.portfolio.get(stock_symbol, 0) + amount self.transactions.append({ 'action': 'buy', 'stock': stock_symbol, 'price': price, 'amount': amount }) logging.info(f\\"Bought {amount} shares of {stock_symbol} at {price:.2f}\\") else: logging.error(f\\"Insufficient balance to buy {amount} shares of {stock_symbol} at {price:.2f}\\") def sell_stock(self, stock_symbol, price, amount): with self.lock: if self.portfolio.get(stock_symbol, 0) >= amount: self.portfolio[stock_symbol] -= amount if self.portfolio[stock_symbol] == 0: del self.portfolio[stock_symbol] self.balance += price * amount self.transactions.append({ 'action': 'sell', 'stock': stock_symbol, 'price': price, 'amount': amount }) logging.info(f\\"Sold {amount} shares of {stock_symbol} at {price:.2f}\\") else: logging.error(f\\"Insufficient shares to sell {amount} of {stock_symbol}\\") def monitor_stock(self, stock_symbol, buy_threshold, sell_threshold): while self.running: try: price = fetch_stock_price(stock_symbol) logging.info(f\\"Current price of {stock_symbol} is {price:.2f}\\") # Buy if the price is below the buy_threshold if price <= buy_threshold: self.buy_stock(stock_symbol, price, 1) # Sell if the price is above the sell_threshold elif price >= sell_threshold: self.sell_stock(stock_symbol, price, 1) except Exception as e: logging.error(f\\"Error fetching price for {stock_symbol}: {e}\\") def stop(self): self.running = False def account_summary(self): return { 'balance': self.balance, 'portfolio': self.portfolio, 'transactions': self.transactions, } # Example usage: platform = TradingPlatform() # Start monitoring in a separate thread thread = threading.Thread(target=platform.monitor_stock, args=('AAPL', 103, 107)) thread.start() # Run the monitoring for about 10 seconds for demonstration purposes time.sleep(10) platform.stop() thread.join() # Account summary summary = platform.account_summary() logging.info(f\\"Account Summary: {summary}\\")"},{"question":"class BankAccount: A class to simulate a simple bank account. Attributes: balance (float): The balance of the bank account. account_holder (str): The name of the account holder. def __init__(self, account_holder: str, balance: float = 0.0): self.balance = balance self.account_holder = account_holder def deposit(self, amount: float) -> None: Method to deposit money into the account. Args: amount (float): The amount of money to deposit. self.balance += amount def withdraw(self, amount: float) -> None: Method to withdraw money from the account. Args: amount (float): The amount of money to withdraw. if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount def check_balance(self) -> float: Method to check the balance of the account. Returns: float: The current balance of the account. return self.balance def calculate_interest(self, annual_rate: float, years: int) -> float: Method to calculate interest for a given period based on an annual interest rate. Args: annual_rate (float): The annual interest rate as a percentage. years (int): The number of years to calculate the interest for. Returns: float: The interest amount. interest = self.balance * (annual_rate / 100) * years self.balance += interest return interest class SavingsAccount(BankAccount): A class to simulate a savings account that extends BankAccount. Attributes: withdrawals (int): The number of withdrawals made. def __init__(self, account_holder: str, balance: float = 0.0): super().__init__(account_holder, balance) self.withdrawals = 0 def withdraw(self, amount: float) -> None: Method to withdraw money from the savings account, with additional fee logic. Args: amount (float): The amount of money to withdraw. self.withdrawals += 1 if self.withdrawals % 3 == 0: amount += 2 # Charging an additional fee of 2 every third withdrawal super().withdraw(amount) # Unit tests def test_bank_account_creation(): account = BankAccount(\\"John Doe\\", 100.0) assert account.account_holder == \\"John Doe\\" assert account.balance == 100.0 def test_deposit_method(): account = BankAccount(\\"John Doe\\", 100.0) account.deposit(50.0) assert account.balance == 150.0 def test_withdraw_method(): account = BankAccount(\\"John Doe\\", 100.0) account.withdraw(30.0) assert account.balance == 70.0 def test_check_balance_method(): account = BankAccount(\\"John Doe\\", 100.0) assert account.check_balance() == 100.0 def test_calculate_interest_method(): account = BankAccount(\\"John Doe\\", 100.0) interest = account.calculate_interest(5, 2) assert interest == 10.0 assert account.balance == 110.0 def test_savings_account_creation(): savings_account = SavingsAccount(\\"Jane Doe\\", 200.0) assert savings_account.account_holder == \\"Jane Doe\\" assert savings_account.balance == 200.0 assert savings_account.withdrawals == 0 def test_savings_account_withdrawal(): savings_account = SavingsAccount(\\"Jane Doe\\", 200.0) savings_account.withdraw(50.0) # First withdrawal, no fee assert savings_account.balance == 150.0 assert savings_account.withdrawals == 1 savings_account.withdraw(50.0) # Second withdrawal, no fee assert savings_account.balance == 100.0 assert savings_account.withdrawals == 2 savings_account.withdraw(50.0) # Third withdrawal, with 2 fee assert savings_account.balance == 48.0 assert savings_account.withdrawals == 3 def test_savings_account_insufficient_funds(): savings_account = SavingsAccount(\\"Jane Doe\\", 50.0) try: savings_account.withdraw(51.0) except ValueError as e: assert str(e) == \\"Insufficient funds\\" def test_savings_account_interest(): savings_account = SavingsAccount(\\"Jane Doe\\", 100.0) savings_account.calculate_interest(5, 1) assert savings_account.balance == 105.0","solution":"class BankAccount: def __init__(self, account_holder, balance=0): self.balance = balance self.account_holder = account_holder def deposit(self, amount): self.balance += amount def withdraw(self, amount): if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount def check_balance(self): return self.balance def calculate_interest(self, annual_rate, years): interest = self.balance * (annual_rate / 100) * years self.balance += interest return interest class SavingsAccount(BankAccount): def __init__(self, account_holder, balance=0): super().__init__(account_holder, balance) self.withdrawals = 0 def withdraw(self, amount): self.withdrawals += 1 if self.withdrawals % 3 == 0: amount += 2 # Charging an additional fee of 2 every third withdrawal super().withdraw(amount)"},{"question":"def move_evens_to_front(input_list: list) -> list: Moves all the even numbers to the front of the list, keeping the relative order of the components unchanged. Parameters: input_list (list): The list of integers to rearrange. Returns: list: A new list with all the even numbers at the front. >>> move_evens_to_front([3, 1, 2, 4, 7, 6]) [2, 4, 6, 3, 1, 7] >>> move_evens_to_front([2, 4, 6, 8]) [2, 4, 6, 8] >>> move_evens_to_front([1, 3, 5, 7]) [1, 3, 5, 7] >>> move_evens_to_front([5, 2, 8, 1, 4]) [2, 8, 4, 5, 1] >>> move_evens_to_front([]) [] >>> move_evens_to_front([2]) [2] >>> move_evens_to_front([1]) [1] >>> move_evens_to_front([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> move_evens_to_front([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> move_evens_to_front([1, 2, 3, 4, 5, 6, 7, 8]) [2, 4, 6, 8, 1, 3, 5, 7]","solution":"def move_evens_to_front(input_list): Moves all the even numbers to the front of the list, keeping the relative order of the components unchanged. Parameters: input_list (list): The list of integers to rearrange. Returns: list: A new list with all the even numbers at the front. evens = [x for x in input_list if x % 2 == 0] odds = [x for x in input_list if x % 2 != 0] return evens + odds"},{"question":"from typing import List def find_kth_missing(nums: List[int], k: int) -> int: Given a list of integers nums and an integer k, finds the k-th missing positive integer from nums when sorted in ascending order. Parameters: nums (List[int]): A list of integers that represents available numbers. k (int): The k-th missing positive integer to find. Returns: int: The k-th missing positive integer from the list. Examples: >>> find_kth_missing([2, 3, 4, 7, 11], 5) 9 >>> find_kth_missing([1, 2, 3, 4], 2) 6","solution":"def find_kth_missing(nums, k): Returns the k-th missing positive integer from a sorted list nums. Parameters: nums (List[int]): A list of integers that represents available numbers. k (int): The k-th missing positive integer to find. Returns: int: The k-th missing positive integer from the list. missing_counter = 0 current_num = 1 nums_set = set(nums) while True: if current_num not in nums_set: missing_counter += 1 if missing_counter == k: return current_num current_num += 1"},{"question":"def filter_and_sort_employees(employees): This function filters out employees who are younger than 30, and sorts the remaining employees by their salaries in descending order. If salaries are equal, it will sort by employee names in ascending order. Args: - employees: List[Dict[str, Union[str, int]]], a list of dictionaries with keys 'name', 'age', and 'salary'. Returns: - List[Dict[str, Union[str, int]]]: A new list of dictionaries that has been filtered and sorted. Usage: >>> filter_and_sort_employees([ ... {'name': 'Alice', 'age': 25, 'salary': 70000}, ... {'name': 'Bob', 'age': 32, 'salary': 80000}, ... {'name': 'Charlie', 'age': 30, 'salary': 75000} ... ]) [{'name': 'Bob', 'age': 32, 'salary': 80000}, {'name': 'Charlie', 'age': 30, 'salary': 75000}] >>> filter_and_sort_employees([]) [] >>> filter_and_sort_employees([{'name': 'Alice', 'age': 25, 'salary': 70000}, {'name': 'Bob', 'age': 28, 'salary': 80000}]) []","solution":"def filter_and_sort_employees(employees): This function filters out employees who are younger than 30, and sorts the remaining employees by their salaries in descending order. If salaries are equal, it will sort by employee names in ascending order. Args: - employees: List[Dict[str, Union[str, int]]], a list of dictionaries with keys 'name', 'age', and 'salary'. Returns: - List[Dict[str, Union[str, int]]]: A new list of dictionaries that has been filtered and sorted. if not all(isinstance(emp, dict) and 'name' in emp and 'age' in emp and 'salary' in emp for emp in employees): raise ValueError(\\"All elements must be dictionaries containing 'name', 'age', and 'salary' keys\\") filtered_employees = [emp for emp in employees if emp['age'] >= 30] sorted_employees = sorted(filtered_employees, key=lambda x: (-x['salary'], x['name'])) return sorted_employees"},{"question":"def find_second_largest(arr: List[int]) -> int: Returns the second largest number in the list. If the input list has fewer than two distinct elements, returns None. >>> find_second_largest([4, 1, 7, 3, 6]) == 6 >>> find_second_largest([7, 7, 7]) == None >>> find_second_largest([10, 20, 30, 40, 50]) == 40 >>> find_second_largest([1, 2, 3, 3, 2, 1]) == 2 >>> find_second_largest([5]) == None >>> find_second_largest([]) == None >>> find_second_largest([-1, -2, -3, -4]) == -2 >>> find_second_largest([-1, 0, 1, 2]) == 1 >>> find_second_largest([-5, -2, -3, -6]) == -3","solution":"def find_second_largest(arr): Returns the second largest number in the list. If the input list has fewer than two distinct elements, returns None. if len(arr) < 2: return None unique_numbers = list(set(arr)) if len(unique_numbers) < 2: return None unique_numbers.sort() return unique_numbers[-2]"},{"question":"from typing import List, Dict def count_duplicates(lst: List[str]) -> Dict[str, int]: Write a function that takes a list of strings as input and returns a dictionary. Each key in the dictionary should be a distinct string from the list that appears more than once, and the corresponding value should be the count of its appearances. If the input list contains any non-string items, raise a ValueError with the message \\"List must contain only strings\\". The function should be case-insensitive, meaning \\"Cat\\" and \\"cat\\" should be treated as the same string. >>> count_duplicates([\\"Cat\\", \\"dog\\", \\"cat\\", \\"Dog\\", \\"bird\\"]) {\\"cat\\": 2, \\"dog\\": 2} >>> count_duplicates([\\"apple\\", \\"Apple\\", \\"APPLE\\", \\"banana\\"]) {\\"apple\\": 3} >>> count_duplicates([\\"one\\", \\"two\\", \\"three\\", \\"two\\", \\"three\\", \\"three\\"]) {\\"two\\": 2, \\"three\\": 3} >>> count_duplicates([\\"Cat\\", \\"Dog\\", \\"CAT\\", \\"Dog\\", \\"BIRD\\", \\"bird\\"]) {\\"cat\\": 2, \\"dog\\": 2, \\"bird\\": 2} >>> count_duplicates([\\"Cat\\", \\"Dog\\", \\"Bird\\", 3]) ValueError(\\"List must contain only strings\\") >>> count_duplicates([]) {}","solution":"def count_duplicates(lst): Returns a dictionary with counts of distinct strings in the list that appear more than once. Raises ValueError if the input list contains non-string items. if not all(isinstance(item, str) for item in lst): raise ValueError(\\"List must contain only strings\\") # Count occurrences of each string in a case-insensitive manner counts = {} for item in lst: item_lower = item.lower() if item_lower in counts: counts[item_lower] += 1 else: counts[item_lower] = 1 # Select only those items that appear more than once duplicates = {item: count for item, count in counts.items() if count > 1} return duplicates"},{"question":"def explore_numerical_patterns(start, end, criteria): Create a function to explore possible numerical patterns within a defined range. Implement a function that takes in a starting integer \`start\`, an ending integer \`end\`, and a string \`criteria\`. The function should return a list of all integers within the given range [start, end] (inclusive) that meet the defined criteria. The \`criteria\` string can take the following values: - \\"even\\": select all even numbers. - \\"odd\\": select all odd numbers. - \\"prime\\": select all prime numbers. - \\"palindrome\\": select all numbers that are palindromic. Each selected number must appear only once in the returned list. Examples: >>> explore_numerical_patterns(10, 20, \\"even\\") [10, 12, 14, 16, 18, 20] >>> explore_numerical_patterns(10, 20, \\"odd\\") [11, 13, 15, 17, 19] >>> explore_numerical_patterns(10, 20, \\"prime\\") [11, 13, 17, 19] >>> explore_numerical_patterns(10, 20, \\"palindrome\\") [11]","solution":"def explore_numerical_patterns(start, end, criteria): def is_prime(n): if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def is_palindrome(n): return str(n) == str(n)[::-1] result = [] for num in range(start, end + 1): if criteria == \\"even\\" and num % 2 == 0: result.append(num) elif criteria == \\"odd\\" and num % 2 != 0: result.append(num) elif criteria == \\"prime\\" and is_prime(num): result.append(num) elif criteria == \\"palindrome\\" and is_palindrome(num): result.append(num) return result"},{"question":"import random def generate_server_data(num_servers): Generates random latency (ms) and bandwidth (Mbps) values for a number of servers. Parameters: num_servers (int): The number of servers to generate data for. Returns: list of dict: A list of dictionaries containing latency and bandwidth values. # Your implementation here def analyze_servers(servers): Analyzes server data to find critical issues and determine best and worst-performing servers. Parameters: servers (list of dict): A list of dictionaries containing latency and bandwidth values. Returns: dict: A summary of critical issues, best and worst-performing servers. # Your implementation here def simulate_network_test(num_servers): Simulates a network latency and bandwidth test for multiple servers. Parameters: num_servers (int): The number of servers to test. Returns: dict: A summary of the test results including critical issues and best/worst performing servers. # Your implementation here from generate_server_data import generate_server_data from analyze_servers import analyze_servers from simulate_network_test import simulate_network_test def test_generate_server_data(): servers = generate_server_data(5) assert len(servers) == 5 for server in servers: assert 1 <= server[\\"latency\\"] <= 1500 assert 0.5 <= server[\\"bandwidth\\"] <= 20.0 def test_analyze_servers(): servers = [ {\\"server_id\\": \\"server_1\\", \\"latency\\": 35, \\"bandwidth\\": 10}, {\\"server_id\\": \\"server_2\\", \\"latency\\": 450, \\"bandwidth\\": 7}, {\\"server_id\\": \\"server_3\\", \\"latency\\": 1200, \\"bandwidth\\": 0.8}, {\\"server_id\\": \\"server_4\\", \\"latency\\": 250, \\"bandwidth\\": 15} ] result = analyze_servers(servers) assert len(result[\\"critical_issues\\"]) == 1 assert result[\\"critical_issues\\"][0][\\"server_id\\"] == \\"server_3\\" assert result[\\"best_latency_server\\"][\\"server_id\\"] == \\"server_1\\" assert result[\\"worst_latency_server\\"][\\"server_id\\"] == \\"server_3\\" assert result[\\"best_bandwidth_server\\"][\\"server_id\\"] == \\"server_4\\" assert result[\\"worst_bandwidth_server\\"][\\"server_id\\"] == \\"server_3\\" def test_simulate_network_test(): result = simulate_network_test(3) assert \\"critical_issues\\" in result assert \\"best_latency_server\\" in result assert \\"worst_latency_server\\" in result assert \\"best_bandwidth_server\\" in result assert \\"worst_bandwidth_server\\" in result","solution":"import random def generate_server_data(num_servers): Generates random latency (ms) and bandwidth (Mbps) values for a number of servers. Parameters: num_servers (int): The number of servers to generate data for. Returns: list of dict: A list of dictionaries containing latency and bandwidth values. servers = [] for i in range(num_servers): latency = random.randint(1, 1500) # Random latency between 1 and 1500 ms bandwidth = round(random.uniform(0.5, 20.0), 2) # Random bandwidth between 0.5 and 20 Mbps servers.append({\\"server_id\\": f\\"server_{i+1}\\", \\"latency\\": latency, \\"bandwidth\\": bandwidth}) return servers def analyze_servers(servers): Analyzes server data to find critical issues and determine best and worst-performing servers. Parameters: servers (list of dict): A list of dictionaries containing latency and bandwidth values. Returns: dict: A summary of critical issues, best and worst-performing servers. critical_issues = [] best_latency_server = min(servers, key=lambda x: x[\\"latency\\"]) worst_latency_server = max(servers, key=lambda x: x[\\"latency\\"]) best_bandwidth_server = max(servers, key=lambda x: x[\\"bandwidth\\"]) worst_bandwidth_server = min(servers, key=lambda x: x[\\"bandwidth\\"]) for server in servers: if server[\\"latency\\"] > 1000 or server[\\"bandwidth\\"] < 1: critical_issues.append(server) return { \\"critical_issues\\": critical_issues, \\"best_latency_server\\": best_latency_server, \\"worst_latency_server\\": worst_latency_server, \\"best_bandwidth_server\\": best_bandwidth_server, \\"worst_bandwidth_server\\": worst_bandwidth_server } def simulate_network_test(num_servers): servers = generate_server_data(num_servers) return analyze_servers(servers)"},{"question":"def reverse_string(string: str) -> str: Takes a string as input and returns the string reversed, with all non-alphabetic characters remaining in their original positions. >>> reverse_string(\\"a,bc\\") \\"c,ba\\" >>> reverse_string(\\"a, b c\\") \\"c, b a\\" >>> reverse_string(\\"abcdef\\") \\"fedcba\\" >>> reverse_string(\\"12345!@#%\\") \\"12345!@#%\\" >>> reverse_string(\\"a!b@c#d\\") \\"d!c@b#a\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"!\\") \\"!\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"aaa!!!bbb\\") \\"bbb!!!aaa\\" >>> long_input = \\"a\\"*500 + \\"1\\" + \\"b\\"*500 >>> long_expected = \\"b\\"*500 + \\"1\\" + \\"a\\"*500 >>> reverse_string(long_input) long_expected","solution":"def reverse_string(string: str) -> str: Takes a string as input and returns the string reversed, with all non-alphabetic characters remaining in their original positions. # Extracting only alphabetic characters and reversing them. alphabets = [char for char in string if char.isalpha()] alphabets.reverse() # Using a list to construct the output string. result = [] alpha_index = 0 for char in string: if char.isalpha(): result.append(alphabets[alpha_index]) alpha_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def is_leap_year(year: int) -> bool: Determines if a given year is a leap year. Args: year (int): The year to be checked. Returns: bool: True if the year is a leap year, False otherwise. Example: >>> is_leap_year(2000) True >>> is_leap_year(1900) False >>> is_leap_year(2012) True >>> is_leap_year(2019) False def test_year_divisible_by_400(): assert is_leap_year(2000) == True assert is_leap_year(2400) == True def test_year_divisible_by_100_not_400(): assert is_leap_year(1900) == False assert is_leap_year(2100) == False def test_year_divisible_by_4_not_100(): assert is_leap_year(2012) == True assert is_leap_year(2020) == True def test_year_not_divisible_by_4(): assert is_leap_year(2019) == False assert is_leap_year(2018) == False def test_edge_cases(): assert is_leap_year(1) == False assert is_leap_year(4) == True assert is_leap_year(100) == False assert is_leap_year(400) == True","solution":"def is_leap_year(year: int) -> bool: Determines if a given year is a leap year. Args: year (int): The year to be checked. Returns: bool: True if the year is a leap year, False otherwise. if year % 400 == 0: return True if year % 100 == 0: return False if year % 4 == 0: return True return False"},{"question":"def filter_and_sort_primes(numbers: List[int]) -> List[int]: This function takes a list of integers and returns a list with only the prime numbers sorted in ascending order. :param numbers: List of integers. :return: List of sorted prime numbers. >>> filter_and_sort_primes([]) == [] >>> filter_and_sort_primes([1, 4, 6, 8, 10, 12]) == [] >>> filter_and_sort_primes([4, 6, 7, 1, 2, 13, 11, 8]) == [2, 7, 11, 13] >>> filter_and_sort_primes([2, 3, 5, 7, 11, 13, 17]) == [2, 3, 5, 7, 11, 13, 17] >>> filter_and_sort_primes([19, 3, 2, 23, 17]) == [2, 3, 17, 19, 23]","solution":"def is_prime(n): Helper function to check if a number n is a prime number. if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def filter_and_sort_primes(numbers): This function takes a list of integers and returns a list with only the prime numbers sorted in ascending order. :param numbers: List of integers. :return: List of sorted prime numbers. if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers.\\") for num in numbers: if not isinstance(num, int): raise ValueError(\\"All elements in the input list must be integers.\\") prime_numbers = [num for num in numbers if is_prime(num)] return sorted(prime_numbers)"},{"question":"def reorder_and_find_position(fruits: list, fruit_name: str) -> int: Reorders the fruits list in alphabetical order and finds the position of the specified fruit. Parameters: fruits (list): A list of fruit names as strings. fruit_name (str): The name of the fruit to find the position of after sorting. Returns: int: The position of the specified fruit in the sorted list. >>> reorder_and_find_position([\\"banana\\", \\"apple\\", \\"cherry\\", \\"mango\\", \\"pear\\", \\"peach\\"], \\"mango\\") 3 >>> reorder_and_find_position([\\"banana\\", \\"apple\\", \\"cherry\\", \\"mango\\", \\"pear\\", \\"peach\\"], \\"apple\\") 0 >>> reorder_and_find_position([\\"banana\\", \\"apple\\", \\"cherry\\", \\"mango\\", \\"pear\\", \\"peach\\"], \\"pear\\") 5","solution":"def reorder_and_find_position(fruits, fruit_name): Reorders the fruits list in alphabetical order and finds the position of the specified fruit. Parameters: fruits (list): A list of fruit names as strings. fruit_name (str): The name of the fruit to find the position of after sorting. Returns: int: The position of the specified fruit in the sorted list. fruits.sort() # Sort the list in alphabetical order return fruits.index(fruit_name) # Return the position (index) of the specified fruit"},{"question":"def memoize(func): Define a decorator \`memoize\` that will store the results of function calls in a dictionary, using the function inputs as keys. cache = {} def memoized_func(*args): if args in cache: return cache[args] result = func(*args) cache[args] = result return result return memoized_func @memoize def fib(n): Function to calculate the nth Fibonacci number. >>> fib(0) 0 >>> fib(1) 1 >>> fib(2) 1 >>> fib(10) 55 >>> fib(20) 6765 if n <= 1: return n return fib(n - 1) + fib(n - 2)","solution":"def memoize(func): cache = {} def memoized_func(*args): if args in cache: return cache[args] result = func(*args) cache[args] = result return result return memoized_func @memoize def fib(n): if n <= 1: return n return fib(n - 1) + fib(n - 2)"},{"question":"from typing import List def min_steps_to_reach_end(grid: List[List[int]]) -> int: You are developing a game where the player must navigate a character through a grid with obstacles. The grid is an \`n x n\` matrix, where each cell can either be empty (represented by a \`0\`) or contain an obstacle (represented by a \`1\`). The character starts at the top-left corner of the grid \`(0, 0)\` and must reach the bottom-right corner \`(n-1, n-1)\`. The character can move up, down, left, or right. The player can also push obstacles out of the way, but only if there is an empty space immediately behind the obstacle in the direction of the push. Each movement (including pushing an obstacle) counts as one step. Write a function \`min_steps_to_reach_end(grid: List[List[int]]) -> int\` that takes as input a 2D list representing the grid and returns the minimum number of steps required to reach the bottom-right corner. If it is not possible to reach the bottom-right corner, return \`-1\`. Example: >>> grid = [ >>> [0, 0, 0, 0], >>> [1, 1, 0, 1], >>> [0, 0, 0, 0], >>> [0, 1, 1, 0] >>> ] >>> min_steps_to_reach_end(grid) 7 pass def test_min_steps_to_reach_end_simple_path(): grid = [ [0, 0], [0, 0] ] assert min_steps_to_reach_end(grid) == 2 def test_min_steps_to_reach_end_with_obstacles(): grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] assert min_steps_to_reach_end(grid) == 7 def test_min_steps_to_reach_end_no_possible_path(): grid = [ [0, 1], [1, 0] ] assert min_steps_to_reach_end(grid) == -1 def test_min_steps_to_reach_end_large_grid(): grid = [[0]*10 for _ in range(10)] assert min_steps_to_reach_end(grid) == 18 def test_min_steps_to_reach_end_all_obstacles(): grid = [ [0, 1, 1], [1, 1, 1], [1, 1, 0] ] assert min_steps_to_reach_end(grid) == -1 def test_min_steps_to_reach_end_edge_case_single_cell(): grid = [ [0] ] assert min_steps_to_reach_end(grid) == 0","solution":"from typing import List, Tuple from collections import deque def min_steps_to_reach_end(grid: List[List[int]]) -> int: n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == n-1 and col == n-1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and (new_row, new_col) not in visited: if grid[new_row][new_col] == 0: queue.append((new_row, new_col, steps + 1)) visited.add((new_row, new_col)) elif grid[new_row][new_col] == 1: pushing_row, pushing_col = new_row + dr, new_col + dc if 0 <= pushing_row < n and 0 <= pushing_col < n and (pushing_row, pushing_col) not in visited and grid[pushing_row][pushing_col] == 0: grid[new_row][new_col] = 0 # Push the obstacle queue.append((new_row, new_col, steps + 2)) # Pushing counts as 2 steps visited.add((new_row, new_col)) return -1"},{"question":"def second_smallest_element(arr: List[int]) -> int: Returns the second smallest element in the list or None if fewer than two distinct elements are present. >>> second_smallest_element([4, 2, 6, 1, 3]) == 2 >>> second_smallest_element([7, 7, 7, 7]) == None >>> second_smallest_element([1]) == None >>> second_smallest_element([4, -2, 0, 4, 3]) == 0 >>> second_smallest_element([3, 1, 3, 2, 2]) == 2","solution":"def second_smallest_element(arr): Returns the second smallest element in the list or None if fewer than two distinct elements are present. if len(arr) < 2: return None first, second = float('inf'), float('inf') for num in arr: if num < first: second = first first = num elif first < num < second: second = num return second if second != float('inf') else None"},{"question":"from typing import List def F(M: List[List[int]]) -> int: Given an n x n matrix M, returns the value of the function F(M) as defined in the problem. >>> F([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 751 >>> F([[5]]) 5 >>> F([[1, 2], [3, 4]]) 34 >>> F([[0, 2], [3, 4]]) 10 >>> F([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 27","solution":"from functools import reduce def F(M): Given an n x n matrix M, returns the value of function F(M) as defined in the problem. n = len(M) total_sum = 0 for i in range(n): for j in range(n): submatrix_product = 1 for x in range(i, n): for y in range(j, n): submatrix_product *= M[x][y] total_sum += submatrix_product return total_sum"},{"question":"def remove_duplicates(s: str) -> str: Removes duplicate characters from the string such that each character appears only once and the output string remains in the order of the first occurrence of each character. >>> remove_duplicates(\\"programming\\") == \\"progamin\\" >>> remove_duplicates(\\"abc\\") == \\"abc\\" >>> remove_duplicates(\\"aaaaaaa\\") == \\"a\\" >>> remove_duplicates(\\"\\") == \\"\\" >>> remove_duplicates(\\"aabbccabc\\") == \\"abc\\" pass","solution":"def remove_duplicates(s): Removes duplicate characters from the string such that each character appears only once and the output string remains in the order of the first occurrence of each character. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list where each integer is replaced by the product of all the other integers in the list, without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6] >>> product_except_self([0, 0, 0]) [0, 0, 0] >>> product_except_self([10]) [1] >>> product_except_self([3, 7]) [7, 3] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6]","solution":"def product_except_self(nums): Given a list of integers, returns a new list where each integer is replaced by the product of all the other integers in the list, without using division. n = len(nums) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"from typing import List def employee_id_check(employee_ids: List[int], queries: List[int]) -> List[str]: Checks if a given employee ID exists in the list of employee IDs. Parameters: employee_ids (List[int]): List of employee IDs. queries (List[int]): List of queries to check for existence in employee_ids. Returns: List[str]: List of \\"Yes\\" or \\"No\\" based on query results. Example: >>> employee_ids = [1001, 1002, 1003, 1004, 1005] >>> queries = [1003, 1006, 1001] >>> employee_id_check(employee_ids, queries) ['Yes', 'No', 'Yes']","solution":"from typing import List def employee_id_check(employee_ids: List[int], queries: List[int]) -> List[str]: Checks if a given employee ID exists in the list of employee IDs. Parameters: employee_ids (List[int]): List of employee IDs. queries (List[int]): List of queries to check for existence in employee_ids. Returns: List[str]: List of \\"Yes\\" or \\"No\\" based on query results. employee_set = set(employee_ids) # Convert list to set for O(1) average-time complexity on lookups result = [\\"Yes\\" if q in employee_set else \\"No\\" for q in queries] return result"},{"question":"class Product: def __init__(self, identifier: str, name: str, quantity: int, price: float): This class represents a product in the inventory. self.identifier = identifier.lower() self.name = name.lower() self.quantity = quantity self.price = price def __str__(self): Returns the product details as a string. return f\\"ID: {self.identifier}, Name: {self.name.capitalize()}, Quantity: {self.quantity}, Price: {self.price:.2f}\\" class InventoryManager: def __init__(self): Initializes an empty inventory. self.inventory = {} def add_product(self, identifier: str, name: str, quantity: int, price: float): Adds a new product to the inventory. Raises ValueError if a product with the same identifier already exists. pass def update_product(self, identifier: str, quantity: int = None, price: float = None): Updates the quantity and/or price of an existing product. Raises KeyError if the product does not exist. pass def remove_product(self, identifier: str): Removes a product from the inventory based on its identifier. Raises KeyError if the product does not exist. pass def get_inventory(self): Returns a list of current inventory, sorted by product name. pass def search_product(self, identifier: str = None, name: str = None): Searches for a product by identifier or name and returns its details. Raises KeyError if the product is not found. pass # Example Usage inventory = InventoryManager() inventory.add_product(\\"001\\", \\"Apple\\", 50, 0.50) inventory.add_product(\\"002\\", \\"Banana\\", 100, 0.20) print(inventory.get_inventory()) inventory.update_product(\\"001\\", quantity=75, price=0.55) print(inventory.search_product(name=\\"Apple\\")) inventory.remove_product(\\"002\\") print(inventory.get_inventory()) inventory.add_product(\\"003\\", \\"Orange\\", 150, 0.30) inventory.add_product(\\"004\\", \\"Grapes\\", 200, 2.50) print(inventory.get_inventory())","solution":"class Product: def __init__(self, identifier: str, name: str, quantity: int, price: float): self.identifier = identifier.lower() self.name = name.lower() self.quantity = quantity self.price = price def __str__(self): return f\\"ID: {self.identifier}, Name: {self.name.capitalize()}, Quantity: {self.quantity}, Price: {self.price:.2f}\\" class InventoryManager: def __init__(self): self.inventory = {} def add_product(self, identifier: str, name: str, quantity: int, price: float): if identifier.lower() in self.inventory: raise ValueError(\\"Product with this identifier already exists.\\") self.inventory[identifier.lower()] = Product(identifier, name, quantity, price) def update_product(self, identifier: str, quantity: int = None, price: float = None): identifier = identifier.lower() if identifier not in self.inventory: raise KeyError(\\"Product with this identifier does not exist.\\") if quantity is not None: self.inventory[identifier].quantity = quantity if price is not None: self.inventory[identifier].price = price def remove_product(self, identifier: str): identifier = identifier.lower() if identifier not in self.inventory: raise KeyError(\\"Product with this identifier does not exist.\\") del self.inventory[identifier] def get_inventory(self): return sorted([str(product) for product in self.inventory.values()], key=lambda x: x.split(\\",\\")[1]) def search_product(self, identifier: str = None, name: str = None): if identifier: identifier = identifier.lower() if identifier in self.inventory: return str(self.inventory[identifier]) if name: name = name.lower() for product in self.inventory.values(): if product.name == name: return str(product) raise KeyError(\\"Product not found.\\")"},{"question":"def largest_square(matrix): Returns the area of the largest square containing only 1's. >>> matrix1 = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> largest_square(matrix1) 4 >>> matrix2 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> largest_square(matrix2) 0 >>> matrix3 = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largest_square(matrix3) 9 >>> matrix4 = [[1]] >>> largest_square(matrix4) 1 >>> matrix5 = [[0]] >>> largest_square(matrix5) 0 >>> matrix6 = [] >>> largest_square(matrix6) 0 >>> matrix7 = [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1], ... ] >>> largest_square(matrix7) 1 >>> matrix8 = [ ... [1, 0, 1, 1], ... [1, 1, 1, 1] ... ] >>> largest_square(matrix8) 4","solution":"def largest_square(matrix): Returns the area of the largest square containing only 1's. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: Convert a binary tree into its mirror image. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The root node of the mirrored binary tree. Examples: >>> tree = TreeNode(1, TreeNode(2), TreeNode(3)) >>> mirrored_tree = mirror_tree(tree) >>> assert mirrored_tree.val == 1 >>> assert mirrored_tree.left.val == 3 >>> assert mirrored_tree.right.val == 2 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively mirror the left and right subtrees if root.left: mirror_tree(root.left) if root.right: mirror_tree(root.right) return root"},{"question":"def group_strings(strings: List[str], n: int) -> List[List[str]]: Groups a list of strings into sublists each containing n strings. Args: strings (list of str): The list of strings to group. n (int): The number of strings per group. Returns: list of list of str: The list of grouped strings. Raises: ValueError: If n is zero or negative. >>> group_strings(['a', 'b', 'c', 'd'], 2) [['a', 'b'], ['c', 'd']] >>> group_strings(['a', 'b', 'c', 'd', 'e'], 2) [['a', 'b'], ['c', 'd'], ['e']] >>> group_strings(['a'], 1) [['a']] >>> group_strings([], 2) [] >>> group_strings(['a', 'b', 'c'], 5) [['a', 'b', 'c']] >>> group_strings(['a', 'b'], -1) Traceback (most recent call last): ... ValueError: n must be a positive integer. >>> group_strings(['a', 'b'], 0) Traceback (most recent call last): ... ValueError: n must be a positive integer. # Your code here","solution":"def group_strings(strings, n): Groups a list of strings into sublists each containing n strings. Args: strings (list of str): The list of strings to group. n (int): The number of strings per group. Returns: list of list of str: The list of grouped strings. Raises: ValueError: If n is zero or negative. if n <= 0: raise ValueError(\\"n must be a positive integer.\\") grouped_strings = [strings[i:i + n] for i in range(0, len(strings), n)] return grouped_strings"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression given as a string with addition and multiplication. Parameters: expression (str): The string representing the expression to evaluate. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"3*5\\") 15 >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"3+5*2+8*3+4\\") 41 >>> evaluate_expression(\\"(3+5)*2\\") 16 >>> evaluate_expression(\\"((2+3)*(5+2))\\") 35 >>> evaluate_expression(\\"2*(5+5*3)+10\\") 50 >>> evaluate_expression(\\"999999*999999+1\\") 999998000002 >>> evaluate_expression(\\"12345\\") 12345","solution":"def evaluate_expression(expression): Evaluates a mathematical expression given as a string with addition and multiplication. Parameters: expression (str): The string representing the expression to evaluate. Returns: int: The result of the evaluated expression. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '*': values.append(left * right) def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) > 0 and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) > 0: apply_operator(operators, values) return values[-1]"},{"question":"import re from collections import defaultdict from typing import Dict def word_count(text: str) -> Dict[str, int]: Count the frequency of each word in a given text. Words are case-insensitive, and punctuation is ignored. >>> word_count(\\"Hello, world! Hello Python. python programming.\\") {'hello': 2, 'world': 1, 'python': 2, 'programming': 1} >>> word_count(\\"\\") {} >>> word_count(\\"!!!@@@#\\") {} >>> word_count(\\"Hello hello HeLLo\\") {'hello': 3} >>> word_count(\\"123 123 456! 789 123\\") {'123': 3, '456': 1, '789': 1} # TODO: Implement this function","solution":"import re from collections import defaultdict def word_count(text): Returns a dictionary of each word's frequency in the given text. Words are case-insensitive and punctuation is ignored. # Using regex to find alphanumeric words words = re.findall(r'bw+b', text.lower()) frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"def count_characters(s: str) -> dict: Returns a dictionary with the counts of each unique character in the string, ignoring whitespace. The counting is case-sensitive. Example: >>> count_characters(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_characters(\\"hello world\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_characters(\\"aA\\") {'a': 1, 'A': 1} >>> count_characters(\\"aAa!@#\\") {'a': 2, 'A': 1, '!': 1, '@': 1, '#': 1} >>> count_characters(\\"\\") {} >>> count_characters(\\"Hello World 123!\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1, '1': 1, '2': 1, '3': 1, '!': 1}","solution":"def count_characters(s): Returns a dictionary with the counts of each unique character in the string, ignoring whitespace. The counting is case-sensitive. result = {} for char in s: if not char.isspace(): if char in result: result[char] += 1 else: result[char] = 1 return result"},{"question":"def is_palindrome(s: str) -> bool: Determines if the provided string is a palindrome, considering only alphanumeric characters and ignoring case sensitivity. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\" \\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"1234 5678\\") == False >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"1\\") == True","solution":"def is_palindrome(s): Returns True if the provided string is a palindrome, considering only alphanumeric characters and ignoring case sensitivity. s = s.lower() s = ''.join(e for e in s if e.isalnum()) return s == s[::-1] # Computational complexity: O(n) where n is the length of the string as we traverse the string multiple times."},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of an integer n. def list_with_sum_of_digits(lst: List[int]) -> List[Tuple[int, int]]: Returns a list of tuples where each tuple contains an integer from the original list and the sum of its digits. >>> list_with_sum_of_digits([123]) [(123, 6)] >>> list_with_sum_of_digits([0]) [(0, 0)] >>> list_with_sum_of_digits([-123]) [(-123, 6)] >>> list_with_sum_of_digits([10, 20, 30]) [(10, 1), (20, 2), (30, 3)] >>> list_with_sum_of_digits([111, 222, 333]) [(111, 3), (222, 6), (333, 9)] >>> list_with_sum_of_digits([0, -1, 2, -123, 456]) [(0, 0), (-1, 1), (2, 2), (-123, 6), (456, 15)] >>> list_with_sum_of_digits([123456789]) [(123456789, 45)] >>> list_with_sum_of_digits([-987654321]) [(-987654321, 45)]","solution":"def sum_of_digits(n): Returns the sum of the digits of an integer n. return sum(int(digit) for digit in str(abs(n))) def list_with_sum_of_digits(lst): Returns a list of tuples with each integer and the sum of its digits. return [(num, sum_of_digits(num)) for num in lst]"},{"question":"def remove_duplicates_and_sort(int_list): Removes duplicates from the list, sorts it in ascending order, and returns the sorted list. >>> remove_duplicates_and_sort([4, 1, 2, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([10, 9, 8, 8, 10, 7]) [7, 8, 9, 10] >>> remove_duplicates_and_sort([]) [] pass def calculate_median(sorted_list): Calculates and returns the median of a sorted list. >>> calculate_median([1, 2, 3, 4, 5]) 3 >>> calculate_median([1, 2, 3, 4, 5, 6]) 3.5 >>> calculate_median([1]) 1 >>> calculate_median([]) raises ValueError(\\"The list is empty, median cannot be calculated.\\") pass def check_integer_existence(sorted_list, query): Checks if the integer exists in the sorted list and returns its position if it exists. If does not exist, returns -1. >>> check_integer_existence([1, 2, 3, 4, 5], 3) 2 >>> check_integer_existence([1, 2, 3, 4, 5], 6) -1 >>> check_integer_existence([], 1) -1 >>> check_integer_existence([1, 2, 3, 4, 5], 1) 0 >>> check_integer_existence([1, 2, 3, 4, 5], 5) 4 pass","solution":"def remove_duplicates_and_sort(int_list): Removes duplicates from the list, sorts it in ascending order, and returns the sorted list. return sorted(set(int_list)) def calculate_median(sorted_list): Calculates and returns the median of a sorted list. n = len(sorted_list) if n == 0: raise ValueError(\\"The list is empty, median cannot be calculated.\\") mid = n // 2 if n % 2 == 0: # Even number of elements median = (sorted_list[mid - 1] + sorted_list[mid]) / 2.0 else: # Odd number of elements median = sorted_list[mid] return median def check_integer_existence(sorted_list, query): Checks if the integer exists in the sorted list and returns its position if it exists. If does not exist, returns -1. try: index = sorted_list.index(query) return index except ValueError: return -1"},{"question":"def create_fruit_weight_dict(): Creates a dictionary mapping fruit names to their average weights in grams. pass def get_fruit_weight(fruit_weights, fruit_name): Retrieves the average weight of the given fruit. Parameters: fruit_weights (dict): A dictionary mapping fruit names to their average weights. fruit_name (str): The name of the fruit to get the average weight for. Returns: float: The average weight of the fruit, or None if the fruit is not found. pass from solution import create_fruit_weight_dict, get_fruit_weight def test_create_fruit_weight_dict(): fruit_weights = create_fruit_weight_dict() assert len(fruit_weights) == 5 assert set(fruit_weights.keys()) == {\\"apple\\", \\"banana\\", \\"cherry\\", \\"grape\\", \\"orange\\"} def test_get_fruit_weight_existing_fruit(): fruit_weights = create_fruit_weight_dict() assert get_fruit_weight(fruit_weights, \\"apple\\") == 182.0 assert get_fruit_weight(fruit_weights, \\"banana\\") == 118.0 def test_get_fruit_weight_non_existing_fruit(): fruit_weights = create_fruit_weight_dict() assert get_fruit_weight(fruit_weights, \\"pear\\") is None def test_get_fruit_weight_case_sensitivity(): fruit_weights = create_fruit_weight_dict() assert get_fruit_weight(fruit_weights, \\"Apple\\") is None # should be case-sensitive","solution":"def create_fruit_weight_dict(): Creates a dictionary mapping fruit names to their average weights in grams. fruit_weights = { \\"apple\\": 182.0, \\"banana\\": 118.0, \\"cherry\\": 8.2, \\"grape\\": 2.4, \\"orange\\": 130.0 } return fruit_weights def get_fruit_weight(fruit_weights, fruit_name): Retrieves the average weight of the given fruit. Parameters: fruit_weights (dict): A dictionary mapping fruit names to their average weights. fruit_name (str): The name of the fruit to get the average weight for. Returns: float: The average weight of the fruit, or None if the fruit is not found. return fruit_weights.get(fruit_name)"},{"question":"import csv import os class Inventory: def __init__(self, filename): Initializes the inventory with the given filename. If the file does not exist, creates a new CSV file with header 'Item' and 'Quantity'. def add_item(self, item, quantity): Adds a new item with its quantity to the inventory. If the item already exists, informs the user to use update_quantity. def delete_item(self, item): Deletes an item from the inventory. If the item is not found, informs the user that the item doesn't exist. def update_quantity(self, item, quantity): Updates the quantity of an existing item in the inventory. If the item is not found, informs the user that the item doesn't exist. def display_inventory(self): Displays current items and their quantities in the inventory. def load_inventory(self): Loads inventory data from the CSV file. Returns the inventory as a dictionary with item names as keys and quantities as values. If there's an error reading the file, informs the user. def save_inventory(self, inventory): Saves the current state of the inventory to the CSV file. import pytest @pytest.fixture def inventory_file(): file_name = 'test_inventory.csv' if os.path.exists(file_name): os.remove(file_name) return file_name def test_add_item(inventory_file): inventory = Inventory(inventory_file) inventory.add_item('Apple', 10) data = inventory.load_inventory() assert data == {'Apple': 10} def test_add_existing_item(inventory_file): inventory = Inventory(inventory_file) inventory.add_item('Apple', 10) inventory.add_item('Apple', 15) data = inventory.load_inventory() assert data == {'Apple': 10} def test_delete_item(inventory_file): inventory = Inventory(inventory_file) inventory.add_item('Banana', 5) inventory.delete_item('Banana') data = inventory.load_inventory() assert 'Banana' not in data def test_delete_non_existing_item(inventory_file): inventory = Inventory(inventory_file) inventory.delete_item('Orange') data = inventory.load_inventory() assert 'Orange' not in data def test_update_quantity(inventory_file): inventory = Inventory(inventory_file) inventory.add_item('Grapes', 12) inventory.update_quantity('Grapes', 7) data = inventory.load_inventory() assert data == {'Grapes': 7} def test_update_non_existing_item(inventory_file): inventory = Inventory(inventory_file) inventory.update_quantity('Strawberry', 5) data = inventory.load_inventory() assert 'Strawberry' not in data def test_display_inventory(inventory_file, capsys): inventory = Inventory(inventory_file) inventory.add_item('Pineapple', 3) inventory.display_inventory() captured = capsys.readouterr() assert \\"Item: Pineapple, Quantity: 3\\" in captured.out","solution":"import csv import os class Inventory: def __init__(self, filename): self.filename = filename if not os.path.isfile(self.filename): with open(self.filename, mode='w', newline='') as file: writer = csv.writer(file) writer.writerow(['Item', 'Quantity']) def add_item(self, item, quantity): inventory = self.load_inventory() if item in inventory: print(f\\"Item '{item}' already exists. Use update_quantity to change the quantity.\\") return with open(self.filename, 'a', newline='') as file: writer = csv.writer(file) writer.writerow([item, quantity]) def delete_item(self, item): inventory = self.load_inventory() if item not in inventory: print(f\\"Item '{item}' not found in inventory.\\") return inventory.pop(item) self.save_inventory(inventory) def update_quantity(self, item, quantity): inventory = self.load_inventory() if item not in inventory: print(f\\"Item '{item}' not found in inventory.\\") return inventory[item] = quantity self.save_inventory(inventory) def display_inventory(self): inventory = self.load_inventory() for item, quantity in inventory.items(): print(f\\"Item: {item}, Quantity: {quantity}\\") def load_inventory(self): inventory = {} try: with open(self.filename, 'r', newline='') as file: reader = csv.DictReader(file) for row in reader: inventory[row['Item']] = int(row['Quantity']) except Exception as e: print(f\\"Error reading inventory file: {e}\\") return inventory def save_inventory(self, inventory): with open(self.filename, 'w', newline='') as file: writer = csv.writer(file) writer.writerow(['Item', 'Quantity']) for item, quantity in inventory.items(): writer.writerow([item, quantity])"},{"question":"def capitalize_words(input_string: str) -> str: Takes a string consisting of words separated by spaces and capitalizes the first letter of each word in the string. Fully capitalized words remain unchanged. >>> capitalize_words(\\"\\") == \\"\\" >>> capitalize_words(\\"hello\\") == \\"Hello\\" >>> capitalize_words(\\"HELLO\\") == \\"HELLO\\" >>> capitalize_words(\\"hello world\\") == \\"Hello World\\" >>> capitalize_words(\\"hello WORLD this is a TEST\\") == \\"Hello WORLD This Is A TEST\\" >>> capitalize_words(\\" hello WORLD \\") == \\"Hello WORLD\\" >>> capitalize_words(\\"HELLO WORLD TEST\\") == \\"HELLO WORLD TEST\\" >>> capitalize_words(\\"hello world test\\") == \\"Hello World Test\\" >>> capitalize_words(\\"heLLo WoRLd\\") == \\"Hello World\\"","solution":"def capitalize_words(input_string): Takes a string consisting of words separated by spaces and capitalizes the first letter of each word in the string. Fully capitalized words remain unchanged. def capitalize_word(word): if word.isupper(): return word else: return word[0].upper() + word[1:].lower() if word else \\"\\" words = input_string.split() capitalized_words = [capitalize_word(word) for word in words] return ' '.join(capitalized_words)"},{"question":"def compress_string(text: str) -> str: Compresses the string using run-length encoding (RLE). If a character appears only once, it should not be followed by a number. :param text: A string containing only alphabetic characters. :return: The compressed string.","solution":"def compress_string(text): Compresses the string using run-length encoding (RLE). If a character appears only once, it should not be followed by a number. :param text: A string containing only alphabetic characters. :return: The compressed string. if not text: return \\"\\" compressed = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char) if count > 1: compressed.append(str(count)) prev_char = char count = 1 # Append the last character and its count compressed.append(prev_char) if count > 1: compressed.append(str(count)) return ''.join(compressed)"},{"question":"from typing import List, Optional from fastapi import FastAPI, APIRouter, Depends, HTTPException from sqlalchemy.orm import Session from pydantic import BaseModel from datetime import datetime app = FastAPI() class TradeCreate(BaseModel): symbol: str price: float quantity: int strategy: str class TradeRead(TradeCreate): id: int timestamp: datetime class Config: orm_mode = True from sqlalchemy import Column, Integer, String, Float, DateTime, func from app.db.base import Base class Trade(Base): __tablename__ = \\"trades\\" id = Column(Integer, primary_key=True, index=True) symbol = Column(String, index=True) price = Column(Float, nullable=False) quantity = Column(Integer, nullable=False) strategy = Column(String, nullable=False) timestamp = Column(DateTime, server_default=func.now()) from app.db.session import get_db class TradingService: def __init__(self, db: Session): self.db = db def create_trade(self, trade_create: TradeCreate) -> Optional[TradeRead]: new_trade = Trade(**trade_create.dict()) self.db.add(new_trade) self.db.commit() self.db.refresh(new_trade) return TradeRead.from_orm(new_trade) def get_trade(self, trade_id: int) -> Optional[TradeRead]: trade = self.db.query(Trade).filter(Trade.id == trade_id).first() if trade: return TradeRead.from_orm(trade) return None def get_trades(self, skip: int = 0, limit: int = 10) -> List[TradeRead]: trades = self.db.query(Trade).offset(skip).limit(limit).all() return [TradeRead.from_orm(trade) for trade in trades] router = APIRouter() @router.post(\\"/trades\\", response_model=TradeRead) def create_trade(trade: TradeCreate, db: Session = Depends(get_db)): Create a new trade using the provided trade details. trading_service = TradingService(db) created_trade = trading_service.create_trade(trade) if not created_trade: raise HTTPException(status_code=400, detail=\\"Trade could not be created\\") return created_trade @router.get(\\"/trades/{trade_id}\\", response_model=TradeRead) def get_trade(trade_id: int, db: Session = Depends(get_db)): Retrieve a trade by its ID. trading_service = TradingService(db) trade = trading_service.get_trade(trade_id) if not trade: raise HTTPException(status_code=404, detail=\\"Trade not found\\") return trade @router.get(\\"/trades\\", response_model=List[TradeRead]) def get_trades(skip: int = 0, limit: int = 10, db: Session = Depends(get_db)): Retrieve a list of trades with pagination. trading_service = TradingService(db) trades = trading_service.get_trades(skip=skip, limit=limit) return trades app.include_router(router) def test_create_trade(): new_trade = { \\"symbol\\": \\"AAPL\\", \\"price\\": 150.0, \\"quantity\\": 10, \\"strategy\\": \\"order_imbalance\\" } response = client.post(\\"/trades\\", json=new_trade) assert response.status_code == 200 data = response.json() assert data[\\"symbol\\"] == new_trade[\\"symbol\\"] assert data[\\"price\\"] == new_trade[\\"price\\"] assert data[\\"quantity\\"] == new_trade[\\"quantity\\"] assert data[\\"strategy\\"] == new_trade[\\"strategy\\"] def test_get_trade(): response = client.get(\\"/trades/1\\") assert response.status_code == 200 data = response.json() assert data[\\"id\\"] == 1 def test_get_trades(): response = client.get(\\"/trades?skip=0&limit=10\\") assert response.status_code == 200 data = response.json() assert isinstance(data, list) assert len(data) <= 10","solution":"def add(a, b): Returns the sum of a and b. return a + b"},{"question":"def remove_first_repeated(lst: List[int]) -> List[int]: Remove the first repeated number from the list if any. If no repeated numbers exist, return the original list. >>> remove_first_repeated([1, 2, 3, 4]) == [1, 2, 3, 4] >>> remove_first_repeated([1, 2, 3, 4, 2]) == [1, 2, 3, 4] >>> remove_first_repeated([1, 2, 3, 4, 2, 3]) == [1, 2, 3, 4, 3] >>> remove_first_repeated([1, 2, 2, 3, 4]) == [1, 2, 3, 4] >>> remove_first_repeated([1, 2, 3, 2, 4, 3]) == [1, 2, 3, 4, 3] >>> remove_first_repeated([1]) == [1] >>> remove_first_repeated([1, 1]) == [1]","solution":"def remove_first_repeated(lst): Remove the first repeated number from the list. If no repeated numbers exist, return the original list. seen = set() # Track the first repeated number's index repeated_index = -1 for i, num in enumerate(lst): if num in seen: repeated_index = i break seen.add(num) if repeated_index == -1: # No repeated number found, return original list return lst # Remove the first repeated number return lst[:repeated_index] + lst[repeated_index+1:]"},{"question":"def calculate_averages(grades_dict): Given a dictionary with student names as keys and lists of grades as values, return a new dictionary with student names and their average grades. Example: calculate_averages({\\"Alice\\": [90, 80, 70], \\"Bob\\": [100, 75, 80]}) ==> {\\"Alice\\": 80.0, \\"Bob\\": 85.0} calculate_averages({\\"Jane\\": [100, 100, 100], \\"Doe\\": [60, 70, 80]}) ==> {\\"Jane\\": 100.0, \\"Doe\\": 70.0} calculate_averages({\\"John\\": [], \\"Paul\\": [88]}) ==> {\\"John\\": 0.0, \\"Paul\\": 88.0}","solution":"def calculate_averages(grades_dict): Given a dictionary with student names as keys and lists of grades as values, return a new dictionary with student names and their average grades. Example: calculate_averages({\\"Alice\\": [90, 80, 70], \\"Bob\\": [100, 75, 80]}) ==> {\\"Alice\\": 80.0, \\"Bob\\": 85.0} calculate_averages({\\"Jane\\": [100, 100, 100], \\"Doe\\": [60, 70, 80]}) ==> {\\"Jane\\": 100.0, \\"Doe\\": 70.0} calculate_averages({\\"John\\": [], \\"Paul\\": [88]}) ==> {\\"John\\": 0.0, \\"Paul\\": 88.0} averages_dict = {} for student, grades in grades_dict.items(): if len(grades) == 0: average_grade = 0.0 else: average_grade = sum(grades) / len(grades) averages_dict[student] = round(average_grade, 1) return averages_dict"},{"question":"from typing import List, Tuple def find_closest_pair(nums: List[int], target: int) -> Tuple[int, int]: This function receives a list of distinct integers and a target integer. It returns the pair of integers from the list whose sum is closest to the target. If there are multiple pairs with the same closest sum, it returns the pair sorted in ascending order with the smallest integer first. If the list has fewer than two integers, it returns an empty tuple. >>> find_closest_pair([1, 3, 4, 7, 10], 15) (4, 10) >>> find_closest_pair([1, -3, 4, 8, 10], 1) (-3, 4) >>> find_closest_pair([5], 10) ()","solution":"from typing import List, Tuple def find_closest_pair(nums: List[int], target: int) -> Tuple[int, int]: This function receives a list of distinct integers and a target integer. It returns the pair of integers from the list whose sum is closest to the target. If there are multiple pairs, it returns the pair sorted in ascending order with the smallest integer first. If the list has fewer than two integers, it returns an empty tuple. if len(nums) < 2: return () # Initialize variables to keep track of the closest pair and the smallest difference. closest_pair = () smallest_diff = float('inf') # Sort the list to make it easier to maintain the smallest pair invariant nums.sort() # Two-pointer approach left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] current_diff = abs(current_sum - target) if current_diff < smallest_diff: smallest_diff = current_diff closest_pair = (nums[left], nums[right]) if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: break # Found exact match return closest_pair"},{"question":"from typing import Tuple def longest_distinct_substring(s: str) -> Tuple[str, int]: Finds the longest substring with all distinct characters in a given string. :param s: Input string :type s: str :return: A tuple containing the longest substring with all distinct characters and its length :rtype: tuple (str, int) >>> longest_distinct_substring(\\"abrkaabcdefghijjxxx\\") (\\"abcdefghij\\", 10) >>> longest_distinct_substring(\\"\\") (\\"\\", 0) >>> longest_distinct_substring(\\"a\\") (\\"a\\", 1) >>> longest_distinct_substring(\\"aaaa\\") (\\"a\\", 1) >>> longest_distinct_substring(\\"abcdef\\") (\\"abcdef\\", 6) >>> longest_distinct_substring(\\"aabbccabcd\\") (\\"abcd\\", 4) >>> longest_distinct_substring(\\"abcdabcdef\\") (\\"abcdef\\", 6) >>> longest_distinct_substring(\\"ababcdeff\\") (\\"abcdef\\", 6) >>> longest_distinct_substring(\\"tmmzuxt\\") (\\"mzuxt\\", 5) >>> longest_distinct_substring(\\"112345678777\\") (\\"12345678\\", 8) >>> longest_distinct_substring(\\"abcdefghijklmnopqrstuvwxyz\\"*100) (\\"abcdefghijklmnopqrstuvwxyz\\", 26) >>> longest_distinct_substring(\\"!@#%^&*()_+\\") (\\"!@#%^&*()_+\\", 12)","solution":"def longest_distinct_substring(s): Finds the longest substring with all distinct characters in a given string. :param s: Input string :type s: str :return: A tuple containing the longest substring with all distinct characters and its length :rtype: tuple (str, int) if not s: return (\\"\\", 0) start = 0 max_len = 0 max_substr = \\"\\" seen = {} for end, char in enumerate(s): if char in seen and seen[char] >= start: start = seen[char] + 1 seen[char] = end if end - start + 1 > max_len: max_len = end - start + 1 max_substr = s[start:end + 1] return (max_substr, max_len)"},{"question":"from typing import List def most_frequent_char(s: str) -> str: Returns the most frequently occurring character in the string \`s\`. In case of a tie, the character that appears first is returned. Ignores case sensitivity. Parameters: s (str): The input string. Returns: str: The most frequently occurring character. >>> most_frequent_char(\\"a\\") 'a' >>> most_frequent_char(\\"abbccc\\") 'c' >>> most_frequent_char(\\"ababc\\") 'a' >>> most_frequent_char(\\"AaBbCc\\") 'a' >>> most_frequent_char(\\"123abc!@#a\\") 'a' >>> most_frequent_char(\\"\\") '' >>> most_frequent_char(\\"123!@#\\") '' # Your code here","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string \`s\`. In case of a tie, the character that appears first is returned. Ignores case sensitivity. s = s.lower() freq = {} for char in s: if char.isalpha(): if char in freq: freq[char] += 1 else: freq[char] = 1 max_freq = 0 most_freq_char = '' for char in s: if char.isalpha() and freq[char] > max_freq: max_freq = freq[char] most_freq_char = char return most_freq_char"},{"question":"class User: def __init__(self, username: str, password: str, email: str): self.username = username self.password = password self.email = email class Profile: def __init__(self, id: int, user: User, bio: str, profile_picture: str): self.id = id self.user = user self.bio = bio self.profile_picture = profile_picture class Follow: def __init__(self, id: int, follower: User, following: User): self.id = id self.follower = follower self.following = following class StatusUpdate: def __init__(self, id: int, author: User, content: str, timestamp: datetime): self.id = id self.author = author self.content = content self.timestamp = timestamp Unit Test: def test_user_creation(): user = User(username=\\"john_doe\\", password=\\"password123\\", email=\\"john@example.com\\") assert user.username == \\"john_doe\\" assert user.password == \\"password123\\" assert user.email == \\"john@example.com\\" def test_profile_creation(): user = User(username=\\"john_doe\\", password=\\"password123\\", email=\\"john@example.com\\") profile = Profile(id=1, user=user, bio=\\"Bio here\\", profile_picture=\\"profile_pic.png\\") assert profile.id == 1 assert profile.user == user assert profile.bio == \\"Bio here\\" assert profile.profile_picture == \\"profile_pic.png\\" def test_follow_creation(): user1 = User(username=\\"john_doe\\", password=\\"password123\\", email=\\"john@example.com\\") user2 = User(username=\\"jane_doe\\", password=\\"password123\\", email=\\"jane@example.com\\") follow = Follow(id=1, follower=user1, following=user2) assert follow.id == 1 assert follow.follower == user1 assert follow.following == user2 def test_status_update_creation(): user = User(username=\\"john_doe\\", password=\\"password123\\", email=\\"john@example.com\\") timestamp = datetime.now() status_update = StatusUpdate(id=1, author=user, content=\\"My first status\\", timestamp=timestamp) assert status_update.id == 1 assert status_update.author == user assert status_update.content == \\"My first status\\" assert status_update.timestamp == timestamp","solution":"from datetime import datetime # Define user class structure class User: def __init__(self, username, password, email): self.username = username self.password = password self.email = email # Define profile class structure class Profile: def __init__(self, id, user, bio, profile_picture): self.id = id self.user = user self.bio = bio self.profile_picture = profile_picture # Define follow class structure class Follow: def __init__(self, id, follower, following): self.id = id self.follower = follower self.following = following # Define status update class structure class StatusUpdate: def __init__(self, id, author, content, timestamp): self.id = id self.author = author self.content = content self.timestamp = timestamp"},{"question":"def greatest_difference(lst: List[int]) -> int: Write a function that takes a list of integers and returns the greatest difference between any two elements in the list. If the list contains fewer than two elements, returns 0. >>> greatest_difference([5, 3, 1, 9, 7]) 8 >>> greatest_difference([5]) 0 >>> greatest_difference([]) 0 >>> greatest_difference([-10, -5, -1, -7]) 9 >>> greatest_difference([-10, 5, 1, 7, -3]) 17 >>> greatest_difference([1, 10]) 9 >>> greatest_difference([7, 7, 7, 7]) 0","solution":"def greatest_difference(lst): Returns the greatest difference between any two elements in the list. If the list contains fewer than two elements, returns 0. :param lst: List of integers. :return: Integer value representing the greatest difference. if len(lst) < 2: return 0 max_element = max(lst) min_element = min(lst) return max_element - min_element"},{"question":"def word_count(text: str) -> dict: Returns a dictionary with words as keys and their counts as values. Ignores punctuation and is case insensitive. >>> word_count(\\"To be or not to be, that is the question.\\") {'to': 2, 'be': 2, 'or': 1, 'not': 1, 'that': 1, 'is': 1, 'the': 1, 'question': 1} >>> word_count(\\"\\") {} >>> word_count(\\"Hello hello HELLO\\") {'hello': 3} >>> word_count(\\"Wow! This is amazing. Isn't it? Wow!\\") {'wow': 2, 'this': 1, 'is': 1, 'amazing': 1, 'isnt': 1, 'it': 1} >>> word_count(\\"123 123 abc 123\\") {'123': 3, 'abc': 1} # Your code here","solution":"def word_count(text): Returns a dictionary with words as keys and their counts as values. Ignores punctuation and is case insensitive. import string # Convert text to lowercase text = text.lower() # Remove punctuation text = text.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) # Split text into words words = text.split() # Count occurrences of each word word_dict = {} for word in words: if word in word_dict: word_dict[word] += 1 else: word_dict[word] = 1 return word_dict print(word_count(\\"To be or not to be, that is the question.\\"))"},{"question":"def sort_names(input_file: str, output_file: str): Reads a text file containing names, sorts the names alphabetically, and writes the sorted list to a new text file. Parameters: input_file (str): Path to the input text file containing names. output_file (str): Path to the output text file to write the sorted names. pass # Unit Tests import os import pytest def setup_function(): Setup function to create test files before tests are run. with open('test_input.txt', 'w') as f: f.write(\\"CharlienAlicenBobn\\") def teardown_function(): Teardown function to remove test files after tests are run. os.remove('test_input.txt') if os.path.exists('test_output.txt'): os.remove('test_output.txt') def test_sort_names_success(): sort_names('test_input.txt', 'test_output.txt') with open('test_output.txt', 'r') as f: sorted_names = f.read().splitlines() assert sorted_names == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_sort_names_empty_file(capfd): with open('empty_test_input.txt', 'w') as f: pass sort_names('empty_test_input.txt', 'test_output.txt') out, err = capfd.readouterr() assert \\"The file empty_test_input.txt is empty.\\" in out os.remove('empty_test_input.txt') def test_sort_names_file_not_found(capfd): sort_names('non_existent_file.txt', 'test_output.txt') out, err = capfd.readouterr() assert \\"The file non_existent_file.txt does not exist.\\" in out def test_sort_names_general_exception(monkeypatch, capfd): def mock_open(*args, **kwargs): raise Exception(\\"General error\\") monkeypatch.setattr('builtins.open', mock_open) sort_names('test_input.txt', 'test_output.txt') out, err = capfd.readouterr() assert \\"An error occurred: General error\\" in out","solution":"def sort_names(input_file, output_file): Reads a text file containing names, sorts the names alphabetically, and writes the sorted list to a new text file. Parameters: input_file (str): Path to the input text file containing names. output_file (str): Path to the output text file to write the sorted names. try: with open(input_file, 'r') as infile: names = infile.read().splitlines() if not names: print(f\\"The file {input_file} is empty.\\") return names.sort() with open(output_file, 'w') as outfile: for name in names: outfile.write(name + 'n') print(f\\"Names were successfully sorted and written to {output_file}\\") except FileNotFoundError: print(f\\"The file {input_file} does not exist.\\") except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"def is_valid_math_expression(s: str) -> bool: Determines if a given string is a valid mathematical expression. >>> is_valid_math_expression(\\"3+5*2-(8/4)\\") True >>> is_valid_math_expression(\\"3++5\\") False >>> is_valid_math_expression(\\"5*(4-2\\") False >>> is_valid_math_expression(\\"7/03\\") False >>> is_valid_math_expression(\\"5\\") True","solution":"def is_valid_math_expression(s): Determines if a given string is a valid mathematical expression. if not s: return False valid_chars = set('0123456789+-*/()') operators = set('+-*/') parentheses_stack = [] last_char = '' index = 0 while index < len(s): char = s[index] if char not in valid_chars: return False if char in operators: if index == 0 or index == len(s)-1: return False if last_char in operators or last_char == '(': return False elif char == '(': parentheses_stack.append(char) elif char == ')': if not parentheses_stack or parentheses_stack[-1] != '(': return False parentheses_stack.pop() elif char in '0123456789': if last_char == '0' and (index == 1 or s[index-2] in operators or s[index-2] == '('): return False last_char = char index += 1 if parentheses_stack: return False return True"},{"question":"def valid_brackets(s: str) -> bool: Checks whether a given string contains a valid combination of brackets. >>> valid_brackets(\\"(){}[]<>\\") True >>> valid_brackets(\\"([{}])\\") True >>> valid_brackets(\\"(<>[{}])\\") True >>> valid_brackets(\\"([{<>])\\") False","solution":"def valid_brackets(s: str) -> bool: Checks whether a given string contains a valid combination of brackets. stack = [] bracket_map = { ')': '(', '}': '{', ']': '[', '>': '<' } for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack == [] or stack.pop() != bracket_map[char]: return False else: return False # invalid character return stack == []"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(10) == False >>> is_prime(13) == True pass def filter_primes(int_list: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([10, 15, 3, 7, 9, 11, 13]) == [3, 7, 11, 13] >>> filter_primes([2, 3, 5, 7, 11, 13, 17, 19, 23]) == [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> filter_primes([4, 6, 8, 10, 12, 14, 15, 16, 18, 20]) == [] >>> filter_primes([1, 2, 4, 5, 6, 7, 8, 9, 10]) == [2, 5, 7] >>> filter_primes([17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) == [17, 19, 23, 29] >>> filter_primes([2]) == [2] >>> filter_primes([10]) == [] >>> filter_primes([17]) == [17] >>> filter_primes([]) == [] pass","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(int_list): Returns a new list containing only the prime numbers from the original list. return [num for num in int_list if is_prime(num)]"},{"question":"def merge_sort(array): Implementation of Merge Sort algorithm which sorts an array in ascending order. >>> arr = [34, 7, 23, 32, 5, 62] >>> merge_sort(arr) >>> arr [5, 7, 23, 32, 34, 62] >>> arr = [1] >>> merge_sort(arr) >>> arr [1] >>> arr = [] >>> merge_sort(arr) >>> arr [] pass def quick_sort(array): Implementation of Quick Sort algorithm which sorts an array in ascending order. >>> quick_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> quick_sort([1]) [1] >>> quick_sort([]) [] pass # Compare and contrast Merge Sort and Quick Sort Merge Sort: - Time Complexity: O(n log n) for all cases (best, average, worst) - Space Complexity: O(n) - Stability: Stable (maintains the relative order of equal elements) - Use-cases: Suitable for large datasets and linked lists, useful when stability is required Quick Sort: - Time Complexity: O(n log n) average, O(n^2) worst, O(n log n) best - Space Complexity: O(log n) for in-place, O(n) for naive - Stability: Not stable (the relative order of equal elements may change) - Use-cases: Suitable for arrays, generally faster in practice for average cases, useful for in-place sorting and cache optimization def test_sorting_algorithms(): array1 = [34, 7, 23, 32, 5, 62] merge_sort(array1) assert array1 == [5, 7, 23, 32, 34, 62] assert quick_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] def test_empty_list(): array = [] merge_sort(array) assert array == [] assert quick_sort([]) == [] def test_single_element_list(): array = [1] merge_sort(array) assert array == [1] assert quick_sort([1]) == [1] def test_sorted_list(): array = [1, 2, 3, 4, 5] merge_sort(array) assert array == [1, 2, 3, 4, 5] assert quick_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_reverse_sorted_list(): array = [5, 4, 3, 2, 1] merge_sort(array) assert array == [1, 2, 3, 4, 5] assert quick_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]","solution":"# Implementation of Merge Sort def merge_sort(array): if len(array) > 1: mid = len(array) // 2 left_half = array[:mid] right_half = array[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: array[k] = left_half[i] i += 1 else: array[k] = right_half[j] j += 1 k += 1 while i < len(left_half): array[k] = left_half[i] i += 1 k += 1 while j < len(right_half): array[k] = right_half[j] j += 1 k += 1 # Implementation of Quick Sort def quick_sort(array): if len(array) <= 1: return array else: pivot = array[len(array) // 2] left = [x for x in array if x < pivot] middle = [x for x in array if x == pivot] right = [x for x in array if x > pivot] return quick_sort(left) + middle + quick_sort(right) # Compare and contrast Merge Sort and Quick Sort Merge Sort: - Time Complexity: O(n log n) for all cases (best, average, worst) - Space Complexity: O(n) - Stability: Stable (maintains the relative order of equal elements) - Use-cases: Suitable for large datasets and linked lists, useful when stability is required Quick Sort: - Time Complexity: O(n log n) average, O(n^2) worst, O(n log n) best - Space Complexity: O(log n) for in-place, O(n) for naive - Stability: Not stable (the relative order of equal elements may change) - Use-cases: Suitable for arrays, generally faster in practice for average cases, useful for in-place sorting and cache optimization"},{"question":"def count_increasing_temperatures(temperatures: List[int]) -> int: Returns the number of days where the temperature was higher than the previous day's temperature. >>> count_increasing_temperatures([71, 73, 75, 74, 72, 76, 77]) 4 >>> count_increasing_temperatures([70, 71, 70, 71, 70, 71, 70]) 3","solution":"def count_increasing_temperatures(temperatures): Returns the number of days where the temperature was higher than the previous day's temperature. :param temperatures: List of integers representing daily temperatures. :return: Integer count of days with increasing temperatures compared to the previous day. count = 0 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i-1]: count += 1 return count # Demonstration: print(count_increasing_temperatures([71, 73, 75, 74, 72, 76, 77])) # Output: 4 print(count_increasing_temperatures([70, 71, 70, 71, 70, 71, 70])) # Output: 3"},{"question":"def find_anagram_pairs(words: List[str]) -> List[Tuple[str, str]]: Detect all unique anagram pairs within a given list of words. Each pair is a tuple of two words that are anagrams of each other. The function is case-insensitive. >>> find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"god\\", \\"dog\\"]) [('listen', 'silent'), ('listen', 'enlist'), ('silent', 'enlist'), ('rat', 'tar'), ('god', 'dog')] >>> find_anagram_pairs([\\"Listen\\", \\"Silent\\", \\"Enlist\\"]) [('Listen', 'Silent'), ('Listen', 'Enlist'), ('Silent', 'Enlist')] >>> find_anagram_pairs([\\"apple\\", \\"banana\\", \\"carrot\\"]) [] >>> find_anagram_pairs([]) [] >>> find_anagram_pairs([\\"listen\\", \\"silent\\"]) [(\\"listen\\", \\"silent\\")]","solution":"def find_anagram_pairs(words): Returns a list of unique anagram pairs from the given list of words. Each pair is a tuple of two words that are anagrams of each other. from collections import defaultdict # Dictionary to store sorted characters as keys and words as values anagram_groups = defaultdict(list) # Populate the dictionary with lowercased, sorted versions of the words for word in words: sorted_word = ''.join(sorted(word.lower())) anagram_groups[sorted_word].append(word) # Generate the list of unique anagram pairs anagram_pairs = [] for group in anagram_groups.values(): for i in range(len(group)): for j in range(i + 1, len(group)): anagram_pairs.append((group[i], group[j])) return anagram_pairs"},{"question":"class BankAccount: def __init__(self, account_number: int, initial_balance: int = 0): Initialize the bank account with an account number and an optional initial balance. self.account_number = account_number self.balance = initial_balance self.transaction_history = [] def deposit(self, amount: int) -> int: Deposit a specified amount into the bank account. pass def withdraw(self, amount: int) -> int: Withdraw a specified amount from the bank account. Raise an error if the funds are insufficient. pass def check_balance(self) -> int: Return the current balance of the bank account. pass def transfer(self, amount: int, other_account: 'BankAccount') -> None: Transfer a specified amount to another bank account. pass class Customer: def __init__(self, name: str, customer_id: int, bank_account: BankAccount): Initialize the customer with a name, customer ID, and associated bank account. self.name = name self.customer_id = customer_id self.bank_account = bank_account def show_account_details(self) -> dict: Show the account details of the customer. pass def show_transaction_history(self) -> list: Show the transaction history of the customer's bank account. pass # Unit Test def test_account_creation(): account = BankAccount(account_number=12345, initial_balance=100) assert account.account_number == 12345 assert account.check_balance() == 100 def test_deposit(): account = BankAccount(account_number=12345) assert account.deposit(200) == 200 def test_withdraw(): account = BankAccount(account_number=12345, initial_balance=500) assert account.withdraw(200) == 300 def test_withdraw_insufficient_funds(): account = BankAccount(account_number=12345, initial_balance=100) try: account.withdraw(200) assert False, \\"Expected ValueError\\" except ValueError: assert True def test_account_transfer(): account1 = BankAccount(account_number=12345, initial_balance=500) account2 = BankAccount(account_number=67890, initial_balance=300) account1.transfer(200, account2) assert account1.check_balance() == 300 assert account2.check_balance() == 500 def test_transaction_history(): account = BankAccount(account_number=12345) account.deposit(100) account.withdraw(50) assert account.transaction_history == [\\"Deposited 100\\", \\"Withdrew 50\\"] def test_customer_details(): account = BankAccount(account_number=12345, initial_balance=100) customer = Customer(name=\\"John Doe\\", customer_id=1, bank_account=account) details = customer.show_account_details() assert details['Name'] == \\"John Doe\\" assert details['Customer ID'] == 1 assert details['Account Number'] == 12345 assert details['Balance'] == 100 def test_customer_transaction_history(): account = BankAccount(account_number=12345) customer = Customer(name=\\"John Doe\\", customer_id=1, bank_account=account) account.deposit(100) account.withdraw(50) assert customer.show_transaction_history() == [\\"Deposited 100\\", \\"Withdrew 50\\"]","solution":"class BankAccount: def __init__(self, account_number, initial_balance=0): self.account_number = account_number self.balance = initial_balance self.transaction_history = [] def deposit(self, amount): self.balance += amount self.transaction_history.append(f\\"Deposited {amount}\\") return self.balance def withdraw(self, amount): if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount self.transaction_history.append(f\\"Withdrew {amount}\\") return self.balance def check_balance(self): return self.balance def transfer(self, amount, other_account): self.withdraw(amount) other_account.deposit(amount) self.transaction_history.append(f\\"Transferred {amount} to account {other_account.account_number}\\") other_account.transaction_history.append(f\\"Received {amount} from account {self.account_number}\\") class Customer: def __init__(self, name, customer_id, bank_account): self.name = name self.customer_id = customer_id self.bank_account = bank_account def show_account_details(self): return { 'Name': self.name, 'Customer ID': self.customer_id, 'Account Number': self.bank_account.account_number, 'Balance': self.bank_account.check_balance() } def show_transaction_history(self): return self.bank_account.transaction_history"},{"question":"def sort_tuples(tuples_list): Sorts a list of tuples primarily by the integer in descending order and secondarily by the string in ascending alphabetical order. :param tuples_list: List of tuples where each tuple contains a string and an integer. :return: New sorted list of tuples. pass # Unit tests def test_sort_tuples_basic(): assert sort_tuples([(\\"pear\\", 3), (\\"apple\\", 4), (\\"banana\\", 2), (\\"apple\\", 2)]) == [(\\"apple\\", 4), (\\"pear\\", 3), (\\"apple\\", 2), (\\"banana\\", 2)] def test_sort_tuples_with_same_strings(): assert sort_tuples([(\\"apple\\", 1), (\\"apple\\", 3), (\\"apple\\", 2)]) == [(\\"apple\\", 3), (\\"apple\\", 2), (\\"apple\\", 1)] def test_sort_tuples_with_same_integers(): assert sort_tuples([(\\"banana\\", 2), (\\"cherry\\", 2), (\\"apple\\", 2)]) == [(\\"apple\\", 2), (\\"banana\\", 2), (\\"cherry\\", 2)] def test_sort_tuples_mixed_order(): assert sort_tuples([(\\"kiwi\\", 3), (\\"grape\\", 4), (\\"lemon\\", 4), (\\"banana\\", 3)]) == [(\\"grape\\", 4), (\\"lemon\\", 4), (\\"banana\\", 3), (\\"kiwi\\", 3)] def test_sort_tuples_empty(): assert sort_tuples([]) == [] def test_sort_tuples_single_element(): assert sort_tuples([(\\"mango\\", 1)]) == [(\\"mango\\", 1)]","solution":"def sort_tuples(tuples_list): Sorts a list of tuples primarily by the integer in descending order and secondarily by the string in ascending alphabetical order. :param tuples_list: List of tuples where each tuple contains a string and an integer. :return: New sorted list of tuples. return sorted(tuples_list, key=lambda x: (-x[1], x[0]))"},{"question":"def permute_string(s: str) -> List[str]: Generate all possible permutations of the string without using any built-in permutation functions. Returns a list of all unique permutations sorted in lexicographic order. >>> permute_string(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> permute_string(\\"a\\") [\\"a\\"] >>> permute_string(\\"aa\\") [\\"aa\\"] >>> permute_string(\\"ab\\") [\\"ab\\", \\"ba\\"] >>> permute_string(\\"aab\\") [\\"aab\\", \\"aba\\", \\"baa\\"] >>> permute_string(\\"bca\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> permute_string(\\"aabb\\") [\\"aabb\\", \\"abab\\", \\"abba\\", \\"baab\\", \\"baba\\", \\"bbaa\\"]","solution":"def permute_string(s): Generate all possible permutations of the string without using any built-in permutation functions. Returns a list of all unique permutations sorted in lexicographic order. def helper(s, path, used, res): if len(path) == len(s): res.append(\\"\\".join(path)) return for i in range(len(s)): if used[i]: continue # Skip duplicates if i > 0 and s[i] == s[i-1] and not used[i-1]: continue used[i] = True path.append(s[i]) helper(s, path, used, res) path.pop() used[i] = False s = sorted(s) res = [] used = [False] * len(s) helper(s, [], used, res) return res"},{"question":"from typing import List, Optional def kth_largest_unique(nums: List[int], k: int) -> Optional[int]: Returns the k-th largest unique element in the list of integers nums. If there are fewer than k unique elements, returns None. >>> kth_largest_unique([3, 1, 5, 1, 3, 7, 9, 7], 3) == 5 >>> kth_largest_unique([3, 1, 4, 1, 2, 5, 4], 1) == 5 >>> kth_largest_unique([3, 3, 3, 3], 1) == 3 >>> kth_largest_unique([3, 3, 3, 3], 2) is None >>> kth_largest_unique([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 5 >>> kth_largest_unique([], 1) is None >>> kth_largest_unique([7, 6, 5], 4) is None >>> kth_largest_unique([10, 10], 1) == 10 >>> kth_largest_unique([1, 2, 2, 3, 4], 3) == 2 >>> kth_largest_unique([100], 1) == 100 >>> kth_largest_unique([100], 2) is None","solution":"def kth_largest_unique(nums, k): Returns the k-th largest unique element in the list of integers nums. If there are fewer than k unique elements, returns None. unique_nums = list(set(nums)) # Remove duplicates unique_nums.sort(reverse=True) # Sort in descending order if len(unique_nums) < k: return None return unique_nums[k-1]"},{"question":"import pandas as pd import matplotlib.pyplot as plt def load_and_plot_airtravel_data(url): Loads air travel data from a CSV file and plots the number of air passengers over the months. :param url: URL of the CSV file containing air travel data. # Implementation here # URL of CSV file url = \\"https://people.sc.fsu.edu/~jburkardt/data/csv/airtravel.csv\\" # Execute the function load_and_plot_airtravel_data(url)","solution":"import pandas as pd import matplotlib.pyplot as plt def load_and_plot_airtravel_data(url): Loads air travel data from a CSV file and plots the number of air passengers over the months. :param url: URL of the CSV file containing air travel data. # Load the data airtravel_data = pd.read_csv(url) # Plot the data plt.figure(figsize=(10, 5)) for year in airtravel_data.columns[1:]: plt.plot(airtravel_data['Month'], airtravel_data[year], label=year) # Add titles and labels plt.title('Monthly Air Travel Data') plt.xlabel('Month') plt.ylabel('Number of Air Passengers') plt.legend(title=\\"Year\\", loc='upper left') plt.grid(True) plt.show() # URL of CSV file url = \\"https://people.sc.fsu.edu/~jburkardt/data/csv/airtravel.csv\\" # Run the function load_and_plot_airtravel_data(url)"},{"question":"def find_triplets(nums): Returns a list of unique triplets in the array that sum up to zero. Example: >>> find_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([1, 2, 3, 4, 5]) [] >>> find_triplets([0, 0, 0, 0]) [[0, 0, 0]]","solution":"def find_triplets(nums): Returns a list of unique triplets in the array that sum up to zero. nums.sort() triplets = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplets"},{"question":"def sum_of_unique_prime_factors(n: int) -> int: Calculate the sum of all unique prime factors of a given integer. >>> sum_of_unique_prime_factors(18) # Output: 5 >>> sum_of_unique_prime_factors(28) # Output: 9 # Your code here pass # Example usage print(sum_of_unique_prime_factors(18)) # Output: 5 print(sum_of_unique_prime_factors(28)) # Output: 9 # Unit Test Cases def test_sum_of_unique_prime_factors_18(): assert sum_of_unique_prime_factors(18) == 5 def test_sum_of_unique_prime_factors_28(): assert sum_of_unique_prime_factors(28) == 9 def test_sum_of_unique_prime_factors_1(): assert sum_of_unique_prime_factors(1) == 0 def test_sum_of_unique_prime_factors_0(): assert sum_of_unique_prime_factors(0) == 0 def test_sum_of_unique_prime_factors_prime_number(): assert sum_of_unique_prime_factors(13) == 13 def test_sum_of_unique_prime_factors_large_number(): assert sum_of_unique_prime_factors(2*3*5*7*11) == 28 def test_sum_of_unique_prime_factors_square_of_prime(): assert sum_of_unique_prime_factors(49) == 7 def test_sum_of_unique_prime_factors_cube_of_prime(): assert sum_of_unique_prime_factors(27) == 3 def test_sum_of_unique_prime_factors_negative_number(): assert sum_of_unique_prime_factors(-18) == 0 # negative numbers should return 0","solution":"def sum_of_unique_prime_factors(n: int) -> int: if n < 2: return 0 def prime_factors(num): i = 2 factors = set() while i * i <= num: if num % i: i += 1 else: num //= i factors.add(i) if num > 1: factors.add(num) return factors unique_factors = prime_factors(n) return sum(unique_factors) # Example usage print(sum_of_unique_prime_factors(18)) # Output: 5 print(sum_of_unique_prime_factors(28)) # Output: 9"},{"question":"from typing import List, Tuple def find_valid_words(string: str, dictionary: List[str]) -> Tuple[List[str], int]: Returns a list of all possible words that can be formed by the contiguous characters of the input string which are valid words from the dictionary and the count of such words. >>> find_valid_words(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"app\\", \\"le\\", \\"pie\\", \\"e\\"]) (['apple', 'pie', 'app', 'le', 'e'], 5) >>> find_valid_words(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"app\\"]) (['apple', 'pie', 'app'], 3) >>> find_valid_words(\\"applepie\\", [\\"banana\\", \\"orange\\", \\"grape\\"]) ([], 0) >>> find_valid_words(\\"applepie\\", [\\"apple\\", \\"apple\\", \\"pie\\", \\"pie\\", \\"app\\", \\"le\\", \\"e\\"]) (['apple', 'pie', 'app', 'le', 'e'], 5) >>> find_valid_words(\\"helloman\\", [\\"he\\", \\"hell\\", \\"man\\", \\"hello\\", \\"helloman\\"]) (['he', 'hell', 'man', 'hello', 'helloman'], 5)","solution":"def find_valid_words(string, dictionary): Returns a list of all possible words that can be formed by the contiguous characters of the input string which are valid words from the dictionary and the count of such words. valid_words = set() dict_set = set(dictionary) for i in range(len(string)): for j in range(i + 1, len(string) + 1): word = string[i:j] if word in dict_set: valid_words.add(word) return list(valid_words), len(valid_words)"},{"question":"def string_occurrences(strings: List[str]) -> Dict[str, int]: Returns a dictionary that maps each unique string to the number of occurrences of that string in the list, excluding any strings that appear more than twice. >>> string_occurrences([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"cherry\\", \\"cherry\\"]) {\\"banana\\": 2, \\"cherry\\": 2} >>> string_occurrences([\\"apple\\", \\"banana\\", \\"cherry\\"]) {\\"apple\\": 1, \\"banana\\": 1, \\"cherry\\": 1} >>> string_occurrences([\\"apple\\", \\"apple\\", \\"apple\\", \\"cherry\\", \\"cherry\\", \\"cherry\\", \\"banana\\"]) {\\"banana\\": 1} >>> string_occurrences([]) {} >>> string_occurrences([\\"apple\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"banana\\", \\"cherry\\", \\"cherry\\", \\"cherry\\"]) {}","solution":"def string_occurrences(strings): Returns a dictionary that maps each unique string to the number of occurrences of that string in the list, excluding any strings that appear more than twice. from collections import Counter count = Counter(strings) result = {key: value for key, value in count.items() if 1 <= value <= 2} return result"},{"question":"def bank_account(initial_balance, operations): Simulates a bank account with deposit, withdraw, and check balance operations. Parameters: initial_balance (float): The initial balance of the account. operations (list of tuples): A list of operations where each operation is represented as a tuple. The first element is the operation type (string: 'deposit', 'withdraw', 'check balance') and the second element is the amount (float) for deposit and withdraw operations. Returns: float: The final balance of the account after all operations.","solution":"def bank_account(initial_balance, operations): Simulates a bank account with deposit, withdraw, and check balance operations. Parameters: initial_balance (float): The initial balance of the account. operations (list of tuples): A list of operations where each operation is represented as a tuple. The first element is the operation type (string: 'deposit', 'withdraw', 'check balance') and the second element is the amount (float) for deposit and withdraw operations. Returns: float: The final balance of the account after all operations. balance = initial_balance for operation in operations: op_type, op_amount = operation if op_type == \\"deposit\\": balance += op_amount elif op_type == \\"withdraw\\": if balance >= op_amount: balance -= op_amount else: print(\\"Insufficient funds for withdrawal\\") elif op_type == \\"check balance\\": pass # \\"check balance\\" operation does not change the balance return balance"},{"question":"def add_item_to_cart(cart, item): Adds an item to the cart. If the item already exists, update the quantity. pass def remove_item_from_cart(cart, item_name): Removes an item from the cart by name. If the item does not exist, do nothing. pass def checkout(cart): Calculates the total price of items in the cart, including a 5% sales tax. pass import pytest def test_add_item_to_cart(): cart = [] item = {'name': 'apple', 'price': 1.0, 'quantity': 3} add_item_to_cart(cart, item) assert cart == [{'name': 'apple', 'price': 1.0, 'quantity': 3}] add_item_to_cart(cart, {'name': 'apple', 'price': 1.0, 'quantity': 2}) assert cart == [{'name': 'apple', 'price': 1.0, 'quantity': 5}] def test_remove_item_from_cart(): cart = [{'name': 'apple', 'price': 1.0, 'quantity': 5}] remove_item_from_cart(cart, 'apple') assert cart == [] cart = [{'name': 'apple', 'price': 1.0, 'quantity': 5}] remove_item_from_cart(cart, 'banana') assert cart == [{'name': 'apple', 'price': 1.0, 'quantity': 5}] def test_checkout(): cart = [{'name': 'apple', 'price': 1.0, 'quantity': 3}, {'name': 'banana', 'price': 0.5, 'quantity': 6}] total = checkout(cart) assert total == pytest.approx((3*1.0 + 6*0.5) * 1.05, 0.01) cart = [] total = checkout(cart) assert total == 0 def test_combined_operations(): cart = [] add_item_to_cart(cart, {'name': 'apple', 'price': 1.0, 'quantity': 3}) add_item_to_cart(cart, {'name': 'banana', 'price': 0.5, 'quantity': 6}) remove_item_from_cart(cart, 'apple') total = checkout(cart) assert cart == [{'name': 'banana', 'price': 0.5, 'quantity': 6}] assert total == pytest.approx((6*0.5) * 1.05, 0.01)","solution":"def add_item_to_cart(cart, item): Adds an item to the cart. If the item already exists, update the quantity. for cart_item in cart: if cart_item['name'] == item['name']: cart_item['quantity'] += item['quantity'] return cart.append(item) def remove_item_from_cart(cart, item_name): Removes an item from the cart by name. If the item does not exist, do nothing. for cart_item in cart: if cart_item['name'] == item_name: cart.remove(cart_item) return def checkout(cart): Calculates the total price of items in the cart, including a 5% sales tax. total_before_tax = sum(item['price'] * item['quantity'] for item in cart) total_with_tax = total_before_tax * 1.05 return total_with_tax"},{"question":"def product_of_list(lst): Returns the product of all elements in the list. If the list is empty, returns 1. >>> product_of_list([1, 2, 3, 4]) == 24 >>> product_of_list([5, 0, 2]) == 0 >>> product_of_list([]) == 1 >>> product_of_list([-1, 2, -3, 4]) == 24 >>> product_of_list([5]) == 5 >>> product_of_list([0, 0, 0]) == 0 # Your code here","solution":"def product_of_list(lst): Returns the product of all elements in the list. If the list is empty, returns 1. product = 1 for num in lst: product *= num return product"},{"question":"def factorial(n: int) -> int: Returns the factorial of a positive integer n using memoization. For n < 0, returns a message indicating factorial is undefined. >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(-3) 'Undefined for negative values' def test_factorial_positive_number(): assert factorial(5) == 120 def test_factorial_zero(): assert factorial(0) == 1 def test_factorial_negative_number(): assert factorial(-3) == \\"Undefined for negative values\\" def test_factorial_large_number(): assert factorial(10) == 3628800 def test_factorial_one(): assert factorial(1) == 1","solution":"def factorial(n): Returns the factorial of a positive integer n using memoization. For n < 0, returns a message indicating factorial is undefined. memo = {} def fact_inner(x): if x in memo: return memo[x] if x <= 1: return 1 memo[x] = x * fact_inner(x - 1) return memo[x] if n < 0: return \\"Undefined for negative values\\" return fact_inner(n)"},{"question":"def infix_to_postfix(expression: str) -> str: Converts a string representing a mathematical expression in infix notation to its corresponding postfix notation (Reverse Polish Notation - RPN). The expression will only contain single-digit positive integers and the operators +, -, *, /, and parentheses (). The function should correctly handle operator precedence and parentheses using the Shunting Yard algorithm. >>> infix_to_postfix(\\"3+4\\") \\"34+\\" >>> infix_to_postfix(\\"3+4*5\\") \\"345*+\\" >>> infix_to_postfix(\\"3+(4*5)-7\\") \\"345*+7-\\" >>> infix_to_postfix(\\"3+(4*5)-7/(1+1)\\") \\"345*+711+/-\\" >>> infix_to_postfix(\\"1+2*3-4/2\\") \\"123*+42/-\\" >>> infix_to_postfix(\\"\\") \\"\\" >>> infix_to_postfix(\\"8\\") \\"8\\"","solution":"def infix_to_postfix(expression): Converts an infix mathematical expression to its postfix notation. precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] operators = [] def has_higher_precedence(op1, op2): return precedence[op1] >= precedence[op2] for char in expression: if char.isdigit(): output.append(char) elif char in precedence: while operators and operators[-1] != '(' and has_higher_precedence(operators[-1], char): output.append(operators.pop()) operators.append(char) elif char == '(': operators.append(char) elif char == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() # Pop the '(' while operators: output.append(operators.pop()) return ''.join(output)"},{"question":"from typing import List def longest_subarray(nums: List[int]) -> int: Write a function that takes an integer array and returns the length of the longest contiguous subarray with an equal number of even and odd numbers. The function should be optimized for efficiency and handle arrays of varying lengths, including an edge case where the input array might be empty. >>> longest_subarray([1, 2, 3, 4]) 4 >>> longest_subarray([1, 1, 1, 2, 2, 2]) 6 >>> longest_subarray([2, 4, 6, 8]) 0 >>> longest_subarray([]) 0 >>> longest_subarray([1, 2, 2, 1, 3, 4, 6, 7]) 8 from solution import longest_subarray def test_empty_array(): assert longest_subarray([]) == 0 def test_no_subarray(): assert longest_subarray([2, 4, 6, 8]) == 0 assert longest_subarray([1, 3, 5, 7]) == 0 def test_example_cases(): assert longest_subarray([1, 2, 3, 4]) == 4 assert longest_subarray([1, 1, 1, 2, 2, 2]) == 6 def test_even_odd_mix(): assert longest_subarray([1, 2, 2, 1, 1, 2, 2, 1]) == 8 assert longest_subarray([1, 2, 2, 1, 3, 4, 6, 7]) == 8 assert longest_subarray([1, 1, 1, 2, 2, 2, 3, 3, 4, 4]) == 10 def test_single_element(): assert longest_subarray([2]) == 0 assert longest_subarray([1]) == 0 def test_all_same_type(): assert longest_subarray([2, 2, 2, 2, 2, 2, 2]) == 0 assert longest_subarray([1, 1, 1, 1, 1, 1, 1]) == 0","solution":"def longest_subarray(nums): count = 0 max_length = 0 count_map = {0: -1} for i in range(len(nums)): if nums[i] % 2 == 0: count += 1 else: count -= 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def parse_requirements(s: str) -> dict: Parses the requirements text and returns a dictionary of sections with their contents. >>> parse_requirements(\\"# ContextnThis is the context.n# Product GoalsnThese are the product goals.\\") {'Context': 'This is the context.', 'Product Goals': 'These are the product goals.'} >>> parse_requirements(\\"# ContextnThis is the context of the requirement.\\") {'Context': 'This is the context of the requirement.'} >>> parse_requirements(\\"# Contextnn# Product GoalsnnThese are the product goals.\\") {'Context': '', 'Product Goals': 'These are the product goals.'} >>> parse_requirements(\\"# Contextn\\") {'Context': ''} sections = {} current_section = None current_content = [] for line in s.split('n'): if line.startswith('#'): if current_section: sections[current_section] = 'n'.join(current_content).strip() current_section = line[1:].strip() current_content = [] else: current_content.append(line) if current_section: sections[current_section] = 'n'.join(current_content).strip() return sections","solution":"def parse_requirements(s): Parses the requirements text and returns a dictionary of sections with their contents. sections = {} current_section = None current_content = [] for line in s.split('n'): if line.startswith('#'): # New section found if current_section: sections[current_section] = 'n'.join(current_content).strip() current_section = line[1:].strip() current_content = [] else: current_content.append(line) # Add the last section if current_section: sections[current_section] = 'n'.join(current_content).strip() return sections"},{"question":"def subset_sum(arr, K, N): Determine if there exists a subset in \`arr\` of size exactly \`N\` that sums up to \`K\`. Parameters: arr (List[int]): The input list of integers. K (int): Target sum of the subset. N (int): The number of elements in the subset. Returns: List[int]: A list of elements in the subset if it exists, otherwise an empty list. # Implementation here # Unit Tests def test_subset_sum_valid_subset(): assert subset_sum([1, 2, 3, 4, 5], 10, 3) == [1, 4, 5] or subset_sum([1, 2, 3, 4, 5], 10, 3) == [2, 3, 5] def test_subset_sum_no_valid_subset(): assert subset_sum([1, 2, 3, 4, 5], 16, 3) == [] def test_subset_sum_with_exact_sum(): assert subset_sum([1, 2, 3, 4, 5], 6, 2) == [1, 5] or subset_sum([1, 2, 3, 4, 5], 6, 2) == [2, 4] def test_subset_sum_single_element(): assert subset_sum([1, 2, 3, 4, 5], 3, 1) == [3] def test_subset_sum_large_N(): assert subset_sum([1, 2, 3, 4, 5], 15, 5) == [1, 2, 3, 4, 5] def test_subset_sum_empty_array(): assert subset_sum([], 10, 3) == []","solution":"def subset_sum(arr, K, N): Determine if there exists a subset in \`arr\` of size exactly \`N\` that sums up to \`K\`. Parameters: arr (List[int]): The input list of integers. K (int): Target sum of the subset. N (int): The number of elements in the subset. Returns: List[int]: A list of elements in the subset if it exists, otherwise an empty list. from itertools import combinations # Generate all combinations of arr of size N for comb in combinations(arr, N): if sum(comb) == K: return list(comb) return []"},{"question":"def can_form_target_string(strings: List[str], target: str) -> bool: Determine if the target string can be formed by concatenating elements in the list in order. >>> can_form_target_string(['cat', 'dog', 'bird'], 'catdog') True >>> can_form_target_string(['cat', 'dog', 'bird'], 'catbird') True >>> can_form_target_string(['cat', 'dog', 'bird'], 'catdogbird') True >>> can_form_target_string(['cat', 'dog', 'bird'], 'catfish') False >>> can_form_target_string(['cat', 'dog', 'bird'], '') True >>> can_form_target_string([], 'catdog') False # Your code goes here pass","solution":"def can_form_target_string(strings, target): Determine if the target string can be formed by concatenating elements in the list in order. target_index = 0 for s in strings: while target_index < len(target) and target.startswith(s, target_index): target_index += len(s) if target_index == len(target): return True return target_index == len(target)"},{"question":"def process_text(text: str) -> tuple: Processes the input text by: 1. Counting the number of words. 2. Reversing the order of words. 3. Converting all characters to lowercase. Returns a tuple with the word count, the reversed text, and the lowercase text. >>> process_text(\\"Hello World\\") (2, \\"World Hello\\", \\"hello world\\") >>> process_text(\\"A quick brown fox jumps over the lazy dog\\") (9, \\"dog lazy the over jumps fox brown quick A\\", \\"a quick brown fox jumps over the lazy dog\\")","solution":"def process_text(text): Processes the input text by: 1. Counting the number of words. 2. Reversing the order of words. 3. Converting all characters to lowercase. Returns a tuple with the word count, the reversed text, and the lowercase text. words = text.split() word_count = len(words) reversed_text = ' '.join(reversed(words)) lowercase_text = text.lower() return (word_count, reversed_text, lowercase_text)"},{"question":"def char_with_frequencies(s: str) -> str: Takes a string containing lowercase alphabetic characters, whitespace, and punctuation, and returns a new string where each character's frequency is shown right after the character itself. >>> char_with_frequencies(\\"hello world\\") 'h1e1l3l3o2 1w1o2r1l3d1' >>> char_with_frequencies(\\"aaabbb\\") 'a3a3a3b3b3b3' >>> char_with_frequencies(\\"a!a!a!\\") 'a3!3a3!3a3!3' >>> char_with_frequencies(\\"a b,a b,a b,\\") 'a3 3b3,3a3 3b3,3a3 3b3,3' >>> char_with_frequencies(\\"a\\") 'a1'","solution":"def char_with_frequencies(s): Takes a string containing lowercase alphabetic characters, whitespace, and punctuation, and returns a new string where each character's frequency is shown right after the character itself. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Build the result string with character and its frequency in original order result = ''.join(c + str(char_count[c]) for c in s) return result"},{"question":"from typing import List def max_subarray_sum(arr: List[int], k: int) -> int: Computes the maximum sum of a subarray with at most \`k\` non-negative contiguous integers. Parameters: arr (List[int]): A list of non-negative integers. k (int): The maximum length of the subarray to consider. Returns: int: The maximum sum possible with the given constraints. >>> max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum([5], 1) 5 >>> max_subarray_sum([1, 2, 3, 4, 5], 5) 15 >>> max_subarray_sum([1, 2, 3], 5) 6 >>> max_subarray_sum([1, 0, 0, 0, 5], 2) 5 >>> max_subarray_sum([1, 2, 3, 4, 5], 0) 0 >>> max_subarray_sum([10000, 9999, 10000], 2) 19999 >>> max_subarray_sum([5, 5, 5, 5, 5], 3) 15","solution":"from typing import List def max_subarray_sum(arr: List[int], k: int) -> int: Computes the maximum sum of a subarray with at most \`k\` non-negative contiguous integers. Parameters: arr (List[int]): A list of non-negative integers. k (int): The maximum length of the subarray to consider. Returns: int: The maximum sum possible with the given constraints. if not arr or k <= 0: return 0 max_sum = 0 current_sum = 0 window_start = 0 for window_end in range(len(arr)): current_sum += arr[window_end] if window_end - window_start + 1 > k: current_sum -= arr[window_start] window_start += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Union, Dict def calculate_statistics(numbers: List[int]) -> Union[Dict[str, Union[float, List[int]]], str]: Given a list of integers, return a dictionary containing: - 'mean': the average value of the list - 'median': the middle value in the sorted list - 'mode': the most frequent value(s) in the list Also handle possible exceptions gracefully, such as when input is not a list or contains non-integer values, and return an appropriate error message. >>> calculate_statistics([4, 1, 2, 2, 3, 3, 3]) { 'mean': 2.57, 'median': 3, 'mode': [3] } >>> calculate_statistics([1, 2, 3, 4]) { 'mean': 2.5, 'median': 2.5, 'mode': [1, 2, 3, 4] } >>> calculate_statistics(\\"not a list\\") \\"Error: Input must be a list.\\" >>> calculate_statistics([1, 2, \\"three\\", 4]) \\"Error: All elements in the list must be integers.\\"","solution":"from statistics import mean, median, mode, StatisticsError from collections import Counter def calculate_statistics(numbers): if not isinstance(numbers, list): return \\"Error: Input must be a list.\\" if not all(isinstance(x, int) for x in numbers): return \\"Error: All elements in the list must be integers.\\" statistics = {} try: statistics['mean'] = round(mean(numbers), 2) statistics['median'] = median(numbers) count = Counter(numbers) max_frequency = max(count.values()) modes = [num for num, freq in count.items() if freq == max_frequency] if len(modes) == len(numbers): statistics['mode'] = numbers else: statistics['mode'] = modes except (StatisticsError, ValueError): return \\"Error: Cannot calculate statistics for the given input.\\" return statistics"},{"question":"from typing import List, Dict def consolidate_inventory(inventories: List[str]) -> Dict[str, int]: Consolidates inventories into a single inventory, summing up the quantities for each item. Quantities exceeding 100 are capped at 100. >>> consolidate_inventory([\\"apple:40\\", \\"banana:60\\", \\"orange:25\\", \\"apple:70\\", \\"banana:50\\", \\"orange:80\\"]) {'apple': 100, 'banana': 100, 'orange': 100} >>> consolidate_inventory([\\"apple:40\\", \\"banana:30\\", \\"orange:50\\"]) {'apple': 40, 'banana': 30, 'orange': 50} >>> consolidate_inventory([]) {} >>> consolidate_inventory([\\"apple:10\\"]) {'apple': 10} >>> consolidate_inventory([\\"apple:90\\", \\"apple:20\\"]) {'apple': 100} >>> consolidate_inventory([\\"apple:40\\", \\"apple:30\\", \\"apple:50\\"]) {'apple': 100} pass","solution":"from typing import List, Dict def consolidate_inventory(inventories: List[str]) -> Dict[str, int]: inventory_dict = {} for entry in inventories: item, quantity = entry.split(':') quantity = int(quantity) if item in inventory_dict: inventory_dict[item] += quantity if inventory_dict[item] > 100: inventory_dict[item] = 100 else: inventory_dict[item] = min(quantity, 100) return inventory_dict"},{"question":"def max_product_of_two(nums: List[int]) -> Optional[int]: Returns the maximum product of any two integers in a given list of integers. If the list contains fewer than two integers, return None. >>> max_product_of_two([3, 5, -2, 9, -10, 4]) == 45 >>> max_product_of_two([1, 2, 3, 4, 5]) == 20 >>> max_product_of_two([-3, -5, -2, -9, -10]) == 90 >>> max_product_of_two([1, -4, 3, -6, 7, 0]) == 24 >>> max_product_of_two([5]) == None >>> max_product_of_two([]) == None >>> max_product_of_two([0, 0]) == 0 >>> max_product_of_two([0, 4, 5, -10]) == 20","solution":"def max_product_of_two(nums): Returns the maximum product of any two integers in a given list of integers. If the list contains fewer than two integers, return None. if len(nums) < 2: return None # Sort the list nums.sort() # The max product can either be the product of the two largest numbers # or the product of the two smallest numbers (which might produce a # positive product if both are negative). return max(nums[0] * nums[1], nums[-1] * nums[-2])"},{"question":"def sort_excluding_negatives(lst: List[int]) -> List[int]: Sort the integers in the list in descending order, excluding negative integers which remain in their original positions. >>> sort_excluding_negatives([3, -1, 4, 1, -2, 5]) == [5, -1, 4, 3, -2, 1] >>> sort_excluding_negatives([3, 1, 4, 1, 2, 5]) == [5, 4, 3, 2, 1, 1] >>> sort_excluding_negatives([-3, -1, -4, -1, -2, -5]) == [-3, -1, -4, -1, -2, -5] >>> sort_excluding_negatives([]) == [] >>> sort_excluding_negatives([5]) == [5] >>> sort_excluding_negatives([-5]) == [-5] >>> sort_excluding_negatives([0, 0, 0, -1, 0, -2]) == [0, 0, 0, -1, 0, -2] >>> sort_excluding_negatives([2, 3, -3, 1, 4, 5]) == [5, 4, -3, 3, 2, 1]","solution":"def sort_excluding_negatives(lst): Sort the integers in the list in descending order, excluding negative integers which remain in their original positions. # Extract only the non-negative integers and sort them in descending order sorted_pos = sorted((x for x in lst if x >= 0), reverse=True) # Create an iterator of the sorted non-negative integers sorted_iter = iter(sorted_pos) # Rebuild the list with sorted non-negatives and original negatives result = [next(sorted_iter) if x >= 0 else x for x in lst] return result"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string \`s\` consisting of lowercase letters, find the length of the longest substring that contains no more than two distinct characters. >>> length_of_longest_substring_two_distinct(\\"\\") == 0 >>> length_of_longest_substring_two_distinct(\\"a\\") == 1 >>> length_of_longest_substring_two_distinct(\\"ab\\") == 2 >>> length_of_longest_substring_two_distinct(\\"aaaaa\\") == 5 >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 >>> length_of_longest_substring_two_distinct(\\"a\\" * 100000 + \\"b\\" * 100000 + \\"c\\") == 200000","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if not s: return 0 # Dictionary to count the characters in current window count = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in count: count[s[right]] += 1 else: count[s[right]] = 1 while len(count) > 2: count[s[left]] -= 1 if count[s[left]] == 0: del count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def count_vowels(s: str) -> (int, List[str]): Returns the number of vowels in the string s and a list of unique vowels present in the string. >>> count_vowels(\\"\\") == (0, []) >>> count_vowels(\\"bcdfg\\") == (0, []) >>> count_vowels(\\"aeiouAEIOU\\") == (10, ['a', 'e', 'i', 'o', 'u']) >>> count_vowels(\\"hello world\\") == (3, ['e', 'o']) >>> count_vowels(\\"banana\\") == (3, ['a']) >>> count_vowels(\\"HeLLo WoRLd\\") == (3, ['e', 'o'])","solution":"def count_vowels(s): Returns the number of vowels in the string s and a list of unique vowels present in the string. vowels = \\"aeiouAEIOU\\" count = 0 unique_vowels = set() for char in s: if char in vowels: count += 1 unique_vowels.add(char.lower()) return count, list(unique_vowels)"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the input square matrix by 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The input matrix to be rotated. Example: >>> matrix = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> rotate_matrix(matrix) >>> print(matrix) >>> # Output should be: >>> # [ >>> # [7, 4, 1], >>> # [8, 5, 2], >>> # [9, 6, 3] >>> # ] def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_large_matrix(): matrix = [[i + j*10 for i in range(10)] for j in range(10)] expected = [[10*(10-1 - i) + j for i in range(10)] for j in range(10)] rotate_matrix(matrix) assert matrix == expected","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the input square matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def valid_palindrome(s: str) -> bool: Check if the input string can be converted to a valid palindrome by removing at most one character. >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"abc\\") False >>> valid_palindrome(\\"a\\") True >>> valid_palindrome(\\"aa\\") True >>> valid_palindrome(\\"ab\\") True >>> valid_palindrome(\\"\\") True >>> valid_palindrome(\\"abccba\\") True >>> valid_palindrome(\\"abccbaa\\") True >>> valid_palindrome(\\"abcdeedcba\\") True >>> valid_palindrome(\\"abcdedcba\\") True","solution":"def valid_palindrome(s): Check if the input string can be converted to a valid palindrome by removing at most one character. def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) for i in range(len(s) // 2): if s[i] != s[~i]: j = len(s) - 1 - i return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1) return True"},{"question":"def calculate_areas(dimensions): Calculate the areas of rectangles given their dimensions. Parameters: dimensions (list of tuples): A list of tuples where each tuple contains two integers (length and width). Returns: list: A list of areas corresponding to each rectangle. # TODO: Implement this function # Unit Tests def test_calculate_areas_multiple_rectangles(): assert calculate_areas([(3, 4), (5, 6), (7, 2)]) == [12, 30, 14] def test_calculate_areas_single_rectangle(): assert calculate_areas([(4, 5)]) == [20] def test_calculate_areas_empty_list(): assert calculate_areas([]) == [] def test_calculate_areas_invalid_input_non_integer(): try: calculate_areas([(3, '4'), (5, 6)]) except ValueError as e: assert str(e) == \\"Tuple values must be integers greater than zero\\" def test_calculate_areas_invalid_input_non_positive_integers(): try: calculate_areas([(0, 4), (5, 6)]) except ValueError as e: assert str(e) == \\"Tuple values must be integers greater than zero\\" def test_calculate_areas_invalid_format(): try: calculate_areas([(3, 4, 5), (5, 6)]) except ValueError as e: assert str(e) == \\"Each item in the list should be a tuple of two integers\\" def test_calculate_areas_invalid_not_a_list_of_tuples(): try: calculate_areas(\\"not a list of tuples\\") except ValueError as e: assert str(e) == \\"Input should be a list of tuples\\"","solution":"def calculate_areas(dimensions): Calculate the areas of rectangles given their dimensions. Parameters: dimensions (list of tuples): A list of tuples where each tuple contains two integers (length and width). Returns: list: A list of areas corresponding to each rectangle. # Validate the input to ensure it's a list of tuples containing two integers greater than zero if not isinstance(dimensions, list): raise ValueError(\\"Input should be a list of tuples\\") for dim in dimensions: if not (isinstance(dim, tuple) and len(dim) == 2): raise ValueError(\\"Each item in the list should be a tuple of two integers\\") if not (isinstance(dim[0], int) and dim[0] > 0 and isinstance(dim[1], int) and dim[1] > 0): raise ValueError(\\"Tuple values must be integers greater than zero\\") # Calculate the areas return [length * width for length, width in dimensions]"},{"question":"def evaluate_expression(expression): Evaluate arithmetic expressions given as strings and return the result. The expression can contain addition (+), subtraction (-), multiplication (*), and division (/), with support for parentheses and floating point numbers. The function should also handle invalid input expressions gracefully. Example test cases: >>> evaluate_expression(\\"3+5*2\\") # Output: 13 >>> evaluate_expression(\\"10 + (2 * 5)\\") # Output: 20 >>> evaluate_expression(\\"10 / 2 - 3*2\\") # Output: -1 >>> evaluate_expression(\\"10 + 1.5 * 4 / 2\\") # Output: 13.0 >>> evaluate_expression(\\" 3 + (4 - 1) * 5 \\") # Output: 18 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") # Output: 23 >>> evaluate_expression(\\"3 / 0\\") # Output: \\"Error: Division by zero\\" >>> evaluate_expression(\\"20 +\\") # Output: \\"Error: Invalid expression\\" pass # Example test cases: print(evaluate_expression(\\"3+5*2\\")) # Output: 13 print(evaluate_expression(\\"10 + (2 * 5)\\")) # Output: 20 print(evaluate_expression(\\"10 / 2 - 3*2\\")) # Output: -1 print(evaluate_expression(\\"10 + 1.5 * 4 / 2\\")) # Output: 13.0 print(evaluate_expression(\\" 3 + (4 - 1) * 5 \\")) # Output: 18 print(evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\")) # Output: 23 print(evaluate_expression(\\"3 / 0\\")) # Output: \\"Error: Division by zero\\" print(evaluate_expression(\\"20 +\\")) # Output: \\"Error: Invalid expression\\"","solution":"def evaluate_expression(expression): def evaluate(tokens): def compute(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': if right == 0: raise ZeroDivisionError(\\"division by zero\\") values.append(left / right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': operators.append(tokens[i]) elif tokens[i].isdigit() or tokens[i] == '.': j = i while j < len(tokens) and (tokens[j].isdigit() or tokens[j] == '.'): j += 1 values.append(float(tokens[i:j]) if '.' in tokens[i:j] else int(tokens[i:j])) i = j - 1 elif tokens[i] == ')': while operators and operators[-1] != '(': compute(operators, values) operators.pop() elif tokens[i] in ('+', '-', '*', '/'): while (operators and precedence(operators[-1]) >= precedence(tokens[i])): compute(operators, values) operators.append(tokens[i]) else: return \\"Error: Invalid character in expression\\" i += 1 while operators: compute(operators, values) return values[0] try: return evaluate(expression.strip()) except ZeroDivisionError: return \\"Error: Division by zero\\" except Exception as e: return \\"Error: Invalid expression\\" # Example test cases: print(evaluate_expression(\\"3+5*2\\")) # Output: 13 print(evaluate_expression(\\"10 + (2 * 5)\\")) # Output: 20 print(evaluate_expression(\\"10 / 2 - 3*2\\")) # Output: -1 print(evaluate_expression(\\"10 + 1.5 * 4 / 2\\")) # Output: 13.0 print(evaluate_expression(\\" 3 + (4 - 1) * 5 \\")) # Output: 18 print(evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\")) # Output: 23 print(evaluate_expression(\\"3 / 0\\")) # Output: \\"Error: Division by zero\\" print(evaluate_expression(\\"20 +\\")) # Output: \\"Error: Invalid expression\\""},{"question":"def find_critical_nodes(n: int, edges: List[Tuple[int, int]]) -> List[int]: Finds the critical nodes in a network graph. A critical node (or articulation point) is a node which, when removed, splits the graph into multiple disjoint sub-networks. Parameters: n (int): Number of nodes in the graph. edges (List[Tuple[int, int]]): List of edges in the graph where each edge is represented by a tuple of two integers. Returns: List[int]: List of critical nodes. pass def test_find_critical_nodes(): assert find_critical_nodes(4, [(0, 1), (1, 2), (2, 3)]) == [1, 2] assert find_critical_nodes(3, [(0, 1), (1, 2), (2, 0)]) == [] assert find_critical_nodes(5, [(0, 1), (0, 2), (1, 3), (1, 4)]) == [0, 1] assert find_critical_nodes(6, [(0, 1), (1, 2), (3, 4)]) == [1] assert find_critical_nodes(7, [(0, 1), (0, 2), (1, 3), (1, 4), (3, 5), (4, 6)]) == [0, 1, 3, 4] assert find_critical_nodes(1, []) == [] assert find_critical_nodes(2, []) == [] assert find_critical_nodes(2, [(0, 1)]) == [] assert find_critical_nodes(3, [(0, 1), (1, 2), (1, 1)]) == [1]","solution":"def find_critical_nodes(n, edges): Finds the critical nodes in a network graph. A critical node (or articulation point) is a node which, when removed, splits the graph into multiple disjoint sub-networks. Parameters: n (int): Number of nodes in the graph. edges (List[Tuple[int, int]]): List of edges in the graph where each edge is represented by a tuple of two integers. Returns: List[int]: List of critical nodes. def dfs(node, parent, discovery_time, low_time, visited, time, graph, articulation_points): visited[node] = True discovery_time[node] = low_time[node] = time[0] time[0] += 1 child_count = 0 is_articulation = False for neighbor in graph[node]: if neighbor == parent: continue if not visited[neighbor]: dfs(neighbor, node, discovery_time, low_time, visited, time, graph, articulation_points) child_count += 1 # Check if the subtree rooted at neighbor has a connection back to one of ancestors of node if low_time[neighbor] >= discovery_time[node]: is_articulation = True low_time[node] = min(low_time[node], low_time[neighbor]) else: low_time[node] = min(low_time[node], discovery_time[neighbor]) if (parent == -1 and child_count > 1) or (parent != -1 and is_articulation): articulation_points.add(node) from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) discovery_time = [-1] * n low_time = [-1] * n visited = [False] * n articulation_points = set() time = [0] for i in range(n): if not visited[i]: dfs(i, -1, discovery_time, low_time, visited, time, graph, articulation_points) return sorted(list(articulation_points))"},{"question":"from typing import List, Tuple def largest_rectangle_area(points: List[Tuple[int, int]]) -> int: Returns the largest possible area of a rectangle that can be formed using the given points, with sides parallel to the coordinate axes. >>> largest_rectangle_area([(1, 1), (1, 3), (3, 1), (3, 3), (2, 2), (4, 4)]) 4 >>> largest_rectangle_area([(1,1), (1,4), (4,1), (4,4)]) 9 >>> largest_rectangle_area([(1, 1), (2, 2), (3, 3)]) 0 >>> largest_rectangle_area([(1, 1), (1, 2), (2, 1), (2, 3)]) 0 from solution import largest_rectangle_area def test_no_points(): assert largest_rectangle_area([]) == 0 def test_less_than_four_points(): assert largest_rectangle_area([(1, 1), (2, 2), (3, 3)]) == 0 def test_collinear_points(): assert largest_rectangle_area([(1, 1), (2, 2), (3, 3), (4, 4)]) == 0 def test_no_rectangle_formable(): assert largest_rectangle_area([(1, 1), (1, 2), (2, 1), (2, 3)]) == 0 def test_smallest_rectangle(): assert largest_rectangle_area([(1, 1), (1, 2), (2, 1), (2, 2)]) == 1 def test_largest_area_rectangle(): points = [(1,1), (1,3), (3,1), (3,3), (2,2), (4,4)] assert largest_rectangle_area(points) == 4 # Correct answer with given points scenario def test_another_largest_area_rectangle(): points = [(1,1), (1,4), (4,1), (4,4)] assert largest_rectangle_area(points) == 9 # Correct answer with given points scenario","solution":"def largest_rectangle_area(points): Returns the largest possible area of a rectangle that can be formed using the given points, with sides parallel to the coordinate axes. point_set = set(points) max_area = 0 n = len(points) for i in range(n): for j in range(i + 1, n): x1, y1 = points[i] x2, y2 = points[j] if x1 != x2 and y1 != y2: # ensure points are diagonally opposite if (x1, y2) in point_set and (x2, y1) in point_set: area = abs(x1 - x2) * abs(y1 - y2) max_area = max(max_area, area) return max_area"},{"question":"class TextEditor: A basic text editor class with functionalities to type characters, delete characters, move the cursor, and undo the latest operation. Methods: - type(char: str): Adds a character at the current cursor position. - delete(): Deletes the character at the current cursor position. - move_cursor(position: int): Moves the cursor to the specified position. - undo(): Undoes the most recent operation. - get_text_and_cursor(): Returns the current text and cursor position. def __init__(self): pass def type(self, char: str): pass def delete(self): pass def move_cursor(self, position: int): pass def undo(self): pass def get_text_and_cursor(self): pass def test_type(): editor = TextEditor() editor.type('a') assert editor.get_text_and_cursor() == ('a', 1) editor.type('b') assert editor.get_text_and_cursor() == ('ab', 2) def test_delete(): editor = TextEditor() editor.type('a') editor.type('b') editor.delete() assert editor.get_text_and_cursor() == ('a', 1) def test_move_cursor(): editor = TextEditor() editor.type('a') editor.type('b') editor.move_cursor(0) assert editor.get_text_and_cursor() == ('ab', 0) editor.type('c') assert editor.get_text_and_cursor() == ('cab', 1) def test_undo_type(): editor = TextEditor() editor.type('a') editor.type('b') editor.undo() assert editor.get_text_and_cursor() == ('a', 1) editor.undo() assert editor.get_text_and_cursor() == ('', 0) def test_undo_delete(): editor = TextEditor() editor.type('a') editor.type('b') editor.delete() editor.undo() assert editor.get_text_and_cursor() == ('ab', 2) def test_undo_move_cursor(): editor = TextEditor() editor.type('a') editor.type('b') editor.move_cursor(0) editor.undo() assert editor.get_text_and_cursor() == ('ab', 2) def test_invalid_positions_and_operations(): editor = TextEditor() try: editor.move_cursor(-1) except ValueError: assert True else: assert False try: editor.move_cursor(1) except ValueError: assert True else: assert False try: editor.undo() except RuntimeError: assert True else: assert False try: editor.type(\\"ab\\") except ValueError: assert True else: assert False","solution":"class TextEditor: def __init__(self): self.text = [] self.cursor = 0 self.history = [] def type(self, char: str): if len(char) != 1: raise ValueError(\\"Only single characters can be typed.\\") self.history.append(('type', char, self.cursor)) self.text.insert(self.cursor, char) self.cursor += 1 def delete(self): if self.cursor > 0: deleted_char = self.text[self.cursor - 1] del self.text[self.cursor - 1] self.history.append(('delete', deleted_char, self.cursor)) self.cursor -= 1 def move_cursor(self, position: int): if not (0 <= position <= len(self.text)): raise ValueError(\\"Cursor position out of bounds.\\") self.history.append(('move', self.cursor)) self.cursor = position def undo(self): if not self.history: raise RuntimeError(\\"No operations to undo.\\") last_op = self.history.pop() if last_op[0] == 'type': self.cursor -= 1 del self.text[self.cursor] elif last_op[0] == 'delete': char, pos = last_op[1], last_op[2] self.text.insert(self.cursor, char) self.cursor += 1 elif last_op[0] == 'move': self.cursor = last_op[1] def get_text_and_cursor(self): return ''.join(self.text), self.cursor"},{"question":"def max_subarray(nums): This function takes a list of integers and returns the longest contiguous subarray with a maximum sum along with the sum. If the input list is empty or contains non-integer elements, it returns an error message. >>> max_subarray([1, 2, 3, 4, 5]) ([1, 2, 3, 4, 5], 15) >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) ([4, -1, 2, 1], 6) >>> max_subarray([1]) ([1], 1) >>> max_subarray([]) \\"Invalid input: Empty list\\" >>> max_subarray([1, 2, 'a', 4]) \\"Invalid input: List contains non-integer elements\\" >>> max_subarray([-1, -2, -3, -4]) ([-1], -1) >>> max_subarray([0, -2, -3, 0, -4, 0]) ([0], 0)","solution":"def max_subarray(nums): This function takes a list of integers and returns the longest contiguous subarray with a maximum sum along with the sum. If the input list is empty or contains non-integer elements, it returns an error message. if not nums: return \\"Invalid input: Empty list\\" if any(not isinstance(x, int) for x in nums): return \\"Invalid input: List contains non-integer elements\\" max_sum = float('-inf') current_sum = 0 start = end = temp_start = 0 for i in range(len(nums)): if current_sum <= 0: temp_start = i current_sum = nums[i] else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return nums[start:end+1], max_sum"},{"question":"def rearrange_list(nums, k): Rearranges the list such that all numbers less than or equal to k come before numbers greater than k, preserving the relative order of elements. Parameters: nums (list): List of integers. k (int): The pivot element. Returns: list: Rearranged list of integers. >>> rearrange_list([10, 1, 15, 3, 7, 8, 12, 17, 2], 7) [1, 3, 7, 2, 10, 15, 8, 12, 17] >>> rearrange_list([1, 2, 3, 4, 5], 10) [1, 2, 3, 4, 5] >>> rearrange_list([10, 20, 30, 40, 50], 5) [10, 20, 30, 40, 50] >>> rearrange_list([11, 2, 8, 3, 15, 5, 1, 9], 5) [2, 3, 5, 1, 11, 8, 15, 9] >>> rearrange_list([], 5) [] >>> rearrange_list([5, 5, 5, 5, 5], 5) [5, 5, 5, 5, 5]","solution":"def rearrange_list(nums, k): Rearranges the list such that all numbers less than or equal to k come before numbers greater than k, preserving the relative order of elements. Parameters: nums (list): List of integers. k (int): The pivot element. Returns: list: Rearranged list of integers. less_or_equal = [] greater = [] for num in nums: if num <= k: less_or_equal.append(num) else: greater.append(num) return less_or_equal + greater"},{"question":"def merge_alternately(a: str, b: str) -> str: Merges two strings alternately, starting with the first character of the first string. Parameters: a (str): The first input string. b (str): The second input string. Returns: str: The alternately merged string. >>> merge_alternately(\\"abc\\", \\"123\\") 'a1b2c3' >>> merge_alternately(\\"abcd\\", \\"123\\") 'a1b2c3d' >>> merge_alternately(\\"ab\\", \\"12345\\") 'a1b2345' >>> merge_alternately(\\"\\", \\"\\") '' >>> merge_alternately(\\"abc\\", \\"\\") 'abc' >>> merge_alternately(\\"\\", \\"123\\") '123' # Your code goes here.","solution":"def merge_alternately(a: str, b: str) -> str: Merges two strings alternately, starting with the first character of the first string. Parameters: a (str): The first input string. b (str): The second input string. Returns: str: The alternately merged string. merged_string = [] len_a, len_b = len(a), len(b) min_len = min(len_a, len_b) for i in range(min_len): merged_string.append(a[i]) merged_string.append(b[i]) if len_a > len_b: merged_string.append(a[min_len:]) elif len_b > len_a: merged_string.append(b[min_len:]) return ''.join(merged_string)"},{"question":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. >>> nth_fibonacci(10) 55 >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(20) 6765 >>> nth_fibonacci(30) 832040 pass","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def count_vowels_consonants(s): Returns the number of vowels and consonants in the string. The function is case-insensitive and ignores any non-alphabetic characters. >>> count_vowels_consonants(\\"\\") == (0, 0) >>> count_vowels_consonants(\\"aeiou\\") == (5, 0) >>> count_vowels_consonants(\\"bcdfg\\") == (0, 5) >>> count_vowels_consonants(\\"Hello, World!\\") == (3, 7) >>> count_vowels_consonants(\\"AEIOUaeiou\\") == (10, 0)","solution":"def count_vowels_consonants(s): Returns the number of vowels and consonants in the string. The function is case-insensitive and ignores any non-alphabetic characters. vowels = \\"aeiou\\" s = s.lower() vowel_count = 0 consonant_count = 0 for char in s: if char.isalpha(): if char in vowels: vowel_count += 1 else: consonant_count += 1 return vowel_count, consonant_count"},{"question":"import requests def get_weather(city_name, api_key): Retrieve current weather data for a given city using the OpenWeatherMap API. :param city_name: Name of the city to get the weather for. :param api_key: The API key for OpenWeatherMap. :return: A dictionary containing weather data or an error message. Example: >>> get_weather(\\"London\\", \\"your_api_key\\") { \\"city\\": \\"London\\", \\"country\\": \\"GB\\", \\"weather_description\\": \\"light rain\\", \\"current_temp\\": 15.0, \\"min_temp\\": 13.0, \\"max_temp\\": 17.0, \\"humidity\\": 82, \\"wind_speed\\": 4.6 } pass def display_weather(weather_data): Display the weather information in a user-friendly format. :param weather_data: The dictionary containing weather data or an error message. Example: >>> weather_data = { \\"city\\": \\"London\\", \\"country\\": \\"GB\\", \\"weather_description\\": \\"light rain\\", \\"current_temp\\": 15.0, \\"min_temp\\": 13.0, \\"max_temp\\": 17.0, \\"humidity\\": 82, \\"wind_speed\\": 4.6 } >>> display_weather(weather_data) Weather information for London, GB: - Weather: light rain - Current Temperature: 15.0C - Minimum Temperature: 13.0C - Maximum Temperature: 17.0C - Humidity: 82% - Wind Speed: 4.6 m/s pass # Unit tests for the functions import requests from unittest.mock import patch, Mock def test_get_weather_success(): api_key = \\"fake_api_key\\" city_name = \\"Test City\\" mock_response = Mock() mock_response.status_code = 200 mock_response.json.return_value = { \\"cod\\": 200, \\"name\\": \\"Test City\\", \\"sys\\": {\\"country\\": \\"TC\\"}, \\"weather\\": [{\\"description\\": \\"clear sky\\"}], \\"main\\": { \\"temp\\": 20.5, \\"temp_min\\": 18.0, \\"temp_max\\": 22.0, \\"humidity\\": 45 }, \\"wind\\": {\\"speed\\": 5.5} } with patch(\\"requests.get\\", return_value=mock_response): weather_data = get_weather(city_name, api_key) assert weather_data['city'] == \\"Test City\\" assert weather_data['country'] == \\"TC\\" assert weather_data['weather_description'] == \\"clear sky\\" assert weather_data['current_temp'] == 20.5 assert weather_data['min_temp'] == 18.0 assert weather_data['max_temp'] == 22.0 assert weather_data['humidity'] == 45 assert weather_data['wind_speed'] == 5.5 def test_get_weather_city_not_found(): api_key = \\"fake_api_key\\" city_name = \\"Nonexistent City\\" mock_response = Mock() mock_response.status_code = 404 mock_response.json.return_value = { \\"cod\\": \\"404\\", \\"message\\": \\"city not found\\" } with patch(\\"requests.get\\", return_value=mock_response): weather_data = get_weather(city_name, api_key) assert \\"error\\" in weather_data assert weather_data[\\"error\\"] == \\"Error retrieving weather data: city not found\\" def test_get_weather_network_issue(): api_key = \\"fake_api_key\\" city_name = \\"Test City\\" with patch(\\"requests.get\\", side_effect=requests.exceptions.RequestException(\\"Network error\\")): weather_data = get_weather(city_name, api_key) assert \\"error\\" in weather_data assert weather_data[\\"error\\"] == \\"Network error\\" def test_display_weather_success(capfd): weather_data = { \\"city\\": \\"Test City\\", \\"country\\": \\"TC\\", \\"weather_description\\": \\"clear sky\\", \\"current_temp\\": 20.5, \\"min_temp\\": 18.0, \\"max_temp\\": 22.0, \\"humidity\\": 45, \\"wind_speed\\": 5.5 } display_weather(weather_data) out, _ = capfd.readouterr() assert \\"Weather information for Test City, TC:\\" in out assert \\"- Weather: clear sky\\" in out assert \\"- Current Temperature: 20.5C\\" in out assert \\"- Minimum Temperature: 18.0C\\" in out assert \\"- Maximum Temperature: 22.0C\\" in out assert \\"- Humidity: 45%\\" in out assert \\"- Wind Speed: 5.5 m/s\\" in out def test_display_weather_error(capfd): weather_data = {\\"error\\": \\"city not found\\"} display_weather(weather_data) out, _ = capfd.readouterr() assert \\"Error: city not found\\" in out","solution":"import requests def get_weather(city_name, api_key): url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={api_key}&units=metric\\" try: response = requests.get(url) response.raise_for_status() # Raise an HTTPError if the HTTP request returned an unsuccessful status code weather_data = response.json() if weather_data[\\"cod\\"] != 200: raise ValueError(f\\"Error retrieving weather data: {weather_data['message']}\\") city = weather_data[\\"name\\"] country = weather_data[\\"sys\\"][\\"country\\"] weather_description = weather_data[\\"weather\\"][0][\\"description\\"] current_temp = weather_data[\\"main\\"][\\"temp\\"] min_temp = weather_data[\\"main\\"][\\"temp_min\\"] max_temp = weather_data[\\"main\\"][\\"temp_max\\"] humidity = weather_data[\\"main\\"][\\"humidity\\"] wind_speed = weather_data[\\"wind\\"][\\"speed\\"] return { \\"city\\": city, \\"country\\": country, \\"weather_description\\": weather_description, \\"current_temp\\": current_temp, \\"min_temp\\": min_temp, \\"max_temp\\": max_temp, \\"humidity\\": humidity, \\"wind_speed\\": wind_speed } except requests.exceptions.RequestException as e: return {\\"error\\": str(e)} except ValueError as ve: return {\\"error\\": str(ve)} def display_weather(weather_data): if \\"error\\" in weather_data: print(f\\"Error: {weather_data['error']}\\") else: print(f\\"Weather information for {weather_data['city']}, {weather_data['country']}:\\") print(f\\"- Weather: {weather_data['weather_description']}\\") print(f\\"- Current Temperature: {weather_data['current_temp']}C\\") print(f\\"- Minimum Temperature: {weather_data['min_temp']}C\\") print(f\\"- Maximum Temperature: {weather_data['max_temp']}C\\") print(f\\"- Humidity: {weather_data['humidity']}%\\") print(f\\"- Wind Speed: {weather_data['wind_speed']} m/s\\")"},{"question":"import re import numpy as np from collections import Counter, defaultdict from sklearn.model_selection import train_test_split, StratifiedKFold from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def preprocess_text(text): Preprocess text by tokenizing, lowercasing, and removing non-alphabetic characters. >>> preprocess_text(\\"The quick brown fox jumps over the lazy dog. 123!\\") ['the', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog'] tokens = re.findall(r'b[a-zA-Z]{2,}b', text.lower()) return tokens def build_vocabulary(data): Build a vocabulary set from the given data after preprocessing. >>> build_vocabulary([\\"The quick brown fox\\", \\"jumps over the lazy dog\\"]) {'the', 'quick', 'brown', 'fox', 'jumps', 'over', 'lazy', 'dog'} vocabulary = set() for text in data: tokens = preprocess_text(text) vocabulary.update(tokens) return vocabulary def text_to_bow(text, vocabulary): Convert text to bag-of-words vector based on the given vocabulary. >>> text_to_bow(\\"The quick quick brown fox\\", [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"lazy\\", \\"dog\\"]) [1, 2, 1, 1, 0, 0, 0, 0] tokens = preprocess_text(text) bow_vector = np.zeros(len(vocabulary)) token_counts = Counter(tokens) for token in token_counts: if token in vocabulary: index = vocabulary.index(token) bow_vector[index] = token_counts[token] return bow_vector class NaiveBayesClassifier: def __init__(self): self.vocabulary = None self.class_probs = None self.word_probs = None def fit(self, X, y): Fit the Naive Bayes classifier to the training data. self.vocabulary = list(build_vocabulary(X)) self.class_probs = defaultdict(float) self.word_probs = defaultdict(lambda: defaultdict(float)) class_counts = Counter(y) total_docs = len(y) for cls in class_counts: self.class_probs[cls] = class_counts[cls] / total_docs word_counts = Counter() for i in range(total_docs): if y[i] == cls: bow_vector = text_to_bow(X[i], self.vocabulary) for j, count in enumerate(bow_vector): word_counts[j] += count total_words = sum(word_counts.values()) for word_index in word_counts: self.word_probs[cls][word_index] = (word_counts[word_index] + 1) / (total_words + len(self.vocabulary)) def predict(self, X): Predict the class labels for the given data. results = [] for text in X: bow_vector = text_to_bow(text, self.vocabulary) log_probs = defaultdict(float) for cls in self.class_probs: log_probs[cls] = np.log(self.class_probs[cls]) for i in range(len(bow_vector)): if bow_vector[i] > 0: log_probs[cls] += bow_vector[i] * np.log(self.word_probs[cls].get(i, 1 / len(self.vocabulary))) results.append(max(log_probs, key=log_probs.get)) return results def evaluate_model(model, X_train, y_train, X_val, y_val): Evaluate the model's performance on the validation set. model.fit(X_train, y_train) y_pred_train = model.predict(X_train) y_pred_val = model.predict(X_val) accuracy_train = accuracy_score(y_train, y_pred_train) accuracy_val = accuracy_score(y_val, y_pred_val) precision_val = precision_score(y_val, y_pred_val, pos_label='positive') recall_val = recall_score(y_val, y_pred_val, pos_label='positive') f1_val = f1_score(y_val, y_pred_val, pos_label='positive') return accuracy_train, accuracy_val, precision_val, recall_val, f1_val def cross_validation(model, X, y, k=5): Perform stratified k-fold cross-validation to evaluate the model. skf = StratifiedKFold(n_splits=k) metrics = [] for train_index, val_index in skf.split(X, y): X_train, X_val = X[train_index], X[val_index] y_train, y_val = y[train_index], y[val_index] metrics.append(evaluate_model(model, X_train, y_train, X_val, y_val)) return metrics","solution":"import re import numpy as np from collections import Counter, defaultdict from sklearn.model_selection import train_test_split, StratifiedKFold from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score # Data Preprocessing def preprocess_text(text): # Tokenization, lowercasing, and removing non-alphabetic characters tokens = re.findall(r'b[a-zA-Z]{2,}b', text.lower()) return tokens # Text Vectorization (Bag-of-Words) def build_vocabulary(data): vocabulary = set() for text in data: tokens = preprocess_text(text) vocabulary.update(tokens) return vocabulary def text_to_bow(text, vocabulary): tokens = preprocess_text(text) bow_vector = np.zeros(len(vocabulary)) token_counts = Counter(tokens) for token in token_counts: if token in vocabulary: index = vocabulary.index(token) bow_vector[index] = token_counts[token] return bow_vector # Naive Bayes Classifier class NaiveBayesClassifier: def __init__(self): self.vocabulary = None self.class_probs = None self.word_probs = None def fit(self, X, y): self.vocabulary = list(build_vocabulary(X)) self.class_probs = defaultdict(float) self.word_probs = defaultdict(lambda: defaultdict(float)) class_counts = Counter(y) total_docs = len(y) for cls in class_counts: self.class_probs[cls] = class_counts[cls] / total_docs word_counts = Counter() for i in range(total_docs): if y[i] == cls: bow_vector = text_to_bow(X[i], self.vocabulary) for j, count in enumerate(bow_vector): word_counts[j] += count total_words = sum(word_counts.values()) for word_index in word_counts: self.word_probs[cls][word_index] = (word_counts[word_index] + 1) / (total_words + len(self.vocabulary)) def predict(self, X): results = [] for text in X: bow_vector = text_to_bow(text, self.vocabulary) log_probs = defaultdict(float) for cls in self.class_probs: log_probs[cls] = np.log(self.class_probs[cls]) for i in range(len(bow_vector)): if bow_vector[i] > 0: log_probs[cls] += bow_vector[i] * np.log(self.word_probs[cls].get(i, 1 / len(self.vocabulary))) results.append(max(log_probs, key=log_probs.get)) return results # Training and Validation def evaluate_model(model, X_train, y_train, X_val, y_val): model.fit(X_train, y_train) y_pred_train = model.predict(X_train) y_pred_val = model.predict(X_val) accuracy_train = accuracy_score(y_train, y_pred_train) accuracy_val = accuracy_score(y_val, y_pred_val) precision_val = precision_score(y_val, y_pred_val, pos_label='positive') recall_val = recall_score(y_val, y_pred_val, pos_label='positive') f1_val = f1_score(y_val, y_pred_val, pos_label='positive') return accuracy_train, accuracy_val, precision_val, recall_val, f1_val # cross validation def cross_validation(model, X, y, k=5): skf = StratifiedKFold(n_splits=k) metrics = [] for train_index, val_index in skf.split(X, y): X_train, X_val = X[train_index], X[val_index] y_train, y_val = y[train_index], y[val_index] metrics.append(evaluate_model(model, X_train, y_train, X_val, y_val)) return metrics"},{"question":"import re from collections import Counter from typing import Dict def count_words(sentence: str) -> Dict[str, int]: Create a Python function that takes a sentence as input and returns a dictionary where the keys are the words, and the values are the counts of their occurrences, sorted by the counts in descending order. Ignore punctuation and consider letter case insensitive. >>> count_words(\\"Hello world hello\\") {'hello': 2, 'world': 1} >>> count_words(\\"Hello, world! Hello.\\") {'hello': 2, 'world': 1} >>> count_words(\\"Hello world HELLO\\") {'hello': 2, 'world': 1} >>> count_words(\\"\\") {} >>> count_words(\\"Hello, HELLO, Hello! World... world?\\") {'hello': 3, 'world': 2} >>> count_words(\\"Hello world hello\\") {'hello': 2, 'world': 1}","solution":"import re from collections import Counter def count_words(sentence): Returns a dictionary where the keys are the words, and the values are the counts of their occurrences, sorted by the counts in descending order. Ignores punctuation and is case insensitive. # Removing punctuation and converting to lowercase clean_sentence = re.sub(r'[^ws]', '', sentence).lower() # Splitting the sentence into words words = clean_sentence.split() # Counting the words word_counts = Counter(words) # Sorting the counts in descending order sorted_word_counts = dict(sorted(word_counts.items(), key=lambda item: item[1], reverse=True)) return sorted_word_counts"},{"question":"class BankAccount: Simulates a basic bank account with operations: deposit, withdraw, and check balance. Example: >>> account = BankAccount() >>> account.deposit(100.0) >>> account.check_balance() 100.0 >>> account.withdraw(40.0) >>> account.check_balance() 60.0 def __init__(self): Initialize a bank account with a balance of 0.0 pass def deposit(self, amount): Deposit a positive amount into the bank account. Args: amount (float): The amount to be deposited. Raises: ValueError: If the deposit amount is not positive. pass def withdraw(self, amount): Withdraw a positive amount from the bank account without allowing the balance to go negative. Args: amount (float): The amount to be withdrawn. Raises: ValueError: If the withdraw amount is not positive or if there are insufficient funds. pass def check_balance(self): Check the current balance of the bank account. Returns: float: The current balance. pass # Test cases can be written using pytest as shown: import pytest def test_deposit(): account = BankAccount() account.deposit(100.0) assert account.check_balance() == 100.0 account.deposit(50.0) assert account.check_balance() == 150.0 with pytest.raises(ValueError, match=\\"Deposit amount must be positive\\"): account.deposit(-10.0) def test_withdraw(): account = BankAccount() account.deposit(100.0) account.withdraw(40.0) assert account.check_balance() == 60.0 with pytest.raises(ValueError, match=\\"Withdraw amount must be positive\\"): account.withdraw(-20.0) with pytest.raises(ValueError, match=\\"Insufficient funds\\"): account.withdraw(70.0) def test_check_balance(): account = BankAccount() assert account.check_balance() == 0.0 account.deposit(100.0) assert account.check_balance() == 100.0 account.withdraw(50.0) assert account.check_balance() == 50.0","solution":"class BankAccount: def __init__(self): self.balance = 0.0 def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdraw amount must be positive\\") if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount def check_balance(self): return self.balance"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(9) False >>> is_prime(11) True def divisible_by_3_and_prime() -> list: Iterates through numbers from 1 to 50 and prints numbers that are both divisible by 3 and primes. >>> divisible_by_3_and_prime() [3]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def divisible_by_3_and_prime(): Iterates through numbers from 1 to 50 and prints numbers that are both divisible by 3 and primes. n = 1 result = [] while n <= 50: if n % 3 == 0 and is_prime(n): print(n) result.append(n) n += 1 return result"},{"question":"def find_median(lst): Returns the median of a list of integers. >>> find_median([3, 1, 2, 4]) 2.5 >>> find_median([3, 1, 4]) 3 >>> find_median([1, 2, 3, 4, 5]) 3 >>> find_median([7]) 7 >>> find_median(\\"not a list\\") \\"Error: Input must be a list\\" >>> find_median([]) \\"Error: The list is empty\\" >>> find_median([1, 2, 'a', 4]) \\"Error: All elements of the list must be integers\\"","solution":"def find_median(lst): Returns the median of a list of integers. try: if not isinstance(lst, list): return \\"Error: Input must be a list\\" if len(lst) == 0: return \\"Error: The list is empty\\" for item in lst: if not isinstance(item, int): return \\"Error: All elements of the list must be integers\\" # Sort the list manually for i in range(len(lst)): for j in range(i + 1, len(lst)): if lst[i] > lst[j]: lst[i], lst[j] = lst[j], lst[i] mid = len(lst) // 2 if len(lst) % 2 == 0: median = (lst[mid - 1] + lst[mid]) / 2 else: median = lst[mid] return median except Exception as e: return f\\"An unexpected error occurred: {e}\\""},{"question":"from typing import List def max_sum_subarray(nums: List[int]) -> List[int]: The input to this function is a list of integers, which may contain both positive and negative values. Task is to find the longest contiguous subarray with the maximum sum and return it. If multiple subarrays have the same maximum sum, return the one that appears first. >>> max_sum_subarray([1, -3, 2, 1, -1]) [2, 1] >>> max_sum_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) [4, -1, -2, 1, 5] >>> max_sum_subarray([-1, -2, -3, -4]) [-1] # please write the solution here","solution":"from typing import List def max_sum_subarray(nums: List[int]) -> List[int]: The input to this function is a list of integers, which may contain both positive and negative values. Task is to find the longest contiguous subarray with the maximum sum and return it. If multiple subarrays have the same maximum sum, return the one that appears first. >>> max_sum_subarray([1, -3, 2, 1, -1]) [2, 1] >>> max_sum_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) [4, -1, -2, 1, 5] >>> max_sum_subarray([-1, -2, -3, -4]) [-1] if not nums: return [] max_sum = current_sum = nums[0] start = end = temp_start = 0 for i in range(1, len(nums)): if current_sum + nums[i] < nums[i]: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum or (current_sum == max_sum and (i - temp_start) > (end - start)): max_sum = current_sum start = temp_start end = i return nums[start:end+1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Determine if a given binary tree is a valid binary search tree (BST). Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the tree is a valid BST, False otherwise. >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> is_valid_bst(root) True >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(3) >>> root.right.right = TreeNode(6) >>> is_valid_bst(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=-float('inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"def find_common_elements(list1: list, list2: list) -> list: Returns a list of unique elements that are common to both list1 and list2 in ascending order. >>> find_common_elements([4, 5, 7, 1, 5, 8, 5], [5, 9, 4, 5, 11, 15, 4]) [4, 5] >>> find_common_elements([1, 2, 3], [4, 5, 6]) [] >>> find_common_elements([1, 2, 3, 4], [4, 3, 2, 1]) [1, 2, 3, 4] >>> find_common_elements([], []) [] >>> find_common_elements([1, 2, 3], []) [] >>> find_common_elements([], [1, 2, 3]) [] >>> list1 = list(range(10000)) >>> list2 = list(range(5000, 15000)) >>> expected = list(range(5000, 10000)) >>> find_common_elements(list1, list2) == expected True","solution":"def find_common_elements(list1: list, list2: list) -> list: Returns a list of unique elements that are common to both list1 and list2 in ascending order. # Convert lists to sets to find common elements common_elements = set(list1) & set(list2) # Convert the set to a sorted list return sorted(common_elements)"},{"question":"def filter_and_sort_even_numbers(input_list: List[int]) -> List[int]: This function takes a list of integers and returns another list containing only the even numbers from the input list sorted in descending order. Parameters: input_list (list): A list of integers Returns: list: A list of even integers sorted in descending order >>> filter_and_sort_even_numbers([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [6, 4, 2] >>> filter_and_sort_even_numbers([10, 20, 30, 40, 50]) == [50, 40, 30, 20, 10] >>> filter_and_sort_even_numbers([1, 3, 5, 7, 9]) == [] >>> filter_and_sort_even_numbers([2, 2, 2, 2, 3, 4, 4]) == [4, 4, 2, 2, 2, 2] >>> filter_and_sort_even_numbers([]) == [] >>> filter_and_sort_even_numbers([2]) == [2] >>> filter_and_sort_even_numbers([1]) == []","solution":"def filter_and_sort_even_numbers(input_list): This function takes a list of integers and returns another list containing only the even numbers from the input list sorted in descending order. Parameters: input_list (list): A list of integers Returns: list: A list of even integers sorted in descending order # Filter even numbers even_numbers = [num for num in input_list if num % 2 == 0] # Sort the even numbers in descending order even_numbers.sort(reverse=True) return even_numbers"},{"question":"from typing import List, Dict def categorize_users_by_email_domain(users: List[Dict[str, str]]) -> Dict[str, List[str]]: Categorizes users by the domain of their email addresses. Args: users (list of dict): List containing user information with 'name' and 'email' keys. Returns: dict: Dictionary where keys are email domains and values are lists of user names. >>> categorize_users_by_email_domain([ ... {\\"name\\": \\"John Doe\\", \\"email\\": \\"john.doe@example.com\\"}, ... {\\"name\\": \\"Jane Smith\\", \\"email\\": \\"jane.smith@another.com\\"}, ... {\\"name\\": \\"Tom Brown\\", \\"email\\": \\"tom.brown@example.com\\"} ... ]) {'example.com': ['John Doe', 'Tom Brown'], 'another.com': ['Jane Smith']} >>> categorize_users_by_email_domain([]) {} >>> categorize_users_by_email_domain([ ... {\\"name\\": \\"John Doe\\"}, ... {\\"email\\": \\"jane.smith@another.com\\"} ... ]) {} >>> categorize_users_by_email_domain([ ... {\\"name\\": \\"John Doe\\", \\"email\\": \\"john.doe@.com\\"}, ... {\\"name\\": \\"Jane Smith\\", \\"email\\": \\"jane.smith@\\"}, ... {\\"name\\": \\"Tom Brown\\", \\"email\\": \\"tom.brown@invalid.\\"} ... ]) {}","solution":"import re from collections import defaultdict def categorize_users_by_email_domain(users): Categorizes users by the domain of their email addresses. Args: users (list of dict): List containing user information with 'name' and 'email' keys. Returns: dict: Dictionary where keys are email domains and values are lists of user names. # Regular expression to match the domain part of an email. email_re = re.compile(r'^[^@]+@([^@]+.[^@]+)') domain_dict = defaultdict(list) for user in users: try: email = user['email'] name = user['name'] match = email_re.match(email) if match: domain = match.group(1) domain_dict[domain].append(name) else: raise ValueError(f\\"Invalid email format: {email}\\") except KeyError as ke: print(f\\"Missing key: {ke} in user information: {user}\\") except ValueError as ve: print(ve) return dict(domain_dict)"},{"question":"def translate_to_morse(plaintext: str) -> str: Translate the given plaintext string to Morse code. Non-alphanumeric characters (including spaces) are not encoded and should be replaced by a forward slash ( / ) in the output. Each encoded character is separated by a single space. The function is case insensitive. >>> translate_to_morse(\\"Hello World 123\\") '.... . .-.. .-.. --- / .-- --- .-. .-.. -.. / .---- ..--- ...--' >>> translate_to_morse(\\"a\\") '.-' >>> translate_to_morse(\\"A\\") '.-' >>> translate_to_morse(\\"SOS\\") '... --- ...' >>> translate_to_morse(\\"sos\\") '... --- ...' >>> translate_to_morse(\\"0\\") '-----' >>> translate_to_morse(\\"1 2 3 4 5 6 7 8 9\\") '.---- / ..--- / ...-- / ....- / ..... / -.... / --... / ---.. / ----.' >>> translate_to_morse(\\"Hello!\\") '.... . .-.. .-.. --- / /' >>> translate_to_morse(\\"Morse Code!\\") '-- --- .-. ... . / -.-. --- -.. . /' >>> translate_to_morse(\\"\\") '' >>> translate_to_morse(\\"Hello, World!\\") '.... . .-.. .-.. --- / / .-- --- .-. .-.. -.. /' >>> translate_to_morse(\\"@#%^&*()\\") '/ / / / / / / / /' >>> translate_to_morse(\\"A B C D E F G H I J\\") '.- / -... / -.-. / -.. / . / ..-. / --. / .... / .. / .---'","solution":"def translate_to_morse(plaintext): Translate the given plaintext string to Morse code. Parameters: plaintext (str): The input plaintext string to be translated. Returns: str: The translated Morse code. morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } translated = [] for char in plaintext.upper(): if char in morse_code_dict: translated.append(morse_code_dict[char]) else: translated.append('/') return ' '.join(translated)"},{"question":"class MemoryAllocationSystem: def __init__(self, size): Initializes the memory allocation system with given size. The memory is represented by a list of size \`size\` with all elements set to None. pass def allocate(self, size): Allocates a block of memory of the given size. Returns an identifier if the allocation is successful. Returns an error message if enough contiguous memory is not available. pass def deallocate(self, identifier): Deallocates the memory block associated with the given identifier. Returns success message if deallocation is successful. Returns error message if identifier does not exist. pass def status(self): Returns the current status of the memory, showing which blocks are allocated and which are free. pass # Example usage: # mem_sys = MemoryAllocationSystem(10) # print(mem_sys.allocate(3)) # Expected to allocate and return an identifier, e.g., 1 # print(mem_sys.allocate(2)) # Expected to allocate and return another identifier, e.g., 2 # print(mem_sys.status()) # Expected to show the current memory status # print(mem_sys.deallocate(1)) # Expected to deallocate the block with identifier 1 # print(mem_sys.status()) # Expected to show the updated memory status","solution":"class MemoryAllocationSystem: def __init__(self, size): Initializes the memory allocation system with given size. The memory is represented by a list of size \`size\` with all elements set to None. self.size = size self.memory = [None] * size self.next_id = 1 self.allocated_blocks = {} # to store information about allocated blocks def allocate(self, size): Allocates a block of memory of the given size. Returns an identifier if the allocation is successful. Returns an error message if enough contiguous memory is not available. for i in range(self.size - size + 1): if all(self.memory[j] is None for j in range(i, i + size)): block_id = self.next_id for j in range(i, i + size): self.memory[j] = block_id self.allocated_blocks[block_id] = (i, i + size - 1) self.next_id += 1 return block_id return \\"Error: Not enough contiguous memory available\\" def deallocate(self, identifier): Deallocates the memory block associated with the given identifier. Returns success message if deallocation is successful. Returns error message if identifier does not exist. if identifier in self.allocated_blocks: start, end = self.allocated_blocks.pop(identifier) for i in range(start, end + 1): self.memory[i] = None return \\"Deallocated successfully\\" return \\"Error: Identifier does not exist\\" def status(self): Returns the current status of the memory, showing which blocks are allocated and which are free. return self.memory"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: Write a Python function that takes a list of integers and an integer target value, and returns two distinct elements from the list that add up to the target value. If multiple pairs exist that satisfy the requirement, return any one of them. If no such pair exists, return an empty tuple. The input list may contain negative numbers and duplicates, but you cannot use the same element twice. The function should have a time complexity of O(n). Args: nums: List[int] - a list of integers which may contain negative numbers and duplicates. target: int - the target sum value. Returns: Tuple[int, int] - a tuple of two distinct integers from the list that add up to the target value, or an empty tuple if no such pair exists. >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 1, 1], 3) () >>> find_pair_with_sum([-1, -2, -3, -4, 1, 2, 3, 4], -6) (-2, -4) >>> find_pair_with_sum([1, 2, 3, 2, 5], 4) (1, 3) >>> find_pair_with_sum([3, 3, 4, 4], 6) (3, 3) >>> find_pair_with_sum([1000000001, 1000000003, -1000000004], -1) (1000000003, -1000000004)","solution":"def find_pair_with_sum(nums, target): Returns a tuple of two distinct elements from the list that add up to the target value. If no such pair exists, returns an empty tuple. seen = {} for num in nums: complement = target - num if complement in seen and seen[complement] > 0: return (complement, num) seen[num] = seen.get(num, 0) + 1 return ()"},{"question":"class BankAccount: Simulates a bank account management system including deposit, withdrawal, checking balance, and transaction history. Attributes: balance (float): The current balance of the bank account. transaction_history (List[str]): A list of strings representing the transaction history. Methods: deposit(amount: float) -> str: Deposits a positive amount to the account. withdraw(amount: float) -> str: Withdraws a positive amount from the account with overdraft protection. check_balance() -> str: Returns the current balance of the account. get_transaction_history() -> str: Returns the transaction history. def test_initial_balance(): account = BankAccount(100) assert account.check_balance() == \\"Current balance is 100\\" def test_deposit_positive_amount(): account = BankAccount(100) result = account.deposit(50) assert result == \\"Deposited 50, new balance is 150\\" assert account.check_balance() == \\"Current balance is 150\\" def test_deposit_negative_amount(): account = BankAccount(100) result = account.deposit(-50) assert result == \\"Deposit amount must be positive\\" assert account.check_balance() == \\"Current balance is 100\\" def test_withdraw_positive_amount(): account = BankAccount(100) result = account.withdraw(50) assert result == \\"Withdrew 50, new balance is 50\\" assert account.check_balance() == \\"Current balance is 50\\" def test_withdraw_negative_amount(): account = BankAccount(100) result = account.withdraw(-50) assert result == \\"Withdrawal amount must be positive\\" assert account.check_balance() == \\"Current balance is 100\\" def test_withdraw_more_than_balance(): account = BankAccount(100) result = account.withdraw(150) assert result == \\"Insufficient funds, available balance is 100\\" assert account.check_balance() == \\"Current balance is 100\\" def test_transaction_history(): account = BankAccount(100) account.deposit(50) account.withdraw(30) history = account.get_transaction_history() assert history == \\"Deposited 50nWithdrew 30\\"","solution":"class BankAccount: def __init__(self, initial_balance=0): self.balance = initial_balance self.transaction_history = [] def deposit(self, amount): if amount <= 0: return \\"Deposit amount must be positive\\" self.balance += amount self.transaction_history.append(f\\"Deposited {amount}\\") return f\\"Deposited {amount}, new balance is {self.balance}\\" def withdraw(self, amount): if amount <= 0: return \\"Withdrawal amount must be positive\\" if amount > self.balance: return f\\"Insufficient funds, available balance is {self.balance}\\" self.balance -= amount self.transaction_history.append(f\\"Withdrew {amount}\\") return f\\"Withdrew {amount}, new balance is {self.balance}\\" def check_balance(self): return f\\"Current balance is {self.balance}\\" def get_transaction_history(self): return \\"n\\".join(self.transaction_history)"},{"question":"def add_binary(str1: str, str2: str) -> str: Design a function that takes two strings representing binary numbers and returns their sum as a string. Ensure that the function handles binary numbers of different lengths and performs the addition without converting the binary numbers directly into integers. Implement the addition using basic binary arithmetic principles. >>> add_binary(\\"1010\\", \\"1101\\") == \\"10111\\" >>> add_binary(\\"11\\", \\"1\\") == \\"100\\" >>> add_binary(\\"101\\", \\"10\\") == \\"111\\" >>> add_binary(\\"111\\", \\"111\\") == \\"1110\\" >>> add_binary(\\"0\\", \\"0\\") == \\"0\\" >>> add_binary(\\"1\\", \\"0\\") == \\"1\\" >>> add_binary(\\"1000\\", \\"1\\") == \\"1001\\"","solution":"def add_binary(str1, str2): Returns the sum of two binary numbers as a string. max_len = max(len(str1), len(str2)) # Padding the shorter string with zeros str1 = str1.zfill(max_len) str2 = str2.zfill(max_len) result = [] carry = 0 # Traverse both strings from the last character for i in range(max_len - 1, -1, -1): bit_sum = carry bit_sum += 1 if str1[i] == '1' else 0 bit_sum += 1 if str2[i] == '1' else 0 # bit_sum can be 0, 1, 2, or 3 result.append('1' if bit_sum % 2 == 1 else '0') carry = 0 if bit_sum < 2 else 1 # If there's a carry left, append it if carry != 0: result.append('1') # The final result should be reversed result.reverse() return ''.join(result)"},{"question":"from typing import List from collections import Counter def top_k_frequent(nums: List[int], k: int) -> List[int]: Create a function in Python that takes a list of integers and an integer k, and returns a list of k integers that appear most frequently in the input list. If there are multiple candidates with the same frequency, the function should return the smaller numbers first. Args: nums (List[int]): List of integers. k (int): Number of top frequent elements to return. Returns: List[int]: List of k most frequent integers. Examples: >>> top_k_frequent([1, 2, 3, 2, 3, 1, 3, 2], 2) [2, 3] >>> top_k_frequent([4, 4, 4, 6, 6, 5, 5, 5, 1], 3) [4, 5, 6] # Implement your solution here","solution":"from collections import Counter def top_k_frequent(nums, k): Returns a list of k integers that appear most frequently in the input list. If there are multiple candidates with the same frequency, returns the smaller numbers first. count = Counter(nums) # Sort by frequency first (descending) and then by number (ascending) sorted_items = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k elements result = [item[0] for item in sorted_items[:k]] return result"},{"question":"def eval_rpn(tokens): Evaluates a mathematical expression in Reverse Polish Notation. Args: tokens (List[str]): The RPN expression where each token is either an integer or an operator (+, -, *, /). Returns: int: The result of evaluating the RPN expression. Examples: >>> eval_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> eval_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> eval_rpn([\\"10\\", \\"-3\\", \\"/\\"]) -3","solution":"def eval_rpn(tokens): Evaluates a mathematical expression in Reverse Polish Notation. Args: tokens (List[str]): The RPN expression where each token is either an integer or an operator (+, -, *, /). Returns: int: The result of evaluating the RPN expression. stack = [] for token in tokens: if token in {\\"+\\", \\"-\\", \\"*\\", \\"/\\"}: b = stack.pop() a = stack.pop() if token == \\"+\\": result = a + b elif token == \\"-\\": result = a - b elif token == \\"*\\": result = a * b elif token == \\"/\\": result = int(a / b) # Truncate towards zero stack.append(result) else: stack.append(int(token)) return stack[0] # Time complexity: O(n) where n is the number of tokens # Space complexity: O(n) for the stack storing operands"},{"question":"from collections import Counter from typing import List, Tuple, Dict, Union def frequency_count_and_max(input_list: List[int]) -> Tuple[Dict[int, int], Union[Tuple[int, int], None]]: Create a function that accepts a list of integers and returns a dictionary with the frequency count of each unique integer in the list. The function should also identify the integer with the highest frequency in the list and return it along with its frequency count. If there are multiple integers with the same highest frequency, return any one of them. >>> frequency_count_and_max([]) ({}, None) >>> frequency_count_and_max([1]) (Counter({1: 1}), (1, 1)) >>> frequency_count_and_max([1, 2, 2, 3, 3, 3]) (Counter({1: 1, 2: 2, 3: 3}), (3, 3)) >>> frequency_count_and_max([1, 2, 2, 1]) (Counter({1: 2, 2: 2}), (1, 2)) # or (Counter({1: 2, 2: 2}), (2, 2)) >>> frequency_count_and_max([1, 2, 3, 4, 5]) (Counter({1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), (1, 1)) # or any tuple with value 1 and frequency 1","solution":"from collections import Counter def frequency_count_and_max(input_list): Returns a dictionary with the frequency count of each unique integer in the list and the integer with the highest frequency and its count. if not input_list: return {}, None frequency_dict = Counter(input_list) most_common = frequency_dict.most_common(1)[0] # Get the most common element return frequency_dict, most_common"},{"question":"def second_largest(numbers: List[int]) -> Union[int, str]: Finds the second largest number in a list of integers. >>> second_largest([10, 20, 4, 45, 99]) 45 >>> second_largest([6, 6, 6]) \\"No second largest number\\" >>> second_largest([3]) \\"No second largest number\\" >>> second_largest([-1, -2, -3, -4]) -2 >>> second_largest([7, 7, 5, 5, 3, 3]) 5 >>> second_largest([1, -1, 2, -2]) 1","solution":"def second_largest(numbers): Finds the second largest number in a list of integers. unique_numbers = list(set(numbers)) # Remove duplicates if len(unique_numbers) < 2: return \\"No second largest number\\" unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. Args: n (int): The number to check. Returns: bool: True if the number is prime, False otherwise. pass def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the input list. Args: numbers (List[int]): The list of integers to filter. Returns: List[int]: A list of prime numbers. >>> filter_primes([10, 15, 3, 7, 8, 23]) [3, 7, 23] >>> filter_primes([1, 2, 4, 6, 9, 11, 29, 37]) [2, 11, 29, 37] pass if __name__ == \\"__main__\\": print(filter_primes([10, 15, 3, 7, 8, 23])) print(filter_primes([1, 2, 4, 6, 9, 11, 29, 37]))","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the input list. return [num for num in numbers if is_prime(num)] if __name__ == \\"__main__\\": print(filter_primes([10, 15, 3, 7, 8, 23])) print(filter_primes([1, 2, 4, 6, 9, 11, 29, 37]))"},{"question":"def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in nums. Uses a time complexity of O(n log n) where n is the number of elements in the list. Args: nums (list): A list of integers Returns: int: The length of the longest strictly increasing subsequence >>> length_of_LIS([]) 0 >>> length_of_LIS([1]) 1 >>> length_of_LIS([1, 2, 3, 4, 5]) 5 >>> length_of_LIS([5, 4, 3, 2, 1]) 1 >>> length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> length_of_LIS([1, 2, 2, 2, 3, 4, 5, 3]) 5 >>> length_of_LIS([-1, 0, -2, -3, 4, 2, 3, 5, 0, -1, 1, 2]) 5","solution":"import bisect def length_of_LIS(nums): Returns the length of the longest strictly increasing subsequence in nums. Uses a time complexity of O(n log n) where n is the number of elements in the list. Args: nums (list): A list of integers Returns: int: The length of the longest strictly increasing subsequence if not nums: return 0 sub = [] for x in nums: if len(sub) == 0 or x > sub[-1]: sub.append(x) else: idx = bisect.bisect_left(sub, x) sub[idx] = x return len(sub)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a new list where each element at index i is the product of all numbers in the input list except the one at index i, without using division. The solution should have O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([10]) [1] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1]","solution":"def product_except_self(nums): Returns a new list where each element at index i is the product of all numbers in the input list except the one at index i. length = len(nums) result = [1] * length # Calculate left products left = 1 for i in range(length): result[i] = left left *= nums[i] # Calculate right products and final result right = 1 for i in reversed(range(length)): result[i] *= right right *= nums[i] return result"},{"question":"def find_max_sum_subarray(arr): Determines if there is a subarray whose length is greater than 1 and whose sum is greater than or equal to the sum of the elements of any other subarray with the same length in the array. Args: arr (List[int]): The input array of non-negative integers. Returns: bool: True if such a subarray exists, False otherwise. Examples: >>> find_max_sum_subarray([1, 2, 3, 4]) True >>> find_max_sum_subarray([4, 1, 1, 1, 4, 2, 2]) True >>> find_max_sum_subarray([1, 1, 1, 1]) True >>> find_max_sum_subarray([0, 0, 0, 0]) False # Your code here def test_find_max_sum_subarray(): assert find_max_sum_subarray([1, 2, 3, 4]) == True assert find_max_sum_subarray([4, 1, 1, 1, 4, 2, 2]) == True assert find_max_sum_subarray([1, 1, 1, 1]) == True assert find_max_sum_subarray([0, 0, 0, 0]) == False assert find_max_sum_subarray([0, 1, 2, 3, 4]) == True assert find_max_sum_subarray([4]) == False assert find_max_sum_subarray([1, 2]) == True assert find_max_sum_subarray([2, 2, 2, 2, 2]) == True assert find_max_sum_subarray([5, -1, 3, -2, 1]) == True # Running the test function test_find_max_sum_subarray()","solution":"def find_max_sum_subarray(arr): Determines if there is a subarray whose length is greater than 1 and whose sum is greater than or equal to the sum of the elements of any other subarray with the same length in the array. n = len(arr) if n < 2: return False for length in range(2, n+1): max_subarray_sum = float('-inf') for i in range(n - length + 1): subarray_sum = sum(arr[i:i+length]) if subarray_sum >= max_subarray_sum: max_subarray_sum = subarray_sum if max_subarray_sum > 0: return True return False"},{"question":"def sum_of_squares(dict_of_lists): Given a dictionary where keys are strings and values are lists of integers, return a new dictionary with the same keys and the value being the sum of the squares of the integers in the list. Parameters: dict_of_lists (dict): Dictionary with string keys and list of integers as values. Returns: dict: Dictionary with string keys and integer values representing the sum of squares of the respective lists. >>> sum_of_squares({\\"a\\": [1, 2, 3], \\"b\\": [4, 5], \\"c\\": [6]}) {'a': 14, 'b': 41, 'c': 36} >>> sum_of_squares({\\"a\\": [], \\"b\\": [], \\"c\\": []}) {'a': 0, 'b': 0, 'c': 0} >>> sum_of_squares({\\"a\\": [1], \\"b\\": [1, 2, 3, 4], \\"c\\": [10, -10]}) {'a': 1, 'b': 30, 'c': 200} >>> sum_of_squares({\\"neg\\": [-1, -2, -3], \\"mixed\\": [-1, 1]}) {'neg': 14, 'mixed': 2} >>> sum_of_squares({\\"a\\": [8], \\"b\\": [0], \\"c\\": [-3]}) {'a': 64, 'b': 0, 'c': 9}","solution":"def sum_of_squares(dict_of_lists): Given a dictionary where keys are strings and values are lists of integers, return a new dictionary with the same keys and the value being the sum of the squares of the integers in the list. Parameters: dict_of_lists (dict): Dictionary with string keys and list of integers as values. Returns: dict: Dictionary with string keys and integer values representing the sum of squares of the respective lists. result = {} for key, value_list in dict_of_lists.items(): result[key] = sum(x ** 2 for x in value_list) return result"},{"question":"import re from typing import List def validate_license_plates(license_plates: List[str]) -> List[bool]: Validates a list of license plate numbers based on the following rules: 1. The license plate must be exactly 7 characters long. 2. The first three characters must be uppercase letters. 3. The next four characters must be digits. 4. No other characters are allowed. >>> validate_license_plates(['ABC1234', 'XYZ9999']) == [True, True] >>> validate_license_plates(['AB1234', 'ABCDE1234']) == [False, False] >>> validate_license_plates(['abc1234', 'A1C1234']) == [False, False] >>> validate_license_plates(['ABC123', 'XYZ12A4']) == [False, False] >>> validate_license_plates(['ABC1234', 'AB1234', 'ab1234', 'XYZ1234']) == [True, False, False, True]","solution":"import re def validate_license_plates(license_plates): Validates a list of license plate numbers based on specified rules. Parameters: license_plates (list): List of license plate numbers as strings. Returns: list: List of booleans indicating the validity of each license plate. pattern = re.compile(r'^[A-Z]{3}d{4}') return [bool(pattern.match(plate)) for plate in license_plates]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathLeafToLeaf(root): Design a function that takes a binary tree and returns the maximum path sum from one leaf to another within the tree. The path must pass through at least two nodes in the tree (i.e., it can't be from a single leaf to itself). Each node in the binary tree contains an integer value, which can be positive or negative. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> maxPathLeafToLeaf(root) 11 >>> root = TreeNode(5) >>> maxPathLeafToLeaf(root) float('-inf') >>> root = TreeNode(-10) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxPathLeafToLeaf(root) 42 >>> maxPathLeafToLeaf(None) 0 >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> maxPathLeafToLeaf(root) 48","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathLeafToLeaf(root): def maxPathSum(node): nonlocal max_sum if not node: return float('-inf') # to represent the notion of path sum through non-existent node if not node.left and not node.right: return node.val left_sum = maxPathSum(node.left) right_sum = maxPathSum(node.right) if node.left and node.right: max_sum = max(max_sum, left_sum + right_sum + node.val) return max(left_sum, right_sum) + node.val elif node.left: return left_sum + node.val else: return right_sum + node.val if not root: return 0 max_sum = float('-inf') maxPathSum(root) return max_sum"},{"question":"def square_list(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list with each element squared. If the input list is empty, returns an empty list. >>> square_list([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_list([]) [] >>> square_list([-1, 2, -3, 4]) [1, 4, 9, 16] >>> square_list([5]) [25] >>> square_list([0, 0, 0]) [0, 0, 0] >>> square_list([10**6, -10**6]) [10**12, 10**12]","solution":"def square_list(numbers): Takes a list of integers and returns a new list with each element squared. If the input list is empty, returns an empty list. return [x**2 for x in numbers]"},{"question":"def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. The function takes two input arrays of integers, which are already in non-decreasing order, and returns a new array that contains all the elements from both input arrays, also in non-decreasing order. The solution has a time complexity of O(n + m), where n and m are the sizes of the two input arrays. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 2, 3], [2, 2, 4]) [1, 2, 2, 2, 2, 3, 4] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1], [2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sorted_arrays([1, 2, 3, 4], [5]) [1, 2, 3, 4, 5] >>> merge_sorted_arrays([-3, -1, 0, 2], [-2, 1, 3]) [-3, -2, -1, 0, 1, 2, 3]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. result = [] i, j = 0, 0 # Use two pointers to merge arrays while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 # Collect remaining elements from arr1 while i < len(arr1): result.append(arr1[i]) i += 1 # Collect remaining elements from arr2 while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"def sort_string(s: str) -> str: Sorts a given string such that all alphabets appear in descending order followed by all numbers in ascending order. Special characters are ignored. >>> sort_string(\\"a1b2c3\\") 'cba123' >>> sort_string(\\"badc\\") 'dcba' >>> sort_string(\\"3241\\") '1234' >>> sort_string(\\"\\") '' >>> sort_string(\\"a!c@#1b\\") 'cba1'","solution":"def sort_string(s): Sorts a given string such that all alphabets appear in descending order followed by all numbers in ascending order. Special characters are ignored. alphabets = sorted([char for char in s if char.isalpha()], reverse=True) numbers = sorted([char for char in s if char.isdigit()]) return ''.join(alphabets + numbers)"},{"question":"def count_letter_frequency(input_string: str) -> dict: This function takes a string and returns a dictionary with the frequency of each letter in the string, ignoring case and non-letter characters. >>> count_letter_frequency(\\"Hello World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_letter_frequency(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> count_letter_frequency(\\"\\") {} >>> count_letter_frequency(\\"123!@# abc XYZ\\") {'a': 1, 'b': 1, 'c': 1, 'x': 1, 'y': 1, 'z': 1} >>> count_letter_frequency(\\"12345!@#%\\") {}","solution":"def count_letter_frequency(input_string): This function takes a string and returns a dictionary with the frequency of each letter in the string, ignoring case and non-letter characters. frequency = {} for char in input_string: if char.isalpha(): char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def flatten_list(nested_list): In a Python list, an element can either be an integer or a nested list containing integers. Write a function flatten_list that takes such a list as an argument and returns a new list where all nested lists are flattened. In other words, all integers should be present in a single, one-dimensional list. >>> flatten_list([1, 2, 3]) [1, 2, 3] >>> flatten_list([1, [2, 3], [4, [5, 6]], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_list([[1, [2, [3, [4, 5]]]], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_list([]) [] >>> flatten_list([1, [2, []], [3, [[], 4]], 5, []]) [1, 2, 3, 4, 5]","solution":"def flatten_list(nested_list): This function takes a nested list as an argument and returns a new list with all nested lists flattened. flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten_list(element)) else: flat_list.append(element) return flat_list"},{"question":"def count_sunset_views(building_heights: List[int]) -> int: Returns the number of buildings with an unobstructed view of the sunset. >>> count_sunset_views([3, 7, 8, 3, 6, 1]) == 3 >>> count_sunset_views([]) == 0 >>> count_sunset_views([5, 4, 3, 2, 1]) == 5 >>> count_sunset_views([1, 2, 3, 4, 5]) == 1 >>> count_sunset_views([5, 5, 5, 5, 5]) == 1 # Test Cases print(count_sunset_views([3, 7, 8, 3, 6, 1])) # Output: 3 (buildings with heights 8, 6, and 1) print(count_sunset_views([])) # Output: 0 (no buildings) print(count_sunset_views([5, 4, 3, 2, 1])) # Output: 5 (each building has an unobstructed view) print(count_sunset_views([1, 2, 3, 4, 5])) # Output: 1 (only the last building has an unobstructed view) print(count_sunset_views([5, 5, 5, 5, 5])) # Output: 1 (only the last building has an unobstructed view)","solution":"def count_sunset_views(building_heights): Returns the number of buildings with an unobstructed view of the sunset. count = 0 max_height = -1 for height in reversed(building_heights): if height > max_height: count += 1 max_height = height return count"},{"question":"from collections import deque, defaultdict class GraphTraversal: GraphTraversal class to perform BFS and DFS on an undirected graph. Methods: - addEdge(u, v): Adds an undirected edge between nodes u and v. - bfs(start): Performs BFS starting from the node start. - dfs(start): Performs DFS starting from the node start. - showGraph(): Displays the adjacency list of the graph. def __init__(self): self.graph = defaultdict(list) def addEdge(self, u, v): Adds an undirected edge between nodes u and v. Parameters: u : int : The first node in the edge. v : int : The second node in the edge. Raises: ValueError: If attempting to add an edge between a node and itself. pass def bfs(self, start): Performs BFS starting from the node start. Parameters: start : int : The starting node for BFS traversal. Returns: list : List of nodes in the order they were visited. Raises: ValueError: If the start node is not present in the graph. pass def dfs(self, start): Performs DFS starting from the node start. Parameters: start : int : The starting node for DFS traversal. Returns: list : List of nodes in the order they were visited. Raises: ValueError: If the start node is not present in the graph. pass def showGraph(self): Displays the adjacency list of the graph. Returns: dict : The adjacency list of the graph. pass import pytest def test_add_edge(): graph = GraphTraversal() graph.addEdge(1, 2) graph.addEdge(2, 3) expected_graph = {1: [2], 2: [1, 3], 3: [2]} assert graph.showGraph() == expected_graph def test_add_edge_self_loop(): graph = GraphTraversal() with pytest.raises(ValueError, match=\\"Cannot add an edge between a node and itself\\"): graph.addEdge(1, 1) def test_add_edge_duplicate(): graph = GraphTraversal() graph.addEdge(1, 2) graph.addEdge(1, 2) # Adding duplicate edge should not cause an issue expected_graph = {1: [2], 2: [1]} assert graph.showGraph() == expected_graph def test_bfs_single_component(): graph = GraphTraversal() graph.addEdge(1, 2) graph.addEdge(2, 3) graph.addEdge(3, 4) assert graph.bfs(1) == [1, 2, 3, 4] def test_bfs_disconnected_component(): graph = GraphTraversal() graph.addEdge(1, 2) graph.addEdge(3, 4) assert graph.bfs(1) == [1, 2] assert graph.bfs(3) == [3, 4] def test_bfs_invalid_start_node(): graph = GraphTraversal() graph.addEdge(1, 2) with pytest.raises(ValueError, match=\\"Start node 3 is not present in the graph\\"): graph.bfs(3) def test_dfs_single_component(): graph = GraphTraversal() graph.addEdge(1, 2) graph.addEdge(2, 3) graph.addEdge(3, 4) assert graph.dfs(1) == [1, 2, 3, 4] def test_dfs_disconnected_component(): graph = GraphTraversal() graph.addEdge(1, 2) graph.addEdge(3, 4) assert graph.dfs(1) == [1, 2] assert graph.dfs(3) == [3, 4] def test_dfs_invalid_start_node(): graph = GraphTraversal() graph.addEdge(1, 2) with pytest.raises(ValueError, match=\\"Start node 3 is not present in the graph\\"): graph.dfs(3)","solution":"from collections import deque, defaultdict class GraphTraversal: def __init__(self): self.graph = defaultdict(list) def addEdge(self, u, v): if u == v: raise ValueError(\\"Cannot add an edge between a node and itself\\") if v not in self.graph[u]: self.graph[u].append(v) self.graph[v].append(u) def bfs(self, start): if start not in self.graph: raise ValueError(f\\"Start node {start} is not present in the graph\\") visited = set() queue = deque([start]) result = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) result.append(node) for neighbour in self.graph[node]: if neighbour not in visited: queue.append(neighbour) return result def dfs(self, start): if start not in self.graph: raise ValueError(f\\"Start node {start} is not present in the graph\\") visited = set() stack = [start] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) for neighbour in reversed(self.graph[node]): if neighbour not in visited: stack.append(neighbour) return result def showGraph(self): return dict(self.graph)"},{"question":"def fibonacci_check(n: int, x: int) -> str: Write a program to generate the Fibonacci sequence up to a given number \`n\` and then determine if a specific integer \`x\` is a part of this sequence. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones. The sequence commonly starts with 0 and 1. Your task is to: 1. Generate the Fibonacci sequence up to \`n\` (inclusive). 2. Check if \`x\` is an element of the generated Fibonacci sequence. 3. Print \\"Yes\\" if \`x\` is a part of the sequence, otherwise print \\"No\\". Args: n (int): An integer representing the upper limit of the Fibonacci sequence (0  n  10000). x (int): An integer representing the number to be checked within the Fibonacci sequence. Returns: str: A string \\"Yes\\" or \\"No\\" indicating whether \`x\` is a part of the Fibonacci sequence generated up to \`n\`. Examples: >>> fibonacci_check(21, 13) \\"Yes\\" >>> fibonacci_check(21, 22) \\"No\\" from solution import fibonacci_check def test_fibonacci_check_present(): assert fibonacci_check(21, 13) == \\"Yes\\" assert fibonacci_check(21, 21) == \\"Yes\\" assert fibonacci_check(34, 21) == \\"Yes\\" assert fibonacci_check(0, 0) == \\"Yes\\" assert fibonacci_check(1, 1) == \\"Yes\\" def test_fibonacci_check_not_present(): assert fibonacci_check(21, 22) == \\"No\\" assert fibonacci_check(34, 35) == \\"No\\" assert fibonacci_check(0, 10) == \\"No\\" assert fibonacci_check(1, 2) == \\"No\\" assert fibonacci_check(13, 14) == \\"No\\" def test_fibonacci_large_values(): assert fibonacci_check(10000, 89) == \\"Yes\\" assert fibonacci_check(10000, 233) == \\"Yes\\" assert fibonacci_check(10000, 610) == \\"Yes\\" assert fibonacci_check(10000, 987) == \\"Yes\\" assert fibonacci_check(10000, 1597) == \\"Yes\\" assert fibonacci_check(10000, 6765) == \\"Yes\\" assert fibonacci_check(10000, 10000) == \\"No\\"","solution":"def fibonacci_check(n: int, x: int) -> str: Returns \\"Yes\\" if x is an element of the Fibonacci sequence up to n, otherwise returns \\"No\\". # Initialize the first two Fibonacci numbers a, b = 0, 1 # Edge case where x is 0 or 1 if x == 0 or x == 1: return \\"Yes\\" if x <= n else \\"No\\" # Generate Fibonacci sequence up to n while a <= n: if a == x: return \\"Yes\\" a, b = b, a + b return \\"No\\""},{"question":"def find_largest_palindrome(input_list: List[str]) -> str: Finds the longest palindrome in a list of strings. If multiple palindromes of the same length are found, the first one encountered in the list is returned. If no palindromes are found, returns an empty string. >>> find_largest_palindrome([\\"racecar\\"]) == \\"racecar\\" >>> find_largest_palindrome([\\"racecar\\", \\"level\\", \\"world\\", \\"civic\\", \\"deified\\"]) == \\"racecar\\" >>> find_largest_palindrome([\\"world\\", \\"madam\\", \\"abba\\", \\"noon\\"]) == \\"madam\\" >>> find_largest_palindrome([\\"world\\", \\"example\\", \\"python\\"]) == \\"\\" >>> find_largest_palindrome([]) == \\"\\" >>> find_largest_palindrome([\\"abcba\\", \\"abcdcba\\", \\"a\\"]) == \\"abcdcba\\" >>> find_largest_palindrome([\\"abcba\\", \\"defed\\", \\"ghihg\\"]) == \\"abcba\\" >>> find_largest_palindrome([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) == \\"a\\"","solution":"def find_largest_palindrome(input_list): Finds the longest palindrome in a list of strings. If multiple palindromes of the same length are found, the first one encountered in the list is returned. If no palindromes are found, returns an empty string. def is_palindrome(s): return s == s[::-1] max_length = 0 largest_palindrome = \\"\\" for s in input_list: if is_palindrome(s) and len(s) > max_length: max_length = len(s) largest_palindrome = s return largest_palindrome"},{"question":"def calculate_averages(students): Given a list of students with their scores, return a dictionary with student names as keys and their average scores as values, rounded to two decimal places. Args: students (list): A list of dictionaries where each dictionary contains a student's 'name' and 'scores'. Returns: dict: A dictionary with student names as keys and their average scores as values. # Implement the function here # Example test cases students = [ {\\"name\\": \\"Alice\\", \\"scores\\": [88, 76, 92]}, {\\"name\\": \\"Bob\\", \\"scores\\": [78, 81, 85]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [95, 93, 90]} ] print(calculate_averages(students)) # Expected: {\\"Alice\\": 85.33, \\"Bob\\": 81.33, \\"Charlie\\": 92.67} students = [{\\"name\\": \\"Alice\\", \\"scores\\": [88, 76, 92]}] print(calculate_averages(students)) # Expected: {\\"Alice\\": 85.33} students = [{\\"name\\": \\"Alice\\", \\"scores\\": []}] try: print(calculate_averages(students)) # Expected: Raise ZeroDivisionError except ZeroDivisionError: print(\\"Caught ZeroDivisionError as expected\\") students = [ {\\"name\\": \\"Alice\\", \\"scores\\": [88]}, {\\"name\\": \\"Bob\\", \\"scores\\": [78, 81]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [95, 93, 90, 88]} ] print(calculate_averages(students)) # Expected: {\\"Alice\\": 88.00, \\"Bob\\": 79.50, \\"Charlie\\": 91.50}","solution":"def calculate_averages(students): Given a list of students with their scores, return a dictionary with student names as keys and their average scores as values, rounded to two decimal places. Args: students (list): A list of dictionaries where each dictionary contains a student's 'name' and 'scores'. Returns: dict: A dictionary with student names as keys and their average scores as values. averages = {} for student in students: name = student['name'] scores = student['scores'] average_score = round(sum(scores) / len(scores), 2) averages[name] = average_score return averages"},{"question":"class UserRegistrationSystem: def __init__(self): self.registered_users = {} def is_valid_password(self, password): Check if the password meets the security criteria: - Minimum 8 characters - At least one uppercase letter - At least one lowercase letter - At least one number # Implementation here def register_user(self, username, password): Register a new user with a unique username and a valid password. >>> system = UserRegistrationSystem() >>> system.register_user(\\"new_user\\", \\"Password1\\") 'Registration successful!' >>> system.register_user(\\"new_user\\", \\"Password2\\") 'Username already exists.' >>> system.register_user(\\"shortpwduser\\", \\"Pwd1\\") 'Password does not meet security criteria.' >>> system.register_user(\\"nonumberuser\\", \\"Password\\") 'Password does not meet security criteria.' >>> system.register_user(\\"nouppercaseuser\\", \\"password1\\") 'Password does not meet security criteria.' >>> system.register_user(\\"nolowercaseuser\\", \\"PASSWORD1\\") 'Password does not meet security criteria.' # Implementation here def test_user_registration(): system = UserRegistrationSystem() assert system.register_user(\\"new_user\\", \\"Password1\\") == \\"Registration successful!\\" assert system.register_user(\\"new_user\\", \\"Password2\\") == \\"Username already exists.\\" assert system.register_user(\\"shortpwduser\\", \\"Pwd1\\") == \\"Password does not meet security criteria.\\" assert system.register_user(\\"nonumberuser\\", \\"Password\\") == \\"Password does not meet security criteria.\\" assert system.register_user(\\"nouppercaseuser\\", \\"password1\\") == \\"Password does not meet security criteria.\\" assert system.register_user(\\"nolowercaseuser\\", \\"PASSWORD1\\") == \\"Password does not meet security criteria.\\" def test_is_valid_password(): system = UserRegistrationSystem() assert not system.is_valid_password(\\"Pwd1\\") # too short assert not system.is_valid_password(\\"password1\\") # no uppercase assert not system.is_valid_password(\\"PASSWORD1\\") # no lowercase assert not system.is_valid_password(\\"Password\\") # no number assert system.is_valid_password(\\"Password1\\") # valid password","solution":"class UserRegistrationSystem: def __init__(self): self.registered_users = {} def is_valid_password(self, password): if len(password) < 8: return False if not any(char.isdigit() for char in password): return False if not any(char.islower() for char in password): return False if not any(char.isupper() for char in password): return False return True def register_user(self, username, password): if username in self.registered_users: return \\"Username already exists.\\" if not self.is_valid_password(password): return \\"Password does not meet security criteria.\\" self.registered_users[username] = password return \\"Registration successful!\\""},{"question":"import re from collections import Counter def word_frequency(input_string: str) -> List[str]: Write a Python function that takes a string as input and returns a list of all unique words in that string, sorted by their frequency in descending order. If two words have the same frequency, they should appear in ascending alphabetical order. The function should be case insensitive and should ignore punctuation. >>> word_frequency(\\"The rain in Spain falls mainly on the plain. In the plain, rain is mainly steady.\\") [\\"the\\", \\"in\\", \\"mainly\\", \\"plain\\", \\"rain\\", \\"falls\\", \\"is\\", \\"on\\", \\"spain\\", \\"steady\\"] >>> word_frequency(\\"\\") [] >>> word_frequency(\\"Word\\") [\\"word\\"] >>> word_frequency(\\"Test test TeSt\\") [\\"test\\"] >>> word_frequency(\\"Hello, world! Hello world.\\") [\\"hello\\", \\"world\\"] >>> word_frequency(\\"cat bat bat cat cat bat apple apple\\") [\\"bat\\", \\"cat\\", \\"apple\\"]","solution":"import re from collections import Counter def word_frequency(input_string): # Convert the string to lowercase and remove punctuation input_string = re.sub(r'[^ws]', '', input_string.lower()) # Split the string into words words = input_string.split() # Count the frequency of each word word_count = Counter(words) # Sort words by frequency (descending order), then by alphabetical order sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) return [word[0] for word in sorted_words]"},{"question":"def concatenateStrings(strings, delimiter=\\"\\"): Concatenates a list of strings in reverse order with a custom delimiter. :param strings: List of strings to be concatenated. :param delimiter: Custom delimiter to be used between strings. :return: Concatenated string in reverse order. >>> concatenateStrings([\\"a\\", \\"b\\", \\"c\\"]) 'cba' >>> concatenateStrings([\\"a\\", \\"b\\", \\"c\\"], \\" \\") 'c b a' >>> concatenateStrings([]) '' >>> concatenateStrings([\\"a\\"]) 'a' >>> concatenateStrings([\\"hello\\", \\"world\\"], \\", \\") 'world, hello' >>> concatenateStrings([\\"abc\\", \\"123\\", \\"xyz\\"], \\"-\\") 'xyz-123-abc' >>> concatenateStrings([\\"a\\", \\"\\", \\"c\\"], \\",\\") 'c,,a'","solution":"def concatenateStrings(strings, delimiter=\\"\\"): Concatenates a list of strings in reverse order with a custom delimiter. :param strings: List of strings to be concatenated. :param delimiter: Custom delimiter to be used between strings. :return: Concatenated string in reverse order. if not strings: return \\"\\" strings_reversed = strings[::-1] result = delimiter.join(strings_reversed) return result"},{"question":"from typing import List, Tuple def find_odd_product_pairs(int_list: List[int]) -> List[Tuple[int, int]]: Returns a list of tuples, each containing a pair of integers from the input list whose product is odd. Each pair (a, b) in the output list will satisfy the condition a < b to ensure uniqueness and avoid duplication. >>> find_odd_product_pairs([1, 3, 5, 2, 8, 7]) [(1, 3), (1, 5), (1, 7), (3, 5), (3, 7), (5, 7)] >>> find_odd_product_pairs([2, 4, 6, 8]) [] >>> find_odd_product_pairs([1, 3, 5, 7]) [(1, 3), (1, 5), (1, 7), (3, 5), (3, 7), (5, 7)] >>> find_odd_product_pairs([2, 4, 6, 8, 10]) [] >>> find_odd_product_pairs([1, 2, 3, 4, 5]) [(1, 3), (1, 5), (3, 5)] >>> find_odd_product_pairs([1]) [] >>> find_odd_product_pairs([]) []","solution":"def find_odd_product_pairs(int_list): Returns a list of tuples, each containing a pair of integers from the input list whose product is odd. Each pair (a, b) in the output list will satisfy the condition a < b to ensure uniqueness and avoid duplication. result = [] n = len(int_list) for i in range(n): for j in range(i + 1, n): if int_list[i] % 2 != 0 and int_list[j] % 2 != 0: result.append((int_list[i], int_list[j])) return result"},{"question":"def filter_palindromes(strings: List[str]) -> List[str]: This function takes a list of strings and returns a new list containing only those strings that are palindromes. The comparison is case-sensitive. >>> filter_palindromes([]) [] >>> filter_palindromes(['apple', 'banana', 'cherry']) [] >>> set(filter_palindromes(['madam', 'racecar', 'level'])) {'madam', 'racecar', 'level'} >>> set(filter_palindromes(['madam', 'apple', 'level', 'banana', 'racecar', 'cherry'])) {'madam', 'racecar', 'level'} >>> filter_palindromes(['Level', 'level', 'Deified', 'deified']) ['level', 'deified'] >>> set(filter_palindromes(['a', 'b', 'c', 'd'])) {'a', 'b', 'c', 'd'}","solution":"def filter_palindromes(strings): This function takes a list of strings and returns a new list containing only those strings that are palindromes. The comparison is case-sensitive. return [s for s in strings if s == s[::-1]]"},{"question":"from typing import List, Dict, Any def generate_report(students: List[Dict[str, Any]]) -> Dict[str, Any]: Given a list of student records, generate a report that includes: 1. The student with the highest total marks. 2. The student with the lowest total marks. 3. The average marks for each subject across all students. 4. The number of students between the age of 10 and 15 (inclusive). Each student record contains a dictionary with student details: {\\"name\\": \\"student_name\\", \\"age\\": age, \\"marks\\": {\\"subject1\\": marks1, \\"subject2\\": marks2, \\"subject3\\": marks3}} >>> students = [ >>> {\\"name\\": \\"Alice\\", \\"age\\": 12, \\"marks\\": {\\"math\\": 89, \\"science\\": 93, \\"english\\": 85}}, >>> {\\"name\\": \\"Bob\\", \\"age\\": 14, \\"marks\\": {\\"math\\": 75, \\"science\\": 81, \\"english\\": 79}}, >>> {\\"name\\": \\"Charlie\\", \\"age\\": 10, \\"marks\\": {\\"math\\": 95, \\"science\\": 94, \\"english\\": 92}}, >>> {\\"name\\": \\"David\\", \\"age\\": 16, \\"marks\\": {\\"math\\": 60, \\"science\\": 56, \\"english\\": 58}} >>> ] >>> generate_report(students) { \\"highest_total\\": \\"Charlie\\", \\"lowest_total\\": \\"David\\", \\"average_marks\\": {\\"math\\": 79.75, \\"science\\": 81, \\"english\\": 78.5}, \\"students_in_age_range\\": 3 } # Your code here","solution":"def generate_report(students): highest_total_student = None lowest_total_student = None highest_total_marks = -float('inf') lowest_total_marks = float('inf') total_marks = {\\"math\\": 0, \\"science\\": 0, \\"english\\": 0} age_count = 0 for student in students: total = sum(student[\\"marks\\"].values()) if total > highest_total_marks: highest_total_marks = total highest_total_student = student[\\"name\\"] if total < lowest_total_marks: lowest_total_marks = total lowest_total_student = student[\\"name\\"] for subject in student[\\"marks\\"]: total_marks[subject] += student[\\"marks\\"][subject] if 10 <= student[\\"age\\"] <= 15: age_count += 1 average_marks = {subject: total_marks[subject] / len(students) for subject in total_marks} return { \\"highest_total\\": highest_total_student, \\"lowest_total\\": lowest_total_student, \\"average_marks\\": average_marks, \\"students_in_age_range\\": age_count }"},{"question":"def add_key_with_length(dicts: list, key: str) -> list: This function takes a list of dictionaries and a key, and returns a new list of dictionaries where each dictionary has an additional key-value pair. The key is always the same for all dictionaries, and the value is the length of the dictionary before the new key is added. Parameters: dicts (list): List of dictionaries key (str): The key to add to each dictionary Returns: list: A new list of dictionaries with the additional key-value pair >>> add_key_with_length([{'a': 1, 'b': 2}, {'c': 3}, {}], 'length') [{'a': 1, 'b': 2, 'length': 2}, {'c': 3, 'length': 1}, {'length': 0}] >>> add_key_with_length([{'a': 1, 'length': 5}, {'b': 2, 'length': 10}], 'length') [{'a': 1, 'length': 2}, {'b': 2, 'length': 2}] >>> add_key_with_length([], 'length') [] >>> add_key_with_length([{}], 'length') [{'length': 0}]","solution":"def add_key_with_length(dicts, key): This function takes a list of dictionaries and a key, and returns a new list of dictionaries where each dictionary has an additional key-value pair. The key is always the same for all dictionaries, and the value is the length of the dictionary before the new key is added. Parameters: dicts (list): List of dictionaries key (str): The key to add to each dictionary Returns: list: A new list of dictionaries with the additional key-value pair result = [] for d in dicts: new_dict = d.copy() new_dict[key] = len(d) result.append(new_dict) return result"},{"question":"def filter_strings_by_length(strings: List[str]) -> List[str]: Returns a new list containing only the strings that have more than 3 characters. >>> filter_strings_by_length([\\"cat\\", \\"dog\\", \\"elephant\\", \\"rat\\"]) [\\"elephant\\"] >>> filter_strings_by_length([\\"a\\", \\"ab\\", \\"abc\\"]) [] >>> filter_strings_by_length([\\"abcd\\", \\"elephant\\", \\"giraffe\\"]) [\\"abcd\\", \\"elephant\\", \\"giraffe\\"] >>> filter_strings_by_length([]) [] >>> filter_strings_by_length([\\"apple\\", \\"bat\\", \\"chimpanzee\\", \\"dog\\"]) [\\"apple\\", \\"chimpanzee\\"]","solution":"def filter_strings_by_length(strings): Returns a new list containing only the strings that have more than 3 characters. return [s for s in strings if len(s) > 3]"},{"question":"import sys import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error def build_and_evaluate_model(csv_file_path): Build a simple linear regression model, train it, and evaluate its performance by printing the Mean Squared Error (MSE). Args: csv_file_path (str): The file path to the CSV file containing the dataset. The CSV file is expected to have two columns: one for features and one for target values. # Implementation goes here if __name__ == \\"__main__\\": # Ensure that a file path is provided as a command-line argument if len(sys.argv) != 2: print(\\"Usage: python script.py <path_to_csv_file>\\") else: csv_file_path = sys.argv[1] build_and_evaluate_model(csv_file_path)","solution":"import sys import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error def build_and_evaluate_model(csv_file_path): # Read the dataset from the provided CSV file data = pd.read_csv(csv_file_path) # Assume the CSV file has two columns: 'feature' and 'target' X = data[['feature']] # Features y = data['target'] # Target values # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Create and train the linear regression model model = LinearRegression() model.fit(X_train, y_train) # Predict on the testing set y_pred = model.predict(X_test) # Calculate and print Mean Squared Error (MSE) mse = mean_squared_error(y_test, y_pred) print(f\\"Mean Squared Error (MSE): {mse}\\") if __name__ == \\"__main__\\": # Ensure that a file path is provided as a command-line argument if len(sys.argv) != 2: print(\\"Usage: python script.py <path_to_csv_file>\\") else: csv_file_path = sys.argv[1] build_and_evaluate_model(csv_file_path)"},{"question":"def flatten_dict(d: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary. Args: d (dict): The dictionary to flatten. parent_key (str): The base key string, default is ''. sep (str): The separator between keys, default is '.'. Returns: dict: The flattened dictionary. >>> flatten_dict({'a': {'b': 1, 'c': {'d': 2, 'e': 3}}, 'f': 4}) {'a.b': 1, 'a.c.d': 2, 'a.c.e': 3, 'f': 4} >>> flatten_dict({}) {}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Args: d (dict): The dictionary to flatten. parent_key (str): The base key string. Default is ''. sep (str): The separator between keys. Default is '.'. Returns: dict: The flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def factorial(number: int, method: str) -> int: This function calculates the factorial of a given non-negative integer. It provides both iterative and recursive implementations based on the specified method. If the input number is not a non-negative integer or the method is not recognized, it should return a suitable error message. >>> factorial(5, 'iterative') 120 >>> factorial(5, 'recursive') 120 >>> factorial(-5, 'iterative') 'Error: Invalid input. Provide a non-negative integer.' >>> factorial(5, 'unknown') 'Error: Unknown method specified.' >>> factorial(10.5, 'iterative') 'Error: Invalid input. Provide a non-negative integer.'","solution":"def factorial(number: int, method: str) -> int: This function calculates the factorial of a given non-negative integer. It provides both iterative and recursive implementations based on the specified method. If the input number is not a non-negative integer or the method is not recognized, it should return a suitable error message. def iterative_fact(n: int) -> int: result = 1 for i in range(2, n + 1): result *= i return result def recursive_fact(n: int) -> int: if n == 0 or n == 1: return 1 else: return n * recursive_fact(n - 1) if not isinstance(number, int) or number < 0: return 'Error: Invalid input. Provide a non-negative integer.' if method == 'iterative': return iterative_fact(number) elif method == 'recursive': return recursive_fact(number) else: return 'Error: Unknown method specified.'"},{"question":"def process_list(numbers: List[int]) -> List[int]: Returns a new list where all even numbers are squared and odd numbers are left unchanged. >>> process_list([2, 4, 6]) [4, 16, 36] >>> process_list([1, 3, 5]) [1, 3, 5] >>> process_list([1, 2, 3, 4]) [1, 4, 3, 16] >>> process_list([0, 1, 2, 3]) [0, 1, 4, 3] >>> process_list([-1, -2, -3, -4]) [-1, 4, -3, 16] >>> process_list([]) [] >>> process_list([10]) [100] >>> process_list([7]) [7]","solution":"def process_list(numbers): Returns a new list where all even numbers are squared and odd numbers are left unchanged. :param numbers: List of integers :return: List of integers with processed numbers result = [] for num in numbers: if num % 2 == 0: result.append(num * num) else: result.append(num) return result"},{"question":"def cumulative_sum(numbers: List[int]) -> List[int]: Takes a list of non-negative integers and returns a new list where each element is the sum of itself and all previous elements in the list. If the input list is empty, the function returns an empty list. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([5]) [5] >>> cumulative_sum([0, 0, 0]) [0, 0, 0] >>> cumulative_sum([1, 0, 3, 2]) [1, 1, 4, 6] >>> cumulative_sum([]) [] pass","solution":"def cumulative_sum(numbers): Takes a list of non-negative integers and returns a new list where each element is the sum of itself and all previous elements in the list. If the input list is empty, the function returns an empty list. if not numbers: return [] cumulative_list = [] current_sum = 0 for number in numbers: current_sum += number cumulative_list.append(current_sum) return cumulative_list"},{"question":"from typing import List def find_substrings(s: str, words: List[str]) -> List[int]: Finds all starting indices in the string s where concatenation of each word in words exactly once in any order is found. Parameters: s (str): The string to search within. words (list of str): The list of words to concatenate and find within the string. Returns: list of int: Starting indices of substrings in string s. >>> find_substrings(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == [0, 9] >>> find_substrings(\\"barfoothefoobarman\\", [\\"xyz\\", \\"abc\\"]) == [] >>> find_substrings(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) == [8] >>> find_substrings(\\"lingmindraboofooowingdingbarrwingmonkeypoundcake\\", [\\"fooo\\", \\"barr\\", \\"wing\\", \\"ding\\", \\"wing\\"]) == [13] >>> find_substrings(\\"\\", [\\"foo\\", \\"bar\\"]) == [] >>> find_substrings(\\"barfoothefoobarman\\", []) == [] >>> find_substrings(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\", \\"foobar\\"]) == [] >>> find_substrings(\\"aaa\\", [\\"aa\\", \\"aa\\"]) == [] >>> find_substrings(\\"abcdabc\\", [\\"a\\", \\"b\\", \\"c\\"]) == [0, 4]","solution":"def find_substrings(s, words): Finds all starting indices in the string s where concatenation of each word in words exactly once in any order is found. Parameters: s (str): The string to search within. words (list of str): The list of words to concatenate and find within the string. Returns: list of int: Starting indices of substrings in string s. if not s or not words or not words[0]: return [] word_len = len(words[0]) words_count = len(words) substring_len = word_len * words_count words_map = {word: words.count(word) for word in words} result_indices = [] for i in range(len(s) - substring_len + 1): seen_words = {} for j in range(words_count): word_start = i + j * word_len word = s[word_start:word_start + word_len] if word in words_map: seen_words[word] = seen_words.get(word, 0) + 1 if seen_words[word] > words_map[word]: break else: break if seen_words == words_map: result_indices.append(i) return result_indices"},{"question":"def process_even_numbers(input_list: List[int]) -> List[int]: Returns a new list containing only the even numbers from the original list, each multiplied by 3. The original list remains unchanged. Parameters: input_list (list of int): The input list of integers. Returns: list of int: A new list with even numbers multiplied by 3. >>> process_even_numbers([1, 2, 3, 4, 5, 6]) [6, 12, 18] >>> process_even_numbers([2, 4, 6, 8]) [6, 12, 18, 24] >>> process_even_numbers([1, 3, 5, 7]) [] >>> process_even_numbers([]) [] >>> process_even_numbers([-2, -1, 0, 1, 2]) [-6, 0, 6]","solution":"def process_even_numbers(input_list): Returns a new list containing only the even numbers from the original list, each multiplied by 3. The original list remains unchanged. Parameters: input_list (list of int): The input list of integers. Returns: list of int: A new list with even numbers multiplied by 3. return [x * 3 for x in input_list if x % 2 == 0]"},{"question":"def second_smallest_unique(numbers: List[int]) -> Optional[int]: Takes a list of integers as input and returns the second smallest unique number in the list. If there are fewer than two unique numbers, returns None. >>> second_smallest_unique([4, 1, 2, 2, 3, 4, 1, 5]) 2 >>> second_smallest_unique([7, 7, 7]) None >>> second_smallest_unique([]) None >>> second_smallest_unique([1, 1, 1, 2, 2, 2, 3, 3, 3]) 2 from solution import second_smallest_unique def test_with_multiple_unique_numbers(): assert second_smallest_unique([4, 1, 2, 2, 3, 4, 1, 5]) == 2 def test_with_all_same_numbers(): assert second_smallest_unique([7, 7, 7]) == None def test_with_empty_list(): assert second_smallest_unique([]) == None def test_with_repeated_unique_numbers(): assert second_smallest_unique([1, 1, 1, 2, 2, 2, 3, 3, 3]) == 2 def test_with_duplicates_and_non_duplicates(): assert second_smallest_unique([1, 1, 2, 3, 4, 5]) == 2 def test_with_minimum_unique_numbers(): assert second_smallest_unique([1, 2]) == 2 def test_with_only_one_number(): assert second_smallest_unique([1]) == None","solution":"def second_smallest_unique(numbers): Returns the second smallest unique number in the list. If there are fewer than two unique numbers, returns None. # Create a set to get unique numbers unique_numbers = set(numbers) # Convert the set back to a sorted list sorted_unique_numbers = sorted(unique_numbers) # Check if there are at least two unique numbers if len(sorted_unique_numbers) < 2: return None # Return the second smallest unique number return sorted_unique_numbers[1]"},{"question":"def generate_sales_report(sales_data): Returns a dictionary with the total sales for each product. Args: sales_data (list): A list of dictionaries where each dictionary contains 'product' and 'amount' keys. Returns: dict: A dictionary where keys are unique products and values are total sales for each product. >>> generate_sales_report([ ... {'product': 'apple', 'amount': 10}, ... {'product': 'banana', 'amount': 15}, ... {'product': 'apple', 'amount': 25} ... ]) == {'apple': 35, 'banana': 15} >>> generate_sales_report([ ... {'product': 'orange', 'amount': 50} ... ]) == {'orange': 50} >>> generate_sales_report([]) == {} >>> generate_sales_report([ ... {'product': 'apple', 'amount': 5}, ... {'product': 'apple', 'amount': 15}, ... {'product': 'apple', 'amount': 20} ... ]) == {'apple': 40} >>> generate_sales_report([ ... {'product': 'apple', 'amount': 5}, ... {'product': 'banana', 'amount': 5}, ... {'product': 'cherry', 'amount': 5} ... ]) == {'apple': 5, 'banana': 5, 'cherry': 5}","solution":"def generate_sales_report(sales_data): Returns a dictionary with the total sales for each product. Args: sales_data (list): A list of dictionaries where each dictionary contains 'product' and 'amount' keys. Returns: dict: A dictionary where keys are unique products and values are total sales for each product. sales_report = {} for record in sales_data: product = record['product'] amount = record['amount'] if product in sales_report: sales_report[product] += amount else: sales_report[product] = amount return sales_report"},{"question":"import numpy as np import pandas as pd from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.metrics import silhouette_score import matplotlib.pyplot as plt def kmeans_clustering(data, max_clusters=10): Perform K-means clustering to segment customers into distinct groups based on their purchase history. Parameters: data (pd.DataFrame): customer purchase history data. max_clusters (int): maximum number of clusters to try for the Elbow method. Returns: tuple: fitted kmeans model, scaling object and the optimal number of clusters. # Implement the k-means clustering algorithm pass def plot_clusters(data, kmeans, scaler): Plot the clusters from the K-means algorithm. Parameters: data (pd.DataFrame): customer purchase history data. kmeans (KMeans): fitted K-means model. scaler (StandardScaler): scaling object that was fit to the data. # Implement the plot_clusters function to visualize K-means clustering results pass Example test cases import pandas as pd import numpy as np from sklearn.datasets import make_blobs def create_test_data(): data, _ = make_blobs(n_samples=300, centers=4, cluster_std=0.60, random_state=0) return pd.DataFrame(data, columns=[\\"Feature 1\\", \\"Feature 2\\"]) def test_kmeans_clustering(): data = create_test_data() kmeans, scaler, optimal_clusters = kmeans_clustering(data) assert isinstance(kmeans, KMeans) assert isinstance(scaler, StandardScaler) assert optimal_clusters > 0 def test_optimal_clusters_range(): data = create_test_data() _, _, optimal_clusters = kmeans_clustering(data, max_clusters=10) # Check that the optimal number of clusters is within the expected range assert 2 <= optimal_clusters <= 10 def test_plot_clusters(): data = create_test_data() kmeans, scaler, _ = kmeans_clustering(data) # The function relies on a visual output thus can be tested with exception handling try: plot_clusters(data, kmeans, scaler) assert True # If no exception, pass the test except: assert False","solution":"import numpy as np import pandas as pd from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.metrics import silhouette_score import matplotlib.pyplot as plt def kmeans_clustering(data, max_clusters=10): Perform K-means clustering on the provided dataset. Parameters: data (pd.DataFrame): customer purchase history data. max_clusters (int): maximum number of clusters to try for the Elbow method. Returns: tuple: fitted kmeans model, scaling object and the optimal number of clusters. # Normalize the data scaler = StandardScaler() normalized_data = scaler.fit_transform(data) # Determine the optimal number of clusters using the Elbow Method wcss = [] # within-cluster sum of squares silhouette_scores = [] for i in range(2, max_clusters + 1): kmeans = KMeans(n_clusters=i, random_state=42) kmeans.fit(normalized_data) wcss.append(kmeans.inertia_) silhouette_scores.append(silhouette_score(normalized_data, kmeans.labels_)) # Find the elbow point (optional: using Silhouette score to double check) optimal_clusters = np.argmax(silhouette_scores) + 2 # Plot the Elbow Method graph plt.figure(figsize=(12, 6)) plt.plot(range(2, max_clusters + 1), wcss, marker='o') plt.title('Elbow Method') plt.xlabel('Number of Clusters') plt.ylabel('WCSS') plt.show() # Silhouette Scores Plot plt.figure(figsize=(12, 6)) plt.plot(range(2, max_clusters + 1), silhouette_scores, marker='o') plt.title('Silhouette Scores') plt.xlabel('Number of Clusters') plt.ylabel('Silhouette Score') plt.show() # Perform final KMeans clustering with optimal clusters kmeans = KMeans(n_clusters=optimal_clusters, random_state=42) kmeans.fit(normalized_data) return kmeans, scaler, optimal_clusters def plot_clusters(data, kmeans, scaler): Plot the clusters from the K-means algorithm. Parameters: data (pd.DataFrame): customer purchase history data. kmeans (KMeans): fitted K-means model. scaler (StandardScaler): scaling object that was fit to the data. normalized_data = scaler.transform(data) labels = kmeans.labels_ plt.figure(figsize=(12, 6)) for i in range(kmeans.n_clusters): plt.scatter(data[labels == i].iloc[:, 0], data[labels == i].iloc[:, 1], label=f'Cluster {i+1}') plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s=300, c='red', label='Centroids') plt.title('Customer Segments') plt.xlabel('Feature 1') plt.ylabel('Feature 2') plt.legend() plt.show() # Example usage: # data = pd.read_csv('purchase_history.csv') # kmeans, scaler, optimal_clusters = kmeans_clustering(data) # plot_clusters(data, kmeans, scaler) # Practical implications: # Retail businesses can use these segments to tailor marketing strategies, design personalized offers, manage inventory better, and improve customer retention."},{"question":"def preprocess_string(s: str) -> str: Converts the string to lower case and removes all non-alphanumeric characters. >>> preprocess_string(\\"A man, a plan, a canal: Panama\\") 'amanaplanacanalpanama' >>> preprocess_string(\\"No 'x' in Nixon\\") 'noxinnixon' >>> preprocess_string(\\"\\") '' >>> preprocess_string(\\"123 456! 789\\") '123456789' def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given document. Ignoring spaces, punctuation, and case variations. >>> longest_palindromic_substring(\\"A man, a plan, a canal: Panama\\") 'amanaplanacanalpanama' >>> longest_palindromic_substring(\\"No 'x' in Nixon\\") 'noxinnixon' >>> longest_palindromic_substring(\\"abc\\") 'a' # Any single char is the longest palindrome. >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"abacdgfdcaba\\") 'aba' def test_preprocess_string(): assert preprocess_string(\\"A man, a plan, a canal: Panama\\") == \\"amanaplanacanalpanama\\" assert preprocess_string(\\"No 'x' in Nixon\\") == \\"noxinnixon\\" assert preprocess_string(\\"\\") == \\"\\" assert preprocess_string(\\"123 456! 789\\") == \\"123456789\\" def test_longest_palindromic_substring(): assert longest_palindromic_substring(\\"A man, a plan, a canal: Panama\\") == \\"amanaplanacanalpanama\\" assert longest_palindromic_substring(\\"No 'x' in Nixon\\") == \\"noxinnixon\\" assert longest_palindromic_substring(\\"abc\\") == \\"a\\" # Any single char is the longest palindrome. assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" assert longest_palindromic_substring(\\"abacdgfdcaba\\") == \\"aba\\" def test_edge_cases(): assert longest_palindromic_substring(\\"\\") == \\"\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" assert longest_palindromic_substring(\\"aa\\") == \\"aa\\" assert longest_palindromic_substring(\\"ab\\") == \\"a\\" # Any single char is a palindrome.","solution":"def preprocess_string(s): Converts the string to lower case and removes all non-alphanumeric characters. return ''.join(c.lower() for c in s if c.isalnum()) def longest_palindromic_substring(s): Returns the longest palindromic substring in the given document. Ignoring spaces, punctuation, and case variations. s = preprocess_string(s) n = len(s) if n == 0: return \\"\\" # Initialize a list to store the details of the longest palindrome found. start = 0 max_length = 1 # Create a table to store results of sub-problems table = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): table[i][i] = True # Check for sub-string of length 2 for i in range(n - 1): if s[i] == s[i + 1]: table[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2. k is length of substring for k in range(3, n + 1): for i in range(n - k + 1): j = i + k - 1 # Ending index of substring from starting index i and length k # Checking for sub-string from ith index to jth index # iff s[i+1] to s[j-1] is a palindrome if table[i + 1][j - 1] and s[i] == s[j]: table[i][j] = True if k > max_length: start = i max_length = k longest_palindrome = s[start:start + max_length] return longest_palindrome"},{"question":"def is_perfect_square(n: int) -> bool: Checks if a given positive integer is a perfect square. Returns True if n is a perfect square, False otherwise. >>> is_perfect_square(16) == True >>> is_perfect_square(14) == False >>> is_perfect_square(25) == True >>> is_perfect_square(30) == False from solution import is_perfect_square def test_is_perfect_square(): # Test positive perfect squares assert is_perfect_square(1) == True assert is_perfect_square(4) == True assert is_perfect_square(9) == True assert is_perfect_square(16) == True assert is_perfect_square(25) == True assert is_perfect_square(36) == True assert is_perfect_square(49) == True assert is_perfect_square(64) == True # Test non-perfect squares assert is_perfect_square(2) == False assert is_perfect_square(3) == False assert is_perfect_square(5) == False assert is_perfect_square(10) == False assert is_perfect_square(15) == False assert is_perfect_square(20) == False assert is_perfect_square(30) == False assert is_perfect_square(50) == False # Test negative numbers, zero and numbers less than 1 assert is_perfect_square(-1) == False assert is_perfect_square(0) == False","solution":"def is_perfect_square(n): Returns True if n is a perfect square, otherwise returns False. if n < 1: return False left, right = 1, n while left <= right: mid = (left + right) // 2 mid_squared = mid * mid if mid_squared == n: return True elif mid_squared < n: left = mid + 1 else: right = mid - 1 return False"},{"question":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B and returns the result matrix. Args: A (List[List[int]]): First matrix. B (List[List[int]]): Second matrix. Returns: List[List[int]]: The resulting matrix after multiplication. Raises: ValueError: If the number of columns in A is not equal to the number of rows in B. pass # Unit Tests def test_matrix_multiplication_correct_result(): A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] expected = [ [58, 64], [139, 154] ] assert matrix_multiplication(A, B) == expected def test_matrix_multiplication_incompatible_dimensions(): A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8], [9, 10] ] try: matrix_multiplication(A, B) except ValueError as e: assert str(e) == \\"The number of columns in the first matrix must be equal to the number of rows in the second matrix.\\" def test_matrix_multiplication_single_element(): A = [ [3] ] B = [ [4] ] expected = [ [12] ] assert matrix_multiplication(A, B) == expected def test_matrix_multiplication_identity_matrix(): A = [ [1, 2], [3, 4] ] B = [ [1, 0], [0, 1] ] expected = [ [1, 2], [3, 4] ] assert matrix_multiplication(A, B) == expected def test_matrix_multiplication_zero_matrix(): A = [ [1, 2], [3, 4] ] B = [ [0, 0], [0, 0] ] expected = [ [0, 0], [0, 0] ] assert matrix_multiplication(A, B) == expected","solution":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B and returns the result matrix. Args: A (List[List[int]]): First matrix. B (List[List[int]]): Second matrix. Returns: List[List[int]]: The resulting matrix after multiplication. Raises: ValueError: If the number of columns in A is not equal to the number of rows in B. # Number of rows in A rows_A = len(A) # Number of columns in A cols_A = len(A[0]) # Number of rows in B rows_B = len(B) # Number of columns in B cols_B = len(B[0]) # Ensure the matrices can be multiplied if cols_A != rows_B: raise ValueError(\\"The number of columns in the first matrix must be equal to the number of rows in the second matrix.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform the matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): # or equivalently range(rows_B) result[i][j] += A[i][k] * B[k][j] return result"},{"question":"from typing import List def max_pairs(dominoes: List[List[int]]) -> int: Returns the maximum number of pairs of dominoes that are identical. A pair of dominoes (a, b) and (c, d) are identical if: 1. a == c and b == d 2. a == d and b == c Parameters: dominoes (List[List[int]]): A list of pairs of integers representing domino halves. Returns: int: The maximum number of identical domino pairs. Examples: >>> max_pairs([[1,2],[2,1],[3,4],[5,6]]) 1 >>> max_pairs([[1,2],[1,2],[1,1],[1,2],[2,2]]) 3 >>> max_pairs([[1,1],[2,2],[1,1],[3,3],[1,1],[2,2]]) 4 from solution import max_pairs def test_max_pairs_example1(): assert max_pairs([[1,2],[2,1],[3,4],[5,6]]) == 1 def test_max_pairs_example2(): assert max_pairs([[1,2],[1,2],[1,1],[1,2],[2,2]]) == 3 def test_max_pairs_example3(): assert max_pairs([[1,1],[2,2],[1,1],[3,3],[1,1],[2,2]]) == 4 def test_max_pairs_no_identical_pairs(): assert max_pairs([[1,2],[3,4],[5,6],[7,8]]) == 0 def test_max_pairs_all_identical_pairs(): assert max_pairs([[1,1],[1,1],[1,1],[1,1]]) == 6 def test_max_pairs_single_domino(): assert max_pairs([[1,1]]) == 0 def test_max_pairs_large_input(): dominoes = [[1,1]] * 40000 expected = 40000 * 39999 // 2 assert max_pairs(dominoes) == expected","solution":"from collections import defaultdict def max_pairs(dominoes): Returns the maximum number of domino pairs that are identical. count = defaultdict(int) for a, b in dominoes: if a > b: a, b = b, a count[(a, b)] += 1 pairs = 0 for val in count.values(): pairs += val * (val - 1) // 2 return pairs"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels in the given string. Vowels considered are: 'a', 'e', 'i', 'o', 'u' in both upper and lower cases. >>> count_vowels('Coding Is Fun') == 4 >>> count_vowels('aeiouAEIOU') == 10 >>> count_vowels('') == 0 >>> count_vowels('12345aei345') == 3 >>> count_vowels('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ') == 0 >>> count_vowels('AaEeIiOoUu') == 10","solution":"def count_vowels(s): Returns the number of vowels in the given string. Vowels considered are: 'a', 'e', 'i', 'o', 'u' in both upper and lower cases. vowels = set('aeiouAEIOU') return sum(1 for char in s if char in vowels)"},{"question":"def process_transactions(initial_balances, transactions): Processes a list of transactions and applies them to the initial balances of accounts. :param initial_balances: Dictionary with account IDs as keys and initial balances as values. :param transactions: List of transaction dictionaries. Each dictionary has a 'type' (string, \\"deposit\\", \\"withdrawal\\", or \\"transfer\\"), 'account_id' (string), 'amount' (float), and 'target_id' (string, optional for 'transfer'). :return: Dictionary with account IDs as keys and final balances as values. >>> process_transactions({\\"acc_1\\": 500.0, \\"acc_2\\": 300.0, \\"acc_3\\": 1000.0}, ... [{\\"type\\": \\"deposit\\", \\"account_id\\": \\"acc_1\\", \\"amount\\": 200.0}, ... {\\"type\\": \\"withdrawal\\", \\"account_id\\": \\"acc_2\\", \\"amount\\": 100.0}, ... {\\"type\\": \\"transfer\\", \\"account_id\\": \\"acc_1\\", \\"target_id\\": \\"acc_3\\", \\"amount\\": 150.0}, ... {\\"type\\": \\"withdrawal\\", \\"account_id\\": \\"acc_3\\", \\"amount\\": 2000.0}]) {'acc_1': 550.0, 'acc_2': 200.0, 'acc_3': 1150.0} final_balances = initial_balances.copy() for transaction in transactions: t_type = transaction[\\"type\\"] account_id = transaction[\\"account_id\\"] amount = transaction[\\"amount\\"] if t_type == \\"deposit\\": if account_id in final_balances: final_balances[account_id] += amount elif t_type == \\"withdrawal\\": if account_id in final_balances and final_balances[account_id] >= amount: final_balances[account_id] -= amount elif t_type == \\"transfer\\": target_id = transaction.get(\\"target_id\\") if account_id in final_balances and target_id in final_balances and final_balances[account_id] >= amount: final_balances[account_id] -= amount final_balances[target_id] += amount return final_balances # Unit tests def test_deposit(): initial_balances = {\\"acc_1\\": 100.0} transactions = [{\\"type\\": \\"deposit\\", \\"account_id\\": \\"acc_1\\", \\"amount\\": 50.0}] expected = {\\"acc_1\\": 150.0} assert process_transactions(initial_balances, transactions) == expected def test_withdrawal(): initial_balances = {\\"acc_1\\": 100.0} transactions = [{\\"type\\": \\"withdrawal\\", \\"account_id\\": \\"acc_1\\", \\"amount\\": 50.0}] expected = {\\"acc_1\\": 50.0} assert process_transactions(initial_balances, transactions) == expected def test_transfer(): initial_balances = {\\"acc_1\\": 100.0, \\"acc_2\\": 50.0} transactions = [{\\"type\\": \\"transfer\\", \\"account_id\\": \\"acc_1\\", \\"target_id\\": \\"acc_2\\", \\"amount\\": 25.0}] expected = {\\"acc_1\\": 75.0, \\"acc_2\\": 75.0} assert process_transactions(initial_balances, transactions) == expected def test_withdrawal_insufficient_funds(): initial_balances = {\\"acc_1\\": 100.0} transactions = [{\\"type\\": \\"withdrawal\\", \\"account_id\\": \\"acc_1\\", \\"amount\\": 150.0}] expected = {\\"acc_1\\": 100.0} assert process_transactions(initial_balances, transactions) == expected def test_transfer_insufficient_funds(): initial_balances = {\\"acc_1\\": 100.0, \\"acc_2\\": 50.0} transactions = [{\\"type\\": \\"transfer\\", \\"account_id\\": \\"acc_1\\", \\"target_id\\": \\"acc_2\\", \\"amount\\": 150.0}] expected = {\\"acc_1\\": 100.0, \\"acc_2\\": 50.0} assert process_transactions(initial_balances, transactions) == expected def test_non_existent_account(): initial_balances = {\\"acc_1\\": 100.0} transactions = [{\\"type\\": \\"deposit\\", \\"account_id\\": \\"acc_2\\", \\"amount\\": 50.0}] expected = {\\"acc_1\\": 100.0} assert process_transactions(initial_balances, transactions) == expected def test_combined_transactions(): initial_balances = { \\"acc_1\\": 500.0, \\"acc_2\\": 300.0, \\"acc_3\\": 1000.0 } transactions = [ {\\"type\\": \\"deposit\\", \\"account_id\\": \\"acc_1\\", \\"amount\\": 200.0}, {\\"type\\": \\"withdrawal\\", \\"account_id\\": \\"acc_2\\", \\"amount\\": 100.0}, {\\"type\\": \\"transfer\\", \\"account_id\\": \\"acc_1\\", \\"target_id\\": \\"acc_3\\", \\"amount\\": 150.0}, {\\"type\\": \\"withdrawal\\", \\"account_id\\": \\"acc_3\\", \\"amount\\": 2000.0} ] expected = { \\"acc_1\\": 550.0, \\"acc_2\\": 200.0, \\"acc_3\\": 1150.0 } assert process_transactions(initial_balances, transactions) == expected","solution":"def process_transactions(initial_balances, transactions): Processes a list of transactions and applies them to the initial balances of accounts. :param initial_balances: Dictionary with account IDs as keys and initial balances as values. :param transactions: List of transaction dictionaries. Each dictionary has a 'type' (string, \\"deposit\\", \\"withdrawal\\", or \\"transfer\\"), 'account_id' (string), 'amount' (float), and 'target_id' (string, optional for 'transfer'). :return: Dictionary with account IDs as keys and final balances as values. for transaction in transactions: t_type = transaction[\\"type\\"] account_id = transaction[\\"account_id\\"] amount = transaction[\\"amount\\"] if t_type == \\"deposit\\": if account_id in initial_balances: initial_balances[account_id] += amount elif t_type == \\"withdrawal\\": if account_id in initial_balances and initial_balances[account_id] >= amount: initial_balances[account_id] -= amount elif t_type == \\"transfer\\": target_id = transaction[\\"target_id\\"] if (account_id in initial_balances and target_id in initial_balances and initial_balances[account_id] >= amount): initial_balances[account_id] -= amount initial_balances[target_id] += amount return initial_balances"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Finds all unique quadruplets in the array which gives the sum of the target. Args: nums : List[int] -- list of integers target : int -- target integer Returns: List[List[int]] -- list of quadruplets >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 100) [] >>> four_sum([1], 1) [] >>> four_sum([0, 0, 0, 0, 0], 0) [[0, 0, 0, 0]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] >>> four_sum([-3,-2,-1,0,0,1,2,3], 0) [[-3, -2, 2, 3], [-3, -1, 1, 3], [-3, 0, 0, 3], [-3, 0, 1, 2], [-2, -1, 0, 3], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([-5, 5, 4, -3, 0, 0, 4, -2], 4) [[-5, 0, 4, 5], [-3, -2, 4, 5]]","solution":"def four_sum(nums, target): Finds all unique quadruplets in the array which gives the sum of target. Args: nums : List[int] -- list of integers target : int -- target integer Returns: List[List[int]] -- list of quadruplets nums.sort() n = len(nums) quadruplets = [] for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue for j in range(i+1, n): if j > i + 1 and nums[j] == nums[j-1]: continue left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"class FoodDeliverySystem: Simulate a basic online food delivery system. The system should have three main components: customer orders, restaurant menu, and order processing. The menu should list at least five different items with their prices. Your script should allow a customer to place an order for one or more items, calculate the total cost, and provide a receipt. Ensure that the system can handle invalid input gracefully, such as ordering an item that doesn't exist or entering a negative quantity. Use appropriate data structures and functions to modularize your code. >>> fds = FoodDeliverySystem() >>> fds.place_order(\\"Pizza\\", 2) 'Added 2 x Pizza to your order.' >>> fds.place_order(\\"Burger\\", 1) 'Added 1 x Burger to your order.' >>> fds.get_receipt() 'Receipt:n2 x Pizza = 20.00n1 x Burger = 6.50nTotal: 26.50' >>> fds.calculate_total() 26.50 def __init__(self): pass def place_order(self, item, quantity): pass def calculate_total(self): pass def get_receipt(self): pass","solution":"class FoodDeliverySystem: def __init__(self): self.menu = { \\"Pizza\\": 10.00, \\"Burger\\": 6.50, \\"Pasta\\": 8.00, \\"Salad\\": 5.00, \\"Soup\\": 4.50 } self.orders = [] def place_order(self, item, quantity): if item not in self.menu: return f\\"Error: {item} is not available in the menu.\\" if quantity <= 0: return \\"Error: Quantity must be greater than 0.\\" self.orders.append((item, quantity)) return f\\"Added {quantity} x {item} to your order.\\" def calculate_total(self): return sum(quantity * self.menu[item] for item, quantity in self.orders) def get_receipt(self): if not self.orders: return \\"No items ordered.\\" receipt = \\"Receipt:n\\" for item, quantity in self.orders: receipt += f\\"{quantity} x {item} = {quantity * self.menu[item]:.2f}n\\" receipt += f\\"Total: {self.calculate_total():.2f}\\" return receipt"},{"question":"def largest_product_of_three(nums: List[int]) -> int: Returns the largest product obtainable from any three numbers in the list. If the list has fewer than three numbers, returns None. >>> largest_product_of_three([1, 2, 3]) 6 >>> largest_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> largest_product_of_three([-10, -10, 5, 2]) 500 >>> largest_product_of_three([-1, -2, -3, -4]) -6 >>> largest_product_of_three([-1, -2, 0, 3, 4]) 8 >>> largest_product_of_three([1]) None >>> largest_product_of_three([1, 2]) None >>> largest_product_of_three([-1, 2, 1]) -2 >>> largest_product_of_three([-1, -2, -3]) -6","solution":"def largest_product_of_three(nums): Returns the largest product obtainable from any three numbers in the list. If the list has fewer than three numbers, returns None. if len(nums) < 3: return None nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def longest_sequence_above_threshold(temperatures: List[int], threshold: int) -> Tuple[int, int]: Analyzes a dataset of temperatures and determines the longest sequence of consecutive days where the temperature was above the specified threshold. Args: temperatures: List of daily temperatures. threshold: The temperature threshold. Returns: A tuple with the starting day index (0-based) and the length of the longest sequence of consecutive days above the threshold. >>> longest_sequence_above_threshold([72, 75, 79, 79, 81, 82, 85, 86, 87, 85, 84, 83, 82, 79, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62], 80) (4, 9) >>> longest_sequence_above_threshold([70, 75, 79, 79, 78, 77, 75, 76, 74, 73], 80) (-1, 0) >>> longest_sequence_above_threshold([82, 85, 86, 87, 85, 84, 83, 82, 79, 77], 80) (0, 8) >>> longest_sequence_above_threshold([72, 75, 79, 81, 82, 75, 85, 86, 70, 85, 84, 83, 60, 79], 80) (9, 3) >>> longest_sequence_above_threshold([79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 81, 81], 80) (10, 2) >>> longest_sequence_above_threshold([85, 86, 87, 72, 75, 79, 81, 82, 85, 86, 87, 85], 80) (6, 6)","solution":"def longest_sequence_above_threshold(temperatures, threshold): Analyzes the dataset of temperatures and determines the longest sequence of consecutive days where the temperature was above the specified threshold. Args: temperatures: List of daily temperatures. threshold: The temperature threshold. Returns: A tuple with the starting day index (0-based) and the length of the longest sequence of consecutive days above the threshold. max_len = 0 current_len = 0 start_index = -1 for i, temp in enumerate(temperatures): if temp > threshold: if current_len == 0: # start of a new sequence start_temp_index = i current_len += 1 else: if current_len > max_len: max_len = current_len start_index = start_temp_index current_len = 0 # Final check in case the longest sequence ends at the last element of the array if current_len > max_len: max_len = current_len start_index = start_temp_index return start_index, max_len # Example usage temperatures = [72, 75, 79, 79, 81, 82, 85, 86, 87, 85, 84, 83, 82, 79, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62] threshold = 80 print(longest_sequence_above_threshold(temperatures, threshold)) # (4, 9)"},{"question":"from collections import defaultdict from itertools import groupby def group_words_by_length(words: List[str]) -> Dict[int, List[str]]: Groups words by their length using a functional programming approach. Parameters: words (list): A list of words. Returns: dict: A dictionary where the keys are word lengths and the values are lists of words of that length. >>> group_words_by_length([\\"apple\\", \\"banana\\", \\"cat\\", \\"dog\\", \\"elephant\\", \\"fish\\", \\"goat\\", \\"hat\\", \\"igloo\\", \\"jog\\", \\"kite\\"]) {3: [\\"cat\\", \\"dog\\", \\"hat\\", \\"jog\\"], 4: [\\"fish\\", \\"goat\\", \\"kite\\"], 5: [\\"apple\\", \\"igloo\\"], 6: [\\"banana\\"], 8: [\\"elephant\\"]} >>> group_words_by_length([]) {} >>> group_words_by_length([\\"a\\", \\"b\\", \\"c\\"]) {1: [\\"a\\", \\"b\\", \\"c\\"]} >>> group_words_by_length([\\"apple\\", \\"a\\", \\"banana\\", \\"cat\\", \\"dog\\"]) {1: [\\"a\\"], 3: [\\"cat\\", \\"dog\\"], 5: [\\"apple\\"], 6: [\\"banana\\"]} >>> group_words_by_length([\\"cat\\", \\"dog\\", \\"bat\\"]) {3: [\\"cat\\", \\"dog\\", \\"bat\\"]}","solution":"from collections import defaultdict from itertools import groupby def group_words_by_length(words): Groups words by their length. Parameters: words (list): A list of words. Returns: dict: A dictionary where the keys are word lengths and the values are lists of words of that length. sorted_words = sorted(words, key=len) grouped = groupby(sorted_words, key=len) return {key: list(group) for key, group in grouped}"},{"question":"def rearrange_multiples(input_list: List[int], n: int) -> List[int]: Rearranges the list so that all multiples of n appear at the beginning, followed by all other elements. The relative order of the elements is preserved. Parameters: input_list (List[int]): A list of integers. n (int): An integer to find multiples of. Returns: List[int]: A reordered list with multiples of n at the beginning. >>> rearrange_multiples([1, 3, 4, 6, 7, 9, 12], 3) [3, 6, 9, 12, 1, 4, 7] >>> rearrange_multiples([1, 2, 4, 5, 7, 8], 3) [1, 2, 4, 5, 7, 8] >>> rearrange_multiples([], 3) [] >>> rearrange_multiples([3], 3) [3] >>> rearrange_multiples([2], 3) [2] >>> rearrange_multiples([-3, -6, -9, 2, 4], -3) [-3, -6, -9, 2, 4] >>> rearrange_multiples([0, 1, 2, 3, 4, 5], 2) [0, 2, 4, 1, 3, 5] pass","solution":"def rearrange_multiples(input_list, n): Rearranges the list so that all multiples of n appear at the beginning, followed by all other elements. The relative order of the elements is preserved. Parameters: input_list (List[int]): A list of integers. n (int): An integer to find multiples of. Returns: List[int]: A reordered list with multiples of n at the beginning. if not isinstance(input_list, list) or not all(isinstance(i, int) for i in input_list) or not isinstance(n, int): raise ValueError(\\"Invalid input. Please provide a list of integers and an integer as inputs.\\") multiples_of_n = [x for x in input_list if x % n == 0] non_multiples_of_n = [x for x in input_list if x % n != 0] return multiples_of_n + non_multiples_of_n"},{"question":"def combination_sum(S: int) -> List[List[int]]: Create a program that takes in a target sum 'S' and finds all unique combinations of positive integers that add up to the target sum, 'S'. Each combination is sorted in ascending order and unique. >>> combination_sum(4) [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4]] >>> combination_sum(3) [[1, 1, 1], [1, 2], [3]] >>> combination_sum(2) [[1, 1], [2]] >>> combination_sum(1) [[1]] >>> combination_sum(5) [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 4], [2, 3], [5]]","solution":"def combination_sum(S): Returns all unique combinations of positive integers that sum up to S. Each combination is sorted in ascending order. Parameters: S (int): The target sum. Returns: List[List[int]]: A list of unique combinations. def backtrack(target, start, path, res): if target == 0: res.append(list(path)) return for i in range(start, target + 1): path.append(i) backtrack(target - i, i, path, res) path.pop() result = [] backtrack(S, 1, [], result) return result"},{"question":"from typing import List, Tuple def find_optimal_books(genre1: List[int], genre2: List[int], ratio: Tuple[int, int] = (3, 2), max_weight: int = 5000) -> Tuple[List[int], List[int]]: Determines the optimal subset of books from two genres that maximizes the weight without exceeding a given weight limit, while respecting a given weight distribution ratio. Parameters: genre1 (List[int]): List of integer weights of books in genre 1. genre2 (List[int]): List of integer weights of books in genre 2. ratio (Tuple[int, int]): The allowed weight distribution ratio between genre1 and genre2. max_weight (int): The maximum allowed weight of the new shelf. Returns: Tuple[List[int], List[int]]: A tuple of two lists containing the weights of the selected books from genre1 and genre2 respectively. pass # Your implementation here def test_find_optimal_books(): genre1 = [1000, 2000, 1500, 1300, 1200] genre2 = [1500, 1500, 1800, 1600] result = find_optimal_books(genre1, genre2) assert sum(result[0]) + sum(result[1]) <= 5000 assert sum(result[0]) <= 3000 assert sum(result[1]) <= 2000 genre1 = [1000, 1000, 1000] genre2 = [3000] result = find_optimal_books(genre1, genre2) assert result == ([], []) genre1 = [1000, 1000, 1000] genre2 = [1000, 1000] result = find_optimal_books(genre1, genre2) assert sum(result[0]) + sum(result[1]) <= 5000 assert sum(result[0]) <= 3000 assert sum(result[1]) <= 2000 genre1 = [] genre2 = [] result = find_optimal_books(genre1, genre2) assert result == ([], []) genre1 = [3000] genre2 = [2000] result = find_optimal_books(genre1, genre2) assert result == ([3000], [2000]) genre1 = [1000, 2500, 1000, 1000, 100] genre2 = [2000, 300, 1000, 1000] result = find_optimal_books(genre1, genre2) assert sum(result[0]) + sum(result[1]) <= 5000 assert sum(result[0]) <= 3000 assert sum(result[1]) <= 2000","solution":"from itertools import combinations def find_optimal_books(genre1, genre2, ratio=(3, 2), max_weight=5000): Determines the optimal subset of books from two genres that maximizes the weight without exceeding a given weight limit, while respecting a given weight distribution ratio. Parameters: genre1 (list): List of integer weights of books in genre 1. genre2 (list): List of integer weights of books in genre 2. ratio (tuple): The allowed weight distribution ratio between genre1 and genre2. max_weight (int): The maximum allowed weight of the new shelf. Returns: tuple: A tuple of two lists containing the weights of the selected books from genre1 and genre2 respectively. def calculate_ratio_subset(genre, ratio_num, subset): return [combo for r in range(len(genre) + 1) for combo in combinations(genre, r) if sum(combo) == subset] target_ratio = max_weight * ratio[0] / sum(ratio) genre1_combos = calculate_ratio_subset(genre1, ratio[0], target_ratio) genre2_combos = calculate_ratio_subset(genre2, ratio[1], max_weight - target_ratio) best_books = ([], []) best_weight = 0 for combo1 in genre1_combos: for combo2 in genre2_combos: current_weight = sum(combo1) + sum(combo2) if current_weight <= max_weight and current_weight > best_weight: best_weight = current_weight best_books = (list(combo1), list(combo2)) return best_books"},{"question":"from typing import List, Dict, Any def sort_employees_by_key(employees: List[Dict[str, Any]], key: str, reverse: bool = False) -> List[Dict[str, Any]]: Sorts a list of dictionaries by a specified key. Parameters: - employees: List[Dict[str, Any]], a list of dictionaries representing employees - key: str, the key to sort by - reverse: bool, whether to sort in ascending (False) or descending (True) order Returns: - List[Dict[str, Any]], the sorted list of dictionaries >>> employees = [ ... {'name': 'John', 'age': 45, 'salary': 100000}, ... {'name': 'Jane', 'age': 35, 'salary': 120000}, ... {'name': 'Dave', 'age': 25, 'salary': 90000}, ... {'name': 'Paula', 'age': 29, 'salary': 95000} ... ] >>> sort_employees_by_key(employees, 'age') [{'name': 'Dave', 'age': 25, 'salary': 90000}, {'name': 'Paula', 'age': 29, 'salary': 95000}, {'name': 'Jane', 'age': 35, 'salary': 120000}, {'name': 'John', 'age': 45, 'salary': 100000}] >>> sort_employees_by_key(employees, 'salary', reverse=True) [{'name': 'Jane', 'age': 35, 'salary': 120000}, {'name': 'John', 'age': 45, 'salary': 100000}, {'name': 'Paula', 'age': 29, 'salary': 95000}, {'name': 'Dave', 'age': 25, 'salary': 90000}]","solution":"def sort_employees_by_key(employees, key, reverse=False): Sorts a list of dictionaries by a specified key. Parameters: - employees: List[Dict[str, Any]], a list of dictionaries representing employees - key: str, the key to sort by - reverse: bool, whether to sort in ascending (False) or descending (True) order Returns: - List[Dict[str, Any]], the sorted list of dictionaries return sorted(employees, key=lambda x: x[key], reverse=reverse) # Example usage employees = [ {'name': 'John', 'age': 45, 'salary': 100000}, {'name': 'Jane', 'age': 35, 'salary': 120000}, {'name': 'Dave', 'age': 25, 'salary': 90000}, {'name': 'Paula', 'age': 29, 'salary': 95000} ] # Sorting by age in ascending order sorted_by_age = sort_employees_by_key(employees, 'age') # Sorting by salary in descending order sorted_by_salary_desc = sort_employees_by_key(employees, 'salary', reverse=True)"},{"question":"def find_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs of integers from the array that add up to the target. Each pair is represented as a tuple, and the pairs are sorted in ascending order based on the first element of the tuple. If multiple pairs have the same first element, sort them by the second element. Duplicate pairs are not returned. >>> find_pairs([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs([1, 1, 2, 45, 46, 46], 47) [(1, 46), (2, 45)]","solution":"def find_pairs(arr, target): Returns all unique pairs of integers from the array that add up to the target. Each pair is represented as a tuple, and the pairs are sorted in ascending order based on the first element of the tuple. If multiple pairs have the same first element, sort them by the second element. Duplicate pairs are not returned. pairs = set() seen = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) # Convert set to list and sort tuples return sorted(pairs)"},{"question":"def second_smallest(arr): Finds the second smallest element in the array and returns its value. If the array has less than two distinct elements, returns None. # Unit Tests def test_second_smallest_normal_case(): assert second_smallest([3, 1, 2, 1, 4]) == 2 def test_second_smallest_all_same(): assert second_smallest([1, 1, 1, 1]) == None def test_second_smallest_two_elements(): assert second_smallest([5, 3]) == 5 def test_second_smallest_less_than_two(): assert second_smallest([42]) == None def test_second_smallest_negative_numbers(): assert second_smallest([-1, -5, -3, -2, -1]) == -3 def test_second_smallest_with_zero(): assert second_smallest([0, -1, 2, 3]) == 0 def test_second_smallest_two_distinct(): assert second_smallest([7, 9]) == 9","solution":"def second_smallest(arr): Finds the second smallest element in the array and returns its value. If the array has less than two distinct elements, returns None. if len(arr) < 2: return None first_min, second_min = float('inf'), float('inf') for num in arr: if num < first_min: first_min, second_min = num, first_min elif first_min < num < second_min: second_min = num return second_min if second_min < float('inf') else None"},{"question":"def unique_pairs(nums: List[int]) -> List[Tuple[int, int]]: Returns a list of tuples containing unique pairs of integers from the input list, where each pair (a, b) satisfies a < b and no integer appears more than once in a tuple. >>> unique_pairs([3, 1, 4, 1, 5, 9]) [(1, 3), (1, 4), (1, 5), (1, 9), (3, 4), (3, 5), (3, 9), (4, 5), (4, 9), (5, 9)] >>> unique_pairs([1, 1, 1, 1]) [] >>> unique_pairs([1, 2, 3, 4]) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> unique_pairs([]) [] >>> unique_pairs([1]) [] >>> unique_pairs([9, 5, 4, 3, 1]) [(1, 3), (1, 4), (1, 5), (1, 9), (3, 4), (3, 5), (3, 9), (4, 5), (4, 9), (5, 9)]","solution":"def unique_pairs(nums): Returns a list of unique tuples where each tuple contains two distinct integers from the list, and the first integer is less than the second integer. result = [] nums = sorted(set(nums)) # Remove duplicates and sort the list for i in range(len(nums)): for j in range(i + 1, len(nums)): result.append((nums[i], nums[j])) return result"},{"question":"def count_characters(s: str) -> dict: Takes a string as input and returns a dictionary where the keys are the unique characters and the values are the number of times each character appears. >>> count_characters(\\"examplestring\\") == { ... 'e': 2, ... 'x': 1, ... 'a': 1, ... 'm': 1, ... 'p': 1, ... 'l': 1, ... 's': 1, ... 't': 1, ... 'r': 1, ... 'i': 1, ... 'n': 1, ... 'g': 1 ... } >>> count_characters(\\"\\") == {} >>> count_characters(\\"aaaa\\") == {'a': 4} >>> count_characters(\\"b\\") == {'b': 1} >>> count_characters(\\"aabbcc\\") == {'a': 2, 'b': 2, 'c': 2} >>> count_characters(\\"abcABC\\") == {'a': 1, 'b': 1, 'c': 1, 'A': 1, 'B': 1, 'C': 1} pass","solution":"def count_characters(s): Takes a string as input and returns a dictionary where the keys are the unique characters and the values are the number of times each character appears. character_count = {} for char in s: if char in character_count: character_count[char] += 1 else: character_count[char] = 1 return character_count"},{"question":"def count_character_frequencies(s: str) -> Dict[str, int]: Given a string consisting of only lowercase alphabets, return a dictionary with the characters as keys and their corresponding frequencies as values. >>> count_character_frequencies('mississippi') {'m': 1, 'i': 4, 's': 4, 'p': 2} >>> count_character_frequencies('') {} >>> count_character_frequencies('a') {'a': 1} >>> count_character_frequencies('aaaa') {'a': 4} >>> count_character_frequencies('abcdefg') {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1} >>> long_string = 'a' * 1000 + 'b' * 500 + 'c' * 300 >>> count_character_frequencies(long_string) {'a': 1000, 'b': 500, 'c': 300}","solution":"def count_character_frequencies(s): Returns a dictionary with the frequency of each character in the string s. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray using Kadane's Algorithm. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-2, -3, -4, -1, -2]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) 10 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-3]) -3 >>> max_subarray_sum([2, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray using Kadane's Algorithm. max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"import re from collections import defaultdict def normalize_word(word: str) -> str: Normalize the word by converting it to lowercase and removing any punctuation. >>> normalize_word(\\"Hello!\\") \\"hello\\" >>> normalize_word(\\"ApPlE\\") \\"apple\\" >>> normalize_word(\\"Fruits,\\") \\"fruits\\" pass def sorted_word_frequencies(word_freq_dict: dict) -> dict: Accepts a dictionary of word-frequency pairs and returns a new dictionary with words sorted alphabetically and their frequencies. This function is case-insensitive and handles punctuation. >>> sorted_word_frequencies({'Apple': 3, 'banana': 2, 'Banana!': 1, 'apple!': 2, 'grape': 1, 'Grape': 1, 'Cherry': 4}) {'apple': 5, 'banana': 3, 'cherry': 4, 'grape': 2} pass","solution":"import re from collections import defaultdict def normalize_word(word): Normalize the word by converting it to lowercase and removing any punctuation. return re.sub(r'[^ws]', '', word).lower() def sorted_word_frequencies(word_freq_dict): Accepts a dictionary of word-frequency pairs and returns a new dictionary with words sorted alphabetically and their frequencies. This function is case-insensitive and handles punctuation. normalized_dict = defaultdict(int) for word, freq in word_freq_dict.items(): normalized_word = normalize_word(word) normalized_dict[normalized_word] += freq sorted_dict = dict(sorted(normalized_dict.items())) return sorted_dict def example(): word_freq_dict = { 'Apple': 3, 'banana': 2, 'Banana!': 1, 'apple!': 2, 'grape': 1, 'Grape': 1, 'Cherry': 4 } result = sorted_word_frequencies(word_freq_dict) print(result) # Call the example function to demonstrate the function with sample input and output example()"},{"question":"from typing import List def generate_spiral_matrix(n: int) -> List[List[int]]: Generates a spiral matrix of size n x n. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"from typing import List def generate_spiral_matrix(n: int) -> List[List[int]]: Generates a spiral matrix of size n x n. matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: # Traverse from left to right for j in range(left, right + 1): matrix[top][j] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left for j in range(right, left - 1, -1): matrix[bottom][j] = num num += 1 bottom -= 1 # Traverse from bottom to top for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def most_expensive_product(products: dict) -> str: Returns the name of the most expensive product. Parameters: - products (dict): A dictionary where keys are product names and values are their prices. Returns: - str: The name of the most expensive product, or None if the dictionary is empty. Examples: >>> most_expensive_product({\\"laptop\\": 1500.00}) \\"laptop\\" >>> most_expensive_product({\\"laptop\\": 1500.00, \\"smartphone\\": 800.50, \\"tablet\\": 450.75}) \\"laptop\\" >>> most_expensive_product({\\"laptop\\": 500.00, \\"smartphone\\": 500.00}) in [\\"laptop\\", \\"smartphone\\"] True >>> most_expensive_product({}) None >>> most_expensive_product({\\"laptop\\": -100.00, \\"smartphone\\": -50.00, \\"tablet\\": -150.75}) \\"smartphone\\" >>> most_expensive_product({\\"laptop\\": 1500.00, \\"smartphone\\": 1500.01, \\"tablet\\": 450.75}) \\"smartphone\\"","solution":"def most_expensive_product(products): Returns the name of the most expensive product. Params: - products (dict): A dictionary where keys are product names and values are their prices. Returns: - (str): The name of the most expensive product. if not products: return None return max(products, key=products.get)"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all other elements in the input list without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([5]) [1] >>> product_except_self([]) [] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all other elements in the input list. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"def longest_common_suffix(names: List[str]) -> str: Determines the longest common suffix shared by all the names in the list. If no common suffix exists, returns an empty string. Args: names: list of str - List of names Returns: str: Longest common suffix or an empty string if none exists. >>> longest_common_suffix([\\"Richardson\\", \\"Peterson\\", \\"Harrison\\"]) == \\"son\\" >>> longest_common_suffix([\\"running\\", \\"jogging\\", \\"jumping\\"]) == \\"ing\\" >>> longest_common_suffix([\\"climbing\\", \\"swimming\\", \\"singing\\"]) == \\"ing\\" >>> longest_common_suffix([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"\\" >>> longest_common_suffix([\\"dog\\", \\"cat\\", \\"mouse\\"]) == \\"\\" >>> longest_common_suffix([]) == \\"\\" >>> longest_common_suffix([\\"single\\"]) == \\"single\\" >>> longest_common_suffix([\\"a\\"]) == \\"a\\" >>> longest_common_suffix([\\"abc\\", \\"zc\\", \\"c\\"]) == \\"c\\" >>> longest_common_suffix([\\"abcdef\\", \\"ghief\\", \\"plef\\"]) == \\"ef\\" >>> longest_common_suffix([\\"flow\\", \\"slow\\", \\"glow\\"]) == \\"low\\" >>> longest_common_suffix([\\"intention\\", \\"convention\\", \\"mention\\"]) == \\"ention\\"","solution":"def longest_common_suffix(names): Determines the longest common suffix shared by all the names in the list. If no common suffix exists, returns an empty string. Args: names: list of str - List of names Returns: str: Longest common suffix or an empty string if none exists. if not names: return \\"\\" # Reverse all the names for easier comparison reversed_names = [name[::-1] for name in names] # Longest common prefix in reversed order means longest common suffix in original common_suffix_reversed = [] for chars in zip(*reversed_names): if all(char == chars[0] for char in chars): common_suffix_reversed.append(chars[0]) else: break common_suffix = ''.join(common_suffix_reversed)[::-1] return common_suffix"},{"question":"def bubble_sort(arr): Sorts a list of integers using the bubble sort algorithm. Returns the sorted list and the number of swaps needed to sort the list. If the list is empty, returns \\"The list is empty!\\". If the list contains non-integer elements, returns \\"Invalid input: list contains non-integer elements!\\". >>> bubble_sort([]) \\"The list is empty!\\" >>> bubble_sort([1, 2, 'a', 4]) \\"Invalid input: list contains non-integer elements!\\" >>> bubble_sort([1, 1, 1, 1]) ([1, 1, 1, 1], 0) >>> bubble_sort([1, 2, 3, 4]) ([1, 2, 3, 4], 0) >>> bubble_sort([4, 3, 2, 1]) ([1, 2, 3, 4], 6) >>> bubble_sort([4, 2, 3, 1]) ([1, 2, 3, 4], 5) >>> bubble_sort([1]) ([1], 0) >>> bubble_sort([2, 1]) ([1, 2], 1) >>> bubble_sort([1, 2]) ([1, 2], 0)","solution":"def bubble_sort(arr): Sorts a list of integers using the bubble sort algorithm. Returns the sorted list and the number of swaps needed to sort the list. If the list is empty, returns \\"The list is empty!\\". If the list contains non-integer elements, returns \\"Invalid input: list contains non-integer elements!\\". if not arr: return \\"The list is empty!\\" if not all(isinstance(x, int) for x in arr): return \\"Invalid input: list contains non-integer elements!\\" n = len(arr) swaps = 0 for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 return arr, swaps"},{"question":"def longest_substring_without_repeating_characters(s: str) -> str: Finds the longest substring without repeating characters in the input string \`s\`. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") == \\"abc\\" >>> longest_substring_without_repeating_characters(\\"bbbbb\\") == \\"b\\" >>> longest_substring_without_repeating_characters(\\"pwwkew\\") == \\"wke\\"","solution":"def longest_substring_without_repeating_characters(s): Finds the longest substring without repeating characters in the input string \`s\`. Parameters: s (str): The input string. Returns: str: The longest substring without repeating characters. start = 0 max_length = 0 max_substr = \\"\\" char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 max_substr = s[start:end+1] return max_substr"},{"question":"from typing import List, Dict def update_salaries(employees: List[Dict], percentage: int, department: str) -> None: Updates the salary of all employees in a specified department by a given percentage. :param employees: List of dictionaries containing employee information. :param percentage: The percentage increase to apply to the salaries. :param department: The department whose employees' salaries are to be updated. pass def find_top_salary_employees(employees: List[Dict], n: int) -> List[str]: Returns the names of top n employees with the highest salaries. :param employees: List of dictionaries containing employee information. :param n: The number of top salary employees to return. :return: List of names of top n employees. pass def test_update_salaries(): employees = [ {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 50000}, {'name': 'Bob', 'age': 25, 'department': 'Engineering', 'salary': 70000}, {'name': 'Charlie', 'age': 35, 'department': 'HR', 'salary': 60000}, {'name': 'David', 'age': 40, 'department': 'Sales', 'salary': 80000}, {'name': 'Eve', 'age': 28, 'department': 'Engineering', 'salary': 90000} ] update_salaries(employees, 10, 'HR') assert employees == [ {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 55000}, {'name': 'Bob', 'age': 25, 'department': 'Engineering', 'salary': 70000}, {'name': 'Charlie', 'age': 35, 'department': 'HR', 'salary': 66000}, {'name': 'David', 'age': 40, 'department': 'Sales', 'salary': 80000}, {'name': 'Eve', 'age': 28, 'department': 'Engineering', 'salary': 90000} ] def test_find_top_salary_employees(): employees = [ {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 50000}, {'name': 'Bob', 'age': 25, 'department': 'Engineering', 'salary': 70000}, {'name': 'Charlie', 'age': 35, 'department': 'HR', 'salary': 60000}, {'name': 'David', 'age': 40, 'department': 'Sales', 'salary': 80000}, {'name': 'Eve', 'age': 28, 'department': 'Engineering', 'salary': 90000} ] top_employees = find_top_salary_employees(employees, 3) assert top_employees == ['Eve', 'David', 'Bob'] def test_find_top_salary_employee_single(): employees = [ {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 50000}, {'name': 'Bob', 'age': 25, 'department': 'Engineering', 'salary': 70000}, {'name': 'Charlie', 'age': 35, 'department': 'HR', 'salary': 60000}, {'name': 'David', 'age': 40, 'department': 'Sales', 'salary': 80000}, {'name': 'Eve', 'age': 28, 'department': 'Engineering', 'salary': 90000} ] top_employee = find_top_salary_employees(employees, 1) assert top_employee == ['Eve']","solution":"def update_salaries(employees, percentage, department): Updates the salary of all employees in a specified department by a given percentage. :param employees: List of dictionaries containing employee information. :param percentage: The percentage increase to apply to the salaries. :param department: The department whose employees' salaries are to be updated. for employee in employees: if employee['department'] == department: employee['salary'] += employee['salary'] * (percentage / 100) def find_top_salary_employees(employees, n): Returns the names of top n employees with the highest salaries. :param employees: List of dictionaries containing employee information. :param n: The number of top salary employees to return. :return: List of names of top n employees. sorted_employees = sorted(employees, key=lambda x: x['salary'], reverse=True) return [employee['name'] for employee in sorted_employees[:n]]"},{"question":"import json from typing import List class Product: def __init__(self, id: int, name: str, price: float, category: str, stock: int): self.id = id self.name = name self.price = price self.category = category self.stock = stock @staticmethod def from_dict(product_dict: dict) -> 'Product': return Product( id=product_dict[\\"id\\"], name=product_dict[\\"name\\"], price=product_dict[\\"price\\"], category=product_dict[\\"category\\"], stock=product_dict[\\"stock\\"], ) def parse_products(json_data: str) -> List[Product]: Parse a JSON string to create a list of Product objects. >>> json_data = ''' ... [ ... {\\"id\\": 1, \\"name\\": \\"Laptop\\", \\"price\\": 999.99, \\"category\\": \\"Electronics\\", \\"stock\\": 15}, ... {\\"id\\": 2, \\"name\\": \\"Coffee Maker\\", \\"price\\": 49.99, \\"category\\": \\"Home Appliances\\", \\"stock\\": 7}, ... {\\"id\\": 3, \\"name\\": \\"Smartphone\\", \\"price\\": 699.99, \\"category\\": \\"Electronics\\", \\"stock\\": 25} ... ] ... ''' >>> products = parse_products(json_data) >>> len(products) == 3 >>> products[0].name == \\"Laptop\\" products_data = json.loads(json_data) return [Product.from_dict(product) for product in products_data] def filter_electronics_with_stock(products: List[Product]) -> None: Filter and display products in the 'Electronics' category with stock greater than 10. >>> products = [ ... Product(1, \\"Laptop\\", 999.99, \\"Electronics\\", 15), ... Product(2, \\"Coffee Maker\\", 49.99, \\"Home Appliances\\", 7), ... Product(3, \\"Smartphone\\", 699.99, \\"Electronics\\", 25) ... ] >>> filter_electronics_with_stock(products) Laptop (ID: 1) - 999.99 Smartphone (ID: 3) - 699.99","solution":"import json class Product: def __init__(self, id, name, price, category, stock): self.id = id self.name = name self.price = price self.category = category self.stock = stock @staticmethod def from_dict(product_dict): return Product( id=product_dict[\\"id\\"], name=product_dict[\\"name\\"], price=product_dict[\\"price\\"], category=product_dict[\\"category\\"], stock=product_dict[\\"stock\\"], ) def parse_products(json_data): products_data = json.loads(json_data) return [Product.from_dict(product) for product in products_data] def filter_electronics_with_stock(products): filtered_products = [product for product in products if product.category == \\"Electronics\\" and product.stock > 10] for product in filtered_products: print(f\\"{product.name} (ID: {product.id}) - {product.price}\\") # Example usage json_data = ''' [ { \\"id\\": 1, \\"name\\": \\"Laptop\\", \\"price\\": 999.99, \\"category\\": \\"Electronics\\", \\"stock\\": 15 }, { \\"id\\": 2, \\"name\\": \\"Coffee Maker\\", \\"price\\": 49.99, \\"category\\": \\"Home Appliances\\", \\"stock\\": 7 }, { \\"id\\": 3, \\"name\\": \\"Smartphone\\", \\"price\\": 699.99, \\"category\\": \\"Electronics\\", \\"stock\\": 25 } ] ''' products = parse_products(json_data) filter_electronics_with_stock(products)"},{"question":"def length_of_lis(nums: List[int]) -> int: Given an integer array nums, return the length of the longest increasing subsequence. An increasing subsequence is a subsequence in which the elements are arranged in ascending order. A subsequence is derived from an array by deleting some or no elements without changing the order of the remaining elements. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([10]) 1 >>> length_of_lis([]) 0 pass","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array nums. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def top_n_individuals(individuals, N): Returns the top N highest scoring individuals from the list of dictionaries. >>> individuals = [ ... {'name': 'Alice', 'score': 85}, ... {'name': 'Bob', 'score': 95}, ... {'name': 'Charlie', 'score': 70}, ... {'name': 'David', 'score': 90}, ... {'name': 'Eva', 'score': 85} ... ] >>> N = 3 >>> top_n_individuals(individuals, N) [{'name': 'Bob', 'score': 95}, {'name': 'David', 'score': 90}, {'name': 'Alice', 'score': 85}]","solution":"def top_n_individuals(individuals, N): Returns the top N highest scoring individuals from the list of dictionaries. # Sorting by score in descending order while maintaining stability of original order for ties sorted_individuals = sorted(individuals, key=lambda x: x['score'], reverse=True) # Return the top N individuals return sorted_individuals[:N]"},{"question":"from datetime import datetime class Passenger: Represents a passenger with name, passport number, and date of birth. def __init__(self, name: str, passport_number: str, date_of_birth: str): self.name = name self.passport_number = passport_number self.date_of_birth = date_of_birth class Flight: Represents a flight with flight number, departure city, arrival city, departure time, arrival time, and capacity. Provides methods to book a seat, cancel a reservation, and get the passenger list. def __init__(self, flight_number: str, departure_city: str, arrival_city: str, departure_time: datetime, arrival_time: datetime, capacity: int): self.flight_number = flight_number self.departure_city = departure_city self.arrival_city = arrival_city self.departure_time = departure_time self.arrival_time = arrival_time self.capacity = capacity self.passengers = [] def book_seat(self, passenger: Passenger) -> bool: Books a seat for the given passenger. Raises: ValueError: If the flight is fully booked or the passenger is already booked. >>> passenger = Passenger(\\"John Doe\\", \\"A123456\\", \\"1990-01-01\\") >>> flight = Flight(\\"FL123\\", \\"CityA\\", \\"CityB\\", datetime(2023,12,11,10,0,0), datetime(2023,12,11,12,0,0), 2) >>> flight.book_seat(passenger) True pass # Implementation goes here def cancel_seat(self, passport_number: str) -> bool: Cancels the reservation for the passenger with the given passport number. Raises: ValueError: If no reservation is found for the provided passport number. >>> passenger = Passenger(\\"John Doe\\", \\"A123456\\", \\"1990-01-01\\") >>> flight = Flight(\\"FL123\\", \\"CityA\\", \\"CityB\\", datetime(2023,12,11,10,0,0), datetime(2023,12,11,12,0,0), 2) >>> flight.book_seat(passenger) >>> flight.cancel_seat(\\"A123456\\") True pass # Implementation goes here def get_passenger_list(self) -> list: Returns the list of passengers for the flight. >>> passenger = Passenger(\\"John Doe\\", \\"A123456\\", \\"1990-01-01\\") >>> flight = Flight(\\"FL123\\", \\"CityA\\", \\"CityB\\", datetime(2023,12,11,10,0,0), datetime(2023,12,11,12,0,0), 2) >>> flight.book_seat(passenger) >>> flight.get_passenger_list() [passenger] pass # Implementation goes here class AirlineReservationSystem: Represents an airline reservation system that manages flights and provides search functionality. def __init__(self): self.flights = [] def add_flight(self, flight: Flight): Adds a flight to the system. >>> flight = Flight(\\"FL123\\", \\"CityA\\", \\"CityB\\", datetime(2023,12,11,10,0,0), datetime(2023,12,11,12,0,0), 2) >>> system = AirlineReservationSystem() >>> system.add_flight(flight) pass # Implementation goes here def search_flights(self, departure_city: str, arrival_city: str, departure_date: datetime.date) -> list: Searches for flights based on departure city, arrival city, and departure date. >>> passenger = Passenger(\\"John Doe\\", \\"A123456\\", \\"1990-01-01\\") >>> flight1 = Flight(\\"FL123\\", \\"CityA\\", \\"CityB\\", datetime(2023,12,11,10,0,0), datetime(2023,12,11,12,0,0), 2) >>> system = AirlineReservationSystem() >>> system.add_flight(flight1) >>> system.search_flights(\\"CityA\\", \\"CityB\\", datetime(2023,12,11).date()) [flight1] pass # Implementation goes here","solution":"from datetime import datetime, timedelta class Passenger: def __init__(self, name, passport_number, date_of_birth): self.name = name self.passport_number = passport_number self.date_of_birth = date_of_birth class Flight: def __init__(self, flight_number, departure_city, arrival_city, departure_time, arrival_time, capacity): self.flight_number = flight_number self.departure_city = departure_city self.arrival_city = arrival_city self.departure_time = departure_time self.arrival_time = arrival_time self.capacity = capacity self.passengers = [] def book_seat(self, passenger): if len(self.passengers) < self.capacity: if passenger.passport_number not in [p.passport_number for p in self.passengers]: self.passengers.append(passenger) return True else: raise ValueError(\\"Passenger already booked on this flight.\\") else: raise ValueError(\\"Flight fully booked.\\") def cancel_seat(self, passport_number): for passenger in self.passengers: if passenger.passport_number == passport_number: self.passengers.remove(passenger) return True raise ValueError(\\"No reservation found for the provided passport number.\\") def get_passenger_list(self): return self.passengers class AirlineReservationSystem: def __init__(self): self.flights = [] def add_flight(self, flight): self.flights.append(flight) def search_flights(self, departure_city, arrival_city, departure_date): matching_flights = [] for flight in self.flights: if ( flight.departure_city == departure_city and flight.arrival_city == arrival_city and flight.departure_time.date() == departure_date ): matching_flights.append(flight) return matching_flights"},{"question":"def square_elements(input_list: List[int]) -> List[int]: Returns a new list where each element is the square of the corresponding element in the input list. >>> square_elements([]) == [] >>> square_elements([4]) == [16] >>> square_elements([1, 2, 3]) == [1, 4, 9] >>> square_elements([0, -1, -2]) == [0, 1, 4] >>> square_elements([1000, 2000, 3000]) == [1000000, 4000000, 9000000] >>> square_elements([5, -7, 0, 12]) == [25, 49, 0, 144]","solution":"def square_elements(input_list): Returns a new list where each element is the square of the corresponding element in the input list. return [x ** 2 for x in input_list]"},{"question":"def categorize_feedback(feedback: str) -> str: Categorize customer feedback into positive, negative, or neutral based on given keywords. >>> categorize_feedback(\\"I had a great day, everything was excellent!\\") \\"Positive\\" >>> categorize_feedback(\\"The experience was horrible, very bad.\\") \\"Negative\\" >>> categorize_feedback(\\"The service was good but the food was bad.\\") \\"Neutral\\" >>> categorize_feedback(\\"It was an average day.\\") \\"Neutral\\" >>> categorize_feedback(\\"The movie was excellent!!!\\") \\"Positive\\" >>> categorize_feedback(\\"The product was horrible... worst ever.\\") \\"Negative\\" >>> categorize_feedback(\\"I am very Happy with the great service.\\") \\"Positive\\" >>> categorize_feedback(\\"This is just terrible, I feel so SAD.\\") \\"Negative\\" >>> categorize_feedback(\\"Good good good job, excellent excellent!\\") \\"Positive\\" >>> categorize_feedback(\\"Bad bad bad experience, horrible horrible!\\") \\"Negative\\"","solution":"def categorize_feedback(feedback): import re positive_keywords = [\\"good\\", \\"happy\\", \\"enjoy\\", \\"excellent\\", \\"great\\"] negative_keywords = [\\"bad\\", \\"sad\\", \\"horrible\\", \\"terrible\\", \\"poor\\"] feedback = feedback.lower() words = re.findall(r'bw+b', feedback) positive_count = sum(words.count(word) for word in positive_keywords) negative_count = sum(words.count(word) for word in negative_keywords) if positive_count > negative_count: return \\"Positive\\" elif negative_count > positive_count: return \\"Negative\\" else: return \\"Neutral\\""},{"question":"def sum_of_squares_with_negative_count(lst): Returns the sum of squares of all elements in a given list of integers and the count of negative numbers in the list. Also ensures that the list contains only integer values. Parameters: lst (list): List of integers Returns: tuple: (sum_of_squares, negative_count) Raises: ValueError: If the list contains non-integer values. >>> sum_of_squares_with_negative_count([1, 2, 3]) (14, 0) >>> sum_of_squares_with_negative_count([-1, 2, -3, 4]) (30, 2) >>> sum_of_squares_with_negative_count([-1, -2, -3]) (14, 3) >>> sum_of_squares_with_negative_count([0, 1, -1]) (2, 1) >>> sum_of_squares_with_negative_count([]) (0, 0) >>> sum_of_squares_with_negative_count([1, 'a', 3]) Traceback (most recent call last): ValueError: List must contain only integer values # Placeholder for function implementation pass","solution":"def sum_of_squares_with_negative_count(lst): Returns the sum of squares of all elements in a given list of integers and the count of negative numbers in the list. Parameters: lst (list): List of integers Returns: tuple: (sum_of_squares, negative_count) # Verify the input contains only integers if not all(isinstance(i, int) for i in lst): raise ValueError(\\"List must contain only integer values\\") sum_of_squares = 0 negative_count = 0 for num in lst: sum_of_squares += num ** 2 if num < 0: negative_count += 1 return sum_of_squares, negative_count"},{"question":"def wave_pattern(arr): Rearranges the elements of the input array into a wave pattern. For any even index i, arr[i] should be greater than or equal to both its neighboring elements (if they exist), and for any odd index i, arr[i] should be less than or equal to both its neighboring elements (if they exist). Args: arr (list): A list of integers representing the heights of students. Returns: None: Modifies the input array in-place. import pytest def test_wave_pattern_basic(): arr = [3, 6, 5, 10, 7, 20] wave_pattern(arr) assert arr in [[6, 3, 10, 5, 20, 7], [5, 3, 10, 7, 20, 6], [6, 3, 10, 6, 20, 5]] def test_wave_pattern_single_element(): arr = [1] wave_pattern(arr) assert arr == [1] def test_wave_pattern_sorted_ascending(): arr = [1, 2, 3, 4, 5, 6] wave_pattern(arr) assert arr in [[1, 2, 3, 4, 5, 6], [2, 1, 4, 3, 6, 5]] def test_wave_pattern_sorted_descending(): arr = [6, 5, 4, 3, 2, 1] wave_pattern(arr) assert arr in [[6, 4, 5, 1, 3, 2], [6, 5, 4, 3, 2, 1], [6, 4, 5, 2, 3, 1]] def test_wave_pattern_duplicates(): arr = [5, 5, 5, 5, 5, 5] wave_pattern(arr) assert arr == [5, 5, 5, 5, 5, 5] def test_wave_pattern_longer_array(): arr = [10, 90, 49, 2, 1, 5, 23] wave_pattern(arr) assert arr in [[90, 10, 49, 1, 5, 2, 23], [90, 10, 49, 1, 5, 2, 23], [49, 2, 90, 1, 23, 5, 10]] def test_wave_pattern_already_wave(): arr = [10, 5, 12, 3, 15, 2] wave_pattern(arr) assert arr == [10, 5, 12, 3, 15, 2] def test_wave_pattern_alternating(): arr = [5, 10, 5, 10, 5, 10] wave_pattern(arr) assert arr in [[10, 5, 10, 5, 10, 5], [5, 10, 5, 10, 5, 10]]","solution":"def wave_pattern(arr): Rearranges the elements of the input array into a wave pattern. For any even index i, arr[i] should be greater than or equal to both its neighboring elements (if they exist), and for any odd index i, arr[i] should be less than or equal to both its neighboring elements (if they exist). Args: arr (list): A list of integers representing the heights of students. Returns: None: Modifies the input array in-place. n = len(arr) for i in range(0, n, 2): if i > 0 and arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] if i < n - 1 and arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i]"},{"question":"from typing import List, Tuple import re from collections import Counter def count_unique_words(document: str) -> List[Tuple[str, int]]: Analyzes a text document to identify and count the frequency of each unique word, ignoring case differences and excluding words with digits or special characters. Returns the top 5 most frequent words in descending order of frequency. >>> count_unique_words(\\"The quick brown fox jumps over the lazy dog\\") == [('the', 2), ('quick', 1), ('brown', 1), ('fox', 1), ('jumps', 1)] >>> count_unique_words(\\"The the the\\") == [('the', 3)] import pytest from solution import count_unique_words def test_empty_document(): with pytest.raises(ValueError): count_unique_words(\\"\\") def test_single_line_document(): document = \\"The quick brown fox jumps over the lazy dog\\" assert count_unique_words(document) == [('the', 2), ('quick', 1), ('brown', 1), ('fox', 1), ('jumps', 1)] def test_multiple_lines_document(): document = The quick brown fox jumps over the lazy dog. The dog was not amused. assert count_unique_words(document) == [('the', 3), ('dog', 2), ('quick', 1), ('brown', 1), ('fox', 1)] def test_ignore_case_and_special_characters(): document = \\"The quick brown fox. The quick, quick!\\" assert count_unique_words(document) == [('quick', 3), ('the', 2), ('brown', 1), ('fox', 1)] def test_exclude_words_with_digits(): document = \\"The quick brown fox jumps over the lazy dog 123 times in 3 days\\" assert count_unique_words(document) == [('the', 2), ('quick', 1), ('brown', 1), ('fox', 1), ('jumps', 1)] def test_less_than_five_unique_words(): document = \\"The the the\\" assert count_unique_words(document) == [('the', 3)]","solution":"import re from collections import Counter def count_unique_words(document): Analyzes a text document to identify and count the frequency of each unique word, ignoring case differences and excluding words with digits or special characters. Returns the top 5 most frequent words in descending order of frequency. if not document: raise ValueError(\\"The document is empty\\") # Split document into words and normalize to lower case words = re.findall(r'b[a-zA-Z]+b', document.lower()) # Count the frequency of each word word_count = Counter(words) # Get the top 5 most frequent words most_common_words = word_count.most_common(5) return most_common_words"},{"question":"class FileSystem: def __init__(self): self.fs = {} def create(self, path: str, value: int) -> str: Create a new file at the specified path with the given value. If the file already exists, return \\"File already exists.\\" # Your implementation here def get(self, path: str): Get the value of the file at the specified path. If the file does not exist, return \\"File does not exist.\\" # Your implementation here def set(self, path: str, value: int) -> str: Set the value of the file at the specified path. If the file does not exist, return \\"File does not exist.\\" # Your implementation here def delete(self, path: str) -> str: Delete the file at the specified path. If the file does not exist, return \\"File does not exist.\\" # Your implementation here # Example usage: # fs = FileSystem() # print(fs.create('/a', 1)) # None # print(fs.get('/a')) # 1 # print(fs.set('/a', 2)) # None # print(fs.get('/a')) # 2 # print(fs.create('/a', 3)) # \\"File already exists.\\" # print(fs.delete('/a')) # None # print(fs.get('/a')) # \\"File does not exist.\\" # print(fs.delete('/a')) # \\"File does not exist.\\" # Unit Tests import pytest from solution import FileSystem def test_create_file(): fs = FileSystem() assert fs.create('/a', 1) is None assert fs.create('/a', 2) == \\"File already exists.\\" def test_get_file(): fs = FileSystem() fs.create('/a', 1) assert fs.get('/a') == 1 assert fs.get('/b') == \\"File does not exist.\\" def test_set_file(): fs = FileSystem() fs.create('/a', 1) assert fs.set('/a', 2) is None assert fs.get('/a') == 2 assert fs.set('/b', 3) == \\"File does not exist.\\" def test_delete_file(): fs = FileSystem() fs.create('/a', 1) assert fs.delete('/a') is None assert fs.delete('/a') == \\"File does not exist.\\" assert fs.get('/a') == \\"File does not exist.\\"","solution":"class FileSystem: def __init__(self): self.fs = {} def create(self, path: str, value: int) -> str: Create a new file at the specified path with the given value. If the file already exists, return \\"File already exists.\\" if path in self.fs: return \\"File already exists.\\" self.fs[path] = value def get(self, path: str): Get the value of the file at the specified path. If the file does not exist, return \\"File does not exist.\\" if path not in self.fs: return \\"File does not exist.\\" return self.fs[path] def set(self, path: str, value: int) -> str: Set the value of the file at the specified path. If the file does not exist, return \\"File does not exist.\\" if path not in self.fs: return \\"File does not exist.\\" self.fs[path] = value def delete(self, path: str) -> str: Delete the file at the specified path. If the file does not exist, return \\"File does not exist.\\" if path not in self.fs: return \\"File does not exist.\\" del self.fs[path]"},{"question":"def merge_dictionaries(dict1, dict2): Merges two dictionaries. If a key exists in both dictionaries, their values are added. If input is not a dictionary, a TypeError is raised. >>> merge_dictionaries({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) {'a': 1, 'b': 5, 'c': 4} >>> merge_dictionaries({'a': 1}, {'b': 2}) {'a': 1, 'b': 2} >>> merge_dictionaries({'a': 1}, {'a': 2.5}) {'a': 3.5} >>> merge_dictionaries({'a': 1, 'b': \\"hello\\"}, {'b': \\"world\\", 'c': 4}) {'a': 1, 'b': 'world', 'c': 4} >>> merge_dictionaries({'a': 1}, \\"not a dict\\") Traceback (most recent call last): ... TypeError: Both inputs must be dictionaries >>> merge_dictionaries(\\"not a dict\\", {'a': 1}) Traceback (most recent call last): ... TypeError: Both inputs must be dictionaries","solution":"def merge_dictionaries(dict1, dict2): Merges two dictionaries. If a key exists in both dictionaries, their values are added. If input is not a dictionary, a TypeError is raised. Parameters: - dict1: The first dictionary. - dict2: The second dictionary. Returns: A dictionary that is a result of merging dict1 and dict2. if not isinstance(dict1, dict) or not isinstance(dict2, dict): raise TypeError(\\"Both inputs must be dictionaries\\") merged_dict = dict1.copy() for key, value in dict2.items(): if key in merged_dict and isinstance(value, (int, float)) and isinstance(merged_dict[key], (int, float)): merged_dict[key] += value else: merged_dict[key] = value return merged_dict"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. >>> rightSideView(None) [] >>> root = TreeNode(1, None, TreeNode(3)) >>> rightSideView(root) [1, 3] >>> root = TreeNode(1, TreeNode(2), TreeNode(3, None, TreeNode(4))) >>> rightSideView(root) [1, 3, 4]","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): view = [] def dfs(node, level): if not node: return if level == len(view): view.append(node.val) dfs(node.right, level + 1) dfs(node.left, level + 1) dfs(root, 0) return view"},{"question":"def findOceanFlowPoints(matrix): Design an efficient algorithm to traverse a bidimensional matrix that represents elevations on a terrain. Your objective is to identify all points where water would flow into the ocean if it only flows from higher to lower elevations or same elevations. Water can flow in four directions: north, south, east, and west. An elevation at the edge of the matrix naturally flows into the ocean. >>> findOceanFlowPoints([]) == [] >>> findOceanFlowPoints([[1]]) == [(0, 0)] >>> findOceanFlowPoints([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) == [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> findOceanFlowPoints([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == [ (0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2) ] >>> findOceanFlowPoints([ [10, 10, 10], [10, 10, 10], [10, 10, 10] ]) == [ (0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2) ]","solution":"def findOceanFlowPoints(matrix): if not matrix: return [] m, n = len(matrix), len(matrix[0]) pacific = [[False] * n for _ in range(m)] atlantic = [[False] * n for _ in range(m)] def dfs(x, y, ocean_matrix): stack = [(x, y)] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while stack: cx, cy = stack.pop() ocean_matrix[cx][cy] = True for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and not ocean_matrix[nx][ny] and matrix[nx][ny] >= matrix[cx][cy]: stack.append((nx, ny)) for i in range(m): dfs(i, 0, pacific) dfs(i, n-1, atlantic) for j in range(n): dfs(0, j, pacific) dfs(m-1, j, atlantic) result = [] for i in range(m): for j in range(n): if pacific[i][j] and atlantic[i][j]: result.append((i, j)) return result"},{"question":"def longest_word(sentence: str) -> str: Identifies and returns the longest word in a given string. If there are multiple words of the same length, returns the first one. Parameters: - sentence: str : input string Returns: - str : the longest word in the input string Examples: >>> longest_word(\\"The quick brown fox jumped over the lazy dog\\") \\"jumped\\" >>> longest_word(\\"I see three bees\\") \\"three\\" >>> longest_word(\\"Antidisestablishmentarianism\\") \\"Antidisestablishmentarianism\\" >>> longest_word(\\"\\") \\"\\" >>> longest_word(\\"Hello!!! World?\\") \\"Hello!!!\\" >>> longest_word(\\"Newlinesn and spaces everywhere\\") \\"everywhere\\"","solution":"def longest_word(sentence): Identifies and returns the longest word in a given string. If there are multiple words of the same length, returns the first one. Parameters: - sentence: str : input string Returns: - str : the longest word in the input string words = sentence.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def sum_of_primes_below(N): Returns the sum of all prime numbers below a given integer N. :param N: int, the upper limit (exclusive) for the sum of prime numbers. :return: The sum of all prime numbers below N if N is a positive integer, else an error message. Example: >>> sum_of_primes_below(10) 17 >>> sum_of_primes_below(30) 129 >>> sum_of_primes_below(2) 0 >>> sum_of_primes_below(1) \\"Error: Input must be greater than or equal to 2.\\" >>> sum_of_primes_below(0) \\"Error: Input must be greater than or equal to 2.\\"","solution":"def sum_of_primes_below(N): Returns the sum of all prime numbers below a given integer N. :param N: int, the upper limit (exclusive) for the sum of prime numbers. :return: The sum of all prime numbers below N if N is a positive integer, else an error message. if not isinstance(N, int): return \\"Error: Input must be an integer.\\" if N < 2: return \\"Error: Input must be greater than or equal to 2.\\" sieve = [True] * N sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers for start in range(2, int(N**0.5) + 1): if sieve[start]: for multiple in range(start*start, N, start): sieve[multiple] = False prime_sum = sum(idx for idx, is_prime in enumerate(sieve) if is_prime) return prime_sum"},{"question":"from typing import List, Tuple def clean_text(text: str) -> str: Remove punctuation and convert text to lowercase. pass def count_word_frequencies(file_path: str) -> List[Tuple[str, int]]: Count the frequency of each word in the given text file. Returns the ten most common words along with their frequencies. >>> result = count_word_frequencies('mock_text_file.txt') >>> expected = [('test', 4), ('example', 1), ('text', 1), ('processing', 1), ('aim', 1), ('counting', 1), ('frequency', 1)] >>> result == expected True >>> result = count_word_frequencies('non_existing_file.txt') >>> result == [] True pass def query_word_frequency(file_path: str, query_word: str) -> int: Query the frequency of a specific word in the given text file. >>> result = query_word_frequency('mock_text_file.txt', 'test') >>> result == 4 True >>> result = query_word_frequency('mock_text_file.txt', 'example') >>> result == 1 True >>> result = query_word_frequency('mock_text_file.txt', 'nonexistentword') >>> result == 0 True >>> result = query_word_frequency('non_existing_file.txt', 'test') >>> result == 0 True pass","solution":"import re from collections import Counter import string # Define the set of common stop words STOP_WORDS = set([ \\"the\\", \\"and\\", \\"in\\", \\"of\\", \\"to\\", \\"a\\", \\"is\\", \\"it\\", \\"that\\", \\"for\\", \\"on\\", \\"with\\", \\"as\\", \\"at\\", \\"this\\", \\"by\\", \\"an\\", \\"are\\", \\"be\\", \\"from\\", \\"which\\", \\"or\\", \\"we\\", \\"can\\", \\"not\\", \\"all\\", \\"one\\", \\"have\\", \\"has\\", \\"you\\", \\"but\\", \\"they\\", \\"i\\", \\"he\\", \\"she\\", \\"will\\", \\"was\\", \\"were\\", \\"do\\", \\"does\\", \\"did\\" ]) def clean_text(text): Remove punctuation and convert text to lowercase. text = text.lower() text = re.sub(f\\"[{string.punctuation}]\\", \\" \\", text) return text def count_word_frequencies(file_path): Count the frequency of each word in the given text file. Returns the ten most common words along with their frequencies. word_counter = Counter() try: with open(file_path, 'r', encoding=\\"utf-8\\") as file: for line in file: clean_line = clean_text(line) words = clean_line.split() filtered_words = [word for word in words if word not in STOP_WORDS] word_counter.update(filtered_words) except FileNotFoundError: print(\\"File not found. Please check the file path.\\") return [] except Exception as e: print(f\\"An error occurred: {e}\\") return [] return word_counter.most_common(10) def query_word_frequency(file_path, query_word): Query the frequency of a specific word in the given text file. word_counter = Counter() try: with open(file_path, 'r', encoding=\\"utf-8\\") as file: for line in file: clean_line = clean_text(line) words = clean_line.split() filtered_words = [word for word in words if word not in STOP_WORDS] word_counter.update(filtered_words) except FileNotFoundError: print(\\"File not found. Please check the file path.\\") return 0 except Exception as e: print(f\\"An error occurred: {e}\\") return 0 return word_counter[query_word.lower()]"},{"question":"def validate_emails(email_list): Validates a list of emails according to the specified rules. Args: email_list (list): List of email addresses to validate. Returns: list: List of invalid email addresses. pass # Test Cases import pytest def test_valid_emails(): valid_emails = [ \\"user@example.com\\", \\"admin@site.com\\", \\"valid@domain.co.uk\\", \\"name@domain.org\\" ] assert validate_emails(valid_emails) == [] def test_invalid_emails(): invalid_emails = [ \\"plainaddress\\", \\"@nosuchuser.com\\", \\"missingatsign.com\\", \\"user@-.com\\", \\"user@site..com\\", \\"user@site-.com\\", \\"user@site.c1\\", \\"@\\", 123, ] assert validate_emails(invalid_emails) == invalid_emails def test_mixed_emails(): mixed_emails = [ \\"user@example.com\\", \\"invalid@site.c\\", 123, \\"missingatsign.com\\", ] result = validate_emails(mixed_emails) assert set(result) == set([\\"invalid@site.c\\", 123, \\"missingatsign.com\\"]) def test_non_list_input(): with pytest.raises(ValueError, match=\\"Input must be a list.\\"): validate_emails(\\"invalid input\\") def test_large_list(): large_list = [\\"user@example.com\\"] * 1001 with pytest.raises(ValueError, match=\\"List cannot contain more than 1000 email addresses.\\"): validate_emails(large_list) def test_no_invalid_emails(): no_invalid_emails = [] assert validate_emails(no_invalid_emails) == []","solution":"import re def validate_emails(email_list): Validates a list of emails according to the specified rules. Args: email_list (list): List of email addresses to validate. Returns: list: List of invalid email addresses. if not isinstance(email_list, list): raise ValueError(\\"Input must be a list.\\") if len(email_list) > 1000: raise ValueError(\\"List cannot contain more than 1000 email addresses.\\") invalid_emails = [] email_regex = re.compile( r'^([^@s]+)@(([a-zA-Z0-9-]+.)+[a-zA-Z]{2,})' ) for email in email_list: if not isinstance(email, str) or not email_regex.match(email): invalid_emails.append(email) else: domain = email.split(\\"@\\")[1] domain_parts = domain.split(\\".\\") for part in domain_parts: if len(part) < 2 or part.startswith(\\"-\\") or part.endswith(\\"-\\"): invalid_emails.append(email) break return invalid_emails"},{"question":"def iterative_fibonacci(n: int) -> int: Computes the nth Fibonacci number non-recursively. Parameters: n (int): The index of the Fibonacci sequence to return Returns: int: The nth Fibonacci number Examples: >>> iterative_fibonacci(0) 0 >>> iterative_fibonacci(1) 1 >>> iterative_fibonacci(10) 55 >>> iterative_fibonacci(100) 354224848179261915075 >>> iterative_fibonacci(1000) Output is a very large number, ensure your function handles it correctly. # Your code here # Unit tests def test_fibonacci_base_cases(): assert iterative_fibonacci(0) == 0 assert iterative_fibonacci(1) == 1 def test_fibonacci_small_numbers(): assert iterative_fibonacci(2) == 1 assert iterative_fibonacci(3) == 2 assert iterative_fibonacci(4) == 3 assert iterative_fibonacci(5) == 5 def test_fibonacci_larger_numbers(): assert iterative_fibonacci(10) == 55 assert iterative_fibonacci(20) == 6765 assert iterative_fibonacci(30) == 832040 def test_fibonacci_large_values(): assert iterative_fibonacci(100) == 354224848179261915075 # The following test is commented out to save computational resources during typical testing. # Uncomment to test large values. # assert iterative_fibonacci(1000) == large precomputed value # Additional test to ward against performance issues def test_fibonacci_performance(): import time start_time = time.time() iterative_fibonacci(10000) end_time = time.time() assert end_time - start_time < 5 # The function should complete very quickly","solution":"def iterative_fibonacci(n: int) -> int: Computes the nth Fibonacci number non-recursively. Parameters: n (int): The index of the Fibonacci sequence to return Returns: int: The nth Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Returns True if the string s is a palindrome, ignoring spaces, punctuation, and capitalization. Returns False otherwise. >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"A Santa at NASA!\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"Z\\") == True def test_palindrome_simple(): assert is_palindrome(\\"A man a plan a canal Panama\\") == True def test_palindrome_numbers(): assert is_palindrome(\\"12321\\") == True def test_palindrome_mixed_characters(): assert is_palindrome(\\"A Santa at NASA!\\") == True def test_not_palindrome_simple(): assert is_palindrome(\\"This is not a palindrome\\") == False def test_palindrome_with_symbols(): assert is_palindrome(\\"No 'x' in Nixon\\") == True def test_empty_string(): assert is_palindrome(\\"\\") == True def test_single_character(): assert is_palindrome(\\"a\\") == True assert is_palindrome(\\"Z\\") == True","solution":"import re def is_palindrome(s): Returns True if the string s is a palindrome, ignoring spaces, punctuation, and capitalization. Returns False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_string == cleaned_string[::-1]"},{"question":"import csv from datetime import datetime def calculate_average_salary(csv_file_path: str) -> float: Reads a CSV file and calculates the average salary of employees who have been working for more than 5 years. The CSV file should have the following columns: 'EmployeeID', 'Name', 'Department', 'JoinDate', 'Salary'. Parameters: csv_file_path (str): The path to the CSV file. Returns: float: The average salary of employees who have been working for more than 5 years. Unit Test: import pytest from solution import calculate_average_salary import csv import os def create_test_csv(file_path, rows): Helper function to create a CSV file for testing fieldnames = ['EmployeeID', 'Name', 'Department', 'JoinDate', 'Salary'] with open(file_path, mode='w', newline='') as file: writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() writer.writerows(rows) def test_calculate_average_salary_normal_case(): # Create a sample CSV file for testing rows = [ {'EmployeeID': '1', 'Name': 'John Doe', 'Department': 'HR', 'JoinDate': '2014-05-10', 'Salary': '50000'}, {'EmployeeID': '2', 'Name': 'Jane Smith', 'Department': 'IT', 'JoinDate': '2010-03-15', 'Salary': '60000'}, {'EmployeeID': '3', 'Name': 'Jim Brown', 'Department': 'Marketing', 'JoinDate': '2020-07-01', 'Salary': '45000'} ] test_csv_file = 'test_employees.csv' create_test_csv(test_csv_file, rows) result = calculate_average_salary(test_csv_file) assert result == 55000.0 os.remove(test_csv_file) def test_calculate_average_salary_with_missing_salary(): rows = [ {'EmployeeID': '1', 'Name': 'John Doe', 'Department': 'HR', 'JoinDate': '2014-05-10', 'Salary': '50000'}, {'EmployeeID': '2', 'Name': 'Jane Smith', 'Department': 'IT', 'JoinDate': '2010-03-15', 'Salary': ''}, {'EmployeeID': '3', 'Name': 'Jim Brown', 'Department': 'Marketing', 'JoinDate': '2020-07-01', 'Salary': '45000'} ] test_csv_file = 'test_employees.csv' create_test_csv(test_csv_file, rows) result = calculate_average_salary(test_csv_file) assert result == 50000.0 os.remove(test_csv_file) def test_calculate_average_salary_with_non_numeric_salary(): rows = [ {'EmployeeID': '1', 'Name': 'John Doe', 'Department': 'HR', 'JoinDate': '2014-05-10', 'Salary': '50000'}, {'EmployeeID': '2', 'Name': 'Jane Smith', 'Department': 'IT', 'JoinDate': '2010-03-15', 'Salary': 'six thousand'}, {'EmployeeID': '3', 'Name': 'Jim Brown', 'Department': 'Marketing', 'JoinDate': '2020-07-01', 'Salary': '45000'} ] test_csv_file = 'test_employees.csv' create_test_csv(test_csv_file, rows) result = calculate_average_salary(test_csv_file) assert result == 50000.0 os.remove(test_csv_file) def test_calculate_average_salary_no_employees_with_more_than_5_years(): rows = [ {'EmployeeID': '1', 'Name': 'John Doe', 'Department': 'HR', 'JoinDate': '2020-05-10', 'Salary': '50000'}, {'EmployeeID': '2', 'Name': 'Jane Smith', 'Department': 'IT', 'JoinDate': '2020-03-15', 'Salary': '60000'} ] test_csv_file = 'test_employees.csv' create_test_csv(test_csv_file, rows) result = calculate_average_salary(test_csv_file) assert result == 0.0 os.remove(test_csv_file)","solution":"import csv from datetime import datetime def calculate_average_salary(csv_file_path): Reads a CSV file and calculates the average salary of employees who have been working for more than 5 years. The CSV file should have the following columns: 'EmployeeID', 'Name', 'Department', 'JoinDate', 'Salary'. Parameters: csv_file_path (str): The path to the CSV file. Returns: float: The average salary of employees who have been working for more than 5 years. total_salary = 0 count = 0 current_date = datetime.now() with open(csv_file_path, mode='r') as file: csv_reader = csv.DictReader(file) for row in csv_reader: join_date_str = row['JoinDate'] salary_str = row['Salary'] try: join_date = datetime.strptime(join_date_str, \\"%Y-%m-%d\\") years_of_service = (current_date - join_date).days / 365.25 salary = float(salary_str) if years_of_service > 5: total_salary += salary count += 1 except (ValueError, TypeError): # Skip this row if there is a parsing error in date or salary field continue if count == 0: return 0.0 return total_salary / count"},{"question":"from typing import List, Dict def sort_employees(employees: List[Dict[str, any]]) -> List[Dict[str, any]]: Sort a list of dictionaries representing employees by age and then by name. :param employees: List of dictionaries with 'name' and 'age' keys :return: Sorted list of dictionaries >>> sort_employees([]) == [] >>> sort_employees([{\\"name\\": \\"Alice\\", \\"age\\": 30}]) == [{\\"name\\": \\"Alice\\", \\"age\\": 30}] >>> sort_employees([{\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 25}]) == [{\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"Alice\\", \\"age\\": 30}] >>> sort_employees([{\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\"}, {\\"age\\": 30}, {\\"name\\": \\"Alice\\", \\"age\\": 30}]) == [{\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"Alice\\", \\"age\\": 30}] >>> sort_employees([{\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"Dave\\", \\"age\\": 35}]) == [{\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Dave\\", \\"age\\": 35}]","solution":"from typing import List, Dict def sort_employees(employees: List[Dict[str, any]]) -> List[Dict[str, any]]: Sort a list of dictionaries representing employees by age and then by name. :param employees: List of dictionaries with 'name' and 'age' keys :return: Sorted list of dictionaries # Filter out dictionaries that don't have both 'name' and 'age' keys filtered_employees = [employee for employee in employees if 'name' in employee and 'age' in employee] # Sort first by age, then by name in case of ties sorted_employees = sorted(filtered_employees, key=lambda x: (x['age'], x['name'])) return sorted_employees"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression contained in a string and returns the result. The expression can contain integers, +, -, *, / operators, and parentheses. >>> evaluate_expression(\\"2 + 3 * 5\\") 17 >>> evaluate_expression(\\"(2 + 3) * 5\\") 25 >>> evaluate_expression(\\"10 + (3 * 5) / (2 + 3)\\") 13.0 >>> evaluate_expression(\\"10 / 0\\") \\"Error: Division by zero\\" >>> evaluate_expression(\\"10 + abc\\") \\"Error: Invalid input (name 'abc' is not defined)\\" >>> evaluate_expression(\\"((2 + 3) * (5 + 2))\\") 35 >>> evaluate_expression(\\"5 + (-2 * 3)\\") -1 >>> evaluate_expression(\\"100 / 2 / 5\\") 10.0 >>> evaluate_expression(\\"42\\") 42","solution":"def evaluate_expression(expression): Evaluates a mathematical expression contained in a string and returns the result. The expression can contain integers, +, -, *, / operators, and parentheses. try: # Evaluate the expression and return the result result = eval(expression) return result except ZeroDivisionError: return \\"Error: Division by zero\\" except Exception as e: return f\\"Error: Invalid input ({str(e)})\\""},{"question":"def total_repetitions(sets_repetitions: list[tuple[int, int]]) -> int: Calculate the total number of repetitions given a list of tuples where each tuple contains (number of sets, number of repetitions per set). Args: sets_repetitions (list of tuples): List containing pairs of (sets, repetitions per set). Returns: int: Total number of repetitions. >>> total_repetitions([(3, 12), (2, 10)]) == 56 >>> total_repetitions([(0, 12), (2, 10)]) == 20 >>> total_repetitions([(3, 0), (2, 10)]) == 20 >>> total_repetitions([(100, 5), (200, 3)]) == 1100 >>> total_repetitions([(5, 8)]) == 40 >>> total_repetitions([]) == 0","solution":"def total_repetitions(sets_repetitions): Calculate the total number of repetitions given a list of tuples where each tuple contains (number of sets, number of repetitions per set). Args: sets_repetitions (list of tuples): List containing pairs of (sets, repetitions per set). Returns: int: Total number of repetitions. total_reps = 0 for sets, reps in sets_repetitions: total_reps += sets * reps return total_reps # For the given problem # The trainer completes: # - 3 sets of 12 repetitions: 3 * 12 # - 2 sets of 10 repetitions: 2 * 10 sets_repetitions_list = [(3, 12), (2, 10)] total_reps_completed = total_repetitions(sets_repetitions_list)"},{"question":"import pandas as pd def filter_regions(df, regions): Filter the given DataFrame to only include the specified regions. Parameters: df (pd.DataFrame): The input DataFrame with MultiIndex indices. regions (list): The list of regions to filter by. Returns: pd.DataFrame: Filtered DataFrame only containing the specified regions. >>> data = {('Region1', 'A'): 10, ('Region1', 'B'): 20, ('Region2', 'A'): 30, ('Region2', 'B'): 40, ('Region3', 'A'): 50, ('Region3', 'B'): 60} >>> index = pd.MultiIndex.from_tuples(data.keys(), names=['region', 'category']) >>> df = pd.DataFrame(list(data.values()), index=index, columns=['value']) >>> filter_regions(df, ['Region1', 'Region3']) value region category Region1 A 10 B 20 Region3 A 50 B 60","solution":"import pandas as pd def filter_regions(df, regions): Filter the given DataFrame to only include the specified regions. Parameters: df (pd.DataFrame): The input DataFrame with MultiIndex indices. regions (list): The list of regions to filter by. Returns: pd.DataFrame: Filtered DataFrame only containing the specified regions. if not regions: return df return df.loc[regions]"},{"question":"def most_frequent_even(arr: List[int]) -> Tuple[int, int]: Returns the most frequent even number in the array along with its frequency. If there are no even numbers in the array, return (-1, 0). Args: arr (List[int]): The input array of integers. Returns: Tuple[int, int]: A tuple containing the most frequent even number and its frequency. Examples: >>> most_frequent_even([1, 2, 2, 3, 3, 4, 4, 4, 6]) (4, 3) >>> most_frequent_even([1, 3, 5, 7]) (-1, 0) >>> most_frequent_even([8, 8, 8, 6, 6, 6, 4]) (6, 3)","solution":"def most_frequent_even(arr): Returns the most frequent even number in the array along with its frequency. If there are no even numbers, returns (-1, 0). from collections import Counter even_count = Counter(num for num in arr if num % 2 == 0) if not even_count: return -1, 0 # Find the even number with the highest frequency most_frequent = max(even_count.items(), key=lambda x: (x[1], -x[0])) return most_frequent[0], most_frequent[1]"},{"question":"class TextBox: def __init__(self, max_length): Initialize the TextBox with a maximum length. Args: max_length (int): The maximum length for the text box. pass def add_text(self, input_text): Add text to the TextBox if it doesn't exceed the maximum length. Convert the input to uppercase. Args: input_text (str): The text to add. >>> tb = TextBox(10) >>> tb.add_text(\\"hello\\") >>> tb.text \\"HELLO\\" >>> tb.add_text(\\"world!\\") Error: Input exceeds maximum length >>> tb.text \\"HELLO\\" pass def clear(self): Clear the text in the TextBox. >>> tb = TextBox(10) >>> tb.add_text(\\"hello\\") >>> tb.clear() >>> tb.text \\"\\" pass def get_text(self): Print the current text in the TextBox. >>> tb = TextBox(10) >>> tb.add_text(\\"hello\\") >>> tb.get_text() HELLO pass def main(): tb = TextBox(10) tb.add_text(\\"hello\\") tb.get_text() tb.add_text(\\"world!\\") tb.get_text() tb.add_text(\\"python\\") tb.get_text() tb.clear() tb.get_text() main()","solution":"class TextBox: def __init__(self, max_length): self.max_length = max_length self.text = \\"\\" def add_text(self, input_text): if len(input_text) + len(self.text) <= self.max_length: self.text += input_text.upper() else: print('Error: Input exceeds maximum length') def clear(self): self.text = \\"\\" def get_text(self): print(self.text) def main(): tb = TextBox(10) tb.add_text(\\"hello\\") tb.get_text() tb.add_text(\\"world!\\") tb.get_text() tb.add_text(\\"python\\") tb.get_text() tb.clear() tb.get_text() main()"},{"question":"def longest_increasing_subsequence(arr): Given an unsorted array of integers, find the length of the longest increasing subsequence in the array. The subsequence need not be contiguous, but the order of elements must be preserved as in the original array. >>> longest_increasing_subsequence([]) == 0 >>> longest_increasing_subsequence([1]) == 1 >>> longest_increasing_subsequence([-1]) == 1 >>> longest_increasing_subsequence([1, 2]) == 2 >>> longest_increasing_subsequence([2, 1]) == 1 >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 pass","solution":"import bisect def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the array using an O(n log n) approach with dynamic programming and binary search. if not arr: return 0 # Helper list to store the smallest end elements of increasing subsequences of different lengths subseq_ends = [] for num in arr: # Find the index of the smallest element greater than or equal to \`num\` idx = bisect.bisect_left(subseq_ends, num) # If \`num\` is greater than all elements in subseq_ends, it extends the largest subsequence if idx == len(subseq_ends): subseq_ends.append(num) else: # Otherwise, replace the existing element with \`num\` to keep subseq_ends optimal subseq_ends[idx] = num # The length of the subseq_ends list is the length of the longest increasing subsequence return len(subseq_ends)"},{"question":"def clean_string(input_string: str) -> str: Takes a string as input and returns the string with all non-alphabetic characters removed and letters converted to lowercase. The order of the remaining characters is maintained. >>> clean_string(\\"Hello, World! 123\\") 'helloworld' >>> clean_string(\\"Python\\") 'python' >>> clean_string(\\"PyThOn Is FuN\\") 'pythonisfun' >>> clean_string(\\"\\") '' >>> clean_string(\\"!@#%^&*()123\\") '' >>> clean_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'abcdefghijklmnopqrstuvwxyz'","solution":"def clean_string(input_string): Takes a string as input and returns the string with all non-alphabetic characters removed and letters converted to lowercase. The order of the remaining characters is maintained. return ''.join(char.lower() for char in input_string if char.isalpha())"},{"question":"def longest_unique_substring(s): Calculate the length of the longest substring with all unique characters. Args: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. Examples: >>> longest_unique_substring(\\"abrkaabcdefghijjxxx\\") 10 >>> longest_unique_substring(\\"geeksforgeeks\\") 7 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"bbbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"dvdf\\") 3 # Include your code here","solution":"def longest_unique_substring(s): Calculate the length of the longest substring with all unique characters. Args: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. if not s: return 0 max_length = 0 start = 0 seen_chars = {} for end in range(len(s)): if s[end] in seen_chars and seen_chars[s[end]] >= start: start = seen_chars[s[end]] + 1 seen_chars[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def minPathSum(grid: List[List[int]]) -> int: Compute the minimum path sum for a given m x n grid. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) 6","solution":"def minPathSum(grid): Compute the minimum path sum for a given m x n grid. :param grid: List of Lists containing non-negative numbers :return: Minimum path sum from top-left to bottom-right corner if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row for j in range(1, n): grid[0][j] += grid[0][j - 1] # Initialize the first column for i in range(1, m): grid[i][0] += grid[i - 1][0] # Compute the path sums for the rest of the grid for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[-1][-1]"},{"question":"class BankingSystem: def __init__(self): Initialzie the banking system with an empty dictionary to hold accounts. self.accounts = {} def create_account(self, id: int, name: str, initial_balance: float) -> None: Creates a new account with a unique id, a user's name, and an initial balance. >>> bank = BankingSystem() >>> bank.create_account(1, 'Alice', 1000) >>> bank.get_balance(1) 1000 def deposit(self, id: int, amount: float) -> None: Deposits a specified amount into the account with the given id. >>> bank = BankingSystem() >>> bank.create_account(1, 'Alice', 1000) >>> bank.deposit(1, 500) >>> bank.get_balance(1) 1500 def withdraw(self, id: int, amount: float) -> None: Withdraws a specified amount from the account with the given id. The operation should fail if the account has insufficient funds. >>> bank = BankingSystem() >>> bank.create_account(1, 'Alice', 1000) >>> bank.withdraw(1, 200) >>> bank.get_balance(1) 800 def transfer(self, sender_id: int, receiver_id: int, amount: float) -> None: Transfers a specified amount from the sender's account to the receiver's account. The operation should fail if the sender has insufficient funds. >>> bank = BankingSystem() >>> bank.create_account(1, 'Alice', 1000) >>> bank.create_account(2, 'Bob', 500) >>> bank.transfer(1, 2, 300) >>> bank.get_balance(1) 700 >>> bank.get_balance(2) 800 def get_balance(self, id: int) -> float: Returns the current balance of the account with the given id. >>> bank = BankingSystem() >>> bank.create_account(1, 'Alice', 1000) >>> bank.get_balance(1) 1000","solution":"class BankingSystem: def __init__(self): self.accounts = {} def create_account(self, id, name, initial_balance): if id in self.accounts: raise ValueError(\\"Account with given id already exists\\") self.accounts[id] = {'name': name, 'balance': initial_balance} def deposit(self, id, amount): if id not in self.accounts: raise ValueError(\\"Account with given id does not exist\\") if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") self.accounts[id]['balance'] += amount def withdraw(self, id, amount): if id not in self.accounts: raise ValueError(\\"Account with given id does not exist\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") if self.accounts[id]['balance'] < amount: raise ValueError(\\"Insufficient funds\\") self.accounts[id]['balance'] -= amount def transfer(self, sender_id, receiver_id, amount): if sender_id not in self.accounts: raise ValueError(\\"Sender account with given id does not exist\\") if receiver_id not in self.accounts: raise ValueError(\\"Receiver account with given id does not exist\\") if amount <= 0: raise ValueError(\\"Transfer amount must be positive\\") if self.accounts[sender_id]['balance'] < amount: raise ValueError(\\"Insufficient funds\\") self.accounts[sender_id]['balance'] -= amount self.accounts[receiver_id]['balance'] += amount def get_balance(self, id): if id not in self.accounts: raise ValueError(\\"Account with given id does not exist\\") return self.accounts[id]['balance']"},{"question":"def find_max_val(lst): Returns the maximum value from the list lst. Args: lst (List[int]): A list of integers. Returns: int: The maximum value in the list. Example: >>> lst = [4, 8, 15, 16, 23, 42] >>> find_max_val(lst) 42","solution":"def find_max_val(lst): Returns the maximum value from the list lst. max_val = lst[0] # Initialize max_val with the first element of the list for i in lst: if i > max_val: # Update max_val if current element i is greater max_val = i return max_val # Example usage lst = [4, 8, 15, 16, 23, 42] print(find_max_val(lst)) # Expected output: 42"},{"question":"from collections import deque from typing import List, Tuple class BankQueue: def __init__(self): self.vip_queue = deque() self.regular_queue = deque() def arrive(self, customer_name: str, is_vip: bool): Adds a customer to the appropriate queue based on their VIP status. pass def serve_next(self) -> str: Returns the name of the next customer to be served. If there are no more customers to serve, return None. pass def get_queue_status(self) -> Tuple[List[str], List[str]]: Returns a tuple containing two lists: the current regular and VIP queues in order. pass # Test cases def test_arrive_and_serve(): bank = BankQueue() bank.arrive(\\"Alice\\", False) bank.arrive(\\"Bob\\", True) bank.arrive(\\"Charlie\\", False) bank.arrive(\\"Dave\\", True) assert bank.serve_next() == \\"Bob\\" # VIP customer assert bank.serve_next() == \\"Dave\\" # VIP customer assert bank.serve_next() == \\"Alice\\" # Regular customer assert bank.serve_next() == \\"Charlie\\" # Regular customer assert bank.serve_next() == None # No more customers to serve def test_get_queue_status(): bank = BankQueue() bank.arrive(\\"Alice\\", False) bank.arrive(\\"Bob\\", True) bank.arrive(\\"Charlie\\", False) bank.arrive(\\"Dave\\", True) vip_queue, regular_queue = bank.get_queue_status() assert vip_queue == [\\"Bob\\", \\"Dave\\"] assert regular_queue == [\\"Alice\\", \\"Charlie\\"] def test_empty_queues(): bank = BankQueue() vip_queue, regular_queue = bank.get_queue_status() assert vip_queue == [] assert regular_queue == [] assert bank.serve_next() == None def test_only_vip_queue(): bank = BankQueue() bank.arrive(\\"Alice\\", True) bank.arrive(\\"Bob\\", True) assert bank.serve_next() == \\"Alice\\" assert bank.serve_next() == \\"Bob\\" assert bank.serve_next() == None def test_only_regular_queue(): bank = BankQueue() bank.arrive(\\"Alice\\", False) bank.arrive(\\"Bob\\", False) assert bank.serve_next() == \\"Alice\\" assert bank.serve_next() == \\"Bob\\" assert bank.serve_next() == None","solution":"from collections import deque from typing import List, Tuple class BankQueue: def __init__(self): self.vip_queue = deque() self.regular_queue = deque() def arrive(self, customer_name: str, is_vip: bool): Adds a customer to the appropriate queue based on their VIP status. if is_vip: self.vip_queue.append(customer_name) else: self.regular_queue.append(customer_name) def serve_next(self) -> str: Returns the name of the next customer to be served. If there are no more customers to serve, return None. if self.vip_queue: return self.vip_queue.popleft() elif self.regular_queue: return self.regular_queue.popleft() else: return None def get_queue_status(self) -> Tuple[List[str], List[str]]: Returns a tuple containing two lists: the current regular and VIP queues in order. return (list(self.vip_queue), list(self.regular_queue))"},{"question":"def sum_dictionary_values(input_dict: dict) -> dict: Write a Python function that accepts a dictionary where the keys are strings and the values are integers or lists of integers (which can also contain nested lists up to two levels). The function should return a new dictionary where each key maps to the sum of all integers (including nested ones) associated with that key. >>> sum_dictionary_values({'a': 5, 'd': 7}) == {'a': 5, 'd': 7} >>> sum_dictionary_values({'b': [3, 4, [1, 2]], 'c': [2, [3, 4]]}) == {'b': 10, 'c': 9} >>> sum_dictionary_values({'a': 5, 'b': [3, 4, [1, 2]], 'c': [2, [3, 4]], 'd': 7}) == {'a': 5, 'b': 10, 'c': 9, 'd': 7} >>> sum_dictionary_values({}) == {} >>> sum_dictionary_values({'a': 0, 'b': [0, 0, [0, 0]], 'c': [0, [0, 0]], 'd': 0}) == {'a': 0, 'b': 0, 'c': 0, 'd': 0}","solution":"def sum_nested_elements(nested_list): Helper function to sum all integers in a nested list structure. It can contain nested lists up to two levels. total_sum = 0 for element in nested_list: if isinstance(element, int): total_sum += element elif isinstance(element, list): for sub_element in element: if isinstance(sub_element, int): total_sum += sub_element return total_sum def sum_dictionary_values(input_dict): Returns a new dictionary where each key maps to the sum of all integers (including nested ones up to two levels) associated with that key. result = {} for key, value in input_dict.items(): if isinstance(value, int): result[key] = value elif isinstance(value, list): result[key] = sum_nested_elements(value) return result"},{"question":"def is_valid_identifier(identifier: str) -> bool: Validate a given string to determine if it is a valid identifier in Python. A Python identifier must start with a letter (a-z, A-Z) or an underscore (_), and can be followed by any number of letters, digits (0-9), or underscores. >>> is_valid_identifier('') False >>> is_valid_identifier('a_valid_identifier') True >>> is_valid_identifier('1_invalid_identifier') False >>> is_valid_identifier('invalid@identifier') False >>> is_valid_identifier('_valid_identifier') True # Your code here","solution":"import re def is_valid_identifier(identifier): Returns True if the given string is a valid Python identifier, False otherwise. A valid identifier must start with a letter (a-z, A-Z) or an underscore (_), and can be followed by letters, digits (0-9), or underscores. if not identifier: return False if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*', identifier): return True return False"},{"question":"class SocialNetwork: Simulates a simplified version of a social networking service with user profiles, friendships, and various operations. >>> sn = SocialNetwork() >>> sn.create_user_profile(1, \\"Alice\\") 'User profile created.' >>> sn.create_user_profile(1, \\"Bob\\") 'User ID already exists.' >>> sn.create_user_profile(2, \\"Bob\\") 'User profile created.' >>> sn.add_friend(1, 2) 'Friendship added.' >>> sn.add_friend(1, 3) 'One or both users do not exist.' >>> sn.add_friend(1, 1) 'A user cannot be friends with themselves.' >>> sn.list_friends(1) ['Bob'] >>> sn.list_friends(3) 'User does not exist.' >>> sn.list_friends(2) ['Alice'] >>> sn.list_friends(2) 'This user has no friends.' >>> sn.remove_friend(1, 2) 'Friendship removed.' >>> sn.remove_friend(1, 2) 'Users are not friends.' >>> sn.delete_user_profile(1) 'User profile deleted.' >>> sn.delete_user_profile(3) 'User does not exist.' def __init__(self): self.users = {} self.friendships = {} def create_user_profile(self, user_id, name): pass def add_friend(self, user_id1, user_id2): pass def list_friends(self, user_id): pass def remove_friend(self, user_id1, user_id2): pass def delete_user_profile(self, user_id): pass","solution":"class SocialNetwork: def __init__(self): self.users = {} self.friendships = {} def create_user_profile(self, user_id, name): if user_id in self.users: return \\"User ID already exists.\\" self.users[user_id] = name self.friendships[user_id] = set() return \\"User profile created.\\" def add_friend(self, user_id1, user_id2): if user_id1 not in self.users or user_id2 not in self.users: return \\"One or both users do not exist.\\" if user_id1 == user_id2: return \\"A user cannot be friends with themselves.\\" self.friendships[user_id1].add(user_id2) self.friendships[user_id2].add(user_id1) return \\"Friendship added.\\" def list_friends(self, user_id): if user_id not in self.users: return \\"User does not exist.\\" friends = list(self.friendships[user_id]) friend_names = [self.users[friend_id] for friend_id in friends] return friend_names if friends else \\"This user has no friends.\\" def remove_friend(self, user_id1, user_id2): if user_id1 not in self.users or user_id2 not in self.users: return \\"One or both users do not exist.\\" if user_id2 in self.friendships[user_id1]: self.friendships[user_id1].remove(user_id2) self.friendships[user_id2].remove(user_id1) return \\"Friendship removed.\\" return \\"Users are not friends.\\" def delete_user_profile(self, user_id): if user_id not in self.users: return \\"User does not exist.\\" for friend_id in self.friendships[user_id]: self.friendships[friend_id].remove(user_id) del self.friendships[user_id] del self.users[user_id] return \\"User profile deleted.\\""},{"question":"def longest_consecutive_subsequence(arr): Create a function that accepts an array of integers and returns the length of the longest subsequence such that elements in the subsequence are consecutive integers. The consecutive numbers can be in any order within the subsequence. Ensure the function efficiently handles large arrays and includes handling potential edge cases, such as empty arrays or arrays with a single element. >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([10]) == 1 >>> longest_consecutive_subsequence([1, 3, 5, 7]) == 1 >>> longest_consecutive_subsequence([2, 3, 4, 1]) == 4 >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2, 19, 21]) == 4 >>> longest_consecutive_subsequence([1, 1, 2, 2, 3, 3, 4, 4]) == 4 >>> longest_consecutive_subsequence([-1, 0, 1, 2, -3, -2]) == 6","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence such that elements in the subsequence are consecutive integers. if not arr: # handle empty array return 0 unique_nums = set(arr) longest_streak = 0 for num in unique_nums: if num - 1 not in unique_nums: # the start of a possible sequence current_num = num current_streak = 1 while current_num + 1 in unique_nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def longest_subarray(nums: List[int]) -> int: Write a function that takes an integer array as input and returns the length of the longest subarray where the difference between the maximum and minimum elements is at most 1. >>> longest_subarray([]) == 0 >>> longest_subarray([1]) == 1 >>> longest_subarray([2, 2, 2, 2]) == 4 >>> longest_subarray([1, 2, 2, 1, 3]) == 4 >>> longest_subarray([4, 6, 5, 3, 3, 1]) == 2 >>> longest_subarray(list(range(1, 10001))) == 2 >>> longest_subarray([1, 2, 2, 1, 3, 7, 8, 8, 7]) == 4","solution":"def longest_subarray(nums): Returns the length of the longest subarray where the difference between the maximum and minimum element is at most 1. if not nums: return 0 # Initiate pointers and a dictionary to keep track of the frequency of numbers left = 0 max_len = 0 count = {} for right in range(len(nums)): count[nums[right]] = count.get(nums[right], 0) + 1 # If the window's max difference exceeds 1, shrink the window from the left while max(count.keys()) - min(count.keys()) > 1: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def cumulative_sum(nums: list) -> list: Returns a new list with the cumulative sum of the elements. Args: nums (list): A list of integers. Returns: list: A list where each element is the cumulative sum of the elements up to that index in the original list. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([-1, 2, -3, 4]) [-1, 1, -2, 2] >>> cumulative_sum([5]) [5] >>> cumulative_sum([]) [] >>> cumulative_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10]","solution":"def cumulative_sum(nums): Returns a new list with the cumulative sum of the elements. Args: nums (list): A list of integers. Returns: list: A list where each element is the cumulative sum of the elements up to that index in the original list. cum_sum = [] current_sum = 0 for num in nums: current_sum += num cum_sum.append(current_sum) return cum_sum"},{"question":"import re def clean_string(s: str) -> str: Removes non-alphanumeric characters and converts the string to lowercase. >>> clean_string(\\"A man, a plan, a canal, Panama!\\") 'amanaplanacanalpanama' >>> clean_string(\\"Was it a car or a cat I saw?\\") 'wasitacaroracatisaw' pass def is_palindrome(s: str) -> bool: Returns True if the processed string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False pass def is_palindrome_substrings(s: str) -> list: Returns a list of all palindromic substrings within the given string. >>> set(is_palindrome_substrings(\\"racecar\\")) {'racecar', 'aceca', 'cec', 'a', 'c', 'e', 'r'} >>> set(is_palindrome_substrings(\\"aabba\\")) {'aa', 'bb', 'abba', 'a', 'b'} >>> set(is_palindrome_substrings(\\"noon\\")) {'noon', 'oo', 'n', 'o'} pass","solution":"import re def clean_string(s): Removes non-alphanumeric characters and converts the string to lowercase. cleaned = re.sub(r'[^a-zA-Z0-9]', '', s) return cleaned.lower() def is_palindrome(s): Returns True if the processed string is a palindrome, False otherwise. cleaned = clean_string(s) return cleaned == cleaned[::-1] def is_palindrome_substrings(s): Returns a list of all palindromic substrings within the given string. def expand_around_center(s, left, right): palindromes = [] while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.append(s[left:right+1]) left -= 1 right += 1 return palindromes result = [] for i in range(len(s)): result.extend(expand_around_center(s, i, i)) # Odd length palindromes result.extend(expand_around_center(s, i, i+1)) # Even length palindromes return list(set(result)) # Removing duplicates"},{"question":"from typing import List def most_frequent(lst: List[int]) -> int: Returns the most frequent element in the list. If there are multiple elements with the same highest frequency, returns the smallest element among them. >>> most_frequent([1, 3, 1, 3, 2, 1]) 1 >>> most_frequent([3, 3, 1, 3, 2, 1]) 3 >>> most_frequent([1, 1, 2, 2]) 1 >>> most_frequent([4, 5, 6, 7]) 4 >>> try: ... most_frequent([]) ... except ValueError as e: ... str(e) 'The list must not be empty' >>> most_frequent([101, 102, 101, 102, 103, 101]) 101","solution":"from typing import List from collections import Counter def most_frequent(lst: List[int]) -> int: Returns the most frequent element in the list. If there are multiple elements with the same highest frequency, returns the smallest element among them. if not lst: raise ValueError(\\"The list must not be empty\\") frequency = Counter(lst) max_freq = max(frequency.values()) most_frequent_elements = [key for key, val in frequency.items() if val == max_freq] return min(most_frequent_elements)"},{"question":"def flatten_and_sort(array_of_arrays: List[List[int]]) -> List[int]: Create a Python function called \`flatten_and_sort\` that takes a list of lists of integers as input and returns a single sorted list of integers. Each nested list can vary in size and may contain positive or negative integers including duplicates. Ensure your function handles edge cases like empty lists or lists containing only negative numbers efficiently. Furthermore, optimize for both time and space complexity where feasible. >>> flatten_and_sort([[3, 2, 1], [7, 8, 9, 6]]) [1, 2, 3, 6, 7, 8, 9] >>> flatten_and_sort([]) [] >>> flatten_and_sort([[]]) [] >>> flatten_and_sort([[-3, -1, -2], [-4], [-5, -6]]) [-6, -5, -4, -3, -2, -1] >>> flatten_and_sort([[4, 4, 2], [1, 3, 2]]) [1, 2, 2, 3, 4, 4] >>> flatten_and_sort([[1, -1, 3], [0, -2, 2]]) [-2,-1, 0, 1, 2, 3] >>> flatten_and_sort([[1, 1, 1], [1, 1, 1]]) [1, 1, 1, 1, 1, 1] >>> flatten_and_sort([[1], [2], [3]]) [1, 2, 3]","solution":"def flatten_and_sort(array_of_arrays): Returns a sorted list of integers flattened from the given list of lists. if not array_of_arrays: # handle if the input is an empty list return [] # Initialize an empty list to flatten the arrays flattened_list = [] # Flattening the list of lists for sublist in array_of_arrays: flattened_list.extend(sublist) # Sorting the flattened list return sorted(flattened_list)"},{"question":"def filter_and_sort_strings(strings: List[str]) -> List[str]: Filters out any strings that contain non-alphabetic characters and returns the list of filtered strings in sorted order. :param list strings: List of strings to be filtered and sorted. :return: List of filtered and sorted strings containing only alphabetic characters. :rtype: list >>> filter_and_sort_strings(['abc', '123', 'hello1', 'world', 'test!']) ['abc', 'world'] >>> filter_and_sort_strings(['abc', 'world', 'hello']) ['abc', 'hello', 'world'] >>> filter_and_sort_strings(['abc', 'DEF', 'ghi']) ['DEF', 'abc', 'ghi'] >>> filter_and_sort_strings(['123', 'hello1', 'test!']) [] >>> filter_and_sort_strings([]) [] >>> filter_and_sort_strings(['valid']) ['valid'] >>> filter_and_sort_strings(['abc', '1A2b3C', 'Def', 'ghi!']) ['Def', 'abc']","solution":"def filter_and_sort_strings(strings): Filters out any strings that contain non-alphabetic characters and returns the list of filtered strings in sorted order. :param list strings: List of strings to be filtered and sorted. :return: List of filtered and sorted strings containing only alphabetic characters. :rtype: list # Filter strings that contain only alphabetic characters filtered_strings = [s for s in strings if s.isalpha()] # Sort the filtered list sorted_filtered_strings = sorted(filtered_strings) return sorted_filtered_strings"},{"question":"def max_subarray_sum(nums): Find the contiguous subarray with the largest sum and return this sum along with the start and end indices. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) (6, 3, 6) >>> max_subarray_sum([1]) (1, 0, 0) >>> max_subarray_sum([-5]) (-5, 0, 0) >>> max_subarray_sum([1, 2, 3, 4]) (10, 0, 3) >>> max_subarray_sum([-1, -2, -3, -4]) (-1, 0, 0) >>> max_subarray_sum([1, -3, 2, 1, -1, 3, -2]) (5, 2, 5) >>> nums = [x for x in range(-5000, 5000)] >>> max_subarray_sum(nums) (12497500, 5000, 9999)","solution":"def max_subarray_sum(nums): Find the contiguous subarray with the largest sum and return this sum along with the start and end indices. max_sum = current_sum = nums[0] start = end = temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, start, end"},{"question":"def transpose(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given 2D matrix. >>> transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose([[1]]) [[1]] def test_transpose_square_matrix(): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] expected = [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert transpose(matrix) == expected def test_transpose_rectangular_matrix(): matrix = [[1, 2], [3, 4], [5, 6]] expected = [[1, 3, 5], [2, 4, 6]] assert transpose(matrix) == expected def test_transpose_single_element_matrix(): matrix = [[1]] expected = [[1]] assert transpose(matrix) == expected def test_transpose_single_row_matrix(): matrix = [[1, 2, 3]] expected = [[1], [2], [3]] assert transpose(matrix) == expected def test_transpose_single_column_matrix(): matrix = [[1], [2], [3]] expected = [[1, 2, 3]] assert transpose(matrix) == expected def test_transpose_empty_matrix(): matrix = [] expected = [] assert transpose(matrix) == expected def test_transpose_large_matrix(): matrix = [[i + j * 1000 for i in range(1000)] for j in range(1000)] expected = [[i + j for j in range(0, 1000000, 1000)] for i in range(1000)] assert transpose(matrix) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def transpose(matrix): Returns the transpose of the given 2D matrix. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) transposed_matrix = [] for col in range(cols): new_row = [] for row in range(rows): new_row.append(matrix[row][col]) transposed_matrix.append(new_row) return transposed_matrix"},{"question":"def create_schema(): Create the database schema for a library management system. def insert_sample_data(): Insert sample data into the library management system. def query_overdue_books(user_id: int): Query overdue books for a given user, displaying book details and due date.","solution":"def create_schema(): schema = CREATE TABLE Users ( user_id INT PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) UNIQUE, phone VARCHAR(15), address TEXT ); CREATE TABLE Books ( isbn VARCHAR(13) PRIMARY KEY, title VARCHAR(255), author VARCHAR(100), genre VARCHAR(50), publication_year INT, copies_available INT ); CREATE TABLE Loans ( loan_id INT PRIMARY KEY, user_id INT, isbn VARCHAR(13), date_borrowed DATE, due_date DATE, returned_date DATE, FOREIGN KEY (user_id) REFERENCES Users(user_id), FOREIGN KEY (isbn) REFERENCES Books(isbn) ); return schema def insert_sample_data(): sample_data = INSERT INTO Users (user_id, name, email, phone, address) VALUES (1, 'Alice Johnson', 'alice@example.com', '1234567890', '123 Maple St'), (2, 'Bob Smith', 'bob@example.com', '0987654321', '456 Oak St'); INSERT INTO Books (isbn, title, author, genre, publication_year, copies_available) VALUES ('978-3-16-148410-0', 'The Great Gatsby', 'F. Scott Fitzgerald', 'Fiction', 1925, 3), ('978-0-14-044926-6', 'War and Peace', 'Leo Tolstoy', 'Historical Fiction', 1869, 2); INSERT INTO Loans (loan_id, user_id, isbn, date_borrowed, due_date, returned_date) VALUES (1, 1, '978-3-16-148410-0', '2023-01-01', '2023-01-15', NULL), (2, 2, '978-0-14-044926-6', '2023-01-10', '2023-01-24', '2023-01-22'); return sample_data def query_overdue_books(user_id): query = f SELECT Books.isbn, Books.title, Books.author, Loans.due_date FROM Loans JOIN Books ON Loans.isbn = Books.isbn WHERE Loans.user_id = {user_id} AND Loans.returned_date IS NULL AND Loans.due_date < CURRENT_DATE; return query"},{"question":"def is_valid_palindrome(s: str) -> bool: Write a function that takes a string as input and returns a boolean indicating whether the string is a valid palindrome, considering only alphanumeric characters and ignoring spaces. Do not use any library functions to manipulate the string, and ensure the function is case-insensitive. >>> is_valid_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_valid_palindrome(\\"Madam, in Eden, I'm Adam\\") == True >>> is_valid_palindrome(\\"a\\") == True >>> is_valid_palindrome(\\"\\") == True >>> is_valid_palindrome(\\"hello\\") == False >>> is_valid_palindrome(\\"This is not a palindrome.\\") == False >>> is_valid_palindrome(\\"Noon\\") == True >>> is_valid_palindrome(\\"A1B2B1a\\") == True","solution":"def is_valid_palindrome(s): Returns True if the input string is a valid palindrome, considering only alphanumeric characters and ignoring spaces. The comparison is case-insensitive. # Clean the string by removing non-alphanumeric characters and converting to lower case cleaned_s = ''.join(c.lower() for c in s if c.isalnum()) # Check if cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together from the provided list of strings, case-insensitively. :param words: List of strings to be grouped as anagrams. :return: List of lists containing grouped anagrams. >>> group_anagrams([\\"Listen\\", \\"Silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"god\\", \\"Dog\\"]) [['Listen', 'Silent', 'enlist'], ['rat', 'tar'], ['god', 'Dog']] >>> group_anagrams([\\"bAre\\", \\"aERb\\", \\"silent\\", \\"enlist\\", \\"Listen\\"]) [['bAre', 'aERb'], ['silent', 'enlist', 'Listen']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [['abc', 'bca', 'cab']] >>> group_anagrams([\\"hello\\", \\"world\\", \\"python\\"]) [['hello'], ['world'], ['python']] >>> group_anagrams([]) []","solution":"def group_anagrams(words): Groups anagrams together from the provided list of strings, case-insensitively. :param words: List of strings to be grouped as anagrams. :return: List of lists containing grouped anagrams. from collections import defaultdict anagram_map = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word.lower())) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Given an unsorted array of integers, returns the length of the longest consecutive elements sequence. The algorithm runs in O(n) complexity. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1, 2, 0, 1]) 3 >>> longest_consecutive_sequence([9, 1, -3, 2, 4, 8, 3, -1, 6, -2, -4, 7]) 4 >>> longest_consecutive_sequence([1, 1, 1, 1]) 1 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([10, 5, 6, 3, 1, 9, 8, 7, 4, 2]) 10 >>> longest_consecutive_sequence([-1, -9, -5, -8, -2, -3, -7, -4, -6]) 9 >>> longest_consecutive_sequence([-1, -2, 0, 1, 2]) 5 >>> longest_consecutive_sequence([0, 0, 0, -1, 1]) 3 >>> longest_consecutive_sequence([5, 2, 99, 3, 100, 4, 101, 102]) 4 >>> longest_consecutive_sequence([10, 5, 101, 52, 11, 12, 1, 100, 13]) 4 >>> longest_consecutive_sequence([1, 2, 2, 2, 3]) 3 >>> longest_consecutive_sequence([1, 2, 2, 0, 2, 2]) 3 >>> longest_consecutive_sequence([1, 1, 1, 1, 1]) 1 >>> longest_consecutive_sequence(list(range(0, 100000))) 100000","solution":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Given an unsorted array of integers, returns the length of the longest consecutive elements sequence. The algorithm runs in O(n) complexity. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only start counting if it's the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def fibonacci(n: int) -> int: Write a function that, given an integer \`n\`, returns the nth Fibonacci number. The function should be efficient for large values of \`n\` (up to 10^4) and should use dynamic programming or matrix exponentiation to ensure optimal performance. Avoid using simple recursion due to its exponential time complexity. The Fibonacci sequence is defined as follows: \`F(0) = 0\`, \`F(1) = 1\`, and \`F(n) = F(n-1) + F(n-2)\` for \`n >= 2\`. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040 >>> fibonacci(50) 12586269025 >>> fibonacci(100) 354224848179261915075 >>> fibonacci(200) 280571172992510140037611932413038677189525 >>> fibonacci(-10) 0 # Assuming non-positive values return 0","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 # Using dynamic programming to store previous Fibonacci numbers fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression given as a string, implementing order of operations. Parameters: expression (str): The mathematical expression containing non-negative integers and operators +, -, *, / Returns: int: The evaluated result of the expression. >>> evaluate_expression(\\"3+5\\") == 8 >>> evaluate_expression(\\"10-2\\") == 8 >>> evaluate_expression(\\"6*3\\") == 18 >>> evaluate_expression(\\"8/2\\") == 4 >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"10+6/2-4\\") == 9 >>> evaluate_expression(\\"5*2+1\\") == 11 >>> evaluate_expression(\\"10-4*2\\") == 2 >>> evaluate_expression(\\"2+3*4-5\\") == 9 >>> evaluate_expression(\\"10-4/2*3\\") == 4 >>> evaluate_expression(\\"5+2*5/5-2\\") == 5 >>> evaluate_expression(\\"1+2*3-4/2\\") == 5","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression given as a string, implementing order of operations. Parameters: expression (str): The mathematical expression containing non-negative integers and operators +, -, *, / Returns: int: The evaluated result of the expression. import re # Helper function to apply operator between two numbers def apply_operator(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return first // second # use integer division # Precedence and associativity of operators precedence = {'+': 1, '-': 1, '*': 2, '/': 2} # Parse into tokens (numbers and operators) tokens = re.findall(r'd+|[+-*/]', expression) values = [] ops = [] for token in tokens: if token.isdigit(): values.append(int(token)) else: while (ops and precedence[ops[-1]] >= precedence[token]): op = ops.pop() second = values.pop() first = values.pop() values.append(apply_operator(op, second, first)) ops.append(token) while ops: op = ops.pop() second = values.pop() first = values.pop() values.append(apply_operator(op, second, first)) return values[0]"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Determine the length of the longest substring that can be rearranged to form a palindrome. Characters in the input string should be considered case-insensitively. Examples: >>> longest_palindromic_substring_length('abccccdd') == 7 >>> longest_palindromic_substring_length('aabb') == 4 >>> longest_palindromic_substring_length('racecar') == 7 >>> longest_palindromic_substring_length('abcdef') == 1 >>> longest_palindromic_substring_length('AaBb') == 4 >>> longest_palindromic_substring_length('a') == 1 >>> longest_palindromic_substring_length('') == 0","solution":"def longest_palindromic_substring_length(s): from collections import Counter # Convert string to lowercase to handle case insensitivity s = s.lower() # Count the frequency of each character char_count = Counter(s) length = 0 odd_found = False # Calculate the length of the longest palindromic substring for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True # If we found at least one character with an odd count, we can put one # of those in the center of the palindrome to maximize the length if odd_found: length += 1 return length"},{"question":"def manage_inventory(transactions): Takes a list of transactions and outputs the remaining inventory for each item. transactions: list of tuples (item_name, quantity, transaction_type) transaction_type: \\"purchase\\" or \\"sale\\" >>> manage_inventory([(\\"apple\\", 10, \\"purchase\\")]) {'apple': 10} >>> manage_inventory([(\\"apple\\", 10, \\"purchase\\"), (\\"apple\\", 5, \\"sale\\")]) {'apple': 5} >>> manage_inventory([(\\"apple\\", 10, \\"purchase\\"), (\\"banana\\", 5, \\"purchase\\"), (\\"apple\\", 5, \\"sale\\")]) {'apple': 5, 'banana': 5} >>> manage_inventory([(\\"apple\\", 10, \\"foo\\")]) Traceback (most recent call last): ValueError: Invalid transaction type. Expected 'purchase' or 'sale' >>> manage_inventory([(\\"apple\\", 10, \\"purchase\\"), (\\"apple\\", 15, \\"sale\\")]) Traceback (most recent call last): ValueError: Cannot sell more apple than available in inventory >>> manage_inventory([(\\"apple\\", 0, \\"purchase\\"), (\\"banana\\", 0, \\"sale\\")]) {'apple': 0, 'banana': 0}","solution":"def manage_inventory(transactions): Takes a list of transactions and outputs the remaining inventory for each item. transactions: list of tuples (item_name, quantity, transaction_type) transaction_type: \\"purchase\\" or \\"sale\\" inventory = {} for item_name, quantity, transaction_type in transactions: if item_name not in inventory: inventory[item_name] = 0 if transaction_type == \\"purchase\\": inventory[item_name] += quantity elif transaction_type == \\"sale\\": if inventory[item_name] < quantity: raise ValueError(f\\"Cannot sell more {item_name} than available in inventory\\") inventory[item_name] -= quantity else: raise ValueError(\\"Invalid transaction type. Expected 'purchase' or 'sale'\\") return inventory"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False def filter_and_sort_primes(input_list: list) -> list: Filters the prime numbers from the input list and returns them sorted in descending order. Parameters: input_list (list): A list of integers Returns: list: A list of prime numbers sorted in descending order or an error message if input list contains non-integer values. >>> filter_and_sort_primes([10, 3, 5, 7, 9, 11, 2]) [11, 7, 5, 3, 2] >>> filter_and_sort_primes([10, 4, 16, 20, 25, 33, 18]) [] >>> filter_and_sort_primes([-1, 0, 1, 2]) [2] >>> filter_and_sort_primes([]) [] >>> filter_and_sort_primes([10, 'a', 5, 7]) \\"Error: Input list contains non-integer values.\\" >>> filter_and_sort_primes([10, 5.5, 7]) \\"Error: Input list contains non-integer values.\\"","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def filter_and_sort_primes(input_list): Filters the prime numbers from the input list and returns them sorted in descending order. Parameters: input_list (list): A list of integers Returns: list: A list of prime numbers sorted in descending order if not all(isinstance(i, int) for i in input_list): return \\"Error: Input list contains non-integer values.\\" prime_list = [num for num in input_list if is_prime(num)] return sorted(prime_list, reverse=True)"},{"question":"def unique_substrings_no_repeats(s: str) -> list[tuple[str, int]]: Returns a list of tuples containing all unique substrings without repeating characters and their starting indices. >>> unique_substrings_no_repeats(\\"abcabcbb\\") [ ('a', 0), ('ab', 0), ('abc', 0), ('b', 1), ('bc', 1), ('bca', 1), ('c', 2), ('ca', 2), ('cab', 2), ('a', 3), ('ab', 3), ('abc', 3), ('b', 4), ('bc', 4), ('c', 5), ('cb', 5), ('b', 6), ('b', 7) ] >>> unique_substrings_no_repeats(\\"a\\") [('a', 0)] >>> unique_substrings_no_repeats(\\"abcdef\\") [ ('a', 0), ('ab', 0), ('abc', 0), ('abcd', 0), ('abcde', 0), ('abcdef', 0), ('b', 1), ('bc', 1), ('bcd', 1), ('bcde', 1), ('bcdef', 1), ('c', 2), ('cd', 2), ('cde', 2), ('cdef', 2), ('d', 3), ('de', 3), ('def', 3), ('e', 4), ('ef', 4), ('f', 5) ] >>> unique_substrings_no_repeats(\\"aaaaa\\") [('a', 0), ('a', 1), ('a', 2), ('a', 3), ('a', 4)]","solution":"def unique_substrings_no_repeats(s): Returns a list of tuples containing all unique substrings without repeating characters and their starting indices. n = len(s) substrings = [] for i in range(n): seen = set() substring = \\"\\" for j in range(i, n): if s[j] in seen: break seen.add(s[j]) substring += s[j] substrings.append((substring, i)) return substrings # Time Complexity: O(n^2) # The two nested loops make the time complexity O(n^2) but this is somewhat optimal given that # all possible substrings must be checked once."},{"question":"from typing import List def extract_primes(nums: List[int]) -> List[int]: Write a function in Python that takes a list of integers as an input and returns a list containing only the prime numbers found in the input list. >>> extract_primes([10, 15, 3, 7, 11, 20]) [3, 7, 11] >>> extract_primes([4, 6, 8, 9, 10]) [] # Unit Tests def test_extract_primes_example_1(): assert extract_primes([10, 15, 3, 7, 11, 20]) == [3, 7, 11] def test_extract_primes_example_2(): assert extract_primes([4, 6, 8, 9, 10]) == [] def test_extract_primes_single_prime(): assert extract_primes([2]) == [2] def test_extract_primes_single_non_prime(): assert extract_primes([4]) == [] def test_extract_primes_large_primes(): assert extract_primes([101, 103, 107, 109, 113]) == [101, 103, 107, 109, 113] def test_extract_primes_mixed(): assert extract_primes([1, 2, 3, 4, 5, 79, 81, 83]) == [2, 3, 5, 79, 83] def test_extract_primes_no_elements(): assert extract_primes([]) == [] def test_extract_primes_large_input(): large_input = list(range(1, 1001)) expected_primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 ] assert extract_primes(large_input) == expected_primes","solution":"def is_prime(num): Helper function that returns True if the number is prime, otherwise False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def extract_primes(nums): Function that takes a list of integers and returns a list of prime numbers found in the input list. return [num for num in nums if is_prime(num)]"},{"question":"def longest_vowel_substring(s: str) -> str: Returns the longest substring that contains only vowels. If there are multiple substrings with the same maximum length, return the first one. Parameters: s (str): Input string Returns: str: Longest substring containing only vowels >>> longest_vowel_substring(\\"earthproblem\\") 'ea' >>> longest_vowel_substring(\\"rhythm\\") '' >>> longest_vowel_substring(\\"aeiou\\") 'aeiou' >>> longest_vowel_substring(\\"hellothere\\") 'e' >>> longest_vowel_substring(\\"beautifully\\") 'eau' >>> longest_vowel_substring(\\"bootaudio\\") 'oo' >>> longest_vowel_substring(\\"\\") '' >>> longest_vowel_substring(\\"a\\") 'a' >>> longest_vowel_substring(\\"b\\") ''","solution":"def longest_vowel_substring(s): Returns the longest substring that contains only vowels. If there are multiple substrings with the same maximum length, return the first one. Parameters: s (str): Input string Returns: str: Longest substring containing only vowels vowels = set('aeiou') max_length = 0 max_substring = \\"\\" current_length = 0 current_substring = \\"\\" for char in s: if char in vowels: current_length += 1 current_substring += char if current_length > max_length: max_length = current_length max_substring = current_substring else: current_length = 0 current_substring = \\"\\" return max_substring"},{"question":"from typing import List from collections import Counter def top_k_frequent_elements(arr: List[int], k: int) -> List[int]: Write a function that takes an integer array and an integer k as input and returns an array of the k most frequent elements. The returned elements must be in ascending order. If there are multiple numbers with the same frequency, the smaller numbers should appear first. >>> top_k_frequent_elements([1,1,1,2,2,3], 2) [1, 2] >>> top_k_frequent_elements([4,4,4,1,1,2,2], 1) [4] >>> top_k_frequent_elements([], 1) ValueError: Input array is empty >>> top_k_frequent_elements([1, 2, 3], 4) ValueError: k cannot be greater than the length of the array if not arr: raise ValueError(\\"Input array is empty\\") if k > len(arr): raise ValueError(\\"k cannot be greater than the length of the array\\") frequency = Counter(arr) sorted_elements = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) return [element for element, freq in sorted_elements[:k]]","solution":"from collections import Counter def top_k_frequent_elements(arr, k): Returns an array of the k most frequent elements from the given array. The returned elements must be in ascending order. if not arr: raise ValueError(\\"Input array is empty\\") if k > len(arr): raise ValueError(\\"k cannot be greater than the length of the array\\") frequency = Counter(arr) sorted_elements = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) return [element for element, freq in sorted_elements[:k]]"},{"question":"import pandas as pd def analyze_sales_data(file_path, start_date=None, end_date=None, region=None): Analyzes sales data from a CSV file. :param file_path: Path to the CSV file containing sales data. :param start_date: Optional start date to filter the sales data (inclusive). :param end_date: Optional end date to filter the sales data (inclusive). :param region: Optional sales region to filter the sales data. :return: A dictionary with total sales for each category and top 3 best-selling products for each category. >>> analyze_sales_data('test_sales_data.csv') {'total_sales_by_category': {'Electronics': 2700, 'Furniture': 1200}, 'top_3_products_by_category': {'Electronics': [{'product_name': 'Laptop', 'sales_amount': 1500}, {'product_name': 'Smartphone', 'sales_amount': 1000}, {'product_name': 'Smartwatch', 'sales_amount': 200}], 'Furniture': [{'product_name': 'Sofa', 'sales_amount': 800}, {'product_name': 'Table', 'sales_amount': 300}, {'product_name': 'Chair', 'sales_amount': 100}]}} >>> analyze_sales_data('test_sales_data.csv', region='South') {'total_sales_by_category': {'Furniture': 1200}, 'top_3_products_by_category': {'Furniture': [{'product_name': 'Sofa', 'sales_amount': 800}, {'product_name': 'Table', 'sales_amount': 300}, {'product_name': 'Chair', 'sales_amount': 100}]}} >>> analyze_sales_data('test_sales_data.csv', start_date='2022-01-02', end_date='2022-01-04') {'total_sales_by_category': {'Electronics': 1700, 'Furniture': 400}, 'top_3_products_by_category': {'Electronics': [{'product_name': 'Laptop', 'sales_amount': 1500}, {'product_name': 'Smartwatch', 'sales_amount': 200}], 'Furniture': [{'product_name': 'Table', 'sales_amount': 300}, {'product_name': 'Chair', 'sales_amount': 100}]}} >>> analyze_sales_data('non_existent_file.csv') {} >>> analyze_sales_data('empty_test_sales_data.csv') {}","solution":"import pandas as pd def analyze_sales_data(file_path, start_date=None, end_date=None, region=None): Analyzes sales data from a CSV file. :param file_path: Path to the CSV file containing sales data. :param start_date: Optional start date to filter the sales data (inclusive). :param end_date: Optional end date to filter the sales data (inclusive). :param region: Optional sales region to filter the sales data. :return: A dictionary with total sales for each category and top 3 best-selling products for each category. try: # Load data from CSV df = pd.read_csv(file_path) # Handle missing values by dropping rows with NaNs in crucial columns df.dropna(subset=['category', 'product_name', 'sales_amount', 'sales_date', 'sales_region'], inplace=True) # Ensure no negative sales figures df = df[df['sales_amount'] >= 0] # Filter by date range if provided if start_date: df = df[df['sales_date'] >= start_date] if end_date: df = df[df['sales_date'] <= end_date] # Filter by region if provided if region: df = df[df['sales_region'] == region] # Calculate total sales for each product category total_sales_by_category = df.groupby('category')['sales_amount'].sum() # Identify top 3 best-selling products for each category top_products = df.groupby(['category', 'product_name'])['sales_amount'].sum().reset_index() top_products = top_products.sort_values(['category', 'sales_amount'], ascending=[True, False]) top_3_products_by_category = top_products.groupby('category').head(3) # Convert the results to dictionary format result = { \\"total_sales_by_category\\": total_sales_by_category.to_dict(), \\"top_3_products_by_category\\": top_3_products_by_category.groupby('category').apply( lambda x: x[['product_name', 'sales_amount']].to_dict('records')).to_dict() } return result except FileNotFoundError as e: print(f\\"File not found: {e}\\") return {} except pd.errors.EmptyDataError as e: print(f\\"Empty CSV file: {e}\\") return {}"},{"question":"def detect_and_remove_cycles(graph): Detects and removes cycles in a directed graph. :param graph: A dictionary representing a directed graph where keys are nodes and values are lists of adjacent nodes. :return: A directed graph with cycles removed. # Unit tests def test_small_graph_no_cycle(): graph = { 'A': ['B'], 'B': ['C'], 'C': [] } expected = { 'A': ['B'], 'B': ['C'], 'C': [] } assert detect_and_remove_cycles(graph) == expected def test_small_graph_with_cycle(): graph = { 'A': ['B'], 'B': ['C'], 'C': ['A'] } expected = { 'A': ['B'], 'B': ['C'], 'C': [] } assert detect_and_remove_cycles(graph) == expected def test_medium_graph_with_multiple_cycles(): graph = { 'A': ['B'], 'B': ['C', 'D'], 'C': ['A', 'E'], 'D': ['E'], 'E': ['B'] } # One possible valid removal to avoid cycles expected = { 'A': ['B'], 'B': ['C', 'D'], 'C': ['E'], 'D': ['E'], 'E': [] } assert detect_and_remove_cycles(graph) == expected def test_disconnected_graph(): graph = { 'A': ['B'], 'B': [], 'C': ['D'], 'D': ['C'] } expected = { 'A': ['B'], 'B': [], 'C': ['D'], 'D': [] } assert detect_and_remove_cycles(graph) == expected def test_graph_with_self_loop(): graph = { 'A': ['A'], 'B': ['C'], 'C': ['D'], 'D': [] } expected = { 'A': [], 'B': ['C'], 'C': ['D'], 'D': [] } assert detect_and_remove_cycles(graph) == expected","solution":"def detect_and_remove_cycles(graph): Detects and removes cycles in a directed graph. :param graph: A dictionary representing a directed graph where keys are nodes and values are lists of adjacent nodes. :return: A directed graph with cycles removed. from collections import defaultdict, deque # Helper function to perform DFS and detect cycles def dfs(node, visited, rec_stack, graph, edges_to_remove): visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack, graph, edges_to_remove): edges_to_remove.append((node, neighbor)) elif rec_stack[neighbor]: edges_to_remove.append((node, neighbor)) rec_stack[node] = False return False nodes = list(graph.keys()) visited = {node: False for node in nodes} rec_stack = {node: False for node in nodes} edges_to_remove = [] # Detect cycles and record edges to remove for node in nodes: if not visited[node]: dfs(node, visited, rec_stack, graph, edges_to_remove) # Remove the recorded edges from the graph for u, v in edges_to_remove: graph[u].remove(v) return graph # Example usage: graph = { 'A': ['B'], 'B': ['C', 'D'], 'C': ['A', 'E'], 'D': ['E'], 'E': ['B'] } # This will modify the input graph by removing cycles print(detect_and_remove_cycles(graph))"},{"question":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_last(head: Node, k: int) -> Node: Removes the k-th last element from a singly linked list. >>> head = Node(1, Node(2, Node(3, Node(4, Node(5))))) >>> k = 2 >>> new_head = remove_kth_last(head, k) >>> list_to_values(new_head) [1, 2, 3, 5] >>> head = Node(1, Node(2, Node(3, Node(4, Node(5))))) >>> k = 5 >>> new_head = remove_kth_last(head, k) >>> list_to_values(new_head) [2, 3, 4, 5]","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_last(head: Node, k: int) -> Node: Removes the k-th last element from a singly linked list. dummy = Node(0) dummy.next = head first, second = dummy, dummy # Move the first pointer so that there is a gap of k between first and second for _ in range(k + 1): first = first.next # Move both pointers until first reaches the end of the list while first: first = first.next second = second.next # Now second points to the (k+1)-th last node, i.e., the node before the node to be removed second.next = second.next.next if second.next else None return dummy.next"},{"question":"def process_strings(strings): This function receives a list of strings and returns a new list with the strings reversed and in uppercase if the original string length is greater than 4. If the string length is 4 or less, the string is returned unchanged. Non-string inputs are handled gracefully and returned as-is. :param strings: List of strings :return: New list with processed strings Examples: >>> process_strings([\\"hello\\", \\"world\\", \\"test\\", \\"python\\", \\"a\\"]) ['OLLEH', 'DLROW', 'test', 'NOHTYP', 'a'] >>> process_strings([\\"hello\\", 123, \\"test\\", [], \\"python\\", None]) ['OLLEH', 123, 'test', [], 'NOHTYP', None] >>> process_strings([\\"\\", \\"a\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) ['', 'a', 'abc', 'abcd', 'EDCBA'] >>> process_strings([\\"a\\", \\"bc\\", \\"def\\", \\"ghij\\"]) ['a', 'bc', 'def', 'ghij'] >>> process_strings([\\"Hello\\", 123, \\"World!\\", \\"Python3\\"]) ['OLLEH', 123, '!DLROW', '3NOHTYP']","solution":"def process_strings(strings): This function receives a list of strings and returns a new list with the strings reversed and in uppercase if the original string length is greater than 4. If the string length is 4 or less, the string is returned unchanged. Non-string inputs are ignored. :param strings: List of strings :return: New list with processed strings result = [] for s in strings: if isinstance(s, str): if len(s) > 4: result.append(s[::-1].upper()) else: result.append(s) else: result.append(s) return result"},{"question":"class Inventory: def __init__(self): self.items = {} def add_item(self, name, quantity, price): Add a new item to the inventory with the given name, quantity, and price. If the item already exists, update the quantity and price. Raises ValueError for negative quantity or price. pass def remove_item(self, name): Remove an item from the inventory by name. Raises KeyError if the item does not exist. pass def update_quantity(self, name, quantity): Update the quantity of an existing item. Raises KeyError if the item does not exist. Raises ValueError for negative quantity. pass def total_inventory_value(self): Calculate and return the total value of the inventory. The total value is the sum of the products of quantities and prices of all items. pass def test_add_item(): inventory = Inventory() inventory.add_item(\\"Apple\\", 10, 0.5) assert inventory.items[\\"Apple\\"] == {\\"quantity\\": 10, \\"price\\": 0.5} def test_add_item_existing(): inventory = Inventory() inventory.add_item(\\"Apple\\", 10, 0.5) inventory.add_item(\\"Apple\\", 5, 0.7) assert inventory.items[\\"Apple\\"] == {\\"quantity\\": 15, \\"price\\": 0.7} def test_add_item_invalid_data(): inventory = Inventory() with pytest.raises(ValueError): inventory.add_item(\\"Apple\\", -1, 0.5) with pytest.raises(ValueError): inventory.add_item(\\"Apple\\", 1, -0.5) def test_remove_item(): inventory = Inventory() inventory.add_item(\\"Apple\\", 10, 0.5) inventory.remove_item(\\"Apple\\") assert \\"Apple\\" not in inventory.items def test_remove_item_not_found(): inventory = Inventory() with pytest.raises(KeyError): inventory.remove_item(\\"Apple\\") def test_update_quantity(): inventory = Inventory() inventory.add_item(\\"Apple\\", 10, 0.5) inventory.update_quantity(\\"Apple\\", 15) assert inventory.items[\\"Apple\\"][\\"quantity\\"] == 15 def test_update_quantity_not_found(): inventory = Inventory() with pytest.raises(KeyError): inventory.update_quantity(\\"Apple\\", 15) def test_update_quantity_invalid_data(): inventory = Inventory() inventory.add_item(\\"Apple\\", 10, 0.5) with pytest.raises(ValueError): inventory.update_quantity(\\"Apple\\", -1) def test_total_inventory_value(): inventory = Inventory() inventory.add_item(\\"Apple\\", 10, 0.5) inventory.add_item(\\"Banana\\", 20, 0.2) assert inventory.total_inventory_value() == 10 * 0.5 + 20 * 0.2 # Intentional logical error in the user's code context: def erroneous_code_snippet(): inventory = {} def add_item(name, quantity, price): inventory[name] = {\\"quantity\\": quantity, \\"price\\": price} def update_quantity(name, quantity): if name in inventory: inventory[name][\\"quantity\\"] = quantity def total_inventory_value(): total_value = 0 for item in inventory: # Logical error here total_value += item[\\"quantity\\"] * item[\\"price\\"] return total_value add_item(\\"Apple\\", 10, 0.5) update_quantity(\\"Apple\\", 15) return total_inventory_value() def test_erroneous_code_snippet(): with pytest.raises(TypeError): # We expect a TypeError because item is a string (key), not a dict erroneous_code_snippet()","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name, quantity, price): if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price must be non-negative\\") if name in self.items: self.items[name]['quantity'] += quantity self.items[name]['price'] = price else: self.items[name] = {\\"quantity\\": quantity, \\"price\\": price} def remove_item(self, name): if name not in self.items: raise KeyError(f\\"Item '{name}' not found in inventory\\") del self.items[name] def update_quantity(self, name, quantity): if name not in self.items: raise KeyError(f\\"Item '{name}' not found in inventory\\") if quantity < 0: raise ValueError(\\"Quantity must be non-negative\\") self.items[name]['quantity'] = quantity def total_inventory_value(self): return sum(item['quantity'] * item['price'] for item in self.items.values())"},{"question":"from typing import List from functools import reduce def unique_positive_product(lst: List[int]) -> int: Write a Python function named \`unique_positive_product\` that takes a list of integers as input and returns the product of all the unique positive integers in the list. If there are no positive integers, the function should return 1. To test your understanding, first implement the solution using a standard loop and conditional logic. Then, further validate your grasp by solving the problem using Python's built-in functions like \`filter\`, \`map\`, and \`functools.reduce\`. >>> unique_positive_product([1, 2, 3, 4, -1, -2, 4]) 24 >>> unique_positive_product([-1, -2, -3, -4]) 1 >>> unique_positive_product([0, 0, 0, 0]) 1 >>> unique_positive_product([2, 2, 3, 3]) 6 >>> unique_positive_product([5, 3, 9]) 135 >>> unique_positive_product([0, 0, 3, 7]) 21 >>> unique_positive_product([]) 1","solution":"from functools import reduce def unique_positive_product(lst): Returns the product of all unique positive integers in the list. If there are no positive integers, returns 1. Parameters: lst (list of int): The input list of integers. Returns: int: The product of unique positive integers. # Using a set to store unique positive integers unique_positives = set(x for x in lst if x > 0) # If there are no positive integers, return 1 if not unique_positives: return 1 # Calculate the product of unique positive integers return reduce(lambda x, y: x * y, unique_positives)"},{"question":"import re from collections import Counter def most_frequent_word(s: str) -> str: Create a function that takes a string as input and returns the word that appears most frequently in the string. In case of a tie, return the word that appears first in the input string. Words are case-insensitive and punctuation should be ignored. >>> most_frequent_word(\\"hello\\") \\"hello\\" >>> most_frequent_word(\\"this is a test test\\") \\"test\\" >>> most_frequent_word(\\"Test test TEST\\") \\"test\\" >>> most_frequent_word(\\"hello, hello; hello!\\") \\"hello\\" >>> most_frequent_word(\\"apple banana apple banana\\") \\"apple\\" >>> most_frequent_word(\\"apple: banana, apple; banana.\\") \\"apple\\" >>> most_frequent_word(\\"\\") is None True","solution":"import re from collections import Counter def most_frequent_word(s): Returns the word that appears most frequently in the input string. If there is a tie, return the word that appears first in the input string. Words are case-insensitive and punctuation is ignored. # Convert to lower case to make it case insensitive s = s.lower() # Remove punctuation using regex words = re.findall(r'bw+b', s) # Count frequency of each word word_count = Counter(words) # Find the most common word most_common_word, most_common_count = None, 0 for word in words: if word_count[word] > most_common_count: most_common_word = word most_common_count = word_count[word] return most_common_word"},{"question":"class LibraryBook: A class representing a library book. Attributes: - title (str): The title of the book. - author (str): The author of the book. - year_published (int): The year the book was published. - isbn (str): The ISBN number of the book. def __init__(self, title='', author='', year_published=0, isbn=''): self.__title = title self.__author = author self.__year_published = year_published self.__isbn = isbn def get_title(self): Returns the title of the book. return self.__title def set_title(self, title): Sets the title of the book. self.__title = title def get_author(self): Returns the author of the book. return self.__author def set_author(self, author): Sets the author of the book. self.__author = author def get_year_published(self): Returns the year the book was published. return self.__year_published def set_year_published(self, year_published): Sets the year the book was published. self.__year_published = year_published def get_isbn(self): Returns the ISBN number of the book. return self.__isbn def set_isbn(self, isbn): Sets the ISBN number of the book. self.__isbn = isbn def __str__(self): Returns a string representation of the book, including the title, author, year published, and ISBN number. return f\\"Title: {self.__title}, Author: {self.__author}, Year Published: {self.__year_published}, ISBN: {self.__isbn}\\" # Flawed code snippet demonstrating incorrect usage def flawed_code(): book = LibraryBook() # Attempting to access private attributes directly - should use getters/setters book.__title = \\"Mistake Title\\" title = book.__title # Incorrect attribute name in setter book.set_title('The Hobbit') book.set_author_name('J.R.R. Tolkien') # Correct usage book.set_title('The Hobbit') book.set_author('J.R.R. Tolkien') book.set_year_published(1937) book.set_isbn('9780261103283') return book # Unit tests def test_default_constructor(): book = LibraryBook() assert book.get_title() == '' assert book.get_author() == '' assert book.get_year_published() == 0 assert book.get_isbn() == '' def test_parameterized_constructor(): book = LibraryBook('1984', 'George Orwell', 1949, '1234567890') assert book.get_title() == '1984' assert book.get_author() == 'George Orwell' assert book.get_year_published() == 1949 assert book.get_isbn() == '1234567890' def test_setters_and_getters(): book = LibraryBook() book.set_title('To Kill a Mockingbird') book.set_author('Harper Lee') book.set_year_published(1960) book.set_isbn('1234567891') assert book.get_title() == 'To Kill a Mockingbird' assert book.get_author() == 'Harper Lee' assert book.get_year_published() == 1960 assert book.get_isbn() == '1234567891' def test_str_method(): book = LibraryBook('Sapiens', 'Yuval Noah Harari', 2011, '0987654321') str_representation = str(book) expected_representation = \\"Title: Sapiens, Author: Yuval Noah Harari, Year Published: 2011, ISBN: 0987654321\\" assert str_representation == expected_representation def test_flawed_code(): book = flawed_code() assert book.get_title() == 'The Hobbit' assert book.get_author() == 'J.R.R. Tolkien' assert book.get_year_published() == 1937 assert book.get_isbn() == '9780261103283'","solution":"class LibraryBook: def __init__(self, title='', author='', year_published=0, isbn=''): self.__title = title self.__author = author self.__year_published = year_published self.__isbn = isbn def get_title(self): return self.__title def set_title(self, title): self.__title = title def get_author(self): return self.__author def set_author(self, author): self.__author = author def get_year_published(self): return self.__year_published def set_year_published(self, year_published): self.__year_published = year_published def get_isbn(self): return self.__isbn def set_isbn(self, isbn): self.__isbn = isbn def __str__(self): return f\\"Title: {self.__title}, Author: {self.__author}, Year Published: {self.__year_published}, ISBN: {self.__isbn}\\""},{"question":"import requests def get_weather_data(city: str, access_key: str) -> dict: Fetches and returns the temperature and humidity for a given city using the Weatherstack API. Parameters: city (str): The name of the city to query. access_key (str): The API access key. Returns: dict: A dictionary containing temperature and humidity. pass # Your code implementation here # Unit Test Example def test_get_weather_data_valid_city(monkeypatch): class MockResponse: @staticmethod def json(): return { \\"current\\": { \\"temperature\\": 20, \\"humidity\\": 50 } } @staticmethod def raise_for_status(): pass def mock_get(*args, **kwargs): return MockResponse() with monkeypatch.context() as m: m.setattr(requests, \\"get\\", mock_get) result = get_weather_data(\\"New York\\", \\"fake_key\\") assert result['temperature'] == 20 assert result['humidity'] == 50 def test_get_weather_data_invalid_city(monkeypatch): class MockResponse: @staticmethod def json(): return { \\"error\\": { \\"code\\": 615, \\"type\\": \\"request_failed\\", \\"info\\": \\"You have entered an invalid location\\" } } @staticmethod def raise_for_status(): pass def mock_get(*args, **kwargs): return MockResponse() with monkeypatch.context() as m: m.setattr(requests, \\"get\\", mock_get) with raises(ValueError, match=\\"Error parsing response: Invalid response, 'current' key not found\\"): get_weather_data(\\"InvalidCity\\", \\"fake_key\\") def test_get_weather_data_api_error(monkeypatch): def mock_get(*args, **kwargs): raise requests.exceptions.RequestException(\\"API down\\") with monkeypatch.context() as m: m.setattr(requests, \\"get\\", mock_get) with raises(ValueError, match=\\"Error fetching data from API: API down\\"): get_weather_data(\\"New York\\", \\"fake_key\\")","solution":"import requests def get_weather_data(city, access_key): Fetches and returns the temperature and humidity for a given city using the Weatherstack API. Parameters: city (str): The name of the city to query. access_key (str): The API access key. Returns: dict: A dictionary containing temperature and humidity. url = \\"http://api.weatherstack.com/current\\" params = { 'access_key': access_key, 'query': city } try: response = requests.get(url, params=params) response.raise_for_status() # Will raise HTTPError for bad responses data = response.json() if 'current' in data: temperature = data['current']['temperature'] humidity = data['current']['humidity'] return { 'temperature': temperature, 'humidity': humidity } else: raise ValueError(\\"Invalid response, 'current' key not found\\") except requests.exceptions.RequestException as e: raise ValueError(f\\"Error fetching data from API: {e}\\") except ValueError as e: raise ValueError(f\\"Error parsing response: {e}\\")"},{"question":"from typing import List def is_prime(n: int) -> bool: Determines if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list \`numbers\`. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 14, 17, 19, 21]) [11, 17, 19] >>> filter_primes([0, 1, 4, 6, 8, 9, 10]) [] >>> filter_primes([29, 31, 37, 41, 43]) [29, 31, 37, 41, 43] >>> filter_primes([101, 103, 105, 107, 109]) [101, 103, 107, 109]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False i = 3 while i * i <= n: if n % i == 0: return False i += 2 return True def filter_primes(numbers): Returns a list of prime numbers from the given list \`numbers\`. return [num for num in numbers if is_prime(num)]"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None def find_lca(root: TreeNode, n1: int, n2: int) -> TreeNode: Function to find the Lowest Common Ancestor (LCA) of two given nodes in a BST. >>> root = TreeNode(20) >>> root.left = TreeNode(10) >>> root.right = TreeNode(30) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(15) >>> root.right.left = TreeNode(25) >>> root.right.right = TreeNode(35) >>> find_lca(root, 5, 15).key 10 >>> find_lca(root, 5, 30).key 20 >>> find_lca(root, 25, 35).key 30 >>> find_lca(root, 5, 35).key 20 >>> find_lca(root, 10, 30).key 20","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None def find_lca(root, n1, n2): Function to find the Lowest Common Ancestor (LCA) of two given nodes in a BST. while root: # If both n1 and n2 are smaller than root, then LCA lies in left subtree if root.key > n1 and root.key > n2: root = root.left # If both n1 and n2 are greater than root, then LCA lies in right subtree elif root.key < n1 and root.key < n2: root = root.right else: break return root # Example # Construct the following BST # 20 # / # 10 30 # / / # 5 15 25 35 root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) root.right.left = TreeNode(25) root.right.right = TreeNode(35) # LCA of nodes 5 and 15 = 10 print(find_lca(root, 5, 15).key) # Output: 10 # LCA of nodes 5 and 30 = 20 print(find_lca(root, 5, 30).key) # Output: 20 # LCA of nodes 25 and 35 = 30 print(find_lca(root, 25, 35).key) # Output: 30"},{"question":"def maxProfit(k: int, prices: List[int]) -> int: Given a list of integers \`prices\` representing the prices of a stock on different days, find the maximum profit you can achieve by completing at most \`k\` transactions. A transaction consists of buying and then selling one share of the stock. You may assume that you cannot engage in multiple transactions at the same time, i.e., you must sell the stock before you buy again. >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(1, [2, 4, 1]) 2","solution":"def maxProfit(k, prices): if not prices or k == 0: return 0 n = len(prices) # If k is larger than n/2, we can conduct unlimited transactions if k >= n // 2: max_profit = 0 for i in range(1, n): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit # Initialize dp array dp = [[0 for _ in range(n)] for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][n - 1]"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False def filter_primes(numbers: List[int]) -> List[int]: Filter and return a list of prime numbers from the given list. >>> filter_primes([3, 4, 7, 10, 17]) [3, 7, 17] >>> filter_primes([1, 2, 3, 4, 5, 6, 7]) [2, 3, 5, 7]","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Filter and return a list of prime numbers from the given list. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List def top_k_frequent_strings(strings: List[str], k: int) -> List[str]: Design a function that takes a list of strings and an integer \`k\`, and returns a list of the \`k\` most frequently occurring strings in the list. If there are multiple strings with the same frequency, the strings should be returned in lexicographical order. >>> top_k_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"grape\\"], 2) [\\"apple\\", \\"banana\\"] >>> top_k_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"grape\\"], 3) [\\"apple\\", \\"banana\\", \\"orange\\"] pass import pytest def test_top_k_frequent_strings_basic(): assert top_k_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"grape\\"], 2) == [\\"apple\\", \\"banana\\"] def test_top_k_frequent_strings_three_elements(): assert top_k_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"grape\\"], 3) == [\\"apple\\", \\"banana\\", \\"orange\\"] def test_top_k_frequent_strings_with_ties(): assert top_k_frequent_strings([\\"apple\\", \\"banana\\", \\"cherry\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"cherry\\", \\"grape\\"], 2) == [\\"apple\\", \\"banana\\"] def test_top_k_frequent_strings_with_all_unique(): assert top_k_frequent_strings([\\"apple\\", \\"banana\\", \\"cherry\\", \\"banana\\", \\"apple\\", \\"grape\\"], 3) == [\\"apple\\", \\"banana\\", \\"cherry\\"] def test_top_k_frequent_strings_with_less_than_k(): assert top_k_frequent_strings([\\"apple\\", \\"banana\\"], 3) == [\\"apple\\", \\"banana] def test_top_k_frequent_strings_with_empty_list(): assert top_k_frequent_strings([], 3) == [] def test_top_k_frequent_strings_with_zero_k(): assert top_k_frequent_strings([\\"apple\\", \\"banana\\"], 0) == [] def test_top_k_frequent_strings_with_negative_k(): assert top_k_frequent_strings([\\"apple\\", \\"banana\\"], -1) == [] pytest.main()","solution":"from collections import Counter import heapq def top_k_frequent_strings(strings, k): Returns a list of the k most frequently occurring strings in the list. If multiple strings have the same frequency, returns them in lexicographical order. if not strings or k <= 0: return [] # Count the frequency of each string freq_counter = Counter(strings) # Use a min heap to keep track of top k frequent strings min_heap = [] for word, freq in freq_counter.items(): heapq.heappush(min_heap, (-freq, word)) # Get the most frequent k elements top_k_strings = [heapq.heappop(min_heap)[1] for _ in range(min(k, len(min_heap)))] # Sort result lexicographically top_k_strings.sort() return top_k_strings"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the input string s. Handles multiple spaces between words and removes leading and trailing spaces. Does not use the built-in split function. # Your code here # Sample input and output input_string = \\" hello world \\" output_string = reverse_words(input_string) print(output_string) # Output: \\"world hello\\" # Unit Test: def test_single_word(): assert reverse_words(\\"hello\\") == \\"hello\\" def test_multiple_words(): assert reverse_words(\\"hello world\\") == \\"world hello\\" def test_leading_and_trailing_spaces(): assert reverse_words(\\" hello world \\") == \\"world hello\\" def test_multiple_spaces_between_words(): assert reverse_words(\\"hello world\\") == \\"world hello\\" def test_only_spaces(): assert reverse_words(\\" \\") == \\"\\" def test_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_mixed_with_multiple_words_and_spaces(): assert reverse_words(\\" this is a test \\") == \\"test a is this\\"","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the input string s. Handles multiple spaces between words and removes leading and trailing spaces. def split_string(s): words = [] word = \\"\\" length = len(s) i = 0 while i < length: if s[i] != ' ': word += s[i] elif word: words.append(word) word = \\"\\" i += 1 if word: words.append(word) return words words = split_string(s) reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List, Dict, Any, Union def highest_average_grade(students: List[Dict[str, Any]]) -> Union[str, List[str]]: Returns the name of the student with the highest average grade. If there is a tie, returns a list of names sorted alphabetically. >>> highest_average_grade([ {\\"name\\": \\"Alice\\", \\"grades\\": [85, 92, 78]}, {\\"name\\": \\"Bob\\", \\"grades\\": [90, 88, 83]}, {\\"name\\": \\"Charlie\\", \\"grades\\": [95, 90, 92]} ]) 'Charlie' >>> highest_average_grade([ {\\"name\\": \\"Alice\\", \\"grades\\": [85, 92, 78]}, {\\"name\\": \\"Bob\\", \\"grades\\": [90, 88, 92]}, {\\"name\\": \\"Charlie\\", \\"grades\\": [90, 88, 92]} ]) [\\"Bob\\", \\"Charlie\\"]","solution":"from typing import List, Dict, Any, Union def highest_average_grade(students: List[Dict[str, Any]]) -> Union[str, List[str]]: Returns the name of the student with the highest average grade. If there is a tie, returns a list of names sorted alphabetically. highest_avg = -1 res = [] for student in students: avg_grade = sum(student[\\"grades\\"]) / len(student[\\"grades\\"]) if avg_grade > highest_avg: highest_avg = avg_grade res = [student[\\"name\\"]] elif avg_grade == highest_avg: res.append(student[\\"name\\"]) if len(res) == 1: return res[0] else: return sorted(res)"},{"question":"def group_even_odd(numbers: List[int]) -> dict: Groups integers by whether they are even or odd. Parameters: numbers (list): A list of integers. Returns: dict: A dictionary with keys \\"even\\" and \\"odd\\", where the values are lists of the corresponding integers. >>> group_even_odd([2, 4, 6]) {'even': [2, 4, 6], 'odd': []} >>> group_even_odd([1, 3, 5]) {'even': [], 'odd': [1, 3, 5]} >>> group_even_odd([2, 3, 4, 5, 6]) {'even': [2, 4, 6], 'odd': [3, 5]} >>> group_even_odd([]) {'even': [], 'odd': []} >>> group_even_odd([-2, -3, 0, 1]) {'even': [-2, 0], 'odd': [-3, 1]}","solution":"def group_even_odd(numbers): Groups integers by whether they are even or odd. Parameters: numbers (list): A list of integers. Returns: dict: A dictionary with keys \\"even\\" and \\"odd\\", where the values are lists of the corresponding integers. result = { \\"even\\": [num for num in numbers if num % 2 == 0], \\"odd\\": [num for num in numbers if num % 2 != 0] } return result"},{"question":"def max_contiguous_product(arr): In a given list of integers, determine the largest product that can be obtained from any three contiguous elements. If the list has fewer than three elements, return None. >>> max_contiguous_product([1, 2, 3, 4, 5]) == 60 >>> max_contiguous_product([-1, -2, -3, -4, -5]) == -6 >>> max_contiguous_product([0, 1, 2, 3, 4]) == 24 >>> max_contiguous_product([1, 2]) == None >>> max_contiguous_product([3]) == None >>> max_contiguous_product([1, -2, 3, -4, 5, -6]) == 120","solution":"def max_contiguous_product(arr): Returns the maximum product of any three consecutive integers in the list. If the list has fewer than three elements, returns None. if len(arr) < 3: return None max_product = float('-inf') for i in range(len(arr) - 2): product = arr[i] * arr[i + 1] * arr[i + 2] if product > max_product: max_product = product return max_product"},{"question":"import re from collections import defaultdict from datetime import datetime class LogAnalyzer: Develop a software module that analyses the multi-threaded event logs generated by a distributed system. This module should be capable of parsing log entries to identify and categorize various types of events, including system warnings, errors, and informational messages. Additional functionalities should include: - Detecting potential performance bottlenecks and concurrency issues such as race conditions and deadlocks. - Aggregating log data to produce visual representations like timelines and heatmaps. - Offering an interface for querying log data using both pre-defined filters and custom user-defined criteria. - Robust error handling to manage malformed log entries and other anomalies in the data. The module should be efficient and scalable, handling large volumes of log data without significant performance hits. log_pattern = re.compile( r'(?P<timestamp>d{4}-d{2}-d{2} d{2}:d{2}:d{2}),' r'(?P<thread_id>d+),' r'(?P<event_type>w+),' r'(?P<message>.*)' ) def __init__(self): self.logs = [] self.threads = defaultdict(list) self.bottlenecks = [] def parse_log(self, log_entry): Parse a log entry string and add it to the logs if well-formed. pass def categorize_logs(self): Categorize logs into warnings, errors, and informational messages. pass def detect_bottlenecks_and_issues(self): Detect potential performance bottlenecks and concurrency issues. pass def create_timeline(self): Create a timeline of events from the log entries. pass def query_logs(self, filter_func=None): Query logs using a filter function. :param filter_func: A callable that defines the filtering criteria. pass def handle_malformed_log(self, log_entry): Handle a malformed log entry. pass def add_log_entry(self, log_entry): Add a log entry to the system. pass # Test cases def test_log_parsing(): analyzer = LogAnalyzer() log_entry = \\"2023-10-10 13:45:30,1,INFO,System started\\" analyzer.add_log_entry(log_entry) assert len(analyzer.logs) == 1 assert analyzer.logs[0]['timestamp'] == datetime(2023, 10, 10, 13, 45, 30) assert analyzer.logs[0]['thread_id'] == 1 assert analyzer.logs[0]['event_type'] == 'INFO' assert analyzer.logs[0]['message'] == 'System started' def test_categorize_logs(): analyzer = LogAnalyzer() log_entries = [ \\"2023-10-10 13:45:30,1,WARNING,Low disk space\\", \\"2023-10-10 13:45:31,2,ERROR,Out of memory\\", \\"2023-10-10 13:45:32,1,INFO,Operation completed\\" ] for entry in log_entries: analyzer.add_log_entry(entry) categorized_logs = analyzer.categorize_logs() assert len(categorized_logs['warnings']) == 1 assert len(categorized_logs['errors']) == 1 assert len(categorized_logs['info']) == 1 def test_timeline_creation(): analyzer = LogAnalyzer() log_entries = [ \\"2023-10-10 13:45:30,1,INFO,System started\\", \\"2023-10-10 13:45:31,2,INFO,Operation in progress\\", \\"2023-10-10 13:45:32,1,INFO,Operation completed\\" ] for entry in log_entries: analyzer.add_log_entry(entry) timeline = analyzer.create_timeline() assert len(timeline) == 3 assert timeline[0][1] == 'INFO' assert timeline[0][2] == 'System started' assert timeline[1][2] == 'Operation in progress' assert timeline[2][2] == 'Operation completed' def test_query_logs(): analyzer = LogAnalyzer() log_entries = [ \\"2023-10-10 13:45:30,1,INFO,System started\\", \\"2023-10-10 13:45:31,1,INFO,Operation in progress\\", \\"2023-10-10 13:45:32,1,ERROR,Operation failed\\" ] for entry in log_entries: analyzer.add_log_entry(entry) errors = analyzer.query_logs(lambda log: log['event_type'] == 'ERROR') assert len(errors) == 1 assert errors[0]['message'] == 'Operation failed' thread_1_logs = analyzer.query_logs(lambda log: log['thread_id'] == 1) assert len(thread_1_logs) == 3 def test_handle_malformed_log(): analyzer = LogAnalyzer() malformed_log_entry = \\"2023-10-10 13:45:30,1\\" analyzer.add_log_entry(malformed_log_entry) assert len(analyzer.logs) == 0","solution":"import re from collections import defaultdict from datetime import datetime class LogAnalyzer: log_pattern = re.compile( r'(?P<timestamp>d{4}-d{2}-d{2} d{2}:d{2}:d{2}),' r'(?P<thread_id>d+),' r'(?P<event_type>w+),' r'(?P<message>.*)' ) def __init__(self): self.logs = [] self.threads = defaultdict(list) self.bottlenecks = [] def parse_log(self, log_entry): match = self.log_pattern.match(log_entry) if match: log_data = match.groupdict() log_data['timestamp'] = datetime.strptime(log_data['timestamp'], \\"%Y-%m-%d %H:%M:%S\\") log_data['thread_id'] = int(log_data['thread_id']) self.logs.append(log_data) self.threads[log_data['thread_id']].append(log_data) else: raise ValueError(f\\"Malformed log entry: {log_entry}\\") def categorize_logs(self): categorized_logs = { 'warnings': [], 'errors': [], 'info': [], } for log in self.logs: if log['event_type'].lower() == 'warning': categorized_logs['warnings'].append(log) elif log['event_type'].lower() == 'error': categorized_logs['errors'].append(log) elif log['event_type'].lower() == 'info': categorized_logs['info'].append(log) return categorized_logs def detect_bottlenecks_and_issues(self): # Place holder for bottleneck and concurrency issue detection pass def create_timeline(self): timeline = [] for log in self.logs: timeline.append((log['timestamp'], log['event_type'], log['message'])) timeline.sort(key=lambda x: x[0]) return timeline def query_logs(self, filter_func=None): if not filter_func: return self.logs return [log for log in self.logs if filter_func(log)] def handle_malformed_log(self, log_entry): try: self.parse_log(log_entry) except ValueError as e: print(e) def add_log_entry(self, log_entry): self.handle_malformed_log(log_entry)"},{"question":"def is_armstrong_number(num: int) -> bool: Determines if a given positive integer is an Armstrong number. An Armstrong number (also known as a narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153. Args: num (int): The positive integer to check. Returns: bool: True if the number is an Armstrong number, otherwise False. >>> is_armstrong_number(153) True >>> is_armstrong_number(9474) True >>> is_armstrong_number(123) False >>> is_armstrong_number(10) False >>> is_armstrong_number(370) True","solution":"def is_armstrong_number(num): Determines if a given positive integer is an Armstrong number. digits = list(map(int, str(num))) num_digits = len(digits) return num == sum(digit ** num_digits for digit in digits)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression given as a string. The expression can include non-negative integers, +, -, *, / operators, and parentheses. >>> evaluate_expression(\\"2+3\\") 5.0 >>> evaluate_expression(\\"5-2\\") 3.0 >>> evaluate_expression(\\"4*2\\") 8.0 >>> evaluate_expression(\\"8/2\\") 4.0 >>> evaluate_expression(\\"2+3*4\\") 14.0 >>> evaluate_expression(\\"2+3*4-8/2\\") 10.0 >>> evaluate_expression(\\"(2+3)*4\\") 20.0 >>> evaluate_expression(\\"((2+3)*4+(3-1))/2\\") 11.0 >>> evaluate_expression(\\"10/0\\") 'division by zero'","solution":"def evaluate_expression(expression): Evaluates a mathematical expression given as a string. The expression can include non-negative integers, +, -, *, / operators, and parentheses. # Use Python's eval function to safely evaluate the expression try: return eval(expression) except Exception as e: return str(e)"},{"question":"def max_subarray_sum(arr): Write a function to calculate the longest contiguous subarray sum within a given list of integers. The function should return the maximum sum possible. If all elements are negative, return the maximum value (which is the smallest negative number). Ensure that your function can handle arrays containing both positive and negative integers and perform efficiently on large input sizes. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([4]) 4 >>> max_subarray_sum([-4]) -4 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([0, 0, 0, 0, 0]) 0 >>> max_subarray_sum([1] * 1000000) 1000000 pass","solution":"def max_subarray_sum(arr): Finds the sum of the longest contiguous subarray with the maximum sum. :param arr: List of integers :return: Integer representing the maximum sum of any contiguous subarray if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def filter_employees(employees, min_age=None, min_salary=None): Takes a list of employee records and filters them based on the provided criteria: min_age and min_salary. Parameters: employees (list): List of dictionaries with each dictionary having keys 'name', 'age', and 'salary'. min_age (int, optional): Minimum age to filter employees. Defaults to None. min_salary (int, optional): Minimum salary to filter employees. Defaults to None. Returns: list: Filtered list of employees matching the criteria. pass import pytest from solution import filter_employees def test_filter_employees_min_age_and_min_salary(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 65000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 50000}, {\\"name\\": \\"David\\", \\"age\\": 40}, {\\"name\\": \\"Eve\\", \\"salary\\": 80000} ] result = filter_employees(employees, min_age=30, min_salary=60000) assert result == [{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}] def test_filter_employees_min_age_only(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 65000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 50000}, {\\"name\\": \\"David\\", \\"age\\": 40}, {\\"name\\": \\"Eve\\", \\"salary\\": 80000} ] result = filter_employees(employees, min_age=30) assert result == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 50000} ] def test_filter_employees_min_salary_only(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 65000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 50000}, {\\"name\\": \\"David\\", \\"age\\": 40}, {\\"name\\": \\"Eve\\", \\"salary\\": 80000} ] result = filter_employees(employees, min_salary=60000) assert result == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 65000} ] def test_filter_employees_no_criteria(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 65000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 50000}, {\\"name\\": \\"David\\", \\"age\\": 40}, {\\"name\\": \\"Eve\\", \\"salary\\": 80000} ] result = filter_employees(employees) assert result == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 65000}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 50000} ]","solution":"def filter_employees(employees, min_age=None, min_salary=None): Takes a list of employee records and filters them based on the provided criteria: min_age and min_salary. Parameters: employees (list): List of dictionaries with each dictionary having keys 'name', 'age', and 'salary'. min_age (int, optional): Minimum age to filter employees. Defaults to None. min_salary (int, optional): Minimum salary to filter employees. Defaults to None. Returns: list: Filtered list of employees matching the criteria. filtered_employees = [] for employee in employees: if 'age' in employee and 'salary' in employee: age_criteria = (min_age is None or employee['age'] >= min_age) salary_criteria = (min_salary is None or employee['salary'] >= min_salary) if age_criteria and salary_criteria: filtered_employees.append(employee) return filtered_employees"},{"question":"def max_subarray_sum(arr): Finds the largest sum of any contiguous subarray using Kadanes algorithm. Parameters: arr (list): A list of integers. Returns: int: The largest sum of any contiguous subarray. from max_subarray_sum import max_subarray_sum def test_max_subarray_with_positive_numbers(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_max_subarray_with_negative_numbers(): assert max_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_max_subarray_with_mixed_numbers(): assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_max_subarray_single_element(): assert max_subarray_sum([5]) == 5 def test_max_subarray_all_zero(): assert max_subarray_sum([0, 0, 0, 0, 0]) == 0 def test_max_subarray_empty(): assert max_subarray_sum([]) == 0 def test_max_subarray_with_large_numbers(): assert max_subarray_sum([100000, 100001, -1, 100000, -100000, 50000]) == 300000 def test_max_subarray_with_alternating_signs(): assert max_subarray_sum([4, -1, 2, 1]) == 6 assert max_subarray_sum([-5, 4, 6, -3, 4, -1, 2]) == 12","solution":"def max_subarray_sum(arr): Finds the largest sum of any contiguous subarray using Kadanes algorithm. Parameters: arr (list): A list of integers. Returns: int: The largest sum of any contiguous subarray. if not arr: return 0 max_so_far = arr[0] max_ending_here = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def compress_string(s: str) -> str: Compresses the given string using counts of repeated characters. Parameters: - s (str): The string to be compressed. Returns: - str: The compressed string or the original string if compressed version is not shorter. Examples: >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aaaabbbbccccddddeeee\\") \\"a4b4c4d4e4\\" >>> compress_string(\\"aabbcc\\") \\"aabbcc\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"aaaa\\") \\"a4\\" >>> compress_string(\\"abcde\\") \\"abcde\\"","solution":"def compress_string(s: str) -> str: Compresses the given string using counts of repeated characters. Parameters: - s (str): The string to be compressed. Returns: - str: The compressed string or the original string if compressed version is not shorter. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 # Add the last seen character count compressed.append(f\\"{s[-1]}{count}\\") # Generate the compressed string compressed_string = \\"\\".join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def bubble_sort(lst: List[int]) -> List[int]: Returns a list of numbers sorted in ascending order using bubble sort algorithm. >>> bubble_sort([1]) == [1] >>> bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> bubble_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] >>> bubble_sort([3, 5, 3, 2, 4, 1, 1, 2]) == [1, 1, 2, 2, 3, 3, 4, 5] >>> bubble_sort([0, -1, 3, -2, 2, 1]) == [-2, -1, 0, 1, 2, 3]","solution":"def bubble_sort(lst): Returns a list of numbers sorted in ascending order using bubble sort algorithm. n = len(lst) for i in range(n): swapped = False for j in range(0, n-i-1): if lst[j] > lst[j+1]: lst[j], lst[j+1] = lst[j+1], lst[j] swapped = True if not swapped: break return lst"},{"question":"def sunsetViews(buildings: List[int]) -> int: Returns the number of buildings with an unobstructed view of the sunset. A building has an unobstructed view if no other building to its right has a height greater than or equal to it. >>> sunsetViews([3, 7, 8, 3, 6, 1]) == 3 >>> sunsetViews([5]) == 1 >>> sunsetViews([10, 8, 6, 4, 2]) == 5 >>> sunsetViews([1, 2, 3, 4, 5]) == 1 >>> sunsetViews([]) == 0 >>> sunsetViews([5, 5, 5, 5, 5]) == 1 >>> sunsetViews([1, 3, 2, 4, 5, 2]) == 2 >>> sunsetViews([1, 3, 2, 3, 1]) == 2","solution":"from typing import List def sunsetViews(buildings: List[int]) -> int: Returns the number of buildings with an unobstructed view of the sunset. A building has an unobstructed view if no other building to its right has a height greater than or equal to it. n = len(buildings) if n == 0: return 0 count = 0 max_height = 0 for i in range(n-1, -1, -1): if buildings[i] > max_height: count += 1 max_height = buildings[i] return count"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string and returns the result as an integer. Handles '+', '-', '*', and '/' operations according to the standard order of operations. >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"5-3\\") == 2 >>> evaluate_expression(\\"4*2\\") == 8 >>> evaluate_expression(\\"8/2\\") == 4 >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\" 3/2 \\") == 1 >>> evaluate_expression(\\" 3+5 / 2 \\") == 5 >>> evaluate_expression(\\"3+5*2-4/2\\") == 11 >>> evaluate_expression(\\"2*3*2\\") == 12 >>> evaluate_expression(\\"123\\") == 123","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string and returns the result as an integer. Handles '+', '-', '*', and '/' operations according to the standard order of operations. :param expression: str, a mathematical expression :return: int, the result of the expression def helper(ops, nums): while ops and (ops[-1] in '*/'): op = ops.pop() right = nums.pop() left = nums.pop() if op == '*': nums.append(left * right) elif op == '/': nums.append(int(left / right)) # use int() to ensure integer division nums = [] ops = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 nums.append(num) i -= 1 elif expression[i] in '+-*/': helper(ops, nums) if expression[i] in '+-*/': ops.append(expression[i]) i += 1 helper(ops, nums) while ops: op = ops.pop(0) left = nums.pop(0) right = nums.pop(0) if op == '+': nums.insert(0, left + right) elif op == '-': nums.insert(0, left - right) return nums[0]"},{"question":"from typing import List, Union def median(numbers: List[Union[int, float]]) -> Union[float, str]: This function calculates the median of a list of numbers. - The median is the middle number in a sorted list. If the list has an odd number of elements, the median is the middle one. If it has an even number of elements, the median is the average of the two middle numbers. - The function should handle lists with both integers and floating-point numbers. - If the input list is empty, the function should return 'Error: List is empty.' >>> median([3, 1, 4, 2, 5]) 3 >>> median([1, 2, 3, 4, 5, 6]) 3.5 >>> median([7.5, 3.2, 5.6, 2.1]) 4.4 >>> median([]) 'Error: List is empty.' # Write your implementation here.","solution":"def median(numbers): This function calculates the median of a list of numbers. - The median is the middle number in a sorted list. If the list has an odd number of elements, the median is the middle one. If it has an even number of elements, the median is the average of the two middle numbers. - The function should handle lists with both integers and floating-point numbers. - If the input list is empty, the function should return 'Error: List is empty.' Parameters: numbers (list of int/float): The list of numbers to find the median of. Returns: float or str: The median of the list of numbers, or an error message if the list is empty. if not numbers: return 'Error: List is empty.' sorted_numbers = sorted(numbers) n = len(sorted_numbers) mid = n // 2 if n % 2 == 1: return sorted_numbers[mid] else: return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2"},{"question":"def find_anagrams(word: str, candidates: List[str]) -> List[str]: Identifies and returns all possible anagrams of the given word from a list of candidates. Ensure that the function is efficient and can handle large lists of candidate strings. >>> find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"]) [\\"enlist\\", \\"inlets\\"] >>> find_anagrams(\\"a\\", [\\"a\\", \\"b\\", \\"c\\", \\"a\\"]) [\\"a\\", \\"a\\"] >>> find_anagrams(\\"fish\\", [\\"dog\\", \\"cat\\", \\"bird\\"]) [] >>> find_anagrams(\\"test\\", []) [] >>> find_anagrams(\\"listen\\", [\\"Listen\\", \\"Silent\\", \\"enlists\\"]) [] >>> find_anagrams(\\"listen\\", [\\"listen\\", \\"listen\\"]) [\\"listen\\", \\"listen\\"] pass","solution":"def find_anagrams(word, candidates): Identifies and returns all possible anagrams of the given word from a list of candidates. :param word: The word to find anagrams for. :param candidates: A list of candidate strings. :return: A list of anagrams of the word. word_sorted = sorted(word) anagrams = [candidate for candidate in candidates if sorted(candidate) == word_sorted] return anagrams # Example usage: candidates = [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"] word = \\"listen\\" print(find_anagrams(word, candidates)) # Output: [\\"enlist\\", \\"inlets\\"]"},{"question":"from typing import Union class BankAccount: def __init__(self, balance: Union[int, float] = 0): self.balance = balance def deposit(self, amount: Union[int, float]): Deposit a specified amount to the bank account pass def withdraw(self, amount: Union[int, float]): Withdraw a specified amount from the bank account pass class CheckingAccount(BankAccount): def __init__(self, balance: Union[int, float] = 0, overdraft_limit: Union[int, float] = 0): super().__init__(balance) self.overdraft_limit = overdraft_limit def withdraw(self, amount: Union[int, float]): Withdraw a specified amount considering the overdraft limit pass class SavingsAccount(BankAccount): def __init__(self, balance: Union[int, float] = 0, interest_rate: float = 0.0): super().__init__(balance) self.interest_rate = interest_rate def apply_interest(self): Apply interest to the savings account balance pass def main(): c_acc = CheckingAccount(100, overdraft_limit=50) c_acc.deposit(50) c_acc.withdraw(120) s_acc = SavingsAccount(200, interest_rate=0.05) s_acc.apply_interest() print(c_acc.balance) print(s_acc.balance) # Testing cases import pytest def test_bank_account_deposit(): acc = BankAccount(100) acc.deposit(50) assert acc.balance == 150 def test_bank_account_withdraw(): acc = BankAccount(100) acc.withdraw(50) assert acc.balance == 50 def test_bank_account_insufficient_funds(): acc = BankAccount(100) with pytest.raises(ValueError, match=\\"Insufficient funds\\"): acc.withdraw(150) def test_checking_account_withdraw_within_overdraft(): c_acc = CheckingAccount(100, overdraft_limit=50) c_acc.withdraw(140) assert c_acc.balance == -40 def test_checking_account_exceed_overdraft(): c_acc = CheckingAccount(100, overdraft_limit=50) with pytest.raises(ValueError, match=\\"Exceeded overdraft limit\\"): c_acc.withdraw(160) def test_savings_account_apply_interest(): s_acc = SavingsAccount(200, interest_rate=0.05) s_acc.apply_interest() assert s_acc.balance == 210 def test_savings_account_apply_interest_no_rate(): s_acc = SavingsAccount(200, interest_rate=0.0) s_acc.apply_interest() assert s_acc.balance == 200","solution":"class BankAccount: def __init__(self, balance=0): self.balance = balance def deposit(self, amount): if amount > 0: self.balance += amount def withdraw(self, amount): if amount > 0 and amount <= self.balance: self.balance -= amount else: raise ValueError(\\"Insufficient funds\\") class CheckingAccount(BankAccount): def __init__(self, balance=0, overdraft_limit=0): super().__init__(balance) self.overdraft_limit = overdraft_limit def withdraw(self, amount): if amount > 0 and amount <= self.balance + self.overdraft_limit: self.balance -= amount else: raise ValueError(\\"Exceeded overdraft limit\\") class SavingsAccount(BankAccount): def __init__(self, balance=0, interest_rate=0.0): super().__init__(balance) self.interest_rate = interest_rate def apply_interest(self): if self.interest_rate > 0: self.balance += self.balance * self.interest_rate # Example usage def main(): c_acc = CheckingAccount(100, overdraft_limit=50) c_acc.deposit(50) print(f\\"Checking account balance after deposit: {c_acc.balance}\\") c_acc.withdraw(120) print(f\\"Checking account balance after withdrawal: {c_acc.balance}\\") s_acc = SavingsAccount(200, interest_rate=0.05) s_acc.apply_interest() print(f\\"Savings account balance after applying interest: {s_acc.balance}\\") main()"},{"question":"def intersection(list1: List[int], list2: List[int]) -> List[int]: Returns a list containing the unique elements that are common to both input lists sorted in ascending order. Example usage: >>> intersection([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> intersection([1, 2, 3], [4, 5, 6]) [] >>> intersection([1, 2, 2, 3, 4], [3, 3, 4, 5, 6]) [3, 4] >>> intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> intersection([], []) [] >>> intersection([1, 2, 3], []) [] >>> intersection([], [4, 5, 6]) [] pass","solution":"def intersection(list1, list2): Returns a list containing the unique elements that are common to both input lists sorted in ascending order. common_elements = set(list1).intersection(set(list2)) return sorted(common_elements) # Example usage: # list1 = [1, 2, 3, 4] # list2 = [3, 4, 5, 6] # intersection(list1, list2) -> [3, 4]"},{"question":"def find_max_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> find_max_unique_substring('') == '' >>> find_max_unique_substring('abcdef') == 'abcdef' >>> find_max_unique_substring('abcabcbb') == 'abc' >>> find_max_unique_substring('bbbbb') == 'b' >>> find_max_unique_substring('pwwkew') == 'wke' >>> find_max_unique_substring('dvdf') == 'vdf' pass def min_window_substring(s: str, t: str) -> str: Returns the minimum window in \`s\` which contains all characters in \`t\`. If no such window exists, returns empty string. >>> min_window_substring('', '') == '' >>> min_window_substring('a', '') == '' >>> min_window_substring('', 'a') == '' >>> min_window_substring('a', 'a') == 'a' >>> min_window_substring('ADOBECODEBANC', 'ABC') == 'BANC' >>> min_window_substring('A', 'AA') == '' >>> min_window_substring('AA', 'AA') == 'AA' >>> min_window_substring('aaflslflsldkalskaaa', 'aaa') == 'aaa' pass","solution":"def find_max_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. start = 0 max_length = 0 max_substring = \\"\\" char_index_map = {} for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end if end - start + 1 > max_length: max_length = end - start + 1 max_substring = s[start:end+1] return max_substring def min_window_substring(s: str, t: str) -> str: Returns the minimum window in \`s\` which contains all characters in \`t\`. If no such window exists, returns empty string. if not t or not s: return \\"\\" dict_t = {} for char in t: dict_t[char] = dict_t.get(char, 0) + 1 required = len(dict_t) formed = 0 l, r = 0, 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): char = s[r] window_counts[char] = window_counts.get(char, 0) + 1 if char in dict_t and window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in dict_t and window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"def first_unique_char(s: str) -> str: Find the first unique (non-repeating) character in a given string. If no unique character is found, output 'None'. >>> first_unique_char('swiss') 'w' >>> first_unique_char('aabbcc') 'None' >>> first_unique_char('abcd') 'a' >>> first_unique_char('aabbc') 'c' >>> first_unique_char('') 'None' >>> first_unique_char('aabbccd') 'd' >>> first_unique_char('aabbccc') 'None' >>> first_unique_char('z') 'z' >>> first_unique_char('zzzzzzz') 'None' >>> first_unique_char('abcdefgabcdefg') 'None' >>> first_unique_char('!@@!') 'None' >>> first_unique_char('9132ff32') '9'","solution":"def first_unique_char(s): counts = {} for char in s: if char in counts: counts[char] += 1 else: counts[char] = 1 for char in s: # Iterate through the string to maintain order if counts[char] == 1: return char return 'None'"},{"question":"class Calculator: A basic calculator with memory functionality. The calculator supports addition, subtraction, multiplication, and division. It also has memory functions to store, recall, and reset memory. Methods: add(value): Adds the provided value to the current value. subtract(value): Subtracts the provided value from the current value. multiply(value): Multiplies the current value by the provided value. divide(value): Divides the current value by the provided value. store(): Stores the current value in memory. recall(): Recalls the value stored in memory. reset_memory(): Resets the memory to None. >>> calc = Calculator() >>> calc.add(5) # 5 5 >>> calc.subtract(2) # 3 3 >>> calc.multiply(4) # 12 12 >>> calc.divide(3) # 4 4 >>> calc.store() >>> calc.add(10) # 14 14 >>> calc.recall() # 4 4 >>> calc.reset_memory() >>> calc.recall() is None True def test_calculator(): calc = Calculator() assert calc.current_value == 0 assert calc.memory is None assert calc.add(5) == 5 assert calc.add(3) == 8 calc.add(10) assert calc.subtract(4) == 14 assert calc.subtract(2) == 12 calc.add(3) assert calc.multiply(4) == 60 assert calc.multiply(2) == 120 calc.add(20) assert calc.divide(4) == 35 try: calc.divide(0) except ZeroDivisionError: pass calc.add(15) calc.store() assert calc.recall() == 50 calc.add(5) assert calc.recall() == 50 calc.reset_memory() assert calc.recall() is None","solution":"class Calculator: def __init__(self): self.current_value = 0 self.memory = None def add(self, value): self.current_value += value return self.current_value def subtract(self, value): self.current_value -= value return self.current_value def multiply(self, value): self.current_value *= value return self.current_value def divide(self, value): if value == 0: raise ZeroDivisionError(\\"Cannot divide by zero.\\") self.current_value /= value return self.current_value def store(self): self.memory = self.current_value def recall(self): return self.memory def reset_memory(self): self.memory = None"},{"question":"def get_top_hashtags(posts: List[Dict[str, str]], N: int) -> List[Tuple[str, int]]: Process the given list of posts and extracts the top N hashtags along with their counts. >>> posts = [ ... {\\"content\\": \\"Loving the sun! #sun #SunnyDay #Fun\\"}, ... {\\"content\\": \\"What a fun day with friends. #Fun #sun\\"}, ... {\\"content\\": \\"Today is a sunny day #SunnyDay #fun #BeHappy\\"}, ... ] >>> get_top_hashtags(posts, 2) [(\\"fun\\", 3), (\\"sun\\", 2)]","solution":"from collections import Counter from operator import itemgetter def get_top_hashtags(posts, N): hashtag_counter = Counter() for post in posts: content = post.get('content', '') words = content.split() for word in words: if word.startswith('#'): hashtag = word[1:].lower() # remove '#' and convert to lowercase hashtag_counter[hashtag] += 1 # Get the top N hashtags from the counter top_hashtags = hashtag_counter.most_common(N) return top_hashtags"},{"question":"def is_disarium(n: int) -> bool: Check if a number is a Disarium number. A Disarium number is a number where the sum of its digits powered to their respective positions is equal to the number itself. :param n: An integer to check :return: True if n is a Disarium number, False otherwise >>> is_disarium(135) True >>> is_disarium(89) True >>> is_disarium(102) False","solution":"def is_disarium(n): Check if a number is a Disarium number. A Disarium number is a number where the sum of its digits powered to their respective positions is equal to the number itself. :param n: An integer to check :return: True if n is a Disarium number, False otherwise digits = list(map(int, str(n))) disarium_sum = sum(digit ** (index + 1) for index, digit in enumerate(digits)) return disarium_sum == n"},{"question":"def robot_path(moves: str, battery: int) -> (int, int, int): Simulates the path of a robot given a sequence of movements and an initial battery level. Parameters: moves (str): A string of characters in 'F', 'B', 'L', 'R' representing the movements. battery (int): The initial battery level of the robot. Returns: (int, int, int): A tuple containing the final x and y coordinates and the remaining battery level. >>> robot_path('F', 1) (0, 1, 0) >>> robot_path('F', 5) (0, 1, 4) >>> robot_path('FLBR', 4) (0, 0, 0) >>> robot_path('FLBR', 5) (0, 0, 1) >>> robot_path('FLBR', 2) (-1, 1, 0) >>> robot_path('', 5) (0, 0, 5) >>> robot_path('', 0) (0, 0, 0) >>> robot_path('F' * 1000, 1000) (0, 1000, 0) >>> robot_path('F' * 1001, 1000) (0, 1000, 0) >>> robot_path('F' * 2000 + 'B' * 1000, 1000) (0, 1000, 0)","solution":"def robot_path(moves: str, battery: int) -> (int, int, int): Simulates the path of a robot given a sequence of movements and an initial battery level. Parameters: moves (str): A string of characters in 'F', 'B', 'L', 'R' representing the movements. battery (int): The initial battery level of the robot. Returns: (int, int, int): A tuple containing the final x and y coordinates and the remaining battery level. x, y = 0, 0 # Starting position is (0,0) for move in moves: if battery <= 0: break if move == 'F': y += 1 elif move == 'B': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 battery -= 1 return x, y, battery"},{"question":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.impute import SimpleImputer from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def download_and_preprocess_data(url: str): Download and preprocess the wine dataset. Args: url (str): The URL to the dataset. Returns: Tuple: Splitted and preprocessed training and test sets. # Load and preprocess the data (handle missing values, normalize) # then split into train and test sets. pass def train_and_evaluate_model(): Train and evaluate a classification model. Returns: dict: A dictionary of accuracy, precision, recall, and f1 score. # Download and preprocess the data, train a RandomForestClassifier, # and evaluate the model by calculating the evaluation metrics. pass from solution import download_and_preprocess_data, train_and_evaluate_model def test_preprocess_data(): url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data' X_train, X_test, y_train, y_test = download_and_preprocess_data(url) # Check if shapes are correct assert X_train.shape[0] == y_train.shape[0] assert X_test.shape[0] == y_test.shape[0] # Check if there are no NaN values assert not np.isnan(X_train).any() assert not np.isnan(X_test).any() # Check if data is normalized (mean close to 0 and standard deviation close to 1) assert np.allclose(np.mean(X_train, axis=0), 0, atol=1e-1) assert np.allclose(np.std(X_train, axis=0), 1, atol=1e-1) def test_train_and_evaluate_model(): metrics = train_and_evaluate_model() # Check if all metrics are returned assert 'accuracy' in metrics assert 'precision' in metrics assert 'recall' in metrics assert 'f1_score' in metrics # Check if the metrics are within an acceptable range assert 0 <= metrics['accuracy'] <= 1 assert 0 <= metrics['precision'] <= 1 assert 0 <= metrics['recall'] <= 1 assert 0 <= metrics['f1_score'] <= 1","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.impute import SimpleImputer from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def download_and_preprocess_data(url: str): # Load the data column_names = [ 'Class', 'Alcohol', 'Malic acid', 'Ash', 'Alcalinity of ash', 'Magnesium', 'Total phenols', 'Flavanoids', 'Nonflavanoid phenols', 'Proanthocyanins', 'Color intensity', 'Hue', 'OD280/OD315 of diluted wines', 'Proline' ] data = pd.read_csv(url, header=None, names=column_names) # Handle missing values imputer = SimpleImputer(strategy='mean') data_imputed = imputer.fit_transform(data) # Separate the features and labels X = data_imputed[:, 1:] y = data_imputed[:, 0] # Normalize the feature set scaler = StandardScaler() X_normalized = scaler.fit_transform(X) return train_test_split(X_normalized, y, test_size=0.3, random_state=42) def train_and_evaluate_model(): # Download and preprocess the data url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data' X_train, X_test, y_train, y_test = download_and_preprocess_data(url) # Train a RandomForestClassifier model = RandomForestClassifier(random_state=42) model.fit(X_train, y_train) # Make predictions y_pred = model.predict(X_test) # Calculate evaluation metrics metrics = { 'accuracy': accuracy_score(y_test, y_pred), 'precision': precision_score(y_test, y_pred, average='macro'), 'recall': recall_score(y_test, y_pred, average='macro'), 'f1_score': f1_score(y_test, y_pred, average='macro') } return metrics # Generate the metrics dictionary metrics_dict = train_and_evaluate_model() metrics_dict"},{"question":"def reverse_string_preserve_non_alpha(s: str) -> str: Reverses the order of the alphanumeric characters in the string, while preserving the position of all non-alphabetic characters. >>> reverse_string_preserve_non_alpha(\\"a,bc\\") 'c,ba' >>> reverse_string_preserve_non_alpha(\\"ab-cd\\") 'dc-ba' >>> reverse_string_preserve_non_alpha(\\"abc!def\\") 'fed!cba' >>> reverse_string_preserve_non_alpha(\\"a1b2c3d\\") 'd1c2b3a' >>> reverse_string_preserve_non_alpha(\\"A@B#C\\") 'C@B#A' >>> reverse_string_preserve_non_alpha(\\"\\") '' >>> reverse_string_preserve_non_alpha(\\"123\\") '123' >>> reverse_string_preserve_non_alpha(\\"abc\\") 'cba' >>> reverse_string_preserve_non_alpha(\\"a\\") 'a'","solution":"def reverse_string_preserve_non_alpha(s: str) -> str: Reverses the order of the alphanumeric characters in the string, while preserving the position of all non-alphabetic characters. # Extract only alphabetic characters alpha_chars = [c for c in s if c.isalpha()] # Reversed list of alphabetic characters reversed_alpha_chars = alpha_chars[::-1] result = [] alpha_index = 0 # Reconstruct the string for char in s: if char.isalpha(): result.append(reversed_alpha_chars[alpha_index]) alpha_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def character_count(s: str) -> dict: Takes a string of lowercase alphabetic characters and returns a dictionary with each character as a key and the count of occurrences of that character as the value. >>> character_count(\\"programming\\") == {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> character_count(\\"a\\") == {'a': 1} >>> character_count(\\"abc\\") == {'a': 1, 'b': 1, 'c': 1} >>> character_count(\\"aaaa\\") == {'a': 4} >>> character_count(\\"abacabad\\") == {'a': 4, 'b': 2, 'c': 1, 'd': 1} >>> character_count(\\"\\") == {}","solution":"def character_count(s): Takes a string of lowercase alphabetic characters and returns a dictionary with each character as a key and the count of occurrences of that character as the value. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def capitalize_vowels(s: str) -> str: Returns a new string where every vowel (a, e, i, o, u) in the input string is replaced with its uppercase form. Consonants and other characters remain unchanged. >>> capitalize_vowels(\\"aeiou\\") \\"AEIOU\\" >>> capitalize_vowels(\\"hEllo\\") \\"hEllO\\" >>> capitalize_vowels(\\"python\\") \\"pythOn\\" >>> capitalize_vowels(\\"bcdfg\\") \\"bcdfg\\" >>> capitalize_vowels(\\"he11o w0r1d\\") \\"hE11O w0r1d\\" >>> capitalize_vowels(\\"\\") \\"\\"","solution":"def capitalize_vowels(s): Returns a new string where every vowel (a, e, i, o, u) in the input string is replaced with its uppercase form. Consonants and other characters remain unchanged. vowels = \\"aeiou\\" result = [] for char in s: if char in vowels: result.append(char.upper()) else: result.append(char) return ''.join(result)"},{"question":"def classify_numbers(numbers: List[int]) -> dict: Design a function that takes in a list of integers and returns a dictionary with two keys: \\"even\\" and \\"odd\\". The values corresponding to these keys should be lists containing the even and odd numbers from the input list, respectively. The original order of the numbers should be maintained in the output lists. If there are no even or odd numbers, return an empty list for the respective key. >>> classify_numbers([1, 2, 3, 4, 5, 6]) {'even': [2, 4, 6], 'odd': [1, 3, 5]} >>> classify_numbers([2, 4, 6, 8]) {'even': [2, 4, 6, 8], 'odd': []} >>> classify_numbers([1, 3, 5, 7]) {'even': [], 'odd': [1, 3, 5, 7]} >>> classify_numbers([]) {'even': [], 'odd': []} >>> classify_numbers([0, 2, 4, 6, 8]) {'even': [0, 2, 4, 6, 8], 'odd': []} >>> classify_numbers([-1, -2, -3, -4]) {'even': [-2, -4], 'odd': [-1, -3]}","solution":"def classify_numbers(numbers): Returns a dictionary with two keys: \\"even\\" and \\"odd\\" containing lists of even and odd numbers from the input list, respectively. The original order of the numbers is maintained in the output lists. :param numbers: List of integers :return: Dictionary with keys \\"even\\" and \\"odd\\" result = {\\"even\\": [], \\"odd\\": []} for number in numbers: if number % 2 == 0: result[\\"even\\"].append(number) else: result[\\"odd\\"].append(number) return result"},{"question":"def unique_numbers(nums: List[int]) -> List[int]: Write a Python function called \`unique_numbers\` that takes a list of integers as an argument and returns another list containing only the unique integers from the input list, but in the reverse order of their first appearance. You must achieve this in O(n) time complexity, where n is the length of the input list. >>> unique_numbers([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> unique_numbers([1, 2, 2, 3, 4, 4, 5]) [5, 4, 3, 2, 1] >>> unique_numbers([4, 4, 4, 4]) [4] >>> unique_numbers([]) [] >>> unique_numbers([5, 1, 2, 3, 2, 1, 5, 4]) [4, 5, 1, 2, 3]","solution":"def unique_numbers(nums): Returns a list of unique integers in the reverse order of their first appearance. Args: nums (list): List of integers. Returns: list: List of unique integers. seen = set() unique_list = [] # Traverse the list in reverse order for num in reversed(nums): if num not in seen: seen.add(num) unique_list.append(num) return unique_list"},{"question":"def evaluate_expression(expression: str, variables: dict) -> float: Evaluates a mathematical expression with variables using provided values. >>> evaluate_expression(\\"3 + x\\", {'x': 4}) 7 >>> evaluate_expression(\\"10 - y\\", {'y': 3}) 7 >>> evaluate_expression(\\"2 * z\\", {'z': 5}) 10 >>> evaluate_expression(\\"8 / w\\", {'w': 2}) 4 >>> evaluate_expression(\\"3 + x * (2 - y) / z\\", {'x': 4, 'y': 3, 'z': 2}) 1 >>> evaluate_expression(\\"(a + b) * c / (d - e)\\", {'a': 2, 'b': 3, 'c': 4, 'd': 10, 'e': 5}) 4","solution":"import operator import re def evaluate_expression(expression, variables): Evaluates a mathematical expression with variables using provided values. Args: expression (str): The mathematical expression as a string. variables (dict): A dictionary of variables and their values. Returns: float: The result of the expression evaluation. # Replace variables in the expression with their values for var, value in variables.items(): expression = expression.replace(var, str(value)) # The eval method can be used to evaluate the mathematical expression # after replacing variables with their corresponding values. However, # in a production setting, using eval is not recommended due to security # concerns. For this example, we'll assume the input is safe. return eval(expression)"},{"question":"class InventoryManager: InventoryManager class to handle a list of products for basic inventory management. def __init__(self): Initialize the inventory with an empty list of products. pass def add_product(self, product): Adds a new product to the inventory. If a product with the same 'id' already exists, update its 'quantity'. :param product: A dictionary with 'id', 'name', and 'quantity' keys. pass def sell_product(self, product_id, amount): Decreases the 'quantity' of the product with the given 'product_id' by 'amount'. If 'amount' exceeds current quantity, raise an Exception with the message 'Insufficient stock'. :param product_id: The ID of the product to be sold. :param amount: The amount of the product to be sold. pass def restock_product(self, product_id, amount): Increases the 'quantity' of the product with the given 'product_id' by 'amount'. :param product_id: The ID of the product to be restocked. :param amount: The amount of the product to be added to the inventory. pass def inventory_status(self): Returns a list of dictionaries, each containing 'id', 'name', and 'quantity' of each product, sorted by 'id'. pass import pytest def test_add_product(): inventory = InventoryManager() inventory.add_product({'id': 1, 'name': 'Apples', 'quantity': 10}) assert inventory.inventory_status() == [{'id': 1, 'name': 'Apples', 'quantity': 10}] inventory.add_product({'id': 1, 'name': 'Apples', 'quantity': 5}) assert inventory.inventory_status() == [{'id': 1, 'name': 'Apples', 'quantity': 15}] def test_sell_product(): inventory = InventoryManager() inventory.add_product({'id': 1, 'name': 'Apples', 'quantity': 10}) inventory.sell_product(1, 7) assert inventory.inventory_status() == [{'id': 1, 'name': 'Apples', 'quantity': 3}] with pytest.raises(Exception) as excinfo: inventory.sell_product(1, 5) assert str(excinfo.value) == 'Insufficient stock' def test_restock_product(): inventory = InventoryManager() inventory.add_product({'id': 1, 'name': 'Apples', 'quantity': 10}) inventory.restock_product(1, 5) assert inventory.inventory_status() == [{'id': 1, 'name': 'Apples', 'quantity': 15}] def test_inventory_status(): inventory = InventoryManager() inventory.add_product({'id': 1, 'name': 'Apples', 'quantity': 10}) inventory.add_product({'id': 2, 'name': 'Bananas', 'quantity': 5}) assert inventory.inventory_status() == [{'id': 1, 'name': 'Apples', 'quantity': 10}, {'id': 2, 'name': 'Bananas', 'quantity': 5}] def test_product_not_found(): inventory = InventoryManager() with pytest.raises(Exception) as excinfo: inventory.sell_product(3, 5) assert str(excinfo.value) == 'Product not found' with pytest.raises(Exception) as excinfo: inventory.restock_product(3, 5) assert str(excinfo.value) == 'Product not found'","solution":"class InventoryManager: def __init__(self): self.products = {} def add_product(self, product): product_id = product['id'] if product_id in self.products: self.products[product_id]['quantity'] += product['quantity'] else: self.products[product_id] = product def sell_product(self, product_id, amount): if product_id not in self.products: raise Exception('Product not found') if self.products[product_id]['quantity'] < amount: raise Exception('Insufficient stock') self.products[product_id]['quantity'] -= amount def restock_product(self, product_id, amount): if product_id not in self.products: raise Exception('Product not found') self.products[product_id]['quantity'] += amount def inventory_status(self): return sorted(self.products.values(), key=lambda x: x['id'])"},{"question":"def evaluate_postfix(expression: str) -> str: Evaluates a postfix expression using a stack. Args: - expression (str): The postfix expression to evaluate. Returns: - int: The result of the evaluation. - str: An error message if the expression is invalid. >>> evaluate_postfix(\\"3 4 +\\") 7 >>> evaluate_postfix(\\"10 2 -\\") 8 >>> evaluate_postfix(\\"6 3 *\\") 18 >>> evaluate_postfix(\\"8 4 /\\") 2 >>> evaluate_postfix(\\"2 3 1 * + 9 -\\") -4 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_postfix(\\"3 +\\") \\"Error: Invalid postfix expression\\" >>> evaluate_postfix(\\"3 4 5 +\\") \\"Error: Invalid postfix expression\\" >>> evaluate_postfix(\\"3 /\\") \\"Error: Invalid postfix expression\\" >>> evaluate_postfix(\\"4 0 /\\") \\"Error: Division by zero\\" >>> evaluate_postfix(\\"4 a +\\") \\"Error: Invalid character in postfix expression\\" >>> evaluate_postfix(\\"2 3 * +\\") \\"Error: Invalid character in postfix expression\\" stack = [] operators = set(['+', '-', '*', '/']) for token in expression.split(): if token.isdigit(): stack.append(int(token)) print(f\\"Pushed {token} -> Stack: {stack}\\") elif token in operators: if len(stack) < 2: return \\"Error: Invalid postfix expression\\" b = stack.pop() a = stack.pop() print(f\\"Popped {a} and {b} for operator {token}\\") if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': if b == 0: return \\"Error: Division by zero\\" result = a // b stack.append(result) print(f\\"Applied {token} -> Stack: {stack}\\") else: return \\"Error: Invalid character in postfix expression\\" if len(stack) != 1: return \\"Error: Invalid postfix expression\\" return stack.pop()","solution":"def evaluate_postfix(expression): Evaluates a postfix expression using a stack. Args: - expression (str): The postfix expression to evaluate. Returns: - int: The result of the evaluation. - str: An error message if the expression is invalid. stack = [] operators = set(['+', '-', '*', '/']) for token in expression.split(): if token.isdigit(): stack.append(int(token)) print(f\\"Pushed {token} -> Stack: {stack}\\") elif token in operators: if len(stack) < 2: return \\"Error: Invalid postfix expression\\" b = stack.pop() a = stack.pop() print(f\\"Popped {a} and {b} for operator {token}\\") if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': if b == 0: return \\"Error: Division by zero\\" result = a // b stack.append(result) print(f\\"Applied {token} -> Stack: {stack}\\") else: return \\"Error: Invalid character in postfix expression\\" if len(stack) != 1: return \\"Error: Invalid postfix expression\\" return stack.pop()"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix 90 degrees clockwise. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([]) [] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] def test_rotate_matrix_3x3(): input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_4x4(): input_matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] expected_output = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_1x1(): input_matrix = [ [1] ] expected_output = [ [1] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_empty(): input_matrix = [] expected_output = [] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_2x2(): input_matrix = [ [1, 2], [3, 4] ] expected_output = [ [3, 1], [4, 2] ] assert rotate_matrix(input_matrix) == expected_output","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix 90 degrees clockwise. if not matrix or not matrix[0]: return matrix n = len(matrix) # Initialize the rotated matrix with the right dimensions rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def product_of_odds(lst): Returns the product of all odd integers in the given list \`lst\`. If no odd integers are found, returns 0. pass # your code here # Unit tests def test_product_of_odds_mixed(): assert product_of_odds([1, 2, 3, 4, 5]) == 15 def test_product_of_odds_no_odds(): assert product_of_odds([2, 4, 6, 8]) == 0 def test_product_of_odds_all_odds(): assert product_of_odds([7, 3, 1]) == 21 def test_product_of_odds_empty_list(): assert product_of_odds([]) == 0 def test_product_of_odds_single_odd(): assert product_of_odds([5]) == 5 def test_product_of_odds_single_even(): assert product_of_odds([4]) == 0 def test_product_of_odds_large_list(): assert product_of_odds(list(range(1, 21))) == 654729075 def test_product_of_odds_zero_in_list(): assert product_of_odds([0, 1, 2, 3]) == 3","solution":"def product_of_odds(lst): Returns the product of all odd integers in the given list \`lst\`. If no odd integers are found, returns 0. product = 1 has_odd = False for num in lst: if num % 2 != 0: product *= num has_odd = True if not has_odd: return 0 return product"},{"question":"def longest_common_substring(s1: str, s2: str) -> tuple: Finds the longest common substring shared by two given strings. Parameters: s1 (str): The first input string. s2 (str): The second input string. Returns: tuple: A tuple containing the longest common substring and its starting indices in the original strings. (substring, start_index_in_s1, start_index_in_s2) pass # Unit Tests def test_no_common_substring(): assert longest_common_substring(\\"abc\\", \\"def\\") == (\\"\\", -1, -1) def test_common_substring_at_start(): assert longest_common_substring(\\"abc\\", \\"abxyz\\") == (\\"ab\\", 0, 0) def test_common_substring_at_end(): assert longest_common_substring(\\"xyzabc\\", \\"123abc\\") == (\\"abc\\", 3, 3) def test_common_substring_in_middle(): assert longest_common_substring(\\"abcdef\\", \\"zabcy\\") == (\\"abc\\", 0, 1) def test_full_string_common_substring(): assert longest_common_substring(\\"hello\\", \\"hello\\") == (\\"hello\\", 0, 0) def test_non_overlapping_substrings(): assert longest_common_substring(\\"abcde\\", \\"cdefg\\") == (\\"cde\\", 2, 0) def test_single_character_common_substring(): assert longest_common_substring(\\"xabcx\\", \\"zabcw\\") == (\\"abc\\", 1, 1)","solution":"def longest_common_substring(s1, s2): Finds the longest common substring shared by two given strings. Parameters: s1 (str): The first input string. s2 (str): The second input string. Returns: tuple: A tuple containing the longest common substring and its starting indices in the original strings. (substring, start_index_in_s1, start_index_in_s2) len_s1, len_s2 = len(s1), len(s2) max_len = 0 ending_index_s1 = 0 dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] ending_index_s1 = i if max_len == 0: return \\"\\", -1, -1 start_index_s1 = ending_index_s1 - max_len common_substring = s1[start_index_s1:ending_index_s1] start_index_s2 = s2.index(common_substring) return common_substring, start_index_s1, start_index_s2"},{"question":"def find_common_elements(list1: List[int], list2: List[int], list3: List[int]) -> List[int]: Write a function that takes three lists of integers and returns a sorted list containing only those integers which are present in all three lists. The function should have a time complexity of O(n) where n is the length of each list. >>> find_common_elements([1, 2, 3], [2, 3, 4], [3, 2, 5]) [2, 3] >>> find_common_elements([1, 6, 8], [2, 4, 9], [3, 7, 5]) [] >>> find_common_elements([1, 2, 3, 4], [2, 4, 5, 6], [4, 2, 7, 8]) [2, 4] >>> find_common_elements([1, 2, 2, 3], [2, 3, 3, 4], [3, 2, 2, 5]) [2, 3] >>> find_common_elements([], [2, 3, 4], [3, 2, 5]) [] >>> find_common_elements([1, 2, 3], [], [3, 2, 5]) [] >>> find_common_elements([1, 2, 3], [2, 3, 4], []) []","solution":"def find_common_elements(list1, list2, list3): Returns a sorted list containing elements that are present in all three lists. set1, set2, set3 = set(list1), set(list2), set(list3) common_elements = set1 & set2 & set3 return sorted(list(common_elements))"},{"question":"class TaskManager: def __init__(self): self.tasks = [] def add_task(self, description, priority): Adds a new task with the given description and priority. pass def remove_task(self, description): Removes the task with the specified description. pass def get_highest_priority_task(self): Returns the highest priority task without removing it from the list. pass def list_tasks(self): Returns all tasks sorted by their priority. pass # Example usage task_manager = TaskManager() task_manager.add_task(\\"Fix bug in code\\", 2) task_manager.add_task(\\"Write documentation\\", 1) task_manager.add_task(\\"Update user guide\\", 3)","solution":"class TaskManager: def __init__(self): self.tasks = [] def add_task(self, description, priority): Adds a new task with the given description and priority. task = {'description': description, 'priority': priority} self.tasks.append(task) self.tasks.sort(key=lambda x: x['priority']) def remove_task(self, description): Removes the task with the specified description. self.tasks = [task for task in self.tasks if task['description'] != description] def get_highest_priority_task(self): Returns the highest priority task without removing it from the list. return self.tasks[0] if self.tasks else None def list_tasks(self): Returns all tasks sorted by their priority. return self.tasks"},{"question":"from typing import List, Tuple def filter_and_add(numbers: List[int], threshold: int) -> Tuple[int, List[int]]: You will be furnished with a list of integers and a threshold value. Your task is to extract all integers from the list that surpass the given threshold, accumulate these integers into a new list, and compute the sum of the integers in this new list. The function should return a tuple containing the sum of these integers and the new list. Illustration Examples: >>> filter_and_add([1, 2, 3, 4, 5], 3) (9, [4, 5]) >>> filter_and_add([5, 10, 3, 7, 2], 6) (17, [10, 7]) def test_filter_and_add(): # Test cases with expected values assert filter_and_add([1, 2, 3, 4, 5], 3) == (9, [4, 5]) assert filter_and_add([5, 10, 3, 7, 2], 6) == (17, [10, 7]) assert filter_and_add([1, 1, 1, 1, 1], 0) == (5, [1, 1, 1, 1, 1]) assert filter_and_add([1, 1, 1, 1, 1], 1) == (0, []) assert filter_and_add([5, 10, 15, 20], 10) == (35, [15, 20]) assert filter_and_add([], 5) == (0, [])","solution":"from typing import List, Tuple def filter_and_add(numbers: List[int], threshold: int) -> Tuple[int, List[int]]: You will be furnished with a list of integers and a threshold value. Your task is to extract all integers from the list that surpass the given threshold, accumulate these integers into a new list, and compute the sum of the integers in this new list. The function should return a tuple containing the sum of these integers and the new list. Illustration Examples: >>> filter_and_add([1, 2, 3, 4, 5], 3) (9, [4, 5]) >>> filter_and_add([5, 10, 3, 7, 2], 6) (17, [10, 7]) result = [] for number in numbers: if number > threshold: result.append(number) return sum(result), result"},{"question":"import time from typing import List def binary_search(arr: List[int], target: int) -> int: Performs binary search on a sorted list to find the index of the target element. Returns the index of the target if found, otherwise returns -1. :param arr: List of sorted elements :param target: Element to search for :return: Index of target if found, -1 otherwise # Your code here def measure_performance(): Measures and prints the performance of the binary_search function for different input sizes. sizes = [10, 100, 1000, 10000] target = -1 # Element not in list for maximum search depth for size in sizes: arr = list(range(size)) start_time = time.time() binary_search(arr, target) end_time = time.time() print(f\\"List Size: {size} - Execution Time: {end_time - start_time:.10f} seconds\\") # Test cases if __name__ == \\"__main__\\": def test_binary_search_found(): assert binary_search([1, 2, 3, 4, 5], 3) == 2 assert binary_search([10, 20, 30, 40, 50], 40) == 3 assert binary_search([100, 200, 300, 400, 500], 100) == 0 def test_binary_search_not_found(): assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert binary_search([10, 20, 30, 40, 50], 25) == -1 assert binary_search([100, 200, 300, 400, 500], 150) == -1 def test_binary_search_empty_list(): assert binary_search([], 1) == -1 def test_binary_search_single_element(): assert binary_search([1], 1) == 0 assert binary_search([1], 2) == -1 def test_binary_search_negative_numbers(): assert binary_search([-5, -4, -3, -2, -1], -3) == 2 test_binary_search_found() test_binary_search_not_found() test_binary_search_empty_list() test_binary_search_single_element() test_binary_search_negative_numbers() measure_performance()","solution":"import time def binary_search(arr, target): Performs binary search on a sorted list to find the index of the target element. Returns the index of the target if found, otherwise returns -1. :param arr: List of sorted elements :param target: Element to search for :return: Index of target if found, -1 otherwise left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def measure_performance(): Measures and prints the performance of the binary_search function for different input sizes. sizes = [10, 100, 1000, 10000] target = -1 # Element not in list for maximum search depth for size in sizes: arr = list(range(size)) start_time = time.time() binary_search(arr, target) end_time = time.time() print(f\\"List Size: {size} - Execution Time: {end_time - start_time:.10f} seconds\\") measure_performance()"},{"question":"def max_adjacent_diff(heights: List[int]) -> int: Compute the maximum difference in heights between any two adjacent buildings. Args: heights (List[int]): a list of integers representing the heights of adjacent buildings. Returns: int: the maximum difference in heights between any two adjacent buildings. Examples: >>> max_adjacent_diff([3, 7, 2, 8, 10, 4]) 6 >>> max_adjacent_diff([1, 1000]) 999 pass # Your code here # Test cases def test_max_adjacent_diff(): assert max_adjacent_diff([3, 7, 2, 8, 10, 4]) == 6 assert max_adjacent_diff([1, 1000]) == 999 assert max_adjacent_diff([1, 1000, 2, 999, 3, 998]) == 999 assert max_adjacent_diff([5, 5, 5, 5]) == 0 assert max_adjacent_diff([1, 2]) == 1 assert max_adjacent_diff([3, 9, 2, 5, 1, 8]) == 7 assert max_adjacent_diff([1, 2, 3, 4, 5]) == 1 assert max_adjacent_diff([5, 4, 3, 2, 1]) == 1 assert max_adjacent_diff([1, 2, 1, 2, 1, 2]) == 1","solution":"def max_adjacent_diff(heights): Returns the maximum difference in heights between any two adjacent buildings. return max(abs(heights[i] - heights[i+1]) for i in range(len(heights) - 1))"},{"question":"import heapq class MedianFinder: A data structure that maintains a list of numbers and can efficiently provide the median of the list after each insertion. def __init__(self): self.min_heap = [] # holds the larger half of the numbers self.max_heap = [] # holds the smaller half of the numbers def addNum(self, num: int) -> None: Add a new number to the data structure. if not self.max_heap or num < -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Rebalance the heaps if their sizes differ by more than one if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: Find and return the median of the current list of numbers. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0 def test_median_finder(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1.0 # median is 1 mf.addNum(2) assert mf.findMedian() == 1.5 # median is (1+2)/2 mf.addNum(3) assert mf.findMedian() == 2.0 # median is 2 mf.addNum(4) assert mf.findMedian() == 2.5 # median is (2+3)/2 mf.addNum(5) assert mf.findMedian() == 3.0 # median is 3 def test_median_finder_single_element(): mf = MedianFinder() mf.addNum(10) assert mf.findMedian() == 10.0 # median is 10 def test_median_finder_two_elements(): mf = MedianFinder() mf.addNum(10) mf.addNum(20) assert mf.findMedian() == 15.0 # median is (10+20)/2 def test_median_finder_negative_numbers(): mf = MedianFinder() mf.addNum(-1) mf.addNum(-2) mf.addNum(-3) assert mf.findMedian() == -2.0 # median is -2 def test_median_finder_mixed_numbers(): mf = MedianFinder() mf.addNum(-1) mf.addNum(-2) mf.addNum(3) mf.addNum(4) assert mf.findMedian() == 1.0 # median is (3+-2)/2","solution":"import heapq class MedianFinder: A data structure that maintains a list of numbers and can efficiently provide the median of the list after each insertion. def __init__(self): self.min_heap = [] # holds the larger half of the numbers self.max_heap = [] # holds the smaller half of the numbers def addNum(self, num: int) -> None: if not self.max_heap or num < -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Rebalance the heaps if their sizes differ by more than one if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"import re from typing import List def check_password_strength(passwords: List[str]) -> List[bool]: Check if given passwords meet the specified criteria for a valid password. Criteria: 1. The password must be at least 8 characters long. 2. It must contain at least one lowercase letter. 3. It must contain at least one uppercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set: {!@#%^&*()-+} >>> check_password_strength([\\"Passw0rd!\\", \\"password\\", \\"PASSWORD1@\\", \\"Pass@123\\", \\"Pass1234\\", \\"1234!abcd\\"]) [True, False, False, True, False, False]","solution":"import re def check_password_strength(passwords): Check if given passwords meet the specified criteria for a valid password. Parameters: passwords (list of str): List of passwords to validate Returns: list of bool: A list where each element is True if the corresponding password is valid, otherwise False. result = [] for password in passwords: if (len(password) >= 8 and re.search(r\\"[a-z]\\", password) and re.search(r\\"[A-Z]\\", password) and re.search(r\\"d\\", password) and re.search(r\\"[!@#%^&*()-+]\\", password)): result.append(True) else: result.append(False) return result passwords = [\\"Passw0rd!\\", \\"password\\", \\"PASSWORD1@\\", \\"Pass@123\\", \\"Pass1234\\", \\"1234!abcd\\"] result = check_password_strength(passwords) print(result)"},{"question":"from typing import List def word_search(grid: List[List[str]], word: str) -> bool: Given a grid of letters and a word, return True if the word exists in the grid, otherwise return False. The word can be constructed from sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Examples: >>> word_search([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCCED\\") True >>> word_search([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"SEE\\") True >>> word_search([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCB\\") False # Implement your code here. def test_word_search_example_1(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] word = \\"ABCCED\\" assert word_search(grid, word) == True def test_word_search_example_2(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] word = \\"SEE\\" assert word_search(grid, word) == True def test_word_search_example_3(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] word = \\"ABCB\\" assert word_search(grid, word) == False def test_word_search_one_letter(): grid = [ ['A', 'B'], ['C', 'D'] ] word = \\"A\\" assert word_search(grid, word) == True def test_word_search_no_match(): grid = [ ['A', 'B'], ['C', 'D'] ] word = \\"E\\" assert word_search(grid, word) == False def test_word_search_complex_path(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] word = \\"SFD\\" assert word_search(grid, word) == True","solution":"from typing import List def word_search(grid: List[List[str]], word: str) -> bool: Given a grid of letters and a word, return True if the word exists in the grid, otherwise return False. The word can be constructed from sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. ROWS, COLS = len(grid), len(grid[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or c < 0 or r >= ROWS or c >= COLS or word[i] != grid[r][c]: return False temp = grid[r][c] grid[r][c] = \\"#\\" found = (dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1)) grid[r][c] = temp return found for r in range(ROWS): for c in range(COLS): if grid[r][c] == word[0] and dfs(r, c, 0): return True return False"},{"question":"def square_even_numbers(numbers: List[int]) -> List[int]: Takes a list of integers and returns a list of squared values of only the even numbers. >>> square_even_numbers([1, 2, 3, 4, 5]) [4, 16] >>> square_even_numbers([2, 4, 6]) [4, 16, 36] >>> square_even_numbers([1, 3, 5]) [] >>> square_even_numbers([]) [] >>> square_even_numbers([-2, -3, 0, 4]) [4, 0, 16]","solution":"def square_even_numbers(numbers): Returns a list of squares of the even numbers from the input list, while maintaining their order in the original list. return [x**2 for x in numbers if x % 2 == 0]"},{"question":"def find_second_largest(nums: List[int]) -> Optional[int]: Returns the second largest number in the given list of integers. If the list has fewer than two distinct elements, returns None. >>> find_second_largest([3, 10, 5, 6]) 6 >>> find_second_largest([3]) None >>> find_second_largest([3, 3, 3]) None >>> find_second_largest([]) None >>> find_second_largest([2, 8]) 2 >>> find_second_largest([-1, -2, -3, -4]) -2 >>> find_second_largest([2, 3, 3, 1, 4, 4, 5, 6, 5, 6]) 5 >>> find_second_largest([100000, 1000000, 999999]) 999999","solution":"def find_second_largest(nums): Returns the second largest number in the given list of integers. If the list has fewer than two distinct elements, returns None. if len(nums) < 2: return None first, second = None, None for num in nums: if first is None or num > first: first, second = num, first elif num != first and (second is None or num > second): second = num return second"},{"question":"def find_second_largest(lst: List[int]) -> Union[int, str]: Finds the second largest number in a list of integers. Parameters: - lst (list of int): The input list of integers. Returns: - int: The second largest number if it exists, otherwise returns an appropriate message. >>> find_second_largest([10, 34, 67, 89, 90, 56, 78, 89]) == 89 >>> find_second_largest([1, 3, 3, 5, 5]) == 3 >>> find_second_largest([2, 2, 2, 2]) == \\"List does not have two distinct elements.\\" >>> find_second_largest([5]) == \\"List does not have enough elements.\\" >>> find_second_largest([]) == \\"List does not have enough elements.\\" >>> find_second_largest([8, 7]) == 7 >>> find_second_largest([-1, -3, -5, -2]) == -2 >>> find_second_largest([15, -2, 22, 22, -5, 5, 5, 0]) == 15","solution":"def find_second_largest(lst): Finds the second largest number in a list of integers. Parameters: - lst (list of int): The input list of integers. Returns: - int: The second largest number if it exists, otherwise returns a message. if len(lst) < 2: return \\"List does not have enough elements.\\" first_largest = second_largest = float('-inf') # Find the largest and the second largest numbers for num in lst: if num > first_largest: second_largest = first_largest first_largest = num elif first_largest > num > second_largest: second_largest = num if second_largest == float('-inf'): return \\"List does not have two distinct elements.\\" else: return second_largest # Time Complexity: O(n), where n is the number of elements in the list. # Space Complexity: O(1), only a few variables are used regardless of the input list size."},{"question":"def count_pairs(arr, target): Implement a function in Python that takes a list of integers as input and returns the count of distinct pairs (i, j) such that the sum of the pair (i, j) is equal to a given target value. Ensure the function handles edge cases where the list might be empty or contain negative integers. >>> count_pairs([1, 2, 3, 4], 5) # Output: 2 (Pairs: (1, 4), (2, 3)) 2 >>> count_pairs([0, -1, 2, -3, 1], -2) # Output: 1 (Pair: (-3, 1)) 1 >>> count_pairs([], 5) # Output: 0 0","solution":"def count_pairs(arr, target): Returns the count of distinct pairs (i, j) such that the sum of the pair (i, j) is equal to the target value. if not arr: return 0 arr.sort() left, right = 0, len(arr) - 1 count = 0 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: count += 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return count"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Takes an array of integers and returns an array where each element is the product of all integers in the input array except the one at the current position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([]) [] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0, 0]) [0, 0, 0] >>> product_except_self([0, 4, 5, 0]) [0, 0, 0, 0] >>> product_except_self([2, 0, 3]) [0, 6, 0] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([1, -1, 2, -2, 3, -3]) [-36, 36, -18, 18, -12, 12]","solution":"def product_except_self(nums): Takes an array of integers and returns an array where each element is the product of all integers in the input array except the one at the current position. n = len(nums) if n == 0: return [] # Initialize the arrays for left and right products left_products = [1] * n right_products = [1] * n # Fill the left products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill the right products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Generate the result array by multiplying left and right products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"import curses from random import randint def create_window(height, width): Creates a new window for the game with the given height and width, initializes the curses settings and sets up the window border. def place_food(snake, height, width): Places food at a random location that is not occupied by the snake. def main(): Main function to run the snake game. if __name__ == \\"__main__\\": main()","solution":"import curses from random import randint def create_window(height, width): Creates a new window for the game with the given height and width, initializes the curses settings and sets up the window border. curses.initscr() window = curses.newwin(height, width, 0, 0) window.keypad(True) curses.curs_set(0) window.border(0) return window def place_food(snake, height, width): Places food at a random location that is not occupied by the snake. food = None while food is None: food = (randint(1, height-2), randint(1, width-2)) if food in snake: food = None return food def main(): Main function to run the snake game. height, width = 20, 60 # Adjustable dimensions window = create_window(height, width) snake = [(height//2, width//4), (height//2, width//4 - 1), (height//2, width//4 - 2)] food = place_food(snake, height, width) window.addch(food[0], food[1], '*') ESC = 27 key = curses.KEY_RIGHT score = 0 while key != ESC: window.addstr(0, 2, 'Score: ' + str(score) + ' ') window.timeout(150) next_key = window.getch() key = key if next_key == -1 else next_key if key not in [curses.KEY_RIGHT, curses.KEY_LEFT, curses.KEY_UP, curses.KEY_DOWN, ESC]: continue head = snake[0] if key == curses.KEY_RIGHT: new_head = (head[0], head[1] + 1) elif key == curses.KEY_LEFT: new_head = (head[0], head[1] - 1) elif key == curses.KEY_UP: new_head = (head[0] - 1, head[1]) elif key == curses.KEY_DOWN: new_head = (head[0] + 1, head[1]) if (new_head[0] in [0, height-1] or new_head[1] in [0, width-1] or new_head in snake): break snake.insert(0, new_head) if new_head == food: score += 1 food = place_food(snake, height, width) window.addch(food[0], food[1], '*') else: tail = snake.pop() window.addch(tail[0], tail[1], ' ') window.addch(new_head[0], new_head[1], 'O') curses.endwin() print(f\\"Game Over! Your final score is {score}.\\") if __name__ == \\"__main__\\": main()"},{"question":"import pandas as pd import numpy as np def clean_data(df: pd.DataFrame) -> pd.DataFrame: Clean the dataset by handling missing prices, ensuring unique product IDs, and stripping leading/trailing spaces from product names. Parameters: df (pd.DataFrame): Input DataFrame containing product information. Returns: pd.DataFrame: Cleaned DataFrame >>> data = [ ... [101, 'Shampoo', 5.99], ... [102, 'Conditioner', np.nan], ... [103, 'Toothpaste', 3.49], ... [104, ' Mouthwash ', 4.99], ... [105, 'Toothbrush', np.nan], ... [102, 'Conditioner', 5.49], ... ] >>> df = pd.DataFrame(data, columns=['product_id', 'product_name', 'price']) >>> cleaned_df = clean_data(df) >>> print(cleaned_df) Test Cases: data = [ [101, 'Shampoo', 5.99], [102, 'Conditioner', np.nan], [103, 'Toothpaste', 3.49], [104, ' Mouthwash ', 4.99], [105, 'Toothbrush', np.nan], [102, 'Conditioner', 5.49], ] df = pd.DataFrame(data, columns=['product_id', 'product_name', 'price']) result = clean_data(df) # Check if NaN prices were replaced with the median price assert result.loc[1, 'price'] == 5.24 # Median of [5.99, 3.49, 4.99, 5.49] assert result.loc[4, 'price'] == 5.24 # Check if product IDs are resolved correctly assert result.loc[5, 'product_id'] == '102_dup1' # Ensure no leading/trailing spaces in product names assert result.loc[3, 'product_name'] == 'Mouthwash' assert all(result['product_name'].str.strip() == result['product_name']) def test_empty_dataframe(): df = pd.DataFrame(columns=['product_id', 'product_name', 'price']) result = clean_data(df) assert result.empty def test_all_prices_nan(): data = [ [101, 'Shampoo', np.nan], [102, 'Conditioner', np.nan] ] df = pd.DataFrame(data, columns=['product_id', 'product_name', 'price']) result = clean_data(df) # Ensure median of empty price is np.nan assert np.isnan(result.loc[0, 'price']) assert np.isnan(result.loc[1, 'price']) def test_no_duplicates_and_no_nans(): data = [ [101, 'Shampoo', 5.99], [102, 'Conditioner', 4.99] ] df = pd.DataFrame(data, columns=['product_id', 'product_name', 'price']) result = clean_data(df) # No changes expected since no NaN and no duplicates assert result.equals(df) def test_spaces_and_duplicates(): data = [ [101, ' Shampoo ', 5.99], [101, ' Conditioner ', 4.99] ] df = pd.DataFrame(data, columns=['product_id', 'product_name', 'price']) result = clean_data(df) # Check if leading/trailing spaces are removed assert result.loc[0, 'product_name'] == 'Shampoo' assert result.loc[1, 'product_name'] == 'Conditioner' # Check if ID is unique assert result.loc[1, 'product_id'] == '101_dup1'","solution":"import pandas as pd import numpy as np def clean_data(df): # Step 1: Replace NaNs in 'price' column with the median value median_price = df['price'].median() df['price'].fillna(median_price, inplace=True) # Step 2: Ensure 'product_id' is unique # Create a counter dictionary to track occurrences of product_ids id_count = {} for i in range(len(df)): pid = df.loc[i, 'product_id'] if pid in id_count: id_count[pid] += 1 df.loc[i, 'product_id'] = f\\"{pid}_dup{id_count[pid]}\\" else: id_count[pid] = 0 # Step 3: Remove leading/trailing spaces in 'product_name' df['product_name'] = df['product_name'].str.strip() return df # Here's the sample input data for the function data = [ [101, 'Shampoo', 5.99], [102, 'Conditioner', np.nan], [103, 'Toothpaste', 3.49], [104, ' Mouthwash ', 4.99], [105, 'Toothbrush', np.nan], [102, 'Conditioner', 5.49], ] df = pd.DataFrame(data, columns=['product_id', 'product_name', 'price']) # Clean data cleaned_df = clean_data(df) print(cleaned_df)"},{"question":"def redact_python_coding(s: str) -> str: Replaces any instances of the words \\"Python\\" or \\"coding\\" with \\"[REDACTED]\\" in a case-insensitive manner. Args: s (str): The input string. Returns: str: The modified string with \\"Python\\" and \\"coding\\" replaced by \\"[REDACTED]\\". >>> redact_python_coding(\\"I love Python!\\") 'I love [REDACTED]!' >>> redact_python_coding(\\"Coding is fun.\\") '[REDACTED] is fun.' >>> redact_python_coding(\\"python and CODING are essential skills.\\") '[REDACTED] and [REDACTED] are essential skills.' >>> redact_python_coding(\\"Learning different languages is useful.\\") 'Learning different languages is useful.' >>> redact_python_coding(\\"My friend is named Py Thon and she loves codes.\\") 'My friend is named Py Thon and she loves codes.' >>> redact_python_coding(\\"python, Python, PYTHON, coding, Coding, CODING\\") '[REDACTED], [REDACTED], [REDACTED], [REDACTED], [REDACTED], [REDACTED]' >>> redact_python_coding(\\"\\") ''","solution":"import re def redact_python_coding(s): Replaces any instances of the words \\"Python\\" or \\"coding\\" with \\"[REDACTED]\\" in a case-insensitive manner. Args: s (str): The input string. Returns: str: The modified string with \\"Python\\" and \\"coding\\" replaced by \\"[REDACTED]\\". return re.sub(r'b(python|coding)b', '[REDACTED]', s, flags=re.IGNORECASE)"},{"question":"def merge_alternatingly(list1: list, list2: list) -> list: Merge two lists by alternatingly taking elements from each list. If one list is longer than the other, append the remaining elements of the longer list to the end of the merged list. >>> merge_alternatingly([1, 2, 3], ['a', 'b', 'c']) == [1, 'a', 2, 'b', 3, 'c'] >>> merge_alternatingly([1, 2, 3, 4], ['a', 'b', 'c']) == [1, 'a', 2, 'b', 3, 'c', 4] >>> merge_alternatingly([1, 2], ['a', 'b', 'c', 'd']) == [1, 'a', 2, 'b', 'c', 'd'] >>> merge_alternatingly([], ['a', 'b', 'c']) == ['a', 'b', 'c'] >>> merge_alternatingly([1, 2, 3], []) == [1, 2, 3] >>> merge_alternatingly([], []) == [] >>> merge_alternatingly([1], ['a']) == [1, 'a'] >>> merge_alternatingly([], [1, 2, 3]) == [1, 2, 3] >>> merge_alternatingly([1, 2, 3], []) == [1, 2, 3]","solution":"def merge_alternatingly(list1: list, list2: list) -> list: Merge two lists by alternatingly taking elements from each list. If one list is longer than the other, append the remaining elements of the longer list to the end of the merged list. merged_list = [] len1, len2 = len(list1), len(list2) min_length = min(len1, len2) for i in range(min_length): merged_list.append(list1[i]) merged_list.append(list2[i]) if len1 > len2: merged_list.extend(list1[min_length:]) elif len2 > len1: merged_list.extend(list2[min_length:]) return merged_list"},{"question":"from typing import List def reformat_dates(date_list: List[str]) -> List[str]: Given a list of dates in \\"DD-MM-YYYY\\" format, returns a list of dates in \\"YYYYMMDD\\" format, ignoring any invalid dates. >>> reformat_dates([\\"23-04-2021\\", \\"15-08-1947\\", \\"01-01-2020\\"]) == [\\"20210423\\", \\"19470815\\", \\"20200101\\"] >>> reformat_dates([\\"23-04-2021\\", \\"15-08-1947\\", \\"01-01-2020\\", \\"10-12-202\\"]) == [\\"20210423\\", \\"19470815\\", \\"20200101\\"] >>> reformat_dates([\\"23-04-21\\", \\"15-08-47\\", \\"01-01-202\\"]) == [] >>> reformat_dates([]) == [] >>> reformat_dates([\\"23-04-2021\\", \\"15-8-1947\\", \\"01-01-2020\\", \\"31-12-1999\\"]) == [\\"20210423\\", \\"20200101\\", \\"19991231\\"] >>> reformat_dates([\\"01-01-2000\\"]) == [\\"20000101\\"] >>> reformat_dates([\\"01-01-20\\"]) == [] pass","solution":"import re def reformat_dates(date_list): Given a list of dates in \\"DD-MM-YYYY\\" format, returns a list of dates in \\"YYYYMMDD\\" format, ignoring invalid dates. valid_dates = [] date_pattern = re.compile(r\\"^d{2}-d{2}-d{4}\\") for date in date_list: if date_pattern.match(date): day, month, year = date.split('-') valid_dates.append(f\\"{year}{month}{day}\\") return valid_dates"},{"question":"class Book: def __init__(self, title, author, publication_year, copies_sold): self.title = title self.author = author self.publication_year = publication_year self.copies_sold = copies_sold def sort_books(books): Sort a list of books. Firstly, sort by 'publication_year' in ascending order. If two or more books share the same publication year, further sort them by 'author' name in alphabetical order. If there are still ties, sort them by the 'copies_sold' in descending order. >>> books = [ ... Book('The Road', 'Cormac McCarthy', 2006, 3000), ... Book('No Country for Old Men', 'Cormac McCarthy', 2005, 2500), ... Book('The Road', 'Cormac McCarthy', 2006, 1500), ... Book('1984', 'George Orwell', 1949, 5000), ... Book('Brave New World', 'Aldous Huxley', 1932, 3700), ... ] >>> sorted_books = sort_books(books) >>> sorted_books[0].title == 'Brave New World' True >>> sorted_books[1].title == '1984' True >>> sorted_books[2].title == 'No Country for Old Men' True >>> sorted_books[3].title == 'The Road' and sorted_books[3].copies_sold == 3000 True >>> sorted_books[4].title == 'The Road' and sorted_books[4].copies_sold == 1500 True","solution":"class Book: def __init__(self, title, author, publication_year, copies_sold): self.title = title self.author = author self.publication_year = publication_year self.copies_sold = copies_sold def __repr__(self): return f\\"Book({self.title}, {self.author}, {self.publication_year}, {self.copies_sold})\\" def sort_books(books): return sorted(books, key=lambda x: (x.publication_year, x.author, -x.copies_sold)) # Sample books list provided in the problematic code books = [ Book('The Road', 'Cormac McCarthy', 2006, 3000), Book('No Country for Old Men', 'Cormac McCarthy', 2005, 2500), Book('The Road', 'Cormac McCarthy', 2006, 1500), Book('1984', 'George Orwell', 1949, 5000), Book('Brave New World', 'Aldous Huxley', 1932, 3700), ] # Printing the sorted list of books to validate sorted_books = sort_books(books) for book in sorted_books: print(book)"},{"question":"import datetime class Vehicle: A class to represent a vehicle with properties such as make, model, year, and VIN. Contains methods to start the engine, stop the engine, determine if the vehicle is an antique, and compare two vehicles based on their VINs. def __init__(self, make, model, year, vin): Initialize a new Vehicle instance. Parameters: make (str): The make of the vehicle. model (str): The model of the vehicle. year (int): The year the vehicle was made. vin (str): The Vehicle Identification Number (VIN) of the vehicle. Raises: ValueError: If any of the input parameters are invalid. pass def start_engine(self): Starts the vehicle's engine. Returns: str: A message indicating that the engine has started. pass def stop_engine(self): Stops the vehicle's engine. Returns: str: A message indicating that the engine has stopped. pass def is_antique(self): Determines if the vehicle is an antique (older than 25 years). Returns: bool: True if the vehicle is an antique, False otherwise. pass def __eq__(self, other): Compare two vehicles based on their VINs. Parameters: other (Vehicle): The other Vehicle instance to compare against. Returns: bool: True if both vehicles have the same VIN, False otherwise. pass","solution":"import datetime class Vehicle: def __init__(self, make, model, year, vin): Initialize a new Vehicle instance. Parameters: make (str): The make of the vehicle. model (str): The model of the vehicle. year (int): The year the vehicle was made. vin (str): The Vehicle Identification Number (VIN) of the vehicle. if not isinstance(make, str) or not make: raise ValueError(\\"Make must be a non-empty string\\") if not isinstance(model, str) or not model: raise ValueError(\\"Model must be a non-empty string\\") if not isinstance(year, int) or year <= 0 or year > datetime.datetime.now().year: raise ValueError(\\"Year must be a positive integer and within the realistic range\\") if not isinstance(vin, str) or len(vin) != 17: raise ValueError(\\"VIN must be a string of 17 characters\\") self.make = make self.model = model self.year = year self.vin = vin self.engine_running = False def start_engine(self): Starts the vehicle's engine. self.engine_running = True return \\"Engine started\\" def stop_engine(self): Stops the vehicle's engine. self.engine_running = False return \\"Engine stopped\\" def is_antique(self): Determines if the vehicle is an antique (older than 25 years). Returns: bool: True if the vehicle is an antique, False otherwise. current_year = datetime.datetime.now().year return current_year - self.year > 25 def __eq__(self, other): Compare two vehicles based on their VINs. Parameters: other (Vehicle): The other Vehicle instance to compare against. Returns: bool: True if both vehicles have the same VIN, False otherwise. if not isinstance(other, Vehicle): return False return self.vin == other.vin"},{"question":"def is_valid_parentheses(s: str) -> bool: Detect whether a given string contains a valid set of parentheses. The function returns True if the parentheses are correctly balanced and closed, and False otherwise. >>> is_valid_parentheses(\\"()[]{}\\") == True >>> is_valid_parentheses(\\"{[]}\\") == True >>> is_valid_parentheses(\\"(]\\") == False >>> is_valid_parentheses(\\"([)]\\") == False >>> is_valid_parentheses(\\"\\") == True # Test cases def test_valid_parentheses(): assert is_valid_parentheses(\\"()[]{}\\") == True assert is_valid_parentheses(\\"{[]}\\") == True assert is_valid_parentheses(\\"()\\") == True assert is_valid_parentheses(\\"([])\\") == True def test_mismatched_parentheses(): assert is_valid_parentheses(\\"(]\\") == False assert is_valid_parentheses(\\"([)]\\") == False assert is_valid_parentheses(\\"{[}]\\") == False assert is_valid_parentheses(\\"({[}])\\") == False def test_single_type_parentheses(): assert is_valid_parentheses(\\"((()))\\") == True assert is_valid_parentheses(\\"[[]]\\") == True assert is_valid_parentheses(\\"{{}}\\") == True def test_empty_parentheses(): assert is_valid_parentheses(\\"\\") == True def test_incomplete_parentheses(): assert is_valid_parentheses(\\"(\\") == False assert is_valid_parentheses(\\"]\\") == False assert is_valid_parentheses(\\"{\\") == False assert is_valid_parentheses(\\"}\\") == False def test_non_parentheses_characters(): assert is_valid_parentheses(\\"a(b)c\\") == True assert is_valid_parentheses(\\"d[e]f\\") == True assert is_valid_parentheses(\\"g{h}i\\") == True assert is_valid_parentheses(\\"j[k(l)m]n\\") == True assert is_valid_parentheses(\\"o{p[q]r}s\\") == True","solution":"def is_valid_parentheses(s): stack = [] mapping = {\\")\\": \\"(\\", \\"]\\": \\"[\\", \\"}\\": \\"{\\"} for char in s: if char in mapping.values(): stack.append(char) elif char in mapping.keys(): if stack == [] or mapping[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def reverse_words(input_string: str) -> str: This function reverses the order of characters within each word in the input string, while maintaining the original word order. The function should handle punctuation appropriately without altering the order of punctuation within the words. Parameters: input_string (str): The input string with words separated by spaces. Returns: str: The string with characters reversed within each word. >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"python\\") \\"nohtyp\\" >>> reverse_words(\\"hello, world!\\") \\",olleh !dlrow\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"this is a test\\") \\"siht si a tset\\" >>> reverse_words(\\" hello world \\") \\" olleh dlrow \\"","solution":"def reverse_words(input_string): This function reverses the order of characters within each word in the input string, while maintaining the original word order. Parameters: input_string (str): The input string with words separated by spaces. Returns: str: The string with characters reversed within each word. words = input_string.split(' ') reversed_words = [] for word in words: reversed_words.append(word[::-1]) return ' '.join(reversed_words)"},{"question":"def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Write a function that takes a list of integers and a target integer. The function should return a list of all unique pairs of integers from the input list that sum up to the target integer. Each pair should be sorted in ascending order and the list of pairs should also be sorted by the first element of each pair. >>> find_pairs_with_sum([1, 2, 3, 4, 3, 6, 8], 6) [(2, 4), (3, 3)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum([-1, -2, -3, -4, -5], -8) [(-5, -3)] >>> find_pairs_with_sum([-1, 1, -2, 2, 0, 3, -3], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs_with_sum([1, 1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs_with_sum([0, 0, 0, 1, 1], 0) [(0, 0)] >>> find_pairs_with_sum([1, 2, 3, 4, 5, -1, -2, -3, -4, -5], 0) [(-5, 5), (-4, 4), (-3, 3), (-2, 2), (-1, 1)] pass","solution":"def find_pairs_with_sum(nums, target): Returns a list of unique pairs (sorted in ascending order) from the input list that sum up to the target integer. The list of pairs is also sorted by the first element of each pair. found_pairs = set() pairs = [] # Create a set to track seen numbers and avoid duplicates seen = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) if pair not in found_pairs: found_pairs.add(pair) pairs.append(pair) seen.add(num) # Sort pairs by the first element of each pair pairs.sort() return pairs"},{"question":"def is_palindrome(s: str) -> bool: Checks if a given string is a valid palindrome, considering only alphanumeric characters and ignoring case sensitivity. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"1\\") True >>> is_palindrome(\\"!!!\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"MadamInEdenImAdam\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"1231\\") False","solution":"def is_palindrome(s): Checks if a given string is a valid palindrome, considering only alphanumeric characters and ignoring case sensitivity. # Remove non-alphanumeric characters and convert to lowercase filtered_s = ''.join(c.lower() for c in s if c.isalnum()) # Check if the filtered string is equal to its reverse return filtered_s == filtered_s[::-1]"},{"question":"def flatten_dict(nested_dict: dict, parent_key: str = '', separator: str = '.', empty_key_placeholder: str = '<empty>') -> dict: Flattens a nested dictionary into a single-level dictionary with dot-separated key paths. Handles leading/trailing spaces in keys and replaces empty keys with placeholder. Parameters: nested_dict (dict): The input nested dictionary to flatten. parent_key (str): The base string for key construction (used during recursion). separator (str): The separator used between levels of key parts. empty_key_placeholder (str): Placeholder string for empty keys. Returns: dict: The flattened dictionary. # Function implementation should go here. def test_flatten_simple_nested(): nested_dict = {'a': 1, 'b': {'c': 2}} expected = {'a': 1, 'b.c': 2} assert flatten_dict(nested_dict) == expected def test_flatten_multi_level_nested(): nested_dict = {'a': {'b': {'c': {'d': 1}}}} expected = {'a.b.c.d': 1} assert flatten_dict(nested_dict) == expected def test_flatten_with_leading_and_trailing_spaces(): nested_dict = {' a ': {' b ': 1}} expected = {'a.b': 1} assert flatten_dict(nested_dict) == expected def test_flatten_with_empty_keys(): nested_dict = {'': {'b': 1}} expected = {'<empty>.b': 1} assert flatten_dict(nested_dict) == expected def test_flatten_with_varied_depths(): nested_dict = {'a': 1, 'b': {'c': 2, 'd': {'e': 3}}, 'f': {'g': 4}} expected = {'a': 1, 'b.c': 2, 'b.d.e': 3, 'f.g': 4} assert flatten_dict(nested_dict) == expected def test_flatten_with_multiple_empty_keys(): nested_dict = {'': {'': {'': 1}}} expected = {'<empty>.<empty>.<empty>': 1} assert flatten_dict(nested_dict) == expected def test_flatten_with_mixed_content(): nested_dict = {'a': 1, 'b': {'c': 2, 'd': {'e': 3}, '': {'f': 4}}} expected = {'a': 1, 'b.c': 2, 'b.d.e': 3, 'b.<empty>.f': 4} assert flatten_dict(nested_dict) == expected","solution":"def flatten_dict(nested_dict, parent_key='', separator='.', empty_key_placeholder='<empty>'): Flattens a nested dictionary into a single-level dictionary with dot-separated keypaths. Handles leading/trailing spaces in keys and replaces empty keys with placeholder. Parameters: nested_dict (dict): The input nested dictionary to flatten. parent_key (str): The base string for key construction (used during recursion). separator (str): The separator used between levels of key parts. empty_key_placeholder (str): Placeholder string for empty keys. Returns: dict: The flattened dictionary. items = {} for k, v in nested_dict.items(): new_key = (parent_key + separator if parent_key else '') + (k.strip() if k else empty_key_placeholder) if isinstance(v, dict): items.update(flatten_dict(v, new_key, separator, empty_key_placeholder)) else: items[new_key] = v return items"},{"question":"import json def json_to_dict(json_str: str) -> dict: Convert the specified JSON structure into an equivalent Python dictionary. >>> json_to_dict(''' { \\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": false, \\"courses\\": [\\"Math\\", \\"Science\\"], \\"address\\": { \\"city\\": \\"New York\\", \\"postal_code\\": \\"10001\\" } }''') {'name': 'John', 'age': 30, 'is_student': False, 'courses': ['Math', 'Science'], 'address': {'city': 'New York', 'postal_code': '10001'}} >>> json_to_dict('{}') {} >>> json_to_dict(''' { \\"company\\": \\"Tech Corp\\", \\"employees\\": [ { \\"name\\": \\"Alice\\", \\"age\\": 28, \\"department\\": \\"Engineering\\" }, { \\"name\\": \\"Bob\\", \\"age\\": 34, \\"department\\": \\"HR\\" } ], \\"active\\": true }''') {'company': 'Tech Corp', 'employees': [{'name': 'Alice', 'age': 28, 'department': 'Engineering'}, {'name': 'Bob', 'age': 34, 'department': 'HR'}], 'active': True} >>> json_to_dict(''' { \\"integer\\": 123, \\"float\\": 45.67, \\"boolean\\": true, \\"null\\": null }''') {'integer': 123, 'float': 45.67, 'boolean': True, 'null': None}","solution":"import json def json_to_dict(json_str): Converts a JSON string into a Python dictionary. :param json_str: JSON string to convert :return: Python dictionary equivalent of the JSON string return json.loads(json_str)"},{"question":"def longest_subarray_with_abs_diff_at_most_one(arr: list) -> int: Determines the length of the longest contiguous subarray where the absolute difference between any two elements is at most 1. Parameters: arr (list): List of integers Returns: int: Length of the longest contiguous subarray Examples: >>> longest_subarray_with_abs_diff_at_most_one([]) 0 >>> longest_subarray_with_abs_diff_at_most_one([1]) 1 >>> longest_subarray_with_abs_diff_at_most_one([2, 2, 2, 2]) 4 >>> longest_subarray_with_abs_diff_at_most_one([1, 2, 3, 2, 1]) 5 >>> longest_subarray_with_abs_diff_at_most_one([1, 4, 5, 6, 2, 2]) 3 >>> longest_subarray_with_abs_diff_at_most_one([1, 2, 2, 5, 6, 9, 9, 8]) 3 >>> longest_subarray_with_abs_diff_at_most_one([5, 4, 3, 2, 1]) 5 >>> longest_subarray_with_abs_diff_at_most_one([1, 2, 3, 4, 5]) 5 >>> longest_subarray_with_abs_diff_at_most_one([1, 2, 1, 2, 1]) 5","solution":"def longest_subarray_with_abs_diff_at_most_one(arr): Determines the length of the longest contiguous subarray where the absolute difference between any two elements is at most 1. Parameters: arr (list): List of integers Returns: int: Length of the longest contiguous subarray if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) <= 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from collections import defaultdict from datetime import datetime, timedelta import numpy as np from sklearn.linear_model import LinearRegression def analyze_purchase_data(purchases): Analyzes customer purchase data to identify patterns and trends. Takes a list of tuples (customer_id, product_id, quantity, price, purchase_date). Returns: 1. Top 3 customers who have spent the most money in the past month. 2. Top 3 most frequently purchased products in the past month. 3. Total revenue generated in the past month. 4. Predicted total revenue for the next month based on linear regression model. if __name__ == \\"__main__\\": from datetime import datetime, timedelta def test_analyze_purchase_data(): current_date = datetime.now().strftime(\\"%Y-%m-%d\\") past_date = (datetime.now() - timedelta(days=30)).strftime(\\"%Y-%m-%d\\") purchases = [ (1, 'A', 2, 10, current_date), (1, 'B', 1, 20, current_date), (2, 'A', 1, 10, current_date), (3, 'B', 4, 20, current_date), (4, 'C', 1, 30, past_date), (2, 'A', 3, 10, past_date), (3, 'C', 1, 30, current_date) ] top_customers, top_products, total_revenue, predicted_revenue = analyze_purchase_data(purchases) assert len(top_customers) == 3 assert top_customers[0][0] == 3 assert top_customers[1][0] == 1 assert top_customers[2][0] == 2 assert len(top_products) == 3 assert top_products[0][0] == 'B' assert top_products[1][0] == 'A' assert top_products[2][0] == 'C' expected_revenue = (2*10 + 1*20 + 1 *10 + 4*20 + 1*30) assert total_revenue == expected_revenue assert isinstance(predicted_revenue, float) print(f\\"Predicted revenue next month: {predicted_revenue}\\") def test_no_purchase_data(): purchases = [] top_customers, top_products, total_revenue, predicted_revenue = analyze_purchase_data(purchases) assert top_customers == [] assert top_products == [] assert total_revenue == 0.0 assert predicted_revenue == 0.0 test_analyze_purchase_data() test_no_purchase_data()","solution":"from collections import defaultdict from datetime import datetime, timedelta import numpy as np from sklearn.linear_model import LinearRegression def analyze_purchase_data(purchases): Analyzes customer purchase data to identify patterns and trends. Takes a list of tuples (customer_id, product_id, quantity, price, purchase_date). Returns: 1. Top 3 customers who have spent the most money in the past month. 2. Top 3 most frequently purchased products in the past month. 3. Total revenue generated in the past month. 4. Predicted total revenue for the next month based on linear regression model. past_month_date = datetime.now() - timedelta(days=30) # Step 1: Filter purchases in the past month recent_purchases = [p for p in purchases if datetime.strptime(p[4], \\"%Y-%m-%d\\") >= past_month_date] # Dictionaries to collect total spent per customer and product counts customer_spent = defaultdict(float) product_count = defaultdict(int) total_revenue = 0.0 for purchase in recent_purchases: customer_id, product_id, quantity, price, purchase_date = purchase amount_spent = quantity * price customer_spent[customer_id] += amount_spent product_count[product_id] += quantity total_revenue += amount_spent # Step 2: Identify the top 3 customers who have spent the most money top_customers = sorted(customer_spent.items(), key=lambda x: x[1], reverse=True)[:3] # Step 3: Identify the top 3 most frequently purchased products top_products = sorted(product_count.items(), key=lambda x: x[1], reverse=True)[:3] # Step 4: Predict total revenue for the next month based on linear regression dates = [datetime.strptime(p[4], \\"%Y-%m-%d\\") for p in purchases] unique_dates = sorted(set(dates)) date_to_int = {date: i for i, date in enumerate(unique_dates)} data = [(date_to_int[datetime.strptime(p[4], \\"%Y-%m-%d\\")], p[2] * p[3]) for p in purchases] X = np.array([d[0] for d in data]).reshape(-1, 1) y = np.array([d[1] for d in data]) if len(X) < 2: predicted_revenue = 0.0 # Not enough data for prediction, return 0.0 else: model = LinearRegression() model.fit(X, y) next_month_date_int = len(unique_dates) predicted_revenue = model.predict([[next_month_date_int]])[0] return top_customers, top_products, total_revenue, predicted_revenue"},{"question":"def sort_by_length(strings): Takes a list of strings and returns a new list with the strings sorted by their lengths in ascending order. If two strings have the same length, they should appear in the result in the same order as they appear in the input list. :param strings: List of strings :return: List of strings sorted by length >>> sort_by_length(['apple', 'banana', 'pear', 'fig', 'grape']) ['fig', 'pear', 'apple', 'grape', 'banana'] >>> sort_by_length(['apple', 'kiwi', 'banana', 'pear']) ['kiwi', 'pear', 'apple', 'banana'] >>> sort_by_length(['a', 'bb', 'ccc', 'dddd']) ['a', 'bb', 'ccc', 'dddd'] >>> sort_by_length([]) [] >>> sort_by_length(['one', 'two', 'three', 'four']) ['one', 'two', 'four', 'three'] >>> sort_by_length(['same', 'size', 'test', 'case']) ['same', 'size', 'test', 'case'] >>> sort_by_length(['', 'a', 'aa', 'aaa']) ['', 'a', 'aa', 'aaa'] >>> sort_by_length(['a', '', 'aaa', 'aa']) ['', 'a', 'aa', 'aaa']","solution":"def sort_by_length(strings): Takes a list of strings and returns a new list with the strings sorted by their lengths in ascending order. If two strings have the same length, they should appear in the result in the same order as they appear in the input list. :param strings: List of strings :return: List of strings sorted by length return sorted(strings, key=len)"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using dynamic programming with optimized memory usage. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025 >>> fibonacci(100) 354224848179261915075","solution":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming with optimized memory usage. if n <= 1: return n a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"from typing import List, Dict def count_occurrences_with_mode(input_list: List[int]) -> Dict: Processes a list of integers and returns a dictionary containing the number of occurrences of each integer and the mode (the integer that appears the most frequently). >>> count_occurrences_with_mode([4, 4, 1, 2, 2, 3, 3, 3, -1, -1, -1, -1]) {-1: 4, 1: 1, 2: 2, 3: 3, 4: 2, \\"mode\\": -1} >>> count_occurrences_with_mode([]) {\\"mode\\": None} >>> count_occurrences_with_mode([1]) {1: 1, \\"mode\\": 1} >>> count_occurrences_with_mode([1, 2, 3, 4, 5]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, \\"mode\\": 1} # or 2, 3, 4, 5 since all occur once >>> count_occurrences_with_mode([2, 2, 2, 2]) {2: 4, \\"mode\\": 2} >>> count_occurrences_with_mode([-1, -2, -3, -1, -2, -1]) {-1: 3, -2: 2, -3: 1, \\"mode\\": -1} >>> count_occurrences_with_mode([-1, 1, -1, 1, 2, 1, -1]) {-1: 3, 1: 3, 2: 1, \\"mode\\": -1} # -1 or 1 can be mode since both have highest frequency","solution":"from typing import List, Dict def count_occurrences_with_mode(input_list: List[int]) -> Dict: Processes a list of integers and returns a dictionary containing the number of occurrences of each integer and the mode (the integer that appears the most frequently). if not input_list: return {\\"mode\\": None} # handle empty list case occurrence_dict = {} for number in input_list: if number in occurrence_dict: occurrence_dict[number] += 1 else: occurrence_dict[number] = 1 # find the mode mode = max(occurrence_dict, key=occurrence_dict.get) occurrence_dict[\\"mode\\"] = mode return occurrence_dict"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if a binary tree is balanced. A balanced binary tree is defined as a tree where the depth of all leaf nodes or all nodes with one child differs by no more than one. # Below are the test cases def test_empty_tree(): assert is_balanced(None) == True def test_single_node_tree(): root = TreeNode(1) assert is_balanced(root) == True def test_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert is_balanced(root) == True def test_unbalanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(4) root.left.left.left = TreeNode(8) assert is_balanced(root) == False def test_balanced_tree_with_single_child_nodes(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(4) assert is_balanced(root) == True","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Determine if a binary tree is balanced. A balanced binary tree is defined as a tree where the depth of all leaf nodes or all nodes with one child differs by no more than one. def check_balance(node): if not node: return 0, True left_depth, left_balanced = check_balance(node.left) right_depth, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return max(left_depth, right_depth) + 1, False if abs(left_depth - right_depth) > 1: return max(left_depth, right_depth) + 1, False return max(left_depth, right_depth) + 1, True _, is_bal = check_balance(root) return is_bal"},{"question":"class HashTable: A simple implementation of a hash table with separate chaining. The hash table supports basic operations like set, get, and delete. >>> ht = HashTable() >>> ht.set(\\"key1\\", \\"value1\\") >>> assert ht.get(\\"key1\\") == \\"value1\\" >>> ht.set(\\"key2\\", \\"value2\\") >>> assert ht.get(\\"key2\\") == \\"value2\\" >>> ht.set(\\"key1\\", \\"value1_updated\\") >>> assert ht.get(\\"key1\\") == \\"value1_updated\\" >>> assert ht.get(\\"nonexistent\\") is None >>> assert ht.delete(\\"key1\\") is True >>> assert ht.get(\\"key1\\") is None >>> assert ht.delete(\\"key1\\") is False >>> ht = HashTable(size=5) # Small size to force collisions >>> ht.set(\\"key1\\", \\"value1\\") >>> ht.set(\\"key2\\", \\"value2\\") # Both keys may collide >>> assert ht.get(\\"key1\\") == \\"value1\\" >>> assert ht.get(\\"key2\\") == \\"value2\\" >>> ht.delete(\\"key1\\") >>> assert ht.get(\\"key1\\") is None >>> assert ht.get(\\"key2\\") == \\"value2\\" def __init__(self, size=1024): self.size = size self.table = [[] for _ in range(size)] def _hash(self, key): return hash(key) % self.size def set(self, key, value): index = self._hash(key) for item in self.table[index]: if item[0] == key: item[1] = value return self.table[index].append([key, value]) def get(self, key): index = self._hash(key) for item in self.table[index]: if item[0] == key: return item[1] return None def delete(self, key): index = self._hash(key) for i, item in enumerate(self.table[index]): if item[0] == key: del self.table[index][i] return True return False","solution":"class HashTable: def __init__(self, size=1024): self.size = size self.table = [[] for _ in range(size)] def _hash(self, key): return hash(key) % self.size def set(self, key, value): index = self._hash(key) for item in self.table[index]: if item[0] == key: item[1] = value return self.table[index].append([key, value]) def get(self, key): index = self._hash(key) for item in self.table[index]: if item[0] == key: return item[1] return None def delete(self, key): index = self._hash(key) for i, item in enumerate(self.table[index]): if item[0] == key: del self.table[index][i] return True return False"},{"question":"from typing import List def common_elements(list1: List[int], list2: List[int]) -> List[int]: Write a Python function that takes in two sorted lists of integers and returns a new list that contains only the elements that are common to both lists, without duplicates and in ascending order. The function should be efficient, having an overall time complexity of O(n + m), where n and m are the lengths of the input lists. The lists may contain negative integers and zeros, and both will already be sorted in non-decreasing order. You should not use any extra space beyond what is necessary for the output list. Args: list1 (List[int]): The first sorted list of integers. list2 (List[int]): The second sorted list of integers. Returns: List[int]: A sorted list that contains only the elements that are common to both input lists, without duplicates. Examples: >>> common_elements([1, 2, 3, 4], [2, 4, 6, 8]) [2, 4] >>> common_elements([1, 1, 2, 2], [1, 1, 1, 2, 2, 3]) [1, 2] def test_common_elements(): # Test cases for common_elements assert common_elements([1, 2, 3, 4], [2, 4, 6, 8]) == [2, 4] assert common_elements([1, 1, 2, 2], [1, 1, 1, 2, 2, 3]) == [1, 2] assert common_elements([-5, -3, -1, 0, 3, 5], [-5, -2, 0, 3, 5]) == [-5, 0, 3, 5] assert common_elements([0, 1, 2], [3, 4, 5]) == [] assert common_elements([1, 2, 3], [1, 2, 3]) == [1, 2, 3] assert common_elements([], [1, 2, 3]) == [] assert common_elements([1, 2, 3], []) == [] assert common_elements([], []) == []","solution":"def common_elements(list1, list2): Returns a sorted list that contains only the elements that are common to both input lists, without duplicates. result = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: if not result or list1[i] != result[-1]: # Avoid duplicates in the result result.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return result"},{"question":"from typing import List def longest_subarray_with_same_diff(arr: List[int]) -> int: Write a function that takes in a list of integers and returns the length of the longest contiguous subarray where the difference between any two consecutive elements is the same. >>> longest_subarray_with_same_diff([1, 2, 3, 4, 5, 8, 9, 10]) == 5 >>> longest_subarray_with_same_diff([10, 20, 30, 40, 50, 60]) == 6 >>> longest_subarray_with_same_diff([100, 105, 110, 115, 120, 150]) == 5 >>> longest_subarray_with_same_diff([]) == 0 Args: arr (List[int]): List of integers Returns: int: Length of the longest contiguous subarray with same difference","solution":"from typing import List def longest_subarray_with_same_diff(arr: List[int]) -> int: if len(arr) < 2: return len(arr) max_len = 1 current_diff = None current_len = 1 for i in range(1, len(arr)): diff = arr[i] - arr[i - 1] if diff == current_diff: current_len += 1 else: current_diff = diff current_len = 2 # Start new subarray including the last element and the current one max_len = max(max_len, current_len) return max_len"},{"question":"def reverse_strings(strings: List[str]) -> List[str]: Accepts a list of strings and returns a new list where each string is reversed. >>> reverse_strings([\\"hello\\", \\"world\\", \\"!\\"]) ['olleh', 'dlrow', '!'] >>> reverse_strings([\\"\\"]) [\\"\\"] >>> reverse_strings([\\"a\\"]) [\\"a\\"] >>> reverse_strings([\\"12345\\", \\"abcde\\"]) [\\"54321\\", \\"edcba\\"] >>> reverse_strings([\\"racecar\\", \\"madam\\"]) [\\"racecar\\", \\"madam\\"] >>> reverse_strings([\\"@!#\\", \\"test 123\\"]) [\\"#!@\\", \\"321 tset\\"]","solution":"def reverse_strings(strings): Accepts a list of strings and returns a new list where each string is reversed. reversed_list = [] for s in strings: reversed_string = '' for char in s: reversed_string = char + reversed_string reversed_list.append(reversed_string) return reversed_list"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds unique pairs of integers from the input list that add up to the target value. Each pair should be a tuple, and the output list should be sorted in lexicographical order. Args: nums: List of integers. target: Integer target value. Returns: List of unique pairs (as tuples) that add up to the target value, sorted lexicographically. >>> find_pairs([1, 2, 3, 4, 3, 2], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([-1, 2, 3, -3, 4], 1) [(-3, 4), (-1, 2)] >>> find_pairs([1, 1, 2, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs([], 5) [] >>> find_pairs([-1, 1, -2, 2], 0) [(-2, 2), (-1, 1)]","solution":"def find_pairs(nums, target): Finds unique pairs of integers from the input list that add up to the target value. Args: nums: List of integers. target: Integer target value. Returns: List of unique pairs (as tuples) that add up to the target value, sorted lexicographically. nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"from typing import List def perfect_squares(lst: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list containing only the integers that are perfect squares, sorted in ascending order. Additionally, the function should count the number of perfect squares identified and append this count as the last element of the returned list. >>> perfect_squares([16, 10, 25, 7, 1, 30, 4]) [1, 4, 16, 25, 4] >>> perfect_squares([49, 50, 51, 52, 9, 3, 2]) [9, 49, 2] def is_perfect_square(n: int) -> bool: Helper function to check if a number is a perfect square.","solution":"import math def is_perfect_square(n): if n < 0: return False root = int(math.sqrt(n)) return root * root == n def perfect_squares(lst): Returns a new list that contains only the perfect squares from the input list, sorted in ascending order, and appends the count of perfect squares as the last element. perfect_squares_list = [x for x in lst if is_perfect_square(x)] perfect_squares_list.sort() perfect_squares_list.append(len(perfect_squares_list)) return perfect_squares_list"},{"question":"from typing import List def majorityElement(nums: List[int]) -> int: Returns the majority element from the list nums. The majority element is the element that appears more than n/2 times where n is the length of the array. >>> majorityElement([3, 2, 3]) == 3 >>> majorityElement([2, 2, 1, 1, 1, 2, 2]) == 2 >>> majorityElement([1]) == 1 >>> majorityElement([4, 4, 4, 4]) == 4 >>> majorityElement([1, 2, 1, 2, 1, 2, 1]) == 1 >>> majorityElement([1]*501 + [2]*499) == 1 # Your code here def test_majorityElement_simple(): assert majorityElement([3, 2, 3]) == 3 def test_majorityElement_with_different_elements(): assert majorityElement([2, 2, 1, 1, 1, 2, 2]) == 2 def test_majorityElement_single_element(): assert majorityElement([1]) == 1 def test_majorityElement_all_same_elements(): assert majorityElement([4, 4, 4, 4]) == 4 def test_majorityElement_alternate_element(): assert majorityElement([1, 2, 1, 2, 1, 2, 1]) == 1 def test_majorityElement_large_list(): nums = [1]*501 + [2]*499 assert majorityElement(nums) == 1","solution":"def majorityElement(nums): Returns the majority element from the list nums. The majority element is the element that appears more than n/2 times where n is the length of the array. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += 1 if num == candidate else -1 return candidate"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Develop a function that takes a list of integers and returns a new list containing only the prime numbers from the original list. >>> filter_primes([]) [] >>> filter_primes([0, 1, -1, -2, 4, 6, 8, 9, 10]) [] >>> filter_primes([2, 3, 5, 7, 11, 13, 17]) [2, 3, 5, 7, 11, 13, 17] >>> filter_primes([2, 4, 6, 7, 9, 10, 11]) [2, 7, 11] >>> filter_primes([2, 3, -3, -5, 5, 9, 11]) [2, 3, 5, 11] >>> filter_primes([3]) [3] >>> filter_primes([4]) [] >>> filter_primes([17, 19, 23, 24, 25, 29, 31, 33]) [17, 19, 23, 29, 31]","solution":"def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def filter_primes(numbers): return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. def filter_primes(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list with only the prime numbers from the original list. >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 10, 12, 14]) == [] >>> filter_primes([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] >>> filter_primes([]) == [] >>> filter_primes([-10, -3, -2, 0, 1, 3, 5]) == [3, 5]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def kth_smallest(array: List[int], k: int) -> Optional[int]: Returns the k-th smallest element in the array without changing the original array's order. If k is out of bounds, return None. >>> kth_smallest([3, 1, 2, 4, 5], 3) == 3 >>> kth_smallest([3, 1, 2, 4, 5], 1) == 1 >>> kth_smallest([3, 1, 2, 4, 5], 5) == 5 >>> kth_smallest([3, 1, 2, 4, 5], 6) == None >>> kth_smallest([3, 1, 2, 4, 5], 0) == None >>> kth_smallest([3, 3, 2, 4, 5], 3) == 3 >>> kth_smallest([1, 1, 1, 1, 1], 3) == 1 >>> kth_smallest([1, 1, 1, 1, 1], 5) == 1 >>> kth_smallest(list(range(1000, 0, -1)), 100) == 100 >>> kth_smallest(list(range(1000, 0, -1)), 900) == 900","solution":"def kth_smallest(array, k): Returns the k-th smallest element in the array without changing the original array's order. If k is out of bounds, return None. if k < 1 or k > len(array): return None def quickselect(start, end, rank): pivot = array[end] low = start for i in range(start, end): if array[i] < pivot: array[i], array[low] = array[low], array[i] low += 1 array[low], array[end] = array[end], array[low] if low == rank: return array[low] elif low < rank: return quickselect(low + 1, end, rank) else: return quickselect(start, low - 1, rank) # Make a copy of the array to not disturb the original order array_copy = array[:] return quickselect(0, len(array_copy) - 1, k - 1)"},{"question":"def find_unique_numbers(nums: List[int]) -> List[int]: Given a list of integers, returns a list containing only the elements that appear exactly once in the input list. The order of the returned elements should be the same as their order of appearance in the input list. >>> find_unique_numbers([4, 5, 7, 4, 8, 5]) [7, 8] >>> find_unique_numbers([10, 20, 30, 20, 40, 50]) [10, 30, 40, 50] >>> find_unique_numbers([1, 2, 2, 3, 4, 4, 5]) [1, 3, 5] # Implement the function here pass from typing import List def test_example_1(): assert find_unique_numbers([4, 5, 7, 4, 8, 5]) == [7, 8] def test_example_2(): assert find_unique_numbers([10, 20, 30, 20, 40, 50]) == [10, 30, 40, 50] def test_example_3(): assert find_unique_numbers([1, 2, 2, 3, 4, 4, 5]) == [1, 3, 5] def test_all_unique(): assert find_unique_numbers([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_no_unique(): assert find_unique_numbers([1, 1, 2, 2, 3, 3]) == [] def test_single_element(): assert find_unique_numbers([1]) == [1] def test_mixed_elements(): assert find_unique_numbers([1, 1, 2, 3, 4, 3, 5, 5, 6]) == [2, 4, 6] def test_negative_and_positive(): assert find_unique_numbers([-1, -2, -2, 3, 4, 3, 5, -5, 6]) == [-1, 4, 5, -5, 6]","solution":"def find_unique_numbers(nums): Returns a list containing only the elements that appear exactly once in the input list. count = {} for num in nums: if num in count: count[num] += 1 else: count[num] = 1 unique_nums = [num for num in nums if count[num] == 1] return unique_nums"},{"question":"def is_toeplitz_matrix(matrix: List[List[int]]) -> bool: Checks if the given 2-dimensional list (matrix) is a Toeplitz matrix. A Toeplitz matrix is one where each descending diagonal from left to right is constant. Parameters: matrix (list of list of int): The 2-dimensional list representing the matrix. Returns: bool: True if the matrix is a Toeplitz matrix, False otherwise. >>> is_toeplitz_matrix([[1, 2, 3, 4],[5, 1, 2, 3],[6, 5, 1, 2]]) == True >>> is_toeplitz_matrix([[1, 2, 3, 4],[5, 1, 9, 3],[6, 5, 1, 2]]) == False >>> is_toeplitz_matrix([[1, 2, 3, 4]]) == True >>> is_toeplitz_matrix([[1],[1],[1]]) == True >>> is_toeplitz_matrix([]) == False >>> is_toeplitz_matrix([[1]]) == True","solution":"def is_toeplitz_matrix(matrix): Checks if the given 2-dimensional list (matrix) is a Toeplitz matrix. A Toeplitz matrix is one where each descending diagonal from left to right is constant. Parameters: matrix (list of list of int): The 2-dimensional list representing the matrix. Returns: bool: True if the matrix is a Toeplitz matrix, False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs of integers from the array that sum up to the target integer. Parameters: arr (list): A list of integers. target (int): The target sum. Returns: list: A list of tuples, where each tuple contains a pair of integers that sum up to the target. Handle edge cases where the array is empty, contains fewer than two elements, or where no pairs sum up to the target integer. >>> find_pairs_with_sum([], 10) [] >>> find_pairs_with_sum([1, 2, 3], 10) [] >>> find_pairs_with_sum([1, 2, 3, 7], 10) [(3, 7)] >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6, 7, 8], 10) [(2, 8), (3, 7), (4, 6)] >>> find_pairs_with_sum([5, 5, 5, 5], 10) [(5, 5)] >>> find_pairs_with_sum([1, 2, 3, 4, 3, 6, 7, 2, 8], 10) [(2, 8), (3, 7), (4, 6)] >>> find_pairs_with_sum([1, -1, 2, -2, 3, -3, 4, -4], 0) [(-1, 1), (-2, 2), (-3, 3), (-4, 4)]","solution":"def find_pairs_with_sum(arr, target): Returns a list of unique pairs of integers from the array that sum up to the target integer. Parameters: arr (list): A list of integers. target (int): The target sum. Returns: list: A list of tuples, where each tuple contains a pair of integers that sum up to the target. seen = set() output = set() for num in arr: complement = target - num if complement in seen: output.add((min(num, complement), max(num, complement))) seen.add(num) return list(output)"},{"question":"def product_except_self(nums): Given a list of integers, returns a new list such that each element at index i is the product of all elements in the original list except the one at i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([3, 5]) [5, 3] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] # Initialize the left and right product lists and the result list left_products = [1] * len(nums) right_products = [1] * len(nums) result = [1] * len(nums) # Calculate left products left_cum_product = 1 for i in range(len(nums)): left_products[i] = left_cum_product left_cum_product *= nums[i] # Calculate right products right_cum_product = 1 for i in range(len(nums) - 1, -1, -1): right_products[i] = right_cum_product right_cum_product *= nums[i] # Calculate the result by multiplying left and right products for i in range(len(nums)): result[i] = left_products[i] * right_products[i] return result","solution":"def product_except_self(nums): Given a list of integers, returns a new list such that each element at index i is the product of all elements in the original list except the one at i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] # Initialize the left and right product lists and the result list left_products = [1] * len(nums) right_products = [1] * len(nums) result = [1] * len(nums) # Calculate left products left_cum_product = 1 for i in range(len(nums)): left_products[i] = left_cum_product left_cum_product *= nums[i] # Calculate right products right_cum_product = 1 for i in range(len(nums) - 1, -1, -1): right_products[i] = right_cum_product right_cum_product *= nums[i] # Calculate the result by multiplying left and right products for i in range(len(nums)): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List, Dict def names_to_dict(names: List[str]) -> Dict[str, List[str]]: Converts a list of full names into a dictionary with first names as keys and lists of last names as values. Args: names (list of str): List of full names (first and last name). Returns: dict: Dictionary with first names as keys and lists of corresponding last names as values. Examples: >>> names_to_dict([\\"John Smith\\", \\"Jane Doe\\", \\"John Doe\\", \\"Anna Smith\\"]) {\\"John\\": [\\"Smith\\", \\"Doe\\"], \\"Jane\\": [\\"Doe\\"], \\"Anna\\": [\\"Smith\\"]} >>> names_to_dict([]) {} >>> names_to_dict([\\"John Smith\\", \\"John Doe\\", \\"John Brown\\"]) {\\"John\\": [\\"Smith\\", \\"Doe\\", \\"Brown\\"]} >>> names_to_dict([\\"john smith\\", \\"Jane DOE\\", \\"JOHN DOE\\", \\"Anna SMITH\\"]) {\\"John\\": [\\"Smith\\", \\"Doe\\"], \\"Jane\\": [\\"Doe\\"], \\"Anna\\": [\\"Smith\\"]} >>> names_to_dict([\\"john smith\\", \\"jane doe\\", \\"John Doe\\", \\"anna SMITH\\"]) {\\"John\\": [\\"Smith\\", \\"Doe\\"], \\"Jane\\": [\\"Doe\\"], \\"Anna\\": [\\"Smith\\"]}","solution":"def names_to_dict(names): Converts a list of full names into a dictionary with first names as keys and lists of last names as values. Args: names (list of str): List of full names (first and last name). Returns: dict: Dictionary with first names as keys and lists of corresponding last names as values. name_dict = {} for full_name in names: parts = full_name.split() if len(parts) == 2: first, last = parts # Capitalize the first letter of each name part and make other letters lowercase first = first.capitalize() last = last.capitalize() if first in name_dict: name_dict[first].append(last) else: name_dict[first] = [last] return name_dict"},{"question":"def filter_strings_starting_with_a(strings): Returns a list of strings from the input list that start with the letter 'a' (case insensitive). Args: strings (list of str): A list of strings. Returns: list of str: A list containing only the strings that start with the letter 'a'. # Implement your code here # Test cases def test_no_strings_start_with_a(): assert filter_strings_starting_with_a([\\"hello\\", \\"world\\", \\"python\\"]) == [] def test_all_strings_start_with_a(): assert filter_strings_starting_with_a([\\"apple\\", \\"Avocado\\", \\"Ant\\"]) == [\\"apple\\", \\"Avocado\\", \\"Ant\\"] def test_some_strings_start_with_a(): assert filter_strings_starting_with_a([\\"banana\\", \\"apple\\", \\"grape\\", \\"apricot\\"]) == [\\"apple\\", \\"apricot\\"] def test_mixed_case_strings(): assert filter_strings_starting_with_a([\\"Apple\\", \\"avocado\\", \\"banana\\", \\"Apricot\\"]) == [\\"Apple\\", \\"avocado\\", \\"Apricot\\"] def test_empty_list(): assert filter_strings_starting_with_a([]) == [] def test_strings_with_varied_first_characters(): assert filter_strings_starting_with_a([\\"apple\\", \\"Banana\\", \\"cherry\\", \\"date\\", \\"Elderberry\\", \\"fig\\", \\"grape\\", \\"Honeydew\\", \\"kiwi\\", \\"lemon\\"]) == [\\"apple\\"]","solution":"def filter_strings_starting_with_a(strings): Returns a list of strings from the input list that start with the letter 'a' (case insensitive). Args: strings (list of str): A list of strings. Returns: list of str: A list containing only the strings that start with the letter 'a'. result = [] for string in strings: if string.lower().startswith('a'): result.append(string) return result"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Find the number of contiguous subarrays that have a sum equal to \`k\`. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([-1, -1, 1], 0) 1","solution":"def subarray_sum(nums, k): Returns the number of contiguous subarrays that sum to k. Parameters: nums (List[int]): The list of integers. k (int): The target sum. Returns: int: The number of contiguous subarrays with a sum equal to k. count = 0 sum_dict = {0: 1} current_sum = 0 for num in nums: current_sum += num if (current_sum - k) in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def max_profit_days(prices: list) -> tuple: Given a list of stock prices, return a tuple of the best days (indices) to buy and sell the stock for maximum profit. If no profit can be made, return (None, None). >>> max_profit_days([7.5, 1.2, 5.3, 3.8, 6.1, 4.0]) (1, 4) >>> max_profit_days([7.5, 6.4, 4.3, 3.2]) (None, None) >>> max_profit_days([1, 2, 3, 4, 5]) (0, 4) >>> max_profit_days([5, 4, 3, 2, 1]) (None, None) >>> max_profit_days([5]) (None, None) >>> max_profit_days([1, 5]) (0, 1) >>> max_profit_days([5, 1]) (None, None) >>> prices = list(range(1000, 0, -1)) >>> max_profit_days(prices) (None, None) >>> max_profit_days([3, 2, 6, 5, 0, 3]) (1, 2)","solution":"def max_profit_days(prices): Given a list of stock prices, return a tuple of the best days (indices) to buy and sell the stock for maximum profit. If no profit can be made, return (None, None). if len(prices) < 2: return (None, None) min_price_index = 0 max_profit = 0 buy_day = None sell_day = None for i in range(1, len(prices)): if prices[i] < prices[min_price_index]: min_price_index = i current_profit = prices[i] - prices[min_price_index] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_index sell_day = i if max_profit == 0: return (None, None) return (buy_day, sell_day)"},{"question":"def process_orders(N, items, M, orders): Process the orders and update the stock levels for each item type. Args: N (int): Number of item types. items (list of tuples): List of tuples representing items with their prices and stock levels. M (int): Number of orders. orders (list of tuples): List of tuples representing the orders with item types and quantities requested. Returns: list: List of tuples representing the updated stock levels for each item type. >>> process_orders(3, [(10, 100), (20, 200), (30, 300)], 2, [(1, 50), (3, 100)]) [(10, 50), (20, 200), (30, 200)] >>> process_orders(3, [(10, 100), (20, 200), (30, 300)], 3, [(1, 50), (2, 150), (3, 100)]) [(10, 50), (20, 50), (30, 200)] >>> process_orders(3, [(10, 10), (20, 20), (30, 30)], 3, [(1, 10), (2, 20), (3, 30)]) [(10, 0), (20, 0), (30, 0)] >>> process_orders(3, [(10, 5), (20, 10), (30, 15)], 3, [(1, 10), (2, 10), (3, 20)]) [(10, 0), (20, 0), (30, 0)] >>> process_orders(3, [(10, 100), (20, 200), (30, 300)], 0, []) [(10, 100), (20, 200), (30, 300)] >>> process_orders(2, [(15, 100), (30, 50)], 2, [(1, 20), (2, 50)]) [(15, 80), (30, 0)]","solution":"def process_orders(N, items, M, orders): updated_items = items[:] for k, q in orders: item_index = k - 1 item_price, item_stock = updated_items[item_index] if item_stock >= q: updated_items[item_index] = (item_price, item_stock - q) else: updated_items[item_index] = (item_price, 0) return updated_items"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression passed as a string and returns the result as a float. The function handles operator precedence and parentheses for grouping operations. Returns None for empty or invalid expressions. >>> evaluate_expression(\\"1 + 2\\") == 3.0 >>> evaluate_expression(\\"10 - 4\\") == 6.0 >>> evaluate_expression(\\"3 * 4\\") == 12.0 >>> evaluate_expression(\\"20 / 4\\") == 5.0 >>> evaluate_expression(\\"2 + 3 * 4\\") == 14.0 >>> evaluate_expression(\\"(2 + 3) * 4\\") == 20.0 >>> evaluate_expression(\\"2 * (3 + 4)\\") == 14.0 >>> evaluate_expression(\\"2 * (3 + (4 * 5))\\") == 46.0 >>> evaluate_expression(\\"2.5 * 3.2\\") == 8.0 >>> evaluate_expression(\\"7.0 / 2\\") == 3.5 >>> evaluate_expression(\\"2 + * 3\\") is None >>> evaluate_expression(\\"abc\\") is None >>> evaluate_expression(\\"\\") is None >>> evaluate_expression(\\"5 / 0\\") is None >>> evaluate_expression(\\"3 + 5 / 0\\") is None","solution":"def evaluate_expression(expression): Evaluates a mathematical expression passed as a string and returns the result as a float. The function handles operator precedence and parentheses for grouping operations. Returns None for empty or invalid expressions. if not expression: return None try: result = eval(expression) return float(result) except (SyntaxError, NameError, TypeError, ZeroDivisionError): return None"},{"question":"import csv import re from datetime import datetime def is_valid_email(email): Validates the email address using a regex pattern. pattern = r'^b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b' return re.match(pattern, email) is not None def process_csv(input_file: str, output_file: str) -> None: Processes the CSV file to retrieve the top 5 most recent signups, validates emails, and writes the output to a new CSV file. Args: input_file (str): Path to the input CSV file containing user data. output_file (str): Path to the output CSV file to write the top 5 recent signups. >>> process_csv('path/to/input.csv', 'path/to/output.csv')","solution":"import csv import re from datetime import datetime def is_valid_email(email): Validates the email address using a regex pattern. regex = r'^b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b' return re.match(regex, email) is not None def process_csv(input_file, output_file): Processes the CSV file to retrieve the top 5 most recent signups, validates emails, and writes the output to a new CSV file. users = [] with open(input_file, mode='r', newline='') as csvfile: reader = csv.DictReader(csvfile) for row in reader: if is_valid_email(row['Email']): row['SignupDate'] = datetime.strptime(row['SignupDate'], '%Y-%m-%d') users.append(row) sorted_users = sorted(users, key=lambda x: x['SignupDate'], reverse=True)[:5] with open(output_file, mode='w', newline='') as csvfile: fieldnames = ['UserID', 'Email'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for user in sorted_users: writer.writerow({'UserID': user['UserID'], 'Email': user['Email']})"},{"question":"def find_k_missing_numbers(arr, k): Returns a sorted list of the k missing numbers from the provided list. You are provided with a list of unique integers where each integer is between 1 and n (inclusive), where n is the length of the list plus k. The list contains numbers from this range with k numbers missing. Your task is to return a sorted list of the k missing numbers. Parameters: arr (list): A list of unique integers. k (int): The number of missing numbers to find. Returns: list: A sorted list of the k missing numbers. Examples: >>> find_k_missing_numbers([1, 3, 4, 5], 1) [2] >>> find_k_missing_numbers([2, 3, 7, 4, 8, 9], 4) [1, 5, 6, 10] >>> find_k_missing_numbers([1, 2, 3, 6, 8], 3) [4, 5, 7]","solution":"def find_k_missing_numbers(arr, k): Returns a sorted list of the k missing numbers from the provided list. Parameters: arr (list): A list of unique integers. k (int): The number of missing numbers to find. Returns: list: A sorted list of the k missing numbers. n = len(arr) + k full_set = set(range(1, n + 1)) missing_nums = sorted(full_set - set(arr)) return missing_nums"},{"question":"def count_islands(matrix: List[List[str]]) -> int: Create a function that takes a 2D grid consisting of '1's (land) and '0's (water) and returns the number of islands using Depth-First Search (DFS). >>> matrix = [ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ] >>> count_islands(matrix) 3 >>> matrix = [ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ] >>> count_islands(matrix) 1 >>> matrix = [ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ] >>> count_islands(matrix) 0 >>> matrix = [ ... ['1', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '1'] ... ] >>> count_islands(matrix) 3 >>> matrix = [ ... ['1', '1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '1', '1'], ... ['0', '0', '1', '0', '0', '1'], ... ['0', '0', '0', '1', '1', '0'] ... ] >>> count_islands(matrix) 4 >>> matrix = [] >>> count_islands(matrix) 0 >>> matrix = [['1']] >>> count_islands(matrix) 1 >>> matrix = [['0']] >>> count_islands(matrix) 0 >>> matrix = [ ... ['1', '0', '1'], ... ['0', '1', '0'], ... ['1', '0', '1'] ... ] >>> count_islands(matrix) 5","solution":"def count_islands(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or matrix[r][c] == '0': return matrix[r][c] = '0' # Mark as visited # Visit all adjacent cells (up, down, left, right) dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) islands_count = 0 for r in range(rows): for c in range(cols): if matrix[r][c] == '1': islands_count += 1 dfs(r, c) return islands_count"},{"question":"def reverse_string(s: str) -> str: Returns the string in reverse order, ignoring spaces and punctuation. >>> reverse_string(\\"Hello, World!\\") == \\"dlroWolleH\\" >>> reverse_string(\\"Python is fun!\\") == \\"nufsinohtyP\\" >>> reverse_string(\\"abcde\\") == \\"edcba\\" >>> reverse_string(\\"!!,,??\\") == \\"\\" >>> reverse_string(\\"\\") == \\"\\" >>> reverse_string(\\" \\") == \\"\\" >>> reverse_string(\\"!Python@2023\\") == \\"3202nohtyP\\" pass","solution":"def reverse_string(s): Returns the string in reverse order, ignoring spaces and punctuation. import string # Define the punctuation to ignore excluded_characters = string.punctuation + \\" \\" # Remove the excluded characters from the string cleaned_string = ''.join([char for char in s if char not in excluded_characters]) # Reverse the cleaned string reversed_string = cleaned_string[::-1] return reversed_string"},{"question":"def sort_by_common_chars(strings, target): Sort a list of strings by the number of characters they have in common with the target string. Only consider common characters once (even if they occur multiple times in both strings). If two strings have the same number of common characters, they should retain their original order. >>> sort_by_common_chars(['apple', 'banana', 'pear', 'peach'], 'pale') ['apple', 'pear', 'peach', 'banana'] >>> sort_by_common_chars([], 'pale') [] >>> sort_by_common_chars(['dog', 'cat', 'mouse'], 'xyz') ['dog', 'cat', 'mouse'] >>> sort_by_common_chars(['ab', 'ba', 'abc'], 'abc') ['abc', 'ab', 'ba'] >>> sort_by_common_chars(['abc', 'a', 'bc', 'b'], 'bca') ['abc', 'bc', 'a', 'b'] >>> sort_by_common_chars(['apple', 'apple', 'pear'], 'pale') ['apple', 'apple', 'pear']","solution":"def count_common_chars(s, target_set): Counts the number of unique characters in s that are also in the target_set. return len(set(s) & target_set) def sort_by_common_chars(strings, target): Sorts a list of strings based on the number of unique characters they have in common with the target string. target_set = set(target) return sorted(strings, key=lambda s: count_common_chars(s, target_set), reverse=True)"},{"question":"def sum_of_neighbors(arr: list) -> list: Returns a new list where each element is the sum of its neighboring elements from the original list. The first and last elements are handled separately. Parameters: arr (list): List of integers Returns: list: List of integers where each element is the sum of its neighbors Examples: >>> sum_of_neighbors([3, 5, 6, 2, 7]) [5, 9, 7, 13, 2] >>> sum_of_neighbors([1, 2, 3, 4, 5]) [2, 4, 6, 8, 4] >>> sum_of_neighbors([5]) [] >>> sum_of_neighbors([3, 7]) [7, 3] >>> sum_of_neighbors([1, -2, 3, -4, 5]) [-2, 4, -6, 8, -4] >>> sum_of_neighbors([1, -1, 1, -1, 1]) [-1, 2, -2, 2, -1]","solution":"def sum_of_neighbors(arr): Returns a new list where each element is the sum of its neighboring elements from the original list. The first and last elements are handled separately. Parameters: arr (list): List of integers Returns: list: List of integers where each element is the sum of its neighbors if len(arr) < 2: return [] result = [] result.append(arr[1]) # First element for i in range(1, len(arr) - 1): result.append(arr[i - 1] + arr[i + 1]) result.append(arr[-2]) # Last element return result"},{"question":"def find_missing_element(arr1, arr2): Returns the missing element in arr2 that is present in arr1. >>> find_missing_element([4, 12, 5, 2, 7, 9], [4, 5, 2, 7, 9]) == 12 >>> find_missing_element([1, 2, 3], [1, 2, 3]) == 0 >>> find_missing_element([1, 2, 3, 4], [1, 2, 3]) == 4 >>> find_missing_element([10, 20, 30, 40], [10, 20, 30]) == 40 >>> find_missing_element([-1, -2, -3, -4], [-1, -2, -3]) == -4 >>> find_missing_element([0, -1, 1, 3], [0, -1, 1]) == 3","solution":"def find_missing_element(arr1, arr2): Returns the missing element in arr2 that is present in arr1. missing_element = sum(arr1) - sum(arr2) return missing_element"},{"question":"def is_palindrome(s: str) -> bool: Determine if a given string is a palindrome, considering only alphanumeric characters and ignoring case. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False","solution":"def is_palindrome(s): Determine if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. Parameters: s (str): The input string to be checked. Returns: bool: True if the string is a palindrome, False otherwise. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list in ascending order. :param list1: List of integers sorted in ascending order. :param list2: List of integers sorted in ascending order. :return: A single list that merges the two inputs into one sorted list in ascending order. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([-5, 0, 3], [-2, 1, 2]) [-5, -2, 0, 1, 2, 3] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([-3, -2, -1], [0, 1, 2]) [-3, -2, -1, 0, 1, 2] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2] >>> merge_sorted_lists([-2, 2, 4], [-5, 0, 3]) [-5, -2, 0, 2, 3, 4]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list in ascending order. :param list1: List of integers sorted in ascending order. :param list2: List of integers sorted in ascending order. :return: A single list that merges the two inputs into one sorted list in ascending order. merged_list = [] i = j = 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def transpose_matrix(matrix): Returns the transpose of the given matrix. Args: matrix (list of list of int): The input matrix to be transposed. Returns: list of list of int: The transposed matrix. pass def test_transpose_matrix_standard_case(): matrix = [[1, 2, 3], [4, 5, 6]] assert transpose_matrix(matrix) == [[1, 4], [2, 5], [3, 6]] def test_transpose_matrix_single_row(): matrix = [[1, 2, 3]] assert transpose_matrix(matrix) == [[1], [2], [3]] def test_transpose_matrix_single_column(): matrix = [[1], [2], [3]] assert transpose_matrix(matrix) == [[1, 2, 3]] def test_transpose_matrix_empty_matrix(): matrix = [] assert transpose_matrix(matrix) == [] def test_transpose_matrix_single_element(): matrix = [[1]] assert transpose_matrix(matrix) == [[1]] def test_transpose_matrix_rectangular_matrix(): matrix = [[1, 2], [3, 4], [5, 6]] assert transpose_matrix(matrix) == [[1, 3, 5], [2, 4, 6]]","solution":"def transpose_matrix(matrix): Returns the transpose of the given matrix. Args: matrix (list of list of int): The input matrix to be transposed. Returns: list of list of int: The transposed matrix. if not matrix or not matrix[0]: return [] return [list(row) for row in zip(*matrix)]"},{"question":"import threading import os import time import pickle import math from typing import List def load_cache(): # Function to load cache from persistent storage file pass def save_cache(cache): # Function to save cache to persistent storage file pass def factorial_with_caching(n: int) -> int: Compute the factorial of a number using caching to avoid redundant calculations. Supports numbers up to 100,000 and includes memoization for efficiency. Ensures thread-safety and handles invalid inputs. >>> factorial_with_caching(0) == 1 >>> factorial_with_caching(1) == 1 >>> factorial_with_caching(5) == 120 >>> factorial_with_caching(10) == 3628800 pass def factorial_multiple_queries(query: List[int]) -> List[int]: Handle multiple factorial queries efficiently, using cached results to improve performance. >>> factorial_multiple_queries([0, 1, 5, 10]) == [1, 1, 120, 3628800] pass","solution":"import functools import math import pickle from typing import List import threading import os import time CACHE_FILE = 'factorial_cache.pkl' CACHE_EXPIRATION = 3600 # 1 hour in seconds # Create a lock for thread-safe operations lock = threading.Lock() # Load cache from file if it exists and not expired def load_cache(): if not os.path.exists(CACHE_FILE): return {} with open(CACHE_FILE, 'rb') as f: cache_data = pickle.load(f) # Check if cache data is still valid if time.time() - cache_data['timestamp'] > CACHE_EXPIRATION: return {} return cache_data['data'] # Save cache to file def save_cache(cache): with open(CACHE_FILE, 'wb') as f: pickle.dump({ 'timestamp': time.time(), 'data': cache }, f) # Initialize cache factorial_cache = load_cache() def factorial_with_caching(n: int) -> int: if n < 0: raise ValueError(\\"Negative values are not allowed.\\") if n > 100000: raise ValueError(\\"Value exceeds maximum limit for caching.\\") with lock: if n in factorial_cache: return factorial_cache[n] result = math.factorial(n) factorial_cache[n] = result save_cache(factorial_cache) return result def factorial_multiple_queries(query: List[int]) -> List[int]: results = [] for n in query: results.append(factorial_with_caching(n)) return results"},{"question":"def list_to_squares_dict(input_list: List[int]) -> Dict[int, int]: Converts a list of integers to a dictionary where keys are unique integers from the list and values are their squares. The order of first appearance of each integer is preserved. >>> list_to_squares_dict([]) {} >>> list_to_squares_dict([3]) {3: 9} >>> list_to_squares_dict([1, 2, 3]) {1: 1, 2: 4, 3: 9} >>> list_to_squares_dict([2, 2, 3, 1, 2, 1]) {2: 4, 3: 9, 1: 1} >>> list_to_squares_dict([-1, -2, -1, 3]) {-1: 1, -2: 4, 3: 9} >>> list_to_squares_dict([1, -1, 2, 1, -2]) {1: 1, -1: 1, 2: 4, -2: 4}","solution":"def list_to_squares_dict(input_list): Converts a list of integers to a dictionary where keys are unique integers from the list and values are their squares. The order of first appearance of each integer is preserved. result = {} for num in input_list: if num not in result: result[num] = num ** 2 return result"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def values_greater_than(root: TreeNode, x: int) -> List[int]: Returns a list of all values in the binary search tree (BST) greater than a given number x. >>> tree = TreeNode(10, TreeNode(5), TreeNode(15)) >>> values_greater_than(tree, 7) [10, 15] >>> values_greater_than(tree, 10) [15] >>> values_greater_than(tree, 15) []","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def values_greater_than(root: TreeNode, x: int): Returns a list of all values in the BST greater than a given number x. result = [] def dfs(node): if node: if node.value > x: result.append(node.value) dfs(node.left) dfs(node.right) dfs(root) return result"},{"question":"import random def shuffle_and_deal(): Shuffles the deck and deals the initial two cards for player and dealer. Returns: deck (list): Remaining cards in the deck. player_hand (list): Cards in player's hand. dealer_hand (list): Cards in dealer's hand. deck = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'] * 4 random.shuffle(deck) player_hand = [deck.pop(), deck.pop()] dealer_hand = [deck.pop(), deck.pop()] return deck, player_hand, dealer_hand def calculate_hand_value(hand): Calculates the value of a given hand of cards. Args: hand (list): Cards in the hand. Returns: int: Total value of the hand. value = 0 aces = 0 for card in hand: if card.isdigit(): value += int(card) elif card in 'JQK': value += 10 elif card == 'A': aces += 1 value += 11 while value > 21 and aces: value -= 10 aces -= 1 return value def blackjack(): Simulates a blackjack game. deck, player_hand, dealer_hand = shuffle_and_deal() print(f\\"Player's hand: {player_hand}\\") print(f\\"Dealer's hand: {dealer_hand[0]}, ?\\") while calculate_hand_value(player_hand) < 21: action = input(\\"Do you want to 'hit' or 'stand'? \\").lower() if action == 'hit': player_hand.append(deck.pop()) print(f\\"Player's hand: {player_hand}\\") elif action == 'stand': break player_value = calculate_hand_value(player_hand) if player_value > 21: print(f\\"Player busted with {player_value}. Dealer wins!\\") return print(f\\"Dealer's hand: {dealer_hand}\\") while calculate_hand_value(dealer_hand) < 17: dealer_hand.append(deck.pop()) print(f\\"Dealer's hand: {dealer_hand}\\") dealer_value = calculate_hand_value(dealer_hand) if dealer_value > 21: print(f\\"Dealer busted with {dealer_value}. Player wins!\\") elif player_value > dealer_value: print(f\\"Player wins with {player_value} against dealer's {dealer_value}!\\") elif dealer_value > player_value: print(f\\"Dealer wins with {dealer_value} against player's {player_value}!\\") else: print(\\"It's a tie!\\") from solution import shuffle_and_deal, calculate_hand_value # Unit test for shuffle_and_deal function def test_shuffle_and_deal(): deck, player_hand, dealer_hand = shuffle_and_deal() assert len(deck) == 48 assert len(player_hand) == 2 assert len(dealer_hand) == 2 # Unit test for calculate_hand_value function def test_calculate_hand_value(): assert calculate_hand_value(['2', '3']) == 5 assert calculate_hand_value(['10', 'K']) == 20 assert calculate_hand_value(['A', '9']) == 20 assert calculate_hand_value(['A', 'K']) == 21 assert calculate_hand_value(['A', 'A', '9']) == 21 assert calculate_hand_value(['A', 'A', '9', '7']) == 18 assert calculate_hand_value(['9', '7', '5']) == 21 assert calculate_hand_value(['9', '7', '6']) == 22 # Integration test for a full round of blackjack def test_blackjack(monkeypatch): inputs = iter(['stand']) monkeypatch.setattr('builtins.input', lambda _: next(inputs)) from solution import blackjack blackjack()","solution":"import random # Function to shuffle and deal cards def shuffle_and_deal(): Shuffles the deck and deals the initial two cards for player and dealer. Returns: deck (list): Remaining cards in the deck. player_hand (list): Cards in player's hand. dealer_hand (list): Cards in dealer's hand. deck = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'] * 4 random.shuffle(deck) player_hand = [deck.pop(), deck.pop()] dealer_hand = [deck.pop(), deck.pop()] return deck, player_hand, dealer_hand # Function to calculate the value of a hand def calculate_hand_value(hand): Calculates the value of a given hand of cards. Args: hand (list): Cards in the hand. Returns: int: Total value of the hand. value = 0 aces = 0 for card in hand: if card.isdigit(): value += int(card) elif card in 'JQK': value += 10 elif card == 'A': aces += 1 value += 11 while value > 21 and aces: value -= 10 aces -= 1 return value # Main game loop def blackjack(): Simulates a blackjack game. deck, player_hand, dealer_hand = shuffle_and_deal() print(f\\"Player's hand: {player_hand}\\") print(f\\"Dealer's hand: {dealer_hand[0]}, ?\\") while calculate_hand_value(player_hand) < 21: action = input(\\"Do you want to 'hit' or 'stand'? \\").lower() if action == 'hit': player_hand.append(deck.pop()) print(f\\"Player's hand: {player_hand}\\") elif action == 'stand': break player_value = calculate_hand_value(player_hand) if player_value > 21: print(f\\"Player busted with {player_value}. Dealer wins!\\") return print(f\\"Dealer's hand: {dealer_hand}\\") while calculate_hand_value(dealer_hand) < 17: dealer_hand.append(deck.pop()) print(f\\"Dealer's hand: {dealer_hand}\\") dealer_value = calculate_hand_value(dealer_hand) if dealer_value > 21: print(f\\"Dealer busted with {dealer_value}. Player wins!\\") elif player_value > dealer_value: print(f\\"Player wins with {player_value} against dealer's {dealer_value}!\\") elif dealer_value > player_value: print(f\\"Dealer wins with {dealer_value} against player's {player_value}!\\") else: print(\\"It's a tie!\\")"},{"question":"def longest_unique_word(words: List[str]) -> str: Given a list of words, returns the longest word with unique characters. If there's a tie, returns the word that appears first in the list. >>> longest_unique_word(['apple', 'banana', 'cherry', 'date', 'elephant']) == \\"date\\" >>> longest_unique_word(['a', 'bb', 'ccc', 'dddd']) == \\"a\\" >>> longest_unique_word(['abcd', 'abc', 'ab', 'a']) == \\"abcd\\" >>> longest_unique_word(['abc', 'defg', 'ghi', 'jklm', 'a']) == \\"defg\\" >>> longest_unique_word([]) == \\"\\"","solution":"def longest_unique_word(words): Given a list of words, returns the longest word with unique characters. If there's a tie, returns the word that appears first in the list. def is_unique(word): return len(word) == len(set(word)) longest = \\"\\" for word in words: if is_unique(word) and (len(word) > len(longest)): longest = word return longest"},{"question":"def filter_and_multiply(mixed_list: list) -> int: Filters out non-integer strings from the list and returns the product of the remaining integers. If the list has no valid integers, returns 1. Args: mixed_list (list): List containing both integers and strings Returns: int: Product of all valid integers in the list >>> filter_and_multiply([2, \\"3\\", \\"apple\\", 5, \\"10b\\", \\"7\\"]) == 210 >>> filter_and_multiply([1, 2, 3, 4, 5]) == 120 >>> filter_and_multiply([\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\"]) == 120 >>> filter_and_multiply([\\"apple\\", \\"banana\\", \\"cat\\"]) == 1 >>> filter_and_multiply([]) == 1 >>> filter_and_multiply([\\"3a\\", \\"4b\\", \\"5c\\"]) == 1 >>> filter_and_multiply([\\"2\\", \\"3\\", \\"bad\\", \\"4\\"]) == 24 >>> filter_and_multiply([1, \\"2\\", \\"bad\\", 3, \\"worst\\", 4, \\"5\\"]) == 120 >>> filter_and_multiply([\\"3\\"]) == 3 >>> filter_and_multiply([\\"apple\\"]) == 1 >>> filter_and_multiply([10]) == 10 # Implement your solution here","solution":"def filter_and_multiply(mixed_list): Filters out non-integer strings from the list and returns the product of the remaining integers. If the list has no valid integers, returns 1. Args: mixed_list (list): List containing both integers and strings Returns: int: Product of all valid integers in the list product = 1 has_valid_integer = False for item in mixed_list: try: number = int(item) product *= number has_valid_integer = True except (ValueError, TypeError): pass return product if has_valid_integer else 1"},{"question":"import heapq class EventScheduler: A class to represent a scheduling system for events with priority levels. Each event has a unique identifier, a priority level, and a timestamp indicating when the event was created. The data structure supports adding events and removing the highest priority event. If multiple events have the same priority, the event with the earliest timestamp is removed first. Methods: - addEvent(eventId: int, priority: int, timestamp: int) -> None: Adds an event to the scheduler. - removeEvent() -> int: Removes and returns the eventId of the highest priority event. Examples: >>> scheduler = EventScheduler() >>> scheduler.addEvent(1, 10, 1) >>> scheduler.addEvent(2, 20, 2) >>> scheduler.addEvent(3, 10, 3) >>> scheduler.removeEvent() 2 >>> scheduler.removeEvent() 1 >>> scheduler.removeEvent() 3 def __init__(self): pass def addEvent(self, eventId: int, priority: int, timestamp: int): pass def removeEvent(self) -> int: pass import pytest def test_example_case(): scheduler = EventScheduler() scheduler.addEvent(1, 10, 1) scheduler.addEvent(2, 20, 2) scheduler.addEvent(3, 10, 3) assert scheduler.removeEvent() == 2 assert scheduler.removeEvent() == 1 assert scheduler.removeEvent() == 3 def test_single_event(): scheduler = EventScheduler() scheduler.addEvent(1, 10, 1) assert scheduler.removeEvent() == 1 def test_same_priority_different_timestamps(): scheduler = EventScheduler() scheduler.addEvent(1, 10, 1) scheduler.addEvent(2, 10, 2) scheduler.addEvent(3, 10, 3) assert scheduler.removeEvent() == 1 assert scheduler.removeEvent() == 2 assert scheduler.removeEvent() == 3 def test_different_priorities(): scheduler = EventScheduler() scheduler.addEvent(1, 5, 1) scheduler.addEvent(2, 15, 2) scheduler.addEvent(3, 10, 3) assert scheduler.removeEvent() == 2 assert scheduler.removeEvent() == 3 assert scheduler.removeEvent() == 1 def test_multiple_events_same_priority_same_timestamp(): scheduler = EventScheduler() scheduler.addEvent(1, 10, 1) scheduler.addEvent(2, 10, 1) assert scheduler.removeEvent() == 1 assert scheduler.removeEvent() == 2 def test_alternating_priorites(): scheduler = EventScheduler() scheduler.addEvent(1, 10, 1) scheduler.addEvent(2, 20, 2) scheduler.addEvent(3, 10, 3) scheduler.addEvent(4, 20, 4) assert scheduler.removeEvent() == 2 assert scheduler.removeEvent() == 4 assert scheduler.removeEvent() == 1 assert scheduler.removeEvent() == 3","solution":"import heapq class EventScheduler: def __init__(self): self.heap = [] self.entry_finder = {} self.counter = 0 def addEvent(self, eventId, priority, timestamp): entry = (priority, timestamp, eventId) self.entry_finder[eventId] = entry heapq.heappush(self.heap, (-priority, timestamp, eventId)) def removeEvent(self): while self.heap: _, _, eventId = heapq.heappop(self.heap) entry = self.entry_finder.pop(eventId, None) if entry: return eventId # Examples to understand how it works scheduler = EventScheduler() scheduler.addEvent(1, 10, 1) scheduler.addEvent(2, 20, 2) scheduler.addEvent(3, 10, 3) print(scheduler.removeEvent()) # Returns 2 print(scheduler.removeEvent()) # Returns 1 print(scheduler.removeEvent()) # Returns 3"},{"question":"def find_two_sum(nums: list, target: int) -> tuple or None: Determines if there exist two distinct numbers in the list that sum up to the target value. Returns their indices as a tuple (index1, index2) with index1 < index2. If no such pair exists, returns None. >>> find_two_sum([2, 7, 11, 15], 9) == (0, 1) >>> find_two_sum([2, 7, 11, 15], 10) == None >>> find_two_sum([3, 3, 4, 5], 6) == (0, 1) >>> find_two_sum([0, 4, 3, 0], 0) == (0, 3) >>> find_two_sum([-1, -2, -3, -4, -5], -8) == (2, 4) >>> find_two_sum([1000000000, 2000000000, 3000000000], 5000000000) == (1, 2) >>> find_two_sum([], 10) == None >>> find_two_sum([1], 1) == None >>> find_two_sum([1, 2, 3, 4, 5], 9) == (3, 4)","solution":"def find_two_sum(nums, target): Determines if there exist two distinct numbers in the list that sum up to the target value. Returns their indices as a tuple (index1, index2) with index1 < index2. If no such pair exists, returns None. Parameters: nums (list): List of integers target (int): Target sum Returns: tuple or None: Indices of the two numbers that sum up to the target, or None if no such pair exists num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"class Account: def __init__(self, account_id, initial_balance=0): Initialize a new account with an account id and an optional initial balance. >>> account = Account(account_id=\\"12345\\", initial_balance=1000) >>> account.balance 1000 self.account_id = account_id self.balance = initial_balance self.daily_withdrawn = 0 self.withdrawal_limit = 500 def deposit(self, amount): Deposit a specified amount into the account. >>> account = Account(account_id=\\"12345\\", initial_balance=1000) >>> account.deposit(200) 'Deposited 200. Current balance is 1200.' if amount > 0: self.balance += amount return f\\"Deposited {amount}. Current balance is {self.balance}.\\" else: return \\"Deposit amount must be positive.\\" def withdraw(self, amount): Withdraw a specified amount from the account. Enforces a daily withdrawal limit of 500. >>> account = Account(account_id=\\"12345\\", initial_balance=1000) >>> account.withdraw(200) 'Withdrew 200. Current balance is 800.' if amount > 0: if self.daily_withdrawn + amount > self.withdrawal_limit: return \\"Withdrawal amount exceeds the daily limit of 500.\\" elif amount <= self.balance: self.balance -= amount self.daily_withdrawn += amount return f\\"Withdrew {amount}. Current balance is {self.balance}.\\" else: return \\"Insufficient balance to make this withdrawal.\\" else: return \\"Withdrawal amount must be positive.\\" def check_balance(self): Check the current balance of the account. >>> account = Account(account_id=\\"12345\\", initial_balance=1000) >>> account.check_balance() 'Current balance is 1000.' return f\\"Current balance is {self.balance}.\\" def reset_daily_withdrawal(self): Reset the daily withdrawal amount. >>> account = Account(account_id=\\"12345\\", initial_balance=1000) >>> account.withdraw(200) 'Withdrew 200. Current balance is 800.' >>> account.reset_daily_withdrawal() 'Daily withdrawal limit has been reset.' self.daily_withdrawn = 0 return \\"Daily withdrawal limit has been reset.\\"","solution":"class Account: def __init__(self, account_id, initial_balance=0): self.account_id = account_id self.balance = initial_balance self.daily_withdrawn = 0 self.withdrawal_limit = 500 def deposit(self, amount): if amount > 0: self.balance += amount return f\\"Deposited {amount}. Current balance is {self.balance}.\\" else: return \\"Deposit amount must be positive.\\" def withdraw(self, amount): if amount > 0: if self.daily_withdrawn + amount > self.withdrawal_limit: return \\"Withdrawal amount exceeds the daily limit of 500.\\" elif amount <= self.balance: self.balance -= amount self.daily_withdrawn += amount return f\\"Withdrew {amount}. Current balance is {self.balance}.\\" else: return \\"Insufficient balance to make this withdrawal.\\" else: return \\"Withdrawal amount must be positive.\\" def check_balance(self): return f\\"Current balance is {self.balance}.\\" def reset_daily_withdrawal(self): self.daily_withdrawn = 0 return \\"Daily withdrawal limit has been reset.\\""},{"question":"def deep_copy_dictionary(d: dict) -> dict: Create a deep copy of the input dictionary. The dictionary may contain nested dictionaries, lists, and other primitive data types (integers, strings, floats, etc.). >>> deep_copy_dictionary({'a': 1, 'b': 2, 'c': 3}) {'a': 1, 'b': 2, 'c': 3} >>> deep_copy_dictionary({'a': {'inner_a': 1}, 'b': 2, 'c': {'inner_b': {'inner_c': 3}}}) {'a': {'inner_a': 1}, 'b': 2, 'c': {'inner_b': {'inner_c': 3}}}","solution":"def deep_copy_dictionary(d): Returns a deep copy of the input dictionary. The dictionary may contain nested dictionaries, lists, and other primitive data types (integers, strings, floats, etc.). if not isinstance(d, dict): raise ValueError(\\"Input is not a dictionary.\\") def deep_copy(d): result = {} for key, value in d.items(): if isinstance(value, dict): result[key] = deep_copy(value) elif isinstance(value, list): result[key] = [deep_copy(v) if isinstance(v, dict) else v for v in value] else: result[key] = value return result return deep_copy(d)"},{"question":"def group_strings_by_length(strings: List[str]) -> Dict[int, List[str]]: Groups strings by their lengths. Returns a dictionary where the keys are the lengths of the strings, and the values are lists of strings of that length. >>> group_strings_by_length([]) {} >>> group_strings_by_length([\\"hello\\"]) {5: [\\"hello\\"]} >>> group_strings_by_length([\\"a\\", \\"b\\", \\"c\\"]) {1: [\\"a\\", \\"b\\", \\"c\\"]} >>> group_strings_by_length([\\"a\\", \\"hi\\", \\"hello\\", \\"world\\", \\"b\\", \\"yo\\"]) {1: [\\"a\\", \\"b\\"], 2: [\\"hi\\", \\"yo\\"], 5: [\\"hello\\", \\"world\\"]} >>> group_strings_by_length([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"a\\", \\"abc\\"]) {1: [\\"a\\", \\"a\\"], 2: [\\"ab\\"], 3: [\\"abc\\", \\"abc\\"], 4: [\\"abcd\\"]}","solution":"def group_strings_by_length(strings): Groups strings by their lengths. :param strings: List of strings to be grouped :return: Dictionary with string lengths as keys and lists of strings as values result = {} for s in strings: length = len(s) if length not in result: result[length] = [] result[length].append(s) return result"},{"question":"def merge_sort(arr): Sorts a list of integers in ascending order using the merge sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. Examples: >>> merge_sort([]) [] >>> merge_sort([1]) [1] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) [1, 1, 2, 3, 4, 5, 5, 6, 9] >>> merge_sort([1, 3, 3, 2, 2, 1]) [1, 1, 2, 2, 3, 3]","solution":"def merge_sort(arr): Sorts a list of integers in ascending order using the merge sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. if len(arr) <= 1: return arr def merge(left, right): sorted_list = [] while left and right: if left[0] < right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) sorted_list.extend(left if left else right) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"import math from typing import List def find_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> find_primes([10, 15, 3, 7, 11, 13, 19, 23, 25, 29]) [3, 7, 11, 13, 19, 23, 29] >>> find_primes([4, 6, 8, 9, 10, 12, 14, 15, 16, 18]) [] >>> find_primes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) [2, 3, 5, 7] >>> find_primes([]) [] >>> find_primes([101, 102, 103, 104, 105, 106, 107, 108, 109, 110]) [101, 103, 107, 109]","solution":"import math def find_primes(numbers): Returns a list of prime numbers from the given list of integers. def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False for i in range(5, int(math.sqrt(n)) + 1, 6): if n % i == 0 or n % (i + 2) == 0: return False return True return [num for num in numbers if is_prime(num)]"},{"question":"class BankAccount: def __init__(self, initial_balance=0): self.balance = initial_balance self.history = [] def deposit(self, amount): Deposits amount to the account. Raises ValueError if the amount is negative. pass def withdraw(self, amount): Withdraws amount from the account. Raises ValueError if the amount is greater than the balance or negative. pass def get_balance(self): Returns current balance. pass def get_history(self): Returns transaction history as a list of strings in chronological order. pass # Unit Test from solution import BankAccount import pytest def test_initial_balance(): account = BankAccount() assert account.get_balance() == 0 def test_initial_balance_with_amount(): account = BankAccount(100) assert account.get_balance() == 100 def test_deposit(): account = BankAccount() account.deposit(50) assert account.get_balance() == 50 def test_deposit_negative_amount(): account = BankAccount() with pytest.raises(ValueError, match=\\"Deposit amount must be positive\\"): account.deposit(-50) def test_withdraw(): account = BankAccount(100) account.withdraw(50) assert account.get_balance() == 50 def test_withdraw_insufficient_funds(): account = BankAccount(50) with pytest.raises(ValueError, match=\\"Insufficient funds\\"): account.withdraw(100) def test_withdraw_negative_amount(): account = BankAccount(100) with pytest.raises(ValueError, match=\\"Withdraw amount must be positive\\"): account.withdraw(-50) def test_get_history(): account = BankAccount() account.deposit(50) account.withdraw(30) history = account.get_history() assert history == [\\"Deposited 50\\", \\"Withdrew 30\\"]","solution":"class BankAccount: def __init__(self, initial_balance=0): self.balance = initial_balance self.history = [] def deposit(self, amount): if amount <= 0: # Error: should raise an error if the amount is negative, not zero. raise ValueError(\\"Deposit amount must be positive\\") self.balance += amount self.history.append(f\\"Deposited {amount}\\") def withdraw(self, amount): if amount <= 0: # Error handling should be added for negative amounts raise ValueError(\\"Withdraw amount must be positive\\") if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount self.history.append(f\\"Withdrew {amount}\\") def get_balance(self): return self.balance def get_history(self): return self.history"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Write a function that accepts an array of integers and returns the maximum sum of any non-empty subarray within the list. A subarray is a contiguous portion of the array. If the array contains all negative numbers, return the highest single negative number. Your function should have an efficient time complexity, ideally O(n). >>> max_subarray_sum([1, -2, 3, 5, -3, 2]) 8 >>> max_subarray_sum([-2, -3, -1, -4]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-2, 0, -1, -4]) 0 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty subarray within the list. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling one share of the stock given the list of daily prices. >>> maxProfit([7, 1, 5, 3, 6, 4]) == 5 >>> maxProfit([7, 6, 4, 3, 1]) == 0","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying and selling one share of the stock given the list of daily prices. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: # Update the minimum price encountered so far if price < min_price: min_price = price # Calculate potential profit with current price and update max profit if it is higher potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"def longestSubstringWithTwoDistinctChars(s: str) -> int: Returns the length of the longest substring with at most 2 distinct characters. >>> longestSubstringWithTwoDistinctChars(\\"\\") == 0 >>> longestSubstringWithTwoDistinctChars(\\"a\\") == 1 >>> longestSubstringWithTwoDistinctChars(\\"aa\\") == 2 >>> longestSubstringWithTwoDistinctChars(\\"ab\\") == 2 >>> longestSubstringWithTwoDistinctChars(\\"eceba\\") == 3 >>> longestSubstringWithTwoDistinctChars(\\"abcbbbbcccbdddadacb\\") == 10 >>> longestSubstringWithTwoDistinctChars(\\"aaaaaaa\\") == 7 >>> longestSubstringWithTwoDistinctChars(\\"ababababab\\") == 10 >>> longestSubstringWithTwoDistinctChars(\\"abaccc\\") == 4","solution":"def longestSubstringWithTwoDistinctChars(s): Returns the length of the longest substring with at most 2 distinct characters. if len(s) == 0: return 0 left, right = 0, 0 char_map = {} max_len = 0 while right < len(s): if len(char_map) <= 2: char_map[s[right]] = right right += 1 if len(char_map) > 2: left_most_index = min(char_map.values()) del char_map[s[left_most_index]] left = left_most_index + 1 max_len = max(max_len, right - left) return max_len"},{"question":"import math def cone_volume(radius, height): Returns the volume of a cone given the radius of the base and the height. >>> cone_volume(5, 12) 314.159265 >>> cone_volume(0, 5) 0 >>> cone_volume(5, 0) 0 # Your code here pass","solution":"import math def cone_volume(radius, height): Returns the volume of a cone given the radius of the base and the height. Parameters: radius (float): the radius of the base of the cone. height (float): the height of the cone. Returns: float: the volume of the cone. # Check for valid input if not isinstance(radius, (int, float)) or not isinstance(height, (int, float)): raise ValueError(\\"Both radius and height must be numeric values.\\") if radius < 0 or height < 0: raise ValueError(\\"Both radius and height must be non-negative values.\\") volume = (1/3) * math.pi * radius ** 2 * height return volume # Example usage: calculate and print the volume of a cone with radius 5 and height 12 radius = 5 height = 12 print(f\\"The volume of the cone is: {cone_volume(radius, height)}\\")"},{"question":"def summarize_log_events(log_file: str) -> dict: Reads the log file and returns a summary dictionary with the count of each event type. :param log_file: str - The filename of the log file. :return: dict - Summary dictionary with counts of INFO, WARN, and ERROR events. >>> summarize_log_events('test_log.txt') {'INFO': 2, 'WARN': 1, 'ERROR': 1} >>> summarize_log_events('empty_log.txt') {'INFO': 0, 'WARN': 0, 'ERROR': 0} >>> summarize_log_events('non_existent_log.txt') {'INFO': 0, 'WARN': 0, 'ERROR': 0} >>> summarize_log_events('varied_log.txt') {'INFO': 3, 'WARN': 2, 'ERROR': 2}","solution":"def summarize_log_events(log_file: str) -> dict: Reads the log file and returns a summary dictionary with the count of each event type. :param log_file: str - The filename of the log file. :return: dict - Summary dictionary with counts of INFO, WARN, and ERROR events. event_types = ['INFO', 'WARN', 'ERROR'] summary = {event_type: 0 for event_type in event_types} try: with open(log_file, 'r') as file: for line in file: parts = line.split() if len(parts) >= 3: event_type = parts[2] if event_type in summary: summary[event_type] += 1 except FileNotFoundError: print(f\\"The file {log_file} does not exist.\\") return summary"},{"question":"[Completion Task in Python] import csv from collections import defaultdict import matplotlib.pyplot as plt from datetime import datetime def parse_csv(file_path): Parse the CSV file and store the data in an appropriate data structure. You should handle errors such as missing or malformed data appropriately to ensure the program does not crash. pass def calculate_total_sales(sales_data): Calculate and return the total sales for each product. pass def product_with_highest_sales(total_sales): Identify and return the product with the highest sales and the amount. pass def plot_monthly_sales_trend(sales_data): Plot the monthly sales trend for each product using matplotlib. pass def analyze_sales(file_path): Analyze sales from the given CSV file and print the results. This function should use the other defined functions to parse the CSV file, calculate sales, and plot sales trends. pass # Unit tests import pytest def setup_module(module): # Create a sample CSV file for testing purposes csv_content = Product,Date,Quantity,Price ProductA,2023-01-15,10,20 ProductB,2023-01-17,5,30 ProductA,2023-02-03,8,20 ProductC,2023-02-10,12,10 with open('test_sales.csv', 'w') as f: f.write(csv_content) def teardown_module(module): import os os.remove('test_sales.csv') def test_parse_csv(): sales_data = parse_csv('test_sales.csv') assert sales_data == { 'ProductA': {'2023-01': 200, '2023-02': 160}, 'ProductB': {'2023-01': 150}, 'ProductC': {'2023-02': 120}, } def test_calculate_total_sales(): sales_data = { 'ProductA': {'2023-01': 200, '2023-02': 160}, 'ProductB': {'2023-01': 150}, 'ProductC': {'2023-02': 120}, } total_sales = calculate_total_sales(sales_data) assert total_sales == {'ProductA': 360, 'ProductB': 150, 'ProductC': 120} def test_product_with_highest_sales(): total_sales = {'ProductA': 360, 'ProductB': 150, 'ProductC': 120} highest_sales_product, highest_sales_amount = product_with_highest_sales(total_sales) assert highest_sales_product == 'ProductA' assert highest_sales_amount == 360 def test_analyze_sales(capfd): analyze_sales('test_sales.csv') out, err = capfd.readouterr() assert \\"Total Sales for Each Product:\\" in out assert \\"ProductA: 360.00\\" in out assert \\"ProductB: 150.00\\" in out assert \\"ProductC: 120.00\\" in out assert \\"Product with the Highest Sales: ProductA ( 360.00)\\" in out","solution":"import csv from collections import defaultdict import matplotlib.pyplot as plt from datetime import datetime def parse_csv(file_path): sales_data = defaultdict(lambda: defaultdict(int)) try: with open(file_path, newline='') as csvfile: reader = csv.DictReader(csvfile) for row in reader: product = row['Product'] date = datetime.strptime(row['Date'], '%Y-%m-%d') quantity = int(row['Quantity']) price = float(row['Price']) sales_amount = quantity * price month = date.strftime('%Y-%m') sales_data[product][month] += sales_amount except FileNotFoundError: print(f\\"Error: The file '{file_path}' was not found.\\") except csv.Error as e: print(f\\"Error: An error occurred while reading the CSV file: {e}\\") except Exception as e: print(f\\"Error: {e}\\") return sales_data def calculate_total_sales(sales_data): total_sales = {product: sum(monthly_sales.values()) for product, monthly_sales in sales_data.items()} return total_sales def product_with_highest_sales(total_sales): return max(total_sales.items(), key=lambda x: x[1]) def plot_monthly_sales_trend(sales_data): for product, monthly_sales in sales_data.items(): sorted_months = sorted(monthly_sales.keys()) sales_amounts = [monthly_sales[month] for month in sorted_months] plt.plot(sorted_months, sales_amounts, label=product) plt.xlabel('Month') plt.ylabel('Sales Amount') plt.title('Monthly Sales Trend per Product') plt.legend() plt.show() def analyze_sales(file_path): sales_data = parse_csv(file_path) total_sales = calculate_total_sales(sales_data) highest_sales_product, highest_sales_amount = product_with_highest_sales(total_sales) print(\\"Total Sales for Each Product:\\") for product, sales in total_sales.items(): print(f\\"{product}: {sales:.2f}\\") print(f\\"nProduct with the Highest Sales: {highest_sales_product} ( {highest_sales_amount:.2f})\\") plot_monthly_sales_trend(sales_data)"},{"question":"def sum_of_squares_of_even_numbers(numbers: List[int]) -> int: Takes a list of integers and returns the sum of the squares of only the even numbers. :param numbers: List of integers :return: Sum of the squares of even numbers >>> sum_of_squares_of_even_numbers([1, 2, 3, 4, 5, 6]) 56 >>> sum_of_squares_of_even_numbers([-2, -3, -4, -5, -6]) 56 >>> sum_of_squares_of_even_numbers([-1, -2, -3, -4, -5, -6]) 56 >>> sum_of_squares_of_even_numbers([1, 3, 5]) 0 >>> sum_of_squares_of_even_numbers([]) 0 >>> sum_of_squares_of_even_numbers([-2, 2, -4, 4]) 40","solution":"def sum_of_squares_of_even_numbers(numbers): Takes a list of integers and returns the sum of the squares of only the even numbers. :param numbers: List of integers :return: Sum of the squares of even numbers return sum(x**2 for x in numbers if x % 2 == 0)"},{"question":"def word_count(s: str) -> dict: Returns a dictionary with unique words as keys and their occurrences as values. The function is case-insensitive. >>> word_count(\\"Hello world hello\\") == {\\"hello\\": 2, \\"world\\": 1} >>> word_count(\\"Hello HELLO HeLLo\\") == {\\"hello\\": 3} >>> word_count(\\"Hello, world! Hello...\\") == {\\"hello,\\": 1, \\"world!\\": 1, \\"hello...\\": 1} def sort_word_count(word_dict: dict) -> list: Returns a sorted list of tuples (word, count) from a dictionary. The list is sorted by count in descending order. >>> sort_word_count({\\"hello\\": 2, \\"world\\": 1}) == [(\\"hello\\", 2), (\\"world\\", 1)] >>> sort_word_count({\\"hello\\": 2, \\"world\\": 2, \\"test\\": 1}) == [(\\"hello\\", 2), (\\"world\\", 2), (\\"test\\", 1)] or [(\\"world\\", 2), (\\"hello\\", 2), (\\"test\\", 1)]","solution":"def word_count(s): Returns a dictionary with unique words as keys and their occurrences as values. The function is case-insensitive. words = s.lower().split() count_dict = {} for word in words: if word in count_dict: count_dict[word] += 1 else: count_dict[word] = 1 return count_dict def sort_word_count(word_dict): Returns a sorted list of tuples (word, count) from a dictionary. The list is sorted by count in descending order. return sorted(word_dict.items(), key=lambda item: item[1], reverse=True) # Demonstration input_string = \\"Hello world hello\\" word_dict = word_count(input_string) sorted_word_list = sort_word_count(word_dict) sorted_word_list"},{"question":"def group_strings_by_length(strings): Processes a list of strings and returns a dictionary where the keys are the lengths of the strings, and the values are lists of strings of that length. Parameters: strings (list): A list of strings. Returns: dict: A dictionary grouping strings by their length. >>> group_strings_by_length([\\"apple\\", \\"bat\\", \\"car\\", \\"elephant\\"]) {5: [\\"apple\\"], 3: [\\"bat\\", \\"car\\"], 8: [\\"elephant\\"]} >>> group_strings_by_length([\\"hello\\"]) {5: [\\"hello\\"]} >>> group_strings_by_length([]) {} >>> group_strings_by_length([\\"\\", \\"\\", \\"a\\", \\"ab\\"]) {0: [\\"\\", \\"\\"], 1: [\\"a\\"], 2: [\\"ab\\"]} >>> group_strings_by_length([\\"aa\\", \\"bb\\", \\"cc\\"]) {2: [\\"aa\\", \\"bb\\", \\"cc\\"]} >>> group_strings_by_length([\\"dog\\", \\"\\", \\"bird\\", \\"elephant\\", \\"mouse\\"]) {3: [\\"dog\\"], 0: [\\"\\"], 4: [\\"bird\\"], 8: [\\"elephant\\"], 5: [\\"mouse\\"]} >>> group_strings_by_length([\\"Dog\\", \\"dog\\"]) {3: [\\"Dog\\", \\"dog\\"]}","solution":"def group_strings_by_length(strings): Processes a list of strings and returns a dictionary where the keys are the lengths of the strings, and the values are lists of strings of that length. Parameters: strings (list): A list of strings. Returns: dict: A dictionary grouping strings by their length. length_dict = {} for string in strings: length = len(string) if length not in length_dict: length_dict[length] = [] length_dict[length].append(string) return length_dict"},{"question":"def findMaxLength(nums: List[int]) -> int: Finds the maximum length of a contiguous subarray with an equal number of 0s and 1s. :param nums: List[int] :return: int >>> findMaxLength([0, 1]) 2 >>> findMaxLength([1, 1, 1, 1]) 0 >>> findMaxLength([0, 0, 0, 0]) 0 >>> findMaxLength([0, 1, 0, 1, 0, 1]) 6 >>> findMaxLength([0, 1, 1, 0, 1, 1, 1, 0]) 4 >>> findMaxLength([0, 1, 0, 1, 1, 0, 0, 1]) 8 >>> findMaxLength([0]) 0 >>> findMaxLength([1]) 0 >>> findMaxLength([]) 0","solution":"def findMaxLength(nums): Finds the maximum length of a contiguous subarray with an equal number of 0s and 1s. :param nums: List[int] :return: int count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def first_n_primes(n): Returns a list of the first n prime numbers. Parameters: n (int): The number of prime numbers to generate. Returns: list of int: A list containing the first n prime numbers. pass # Unit tests def test_first_n_primes_zero(): assert first_n_primes(0) == [] def test_first_n_primes_negative(): assert first_n_primes(-5) == [] def test_first_n_primes_one(): assert first_n_primes(1) == [2] def test_first_n_primes_five(): assert first_n_primes(5) == [2, 3, 5, 7, 11] def test_first_n_primes_ten(): assert first_n_primes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_first_n_primes_large(): assert first_n_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def first_n_primes(n): Returns a list of the first n prime numbers. Parameters: n (int): The number of prime numbers to generate. Returns: list of int: A list containing the first n prime numbers. if n <= 0: return [] primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return primes"},{"question":"from typing import List def maxSubArraySum(nums: List[int]) -> int: Find a contiguous subarray with the largest sum and return its sum. The function should implement an efficient algorithm to handle large input sizes. >>> maxSubArraySum([1, 2, 3, 4, 5]) == 15 >>> maxSubArraySum([-1, -2, -3, -4, -5]) == -1 >>> maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> maxSubArraySum([]) == 0 >>> maxSubArraySum([0, 0, 0, 0]) == 0 >>> maxSubArraySum([1000000, -900000, 500000, 2000000, -1000000]) == 2600000","solution":"from typing import List def maxSubArraySum(nums: List[int]) -> int: Find the contiguous subarray which has the largest sum and return its sum. Implements Kadane's Algorithm which runs in O(n) time complexity. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list representing the n x n matrix. Returns: List[List[int]]: A new 2D list representing the rotated matrix. pass # Unit Tests def test_rotate_3x3_matrix(): assert rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_single_element_matrix(): assert rotate_matrix([[1]]) == [[1]] def test_rotate_2x2_matrix(): assert rotate_matrix([ [1, 2], [3, 4] ]) == [ [3, 1], [4, 2] ] def test_rotate_4x4_matrix(): assert rotate_matrix([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_larger_matrix(): assert rotate_matrix([ [7, 1, 4, 3, 12], [8, 2, 5, 6, 13], [9, 3, 6, 9, 10], [10, 4, 7, 8, 11], [11, 5, 8, 9, 12] ]) == [ [11, 10, 9, 8, 7], [5, 4, 3, 2, 1], [8, 7, 6, 5, 4], [9, 8, 9, 6, 3], [12, 11, 10, 13, 12] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list representing the n x n matrix. Returns: List[List[int]]: A new 2D list representing the rotated matrix. n = len(matrix) # Create a new matrix for the result with the same size rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-i-1] = matrix[i][j] return rotated_matrix"},{"question":"def evaluate_expression(expression: str) -> int: Given a string representing a mathematical expression, evaluate and return the result as an integer. The expression will include positive integers and may contain the following operators: - Addition: + - Subtraction: - - Multiplication: * - Division: / - Parentheses: () The function should handle operator precedence and parentheses correctly. >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" (1+(4+5+2)-3)+(6+8) \\") 23 return import pytest from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3 + 2\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"10 - 2\\") == 8 def test_simple_multiplication(): assert evaluate_expression(\\"2 * 3\\") == 6 def test_simple_division(): assert evaluate_expression(\\"8 / 4\\") == 2 def test_combined_operations(): assert evaluate_expression(\\"3 + 2 * 2\\") == 7 def test_combined_operations_with_parentheses(): assert evaluate_expression(\\"(3 + 2) * 2\\") == 10 def test_complex_expression(): assert evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 def test_expression_with_spaces(): assert evaluate_expression(\\" 3 + 2 * 2 \\") == 7 def test_division_floor(): assert evaluate_expression(\\"3 / 2\\") == 1 def test_expression_with_nested_parentheses(): assert evaluate_expression(\\"((3 + 2) * (2 + 1)) / 3 + 1\\") == 6 pytest.main()","solution":"def evaluate_expression(expression: str) -> int: Given a string representing a mathematical expression, evaluate and return the result as an integer. The expression will include positive integers and may contain the following operators: - Addition: + - Subtraction: - - Multiplication: * - Division: / - Parentheses: () The function should handle operator precedence and parentheses correctly. >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 def operation(op: str, second: int, first: int) -> int: if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) # Using int() for floor division def precedence(op: str) -> int: if op in ('+', '-'): return 1 elif op in ('*', '/'): return 2 return 0 def apply_operations(operators, values): operator = operators.pop() second = values.pop() first = values.pop() values.append(operation(operator, second, first)) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operations(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operations(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operations(operators, values) return values[-1]"},{"question":"import re from collections import Counter from typing import List, Tuple def get_top_n_words(text: str, n: int = 5) -> List[Tuple[str, int]]: Write a Python function that takes in a text document (string format) and returns the top N most common words in the document, along with their frequencies. Ignore common stop words (e.g., \\"the\\", \\"and\\", \\"is\\", etc.) and consider words case-insensitively (e.g., \\"Apple\\" and \\"apple\\" should be treated as the same word). Use regular expressions to process the text. >>> get_top_n_words(\\"Apple apple apple Orange orange banana banana Banana.\\", 2) [('apple', 3), ('banana', 3)] >>> get_top_n_words(\\"The apple is sweet and the apple is red.\\", 2) [('apple', 2), ('sweet', 1)]","solution":"import re from collections import Counter def get_top_n_words(text, n=5): Returns the top N most common words in the text document, ignoring common stop words. # Define a list of common stop words stop_words = set([ 'the', 'and', 'is', 'in', 'to', 'a', 'of', 'that', 'it', 'with', 'as', 'for', 'its', 'on', 'at', 'by', 'an', 'be' ]) # Use regular expressions to remove punctuation (keeping spaces) and lower the text cleaned_text = re.sub(r'[^ws]', '', text).lower() # Split the cleaned text into words words = cleaned_text.split() # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequency of each word word_counts = Counter(filtered_words) # Return the top N most common words along with their frequencies return word_counts.most_common(n)"},{"question":"def sorted_squared_array(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the squares of each integer from the original list, sorted in non-decreasing order. >>> sorted_squared_array([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sorted_squared_array([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121]","solution":"def sorted_squared_array(nums): Takes a list of integers and returns a list containing the squares of each integer sorted in non-decreasing order. n = len(nums) result = [0] * n left, right = 0, n - 1 for i in range(n - 1, -1, -1): if abs(nums[left]) > abs(nums[right]): result[i] = nums[left] ** 2 left += 1 else: result[i] = nums[right] ** 2 right -= 1 return result"},{"question":"def filter_and_sort(int_list, x, y): Filters the list to include only numbers between x and y (inclusive), and returns the sorted list. If no such numbers are present, returns 'No values found'. If the input list is empty, returns 'Invalid input'. >>> filter_and_sort([13, 5, 22, 9, 3, 7], 4, 10) == [5, 7, 9] >>> filter_and_sort([13, 5, 22, 9, 3, 7], 10, 4) == [5, 7, 9] >>> filter_and_sort([13, 5, 22, 9, 3, 7], 14, 20) == 'No values found' >>> filter_and_sort([], 4, 10) == 'Invalid input' >>> filter_and_sort([4, 5, 6, 10], 4, 10) == [4, 5, 6, 10] >>> filter_and_sort([13, 5, 22, 9, 3, 7], 9, 9) == [9] >>> filter_and_sort([1, 2, 3, 4, 5], 1, 5) == [1, 2, 3, 4, 5] >>> filter_and_sort([-10, -5, 0, 5, 10], -5, 5) == [-5, 0, 5] >>> filter_and_sort([13, 5, 22, 9, 3, 7], 20, 25) == [22]","solution":"def filter_and_sort(int_list, x, y): Filters the list to include only numbers between x and y (inclusive), and returns the sorted list. If no such numbers are present, returns 'No values found'. If the input list is empty, returns 'Invalid input'. if not int_list: return 'Invalid input' if x > y: x, y = y, x result = [num for num in int_list if x <= num <= y] if not result: return 'No values found' return sorted(result)"},{"question":"import keyword def is_valid_identifier(identifier: str) -> bool: Returns whether a string is a valid identifier in Python. A valid identifier should meet the following criteria: 1. It must start with a letter (a-z, A-Z) or an underscore (_). 2. It must be followed by letters, digits (0-9), or underscores. 3. It must not be a reserved keyword in Python. >>> is_valid_identifier(\\"variable\\") == True >>> is_valid_identifier(\\"_Variable1\\") == True >>> is_valid_identifier(\\"2variable\\") == False >>> is_valid_identifier(\\"for\\") == False >>> is_valid_identifier(\\"while_\\") == True >>> is_valid_identifier(\\"__init__\\") == True >>> is_valid_identifier(\\"class\\") == False def check_identifiers(test_cases: List[str]) -> Dict[str, bool]: Takes a list of strings and returns a dictionary with the string as the key and a boolean indicating if it is a valid identifier as the value. >>> test_cases = [\\"variable\\", \\"_Variable1\\", \\"2variable\\", \\"for\\", \\"while_\\", \\"__init__\\", \\"class\\"] >>> check_identifiers(test_cases) == { \\"variable\\": True, \\"_Variable1\\": True, \\"2variable\\": False, \\"for\\": False, \\"while_\\": True, \\"__init__\\": True, \\"class\\": False }","solution":"import keyword def is_valid_identifier(identifier): Returns whether a string is a valid identifier in Python. if not identifier.isidentifier() or keyword.iskeyword(identifier): return False return True def check_identifiers(test_cases): Takes a list of strings and returns a dictionary with the string as the key and a boolean indicating if it is a valid identifier as the value. return {case: is_valid_identifier(case) for case in test_cases}"},{"question":"def update_inventory(inventory, sales): Simulate a simplified inventory management system. The function should receive a list of tuples, where each tuple represents an item with its name (str), quantity (int), and price per unit (float). The function needs to update the quantity of items based on sales transactions detailed in another list of tuples. Each tuple in the sales list contains an item's name and the quantity sold. The function should adjust the inventory accordingly and also calculate and print the total revenue from sold items. If an item in the sales list is not present in the inventory, it should record an error and continue processing the next item. Args: inventory (List[Tuple[str, int, float]]): A list of items in the inventory. sales (List[Tuple[str, int]]): A list of sales transactions. Returns: List[Tuple[str, int, float]]: Updated inventory after processing all sales. Examples: >>> update_inventory([(\\"apple\\", 10, 0.50), (\\"banana\\", 5, 0.30), (\\"orange\\", 8, 0.70)], [(\\"apple\\", 3), (\\"banana\\", 2), (\\"orange\\", 5)]) Total Revenue: 5.50 [(\\"apple\\", 7, 0.50), (\\"banana\\", 3, 0.30), (\\"orange\\", 3, 0.70)] >>> update_inventory([(\\"apple\\", 10, 0.50), (\\"banana\\", 5, 0.30), (\\"orange\\", 8, 0.70)], [(\\"apple\\", 3), (\\"grape\\", 1), (\\"orange\\", 5)]) Item grape not found in inventory Total Revenue: 5.50 [(\\"apple\\", 7, 0.50), (\\"banana\\", 5, 0.30), (\\"orange\\", 3, 0.70)]","solution":"def update_inventory(inventory, sales): total_revenue = 0 errors = [] for item_name, quantity_sold in sales: for i in range(len(inventory)): if inventory[i][0] == item_name: if inventory[i][1] >= quantity_sold: inventory[i] = (inventory[i][0], inventory[i][1] - quantity_sold, inventory[i][2]) total_revenue += quantity_sold * inventory[i][2] else: errors.append(f\\"Not enough stock for {item_name}\\") break else: errors.append(f\\"Item {item_name} not found in inventory\\") for error in errors: print(error) print(f\\"Total Revenue: {total_revenue:.2f}\\") return inventory"},{"question":"def length_of_longest_ap(arr: List[int]) -> int: Develop a function that takes a list of integers and returns the length of the longest subsequence which forms an arithmetic progression. >>> length_of_longest_ap([1, 3, 5, 7, 9, 11]) 6 >>> length_of_longest_ap([10, 5, 3, 7, 2]) 2 >>> length_of_longest_ap([1, 2, 4, 3, 5]) 3 >>> length_of_longest_ap([10]) 1 >>> length_of_longest_ap([5, 10]) 2 >>> length_of_longest_ap([20, 15, 10, 5, 0, -5, -10]) 7","solution":"def length_of_longest_ap(arr): if len(arr) <= 2: return len(arr) n = len(arr) dp = [{} for _ in range(n)] max_len = 2 for i in range(1, n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_len = max(max_len, dp[i][diff]) return max_len"},{"question":"[Completion Task in Python] from typing import List def modify_strings(input_list: List[str], n: int) -> List[str]: Returns a new list of strings where each string is modified to include its length at the end, but only if the length of the string is greater than n. If the length is less than or equal to n, the string remains unchanged. Parameters: - input_list: List[str] - A list of strings. - n: int - An integer threshold for string length. Returns: - List[str]: A new list of modified strings. Examples: >>> modify_strings([\\"a\\", \\"ab\\", \\"abc\\"], 3) [\\"a\\", \\"ab\\", \\"abc\\"] >>> modify_strings([\\"apple\\", \\"banana\\", \\"cherry\\"], 3) [\\"apple,5\\", \\"banana,6\\", \\"cherry,6\\"] >>> modify_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"], 3) [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd,4\\", \\"abcde,5\\"] >>> modify_strings([\\"apple\\", \\"beet\\", \\"cherry\\", \\"date\\"], 4) [\\"apple,5\\", \\"beet\\", \\"cherry,6\\", \\"date\\"] >>> modify_strings([], 3) []","solution":"def modify_strings(input_list, n): Returns a new list of strings where each string is modified to include its length at the end, but only if the length of the string is greater than n. If the length is less than or equal to n, the string remains unchanged. Parameters: - input_list: List[str] - A list of strings. - n: int - An integer threshold for string length. Returns: - List[str]: A new list of modified strings. return [word + f\\",{len(word)}\\" if len(word) > n else word for word in input_list] # Time complexity explanation: # The algorithm iterates through the input list of strings once and performs an O(1) operation for each string. # Thus, the time complexity is O(m * k), where m is the number of strings in the list and k is the average length # of the strings (due to string concatenation), making it effectively O(m)."},{"question":"import time class Player: def __init__(self, name, initial_funds): Initialize player with name and initial funds. >>> player = Player(\\"Alice\\", 100) >>> player.name 'Alice' >>> player.funds 100 >>> player.bidding_history [] pass def place_bid(self, amount): Place a bid with a specified amount if funds are sufficient. >>> player = Player(\\"Alice\\", 100) >>> player.place_bid(50) 50 >>> player.place_bid(150) Traceback (most recent call last): ... ValueError: Insufficient funds pass def deduct_funds(self, amount): Deduct the funds by a specified amount and log the bid. >>> player = Player(\\"Alice\\", 100) >>> player.deduct_funds(50) >>> player.funds 50 >>> player.bidding_history [50] pass class Auction: def __init__(self, initial_funds): Initialize auction with initial funds for each player. >>> auction = Auction(100) >>> auction.initial_funds 100 >>> auction.players {} >>> auction.winners [] pass def register_player(self, name): Register a player with a specified name. >>> auction = Auction(100) >>> auction.register_player(\\"Alice\\") >>> \\"Alice\\" in auction.players True >>> auction.players[\\"Alice\\"].funds 100 >>> auction.register_player(\\"Alice\\") Traceback (most recent call last): ... ValueError: Player already registered pass def start_round(self, duration_seconds): Start a bidding round for a specified duration in seconds. pass def process_bids(self, bids): Process the bids and determine the winner. >>> auction = Auction(100) >>> auction.register_player(\\"Alice\\") >>> auction.register_player(\\"Bob\\") >>> bids = {\\"Alice\\": 50, \\"Bob\\": 40} >>> auction.process_bids(bids) >>> auction.get_winning_log() [('Alice', 50)] >>> auction.get_player_balance(\\"Alice\\") 50 >>> auction.get_player_balance(\\"Bob\\") 100 pass def get_player_balance(self, name): Get the balance of a specific player. >>> auction = Auction(100) >>> auction.register_player(\\"Alice\\") >>> auction.get_player_balance(\\"Alice\\") 100 >>> auction.get_player_balance(\\"Bob\\") Traceback (most recent call last): ... ValueError: Player not found pass def get_winning_log(self): Retrieve the winning log. >>> auction = Auction(100) >>> auction.register_player(\\"Alice\\") >>> auction.register_player(\\"Bob\\") >>> auction.start_round(2) >>> log = auction.get_winning_log() >>> len(log) 1 >>> winner, bid = log[0] >>> winner in [\\"Alice\\", \\"Bob\\", \\"Tie\\"] True >>> bid == 10 True pass","solution":"import time class Player: def __init__(self, name, initial_funds): self.name = name self.funds = initial_funds self.bidding_history = [] def place_bid(self, amount): if amount > self.funds: raise ValueError(\\"Insufficient funds\\") return amount def deduct_funds(self, amount): self.funds -= amount self.bidding_history.append(amount) class Auction: def __init__(self, initial_funds): self.players = {} self.initial_funds = initial_funds self.winners = [] def register_player(self, name): if name in self.players: raise ValueError(\\"Player already registered\\") self.players[name] = Player(name, self.initial_funds) def start_round(self, duration_seconds): bids = {} start_time = time.time() while time.time() - start_time < duration_seconds: time.sleep(1) # Simulating waiting period for bids # Collect bids # For simplicity, this is random and immediate # In real situation, you would accept them from input for player_name in self.players: player = self.players[player_name] try: bid = player.place_bid(10) # For testing, each places a bid of 10 units bids[player_name] = bid except ValueError: continue self.process_bids(bids) def process_bids(self, bids): if not bids: return max_bid = max(bids.values()) winners = [name for name, bid in bids.items() if bid == max_bid] if len(winners) == 1: winner = winners[0] self.players[winner].deduct_funds(max_bid) self.winners.append((winner, max_bid)) else: self.winners.append((\\"Tie\\", max_bid)) def get_player_balance(self, name): if name not in self.players: raise ValueError(\\"Player not found\\") return self.players[name].funds def get_winning_log(self): return self.winners # Example usage: # auction = Auction(100) # auction.register_player(\\"Alice\\") # auction.register_player(\\"Bob\\") # auction.start_round(10) # winner_log = auction.get_winning_log() # print(winner_log) # balance = auction.get_player_balance(\\"Alice\\") # print(balance)"},{"question":"import re from collections import defaultdict from typing import Dict def word_count(s: str) -> Dict[str, int]: Given a string, return a map where each word is a key and the value is the number of times that word appears in the string. Ignore case sensitivity and punctuation. >>> word_count(\\"Hello world, hello! This is a test. Hello, world...\\") == {'hello': 3, 'world': 2, 'this': 1, 'is': 1, 'a': 1, 'test': 1} >>> word_count(\\"Hi! This-test? Yes, it's... okay.\\") == {'hi': 1, 'this': 1, 'test': 1, 'yes': 1, 'it': 1, 's': 1, 'okay': 1} >>> word_count(\\"Apple apple APPLE\\") == {'apple': 3} >>> word_count(\\"\\") == {} from solution import word_count def test_single_word(): assert word_count(\\"Hello\\") == {\\"hello\\": 1} def test_multiple_same_words(): assert word_count(\\"Hello hello HELLO\\") == {\\"hello\\": 3} def test_sentence(): assert word_count(\\"Hello world, hello! This is a test. Hello, world...\\") == { \\"hello\\": 3, \\"world\\": 2, \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"test\\": 1, } def test_punctuation_removal(): assert word_count(\\"Hi! This-test? Yes, it's... okay.\\") == { \\"hi\\": 1, \\"this\\": 1, \\"test\\": 1, \\"yes\\": 1, \\"it\\": 1, \\"s\\": 1, \\"okay\\": 1, } def test_case_insensitivity(): assert word_count(\\"Apple apple APPLE\\") == {\\"apple\\": 3} def test_empty_string(): assert word_count(\\"\\") == {}","solution":"import re from collections import defaultdict def word_count(s): Returns a map where each word is a key and the value is the number of times that word appears in the string. Ignores case sensitivity and punctuation. # Removing punctuation and converting to lower case words = re.findall(r'bw+b', s.lower()) # Counting words using a dictionary word_map = defaultdict(int) for word in words: word_map[word] += 1 return dict(word_map)"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is a prime number. Prime numbers must be greater than 1, and have no positive divisors other than 1 and itself. Args: n (int): The number to be checked. Returns: bool: True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(-3) False pass def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. Args: numbers (List[int]): The list of integers to filter. Returns: List[int]: A list containing only the prime numbers from the input list. >>> filter_primes([-3, 2, 4, 5, 8, -11, 13, 0]) [2, 5, 13] >>> filter_primes([0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 22, 33, 44, 55, 66]) [11] >>> filter_primes([-2, -3, -4, -5, -6]) [] >>> filter_primes([]) [] pass","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def is_valid_hex(s: str) -> bool: Determines if a given string is a valid hexadecimal number. A valid hexadecimal number can contain digits (0-9) and letters (A-F) or (a-f), and may optionally start with \\"0x\\" or \\"0X\\". Parameters: s (str): The string to be checked. Returns: bool: True if the string is a valid hexadecimal number, False otherwise. pass # Unit Tests: def test_is_valid_hex_with_prefix(): assert is_valid_hex(\\"0x1A3F\\") == True assert is_valid_hex(\\"0XABC\\") == True assert is_valid_hex(\\"0X\\") == False def test_is_valid_hex_without_prefix(): assert is_valid_hex(\\"1A3F\\") == True assert is_valid_hex(\\"1234\\") == True assert is_valid_hex(\\"abcdef\\") == True assert is_valid_hex(\\"ABCDEF\\") == True assert is_valid_hex(\\"123G\\") == False def test_is_valid_hex_empty_string(): assert is_valid_hex(\\"\\") == False def test_is_valid_hex_invalid_characters(): assert is_valid_hex(\\"GHI\\") == False assert is_valid_hex(\\"0x1A3G\\") == False assert is_valid_hex(\\"0YABC\\") == False","solution":"def is_valid_hex(s: str) -> bool: Determines if a given string is a valid hexadecimal number. A valid hexadecimal number can contain digits (0-9) and letters (A-F) or (a-f), and may optionally start with \\"0x\\" or \\"0X\\". Parameters: s (str): The string to be checked. Returns: bool: True if the string is a valid hexadecimal number, False otherwise. if s.startswith(\\"0x\\") or s.startswith(\\"0X\\"): s = s[2:] if len(s) == 0: return False for char in s: if not (char.isdigit() or ('a' <= char <= 'f') or ('A' <= char <= 'F')): return False return True"},{"question":"from datetime import datetime def seconds_difference(start: str, end: str) -> float: Calculate the number of seconds between two datetime strings. Args: start (str): The start datetime string in the format \\"YYYY-MM-DD HH:MM:SS\\". end (str): The end datetime string in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: float: The number of seconds between start and end. Example usage: >>> seconds_difference(\\"2023-01-01 10:00:00\\", \\"2023-01-01 12:00:00\\") 7200.0 >>> seconds_difference(\\"2023-01-01 10:00:00\\", \\"2023-01-02 10:00:00\\") 86400.0","solution":"from datetime import datetime def seconds_difference(start, end): Calculate the number of seconds between two datetime strings. Args: start (str): The start datetime string in the format \\"YYYY-MM-DD HH:MM:SS\\". end (str): The end datetime string in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: float: The number of seconds between start and end. start_dt = datetime.strptime(start, '%Y-%m-%d %H:%M:%S') end_dt = datetime.strptime(end, '%Y-%m-%d %H:%M:%S') difference = (end_dt - start_dt).total_seconds() return difference"},{"question":"def find_unique_elements(input_list): Returns a list containing unique elements from the input list, preserving the original order. Args: input_list (List[int]): The list of integers from which to find unique elements. Returns: List[int]: A list containing only the unique elements from the original list in the same order they first appeared. Raises: ValueError: If the input is not a list or if any element is not an integer. >>> find_unique_elements([1, 2, 3, 2, 1, 4]) [1, 2, 3, 4] >>> find_unique_elements([4, 5, 6]) [4, 5, 6] >>> find_unique_elements([]) [] >>> find_unique_elements([7, 7, 7, 7]) [7] >>> find_unique_elements([9]) [9] >>> find_unique_elements([1, 1, 2, 3, 3, 2, 4]) [1, 2, 3, 4] pass import pytest def test_unique_elements_order(): assert find_unique_elements([1, 2, 3, 2, 1, 4]) == [1, 2, 3, 4] def test_all_unique_elements(): assert find_unique_elements([4, 5, 6]) == [4, 5, 6] def test_empty_list(): assert find_unique_elements([]) == [] def test_no_unique_elements(): assert find_unique_elements([7, 7, 7, 7]) == [7] def test_single_element_list(): assert find_unique_elements([9]) == [9] def test_mixed_elements(): assert find_unique_elements([1, 1, 2, 3, 3, 2, 4]) == [1, 2, 3, 4] def test_raises_value_error_on_non_list_input(): with pytest.raises(ValueError): find_unique_elements(\\"not a list\\") def test_raises_value_error_on_non_integer_element(): with pytest.raises(ValueError): find_unique_elements([1, 2, \\"three\\", 4])","solution":"def find_unique_elements(input_list): Returns a list containing unique elements from the input list, preserving the original order. if not isinstance(input_list, list): raise ValueError(\\"Input must be a list\\") for element in input_list: if not isinstance(element, int): raise ValueError(\\"All elements in the list must be integers\\") seen = set() unique_list = [] for item in input_list: if item not in seen: seen.add(item) unique_list.append(item) return unique_list"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into a single sorted linked list. The function should take as input two linked lists where each node contains an integer value and a reference to the next node. The returned linked list should be sorted in ascending order. >>> linked_list_from_list([]) == [] >>> linked_list_from_list([1, 2, 3]) == [1, 2, 3] >>> linked_list_from_list([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> linked_list_from_list([1, 3, 5], [1, 3, 4]) == [1, 1, 3, 3, 4, 5] >>> linked_list_from_list([1, 2, 3], [4, 5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists and returns it as a new sorted list. The new list is made by splicing together the nodes of the first two lists. dummy = ListNode() # Dummy node to form the base of the merged list current = dummy # Pointer to the current end of the merged list # Traverse both lists and append the smaller value to the merged list while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If any elements remain in either list, append them if l1: current.next = l1 else: current.next = l2 # Return the merged list, skipping the dummy head node return dummy.next"},{"question":"from typing import List, Dict def percentage_of_high_rated_products(reviews: List[Dict[str, any]]) -> float: Determines the percentage of products with an average rating above 4.0. Parameters: reviews (list of dict): A list of review data, where each review is a dictionary containing 'rating', 'product_id', and 'review_date'. Returns: float: The percentage of products with an average rating above 4.0. pass # Unit Tests def test_case_one(): data = [ {'rating': 5, 'product_id': 'A1', 'review_date': '2023-01-01'}, {'rating': 4, 'product_id': 'A1', 'review_date': '2023-01-02'}, {'rating': 3, 'product_id': 'A2', 'review_date': '2023-01-03'}, {'rating': 5, 'product_id': 'A2', 'review_date': '2023-01-04'}, {'rating': 5, 'product_id': 'A3', 'review_date': '2023-01-05'}, {'rating': 4, 'product_id': 'A3', 'review_date': '2023-01-06'}, {'rating': 5, 'product_id': 'A3', 'review_date': '2023-01-07'}, ] assert percentage_of_high_rated_products(data) == 66.66666666666666 def test_case_two(): data = [ {'rating': 2, 'product_id': 'A1', 'review_date': '2023-01-01'}, {'rating': 4, 'product_id': 'A1', 'review_date': '2023-01-02'}, {'rating': 3, 'product_id': 'A2', 'review_date': '2023-01-03'}, {'rating': 5, 'product_id': 'A2', 'review_date': '2023-01-04'}, {'rating': 4, 'product_id': 'A3', 'review_date': '2023-01-05'}, ] assert percentage_of_high_rated_products(data) == 0.0 def test_case_three(): data = [] assert percentage_of_high_rated_products(data) == 0.0 def test_case_four(): data = [ {'rating': 5, 'product_id': 'A1', 'review_date': '2023-01-01'}, {'rating': 5, 'product_id': 'A1', 'review_date': '2023-01-02'}, {'rating': 5, 'product_id': 'A2', 'review_date': '2023-01-03'} ] assert percentage_of_high_rated_products(data) == 100.0 def test_case_five(): data = [ {'rating': 3, 'product_id': 'A1', 'review_date': '2023-01-01'}, {'rating': 5, 'product_id': 'A1', 'review_date': '2023-01-02'}, {'rating': 4, 'product_id': 'A2', 'review_date': '2023-01-03'}, {'rating': 2, 'product_id': 'A2', 'review_date': '2023-01-04'}, {'rating': 5, 'product_id': 'A3', 'review_date': '2023-01-05'}, {'rating': 4, 'product_id': 'A3', 'review_date': '2023-01-06'}, {'rating': 5, 'product_id': 'A3', 'review_date': '2023-01-07'}, {'rating': 1, 'product_id': 'A4', 'review_date': '2023-01-08'}, ] assert percentage_of_high_rated_products(data) == 25.0","solution":"def percentage_of_high_rated_products(reviews): Determines the percentage of products with an average rating above 4.0. Parameters: reviews (list of dict): A list of review data, where each review is a dictionary containing 'rating', 'product_id', and 'review_date'. Returns: float: The percentage of products with an average rating above 4.0. from collections import defaultdict product_ratings = defaultdict(list) for review in reviews: product_id = review['product_id'] rating = review['rating'] product_ratings[product_id].append(rating) high_rated_count = 0 for ratings in product_ratings.values(): avg_rating = sum(ratings) / len(ratings) if avg_rating > 4.0: high_rated_count += 1 total_products = len(product_ratings) if total_products == 0: return 0.0 return (high_rated_count / total_products) * 100"},{"question":"def remove_duplicates(input_list: List[int]) -> List[int]: Removes duplicate elements from the input list while maintaining the original order of their first occurrences. Args: input_list (list): The list of integers from which duplicates are to be removed. Returns: list: A new list with duplicates removed and the original order preserved. >>> remove_duplicates([]) [] >>> remove_duplicates([1]) [1] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 2, 2, 3, 4, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates(list(range(1000)) + list(range(1000))) list(range(1000)) >>> remove_duplicates([-1, -1, 2, 2, -3, -3, 3, 3]) [-1, 2, -3, 3] >>> remove_duplicates([1, -1, 1, 2, -2, -1, 2, 3, -2, 3]) [1, -1, 2, -2, 3]","solution":"def remove_duplicates(input_list): Removes duplicate elements from the input list while maintaining the original order of their first occurrences. Args: input_list (list): The list of integers from which duplicates are to be removed. Returns: list: A new list with duplicates removed and the original order preserved. seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"import pandas as pd import numpy as np def create_dataframe(): Create a DataFrame with columns 'Name', 'Age', 'Salary', and 'Department'. The 'Name' column should include 5 different names. The 'Age' column should include ages ranging between 25 to 45. The 'Salary' column should contain salaries between 50,000 to 100,000. The 'Department' column should have categorical values: 'HR', 'Development', 'Marketing', 'Sales', and 'Support'. Returns: A pandas DataFrame. def calculate_average_salary_by_department(df): Calculate the average salary for each department in the given DataFrame. Args: df: A pandas DataFrame with columns 'Name', 'Age', 'Salary', and 'Department'. Returns: A pandas Series with the average salary for each department. >>> df = create_dataframe() >>> calculate_average_salary_by_department(df) HR 70000 Development 90000 Marketing 56000 Sales 80000 Support 100000 Name: Salary, dtype: int64","solution":"import pandas as pd import numpy as np def create_dataframe(): data = { \\"Name\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"], \\"Age\\": [28, 35, 30, 40, 45], \\"Salary\\": [70000, 90000, 56000, 80000, 100000], \\"Department\\": [\\"HR\\", \\"Development\\", \\"Marketing\\", \\"Sales\\", \\"Support\\"] } df = pd.DataFrame(data) return df def calculate_average_salary_by_department(df): return df.groupby(\\"Department\\")[\\"Salary\\"].mean()"},{"question":"from typing import List def elements_appearing_k_times(lst: List[int], k: int) -> List[int]: Write a function that accepts a list of integers and an integer \`k\`, and returns a new list containing all unique elements from the original list that appear exactly \`k\` times. The returned list should be sorted in the order the elements first appeared in the original list. If no elements meet the criteria, return an empty list. >>> elements_appearing_k_times([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> elements_appearing_k_times([1, 2, 2, 3, 3, 4, 4], 3) [] >>> elements_appearing_k_times([4, 4, 4, 2, 2, 3, 5, 5, 5, 5], 2) [2] >>> elements_appearing_k_times([4, 4, 4, 2, 2, 3, 5, 5, 5, 5], 3) [4] >>> elements_appearing_k_times([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3) [3] >>> elements_appearing_k_times([10, 20, 20, 30, 30, 30], 1) [10]","solution":"def elements_appearing_k_times(lst, k): Returns a list of unique elements that appear exactly k times in the original list. The returned list is sorted in the order the elements first appeared in the original list. from collections import Counter counter = Counter(lst) result = [] seen = set() for element in lst: if counter[element] == k and element not in seen: result.append(element) seen.add(element) return result"},{"question":"def fibonacci(n: int) -> int: Compute the nth Fibonacci number using a method that ensures efficiency for large inputs. Constraints: 0 <= n <= 10^5 >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 >>> fibonacci(100) 354224848179261915075","solution":"def fibonacci(n: int) -> int: Compute the nth Fibonacci number using an efficient approach. if n < 0: raise ValueError(\\"The input n should be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 fib = [0, 1] for i in range(2, n + 1): fib.append(fib[-1] + fib[-2]) return fib[-1]"},{"question":"import datetime from typing import List, Tuple def read_pairs(file_path: str) -> List[Tuple[str, int]]: Reads pairs of names and ages from the given file. Returns a list of tuples (name, age). Logs any errors encountered to 'error_log.txt'. pass def sort_pairs(pairs: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the pairs based on age in ascending order. If two people have the same age, they are sorted alphabetically by name. pass def write_pairs(file_path: str, pairs: List[Tuple[str, int]]): Writes the sorted pairs to the given file. pass def log_error(message: str): Logs errors with a timestamp to 'error_log.txt'. pass def sort_names_by_age(input_file: str, output_file: str): Main function to read input file, sort pairs, and write to output file. pass import os def test_read_pairs(): input_file = 'test_input.txt' with open(input_file, 'w') as file: file.write(\\"Alice 30nBob 25nCharlie 25nEve 22nInvalidLinenJohn 30nJanen\\") pairs = read_pairs(input_file) assert pairs == [('Alice', 30), ('Bob', 25), ('Charlie', 25), ('Eve', 22), ('John', 30)] os.remove('error_log.txt') os.remove(input_file) def test_sort_pairs(): pairs = [('Alice', 30), ('Bob', 25), ('Charlie', 25), ('Eve', 22)] sorted_pairs = sort_pairs(pairs) assert sorted_pairs == [('Eve', 22), ('Bob', 25), ('Charlie', 25), ('Alice', 30)] def test_write_pairs(): output_file = 'test_output.txt' pairs = [('Eve', 22), ('Bob', 25), ('Charlie', 25), ('Alice', 30)] write_pairs(output_file, pairs) with open(output_file, 'r') as file: lines = file.readlines() assert lines == [\\"Eve 22n\\", \\"Bob 25n\\", \\"Charlie 25n\\", \\"Alice 30n\\"] os.remove(output_file) def test_sort_names_by_age(): input_file = 'test_input.txt' output_file = 'test_output.txt' with open(input_file, 'w') as file: file.write(\\"Alice 30nBob 25nCharlie 25nEve 22nJohn 30n\\") sort_names_by_age(input_file, output_file) with open(output_file, 'r') as file: lines = file.readlines() assert lines == [\\"Eve 22n\\", \\"Bob 25n\\", \\"Charlie 25n\\", \\"Alice 30n\\", \\"John 30n\\"] os.remove(input_file) os.remove(output_file) def test_log_error(): log_file = 'error_log.txt' log_error(\\"Test error message\\") with open(log_file, 'r') as file: lines = file.readlines() assert len(lines) == 1 assert \\"Test error message\\" in lines[0] os.remove(log_file)","solution":"import datetime def read_pairs(file_path): Reads pairs of names and ages from the given file. Returns a list of tuples (name, age). Logs any errors encountered to 'error_log.txt'. pairs = [] with open(file_path, 'r') as file: for line in file: try: name, age = line.strip().split() age = int(age) pairs.append((name, age)) except ValueError as e: log_error(f\\"Invalid line '{line.strip()}': {e}\\") return pairs def sort_pairs(pairs): Sorts the pairs based on age in ascending order. If two people have the same age, they are sorted alphabetically by name. return sorted(pairs, key=lambda x: (x[1], x[0])) def write_pairs(file_path, pairs): Writes the sorted pairs to the given file. with open(file_path, 'w') as file: for name, age in pairs: file.write(f\\"{name} {age}n\\") def log_error(message): Logs errors with a timestamp to 'error_log.txt'. with open('error_log.txt', 'a') as log_file: timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') log_file.write(f\\"[{timestamp}] Error: {message}n\\") def sort_names_by_age(input_file, output_file): Main function to read input file, sort pairs, and write to output file. pairs = read_pairs(input_file) sorted_pairs = sort_pairs(pairs) write_pairs(output_file, sorted_pairs)"},{"question":"def parse_log_file(log_file: list) -> dict: Parses the log file content and calculates the total number of log entries for each log level. Parameters: log_file (list): List of strings, each representing a line in the log file. Returns: dict: Dictionary with log levels as keys and their corresponding counts as values. >>> parse_log_file([ ... \\"2023-10-01T12:00:00 INFO Server started\\", ... \\"2023-10-01T12:05:23 WARNING High memory usage\\", ... \\"2023-10-01T12:10:45 ERROR Disk full\\", ... \\"2023-10-01T13:00:00 INFO Server stopped\\" ... ]) == {\\"INFO\\": 2, \\"WARNING\\": 1, \\"ERROR\\": 1} >>> parse_log_file([ ... \\"2023-10-01T12:00:00 INFO Server started\\", ... \\"2023-10-01T12:05:23 INFO Service running\\", ... \\"2023-10-01T12:10:45 INFO Service active\\", ... \\"2023-10-01T13:00:00 INFO Server stopped\\" ... ]) == {\\"INFO\\": 4, \\"WARNING\\": 0, \\"ERROR\\": 0} >>> parse_log_file([ ... \\"2023-10-01T12:05:23 WARNING High memory usage\\", ... \\"2023-10-01T12:10:45 ERROR Disk full\\", ... \\"2023-10-01T13:10:00 ERROR Network failure\\", ... \\"2023-10-01T13:11:00 WARNING CPU Overload\\" ... ]) == {\\"INFO\\": 0, \\"WARNING\\": 2, \\"ERROR\\": 2} >>> parse_log_file([]) == {\\"INFO\\": 0, \\"WARNING\\": 0, \\"ERROR\\": 0} >>> parse_log_file([ ... \\"2023-10-01T12:00:00 INFO Server started\\", ... \\"2023-10-01T12:05:23 WARNING High memory usage\\", ... \\"2023-10-01T12:10:45 ERROR Disk full\\", ... \\"2023-10-01T13:00:00 INFO Server stopped\\", ... \\"2023-10-01T13:05:00 WARNING High memory usage\\", ... \\"2023-10-01T13:10:45 ERROR Disk full\\", ... \\"2023-10-01T14:00:00 INFO Server restarted\\", ... ]) == {\\"INFO\\": 3, \\"WARNING\\": 2, \\"ERROR\\": 2}","solution":"def parse_log_file(log_file): Parses the log file content and calculates the total number of log entries for each log level. Parameters: log_file (list): List of strings, each representing a line in the log file. Returns: dict: Dictionary with log levels as keys and their corresponding counts as values. log_counts = { \\"INFO\\": 0, \\"WARNING\\": 0, \\"ERROR\\": 0 } for line in log_file: parts = line.split() log_level = parts[1] if log_level in log_counts: log_counts[log_level] += 1 return log_counts # Sample input log_file_content = [ \\"2023-10-01T12:00:00 INFO Server started\\", \\"2023-10-01T12:05:23 WARNING High memory usage\\", \\"2023-10-01T12:10:45 ERROR Disk full\\", \\"2023-10-01T13:00:00 INFO Server stopped\\" ] # Run the function with sample input print(parse_log_file(log_file_content))"},{"question":"class BankAccount: Simulates a simple bank account. The account allows deposits, withdrawals, and checking the current balance. It prevents overdrafting by ensuring withdrawals do not exceed the account balance. It can handle multiple transactions in sequence. >>> account = BankAccount(100) >>> account.get_balance() 100 >>> account.deposit(50) True >>> account.get_balance() 150 >>> account.withdraw(30) True >>> account.get_balance() 120 >>> account.withdraw(150) False >>> account.get_balance() 120 def __init__(self, initial_balance=0): pass def deposit(self, amount): pass def withdraw(self, amount): pass def get_balance(self): pass","solution":"class BankAccount: def __init__(self, initial_balance=0): self.balance = initial_balance def deposit(self, amount): if amount > 0: self.balance += amount return True return False def withdraw(self, amount): if 0 < amount <= self.balance: self.balance -= amount return True return False def get_balance(self): return self.balance"},{"question":"def transform_list(int_list: List[int]) -> List[int]: Transforms a list of integers according to the following rule: - If the element is even, replace it with its square. - If the element is odd, replace it with its cube. Args: int_list (list): List of integers. Returns: list: Transformed list of integers. Examples: >>> transform_list([1, 2, 3, 4, 5, 6]) [1, 4, 27, 16, 125, 36] >>> transform_list([2, 4, 6]) [4, 16, 36] >>> transform_list([1, 3, 5]) [1, 27, 125] >>> transform_list([]) [] >>> transform_list([4]) [16] >>> transform_list([3]) [27]","solution":"def transform_list(int_list): Transforms a list of integers according to the following rule: - If the element is even, replace it with its square. - If the element is odd, replace it with its cube. Args: int_list (list): List of integers. Returns: list: Transformed list of integers. return [x**2 if x % 2 == 0 else x**3 for x in int_list]"},{"question":"class TicTacToe: A simple tic-tac-toe game for two players Example usage: >>> game = TicTacToe() >>> game.make_move(0, 0) 'Move accepted' >>> game.make_move(0, 1) 'Move accepted' >>> game.make_move(1, 1) 'Move accepted' >>> game.make_move(0, 2) 'Move accepted' >>> game.make_move(2, 2) 'Player X wins!'","solution":"class TicTacToe: def __init__(self): self.board = [[' ' for _ in range(3)] for _ in range(3)] self.current_player = 'X' def display_board(self): for row in self.board: print('|'.join(row)) print('-'*5) def make_move(self, row, col): if self.board[row][col] == ' ': self.board[row][col] = self.current_player if self.check_winner(self.current_player): return f\\"Player {self.current_player} wins!\\" if self.check_draw(): return \\"The game is a draw!\\" self.current_player = 'O' if self.current_player == 'X' else 'X' return \\"Move accepted\\" else: return \\"Invalid move\\" def check_winner(self, player): win_conditions = [ [self.board[0][0], self.board[0][1], self.board[0][2]], [self.board[1][0], self.board[1][1], self.board[1][2]], [self.board[2][0], self.board[2][1], self.board[2][2]], [self.board[0][0], self.board[1][0], self.board[2][0]], [self.board[0][1], self.board[1][1], self.board[2][1]], [self.board[0][2], self.board[1][2], self.board[2][2]], [self.board[0][0], self.board[1][1], self.board[2][2]], [self.board[2][0], self.board[1][1], self.board[0][2]] ] if [player, player, player] in win_conditions: return True return False def check_draw(self): for row in self.board: if ' ' in row: return False return True def reset_game(self): self.__init__()"},{"question":"import pandas as pd import matplotlib.pyplot as plt def load_data(url): Loads data from the specified CSV URL. # Implementation here pass def clean_data(data): Cleans the dataset by handling missing values and erroneous data. # Implementation here pass def calculate_average_closing_price(data): Calculates the average closing price for each company. # Implementation here pass def highest_trading_volume_day(data): Identifies the day with the highest trading volume for each company. # Implementation here pass def plot_closing_prices(data, company): Creates a line plot representing the daily closing prices of the specified company over time. # Implementation here pass # Example usage: # url = \\"http://example.com/stock_prices.csv\\" # data = load_data(url) # clean_data = clean_data(data) # average_closing_prices = calculate_average_closing_price(clean_data) # highest_volume_days = highest_trading_volume_day(clean_data) # plot_closing_prices(clean_data, 'Company_Name') # Unit Tests def test_clean_data_handles_missing_values(): data = pd.DataFrame({ 'Date': ['2022-01-01', None, '2022-01-03'], 'Company': ['Company_A', 'Company_B', 'Company_A'], 'Open': [100, 105, 110], 'High': [110, 115, 120], 'Low': [90, None, 100], 'Close': [105, 110, 115], 'Volume': [1000, 2000, None] }) cleaned_data = clean_data(data) assert cleaned_data.shape[0] == 1 def test_calculate_average_closing_price(): data = pd.DataFrame({ 'Company': ['Company_A', 'Company_B', 'Company_A'], 'Close': [100, 200, 150] }) avg_closing_price = calculate_average_closing_price(data) assert avg_closing_price[avg_closing_price['Company'] == 'Company_A']['Close'].values[0] == 125 assert avg_closing_price[avg_closing_price['Company'] == 'Company_B']['Close'].values[0] == 200 def test_highest_trading_volume_day(): data = pd.DataFrame({ 'Date': ['2022-01-01', '2022-01-02', '2022-01-03', '2022-01-01', '2022-01-02'], 'Company': ['Company_A', 'Company_A', 'Company_A', 'Company_B', 'Company_B'], 'Volume': [1000, 1500, 1200, 3000, 2000] }) highest_volume = highest_trading_volume_day(data) assert highest_volume[(highest_volume['Company'] == 'Company_A') & (highest_volume['Date'] == '2022-01-02')].empty == False assert highest_volume[(highest_volume['Company'] == 'Company_B') & (highest_volume['Date'] == '2022-01-01')].empty == False def test_plot_closing_prices(): from pandas.plotting import register_matplotlib_converters register_matplotlib_converters() data = pd.DataFrame({ 'Date': pd.to_datetime(['2022-01-01', '2022-01-02', '2022-01-03']), 'Company': ['Company_A', 'Company_A', 'Company_A'], 'Close': [100, 105, 110] }) # We won't assert anything for plots here, just ensure it runs without errors. try: plot_closing_prices(data, 'Company_A') except Exception as e: assert False, f\\"Plotting function raised an exception: {e}\\"","solution":"import pandas as pd import matplotlib.pyplot as plt def load_data(url): Loads data from the specified CSV URL. return pd.read_csv(url) def clean_data(data): Cleans the dataset by handling missing values and erroneous data. # Remove rows where any of the critical columns contain missing values data = data.dropna(subset=['Date', 'Company', 'Open', 'High', 'Low', 'Close', 'Volume']) # Convert the data types to appropriate types data['Date'] = pd.to_datetime(data['Date'], errors='coerce') data['Open'] = pd.to_numeric(data['Open'], errors='coerce') data['High'] = pd.to_numeric(data['High'], errors='coerce') data['Low'] = pd.to_numeric(data['Low'], errors='coerce') data['Close'] = pd.to_numeric(data['Close'], errors='coerce') data['Volume'] = pd.to_numeric(data['Volume'], errors='coerce') # Drop rows with any conversions that failed (contain NaN) data = data.dropna() return data def calculate_average_closing_price(data): Calculates the average closing price for each company. return data.groupby('Company')['Close'].mean().reset_index() def highest_trading_volume_day(data): Identifies the day with the highest trading volume for each company. idx = data.groupby('Company')['Volume'].idxmax() return data.loc[idx, ['Company', 'Date', 'Volume']] def plot_closing_prices(data, company): Creates a line plot representing the daily closing prices of the specified company over time. company_data = data[data['Company'] == company] plt.figure(figsize=(10,6)) plt.plot(company_data['Date'], company_data['Close']) plt.xlabel('Date') plt.ylabel('Closing Price') plt.title(f'Daily Closing Prices for {company}') plt.xticks(rotation=45) plt.tight_layout() plt.show() # Example usage (assuming the presence of required URL): # url = \\"http://example.com/stock_prices.csv\\" # data = load_data(url) # clean_data = clean_data(data) # average_closing_prices = calculate_average_closing_price(clean_data) # highest_volume_days = highest_trading_volume_day(clean_data) # plot_closing_prices(clean_data, 'Company_Name')"},{"question":"def process_string(s: str) -> str: Processes a string to separate out digits and alphabetical characters, sorts digits in ascending order and characters in descending order while retaining their original case. >>> process_string(\\"a3B1c2A\\") == \\"123cBaA\\" >>> process_string(\\"987\\") == \\"789\\" >>> process_string(\\"aBcD\\") == \\"DcBa\\" >>> process_string(\\"\\") == \\"\\" >>> process_string(\\"dCba2134\\") == \\"1234dCba\\" >>> process_string(\\"bbaa2211\\") == \\"1122bbaa\\" >>> process_string(\\"!a2b1*c\\") == \\"12cba\\" >>> process_string(\\"DCBA\\") == \\"DCBA\\" >>> process_string(\\"abcd\\") == \\"dcba\\"","solution":"def process_string(s): digits = sorted(char for char in s if char.isdigit()) letters = sorted((char for char in s if char.isalpha()), key=lambda x: x.lower(), reverse=True) return ''.join(digits + letters)"},{"question":"from typing import List, Dict def separate_positive_negative(numbers: List[str]) -> Dict[str, List[int]]: Takes a list of strings where each string can be either a positive or a negative integer, and returns a dictionary with two keys: \\"positive\\" and \\"negative\\". The value associated with each key is a list of integers that are either positive or negative, sorted in ascending order. Args: numbers (list of str): List of strings representing integers. Returns: dict: A dictionary with two keys: \\"positive\\" and \\"negative\\". >>> separate_positive_negative([\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\"]) {'positive': [1, 2, 3, 4, 5], 'negative': []} >>> separate_positive_negative([\\"-1\\", \\"-2\\", \\"-3\\", \\"-4\\", \\"-5\\"]) {'positive': [], 'negative': [-5, -4, -3, -2, -1]} >>> separate_positive_negative([\\"1\\", \\"-2\\", \\"3\\", \\"-4\\", \\"5\\"]) {'positive': [1, 3, 5], 'negative': [-4, -2]} >>> separate_positive_negative([\\"1\\", \\"-two\\", \\"3\\", \\"four\\", \\"5\\"]) {'positive': [1, 3, 5], 'negative': []} >>> separate_positive_negative([]) {'positive': [], 'negative': []} >>> separate_positive_negative([\\"0\\", \\"1\\", \\"-1\\", \\"2\\", \\"-2\\"]) {'positive': [0, 1, 2], 'negative': [-2, -1]} >>> separate_positive_negative([\\"1000\\", \\"-1000\\", \\"999\\", \\"-999\\"]) {'positive': [999, 1000], 'negative': [-1000, -999]}","solution":"def separate_positive_negative(numbers): Takes a list of strings where each string can be either a positive or a negative integer, and returns a dictionary with two keys: \\"positive\\" and \\"negative\\". The value associated with each key is a list of integers that are either positive or negative, sorted in ascending order. Args: numbers (list of str): List of strings representing integers. Returns: dict: A dictionary with two keys: \\"positive\\" and \\"negative\\". positive = [] negative = [] for num in numbers: try: num_int = int(num) if num_int >= 0: positive.append(num_int) else: negative.append(num_int) except ValueError: continue return { \\"positive\\": sorted(positive), \\"negative\\": sorted(negative) }"},{"question":"from datetime import datetime def generate_sorted_temperature_list(date_list: List[str], temp_list: List[int]) -> List[str]: Generate a sorted list of tuples with date strings and corresponding temperature readings. Each tuple contains a datetime object and an integer temperature value. Args: date_list (list of str): List of date strings. temp_list (list of int): List of temperatures corresponding to the dates. Returns: list of str: Sorted list of strings by date in ascending order where each string is in the format 'YYYY-MM-DD: temperature'. >>> generate_sorted_temperature_list(['2021-07-20', '2020-05-15', '2022-09-30'], [30, 22, 25]) ['2020-05-15: 22', '2021-07-20: 30', '2022-09-30: 25'] >>> generate_sorted_temperature_list(['2021-03-20', '2021-05-20', '2021-01-20'], [15, 20, 10]) ['2021-01-20: 10', '2021-03-20: 15', '2021-05-20: 20'] >>> generate_sorted_temperature_list([], []) [] >>> generate_sorted_temperature_list(['2020-05-15'], [22]) ['2020-05-15: 22'] # Your code here","solution":"from datetime import datetime def generate_sorted_temperature_list(date_list, temp_list): Generate a sorted list of tuples with date strings and corresponding temperature readings. Each tuple contains a datetime object and an integer temperature value. Args: date_list (list of str): List of date strings. temp_list (list of int): List of temperatures corresponding to the dates. Returns: list of tuple: Sorted list of tuples by date in ascending order. # Zip the lists together into a list of tuples combined_list = list(zip(date_list, temp_list)) # Convert date strings to datetime objects and create a new list of tuples datetime_temp_list = [(datetime.strptime(date, '%Y-%m-%d'), temp) for date, temp in combined_list] # Sort the list of tuples by datetime objects sorted_datetime_temp_list = sorted(datetime_temp_list) # Format the sorted list for printing formatted_list = [f\\"{date.strftime('%Y-%m-%d')}: {temp}\\" for date, temp in sorted_datetime_temp_list] return formatted_list"},{"question":"def average_scores(students_scores): Takes a dictionary with names as keys and lists of scores as values. Returns a new dictionary with names as keys and average scores rounded to two decimal places as values. Parameters: students_scores (dict): A dictionary where keys are names (strings) and values are lists of integers representing scores. Returns: dict: A dictionary with the same keys, but with values being the average score for each name, rounded to two decimal places. Examples: >>> average_scores({ ... \\"Alice\\": [88, 76, 92, 85], ... \\"Bob\\": [67, 80, 78, 72], ... \\"Charlie\\": [95, 90, 85, 87] ... }) {\\"Alice\\": 85.25, \\"Bob\\": 74.25, \\"Charlie\\": 89.25}","solution":"def average_scores(students_scores): Takes a dictionary with names as keys and lists of scores as values. Returns a new dictionary with names as keys and average scores rounded to two decimal places as values. averages = {} for name, scores in students_scores.items(): average_score = sum(scores) / len(scores) if scores else 0 averages[name] = round(average_score, 2) return averages"},{"question":"def count_vowels(strings: List[str]) -> Dict[str, int]: Takes a list of strings and returns a dictionary with the strings as keys and the number of vowels in each string as values. Ignores case. >>> count_vowels(['hello']) {'hello': 2} >>> count_vowels(['HELLO', 'HeLLo']) {'HELLO': 2, 'HeLLo': 2} >>> count_vowels(['aeiou', 'wxyz']) {'aeiou': 5, 'wxyz': 0}","solution":"def count_vowels(strings): Takes a list of strings and returns a dictionary with the strings as keys and the number of vowels in each string as values. Ignores case. def vowel_count(s): vowels = \\"aeiou\\" count = 0 for char in s.lower(): if char in vowels: count += 1 return count result = {s: vowel_count(s) for s in strings} return result"},{"question":"import string def is_anagram(str1: str, str2: str) -> bool: Check if str1 is a valid anagram of str2. The function should ignore spaces, punctuation marks, and capitalization, considering only the alphabetical characters. >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") True >>> is_anagram(\\"the eyes\\", \\"they see\\") True >>> is_anagram(\\"hello\\", \\"world\\") False >>> is_anagram(\\"William Shakespeare!\\", \\"I am a weakish speller.\\") True >>> is_anagram(\\"\\", \\"\\") True","solution":"import string def is_anagram(str1, str2): Check if str1 is a valid anagram of str2. # Removing spaces, punctuation marks and converting to lowercase translator = str.maketrans('', '', string.punctuation + string.whitespace) clean_str1 = str1.translate(translator).lower() clean_str2 = str2.translate(translator).lower() # Check if the sorted characters of the cleaned strings are identical return sorted(clean_str1) == sorted(clean_str2)"},{"question":"from typing import List, Tuple def navigate(commands: List[str]) -> Tuple[int, int]: Navigate a spaceship in a 2D Cartesian coordinate system based on a sequence of commands. It starts from the origin (0, 0) and faces the positive X-axis direction initially. Available commands: - \\"F n\\": Move forward in the current direction by n units. - \\"L\\": Turn 90 degrees to the left. - \\"R\\": Turn 90 degrees to the right. Args: commands (List[str]): List of commands to navigate the spaceship. Returns: Tuple[int, int]: The final coordinates of the spaceship. Examples: >>> navigate([\\"F 10\\", \\"L\\", \\"F 5\\", \\"R\\", \\"F 2\\"]) (12, 5) >>> navigate([\\"F 3\\", \\"R\\", \\"F 2\\", \\"R\\", \\"F 1\\", \\"L\\", \\"F 2\\"]) (2, -4) >>> navigate([\\"F 1\\", \\"F 2\\", \\"F 3\\"]) (6, 0) >>> navigate([\\"L\\", \\"L\\", \\"L\\", \\"L\\"]) (0, 0) >>> navigate([\\"R\\", \\"R\\", \\"R\\", \\"R\\"]) (0, 0) >>> navigate([\\"F 2\\", \\"R\\", \\"F 2\\", \\"R\\", \\"F 2\\", \\"R\\", \\"F 2\\"]) (0, 0) >>> navigate([\\"F 1000\\", \\"L\\", \\"F 1000\\", \\"L\\", \\"F 1000\\", \\"L\\", \\"F 1000\\"]) (0, 0)","solution":"from typing import List, Tuple def navigate(commands: List[str]) -> Tuple[int, int]: # Define the direction vectors for (x, y) starting from positive X direction. # Directions are in clockwise: 0 - (1,0), 1 - (0,-1), 2 - (-1,0), 3 - (0,1) directions = [(1, 0), (0, -1), (-1, 0), (0, 1)] x, y = 0, 0 # Starting coordinates direction_index = 0 # Start facing positive X-axis for command in commands: if command.startswith(\\"F\\"): # Forward N units parts = command.split() n = int(parts[1]) dx, dy = directions[direction_index] x += dx * n y += dy * n elif command == \\"L\\": # Turn left 90 degrees (counter-clockwise) direction_index = (direction_index - 1) % 4 elif command == \\"R\\": # Turn right 90 degrees (clockwise) direction_index = (direction_index + 1) % 4 return (x, y)"},{"question":"import pytest from typing import List def is_valid_input(numbers: List[int], K: int) -> bool: Validates the input to check if \`numbers\` is a list of integers and \`K\` is an integer within the range 1 to 100. # Implementation is required def filter_divisible(numbers: List[int], K: int) -> List[int]: Returns a new list containing only the integers from the provided list that are divisible by K. Raises ValueError if inputs are invalid. >>> filter_divisible([1, 2, 3, 4, 5, 6], 2) -> [2, 4, 6] >>> filter_divisible([10, 15, 20, 25, 30], 5) -> [10, 15, 20, 25, 30] >>> filter_divisible([], 3) -> [] # Implementation is required def test_filter_divisible_valid_input(): assert filter_divisible([1, 2, 3, 4, 5, 6], 2) == [2, 4, 6] assert filter_divisible([10, 15, 20, 25, 30], 5) == [10, 15, 20, 25, 30] assert filter_divisible([], 3) == [] def test_filter_divisible_with_no_multiples(): assert filter_divisible([1, 2, 3, 4], 5) == [] assert filter_divisible([4, 5, 6], 7) == [] def test_filter_divisible_invalid_list_input(): with pytest.raises(ValueError): filter_divisible(\\"not a list\\", 2) def test_filter_divisible_invalid_list_elements(): with pytest.raises(ValueError): filter_divisible([1, \\"a\\", 3], 2) def test_filter_divisible_invalid_K(): with pytest.raises(ValueError): filter_divisible([1, 2, 3], 0) with pytest.raises(ValueError): filter_divisible([1, 2, 3], 101) with pytest.raises(ValueError): filter_divisible([1, 2, 3], \\"a\\")","solution":"def is_valid_input(numbers, K): Validates the input to check if \`numbers\` is a list of integers and \`K\` is an integer within the range 1 to 100. if not isinstance(numbers, list): return False if not all(isinstance(num, int) for num in numbers): return False if not isinstance(K, int) or not (1 <= K <= 100): return False return True def filter_divisible(numbers, K): Returns a new list containing only the integers from the provided list that are divisible by K. Raises ValueError if inputs are invalid. if not is_valid_input(numbers, K): raise ValueError(\\"Invalid input! Ensure that \`numbers\` is a list of integers and \`K\` is an integer within the range 1 to 100.\\") return [num for num in numbers if num % K == 0]"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def nth_from_end(head: ListNode, n: int) -> int: Returns the nth node's value from the end of a singly linked list. If the list has fewer than n elements, returns None. Example Usage: >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> >>> nth_from_end(head, 2) 4 >>> node = ListNode(1) >>> nth_from_end(node, 1) 1 >>> nth_from_end(node, 2) None def test_nth_from_end_single_element(): node = ListNode(1) assert nth_from_end(node, 1) == 1 assert nth_from_end(node, 2) == None def test_nth_from_end_multiple_elements(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) assert nth_from_end(head, 1) == 5 assert nth_from_end(head, 2) == 4 assert nth_from_end(head, 3) == 3 assert nth_from_end(head, 5) == 1 assert nth_from_end(head, 6) == None def test_nth_from_end_empty_list(): assert nth_from_end(None, 1) == None def test_nth_from_end_exact_length(): head = ListNode(10) tail = head for i in range(9): tail.next = ListNode(i) tail = tail.next assert nth_from_end(head, 10) == 10 assert nth_from_end(head, 11) == None","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def nth_from_end(head: ListNode, n: int) -> int: Returns the nth node's value from the end of a singly linked list. If the list has fewer than n elements, returns None. # Initialize two pointers first = head second = head # Move first pointer n steps ahead for _ in range(n): if first is None: return None # If n is greater than the length of list first = first.next # Move both pointers until first reaches the end while first: first = first.next second = second.next # second should now be pointing at the nth node from the end return second.val if second else None"},{"question":"def is_palindrome(s: str) -> tuple: Checks if the given string is a palindrome after removing all non-alphanumeric characters and converting to lowercase. Args: s (str): The input string Returns: tuple: A boolean indicating if the string is a palindrome, and the cleaned version of the string >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") (True, \\"amanaplanacanalpanama\\") >>> is_palindrome(\\"This is not a palindrome\\") (False, \\"thisisnotapalindrome\\") >>> is_palindrome(\\"\\") (True, \\"\\") >>> is_palindrome(\\"MadamInEdenImAdam\\") (True, \\"madaminedenimadam\\") >>> is_palindrome(\\"No 'x' in Nixon\\") (True, \\"noxinnixon\\") # Remove non-alphanumeric characters and convert to lowercase pass # implementation here","solution":"def is_palindrome(s): Checks if the given string is a palindrome after removing all non-alphanumeric characters and converting to lowercase. Args: s (str): The input string Returns: tuple: A boolean indicating if the string is a palindrome, and the cleaned version of the string # Remove non-alphanumeric characters and convert to lowercase cleaned = ''.join(c for c in s if c.isalnum()).lower() # Check if the cleaned string is a palindrome return cleaned == cleaned[::-1], cleaned"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the contiguous subarray within a list which has the largest sum. Args: nums (list of int): The list of integers. Returns: int: The sum of the contiguous subarray with the largest sum. >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([2, 4, 6, 8, 10]) == 30 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-5, -6, -7, -8]) == -5 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([0, -3, 1, -4, 0, 4, -1, 2, -3]) == 5 >>> max_subarray_sum([-1, 0, -2, 0, -3]) == 0 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): Finds the contiguous subarray within a list which has the largest sum. Args: nums (list of int): The list of integers. Returns: int: The sum of the contiguous subarray with the largest sum. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def analyze_lists(list1, list2): Takes two lists of integers and returns a dictionary with four keys: 'unique_in_list1', 'unique_in_list2', 'common_elements', and 'combined_sorted'. Parameters: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: dict: A dictionary with the analysis of the lists. Example: >>> analyze_lists([1, 2, 3, 5, 7], [3, 4, 5, 6]) { 'unique_in_list1': [1, 2, 7], 'unique_in_list2': [4, 6], 'common_elements': [3, 5], 'combined_sorted': [1, 2, 3, 3, 4, 5, 5, 6, 7] }","solution":"def analyze_lists(list1, list2): Takes two lists of integers and returns a dictionary with four keys: 'unique_in_list1', 'unique_in_list2', 'common_elements', and 'combined_sorted'. Parameters: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: dict: A dictionary with the analysis of the lists. set1 = set(list1) set2 = set(list2) unique_in_list1 = sorted(list(set1 - set2)) unique_in_list2 = sorted(list(set2 - set1)) common_elements = sorted(list(set1 & set2)) combined_sorted = sorted(list1 + list2) return { 'unique_in_list1': unique_in_list1, 'unique_in_list2': unique_in_list2, 'common_elements': common_elements, 'combined_sorted': combined_sorted }"},{"question":"def string_lengths(strings: List[str]) -> Dict[str, int]: Takes a list of strings as input and returns a dictionary where each key is a string from the list and its value is the length of that string. Handles case sensitivity and does not count duplicate strings. >>> string_lengths([\\"apple\\", \\"banana\\", \\"Apple\\", \\"cherry\\", \\"banana\\"]) == { ... \\"apple\\": 5, ... \\"banana\\": 6, ... \\"Apple\\": 5, ... \\"cherry\\": 6 ... } >>> string_lengths([]) == {} >>> string_lengths([\\"apple\\"]) == { ... \\"apple\\": 5 ... } >>> string_lengths([\\"Hello\\", \\"hello\\"]) == { ... \\"Hello\\": 5, ... \\"hello\\": 5 ... } >>> string_lengths([\\"test\\", \\"test\\", \\"Test\\", \\"TEST\\"]) == { ... \\"test\\": 4, ... \\"Test\\": 4, ... \\"TEST\\": 4 ... } >>> string_lengths([\\"short\\", \\"loooooong\\", \\"medium\\"]) == { ... \\"short\\": 5, ... \\"loooooong\\": 9, ... \\"medium\\": 6 ... }","solution":"def string_lengths(strings): Takes a list of strings as input and returns a dictionary where each key is a string from the list and its value is the length of that string. Handles case sensitivity and does not count duplicate strings. return {string: len(string) for string in set(strings)}"},{"question":"import pandas as pd from sklearn.linear_model import LinearRegression from sklearn.preprocessing import OneHotEncoder from sklearn.metrics import mean_squared_error, r2_score from sklearn.model_selection import train_test_split def build_and_evaluate_model(): Builds a linear regression model to predict salaries and evaluates its performance. Returns: mse: Mean Squared Error of the model r2: R-squared value of the model years_experience = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] education_level = [\\"Bachelor\\", \\"Bachelor\\", \\"Master\\", \\"Master\\", \\"PhD\\", \\"PhD\\", \\"PhD\\", \\"Master\\", \\"Bachelor\\", \\"Master\\"] num_projects = [1, 2, 2, 3, 4, 5, 6, 3, 2, 4] current_salary = [50000, 55000, 60000, 65000, 70000, 75000, 80000, 70000, 55000, 65000] # Create a DataFrame data = pd.DataFrame({ 'years_experience': years_experience, 'education_level': education_level, 'num_projects': num_projects, 'current_salary': current_salary }) # One-hot encode the education_level column encoder = OneHotEncoder() encoded_education = encoder.fit_transform(data[['education_level']]) encoded_education_df = pd.DataFrame(encoded_education.toarray(), columns=encoder.get_feature_names_out()) # Combine the encoded columns with the original data data = pd.concat([data.drop('education_level', axis=1), encoded_education_df], axis=1) # Define features and target variable X = data.drop('current_salary', axis=1) y = data['current_salary'] # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Train the regression model model = LinearRegression() model.fit(X_train, y_train) # Make predictions y_pred = model.predict(X_test) # Evaluate the model mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) return mse, r2","solution":"import pandas as pd from sklearn.linear_model import LinearRegression from sklearn.preprocessing import OneHotEncoder from sklearn.metrics import mean_squared_error, r2_score from sklearn.model_selection import train_test_split # Define the data years_experience = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] education_level = [\\"Bachelor\\", \\"Bachelor\\", \\"Master\\", \\"Master\\", \\"PhD\\", \\"PhD\\", \\"PhD\\", \\"Master\\", \\"Bachelor\\", \\"Master\\"] num_projects = [1, 2, 2, 3, 4, 5, 6, 3, 2, 4] current_salary = [50000, 55000, 60000, 65000, 70000, 75000, 80000, 70000, 55000, 65000] # Create a DataFrame data = pd.DataFrame({ 'years_experience': years_experience, 'education_level': education_level, 'num_projects': num_projects, 'current_salary': current_salary }) # One-hot encode the education_level column encoder = OneHotEncoder() encoded_education = encoder.fit_transform(data[['education_level']]) encoded_education_df = pd.DataFrame(encoded_education.toarray(), columns=encoder.get_feature_names_out()) # Combine the encoded columns with the original data data = pd.concat([data.drop('education_level', axis=1), encoded_education_df], axis=1) # Define features and target variable X = data.drop('current_salary', axis=1) y = data['current_salary'] # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Train the regression model model = LinearRegression() model.fit(X_train, y_train) # Make predictions y_pred = model.predict(X_test) # Evaluate the model mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) def build_and_evaluate_model(): Builds a linear regression model to predict salaries and evaluates its performance. Returns: mse: Mean Squared Error of the model r2: R-squared value of the model return mse, r2"},{"question":"from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error from sklearn.model_selection import train_test_split import pandas as pd def train_and_evaluate(data: pd.DataFrame) -> float: Trains a Linear Regression model on the given dataset and evaluates its performance. Parameters: data (pd.DataFrame): The dataset containing house features and prices. Returns: float: The Mean Absolute Error on the test set. Example: >>> data = { ... 'bedrooms': [3, 4, 2, 5, 3, 4, 6, 3], ... 'square_footage': [2000, 2500, 1500, 3000, 1800, 2200, 3500, 1800], ... 'has_pool': [True, False, False, True, True, False, True, False], ... 'price': [500000, 600000, 400000, 700000, 550000, 600000, 750000, 500000] ... } >>> df = pd.DataFrame(data) >>> df['has_pool'] = df['has_pool'].astype(int) >>> mae = train_and_evaluate(df) >>> isinstance(mae, float) True >>> mae > 0 True >>> mae < 200000 True def test_train_and_evaluate(): # Create a mock dataset data = { 'bedrooms': [3, 4, 2, 5, 3, 4, 6, 3], 'square_footage': [2000, 2500, 1500, 3000, 1800, 2200, 3500, 1800], 'has_pool': [True, False, False, True, True, False, True, False], 'price': [500000, 600000, 400000, 700000, 550000, 600000, 750000, 500000] } df = pd.DataFrame(data) # Convert boolean to int for the model df['has_pool'] = df['has_pool'].astype(int) # Calculate MAE mae = train_and_evaluate(df) # Assert that the MAE is a float and in a reasonable range (won't be perfect since it's minimal data) assert isinstance(mae, float) assert mae > 0 assert mae < 200000 # arbitrary reasonable boundary for this mock data def test_empty_dataset(): df = pd.DataFrame(columns=['bedrooms', 'square_footage', 'has_pool', 'price']) try: mae = train_and_evaluate(df) except ValueError as e: assert str(e) == 'With n_samples=0, test_size=0.2 and train_size=None, the resulting train set will be empty. Adjust any of the aforementioned parameters.' def test_zero_variance_feature(): data = { 'bedrooms': [3, 3, 3, 3], 'square_footage': [2000, 2000, 2000, 2000], 'has_pool': [True, True, True, True], 'price': [500000, 500000, 500000, 500000] } df = pd.DataFrame(data) # Convert boolean to int for the model df['has_pool'] = df['has_pool'].astype(int) # Calculate MAE mae = train_and_evaluate(df) # Assert that the MAE is zero because all prices are the same assert mae == 0 def test_single_data_point(): data = { 'bedrooms': [3], 'square_footage': [2000], 'has_pool': [0], 'price': [500000] } df = pd.DataFrame(data) try: mae = train_and_evaluate(df) except ValueError as e: assert str(e) == 'With n_samples=1, test_size=0.2 and train_size=None, the resulting train set will be empty. Adjust any of the aforementioned parameters.'","solution":"from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error from sklearn.model_selection import train_test_split import pandas as pd def train_and_evaluate(data): Trains a Linear Regression model on the given dataset and evaluates its performance. Parameters: data (pd.DataFrame): The dataset containing house features and prices. Returns: float: The Mean Absolute Error on the test set. # Features and target X = data[['bedrooms', 'square_footage', 'has_pool']] y = data['price'] # Train-test split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Model training model = LinearRegression() model.fit(X_train, y_train) # Predicting y_pred = model.predict(X_test) # Calculate MAE mae = mean_absolute_error(y_test, y_pred) return mae"},{"question":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generate all possible permutations of a given list of numbers. >>> generate_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_permutations([0, -1, 1]) [[0, -1, 1], [0, 1, -1], [-1, 0, 1], [-1, 1, 0], [1, 0, -1], [1, -1, 0]] pass def test_generate_permutations_three_elements(): result = generate_permutations([1, 2, 3]) expected = [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert sorted(result) == sorted(expected) def test_generate_permutations_two_elements(): result = generate_permutations([1, 2]) expected = [[1, 2], [2, 1]] assert sorted(result) == sorted(expected) def test_generate_permutations_single_element(): result = generate_permutations([1]) expected = [[1]] assert sorted(result) == sorted(expected) def test_generate_permutations_with_zero_and_negatives(): result = generate_permutations([0, -1, 1]) expected = [ [0, -1, 1], [0, 1, -1], [-1, 0, 1], [-1, 1, 0], [1, 0, -1], [1, -1, 0] ] assert sorted(result) == sorted(expected) def test_generate_permutations_empty_list(): result = generate_permutations([]) expected = [[]] assert result == expected","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: def backtrack(start=0): # If we've reached the end of the list, append the permutation if start == len(nums): permutations.append(nums[:]) for i in range(start, len(nums)): # Swap the current element with the start nums[start], nums[i] = nums[i], nums[start] # Recursively generate permutations for the rest of the list backtrack(start + 1) # Swap back to restore the original list state nums[start], nums[i] = nums[i], nums[start] permutations = [] backtrack() return permutations"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeElements(head, val): Removes all instances of val from the linked list. :param head: ListNode, the head of the linked list :param val: int, the value to remove :return: ListNode, the head of the modified linked list from solution import ListNode, removeElements def list_to_array(head): Helper function to convert linked list to array for easy comparison. array = [] while head: array.append(head.val) head = head.next return array def test_remove_elements_empty_list(): assert removeElements(None, 1) == None def test_remove_elements_all_elements_removed(): nodes = ListNode(1, ListNode(1, ListNode(1))) result_head = removeElements(nodes, 1) assert result_head == None def test_remove_elements_no_elements_removed(): nodes = ListNode(1, ListNode(2, ListNode(3))) result_head = removeElements(nodes, 4) assert list_to_array(result_head) == [1, 2, 3] def test_remove_elements_some_elements_removed(): nodes = ListNode(1, ListNode(2, ListNode(2, ListNode(3)))) result_head = removeElements(nodes, 2) assert list_to_array(result_head) == [1, 3] def test_remove_elements_head_is_removed(): nodes = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) result_head = removeElements(nodes, 1) assert list_to_array(result_head) == [2, 3, 4] def test_remove_elements_tail_is_removed(): nodes = ListNode(1, ListNode(2, ListNode(3))) result_head = removeElements(nodes, 3) assert list_to_array(result_head) == [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeElements(head, val): Removes all instances of val from the linked list. :param head: ListNode, the head of the linked list :param val: int, the value to remove :return: ListNode, the head of the modified linked list dummy = ListNode(next=head) current = dummy while current.next: if current.next.val == val: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"def modify_list(lst): Takes a list of integers and returns a new list with the cube of each even number, while leaving the odd numbers unchanged. >>> modify_list([2, 4, 6]) [8, 64, 216] >>> modify_list([1, 3, 5]) [1, 3, 5] >>> modify_list([1, 2, 3, 4]) [1, 8, 3, 64] >>> modify_list([]) [] >>> modify_list([2]) [8] >>> modify_list([1]) [1] >>> modify_list([10, 20, 30]) [1000, 8000, 27000]","solution":"def modify_list(lst): Takes a list of integers and returns a new list with the cube of each even number, while leaving the odd numbers unchanged. return [x**3 if x % 2 == 0 else x for x in lst]"},{"question":"def second_smallest(lst: List[int]) -> Optional[int]: Returns the second smallest integer in the list. If there are fewer than two unique integers, return None. >>> second_smallest([]) == None >>> second_smallest([1]) == None >>> second_smallest([2, 2]) == None >>> second_smallest([3, 1]) == 3 >>> second_smallest([4, 3, 2, 1, 5]) == 2 >>> second_smallest([7, 7, 7, 7]) == None >>> second_smallest([-3, -1, -2, -1, -5]) == -3 >>> second_smallest([10, -1, 10, 1, -10]) == -1","solution":"def second_smallest(lst): Returns the second smallest integer in the list. If there are fewer than two unique integers, return None. if len(lst) < 2: return None unique_elements = list(set(lst)) if len(unique_elements) < 2: return None unique_elements.sort() return unique_elements[1]"},{"question":"def top_student(students: List[Dict[str, Union[str, List[int], int]]]) -> Union[str, None]: Returns the name of the student with the highest average grade and attendance above 75%. >>> top_student([]) None >>> top_student([ {\\"name\\": \\"Alice\\", \\"grades\\": [90, 85, 88], \\"attendance\\": 70}, {\\"name\\": \\"Bob\\", \\"grades\\": [78, 82, 80], \\"attendance\\": 60} ]) None >>> top_student([ {\\"name\\": \\"Alice\\", \\"grades\\": [90, 85, 88], \\"attendance\\": 80} ]) 'Alice' >>> top_student([ {\\"name\\": \\"Alice\\", \\"grades\\": [90, 85, 88], \\"attendance\\": 80}, {\\"name\\": \\"Bob\\", \\"grades\\": [78, 82, 80], \\"attendance\\": 85} ]) 'Alice' >>> top_student([ {\\"name\\": \\"Alice\\", \\"grades\\": [90, 85, 88], \\"attendance\\": 80}, {\\"name\\": \\"Bob\\", \\"grades\\": [100, 92, 88], \\"attendance\\": 95} ]) 'Bob' >>> top_student([ {\\"name\\": \\"Alice\\", \\"grades\\": [90, 85, 88], \\"attendance\\": 80}, {\\"name\\": \\"Bob\\", \\"grades\\": [90, 85, 88], \\"attendance\\": 95} ]) 'Alice'","solution":"def top_student(students): Returns the name of the student with the highest average grade and attendance above 75%. top_name = None top_average = -1 for student in students: if student['attendance'] > 75: average_grade = sum(student['grades']) / len(student['grades']) if average_grade > top_average: top_average = average_grade top_name = student['name'] return top_name"},{"question":"from typing import List, Tuple def split_list(lst: List[int], N: int) -> Tuple[List[int], List[int]]: Splits the list 'lst' into two sublists: one containing all integers less than or equal to 'N', and the other containing all integers greater than 'N'. Returns a tuple containing the two sublists. >>> split_list([1, 4, 5, 8, 2, 12, 7, 3], 5) ([1, 4, 5, 2, 3], [8, 12, 7]) >>> split_list([10, 20, 5, 1, 4, 7, 3, 8], 10) ([10, 5, 1, 4, 7, 3, 8], [20]) >>> split_list([], 5) ([], []) def test_split_list_mixed_values(): assert split_list([1, 4, 5, 8, 2, 12, 7, 3], 5) == ([1, 4, 5, 2, 3], [8, 12, 7]) def test_split_list_with_exact_N(): assert split_list([10, 20, 5, 1, 4, 7, 3, 8], 10) == ([10, 5, 1, 4, 7, 3, 8], [20]) def test_split_list_empty(): assert split_list([], 5) == ([], []) def test_split_list_all_less_equal(): assert split_list([2, 3, 4, 5], 5) == ([2, 3, 4, 5], []) def test_split_list_all_greater(): assert split_list([6, 7, 8, 9], 5) == ([], [6, 7, 8, 9]) def test_split_list_with_duplicates(): assert split_list([5, 5, 5, 5], 5) == ([5, 5, 5, 5], [])","solution":"def split_list(lst, N): Splits the list 'lst' into two sublists: one containing all integers less than or equal to 'N', and the other containing all integers greater than 'N'. Returns a tuple containing the two sublists. less_equal_N = [x for x in lst if x <= N] greater_than_N = [x for x in lst if x > N] return (less_equal_N, greater_than_N)"},{"question":"def is_palindrome(word: str) -> (bool, int): Detects whether a given word is a palindrome, ignoring case and spaces. Returns a tuple where the first element is a boolean indicating if the word is a palindrome, and the second element is the total number of characters in the word (ignoring spaces). >>> is_palindrome(\\"Was it a car or a cat I saw\\") (True, 19) >>> is_palindrome(\\"madam\\") (True, 5) >>> is_palindrome(\\"racecar\\") (True, 7) >>> is_palindrome(\\"hello\\") (False, 5) >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") (True, 21) >>> is_palindrome(\\"Madam, in Eden, I'm Adam\\") (True, 17) >>> is_palindrome(\\"A\\") (True, 1) >>> is_palindrome(\\"\\") (True, 0) >>> is_palindrome(\\" \\") (True, 0) >>> is_palindrome(\\"123 321\\") (True, 6) >>> is_palindrome(\\"1234 4321\\") (True, 8) >>> is_palindrome(\\"12 34 43 21\\") (True, 8)","solution":"def is_palindrome(word): Detects whether a given word is a palindrome, ignoring case and spaces. Returns a tuple where the first element is a boolean indicating if the word is a palindrome, and the second element is the total number of characters in the word (ignoring spaces). cleaned_word = ''.join(char.lower() for char in word if char.isalnum()) is_palindrome = cleaned_word == cleaned_word[::-1] total_chars = len(cleaned_word) return is_palindrome, total_chars"},{"question":"import datetime import numpy as np class ResourceAllocator: def __init__(self, min_resources, max_resources): Initializes the ResourceAllocator with the given minimum and maximum resources. :param min_resources: Minimum resources to be allocated. :param max_resources: Maximum resources to be allocated. self.min_resources = min_resources self.max_resources = max_resources self.current_resources = min_resources self.historical_data = [] def record_metrics(self, timestamp, workload): Records the metrics - timestamp and workload. :param timestamp: The time at which the workload data is sampled. :param workload: The amount of workload at the given timestamp. pass def predict_workload(self, current_time): Predicts the workload based on historical data. :param current_time: The current time to predict the workload for. :return: Predicted workload pass def adjust_resources(self, current_time, current_workload): Adjusts the resources based on the predicted workload. :param current_time: The current time to use for predictions. :param current_workload: The current amount of workload. :return: The adjusted number of resources. pass from solution import ResourceAllocator def test_record_metrics(): allocator = ResourceAllocator(1, 10) allocator.record_metrics(datetime.datetime.now(), 50) assert len(allocator.historical_data) == 1 allocator.record_metrics(datetime.datetime.now(), 60) assert len(allocator.historical_data) == 2 def test_predict_workload(): allocator = ResourceAllocator(1, 10) allocator.record_metrics(datetime.datetime(2023, 10, 23, 12, 0), 50) allocator.record_metrics(datetime.datetime(2023, 10, 23, 13, 0), 70) predicted = allocator.predict_workload(datetime.datetime(2023, 10, 23, 14, 0)) assert predicted > 0 def test_adjust_resources(): allocator = ResourceAllocator(1, 10) allocator.record_metrics(datetime.datetime(2023, 10, 23, 12, 0), 50) allocator.record_metrics(datetime.datetime(2023, 10, 23, 13, 0), 70) resources = allocator.adjust_resources(datetime.datetime(2023, 10, 23, 14, 0), 60) assert allocator.min_resources <= resources <= allocator.max_resources def test_min_resource_cap(): allocator = ResourceAllocator(1, 10) allocator.record_metrics(datetime.datetime(2023, 10, 23, 12, 0), 8) resources = allocator.adjust_resources(datetime.datetime(2023, 10, 23, 13, 0), 8) assert resources == allocator.min_resources def test_max_resource_cap(): allocator = ResourceAllocator(1, 10) allocator.record_metrics(datetime.datetime(2023, 10, 23, 12, 0), 1000) resources = allocator.adjust_resources(datetime.datetime(2023, 10, 23, 13, 0), 1000) assert resources == allocator.max_resources","solution":"import datetime import numpy as np class ResourceAllocator: def __init__(self, min_resources, max_resources): self.min_resources = min_resources self.max_resources = max_resources self.current_resources = min_resources self.historical_data = [] def record_metrics(self, timestamp, workload): Records the metrics - timestamp and workload. self.historical_data.append((timestamp, workload)) def predict_workload(self, current_time): Predicts the workload based on historical data using a simple linear regression model. times = np.array([d[0].timestamp() for d in self.historical_data]).reshape(-1, 1) workloads = np.array([d[1] for d in self.historical_data]) # Using simple linear regression to predict the next workload if len(times) > 1: # Ensure there is enough data to make predictions from sklearn.linear_model import LinearRegression model = LinearRegression() model.fit(times, workloads) future_time = np.array([[current_time.timestamp()]]) predicted_workload = model.predict(future_time) return max(0, predicted_workload[0]) else: # Not enough data to predict, return current workload return workloads[-1] if workloads else 0 def adjust_resources(self, current_time, current_workload): Adjust the resources based on the predicted workload. predicted_workload = self.predict_workload(current_time) proposed_resources = int(predicted_workload // 10) # Assuming 1 resource unit per 10 units of workload # Ensuring resources are within the designated range proposed_resources = min(max(self.min_resources, proposed_resources), self.max_resources) self.current_resources = proposed_resources return self.current_resources"},{"question":"from typing import List from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: Groups a list of words into sets of anagrams. Args: words (list of str): List of words. Returns: list of list of str: List of lists where each sublist contains anagrams. >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\"]) [['bat', 'tab'], ['cat']] >>> group_anagrams([\\"act\\", \\"cat\\", \\"tac\\"]) [['act', 'cat', 'tac']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([]) [] >>> group_anagrams([\\"bat\\", \\"tab\\", \\"ate\\", \\"tea\\", \\"eat\\", \\"now\\", \\"won\\"]) [['bat', 'tab'], ['ate', 'tea', 'eat'], ['now', 'won']] >>> group_anagrams([\\"word\\"]) [['word']]","solution":"from collections import defaultdict def group_anagrams(words): Groups a list of words into sets of anagrams. Args: words (list of str): List of words. Returns: list of list of str: List of lists where each sublist contains anagrams. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def compressString(s: str) -> str: Compress a string by replacing consecutive repeated characters with the character followed by the count of its repetitions. If a character does not repeat consecutively, it should be left as is. >>> compressString(\\"aabcccdeff\\") == \\"a2bc3def2\\" >>> compressString(\\"aabbcc\\") == \\"a2b2c2\\" >>> compressString(\\"abc\\") == \\"abc\\" >>> compressString(\\"aaabbbccc\\") == \\"a3b3c3\\" >>> compressString(\\"\\") == \\"\\" >>> compressString(\\"a\\") == \\"a\\" >>> compressString(\\"b\\") == \\"b\\" >>> compressString(\\"abcdef\\") == \\"abcdef\\" >>> compressString(\\"aaaa\\") == \\"a4\\" >>> compressString(\\"bbbbbb\\") == \\"b6\\" >>> compressString(\\"aabbbcccddeeefffgggg\\") == \\"a2b3c3d2e3f3g4\\" pass","solution":"def compressString(s: str) -> str: if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for i in range(1, len(s)): if s[i] == current_char: count += 1 else: if count > 1: compressed.append(f\\"{current_char}{count}\\") else: compressed.append(current_char) current_char = s[i] count = 1 # Handling the last set of characters if count > 1: compressed.append(f\\"{current_char}{count}\\") else: compressed.append(current_char) return ''.join(compressed)"},{"question":"import random class CardDeck: A class to represent a standard deck of 52 cards and perform operations on it such as: 1. Shuffle the deck. 2. Deal a specific number of cards to a player. 3. Reset the deck to its original state. 4. Check the number of cards remaining in the deck. 5. Convert a card representation into a human-readable string format (e.g., \\"2 of Hearts\\"). >>> deck = CardDeck() >>> deck.shuffle_deck() >>> len(deck.deal_cards(5)) == 5 True >>> deck.remaining_cards() 47 >>> deck.reset_deck() >>> deck.remaining_cards() 52 >>> CardDeck.card_to_string(('Ace', 'Spades')) 'Ace of Spades' suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades'] ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'] def __init__(self): self.original_deck = [(rank, suit) for suit in CardDeck.suits for rank in CardDeck.ranks] self.deck = self.original_deck[:] random.shuffle(self.deck) def shuffle_deck(self): pass def deal_cards(self, num_cards): pass def reset_deck(self): pass def remaining_cards(self): pass @staticmethod def card_to_string(card): pass","solution":"import random class CardDeck: suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades'] ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'] def __init__(self): self.original_deck = [(rank, suit) for suit in CardDeck.suits for rank in CardDeck.ranks] self.deck = self.original_deck[:] random.shuffle(self.deck) def shuffle_deck(self): random.shuffle(self.deck) def deal_cards(self, num_cards): if num_cards > len(self.deck): raise ValueError(\\"Not enough cards in the deck to deal\\") dealt_cards = self.deck[:num_cards] self.deck = self.deck[num_cards:] return dealt_cards def reset_deck(self): self.deck = self.original_deck[:] random.shuffle(self.deck) def remaining_cards(self): return len(self.deck) @staticmethod def card_to_string(card): rank, suit = card return f\\"{rank} of {suit}\\""},{"question":"import heapq from collections import defaultdict from typing import Dict, Tuple class HuffmanNode: def __init__(self, char: str, freq: int): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def compute_frequencies(text: str) -> Dict[str, int]: Compute the frequency of each character in the input text. >>> compute_frequencies(\\"abbcccddddeeeee\\") {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} pass def build_huffman_tree(frequencies: Dict[str, int]) -> HuffmanNode: Build a Huffman tree from the character frequencies. >>> frequencies = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} >>> root = build_huffman_tree(frequencies) >>> root.freq 15 pass def generate_codes(root: HuffmanNode, prefix: str = \\"\\", codebook: Dict[str, str] = None) -> Dict[str, str]: Generate Huffman codes for each character based on the Huffman tree. >>> frequencies = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} >>> root = build_huffman_tree(frequencies) >>> codebook = generate_codes(root) >>> set(codebook.keys()) {'a', 'b', 'c', 'd', 'e'} >>> all(isinstance(code, str) for code in codebook.values()) True pass def encode(text: str, codebook: Dict[str, str]) -> str: Encode the input text using the generated Huffman codes. >>> text = \\"abbcccddddeeeee\\" >>> frequencies = compute_frequencies(text) >>> root = build_huffman_tree(frequencies) >>> codebook = generate_codes(root) >>> encoded_text = encode(text, codebook) >>> isinstance(encoded_text, str) True pass def decode(encoded_text: str, root: HuffmanNode) -> str: Decode the encoded text using the Huffman tree to get back the original text. >>> text = \\"abbcccddddeeeee\\" >>> frequencies = compute_frequencies(text) >>> root = build_huffman_tree(frequencies) >>> codebook = generate_codes(root) >>> encoded_text = encode(text, codebook) >>> decoded_text = decode(encoded_text, root) >>> decoded_text == text True pass def compression_efficiency(original_text: str, encoded_text: str) -> Tuple[int, int, float]: Evaluate the compression efficiency by comparing the sizes of the original and compressed text. >>> text = \\"abbcccddddeeeee\\" >>> frequencies = compute_frequencies(text) >>> root = build_huffman_tree(frequencies) >>> codebook = generate_codes(root) >>> encoded_text = encode(text, codebook) >>> original_size, compressed_size, efficiency = compression_efficiency(text, encoded_text) >>> original_size > compressed_size True >>> 0 <= efficiency <= 100 True pass","solution":"import heapq from collections import defaultdict from typing import Dict, Tuple, Any class HuffmanNode: def __init__(self, char: str, freq: int): self.char = char self.freq = freq self.left = None self.right = None # Define comparison methods for priority queue def __lt__(self, other): return self.freq < other.freq def compute_frequencies(text: str) -> Dict[str, int]: frequencies = defaultdict(int) for char in text: frequencies[char] += 1 return frequencies def build_huffman_tree(frequencies: Dict[str, int]) -> HuffmanNode: priority_queue = [HuffmanNode(char, freq) for char, freq in frequencies.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: left = heapq.heappop(priority_queue) right = heapq.heappop(priority_queue) merged = HuffmanNode(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(priority_queue, merged) return priority_queue[0] def generate_codes(root: HuffmanNode, prefix: str = \\"\\", codebook: Dict[str, str] = None) -> Dict[str, str]: if codebook is None: codebook = {} if root is not None: if root.char is not None: codebook[root.char] = prefix generate_codes(root.left, prefix + \\"0\\", codebook) generate_codes(root.right, prefix + \\"1\\", codebook) return codebook def encode(text: str, codebook: Dict[str, str]) -> str: return ''.join(codebook[char] for char in text) def decode(encoded_text: str, root: HuffmanNode) -> str: current = root decoded_chars = [] for bit in encoded_text: if bit == '0': current = current.left else: current = current.right if current.char is not None: decoded_chars.append(current.char) current = root return ''.join(decoded_chars) def compression_efficiency(original_text: str, encoded_text: str) -> Tuple[int, int, float]: original_size = len(original_text) * 8 # size in bits compressed_size = len(encoded_text) # size in bits efficiency = (original_size - compressed_size) / original_size * 100 # compression efficiency in percentage return original_size, compressed_size, efficiency"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"abba\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"aabbcccc\\") True >>> can_form_palindrome(\\"a man a plan a canal panama\\") True","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. A string can form a palindrome if at most one character has an odd count. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter char_counts = Counter(s) odd_count = 0 for count in char_counts.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"def all_substrings(string: str): Generates all possible substrings of the given string. Parameters: string (str): The input string. Yields: str: Each possible substring of the input string. # Your implementation here pass # Example Usage # Input: \\"abc\\" # Output: ['a', 'ab', 'abc', 'b', 'bc', 'c'] import pytest def test_all_substrings_basic(): result = list(all_substrings(\\"abc\\")) expected = [\\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"] assert result == expected def test_all_substrings_empty_string(): result = list(all_substrings(\\"\\")) expected = [] assert result == expected def test_all_substrings_single_character(): result = list(all_substrings(\\"a\\")) expected = [\\"a\\"] assert result == expected def test_all_substrings_repeated_characters(): result = list(all_substrings(\\"aaa\\")) expected = [\\"a\\", \\"aa\\", \\"aaa\\", \\"a\\", \\"aa\\", \\"a\\"] assert result == expected def test_all_substrings_mixed_characters(): result = list(all_substrings(\\"abC\\")) expected = [\\"a\\", \\"ab\\", \\"abC\\", \\"b\\", \\"bC\\", \\"C\\"] assert result == expected","solution":"def all_substrings(string): Generates all possible substrings of the given string. Parameters: string (str): The input string. Yields: str: Each possible substring of the input string. length = len(string) for start in range(length): for end in range(start + 1, length + 1): yield string[start:end]"},{"question":"import pytest def sort_words_by_length(words: str) -> list: Sorts a list of words first by their length and then alphabetically for words of the same length. Args: words (str): A string of words separated by spaces. Returns: list: A sorted list of words. >>> sort_words_by_length(\\"banana apple cherry fig\\") ['fig', 'apple', 'banana', 'cherry'] >>> sort_words_by_length(\\"cat bat mat rat\\") ['bat', 'cat', 'mat', 'rat'] >>> sort_words_by_length(\\"\\") [] >>> sort_words_by_length(\\"word\\") ['word'] >>> sort_words_by_length(\\"a ab abc abcde\\") ['a', 'ab', 'abc', 'abcde'] >>> sort_words_by_length(\\"Apple cat Bat\\") ['Bat', 'cat', 'Apple']","solution":"def sort_words_by_length(words): Sorts a list of words first by their length and then alphabetically for words of the same length. Args: words (str): A string of words separated by spaces. Returns: list: A sorted list of words. # Validate the input if not all(word.isalpha() for word in words.split()): raise ValueError(\\"Input should only contain alphabetic characters and spaces.\\") # Split the input string into a list of words words_list = words.split() # Sort the list of words by length, then alphabetically sorted_words = sorted(words_list, key=lambda w: (len(w), w.lower())) return sorted_words"},{"question":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Given a 2D matrix, return elements in spiral order. >>> spiralOrder([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiralOrder([ [1] ]) [1] >>> spiralOrder([ [] ]) [] >>> spiralOrder([ [1, 2], [3, 4], [5, 6] ]) [1, 2, 4, 6, 5, 3]","solution":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Given a 2D matrix, return elements in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse downwards for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse upwards for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"from typing import List def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool: Determine if it is possible to finish all courses given the prerequisites. :param numCourses: int, number of courses :param prerequisites: List[List[int]], list of prerequisite pairs :return: bool, True if it is possible to finish all courses, else False >>> canFinish(2, [[1, 0]]) == True >>> canFinish(2, [[1, 0], [0, 1]]) == False >>> canFinish(3, []) == True >>> canFinish(4, [[1, 0], [2, 1], [3, 2]]) == True >>> canFinish(4, [[1, 0], [2, 1], [3, 2], [1, 3]]) == False >>> canFinish(4, [[1, 0], [3, 2]]) == True >>> canFinish(1000, []) == True >>> prerequisites = [[i, i-1] for i in range(1, 1000)] >>> canFinish(1000, prerequisites) == True >>> prerequisites.append([0, 999]) >>> canFinish(1000, prerequisites) == False","solution":"from collections import defaultdict, deque def canFinish(numCourses, prerequisites): Determine if it is possible to finish all courses given the prerequisites. :param numCourses: int, number of courses :param prerequisites: List[List[int]], list of prerequisite pairs :return: bool, True if it is possible to finish all courses, else False # Create a graph of course prerequisites adj_list = defaultdict(list) in_degree = [0] * numCourses # Build the graph and in-degree array for dest, src in prerequisites: adj_list[src].append(dest) in_degree[dest] += 1 # Queue for courses with no prerequisites queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) visited_courses = 0 while queue: course = queue.popleft() visited_courses += 1 # Reduce the in-degree of subsequent courses for neighbor in adj_list[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we've visited all courses, return True return visited_courses == numCourses"},{"question":"def increment_list_elements(input_list): Takes a list of integers and returns a new list with each element incremented by 1. Args: input_list (list): A list of integers. Returns: list: A new list with each element incremented by 1. Example: >>> increment_list_elements([1, 2, 3]) [2, 3, 4] >>> increment_list_elements([0, -1, -2]) [1, 0, -1] >>> increment_list_elements([]) []","solution":"def increment_list_elements(input_list): Takes a list of integers and returns a new list with each element incremented by 1. Args: input_list (list): A list of integers. Returns: list: A new list with each element incremented by 1. return [x + 1 for x in input_list]"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Checks if there are two distinct elements in the list that sum up to the target value. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) == True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == False >>> has_pair_with_sum([0, -1, 2, -3, 1], -1) == True >>> has_pair_with_sum([5], 5) == False >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) == True >>> has_pair_with_sum([1, 4, 45, 6, 10, -8], 16) == True >>> has_pair_with_sum([1, 2, 3, 9], 8) == False >>> has_pair_with_sum([1, 2, 3, 12], 15) == True pass","solution":"def has_pair_with_sum(nums, target): Checks if there are two distinct elements in the list that sum up to the target value. seen_elements = set() for num in nums: complement = target - num if complement in seen_elements: return True seen_elements.add(num) return False"},{"question":"def largest_rectangle_area(heights): Returns the largest rectangular area in the histogram given by 'heights'. 'heights' is a list of positive integers representing the heights of bars. >>> largest_rectangle_area([2]) 2 >>> largest_rectangle_area([2, 1]) 2 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([]) 0","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area in the histogram given by 'heights'. 'heights' is a list of positive integers representing the heights of bars. stack = [] max_area = 0 index = 0 # Iterate through the histogram while index < len(heights): # If stack is empty or current bar height is greater than or equal to the bar # at the index stored at the top of the stack, push current index to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top of the stack and calculate area with the popped height top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now pop the remaining bars from the stack and calculate the area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def simulate_banking_system(operations: list) -> list: Simulates a banking system with a series of operations. Parameters: operations (list): List of operations to be performed. Each operation is a dictionary with the following structure: - {'operation': 'create_account', 'account_id': int, 'initial_balance': float} - {'operation': 'deposit', 'account_id': int, 'amount': float} - {'operation': 'withdraw', 'account_id': int, 'amount': float} - {'operation': 'transfer', 'from_account_id': int, 'to_account_id': int, 'amount': float} - {'operation': 'get_balance', 'account_id': int} Returns: list: List of results for 'get_balance' operations with the balance of the respective account. # Example Usage: # operations = [ # {'operation': 'create_account', 'account_id': 1, 'initial_balance': 100.0}, # {'operation': 'create_account', 'account_id': 2, 'initial_balance': 150.0}, # {'operation': 'deposit', 'account_id': 1, 'amount': 50.0}, # {'operation': 'withdraw', 'account_id': 1, 'amount': 20.0}, # {'operation': 'transfer', 'from_account_id': 1, 'to_account_id': 2, 'amount': 30.0}, # {'operation': 'get_balance', 'account_id': 1}, # {'operation': 'get_balance', 'account_id': 2} # ] # Expected Output: [100.0, 180.0] from solution import simulate_banking_system def test_create_account_and_get_balance(): operations = [ {'operation': 'create_account', 'account_id': 1, 'initial_balance': 100.0}, {'operation': 'get_balance', 'account_id': 1} ] assert simulate_banking_system(operations) == [100.0] def test_deposit_and_get_balance(): operations = [ {'operation': 'create_account', 'account_id': 1, 'initial_balance': 100.0}, {'operation': 'deposit', 'account_id': 1, 'amount': 50.0}, {'operation': 'get_balance', 'account_id': 1} ] assert simulate_banking_system(operations) == [150.0] def test_withdraw_and_get_balance(): operations = [ {'operation': 'create_account', 'account_id': 1, 'initial_balance': 100.0}, {'operation': 'withdraw', 'account_id': 1, 'amount': 30.0}, {'operation': 'get_balance', 'account_id': 1} ] assert simulate_banking_system(operations) == [70.0] def test_withdraw_insufficient_funds(): operations = [ {'operation': 'create_account', 'account_id': 1, 'initial_balance': 100.0}, {'operation': 'withdraw', 'account_id': 1, 'amount': 150.0}, {'operation': 'get_balance', 'account_id': 1} ] assert simulate_banking_system(operations) == [100.0] def test_transfer_and_get_balance(): operations = [ {'operation': 'create_account', 'account_id': 1, 'initial_balance': 100.0}, {'operation': 'create_account', 'account_id': 2, 'initial_balance': 200.0}, {'operation': 'transfer', 'from_account_id': 1, 'to_account_id': 2, 'amount': 50.0}, {'operation': 'get_balance', 'account_id': 1}, {'operation': 'get_balance', 'account_id': 2} ] assert simulate_banking_system(operations) == [50.0, 250.0] def test_transfer_insufficient_funds(): operations = [ {'operation': 'create_account', 'account_id': 1, 'initial_balance': 100.0}, {'operation': 'create_account', 'account_id': 2, 'initial_balance': 200.0}, {'operation': 'transfer', 'from_account_id': 1, 'to_account_id': 2, 'amount': 150.0}, {'operation': 'get_balance', 'account_id': 1}, {'operation': 'get_balance', 'account_id': 2} ] assert simulate_banking_system(operations) == [100.0, 200.0]","solution":"def simulate_banking_system(operations: list) -> list: accounts = {} results = [] for op in operations: if op['operation'] == 'create_account': accounts[op['account_id']] = op['initial_balance'] elif op['operation'] == 'deposit': if op['account_id'] in accounts: accounts[op['account_id']] += op['amount'] elif op['operation'] == 'withdraw': if op['account_id'] in accounts: if accounts[op['account_id']] >= op['amount']: accounts[op['account_id']] -= op['amount'] else: print(\\"Insufficient funds\\") elif op['operation'] == 'transfer': if (op['from_account_id'] in accounts and op['to_account_id'] in accounts): if accounts[op['from_account_id']] >= op['amount']: accounts[op['from_account_id']] -= op['amount'] accounts[op['to_account_id']] += op['amount'] else: print(\\"Insufficient funds\\") elif op['operation'] == 'get_balance': if op['account_id'] in accounts: results.append(accounts[op['account_id']]) return results"},{"question":"from typing import List, Optional def find_pair_with_sum(arr: List[int], target: int) -> Optional[List[int]]: Checks if there are two distinct elements in the array that add up to the target sum. Returns the pair as an array of the two integers if such a pair exists. Returns null if no such pair exists. >>> find_pair_with_sum([1, 2, 3, 4, 5], 9) [4, 5] >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([1, -2, 3, -4, 5], 1) [-2, 3] >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) [-3, -5] def test_find_pair_with_sum(): assert find_pair_with_sum([1, 2, 3, 4, 5], 9) == [4, 5] assert find_pair_with_sum([1, 2, 3, 4, 5], 3) == [1, 2] assert find_pair_with_sum([1, 2, 3, 4, 5], 10) == None assert find_pair_with_sum([1, 2, 3, 4, 5], 1) == None assert find_pair_with_sum([1, -2, 3, -4, 5], 1) == [-2, 3] assert find_pair_with_sum([-1, -2, -3, -4, -5], -8) == [-3, -5] large_array = list(range(1, 10001)) # 1 to 10000 assert find_pair_with_sum(large_array, 19999) == [9999, 10000] assert find_pair_with_sum(large_array, 20000) == None","solution":"from typing import List, Optional def find_pair_with_sum(arr: List[int], target: int) -> Optional[List[int]]: Checks if there are two distinct elements in the array that add up to the target sum. Returns the pair as an array of the two integers if such a pair exists. Returns null if no such pair exists. seen = set() for num in arr: complement = target - num if complement in seen: return [complement, num] seen.add(num) return None"},{"question":"def longest_common_prefix(strs: List[str]) -> str: Find and return the longest common prefix among a list of strings. Args: strs (list of str): List of strings to find the common prefix. Returns: str: The longest common prefix or an empty string if there is none. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longest_common_prefix([\\"alone\\"]) 'alone'","solution":"def longest_common_prefix(strs): Finds and returns the longest common prefix among a list of strings. Args: strs (list of str): List of strings to find the common prefix. Returns: str: The longest common prefix or an empty string if there is none. if not strs: return \\"\\" # Sort the array, so the potential common prefixes are aligned strs.sort() # The first and the last string will have the shortest common prefix first = strs[0] last = strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"def shortest_path_in_maze(maze, start, destination): Calculates the shortest path in a maze represented by a 2D grid. :param maze: List[List[int]], 2D list representing the maze (0: walkable, 1: blocked) :param start: Tuple[int, int], starting coordinates (row, col) :param destination: Tuple[int, int], destination coordinates (row, col) :return: int, minimum number of steps or -1 if unreachable >>> maze = [ ... [0, 0, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> start = (0, 0) >>> destination = (3, 3) >>> shortest_path_in_maze(maze, start, destination) 6 >>> maze = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> destination = (2, 2) >>> shortest_path_in_maze(maze, start, destination) -1 >>> maze = [ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> destination = (2, 2) >>> shortest_path_in_maze(maze, start, destination) -1 >>> maze = [ ... [0, 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> destination = (0, 0) >>> shortest_path_in_maze(maze, start, destination) 0 >>> maze = [] >>> start = (0, 0) >>> destination = (0, 0) >>> shortest_path_in_maze(maze, start, destination) -1 >>> maze = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> destination = (2, 2) >>> shortest_path_in_maze(maze, start, destination) -1 >>> maze = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> start = (0, 0) >>> destination = (2, 2) >>> shortest_path_in_maze(maze, start, destination) -1","solution":"from collections import deque def shortest_path_in_maze(maze, start, destination): Returns the minimum number of steps required to reach the destination in the maze, or -1 if the destination is unreachable. :param maze: List[List[int]], 2D list representing the maze (0: walkable, 1: blocked) :param start: Tuple[int, int], starting coordinates (row, col) :param destination: Tuple[int, int], destination coordinates (row, col) :return: int, minimum number of steps or -1 if unreachable if not maze or not maze[0]: # If the maze is empty return -1 rows, cols = len(maze), len(maze[0]) sr, sc = start dr, dc = destination # Check if start or destination is out of bounds or blocked if maze[sr][sc] == 1 or maze[dr][dc] == 1: return -1 # Possible movements: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sr, sc, 0)]) # stores (current_row, current_col, current_distance) visited = set((sr, sc)) # add starting point to visited while queue: r, c, dist = queue.popleft() # If reached the destination if (r, c) == destination: return dist # Explore neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 # Return -1 if the destination is unreachable"},{"question":"def prime_factors(n: int) -> List[Tuple[int, int]]: Returns the prime factorization of n as a list of tuples containing each prime factor and its exponent. # Implement function here def prime_factorization_list(lst: List[int]) -> List[List[Tuple[int, int]]]: Returns a list of prime factorization for each integer in the input list. Each element in the result contains tuples representing prime factors and their exponents. # Implement function here def verify_prime_factorizations(lst: List[int], factorizations: List[List[Tuple[int, int]]]) -> str: Verifies the factorizations by reconstructing the numbers and comparing them to the original list. Returns a message if any discrepancy is found, otherwise returns \\"All factorizations are correct\\". # Implement function here # Test cases from typing import List, Tuple def test_prime_factors(): assert prime_factors(28) == [(2, 2), (7, 1)] assert prime_factors(30) == [(2, 1), (3, 1), (5, 1)] assert prime_factors(1) == [] assert prime_factors(100) == [(2, 2), (5, 2)] assert prime_factors(17) == [(17, 1)] def test_prime_factorization_list(): assert prime_factorization_list([28, 30, 1, 100, 17]) == [ [(2, 2), (7, 1)], [(2, 1), (3, 1), (5, 1)], [], [(2, 2), (5, 2)], [(17, 1)] ] def test_verify_prime_factorizations_correct(): original_list = [28, 30, 1, 100, 17] factorizations = prime_factorization_list(original_list) assert verify_prime_factorizations(original_list, factorizations) == \\"All factorizations are correct\\" def test_verify_prime_factorizations_incorrect(): original_list = [28, 30, 1, 100, 17] incorrect_factorizations = [ [(2, 2), (7, 1)], [(2, 1), (3, 1)], # Missing (5, 1) [], [(2, 2), (5, 1)], # Missing one exponent 5 [(17, 1)] ] assert \\"Discrepancy found\\" in verify_prime_factorizations(original_list, incorrect_factorizations)","solution":"def prime_factors(n): Returns the prime factorization of n as a list of tuples containing each prime factor and its exponent. i = 2 factors = [] while i * i <= n: count = 0 while (n % i) == 0: n //= i count += 1 if count > 0: factors.append((i, count)) i += 1 if n > 1: factors.append((n, 1)) return factors def prime_factorization_list(lst): Returns a list of prime factorization for each integer in the input list. Each element in the result contains tuples representing prime factors and their exponents. return [prime_factors(x) for x in lst] def verify_prime_factorizations(lst, factorizations): Verifies the factorizations by reconstructing the numbers and comparing them to the original list. Returns a message if any discrepancy is found, otherwise returns \\"All factorizations are correct\\". for original, factors in zip(lst, factorizations): reconstructed = 1 for base, exponent in factors: reconstructed *= (base ** exponent) if reconstructed != original: return f\\"Discrepancy found: original {original}, reconstructed {reconstructed}\\" return \\"All factorizations are correct\\""},{"question":"def find_indices(lst, n): Returns a list of indices where the integer 'n' occurs in the input list 'lst'. If 'n' is not present in 'lst', returns an empty list. Example usage: >>> find_indices([1, 2, 3, 2, 4, 2], 2) [1, 3, 5] >>> find_indices([5, 5, 5], 5) [0, 1, 2] >>> find_indices([1, 2, 3], 4) []","solution":"def find_indices(lst, n): Returns a list of indices where the integer 'n' occurs in the input list 'lst'. If 'n' is not present in 'lst', returns an empty list. if not isinstance(lst, list): raise ValueError(\\"The first argument must be a list.\\") if not isinstance(n, int): raise ValueError(\\"The second argument must be an integer.\\") return [i for i, x in enumerate(lst) if x == n]"},{"question":"def can_form_arithmetic_progression(nums: List[int]) -> bool: Determine whether a list of integers can be rearranged to form an arithmetic progression. Use only manual sorting. >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 4, 2, 6]) False pass","solution":"def can_form_arithmetic_progression(nums): Determine whether a list of integers can be rearranged to form an arithmetic progression. if len(nums) < 2: return True # Manual selection sort for i in range(len(nums)): min_index = i for j in range(i + 1, len(nums)): if nums[j] < nums[min_index]: min_index = j if min_index != i: nums[i], nums[min_index] = nums[min_index], nums[i] common_difference = nums[1] - nums[0] for k in range(2, len(nums)): if nums[k] - nums[k - 1] != common_difference: return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotates a singly linked list to the right by k places. >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> rotated_head = rotateRight(head, 2) >>> linked_list_to_list(rotated_head) [4, 5, 1, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # First, let's determine the length of the list length, current = 1, head while current.next: current = current.next length += 1 # Make the list circular current.next = head # Find the new head and tail k %= length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"def count_unique_vowels(s: str) -> int: Returns the number of unique vowels that appear in the string. Ensures the input provided is a string, otherwise returns an appropriate error message. The function is case-insensitive and considers 'a', 'e', 'i', 'o', 'u' as vowels. >>> count_unique_vowels(\\"AEIOUY\\") 5 >>> count_unique_vowels(\\"Apple\\") 2 >>> count_unique_vowels(\\"bcdfg\\") 0 >>> count_unique_vowels(\\"AaAaEeEeIiIiOoOoUuUu\\") 5 >>> count_unique_vowels(\\"\\") 0 >>> count_unique_vowels(123) 'Input must be a string' >>> count_unique_vowels([]) 'Input must be a string' >>> count_unique_vowels(None) 'Input must be a string'","solution":"def count_unique_vowels(s): Returns the number of unique vowels in the given string. Handles cases where input is not a string. if not isinstance(s, str): return \\"Input must be a string\\" vowels = set('aeiou') s = s.lower() unique_vowels = {char for char in s if char in vowels} return len(unique_vowels)"},{"question":"def reverse_words_preserve_order(s: str) -> str: Reverses each word in the input string while preserving the original order of the words. Leading and trailing whitespace is removed and multiple spaces between words are reduced to a single space. >>> reverse_words_preserve_order(\\"hello\\") 'olleh' >>> reverse_words_preserve_order(\\"hello world\\") 'olleh dlrow' >>> reverse_words_preserve_order(\\" hello world \\") 'olleh dlrow' >>> reverse_words_preserve_order(\\"hello, world!\\") ',olleh !dlrow' >>> reverse_words_preserve_order(\\"\\") '' >>> reverse_words_preserve_order(\\" \\") '' >>> reverse_words_preserve_order(\\" \\") ''","solution":"def reverse_words_preserve_order(s): Reverses each word in the input string while preserving the original order of the words. Leading and trailing whitespace is removed and multiple spaces between words are reduced to a single space. return ' '.join(word[::-1] for word in s.split())"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing integers, '+', '-', and nested parentheses. >>> evaluate_expression(\\"3+2-1\\") 4 >>> evaluate_expression(\\" 3 + 5 - 2 \\") 6 >>> evaluate_expression(\\"3 + (2 - 1)\\") 4 >>> evaluate_expression(\\"3 + (2 - (1 + 4))\\") 0 >>> evaluate_expression(\\"5 - (3 + (10 - (2 + 1)))\\") -5 >>> evaluate_expression(\\"7\\") 7 >>> evaluate_expression(\\"3 + ()\\") 3","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers, '+', '-', and nested parentheses. def helper(s, index): stack = [] num = 0 sign = 1 while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) elif char in \\"+-\\": stack.append(sign * num) num = 0 sign = 1 if char == '+' else -1 elif char == '(': num, index = helper(s, index + 1) elif char == ')': stack.append(sign * num) return sum(stack), index index += 1 stack.append(sign * num) return sum(stack), index expression = expression.replace(\\" \\", \\"\\") result, _ = helper(expression, 0) return result"},{"question":"import string def is_palindrome(inputString: str) -> bool: Write a function to determine if a given string is a palindrome, ignoring case and punctuation. The function should return a boolean value (True or False). Returns True if the inputString is a palindrome, ignoring case and punctuation, False otherwise. Examples: >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False pass from solution import is_palindrome def test_palindrome_simple(): assert is_palindrome(\\"madam\\") == True def test_palindrome_with_punctuation(): assert is_palindrome(\\"A man, a plan, a canal, Panama\\") == True def test_palindrome_mixed_case(): assert is_palindrome(\\"No 'x' in Nixon\\") == True def test_non_palindrome(): assert is_palindrome(\\"This is not a palindrome\\") == False def test_empty_string(): assert is_palindrome(\\"\\") == True def test_palindrome_with_numbers(): assert is_palindrome(\\"12321\\") == True assert is_palindrome(\\"12345\\") == False","solution":"import string def isPalindrome(inputString): Returns True if the inputString is a palindrome, ignoring case and punctuation, False otherwise. # Remove punctuation and convert to lowercase cleaned_string = ''.join(char.lower() for char in inputString if char.isalnum()) # Check if the cleaned string is equal to its reverse return cleaned_string == cleaned_string[::-1]"},{"question":"import re from collections import Counter def clean_text(text): Takes a string and returns a cleaned version of the string, where all characters are converted to lowercase, and all punctuation and special characters are removed. >>> clean_text(\\"Hello, World!\\") 'hello world' >>> clean_text(\\"Python3.8 is great!\\") 'python38 is great' >>> clean_text(\\"No special@characters!\\") 'no specialcharacters' pass def get_word_frequencies(text): Takes the cleaned text and returns a dictionary with words as keys and their frequency counts as values. >>> get_word_frequencies(\\"hello world hello\\") {'hello': 2, 'world': 1} >>> get_word_frequencies(\\"python is fun python python\\") {'python': 3, 'is': 1, 'fun': 1} pass def top_k_frequent_words(text, k): Uses the previous two functions to determine the k most frequent words in the text. Returns a list of tuples with the word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they are sorted alphabetically. >>> top_k_frequent_words(\\"Hello world! Hello everyone. Programming in Python is fun. Python programming is powerful.\\", 3) [('hello', 2), ('is', 2), ('programming', 2)] >>> top_k_frequent_words(\\"apple orange banana apple fruit orange apple\\", 2) [('apple', 3), ('orange', 2)] >>> top_k_frequent_words(\\"tie tie tie alpha beta beta gamma delta delta delta\\", 3) [('delta', 3), ('tie', 3), ('beta', 2)] pass","solution":"import re from collections import Counter def clean_text(text): Takes a string and returns a cleaned version of the string, where all characters are converted to lowercase, and all punctuation and special characters are removed. # Convert to lowercase text = text.lower() # Remove punctuation and special characters text = re.sub(r'[^a-zA-Z0-9s]', '', text) return text def get_word_frequencies(text): Takes the cleaned text and returns a dictionary with words as keys and their frequency counts as values. words = text.split() word_counts = Counter(words) return word_counts def top_k_frequent_words(text, k): Uses the previous two functions to determine the k most frequent words in the text. Returns a list of tuples with the word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they are sorted alphabetically. cleaned_text = clean_text(text) word_frequencies = get_word_frequencies(cleaned_text) sorted_frequencies = sorted(word_frequencies.items(), key=lambda item: (-item[1], item[0])) return sorted_frequencies[:k]"},{"question":"def filter_and_map(strings: List[str]) -> Dict[str, int]: Returns a dictionary with strings as keys and their lengths as values, omitting any strings that contain the substring \\"xyz\\". >>> words = [\\"apple\\", \\"xyzbanana\\", \\"cherry\\", \\"xyz\\", \\"blueberry\\"] >>> filter_and_map(words) {'apple': 5, 'cherry': 6, 'blueberry': 9} >>> words = [\\"apple\\", \\"cherry\\", \\"blueberry\\"] >>> filter_and_map(words) {'apple': 5, 'cherry': 6, 'blueberry': 9} >>> words = [\\"xyzapple\\", \\"xyzbanana\\", \\"xyz\\"] >>> filter_and_map(words) {} >>> words = [] >>> filter_and_map(words) {} >>> words = [\\"xyzapple\\", \\"banana\\", \\"cherryxyz\\", \\"blue\\"] >>> filter_and_map(words) {'banana': 6, 'blue': 4}","solution":"def filter_and_map(strings): Returns a dictionary with strings as keys and their lengths as values, omitting any strings that contain the substring \\"xyz\\". return {s: len(s) for s in strings if 'xyz' not in s}"},{"question":"def product_of_all_except_self(numbers: List[int]) -> List[int]: Takes a list of integers as input and returns a new list where each integer in the original list is replaced by the product of all other integers. The function does not use division to solve the problem and handles cases with zeros. >>> product_of_all_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_all_except_self([0, 2, 3]) [6, 0, 0] >>> product_of_all_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_of_all_except_self([42]) [1] >>> product_of_all_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6]","solution":"def product_of_all_except_self(numbers): Returns a new list where each integer in the original list is replaced by the product of all other integers in the list. length = len(numbers) result = [1] * length # Compute prefix products prefix_product = 1 for i in range(length): result[i] = prefix_product prefix_product *= numbers[i] # Compute suffix products and multiply with prefix products suffix_product = 1 for i in range(length - 1, -1, -1): result[i] *= suffix_product suffix_product *= numbers[i] return result"},{"question":"def remove_consecutive_duplicates(lst: List[int]) -> List[int]: Given a list of integers, return a new list containing only the integers that remain after removing all consecutive duplicate values. >>> remove_consecutive_duplicates([1, 2, 2, 3, 3, 1, 1, 4]) [1, 2, 3, 1, 4] >>> remove_consecutive_duplicates([]) [] >>> remove_consecutive_duplicates([1, 1, 1]) [1] >>> remove_consecutive_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_consecutive_duplicates([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7]) [1, 2, 3, 4, 5, 6, 7] >>> remove_consecutive_duplicates([1, 2, 3, 3, 3, 2, 2, 1, 1, 4, 4, 5]) [1, 2, 3, 2, 1, 4, 5]","solution":"def remove_consecutive_duplicates(lst): Given a list of integers, return a new list containing only the integers that remain after removing all consecutive duplicate values. if not lst: return [] result = [lst[0]] for i in range(1, len(lst)): if lst[i] != lst[i - 1]: result.append(lst[i]) return result"},{"question":"def generate_summary_report(reviews): Generates a summary report of products from the reviews. :param reviews: List of reviews, each a list in the format [userName, productName, rating, reviewText] :return: Summary report as a list of lists in the format [[\\"Product\\", \\"Average Rating\\", \\"Mentions\\"], ...] >>> generate_summary_report([[\\"Alice\\", \\"Air Fryer\\", 4, \\"This air fryer is amazing!\\"]]) [[\\"Product\\", \\"Average Rating\\", \\"Mentions\\"], [\\"Air Fryer\\", 4.0, 1]] >>> generate_summary_report([ [\\"Alice\\", \\"Air Fryer\\", 4, \\"This air fryer is amazing!\\"], [\\"Bob\\", \\"Blender\\", 5, \\"The best blender I've ever used.\\"], [\\"Alice\\", \\"Blender\\", 4, \\"Makes great smoothies.\\"], [\\"David\\", \\"Air Fryer\\", 5, \\"I use it every day.\\"], [\\"Eve\\", \\"Coffee Maker\\", 3, \\"Good for the price.\\"] ]) [[\\"Product\\", \\"Average Rating\\", \\"Mentions\\"], [\\"Air Fryer\\", 4.5, 2], [\\"Blender\\", 4.5, 2], [\\"Coffee Maker\\", 3.0, 1]]","solution":"from collections import defaultdict def generate_summary_report(reviews): Generates a summary report of products from the reviews. :param reviews: List of reviews, each a list in the format [userName, productName, rating, reviewText] :return: Summary report as a list of lists in the format [[\\"Product\\", \\"Average Rating\\", \\"Mentions\\"], ...] product_ratings = defaultdict(list) for _, productName, rating, _ in reviews: product_ratings[productName].append(rating) summary = [[\\"Product\\", \\"Average Rating\\", \\"Mentions\\"]] for product in sorted(product_ratings): ratings = product_ratings[product] average_rating = round(sum(ratings) / len(ratings), 1) mentions = len(ratings) summary.append([product, average_rating, mentions]) return summary"},{"question":"def max_depth_of_parentheses(s: str) -> int: Determines the maximum depth of nested parentheses within a given string. The function returns an integer representing this maximum depth. If the string is empty or contains no parentheses, the function returns 0. If there are unbalanced parentheses, it returns -1. >>> max_depth_of_parentheses('') == 0 >>> max_depth_of_parentheses('abc') == 0 >>> max_depth_of_parentheses('(abc)') == 1 >>> max_depth_of_parentheses('(a(b)c(d(e)f)g)') == 3 >>> max_depth_of_parentheses(')abc(') == -1 >>> max_depth_of_parentheses('(abc') == -1 >>> max_depth_of_parentheses('((a)((b)c))') == 3 >>> max_depth_of_parentheses('((a)(b)c))))') == -1 >>> max_depth_of_parentheses('') == 0 >>> max_depth_of_parentheses('()') == 1 >>> max_depth_of_parentheses('(((())))') == 4","solution":"def max_depth_of_parentheses(s: str) -> int: Returns the maximum depth of nested parentheses within the given string. If the string contains unbalanced parentheses, the function returns -1. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': if current_depth == 0: return -1 # Unbalanced case: more closing than opening current_depth -= 1 if current_depth != 0: return -1 # Unbalanced case: more opening than closing return max_depth"},{"question":"def top_n_students(students, N): Given a list of students with their respective scores in a format of a list of dictionaries, returns a list of the top N students based on their scores. Each dictionary represents a student with their name and score (e.g., {'name': 'Alice', 'score': 90}). If multiple students have the same score, they should all be included in the result. If N is larger than the number of students, all students should be included. Parameters: - students (list): List of dictionaries with 'name' and 'score'. - N (int): Number of top students to return. Returns: - list: List of dictionaries of the top N students sorted by score in descending order. Examples: >>> students = [ ... {'name': 'Alice', 'score': 90}, ... {'name': 'Bob', 'score': 85}, ... {'name': 'Charlie', 'score': 95}, ... {'name': 'David', 'score': 85}, ... {'name': 'Eva', 'score': 100} ... ] >>> top_n_students(students, 3) [{'name': 'Eva', 'score': 100}, {'name': 'Charlie', 'score': 95}, {'name': 'Alice', 'score': 90}] def test_top_n_students(): students = [ {'name': 'Alice', 'score': 90}, {'name': 'Bob', 'score': 85}, {'name': 'Charlie', 'score': 95}, {'name': 'David', 'score': 85}, {'name': 'Eva', 'score': 100} ] result = top_n_students(students, 3) expected = [ {'name': 'Eva', 'score': 100}, {'name': 'Charlie', 'score': 95}, {'name': 'Alice', 'score': 90} ] assert result == expected def test_top_n_students_with_tie(): students = [ {'name': 'Alice', 'score': 90}, {'name': 'Bob', 'score': 85}, {'name': 'Charlie', 'score': 95}, {'name': 'David', 'score': 85}, {'name': 'Eva', 'score': 100}, {'name': 'Frank', 'score': 85} ] result = top_n_students(students, 4) expected = [ {'name': 'Eva', 'score': 100}, {'name': 'Charlie', 'score': 95}, {'name': 'Alice', 'score': 90}, {'name': 'Bob', 'score': 85}, {'name': 'David', 'score': 85}, {'name': 'Frank', 'score': 85} ] assert result == expected def test_top_n_students_no_students(): students = [] result = top_n_students(students, 3) expected = [] assert result == expected def test_top_n_students_n_larger_than_students(): students = [ {'name': 'Alice', 'score': 90}, {'name': 'Bob', 'score': 85} ] result = top_n_students(students, 5) expected = [ {'name': 'Alice', 'score': 90}, {'name': 'Bob', 'score': 85} ] assert result == expected def test_top_n_students_all_same_score(): students = [ {'name': 'Alice', 'score': 85}, {'name': 'Bob', 'score': 85}, {'name': 'Charlie', 'score': 85} ] result = top_n_students(students, 2) expected = [ {'name': 'Alice', 'score': 85}, {'name': 'Bob', 'score': 85}, {'name': 'Charlie', 'score': 85} ] assert result == expected","solution":"def top_n_students(students, N): Returns the top N students based on their scores. Parameters: students (list): List of dictionaries with 'name' and 'score'. N (int): Number of top students to return. Returns: list: List of dictionaries of top N students sorted by score in descending order. # Sort the list of students based on their scores in descending order sorted_students = sorted(students, key=lambda k: k['score'], reverse=True) # Initialize the list to store the top N students top_students = [] for student in sorted_students: if len(top_students) < N or student['score'] == top_students[-1]['score']: top_students.append(student) else: break return top_students"},{"question":"import numpy as np from typing import Set, Dict def levenshtein_distance(str1: str, str2: str) -> int: Returns the Levenshtein distance between str1 and str2. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") == 2 >>> levenshtein_distance(\\"\\", \\"\\") == 0 >>> levenshtein_distance(\\"gumbo\\", \\"gambol\\") == 2 pass def spell_checker(dictionary: Set[str], sentence: str) -> Dict[str, str]: Identifies misspelled words in the sentence and suggests corrections. >>> dictionary = {\\"this\\", \\"is\\", \\"a\\", \\"sentence\\"} >>> sentence = \\"this is a sentenc\\" >>> spell_checker(dictionary, sentence) == {\\"sentenc\\": \\"sentence\\"} >>> dictionary = {\\"hello\\", \\"world\\"} >>> sentence = \\"helo wurld\\" >>> spell_checker(dictionary, sentence) == {\\"helo\\": \\"hello\\", \\"wurld\\": \\"world\\"} >>> dictionary = {\\"Case\\", \\"Sensitive\\"} >>> sentence = \\"case sensitive\\" >>> spell_checker(dictionary, sentence) == {\\"case\\": \\"Case\\", \\"sensitive\\": \\"Sensitive\\"} pass","solution":"import numpy as np def levenshtein_distance(str1, str2): Returns the Levenshtein distance between str1 and str2. n, m = len(str1), len(str2) if n > m: str1, str2 = str2, str1 n, m = m, n current_row = range(n + 1) for i in range(1, m + 1): previous_row, current_row = current_row, [i] + [0] * n for j in range(1, n + 1): add, delete, change = previous_row[j] + 1, current_row[j - 1] + 1, previous_row[j - 1] if str1[j - 1] != str2[i - 1]: change += 1 current_row[j] = min(add, delete, change) return current_row[n] def spell_checker(dictionary, sentence): Identifies misspelled words in the sentence and suggests corrections. suggestions = {} words = sentence.split() for word in words: if word not in dictionary: closest_word = min(dictionary, key=lambda dict_word: levenshtein_distance(word, dict_word)) suggestions[word] = closest_word return suggestions"},{"question":"import json def filter_books_by_price(input_file_path: str, max_price: float, output_file_path: str): Filters books with a price greater than the specified max_price from a JSON file and writes the filtered data to a new JSON file. Parameters: input_file_path (str): Path to the input JSON file containing book data. max_price (float): Maximum price threshold. output_file_path (str): Path to the output JSON file to write the filtered data. import pytest import json import os def test_filter_books_by_price(tmp_path): # Create a sample input JSON file input_file_path = tmp_path / \\"books.json\\" output_file_path = tmp_path / \\"filtered_books.json\\" books_data = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"price\\": 20}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"price\\": 15}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"price\\": 30}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author D\\", \\"price\\": 25} ] with open(input_file_path, 'w') as input_file: json.dump(books_data, input_file) # Filter books with price greater than 20 filter_books_by_price(input_file_path, 20, output_file_path) # Verify the output with open(output_file_path, 'r') as output_file: filtered_books = json.load(output_file) expected_filtered_books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"price\\": 20}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"price\\": 15} ] assert filtered_books == expected_filtered_books def test_no_books_filtered(tmp_path): # Create a sample input JSON file where no books are filtered input_file_path = tmp_path / \\"books.json\\" output_file_path = tmp_path / \\"filtered_books.json\\" books_data = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"price\\": 10}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"price\\": 15}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"price\\": 20} ] with open(input_file_path, 'w') as input_file: json.dump(books_data, input_file) # Filter books with price greater than 20 filter_books_by_price(input_file_path, 20, output_file_path) # Verify the output with open(output_file_path, 'r') as output_file: filtered_books = json.load(output_file) expected_filtered_books = books_data assert filtered_books == expected_filtered_books def test_all_books_filtered(tmp_path): # Create a sample input JSON file where all books are filtered input_file_path = tmp_path / \\"books.json\\" output_file_path = tmp_path / \\"filtered_books.json\\" books_data = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"price\\": 25}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"price\\": 35}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"price\\": 30} ] with open(input_file_path, 'w') as input_file: json.dump(books_data, input_file) # Filter books with price greater than 20 filter_books_by_price(input_file_path, 20, output_file_path) # Verify the output with open(output_file_path, 'r') as output_file: filtered_books = json.load(output_file) expected_filtered_books = [] assert filtered_books == expected_filtered_books","solution":"import json def filter_books_by_price(input_file_path, max_price, output_file_path): Filters books with a price greater than the specified max_price from a JSON file and writes the filtered data to a new JSON file. Parameters: input_file_path (str): Path to the input JSON file containing book data. max_price (float): Maximum price threshold. output_file_path (str): Path to the output JSON file to write the filtered data. # Read the input JSON file with open(input_file_path, 'r') as input_file: books = json.load(input_file) # Filter the books based on the max_price filtered_books = [book for book in books if book['price'] <= max_price] # Write the filtered data to the output JSON file with open(output_file_path, 'w') as output_file: json.dump(filtered_books, output_file, indent=4)"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is replaced with the product of all other integers except the current position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([1]) [1] >>> product_except_self([]) []","solution":"def product_except_self(nums): Returns a new list where each integer is replaced with the product of all other integers in the original list except the one at the current position. length = len(nums) if length == 0: return [] # Initialize the left and right products left_products = [1] * length right_products = [1] * length # Calculate left products for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate right products for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate the result by multiplying left and right products result = [1] * length for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"import pandas as pd import matplotlib.pyplot as plt def fetch_and_process_data(url: str) -> pd.DataFrame: This function fetches the data from the provided URL and processes it to focus on average annual temperatures. # Your code here def plot_data(df: pd.DataFrame): This function generates a graph illustrating the change in average annual global temperatures from the year 1900 to the most recent year. # Your code here # URL to the dataset url = \\"https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv\\" # Fetch and process the data df = fetch_and_process_data(url) # Plot the data plot_data(df)","solution":"import pandas as pd import matplotlib.pyplot as plt def fetch_and_process_data(url): This function fetches the data from the provided URL and processes it to focus on average annual temperatures. # Fetch data df = pd.read_csv(url, skiprows=1) # Select relevant columns df = df[['Year', 'J-D']] # Remove rows with missing data df = df.dropna() # Filter data from year 1900 onwards df = df[df['Year'] >= 1900] # Rename columns for clarity df.columns = ['Year', 'AvgAnnualTemp'] return df def plot_data(df): This function generates a graph illustrating the change in average annual global temperatures from the year 1900 to the most recent year. plt.figure(figsize=(14, 7)) plt.plot(df['Year'], df['AvgAnnualTemp'], label='Avg Annual Temperature') plt.xlabel('Year') plt.ylabel('Temperature (C)') plt.title('Change in Average Annual Global Temperatures (1900 - Present)') plt.legend() plt.grid(True) plt.show() # URL to the dataset url = \\"https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv\\" # Fetch and process the data df = fetch_and_process_data(url) # Plot the data plot_data(df)"},{"question":"def count_vowels(s: str) -> int: Write a Python function called \`count_vowels\` that takes a string as input and returns the number of vowels (a, e, i, o, u) present in that string. The function should be case-insensitive, meaning it should count both uppercase and lowercase vowels. Ensure the function handles edge cases such as an empty string or a string with no vowels. >>> count_vowels('') == 0 >>> count_vowels('bcdfg') == 0 >>> count_vowels('aeiou') == 5 >>> count_vowels('AEIOU') == 5 >>> count_vowels('aEiOu') == 5 >>> count_vowels('Hello World') == 3 >>> count_vowels('12345!@#') == 0 >>> count_vowels('H3ll0 W0rld! aeiou AEIOU') == 10","solution":"def count_vowels(s): Returns the number of vowels (a, e, i, o, u) in the input string s. The function is case-insensitive. vowels = \\"aeiou\\" count = 0 for char in s.lower(): # Convert string to lowercase to handle case-insensitivity if char in vowels: count += 1 return count # Corrected the erroneous code with the inclusion of s.lower() to make the function case-insensitive"},{"question":"def S(n): Calculate the sum of the x-coordinates of all fixed points in F(n). Let _n be the set of integers modulo n. Consider the function h from _n  _n to _n  _n defined by h(x, y) = ((x + y) mod n, (x + 2y) mod n). Let h^(k)(x, y) = h(h(...h(x, y)...)) be the k-th iterated composition of h with itself. A point (x, y)  _n  _n is said to be fixed by h if h(x, y) = (x, y). Let F(n) denote the set of all fixed points of h in _n  _n. Define S(n) as the sum of the x-coordinates of all fixed points in F(n). Parameters: n (int): A positive integer Returns: int: The sum of the x-coordinates of all fixed points in F(n) Examples: >>> S(3) 0 >>> S(10) 0","solution":"def S(n): Calculate the sum of the x-coordinates of all fixed points in F(n). # As derived, the only fixed point is (0, 0) for any positive integer n. return 0"},{"question":"def average_scores(students_scores: dict, threshold: float) -> dict: Returns a dictionary with student names and their average scores rounded to two decimal places. Filters out students whose average score is below the threshold. Args: students_scores (dict): A dictionary where keys are student names and values are lists of scores. threshold (float): The threshold for filtering out students. Returns: dict: A dictionary with student names and their average scores. >>> students_scores = { ... \\"Alice\\": [85, 90, 78], ... \\"Bob\\": [70, 65, 75], ... \\"Charlie\\": [95, 100, 85], ... \\"David\\": [60, 62, 58] ... } >>> threshold = 80 >>> average_scores(students_scores, threshold) {'Alice': 84.33, 'Charlie': 93.33}","solution":"def average_scores(students_scores, threshold): Returns a dictionary with student names and their average scores rounded to two decimal places. Filters out students whose average score is below the threshold. Args: students_scores (dict): A dictionary where keys are student names and values are lists of scores. threshold (float): The threshold for filtering out students. Returns: dict: A dictionary with student names and their average scores. result = {} for student, scores in students_scores.items(): if scores: avg_score = round(sum(scores) / len(scores), 2) if avg_score >= threshold: result[student] = avg_score return result"},{"question":"def filter_greater_than_threshold(lst, threshold): Returns a list containing only the elements from lst that are greater than threshold. Parameters: lst (list): List of integers threshold (int): The threshold integer Returns: list: New list with elements greater than threshold pass def validate_inputs(lst, threshold): Validates that lst is a list of integers and threshold is an integer. Parameters: lst (list): List of integers threshold (int): The threshold integer Returns: bool: True if both inputs are valid, False otherwise pass # Test cases import pytest def test_filter_greater_than_threshold(): assert filter_greater_than_threshold([1, 2, 3, 4, 5], 3) == [4, 5] def test_filter_greater_than_threshold_with_empty_list(): assert filter_greater_than_threshold([], 3) == [] def test_filter_greater_than_threshold_no_elements_greater(): assert filter_greater_than_threshold([1, 2, 3], 5) == [] def test_filter_greater_than_threshold_all_elements_greater(): assert filter_greater_than_threshold([6, 7, 8, 9], 5) == [6, 7, 8, 9] def test_filter_greater_than_threshold_threshold_as_zero(): assert filter_greater_than_threshold([0, -1, 1, 2], 0) == [1, 2] def test_validate_inputs_valid(): assert validate_inputs([1, 2, 3], 2) == True def test_validate_inputs_invalid_list(): assert validate_inputs(\\"not a list\\", 2) == False def test_validate_inputs_invalid_threshold(): assert validate_inputs([1, 2, 3], \\"not an int\\") == False def test_validate_inputs_invalid_list_elements(): assert validate_inputs([1, \\"not an int\\", 3], 2) == False def test_invalid_inputs_raises_value_error(): with pytest.raises(ValueError, match=\\"Invalid inputs: List must contain only integers and threshold must be an integer.\\"): filter_greater_than_threshold([1, \\"not an int\\", 3], 2)","solution":"def filter_greater_than_threshold(lst, threshold): Returns a list containing only the elements from lst that are greater than threshold. Parameters: lst (list): List of integers threshold (int): The threshold integer Returns: list: New list with elements greater than threshold if not validate_inputs(lst, threshold): raise ValueError(\\"Invalid inputs: List must contain only integers and threshold must be an integer.\\") return [item for item in lst if item > threshold] def validate_inputs(lst, threshold): Validates that lst is a list of integers and threshold is an integer. Parameters: lst (list): List of integers threshold (int): The threshold integer Returns: bool: True if both inputs are valid, False otherwise if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst) or not isinstance(threshold, int): return False return True"},{"question":"from typing import Tuple def longest_palindromic_subsequence(s: str) -> Tuple[int, str]: Finds the longest palindromic subsequence in a given string. :param s: Input string :return: A tuple containing the length of the longest palindromic subsequence and the subsequence itself. >>> longest_palindromic_subsequence(\\"agbdba\\") (5, \\"abdba\\") >>> longest_palindromic_subsequence(\\"cbbd\\") (2, \\"bb\\")","solution":"def longest_palindromic_subsequence(s): Finds the longest palindromic subsequence in a given string. :param s: Input string :return: A tuple containing the length of the longest palindromic subsequence and the subsequence itself. n = len(s) # Create a 2D table to store the length of palindromic subsequence dp = [[0 for _ in range(n)] for _ in range(n)] # All substrings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the table for cl in range(2, n+1): # cl is the length of substring for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # The length of LPS is at dp[0][n-1] lps_length = dp[0][n-1] # Create a character array to store the lps lps = [''] * lps_length i, j = 0, n - 1 start, end = 0, lps_length - 1 while i <= j: if s[i] == s[j]: lps[start] = s[i] lps[end] = s[j] i += 1 j -= 1 start += 1 end -= 1 elif dp[i][j-1] > dp[i+1][j]: j -= 1 else: i += 1 return lps_length, ''.join(lps)"},{"question":"from datetime import datetime, timedelta def recently_added_names(records, days): Computes the recently added names within a span of \`n\` days from a list of name records. Args: records (list of tuples): A list of tuples, where each tuple contains a name (string) and a date (string in 'YYYY-MM-DD' format). days (int): An integer representing the number of days to look back from today. Returns: list: A list of names (strings) added within the last n days. Examples: >>> recently_added_names([('Alice', '2023-09-20'), ('Bob', '2023-10-01'), ('Charlie', '2023-10-10')], 10) ['Bob', 'Charlie'] >>> recently_added_names([('Alice', '2023-09-20'), ('Bob', '2023-10-01')], 0) []","solution":"from datetime import datetime, timedelta def recently_added_names(records, days): Returns a list of names added within the last n days from today's date Args: records (list of tuples): A list of tuples, where each tuple contains a name (string) and a date (string in 'YYYY-MM-DD' format). days (int): An integer representing the number of days to look back from today. Returns: list: A list of names (strings) added within the last n days. today = datetime.today().date() result = [] cutoff_date = today - timedelta(days=days) for name, date_str in records: try: date = datetime.strptime(date_str, '%Y-%m-%d').date() except ValueError: continue if cutoff_date <= date <= today: result.append(name) return result"},{"question":"def count_paths(N: int, M: int, grid: List[str]) -> int: Determine the number of distinct paths the robot can take to reach the bottom-right corner. The robot starts at the top-left corner and aims to reach the bottom-right corner. It can move exactly one cell to the right or one cell down at each step, but it cannot enter a blocked cell. >>> N = 3 >>> M = 3 >>> grid = [\\"...\\", \\".#.\\", \\"...\\"] >>> count_paths(N, M, grid) 2 >>> N = 3 >>> M = 3 >>> grid = [\\"#..\\", \\"...\\", \\"...\\"] >>> count_paths(N, M, grid) 0 >>> N = 3 >>> M = 3 >>> grid = [\\"...\\", \\"...\\", \\"..#\\"] >>> count_paths(N, M, grid) 0 >>> N = 3 >>> M = 3 >>> grid = [\\"...\\", \\"#\\", \\"...\\"] >>> count_paths(N, M, grid) 0 >>> N = 1 >>> M = 5 >>> grid = [\\".....\\"] >>> count_paths(N, M, grid) 1 >>> N = 5 >>> M = 1 >>> grid = [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"] >>> count_paths(N, M, grid) 1 >>> N = 1 >>> M = 1 >>> grid = [\\".\\"] >>> count_paths(N, M, grid) 1 >>> N = 5 >>> M = 5 >>> grid = [\\".....\\", \\".#.\\", \\".#...\\", \\".#.\\", \\".....\\"] >>> count_paths(N, M, grid) 2","solution":"from typing import List def count_paths(N: int, M: int, grid: List[str]) -> int: if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"class Account: def __init__(self, account_number, password): self.account_number = account_number self.password = password self.balance = 0 def deposit(self, amount): pass def withdraw(self, amount): pass def get_balance(self): pass class BankingSystem: def __init__(self): self.accounts = {} self.logged_in_account = None def create_account(self, account_number, password): pass def login(self, account_number, password): pass def logout(self): pass def deposit(self, amount): pass def withdraw(self, amount): pass def check_balance(self): pass import pytest def test_create_account(): banking_system = BankingSystem() assert banking_system.create_account(\\"12345\\", \\"password\\") == \\"Account created successfully\\" with pytest.raises(ValueError): banking_system.create_account(\\"12345\\", \\"password\\") def test_login_logout(): banking_system = BankingSystem() banking_system.create_account(\\"12345\\", \\"password\\") with pytest.raises(ValueError): banking_system.login(\\"12345\\", \\"wrongpassword\\") assert banking_system.login(\\"12345\\", \\"password\\") == \\"Logged in successfully\\" assert banking_system.logout() == \\"Logged out successfully\\" with pytest.raises(ValueError): banking_system.login(\\"123456\\", \\"password\\") def test_deposit(): banking_system = BankingSystem() banking_system.create_account(\\"12345\\", \\"password\\") banking_system.login(\\"12345\\", \\"password\\") assert banking_system.deposit(100) == 100 with pytest.raises(ValueError): banking_system.deposit(-50) banking_system.logout() with pytest.raises(PermissionError): banking_system.deposit(50) def test_withdraw(): banking_system = BankingSystem() banking_system.create_account(\\"12345\\", \\"password\\") banking_system.login(\\"12345\\", \\"password\\") banking_system.deposit(100) assert banking_system.withdraw(50) == 50 with pytest.raises(ValueError): banking_system.withdraw(-30) with pytest.raises(ValueError): banking_system.withdraw(100) banking_system.logout() with pytest.raises(PermissionError): banking_system.withdraw(30) def test_check_balance(): banking_system = BankingSystem() banking_system.create_account(\\"12345\\", \\"password\\") banking_system.login(\\"12345\\", \\"password\\") banking_system.deposit(150) assert banking_system.check_balance() == 150 banking_system.logout() with pytest.raises(PermissionError): banking_system.check_balance()","solution":"class Account: def __init__(self, account_number, password): self.account_number = account_number self.password = password self.balance = 0 def deposit(self, amount): if amount > 0: self.balance += amount return self.balance else: raise ValueError(\\"Deposit amount must be positive\\") def withdraw(self, amount): if amount > self.balance: raise ValueError(\\"Insufficient funds\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") self.balance -= amount return self.balance def get_balance(self): return self.balance class BankingSystem: def __init__(self): self.accounts = {} self.logged_in_account = None def create_account(self, account_number, password): if account_number in self.accounts: raise ValueError(\\"Account number already exists\\") self.accounts[account_number] = Account(account_number, password) return \\"Account created successfully\\" def login(self, account_number, password): if account_number not in self.accounts: raise ValueError(\\"Invalid account number\\") if self.accounts[account_number].password != password: raise ValueError(\\"Incorrect password\\") self.logged_in_account = self.accounts[account_number] return \\"Logged in successfully\\" def logout(self): self.logged_in_account = None return \\"Logged out successfully\\" def deposit(self, amount): if self.logged_in_account is None: raise PermissionError(\\"Please log in first\\") return self.logged_in_account.deposit(amount) def withdraw(self, amount): if self.logged_in_account is None: raise PermissionError(\\"Please log in first\\") return self.logged_in_account.withdraw(amount) def check_balance(self): if self.logged_in_account is None: raise PermissionError(\\"Please log in first\\") return self.logged_in_account.get_balance()"},{"question":"from typing import List def find_top_k_frequent(nums: List[int], k: int) -> List[int]: Design a function which takes a list of integers and an integer k, and returns the k most frequent elements in the list. In case of a tie, the elements should be sorted in ascending order. >>> find_top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> find_top_k_frequent([1], 1) [1] >>> find_top_k_frequent([1, 2, 2, 3, 3], 2) [2, 3] pass","solution":"from collections import Counter from heapq import nlargest def find_top_k_frequent(nums, k): Returns the k most frequent elements in the list nums. In case of a tie, the elements are sorted in ascending order. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"Input must be a list of integers\\") if not isinstance(k, int) or k < 1: raise ValueError(\\"k must be a positive integer\\") if not nums: return [] count = Counter(nums) result = nlargest(k, sorted(count), key=count.get) return result"},{"question":"def sort_and_count_odd(num_list): Sort the list in ascending order, and return a tuple containing the sorted list and the count of odd numbers present in the list. Handles various types of inputs, including strings, negative numbers, special characters or None values. >>> sort_and_count_odd([4, \\"17\\", None, -3, 11.2, 6, True, \\"8\\", 4, -1]) ([-3, -1, 4, 4, 6, 11.2], 2) >>> sort_and_count_odd([7, 3, 1, 12]) ([1, 3, 7, 12], 3) >>> sort_and_count_odd([\\"a\\", True, None, \\"12\\"]) ([], 0) >>> sort_and_count_odd([9, 2.0, \\"hello\\", 8, -1, False]) ([-1, 2.0, 8, 9], 2) >>> sort_and_count_odd([]) ([], 0) >>> sort_and_count_odd([7, 3, 1, 9, -1]) ([-1, 1, 3, 7, 9], 5)","solution":"def sort_and_count_odd(num_list): sorted_list = [] odd_count = 0 for num in num_list: if num is None or type(num) not in [int, float] or isinstance(num, bool): pass else: sorted_list.append(num) if isinstance(num, int) and num % 2 != 0: odd_count += 1 # Sorting the list in ascending order sorted_list.sort() return (sorted_list, odd_count) numbers = [4, \\"17\\", None, -3, 11.2, 6, True, \\"8\\", 4, -1] print(sort_and_count_odd(numbers))"},{"question":"def is_valid_isbn10(isbn: str) -> bool: Validate if a given string is a correctly formatted International Standard Book Number (ISBN-10). >>> is_valid_isbn10(\\"0471958697\\") True >>> is_valid_isbn10(\\"123456789X\\") True >>> is_valid_isbn10(\\"0306406152\\") True >>> is_valid_isbn10(\\"1234567890\\") False >>> is_valid_isbn10(\\"12345678X9\\") False","solution":"def is_valid_isbn10(isbn: str) -> bool: if len(isbn) != 10: return False if not isbn[:9].isdigit(): return False if isbn[-1] not in \\"0123456789X\\": return False total = 0 for i in range(9): total += int(isbn[i]) * (i + 1) if isbn[-1] == 'X': total += 10 * 10 else: total += int(isbn[-1]) * 10 return total % 11 == 0"},{"question":"from typing import List def find_substring_indices(s: str, sub: str) -> List[int]: Finds all starting indices of the substring \`sub\` in the string \`s\`. Parameters: s (str): The string to search within. sub (str): The substring to search for. Returns: List[int]: A list of starting indices of \`sub\` in \`s\`. >>> find_substring_indices(\\"hellohello\\", \\"lo\\") [3, 8] >>> find_substring_indices(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> find_substring_indices(\\"abc\\", \\"d\\") [] def test_find_substring_indices_normal_case(): assert find_substring_indices(\\"hellohello\\", \\"lo\\") == [3, 8] def test_find_substring_indices_repeated_sub(): assert find_substring_indices(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] def test_find_substring_indices_not_found(): assert find_substring_indices(\\"abc\\", \\"d\\") == [] def test_find_substring_indices_single_character(): assert find_substring_indices(\\"aaaaa\\", \\"a\\") == [0, 1, 2, 3, 4] def test_find_substring_indices_full_string(): assert find_substring_indices(\\"abcd\\", \\"abcd\\") == [0] def test_find_substring_indices_empty_string(): assert find_substring_indices(\\"\\", \\"a\\") == [] def test_find_substring_indices_sub_longer_than_s(): assert find_substring_indices(\\"abc\\", \\"abcd\\") == [] def test_find_substring_indices_sub_at_end(): assert find_substring_indices(\\"hello\\", \\"lo\\") == [3]","solution":"from typing import List def find_substring_indices(s: str, sub: str) -> List[int]: Finds all starting indices of the substring \`sub\` in the string \`s\`. Parameters: s (str): The string to search within. sub (str): The substring to search for. Returns: List[int]: A list of starting indices of \`sub\` in \`s\`. indices = [] start = 0 while True: start = s.find(sub, start) if start == -1: break indices.append(start) start += 1 # Increment start to search for next non-overlapping occurrence return indices"},{"question":"def first_non_repeated_char(s: str) -> str: Write a function that takes a string as input and returns the first non-repeated character in the string. If all characters are repeated or the string is empty, return a message indicating such. >>> first_non_repeated_char(\\"swiss\\") == 'w' >>> first_non_repeated_char(\\"aabbcc\\") == \\"All characters are repeated or the string is empty.\\" >>> first_non_repeated_char(\\"\\") == \\"All characters are repeated or the string is empty.\\" >>> first_non_repeated_char(\\"aabbc\\") == 'c' >>> first_non_repeated_char(\\"abcdabc\\") == 'd'","solution":"def first_non_repeated_char(s): Returns the first non-repeated character in the string \`s\`. If all characters are repeated or the string is empty, returns a message indicating such. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeated character for char in s: if char_count[char] == 1: return char return \\"All characters are repeated or the string is empty.\\""},{"question":"class Library: A simplified library system to manage book borrowing and returning. Methods: - add_book(title, author): Add a book to the catalog. - borrow_book(username, title): Borrow a book if available. - return_book(username, title): Return a borrowed book. - list_available_books(): List all currently available books. - list_borrowed_books(): List all borrowed books and corresponding borrowers. Example usage: >>> library = Library() >>> library.add_book(\\"Book One\\", \\"Author One\\") >>> library.list_available_books() {\\"Book One\\": \\"Author One\\"} >>> library.borrow_book(\\"User1\\", \\"Book One\\") True >>> library.list_borrowed_books() {\\"Book One\\": (\\"Author One\\", \\"User1\\")} >>> library.return_book(\\"User1\\", \\"Book One\\") True >>> library.list_available_books() {\\"Book One\\": \\"Author One\\"} Unit tests: from solution import Library def test_add_book(): library = Library() library.add_book(\\"Book One\\", \\"Author One\\") assert \\"Book One\\" in library.catalog def test_borrow_book(): library = Library() library.add_book(\\"Book Two\\", \\"Author Two\\") assert library.borrow_book(\\"User1\\", \\"Book Two\\") assert \\"Book Two\\" in library.borrowed_books assert not library.borrow_book(\\"User2\\", \\"Book Two\\") def test_return_book(): library = Library() library.add_book(\\"Book Three\\", \\"Author Three\\") assert library.borrow_book(\\"User1\\", \\"Book Three\\") assert library.return_book(\\"User1\\", \\"Book Three\\") assert \\"Book Three\\" not in library.borrowed_books assert not library.return_book(\\"User2\\", \\"Book Three\\") def test_list_available_books(): library = Library() library.add_book(\\"Book Four\\", \\"Author Four\\") library.add_book(\\"Book Five\\", \\"Author Five\\") library.borrow_book(\\"User1\\", \\"Book Four\\") available_books = library.list_available_books() assert \\"Book Five\\" in available_books assert \\"Book Four\\" not in available_books def test_list_borrowed_books(): library = Library() library.add_book(\\"Book Six\\", \\"Author Six\\") library.add_book(\\"Book Seven\\", \\"Author Seven\\") library.borrow_book(\\"User1\\", \\"Book Six\\") borrowed_books = library.list_borrowed_books() assert \\"Book Six\\" in borrowed_books assert borrowed_books[\\"Book Six\\"] == (\\"Author Six\\", \\"User1\\") assert \\"Book Seven\\" not in borrowed_books def __init__(self): self.catalog = {} self.borrowed_books = {} def add_book(self, title, author): pass # Implement here def borrow_book(self, username, title): pass # Implement here def return_book(self, username, title): pass # Implement here def list_available_books(self): pass # Implement here def list_borrowed_books(self): pass # Implement here","solution":"class Library: def __init__(self): self.catalog = {} self.borrowed_books = {} def add_book(self, title, author): if title not in self.catalog: self.catalog[title] = author def borrow_book(self, username, title): if title in self.catalog and title not in self.borrowed_books: self.borrowed_books[title] = username return True return False def return_book(self, username, title): if title in self.borrowed_books and self.borrowed_books[title] == username: del self.borrowed_books[title] return True return False def list_available_books(self): return {title: author for title, author in self.catalog.items() if title not in self.borrowed_books} def list_borrowed_books(self): return {title: (author, username) for title, author in self.catalog.items() if title in self.borrowed_books and (username := self.borrowed_books[title])}"},{"question":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Design a function named \`remove_duplicates\` that takes a list of integers and returns a new list containing only the unique elements in the order they first appeared. The original list should remain unmodified. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([5, 5, 5, 6]) [5, 6] >>> remove_duplicates([1, 2, 1, 2, 3, 1, 2]) [1, 2, 3] def test_remove_duplicates(): assert remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] assert remove_duplicates([5, 5, 5, 6]) == [5, 6] assert remove_duplicates([1, 2, 1, 2, 3, 1, 2]) == [1, 2, 3] assert remove_duplicates([]) == [] assert remove_duplicates([1]) == [1] assert remove_duplicates([1, 1, 1, 1, 1]) == [1] assert remove_duplicates([-1, -1, 0, 1, 1, -1, 0]) == [-1, 0, 1] assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert remove_duplicates([1, 1, 2, 2, 3, 3, 4, 4]) == [1, 2, 3, 4]","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: unique_nums = [] seen = set() for num in nums: if num not in seen: unique_nums.append(num) seen.add(num) return unique_nums"},{"question":"def separate_alphabets_digits(input_string: str) -> tuple: Separates the input string into two distinct strings: one containing only alphabets and the other containing only digits. Args: input_string (str): The string containing both alphabets and digits. Returns: tuple: A tuple containing two strings. The first string contains only the alphabets, and the second string contains only the digits. >>> separate_alphabets_digits(\\"a1b2c3\\") ('abc', '123') >>> separate_alphabets_digits(\\"abc\\") ('abc', '') >>> separate_alphabets_digits(\\"123\\") ('', '123') >>> separate_alphabets_digits(\\"\\") ('', '') >>> separate_alphabets_digits(\\"aBc1D2e3\\") ('aBcDe', '123') >>> separate_alphabets_digits(\\"a1!b2@c3#\\") ('abc', '123')","solution":"def separate_alphabets_digits(input_string): Separates the input string into two distinct strings: one containing only alphabets and the other containing only digits. Args: input_string (str): The string containing both alphabets and digits. Returns: tuple: A tuple containing two strings. The first string contains only the alphabets, and the second string contains only the digits. alphabets = ''.join([char for char in input_string if char.isalpha()]) digits = ''.join([char for char in input_string if char.isdigit()]) return (alphabets, digits)"},{"question":"def insert_z(numbers): Inserts the element 'z' into the third position of the array 'numbers' and returns the updated array. >>> insert_z([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [1, 2, 'z', 3, 4, 5, 6, 7, 8, 9, 10] >>> insert_z([]) ['z'] >>> insert_z([1, 2]) [1, 2, 'z'] >>> insert_z(['a', 'b', 'c', 'd']) ['a', 'b', 'z', 'c', 'd'] >>> insert_z([1]) [1, 'z']","solution":"def insert_z(numbers): Inserts the element 'z' into the third position of the array 'numbers' and returns the updated array. numbers.insert(2, 'z') # Insert 'z' at index 2 (third position) return numbers # Example usage: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(insert_z(numbers)) # Output should be [1, 2, 'z', 3, 4, 5, 6, 7, 8, 9, 10]"},{"question":"from typing import List, Tuple def vending_machine(commands: List[str], items: dict, prices: dict) -> Tuple[List[str], int]: Simulate a vending machine that dispenses items based on commands. >>> vending_machine([\\"insert 100\\", \\"select A1\\"], {\\"A1\\": \\"Soda\\", \\"B1\\": \\"Chips\\", \\"C1\\": \\"Candy\\"}, {\\"A1\\": 100, \\"B1\\": 50, \\"C1\\": 25}) ([\\"Soda\\"], 0) >>> vending_machine([\\"insert 100\\", \\"select B1\\", \\"select C1\\"], {\\"A1\\": \\"Soda\\", \\"B1\\": \\"Chips\\", \\"C1\\": \\"Candy\\"}, {\\"A1\\": 100, \\"B1\\": 50, \\"C1\\": 25}) ([\\"Chips\\", \\"Candy\\"], 25) >>> vending_machine([\\"insert 50\\", \\"insert 50\\", \\"select C1\\"], {\\"A1\\": \\"Soda\\", \\"B1\\": \\"Chips\\", \\"C1\\": \\"Candy\\"}, {\\"A1\\": 100, \\"B1\\": 50, \\"C1\\": 25}) ([\\"Candy\\"], 75) >>> vending_machine([\\"insert 50\\", \\"select A1\\"], {\\"A1\\": \\"Soda\\", \\"B1\\": \\"Chips\\", \\"C1\\": \\"Candy\\"}, {\\"A1\\": 100, \\"B1\\": 50, \\"C1\\": 25}) ([], 50) >>> vending_machine([\\"insert 50\\"], {\\"A1\\": \\"Soda\\", \\"B1\\": \\"Chips\\", \\"C1\\": \\"Candy\\"}, {\\"A1\\": 100, \\"B1\\": 50, \\"C1\\": 25}) ([], 50)","solution":"from typing import List, Tuple def vending_machine(commands: List[str], items: dict, prices: dict) -> Tuple[List[str], int]: dispensed_items = [] balance = 0 for command in commands: if command.startswith(\\"insert\\"): _, amount_str = command.split() balance += int(amount_str) elif command.startswith(\\"select\\"): _, item_code = command.split() if item_code in items and balance >= prices[item_code]: balance -= prices[item_code] dispensed_items.append(items[item_code]) return (dispensed_items, balance)"},{"question":"import copy def demonstrate_shallow_copy(): Demonstrate the behavior of a shallow copy on a nested list structure. >>> o_list, s_list = demonstrate_shallow_copy() >>> o_list[0][1] = 'modified' >>> assert s_list[0][1] == 'modified' original_list = [[1, 2, 3], [4, 5, 6]] shallow_copied_list = copy.copy(original_list) return original_list, shallow_copied_list def demonstrate_deep_copy(): Demonstrate the behavior of a deep copy on a nested dictionary structure. >>> o_dict, d_dict = demonstrate_deep_copy() >>> o_dict['a'][1] = 'modified_deep' >>> assert d_dict['a'][1] != 'modified_deep' original_dict = {'a': [1, 2, 3], 'b': [4, 5, 6]} deep_copied_dict = copy.deepcopy(original_dict) return original_dict, deep_copied_dict def test_shallow_copy(): original_list, shallow_copied_list = demonstrate_shallow_copy() assert original_list[0][1] == 'modified' assert shallow_copied_list[0][1] == 'modified' def test_deep_copy(): original_dict, deep_copied_dict = demonstrate_deep_copy() assert original_dict['a'][1] != 'modified_deep' assert deep_copied_dict['a'][1] == 'modified_deep' def test_shallow_copy_no_nested_change(): original_list, shallow_copied_list = demonstrate_shallow_copy() original_list[1][2] = 'new_value' assert shallow_copied_list[1][2] == 'new_value' def test_deep_copy_no_nested_change(): original_dict, deep_copied_dict = demonstrate_deep_copy() original_dict['b'][2] = 'new_value_deep' assert deep_copied_dict['b'][2] != 'new_value_deep'","solution":"import copy def demonstrate_shallow_copy(): original_list = [[1, 2, 3], [4, 5, 6]] shallow_copied_list = copy.copy(original_list) shallow_copied_list[0][1] = 'modified' return original_list, shallow_copied_list def demonstrate_deep_copy(): original_dict = {'a': [1, 2, 3], 'b': [4, 5, 6]} deep_copied_dict = copy.deepcopy(original_dict) deep_copied_dict['a'][1] = 'modified_deep' return original_dict, deep_copied_dict # Explanation: # Shallow Copy: A shallow copy creates a new object, but does not create copies of objects that the original object references. Instead, it only copies references to the original nested objects. Therefore, if the nested objects are modified, it reflects in both the original and shallow copied objects. # Deep Copy: A deep copy creates a new object and recursively copies all objects found within the original. This means that modifications to the nested objects in the deep copy do not affect the original object. # Use Cases & Pitfalls: # - Use a shallow copy if you have a flat (non-nested) data structure or if you do not need to modify nested objects. # - Use a deep copy when working with nested structures or when modifications to the duplicate should not affect the original data. # - Pitfalls: Using a shallow copy when you need a deep copy can lead to bugs due to unintentional modifications across the object and its duplicate. # Python's \`copy\` module provides both \`copy\` and \`deepcopy\` functions. # Importance: # Understanding the difference between shallow and deep copies is crucial in managing memory effectively in Python and preventing unintended side effects. This knowledge is essential for maintaining data integrity and ensuring that operations on duplicates do not inadvertently alter the original structures."},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Write a function that, given a binary tree, returns its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. You are to use an iterative approach utilizing a queue for breadth-first traversal. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> max_depth(root) 3 >>> max_depth(None) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> max_depth(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> max_depth(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> root.left.left.left = TreeNode(6) >>> root.right.right.right = TreeNode(7) >>> max_depth(root) 4","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): if not root: return 0 queue = deque([(root, 1)]) # Queue contains pairs of (TreeNode, depth) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"def add_item(inventory: dict, item: str, quantity: int) -> None: Adds a new item or updates the quantity if the item already exists. >>> inventory = {} >>> add_item(inventory, 'apple', 10) >>> inventory {'apple': 10} def update_item(inventory: dict, item: str, quantity: int) -> None: Updates the quantity of an existing item. If the item is not found, it raises a KeyError. >>> inventory = {'apple': 10} >>> update_item(inventory, 'apple', 5) >>> inventory {'apple': 15} def remove_item(inventory: dict, item: str) -> None: Removes an item from the inventory. If the item is not found, it raises a KeyError. >>> inventory = {'apple': 10} >>> remove_item(inventory, 'apple') >>> inventory {} from solution import add_item, update_item, remove_item def test_add_item(): inventory = {} add_item(inventory, 'apple', 10) assert inventory == {'apple': 10} add_item(inventory, 'apple', 5) assert inventory == {'apple': 15} add_item(inventory, 'banana', 20) assert inventory == {'apple': 15, 'banana': 20} def test_update_item(): inventory = {'apple': 10} update_item(inventory, 'apple', 5) assert inventory == {'apple': 15} try: update_item(inventory, 'banana', 5) except KeyError: pass else: assert False, \\"Expected KeyError for item not in inventory\\" def test_remove_item(): inventory = {'apple': 10} remove_item(inventory, 'apple') assert inventory == {} try: remove_item(inventory, 'banana') except KeyError: pass else: assert False, \\"Expected KeyError for item not in inventory\\"","solution":"def add_item(inventory: dict, item: str, quantity: int) -> None: Adds a new item or updates the quantity if the item already exists. if item in inventory: inventory[item] += quantity else: inventory[item] = quantity print(f\\"Inventory: {inventory}\\") def update_item(inventory: dict, item: str, quantity: int) -> None: Updates the quantity of an existing item. If the item is not found, it raises a KeyError. if item in inventory: inventory[item] += quantity print(f\\"Inventory: {inventory}\\") else: print(f\\"Error: Item '{item}' not found in inventory.\\") raise KeyError(f\\"Item '{item}' not found in inventory.\\") def remove_item(inventory: dict, item: str) -> None: Removes an item from the inventory. If the item is not found, it raises a KeyError. if item in inventory: del inventory[item] print(f\\"Inventory: {inventory}\\") else: print(f\\"Error: Item '{item}' not found in inventory.\\") raise KeyError(f\\"Item '{item}' not found in inventory.\\")"},{"question":"import re from collections import Counter from typing import List, Tuple def k_most_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: Write a function that takes a large text document as input and returns the k most frequent words in the document. Ensure that your function is efficient in terms of both time and space complexity. The function should be case-insensitive and should disregard punctuation marks such as commas, periods, and exclamation points. Words should be treated as sequences of alphabetic characters only. Args: text (str): input text document as a string k (int): number of most frequent words to return Returns: List[Tuple[str, int]]: list of tuples containing words and their frequency count >>> k_most_frequent_words(\\"\\", 3) [] >>> k_most_frequent_words(\\"!!!@@@#\\", 3) [] >>> k_most_frequent_words(\\"Hello, hello! How are you? You are learning. Learning is good.\\", 2) [('are', 2), ('hello', 2)] >>> k_most_frequent_words(\\"Python python pyThOn PYTHON.\\", 1) [('python', 4)] >>> k_most_frequent_words(\\"Well, this is a test, a very simple TEST.\\", 3) [('a', 2), ('test', 2), ('is', 1)] >>> k_most_frequent_words(\\"Cat bat mat rat.\\", 2) [('bat', 1), ('cat', 1)] >>> k_most_frequent_words(\\"A B C\\", 10) [('a', 1), ('b', 1), ('c', 1)] >>> k_most_frequent_words(\\"Alice in Wonderland. In a word, Alice is curious. Alice loves Alice.\\", 3) [('alice', 4), ('in', 2), ('a', 1)]","solution":"import re from collections import Counter def k_most_frequent_words(text, k): Returns the k most frequent words in the text. Args: text (str): input text document as a string k (int): number of most frequent words to return Returns: List[Tuple[str, int]]: list of tuples containing words and their frequency count if not text or not isinstance(text, str): return [] # Normalize the text text = text.lower() words = re.findall(r'b[a-z]+b', text) # Extract words if not words: return [] # Count the frequency of words word_count = Counter(words) # Get the k most common words and handle ties alphabetically most_common = word_count.most_common() most_common.sort(key=lambda x: (-x[1], x[0])) return most_common[:k]"},{"question":"def is_palindrome(s: str) -> bool: Determine if the input string is a valid palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"0P\\") == False","solution":"def is_palindrome(s: str) -> bool: Determine if the input string is a valid palindrome, considering only alphanumeric characters and ignoring cases. # Normalize the string: remove non-alphanumeric characters and convert to lowercase normalized_str = ''.join(char.lower() for char in s if char.isalnum()) # Check if the normalized string is equal to its reverse return normalized_str == normalized_str[::-1]"},{"question":"def is_valid_palindrome(s: str) -> bool: Returns True if s is a valid palindrome considering only alphanumeric characters and ignoring cases. >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_valid_palindrome(\\"race a car\\") == False >>> is_valid_palindrome(\\"\\") == True >>> is_valid_palindrome(\\"a\\") == True >>> is_valid_palindrome(\\"Able was I ere I saw Elba\\") == True >>> is_valid_palindrome(\\"No 'x' in Nixon\\") == True >>> is_valid_palindrome(\\"Hello, World!\\") == False","solution":"def is_valid_palindrome(s: str) -> bool: Returns True if s is a valid palindrome considering only alphanumeric characters and ignoring cases. # Define a function that checks if a character is alphanumeric def is_alphanumeric(c): return (ord('a') <= ord(c) <= ord('z') or ord('A') <= ord(c) <= ord('Z') or ord('0') <= ord(c) <= ord('9')) # Convert to lowercase and filter out non-alphanumeric characters filtered_chars = [char.lower() for char in s if is_alphanumeric(char)] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def reverse_string_recursively(s: str) -> str: Recursively reverse a given string. >>> reverse_string_recursively(\\"\\") \\"\\" >>> reverse_string_recursively(\\"a\\") \\"a\\" >>> reverse_string_recursively(\\"madam\\") \\"madam\\" >>> reverse_string_recursively(\\"hello\\") \\"olleh\\" >>> reverse_string_recursively(\\"12345\\") \\"54321\\"","solution":"def reverse_string_recursively(s): Reverses a given string recursively. # Base case: if the string is empty or has only one character, return it as is. if len(s) <= 1: return s # Recursive case: return the last character + reverse of the rest of the string. return s[-1] + reverse_string_recursively(s[:-1])"},{"question":"def odd_multiples_of_three(int_list: list) -> list: Returns a new list containing only the odd numbers from the original list, each multiplied by 3. Validates that the input is a list of integers. >>> odd_multiples_of_three([1, 2, 3, 4, 5]) [3, 9, 15] >>> odd_multiples_of_three([1, 3, 5, 7]) [3, 9, 15, 21] >>> odd_multiples_of_three([2, 4, 6, 8]) [] >>> odd_multiples_of_three([10, 15, 20, 25]) [45, 75] >>> odd_multiples_of_three([]) [] >>> odd_multiples_of_three([1, 'two', 3, 4]) Traceback (most recent call last): ValueError: All elements in the list must be integers >>> odd_multiples_of_three(\\"not a list\\") Traceback (most recent call last): ValueError: Input must be a list","solution":"def odd_multiples_of_three(int_list): Returns a new list containing only the odd numbers from the original list, each multiplied by 3. Validates that the input is a list of integers. if not isinstance(int_list, list): raise ValueError(\\"Input must be a list\\") for elem in int_list: if not isinstance(elem, int): raise ValueError(\\"All elements in the list must be integers\\") return [x * 3 for x in int_list if x % 2 != 0]"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determines if a list can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([0]) True >>> can_partition([1, 1]) True >>> can_partition([1, 2]) False >>> can_partition([3, 3, 3, 4, 5]) True >>> can_partition([1, 2, 5, 10, 7]) False >>> can_partition([10, 10, 10, 30]) True >>> can_partition([]) True","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If total sum is odd, it cannot be partitioned into two subsets with equal sum if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a DP array of size (target + 1) with all False dp = [False] * (target + 1) dp[0] = True # Because a subset with sum 0 is always possible for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def detect_cycle(graph: dict) -> bool: Create a function that detects a cycle in a directed graph using Depth First Search (DFS). >>> graph1 = {'A': ['B'], 'B': ['C'], 'C': ['A']} >>> detect_cycle(graph1) True >>> graph2 = {'A': ['B'], 'B': ['C'], 'C': []} >>> detect_cycle(graph2) False","solution":"def detect_cycle(graph): def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"from typing import List def top_k_frequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array \`nums\`. If there are multiple elements with the same frequency, it prioritizes the elements with the larger values. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1, 1, 1, 1], 1) [1] >>> top_k_frequent([1, 2, 3, 4], 2) [4, 3] >>> top_k_frequent([], 2) [] >>> top_k_frequent([1, 2, 3, 4], 10) [4, 3, 2, 1] >>> top_k_frequent([1, 2, 2, 3, 3, 4, 4], 2) [4, 3] >>> top_k_frequent([-1, -1, 2, 2, -3], 2) [2, -1]","solution":"from collections import Counter def top_k_frequent(nums, k): Returns the k most frequent elements in the array \`nums\`. If there are multiple elements with the same frequency, it prioritizes the elements with the larger values. :param nums: List of integers. :param k: Integer, number of top frequent elements to return. :return: List of k most frequent elements. if not nums: return [] # Count the frequency of each element in the list count = Counter(nums) # Create a sorted list of the elements by frequency, and then by number (descending) sorted_elements = sorted(count.items(), key=lambda x: (-x[1], -x[0])) # Extract the top k elements top_k = [element for element, frequency in sorted_elements[:k]] return top_k"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Write a function that receives an integer array and an integer value k, and returns the maximum sum of any subarray of length k. A subarray is defined as a contiguous portion of the array. Handle edge cases such as k being larger than the length of the array or the array containing all negative numbers efficiently. Parameters: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length k. Examples: >>> max_sum_subarray([1, 2, 3, 4, 5, 6], 3) 15 >>> max_sum_subarray([1, 2, 3], 4) None >>> max_sum_subarray([-1, -2, -3, -4], 2) -3 >>> max_sum_subarray([1, 2, 3, 4], 2) 7 >>> max_sum_subarray([1, -2, 3, 10, -1], 2) 13 >>> max_sum_subarray([10, -2, 3, -1, 4], 1) 10 >>> max_sum_subarray([], 3) None >>> max_sum_subarray([1, 2, 3], 0) None >>> max_sum_subarray([10], 1) 10 >>> max_sum_subarray([10], 2) None >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any subarray of length k. Parameters: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length k. n = len(arr) if n < k or k <= 0: return None # Edge case where k is larger than array length or k is non-positive # Compute the sum for the first subarray of length k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array for i in range(k, n): current_sum = current_sum - arr[i - k] + arr[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def sort_students_by_scores(students, top_n=None): Sorts the list of tuples (students, scores) in descending order based on scores. Parameters: students (list): A list of tuples with each tuple containing a student's name and their score. top_n (int, optional): The number of top students to return. If None, returns the entire sorted list. Returns: list: A sorted list of tuples based on scores in descending order. pass # Example Usage: # students = [('Alice', 90), ('Bob', 75), ('Charlie', 85), ('David', 95)] # print(sort_students_by_scores(students)) # Output: [('David', 95), ('Alice', 90), ('Charlie', 85), ('Bob', 75)]","solution":"def sort_students_by_scores(students, top_n=None): Sorts the list of tuples (students, scores) in descending order based on scores. Parameters: students (list): A list of tuples with each tuple containing a student's name and their score. top_n (int, optional): The number of top students to return. If None, returns the entire sorted list. Returns: list: A sorted list of tuples based on scores in descending order. # Sort the list of students by scores in descending order sorted_students = sorted(students, key=lambda x: x[1], reverse=True) # If top_n is provided, return only the top N students if top_n is not None: return sorted_students[:top_n] # Otherwise, return the entire sorted list return sorted_students"},{"question":"def find_key_recursively(nested_dict: dict, search_key: str) -> any: Recursively searches through a nested dictionary to find and return the value associated with the specified key. If the key is not present, returns None. :param nested_dict: The nested dictionary to search through. :param search_key: The key to search for. :return: The value associated with the search_key or None if the key is not found. >>> nested_dict = { ... 'a': 10, ... 'b': {'ba': 20, 'bb': {'bba': 30}}, ... 'c': 40 ... } >>> find_key_recursively(nested_dict, 'bba') 30 >>> find_key_recursively(nested_dict, 'd') is None True >>> find_key_recursively({}, 'a') is None True >>> find_key_recursively({'a': 1, 'b': 2, 'c': 3}, 'a') 1","solution":"def find_key_recursively(nested_dict, search_key): Recursively searches through a nested dictionary to find and return the value associated with the specified key. If the key is not present, returns None. :param nested_dict: The nested dictionary to search through. :param search_key: The key to search for. :return: The value associated with the search_key or None if the key is not found. if isinstance(nested_dict, dict): for key, value in nested_dict.items(): if key == search_key: return value if isinstance(value, dict): result = find_key_recursively(value, search_key) if result is not None: return result return None # Example demonstrating the function's usage example_dict = { 'a': 10, 'b': {'ba': 20, 'bb': {'bba': 30}}, 'c': 40 } # Searches for 'bba', which should return 30 print(find_key_recursively(example_dict, 'bba')) # Output: 30 # Searches for a key that does not exist, which should return None print(find_key_recursively(example_dict, 'd')) # Output: None"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest sequence of consecutive integers in the list. Args: nums: List[int] : A list of integers. Returns: int : Length of the longest sequence of consecutive integers. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_sequence([]) == 0 >>> longest_consecutive_sequence([10, 20, 30]) == 1 >>> longest_consecutive_sequence([-1, -2, -3, 1, 2, 3, 5, 4]) == 5 >>> longest_consecutive_sequence([7]) == 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 4, 5]) == 5","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest sequence of consecutive integers in the list. Args: nums: List[int] : A list of integers. Returns: int : Length of the longest sequence of consecutive integers. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # Check if it's the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def len_longest_subarray(nums: List[int], k: int) -> int: Returns the length of the longest contiguous subarray whose sum is exactly k. If no such subarray exists, return 0. >>> len_longest_subarray([1, 2, 3], 10) == 0 >>> len_longest_subarray([1, 2, 3], 6) == 3 >>> len_longest_subarray([1, -1, 5, -2, 3], 1) == 2 >>> len_longest_subarray([-2, -1, 2, 1], 1) == 2 >>> len_longest_subarray([1, 2, 3], 5) == 2","solution":"def len_longest_subarray(nums, k): Returns the length of the longest contiguous subarray whose sum is exactly k. If no such subarray exists, return 0. sum_map = {} current_sum = 0 max_len = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == k: max_len = i + 1 if (current_sum - k) in sum_map: max_len = max(max_len, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_len"},{"question":"def strings_with_vowels(strings: List[str]) -> List[str]: Returns a list of strings that contain at least one vowel. >>> strings_with_vowels([\\"apple\\", \\"orange\\", \\"banana\\"]) [\\"apple\\", \\"orange\\", \\"banana\\"] >>> strings_with_vowels([\\"apple\\", \\"sky\\", \\"world\\", \\"bcdfg\\", \\"universe\\"]) [\\"apple\\", \\"world\\", \\"universe\\"] >>> strings_with_vowels([\\"AppLe\\", \\"SkY\\", \\"Middle\\", \\"dFpTt\\"]) [\\"AppLe\\", \\"Middle\\"] >>> strings_with_vowels([]) [] >>> strings_with_vowels([\\"\\", \\"a\\", \\"e\\", \\"\\"]) [\\"a\\", \\"e\\"] >>> strings_with_vowels([\\"nthng\\", \\"bt\\", \\"bcdfg\\", \\"sHrt\\"]) [] >>> strings_with_vowels([\\"\\", \\"\\", \\"\\"]) [] >>> strings_with_vowels([\\"HeLLo\\", \\"PYthn\\", \\"xylPhonE\\", \\"AlGOrithm\\"]) [\\"HeLLo\\", \\"xylPhonE\\", \\"AlGOrithm\\"]","solution":"def strings_with_vowels(strings): Returns a list of strings that contain at least one vowel. vowels = set(\\"aeiouAEIOU\\") return [s for s in strings if any(char in vowels for char in s)]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists and returns it as a new list. The new list is created by splicing together the nodes of the first two lists. This function implements an iterative approach. :param ListNode l1: The head of the first sorted linked list. :param ListNode l2: The head of the second sorted linked list. :return: The head of the merged, sorted linked list. :rtype: ListNode def test_merge_two_sorted_lists(): >>> l1 = list_to_linkedlist([1, 2, 4]) >>> l2 = list_to_linkedlist([1, 3, 4]) >>> merged_list = merge_two_sorted_lists(l1, l2) >>> linkedlist_to_list(merged_list) [1, 1, 2, 3, 4, 4] >>> l1 = list_to_linkedlist([]) >>> l2 = list_to_linkedlist([]) >>> merged_list = merge_two_sorted_lists(l1, l2) >>> linkedlist_to_list(merged_list) [] >>> l1 = list_to_linkedlist([2]) >>> l2 = list_to_linkedlist([]) >>> merged_list = merge_two_sorted_lists(l1, l2) >>> linkedlist_to_list(merged_list) [2] >>> l1 = list_to_linkedlist([]) >>> l2 = list_to_linkedlist([3]) >>> merged_list = merge_two_sorted_lists(l1, l2) >>> linkedlist_to_list(merged_list) [3] >>> l1 = list_to_linkedlist([1, 2, 3]) >>> l2 = list_to_linkedlist([4, 5, 6]) >>> merged_list = merge_two_sorted_lists(l1, l2) >>> linkedlist_to_list(merged_list) [1, 2, 3, 4, 5, 6] >>> l1 = list_to_linkedlist([2, 2, 2]) >>> l2 = list_to_linkedlist([2, 2, 2]) >>> merged_list = merge_two_sorted_lists(l1, l2) >>> linkedlist_to_list(merged_list) [2, 2, 2, 2, 2, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1, l2): Merges two sorted linked lists and returns it as a new list. The new list is created by splicing together the nodes of the first two lists. :param ListNode l1: The head of the first sorted linked list. :param ListNode l2: The head of the second sorted linked list. :return: The head of the merged, sorted linked list. :rtype: ListNode dummy = ListNode(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next"},{"question":"def count_vowels(sentence: str) -> dict: Returns a dictionary with each vowel and their respective counts in the sentence. Args: sentence (str): The input sentence to count vowels in. Returns: dict: A dictionary with vowels as keys and their respective counts as values. >>> count_vowels(\\"The quick brown fox jumps over the lazy dog\\") {'a': 1, 'e': 3, 'i': 1, 'o': 4, 'u': 2} >>> count_vowels(\\"Aa Ee Ii Oo Uu\\") {'a': 2, 'e': 2, 'i': 2, 'o': 2, 'u': 2} >>> count_vowels(\\"bcdfghjklmnpqrstvwxyz\\") {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0} >>> count_vowels(\\"\\") {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0} >>> count_vowels(\\"AeIoUaeiou\\") {'a': 2, 'e': 2, 'i': 2, 'o': 2, 'u': 2}","solution":"def count_vowels(sentence): Returns a dictionary with each vowel and their respective counts in the sentence. vowels = 'aeiou' sentence = sentence.lower() vowel_counts = {vowel: 0 for vowel in vowels} for char in sentence: if char in vowels: vowel_counts[char] += 1 return vowel_counts"},{"question":"def election_winner(votes: List[int]) -> List[int]: Returns the index or indices of the candidate(s) with the highest votes. If there is a tie, returns a list of indices of the tied candidates. >>> election_winner([4, 2, 7, 1]) [2] >>> election_winner([4, 2, 7, 7, 1, 4]) [2, 3] >>> election_winner([3, 3, 3, 3]) [0, 1, 2, 3] >>> election_winner([]) [] >>> election_winner([5, 2, 3, 1]) [0] >>> election_winner([-1, -3, -2, -1]) [0, 3]","solution":"def election_winner(votes): Returns the index or indices of the candidate(s) with the highest votes. If there is a tie, returns a list of indices of the tied candidates. if not votes: return [] max_votes = max(votes) winners = [index for index, vote in enumerate(votes) if vote == max_votes] return winners"},{"question":"from typing import List def sum_even_numbers(arr: List[int]) -> int: Returns the sum of all the even numbers in the array. If the array is empty or contains no even numbers, returns 0. >>> sum_even_numbers([1, 2, 3, 4, 5]) 6 >>> sum_even_numbers([2, 4, 6, 8]) 20 >>> sum_even_numbers([1, 3, 5, 7]) 0 >>> sum_even_numbers([]) 0 >>> sum_even_numbers([1, 3, 5, 7, 9]) 0 >>> sum_even_numbers([4]) 4 >>> sum_even_numbers([7]) 0 # Your code here","solution":"def sum_even_numbers(arr): Returns the sum of all the even numbers in the array. If the array is empty or contains no even numbers, returns 0. return sum(num for num in arr if num % 2 == 0)"},{"question":"def categorize_grades(students: List[Tuple[str, int]]) -> Dict[str, List[str]]: Categorizes students into grade categories based on their grades. Parameters: students (list of tuples): A list where each tuple contains a student's name and their grade (0-100). Returns: dict: A dictionary with grade categories ('A', 'B', 'C', 'D', 'F') as keys and lists of student names as values. >>> students = [(\\"John\\", 95), (\\"Jane\\", 86), (\\"Doe\\", 72), (\\"Alice\\", 67), (\\"Bob\\", 59)] >>> categorize_grades(students) {'A': [\\"John\\"], 'B': [\\"Jane\\"], 'C': [\\"Doe\\"], 'D': [\\"Alice\\"], 'F': [\\"Bob\\"]} >>> students = [] >>> categorize_grades(students) {'A': [], 'B': [], 'C': [], 'D': [], 'F': []} >>> students = [(\\"John\\", 105), (\\"Jane\\", -5), (\\"Doe\\", \\"N/A\\"), (\\"Alice\\", 87)] >>> categorize_grades(students) {'A': [], 'B': [\\"Alice\\"], 'C': [], 'D': [], 'F': []} >>> students = [(\\"John\\", 90), (\\"Jane\\", 80), (\\"Doe\\", 70), (\\"Alice\\", 60), (\\"Bob\\", 0)] >>> categorize_grades(students) {'A': [\\"John\\"], 'B': [\\"Jane\\"], 'C': [\\"Doe\\"], 'D': [\\"Alice\\"], 'F': [\\"Bob\\"]}","solution":"def categorize_grades(students): Categorizes students into grade categories based on their grades. Parameters: students (list of tuples): A list where each tuple contains a student's name and their grade (0-100). Returns: dict: A dictionary with grade categories ('A', 'B', 'C', 'D', 'F') as keys and lists of student names as values. grade_categories = { 'A': [], 'B': [], 'C': [], 'D': [], 'F': [] } for name, grade in students: if not isinstance(grade, int) or not 0 <= grade <= 100: continue # Skip invalid grades if grade >= 90: grade_categories['A'].append(name) elif grade >= 80: grade_categories['B'].append(name) elif grade >= 70: grade_categories['C'].append(name) elif grade >= 60: grade_categories['D'].append(name) else: grade_categories['F'].append(name) return grade_categories"},{"question":"def find_anagrams(file_path: str) -> dict: Reads a list of words from a file and returns a dictionary of anagrams. :param file_path: Path to the input file containing one word per line :return: A dictionary where the keys are sorted characters and the values are lists of anagrams >>> find_anagrams(\\"words.txt\\") { \\"eilnst\\": [\\"listen\\", \\"silent\\", \\"enlist\\"], \\"aaabnn\\": [\\"banana\\"] } >>> find_anagrams(\\"empty.txt\\") {} >>> find_anagrams(\\"special_chars.txt\\") { \\"dimoorrty\\": [\\"dormitory\\"], \\" dimoorrty\\": [\\"dirty room\\"] } >>> find_anagrams(\\"different_lengths.txt\\") { \\"abc\\": [\\"abc\\", \\"bca\\", \\"cba\\"], \\"a\\": [\\"a\\"], \\"aa\\": [\\"aa\\"] }","solution":"def find_anagrams(file_path): Reads a list of words from a file and returns a dictionary of anagrams. :param file_path: Path to the input file containing one word per line :return: A dictionary where the keys are sorted characters and the values are lists of anagrams from collections import defaultdict anagram_dict = defaultdict(list) with open(file_path, \\"r\\") as file: for line in file: word = line.strip() sorted_word = \\"\\".join(sorted(word)) anagram_dict[sorted_word].append(word) return anagram_dict"},{"question":"def count_alphabets(s: str) -> dict: Returns a dictionary with the count of each alphabet present in the string. The function is case-insensitive and ignores non-alphabet characters. >>> count_alphabets(\\"Hello World!\\") == { 'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1 } >>> count_alphabets(\\"Python 3.8\\") == { 'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1 } >>> count_alphabets(\\"\\") == {}","solution":"def count_alphabets(s: str) -> dict: Returns a dictionary with the count of each alphabet present in the string. The function is case-insensitive and ignores non-alphabet characters. from collections import Counter # Normalize the string to lowercase and filter out non-alphabet characters filtered_string = ''.join([char.lower() for char in s if char.isalpha()]) # Use Counter to count the occurrences of each character return dict(Counter(filtered_string))"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing non-negative integers and the operators +, -, *, /. Ensure correct order of precedence and handle parentheses. Args: expression (str): A string representing a valid mathematical expression. Returns: int: The result of evaluating the given expression. Examples: >>> evaluate_expression(\\"3 + 6 * (5 + 4) / 3 - 7\\") 14 >>> evaluate_expression(\\"10 + 2 * 6\\") 22 >>> evaluate_expression(\\"100 * 2 + 12\\") 212 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100 def test_evaluate_expression_simple_add(): assert evaluate_expression(\\"10 + 2\\") == 12 def test_evaluate_expression_add_and_multiply(): assert evaluate_expression(\\"10 + 2 * 6\\") == 22 def test_evaluate_expression_with_parentheses(): assert evaluate_expression(\\"3 + 6 * (5 + 4) / 3 - 7\\") == 14 def test_evaluate_expression_add_multiply(): assert evaluate_expression(\\"100 * 2 + 12\\") == 212 def test_evaluate_expression_complex_parentheses(): assert evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100 def test_evaluate_expression_nested_parentheses(): assert evaluate_expression(\\"((2+3)*(5+5))/5\\") == 10 def test_evaluate_expression_division(): assert evaluate_expression(\\"20 / 5 + 3\\") == 7 def test_evaluate_expression_large_numbers(): assert evaluate_expression(\\"1000000 + 2000000 * 3\\") == 7000000 def test_evaluate_expression_mixed_operations(): assert evaluate_expression(\\"50 + 10 * 4 / 2 - 6\\") == 64","solution":"def evaluate_expression(expression: str) -> int: def helper(tokens): stack = [] num = 0 sign = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == '(': num = helper(tokens) if token in '+-*/' or not tokens or token == ')': if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) num = 0 if token == ')': break sign = token return sum(stack) tokens = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = '' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 tokens.append(num) elif expression[i] in '+-*/()': tokens.append(expression[i]) i += 1 else: i += 1 return helper(tokens)"},{"question":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Takes an array of integers and a target sum as input and returns all unique combinations of numbers from the array that add up to the target sum. Each number from the array can be used zero or more times to form the combinations. The solution set must not contain duplicate combinations. >>> combination_sum([2, 3, 6, 7], 7) # returns [[2, 2, 3], [7]] >>> combination_sum([2, 4], 5) # returns [] >>> combination_sum([2, 3, 5], 8) # returns [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([3], 9) # returns [[3, 3, 3]] >>> combination_sum([], 7) # returns []","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Returns all unique combinations of numbers from the candidates array that add up to the target. Each number from the array can be used zero or more times. result = [] def backtrack(remain, combo, start): if remain == 0: result.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() candidates.sort() backtrack(target, [], 0) return result # Example usage if __name__ == \\"__main__\\": candidates = [2, 3, 6, 7] target = 7 print(combination_sum(candidates, target)) # Output: [[2, 2, 3], [7]]"},{"question":"def interleave_lists(list1, list2): Returns a list where elements from list1 and list2 are interleaved. Assumes both lists are of equal length. Args: list1: The first list containing elements. list2: The second list containing elements. Returns: A list containing elements from list1 and list2 interleaved. Raises: ValueError: If the input lists are not of equal length. Examples: >>> interleave_lists([1, 2, 3], ['a', 'b', 'c']) [1, 'a', 2, 'b', 3, 'c'] >>> interleave_lists(['x', 'y'], [10, 20]) ['x', 10, 'y', 20]","solution":"def interleave_lists(list1, list2): Returns a list where elements from list1 and list2 are interleaved. Assumes both lists are of equal length. if len(list1) != len(list2): raise ValueError(\\"Both lists must have the same length\\") interleaved_list = [] for i in range(len(list1)): interleaved_list.append(list1[i]) interleaved_list.append(list2[i]) return interleaved_list"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. :param head: ListNode, the head of the singly linked list. :return: ListNode, the new head of the reversed linked list. >>> list_to_linked_list = lambda lst: None if not lst else (lambda head, *tail: lambda accum: accum(head, *tail))(ListNode(lst[0]), *lst[1:])(lambda h, *ts: h if not ts else [setattr(h, 'next', t) for t in (ts[0],)][0] or list_to_linked_list(ts.__iter__())[-1] or h) >>> linked_list_to_list = lambda node: [] if not node else [node.value] + linked_list_to_list(node.next) >>> linked_list_to_list(reverse_linked_list(None)) [] >>> linked_list_to_list(reverse_linked_list(list_to_linked_list([1]))) [1] >>> linked_list_to_list(reverse_linked_list(list_to_linked_list([1, 2]))) [2, 1] >>> linked_list_to_list(reverse_linked_list(list_to_linked_list([1, 2, 3, 4, 5]))) [5, 4, 3, 2, 1]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head): Reverses a singly linked list. :param head: ListNode, the head of the singly linked list. :return: ListNode, the new head of the reversed linked list. prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"from typing import Dict def count_unique_chars(s: str) -> Dict[str, int]: Takes a string as input and returns a dictionary with the count of each unique character in the string, ignoring case sensitivity and excluding non-alphabetic characters. >>> count_unique_chars(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_unique_chars(\\"Hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_unique_chars(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_unique_chars(\\"\\") {} >>> count_unique_chars(\\"12345 ^&*()!\\") {} >>> count_unique_chars(\\"aaBBccDD\\") {'a': 2, 'b': 2, 'c': 2, 'd': 2}","solution":"def count_unique_chars(s): Takes a string as input and returns a dictionary with the count of each unique character in the string, ignoring case sensitivity and excluding non-alphabetic characters. s = s.lower() char_count = {} for char in s: if char.isalpha(): if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines whether s2 is an anagram of s1. An anagram of a string is another string that contains the same characters, only the order of characters can be different. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"triangle\\", \\"integral\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False >>> is_anagram(\\"hello\\", \\"billion\\") False >>> is_anagram(\\"aabbcc\\", \\"abcabc\\") True >>> is_anagram(\\"aabbc\\", \\"aabbcc\\") False >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"Listen\\", \\"Silent\\") False >>> is_anagram(\\"listen\\", \\"LiSteN\\") False","solution":"def is_anagram(s1, s2): Determines whether s2 is an anagram of s1. :param s1: First string :param s2: Second string :return: True if s2 is an anagram of s1, False otherwise # If lengths of s1 and s2 aren't the same, s2 can't be an anagram of s1 if len(s1) != len(s2): return False # Count frequencies of each character in both strings char_count_s1 = {} char_count_s2 = {} for char in s1: char_count_s1[char] = char_count_s1.get(char, 0) + 1 for char in s2: char_count_s2[char] = char_count_s2.get(char, 0) + 1 # Compare the frequency dictionaries return char_count_s1 == char_count_s2"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. The expression can include positive integers, +, -, *, / operators, and parentheses, with consideration of operator precedence (BODMAS/BIDMAS). >>> evaluate_expression(\\"3 + 4\\") == 7.0 >>> evaluate_expression(\\"10 - 2\\") == 8.0 >>> evaluate_expression(\\"6 * 3\\") == 18.0 >>> evaluate_expression(\\"8 / 2\\") == 4.0 >>> evaluate_expression(\\"3 + 5 * 2\\") == 13.0 >>> evaluate_expression(\\"3 + ( 2 + 1 )\\") == 6.0 >>> evaluate_expression(\\"3 + 5 * 2 / ( 8 - 3 )\\") == 5.0 >>> evaluate_expression(\\" 3 + 5 * 2 / ( 8 - 3 ) \\") == 5.0 >>> evaluate_expression(\\"(1 + (2 * 3))\\") == 7.0 >>> evaluate_expression(\\"100 / 2 / 5\\") == 10.0 # Function implementation","solution":"import re def evaluate_expression(expression): Evaluates a mathematical expression and returns the result as a float. The expression can include positive integers, +, -, *, / operators, and parentheses, with consideration of operator precedence (BODMAS/BIDMAS). def parse_tokens(expression): Parses an expression string into tokens (numbers, operators, and parentheses) return re.findall(r'd+.?d*|[-+*/()]', expression) def precedence(op): Returns the precedence of the operators. if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operation(a, b, op): Applies an arithmetic operation to two numbers. if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a / b def evaluate(tokens): Evaluates a list of tokens to compute the result of the expression. values = [] ops = [] def perform_operation(): Performs the last operation on the two topmost values. b = values.pop() a = values.pop() op = ops.pop() values.append(apply_operation(a, b, op)) i = 0 while i < len(tokens): token = tokens[i] if token.isdigit() or '.' in token: # if the token is a number values.append(float(token)) elif token == '(': ops.append(token) elif token == ')': while ops and ops[-1] != '(': perform_operation() ops.pop() # Remove '(' from stack elif token in '+-*/': while (ops and precedence(ops[-1]) >= precedence(token)): perform_operation() ops.append(token) i += 1 while ops: perform_operation() return values[-1] tokens = parse_tokens(expression) return evaluate(tokens)"},{"question":"class Warehouse: A class to manage a simple warehouse inventory system. Attributes: inventory (dict): A dictionary where keys are item names and values are tuples of (quantity, price per unit). Methods: __init__(self): Initializes an empty inventory. add_item(self, item_name, quantity, price): Adds the specified quantity of an item to the inventory. If the item already exists, it should update the quantity and price. remove_item(self, item_name, quantity): Removes the specified quantity of an item from the inventory. If the quantity to remove is more than exists, it should throw an exception. get_stock(self, item_name): Returns the current stock of the item (quantity and price). If the item does not exist, return a message indicating that. total_value(self): Calculates and returns the total value of all items in the inventory. list_items(self): Lists all items in the inventory with their quantities and prices. import_items(self, item_list): Imports a list of items into the inventory where each item is represented as a tuple (item_name, quantity, price). Ensures proper error handling for potential issues like negative quantities or prices. Usage example: >>> warehouse = Warehouse() >>> warehouse.add_item(\\"Laptop\\", 10, 999.99) >>> warehouse.add_item(\\"Smartphone\\", 50, 499.99) >>> print(warehouse.get_stock(\\"Laptop\\")) (10, 999.99) >>> print(warehouse.total_value()) 30998.5 >>> warehouse.remove_item(\\"Smartphone\\", 5) >>> print(warehouse.get_stock(\\"Smartphone\\")) (45, 499.99) >>> items_to_import = [(\\"Headphone\\", 20, 49.99), (\\"Charger\\", 100, 19.99)] >>> warehouse.import_items(items_to_import) >>> print(warehouse.list_items()) [(\\"Laptop\\", 10, 999.99), (\\"Smartphone\\", 45, 499.99), (\\"Headphone\\", 20, 49.99), (\\"Charger\\", 100, 19.99)] def __init__(self): pass def add_item(self, item_name, quantity, price): pass def remove_item(self, item_name, quantity): pass def get_stock(self, item_name): pass def total_value(self): pass def list_items(self): pass def import_items(self, item_list): pass import pytest def test_initialize_warehouse(): warehouse = Warehouse() assert warehouse.inventory == {} def test_add_single_item(): warehouse = Warehouse() warehouse.add_item(\\"Laptop\\", 10, 999.99) assert warehouse.get_stock(\\"Laptop\\") == (10, 999.99) def test_add_existing_item(): warehouse = Warehouse() warehouse.add_item(\\"Laptop\\", 10, 999.99) warehouse.add_item(\\"Laptop\\", 5, 999.99) assert warehouse.get_stock(\\"Laptop\\") == (15, 999.99) def test_remove_item(): warehouse = Warehouse() warehouse.add_item(\\"Laptop\\", 10, 999.99) warehouse.remove_item(\\"Laptop\\", 5) assert warehouse.get_stock(\\"Laptop\\") == (5, 999.99) def test_remove_item_insufficient_quantity(): warehouse = Warehouse() warehouse.add_item(\\"Laptop\\", 5, 999.99) with pytest.raises(ValueError): warehouse.remove_item(\\"Laptop\\", 10) def test_remove_item_not_in_inventory(): warehouse = Warehouse() with pytest.raises(KeyError): warehouse.remove_item(\\"Tablet\\", 1) def test_get_stock_item_not_in_inventory(): warehouse = Warehouse() assert warehouse.get_stock(\\"Smartphone\\") == \\"Item Smartphone not found in inventory.\\" def test_total_value(): warehouse = Warehouse() warehouse.add_item(\\"Laptop\\", 10, 1000.0) warehouse.add_item(\\"Smartphone\\", 5, 500.0) assert warehouse.total_value() == 12500.0 def test_list_items(): warehouse = Warehouse() warehouse.add_item(\\"Laptop\\", 10, 1000.0) warehouse.add_item(\\"Smartphone\\", 5, 500.0) assert warehouse.list_items() == [(\\"Laptop\\", 10, 1000.0), (\\"Smartphone\\", 5, 500.0)] def test_import_items(): warehouse = Warehouse() item_list = [(\\"Laptop\\", 10, 999.99), (\\"Smartphone\\", 5, 499.99)] warehouse.import_items(item_list) assert warehouse.get_stock(\\"Laptop\\") == (10, 999.99) assert warehouse.get_stock(\\"Smartphone\\") == (5, 499.99) def test_import_items_with_negative_quantity(): warehouse = Warehouse() item_list = [(\\"Laptop\\", -10, 999.99)] with pytest.raises(ValueError): warehouse.import_items(item_list) def test_import_items_with_negative_price(): warehouse = Warehouse() item_list = [(\\"Laptop\\", 10, -999.99)] with pytest.raises(ValueError): warehouse.import_items(item_list) def test_add_item_negative_quantity(): warehouse = Warehouse() with pytest.raises(ValueError): warehouse.add_item(\\"Laptop\\", -3, 999.99) def test_add_item_negative_price(): warehouse = Warehouse() with pytest.raises(ValueError): warehouse.add_item(\\"Laptop\\", 3, -999.99) def test_remove_item_negative_quantity(): warehouse = Warehouse() warehouse.add_item(\\"Laptop\\", 10, 999.99) with pytest.raises(ValueError): warehouse.remove_item(\\"Laptop\\", -5)","solution":"class Warehouse: def __init__(self): self.inventory = {} def add_item(self, item_name, quantity, price): if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price must be non-negative.\\") if item_name in self.inventory: current_quantity, _ = self.inventory[item_name] self.inventory[item_name] = (current_quantity + quantity, price) else: self.inventory[item_name] = (quantity, price) def remove_item(self, item_name, quantity): if item_name not in self.inventory: raise KeyError(f\\"Item {item_name} not found in inventory.\\") current_quantity, price = self.inventory[item_name] if quantity > current_quantity: raise ValueError(f\\"Cannot remove {quantity} units. Only {current_quantity} available.\\") if quantity < 0: raise ValueError(\\"Quantity to remove must be non-negative.\\") self.inventory[item_name] = (current_quantity - quantity, price) if self.inventory[item_name][0] == 0: del self.inventory[item_name] def get_stock(self, item_name): if item_name in self.inventory: return self.inventory[item_name] return f\\"Item {item_name} not found in inventory.\\" def total_value(self): return sum(quantity * price for quantity, price in self.inventory.values()) def list_items(self): return [(item, quantity, price) for item, (quantity, price) in self.inventory.items()] def import_items(self, item_list): for item_name, quantity, price in item_list: if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price must be non-negative.\\") self.add_item(item_name, quantity, price)"},{"question":"def max_water_container(heights: list) -> int: Returns the maximum amount of water that can be contained between any two lines. >>> max_water_container([1,8,6,2,5,4,8,3,7]) 49 >>> max_water_container([1,1]) 1 >>> max_water_container([4,3,2,1,4]) 16 >>> max_water_container([1,2,1]) 2","solution":"def max_water_container(heights: list) -> int: Returns the maximum amount of water that can be contained between any two lines. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def nodes_at_distance_k(root: TreeNode, target: TreeNode, k: int) -> List[int]: Find all nodes at a distance \`k\` from the target node in a binary tree. Args: root (TreeNode): The root of the binary tree. target (TreeNode): The target node. k (int): The distance from the target node. Returns: List[int]: A list of values of the nodes that are exactly \`k\` distance away from the target node. Example: >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> target = root.left # Node with value 5 >>> distance = 2 >>> nodes_at_distance_k(root, target, distance) [7, 4, 1] pass","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def nodes_at_distance_k(root: TreeNode, target: TreeNode, k: int) -> list: from collections import defaultdict, deque def buildGraph(node, parent = None): if node: if parent: graph[node.val].append(parent.val) graph[parent.val].append(node.val) if node.left: buildGraph(node.left, node) if node.right: buildGraph(node.right, node) graph = defaultdict(list) buildGraph(root) queue = deque([(target.val, 0)]) visited = {target.val} result = [] while queue: currentNode, currentDist = queue.popleft() if currentDist == k: result.append(currentNode) elif currentDist < k: for neighbor in graph[currentNode]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, currentDist + 1)) return result"},{"question":"def count_characters(s: str) -> dict: Returns a dictionary with the characters in the string as keys and the number of times they appear as values. >>> count_characters(\\"abc\\") {'a': 1, 'b': 1, 'c': 1} >>> count_characters(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> count_characters(\\"aabbccc\\") {'a': 2, 'b': 2, 'c': 3} >>> count_characters(\\"a b c\\") {'a': 1, ' ': 2, 'b': 1, 'c': 1} >>> count_characters(\\"\\") {} >>> count_characters(\\"a!@#a!@#\\") {'a': 2, '!': 2, '@': 2, '#': 2} >>> count_characters(\\"aAaA\\") {'a': 2, 'A': 2}","solution":"def count_characters(s): Returns a dictionary with the characters in the string as keys and the number of times they appear as values. character_count = {} for character in s: if character in character_count: character_count[character] += 1 else: character_count[character] = 1 return character_count"},{"question":"import heapq class Graph: def __init__(self): self.nodes = set() self.edges = dict() def add_node(self, value): Adds a node to the graph. >>> g = Graph() >>> g.add_node('A') self.nodes.add(value) if value not in self.edges: self.edges[value] = [] def add_edge(self, from_node, to_node, weight): Adds a directed edge to the graph. >>> g = Graph() >>> g.add_node('A') >>> g.add_node('B') >>> g.add_edge('A', 'B', 1) self.edges[from_node].append((to_node, weight)) def dijkstra(graph, start, goal): Finds the shortest path in a weighted graph using Dijkstra's algorithm. >>> g = Graph() >>> g.add_node('A') >>> g.add_node('B') >>> g.add_edge('A', 'B', 1) >>> dijkstra(g, 'A', 'B') ['A', 'B'] >>> g = Graph() >>> g.add_node('A') >>> g.add_node('B') >>> g.add_node('C') >>> g.add_edge('A', 'B', 1) >>> g.add_edge('B', 'C', 2) >>> dijkstra(g, 'A', 'C') ['A', 'B', 'C'] queue = [] heapq.heappush(queue, (0, start)) distances = {node: float('infinity') for node in graph.nodes} distances[start] = 0 shortest_path = {} while queue: current_distance, current_node = heapq.heappop(queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph.edges[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) shortest_path[neighbor] = current_node path = [] node = goal while node != start: path.insert(0, node) if node in shortest_path: node = shortest_path[node] else: return None path.insert(0, start) return path","solution":"import heapq class Graph: def __init__(self): self.nodes = set() self.edges = dict() def add_node(self, value): self.nodes.add(value) if value not in self.edges: self.edges[value] = [] def add_edge(self, from_node, to_node, weight): self.edges[from_node].append((to_node, weight)) def dijkstra(graph, start, goal): queue = [] heapq.heappush(queue, (0, start)) distances = {node: float('infinity') for node in graph.nodes} distances[start] = 0 shortest_path = {} while queue: current_distance, current_node = heapq.heappop(queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph.edges[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) shortest_path[neighbor] = current_node path = [] node = goal while node != start: path.insert(0, node) if node in shortest_path: node = shortest_path[node] else: return None path.insert(0, start) return path"},{"question":"class Stack: A class that simulates the basic operations of a stack data structure. The stack supports the following operations: - push(element): Add an element to the top of the stack. - pop(): Remove the top element from the stack and return it. If the stack is empty, return None. - peek(): Return the top element of the stack without removing it. If the stack is empty, return None. - is_empty(): Return True if the stack is empty, else return False. def __init__(self): pass def push(self, element): pass def pop(self): pass def peek(self): pass def is_empty(self): pass","solution":"class Stack: def __init__(self): self.stack = [] def push(self, element): self.stack.append(element) def pop(self): if self.is_empty(): return None return self.stack.pop() def peek(self): if self.is_empty(): return None return self.stack[-1] def is_empty(self): return len(self.stack) == 0"},{"question":"def has_cycle(graph): Returns True if there is a cycle in the graph, else False. Parameters: - graph: a dictionary representing the adjacency list of the graph Returns: - Boolean value indicating the presence of a cycle pass from solution import has_cycle def test_cyclic_graph(): graph1 = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [] } assert has_cycle(graph1) == True def test_acyclic_graph(): graph2 = { 0: [1, 2], 1: [2], 2: [3], 3: [4], 4: [] } assert has_cycle(graph2) == False def test_single_node_no_cycle(): graph3 = { 0: [] } assert has_cycle(graph3) == False def test_single_node_with_cycle(): graph4 = { 0: [0] } assert has_cycle(graph4) == True def test_disconnected_graph_with_cycle(): graph5 = { 0: [1], 1: [2], 2: [0], 3: [4], 4: [] } assert has_cycle(graph5) == True def test_disconnected_graph_no_cycle(): graph6 = { 0: [1], 1: [], 2: [3], 3: [] } assert has_cycle(graph6) == False","solution":"def has_cycle(graph): Returns True if there is a cycle in the graph, else False. Parameters: - graph: a dictionary representing the adjacency list of the graph Returns: - Boolean value indicating the presence of a cycle visited = set() rec_stack = set() def is_cyclic(v): visited.add(v) rec_stack.add(v) for neighbour in graph[v]: if neighbour not in visited: if is_cyclic(neighbour): return True elif neighbour in rec_stack: return True rec_stack.remove(v) return False for node in graph: if node not in visited: if is_cyclic(node): return True return False"},{"question":"def trap(height: List[int]) -> int: Given an array of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. :param height: List[int] :return: int >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([1,1,1,1]) == 0 >>> trap([]) == 0 >>> trap([4,3,2,1]) == 0 >>> trap([4,1,4]) == 3 >>> trap([4]) == 0 >>> trap([4,1]) == 0","solution":"def trap(height): Given an array of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. :param height: List[int] :return: int if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def my_decorator(func): This decorator adds some behavior before and after the execution of the function it decorates. def wrapper(): print(\\"Something is happening before the function is called.\\") func() print(\\"Something is happening after the function is called.\\") return wrapper @my_decorator def say_hello(): Prints 'Hello!'. print(\\"Hello!\\") # Explanation: # 1. The \`my_decorator\` function takes a function \`func\` as an argument and returns a new function \`wrapper\` that adds some behavior before and after calling \`func\`. # 2. The \`@\` symbol before the \`say_hello\` function is used to apply the \`my_decorator\` function to \`say_hello\`, meaning that \`say_hello\` will be replaced by the wrapped version. # 3. When the \`say_hello\` function is called, the output will be: # Something is happening before the function is called. # Hello! # Something is happening after the function is called.","solution":"def my_decorator(func): This decorator adds some behavior before and after the execution of the function it decorates. def wrapper(): print(\\"Something is happening before the function is called.\\") func() print(\\"Something is happening after the function is called.\\") return wrapper @my_decorator def say_hello(): Prints 'Hello!'. print(\\"Hello!\\") # Call the decorated function say_hello() # Explanation: # 1. The \`my_decorator\` function takes a function \`func\` as an argument and returns a new function \`wrapper\` that adds some behavior before and after calling \`func\`. # 2. The \`@\` symbol before the \`say_hello\` function is used to apply the \`my_decorator\` function to \`say_hello\`, meaning that \`say_hello\` will be replaced by the wrapped version. # 3. When the \`say_hello\` function is called, the output will be: # Something is happening before the function is called. # Hello! # Something is happening after the function is called."},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns indices of the two numbers in the array such that they add up to the target. :param nums: List[int], list of integers :param target: int, target sum :return: Tuple[int, int], tuple of indices >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([0, 4, 3, 0], 0) (0, 3) >>> two_sum([3, 3], 6) (0, 1)","solution":"def two_sum(nums, target): Returns indices of the two numbers in the array such that they add up to the target. :param nums: List[int], list of integers :param target: int, target sum :return: Tuple[int, int], tuple of indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i # Example array and target result = two_sum([2, 7, 11, 15], 9)"},{"question":"def is_anagram_of_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. >>> is_anagram_of_palindrome(\\"\\") True >>> is_anagram_of_palindrome(\\"a\\") True >>> is_anagram_of_palindrome(\\"abba\\") True >>> is_anagram_of_palindrome(\\"racecar\\") True >>> is_anagram_of_palindrome(\\"hello\\") False >>> is_anagram_of_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_anagram_of_palindrome(\\"carerac\\") True >>> is_anagram_of_palindrome(\\"random\\") False >>> is_anagram_of_palindrome(\\"aaaa\\") True >>> is_anagram_of_palindrome(\\"aaab\\") False","solution":"def is_anagram_of_palindrome(s): Determines if the input string can be rearranged to form a palindrome. :param s: The input string :return: True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter # Filter out non-alphabetic characters and convert to lowercase filtered_s = ''.join(filter(str.isalpha, s)).lower() # Count the frequency of each character char_counts = Counter(filtered_s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in char_counts.values() if count % 2 == 1) # A string can be rearranged into a palindrome if it has at most one odd character count return odd_count <= 1"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing positive integers, operators +, -, *, /, and parentheses, following the proper order of operations. Returns \\"Error: Division by zero\\" for division by zero errors. Args: expression (str): The mathematical expression to evaluate. Returns: int/float/str: The result of the evaluated expression or \\"Error: Division by zero\\" for division by zero errors.","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing positive integers, operators +, -, *, /, and parentheses, following the proper order of operations. Args: expression (str): The mathematical expression to evaluate. Returns: int/float/str: The result of the evaluated expression or \\"Error: Division by zero\\" for division by zero errors. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operator(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': if right == 0: return \\"Error: Division by zero\\" values.append(left / right) def evaluate(expression): if expression == \\"\\": return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': result = apply_operator(operators, values) if result == \\"Error: Division by zero\\": return result operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): result = apply_operator(operators, values) if result == \\"Error: Division by zero\\": return result operators.append(expression[i]) i += 1 while len(operators) != 0: result = apply_operator(operators, values) if result == \\"Error: Division by zero\\": return result return values[-1] return int(evaluate(expression)) if isinstance(evaluate(expression), (int, float)) else evaluate(expression)"},{"question":"def find_kth_largest(arr: List[int], k: int) -> int: Given an unsorted array of integers, find the Kth largest element in the array without using built-in sorting functions. The function should run in O(n) average time complexity. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([1, 1, 1, 1, 1], 3) 1 >>> find_kth_largest([7, 6, 5, 4, 3, 2, 1], 7) 1 >>> find_kth_largest([7, 6, 5, 4, 3, 2, 1], 8) Traceback (most recent call last): ... ValueError: Index out of bounds","solution":"def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] >= pivot: # We use >= to arrange in non-increasing order i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low <= high: pi = partition(arr, low, high) if pi == k: return arr[pi] elif pi < k: return quickselect(arr, pi + 1, high, k) else: return quickselect(arr, low, pi - 1, k) raise ValueError(\\"Index out of bounds\\") def find_kth_largest(arr, k): n = len(arr) return quickselect(arr, 0, n - 1, k - 1)"},{"question":"def longest_substring_k_unique(s: str, k: int) -> str: Return the longest substring with exactly k unique characters. If multiple substrings have the same maximum length, return the one that appears first. If no such substring exists, return an empty string. Parameters: - s (str): The input string where the substring is to be found. - k (int): The exact number of unique characters required in the substring. Returns: - str: The longest substring with exactly k unique characters, or an empty string if none exists. >>> longest_substring_k_unique(\\"aabbcc\\", 2) 'aabb' >>> longest_substring_k_unique(\\"aaaaa\\", 1) 'aaaaa' >>> longest_substring_k_unique(\\"abcdefg\\", 0) '' >>> longest_substring_k_unique(\\"abcd\\", 5) '' >>> longest_substring_k_unique(\\"abcdef\\", 6) 'abcdef' >>> longest_substring_k_unique(\\"aabacbebebe\\", 3) 'cbebebe' >>> longest_substring_k_unique(\\"aaabbbccc\\", 2) 'aaabbb'","solution":"def longest_substring_k_unique(s: str, k: int) -> str: Return the longest substring with exactly k unique characters. If multiple substrings have the same maximum length, return the one that appears first. If no such substring exists, return an empty string. Parameters: - s (str): The input string where the substring is to be found. - k (int): The exact number of unique characters required in the substring. Returns: - str: The longest substring with exactly k unique characters, or an empty string if none exists. from collections import defaultdict n = len(s) if n == 0 or k == 0: return \\"\\" left = 0 right = 0 max_len = 0 max_substring = \\"\\" char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: current_len = right - left + 1 if current_len > max_len: max_len = current_len max_substring = s[left:right+1] right += 1 return max_substring"},{"question":"from typing import List def max_consecutive_sum(arr: List[int], k: int) -> int: Write a function that takes an integer array and an integer k, and returns the maximum sum of k consecutive elements in the array. >>> max_consecutive_sum([1, 2, 5, 2, 8, 1, 5], 2) 10 >>> max_consecutive_sum([4, 2, 1, 6, 2], 3) 9 >>> max_consecutive_sum([5], 1) 5 >>> max_consecutive_sum([5], 2) 0 >>> max_consecutive_sum([], 1) 0 >>> max_consecutive_sum([-1, -2, -3, -4, -5], 2) -3 >>> max_consecutive_sum([-1, -2, -3, -4, -5], 3) -6 >>> max_consecutive_sum([1, -2, 3, -4, 5], 2) 1 >>> max_consecutive_sum([1, -2, 3, -4, 5], 3) 4 >>> max_consecutive_sum([1, 2, 3, 4, 5], 5) 15 >>> max_consecutive_sum([1, 2, 3, 4, 5], 6) 0 >>> max_consecutive_sum([4, 2, 1, 6, 2], 1) 6 >>> max_consecutive_sum([-1, -2, -3, -4, -5], 1) -1","solution":"from typing import List def max_consecutive_sum(arr: List[int], k: int) -> int: # Edge cases: if k is greater than the length of the array or k is less than 1 if not arr or k > len(arr) or k < 1: return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum = current_sum + arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def k_largest_elements(lst: List[int], k: int) -> List[int]: Returns the k largest elements from the list in descending order. Parameters: lst (list of int): The list of integers. k (int): The number of largest elements to return. Returns: list of int: The k largest elements in descending order. >>> k_largest_elements([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3) [9, 6, 5] >>> k_largest_elements([10, 20, 30, 40, 50], 2) [50, 40] >>> k_largest_elements([4, 4, 4, 4, 4, 4, 4], 2) [4, 4] >>> k_largest_elements([7, 10, 4, 3, 20, 15], 6) [20, 15, 10, 7, 4, 3] >>> k_largest_elements([1], 1) [1] >>> k_largest_elements([1, 5, 3, 8], 1) [8] >>> k_largest_elements([1, -5, 3, -8, 4], 3) [4, 3, 1]","solution":"import heapq def k_largest_elements(lst, k): Returns the k largest elements from the list in descending order. Parameters: lst (list of int): The list of integers. k (int): The number of largest elements to return. Returns: list of int: The k largest elements in descending order. # Use heapq.nlargest to find the k largest elements largest_elements = heapq.nlargest(k, lst) return largest_elements"},{"question":"def first_non_repeated_character(s: str) -> str: Returns the first non-repeated character in a string. If all characters are repeated, returns an empty string. >>> first_non_repeated_character(\\"swiss\\") \\"w\\" >>> first_non_repeated_character(\\"aabbcc\\") \\"\\" from solution import first_non_repeated_character def test_first_non_repeated_character(): assert first_non_repeated_character(\\"swiss\\") == \\"w\\" assert first_non_repeated_character(\\"aabbcc\\") == \\"\\" assert first_non_repeated_character(\\"aabbc\\") == \\"c\\" assert first_non_repeated_character(\\"aabbbc\\") == \\"c\\" assert first_non_repeated_character(\\"abcd\\") == \\"a\\" assert first_non_repeated_character(\\"\\") == \\"\\" assert first_non_repeated_character(\\"a\\") == \\"a\\" assert first_non_repeated_character(\\"abacabad\\") == \\"c\\" assert first_non_repeated_character(\\"xxyz\\") == \\"y\\" assert first_non_repeated_character(\\"aabbccddef\\") == \\"e\\" assert first_non_repeated_character(\\"aabbccffeed\\") == \\"d\\"","solution":"def first_non_repeated_character(s): Returns the first non-repeated character in a string. If all characters are repeated, returns an empty string. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeated character for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"from typing import List, Tuple from collections import Counter def frequency_sort(nums: List[int]) -> List[Tuple[int, int]]: Create a Python function that takes a list of integers and returns a list of tuples, where each tuple contains an integer from the list and its frequency in the list, sorted in descending order by frequency. If two integers have the same frequency, they should be sorted in ascending order numerically. :param nums: List of integers :return: List of tuples (integer, frequency) >>> frequency_sort([4, 6, 2, 6, 6, 1, 4, 2]) [(6, 3), (4, 2), (2, 2), (1, 1)] >>> frequency_sort([]) [] >>> frequency_sort([10]) [(10, 1)] >>> frequency_sort([1, 1, 1]) [(1, 3)] >>> frequency_sort([1, 2, 3, 2, 3, 1]) [(1, 2), (2, 2), (3, 2)] >>> frequency_sort([9, 8, 7, 6, 5, 4, 3, 3, 2, 5]) [(3, 2), (5, 2), (2, 1), (4, 1), (6, 1), (7, 1), (8, 1), (9, 1)]","solution":"from collections import Counter def frequency_sort(nums): Returns a list of tuples where each tuple contains an integer from the list \`nums\` and its frequency in the list, sorted in descending order by frequency. If two integers have the same frequency, they are sorted in ascending order numerically. :param nums: List of integers :return: List of tuples (integer, frequency) counter = Counter(nums) return sorted(counter.items(), key=lambda x: (-x[1], x[0]))"},{"question":"from typing import List, Tuple def schedule_meeting(start_time: str, duration: int, meetings: List[Tuple[str, str]]) -> bool: Determines if a proposed meeting can be scheduled without overlapping any existing meetings. Args: start_time (str): Starting time of the meeting in 'HH:MM' 24-hour format. duration (int): Duration of the meeting in minutes. meetings (list): A list of tuples with each tuple containing start and end times of already scheduled meetings. Returns: bool: True if the meeting can be scheduled without overlapping, otherwise False. Examples: >>> meetings = [(\\"09:00\\", \\"09:30\\"), (\\"11:00\\", \\"11:30\\"), (\\"13:00\\", \\"13:45\\")] >>> schedule_meeting(\\"10:30\\", 30, meetings) True >>> schedule_meeting(\\"11:15\\", 45, meetings) False","solution":"from datetime import datetime, timedelta def schedule_meeting(start_time, duration, meetings): Determines if a proposed meeting can be scheduled without overlapping any existing meetings. Args: start_time (str): Starting time of the meeting in 'HH:MM' 24-hour format. duration (int): Duration of the meeting in minutes. meetings (list): A list of tuples with each tuple containing start and end times of already scheduled meetings. Returns: bool: True if the meeting can be scheduled without overlapping, otherwise False. # Convert the start_time to a datetime object new_meeting_start = datetime.strptime(start_time, '%H:%M') new_meeting_end = new_meeting_start + timedelta(minutes=duration) # Iterate through each existing meeting to check for overlaps for meeting_start, meeting_end in meetings: existing_meeting_start = datetime.strptime(meeting_start, '%H:%M') existing_meeting_end = datetime.strptime(meeting_end, '%H:%M') # Check if there is any overlap if new_meeting_start < existing_meeting_end and existing_meeting_start < new_meeting_end: return False # If no overlaps, return True return True"},{"question":"from typing import List, Dict def group_employees_by_department(employees: List[Dict]) -> Dict: Groups employees by their departments and sorts by salary in descending order. Args: employees (list): A list of dictionaries, each representing an employee with keys 'name', 'department', and 'salary'. Returns: dict: A dictionary where keys are department names and values are lists of dictionaries, each containing 'name' and 'salary' of employees, sorted by salary in descending order. pass def test_group_employees_by_department(): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"HR\\", \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\", \\"salary\\": 75000}, {\\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"salary\\": 100000} ] expected_output = { \\"HR\\": [{\\"name\\": \\"Charlie\\", \\"salary\\": 75000}, {\\"name\\": \\"Alice\\", \\"salary\\": 70000}], \\"Engineering\\": [{\\"name\\": \\"David\\", \\"salary\\": 100000}, {\\"name\\": \\"Bob\\", \\"salary\\": 90000}] } assert group_employees_by_department(employees) == expected_output def test_empty_list(): employees = [] expected_output = {} assert group_employees_by_department(employees) == expected_output def test_single_employee(): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"HR\\", \\"salary\\": 70000}, ] expected_output = { \\"HR\\": [{\\"name\\": \\"Alice\\", \\"salary\\": 70000}] } assert group_employees_by_department(employees) == expected_output def test_multiple_departments_and_salaries(): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"HR\\", \\"salary\\": 60000}, {\\"name\\": \\"Eve\\", \\"department\\": \\"HR\\", \\"salary\\": 70000}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\", \\"salary\\": 75000}, {\\"name\\": \\"Faythe\\", \\"department\\": \\"Engineering\\", \\"salary\\": 95000}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000} ] expected_output = { \\"HR\\": [{\\"name\\": \\"Charlie\\", \\"salary\\": 75000}, {\\"name\\": \\"Eve\\", \\"salary\\": 70000}, {\\"name\\": \\"Alice\\", \\"salary\\": 60000}], \\"Engineering\\": [{\\"name\\": \\"Faythe\\", \\"salary\\": 95000}, {\\"name\\": \\"Bob\\", \\"salary\\": 90000}] } assert group_employees_by_department(employees) == expected_output","solution":"def group_employees_by_department(employees): Groups employees by their departments and sorts by salary in descending order. Args: employees (list): A list of dictionaries, each representing an employee with keys 'name', 'department', and 'salary'. Returns: dict: A dictionary where keys are department names and values are lists of dictionaries, each containing 'name' and 'salary' of employees, sorted by salary in descending order. from collections import defaultdict department_dict = defaultdict(list) for employee in employees: department = employee[\\"department\\"] department_dict[department].append({\\"name\\": employee[\\"name\\"], \\"salary\\": employee[\\"salary\\"]}) # Sort by salary in descending order for department in department_dict: department_dict[department] = sorted(department_dict[department], key=lambda x: x['salary'], reverse=True) return dict(department_dict)"},{"question":"def find_longest_word(words: List[str]) -> str: Design a function \`find_longest_word\` that takes a list of words as input and returns the longest word in the list. If there are multiple words with the same maximum length, return the first one encountered in the list. Ensure the implementation is efficient and handles edge cases such as an empty list or a list with one element. >>> find_longest_word([]) == \\"\\" >>> find_longest_word([\\"apple\\"]) == \\"apple\\" >>> find_longest_word([\\"cat\\", \\"dog\\", \\"pig\\"]) == \\"cat\\" >>> find_longest_word([\\"lion\\", \\"zebra\\", \\"elephant\\", \\"cat\\"]) == \\"elephant\\" >>> find_longest_word([\\"ant\\", \\"bee\\", \\"chimp\\"]) == \\"chimp\\" >>> find_longest_word([\\" \\", \\"a\\", \\" \\"]) == \\" \\"","solution":"def find_longest_word(words): Returns the longest word in the list. If there are multiple words with the same maximum length, returns the first one encountered. Args: words (list of str): List of words. Returns: str: The longest word in the list. if not words: return \\"\\" longest_word = words[0] for word in words[1:]: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def max_subarray_sum(nums, k): Returns the maximum sum of a subarray of length k. Args: nums: List of integers. k: Integer, length of subarray. Returns: Integer, maximum sum of any subarray of length k. >>> max_subarray_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) == 39 >>> max_subarray_sum([-1, -2, -3, -4, -5, -6, -7, -8, -9], 3) == -6 >>> max_subarray_sum([5], 1) == 5 >>> max_subarray_sum([-2, -3, -4, -2, -1, -6], 2) == -3 >>> max_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 55 >>> max_subarray_sum([5, 1, 3, 7, -2, -1, 0, 12], 1) == 12 >>> max_subarray_sum([10**4, -10**4, 10**4, -10**4, 10**4], 2) == 0","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of a subarray of length k. Args: nums: List of integers. k: Integer, length of subarray. Returns: Integer, maximum sum of any subarray of length k. # Initialize the sum of the first window window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window over the array, compute sums efficiently for i in range(k, len(nums)): window_sum = window_sum + nums[i] - nums[i - k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the given string is a palindrome, ignoring non-alphanumeric characters and case. >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Random string!\\") == False def is_palindrome_erroneous(s: str) -> bool: Erroneous implementation that tries to solve the same problem. def is_alphanumeric(c: str) -> bool: return ('a' <= c <= 'z') or ('A' <= c <= 'Z') or ('0' <= c <= '9') def to_lower(c: str) -> str: if 'A' <= c <= 'Z': return chr(ord(c) + 32) return c cleaned = [] for char in s: if is_alphanumeric(char): cleaned.append(to_lower(char)) return cleaned == cleaned[::-1]","solution":"def is_palindrome(s): Returns True if the given string is a palindrome, ignoring non-alphanumeric characters and case. def is_alphanumeric(c): return ('a' <= c <= 'z') or ('A' <= c <= 'Z') or ('0' <= c <= '9') def to_lower(c): if 'A' <= c <= 'Z': return chr(ord(c) + 32) return c cleaned = [] for char in s: if is_alphanumeric(char): cleaned.append(to_lower(char)) left, right = 0, len(cleaned) - 1 while left < right: if cleaned[left] != cleaned[right]: return False left += 1 right -= 1 return True def is_palindrome_erroneous(s): Erroneous implementation that tries to solve the same problem. def is_alphanumeric(c): return ('a' <= c <= 'z') or ('A' <= c <= 'Z') or ('0' <= c <= '9') def to_lower(c): if 'A' <= c <= 'Z': return chr(ord(c) + 32) return c cleaned = [] for char in s: if is_alphanumeric(char): cleaned.append(to_lower(char)) return cleaned == cleaned[::-1] # Analyze and explain why the erroneous code doesn't work: # # The erroneous code will work correctly for checking if a string is a palindrome or not by comparing the cleaned list to its reverse. # The issue in this problem is that it uses built-in list slicing (cleaned[::-1]) which directly solves the problem by reversing the list. # This contravenes the requirement of not using built-in Python functions or libraries to solve the problem directly."},{"question":"def reorder_even_first(nums: List[int]) -> List[int]: Reorders a list by moving all the even numbers to the beginning followed by all the odd numbers, while preserving the relative order of the even numbers and the relative order of the odd numbers. Parameters: nums (List[int]): The input list of integers. Returns: List[int]: The reordered list. Examples: >>> reorder_even_first([5, 2, 8, 1, 4, 7, 6]) [2, 8, 4, 6, 5, 1, 7] >>> reorder_even_first([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> reorder_even_first([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] pass def test_with_mix_of_even_and_odd_numbers(): assert reorder_even_first([5, 2, 8, 1, 4, 7, 6]) == [2, 8, 4, 6, 5, 1, 7] def test_with_all_odd_numbers(): assert reorder_even_first([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9] def test_with_all_even_numbers(): assert reorder_even_first([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] def test_with_single_element_list(): assert reorder_even_first([1]) == [1] assert reorder_even_first([2]) == [2] def test_with_empty_list(): assert reorder_even_first([]) == [] def test_with_no_even_numbers(): assert reorder_even_first([9, 7, 5, 3, 1]) == [9, 7, 5, 3, 1] def test_with_no_odd_numbers(): assert reorder_even_first([0, 2, 4, 6, 8]) == [0, 2, 4, 6, 8] def test_with_large_mixture_numbers(): assert reorder_even_first([2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11]) == [2, 4, 6, 8, 10, 12, 1, 3, 5, 7, 9, 11] def test_with_repeated_numbers(): assert reorder_even_first([2, 1, 2, 1, 2, 1, 2, 1]) == [2, 2, 2, 2, 1, 1, 1, 1]","solution":"from typing import List def reorder_even_first(nums: List[int]) -> List[int]: Reorders a list by moving all the even numbers to the beginning followed by all the odd numbers, while preserving the relative order of the even numbers and the relative order of the odd numbers. Parameters: nums (List[int]): The input list of integers. Returns: List[int]: The reordered list. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def canPartitionIntoThreeEqualSumSubsets(arr: List[int]) -> bool: Given an array of integers, determine if it is possible to partition the array into three non-empty subsets such that the sum of the elements in each subset is equal. >>> canPartitionIntoThreeEqualSumSubsets([1, 2, 3, 4, 5, 6, 7, 8, 9]) True >>> canPartitionIntoThreeEqualSumSubsets([1, 1, 1, 1, 1, 1, 1, 1]) False >>> canPartitionIntoThreeEqualSumSubsets([3, 3, 3, 3, 3, 3]) True >>> canPartitionIntoThreeEqualSumSubsets([1]) False >>> canPartitionIntoThreeEqualSumSubsets([10000, -10000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1000, -1000, 100, -100, 10, -10, 20, -20]) False","solution":"from functools import lru_cache def canPartitionIntoThreeEqualSumSubsets(arr): if len(arr) < 3: return False total_sum = sum(arr) if total_sum % 3 != 0: return False target = total_sum // 3 n = len(arr) arr.sort(reverse=True) if arr[0] > target: return False @lru_cache(None) def dfs(i, subset_sums): if i == n: return subset_sums[0] == subset_sums[1] == subset_sums[2] == target for j in range(3): if subset_sums[j] + arr[i] <= target: new_sums = list(subset_sums) new_sums[j] += arr[i] if dfs(i + 1, tuple(new_sums)): return True return False return dfs(0, (0, 0, 0))"},{"question":"def filter_palindromes(strings: list) -> list: Create a function that accepts a list of strings and returns a new list containing only the strings that are palindromes. A palindrome is a string that reads the same forwards and backwards, ignoring case and non-alphanumeric characters. >>> filter_palindromes([\\"madam\\", \\"racecar\\", \\"apple\\", \\"Step on no pets\\", \\"Was it a car or a cat I saw\\", \\"No 'x' in Nixon\\"]) ['madam', 'racecar', 'Step on no pets', 'Was it a car or a cat I saw', 'No 'x' in Nixon'] >>> filter_palindromes([\\"apple\\", \\"banana\\", \\"cherry\\"]) [] >>> filter_palindromes([\\"madam\\", \\"apple\\", \\"racecar\\", \\"banana\\"]) ['madam', 'racecar'] >>> filter_palindromes([]) []","solution":"import re def is_palindrome(s: str) -> bool: # Remove non-alphanumeric characters and convert to lowercase clean_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Compare the cleaned string with its reverse return clean_s == clean_s[::-1] def filter_palindromes(strings: list) -> list: return [s for s in strings if is_palindrome(s)]"},{"question":"from typing import List def max_unique_anagrams(words: List[str]) -> str: Finds the word that forms the maximum number of unique anagrams. Args: words (List[str]): A list of words. Returns: str: The word with the maximum number of unique anagrams. >>> max_unique_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\", \\"Aabc\\"]) == \\"abc\\" >>> max_unique_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"silent\\"]) == \\"listen\\" >>> max_unique_anagrams([\\"one\\", \\"two\\", \\"three\\"]) == \\"one\\" >>> max_unique_anagrams([\\"abc\\", \\"bca\\", \\"CAB\\", \\"cba\\"]) == \\"abc\\" >>> max_unique_anagrams([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == \\"apple\\" >>> max_unique_anagrams([\\"evil\\", \\"vile\\", \\"live\\", \\"veil\\", \\"vile\\"]) == \\"evil\\"","solution":"from collections import defaultdict from typing import List def max_unique_anagrams(words: List[str]) -> str: Finds the word that forms the maximum number of unique anagrams. Args: words (List[str]): A list of words. Returns: str: The word with the maximum number of unique anagrams. anagram_dict = defaultdict(set) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].add(word) max_anagram_word = \\"\\" max_anagrams_count = 0 for word in words: sorted_word = ''.join(sorted(word)) current_count = len(anagram_dict[sorted_word]) if current_count > max_anagrams_count: max_anagram_word = word max_anagrams_count = current_count return max_anagram_word"},{"question":"import re from typing import List def reverse_vowels(s: str) -> str: Returns a new string with the vowels reversed while keeping other characters in their original positions. >>> reverse_vowels(\\"hello\\") \\"holle\\" >>> reverse_vowels(\\"leetcode\\") \\"leotcede\\" >>> reverse_vowels(\\"\\") \\"\\" >>> reverse_vowels(\\"bcdfg\\") \\"bcdfg\\" >>> reverse_vowels(\\"aeiou\\") \\"uoiea\\" >>> reverse_vowels(\\"AEIOU\\") \\"UOIEA\\" >>> reverse_vowels(\\"aA\\") \\"Aa\\" >>> reverse_vowels(\\"a\\") \\"a\\" >>> reverse_vowels(\\"b\\") \\"b\\"","solution":"def reverse_vowels(s): Returns a new string with the vowels reversed while keeping other characters in their original positions. vowels = set('aeiouAEIOU') s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] not in vowels: left += 1 elif s_list[right] not in vowels: right -= 1 else: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return ''.join(s_list)"},{"question":"def max_consecutive_vowels(s: str) -> int: Returns the maximum number of consecutive vowels in the string s. >>> max_consecutive_vowels(\\"earthquake\\") 2 >>> max_consecutive_vowels(\\"beautifully\\") 3 >>> max_consecutive_vowels(\\"rhythm\\") 0 >>> max_consecutive_vowels(\\"\\") 0 >>> max_consecutive_vowels(\\"aeiou\\") 5 >>> max_consecutive_vowels(\\"aeiomnp\\") 4 >>> max_consecutive_vowels(\\"prqaazoe\\") 2","solution":"def max_consecutive_vowels(s): Returns the maximum number of consecutive vowels in the string s. vowels = set('aeiou') max_count = 0 current_count = 0 for char in s: if char in vowels: current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"def first_non_repeated(string: str) -> str: Write a function that accepts a string and returns the first non-repeated character in the string. In case all characters are repeated, the function should return \`None\`. The function is case-sensitive, meaning 'a' and 'A' are considered different characters. >>> first_non_repeated(\\"stress\\") == 't' >>> first_non_repeated(\\"sTreSs\\") == 'T' >>> first_non_repeated(\\"aabbcc\\") == None >>> first_non_repeated(\\"abcdefghija\\") == 'b' >>> first_non_repeated(\\"\\") == None from solution import first_non_repeated def test_first_non_repeated_regular_case(): assert first_non_repeated(\\"stress\\") == 't' def test_first_non_repeated_case_sensitive(): assert first_non_repeated(\\"sTreSs\\") == 'T' def test_first_non_repeated_all_repeated(): assert first_non_repeated(\\"aabbcc\\") == None def test_first_non_repeated_single_character(): assert first_non_repeated(\\"a\\") == 'a' def test_first_non_repeated_identical_repeated_characters(): assert first_non_repeated(\\"aa\\") == None def test_first_non_repeated_mixed_characters(): assert first_non_repeated(\\"abcdefghija\\") == 'b' def test_first_non_repeated_no_characters(): assert first_non_repeated(\\"\\") == None","solution":"def first_non_repeated(string: str) -> str: from collections import Counter # Create a counter object to count occurrences of each character char_count = Counter(string) # Find the first character that appears only once in the string for char in string: if char_count[char] == 1: return char return None"},{"question":"class Room: def __init__(self, name, description, actions): Class representing a Room in the adventure game. Args: name (str): The name of the room. description (str): A brief description of the room. actions (dict): A dictionary with actions as keys and room names as values. pass def play_game(start_room): Starts the game from the given room. Args: start_room (Room): The room where the game starts. pass def test_initial_room_description(monkeypatch): io = InputOutput([\\"quit\\"]) monkeypatch.setattr(\\"builtins.input\\", io.input) monkeypatch.setattr(\\"builtins.print\\", io.print) living_room = Room.rooms[\\"Living Room\\"] play_game(living_room) assert \\"You are in the living room. There is a door to the north.\\" in io.outputs def test_move_to_kitchen(monkeypatch): io = InputOutput([\\"go north\\", \\"quit\\"]) monkeypatch.setattr(\\"builtins.input\\", io.input) monkeypatch.setattr(\\"builtins.print\\", io.print) living_room = Room.rooms[\\"Living Room\\"] play_game(living_room) assert \\"You are in the kitchen. There is a door to the south.\\" in io.outputs def test_invalid_action(monkeypatch): io = InputOutput([\\"go west\\", \\"quit\\"]) monkeypatch.setattr(\\"builtins.input\\", io.input) monkeypatch.setattr(\\"builtins.print\\", io.print) living_room = Room.rooms[\\"Living Room\\"] play_game(living_room) assert \\"Invalid action, please try again.\\" in io.outputs def test_quit_action(monkeypatch): io = InputOutput([\\"quit\\"]) monkeypatch.setattr(\\"builtins.input\\", io.input) monkeypatch.setattr(\\"builtins.print\\", io.print) living_room = Room.rooms[\\"Living Room\\"] play_game(living_room) assert \\"Thanks for playing!\\" in io.outputs # Define example rooms for the adventure game living_room = Room( name=\\"Living Room\\", description=\\"You are in the living room. There is a door to the north.\\", actions={\\"go north\\": \\"Kitchen\\", \\"quit\\": \\"Quit\\"} ) kitchen = Room( name=\\"Kitchen\\", description=\\"You are in the kitchen. There is a door to the south.\\", actions={\\"go south\\": \\"Living Room\\", \\"quit\\": \\"Quit\\"} ) bedroom = Room( name=\\"Bedroom\\", description=\\"You are in the bedroom. There is a door to the east and one to the west.\\", actions={\\"go east\\": \\"Living Room\\", \\"go west\\": \\"Kitchen\\", \\"quit\\": \\"Quit\\"} ) # Create a central repository of all rooms Room.rooms = { \\"Living Room\\": living_room, \\"Kitchen\\": kitchen, \\"Bedroom\\": bedroom, } # Main block to start the game if __name__ == \\"__main__\\": play_game(living_room)","solution":"class Room: def __init__(self, name, description, actions): self.name = name self.description = description self.actions = actions def play_game(start_room): current_room = start_room while True: print(current_room.description) possible_actions = ', '.join(current_room.actions.keys()) print(f\\"Possible actions: {possible_actions}\\") action = input(\\"> \\").strip().lower() if action == \\"quit\\": print(\\"Thanks for playing!\\") break elif action in current_room.actions: next_room_name = current_room.actions[action] current_room = Room.rooms[next_room_name] else: print(\\"Invalid action, please try again.\\") # Define rooms living_room = Room( name=\\"Living Room\\", description=\\"You are in the living room. There is a door to the north.\\", actions={\\"go north\\": \\"Kitchen\\", \\"quit\\": \\"Quit\\"} ) kitchen = Room( name=\\"Kitchen\\", description=\\"You are in the kitchen. There is a door to the south.\\", actions={\\"go south\\": \\"Living Room\\", \\"quit\\": \\"Quit\\"} ) bedroom = Room( name=\\"Bedroom\\", description=\\"You are in the bedroom. There is a door to the east and one to the west.\\", actions={\\"go east\\": \\"Living Room\\", \\"go west\\": \\"Kitchen\\", \\"quit\\": \\"Quit\\"} ) # Create a central repository of all rooms Room.rooms = { \\"Living Room\\": living_room, \\"Kitchen\\": kitchen, \\"Bedroom\\": bedroom, } # Main block to start the game if __name__ == \\"__main__\\": play_game(living_room)"},{"question":"def evaluate_expressions(expression_string: str) -> list: Evaluates each mathematical expression in a string separated by semicolons. Parameters: - expression_string (str): The string containing expressions separated by semicolons. Returns: - List of results of evaluated expressions (only valid results). from solution import evaluate_expressions def test_single_expressions(): assert evaluate_expressions(\\"2+2\\") == [4] assert evaluate_expressions(\\"3*5\\") == [15] assert evaluate_expressions(\\"10/2\\") == [5.0] assert evaluate_expressions(\\"7-3\\") == [4] def test_multiple_expressions(): assert evaluate_expressions(\\"2+2; 3*5; 10/2; 7-3\\") == [4, 15, 5.0, 4] def test_invalid_expressions(): assert evaluate_expressions(\\"2+2; invalid; 3*5\\") == [4, 15] assert evaluate_expressions(\\"1/0; 3+3\\") == [6] # Skips division by zero expression def test_mixed_valid_invalid_expressions(): assert evaluate_expressions(\\"; 10*2; bad_expr; 5+5; 6/3\\") == [20, 10, 2.0] def test_empty_string(): assert evaluate_expressions(\\"\\") == [] def test_whitespace_expressions(): assert evaluate_expressions(\\" 2 + 3 ; 4*5 \\") == [5, 20]","solution":"def evaluate_expressions(expression_string): Evaluates each mathematical expression in a string separated by semicolons. Parameters: - expression_string (str): The string containing expressions separated by semicolons. Returns: - List of results of evaluated expressions (only valid results). results = [] expressions = expression_string.split(';') for expression in expressions: expression = expression.strip() try: # Evaluating the expression using eval result = eval(expression) results.append(result) except Exception as e: # Skips the invalid expression print(f\\"Skipping invalid expression: '{expression}' ({e})\\") return results"},{"question":"from typing import List, Tuple, Union def calculate_factorial(n: int) -> Union[int, None]: Manually computes the factorial of a given integer n. If n is negative, returns None as the factorial of a negative number is undefined. >>> calculate_factorial(0) 1 >>> calculate_factorial(5) 120 >>> calculate_factorial(-3) None pass def list_integers_with_factorial(integers: List[int]) -> List[Tuple[int, Union[int, None]]]: Takes a list of integers and returns a list of tuples. Each tuple contains the original integer and its factorial. >>> list_integers_with_factorial([0, 1, 2, 3]) [(0, 1), (1, 1), (2, 2), (3, 6)] >>> list_integers_with_factorial([5, -1, 4, 7]) [(5, 120), (-1, None), (4, 24), (7, 5040)] pass def test_calculate_factorial(): assert calculate_factorial(0) == 1 assert calculate_factorial(1) == 1 assert calculate_factorial(5) == 120 assert calculate_factorial(10) == 3628800 assert calculate_factorial(-3) == None def test_list_integers_with_factorial_basic(): assert list_integers_with_factorial([0, 1, 2, 3]) == [(0, 1), (1, 1), (2, 2), (3, 6)] assert list_integers_with_factorial([5, -1, 4, 7]) == [(5, 120), (-1, None), (4, 24), (7, 5040)] def test_list_integers_with_factorial_edge_cases(): assert list_integers_with_factorial([]) == [] assert list_integers_with_factorial([20]) == [(20, 2432902008176640000)] assert list_integers_with_factorial([-5, 0, 5]) == [(-5, None), (0, 1), (5, 120)] def test_list_integers_with_factorial_negative_integers(): assert list_integers_with_factorial([-1, -2, -3]) == [(-1, None), (-2, None), (-3, None)]","solution":"def calculate_factorial(n): Manually computes the factorial of a given integer n. If n is negative, returns None as the factorial of a negative number is undefined. if n < 0: return None factorial = 1 for i in range(2, n + 1): factorial *= i return factorial def list_integers_with_factorial(integers): Takes a list of integers and returns a list of tuples. Each tuple contains the original integer and its factorial. result = [] for num in integers: factorial = calculate_factorial(num) result.append((num, factorial)) return result"},{"question":"def is_integer(value): Check if a given value is an integer. Args: value (str): Input value. Returns: bool: True if the value is an integer, false otherwise. # Implementation here def remove_duplicates(lst): Remove duplicates from the list. Args: lst (list): Input list. Returns: list: List without duplicates. # Implementation here def sort_list(lst): Sort the list in ascending order. Args: lst (list): Input list. Returns: list: Sorted list in ascending order. # Implementation here def calculate_mean(lst): Calculate the mean of the list. Args: lst (list): Input list. Returns: float: Mean of the list. # Implementation here def calculate_median(lst): Calculate the median of the list. Args: lst (list): Input list. Returns: float: Median of the list. # Implementation here def calculate_mode(lst): Calculate the mode of the list. Args: lst (list): Input list. Returns: int or list: Mode of the list. Returns a list if multiple modes are found. # Implementation here","solution":"def is_integer(value): Check if a given value is an integer. Args: value (str): Input value. Returns: bool: True if the value is an integer, false otherwise. try: int(value) return True except ValueError: return False def remove_duplicates(lst): Remove duplicates from the list. Args: lst (list): Input list. Returns: list: List without duplicates. return list(set(lst)) def sort_list(lst): Sort the list in ascending order. Args: lst (list): Input list. Returns: list: Sorted list in ascending order. return sorted(lst) def calculate_mean(lst): Calculate the mean of the list. Args: lst (list): Input list. Returns: float: Mean of the list. return sum(lst) / len(lst) def calculate_median(lst): Calculate the median of the list. Args: lst (list): Input list. Returns: float: Median of the list. n = len(lst) lst_sorted = sorted(lst) mid = n // 2 if n % 2 == 0: return (lst_sorted[mid - 1] + lst_sorted[mid]) / 2 else: return lst_sorted[mid] def calculate_mode(lst): Calculate the mode of the list. Args: lst (list): Input list. Returns: int or list: Mode of the list. Returns a list if multiple modes are found. from collections import Counter data = Counter(lst) modes = [k for k, v in data.items() if v == max(data.values())] if len(modes) == 1: return modes[0] else: return modes"},{"question":"import numpy as np class MatrixManipulator: A class to perform various operations on 2D matrices. def __init__(self, matrix): self.matrix = np.array(matrix) def add(self, other): Add two matrices. >>> MatrixManipulator([[1, 2], [3, 4]]).add([[5, 6], [7, 8]]) array([[ 6, 8], [10, 12]]) >>> MatrixManipulator([[1, 2]]).add([[3, 4]]) array([[4, 6]]) pass def multiply(self, other): Multiply two matrices. >>> MatrixManipulator([[1, 2], [3, 4]]).multiply([[2, 0], [1, 2]]) array([[ 4, 4], [10, 8]]) >>> MatrixManipulator([[1, 2, 3]]).multiply([[1], [2], [3]]) array([[14]]) pass def transpose(self): Transpose a matrix. >>> MatrixManipulator([[1, 2], [3, 4]]).transpose() array([[1, 3], [2, 4]]) >>> MatrixManipulator([[1, 2, 3]]).transpose() array([[1], [2], [3]]) pass def invert(self): Invert a square matrix. >>> MatrixManipulator([[1, 2], [3, 4]]).invert() array([[-2. , 1. ], [ 1.5, -0.5]]) >>> MatrixManipulator([[4, 7], [2, 6]]).invert() array([[ 0.6, -0.7], [-0.2, 0.4]]) pass def determinant(self): Calculate the determinant of a square matrix. >>> MatrixManipulator([[1, 2], [3, 4]]).determinant() -2.0 >>> MatrixManipulator([[4, 7], [2, 6]]).determinant() 10.0 pass # Example usage # if __name__ == \\"__main__\\": # mat = MatrixManipulator([[1, 2], [3, 4]]) # print(mat.add([[5, 6], [7, 8]])) # print(mat.multiply([[2, 0], [1, 2]])) # print(mat.transpose()) # print(mat.invert()) # print(mat.determinant())","solution":"import numpy as np class MatrixManipulator: A class to perform various operations on 2D matrices. def __init__(self, matrix): self.matrix = np.array(matrix) def add(self, other): other_matrix = np.array(other) if self.matrix.shape != other_matrix.shape: raise ValueError(\\"Matrices must have the same dimensions for addition.\\") return self.matrix + other_matrix def multiply(self, other): other_matrix = np.array(other) if self.matrix.shape[1] != other_matrix.shape[0]: raise ValueError(\\"Number of columns in A must equal the number of rows in B for multiplication.\\") return self.matrix.dot(other_matrix) def transpose(self): return self.matrix.T def invert(self): if self.matrix.shape[0] != self.matrix.shape[1]: raise ValueError(\\"Matrix must be square to be inverted.\\") if np.linalg.det(self.matrix) == 0: raise ValueError(\\"Matrix is singular and cannot be inverted.\\") return np.linalg.inv(self.matrix) def determinant(self): if self.matrix.shape[0] != self.matrix.shape[1]: raise ValueError(\\"Matrix must be square to compute the determinant.\\") return np.linalg.det(self.matrix) # Example usage # mat = MatrixManipulator([[1, 2], [3, 4]]) # print(mat.add([[5, 6], [7, 8]])) # print(mat.multiply([[0, 1], [1, 0]])) # print(mat.transpose()) # print(mat.invert()) # print(mat.determinant())"},{"question":"def is_interesting_substring(s: str, k: int) -> bool: Create a Python function that determines if there exists a contiguous substring of length \`k\` within the given string \`s\` such that the sum of the ASCII values of its characters is divisible by \`k\`. Args: s (str): A string containing only alphanumeric characters (both lower and upper case). k (int): An integer representing the length of the substring to consider. Returns: bool: True if there exists such a substring, otherwise False. Examples: >>> is_interesting_substring(\\"abcdefgh\\", 3) True >>> is_interesting_substring(\\"abcde\\", 2) False >>> is_interesting_substring(\\"Aaaaa\\", 2) True pass import pytest from solution import is_interesting_substring def test_example_cases(): assert is_interesting_substring(\\"abcdefgh\\", 3) == True assert is_interesting_substring(\\"abcde\\", 2) == False assert is_interesting_substring(\\"Aaaaa\\", 2) == True def test_edge_cases(): assert is_interesting_substring(\\"\\", 1) == False assert is_interesting_substring(\\"a\\", 1) == True assert is_interesting_substring(\\"a\\", 2) == False def test_all_same_chars(): assert is_interesting_substring(\\"aaa\\", 2) == True assert is_interesting_substring(\\"bbb\\", 3) == True def test_divisible_cases(): assert is_interesting_substring(\\"xyzxyzxyz\\", 3) == True assert is_interesting_substring(\\"123456789\\", 3) == True assert is_interesting_substring(\\"123456789\\", 4) == False def test_large_k(): assert is_interesting_substring(\\"abcde\\", 5) == True assert is_interesting_substring(\\"abcde\\", 6) == False","solution":"def is_interesting_substring(s: str, k: int) -> bool: n = len(s) if k > n: return False # Compute the sum for the first k-length substring current_sum = sum(ord(s[i]) for i in range(k)) if current_sum % k == 0: return True # Sliding window to examine every k-length substring for i in range(k, n): current_sum += ord(s[i]) - ord(s[i - k]) if current_sum % k == 0: return True return False"},{"question":"def reverse_words(words: List[str]) -> List[str]: Reverses the characters of each word in the input list, keeping the original order. Args: words (list of str): The list of words to be reversed. Returns: list of str: A list with each word's characters reversed. >>> reverse_words([\\"hello\\", \\"world\\"]) [\\"olleh\\", \\"dlrow\\"] >>> reverse_words([\\"abcd\\", \\"efgh\\"]) [\\"dcba\\", \\"hgfe\\"] >>> reverse_words([\\"\\", \\"\\"]) [\\"\\", \\"\\"] >>> reverse_words([\\" \\", \\" \\"]) [\\" \\", \\" \\"] >>> reverse_words([\\"hello\\", \\"world\\", \\" \\", \\"\\", \\"123\\"]) [\\"olleh\\", \\"dlrow\\", \\" \\", \\"\\", \\"321\\"] >>> reverse_words([\\"a\\", \\"b\\", \\"c\\", \\"\\", \\" \\"]) [\\"a\\", \\"b\\", \\"c\\", \\"\\", \\" \\"] >>> reverse_words([\\"!@#\\", \\"%^\\", \\"&*()\\"]) [\\"#@!\\", \\"^%\\", \\")(*&\\"]","solution":"def reverse_words(words): Reverses the characters of each word in the input list, keeping the original order. Args: words (list of str): The list of words to be reversed. Returns: list of str: A list with each word's characters reversed. reversed_words = [] for word in words: reversed_word = \\"\\" for char in word: reversed_word = char + reversed_word reversed_words.append(reversed_word) return reversed_words"},{"question":"def find_anagram_groups(words): Returns groups of anagrams from the input list of words. >>> find_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"evil\\", \\"vile\\", \\"veil\\"]) [['listen', 'silent', 'enlist'], ['google', 'gogole'], ['evil', 'vile', 'veil']] >>> find_anagram_groups([\\"cat\\", \\"dog\\", \\"god\\", \\"tac\\"]) [['cat', 'tac'], ['dog', 'god']] >>> find_anagram_groups([\\"hello\\", \\"world\\"]) [] >>> find_anagram_groups([]) []","solution":"def find_anagram_groups(words): from collections import defaultdict # Dictionary to hold sorted character tuple as key and list of anagrams as value anagrams = defaultdict(list) for word in words: # Sorting the word and using it as a key key = tuple(sorted(word)) anagrams[key].append(word) # Returning groups of anagrams return [group for group in anagrams.values() if len(group) > 1]"},{"question":"def is_substring(s1: str, s2: str) -> bool: Checks if s1 is a substring of s2. :param s1: The substring to search for :param s2: The string to search within :return: True if s1 is found within s2, False otherwise def is_rotation(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1. :param s1: Original string :param s2: String to check if it is a rotation of s1 :return: True if s2 is a rotation of s1, False otherwise from solution import is_rotation def test_is_rotation_positive_cases(): assert is_rotation(\\"waterbottle\\", \\"erbottlewat\\") assert is_rotation(\\"abcdef\\", \\"cdefab\\") assert is_rotation(\\"rotation\\", \\"tationro\\") def test_is_rotation_negative_cases(): assert not is_rotation(\\"abc\\", \\"abd\\") assert not is_rotation(\\"waterbottle\\", \\"erboottlewat\\") assert not is_rotation(\\"rotation\\", \\"rotationa\\") def test_is_rotation_same_strings(): assert is_rotation(\\"abc\\", \\"abc\\") def test_is_rotation_different_lengths(): assert not is_rotation(\\"abcd\\", \\"abc\\") assert not is_rotation(\\"abc\\", \\"abcd\\") def test_is_rotation_empty_strings(): assert is_rotation(\\"\\", \\"\\")","solution":"def is_substring(s1: str, s2: str) -> bool: return s1 in s2 def is_rotation(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1. :param s1: Original string :param s2: String to check if it is a rotation of s1 :return: True if s2 is a rotation of s1, False otherwise if len(s1) != len(s2): return False combined = s1 + s1 return is_substring(s2, combined)"},{"question":"import re def is_valid_palindrome(s: str) -> bool: Determines whether a given string is a valid palindrome or not. A valid palindrome reads the same forward and backward, and it is case-insensitive and ignores non-alphanumeric characters. Parameters: s (str): The input string to check for palindrome validity. Returns: bool: True if the string is a valid palindrome, False otherwise. Example: >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_valid_palindrome(\\"race a car\\") False >>> is_valid_palindrome(\\"\\") True","solution":"import re def is_valid_palindrome(s: str) -> bool: Determines whether a given string is a valid palindrome or not. A valid palindrome reads the same forward and backward, and it is case-insensitive and ignores non-alphanumeric characters. Parameters: s (str): The input string to check for palindrome validity. Returns: bool: True if the string is a valid palindrome, False otherwise. # Remove all non-alphanumeric characters and convert to lowercase clean_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Compare the cleaned string with its reverse return clean_string == clean_string[::-1]"},{"question":"from typing import List def list_multiples(n: int, limit: int) -> List[int]: Returns a list of all multiples of n up to (and including) limit. If n is greater than limit, returns an empty list. >>> list_multiples(3, 20) [3, 6, 9, 12, 15, 18] >>> list_multiples(5, 25) [5, 10, 15, 20, 25] >>> list_multiples(10, 5) [] >>> list_multiples(7, 6) [] >>> list_multiples(5, 5) [5] >>> list_multiples(10, 10) [10] >>> list_multiples(1, 3) [1, 2, 3] >>> list_multiples(3, 15) [3, 6, 9, 12, 15] >>> list_multiples(100, 1000) [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000] >>> list_multiples(250, 1000) [250, 500, 750, 1000]","solution":"def list_multiples(n, limit): Returns a list of all multiples of n up to (and including) limit. if n > limit: return [] multiples = [] multiple = n while multiple <= limit: multiples.append(multiple) multiple += n return multiples"},{"question":"def swap_case(s: str) -> str: Returns a new string where all uppercase letters are converted to lowercase, all lowercase letters are converted to uppercase, and all non-alphabetic characters remain unchanged. >>> swap_case(\\"HELLO\\") == \\"hello\\" >>> swap_case(\\"world\\") == \\"WORLD\\" >>> swap_case(\\"HelloWorld\\") == \\"hELLOwORLD\\" >>> swap_case(\\"Hello, World! 123\\") == \\"hELLO, wORLD! 123\\" >>> swap_case(\\"\\") == \\"\\" >>> swap_case(\\"12345!@#%\\") == \\"12345!@#%\\" >>> swap_case(\\"a\\") == \\"A\\" >>> swap_case(\\"Z\\") == \\"z\\" >>> swap_case(\\"1\\") == \\"1\\"","solution":"def swap_case(s): Returns a new string where all uppercase letters are converted to lowercase, all lowercase letters are converted to uppercase, and all non-alphabetic characters remain unchanged. return s.swapcase()"},{"question":"from datetime import datetime import heapq def parse_time(time_str): Parses a string to a datetime object. return datetime.strptime(time_str, '%Y-%m-%d %H:%M') def find_cheapest_route(flights, departure_city, destination_city): Find the cheapest flight route from a given departure city to a destination city that consists of one or more connecting flights. The function should return a list of tuples representing the flight route. If two routes have the same cost, return the one with the earliest arrival time. If no route is found, return an empty list. Constraints: 1. Departure and arrival times are given as strings in 'YYYY-MM-DD HH:MM' format. 2. The cost is a positive float. 3. The function should handle erroneous data entries such as incorrect time formats, negative costs, or missing information. It should raise a ValueError with a descriptive message. 4. The function should efficiently handle cases with multiple flights and cities. Example Incorrect Code: def incorrect_find_cheapest_route(flights, departure_city, destination_city): routes = [] for flight in flights: if flight[0] == departure_city: current_route = [flight] current_city = flight[1] current_cost = flight[4] for next_flight in flights: if next_flight[0] == current_city and next_flight[2] > flight[3]: current_route.append(next_flight) current_city = next_flight[1] current_cost += next_flight[4] if current_city == destination_city: routes.append((current_route, current_cost)) if routes: routes.sort(key=lambda x: (x[1], x[0][-1][3])) # Choose the cheapest one or the one that arrives earliest if cost is the same return [f for f in routes[0][0]] return [] Common Mistake Analysis: - The above code does not properly handle checking connection times, which can lead to invalid routes being considered. - It also does not raise ValueError for invalid data entries. # Implement the correct function here import pytest def test_parse_time(): assert parse_time('2023-10-10 10:10') == datetime(2023, 10, 10, 10, 10) def test_cheapest_route_single_flight(): flights = [ ('A', 'B', '2023-10-10 10:00', '2023-10-10 12:00', 100.0, 'Airline1') ] assert find_cheapest_route(flights, 'A', 'B') == [('B', 100.0)] def test_cheapest_route_multiple_flights(): flights = [ ('A', 'B', '2023-10-10 10:00', '2023-10-10 12:00', 100.0, 'Airline1'), ('B', 'C', '2023-10-10 14:00', '2023-10-10 16:00', 150.0, 'Airline2'), ('A', 'C', '2023-10-10 11:00', '2023-10-10 13:00', 300.0, 'Airline3') ] assert find_cheapest_route(flights, 'A', 'C') == [('B', 100.0), ('C', 250.0)] def test_cheapest_route_no_available_flights(): flights = [ ('A', 'B', '2023-10-10 10:00', '2023-10-10 12:00', 100.0, 'Airline1') ] assert find_cheapest_route(flights, 'A', 'C') == [] def test_cheapest_route_with_earliest_arrival(): flights = [ ('A', 'B', '2023-10-10 10:00', '2023-10-10 12:00', 100.0, 'Airline1'), ('B', 'C', '2023-10-10 12:30', '2023-10-10 14:00', 150.0, 'Airline2'), ('B', 'C', '2023-10-10 14:30', '2023-10-10 16:00', 150.0, 'Airline3') ] assert find_cheapest_route(flights, 'A', 'C') == [('B', 100.0), ('C', 250.0)] def test_invalid_time_format(): flights = [ ('A', 'B', '2023-10-10 10:00', '2023-10-10 12:00', 100.0, 'Airline1'), ('B', 'C', '2023-10-10 12:30', 'Invalid Time', 150.0, 'Airline2') ] with pytest.raises(ValueError, match=\\"Time format must be 'YYYY-MM-DD HH:MM'.\\"): find_cheapest_route(flights, 'A', 'C') def test_negative_cost(): flights = [ ('A', 'B', '2023-10-10 10:00', '2023-10-10 12:00', -100.0, 'Airline1') ] with pytest.raises(ValueError, match=\\"Flight cost cannot be negative.\\"): find_cheapest_route(flights, 'A', 'B') def test_current_code_fails(): flights = [ ('A', 'B', '2023-10-10 10:00', '2023-10-10 12:00', 100.0, 'Airline1'), ('B', 'C', '2023-10-10 11:00', '2023-10-10 13:00', 100.0, 'Airline2') ] assert incorrect_find_cheapest_route(flights, 'A', 'C') == []","solution":"from datetime import datetime import heapq def parse_time(time_str): Parses a string to a datetime object. return datetime.strptime(time_str, '%Y-%m-%d %H:%M') def find_cheapest_route(flights, departure_city, destination_city): Finds the cheapest flight route from departure_city to destination_city. # Validate and preprocess flights information graph = {} for flight in flights: if len(flight) != 6: raise ValueError(\\"Each flight must contain exactly 6 elements.\\") dep_city, dest_city, dep_time, arr_time, cost, airline = flight if cost < 0: raise ValueError(\\"Flight cost cannot be negative.\\") try: dep_time_parsed = parse_time(dep_time) arr_time_parsed = parse_time(arr_time) except ValueError: raise ValueError(\\"Time format must be 'YYYY-MM-DD HH:MM'.\\") if dep_city not in graph: graph[dep_city] = [] graph[dep_city].append((dest_city, dep_time_parsed, arr_time_parsed, cost, airline)) # Dijkstra's algorithm to find the shortest path by cost pq = [(0, departure_city, [], datetime.min)] # (total_cost, current_city, path, arrival_time) visited = set() while pq: total_cost, current_city, path, last_arrival = heapq.heappop(pq) if current_city in visited: continue visited.add(current_city) path = path + [(current_city, total_cost)] if current_city == destination_city: return path[1:] # exclude the start point for neighbor in graph.get(current_city, []): dest_city, dep_time, arr_time, cost, airline = neighbor if dep_time >= last_arrival: # Ensure valid connection heapq.heappush(pq, (total_cost + cost, dest_city, path, arr_time)) return [] def incorrect_find_cheapest_route(flights, departure_city, destination_city): # This code fails because it doesn't handle checking connection times properly routes = [] for flight in flights: if flight[0] == departure_city: current_route = [flight] current_city = flight[1] current_cost = flight[4] for next_flight in flights: if next_flight[0] == current_city and next_flight[2] > flight[3]: current_route.append(next_flight) current_city = next_flight[1] current_cost += next_flight[4] if current_city == destination_city: routes.append((current_route, current_cost)) if routes: # Choose the cheapest one or the one that arrives earliest if cost is the same routes.sort(key=lambda x: (x[1], x[0][-1][3])) return [f for f in routes[0][0]] return []"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the string s is a palindrome, False otherwise. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"\\") True pass def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" # or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"ac\\") \\"a\\" # or \\"c\\" pass def get_palindrome_info(s: str): Returns whether the string s is a palindrome, the longest palindromic substring, and its length. >>> get_palindrome_info(\\"babad\\") (False, \\"bab\\", 3) >>> get_palindrome_info(\\"cbbd\\") (False, \\"bb\\", 2) >>> get_palindrome_info(\\"a\\") (True, \\"a\\", 1) >>> get_palindrome_info(\\"\\") (True, \\"\\", 0) >>> get_palindrome_info(\\"racecar\\") (True, \\"racecar\\", 7) pass","solution":"def is_palindrome(s: str) -> bool: Returns True if the string s is a palindrome, False otherwise. return s == s[::-1] def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. n = len(s) if n == 0: return \\"\\" longest = s[0] dp = [[False] * n for _ in range(n)] for end in range(n): for start in range(end + 1): if s[start] == s[end] and (end - start <= 2 or dp[start + 1][end - 1]): dp[start][end] = True if end - start + 1 > len(longest): longest = s[start:end + 1] return longest def get_palindrome_info(s: str): Returns whether the string s is a palindrome, the longest palindromic substring, and its length. is_palindrome_res = is_palindrome(s) longest_palindrome = longest_palindromic_substring(s) longest_length = len(longest_palindrome) return is_palindrome_res, longest_palindrome, longest_length"},{"question":"def ascii_hyphen_string(input_str): Returns a new string where each character from the original string is followed by its corresponding ASCII value, separated by a hyphen. If the input string is empty, returns \\"Empty String\\". >>> ascii_hyphen_string(\\"abc\\") == \\"a-97b-98c-99\\" >>> ascii_hyphen_string(\\"\\") == \\"Empty String\\" >>> ascii_hyphen_string(\\"a1!\\") == \\"a-971-49!-33\\" >>> ascii_hyphen_string(\\"z\\") == \\"z-122\\" >>> ascii_hyphen_string(\\"a b\\") == \\"a-97 -32b-98\\"","solution":"def ascii_hyphen_string(input_str): Returns a new string where each character from the original string is followed by its corresponding ASCII value, separated by a hyphen. If the input string is empty, returns \\"Empty String\\". if not input_str: return \\"Empty String\\" result = ''.join([f\\"{char}-{ord(char)}\\" for char in input_str]) return result"},{"question":"from typing import List class Matrix: Implement a class Matrix that performs basic matrix operations. 1. Initialization: Accepts a 2D list representing the matrix elements. >>> m = Matrix([[1, 2], [3, 4]]) >>> m.elements [[1, 2], [3, 4]] 2. Scalar Multiplication: Multiplies the matrix by a scalar value. >>> m = Matrix([[1, 2], [3, 4]]) >>> m.scalar_multiply(2) >>> m.elements [[2, 4], [6, 8]] 3. Matrix Addition: Adds another matrix to the current matrix. >>> m1 = Matrix([[1, 2], [3, 4]]) >>> m2 = Matrix([[5, 6], [7, 8]]) >>> m3 = m1.add(m2) >>> m3.elements [[6, 8], [10, 12]] 4. Matrix Transpose: Transposes the matrix. >>> m = Matrix([[1, 2, 3], [4, 5, 6]]) >>> t = m.transpose() >>> t.elements [[1, 4], [2, 5], [3, 6]] 5. String Representation: Provides a readable string representation of the matrix, where each row is on a new line and elements are space-separated. >>> m = Matrix([[1, 2], [3, 4]]) >>> str(m) '1 2n3 4' def __init__(self, elements: List[List[int]]): # Your code here def scalar_multiply(self, scalar: int) -> None: # Your code here def add(self, other: 'Matrix') -> 'Matrix': # Your code here def transpose(self) -> 'Matrix': # Your code here def __str__(self) -> str: # Your code here","solution":"from typing import List class Matrix: def __init__(self, elements: List[List[int]]): self.elements = elements def scalar_multiply(self, scalar: int) -> None: self.elements = [[scalar * element for element in row] for row in self.elements] def add(self, other: 'Matrix') -> 'Matrix': if len(self.elements) != len(other.elements) or len(self.elements[0]) != len(other.elements[0]): raise ValueError(\\"Matrices are not of the same size\\") result_elements = [ [self.elements[i][j] + other.elements[i][j] for j in range(len(self.elements[0]))] for i in range(len(self.elements)) ] return Matrix(result_elements) def transpose(self) -> 'Matrix': transposed_elements = [ [self.elements[j][i] for j in range(len(self.elements))] for i in range(len(self.elements[0])) ] return Matrix(transposed_elements) def __str__(self) -> str: return 'n'.join(' '.join(map(str, row)) for row in self.elements)"},{"question":"def reverse_alphabet_shift(s: str) -> str: This function takes a string consisting of lowercase alphabets and returns another string where 'a' shifts to 'z', 'b' shifts to 'y', and so on (reverse the alphabet). Non-alphabet characters are preserved in their positions. >>> reverse_alphabet_shift('abc') == 'zyx' >>> reverse_alphabet_shift('a-b-c') == 'z-y-x'","solution":"def reverse_alphabet_shift(s): This function takes a string consisting of lowercase alphabets and returns another string where 'a' shifts to 'z', 'b' shifts to 'y', and so on. Non-alphabet characters are preserved in their positions. def shift_char(c): if 'a' <= c <= 'z': return chr(219 - ord(c)) return c return ''.join(shift_char(c) for c in s)"},{"question":"from typing import List def no_adjacent_duplicates_permutations(s: str) -> List[str]: Determines all possible permutations of a string that have no two identical letters adjacent to each other. If it is impossible to achieve, returns an empty list. >>> sorted(no_adjacent_duplicates_permutations(\\"a\\")) == [\\"a\\"] >>> sorted(no_adjacent_duplicates_permutations(\\"abc\\")) == sorted([\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]) >>> no_adjacent_duplicates_permutations(\\"aa\\") == [] >>> no_adjacent_duplicates_permutations(\\"aaa\\") == [] >>> no_adjacent_duplicates_permutations(\\"\\") == [] >>> sorted(no_adjacent_duplicates_permutations(\\"aab\\")) == sorted([\\"aba\\"]) >>> sorted(no_adjacent_duplicates_permutations(\\"aabb\\")) == sorted([\\"abab\\", \\"baba\\"])","solution":"from itertools import permutations from collections import Counter def no_adjacent_duplicates_permutations(s): def is_valid(permutation): for i in range(len(permutation) - 1): if permutation[i] == permutation[i + 1]: return False return True if not s: return [] # Generate permutations perms = set(permutations(s)) # Filter permutations that have no two identical letters adjacent valid_perms = [''.join(p) for p in perms if is_valid(p)] return valid_perms"},{"question":"def even_odd_sort(nums): Sorts the list such that all the even numbers come before all the odd numbers, while maintaining their original relative order. Args: nums (list of int): List of integers to sort. Returns: list of int: Sorted list where evens come before odds. >>> even_odd_sort([3, 8, 5, 12, 10, 15, 7, 2]) [8, 12, 10, 2, 3, 5, 15, 7] >>> even_odd_sort([2, 4, 6, 8]) [2, 4, 6, 8] >>> even_odd_sort([1, 3, 5, 7]) [1, 3, 5, 7] >>> even_odd_sort([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> even_odd_sort([]) [] >>> even_odd_sort([2]) [2] >>> even_odd_sort([1]) [1]","solution":"def even_odd_sort(nums): Sorts the list such that all the even numbers come before all the odd numbers, while maintaining their original relative order. Args: nums (list of int): List of integers to sort. Returns: list of int: Sorted list where evens come before odds. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 != 0] return evens + odds"},{"question":"def separate_and_sort(input_string: str) -> dict: Separates alphabetic and numeric components from the input string. Sorted alphabetic characters are stored under the 'letters' key, and the sum of numeric values is stored under the 'numbers' key. Args: input_string (str): A string containing alphabetic characters and integers. Returns: dict: A dictionary with 'letters' and 'numbers' keys. >>> separate_and_sort(\\"a2b3c1\\") {'letters': 'abc', 'numbers': 6} >>> separate_and_sort(\\"abc\\") {'letters': 'abc', 'numbers': 0} >>> separate_and_sort(\\"123\\") {'letters': '', 'numbers': 6} >>> separate_and_sort(\\"\\") {'letters': '', 'numbers': 0} >>> separate_and_sort(\\"3b2a1c\\") {'letters': 'abc', 'numbers': 6}","solution":"def separate_and_sort(input_string): Separates alphabetic and numeric components from the input string. Sorted alphabetic characters are stored under the 'letters' key, and the sum of numeric values is stored under the 'numbers' key. Args: input_string (str): A string containing alphabetic characters and integers. Returns: dict: A dictionary with 'letters' and 'numbers' keys. letters = \\"\\" numbers = 0 for char in input_string: if char.isalpha(): letters += char elif char.isdigit(): numbers += int(char) sorted_letters = ''.join(sorted(letters)) return { 'letters': sorted_letters, 'numbers': numbers }"},{"question":"def is_palindrome(s: str) -> bool: Check whether the given string s is a palindrome. A string is considered a palindrome if it reads the same backward as forward. Parameters: s (str): The input string consisting of lowercase letters. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"level\\") True >>> is_palindrome(\\"algorithm\\") False","solution":"def is_palindrome(s: str) -> bool: Check whether the given string s is a palindrome. A string is considered a palindrome if it reads the same backward as forward. Parameters: s (str): The input string consisting of lowercase letters. Returns: bool: True if the string is a palindrome, False otherwise. left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True"},{"question":"def most_frequent_final_transformation(pipelines: list) -> str: Identifies the most frequent transformation that appears as the last step in the pipelines. >>> pipelines = [ ... \\"extract -> clean -> transform -> load\\", ... \\"extract -> transform -> load\\", ... \\"extract -> clean -> analyze\\", ... \\"extract -> clean -> transform -> analyze\\", ... \\"load -> clean -> transform -> load\\" ... ] >>> most_frequent_final_transformation(pipelines) 'load' from collections import Counter def test_most_frequent_final_transformation_single_most_frequent(): pipelines = [ \\"extract -> clean -> transform -> load\\", \\"extract -> transform -> load\\", \\"extract -> clean -> analyze\\", \\"extract -> clean -> transform -> analyze\\", \\"load -> clean -> transform -> load\\" ] assert most_frequent_final_transformation(pipelines) == \\"load\\" def test_most_frequent_final_transformation_tie(): pipelines = [ \\"extract -> clean -> load\\", \\"extract -> clean -> analyze\\", \\"extract -> validate\\", \\"load -> clean -> validate\\" ] assert most_frequent_final_transformation(pipelines) in [\\"load\\", \\"analyze\\", \\"validate\\"] def test_most_frequent_final_transformation_no_pipelines(): pipelines = [] assert most_frequent_final_transformation(pipelines) is None def test_most_frequent_final_transformation_all_same(): pipelines = [ \\"extract -> clean -> validate\\", \\"extract -> transform -> validate\\", \\"load -> validate\\" ] assert most_frequent_final_transformation(pipelines) == \\"validate\\" def test_most_frequent_final_transformation_mixed(): pipelines = [ \\"clean -> extract -> validate\\", \\"analyze -> load -> process\\", \\"validate -> process\\" ] assert most_frequent_final_transformation(pipelines) == \\"process\\"","solution":"def most_frequent_final_transformation(pipelines: list) -> str: Identifies the most frequent transformation that appears as the last step in the pipelines. from collections import Counter last_steps = [pipeline.split('->')[-1].strip() for pipeline in pipelines] most_common = Counter(last_steps).most_common(1) return most_common[0][0] if most_common else None # Example usage: pipelines = [ \\"extract -> clean -> transform -> load\\", \\"extract -> transform -> load\\", \\"extract -> clean -> analyze\\", \\"extract -> clean -> transform -> analyze\\", \\"load -> clean -> transform -> load\\" ] print(most_frequent_final_transformation(pipelines)) # Output should be \\"load\\""},{"question":"from typing import List def is_prime(num: int) -> bool: Returns True if the given number is prime, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(1) False >>> is_prime(0) False def sort_array(array: List[int]) -> List[int]: Sorts the array such that prime numbers come before non-prime numbers. >>> sort_array([3, 4, 5, 6, 7, 8, 9]) [3, 5, 7, 4, 6, 8, 9] >>> sort_array([2, 3, 4, 5, 6, 1, 0]) [2, 3, 5, 4, 6, 1, 0] >>> sort_array([10, 11, 12, 13]) [11, 13, 10, 12] >>> sort_array([20, 30, 1, 3]) [3, 20, 30, 1] def parse_input(input_str: str) -> List[int]: Parses the input string and returns a list of integers if valid. Raises ValueError if the input contains non-integer values. >>> parse_input(\\"3 4 5 6 7\\") [3, 4, 5, 6, 7] >>> parse_input(\\"2 3 4 5 6 1 0\\") [2, 3, 4, 5, 6, 1, 0] >>> parse_input(\\"3 4 a\\") ValueError(\\"Input contains non-integer values. Only integers are allowed.\\")","solution":"def is_prime(num): Returns True if the given number is prime, otherwise False. if num <= 1: return False if num == 2: return True # 2 is the only even prime number if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def sort_array(array): Sorts the array such that prime numbers come before non-prime numbers. primes = [num for num in array if is_prime(num)] non_primes = [num for num in array if not is_prime(num)] return primes + non_primes def parse_input(input_str): Parses the input string and returns a list of integers if valid. Raises ValueError if the input contains non-integer values. try: return list(map(int, input_str.split())) except ValueError: raise ValueError(\\"Input contains non-integer values. Only integers are allowed.\\")"},{"question":"def above_average(lst: list) -> list: This function accepts a list of integers 'lst' and computes the average value of these integers. It then constructs a new list containing only those integers from the original list that are greater than the computed average. >>> above_average([1, 2, 3, 4, 5]) [4, 5] >>> above_average([10, 20, 30, 40, 50]) [40, 50] >>> above_average([-1, -2, -3, -4, -5]) [-1, -2]","solution":"def above_average(lst: list) -> list: This function accepts a list of integers 'lst' and computes the average value of these integers. It then constructs a new list containing only those integers from the original list that are greater than the computed average. if not lst: return [] average = sum(lst) / len(lst) return [x for x in lst if x > average]"},{"question":"def longest_common_contiguous_subarray(List_A, List_B): Identifies the longest common contiguous subarray shared by List_A and List_B. >>> longest_common_contiguous_subarray([1, 2, 8, 2, 4, 5, 6, 7], [6, 7, 8, 2, 4, 1, 2, 4, 5, 6, 7]) == [2, 4, 5, 6, 7] >>> longest_common_contiguous_subarray([1, 2, 3], [4, 5, 6]) == [] >>> longest_common_contiguous_subarray([1, 2, 3], [1, 2, 3]) == [1, 2, 3] >>> longest_common_contiguous_subarray([1, 2, 3, 4], [1, 2, 3, 5]) == [1, 2, 3] >>> longest_common_contiguous_subarray([4, 5, 6, 7], [1, 2, 6, 7]) == [6, 7] >>> longest_common_contiguous_subarray([1, 2, 3, 2, 3], [2, 3, 2, 3, 4]) == [2, 3, 2, 3]","solution":"def longest_common_contiguous_subarray(List_A, List_B): Identifies the longest common contiguous subarray shared by List_A and List_B. m, n = len(List_A), len(List_B) max_len = 0 end_index_A = 0 # Create a 2D array to store the length of longest common suffix # of subarray ending at each pair of indices (i, j) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if List_A[i - 1] == List_B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] end_index_A = i start_index_A = end_index_A - max_len return List_A[start_index_A:end_index_A]"},{"question":"def is_valid_parentheses(s: str) -> bool: Validates if a given string containing only characters '(', ')', '{', '}', '[' and ']' is a valid parentheses sequence. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"({[]})\\") True","solution":"def is_valid_parentheses(s): stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"import pandas as pd from typing import List, Dict def total_quantity_sold(sales_data: List[Dict[str, any]]) -> Dict[str, int]: Returns a dictionary where each key is the item name and each value is the total quantity sold for that item. Parameters: sales_data (list of dict): Sales data where each dictionary contains 'date', 'item', and 'quantity' keys. Returns: dict: Dictionary with item names as keys and total quantity sold as values. Example usage: >>> sales_data = [ >>> {'date': '2023-10-01', 'item': 'apple', 'quantity': 10}, >>> {'date': '2023-10-01', 'item': 'banana', 'quantity': 5}, >>> {'date': '2023-10-02', 'item': 'apple', 'quantity': 7}, >>> ] >>> total_quantity_sold(sales_data) {'apple': 17, 'banana': 5} pass def test_total_quantity_sold_basic(): sales_data = [ {'date': '2023-10-01', 'item': 'apple', 'quantity': 10}, {'date': '2023-10-01', 'item': 'banana', 'quantity': 5}, {'date': '2023-10-02', 'item': 'apple', 'quantity': 7}, ] result = total_quantity_sold(sales_data) assert result == {'apple': 17, 'banana': 5} def test_total_quantity_sold_empty(): sales_data = [] result = total_quantity_sold(sales_data) assert result == {} def test_total_quantity_sold_single_entry(): sales_data = [ {'date': '2023-10-01', 'item': 'apple', 'quantity': 10}, ] result = total_quantity_sold(sales_data) assert result == {'apple': 10} def test_total_quantity_sold_multiple_items(): sales_data = [ {'date': '2023-10-01', 'item': 'apple', 'quantity': 10}, {'date': '2023-10-01', 'item': 'banana', 'quantity': 5}, {'date': '2023-10-02', 'item': 'apple', 'quantity': 7}, {'date': '2023-10-02', 'item': 'banana', 'quantity': 3}, {'date': '2023-10-03', 'item': 'pear', 'quantity': 6}, ] result = total_quantity_sold(sales_data) assert result == {'apple': 17, 'banana': 8, 'pear': 6} def test_total_quantity_sold_zero_quantity(): sales_data = [ {'date': '2023-10-01', 'item': 'apple', 'quantity': 0}, {'date': '2023-10-01', 'item': 'banana', 'quantity': 0}, ] result = total_quantity_sold(sales_data) assert result == {'apple': 0, 'banana': 0}","solution":"import pandas as pd def total_quantity_sold(sales_data): Returns a dictionary where each key is the item name and each value is the total quantity sold for that item. Parameters: sales_data (list of dict): Sales data where each dictionary contains 'date', 'item', and 'quantity' keys. Returns: dict: Dictionary with item names as keys and total quantity sold as values. if not sales_data: return {} # Convert the list of dictionaries to a pandas DataFrame df = pd.DataFrame(sales_data) # Group by the 'item' column and sum the 'quantity' column grouped_df = df.groupby('item')['quantity'].sum() # Convert the result to a dictionary result = grouped_df.to_dict() return result"},{"question":"def is_permutation_of_palindrome(s: str) -> bool: Checks whether a given string is a permutation of a palindrome. >>> is_permutation_of_palindrome(\\"Tact Coa\\") == True >>> is_permutation_of_palindrome(\\"Able was I ere I saw Elba\\") == True >>> is_permutation_of_palindrome(\\"Random String\\") == False >>> is_permutation_of_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_permutation_of_palindrome(\\"Hello\\") == False >>> is_permutation_of_palindrome(\\"racecar\\") == True >>> is_permutation_of_palindrome(\\" \\") == True >>> is_permutation_of_palindrome(\\"a\\") == True >>> is_permutation_of_palindrome(\\"aabb\\") == True","solution":"def is_permutation_of_palindrome(s): Checks whether a given string is a permutation of a palindrome. Parameters: s (str): Input string. Returns: bool: True if the input string is a permutation of a palindrome, False otherwise. s = s.replace(\\" \\", \\"\\").lower() char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"def is_unique(string: str) -> bool: Check if the input string contains all unique characters. Args: string (str): The string to be checked. Returns: bool: True if the string contains all unique characters, False otherwise. Examples: >>> is_unique(\\"hello\\") False >>> is_unique(\\"world\\") True","solution":"def is_unique(string): Check if the input string contains all unique characters. Args: string (str): The string to be checked. Returns: bool: True if the string contains all unique characters, False otherwise. # Using a set to track characters seen so far seen = set() for char in string: if char in seen: return False seen.add(char) return True"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determines if a given string is a permutation of a palindrome. A palindrome is a word or phrase that reads the same backward as forward, and a permutation is a rearrangement of letters. The function ignores spaces and is case-insensitive. >>> is_palindrome_permutation('Tact Coa') True >>> is_palindrome_permutation('Not a Palindrome') False >>> is_palindrome_permutation('A Santa at Nasa') True >>> is_palindrome_permutation('No lemon no melon') True >>> is_palindrome_permutation('civic') True >>> is_palindrome_permutation('ivicc') True >>> is_palindrome_permutation('hello') False >>> is_palindrome_permutation('random text') False pass from solution import is_palindrome_permutation def test_is_palindrome_permutation_true(): assert is_palindrome_permutation('Tact Coa') == True assert is_palindrome_permutation('A Santa at Nasa') == True assert is_palindrome_permutation('No lemon no melon') == True assert is_palindrome_permutation('civic') == True assert is_palindrome_permutation('ivicc') == True def test_is_palindrome_permutation_false(): assert is_palindrome_permutation('Not a Palindrome') == False assert is_palindrome_permutation('hello') == False assert is_palindrome_permutation('random text') == False def test_is_palindrome_permutation_empty_and_single_char(): assert is_palindrome_permutation('') == True # Empty string is technically a palindrome assert is_palindrome_permutation('a') == True assert is_palindrome_permutation(' ') == True # Space-only string should be treated as empty def test_is_palindrome_permutation_mixed_case(): assert is_palindrome_permutation('Tact Coa') == True assert is_palindrome_permutation('racECaR') == True assert is_palindrome_permutation('RaCecAr') == True","solution":"def is_palindrome_permutation(s): Determines if a given string is a permutation of a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string is a permutation of a palindrome, otherwise False. from collections import Counter s = ''.join(s.lower().split()) # Convert to lowercase and remove spaces char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"import time import threading class RealTimeLogger: A class to handle real-time data logging. Initializes with a specific time window in seconds, provides a method log_data(data_point) to log each data point with its timestamp, aggregates and writes all data points to a file after the time window elapses, and automatically starts a new logging cycle for the next time window. >>> logger = RealTimeLogger(time_window=2, file_name=\\"test_log.txt\\") >>> logger.log_data(\\"test_point_1\\") >>> time.sleep(1) >>> logger.log_data(\\"test_point_2\\") >>> time.sleep(3) >>> logger.stop_logging() def __init__(self, time_window: float, file_name: str): pass # Implementation to be added def log_data(self, data_point: str): pass # Implementation to be added def _write_periodically(self): pass # Implementation to be added def _write_to_file(self): pass # Implementation to be added def stop_logging(self): pass # Implementation to be added # Test cases def test_log_data(): log_file = \\"test_log.txt\\" if os.path.exists(log_file): os.remove(log_file) logger = RealTimeLogger(time_window=2, file_name=log_file) logger.log_data(\\"test_point_1\\") time.sleep(1) logger.log_data(\\"test_point_2\\") time.sleep(3) logger.stop_logging() with open(log_file, 'r') as file: lines = file.readlines() assert len(lines) == 2 assert \\"test_point_1\\" in lines[0] assert \\"test_point_2\\" in lines[1] def test_data_point_after_stop(): log_file = \\"test_log_after_stop.txt\\" if os.path.exists(log_file): os.remove(log_file) logger = RealTimeLogger(time_window=2, file_name=log_file) logger.log_data(\\"test_point_3\\") time.sleep(3) logger.stop_logging() logger.log_data(\\"test_point_4\\") time.sleep(2) with open(log_file, 'r') as file: lines = file.readlines() assert len(lines) == 1 assert \\"test_point_3\\" in lines[0] assert not any(\\"test_point_4\\" in line for line in lines) if os.path.exists(log_file): os.remove(log_file)","solution":"import time import threading class RealTimeLogger: def __init__(self, time_window, file_name): self.time_window = time_window self.file_name = file_name self.data_points = [] self.lock = threading.Lock() self.stop_event = threading.Event() self.thread = threading.Thread(target=self._write_periodically) self.thread.start() def log_data(self, data_point): timestamp = time.time() with self.lock: self.data_points.append((timestamp, data_point)) def _write_periodically(self): while not self.stop_event.is_set(): time.sleep(self.time_window) self._write_to_file() def _write_to_file(self): with self.lock: if not self.data_points: return with open(self.file_name, 'a') as file: for timestamp, data_point in self.data_points: file.write(f\\"{timestamp},{data_point}n\\") self.data_points = [] def stop_logging(self): self.stop_event.set() self.thread.join() self._write_to_file() # Example usage: # logger = RealTimeLogger(time_window=5, file_name=\\"log.txt\\") # logger.log_data(\\"data_point_1\\") # logger.log_data(\\"data_point_2\\") # time.sleep(6) # logger.stop_logging()"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the input string is a valid sequence of parentheses. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"())(\\") False","solution":"def is_valid_parentheses(s: str) -> bool: stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"import random import numpy as np def create_route(city_list): Create a random route from a list of cities. pass def initial_population(pop_size, city_list): Generate an initial population of routes. pass def rank_routes(population): Rank routes based on their fitness. pass def selection(pop_ranked, elite_size): Select the best routes for mating. pass def mating_pool(population, selection_results): Create a mating pool from the selected best routes. pass def breed(parent1, parent2): Create a new route by breeding two parent routes. pass def breed_population(matingpool, elite_size): Generate a new population through breeding. pass def mutate(individual, mutation_rate): Mutate an individual route based on a mutation rate. pass def mutate_population(population, mutation_rate): Mutate a population of routes. pass def next_generation(current_gen, elite_size, mutation_rate): Generate the next generation of routes. pass def genetic_algorithm(city_list, pop_size, elite_size, mutation_rate, generations): Run a genetic algorithm to solve the traveling salesman problem. pass # Test cases def test_create_route(): city_list = [(0, 0), (1, 1), (2, 2)] route = create_route(city_list) print(len(route) == len(city_list)) print(set(route) == set(city_list)) def test_initial_population(): city_list = [(0, 0), (1, 1), (2, 2)] pop = initial_population(5, city_list) print(len(pop) == 5) for route in pop: print(len(route) == len(city_list)) print(set(route) == set(city_list)) def test_rank_routes(): city_list = [(0, 0), (1, 1), (2, 2), (3, 3)] pop = initial_population(5, city_list) ranked = rank_routes(pop) print(len(ranked) == 5) print(isinstance(ranked[0], tuple)) print(len(ranked[0]) == 2) def test_selection(): city_list = [(0, 0), (1, 1), (2, 2), (3, 3)] pop = initial_population(5, city_list) ranked = rank_routes(pop) selected = selection(ranked, 2) print(len(selected) == 5) def test_mating_pool(): city_list = [(0, 0), (1, 1), (2, 2), (3, 3)] pop = initial_population(5, city_list) ranked = rank_routes(pop) selected = selection(ranked, 2) matingpool = mating_pool(pop, selected) print(len(matingpool) == 5) def test_breed(): parent1 = [(0, 0), (1, 1), (2, 2)] parent2 = [(2, 2), (0, 0), (1, 1)] child = breed(parent1, parent2) print(len(child) == 3) print(set(child) == set(parent1)) def test_breed_population(): city_list = [(0, 0), (1, 1), (2, 2), (3, 3)] pop = initial_population(5, city_list) ranked = rank_routes(pop) selected = selection(ranked, 2) matingpool = mating_pool(pop, selected) children = breed_population(matingpool, 2) print(len(children) == 5) def test_mutate(): individual = [(0, 0), (1, 1), (2, 2)] mutated = mutate(individual, 1.0) print(set(mutated) == set(individual)) def test_mutate_population(): city_list = [(0, 0), (1, 1), (2, 2), (3, 3)] pop = initial_population(5, city_list) mutated_pop = mutate_population(pop, 1.0) print(len(mutated_pop) == 5) def test_next_generation(): city_list = [(0, 0), (1, 1), (2, 2), (3, 3)] pop = initial_population(5, city_list) next_gen = next_generation(pop, 2, 0.01) print(len(next_gen) == 5) def test_genetic_algorithm(): city_list = [(random.randrange(100), random.randrange(100)) for x in range(25)] best_route = genetic_algorithm(city_list, 100, 20, 0.01, 500) print(len(best_route) == len(city_list)) print(set(best_route) == set(city_list))","solution":"import random import numpy as np def create_route(city_list): return random.sample(city_list, len(city_list)) def initial_population(pop_size, city_list): population = [] for i in range(pop_size): population.append(create_route(city_list)) return population def rank_routes(population): fitness_results = {} for i in range(len(population)): fitness_results[i] = route_fitness(population[i]) return sorted(fitness_results.items(), key=lambda x: x[1], reverse=True) def route_fitness(route): return 1 / float(route_distance(route)) def route_distance(route): distance = 0 for i in range(0, len(route)): from_city = route[i] to_city = None if i + 1 < len(route): to_city = route[i + 1] else: to_city = route[0] distance += np.linalg.norm(np.array(from_city) - np.array(to_city)) return distance def selection(pop_ranked, elite_size): selection_results = [] df = sum([item[1] for item in pop_ranked]) cum_sum = np.cumsum([item[1]/df for item in pop_ranked]) for i in range(elite_size): selection_results.append(pop_ranked[i][0]) for i in range(len(pop_ranked) - elite_size): pick = random.random() for i in range(0, len(pop_ranked)): if pick <= cum_sum[i]: selection_results.append(pop_ranked[i][0]) break return selection_results def mating_pool(population, selection_results): matingpool = [] for i in range(len(selection_results)): index = selection_results[i] matingpool.append(population[index]) return matingpool def breed(parent1, parent2): child = [] childP1, childP2 = [], [] geneA = int(random.random() * len(parent1)) geneB = int(random.random() * len(parent1)) startGene = min(geneA, geneB) endGene = max(geneA, geneB) for i in range(startGene, endGene): childP1.append(parent1[i]) childP2 = [item for item in parent2 if item not in childP1] child = childP1 + childP2 return child def breed_population(matingpool, elite_size): children = [] length = len(matingpool) - elite_size pool = random.sample(matingpool, len(matingpool)) for i in range(0, elite_size): children.append(matingpool[i]) for i in range(0, length): child = breed(pool[i], pool[len(matingpool)-i-1]) children.append(child) return children def mutate(individual, mutation_rate): for swapped in range(len(individual)): if(random.random() < mutation_rate): swapWith = int(random.random() * len(individual)) city1 = individual[swapped] city2 = individual[swapWith] individual[swapped] = city2 individual[swapWith] = city1 return individual def mutate_population(population, mutation_rate): mutated_pop = [] for individual in range(0, len(population)): mutated_ind = mutate(population[individual], mutation_rate) mutated_pop.append(mutated_ind) return mutated_pop def next_generation(current_gen, elite_size, mutation_rate): pop_ranked = rank_routes(current_gen) selection_results = selection(pop_ranked, elite_size) matingpool = mating_pool(current_gen, selection_results) children = breed_population(matingpool, elite_size) next_generation = mutate_population(children, mutation_rate) return next_generation def genetic_algorithm(city_list, pop_size, elite_size, mutation_rate, generations): pop = initial_population(pop_size, city_list) print(\\"Initial distance: \\" + str(1 / rank_routes(pop)[0][1])) for i in range(0, generations): pop = next_generation(pop, elite_size, mutation_rate) print(\\"Final distance: \\" + str(1 / rank_routes(pop)[0][1])) best_route_index = rank_routes(pop)[0][0] best_route = pop[best_route_index] return best_route"},{"question":"from typing import List def rearrange_kth_element(arr: List[int], k: int) -> List[int]: Rearranges the array's elements so that every 'k'th element is the largest among the remaining elements. >>> rearrange_kth_element([3, 5, 1, 4, 2], 2) [3, 5, 1, 4, 2] >>> rearrange_kth_element([3, 1, 4, 1, 5, 9, 2], 3) [3, 1, 9, 1, 5, 4, 2] n = len(arr) for i in range(k-1, n, k): largest_index = i for j in range(i+1, n): if arr[j] > arr[largest_index]: largest_index = j # Swap the largest element found with the k'th position arr[i], arr[largest_index] = arr[largest_index], arr[i] return arr # Unit Tests def test_rearrange_kth_element_sample1(): assert rearrange_kth_element([3, 5, 1, 4, 2], 2) == [3, 5, 1, 4, 2] def test_rearrange_kth_element_sample2(): assert rearrange_kth_element([3, 1, 4, 1, 5, 9, 2], 3) == [3, 1, 9, 1, 5, 4, 2] def test_rearrange_kth_element_single_element(): assert rearrange_kth_element([10], 1) == [10] def test_rearrange_kth_element_all_equal(): assert rearrange_kth_element([2, 2, 2, 2, 2], 2) == [2, 2, 2, 2, 2] def test_rearrange_kth_element_already_sorted(): assert rearrange_kth_element([1, 2, 3, 4, 5, 6], 3) == [1, 2, 6, 4, 5, 3] def test_rearrange_kth_element_descending(): assert rearrange_kth_element([6, 5, 4, 3, 2, 1], 1) == [6, 5, 4, 3, 2, 1] def test_rearrange_kth_element_large_k(): assert rearrange_kth_element([5, 3, 4, 6, 2, 1], 6) == [5, 3, 4, 6, 2, 1]","solution":"def rearrange_kth_element(arr, k): Rearranges the array's elements so that every 'k'th element is the largest among the remaining elements. n = len(arr) for i in range(k-1, n, k): largest_index = i for j in range(i+1, n): if arr[j] > arr[largest_index]: largest_index = j # Swap the largest element found with the k'th position arr[i], arr[largest_index] = arr[largest_index], arr[i] return arr"},{"question":"from typing import List def smallest_in_rows(matrix: List[List[int]]) -> List[int]: Returns a list of the smallest values in each row of the matrix. Args: matrix (List[List[int]]): A rectangular matrix of integers. Returns: List[int]: A list containing the smallest value in each row. Example: >>> matrix = [ >>> [3, 5, 2, 4], >>> [1, 6, 9, 8], >>> [7, 3, 4, 2] >>> ] >>> smallest_in_rows(matrix) [2, 1, 2] pass def test_smallest_in_rows_single_row(): assert smallest_in_rows([[3, 5, 2, 4]]) == [2] def test_smallest_in_rows_multiple_rows(): matrix = [ [3, 5, 2, 4], [1, 6, 9, 8], [7, 3, 4, 2] ] assert smallest_in_rows(matrix) == [2, 1, 2] def test_smallest_in_rows_identical_elements(): matrix = [ [4, 4, 4, 4], [1, 1, 1, 1], [3, 3, 3, 3] ] assert smallest_in_rows(matrix) == [4, 1, 3] def test_smallest_in_rows_negative_elements(): matrix = [ [-3, 5, 2, -4], [1, -6, 9, 8], [7, 3, -4, 2] ] assert smallest_in_rows(matrix) == [-4, -6, -4] def test_smallest_in_rows_single_column(): matrix = [ [3], [1], [7] ] assert smallest_in_rows(matrix) == [3, 1, 7]","solution":"from typing import List def smallest_in_rows(matrix: List[List[int]]) -> List[int]: Returns a list of the smallest values in each row of the matrix. return [min(row) for row in matrix]"},{"question":"def remove_duplicates(nums: List[int]) -> int: Remove duplicates from a sorted array in place, returning the new length of the array and modifying the input array to contain only the unique elements in the first part. Args: nums (list): A sorted list of integers. Returns: int: The length of the array after removing duplicates. >>> nums = [1, 1, 2, 2, 3, 4, 4, 5] >>> remove_duplicates(nums) 5 >>> nums[:5] [1, 2, 3, 4, 5]","solution":"def remove_duplicates(nums): Remove duplicates from a sorted array in place, returning the new length of the array and modifying the input array to contain only the unique elements in the first part. Args: nums (list): A sorted list of integers. Returns: int: The length of the array after removing duplicates. if not nums: return 0 write_index = 1 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"class Matrix: A class to represent a matrix and perform basic operations such as matrix addition, scalar multiplication, and matrix multiplication. def __init__(self, data): Initializes a matrix with the given 2D list \`data\`. def __str__(self): Returns a string representation of the matrix. def __eq__(self, other): Checks if two matrices are equal. def add(self, other): Adds this matrix with another matrix \`other\`. Raises an error if dimensions do not match. def scalar_multiply(self, scalar): Multiplies this matrix by a scalar \`scalar\`. def multiply(self, other): Multiplies this matrix with another matrix \`other\`. Raises an error if dimensions do not match for matrix multiplication. import pytest def test_matrix_initialization(): mat = Matrix([[1, 2], [3, 4]]) assert mat.data == [[1, 2], [3, 4]] assert mat.rows == 2 assert mat.cols == 2 def test_matrix_str(): mat = Matrix([[1, 2], [3, 4]]) assert str(mat) == \\"1t2n3t4\\" def test_matrix_addition(): mat1 = Matrix([[1, 2], [3, 4]]) mat2 = Matrix([[5, 6], [7, 8]]) result = mat1.add(mat2) expected = Matrix([[6, 8], [10, 12]]) assert result == expected def test_matrix_addition_dimension_mismatch(): mat1 = Matrix([[1, 2], [3, 4]]) mat2 = Matrix([[5, 6, 7], [8, 9, 10]]) with pytest.raises(ValueError): mat1.add(mat2) def test_scalar_multiplication(): mat = Matrix([[1, 2], [3, 4]]) result = mat.scalar_multiply(2) expected = Matrix([[2, 4], [6, 8]]) assert result == expected def test_matrix_multiplication(): mat1 = Matrix([[1, 2], [3, 4]]) mat2 = Matrix([[5, 6], [7, 8]]) result = mat1.multiply(mat2) expected = Matrix([[19, 22], [43, 50]]) assert result == expected def test_matrix_multiplication_dimension_mismatch(): mat1 = Matrix([[1, 2, 3], [4, 5, 6]]) mat2 = Matrix([[7, 8], [9, 10]]) with pytest.raises(ValueError): mat1.multiply(mat2)","solution":"class Matrix: def __init__(self, data): Initializes a matrix with the given 2D list \`data\`. self.data = data self.rows = len(data) self.cols = len(data[0]) if data else 0 def __str__(self): Returns a string representation of the matrix. return \\"n\\".join([\\"t\\".join(map(str, row)) for row in self.data]) def __eq__(self, other): Checks if two matrices are equal. return self.data == other.data def add(self, other): Adds this matrix with another matrix \`other\`. Raises an error if dimensions do not match. if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrix dimensions do not match for addition\\") result_data = [[self.data[i][j] + other.data[i][j] for j in range(self.cols)] for i in range(self.rows)] return Matrix(result_data) def scalar_multiply(self, scalar): Multiplies this matrix by a scalar \`scalar\`. result_data = [[self.data[i][j] * scalar for j in range(self.cols)] for i in range(self.rows)] return Matrix(result_data) def multiply(self, other): Multiplies this matrix with another matrix \`other\`. Raises an error if dimensions do not match for matrix multiplication. if self.cols != other.rows: raise ValueError(\\"Matrix dimensions do not match for multiplication\\") result_data = [[sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) for j in range(other.cols)] for i in range(self.rows)] return Matrix(result_data)"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Given a list of integers and a target number, return a list of unique pairs (tuples) from the list that sum up to the target. Each pair is ordered such that the smaller integer comes first, and duplicate pairs in the output are avoided. >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 5, 7, -1, 5], 6) [(1, 5), (-1, 7)] >>> find_pairs([1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([-2, 2, 0, 4, -4], 0) [(-4, 4), (-2, 2)] >>> find_pairs([], 10) []","solution":"def find_pairs(nums, target): Given a list of integers and a target number, returns a list of unique pairs (tuples) from the list that sum up to the target. Each pair is ordered such that the smaller integer comes first, and duplicate pairs in the output are avoided. nums.sort() pairs = [] seen = set() for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: pair = (nums[i], nums[j]) if pair not in seen: pairs.append(pair) seen.add(pair) return pairs"},{"question":"def max_difference(nums: list) -> int: Given a list of integers, returns the maximum difference between any two elements such that the larger element comes after the smaller one. Args: nums: List of integers. Returns: An integer representing the maximum difference. Returns 0 if the list has fewer than two elements. # Implement your code here # Test cases print(max_difference([2, 3, 10, 6, 4, 8, 1])) # Output: 8 (10 - 2) print(max_difference([7, 9, 5, 6, 3, 2])) # Output: 2 (9 - 7) print(max_difference([1])) # Output: 0 (less than two elements) print(max_difference([10, 8, 7, 6, 5])) # Output: 0 (no element greater than previous ones) def test_max_difference_standard(): assert max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 # 10 - 2 def test_max_difference_no_difference(): assert max_difference([10, 8, 7, 6, 5]) == 0 # no element greater than the previous one def test_max_difference_single_element(): assert max_difference([1]) == 0 # less than two elements def test_max_difference_two_elements(): assert max_difference([3, 9]) == 6 # 9 - 3 def test_max_difference_negative_numbers(): assert max_difference([4, 3, -2, 7, 9, -1]) == 11 # 9 - (-2) def test_max_difference_mixed_numbers(): assert max_difference([7, 1, 5, 3, 6, 4]) == 5 # 6 - 1 def test_max_difference_all_identical(): assert max_difference([5, 5, 5, 5, 5]) == 0 # all elements are the same","solution":"def max_difference(nums: list) -> int: Given a list of integers, returns the maximum difference between any two elements such that the larger element comes after the smaller one. Args: nums: List of integers. Returns: An integer representing the maximum difference. Returns 0 if the list has fewer than two elements. if len(nums) < 2: return 0 min_value = nums[0] max_diff = 0 for num in nums[1:]: if num - min_value > max_diff: max_diff = num - min_value if num < min_value: min_value = num return max_diff"},{"question":"def find_largest_digit(number: int) -> int: Returns the largest digit in a given positive integer. >>> find_largest_digit(4936) 9 >>> find_largest_digit(85732) 8 >>> find_largest_digit(22222) 2 >>> find_largest_digit(7) 7 >>> find_largest_digit(1) 1 >>> find_largest_digit(10203) 3","solution":"def find_largest_digit(number: int) -> int: Returns the largest digit in a given positive integer. largest_digit = 0 while number > 0: digit = number % 10 if digit > largest_digit: largest_digit = digit number //= 10 return largest_digit"},{"question":"from typing import List def has_pair_with_sum(nums: List[int], target: int) -> bool: Write a function that takes a list of integers and returns a boolean indicating whether there are any two distinct numbers in the list whose sum is equal to a given target number. The function should have a time complexity of O(n). >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5, -5], 0) True >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([1, 2, 2, 3], 4) True >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([-1, -2, -3, -4, -5], -1) False >>> has_pair_with_sum([-1, 2, 9, -4, 5], 1) True >>> has_pair_with_sum([-1, 2, 9, -4, 5], 15) False","solution":"def has_pair_with_sum(nums, target): Checks if there are two distinct numbers in list \`nums\` whose sum is equal to \`target\`. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def find_first_largest(arr: list) -> int: Returns the index of the first occurrence of the largest element in the array. If the array is empty, return -1. >>> find_first_largest([3, 7, 2, 5, 7, 4]) == 1 >>> find_first_largest([5]) == 0 >>> find_first_largest([1, 1, 1, 1, 1]) == 0 >>> find_first_largest([-1, -3, -2, -5, -7, -4]) == 0 >>> find_first_largest([]) == -1 >>> find_first_largest([3, 7, 2, 7, 5, 7, 4]) == 1 >>> arr = [i for i in range(1000000)] + [999999] >>> find_first_largest(arr) == 999999","solution":"def find_first_largest(arr): Returns the index of the first occurrence of the largest element in the array. If the array is empty, returns -1. if not arr: return -1 max_value = arr[0] max_index = 0 for index in range(1, len(arr)): if arr[index] > max_value: max_value = arr[index] max_index = index return max_index"},{"question":"import hashlib import json from time import time class Blockchain: def __init__(self): Implement a comprehensive blockchain-based voting system ensuring high security, transparency, scalability, and user anonymity. The system should be adaptable to both small and large scale elections, while being resilient to potential threats. Develop a distributed ledger using blockchain technology to securely store votes. self.chain = [] self.current_transactions = [] self.new_block(previous_hash='1', proof=100) # Genesis block def new_block(self, proof, previous_hash=None): Create a new Block in the Blockchain. Args: proof (int): The proof given by the Proof of Work algorithm. previous_hash (str): Hash of the previous Block. Returns: dict: The new Block. block = { 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.current_transactions, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), } self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, voter, candidate): Creates a new transaction to go into the next mined Block. Args: voter (str): The ID of the voter. candidate (str): The candidate being voted for. Returns: int: The index of the block that will hold this transaction. self.current_transactions.append({ 'voter': voter, 'candidate': candidate, }) return self.last_block['index'] + 1 @staticmethod def hash(block): Creates a SHA-256 hash of a Block. Args: block (dict): Block to be hashed. Returns: str: The hash of the block. block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): Returns the last Block in the chain. Returns: dict: The last block in the chain. return self.chain[-1] def proof_of_work(self, last_proof): Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') contains leading 4 zeroes. - p is the previous proof, and p' is the new proof. Args: last_proof (int): Previous proof. Returns: int: New proof. proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? Args: last_proof (int): Previous proof. proof (int): Current proof. Returns: bool: True if correct, False if not. guess = f'{last_proof}{proof}'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \\"0000\\" import pytest from solution import Blockchain def test_blockchain_creation(): blockchain = Blockchain() # Make sure there's a genesis block assert len(blockchain.chain) == 1 assert blockchain.chain[0]['previous_hash'] == '1' def test_new_block(): blockchain = Blockchain() initial_len = len(blockchain.chain) blockchain.new_block(proof=12345, previous_hash='abcde') assert len(blockchain.chain) == initial_len + 1 assert blockchain.chain[-1]['proof'] == 12345 def test_new_transaction(): blockchain = Blockchain() blockchain.new_transaction(voter='voter123', candidate='candidateXYZ') assert len(blockchain.current_transactions) == 1 assert blockchain.current_transactions[-1]['voter'] == 'voter123' assert blockchain.current_transactions[-1]['candidate'] == 'candidateXYZ' def test_hash(): blockchain = Blockchain() block = blockchain.chain[0] hashed = blockchain.hash(block) assert isinstance(hashed, str) def test_proof_of_work(): blockchain = Blockchain() last_proof = blockchain.chain[-1]['proof'] proof = blockchain.proof_of_work(last_proof) assert blockchain.valid_proof(last_proof, proof) is True def test_valid_proof(): assert Blockchain.valid_proof(100, 35293) is True assert Blockchain.valid_proof(100, 12345) is False","solution":"import hashlib import json from time import time from uuid import uuid4 class Blockchain: def __init__(self): self.chain = [] self.current_transactions = [] self.new_block(previous_hash='1', proof=100) # Genesis block def new_block(self, proof, previous_hash=None): Create a new Block in the Blockchain. block = { 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.current_transactions, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), } self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, voter, candidate): Creates a new transaction to go into the next mined Block. self.current_transactions.append({ 'voter': voter, 'candidate': candidate, }) return self.last_block['index'] + 1 @staticmethod def hash(block): Creates a SHA-256 hash of a Block. block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): return self.chain[-1] def proof_of_work(self, last_proof): Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') contains leading 4 zeroes. - p is the previous proof, and p' is the new proof. proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? guess = f'{last_proof}{proof}'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \\"0000\\""},{"question":"import math from typing import List def is_prime(num: int) -> bool: Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(math.sqrt(num)) + 1, 2): if num % i == 0: return False return True def sum_of_primes(numbers: List[int]) -> int: Returns the sum of all prime numbers in the provided list of positive integers. If the list is empty or contains no prime numbers, returns 0. Raises a ValueError if the input list contains non-integer elements. >>> sum_of_primes([]) == 0 >>> sum_of_primes([1, 4, 6, 8, 10]) == 0 >>> sum_of_primes([2, 3, 5, 7]) == 17 >>> sum_of_primes([2, 4, 6, 7, 9]) == 9 >>> sum_of_primes([11]) == 11 >>> sum_of_primes([10]) == 0 >>> try: ... sum_of_primes([2, \\"3\\", 4]) ... except ValueError as e: ... str(e) == \\"Input list should only contain positive integers.\\" >>> try: ... sum_of_primes([2, -3, 4]) ... except ValueError as e: ... str(e) == \\"Input list should only contain positive integers.\\" >>> try: ... sum_of_primes(123) ... except ValueError as e: ... str(e) == \\"Input should be a list.\\"","solution":"import math def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(math.sqrt(num)) + 1, 2): if num % i == 0: return False return True def sum_of_primes(numbers): Returns the sum of all prime numbers in the provided list of positive integers. If the list is empty or contains no prime numbers, returns 0. Raises a ValueError if the input list contains non-integer elements. if not isinstance(numbers, list): raise ValueError(\\"Input should be a list.\\") for num in numbers: if not isinstance(num, int) or num < 0: raise ValueError(\\"Input list should only contain positive integers.\\") return sum(num for num in numbers if is_prime(num))"},{"question":"def sum_with_right_neighbor(input_list): Returns a new list where each element is the sum of the original element and its right neighbor. If an element does not have a right neighbor, it remains unchanged. Args: input_list (List[int]): A list of integers Returns: List[int]: A new list with summed elements. Examples: >>> sum_with_right_neighbor([2, 4, 6, 8]) [6, 10, 14, 8] >>> sum_with_right_neighbor([1, 2, 3]) [3, 5, 3]","solution":"def sum_with_right_neighbor(input_list): Returns a new list where each element is the sum of the original element and its right neighbor. If an element does not have a right neighbor, it remains unchanged. n = len(input_list) if n == 0: return [] output_list = [0] * n for i in range(n - 1): output_list[i] = input_list[i] + input_list[i + 1] output_list[-1] = input_list[-1] return output_list"},{"question":"def find_common_elements(arr1, arr2, arr3): Find common elements in three sorted arrays and return a list of their common elements without duplicates >>> find_common_elements([1, 5, 5, 10], [3, 4, 5, 5, 10], [5, 5, 10, 20]) == [5, 10] >>> find_common_elements([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [] >>> find_common_elements([], [1, 2, 3], [1, 2, 3]) == [] >>> find_common_elements([1, 2, 2, 3], [2, 2, 3, 4], [2, 3, 3, 3]) == [2, 3] ... def find_common_elements_comprehension(arr1, arr2, arr3): Find common elements in three sorted arrays using list comprehension and return a list of their common elements without duplicates >>> find_common_elements_comprehension([1, 5, 5, 10], [3, 4, 5, 5, 10], [5, 5, 10, 20]) == [5, 10] >>> find_common_elements_comprehension([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [] >>> find_common_elements_comprehension([], [1, 2, 3], [1, 2, 3]) == [] >>> find_common_elements_comprehension([1, 2, 2, 3], [2, 2, 3, 4], [2, 3, 3, 3]) == [2, 3] ...","solution":"def find_common_elements(arr1, arr2, arr3): Find common elements in three sorted arrays and return a list of their common elements without duplicates i = j = k = 0 common = [] while i < len(arr1) and j < len(arr2) and k < len(arr3): # Check if elements are same and also not already in common list if arr1[i] == arr2[j] == arr3[k] and (len(common) == 0 or arr1[i] != common[-1]): common.append(arr1[i]) i += 1 j += 1 k += 1 elif arr1[i] < arr2[j]: i += 1 elif arr2[j] < arr3[k]: j += 1 else: k += 1 return common def find_common_elements_comprehension(arr1, arr2, arr3): Find common elements in three sorted arrays using list comprehension and return a list of their common elements without duplicates set1, set2, set3 = set(arr1), set(arr2), set(arr3) return sorted(set1 & set2 & set3)"},{"question":"def rotate_matrix_90_degree_clockwise(matrix): Rotate the given N x N matrix 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix_90_degree_clockwise(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix_90_degree_clockwise(matrix) >>> matrix [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_degree_clockwise(matrix): Rotates the given N x N matrix 90 degrees clockwise in place. N = len(matrix) # Transpose the matrix for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(N): matrix[i].reverse()"},{"question":"def remove_vowels(input_string: str) -> str: Removes vowels from the input string. >>> remove_vowels(\\"hello world\\") \\"hll wrld\\" >>> remove_vowels(\\"AEIOUaeiou\\") \\"\\" >>> remove_vowels(\\"BCDFG\\") \\"BCDFG\\" >>> remove_vowels(\\"Python Programming\\") \\"Pythn Prgrmmng\\" >>> remove_vowels(\\"\\") \\"\\" >>> remove_vowels(\\"abcdefghijklmnopqrstuvwxyz\\") \\"bcdfghjklmnpqrstvwxyz\\" vowels = \\"aeiouAEIOU\\" return ''.join([char for char in input_string if char not in vowels])","solution":"def remove_vowels(input_string): Removes vowels from the input string. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in input_string if char not in vowels])"},{"question":"def can_form_palindrome(inputStr: str) -> bool: Determine if the given string can be rearranged to form a palindrome. Args: inputStr (str): The input string consisting of lowercase alphabetic characters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aab\\") True >>> can_form_palindrome(\\"abc\\") False","solution":"def can_form_palindrome(inputStr: str) -> bool: Determine if the given string can be rearranged to form a palindrome. Args: inputStr (str): The input string consisting of lowercase alphabetic characters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. from collections import Counter # Count the frequency of each character in the string char_count = Counter(inputStr) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one odd frequency character count return odd_count <= 1"},{"question":"from typing import List, Tuple def calculate_overlap(intervals1: List[Tuple[int, int]], intervals2: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Write a function that takes two lists of intervals as input and returns a list of intervals where the intervals in the two lists overlap. >>> calculate_overlap([(1, 5), (8, 10)], [(2, 6), (8, 9)]) == [(2, 5), (8, 9)] >>> calculate_overlap([(1, 3), (5, 7)], [(2, 4), (6, 8)]) == [(2, 3), (6, 7)] >>> calculate_overlap([(1, 10)], [(2, 5), (6, 8)]) == [(2, 5), (6, 8)] Example Test Cases: assert calculate_overlap([(1, 5), (8, 10)], [(2, 6), (8, 9)]) == [(2, 5), (8, 9)] assert calculate_overlap([(1, 3), (5, 7)], [(2, 4), (6, 8)]) == [(2, 3), (6, 7)] assert calculate_overlap([(1, 10)], [(2, 5), (6, 8)]) == [(2, 5), (6, 8)] assert calculate_overlap([], [(1, 3)]) == [] assert calculate_overlap([(1, 3)], []) == [] assert calculate_overlap([], []) == [] assert calculate_overlap([(1, 2)], [(3, 4)]) == [] pass def test_calculate_overlap(): assert calculate_overlap([(1, 5), (8, 10)], [(2, 6), (8, 9)]) == [(2, 5), (8, 9)] assert calculate_overlap([(1, 3), (5, 7)], [(2, 4), (6, 8)]) == [(2, 3), (6, 7)] assert calculate_overlap([(1, 10)], [(2, 5), (6, 8)]) == [(2, 5), (6, 8)] assert calculate_overlap([(1, 4), (6, 9)], [(2, 7)]) == [(2, 4), (6, 7)] assert calculate_overlap([(1, 6)], [(5, 10)]) == [(5, 6)] assert calculate_overlap([(10, 20)], [(5, 15), (18, 25)]) == [(10, 15), (18, 20)] assert calculate_overlap([], [(1, 3)]) == [] assert calculate_overlap([(1, 3)], []) == [] assert calculate_overlap([], []) == [] assert calculate_overlap([(1, 2)], [(3, 4)]) == [] def test_calculate_overlap_no_overlap(): assert calculate_overlap([(1, 3), (4, 6)], [(7, 8)]) == [] assert calculate_overlap([(1, 5)], [(6, 10)]) == [] def test_calculate_overlap_full_overlap(): assert calculate_overlap([(1, 10)], [(5, 6)]) == [(5, 6)] assert calculate_overlap([(5, 6)], [(1, 10)]) == [(5, 6)]","solution":"from typing import List, Tuple def calculate_overlap(intervals1: List[Tuple[int, int]], intervals2: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns a list of intervals where the intervals in the two lists overlap. overlap_intervals = [] for start1, end1 in intervals1: for start2, end2 in intervals2: start_overlap = max(start1, start2) end_overlap = min(end1, end2) if start_overlap < end_overlap: overlap_intervals.append((start_overlap, end_overlap)) return overlap_intervals"},{"question":"def max_visible_buildings_from_right(buildings): Returns the maximum number of buildings that can be seen from the rightmost building. A building is considered visible if there are no taller buildings blocking the view between it and the rightmost building. Example: >>> max_visible_buildings_from_right([3, 5, 4, 4, 2, 1]) 4 >>> max_visible_buildings_from_right([1, 2, 3, 4, 5, 6]) 1 >>> max_visible_buildings_from_right([6, 5, 4, 3, 2, 1]) 6 >>> max_visible_buildings_from_right([5]) 1 >>> max_visible_buildings_from_right([]) 0 >>> max_visible_buildings_from_right([4, 4, 4, 4, 4]) 1","solution":"def max_visible_buildings_from_right(buildings): Returns the number of buildings visible when viewed from the rightmost building. if not buildings: return 0 max_height = 0 visible_count = 0 for height in reversed(buildings): if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"import csv from collections import defaultdict, Counter from statistics import mean from typing import List, Tuple, Dict, Any def read_csv(file_path: str) -> List[Dict[str, Any]]: Read a CSV file and return a list of movie dictionaries. # Implementation goes here def calculate_average_rating(movies: List[Dict[str, Any]]) -> float: Calculate the average rating of all the movies. >>> calculate_average_rating([{'Rating': 5.0}, {'Rating': 4.0}, {'Rating': 3.0}]) 4.0 >>> calculate_average_rating([]) 0 # Implementation goes here def get_top_10_highest_rated_movies(movies: List[Dict[str, Any]]) -> List[Tuple[str, float]]: List the top 10 highest rated movies with their respective ratings. >>> get_top_10_highest_rated_movies( ... [{'Title': 'Movie A', 'Rating': 5.0}, {'Title': 'Movie B', 'Rating': 4.0}, {'Title': 'Movie C', 'Rating': 4.5}] ... ) [('Movie A', 5.0), ('Movie C', 4.5), ('Movie B', 4.0)] # Implementation goes here def count_movies_per_year(movies: List[Dict[str, Any]]) -> Dict[int, int]: Find and list the number of movies released each year. >>> count_movies_per_year([{'Year': 2020}, {'Year': 2020}, {'Year': 2021}]) {2020: 2, 2021: 1} # Implementation goes here def find_most_common_genres(movies: List[Dict[str, Any]]) -> List[Tuple[str, int]]: Identify and list the 5 most common genres and the number of movies in each genre. >>> find_most_common_genres([{'Genre': ['Action', 'Adventure']}, {'Genre': ['Action', 'Drama']}, {'Genre': ['Drama']}]) [('Action', 2), ('Drama', 2), ('Adventure', 1)] # Implementation goes here # Wrapper function to process the CSV and return the required information def process_movie_data(file_path: str) -> Tuple[float, List[Tuple[str, float]], Dict[int, int], List[Tuple[str, int]]]: Process the movie data from the CSV file and return the calculated information. >>> file_path = \\"movies.csv\\" >>> process_movie_data(file_path) (4.26, [('Movie D', 5.0), ('Movie E', 4.8), ('Movie A', 4.5), ('Movie C', 4.0), ('Movie B', 3.0)], {2020: 2, 2021: 2, 2022: 1}, [('Action', 2), ('Comedy', 1), ('Drama', 1), ('Adventure', 1)]) # Implementation goes here","solution":"import csv from collections import defaultdict, Counter from statistics import mean def read_csv(file_path): movies = [] with open(file_path, newline='') as csvfile: reader = csv.DictReader(csvfile) for row in reader: try: movie = { 'MovieID': int(row['MovieID']), 'Title': row['Title'].strip(), 'Genre': [genre.strip() for genre in row['Genre'].split(',')], 'Year': int(row['Year']), 'Rating': float(row['Rating']) } movies.append(movie) except ValueError: # Skip rows with malformed data continue return movies def calculate_average_rating(movies): ratings = [movie['Rating'] for movie in movies] return mean(ratings) if ratings else 0 def get_top_10_highest_rated_movies(movies): top_movies = sorted(movies, key=lambda x: x['Rating'], reverse=True)[:10] return [(movie['Title'], movie['Rating']) for movie in top_movies] def count_movies_per_year(movies): year_count = defaultdict(int) for movie in movies: year_count[movie['Year']] += 1 return dict(year_count) def find_most_common_genres(movies): genre_count = Counter() for movie in movies: genre_count.update(movie['Genre']) return genre_count.most_common(5) # Wrapper function to process the CSV and return the required information def process_movie_data(file_path): movies = read_csv(file_path) average_rating = calculate_average_rating(movies) top_10_movies = get_top_10_highest_rated_movies(movies) movies_per_year = count_movies_per_year(movies) common_genres = find_most_common_genres(movies) return average_rating, top_10_movies, movies_per_year, common_genres"},{"question":"import pandas as pd import numpy as np from sklearn.preprocessing import StandardScaler from sklearn.cluster import KMeans import matplotlib.pyplot as plt def preprocess_data(data): Preprocess the data by removing missing values and normalizing the features. pass def determine_optimal_clusters(data): Determine the optimal number of clusters using the elbow method. pass def apply_kmeans(data, n_clusters): Apply KMeans clustering algorithm and return the labeled data. pass def visualize_clusters(data, labels): Visualize the clusters and analyze the grouping of customers. pass def kmeans_customer_segmentation(data): Perform the full customer segmentation process using KMeans. pass # Unit tests for the implementation def test_preprocess_data(): data = pd.DataFrame({ 'Annual Income (k)': [15, 16, 17, np.nan, 20], 'Spending Score (1-100)': [39, 81, 6, 77, np.nan] }) processed_data = preprocess_data(data) # Verify if missing values are removed assert processed_data.shape == (3, 2) # Verify if data is normalized assert np.allclose(processed_data.mean(axis=0), [0, 0], atol=1e-7) assert np.allclose(processed_data.std(axis=0), [1, 1], atol=1e-7) def test_determine_optimal_clusters(): # Manually inspecting elbow plot to ensure proper function data = np.random.rand(100, 2) # random data processed_data = preprocess_data(pd.DataFrame(data, columns=['Annual Income (k)', 'Spending Score (1-100)'])) determine_optimal_clusters(processed_data) # This test only validates the plot generation by visual inspection def test_apply_kmeans(): data = pd.DataFrame({ 'Annual Income (k)': [15, 16, 17], 'Spending Score (1-100)': [39, 81, 6] }) processed_data = preprocess_data(data) n_clusters = 2 labels = apply_kmeans(processed_data, n_clusters) # Verify if returned labels are as expected assert len(labels) == processed_data.shape[0] assert set(labels) <= {0, 1} # Only two clusters def test_visualize_clusters(): data = pd.DataFrame({ 'Annual Income (k)': [15, 16, 17], 'Spending Score (1-100)': [39, 81, 6] }) processed_data = preprocess_data(data) n_clusters = 2 labels = apply_kmeans(processed_data, n_clusters) visualize_clusters(processed_data, labels) # This test only validates the plot generation by visual inspection def test_kmeans_customer_segmentation(): data = pd.DataFrame({ 'Annual Income (k)': np.random.randint(15, 100, size=200), 'Spending Score (1-100)': np.random.randint(1, 100, size=200) }) labels = kmeans_customer_segmentation(data) # Check if the correct number of labels are returned assert len(labels) == data.dropna().shape[0]","solution":"import pandas as pd from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler import matplotlib.pyplot as plt import numpy as np def preprocess_data(data): Preprocess the data by removing missing values and normalizing the features. # Remove missing values data_clean = data.dropna() # Extract relevant features features = data_clean[['Annual Income (k)', 'Spending Score (1-100)']] # Normalize the features scaler = StandardScaler() features_scaled = scaler.fit_transform(features) return features_scaled def determine_optimal_clusters(data): Determine the optimal number of clusters using the elbow method. inertia = [] K = range(1, 11) for k in K: kmeans = KMeans(n_clusters=k, random_state=42) kmeans.fit(data) inertia.append(kmeans.inertia_) # Plot the elbow curve plt.figure(figsize=(8, 4)) plt.plot(K, inertia, 'bx-') plt.xlabel('Number of clusters') plt.ylabel('Inertia') plt.title('The Elbow Method showing the optimal k') plt.show() def apply_kmeans(data, n_clusters): Apply KMeans clustering algorithm and return the labeled data. kmeans = KMeans(n_clusters=n_clusters, random_state=42) kmeans.fit(data) return kmeans.labels_ def visualize_clusters(data, labels): Visualize the clusters and analyze the grouping of customers. plt.figure(figsize=(8, 4)) plt.scatter(data[:, 0], data[:, 1], c=labels, cmap='viridis') plt.xlabel('Annual Income (k)') plt.ylabel('Spending Score (1-100)') plt.title('Customer Segments') plt.show() def kmeans_customer_segmentation(data): Perform the full customer segmentation process using KMeans. processed_data = preprocess_data(data) determine_optimal_clusters(processed_data) # Choosing 5 clusters based on elbow method observation n_clusters = 5 labels = apply_kmeans(processed_data, n_clusters) visualize_clusters(processed_data, labels) return labels"},{"question":"from typing import List, Tuple, Union def file_storage_system(max_storage_size: int, operations: List[Tuple[str, str, Union[int, None]]]) -> Union[bool, str, List[int]]: A function to simulate a simple file storage system. It processes a list of operations: adding, deleting, and reading files. The function returns True if all operations are successful, otherwise it returns an error message and the index of the operation that caused the error. Args: max_storage_size (int): The maximum allowed storage size. operations (List[Tuple[str, str, Union[int, None]]]): A list of tuples representing the operations. Returns: Union[bool, str, List[int]]: True if all operations are successful, otherwise an error message and the index of the invalid operation. Examples: >>> file_storage_system(100, [('Add', 'file1.txt', 10), ('Add', 'file2.txt', 20), ('Delete', 'file1.txt', None)]) >>> file_storage_system(50, [('Add', 'file1.txt', 10), ('Add', 'file1.txt', 60), ('Add', 'file2.txt', 20)]) >>> file_storage_system(50, [('Add', 'file1.txt', 20), ('Add', 'file2.txt', 20), ('Read', 'file3.txt', None)]) from solution import file_storage_system def test_file_storage_success(): assert file_storage_system(100, [('Add', 'file1.txt', 10), ('Add', 'file2.txt', 20), ('Delete', 'file1.txt', None)]) == True def test_file_already_exists_error(): assert file_storage_system(50, [('Add', 'file1.txt', 10), ('Add', 'file1.txt', 60), ('Add', 'file2.txt', 20)]) == (\\"Error: File 'file1.txt' already exists\\", 1) def test_exceed_storage_error(): assert file_storage_system(50, [('Add', 'file1.txt', 20), ('Add', 'file2.txt', 20), ('Add', 'file3.txt', 20)]) == (\\"Error: Exceeds maximum storage size\\", 2) def test_delete_non_existent_file_error(): assert file_storage_system(50, [('Delete', 'file1.txt', None)]) == (\\"Error: File 'file1.txt' does not exist\\", 0) def test_read_non_existent_file_error(): assert file_storage_system(50, [('Read', 'file1.txt', None)]) == (\\"Error: File 'file1.txt' does not exist\\", 0) def test_invalid_operation_error(): assert file_storage_system(50, [('Update', 'file1.txt', 10)]) == (\\"Error: Invalid operation 'Update'\\", 0) def test_rollback_not_triggered(): assert file_storage_system(100, [('Add', 'file1.txt', 10)]) == True","solution":"from typing import List, Tuple, Union def file_storage_system(max_storage_size: int, operations: List[Tuple[str, str, Union[int, None]]]) -> Union[bool, str, List[int]]: A function to simulate a simple file storage system. It processes a list of operations: adding, deleting, and reading files. current_storage = {} total_storage = 0 successful_operations = [] for i, (op, filename, filesize) in enumerate(operations): if op == 'Add': if filename in current_storage: return f\\"Error: File '{filename}' already exists\\", i if total_storage + filesize > max_storage_size: return f\\"Error: Exceeds maximum storage size\\", i current_storage[filename] = filesize total_storage += filesize successful_operations.append((op, filename, filesize)) elif op == 'Delete': if filename not in current_storage: return f\\"Error: File '{filename}' does not exist\\", i total_storage -= current_storage.pop(filename) successful_operations.append((op, filename, filesize)) elif op == 'Read': if filename not in current_storage: return f\\"Error: File '{filename}' does not exist\\", i successful_operations.append((op, filename, filesize)) else: return f\\"Error: Invalid operation '{op}'\\", i # Rollback functionality can be triggered on an error, but it's not mentioned how to trigger it in this task. # We assume latest successful operation should be considered as rollback checkpoint in case of external trigger return True"},{"question":"def filter_greater_than(arr, n): Returns a new array containing only the elements from the original array that are greater than n. Args: arr (list): The original array of integers. n (int): The integer threshold. Returns: list: A new array with elements greater than n. Examples: >>> filter_greater_than([1, 2, 3, 4, 5], 3) [4, 5] >>> filter_greater_than([1, 2, 3], 5) [] >>> filter_greater_than([], 3) [] >>> filter_greater_than([6, 7, 8], 5) [6, 7, 8] >>> filter_greater_than([-3, -2, -1, 0, 1], -1) [0, 1] >>> filter_greater_than([-3, 50, 0, 2, 9, -1], 0) [50, 2, 9]","solution":"def filter_greater_than(arr, n): Returns a new array containing only the elements from the original array that are greater than n. Args: arr (list): The original array of integers. n (int): The integer threshold. Returns: list: A new array with elements greater than n. return [x for x in arr if x > n]"},{"question":"def count_occurrences(int_list): Returns a dictionary where the keys are the unique integers from the list and the values are the number of times each integer appears in the list. Example usage: >>> count_occurrences([1, 2, 2, 3, 3, 3]) {1: 1, 2: 2, 3: 3} >>> count_occurrences([]) {} >>> count_occurrences([-1, -1, 2, -1, 2, 2, 2]) {-1: 3, 2: 4} pass # Test cases def test_empty_list(): assert count_occurrences([]) == {} def test_single_element_list(): assert count_occurrences([1]) == {1: 1} def test_unique_elements(): assert count_occurrences([1, 2, 3]) == {1: 1, 2: 1, 3: 1} def test_repeated_elements(): assert count_occurrences([1, 1, 1, 1]) == {1: 4} def test_mixed_elements(): assert count_occurrences([1, 2, 2, 3, 3, 3]) == {1: 1, 2: 2, 3: 3} def test_with_negative_elements(): assert count_occurrences([-1, -1, 2, -1, 2, 2, 2]) == {-1: 3, 2: 4} def test_large_input(): large_list = [1]*1000000 + [2]*1000000 + [3]*1000000 result = count_occurrences(large_list) assert result == {1: 1000000, 2: 1000000, 3: 1000000}","solution":"def count_occurrences(int_list): Returns a dictionary where the keys are the unique integers from the list and the values are the number of times each integer appears in the list. occurrences = {} for num in int_list: if num in occurrences: occurrences[num] += 1 else: occurrences[num] = 1 return occurrences"},{"question":"def partition_list(nums: list[int], k: int) -> None: Reorders the list \`nums\` such that all elements less than \`k\` come before elements greater than or equal to \`k\`, preserving their relative order. Args: nums (list of int): List of integers to be partitioned. k (int): The partition value. Returns: None. The list \`nums\` is modified in place. >>> nums = [5, 1, 4, 2, 3] >>> partition_list(nums, 3) >>> nums [1, 2, 4, 5, 3] >>> nums = [0, -1, 5, -2, 3] >>> partition_list(nums, 0) >>> nums [-1, -2, 5, 0, 3] >>> nums = [] >>> partition_list(nums, 1) >>> nums [] >>> nums = [1] >>> partition_list(nums, 2) >>> nums [1] >>> nums = [3] >>> partition_list(nums, 2) >>> nums [3]","solution":"def partition_list(nums, k): Reorders the list \`nums\` such that all elements less than \`k\` come before elements greater than or equal to \`k\`, preserving their relative order. Args: nums (list of int): List of integers to be partitioned. k (int): The partition value. Returns: None. The list \`nums\` is modified in place. left = 0 # Initialize the left pointer for right in range(len(nums)): if nums[right] < k: nums[left], nums[right] = nums[right], nums[left] left += 1"},{"question":"def split_number(n): Splits the number \`n\` into two parts where: - Both parts are positive integers. - Neither part contains the digit \`2\` or \`6\` in their decimal representation. Returns: list: A list [A, B] where A + B = n and neither A nor B contains the digit \`2\` or \`6\`. Examples: >>> split_number(5) [1, 4] >>> split_number(13) [3, 10] >>> split_number(37) [31, 6] pass","solution":"def split_number(n): Splits the number \`n\` into two parts where: - Both parts are positive integers. - Neither part contains the digit \`2\` or \`6\` in their decimal representation. Returns: list: A list [A, B] where A + B = n and neither A nor B contains the digit \`2\` or \`6\`. def contains_unwanted_digits(number): return '2' in str(number) or '6' in str(number) for i in range(1, n): if not contains_unwanted_digits(i) and not contains_unwanted_digits(n - i): return [i, n - i]"},{"question":"def find_unique_words(sentences: List[str]) -> Set[str]: Returns a set of unique words from the list of sentences, ignoring case and punctuation. >>> find_unique_words([\\"Hello world\\"]) == {\\"hello\\", \\"world\\"} >>> find_unique_words([\\"Hello world\\", \\"The world is beautiful\\", \\"hello Universe\\"]) == {\\"hello\\", \\"world\\", \\"the\\", \\"is\\", \\"beautiful\\", \\"universe\\"} >>> find_unique_words([]) == set() >>> find_unique_words([\\"Hello World\\", \\"hello WORLD\\", \\"HELLO world\\"]) == {\\"hello\\", \\"world\\"} >>> find_unique_words([\\"Hello\\", \\"World\\", \\"Is\\", \\"Beautiful\\"]) == {\\"hello\\", \\"world\\", \\"is\\", \\"beautiful\\"} >>> find_unique_words([\\"Hello Hello\\", \\"world world\\", \\"Is is\\", \\"beautiful Beautiful\\"]) == {\\"hello\\", \\"world\\", \\"is\\", \\"beautiful\\"}","solution":"import re def find_unique_words(sentences): Returns a set of unique words from the list of sentences, ignoring case and punctuation. words = set() for sentence in sentences: # Convert to lowercase and split into words lower_sentence = sentence.lower() words_in_sentence = re.findall(r'bw+b', lower_sentence) words.update(words_in_sentence) return words"},{"question":"from typing import List def second_largest(arr: List[int]) -> int: Given an array of integers, returns the second largest number in the array. Note that the array contains at least two distinct integers. >>> second_largest([10, 20, 4, 45, 99]) 45 >>> second_largest([1, 2, 3, 4]) 3 pass # You can test your implementation using the following test cases: def test_second_largest_example_cases(): assert second_largest([10, 20, 4, 45, 99]) == 45 assert second_largest([1, 2, 3, 4]) == 3 def test_second_largest_with_duplicates(): assert second_largest([10, 20, 20, 4, 4, 45, 99]) == 45 assert second_largest([1, 3, 3, 3, 4]) == 3 def test_second_largest_with_negative_numbers(): assert second_largest([-10, -20, -4, -45, -99]) == -10 assert second_largest([-1, -2, -3, -4]) == -2 def test_second_largest_with_mixed_numbers(): assert second_largest([-1, 0, 1, 2, 3, 4]) == 3 assert second_largest([98, 99, 100, -1, 45, 47]) == 99 def test_second_largest_with_min_integers(): assert second_largest([float('-inf'), 1, 0, 2]) == 1 assert second_largest([3, 2, float('-inf')]) == 2","solution":"from typing import List def second_largest(arr: List[int]) -> int: Returns the second largest number in the array. first, second = float('-inf'), float('-inf') for number in arr: if number > first: second = first first = number elif number > second and number != first: second = number return second"},{"question":"def find_target_indices(strings, target): Returns a list of indices where the target string is found in the list of strings. Parameters: strings (list of str): The list of strings to search within. target (str): The target string to find in the list. Returns: list of int: List of indices at which the target string is found. Returns an empty list if the target string is not found. >>> find_target_indices([\\"apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"grape\\"], \\"apple\\") == [0, 3] >>> find_target_indices([\\"apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"grape\\"], \\"mango\\") == [] >>> find_target_indices([\\"apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"grape\\"], \\"banana\\") == [1] >>> find_target_indices([], \\"apple\\") == [] >>> find_target_indices([\\"Apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"grape\\"], \\"apple\\") == [3] >>> find_target_indices([\\"Apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"grape\\"], \\"Apple\\") == [0]","solution":"def find_target_indices(strings, target): Returns a list of indices where the target string is found in the list of strings. Parameters: strings (list of str): The list of strings to search within. target (str): The target string to find in the list. Returns: list of int: List of indices at which the target string is found. Returns an empty list if the target string is not found. indices = [] for index, string in enumerate(strings): if string == target: indices.append(index) return indices"},{"question":"class InvalidMatrixException(Exception): Custom exception for invalid matrix inputs. pass def matrix_diagonal_diff(matrix): Computes the absolute difference between the sums of the matrix's two diagonals. Args: matrix (list of list of int): A square matrix. Returns: int: The absolute difference between the sums of the matrix's two diagonals. Raises: InvalidMatrixException: If the input is not a square matrix or is not a list of lists of integers. Test cases: >>> matrix_diagonal_diff([[1, 2], [3, 4]]) == 0 >>> matrix_diagonal_diff([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0 >>> try: ... matrix_diagonal_diff([[1, 2], [3, '4']]) ... except InvalidMatrixException as e: ... str(e) == \\"All elements must be integers.\\" >>> try: ... matrix_diagonal_diff([[1, 2], [3, 4, 5]]) ... except InvalidMatrixException as e: ... str(e) == \\"Input must be a square matrix.\\" >>> try: ... matrix_diagonal_diff([1, 2, 3]) ... except InvalidMatrixException as e: ... str(e) == \\"Input must be a list of lists.\\"","solution":"class InvalidMatrixException(Exception): pass def matrix_diagonal_diff(matrix): if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise InvalidMatrixException(\\"Input must be a list of lists.\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise InvalidMatrixException(\\"Input must be a square matrix.\\") for row in matrix: if not all(isinstance(elem, int) for elem in row): raise InvalidMatrixException(\\"All elements must be integers.\\") primary_diag_sum = sum(matrix[i][i] for i in range(n)) secondary_diag_sum = sum(matrix[i][n - i - 1] for i in range(n)) return abs(primary_diag_sum - secondary_diag_sum)"},{"question":"def is_valid_parentheses(s: str) -> bool: Evaluate if a string has a valid parenthesis sequence including (), {}, and [] >>> is_valid_parentheses(\\"({[()]})\\") == True >>> is_valid_parentheses(\\"([)]\\") == False >>> is_valid_parentheses(\\"(((\\") == False >>> is_valid_parentheses(\\"\\") == True >>> is_valid_parentheses(\\")\\") == False >>> is_valid_parentheses(\\"{[()]}\\") == True >>> is_valid_parentheses(\\"a(b)c{d[e]f}g\\") == True >>> is_valid_parentheses(\\"a(b)c{d[e]f}g)\\") == False","solution":"def is_valid_parentheses(s): Evaluate if a string has a valid parenthesis sequence including (), {}, and [] stack = [] matching_parenthesis = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parenthesis.values(): stack.append(char) elif char in matching_parenthesis.keys(): if stack == [] or matching_parenthesis[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def find_convex_hull(points: List[List[int]]) -> List[List[int]]: Finds the convex hull of a set of 2D points using Andrew's monotone chain algorithm. >>> find_convex_hull([[0,0],[1,1],[2,2],[3,3],[2,0],[2,4],[4,2]]) [[0,0],[2,0],[4,2],[2,4]] >>> find_convex_hull([[1,1],[2,2],[2,0],[2,4],[3,3]]) [[1,1],[2,0],[3,3],[2,4]] from solution import find_convex_hull def test_find_convex_hull_example_1(): points = [[0,0],[1,1],[2,2],[3,3],[2,0],[2,4],[4,2]] hull = find_convex_hull(points) expected = [[0,0],[2,0],[4,2],[2,4]] assert hull == expected def test_find_convex_hull_example_2(): points = [[1,1],[2,2],[2,0],[2,4],[3,3]] hull = find_convex_hull(points) expected = [[1,1],[2,0],[3,3],[2,4]] assert hull == expected def test_find_convex_hull_simple_triangle(): points = [[0,0],[1,1],[0,2]] hull = find_convex_hull(points) expected = [[0,0],[1,1],[0,2]] assert hull == expected def test_find_convex_hull_collinear_points(): points = [[0,0],[1,1],[2,2],[3,3]] hull = find_convex_hull(points) expected = [[0,0],[3,3]] assert hull == expected def test_find_convex_hull_square(): points = [[0,0],[0,1],[1,0],[1,1]] hull = find_convex_hull(points) expected = [[0,0],[1,0],[1,1],[0,1]] assert hull == expected","solution":"def find_convex_hull(points): Finds the convex hull of a set of 2D points using Andrew's monotone chain algorithm. :param points: A list of lists containing the x and y coordinates of the points. :return: A list of lists containing the coordinates of the convex hull in counterclockwise order. points = sorted(points) def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) return lower[:-1] + upper[:-1]"},{"question":"def filter_above_average(items): Returns a list of item names whose price is above the average price of all items. Parameters: items (list of dict): A list of dictionaries, each with 'name' (str) and 'price' (float). Returns: list of str: A list of item names with prices above the average price. >>> filter_above_average([{'name': 'apple', 'price': 1.2}, {'name': 'banana', 'price': 0.8}, {'name': 'cherry', 'price': 2.5}]) ['cherry'] >>> filter_above_average([]) [] >>> filter_above_average([{'name': 'apple', 'price': 1.5}]) [] def test_empty_list(): assert filter_above_average([]) == [] def test_single_item(): items = [{'name': 'apple', 'price': 1.5}] assert filter_above_average(items) == [] def test_all_items_below_average(): items = [ {'name': 'apple', 'price': 1.0}, {'name': 'banana', 'price': 1.0} ] assert filter_above_average(items) == [] def test_single_item_above_average(): items = [ {'name': 'apple', 'price': 1.0}, {'name': 'banana', 'price': 2.0} ] assert filter_above_average(items) == ['banana'] def test_multiple_items_above_average(): items = [ {'name': 'apple', 'price': 1.2}, {'name': 'banana', 'price': 0.8}, {'name': 'cherry', 'price': 2.5} ] assert filter_above_average(items) == ['cherry'] def test_complex_scenario(): items = [ {'name': 'item1', 'price': 10}, {'name': 'item2', 'price': 20}, {'name': 'item3', 'price': 30}, {'name': 'item4', 'price': 40}, {'name': 'item5', 'price': 50} ] assert filter_above_average(items) == ['item4', 'item5']","solution":"def filter_above_average(items): Returns a list of item names whose price is above the average price of all items. Parameters: items (list of dict): A list of dictionaries, each with 'name' (str) and 'price' (float). Returns: list of str: A list of item names with prices above the average price. if not items: return [] # Calculate average price total_price = sum(item['price'] for item in items) average_price = total_price / len(items) # Filter items with price above average above_average_items = [item['name'] for item in items if item['price'] > average_price] return above_average_items"},{"question":"import copy def shallow_copy_example(original_list): Returns a shallow copy of the original list. >>> shallow_copy_example([1, [2, 3], 4]) [1, [2, 3], 4] return copy.copy(original_list) def deep_copy_example(original_list): Returns a deep copy of the original list. >>> deep_copy_example([1, [2, 3], 4]) [1, [2, 3], 4] return copy.deepcopy(original_list)","solution":"import copy def shallow_copy_example(original_list): Returns a shallow copy of the original list. return copy.copy(original_list) def deep_copy_example(original_list): Returns a deep copy of the original list. return copy.deepcopy(original_list) # Example of shallow copy vs. deep copy original_list = [1, [2, 3], 4] shallow_copied_list = shallow_copy_example(original_list) deep_copied_list = deep_copy_example(original_list) # Modify the nested list in the original list original_list[1][0] = 'modified' # Now, shallow_copied_list will reflect the change but deep_copied_list will not shallow_copied_result = shallow_copied_list deep_copied_result = deep_copied_list shallow_copied_result, deep_copied_result"},{"question":"def find_unique_number(nums): Finds and returns the unique number in a list where every other number appears exactly twice. >>> find_unique_number([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_number([2, 2, 1]) 1 >>> find_unique_number([5, 3, 5, 2, 3]) 2 >>> find_unique_number([10]) 10 >>> find_unique_number([0, 1, 2, 2, 1]) 0 >>> find_unique_number([999, 0, 999, 8]) 8 >>> find_unique_number([0, 0, 7]) 7","solution":"def find_unique_number(nums): Finds and returns the unique number in a list where every other number appears exactly twice. unique_number = 0 for num in nums: unique_number ^= num return unique_number # Example usage: # find_unique_number([4, 3, 2, 4, 1, 3, 2]) should return 1"},{"question":"def total_inventory(items): Returns the total number of items available in the inventory. Args: items (list of tuples): A list where each tuple contains an item name and its quantity. Returns: int: The total number of items. total = 0 for item, quantity in items: total += quantity return total if __name__ == \\"__main__\\": def test_total_inventory_normal_case(): assert total_inventory([('apple', 10), ('banana', 5), ('orange', 3), ('apple', 2)]) == 20 def test_total_inventory_empty_list(): assert total_inventory([]) == 0 def test_total_inventory_single_item(): assert total_inventory([('apple', 10)]) == 10 def test_total_inventory_duplicates(): assert total_inventory([('apple', 3), ('apple', 3), ('apple', 3)]) == 9 def test_total_inventory_zero_quantities(): assert total_inventory([('apple', 0), ('banana', 0), ('orange', 0)]) == 0 test_total_inventory_normal_case() test_total_inventory_empty_list() test_total_inventory_single_item() test_total_inventory_duplicates() test_total_inventory_zero_quantities() print(\\"All tests passed!\\")","solution":"def total_inventory(items): Returns the total number of items available in the inventory. Args: items (list of tuples): A list where each tuple contains an item name and its quantity. Returns: int: The total number of items. total = 0 for item, quantity in items: total += quantity return total"},{"question":"def reverse_string(input_str: str) -> str: Write a function that takes a string as input and returns a new string with the characters in reverse order. >>> reverse_string(\\"hello\\") == \\"olleh\\" >>> reverse_string(\\"\\") == \\"\\" >>> reverse_string(\\"madam\\") == \\"madam\\" >>> reverse_string(\\"a man a plan\\") == \\"nalp a nam a\\" >>> reverse_string(\\"!@# %^&\\") == \\"&^% #@!\\"","solution":"def reverse_string(input_str): Returns a new string with the characters in reverse order. return input_str[::-1]"},{"question":"import random from typing import List, Tuple def generate_rectangles(W: int, H: int, N: int, min_w: int, min_h: int, max_w: int, max_h: int) -> List[Tuple[int, int, int, int]]: Generate random, non-overlapping rectangles within a specified boundary size. Args: W: Integer representing the width of the boundary. H: Integer representing the height of the boundary. N: Integer representing the number of rectangles to be generated. min_w: Integer representing the minimum width of the rectangles. min_h: Integer representing the minimum height of the rectangles. max_w: Integer representing the maximum width of the rectangles. max_h: Integer representing the maximum height of the rectangles. Returns: A list of tuples, where each tuple represents a rectangle with coordinates (x, y, width, height), indicating the top-left corner and dimensions. >>> rectangles = generate_rectangles(100, 100, 5, 10, 10, 30, 30) >>> all(0 <= x < 100 and 0 <= y < 100 and x + w <= 100 and y + h <= 100 for (x, y, w, h) in rectangles) True >>> len(rectangles) 5 >>> all(10 <= w <= 30 and 10 <= h <= 30 for (x, y, w, h) in rectangles) True","solution":"import random from typing import List, Tuple def generate_rectangles(W: int, H: int, N: int, min_w: int, min_h: int, max_w: int, max_h: int) -> List[Tuple[int, int, int, int]]: def is_overlapping(rect1, rect2): x1, y1, w1, h1 = rect1 x2, y2, w2, h2 = rect2 return not (x1 + w1 <= x2 or x2 + w2 <= x1 or y1 + h1 <= y2 or y2 + h2 <= y1) rectangles = [] retries = 1000 # Limit the retries to avoid infinite loops while len(rectangles) < N and retries > 0: w = random.randint(min_w, max_w) h = random.randint(min_h, max_h) x = random.randint(0, W - w) y = random.randint(0, H - h) new_rect = (x, y, w, h) if all(not is_overlapping(new_rect, existing_rect) for existing_rect in rectangles): rectangles.append(new_rect) else: retries -= 1 return rectangles"},{"question":"from typing import List, Tuple def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Create a function that takes in a list of integers and a target integer. The function should return a list of tuples, where each tuple contains a pair of indices whose corresponding elements in the input list sum up to the target integer. Ensure that each pair of indices (i, j) meets the criteria i < j and does not include the same pair more than once in the result. >>> find_pairs_with_sum([2, 7, 11, 15], 9) [(0, 1)] >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) [(1, 3), (2, 4)] >>> find_pairs_with_sum([5, 5, 5], 10) [(0, 1), (0, 2), (1, 2)] >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([1], 2) [] pass def test_find_pairs_with_single_pair(): assert find_pairs_with_sum([2, 7, 11, 15], 9) == [(0, 1)] def test_find_pairs_with_multiple_pairs(): assert find_pairs_with_sum([1, 2, 3, 4, 3], 6) == [(1, 3), (2, 4)] def test_find_pairs_with_same_numbers(): assert find_pairs_with_sum([5, 5, 5], 10) == [(0, 1), (0, 2), (1, 2)] def test_find_pairs_with_no_matches(): assert find_pairs_with_sum([1, 2, 3], 7) == [] def test_find_pairs_with_empty_list(): assert find_pairs_with_sum([], 5) == [] def test_find_pairs_with_one_element(): assert find_pairs_with_sum([1], 2) == [] def test_find_pairs_with_repeated_elements(): assert find_pairs_with_sum([1, 1, 1, 1], 2) == [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]","solution":"from typing import List, Tuple def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of tuples where each tuple contains pairs of indices whose corresponding elements in the input list sum up to the target integer. pairs = [] seen_indices = set() for i in range(len(nums)): for j in range(i + 1, len(nums)): if (nums[i] + nums[j] == target) and (i, j) not in seen_indices: pairs.append((i, j)) seen_indices.add((i, j)) seen_indices.add((j, i)) return pairs"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to the given target. :param nums: List[int] - List of integers :param target: int - Target sum :return: List[int] - Indices of the two numbers Example 1: >>> two_sum([2, 7, 11, 15], 9) [0, 1] Example 2: >>> two_sum([3, 2, 4], 6) [1, 2] Example 3: >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the given target. :param nums: List[int] - List of integers :param target: int - Target sum :return: List[int] - Indices of the two numbers num_to_index = {} for i, num in enumerate(nums): diff = target - num if diff in num_to_index: return [num_to_index[diff], i] num_to_index[num] = i return []"},{"question":"def intersection_of_lists(list1, list2): Returns a new list containing the intersection of the two input lists with duplicates considered. Args: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: list: A new list containing the intersection of the two input lists with duplicates. Raises: ValueError: If either of the arguments is not a list or the lists contain non-integer elements. Examples: >>> intersection_of_lists([1, 2, 3], [2, 3, 4]) [2, 3] >>> intersection_of_lists([1, 2, 2, 3], [2, 2, 4]) [2, 2] >>> intersection_of_lists([1, 'a'], [2, 3]) Traceback (most recent call last): ... ValueError: Both lists must contain only integers >>> intersection_of_lists([1, 2, 3], \\"not a list\\") Traceback (most recent call last): ... ValueError: Both arguments must be lists","solution":"def intersection_of_lists(list1, list2): Returns a new list containing the intersection of the two input lists with duplicates considered. if not isinstance(list1, list) or not isinstance(list2, list): raise ValueError(\\"Both arguments must be lists\\") if any(not isinstance(x, int) for x in list1) or any(not isinstance(x, int) for x in list2): raise ValueError(\\"Both lists must contain only integers\\") list1_counter = {} list2_counter = {} for item in list1: if item in list1_counter: list1_counter[item] += 1 else: list1_counter[item] = 1 for item in list2: if item in list2_counter: list2_counter[item] += 1 else: list2_counter[item] = 1 intersection = [] for item in list1_counter: if item in list2_counter: min_count = min(list1_counter[item], list2_counter[item]) intersection.extend([item] * min_count) return intersection"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-1) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(29) True def prime_counts(numbers: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the prime integers from the list, and the values are the number of times each prime integer appears in the list. >>> numbers = [3, 5, 7, 11, 3, 5, 2, 11, 13, 5, 3, 7] >>> prime_counts(numbers) {3: 3, 5: 3, 7: 2, 11: 2, 2: 1, 13: 1} >>> prime_counts([]) {} >>> prime_counts([4, 6, 8, 9, 10, 12]) {} >>> numbers = [17, 19, 20, 21, 19, 22, 2] >>> prime_counts(numbers) {17: 1, 19: 2, 2: 1}","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def prime_counts(numbers): Returns a dictionary where the keys are the prime integers from the list, and the values are the number of times each prime integer appears in the list. prime_count_dict = {} for num in numbers: if is_prime(num): if num in prime_count_dict: prime_count_dict[num] += 1 else: prime_count_dict[num] = 1 return prime_count_dict"},{"question":"def string_lengths(string_list: List[str]) -> Dict[str, int]: Write a Python function that accepts a list of strings and returns a dictionary where each key is a unique string from the list and the corresponding value is the length of that string. Ensure your solution respects case-sensitivity, meaning \\"hello\\" and \\"Hello\\" should be treated as different strings. >>> string_lengths([\\"hello\\", \\"world\\", \\"Hello\\"]) {'hello': 5, 'world': 5, 'Hello': 5} >>> string_lengths([]) {} >>> string_lengths([\\"a\\", \\"b\\", \\"c\\"]) {'a': 1, 'b': 1, 'c': 1} >>> string_lengths([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) {'a': 1, 'ab': 2, 'abc': 3, 'abcd': 4} >>> string_lengths([\\"test\\", \\"test\\", \\"Test\\"]) {'test': 4, 'Test': 4}","solution":"def string_lengths(string_list): Returns a dictionary where each key is a unique string from the list and the corresponding value is the length of that string. return {s: len(s) for s in string_list}"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"ab\\") 2 >>> length_of_longest_substring_two_distinct(\\"abcba\\") 3 >>> length_of_longest_substring_two_distinct(\\"aaabbb\\") 6 >>> length_of_longest_substring_two_distinct(\\"aabbcc\\") 4 >>> length_of_longest_substring_two_distinct(\\"aabbaacc\\") 6","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 hashmap = {} max_len = 2 while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def longest_even_subsequence(arr): This function takes in an array of integers and returns the length of the longest contiguous subsequence wherein all the numbers are even. If there are no even numbers in the array, the function should return 0. Example cases: >>> longest_even_subsequence([1, 2, 4, 6, 3, 8, 10, 2]) == 3 # [4, 6] is the longest even subsequence. >>> longest_even_subsequence([1, 3, 5, 7]) == 0 # No even numbers are present. >>> longest_even_subsequence([2, 4, 6, 8, 10]) == 5 # Entire array consists of even numbers.","solution":"def longest_even_subsequence(arr): This function takes in an array of integers and returns the length of the longest contiguous subsequence wherein all the numbers are even. If there are no even numbers in the array, the function should return 0. max_len = 0 current_len = 0 for num in arr: if num % 2 == 0: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of the list nums. Each subset is sorted in non-descending order. Duplicate subsets are not included. >>> subsets([]) == [[]] >>> subsets([1]) == [[], [1]] >>> subsets([1, 2]) == [[], [1], [1, 2], [2]] >>> subsets([1, 2, 2]) == [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> subsets([-1, 0, 1]) == [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]] >>> subsets([3, 1, 2]) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> len(subsets([1, 2, 3, 4])) == 16 # 2^4 subsets","solution":"def subsets(nums): Returns all possible subsets of the list nums. Each subset is sorted in non-descending order. Duplicate subsets are not included. def backtrack(start, end, path): result.append(path) for i in range(start, end): if i > start and nums[i] == nums[i - 1]: # skip duplicates continue backtrack(i + 1, end, path + [nums[i]]) nums.sort() # sort the nums to ensure non-descending order in subsets result = [] backtrack(0, len(nums), []) return result"},{"question":"from typing import List def longestSubarray(nums: List[int], k: int) -> int: Given an array of integers \`nums\`, return the length of the longest contiguous subarray that sums to a given target \`k\`. The subarray must have at least a length of 1. If no such subarray exists, return 0. Example 1: >>> longestSubarray([1, -1, 5, -2, 3], 3) 4 Example 2: >>> longestSubarray([-2, -1, 2, 1], 1) 2 Example 3: >>> longestSubarray([1, 2, 3], 6) 3 pass def test_longest_subarray_case_1(): nums = [1, -1, 5, -2, 3] k = 3 assert longestSubarray(nums, k) == 4 def test_longest_subarray_case_2(): nums = [-2, -1, 2, 1] k = 1 assert longestSubarray(nums, k) == 2 def test_longest_subarray_case_3(): nums = [1, 2, 3] k = 6 assert longestSubarray(nums, k) == 3 def test_longest_subarray_case_no_existence(): nums = [1, 2, 3] k = 7 assert longestSubarray(nums, k) == 0 def test_longest_subarray_case_large_numbers(): nums = [1000, -1000, 1000, -1000, 1000] k = 0 assert longestSubarray(nums, k) == 4 def test_longest_subarray_case_negatives(): nums = [-1, -1, -1, -1] k = -2 assert longestSubarray(nums, k) == 2","solution":"def longestSubarray(nums, k): Returns the length of the longest contiguous subarray that sums to k. If no such subarray exists, return 0. sum_map = {} # Dictionary to store (sum, index) pairs current_sum = 0 # Initialize the cumulative sum max_length = 0 # Initialize the max_length of the subarray for i, num in enumerate(nums): current_sum += num # Check if current_sum is equal to k if current_sum == k: max_length = i + 1 # Check if current_sum - k exists in the dictionary if (current_sum - k) in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) # Store current_sum[i] if it is not already in the dictionary if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"def char_count(s: str) -> dict: Create a function that accepts a string as an argument and returns a dictionary where the keys are the unique characters in the string and the values are the counts of those characters. Treats characters as case insensitive. >>> char_count(\\"apple\\") {'a': 1, 'p': 2, 'l': 1, 'e': 1} >>> char_count(\\"ApPlE\\") {'a': 1, 'p': 2, 'l': 1, 'e': 1} >>> char_count(\\"aaBBcc\\") {'a': 2, 'b': 2, 'c': 2} >>> char_count(\\"apple!@#\\") {'a': 1, 'p': 2, 'l': 1, 'e': 1, '!': 1, '@': 1, '#': 1} >>> char_count(\\"\\") {} >>> char_count(\\"ab12ab12\\") {'a': 2, 'b': 2, '1': 2, '2': 2}","solution":"def char_count(s): Returns a dictionary with the count of each unique character in the string. Treats characters as case insensitive. s = s.lower() count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string expression involving addition and subtraction of non-negative integers. >>> evaluate_expression(\\"3 + 2 - 1\\") 4 >>> evaluate_expression(\\"10 - 5 + 3\\") 8 >>> evaluate_expression(\\"7 + 2 - 3 + 5 - 8\\") 3 >>> evaluate_expression(\\" 3 + 2 \\") 5 >>> evaluate_expression(\\" 10 - 5 + 3 \\") 8 >>> evaluate_expression(\\" 7 + 2 - 3 + 5 - 8 \\") 3 >>> evaluate_expression(\\"5\\") 5 >>> evaluate_expression(\\" 10 \\") 10 >>> evaluate_expression(\\"1 + 1 + 1 + 1\\") 4 >>> evaluate_expression(\\" 2 + 3 + 4 + 5 \\") 14 >>> evaluate_expression(\\"10 - 1 - 2 - 3\\") 4 >>> evaluate_expression(\\" 20 - 10 - 5 \\") 5","solution":"def evaluate_expression(expression): Evaluates a string expression involving addition and subtraction of non-negative integers. Parameters: expression (str): The string containing the mathematical expression. Returns: int: The result of the evaluated expression. # Remove leading and trailing spaces expression = expression.strip() # Split the expression by spaces tokens = expression.split() # Initialize the result and the current operand result = 0 current_op = '+' for token in tokens: if token.isdigit() or token in ('+', '-'): if token.isdigit(): if current_op == '+': result += int(token) elif current_op == '-': result -= int(token) else: current_op = token return result"},{"question":"def factorial(n): Returns the factorial of a given non-negative integer n. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(5) == 120 >>> factorial(6) == 720 >>> factorial(10) == 3628800 >>> try: ... factorial(-1) ... except ValueError as e: ... str(e) == \\"Factorial is not defined for negative integers\\"","solution":"def factorial(n): Returns the factorial of a given non-negative integer n. if n < 0: raise ValueError(\\"Factorial is not defined for negative integers\\") result = 1 i = 1 # Start with 1 since multiplying by 0 would result in 0 while i <= n: result *= i i += 1 return result # Example usage n = 5 print(f\\"The factorial of {n} is {factorial(n)}\\")"},{"question":"class LibrarySystem: A class to manage a library system offering various services for managing book information, adding, borrowing, returning, searching, and recommending books. def __init__(self): self.books = {} # {ISBN: {\\"title\\": ..., \\"author\\": ..., \\"genre\\": ..., \\"is_borrowed\\": ...}} self.borrowed_books = set() # Set of borrowed ISBNs def add_book(self, isbn, title, author, genre): Adds a new book to the library. Args: isbn (str): The unique ISBN of the book. title (str): The title of the book. author (str): The author of the book. genre (str): The genre of the book. Raises: ValueError: If the ISBN is a duplicate or any required field is missing. pass def borrow_book(self, isbn): Handles the borrowing of a book. Args: isbn (str): The unique ISBN of the book to be borrowed. Raises: ValueError: If the book does not exist or is already borrowed. pass def return_book(self, isbn): Handles the returning of a borrowed book. Args: isbn (str): The unique ISBN of the book to be returned. Raises: ValueError: If the book does not exist or was not borrowed. pass def search_books(self, title=None, author=None, genre=None): Searches for books in the library by title, author, or genre. Args: title (str, optional): The title of the book. author (str, optional): The author of the book. genre (str, optional): The genre of the book. Returns: list: A list of dictionaries containing details of the matching books. pass def recommend_book(self, genre): Recommends an available book from the same genre when a book is borrowed. Args: genre (str): The genre of the book. Returns: dict: The details of the recommended book if available. Otherwise, a message indicating no books are available. pass import pytest def test_add_book(): library = LibrarySystem() library.add_book(\\"123\\", \\"Book One\\", \\"Author A\\", \\"Fiction\\") assert library.books[\\"123\\"] == { \\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"genre\\": \\"Fiction\\", \\"is_borrowed\\": False } with pytest.raises(ValueError): library.add_book(\\"123\\", \\"Book Two\\", \\"Author B\\", \\"Non-Fiction\\") with pytest.raises(ValueError): library.add_book(\\"\\", \\"Book Three\\", \\"Author C\\", \\"Fiction\\") def test_borrow_book(): library = LibrarySystem() library.add_book(\\"123\\", \\"Book One\\", \\"Author A\\", \\"Fiction\\") library.borrow_book(\\"123\\") assert library.books[\\"123\\"][\\"is_borrowed\\"] with pytest.raises(ValueError): library.borrow_book(\\"124\\") with pytest.raises(ValueError): library.borrow_book(\\"123\\") def test_return_book(): library = LibrarySystem() library.add_book(\\"123\\", \\"Book One\\", \\"Author A\\", \\"Fiction\\") library.borrow_book(\\"123\\") library.return_book(\\"123\\") assert not library.books[\\"123\\"][\\"is_borrowed\\"] with pytest.raises(ValueError): library.return_book(\\"124\\") with pytest.raises(ValueError): library.return_book(\\"123\\") def test_search_books(): library = LibrarySystem() library.add_book(\\"123\\", \\"Book One\\", \\"Author A\\", \\"Fiction\\") library.add_book(\\"124\\", \\"Book Two\\", \\"Author B\\", \\"Non-Fiction\\") result = library.search_books(title=\\"Book One\\") assert len(result) == 1 and result[0][\\"isbn\\"] == \\"123\\" result = library.search_books(author=\\"Author B\\") assert len(result) == 1 and result[0][\\"isbn\\"] == \\"124\\" result = library.search_books(genre=\\"Fiction\\") assert len(result) == 1 and result[0][\\"isbn\\"] == \\"123\\" def test_recommend_book(): library = LibrarySystem() library.add_book(\\"123\\", \\"Book One\\", \\"Author A\\", \\"Fiction\\") library.add_book(\\"124\\", \\"Book Two\\", \\"Author B\\", \\"Fiction\\") library.borrow_book(\\"123\\") result = library.recommend_book(\\"Fiction\\") assert result == { \\"isbn\\": \\"124\\", \\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"genre\\": \\"Fiction\\", \\"is_borrowed\\": False } result = library.recommend_book(\\"Non-Fiction\\") assert result == \\"No books available for recommendation in this genre.\\"","solution":"class LibrarySystem: def __init__(self): self.books = {} # {ISBN: {\\"title\\": ..., \\"author\\": ..., \\"genre\\": ..., \\"is_borrowed\\": ...}} self.borrowed_books = set() # Set of borrowed ISBNs def add_book(self, isbn, title, author, genre): if isbn in self.books: raise ValueError(\\"Duplicate ISBN not allowed.\\") if not all([isbn, title, author, genre]): raise ValueError(\\"All book details must be provided.\\") self.books[isbn] = { \\"title\\": title, \\"author\\": author, \\"genre\\": genre, \\"is_borrowed\\": False } def borrow_book(self, isbn): if isbn not in self.books: raise ValueError(\\"Book does not exist in the library.\\") if self.books[isbn][\\"is_borrowed\\"]: raise ValueError(\\"Book is already borrowed.\\") self.books[isbn][\\"is_borrowed\\"] = True self.borrowed_books.add(isbn) def return_book(self, isbn): if isbn not in self.books: raise ValueError(\\"Book does not exist in the library.\\") if not self.books[isbn][\\"is_borrowed\\"]: raise ValueError(\\"Book was not borrowed.\\") self.books[isbn][\\"is_borrowed\\"] = False self.borrowed_books.remove(isbn) def search_books(self, title=None, author=None, genre=None): results = [] for isbn, details in self.books.items(): if ( (title is None or details[\\"title\\"] == title) and (author is None or details[\\"author\\"] == author) and (genre is None or details[\\"genre\\"] == genre) ): results.append({**details, \\"isbn\\": isbn}) return results def recommend_book(self, genre): for isbn, details in self.books.items(): if details[\\"genre\\"] == genre and not details[\\"is_borrowed\\"]: return {**details, \\"isbn\\": isbn} return \\"No books available for recommendation in this genre.\\""},{"question":"def process_mixed_list(input_list: list) -> list: This function processes a mixed list of integers and strings. Each integer is doubled and each string is converted to uppercase. Args: input_list (list): A list of integers and strings. Returns: list: A new list with processed integers and strings. >>> process_mixed_list([1, 'hello', 5, 'world', 10]) [2, 'HELLO', 10, 'WORLD', 20] >>> process_mixed_list(['python', 7, 'programming', 3]) ['PYTHON', 14, 'PROGRAMMING', 6]","solution":"def process_mixed_list(input_list: list) -> list: This function processes a mixed list of integers and strings. Each integer is doubled and each string is converted to uppercase. Args: input_list (list): A list of integers and strings. Returns: list: A new list with processed integers and strings. result = [] for item in input_list: if isinstance(item, int): result.append(item * 2) elif isinstance(item, str): result.append(item.upper()) return result"},{"question":"def generatePalindromicSubstrings(s: str) -> list: Generates all possible palindromic substrings from a given string \`s\` in lexicographical order. >>> generatePalindromicSubstrings(\\"a\\") [\\"a\\"] >>> generatePalindromicSubstrings(\\"aa\\") [\\"a\\", \\"aa\\"] >>> generatePalindromicSubstrings(\\"ab\\") [\\"a\\", \\"b\\"] >>> generatePalindromicSubstrings(\\"aabb\\") [\\"a\\", \\"aa\\", \\"b\\", \\"bb\\"] >>> generatePalindromicSubstrings(\\"racecar\\") ['a', 'aceca', 'c', 'cec', 'e', 'r', 'racecar'] # Complete the function implementation here","solution":"def generatePalindromicSubstrings(s): Generates all possible palindromic substrings from a given string \`s\` in lexicographical order. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() # Generate all substrings and check if they are palindromes for start in range(len(s)): for end in range(start, len(s)): substring = s[start:end + 1] if is_palindrome(substring): palindromes.add(substring) return sorted(palindromes) # Example usage # print(generatePalindromicSubstrings(\\"aabb\\")) # Output: ['a', 'a', 'aa', 'b', 'b', 'bb']"},{"question":"class CircularQueue: This class represents a fixed-size circular queue data structure. Methods: - enqueue(element): Adds an element to the end of the queue. Raises an OverflowError if the queue is full. - dequeue(): Removes and returns the front element of the queue. Raises an IndexError if the queue is empty. - get_size(): Returns the current number of elements in the queue. - is_empty(): Returns True if the queue is empty, False otherwise. - is_full(): Returns True if the queue is full, False otherwise. >>> q = CircularQueue(3) >>> q.enqueue(1) >>> q.enqueue(2) >>> q.enqueue(3) >>> try: ... q.enqueue(4) ... except OverflowError as e: ... print(e) Queue is full >>> q.dequeue() 1 >>> q.dequeue() 2 >>> q.dequeue() 3 >>> try: ... q.dequeue() ... except IndexError as e: ... print(e) Queue is empty >>> q.enqueue(1) >>> q.is_empty() False >>> q.is_full() False >>> q.get_size() 1 def test_enqueue(): q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) with pytest.raises(OverflowError): q.enqueue(4) def test_dequeue(): q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.dequeue() == 1 assert q.dequeue() == 2 assert q.dequeue() == 3 with pytest.raises(IndexError): q.dequeue() def test_size(): q = CircularQueue(3) assert q.get_size() == 0 q.enqueue(1) q.enqueue(2) assert q.get_size() == 2 q.dequeue() assert q.get_size() == 1 q.dequeue() assert q.get_size() == 0 def test_is_empty(): q = CircularQueue(3) assert q.is_empty() is True q.enqueue(1) assert q.is_empty() is False def test_is_full(): q = CircularQueue(3) assert q.is_full() is False q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.is_full() is True def test_circular_behavior(): q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) q.dequeue() q.dequeue() q.enqueue(4) q.enqueue(5) assert q.dequeue() == 3 assert q.dequeue() == 4 assert q.dequeue() == 5","solution":"class CircularQueue: def __init__(self, capacity): Initialize the circular queue with a fixed capacity. self.capacity = capacity self.queue = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, element): Add an element to the end of the queue. Raise an OverflowError if the queue is full. if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.tail] = element self.tail = (self.tail + 1) % self.capacity self.size += 1 def dequeue(self): Remove and return the front element of the queue. Raise an IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") element = self.queue[self.head] self.queue[self.head] = None # Clear the slot self.head = (self.head + 1) % self.capacity self.size -= 1 return element def get_size(self): Return the number of elements currently in the queue. return self.size def is_empty(self): Return True if the queue is empty, False otherwise. return self.size == 0 def is_full(self): Return True if the queue is full, False otherwise. return self.size == self.capacity"},{"question":"import multiprocessing from typing import List def square_number(number: int, result: multiprocessing.managers.ListProxy, index: int): This function computes the square of a number and stores it at the specified index of a shared list. result[index] = number * number def square_numbers(numbers: List[int]) -> List[int]: This function takes a list of numbers, computes the square of each number using multiple processes, and returns a new list with the squared values. >>> square_numbers([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> square_numbers([0, 0, 0]) [0, 0, 0] >>> square_numbers([-1, -2, -3]) [1, 4, 9] >>> square_numbers([5, -4, 0]) [25, 16, 0] >>> square_numbers([1000, -2000]) [1000000, 4000000] manager = multiprocessing.Manager() result = manager.list([0] * len(numbers)) # Shared list jobs = [] for i, num in enumerate(numbers): p = multiprocessing.Process(target=square_number, args=(num, result, i)) jobs.append(p) p.start() for j in jobs: j.join() return list(result)","solution":"import multiprocessing def square_number(number, result, index): This function computes the square of a number and stores it at the specified index of a shared list. result[index] = number * number def square_numbers(numbers): This function takes a list of numbers, computes the square of each number using multiple processes, and returns a new list with the squared values. manager = multiprocessing.Manager() result = manager.list([0] * len(numbers)) # Shared list jobs = [] for i, num in enumerate(numbers): p = multiprocessing.Process(target=square_number, args=(num, result, i)) jobs.append(p) p.start() for j in jobs: j.join() return list(result)"},{"question":"def get_books_by_year(books: List[Dict[str, Union[str, int]]], year: int, sort_by: str = 'none') -> List[str]: Returns a list of titles of books published in a given year, with an option to sort the titles either alphabetically or by publication year. :param books: List of dictionaries where each dictionary represents a book with 'title', 'author', 'year_published', and 'genre'. :param year: An integer representing the year of publication to filter the books. :param sort_by: A string that indicates the sort order: 'none', 'title', or 'year'. Default is 'none', no sorting applied. :return: List of titles of books published in the given year. >>> books = [ ... {'title': 'Book A', 'author': 'Author X', 'year_published': 2021, 'genre': 'Fiction'}, ... {'title': 'Book B', 'author': 'Author Y', 'year_published': 2022, 'genre': 'Science'}, ... {'title': 'Book C', 'author': 'Author Z', 'year_published': 2021, 'genre': 'History'} ... ] >>> get_books_by_year(books, 2021) ['Book A', 'Book C'] >>> get_books_by_year(books, 2020) [] >>> get_books_by_year(books, 2021, 'title') ['Book A', 'Book C'] >>> get_books_by_year(books, 2021, 'year') ['Book A', 'Book C'] >>> get_books_by_year([], 2021) []","solution":"def get_books_by_year(books, year, sort_by='none'): Returns a list of titles of books published in a given year, with an option to sort the titles either alphabetically or by publication year. :param books: List of dictionaries where each dictionary represents a book with 'title', 'author', 'year_published', and 'genre'. :param year: An integer representing the year of publication to filter the books. :param sort_by: A string that indicates the sort order: 'none', 'title', or 'year'. Default is 'none', no sorting applied. :return: List of titles of books published in the given year. filtered_books = [book['title'] for book in books if book['year_published'] == year] if sort_by == 'title': filtered_books.sort() elif sort_by == 'year': # Sort by publication year, though this should generally be unnecessary since all books have the same year filtered_books.sort(key=lambda title: next(book['year_published'] for book in books if book['title'] == title)) return filtered_books"},{"question":"def unique_elements(lst: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list containing only the elements that appear exactly once in the original list, maintaining their original order. >>> unique_elements([4, 5, 4, 5, 6, 7, 8, 6, 9]) [7, 8, 9] >>> unique_elements([1, 1, 2, 2, 3, 3]) [] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([10, 20, 20, 30, 40, 50, 50]) [10, 30, 40] >>> unique_elements([]) [] >>> unique_elements([99]) [99]","solution":"def unique_elements(lst): Returns a new list containing only the elements that appear exactly once in the original list, maintaining their original order. from collections import Counter counter = Counter(lst) return [x for x in lst if counter[x] == 1]"},{"question":"def sort_matrix_columns(mat): Given a 2D list (matrix) mat containing non-negative integers, return a new matrix where each column is sorted in ascending order. Parameters: mat (list of lists of int): The input matrix with non-negative integers. Returns: list of lists of int: A new matrix with each column sorted in ascending order. Examples: >>> sort_matrix_columns([[9, 4, 6], [3, 7, 5], [8, 2, 1]]) [[3, 2, 1], [8, 4, 5], [9, 7, 6]] >>> sort_matrix_columns([[7, 5], [1, 12], [9, 3]]) [[1, 3], [7, 5], [9, 12]] >>> sort_matrix_columns([[], []]) [[], []] >>> sort_matrix_columns([]) []","solution":"def sort_matrix_columns(mat): Given a 2D list (matrix) mat containing non-negative integers, return a new matrix where each column is sorted in ascending order. Parameters: mat (list of lists of int): The input matrix with non-negative integers. Returns: list of lists of int: A new matrix with each column sorted in ascending order. if not mat or not mat[0]: return mat # Transpose the matrix transposed = list(zip(*mat)) # Sort each column sorted_columns = [sorted(column) for column in transposed] # Transpose back to original form sorted_matrix = list(zip(*sorted_columns)) # Convert tuples back to lists sorted_matrix = [list(row) for row in sorted_matrix] return sorted_matrix"},{"question":"class VendingMachine: def __init__(self): self.products = {} self.transactions = [] def add_product(self, identifier: str, name: str, price: float, quantity: int): Adds a new product to the vending machine. pass def display_products(self) -> dict: Displays available products to the customer. pass def select_product(self, identifier: str) -> dict: Allows the customer to select a product by its unique identifier. pass def accept_payment(self, identifier: str, amount: float) -> float: Accepts payment from the customer, ensures the amount is sufficient, dispenses the product and returns change if overpayment is made. pass def restock_product(self, identifier: str, quantity: int): Restocks products when quantities run low. pass def get_transaction_log(self) -> list: Maintains a transaction log that records each sale. pass import pytest def test_add_product(): vm = VendingMachine() vm.add_product('1', 'Soda', 1.50, 10) assert vm.products == {'1': {'name': 'Soda', 'price': 1.50, 'quantity': 10}} def test_display_products(): vm = VendingMachine() vm.add_product('1', 'Soda', 1.50, 10) vm.add_product('2', 'Chips', 1.00, 0) available_products = vm.display_products() assert available_products == {'1': {'name': 'Soda', 'price': 1.50, 'quantity': 10}} def test_select_product(): vm = VendingMachine() vm.add_product('1', 'Soda', 1.50, 10) product = vm.select_product('1') assert product == {'name': 'Soda', 'price': 1.50, 'quantity': 10} with pytest.raises(Exception, match=\\"Out of stock\\"): vm.add_product('2', 'Chips', 1.00, 0) vm.select_product('2') with pytest.raises(Exception, match=\\"Invalid product selection\\"): vm.select_product('3') def test_accept_payment(): vm = VendingMachine() vm.add_product('1', 'Soda', 1.50, 10) change = vm.accept_payment('1', 2.00) assert change == 0.50 assert vm.products['1']['quantity'] == 9 with pytest.raises(Exception, match=\\"Insufficient payment\\"): vm.accept_payment('1', 1.00) def test_restock_product(): vm = VendingMachine() vm.add_product('1', 'Soda', 1.50, 10) vm.restock_product('1', 5) assert vm.products['1']['quantity'] == 15 with pytest.raises(Exception, match=\\"Invalid product identifier\\"): vm.restock_product('2', 5) def test_transaction_log(): vm = VendingMachine() vm.add_product('1', 'Soda', 1.50, 10) vm.accept_payment('1', 2.00) log = vm.get_transaction_log() assert log == [{'product_id': '1', 'product_name': 'Soda', 'quantity_sold': 1, 'amount_received': 2.00, 'change_returned': 0.50}]","solution":"class VendingMachine: def __init__(self): self.products = {} self.transactions = [] def add_product(self, identifier, name, price, quantity): self.products[identifier] = {\\"name\\": name, \\"price\\": price, \\"quantity\\": quantity} def display_products(self): available_products = {key: value for key, value in self.products.items() if value[\\"quantity\\"] > 0} return available_products def select_product(self, identifier): if identifier in self.products: product = self.products[identifier] if product[\\"quantity\\"] > 0: return product else: raise Exception(\\"Out of stock\\") else: raise Exception(\\"Invalid product selection\\") def accept_payment(self, identifier, amount): product = self.select_product(identifier) if amount >= product[\\"price\\"]: self.products[identifier][\\"quantity\\"] -= 1 change = amount - product[\\"price\\"] self.transactions.append({ \\"product_id\\": identifier, \\"product_name\\": product[\\"name\\"], \\"quantity_sold\\": 1, \\"amount_received\\": amount, \\"change_returned\\": change }) return change else: raise Exception(\\"Insufficient payment\\") def restock_product(self, identifier, quantity): if identifier in self.products: self.products[identifier][\\"quantity\\"] += quantity else: raise Exception(\\"Invalid product identifier\\") def get_transaction_log(self): return self.transactions"},{"question":"def reverse_strings(input_list: List[str]) -> List[str]: Accepts a list of strings and returns a new list where each string is reversed, but the order of the strings in the list remains the same. >>> reverse_strings([\\"hello\\", \\"world\\"]) [\\"olleh\\", \\"dlrow\\"] >>> reverse_strings([]) [] >>> reverse_strings([\\"\\"]) [\\"\\"] >>> reverse_strings([\\"hello\\", \\"\\", \\"world\\", \\"\\"]) [\\"olleh\\", \\"\\", \\"dlrow\\", \\"\\"] >>> reverse_strings([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> reverse_strings([\\"!@#\\", \\"^&*\\"]) [\\"#@!\\", \\"*&^\\"]","solution":"def reverse_strings(input_list): Accepts a list of strings and returns a new list where each string is reversed, but the order of the strings in the list remains the same. return [s[::-1] for s in input_list]"},{"question":"import math from typing import Dict def log_transform(input_dict: Dict[str, int]) -> Dict[str, float]: Transforms the input dictionary by taking the logarithm (base 10) of its values. Raises a ValueError if any value in the dictionary is less than or equal to zero. Parameters: input_dict (dict): Dictionary with integer values. Returns: dict: Dictionary with the same keys but with logarithmic values. >>> log_transform({\\"a\\": 10, \\"b\\": 100, \\"c\\": 1000}) == {\\"a\\": 1.0, \\"b\\": 2.0, \\"c\\": 3.0} >>> log_transform({\\"a\\": 1}) == {\\"a\\": 0.0} Raises: >>> log_transform({\\"a\\": 10, \\"b\\": 100, \\"c\\": 0}) ValueError: Invalid entry 0 associated with key 'c' >>> log_transform({\\"a\\": 10, \\"b\\": 100, \\"c\\": -5}) ValueError: Invalid entry -5 associated with key 'c' >>> log_transform({\\"a\\": 10, \\"b\\": -100, \\"c\\": 1000}) ValueError: Invalid entry -100 associated with key 'b'","solution":"import math def log_transform(input_dict): Transforms the input dictionary by taking the logarithm (base 10) of its values. Raises a ValueError if any value in the dictionary is less than or equal to zero. Parameters: input_dict (dict): Dictionary with integer values. Returns: dict: Dictionary with the same keys but with logarithmic values. output_dict = {} for key, value in input_dict.items(): if value <= 0: raise ValueError(f\\"Invalid entry {value} associated with key '{key}'\\") output_dict[key] = math.log10(value) return output_dict"},{"question":"def sum_primes(n: int) -> int: Returns the sum of all prime numbers up to and including \`n\`. >>> sum_primes(10) # Should return 17 because the primes are 2, 3, 5, 7 >>> sum_primes(2) # Should return 2 because 2 is the only prime less than or equal to 2 >>> sum_primes(20) # Should return 77 because the primes are 2, 3, 5, 7, 11, 13, 17, 19 from solution import sum_primes def test_sum_primes(): assert sum_primes(10) == 17, \\"Test case 1 failed\\" # Primes: 2, 3, 5, 7 assert sum_primes(1) == 0, \\"Test case 2 failed\\" # No primes less than or equal to 1 assert sum_primes(2) == 2, \\"Test case 3 failed\\" # Only prime: 2 assert sum_primes(5) == 10, \\"Test case 4 failed\\" # Primes: 2, 3, 5 assert sum_primes(0) == 0, \\"Test case 5 failed\\" # No primes less than or equal to 0 assert sum_primes(20) == 77, \\"Test case 6 failed\\" # Primes: 2, 3, 5, 7, 11, 13, 17, 19 assert sum_primes(50) == 328, \\"Test case 7 failed\\" # Total sum of primes up to 50 def test_sum_primes_large(): assert sum_primes(100) == 1060, \\"Test case 8 failed\\" # Total sum of primes up to 100 def test_sum_primes_edge_cases(): assert sum_primes(-10) == 0, \\"Test case 9 failed\\" # Negative input should return 0 def test_sum_primes_single_prime(): assert sum_primes(3) == 5, \\"Test case 10 failed\\" # Primes: 2, 3","solution":"def sum_primes(n): Returns the sum of all prime numbers up to and including n using the Sieve of Eratosthenes algorithm. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False return sum(idx for idx, is_prime in enumerate(sieve) if is_prime)"},{"question":"def find_occurrences(text: str, pattern: str) -> List[int]: Takes two strings as input and returns a list of indices where the second string occurs in the first string. The function should be case-sensitive and should not use any built-in string find or count methods. >>> find_occurrences(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_occurrences(\\"hello world\\", \\"world\\") [6] >>> find_occurrences(\\"abcabcabc\\", \\"abc\\") [0, 3, 6] >>> find_occurrences(\\"abcdefg\\", \\"hij\\") [] >>> find_occurrences(\\"abcdefg\\", \\"\\") [] >>> find_occurrences(\\"\\", \\"abc\\") [] >>> find_occurrences(\\"\\", \\"\\") [] >>> find_occurrences(\\"aBcAbCabc\\", \\"abc\\") [6] >>> find_occurrences(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3]","solution":"def find_occurrences(text, pattern): Returns a list of indices where the pattern occurs in the text. if not text or not pattern: return [] indices = [] pattern_length = len(pattern) text_length = len(text) for i in range(text_length - pattern_length + 1): if text[i:i + pattern_length] == pattern: indices.append(i) return indices"},{"question":"import pytest def second_smallest(numbers: List[int]) -> int: Returns the second smallest unique number in the given list. Raises a ValueError if the list contains less than two unique numbers. pass def test_second_smallest_normal_case(): assert second_smallest([5, 3, 9, 1, 2]) == 2 def test_second_smallest_with_duplicates(): assert second_smallest([5, 3, 3, 9, 1, 2]) == 2 def test_second_smallest_with_negative_numbers(): assert second_smallest([-5, -3, -9, -1, -2]) == -5 def test_second_smallest_with_mixed_sign_numbers(): assert second_smallest([-5, 3, -9, 1, 2]) == -5 def test_second_smallest_with_two_unique_numbers(): assert second_smallest([1, 2]) == 2 def test_second_smallest_with_repeated_numbers(): assert second_smallest([2, 2, 2, 1]) == 2 def test_second_smallest_invalid_cases(): with pytest.raises(ValueError, match=\\"List must contain at least two unique numbers\\"): second_smallest([1]) with pytest.raises(ValueError, match=\\"List must contain at least two unique numbers\\"): second_smallest([3, 3, 3]) with pytest.raises(ValueError, match=\\"List must contain at least two unique numbers\\"): second_smallest([])","solution":"def second_smallest(numbers): Returns the second smallest unique number in the given list. Raises a ValueError if the list contains less than two unique numbers. unique_numbers = set(numbers) if len(unique_numbers) < 2: raise ValueError(\\"List must contain at least two unique numbers\\") sorted_unique_numbers = sorted(unique_numbers) return sorted_unique_numbers[1]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into a single sorted linked list. The function takes the head nodes of both linked lists as input and returns the head node of the merged linked list. Your solution should maintain the order of elements and handle lists of up to 1,000 nodes efficiently. Ensure that your program can handle cases where one or both of the input lists are empty. >>> l1 = create_linked_list([1, 3, 5]) >>> l2 = create_linked_list([2, 4, 6]) >>> result = merge_two_sorted_lists(l1, l2) >>> linked_list_to_list(result) [1, 2, 3, 4, 5, 6] def create_linked_list(values): dummy = ListNode() current = dummy for value in values: current.next = ListNode(value) current = current.next return dummy.next def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1, l2): # Create a dummy node to act as the start of the merged list dummy = ListNode() current = dummy # Traverse both lists and append the smaller node to the merged list while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If one of the lists is not empty, append the rest of it to the merged list if l1: current.next = l1 elif l2: current.next = l2 # Return the head of the merged list return dummy.next"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string containing an arithmetic expression with +, -, *, /, and parentheses. Division uses integer division where the fractional part is discarded. Args: expression (str): The arithmetic expression to evaluate. Returns: int: The result of the evaluated expression. Examples: >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"3+5 / 2\\") 5 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") 21","solution":"def evaluate_expression(expression): Evaluates a string containing an arithmetic expression with +, -, *, /, and parentheses, and returns the result as an integer. Division uses integer division. def calc(it): num = 0 stack = [] sign = '+' while it < len(expression): ch = expression[it] if ch.isdigit(): num = num * 10 + int(ch) if ch == '(': num, it = calc(it + 1) if it == len(expression) - 1 or ch in '+-*/)': if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) num = 0 sign = ch if ch == ')': return sum(stack), it it += 1 return sum(stack) return int(calc(0)) print(evaluate_expression(\\"3+2*2\\")) # Should print 7 print(evaluate_expression(\\"3/2\\")) # Should print 1 print(evaluate_expression(\\"3+5 / 2\\")) # Should print 5"},{"question":"# Import necessary libraries import pandas as pd import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import cross_val_score import matplotlib.pyplot as plt def load_dataset(file_path): Load the dataset from a CSV file where the last column is the target variable. >>> X, y = load_dataset('data.csv') >>> isinstance(X, pd.DataFrame) True >>> isinstance(y, pd.Series) True pass def train_and_evaluate(X, y): Train a RandomForestClassifier and evaluate its performance using 5-fold cross-validation. Return the mean CV accuracy. >>> X, y = load_dataset('data.csv') >>> model, mean_cv_score = train_and_evaluate(X, y) >>> isinstance(model, RandomForestClassifier) True >>> 0 <= mean_cv_score <= 1 True pass def plot_feature_importances(model, X, y, feature_names): Plot the feature importances of the RandomForest model. >>> X, y = load_dataset('data.csv') >>> model, _ = train_and_evaluate(X, y) >>> plot_feature_importances(model, X, y, X.columns) pass if __name__ == \\"__main__\\": # File path to the dataset file_path = 'data.csv' # Load the dataset X, y = load_dataset(file_path) # Train the model and evaluate performance model, mean_cv_score = train_and_evaluate(X, y) print(f\\"Mean Cross-Validation Accuracy: {mean_cv_score:.2f}\\") # Plot feature importances feature_names = X.columns plot_feature_importances(model, X, y, feature_names)","solution":"# Import necessary libraries import pandas as pd import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import cross_val_score import matplotlib.pyplot as plt # Load the dataset # Assume the dataset is a CSV file named 'data.csv' with the last column as the target variable. def load_dataset(file_path): # Implement loading of dataset dataset = pd.read_csv(file_path) X = dataset.iloc[:,:-1] y = dataset.iloc[:,-1] return X, y # Train the RandomForest model and evaluate its performance using 5-fold cross-validation def train_and_evaluate(X, y): # Initialize the RandomForestClassifier model = RandomForestClassifier(random_state=42) # Perform 5-fold cross-validation and return the mean accuracy cv_scores = cross_val_score(model, X, y, cv=5) mean_cv_score = np.mean(cv_scores) return model, mean_cv_score # Plot the feature importances def plot_feature_importances(model, X, y, feature_names): # Fit the model to the entire dataset to get feature importances model.fit(X, y) importances = model.feature_importances_ # Sort the features by importance indices = np.argsort(importances)[::-1] # Plot plt.figure() plt.title(\\"Feature Importances\\") plt.bar(range(X.shape[1]), importances[indices], align=\\"center\\") plt.xticks(range(X.shape[1]), feature_names[indices], rotation=90) plt.xlim([-1, X.shape[1]]) plt.show() if __name__ == \\"__main__\\": # File path to the dataset file_path = 'data.csv' # Load the dataset X, y = load_dataset(file_path) # Train the model and evaluate performance model, mean_cv_score = train_and_evaluate(X, y) print(f\\"Mean Cross-Validation Accuracy: {mean_cv_score:.2f}\\") # Plot feature importances feature_names = X.columns plot_feature_importances(model, X, y, feature_names)"},{"question":"def inverse_dictionary(input_dict: dict) -> dict: Returns a new dictionary with keys and values swapped from the input dictionary. Args: input_dict (dict): Dictionary to be inverted. The values are unique. Returns: dict: A dictionary with keys and values swapped. Example: >>> inverse_dictionary({'one': 1, 'two': 2, 'three': 3}) {1: 'one', 2: 'two', 3: 'three'}","solution":"def inverse_dictionary(input_dict: dict) -> dict: Returns a new dictionary with keys and values swapped from the input dictionary. Args: input_dict (dict): Dictionary to be inverted. The values are unique. Returns: dict: A dictionary with keys and values swapped. return {value: key for key, value in input_dict.items()}"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using an efficient approach. The function should handle large values of n efficiently. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(10) == 55 >>> fibonacci(20) == 6765 >>> fibonacci(50) == 12586269025 >>> fibonacci(100) == 354224848179261915075","solution":"def fibonacci(n): Returns the nth Fibonacci number using an iterative approach. This approach is efficient and handles large values of n. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def moving_average(data, window_size): Calculates the moving average of a list of numbers over a specified window size. Parameters: - data (list): A list of integers or floating-point numbers. - window_size (int): The number of elements in each window. Returns: - list: A list of floating-point numbers representing the moving average for each possible position of the window in the original data list. Raises: - ValueError: If window_size is greater than the length of data. >>> moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> moving_average([1, 2, 3, 4, 5], 5) [3.0] >>> moving_average([1, 2, 3], 4) Traceback (most recent call last): ... ValueError: window_size must not be greater than the length of data >>> moving_average([], 3) [] >>> moving_average([1, 2, 3, 4, 5], 0) [] >>> moving_average([1, 2, 3, 4, 5], -1) []","solution":"def moving_average(data, window_size): Calculates the moving average of a list of numbers over a specified window size. Parameters: - data (list): A list of integers or floating-point numbers. - window_size (int): The number of elements in each window. Returns: - list: A list of floating-point numbers representing the moving average for each possible position of the window in the original data list. Raises: - ValueError: If window_size is greater than the length of data. if not data or window_size <= 0: return [] if window_size > len(data): raise ValueError(\\"window_size must not be greater than the length of data\\") moving_averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] average = sum(window) / window_size moving_averages.append(average) return moving_averages"},{"question":"def find_majority_elements(nums: List[int]) -> List[int]: This function takes a list of positive integers and returns a list of elements that appear more than n/2 times in the original list, where n is the list size. If no such element exists, it returns an empty list. Examples: >>> find_majority_elements([]) [] >>> find_majority_elements([1, 2, 3, 4]) [] >>> find_majority_elements([1, 1, 1, 2, 2]) [1] >>> find_majority_elements([3, 3, 3, 2, 2]) [3] >>> find_majority_elements([4, 4, 4, 4, 4]) [4] >>> find_majority_elements([5]*51 + [6]*49) [5] >>> find_majority_elements([7]*5 + [8]*5) [] >>> find_majority_elements([9]) [9]","solution":"def find_majority_elements(nums): This function takes a list of positive integers and returns a list of elements that appear more than n/2 times in the original list, where n is the list size. If no such element exists, it returns an empty list. if not nums: return [] n = len(nums) count_dict = {} for num in nums: count_dict[num] = count_dict.get(num, 0) + 1 result = [num for num, count in count_dict.items() if count > n // 2] return result"},{"question":"def remove_vowels(input_string: str) -> str: Removes all vowels (both uppercase and lowercase) from the input string. >>> remove_vowels(\\"beautiful day\\") \\"btfl dy\\" >>> remove_vowels(\\"Eloquent Python\\") \\"lqnt Pythn\\" >>> remove_vowels(\\"HELLO WORLD\\") \\"HLL WRLD\\" >>> remove_vowels(\\"This is a Test\\") \\"Ths s Tst\\" >>> remove_vowels(\\"AEIOUaeiou\\") \\"\\" >>> remove_vowels(\\"Mnp\\") \\"Mnp\\" >>> remove_vowels(\\"\\") \\"\\"","solution":"def remove_vowels(input_string): Removes all vowels (both uppercase and lowercase) from the input string. Parameters: input_string (str): The string from which to remove vowels. Returns: str: The input string with all vowels removed. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in input_string if char not in vowels]) # Example usage print(remove_vowels(\\"beautiful day\\")) # Output should be \\"btfl dy\\" print(remove_vowels(\\"Eloquent Python\\")) # Output should be \\"lqnt Pythn\\""},{"question":"import re from collections import defaultdict from typing import Dict def word_count(s: str) -> Dict[str, int]: This function returns a dictionary with words as keys and the counts of their occurrences as values, ignoring case and punctuation. Ignore case and punctuation, and consider only alphabetical characters and spaces in the words. The function handles an empty string and returns an empty dictionary in such cases. >>> word_count(\\"\\") == {} >>> word_count(\\"Hello\\") == {\\"hello\\": 1} >>> word_count(\\"Hello Hello\\") == {\\"hello\\": 2} >>> word_count(\\"Hello hello hELLo\\") == {\\"hello\\": 3} >>> word_count(\\"Hello, world! This is a test.\\") == {\\"hello\\": 1, \\"world\\": 1, \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"test\\": 1} >>> word_count(\\"Hello world\\") == {\\"hello\\": 1, \\"world\\": 1} >>> word_count(\\"This is a test. This is only a test.\\") == {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 2, \\"only\\": 1}","solution":"import re from collections import defaultdict def word_count(s): This function returns a dictionary with words as keys and the counts of their occurrences as values, ignoring case and punctuation. # Remove non-alphabetic characters and convert to lowercase cleaned_string = re.sub(r'[^a-zA-Zs]', '', s).lower() words = cleaned_string.split() # Count the occurrences of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Reverses the order of words in a given sentence without altering the individual words. >>> reverse_words_in_sentence(\\"The quick brown fox jumps over the lazy dog\\") \\"dog lazy the over jumps fox brown quick The\\" >>> reverse_words_in_sentence(\\" The quick brown fox \\") \\"fox brown quick The\\" >>> reverse_words_in_sentence(\\"\\") \\"\\" from solution import reverse_words_in_sentence def test_single_word(): assert reverse_words_in_sentence(\\"Hello\\") == \\"Hello\\" def test_two_words(): assert reverse_words_in_sentence(\\"hello world\\") == \\"world hello\\" def test_multiple_words(): assert reverse_words_in_sentence(\\"The quick brown fox\\") == \\"fox brown quick The\\" def test_sentence_with_punctuation(): assert reverse_words_in_sentence(\\"The quick, brown fox jumps!\\") == \\"jumps! fox brown quick, The\\" def test_sentence_with_extra_spaces(): assert reverse_words_in_sentence(\\" The quick brown fox \\") == \\"fox brown quick The\\" def test_empty_string(): assert reverse_words_in_sentence(\\"\\") == \\"\\" def test_only_spaces(): assert reverse_words_in_sentence(\\" \\") == \\"\\" def test_mixed_capitalization(): assert reverse_words_in_sentence(\\"The Quick Brown Fox\\") == \\"Fox Brown Quick The\\"","solution":"def reverse_words_in_sentence(sentence): Reverses the order of words in a given sentence without altering the individual words. Args: sentence (str): The sentence to be reversed. Returns: str: The sentence with words in reversed order. words = sentence.strip().split() reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"from typing import List def running_product(nums: List[int]) -> List[int]: Returns a list where each element is the running product of elements up to that index in the input list. >>> running_product([1, 2, 3, 4]) [1, 2, 6, 24] >>> running_product([2, 2, 2, 2]) [2, 4, 8, 16] >>> running_product([5, 10, 2]) [5, 50, 100] >>> running_product([1]) [1] >>> running_product([]) [] >>> running_product([1, -1, -1, 1]) [1, -1, 1, 1] >>> running_product([0, 1, 2, 3]) [0, 0, 0, 0] >>> running_product([1, 2, 0, 3, 4]) [1, 2, 0, 0, 0] >>> running_product([-1, -2, -3, -4]) [-1, 2, -6, 24] >>> running_product([1, -2, 3, -4]) [1, -2, -6, 24] pass","solution":"from typing import List def running_product(nums: List[int]) -> List[int]: Returns a list where each element is the running product of elements up to that index in the input list. if not nums: return [] running_product_list = [nums[0]] for i in range(1, len(nums)): running_product_list.append(running_product_list[-1] * nums[i]) return running_product_list"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of non-negative integers, return a new list where each integer is replaced with the product of all other integers in the list except for the one at the current position. This implementation does not use the division operator and has O(n) time and space complexity. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 0, 3, 0]) == [0, 0, 0, 0] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] >>> product_except_self([2, 2, 2, 2]) == [8, 8, 8, 8] >>> product_except_self([5]) == [1] >>> product_except_self([3, 4]) == [4, 3] >>> product_except_self([]) == []","solution":"def product_except_self(nums): Given a list of non-negative integers, return a new list where each integer is replaced with the product of all other integers in the list except for the one at the current position. This implementation does not use the division operator and has O(n) time and space complexity. length = len(nums) # Initialize the result array with 1s result = [1] * length # Fill result array with products of elements to the left of each index left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Fill result array with products of elements to the right of each index right_product = 1 for i in range(length-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Find two indices such that the numbers at those indices add up to the target value. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, -2, 3, 7], 1) [1, 2] >>> two_sum([3, 3, 4, 2], 6) [0, 1] >>> two_sum([1000000, 500, -1000000, 1500], 0) [0, 2] >>> two_sum([2, 3, 1, 5], 10) [] >>> two_sum([0, 4, 3, 0], 0) [0, 3]","solution":"def two_sum(nums, target): Finds two indices such that the numbers at those indices add up to the target. Args: nums (list): A list of integers. target (int): The target sum. Returns: list: A list containing the two indices. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Create a function that accepts a list of unsorted integers and a target integer value. The function should return the indices of the two numbers in the list that add up to the target value. If no such pair exists, the function should return an empty list. Assume that each input will have exactly one solution, and you may not use the same element twice. The output indices should be in ascending order. >>> two_sum([4, 7, 1, -3, 2], 5) [0, 2] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([3, 2, 4], 8) [] >>> two_sum([1, 4, 5, -1, -3], 0) [0, 3] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([], 5) [] >>> two_sum([5], 5) []","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target value. If no such pair exists, the function returns an empty list. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: # Return sorted indices return sorted([num_dict[complement], i]) num_dict[num] = i return []"},{"question":"def character_frequency(s: str) -> dict: Returns a dictionary with the frequency count of each unique character in the input string. The function ignores case. :param s: input string :return: dictionary where keys are characters and values are their frequency count in the string >>> character_frequency(\\"a\\") {'a': 1} >>> character_frequency(\\"aA\\") {'a': 2} >>> character_frequency(\\"a a\\") {'a': 2, ' ': 1} >>> character_frequency(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} >>> character_frequency(\\"\\") {} >>> character_frequency(\\"!@# !!! @@\\") {'!': 4, '@': 3, '#': 1, ' ': 2}","solution":"def character_frequency(s): Returns a dictionary with the frequency count of each unique character in the input string. The function ignores case. :param s: input string :return: dictionary where keys are characters and values are their frequency count in the string s = s.lower() # Convert the string to lowercase to ignore case freq_dict = {} for char in s: if char not in freq_dict: freq_dict[char] = 1 else: freq_dict[char] += 1 return freq_dict"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix by 90 degrees clockwise. :param matrix: A square n x n matrix of integers :return: The rotated matrix >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[5, 1], [2, 3]]) [[2, 5], [3, 1]] from typing import List def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_2x2(): matrix = [ [5, 1], [2, 3] ] expected = [ [2, 5], [3, 1] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_1x1(): matrix = [ [1] ] expected = [ [1] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_5x5(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert rotate_matrix(matrix) == expected","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix by 90 degrees clockwise. :param matrix: A square n x n matrix of integers :return: The rotated matrix n = len(matrix) # Create a new matrix for the rotated result rotated = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): # Copy the elements to rotated matrix with 90 degrees shift rotated[j][n-1-i] = matrix[i][j] return rotated"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns a list of all unique quadruplets [a, b, c, d] such that a + b + c + d equals the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([], 0) == [] >>> four_sum([1, 2, 3], 6) == [] >>> four_sum([1, 2, 3, 4], 10) == [[1, 2, 3, 4]] >>> four_sum([-3, -2, -1, 0, 0, 1, 2, 3], 0) == [[-3, -2, 2, 3], [-3, -1, 1, 3], [-3, 0, 0, 3], [-3, 0, 1, 2], [-2, -1, 0, 3], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) == [[2, 2, 2, 2]] >>> four_sum([0, 0, 0, 0], 0) == [[0, 0, 0, 0]]","solution":"def four_sum(nums, target): Returns a list of all unique quadruplets [a, b, c, d] such that a + b + c + d equals the target. nums.sort() results = [] n = len(nums) if n < 4: return results for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: sum_ = nums[i] + nums[j] + nums[left] + nums[right] if sum_ == target: results.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_ < target: left += 1 else: right -= 1 return results"},{"question":"def second_most_frequent(nums: List[int]) -> Optional[int]: Returns the second most frequent number in the list. If there is no unique second most frequent number, or if the list contains fewer than two distinct numbers, returns None. >>> second_most_frequent([]) == None >>> second_most_frequent([1]) == None >>> second_most_frequent([1, 1, 1]) == None >>> second_most_frequent([1, 1, 2, 2]) == None >>> second_most_frequent([1, 1, 1, 2]) == 2 >>> second_most_frequent([2, 2, 1, 1, 1]) == 2 >>> second_most_frequent([1, 1, 1, 2, 2, 3]) == 2 >>> second_most_frequent([1, 1, 2, 2, 2, 3]) == 1 >>> second_most_frequent([1, 1, 2, 2, 3, 3]) == None pass","solution":"def second_most_frequent(nums): Returns the second most frequent number in the list. If there is no unique second most frequent number, or if the list contains fewer than two distinct numbers, returns None. if len(nums) < 2: return None from collections import Counter frequency = Counter(nums) if len(frequency) < 2: return None most_common = frequency.most_common() if len(most_common) < 2: return None second_most_common = most_common[1][1] # Check if there's a unique second most frequent number if sum(1 for item in most_common if item[1] == second_most_common) > 1: return None return most_common[1][0]"},{"question":"def rotate_90_clockwise(matrix: List[List[int]]) -> None: Rotate the given NxN matrix 90 degrees clockwise in place. Example usage: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_90_clockwise(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]]","solution":"def rotate_90_clockwise(matrix): Rotate the given NxN matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() # Sample input matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_90_clockwise(matrix) print(matrix) # Output should be [[7, 4, 1], [8, 5, 2], [9, 6, 3]]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Adds two numbers represented by linked lists l1 and l2, where digits are stored in reverse order. Returns the sum as a linked list in the same reverse order format. >>> list_from_linked_list(add_two_numbers(linked_list_from_list([2, 4, 3]), linked_list_from_list([5, 6, 4]))) == [7, 0, 8] True >>> list_from_linked_list(add_two_numbers(linked_list_from_list([9, 9, 9]), linked_list_from_list([1]))) == [0, 0, 0, 1] True >>> list_from_linked_list(add_two_numbers(linked_list_from_list([2, 4]), linked_list_from_list([5, 6, 4]))) == [7, 0, 5] True >>> list_from_linked_list(add_two_numbers(linked_list_from_list([0]), linked_list_from_list([0]))) == [0] True >>> list_from_linked_list(add_two_numbers(linked_list_from_list([5]), linked_list_from_list([5]))) == [0, 1] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Adds two numbers represented by linked lists l1 and l2, where digits are stored in reverse order. Returns the sum as a linked list in the same reverse order format. dummy_head = ListNode() current = dummy_head carry = 0 while l1 or l2 or carry: val1 = (l1.val if l1 else 0) val2 = (l2.val if l2 else 0) total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"def tribonacci(n: int) -> int: Calculate the nth term of the Tribonacci sequence, where each term is the sum of the three preceding terms. >>> tribonacci(0) == 0 >>> tribonacci(1) == 1 >>> tribonacci(2) == 1 >>> tribonacci(3) == 2 >>> tribonacci(4) == 4 >>> tribonacci(5) == 7 >>> tribonacci(10) == 149 >>> tribonacci(25) == 1389537 >>> tribonacci(30) == 29249425 pass","solution":"def tribonacci(n): Calculate the nth term of the Tribonacci sequence, where each term is the sum of the three preceding terms. Parameters: n (int): The index of the term in the Tribonacci sequence. Returns: int: The nth term of the Tribonacci sequence. if n == 0: return 0 elif n == 1 or n == 2: return 1 # Initialize the first three terms t0, t1, t2 = 0, 1, 1 # Iterate to calculate the nth term for i in range(3, n + 1): tn = t0 + t1 + t2 t0, t1, t2 = t1, t2, tn return t2"},{"question":"def fibonacci(n: int) -> List[int]: Takes an integer n and returns a list containing the first n Fibonacci numbers using a generator to yield the sequence one element at a time. >>> fibonacci(0) [] >>> fibonacci(1) [0] >>> fibonacci(2) [0, 1] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Takes an integer n and returns a list of the first n Fibonacci numbers. def fib_generator(): a, b = 0, 1 while True: yield a a, b = b, a + b fib_sequence = [] gen = fib_generator() for _ in range(n): fib_sequence.append(next(gen)) return fib_sequence"},{"question":"def longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. Args: s (str): input string Returns: int: length of the longest substring with at most two distinct characters >>> longest_substring_two_distinct(\\"eceba\\") 3 >>> longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> longest_substring_two_distinct(\\"\\") 0 >>> longest_substring_two_distinct(\\"a\\") 1 >>> longest_substring_two_distinct(\\"aa\\") 2 >>> longest_substring_two_distinct(\\"ab\\") 2 >>> longest_substring_two_distinct(\\"aaab\\") 4 >>> longest_substring_two_distinct(\\"aabb\\") 4 >>> longest_substring_two_distinct(\\"aaaaa\\") 5 >>> longest_substring_two_distinct(\\"bbbbbbbbb\\") 9 >>> longest_substring_two_distinct(\\"a\\"*100000 + \\"b\\"*100000) 200000 >>> longest_substring_two_distinct(\\"abaccc\\") 4 >>> longest_substring_two_distinct(\\"abbbbbcccc\\") 9 >>> longest_substring_two_distinct(\\"abcdabcdabcd\\") 2 >>> longest_substring_two_distinct(\\"abcdef\\") 2","solution":"def longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. Args: s (str): input string Returns: int: length of the longest substring with at most two distinct characters from collections import defaultdict n = len(s) if n < 3: return n # Sliding window left and right pointers left, right = 0, 0 # HashMap character -> its rightmost position in the sliding window hashmap = defaultdict(int) max_len = 2 while right < n: # When the sliding window contains less than 3 characters hashmap[s[right]] = right right += 1 # When the sliding window contains 3 characters if len(hashmap) == 3: # delete the leftmost character del_index = min(hashmap.values()) del hashmap[s[del_index]] # move left pointer of the sliding window left = del_index + 1 max_len = max(max_len, right - left) return max_len"},{"question":"from typing import List def replace_with_next_largest(nums: List[int]) -> List[int]: Given a list of integers, replace each element with the next largest integer in the list. If an integer is the largest in the list, replace it with -1. >>> replace_with_next_largest([2, 5, 1, 7, 3]) == [3, 7, 2, -1, 5] >>> replace_with_next_largest([4, 4, 4, 4]) == [-1, -1, -1, -1] >>> replace_with_next_largest([1, 2, 3, 4, 5]) == [2, 3, 4, 5, -1] >>> replace_with_next_largest([5, 4, 3, 2, 1]) == [-1, 5, 4, 3, 2] >>> replace_with_next_largest([2, 3, 4, 1, 5]) == [3, 4, 5, 2, -1]","solution":"def replace_with_next_largest(nums): Given a list of integers, replace each element with the next largest integer in the list. If an integer is the largest in the list, replace it with -1. result = [-1] * len(nums) for i in range(len(nums)): next_largest = float('inf') for j in range(len(nums)): if nums[j] > nums[i] and nums[j] < next_largest: next_largest = nums[j] if next_largest != float('inf'): result[i] = next_largest return result"},{"question":"def fibonacci(n: int) -> int: Write a Python program that utilizes dynamic programming to solve the classic Fibonacci sequence problem. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n >= 2 The program should take a non-negative integer \`n\` as input and return the \`n\`th Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(20) == 6765 >>> fibonacci(100) == 354224848179261915075 # Implement the dynamic programming solution to compute the nth Fibonacci number #","solution":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 # Initialize base cases fib = [0] * (n + 1) fib[0] = 0 fib[1] = 1 # Compute subsequent Fibonacci numbers for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"def longest_palindrome(s: str) -> str: Write a function to find the longest palindrome substring in a given string \`s\`. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces and special characters). Note: Return the first longest palindrome in case there are multiple longest palindromes with the same length. >>> longest_palindrome(\\"racecar\\") 'racecar' >>> longest_palindrome(\\"madam\\") 'madam' >>> longest_palindrome(\\"A man, a plan, a canal, Panama!\\") 'amanaplanacanalpanama' >>> longest_palindrome(\\"!madam!\\") 'madam' >>> longest_palindrome(\\"a bc ddcb a\\") 'abcddcba' >>> longest_palindrome(\\" a \\") 'a' >>> longest_palindrome(\\"abc\\") 'a' >>> longest_palindrome(\\"a\\") 'a' >>> longest_palindrome(\\"\\") ''","solution":"def longest_palindrome(s): Returns the longest palindrome substring in a given string s. def preprocess_string(s): return ''.join([char.lower() for char in s if char.isalnum()]) def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] s_processed = preprocess_string(s) if not s_processed: return \\"\\" longest = \\"\\" for i in range(len(s_processed)): # Odd length palindromes temp = expand_around_center(s_processed, i, i) if len(temp) > len(longest): longest = temp # Even length palindromes temp = expand_around_center(s_processed, i, i + 1) if len(temp) > len(longest): longest = temp return longest"},{"question":"def find_largest_number(numbers: List[int]) -> int: Returns the largest number from a list of integers. If the list is empty, return None. >>> find_largest_number([1, 2, 3, 4, 5]) 5 >>> find_largest_number([-10, -20, -30, -5]) -5 >>> find_largest_number([0, -1, 1, 2, -2]) 2 >>> find_largest_number([10]) 10 >>> find_largest_number([]) None >>> find_largest_number([0, 0, 0, 0]) 0 >>> find_largest_number([999999999, 222222222, 3333333333, 444444444]) 3333333333","solution":"def find_largest_number(numbers): Returns the largest number in the list of integers, or None if the list is empty. if not numbers: return None return max(numbers)"},{"question":"import re from collections import defaultdict def word_count(s: str) -> dict: Returns a dictionary where the keys are the unique words in the string and the values are the counts of each word's occurrences. The function ignores punctuation and is case-insensitive. >>> word_count(\\"hello\\") == {\\"hello\\": 1} >>> word_count(\\"hello world hello\\") == {\\"hello\\": 2, \\"world\\": 1} >>> word_count(\\"hello, world! hello...\\") == {\\"hello\\": 2, \\"world\\": 1} >>> word_count(\\"Hello hello HELLO\\") == {\\"hello\\": 3} >>> word_count(\\"\\") == {} >>> word_count(\\"This is a test. This test is only a test.\\") == { \\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1 }","solution":"import re from collections import defaultdict def word_count(s): Returns a dictionary where the keys are the unique words in the string and the values are the counts of each word's occurrences. The function ignores punctuation and is case-insensitive. words = re.findall(r'bw+b', s.lower()) word_dict = defaultdict(int) for word in words: word_dict[word] += 1 return dict(word_dict)"},{"question":"def longest_subarray_with_sum_k(arr: List[int], k: int) -> int: Write a function \`longest_subarray_with_sum_k(arr, k)\` that, given a list of integers \`arr\` and an integer \`k\`, returns the length of the longest subarray that sums to \`k\`. Ensure your solution handles all possible edge cases such as empty arrays, arrays with no valid subarrays, and large input sizes efficiently. Examples: >>> longest_subarray_with_sum_k([1, -1, 5, -2, 3], 3) # should return 4 >>> longest_subarray_with_sum_k([1, 2, 3], 3) # should return 2","solution":"def longest_subarray_with_sum_k(arr, k): Returns the length of the longest subarray with sum equal to k. # Dictionary to store the cumulative sum up to all indices cum_sum_map = {} max_length = 0 cum_sum = 0 for i in range(len(arr)): cum_sum += arr[i] if cum_sum == k: max_length = i + 1 if cum_sum - k in cum_sum_map: max_length = max(max_length, i - cum_sum_map[cum_sum - k]) if cum_sum not in cum_sum_map: cum_sum_map[cum_sum] = i return max_length"},{"question":"class CashRegister: def __init__(self, tax_rate=0.05): Initialize a new cash register with an empty list of items and a given tax rate. self.items = [] self.tax_rate = tax_rate def add_item(self, price: float): Add an item with the specified price to the list of items. pass def compute_totals(self) -> tuple: Compute and return the subtotal, tax, and total amount due. pass def calculate_change(self, payment: float) -> float or str: Calculate and return the change to be returned to the customer after payment. If the payment is insufficient, return the string \\"Insufficient payment\\". pass # Unit Test def test_add_item(): register = CashRegister() register.add_item(10.0) register.add_item(5.0) assert register.items == [10.0, 5.0] def test_compute_totals(): register = CashRegister() register.add_item(10.0) register.add_item(5.0) subtotal, tax, total = register.compute_totals() assert subtotal == 15.0 assert tax == 0.75 assert total == 15.75 def test_calculate_change(): register = CashRegister() register.add_item(10.0) register.add_item(5.0) change = register.calculate_change(20.0) assert change == 4.25 def test_insufficient_payment(): register = CashRegister() register.add_item(10.0) register.add_item(5.0) change = register.calculate_change(10.0) assert change == \\"Insufficient payment\\"","solution":"class CashRegister: def __init__(self, tax_rate=0.05): self.items = [] self.tax_rate = tax_rate def add_item(self, price): self.items.append(price) def compute_totals(self): subtotal = sum(self.items) tax = subtotal * self.tax_rate total = subtotal + tax return subtotal, tax, total def calculate_change(self, payment): _, _, total = self.compute_totals() if payment < total: return \\"Insufficient payment\\" return payment - total"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_lists([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 3, 5], [1, 3, 5]) [1, 1, 3, 3, 5, 5] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2] >>> merge_sorted_lists([1], []) [1] >>> merge_sorted_lists([], [1]) [1] >>> merge_sorted_lists([-3, -1, 0], [-2, 1, 2]) [-3, -2, -1, 0, 1, 2] >>> merge_sorted_lists([1, 1000000, 2000000], [500000, 1500000]) [1, 500000, 1000000, 1500000, 2000000]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1 (if any) while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements of list2 (if any) while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def convert_to_binary(n: int) -> str: Converts a given integer to its binary representation as a string of 32 bits in two's complement. Parameters: n (int): The integer to be converted. Returns: str: A string representing the 32-bit binary representation of the input integer. >>> convert_to_binary(5) '00000000000000000000000000000101' >>> convert_to_binary(-5) '11111111111111111111111111111011' >>> convert_to_binary(0) '00000000000000000000000000000000' >>> convert_to_binary(1) '00000000000000000000000000000001' >>> convert_to_binary(-1) '11111111111111111111111111111111' from solution import convert_to_binary def test_positive_numbers(): assert convert_to_binary(5) == '00000000000000000000000000000101' assert convert_to_binary(1) == '00000000000000000000000000000001' assert convert_to_binary(123) == '00000000000000000000000001111011' assert convert_to_binary(1023) == '00000000000000000000001111111111' def test_zero(): assert convert_to_binary(0) == '00000000000000000000000000000000' def test_negative_numbers(): assert convert_to_binary(-1) == '11111111111111111111111111111111' assert convert_to_binary(-5) == '11111111111111111111111111111011' assert convert_to_binary(-123) == '11111111111111111111111110000101' assert convert_to_binary(-1023) == '11111111111111111111110000000001' def test_large_positive_number(): assert convert_to_binary(2147483647) == '01111111111111111111111111111111' def test_large_negative_number(): assert convert_to_binary(-2147483648) == '10000000000000000000000000000000'","solution":"def convert_to_binary(n): Converts a given integer to its binary representation as a string of 32 bits in two's complement. Parameters: n (int): The integer to be converted. Returns: str: A string representing the 32-bit binary representation of the input integer. if n < 0: n = (1 << 32) + n bits = [] for i in range(31, -1, -1): bits.append('1' if (n & (1 << i)) else '0') return ''.join(bits)"},{"question":"def is_palindrome_iterative(s: str) -> bool: Check if a string is a palindrome using the iterative approach. Ignores case and non-alphanumeric characters. Returns True if the string is a palindrome, False otherwise. Raises: ValueError: If the input is not a string. >>> is_palindrome_iterative(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome_iterative(\\"racecar\\") True >>> is_palindrome_iterative(\\"hello\\") False >>> is_palindrome_iterative(\\"12321\\") True >>> is_palindrome_iterative(\\"12345\\") False >>> is_palindrome_iterative(12321) raises ValueError def is_palindrome_recursive(s: str) -> bool: Check if a string is a palindrome using the recursive approach. Ignores case and non-alphanumeric characters. Returns True if the string is a palindrome, False otherwise. Raises: ValueError: If the input is not a string. >>> is_palindrome_recursive(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome_recursive(\\"racecar\\") True >>> is_palindrome_recursive(\\"hello\\") False >>> is_palindrome_recursive(\\"12321\\") True >>> is_palindrome_recursive(\\"12345\\") False >>> is_palindrome_recursive(12321) raises ValueError","solution":"import re def is_palindrome_iterative(s): Check if a string is a palindrome using the iterative approach. Ignores case and non-alphanumeric characters. Returns True if the string is a palindrome, False otherwise. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True def is_palindrome_recursive(s): Check if a string is a palindrome using the recursive approach. Ignores case and non-alphanumeric characters. Returns True if the string is a palindrome, False otherwise. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() def helper_sub(s, left, right): if left >= right: return True if s[left] != s[right]: return False return helper_sub(s, left + 1, right - 1) return helper_sub(s, 0, len(s) - 1)"},{"question":"def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent on a traditional phone keypad. >>> letter_combinations(\\"23\\") [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\",\\"b\\",\\"c\\"]","solution":"def letter_combinations(digits): Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent on a traditional phone keypad. if not digits: return [] phone_mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def find_missing_number(arr: list[int]) -> int: Finds the missing number in the list. The list contains n-1 distinct integers from 1 to n with one missing. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 >>> find_missing_number([1, 3, 4, 5, 6]) == 2","solution":"def find_missing_number(arr: list[int]) -> int: Finds the missing number in the list. The list contains n-1 distinct integers from 1 to n with one missing. n = len(arr) + 1 total_sum = n * (n + 1) // 2 array_sum = sum(arr) return total_sum - array_sum"},{"question":"def sort_and_analyze(numbers): Perform the following tasks on a list of integers: 1. Sort the list in ascending order. 2. Calculate the median of the sorted list. 3. Calculate the frequency of each number in the list. 4. Return the sorted list, the median value, and a dictionary with frequencies. >>> sort_and_analyze([3, 1, 4, 1, 5, 9, 2]) ([1, 1, 2, 3, 4, 5, 9], 3, {1: 2, 2: 1, 3: 1, 4: 1, 5: 1, 9: 1}) >>> sort_and_analyze([7]) ([7], 7, {7: 1}) >>> sort_and_analyze([2, 2, 2, 2, 2]) ([2, 2, 2, 2, 2], 2, {2: 5}) >>> sort_and_analyze([10, -1, 3, 5, -1, 3, 7]) ([-1, -1, 3, 3, 5, 7, 10], 3, {-1: 2, 3: 2, 5: 1, 7: 1, 10: 1}) >>> sort_and_analyze([1000, -1000, 500, 0, 500, -500, 1000]) ([-1000, -500, 0, 500, 500, 1000, 1000], 500, {-1000: 1, -500: 1, 0: 1, 500: 2, 1000: 2})","solution":"def sort_and_analyze(numbers): # Step 1: Sort the list in ascending order sorted_numbers = sorted(numbers) # Step 2: Calculate the median of the sorted list n = len(sorted_numbers) median = sorted_numbers[n // 2] # Step 3: Calculate the frequency of each number in the list frequency = {} for number in sorted_numbers: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 # Step 4: Return the sorted list, median value, and frequency dictionary return sorted_numbers, median, frequency"},{"question":"import heapq class MinHeap: A Min-Heap implementation in Python. - insert(val): Insert an integer into the Min-Heap - extract_min(): Extract the minimum integer from the Min-Heap - get_min(): Return the minimum integer without removing it from the Min-Heap - size(): Return the size of the Min-Heap Unit Tests: >>> heap = MinHeap() >>> heap.insert(3) >>> heap.insert(1) >>> heap.insert(2) >>> heap.get_min() 1 >>> min_val = heap.extract_min() >>> min_val 1 >>> heap.get_min() 2 >>> empty_heap = MinHeap() >>> empty_heap.get_min() Traceback (most recent call last): ... IndexError: Heap is empty >>> empty_heap = MinHeap() >>> empty_heap.extract_min() Traceback (most recent call last): ... IndexError: Extract from an empty heap is not allowed >>> heap = MinHeap() >>> heap.size() 0 >>> heap.insert(3) >>> heap.size() 1 >>> heap.insert(1) >>> heap.size() 2 >>> heap.insert(2) >>> heap.size() 3 >>> heap.extract_min() >>> heap.size() 2 def __init__(self): self.heap = [] def insert(self, val): Insert an integer into the Min-Heap heapq.heappush(self.heap, val) def extract_min(self): Extract the minimum integer from the Min-Heap if not self.heap: raise IndexError(\\"Extract from an empty heap is not allowed\\") return heapq.heappop(self.heap) def get_min(self): Return the minimum integer without removing it from the Min-Heap if not self.heap: raise IndexError(\\"Heap is empty\\") return self.heap[0] def size(self): Return the size of the Min-Heap return len(self.heap)","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, val): Insert an integer into the Min-Heap heapq.heappush(self.heap, val) def extract_min(self): Extract the minimum integer from the Min-Heap if not self.heap: raise IndexError(\\"Extract from an empty heap is not allowed\\") return heapq.heappop(self.heap) def get_min(self): Return the minimum integer without removing it from the Min-Heap if not self.heap: raise IndexError(\\"Heap is empty\\") return self.heap[0] def size(self): Return the size of the Min-Heap return len(self.heap)"},{"question":"import math class Circle: A class to represent a circle with a radius and color. >>> c = Circle(3, \\"green\\") >>> c.get_radius() 3 >>> c.set_radius(5) >>> c.get_radius() 5 >>> c.get_color() 'green' >>> c.set_color(\\"blue\\") >>> c.get_color() 'blue' >>> c.area() # Area of circle with radius 5 78.53981633974483 >>> c.circumference() # Circumference of circle with radius 5 31.41592653589793 def __init__(self, radius, color): self._radius = None self._color = None self.set_radius(radius) self.set_color(color) def set_radius(self, radius): Sets the radius of the circle ensuring it is non-negative. def get_radius(self): Returns the radius of the circle. def set_color(self, color): Sets the color of the circle ensuring it is a string with more than 2 characters. def get_color(self): Returns the color of the circle. def area(self): Calculates and returns the area of the circle. def circumference(self): Calculates and returns the circumference of the circle.","solution":"import math class Circle: def __init__(self, radius, color): self._radius = None self._color = None self.set_radius(radius) self.set_color(color) def set_radius(self, radius): Sets the radius of the circle ensuring it is non-negative. if radius >= 0: self._radius = radius else: raise ValueError(\\"Radius must be a non-negative number.\\") def get_radius(self): Returns the radius of the circle. return self._radius def set_color(self, color): Sets the color of the circle ensuring it is a string with more than 2 characters. if isinstance(color, str) and len(color) > 2: self._color = color else: raise ValueError(\\"Color must be a string with more than 2 characters.\\") def get_color(self): Returns the color of the circle. return self._color def area(self): Calculates and returns the area of the circle. return math.pi * self._radius ** 2 def circumference(self): Calculates and returns the circumference of the circle. return 2 * math.pi * self._radius"},{"question":"def to_leet_speak(plain_text: str) -> str: Converts a plain English string to Leet Speak by replacing specific characters. Replacements: A -> 4 E -> 3 G -> 6 I -> 1 O -> 0 S -> 5 T -> 7 Args: plain_text (str): The plain English string to be converted. Returns: str: The converted Leet Speak string. Examples: >>> to_leet_speak(\\"Leet Speak is Great\\") \\"L337 5p34k 15 6r347\\" >>> to_leet_speak(\\"Hello World\\") \\"H3ll0 W0rld\\"","solution":"def to_leet_speak(plain_text: str) -> str: Converts a plain English string to Leet Speak by replacing specific characters. Replacements: A -> 4 E -> 3 G -> 6 I -> 1 O -> 0 S -> 5 T -> 7 leet_dict = { 'A': '4', 'a': '4', 'E': '3', 'e': '3', 'G': '6', 'g': '6', 'I': '1', 'i': '1', 'O': '0', 'o': '0', 'S': '5', 's': '5', 'T': '7', 't': '7' } return ''.join(leet_dict.get(c, c) for c in plain_text)"},{"question":"def find_second_largest(numbers): Returns the second largest number in the list if present, else returns None. >>> find_second_largest([1, 3, 4, 5, 0, 2]) == 4 >>> find_second_largest([1, 2, 2, 2, 3, 3, 4]) == 3 >>> find_second_largest([1, 1, 1, 1]) == None >>> find_second_largest([1, 2]) == 1 >>> find_second_largest([1]) == None >>> find_second_largest([-1, -2, -3, -4, -5]) == -2 >>> find_second_largest([1, -1, 2, -2, 3, -3, 0]) == 2","solution":"def find_second_largest(numbers): Returns the second largest number in the list if present, else returns None. if len(set(numbers)) < 2: return None first_largest = second_largest = float('-inf') for num in numbers: if num > first_largest: second_largest = first_largest first_largest = num elif first_largest > num > second_largest: second_largest = num return second_largest if second_largest != float('-inf') else None"},{"question":"def stable_sort(nums: List[int]) -> List[int]: Performs a stable sort on a list of integers and returns a new sorted list in ascending order. If two numbers have the same value, they are ordered according to their original positions. >>> stable_sort([1, 2, 3, 4]) == [1, 2, 3, 4] >>> stable_sort([4, 3, 2, 1]) == [1, 2, 3, 4] >>> stable_sort([3, 1, 2, 4]) == [1, 2, 3, 4] >>> stable_sort([4, 2, 2, 3, 1, 2, 4]) == [1, 2, 2, 2, 3, 4, 4] >>> stable_sort([3, -1, -2, 4]) == [-2, -1, 3, 4] >>> stable_sort([9, 7, 5, 3, 1, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","solution":"def stable_sort(nums): Performs a stable sort on a list of integers and returns a new sorted list. n = len(nums) for i in range(n): for j in range(0, n-i-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] return nums"},{"question":"def check_palindromes(sentence: str) -> list: Takes a space-separated string of words and returns a list of boolean values indicating whether each word is a palindrome. Parameters: sentence (str): The input string containing space-separated words. Returns: list: A list of boolean values where each value corresponds to whether a word in the input string is a palindrome. >>> check_palindromes(\\"madam racecar apple\\") [True, True, False] >>> check_palindromes(\\"Madam RaceCar\\") [True, True] >>> check_palindromes(\\"\\") [] >>> check_palindromes(\\"a b c d\\") [True, True, True, True] >>> check_palindromes(\\"A anna Civic deed level live\\") [True, True, True, True, True, False]","solution":"def check_palindromes(sentence): Takes a space-separated string of words and returns a list of boolean values indicating whether each word is a palindrome. Parameters: sentence (str): The input string containing space-separated words. Returns: list: A list of boolean values where each value corresponds to whether a word in the input string is a palindrome. words = sentence.split() return [word.lower() == word[::-1].lower() for word in words]"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if the given strings str1 and str2 are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. >>> are_anagrams(\\"listen\\", \\"silent\\") == True >>> are_anagrams(\\"triangle\\", \\"integral\\") == True >>> are_anagrams(\\"apple\\", \\"papel\\") == True >>> are_anagrams(\\"rat\\", \\"car\\") == False >>> are_anagrams(\\"night\\", \\"thing\\") == True >>> are_anagrams(\\"abcde\\", \\"edcba\\") == True >>> are_anagrams(\\"a\\", \\"b\\") == False >>> are_anagrams(\\"abc\\", \\"bca\\") == True >>> are_anagrams(\\"ab\\", \\"bc\\") == False >>> are_anagrams(\\"aabbcc\\", \\"ccbbaa\\") == True >>> are_anagrams(\\"\\", \\"\\") == True >>> are_anagrams(\\"a\\", \\"\\") == False","solution":"def are_anagrams(str1, str2): Determines if the given strings str1 and str2 are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. return sorted(str1) == sorted(str2)"},{"question":"import math from typing import List, Tuple def generate_primes(N: int) -> List[int]: Generates the first N prime numbers. Args: N (int): The number of prime numbers to generate. Returns: List[int]: List of the first N prime numbers. >>> generate_primes(1) [2] >>> generate_primes(5) [2, 3, 5, 7, 11] pass def calculate_prime_stats(primes: List[int]) -> Tuple[int, int, float]: Calculate sum, product, and geometric mean of a list of prime numbers. Args: primes (List[int]): List of prime numbers. Returns: Tuple[int, int, float]: A tuple containing the sum, product, and geometric mean. >>> calculate_prime_stats([2, 3, 5, 7, 11]) (28, 2310, 6.583840638697614) pass","solution":"import math def generate_primes(N): Generates the first N prime numbers. Args: N (int): The number of prime numbers to generate. Returns: List[int]: List of the first N prime numbers. if not isinstance(N, int) or N <= 0: raise ValueError(\\"Input must be a positive integer.\\") primes = [] num = 2 while len(primes) < N: is_prime = True for p in primes: if p * p > num: # No need to check higher divisors break if num % p == 0: is_prime = False break if is_prime: primes.append(num) num += 1 return primes def calculate_prime_stats(primes): Calculate sum, product, and geometric mean of a list of prime numbers. Args: primes (List[int]): List of prime numbers. Returns: Tuple[int, int, float]: A tuple containing the sum, product, and geometric mean. total_sum = sum(primes) total_product = math.prod(primes) geom_mean = total_product ** (1 / len(primes)) return total_sum, total_product, geom_mean"},{"question":"from datetime import datetime class WeatherData: WeatherData class for storing weather information of a location. Attributes: city: str country: str temperature: float humidity: float description: str timestamp: datetime >>> weather_data = WeatherData(\\"London\\", \\"UK\\", 15.0, 80, \\"Cloudy\\", datetime.utcnow()) >>> weather_data.city == \\"London\\" True >>> weather_data.country == \\"UK\\" True >>> weather_data.temperature == 15.0 True >>> weather_data.humidity == 80 True >>> weather_data.description == \\"Cloudy\\" True >>> isinstance(weather_data.timestamp, datetime) True","solution":"class WeatherData: def __init__(self, city, country, temperature, humidity, description, timestamp): self.city = city self.country = country self.temperature = temperature self.humidity = humidity self.description = description self.timestamp = timestamp def __repr__(self): return f'WeatherData({self.city}, {self.country}, {self.temperature}, {self.humidity}, {self.description}, {self.timestamp})'"},{"question":"def remove_vowels(input_str: str) -> str: Remove all vowels from the input string. Parameters: input_str (str): The string from which vowels should be removed. Returns: str: New string with all vowels removed. >>> remove_vowels(\\"Hacktoberfest\\") 'Hcktbrfst' >>> remove_vowels(\\"Hello World\\") 'Hll Wrld' >>> remove_vowels(\\"Programming\\") 'Prgrmmng' >>> remove_vowels(\\"\\") '' >>> remove_vowels(\\"rhythm\\") 'rhythm' >>> remove_vowels(\\"python\\") 'pythn' >>> remove_vowels(\\"AEIOU\\") '' >>> remove_vowels(\\"HELLO\\") 'HLL' >>> remove_vowels(\\"123!@#abcDEF\\") '123!@#bcDF' >>> remove_vowels(\\"This is a test!!!\\") 'Ths s tst!!!'","solution":"def remove_vowels(input_str): Remove all vowels from the input string. Parameters: input_str (str): The string from which vowels should be removed. Returns: str: New string with all vowels removed. vowels = \\"aeiouAEIOU\\" return ''.join(char for char in input_str if char not in vowels) # Demonstrating the function with the string \\"Hacktoberfest\\" example_string = \\"Hacktoberfest\\" print(remove_vowels(example_string)) # Output: \\"Hcktbrfst\\""},{"question":"def min_avg_log(arr, k): Given a list of integers arr and an integer k, find the starting index of the subarray of length k that has the minimum average value. If there are multiple such subarrays, return the starting index of the first one. If the length of the array is less than k, return -1. Example 1: Input: [1, 2, 3, 4, 5], 2 Output: 0 Explanation: The subarrays of length 2 are [1, 2], [2, 3], [3, 4], [4, 5]. The averages are 1.5, 2.5, 3.5, and 4.5 respectively. The minimum average is 1.5 for the subarray starting at index 0. Example 2: Input: [1, 4, 2, 3], 3 Output: 0 Explanation: The subarrays of length 3 are [1, 4, 2] and [4, 2, 3]. The averages are 2.33 and 3 respectively. The minimum average is 2.33 for the subarray starting at index 0. Constraints: * 1 <= len(arr) <= 10000 * -1e4 <= arr[i] <= 1e4 * 1 <= k <= len(arr) pass","solution":"def min_avg_log(arr, k): Given a list of integers arr and an integer k, find the starting index of the subarray of length k that has the minimum average value. If there are multiple such subarrays, return the starting index of the first one. If the length of the array is less than k, return -1. n = len(arr) if n < k: return -1 min_avg = float('inf') min_index = -1 # calculate the sum of first window of size k window_sum = sum(arr[:k]) # initialize min window sum as the sum of the first window min_window_sum = window_sum min_index = 0 # slide window by one element at a time towards right for i in range(1, n - k + 1): window_sum = window_sum - arr[i - 1] + arr[i + k - 1] if window_sum < min_window_sum: min_window_sum = window_sum min_index = i return min_index"},{"question":"def reverse_words(s: str) -> str: Reverse the words in the input string \`s\` such that their relative order remains the same. Parameters: s (str): Input string containing words separated by a single space. Returns: str: A string with the words of \`s\` reversed in their order. Examples: >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" # Your code here","solution":"def reverse_words(s): Reverses the words in the input string s. Parameters: s (str): Input string containing words separated by a single space. Returns: str: A string with the words of s reversed in their order. words = s.split() reversed_words = [] for word in words: reversed_words.insert(0, word) return ' '.join(reversed_words)"},{"question":"def balance_parentheses(s: str) -> bool: Returns True if the parentheses in the string s are balanced and correctly nested. >>> balance_parentheses(\\"()\\") True >>> balance_parentheses(\\"(())\\") True >>> balance_parentheses(\\")\\") False >>> balance_parentheses(\\"(()\\") False >>> balance_parentheses(\\"((())())\\") True >>> balance_parentheses(\\"(()))(\\") False","solution":"def balance_parentheses(s): Returns True if the parentheses in the string s are balanced and correctly nested. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() else: return False return len(stack) == 0"},{"question":"from typing import List def calculate_subarray_averages(data: List[int], k: int) -> List[float]: Calculates the average of every contiguous subarray of length k in the given data list. Parameters: data (List[int]): List of integers. k (int): Length of subarray. Returns: List[float]: A list of averages of each contiguous subarray of length k. >>> calculate_subarray_averages([1, 3, 4, 6, 10], 2) [2.0, 3.5, 5.0, 8.0] >>> calculate_subarray_averages([], 3) [] >>> calculate_subarray_averages([1, 2, 3], 5) [] >>> calculate_subarray_averages([1, 2, 3], 1) [1.0, 2.0, 3.0] >>> calculate_subarray_averages([1, 3, 4, 6, 10], 3) [2.6666666666666665, 4.333333333333333, 6.666666666666667] >>> calculate_subarray_averages([1, -2, 3, -4, 5], 2) [-0.5, 0.5, -0.5, 0.5] >>> calculate_subarray_averages([5], 1) [5.0] >>> calculate_subarray_averages([5], 2) [] >>> calculate_subarray_averages([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) [3.0, 4.0, 5.0, 6.0, 7.0, 8.0]","solution":"from typing import List def calculate_subarray_averages(data: List[int], k: int) -> List[float]: Calculates the average of every contiguous subarray of length k in the given data list. Parameters: data (List[int]): List of integers. k (int): Length of subarray. Returns: List[float]: A list of averages of each contiguous subarray of length k. n = len(data) if n == 0 or k > n: return [] subarray_averages = [] current_sum = sum(data[:k]) subarray_averages.append(current_sum / k) for i in range(k, n): current_sum += data[i] - data[i - k] subarray_averages.append(current_sum / k) return subarray_averages"},{"question":"from typing import List def validate_emails(email_list: List[str]) -> List[bool]: Validates a list of email addresses. Args: email_list (list): List of email addresses to validate. Returns: list: A list of boolean values corresponding to whether each email address is valid or not. >>> validate_emails([\\"john.doe@example.com\\", \\"jane_doe@company.co\\"]) [True, True] >>> validate_emails([\\"invalid-email@domain@domain.com\\"]) [False] >>> validate_emails([\\"@missinglocalpart.com\\"]) [False] >>> validate_emails([\\"another.invalid@domain,.com\\"]) [False] >>> validate_emails([\\"john.doe@example.com\\", \\"invalid-email@domain@domain.com\\", \\"jane_doe@company.co\\", \\"@missinglocalpart.com\\", \\"another.invalid@domain,.com\\"]) [True, False, True, False, False]","solution":"import re def is_valid_email(email): Checks if the provided email address is valid based on specified conditions. email_regex = r'^[a-zA-Z0-9](?:[a-zA-Z0-9._-]{0,63}[a-zA-Z0-9])?@[a-zA-Z0-9](?:[a-zA-Z0-9.-]{0,253}[a-zA-Z0-9])?.[a-zA-Z]{2,}' return bool(re.match(email_regex, email)) def validate_emails(email_list): Validates a list of email addresses. Args: email_list (list): List of email addresses to validate. Returns: list: A list of boolean values corresponding to whether each email address is valid or not. return [is_valid_email(email) for email in email_list]"},{"question":"def binary_search(arr, target): Conducts a binary search on a sorted list to find the index of the target element. If the target is found, returns its index. Otherwise, returns -1. Parameters: arr (list of int): A sorted list of integers. target (int): The integer to search for in the list. Returns: int: The index of the target element, or -1 if not found. Examples: >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) 4 >>> binary_search([1, 3, 5, 7, 9, 11, 13, 15], 7) 3 >>> binary_search([10, 20, 30, 40, 50], 25) -1 >>> binary_search([], 5) -1 >>> binary_search([5], 5) 0 >>> binary_search([5], 1) -1 >>> binary_search([1, 3, 5, 7], 1) 0 >>> binary_search([1, 3, 5, 7], 7) 3","solution":"def binary_search(arr, target): Conducts a binary search on a sorted list to find the index of the target element. If the target is found, returns its index. Otherwise, returns -1. Parameters: arr (list of int): A sorted list of integers. target (int): The integer to search for in the list. Returns: int: The index of the target element, or -1 if not found. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the contiguous subarray which has the maximum sum and returns its sum. :param nums: List of integers :return: Integer, the maximum sum of a contiguous subarray >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1, -3, 2, 1, -1, 2, 1, -5, 4]) == 5 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): Finds the contiguous subarray which has the maximum sum and returns its sum. :param nums: List of integers :return: Integer, the maximum sum of a contiguous subarray if not nums: # If the list is empty, return 0 return 0 # Initialize the current sum and maximum sum to the first element current_sum = max_sum = nums[0] for num in nums[1:]: # Update the current sum to be the maximum of either the current number itself or the current sum plus the current number current_sum = max(num, current_sum + num) # Update the maximum sum encountered so far max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def sum_of_values(list_of_dicts: List[dict], key_name: str) -> int: Returns the sum of all values associated with the given key name in the list of dictionaries. >>> sum_of_values([{'a': 5, 'b': 10}, {'a': 3, 'c': 8}, {'a': 7, 'b': 2}, {'b': 4, 'c': 1}], 'a') == 15 >>> sum_of_values([{'a': 5, 'b': 10}, {'a': 3, 'c': 8}, {'a': 7, 'b': 2}, {'b': 4, 'c': 1}], 'd') == 0 >>> sum_of_values([{'a': 5, 'b': 10}, {'c': 8}, {'a': 7, 'b': 2}, {'b': 4, 'c': 1}], 'a') == 12 >>> sum_of_values([{'a': 1}, {'a': 2}, {'a': 3}, {'a': 4}], 'a') == 10 >>> sum_of_values([], 'a') == 0","solution":"def sum_of_values(list_of_dicts, key_name): Returns the sum of all values associated with the given key name in the list of dictionaries. :param list_of_dicts: List of dictionaries to search for the key. :param key_name: The key for which values are to be summed. :return: Sum of all values corresponding to the given key. return sum(d.get(key_name, 0) for d in list_of_dicts)"},{"question":"import csv from collections import defaultdict import heapq def top_5_customers_by_spending(file_path: str) -> list: Reads a CSV file containing transaction data and identifies the top 5 customers by total spending. :param file_path: The path to the CSV file :return: A list of the top 5 customers' IDs sorted by highest to lowest total spending Example usage: >>> top_5_customers_by_spending(\\"sample_transactions.csv\\") ['1', '3', '2', '5', '4'] pass # Sample CSV content sample_csv_content = CustomerID,TransactionID,Amount 1,1001,250.0 2,1002,300.0 1,1003,200.0 3,1004,500.0 4,1005,150.0 5,1006,200.0 6,1007,100.0 3,1008,250.0 2,1009,50.0 1,1010,300.0 def write_sample_csv(content, path): Write the provided content to a CSV file at the given path. with open(path, 'w') as f: f.write(content) def test_top_5_customers_by_spending(): # Write the sample CSV to a file sample_csv_path = 'sample_transactions.csv' write_sample_csv(sample_csv_content, sample_csv_path) # Calculate the top 5 customers top_5 = top_5_customers_by_spending(sample_csv_path) # Expected result based on the sample CSV content expected_top_5 = ['1', '3', '2', '5', '4'] # Based on total spending 750, 750, 350, 200, 150 assert top_5 == expected_top_5 def test_file_not_found(): # Test handling of a missing file result = top_5_customers_by_spending('non_existent_file.csv') assert result == [] def test_missing_column(): # Write a CSV with missing columns missing_column_csv_content = CustomerID,TransactionID 1,1001 2,1002 missing_column_csv_path = 'missing_column.csv' write_sample_csv(missing_column_csv_content, missing_column_csv_path) result = top_5_customers_by_spending(missing_column_csv_path) assert result == [] def test_invalid_data_format(): # Write a CSV with invalid data format invalid_data_csv_content = CustomerID,TransactionID,Amount 1,1001,250.0 2,1002,invalid invalid_data_csv_path = 'invalid_data.csv' write_sample_csv(invalid_data_csv_content, invalid_data_csv_path) result = top_5_customers_by_spending(invalid_data_csv_path) assert result == []","solution":"import csv from collections import defaultdict import heapq def top_5_customers_by_spending(file_path): Reads a CSV file and identifies the top 5 customers by total spending. :param file_path: path to the CSV file :return: List of top 5 customer IDs sorted by highest to lowest total spending customer_spending = defaultdict(float) try: with open(file_path, 'r') as csvfile: reader = csv.DictReader(csvfile) for row in reader: customer_id = row['CustomerID'] amount = float(row['Amount']) customer_spending[customer_id] += amount except FileNotFoundError: print(f\\"File {file_path} not found.\\") return [] except KeyError as e: print(f\\"Missing column in CSV: {e}\\") return [] except ValueError as e: print(f\\"Error in data format: {e}\\") return [] # Find top 5 customers by total spending using heapq top_5_customers = heapq.nlargest(5, customer_spending, key=customer_spending.get) return top_5_customers"},{"question":"def integer_to_roman(num: int) -> str: Convert an integer to its Roman numeral representation. The function accepts one parameter \`num\`, which is an integer between 1 and 3999. If the integer is out of the specified range, it returns an error message: \\"Error: Input out of range\\". >>> integer_to_roman(1) == \\"I\\" >>> integer_to_roman(3999) == \\"MMMCMXCIX\\" >>> integer_to_roman(1987) == \\"MCMLXXXVII\\" >>> integer_to_roman(44) == \\"XLIV\\" >>> integer_to_roman(0) == \\"Error: Input out of range\\" >>> integer_to_roman(4000) == \\"Error: Input out of range\\" >>> integer_to_roman(3) == \\"III\\" >>> integer_to_roman(58) == \\"LVIII\\" >>> integer_to_roman(1994) == \\"MCMXCIV\\"","solution":"def integer_to_roman(num): if not (1 <= num <= 3999): return \\"Error: Input out of range\\" roman_numerals = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] result = [] for value, numeral in roman_numerals: while num >= value: result.append(numeral) num -= value return ''.join(result)"},{"question":"def merge_two_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. >>> merge_two_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_two_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_two_sorted_lists([], [4, 5, 6]) [4, 5, 6] >>> merge_two_sorted_lists([], []) [] >>> merge_two_sorted_lists([5], [3]) [3, 5] >>> merge_two_sorted_lists([1, 1, 1], [1, 1]) [1, 1, 1, 1, 1] >>> merge_two_sorted_lists([-3, 0, 2], [-4, -1, 3]) [-4, -3, -1, 0, 2, 3]","solution":"def merge_two_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 # Loop through both lists and append the smaller element to merged_list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append any remaining elements from list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # Append any remaining elements from list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing integers, addition (+), and multiplication (*) operators, respecting the usual operator precedence rules. >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"2*3+4*5\\") 26 >>> evaluate_expression(\\"10+20*30+40\\") 650 >>> evaluate_expression(\\" 2 + 3 * 4 \\") 14 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"1+2+3+4+5\\") 15 >>> evaluate_expression(\\"1*2*3*4*5\\") 120 >>> evaluate_expression(\\"1+2*3+4*5+6\\") 33 # Your code here","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string containing integers, addition (+), and multiplication (*) operators, respecting the usual operator precedence rules. # Split the expression into tokens tokens = expression.replace(\\" \\", \\"\\") num_stack = [] op_stack = [] i = 0 # Helper function to apply an operator to the top two elements in the num_stack def apply_operation(): right = num_stack.pop() left = num_stack.pop() op = op_stack.pop() if op == '+': num_stack.append(left + right) elif op == '*': num_stack.append(left * right) while i < len(tokens): if tokens[i].isdigit(): num = 0 while i < len(tokens) and tokens[i].isdigit(): num = num * 10 + int(tokens[i]) i += 1 num_stack.append(num) else: while (op_stack and op_stack[-1] == '*'): apply_operation() op_stack.append(tokens[i]) i += 1 while op_stack: apply_operation() return num_stack[0] # Example usage: #print(evaluate_expression(\\"2+3*4\\")) # Expected output: 14 #print(evaluate_expression(\\"2*3+4*5\\")) # Expected output: 26 #print(evaluate_expression(\\"10+20*30+40\\")) # Expected output: 650"},{"question":"class Inventory: def __init__(self): Initialize the inventory with an empty dictionary. pass def add_item(self, name: str, price: float, quantity: int): Add a new item to the inventory. Args: name (str): The name of the item. price (float): The price of the item. quantity (int): The quantity of the item. >>> inv = Inventory() >>> inv.add_item('Apple', 0.5, 100) >>> inv.items == {'Apple': {'price': 0.5, 'quantity': 100}} True pass def update_quantity(self, name: str, quantity: int): Update the quantity of an existing item in the inventory. Args: name (str): The name of the item. quantity (int): The new quantity of the item. >>> inv = Inventory() >>> inv.add_item('Apple', 0.5, 100) >>> inv.update_quantity('Apple', 200) >>> inv.items['Apple']['quantity'] == 200 True pass def update_price(self, name: str, price: float): Update the price of an existing item in the inventory. Args: name (str): The name of the item. price (float): The new price of the item. >>> inv = Inventory() >>> inv.add_item('Apple', 0.5, 100) >>> inv.update_price('Apple', 0.75) >>> inv.items['Apple']['price'] == 0.75 True pass def remove_item(self, name: str): Remove an item from the inventory. Args: name (str): The name of the item. >>> inv = Inventory() >>> inv.add_item('Apple', 0.5, 100) >>> inv.remove_item('Apple') >>> 'Apple' not in inv.items True pass def display_items(self): Display all items in the inventory sorted by name. Returns: list: A list of tuples containing item name and details. >>> inv = Inventory() >>> inv.add_item('Banana', 0.25, 50) >>> inv.add_item('Apple', 0.5, 100) >>> inv.display_items() [('Apple', {'price': 0.5, 'quantity': 100}), ('Banana', {'price': 0.25, 'quantity': 50})] pass","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name, price, quantity): self.items[name] = {'price': price, 'quantity': quantity} def update_quantity(self, name, quantity): if name in self.items: self.items[name]['quantity'] = quantity def update_price(self, name, price): if name in self.items: self.items[name]['price'] = price def remove_item(self, name): if name in self.items: del self.items[name] def display_items(self): sorted_items = sorted(self.items.items()) for name, details in sorted_items: print(f\\"Name: {name}, Price: {details['price']}, Quantity: {details['quantity']}\\") return sorted_items # For testing purposes"},{"question":"def filter_divisible(numbers: list, n: int) -> list: Returns a list of numbers from the input list that are divisible by n. Parameters: numbers (list): A list of integers. n (int): An integer divisor. Returns: list: A list of integers from the input list that are divisible by n. Examples: >>> filter_divisible([10, 20, 33, 46, 55], 5) [10, 20, 55] >>> filter_divisible([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> filter_divisible([10, 20, 33, 46, 55], 10) [10, 20] >>> filter_divisible([], 3) [] >>> filter_divisible([1, 2, 4], 3) [] >>> filter_divisible([14, 15, 29, 30], 15) [15, 30] pass","solution":"def filter_divisible(numbers: list, n: int) -> list: Returns a list of numbers from the input list that are divisible by n. Parameters: numbers (list): A list of integers. n (int): An integer divisor. Returns: list: A list of integers from the input list that are divisible by n. if n == 0: raise ValueError(\\"n should not be 0\\") return [num for num in numbers if num % n == 0]"},{"question":"def length_of_longest_substring(s: str) -> int: Return the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"nfpdmpi\\") == 5 >>> length_of_longest_substring(\\"abcabcdefg\\") == 7","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_quadruplets(lst, k): Returns a list of unique quadruplets from the input list that sum up to k. >>> find_quadruplets([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> find_quadruplets([1, 2, 3, 4, 5], 10) [[1, 2, 3, 4]] >>> find_quadruplets([1, 2, 3], 6) [] >>> find_quadruplets([1, 1, 1, 1, -2, -2, 2, 2], 2) [[-2, 1, 1, 2]] >>> find_quadruplets([0, 0, 0, 0, 0], 0) [[0, 0, 0, 0]]","solution":"def find_quadruplets(lst, k): Returns a list of unique quadruplets from the input list that sum up to k. lst.sort() quadruplets = set() n = len(lst) for i in range(n - 3): for j in range(i + 1, n - 2): left, right = j + 1, n - 1 while left < right: total = lst[i] + lst[j] + lst[left] + lst[right] if total == k: quadruplets.add((lst[i], lst[j], lst[left], lst[right])) left += 1 right -= 1 elif total < k: left += 1 else: right -= 1 return [list(quad) for quad in sorted(quadruplets)]"},{"question":"from typing import List, Dict, Union def analyze_list(numbers: List[int]) -> Dict[str, Union[float, List[float]]]: Analyzes a list of integers and returns a dictionary containing the mean, median, mode(s), and the standard deviation. If the list is empty, return an empty dictionary. >>> analyze_list([1, 2, 3, 4, 5]) == {'mean': 3.0, 'median': 3, 'mode': [1, 2, 3, 4, 5], 'std_dev': 1.5811} >>> analyze_list([1, 1, 2, 2, 3]) == {'mean': 1.8, 'median': 2, 'mode': [1, 2], 'std_dev': 0.8366} >>> analyze_list([10]) == {'mean': 10.0, 'median': 10, 'mode': [10], 'std_dev': 0.0} >>> analyze_list([]) == {}","solution":"from typing import List, Dict, Union from statistics import mean, median, multimode, stdev def analyze_list(numbers: List[int]) -> Dict[str, Union[float, List[float]]]: Analyzes a list of integers and returns a dictionary containing the mean, median, mode(s), and the standard deviation. If the list is empty, returns an empty dictionary. if not numbers: return {} analysis = { 'mean': mean(numbers), 'median': median(numbers), 'mode': multimode(numbers), 'std_dev': stdev(numbers) if len(numbers) > 1 else 0.0 } return analysis"},{"question":"def find_most_common(lst: List[str]) -> str: Create a function in Python named \\"find_most_common\\" that takes a list of strings as input and returns the string that appears most frequently in the list. If there is a tie for the most frequent string, return the one that appeared first in the list. Handle edge cases such as an empty list. >>> find_most_common(['a']) == 'a' >>> find_most_common(['a', 'b', 'a']) == 'a' >>> find_most_common(['a', 'a', 'b', 'b', 'b']) == 'b' >>> find_most_common(['a', 'b', 'a', 'b']) == 'a' >>> find_most_common(['b', 'a', 'b', 'a']) == 'b' >>> find_most_common([]) is None >>> find_most_common(['a', 'b', 'c']) == 'a'","solution":"def find_most_common(lst): Returns the most common string in the list. If there is a tie, returns the string that appeared first. if not lst: return None from collections import defaultdict frequency = defaultdict(int) for item in lst: frequency[item] += 1 most_common = lst[0] max_count = frequency[most_common] for item in lst: if frequency[item] > max_count: most_common = item max_count = frequency[item] return most_common"},{"question":"def evaluate_tic_tac_toe(board): Evaluates the state of a tic-tac-toe game board. :param board: A 3x3 list of lists representing the tic-tac-toe game board, where each slot is \\"X\\", \\"O\\", or an empty string \\"\\". :return: A string representing the state of the game (\\"X wins\\", \\"O wins\\", \\"Draw\\", or \\"Incomplete\\"). >>> evaluate_tic_tac_toe([[\\"X\\", \\"O\\", \\"X\\"], [\\"\\", \\"X\\", \\"O\\"], [\\"O\\", \\"\\", \\"X\\"]]) 'X wins' >>> evaluate_tic_tac_toe([[\\"X\\", \\"O\\", \\"X\\"], [\\"\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"\\"]]) 'Incomplete'","solution":"def evaluate_tic_tac_toe(board): Evaluates the state of a tic-tac-toe game board. :param board: A 3x3 list of lists representing the tic-tac-toe game board, where each slot is \\"X\\", \\"O\\", or an empty string \\"\\". :return: A string representing the state of the game (\\"X wins\\", \\"O wins\\", \\"Draw\\", or \\"Incomplete\\"). # Check rows and columns for a win for i in range(3): if board[i][0] == board[i][1] == board[i][2] != \\"\\": return f\\"{board[i][0]} wins\\" if board[0][i] == board[1][i] == board[2][i] != \\"\\": return f\\"{board[0][i]} wins\\" # Check diagonals for a win if board[0][0] == board[1][1] == board[2][2] != \\"\\": return f\\"{board[0][0]} wins\\" if board[0][2] == board[1][1] == board[2][0] != \\"\\": return f\\"{board[0][2]} wins\\" # Check for incomplete or draw for row in board: for cell in row: if cell == \\"\\": return \\"Incomplete\\" return \\"Draw\\""},{"question":"def flatten_collection(nested): Define a function flatten_collection that takes a nested collection (list or tuple) and returns a single list of integers. Flatten input collections by recursively extracting integers from nested lists or tuples. Example: >>> flatten_collection([1, [2, 3, [4]], (5, 6, [7, [8, 9]])]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_collection((1, (2, 3), [4, (5,)])) [1, 2, 3, 4, 5] >>> flatten_collection([]) [] >>> flatten_collection(((), [(), [()]])) [] >>> flatten_collection([1, (2, 'three'), 4]) ValueError: Collection must contain only integers. import pytest def test_flatten_collection_mixed_types(): with pytest.raises(ValueError): flatten_collection([1, (2, 'three'), 4]) def test_flatten_collection_list(): assert flatten_collection([1, [2, 3, [4]], (5, 6, [7, [8, 9]])]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_flatten_collection_tuple(): assert flatten_collection((1, (2, 3), [4, (5,)])) == [1, 2, 3, 4, 5] def test_flatten_empty_collection(): assert flatten_collection([]) == [] assert flatten_collection(((), [(), [()]])) == [] def test_flatten_collection_single_integer(): assert flatten_collection([1]) == [1] assert flatten_collection((4,)) == [4]","solution":"def flatten_collection(nested): Takes a nested collection (list or tuple) and returns a single list of integers. Flatten input collections by recursively extracting integers from nested lists or tuples. Args: nested: A nested collection (list or tuple) of integers. Returns: A single list of integers. Raises: ValueError: If any of the elements are not integers, lists, or tuples. Example: >>> flatten_collection([1, [2, 3, [4]], (5, 6, [7, [8, 9]])]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_collection((1, (2, 3), [4, (5,)])) [1, 2, 3, 4, 5] >>> flatten_collection([]) [] >>> flatten_collection(((), [(), [()]])) [] >>> flatten_collection([1, (2, 'three'), 4]) Traceback (most recent call last): ... ValueError: Collection must contain only integers. if isinstance(nested, (list, tuple)): result = [] for item in nested: result.extend(flatten_collection(item)) return result elif isinstance(nested, int): return [nested] else: raise ValueError(\\"Collection must contain only integers.\\")"},{"question":"def longest_unique_substring(s: str) -> tuple: Determines the longest substring within a given string that consists solely of unique characters. Returns both the length of this longest unique substring and the substring itself. Parameters: s (str): The input string Returns: tuple: A tuple containing the length of the longest unique substring and the substring itself >>> longest_unique_substring(\\"abcabcbb\\") (3, \\"abc\\") >>> longest_unique_substring(\\"bbbbb\\") (1, \\"b\\") >>> longest_unique_substring(\\"pwwkew\\") (3, \\"wke\\") >>> longest_unique_substring(\\"\\") (0, \\"\\") >>> longest_unique_substring(\\"a\\") (1, \\"a\\") >>> longest_unique_substring(\\"abc123!@#\\") (9, \\"abc123!@#\\") >>> longest_unique_substring(\\"abc123!@#abc123\\") (9, \\"abc123!@#\\") >>> longest_unique_substring(\\"a!@#a!@#a!@#\\") (4, \\"a!@#\\") >>> longest_unique_substring(\\"abababab\\") (2, \\"ab\\") >>> longest_unique_substring(\\"abcdefghijabcdefghij\\") (10, \\"abcdefghij\\")","solution":"def longest_unique_substring(s): Determines the longest substring within a given string that consists solely of unique characters. Returns both the length of this longest unique substring and the substring itself. Parameters: s (str): The input string Returns: tuple: A tuple containing the length of the longest unique substring and the substring itself start = 0 max_len = 0 max_substr = \\"\\" char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end if end - start + 1 > max_len: max_len = end - start + 1 max_substr = s[start:end + 1] return (max_len, max_substr)"},{"question":"def sum_values_in_dict(input_dict: dict) -> dict: Takes a dictionary where the values are lists of integers and returns a dictionary with the same keys but where the values are the sums of the corresponding lists. >>> sum_values_in_dict({\\"a\\": [1, 2, 3], \\"b\\": [4, 5], \\"c\\": [6]}) {\\"a\\": 6, \\"b\\": 9, \\"c\\": 6} >>> sum_values_in_dict({\\"x\\": [], \\"y\\": [0], \\"z\\": [1, -1]}) {\\"x\\": 0, \\"y\\": 0, \\"z\\": 0} >>> sum_values_in_dict({}) {} >>> sum_values_in_dict({\\"key1\\": [2, 2, 2], \\"key2\\": [10]}) {\\"key1\\": 6, \\"key2\\": 10} >>> sum_values_in_dict({\\"a\\": [5]}) {\\"a\\": 5}","solution":"def sum_values_in_dict(input_dict): Takes a dictionary where the values are lists of integers and returns a dictionary with the same keys but where the values are the sums of the corresponding lists. return {key: sum(value) for key, value in input_dict.items()}"},{"question":"def evaluate_expression(expression: str) -> Union[int, float]: Given a string containing a mathematical expression, evaluate it and return the result. The expression will only contain numbers, spaces, '+' and '-'. It can handle both integer and float numbers. >>> evaluate_expression(\\"1 + 2 - 3 + 4\\") 4 >>> evaluate_expression(\\"5.5 + 4.5 - 2\\") 8.0 >>> evaluate_expression(\\" 10 - 3.5 + 4 \\") 10.5 # Extended code to implement should be added below","solution":"def evaluate_expression(expression: str): Given a string containing a mathematical expression, evaluates it and returns the result. Parameters: expression (str): A string containing a mathematical expression with numbers, spaces, '+' and '-'. The numbers can be both integers and floats. Returns: The evaluated result of the expression as an int or float. Examples: >>> evaluate_expression(\\"1 + 2 - 3 + 4\\") 4 >>> evaluate_expression(\\"5.5 + 4.5 - 2\\") 8.0 >>> evaluate_expression(\\" 10 - 3.5 + 4 \\") 10.5 # Remove any whitespace from the expression expression = expression.replace(' ', '') # Evaluate the expression result = eval(expression) return result"},{"question":"def replace_with_left_sums(arr: List[int]) -> List[int]: Replace each element in the array with the sum of the elements to its left. The first element remains unchanged. If the array is empty, return an empty array. :param arr: List of integers :return: Modified list of integers >>> replace_with_left_sums([]) [] >>> replace_with_left_sums([5]) [5] >>> replace_with_left_sums([1, 2]) [1, 3] >>> replace_with_left_sums([4, 8, 15, 16, 23, 42]) [4, 12, 27, 43, 66, 108] >>> replace_with_left_sums([0, 0, 0, 0]) [0, 0, 0, 0] >>> replace_with_left_sums([-1, -2, -3]) [-1, -3, -6] >>> replace_with_left_sums([-1, 1, -1, 1]) [-1, 0, -1, 0]","solution":"def replace_with_left_sums(arr): Replace each element in the array with the sum of the elements to its left. The first element remains unchanged. :param arr: List of integers :return: Modified list of integers if not arr: # Handle empty array case return [] for i in range(1, len(arr)): arr[i] += arr[i - 1] return arr"},{"question":"def max_sum_consecutive_elements(nums: List[int], k: int) -> int: Returns the maximum sum of k consecutive elements in the list nums. If the length of nums is less than k, return None. >>> max_sum_consecutive_elements([1, 2, 3, 4, 5, 6], 2) == 11 >>> max_sum_consecutive_elements([1, 2, 3, 4, 5, 6], 3) == 15 >>> max_sum_consecutive_elements([1, 2, 3, 4, 5, 6], 6) == 21 >>> max_sum_consecutive_elements([1, 2, 3], 1) == 3 >>> max_sum_consecutive_elements([1, 2], 3) == None >>> max_sum_consecutive_elements([], 3) == None >>> max_sum_consecutive_elements([-1, -2, -3, -4], 2) == -3 >>> max_sum_consecutive_elements([1, 2, -1, 3, 4, -2], 3) == 6 pass","solution":"def max_sum_consecutive_elements(nums, k): Returns the maximum sum of k consecutive elements in the list nums. If the length of nums is less than k, return None. if len(nums) < k: return None # Initialize the current sum to the sum of the first k elements current_sum = sum(nums[:k]) max_sum = current_sum # Iterate through the list starting from the k-th element for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from datetime import datetime def filter_errors_by_hour(filepath, hour): Reads a log file and returns all error messages that occurred during the specified hour. Parameters: filepath (str): The path to the log file. hour (str): The hour during which to filter the errors (format 'HH', 24-hour clock). Returns: list: A list of error messages that occurred during the specified hour. Example: >>> create_temp_log_file('temp_errors.log', [ ... '2023-05-23 14:02:15 Error: Connection failure', ... '2023-05-23 14:45:00 Error: Timeout', ... '2023-05-23 15:12:34 Error: Disk full' ... ]) >>> filter_errors_by_hour('temp_errors.log', '14') [ '2023-05-23 14:02:15 Error: Connection failure', '2023-05-23 14:45:00 Error: Timeout' ] # Write your code here # Helper function to create a temporary log file for testing def create_temp_log_file(filepath, lines): with open(filepath, 'w') as file: file.write(\\"n\\".join(lines)) def test_filter_errors_by_hour(): log_lines = [ '2023-05-23 14:02:15 Error: Connection failure', '2023-05-23 14:45:00 Error: Timeout', '2023-05-23 15:12:34 Error: Disk full' ] log_file = 'temp_errors.log' create_temp_log_file(log_file, log_lines) try: result = filter_errors_by_hour(log_file, '14') assert result == [ '2023-05-23 14:02:15 Error: Connection failure', '2023-05-23 14:45:00 Error: Timeout' ] result = filter_errors_by_hour(log_file, '15') assert result == [ '2023-05-23 15:12:34 Error: Disk full' ] result = filter_errors_by_hour(log_file, '13') assert result == [] finally: os.remove(log_file) def test_filter_errors_with_no_matching_entries(): log_lines = [ '2023-05-23 10:02:15 Error: Connection failure', '2023-05-23 11:45:00 Error: Timeout', '2023-05-23 12:12:34 Error: Disk full' ] log_file = 'temp_errors_no_match.log' create_temp_log_file(log_file, log_lines) try: result = filter_errors_by_hour(log_file, '14') assert result == [] finally: os.remove(log_file) def test_filter_errors_with_multiple_matching_entries(): log_lines = [ '2023-05-23 09:02:15 Error: Connection failure', '2023-05-23 09:45:00 Error: Timeout', '2023-05-23 09:12:34 Error: Disk full' ] log_file = 'temp_errors_multiple_match.log' create_temp_log_file(log_file, log_lines) try: result = filter_errors_by_hour(log_file, '09') assert result == [ '2023-05-23 09:02:15 Error: Connection failure', '2023-05-23 09:45:00 Error: Timeout', '2023-05-23 09:12:34 Error: Disk full' ] finally: os.remove(log_file)","solution":"from datetime import datetime def filter_errors_by_hour(filepath, hour): Reads a log file and returns all error messages that occurred during the specified hour. Parameters: filepath (str): The path to the log file. hour (str): The hour during which to filter the errors (format 'HH', 24-hour clock). Returns: list: A list of error messages that occurred during the specified hour. errors = [] target_hour = int(hour) with open(filepath, 'r') as file: for line in file: timestamp_str = line.split(' ', 2)[1] # Extracting the 'HH:MM:SS' part timestamp = datetime.strptime(timestamp_str, \\"%H:%M:%S\\") if timestamp.hour == target_hour: errors.append(line.strip()) return errors"},{"question":"import pandas as pd def process_large_csv(input_file, output_file, chunk_size, condition): Processes a large CSV file in chunks, filters rows based on a condition, and appends the filtered data to a new CSV file. :param input_file: Path to the input large CSV file. :param output_file: Path to the output CSV file where filtered data will be stored. :param chunk_size: Number of rows per chunk to process. :param condition: Lambda function to filter rows. # Unit Test import pandas as pd import os def setup_module(module): # Create a large CSV file for testing df = pd.DataFrame({ 'A': range(100), 'B': ['x' if i % 2 == 0 else 'y' for i in range(100)] }) df.to_csv('test_input.csv', index=False) def teardown_module(module): # Clean up the files created during the tests os.remove('test_input.csv') if os.path.exists('test_output.csv'): os.remove('test_output.csv') def test_process_large_csv(): condition = lambda row: row['A'] % 2 == 0 process_large_csv('test_input.csv', 'test_output.csv', chunk_size=10, condition=condition) result_df = pd.read_csv('test_output.csv') assert result_df.shape[0] == 50 assert all(result_df['A'] % 2 == 0)","solution":"import pandas as pd def process_large_csv(input_file, output_file, chunk_size, condition): Processes a large CSV file in chunks, filters rows based on a condition, and appends the filtered data to a new CSV file. :param input_file: Path to the input large CSV file. :param output_file: Path to the output CSV file where filtered data will be stored. :param chunk_size: Number of rows per chunk to process. :param condition: Lambda function to filter rows. chunks = pd.read_csv(input_file, chunksize=chunk_size) for i, chunk in enumerate(chunks): filtered_chunk = chunk[chunk.apply(condition, axis=1)] if i == 0: filtered_chunk.to_csv(output_file, index=False) else: filtered_chunk.to_csv(output_file, mode='a', header=False, index=False)"}]`),C={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},I={class:"card-container"},S={key:0,class:"empty-state"},D=["disabled"],P={key:0},z={key:1};function j(n,e,l,m,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")},"  ")):u("",!0)]),t("div",I,[(s(!0),r(y,null,v(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",S,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",z,"Loading...")):(s(),r("span",P,"See more"))],8,D)):u("",!0)])}const B=_(C,[["render",j],["__scopeId","data-v-cc41a034"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/22.md","filePath":"grok/22.md"}'),M={name:"grok/22.md"},H=Object.assign(M,{setup(n){return(e,l)=>(s(),r("div",null,[x(B)]))}});export{O as __pageData,H as default};
