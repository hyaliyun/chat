import{_ as c,o as s,c as n,a as t,m as d,t as _,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},N={class:"review-content"};function A(i,e,u,m,r,a){return s(),n("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(_(u.poem.solution),1)])])])}const R=c(q,[["render",A],["__scopeId","data-v-2248f925"]]),E=JSON.parse(`[{"question":"def optimize_cluster(n: int, t: int, c: List[int], p: List[int]) -> Union[str, Tuple[str, List[Tuple[int, int]]]]: Decides if it's possible to assign exactly one task of each type to exactly one server such that the combined load on any server does not exceed its processing capacity. Parameters: n (int): Number of servers t (int): Number of task types c (list): List of servers' capacities p (list): List of task kinds' processing power Returns: str: \\"POSSIBLE\\" if a valid assignment exists, otherwise \\"IMPOSSIBLE\\" list of tuples: Each tuple contains two integers representing assignments (server, task type) pass # Example usage and test cases if __name__ == \\"__main__\\": from typing import List, Union, Tuple n = 3 t = 3 c = [10, 20, 30] p = [5, 10, 25] result = optimize_cluster(n, t, c, p) print(result) # \\"POSSIBLE\\", [(1, 1), (2, 2), (3, 3)] n = 2 t = 3 c = [15, 10] p = [5, 10, 5] result = optimize_cluster(n, t, c, p) print(result) # \\"IMPOSSIBLE\\"","solution":"def optimize_cluster(n, t, c, p): Decides if it's possible to assign exactly one task of each type to exactly one server such that the combined load on any server does not exceed its processing capacity. Parameters: n (int): Number of servers t (int): Number of task types c (list): List of servers' capacities p (list): List of task kinds' processing power Returns: str: \\"POSSIBLE\\" if a valid assignment exists, otherwise \\"IMPOSSIBLE\\" list of tuples: Each tuple contains two integers representing assignments (server, task type) # Sort the capacities and tasks along with their original indices servers = sorted([(c[i], i + 1) for i in range(n)], reverse=True) tasks = sorted([(p[j], j + 1) for j in range(t)], reverse=True) if n < t: return \\"IMPOSSIBLE\\" assignments = [] for j in range(t): found = False for i in range(n): if servers[i][0] >= tasks[j][0]: assignments.append((servers[i][1], tasks[j][1])) servers[i] = (servers[i][0] - tasks[j][0], servers[i][1]) found = True break if not found: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\", assignments"},{"question":"def rabbit_behavior(n: int, m: int, k: int, record_action) -> List[List[int]]: Determine the sequence of actions performed by each rabbit species over d days. Args: n : int : Number of rabbit species (power of 2) m : int : Number of unique actions k : int : Length of observation window (power of 2) record_action : function : A function to record the actions of a given rabbit species. It takes an integer (species index) as a parameter and returns a list of length k representing the actions over k days. Returns: List[List[int]] : A nested list where each inner list contains the complete sequence of actions for a rabbit species. >>> n, m, k = 4, 5, 2 >>> mock_record_action = lambda s: {1: [1, 2], 2: [3, 4], 3: [2, 5], 4: [1, 3]}[s] >>> rabbit_behavior(n, m, k, mock_record_action) [[1, 2], [3, 4], [2, 5], [1, 3]] def mock_record_action_1(s): mock_data = { 1: [1, 2], 2: [3, 4], 3: [2, 5], 4: [1, 3] } return mock_data[s] def mock_record_action_2(s): mock_data = { 1: [5, 4], 2: [3, 2], 3: [1, 4], 4: [2, 3] } return mock_data[s] def test_rabbit_behavior_case_1(): n, m, k = 4, 5, 2 expected_output = [ [1, 2], [3, 4], [2, 5], [1, 3] ] assert rabbit_behavior(n, m, k, mock_record_action_1) == expected_output def test_rabbit_behavior_case_2(): n, m, k = 4, 5, 2 expected_output = [ [5, 4], [3, 2], [1, 4], [2, 3] ] assert rabbit_behavior(n, m, k, mock_record_action_2) == expected_output def test_rabbit_behavior_different_k(): n, m, k = 4, 5, 2 expected_output = [ [5, 4], [3, 2], [1, 4], [2, 3] ] assert rabbit_behavior(n, m, k, mock_record_action_2) == expected_output","solution":"def rabbit_behavior(n, m, k, record_action): Determine the sequence of actions performed by each rabbit species over d days. Args: n : int : Number of rabbit species (power of 2) m : int : Number of unique actions k : int : Length of observation window (power of 2) record_action : function : A function to record the actions of a given rabbit species. It takes an integer (species index) as parameter and returns a list of length k representing the actions over k days. Returns: List[List[int]] : A nested list where each inner list contains the complete sequence of actions for a rabbit species. action_sequences = [None] * n for i in range(1, n+1): action_sequences[i-1] = record_action(i) return action_sequences"},{"question":"def first_repeated_number(n: int, sequence: List[int]) -> int: Finds the first number in the given sequence that appears at least twice. >>> first_repeated_number(6, [2, 3, 4, 2, 1, 3]) 2 >>> first_repeated_number(5, [1, 2, 3, 4, 5]) -1","solution":"def first_repeated_number(n, sequence): Finds the first number in the given sequence that appears at least twice. :param n: Number of integers in the sequence :param sequence: List of integers in the sequence :return: The first repeating number or -1 if no such number exists seen = set() for number in sequence: if number in seen: return number seen.add(number) return -1"},{"question":"def generate_sequence(k: int) -> (List[int], int): Generates a sequence of incrementing integers starting from 1 until the sum of the sequence becomes greater than or equal to k. Arguments: k -- the threshold integer value (1 ≤ k ≤ 10^9) Returns: A tuple containing: - the sequence as a list of integers - the final sum of the sequence Examples: >>> generate_sequence(10) ([1, 2, 3, 4], 10) >>> generate_sequence(20) ([1, 2, 3, 4, 5, 6], 21) >>> generate_sequence(1) ([1], 1)","solution":"def generate_sequence(k): Generates a sequence of incrementing integers starting from 1 until the sum of the sequence becomes greater than or equal to k. Arguments: k -- the threshold integer value (1 ≤ k ≤ 10^9) Returns: A tuple containing: - the sequence as a list of integers - the final sum of the sequence sequence = [] current_number = 1 current_sum = 0 while current_sum < k: sequence.append(current_number) current_sum += current_number current_number += 1 return sequence, current_sum"},{"question":"def longest_common_substring(s1: str, s2: str) -> str: Finds the longest common substring of s1 and s2. If there are multiple substrings with the same maximum length, returns the lexicographically smallest one. >>> longest_common_substring(\\"abcde\\", \\"bcdf\\") 'bcd' >>> longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\") 'abcd' >>> longest_common_substring(\\"a\\", \\"a\\") 'a' >>> longest_common_substring(\\"b\\", \\"a\\") '' >>> longest_common_substring(\\"abc\\", \\"xyz\\") '' >>> longest_common_substring(\\"testing\\", \\"testing\\") 'testing' >>> longest_common_substring(\\"abcabc\\", \\"abc\\") 'abc' >>> longest_common_substring('a'*100, 'b'*100) '' >>> longest_common_substring('a'*100, 'a'*100) 'a'*100","solution":"def longest_common_substring(s1, s2): Finds the longest common substring of s1 and s2. If there are multiple substrings with the same maximum length, returns the lexicographically smallest one. m, n = len(s1), len(s2) # Create a 2D array to store lengths of longest common suffixes. # lc_suffix[i][j] will contain length of longest common suffix of # s1[0..i-1] and s2[0..j-1]. lc_suffix = [[0] * (n+1) for _ in range(m+1)] longest_len = 0 longest_end_pos = 0 for i in range(1, m+1): for j in range(1, n+1): if s1[i-1] == s2[j-1]: lc_suffix[i][j] = lc_suffix[i-1][j-1] + 1 if lc_suffix[i][j] > longest_len: longest_len = lc_suffix[i][j] longest_end_pos = i elif lc_suffix[i][j] == longest_len: current_substring = s1[i-longest_len:i] existing_substring = s1[longest_end_pos-longest_len:longest_end_pos] if current_substring < existing_substring: longest_end_pos = i # The longest common substring return s1[longest_end_pos-longest_len:longest_end_pos] # Test the function with the provided examples print(longest_common_substring(\\"abcde\\", \\"bcdf\\")) # Output: bcd print(longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\")) # Output: abcd"},{"question":"def find_min_time_per_year(participants): Finds the participant who took the least time to complete the marathon for each given year. Input: - participants: list of tuples containing (time, year) for each participant Output: - A list of tuples, where each tuple contains (year, minimum time) in ascending order of year. >>> find_min_time_per_year([(240, 2020), (180, 2020), (200, 2021), (210, 2021), (130, 2022), (190, 2022)]) [(2020, 180), (2021, 200), (2022, 130)] >>> find_min_time_per_year([(240, 2020)]) [(2020, 240)] >>> find_min_time_per_year([(240, 2020), (180, 2020)]) [(2020, 180)] >>> find_min_time_per_year([(200, 2021), (180, 2020), (210, 2021)]) [(2020, 180), (2021, 200)] >>> find_min_time_per_year([(100, 2020), (150, 2020), (120, 2020), (90, 2020)]) [(2020, 90)] >>> find_min_time_per_year([]) []","solution":"def find_min_time_per_year(participants): Finds the participant who took the least time to complete the marathon for each given year. Input: - participants: list of tuples containing (time, year) for each participant Output: - A list of tuples, where each tuple contains (year, minimum time) in ascending order of year. from collections import defaultdict # Dictionary to store the minimum time for each year min_times = defaultdict(lambda: float('inf')) for time, year in participants: if time < min_times[year]: min_times[year] = time # Sort years and prepare the result result = sorted(min_times.items()) return result"},{"question":"def total_cost(n, m, prices, qualities, budgets, min_qualities): Calculate the total cost incurred by each customer if they buy the most expensive product they can afford and meets their quality requirement. >>> total_cost(5, 3, [4, 3, 5, 7, 2], [10, 8, 6, 5, 7], [6, 10, 8], [7, 5, 11]) == [4, 7, 0] >>> total_cost(4, 2, [1, 10, 3, 6], [3, 8, 5, 2], [12, 4], [7, 4]) == [10, 3]","solution":"def total_cost(n, m, prices, qualities, budgets, min_qualities): results = [] for j in range(m): max_affordable_price = 0 for i in range(n): if prices[i] <= budgets[j] and qualities[i] >= min_qualities[j]: max_affordable_price = max(max_affordable_price, prices[i]) results.append(max_affordable_price) return results # Example usage n = 5 m = 3 prices = [4, 3, 5, 7, 2] qualities = [10, 8, 6, 5, 7] budgets = [6, 10, 8] min_qualities = [7, 5, 11] print(total_cost(n, m, prices, qualities, budgets, min_qualities)) # Output: [4, 7, 0]"},{"question":"def minimum_rest_days(n: int, activities: List[int]) -> int: Determine the minimum number of days Andrew must rest given the constraints. Args: n (int): The number of days. activities (List[int]): List of integers where each integer represents the activity on that day. Returns: int: The minimum number of rest days. Examples: >>> minimum_rest_days(5, [1, 3, 3, 2, 0]) 1 >>> minimum_rest_days(6, [0, 1, 2, 0, 1, 3]) 2 def test_minimum_rest_days_example1(): assert minimum_rest_days(5, [1, 3, 3, 2, 0]) == 1 def test_minimum_rest_days_example2(): assert minimum_rest_days(6, [0, 1, 2, 0, 1, 3]) == 2 def test_minimum_rest_days_no_activities(): assert minimum_rest_days(3, [0, 0, 0]) == 3 def test_minimum_rest_days_all_activities(): assert minimum_rest_days(4, [3, 3, 3, 3]) == 0 def test_minimum_rest_days_alternating_activities(): assert minimum_rest_days(4, [1, 2, 1, 2]) == 0 def test_minimum_rest_days_consecutive_runs(): assert minimum_rest_days(4, [1, 1, 1, 1]) == 2 def test_minimum_rest_days_consecutive_swims(): assert minimum_rest_days(4, [2, 2, 2, 2]) == 2 def test_minimum_rest_days_alternating_with_rests(): assert minimum_rest_days(5, [1, 0, 2, 0, 1]) == 2","solution":"def minimum_rest_days(n, activities): rest_days = 0 last_activity = -1 # -1 means no previous activity for i in range(n): if activities[i] == 0: rest_days += 1 last_activity = 0 else: if activities[i] == 1: if last_activity == 1: rest_days += 1 last_activity = 0 else: last_activity = 1 elif activities[i] == 2: if last_activity == 2: rest_days += 1 last_activity = 0 else: last_activity = 2 else: # activities[i] == 3 if last_activity == 1: last_activity = 2 elif last_activity == 2: last_activity = 1 else: last_activity = 1 # default to running if there's a choice return rest_days"},{"question":"def process_queries(n: int, array: list[int], queries: list[tuple[int, int]]) -> list[int]: Processes the given queries to find the sum of elements between the provided indices. Args: n (int): The number of integers in the list. array (list): The list of integers. queries (list of tuples): Each tuple contains two integers li and ri representing the query. Returns: list: The list of sums for each query. >>> process_queries(5, [10, 20, 30, 40, 50], [(1, 3)]) [60] >>> process_queries(5, [10, 20, 30, 40, 50], [(1, 5)]) [150]","solution":"def process_queries(n, array, queries): Processes the given queries to find the sum of elements between the provided indices. Args: n (int): The number of integers in the list. array (list): The list of integers. queries (list of tuples): Each tuple contains two integers li and ri representing the query. Returns: list: The list of sums for each query. # Create a prefix sum array prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + array[i] # Process each query results = [] for li, ri in queries: sum_sublist = prefix_sum[ri] - prefix_sum[li - 1] results.append(sum_sublist) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Function to find the length of the longest substring without repeating characters. :param s: Input string :return: Length of the longest substring without repeating characters >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s: str) -> int: Function to find the length of the longest substring without repeating characters. :param s: Input string :return: Length of the longest substring without repeating characters char_set = set() left = 0 result = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) result = max(result, right - left + 1) return result"},{"question":"def is_palindrome(S: str) -> bool: Determine if S is a palindrome, ignoring non-alphanumeric characters and case differences. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"aba\\") True def test_palindrome_with_punctuation(): assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True def test_palindrome_simple(): assert is_palindrome(\\"aba\\") == True def test_non_palindrome(): assert is_palindrome(\\"race a car\\") == False def test_palindrome_with_numbers(): assert is_palindrome(\\"12321\\") == True def test_non_palindrome_with_numbers(): assert is_palindrome(\\"12345\\") == False def test_empty_string(): assert is_palindrome(\\"\\") == True def test_single_character(): assert is_palindrome(\\"a\\") == True def test_whitespace_only(): assert is_palindrome(\\" \\") == True def test_special_characters(): assert is_palindrome(\\"@#%^&@#\\") == True","solution":"def is_palindrome(S): Returns True if S is a palindrome, ignoring non-alphanumeric characters and case differences; otherwise, returns False. Parameters: S (str): The input string Returns: bool: True if S is a palindrome, False otherwise # Remove non-alphanumeric characters and convert to lowercase cleaned_S = ''.join(char.lower() for char in S if char.isalnum()) # Check if the cleaned string is a palindrome return cleaned_S == cleaned_S[::-1]"},{"question":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array. >>> minimum_swaps_to_sort([4, 3, 1, 2, 5]) 3 >>> minimum_swaps_to_sort([2, 3, 4, 1]) 3 >>> minimum_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_swaps_to_sort([1]) 0 >>> minimum_swaps_to_sort([5, 4, 3, 2, 1]) 2 >>> minimum_swaps_to_sort([7, 1, 3, 2, 4, 5, 6]) 5 >>> minimum_swaps_to_sort([5, 5, 5]) 0 >>> minimum_swaps_to_sort([2, 2, 2, 2]) 0","solution":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array. n = len(arr) arrpos = [(value, idx) for idx, value in enumerate(arr)] arrpos.sort(key=lambda it: it[0]) visited = {k: False for k in range(n)} ans = 0 for i in range(n): if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"def check_numbers(t: int, numbers: List[int]) -> List[str]: You are given a list of integers. For each integer, determine whether it can be represented as the sum of two unique prime numbers. Write a program to solve this problem. INPUT The first line contains a single integer t (1 ≤ t ≤ 10^6), the number of test cases. Each of the next t lines contains a single integer n (4 ≤ n ≤ 10^6), which is the number to be checked. OUTPUT For each integer n, output \\"YES\\" if it can be represented as the sum of two unique prime numbers, otherwise output \\"NO\\". Example: >>> check_numbers(3, [10, 17, 34]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_numbers(1, [17]) [\\"NO\\"] >>> check_numbers(1, [10]) [\\"YES\\"] >>> check_numbers(1, [4]) [\\"YES\\"] >>> check_numbers(1, [1000000]) [\\"YES\\"] >>> check_numbers(2, [999983, 999979]) [\\"NO\\", \\"NO\\"] >>> check_numbers(4, [4, 6, 8, 10]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def sieve(n): is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False primes = [p for p in range(n + 1) if is_prime[p]] return primes, is_prime def can_be_sum_of_two_unique_primes(n, primes, is_prime): for prime in primes: if prime >= n: return \\"NO\\" if is_prime[n - prime]: return \\"YES\\" return \\"NO\\" def check_numbers(t, numbers): max_number = max(numbers) primes, is_prime = sieve(max_number) results = [] for number in numbers: results.append(can_be_sum_of_two_unique_primes(number, primes, is_prime)) return results # Example usage: # t = 3 # numbers = [10, 17, 34] # results = check_numbers(t, numbers) # for result in results: # print(result)"},{"question":"from typing import List def can_form_cake(N: int, K: int, layer_scores: List[int], S: int) -> str: Determines if it is possible to form a cake with exactly K layers with the sum of scores equal to S. Parameters: N (int): Total number of available layers. K (int): Number of layers the customer wants in the cake. layer_scores (list): List of integers representing the scores of available layers. S (int): Desired sum of the scores of the layers in the cake. Returns: str: \\"YES\\" if it is possible, \\"NO\\" otherwise. >>> can_form_cake(5, 3, [10, 20, 30, 40, 50], 60) 'YES' >>> can_form_cake(4, 2, [5, 25, 35, 50], 100) 'NO' >>> can_form_cake(3, 1, [15, 25, 35], 15) 'YES' >>> can_form_cake(2, 1, [20, 30], 10) 'NO' >>> can_form_cake(4, 4, [10, 20, 30, 40], 100) 'YES' >>> can_form_cake(5, 3, [1, 1, 1, 1, 1], 3) 'YES'","solution":"from itertools import combinations def can_form_cake(N, K, layer_scores, S): Determines if it is possible to form a cake with exactly K layers with the sum of scores equal to S. Parameters: N (int): Total number of available layers. K (int): Number of layers the customer wants in the cake. layer_scores (list): List of integers representing the scores of available layers. S (int): Desired sum of the scores of the layers in the cake. Returns: str: \\"YES\\" if it is possible, \\"NO\\" otherwise. # Generate all possible combinations of K layers from the given layer scores for combination in combinations(layer_scores, K): if sum(combination) == S: return \\"YES\\" return \\"NO\\""},{"question":"def shortest_substring_length(n: int, s: str) -> int: Determine the length of the shortest substring that contains at least one 'a' and one 'b'. If no such substring exists, return 0. Parameters: n (int): The length of the string. s (str): The input string consisting of characters 'a' and 'b' only. Returns: int: The length of the shortest substring containing both characters 'a' and 'b', or 0 if no such substring exists. Examples: >>> shortest_substring_length(7, 'aabbbab') 2 >>> shortest_substring_length(5, 'aaaaa') 0 >>> shortest_substring_length(6, 'abbbbb') 2","solution":"def shortest_substring_length(n, s): Returns the length of the shortest substring that contains at least one 'a' and one 'b'. If no such substring exists, returns 0. min_length = float('inf') found = False for i in range(n - 1): if s[i] != s[i + 1]: min_length = min(min_length, 2) found = True return min_length if found else 0"},{"question":"def count_a_occurrences(lines: List[str]) -> List[int]: Counts the occurrences of the character 'a' (case-insensitive) in each line of input. >>> count_a_occurrences([\\"apple\\", \\"banana\\", \\"A random sentence with several a's and Aa.\\"]) [1, 3, 7] >>> count_a_occurrences([\\"a\\", \\"b\\", \\"A\\"]) [1, 0, 1]","solution":"def count_a_occurrences(lines): Counts the occurrences of the character 'a' (case-insensitive) in each line of input. :param lines: List of strings where each string is a word or sentence :return: List of integers where each integer is the count of 'a' characters (case-insensitive) in the corresponding line results = [] for line in lines: count = sum(1 for char in line if char.lower() == 'a') results.append(count) return results"},{"question":"def find_leap_years(years): This function takes a list of years and returns a list of strings indicating whether each year is a leap year or not. >>> find_leap_years([2000, 2001, 2002, 2003, 2004]) [\\"leap year\\", \\"not leap year\\", \\"not leap year\\", \\"not leap year\\", \\"leap year\\"] >>> find_leap_years([1900, 1600, 2400]) [\\"not leap year\\", \\"leap year\\", \\"leap year\\"]","solution":"def find_leap_years(years): This function takes a list of years and returns a list of strings indicating whether each year is a leap year or not. results = [] for year in years: if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): results.append(\\"leap year\\") else: results.append(\\"not leap year\\") return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_list): if not node_list: return None nodes = {} for value, left, right in node_list: if value not in nodes: nodes[value] = TreeNode(value) node = nodes[value] if left != -1: if left not in nodes: nodes[left] = TreeNode(left) node.left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) node.right = nodes[right] return nodes[node_list[0][0]] def height_of_binary_tree(n, node_list): Determine the height of a binary tree given its nodes. Args: n (int): Number of nodes in the tree. node_list (List[Tuple[int, int, int]]): List of tuples where each tuple contains the value of the node and its left and right children. Returns: int: Height of the binary tree. Example: >>> height_of_binary_tree(5, [(1, 2, 3), (2, 4, -1), (3, -1, 5), (4, -1, -1), (5, -1, -1)]) 2 >>> height_of_binary_tree(1, [(1, -1, -1)]) 0 >>> height_of_binary_tree(0, []) -1 if n == 0: return -1 # To denote an empty tree root = build_tree(node_list) def height(node): if not node: return 0 left_height = height(node.left) right_height = height(node.right) return 1 + max(left_height, right_height) return height(root) - 1","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_list): if not node_list: return None nodes = {} for value, left, right in node_list: if value not in nodes: nodes[value] = TreeNode(value) node = nodes[value] if left != -1: if left not in nodes: nodes[left] = TreeNode(left) node.left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) node.right = nodes[right] return nodes[node_list[0][0]] def height_of_binary_tree(n, node_list): if n == 0: return -1 # To denote an empty tree root = build_tree(node_list) def height(node): if not node: return 0 left_height = height(node.left) right_height = height(node.right) return 1 + max(left_height, right_height) return height(root) - 1"},{"question":"def is_subset_sum_exist(t, test_cases): Determine whether there is a subset of integers that sums to exactly S. >>> is_subset_sum_exist(2, [((5, 9), [3, 34, 4, 12, 5]), ((4, 30), [3, 34, 4, 12])]) ['YES', 'NO'] >>> is_subset_sum_exist(1, [((6, 8), [1, 3, 5, 7, 9, 11])]) ['YES'] >>> is_subset_sum_exist(1, [((3, 5), [2, 2, 2])]) ['NO'] >>> is_subset_sum_exist(1, [((5, 10), [1, 2, 3, 4, 5])]) ['YES'] >>> is_subset_sum_exist(1, [((5, 17), [2, 3, 5, 8, 10])]) ['YES']","solution":"def subset_sum_exists(arr, n, sum_val): dp = [[False for x in range(sum_val + 1)] for y in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, sum_val + 1): if j < arr[i - 1]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] return dp[n][sum_val] def is_subset_sum_exist(t, test_cases): results = [] for i in range(t): n, s = test_cases[i][0] arr = test_cases[i][1] if subset_sum_exists(arr, n, s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_identical_gift_bags(t: int, quantities: List[int]) -> int: Returns the maximum number of identical gift bags that can be prepared. Each type of item has a fixed quantity, and each bag must include at least one item of each type. Given the quantities of each type, determine the maximum number of identical gift bags that can be prepared. Parameters: t (int): The number of types of items. quantities (List[int]): A list where each element represents the quantity of the corresponding type of item. Returns: int: The maximum number of identical gift bags. Examples: >>> max_identical_gift_bags(3, [6, 4, 8]) 4 >>> max_identical_gift_bags(5, [10, 1, 10, 1, 10]) 1 >>> max_identical_gift_bags(4, [9, 9, 9, 9]) 9 >>> max_identical_gift_bags(2, [5, 20]) 5","solution":"def max_identical_gift_bags(t, quantities): Returns the maximum number of identical gift bags that can be prepared. return min(quantities)"},{"question":"def digital_root(n): Computes the digital root of a non-negative integer n. >>> digital_root(12345) 6 >>> digital_root(98765) 8 >>> digital_root(0) 0 >>> digital_root(9) 9 >>> digital_root(99) 9 >>> digital_root(999) 9 pass def main(input_lines): Reads a sequence of lines containing non-negative integers and prints their digital roots. The input ends with a line containing a single 0. >>> main([\\"12345\\", \\"98765\\", \\"0\\"]) [6, 8] >>> main([\\"999\\", \\"27\\", \\"12345\\", \\"0\\"]) [9, 9, 6] >>> main([\\"1\\", \\"2\\", \\"3\\", \\"0\\"]) [1, 2, 3] >>> main([\\"10\\", \\"20\\", \\"30\\", \\"0\\"]) [1, 2, 3] >>> main([\\"0\\"]) [] pass","solution":"def digital_root(n): Computes the digital root of a non-negative integer n. if n == 0: return 0 return 1 + (n - 1) % 9 def main(input_lines): Reads a sequence of lines containing non-negative integers and prints their digital roots. The input ends with a line containing a single 0. results = [] for line in input_lines: n = int(line) if n == 0: break results.append(digital_root(n)) return results"},{"question":"def is_beautiful_string(s: str) -> str: Determines if the given string is beautiful. A string is considered beautiful if it contains only characters 'a', 'b', 'c', and these characters do not appear more than twice consecutively. Args: s (str): The string to check. Returns: str: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". >>> is_beautiful_string(\\"abcabc\\") \\"YES\\" >>> is_beautiful_string(\\"aaabbb\\") \\"NO\\" >>> is_beautiful_string(\\"aabbcc\\") \\"YES\\" >>> is_beautiful_string(\\"abccccc\\") \\"NO\\" >>> is_beautiful_string(\\"a\\") \\"YES\\" >>> is_beautiful_string(\\"ccc\\") \\"NO\\"","solution":"def is_beautiful_string(s): Determines if the given string is beautiful. A string is considered beautiful if it contains only characters 'a', 'b', 'c', and these characters do not appear more than twice consecutively. Args: s (str): The string to check. Returns: str: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". for i in range(len(s) - 2): if s[i] == s[i + 1] == s[i + 2]: return \\"NO\\" return \\"YES\\""},{"question":"def check_string(s: str) -> str: Returns \\"YES\\" if the string contains at least one uppercase letter and at least one lowercase letter, otherwise returns \\"NO\\". >>> check_string(\\"HelloWorld\\") \\"YES\\" >>> check_string(\\"AbC\\") \\"YES\\" >>> check_string(\\"aB\\") \\"YES\\" >>> check_string(\\"HELLO\\") \\"NO\\" >>> check_string(\\"WORLD\\") \\"NO\\" >>> check_string(\\"helloworld\\") \\"NO\\" >>> check_string(\\"python\\") \\"NO\\" >>> check_string(\\"a\\") \\"NO\\" >>> check_string(\\"A\\") \\"NO\\" >>> check_string(\\"\\") \\"NO\\" >>> check_string(\\"A\\"*50 + \\"b\\"*50) \\"YES\\" >>> check_string(\\"a\\"*49 + \\"B\\"*51) \\"YES\\"","solution":"def check_string(s): Returns \\"YES\\" if the string contains at least one uppercase letter and at least one lowercase letter, otherwise returns \\"NO\\". has_upper = any(char.isupper() for char in s) has_lower = any(char.islower() for char in s) if has_upper and has_lower: return \\"YES\\" return \\"NO\\""},{"question":"def most_frequent_integer(n: int, arr: List[int]) -> int: Determines which integer appears the most frequently in the list. In case of a tie, returns the smallest integer among those that appear with the highest frequency. >>> most_frequent_integer(5, [1, 2, 2, 3, 3]) 2 >>> most_frequent_integer(6, [4, 4, 1, 1, 2, 2]) 1 >>> most_frequent_integer(4, [-1, -1, 2, 2]) -1 def test_single_element_list(): assert most_frequent_integer(1, [5]) == 5 def test_all_unique_elements(): assert most_frequent_integer(5, [1, 2, 3, 4, 5]) == 1 def test_multiple_frequent_elements(): assert most_frequent_integer(5, [1, 2, 2, 3, 3]) == 2 assert most_frequent_integer(6, [4, 4, 1, 1, 2, 2]) == 1 assert most_frequent_integer(4, [-1, -1, 2, 2]) == -1 def test_all_same_elements(): assert most_frequent_integer(4, [3, 3, 3, 3]) == 3 def test_negative_and_positive_mix(): assert most_frequent_integer(6, [-1, -1, -1, 2, 2, 2]) == -1 assert most_frequent_integer(7, [-3, -3, 2, 2, 3, 3, -4]) == -3 def test_large_list(): assert most_frequent_integer(100, [i % 10 for i in range(100)]) == 0","solution":"def most_frequent_integer(n, arr): Determines which integer appears the most frequently in the list. In case of a tie, returns the smallest integer among those that appear with the highest frequency. from collections import Counter # Count the frequency of each integer in the list counter = Counter(arr) # Get the maximum frequency max_freq = max(counter.values()) # Find all integers that have the maximum frequency candidates = [num for num, freq in counter.items() if freq == max_freq] # Return the smallest integer among the candidates return min(candidates)"},{"question":"def determine_winner(n: int) -> str: Determines the winner of the game for a given integer \`n\`. If \`n\` is even, Alice wins. If \`n\` is odd, Bob wins. pass def get_game_results(nums: List[int]) -> List[str]: Given a list of integers, returns the results of the game for each integer. List of results will contain \\"Alice\\" if Alice wins the game for corresponding integer, and \\"Bob\\" otherwise. >>> get_game_results([1, 2, 3, 12, 15]) [\\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\"] >>> get_game_results([7, 10, 13, 16, 19]) [\\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\"] pass","solution":"def determine_winner(n): Determines the winner of the game for a given integer \`n\`. If \`n\` is even, Alice wins. If \`n\` is odd, Bob wins. if n % 2 == 0: return \\"Alice\\" else: return \\"Bob\\" def get_game_results(nums): results = [] for num in nums: results.append(determine_winner(num)) return results"},{"question":"def contains_duplicates(list_of_nums: List[int]) -> str: Returns 'YES' if the list contains duplicates, otherwise 'NO'. >>> contains_duplicates([1, 2, 3, 4, 5]) == \\"NO\\" >>> contains_duplicates([10, 20, 30, 40, 50, 10]) == \\"YES\\" >>> contains_duplicates([-1, -2, -3, -4, -5, -1]) == \\"YES\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes a list of test cases and returns a list of results indicating if each contains duplicates. >>> process_test_cases([\\"1 2 3 4 5\\", \\"10 20 30 40 50 10\\", \\"-1 -2 -3 -4 -5 -1\\"]) == [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def contains_duplicates(list_of_nums): Returns \\"YES\\" if the list contains duplicates, otherwise \\"NO\\". return \\"YES\\" if len(list_of_nums) != len(set(list_of_nums)) else \\"NO\\" def process_test_cases(test_cases): Processes a list of test cases and returns a list of results indicating if each contains duplicates. results = [] for case in test_cases: list_of_nums = list(map(int, case.split())) results.append(contains_duplicates(list_of_nums)) return results"},{"question":"from typing import List, Dict, Tuple def group_and_sort_books(n: int, books: List[Tuple[int, str]]) -> Dict[str, List[int]]: Groups books by their genres and sorts each group by the book IDs in ascending order. Args: - n: An integer, the number of books. - books: A list of tuples, where each tuple contains: - An integer id: The book's ID. - A string genre: The book's genre. Returns: - A dictionary where the keys are genres and the values are lists of book IDs sorted in ascending order. pass def test_group_and_sort_books(): assert group_and_sort_books(5, [(1, \\"Fiction\\"), (2, \\"Science\\"), (3, \\"Fiction\\"), (4, \\"History\\"), (5, \\"Science\\")]) == { \\"Fiction\\": [1, 3], \\"Science\\": [2, 5], \\"History\\": [4] } def test_single_book(): assert group_and_sort_books(1, [(10, \\"Mystery\\")]) == { \\"Mystery\\": [10] } def test_multiple_genres_with_single_books(): assert group_and_sort_books(3, [(1, \\"Romance\\"), (2, \\"Adventure\\"), (3, \\"Mystery\\")]) == { \\"Romance\\": [1], \\"Adventure\\": [2], \\"Mystery\\": [3] } def test_multiple_books_same_genre(): assert group_and_sort_books(4, [(10, \\"Science\\"), (9, \\"Science\\"), (8, \\"Science\\"), (7, \\"Science\\")]) == { \\"Science\\": [7, 8, 9, 10] } def test_large_id_values(): assert group_and_sort_books(4, [(1000000, \\"Fiction\\"), (999999, \\"Science\\"), (1, \\"Fiction\\"), (2, \\"Science\\")]) == { \\"Fiction\\": [1, 1000000], \\"Science\\": [2, 999999] } def test_no_books(): assert group_and_sort_books(0, []) == {} def test_identical_genres_with_different_ids(): assert group_and_sort_books(3, [(5, \\"Drama\\"), (4, \\"Drama\\"), (8, \\"Drama\\")]) == { \\"Drama\\": [4, 5, 8] }","solution":"def group_and_sort_books(n, books): Groups books by their genres and sorts each group by the book IDs in ascending order. Args: - n: An integer, the number of books. - books: A list of tuples, where each tuple contains: - An integer id: The book's ID. - A string genre: The book's genre. Returns: - A dictionary where the keys are genres and the values are lists of book IDs sorted in ascending order. from collections import defaultdict genre_dict = defaultdict(list) for book_id, genre in books: genre_dict[genre].append(book_id) for genre in genre_dict: genre_dict[genre].sort() return dict(genre_dict)"},{"question":"def longest_subarray_with_k_distinct(n: int, k: int, array: List[int]) -> int: Write a program that takes in an array of integers, and an integer \`k\`, and returns the length of the longest contiguous subarray that contains at most \`k\` distinct integers. >>> longest_subarray_with_k_distinct(5, 2, [1, 2, 1, 2, 3]) 4 >>> longest_subarray_with_k_distinct(6, 6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_subarray_with_k_distinct(1, 1, [99]) 1 >>> longest_subarray_with_k_distinct(5, 1, [4, 4, 1, 1, 1]) 3 >>> longest_subarray_with_k_distinct(3, 1, [2, 2, 2]) 3 >>> longest_subarray_with_k_distinct(4, 3, [5, 5, 5, 5]) 4 >>> longest_subarray_with_k_distinct(3, 1, [3, 1, 2]) 1","solution":"def longest_subarray_with_k_distinct(n, k, array): Returns the length of the longest contiguous subarray that contains at most k distinct integers. from collections import defaultdict left = 0 right = 0 max_length = 0 distinct_count = defaultdict(int) while right < n: distinct_count[array[right]] += 1 while len(distinct_count) > k: distinct_count[array[left]] -= 1 if distinct_count[array[left]] == 0: del distinct_count[array[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"from typing import List, Tuple def most_frequent_element(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the most frequent element in each test case. If multiple elements have the same highest frequency, return the smallest one. >>> most_frequent_element([(6, [1, 2, 3, 2, 4, 2]), (5, [1, 2, 3, 1, 3])]) [2, 1] >>> most_frequent_element([(5, [5, 5, 5, 2, 2])]) [5] >>> most_frequent_element([(3, [1, 1, 1]), (4, [2, 2, 3, 3]), (2, [4, 5])]) [1, 2, 4] def process_input(input_data: str) -> List[int]: Process input string and call the most_frequent_element function to get the results. >>> process_input(\\"2n6n1 2 3 2 4 2n5n1 2 3 1 3\\") [2, 1] >>> process_input(\\"1n5n5 5 5 2 2\\") [5]","solution":"def most_frequent_element(test_cases): from collections import Counter results = [] for case in test_cases: n, arr = case count = Counter(arr) max_freq = max(count.values()) most_frequent = [num for num, freq in count.items() if freq == max_freq] results.append(min(most_frequent)) return results # This function processes the input and calls the most_frequent_element function to get the results def process_input(input_data): lines = input_data.strip().split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return most_frequent_element(test_cases)"},{"question":"def remove_duplicates(input_string: str) -> str: Returns a new string with all duplicate characters removed and each character appearing only once in its first occurrence order. >>> remove_duplicates(\\"input_string\\") == \\"input_srg\\" >>> remove_duplicates(\\"aaaa\\") == \\"a\\" >>> remove_duplicates(\\"abcabc\\") == \\"abc\\" >>> remove_duplicates(\\"xyzxyzxyz\\") == \\"xyz\\" >>> remove_duplicates(\\"\\") == \\"\\" >>> remove_duplicates(\\"a\\") == \\"a\\" >>> remove_duplicates(\\"abcdef\\") == \\"abcdef\\" >>> remove_duplicates(\\"xyz\\") == \\"xyz\\" >>> remove_duplicates(\\"hello\\") == \\"helo\\" >>> remove_duplicates(\\"mississippi\\") == \\"misp\\"","solution":"def remove_duplicates(input_string): Returns a new string with all duplicate characters removed and each character appearing only once in its first occurrence order. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def max_tasks(tasks: list[str], members: dict[str, list[str]]) -> int: Determines the maximum number of tasks that can be assigned given a list of tasks and members with their respective capabilities. Args: tasks: A list of strings where each string represents a task. members: A dictionary where keys are strings representing member names, and values are lists of strings representing tasks that the member can perform. Returns: An integer representing the maximum number of tasks that can be assigned. >>> tasks = [\\"setup\\", \\"host\\", \\"scorekeeping\\", \\"refreshments\\"] >>> members = { ... \\"Alice\\": [\\"setup\\", \\"host\\"], ... \\"Bob\\": [\\"scorekeeping\\", \\"refreshments\\"], ... \\"Charlie\\": [\\"refreshments\\"], ... } >>> max_tasks(tasks, members) 3 >>> tasks = [\\"setup\\", \\"host\\", \\"scorekeeping\\", \\"refreshments\\"] >>> members = { ... \\"Alice\\": [\\"setup\\"], ... \\"Bob\\": [\\"host\\"], ... \\"Charlie\\": [\\"scorekeeping\\"], ... \\"David\\": [\\"refreshments\\"], ... } >>> max_tasks(tasks, members) 4 >>> tasks = [\\"setup\\", \\"host\\", \\"scorekeeping\\", \\"refreshments\\"] >>> members = { ... \\"Alice\\": [\\"setup\\"], ... \\"Bob\\": [\\"host\\"], ... \\"Charlie\\": [\\"scorekeeping\\"], ... } >>> max_tasks(tasks, members) 3 >>> tasks = [\\"setup\\", \\"host\\", \\"scorekeeping\\", \\"refreshments\\"] >>> members = { ... \\"Alice\\": [], ... \\"Bob\\": [], ... \\"Charlie\\": [], ... } >>> max_tasks(tasks, members) 0 >>> tasks = [\\"task\\" + str(i) for i in range(100)] >>> members = {f\\"member{i}\\": [f\\"task{j}\\" for j in range(i, i+10) if j < 100] for i in range(50)} >>> max_tasks(tasks, members) 50 >>> tasks = [\\"t1\\", \\"t2\\", \\"t3\\"] >>> members = { ... \\"Alice\\": [\\"t1\\"], ... \\"Bob\\": [\\"t2\\"], ... \\"Charlie\\": [\\"t3\\"], ... \\"David\\": [\\"t1\\", \\"t2\\"], ... } >>> max_tasks(tasks, members) 3 pass","solution":"def max_tasks(tasks: list[str], members: dict[str, list[str]]) -> int: # We will use maximum bipartite matching algorithm for this problem. n_tasks = len(tasks) n_members = len(members) task_to_index = {task: i for i, task in enumerate(tasks)} # Create an adjacency matrix to represent the bipartite graph adj = [[0] * n_members for _ in range(n_tasks)] for member_idx, (member, member_tasks) in enumerate(members.items()): for task in member_tasks: if task in task_to_index: adj[task_to_index[task]][member_idx] = 1 def bpm(u, seen, match_r): for v in range(n_members): if adj[u][v] and not seen[v]: seen[v] = True if match_r[v] == -1 or bpm(match_r[v], seen, match_r): match_r[v] = u return True return False match_r = [-1] * n_members result = 0 for i in range(n_tasks): seen = [False] * n_members if bpm(i, seen, match_r): result += 1 return result"},{"question":"def longest_common_subsequence(n: int, m: int, s1: str, s2: str) -> int: Determine the length of the longest common subsequence of runes in two stone tablets. Args: n (int): The number of runes on the first tablet. m (int): The number of runes on the second tablet. s1 (str): The runes on the first tablet. s2 (str): The runes on the second tablet. Returns: int: The length of the longest common subsequence of runes. Examples: >>> longest_common_subsequence(6, 7, \\"abcdef\\", \\"acdfbeg\\") 4 >>> longest_common_subsequence(4, 5, \\"wxyz\\", \\"yzwux\\") 2","solution":"def longest_common_subsequence(n, m, s1, s2): # Create a 2D table to store lengths of longest common subsequence. dp = [[0] * (m + 1) for _ in range(n + 1)] # Build the dp table in bottom-up fashion. for i in range(n + 1): for j in range(m + 1): if i == 0 or j == 0: dp[i][j] = 0 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # dp[n][m] contains the length of LCS. return dp[n][m]"},{"question":"def is_prime(num: int) -> bool: Check if the given number is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(1) == False >>> is_prime(0) == False def nearest_prime(n: int) -> int: Find the largest prime number less than or equal to n. >>> nearest_prime(10) == 7 >>> nearest_prime(29) == 29 >>> nearest_prime(1) == None >>> nearest_prime(2) == 2 >>> nearest_prime(100) == 97 >>> nearest_prime(97) == 97 >>> nearest_prime(30) == 29","solution":"def is_prime(num): Check if the given number is a prime number. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def nearest_prime(n): Find the largest prime number less than or equal to n. while n > 1: if is_prime(n): return n n -= 1 return None"},{"question":"def longest_repeated_subsequence(arr: List[int]) -> int: Returns the length of the longest subsequence of consecutive repeated numbers. >>> longest_repeated_subsequence([1, 2, 2, 2, 3, 3, 4, 4, 4, 4]) 4 >>> longest_repeated_subsequence([5, 5, 5, 5, 5, 5, 5]) 7 >>> longest_repeated_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) 1","solution":"def longest_repeated_subsequence(arr): Returns the length of the longest subsequence of consecutive repeated numbers. if not arr: return 0 longest = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 if current_length > longest: longest = current_length else: current_length = 1 return longest"},{"question":"from typing import List, Tuple def can_partition_into_subsets_divisible_by_k(arr: List[int], k: int) -> bool: Determine if there is a way to partition the array into two non-empty subsets such that the sum of the elements in each subset is a multiple of k. Parameters: - arr: List[int] : List of integers representing the array - k: int : The integer divisor Returns: - bool: True if such a partition exists, False otherwise pass def process_test_cases(test_cases: List[Tuple[int, List[int], int]]) -> List[str]: Process multiple test cases to determine if each can be partitioned into subsets divisible by k. Parameters: - test_cases: List[Tuple[int, List[int], int]] : List of tuples, each containing: - n: int : Number of elements in the array - arr: List[int] : List of integers representing the array - k: int : The integer divisor Returns: - List[str] : List of strings \\"YES\\" or \\"NO\\" for each test case pass def test_single_case(): assert process_test_cases([(5, [1, 2, 3, 4, 5], 3)]) == [\\"YES\\"] def test_single_case_no(): assert process_test_cases([(4, [6, 9, 7, 12], 5)]) == [\\"NO\\"] def test_multiple_cases(): test_cases = [ (5, [1, 2, 3, 4, 5], 3), (4, [6, 9, 7, 12], 5) ] assert process_test_cases(test_cases) == [\\"YES\\", \\"NO\\"] def test_all_elements_multiple_of_k(): assert process_test_cases([(3, [3, 6, 9], 3)]) == [\\"YES\\"] def test_no_partition_found(): assert process_test_cases([(2, [1, 2], 4)]) == [\\"NO\\"] def test_large_numbers(): assert process_test_cases([(3, [1000, 2000, 3000], 1000)]) == [\\"YES\\"]","solution":"def can_partition_into_subsets_divisible_by_k(arr, k): total_sum = sum(arr) if total_sum % k != 0: return False n = len(arr) dp = [False] * k dp[0] = True for num in arr: next_dp = dp[:] for i in range(k): if dp[i]: next_dp[(i + num) % k] = True dp = next_dp return dp[0] def process_test_cases(test_cases): results = [] for case in test_cases: n, arr, k = case if n == 1: results.append(\\"NO\\") else: if can_partition_into_subsets_divisible_by_k(arr, k): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimum_replacements(n: int, s: str) -> int: Returns the minimum number of replacements required to make all flowers red. :param n: Number of flowerpots (int) :param s: String representation of flowers (str) :return: Minimum number of replacements (int) >>> minimum_replacements(5, \\"RBBRR\\") 2 >>> minimum_replacements(3, \\"BBB\\") 3 >>> minimum_replacements(5, \\"RRRRR\\") 0 >>> minimum_replacements(1, \\"R\\") 0 >>> minimum_replacements(1, \\"B\\") 1 >>> minimum_replacements(10, \\"RBRBRBRBRB\\") 5","solution":"def minimum_replacements(n, s): Returns the minimum number of replacements required to make all flowers red. :param n: Number of flowerpots (int) :param s: String representation of flowers (str) :return: Minimum number of replacements (int) return s.count('B')"},{"question":"def find_substring_indices(S: str, L: List[str]) -> List[int]: Given a string S and a list of substrings L, find all starting indices of substring(s) in S that are a concatenation of each substring in L exactly once and without any intervening characters. >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring_indices(\\"abcabc\\", [\\"def\\"]) []","solution":"def find_substring_indices(S, L): from collections import Counter if not S or not L or not L[0]: return [] word_length = len(L[0]) num_words = len(L) concat_length = word_length * num_words word_count = Counter(L) result_indices = [] for i in range(word_length): left, count, temp_count = i, 0, Counter() for j in range(i, len(S) - word_length + 1, word_length): word = S[j:j + word_length] if word in word_count: temp_count[word] += 1 count += 1 while temp_count[word] > word_count[word]: left_word = S[left:left + word_length] temp_count[left_word] -= 1 count -= 1 left += word_length if count == num_words: result_indices.append(left) else: temp_count.clear() count = 0 left = j + word_length return result_indices"},{"question":"def count_non_blocked_buildings(buildings): Given a list of buildings with their x-coordinates and heights, returns the number of buildings that are not blocked by any building to their right. :param buildings: List of tuples, where each tuple contains two integers - x-coordinate and height of a building :return: Integer, number of buildings not blocked by any building to their right >>> count_non_blocked_buildings([(1, 5), (2, 3), (3, 6), (4, 4), (5, 2)]) 3 >>> count_non_blocked_buildings([(1, 5), (2, 6), (3, 7), (4, 8)]) 1 >>> count_non_blocked_buildings([(1, 5), (2, 4), (3, 3), (4, 2)]) 4 >>> count_non_blocked_buildings([]) 0 >>> count_non_blocked_buildings([(1, 5)]) 1 >>> count_non_blocked_buildings([(1, 2), (2, 2), (3, 2), (4, 2)]) 1","solution":"def count_non_blocked_buildings(buildings): Given a list of buildings with their x-coordinates and heights, returns the number of buildings that are not blocked by any building to their right. :param buildings: List of tuples, where each tuple contains two integers - x-coordinate and height of a building :return: Integer, number of buildings not blocked by any building to their right # Sort buildings according to their x-coordinate buildings.sort() # Traverse from right to left and keep track of max height seen so far max_height_right = 0 count_non_blocked = 0 for x, h in reversed(buildings): if h > max_height_right: count_non_blocked += 1 max_height_right = h return count_non_blocked"},{"question":"from itertools import combinations from typing import List def min_abs_sum_diff(nums: List[int]) -> int: Determine the smallest possible absolute difference between the sum of elements of any two non-empty subsets from the given list. Args: nums: List[int] - a list of integers Returns: int - the minimum absolute difference between the sums of any two non-empty subsets Example: >>> min_abs_sum_diff([1, 6, 11, 5]) 1 >>> min_abs_sum_diff([8, 5, 3]) 0","solution":"from itertools import combinations def min_abs_sum_diff(nums): total_sum = sum(nums) n = len(nums) min_diff = float('inf') # Check each possible subset for i in range(1, n): for subset in combinations(nums, i): subset_sum = sum(subset) other_sum = total_sum - subset_sum min_diff = min(min_diff, abs(subset_sum - other_sum)) return min_diff"},{"question":"from typing import List def sort_binary_ids(binary_ids: List[str]) -> List[str]: Sorts binary IDs based on the specified criteria: 1. Number of '1's in the binary ID. 2. Length of the binary ID. 3. Lexicographical order if the number of '1's and lengths are the same. Args: binary_ids (List[str]): List of binary ID strings. Returns: List[str]: Sorted list of binary ID strings. Examples: >>> sort_binary_ids([\\"110\\", \\"101\\", \\"111\\", \\"1001\\", \\"1111\\"]) ['101', '110', '1001', '111', '1111'] >>> sort_binary_ids([\\"0\\", \\"00\\", \\"000\\"]) ['0', '00', '000'] from typing import List def test_sort_binary_ids_example(): input_data = [\\"110\\", \\"101\\", \\"111\\", \\"1001\\", \\"1111\\"] expected_output = [\\"101\\", \\"110\\", \\"1001\\", \\"111\\", \\"1111\\"] assert sort_binary_ids(input_data) == expected_output def test_sort_all_equal(): input_data = [\\"0\\", \\"00\\", \\"000\\"] expected_output = [\\"0\\", \\"00\\", \\"000\\"] assert sort_binary_ids(input_data) == expected_output def test_sort_varied_lengths(): input_data = [\\"111\\", \\"11\\", \\"1\\", \\"10101\\", \\"101\\"] expected_output = [\\"1\\", \\"11\\", \\"101\\", \\"111\\", \\"10101\\"] assert sort_binary_ids(input_data) == expected_output def test_sort_mixed_ones_and_lengths(): input_data = [\\"11000\\", \\"101\\", \\"111\\", \\"1001\\", \\"1111\\"] expected_output = [\\"101\\", \\"1001\\", \\"11000\\", \\"111\\", \\"1111\\"] assert sort_binary_ids(input_data) == expected_output def test_sort_same_count_and_length(): input_data = [\\"10\\", \\"01\\", \\"11\\"] expected_output = [\\"01\\", \\"10\\", \\"11\\"] assert sort_binary_ids(input_data) == expected_output","solution":"def sort_binary_ids(binary_ids): Sorts binary IDs based on the specified criteria: 1. Number of '1's in the binary ID. 2. Length of the binary ID. 3. Lexicographical order if the number of '1's and lengths are the same. # Use a customized sorting with a key function sorted_ids = sorted(binary_ids, key=lambda x: (x.count('1'), len(x), x)) return sorted_ids"},{"question":"from typing import List, Tuple import math def smallest_distance(n: int, coordinates: List[Tuple[int, int]]) -> float: Returns the smallest distance between any two stores given their coordinates. :param n: Number of stores :param coordinates: List of tuples, each containing the (x, y) coordinates of a store. :return: Smallest Euclidean distance between any two stores. >>> smallest_distance(5, [(0, 0), (0, 4), (3, 0), (4, 4), (1, 1)]) 1.414213 >>> smallest_distance(3, [(-1, -1), (-2, -2), (3, 4)]) 1.414213 import itertools def test_case_1(): n = 5 coordinates = [(0, 0), (0, 4), (3, 0), (4, 4), (1, 1)] result = smallest_distance(n, coordinates) expected = math.sqrt(2) assert math.isclose(result, expected, rel_tol=1e-6) def test_case_2(): n = 3 coordinates = [(-1, -1), (-2, -2), (3, 4)] result = smallest_distance(n, coordinates) expected = math.sqrt(2) assert math.isclose(result, expected, rel_tol=1e-6) def test_case_3(): n = 4 coordinates = [(1, 1), (2, 2), (3, 3), (4, 4)] result = smallest_distance(n, coordinates) expected = math.sqrt(2) assert math.isclose(result, expected, rel_tol=1e-6) def test_case_4(): n = 2 coordinates = [(0, 0), (0, 1)] result = smallest_distance(n, coordinates) expected = 1.0 assert math.isclose(result, expected, rel_tol=1e-6) def test_case_5(): n = 3 coordinates = [(0, 0), (3, 4), (6, 8)] result = smallest_distance(n, coordinates) expected = 5.0 assert math.isclose(result, expected, rel_tol=1e-6)","solution":"import math import itertools def smallest_distance(n, coordinates): Returns the smallest distance between any two stores given their coordinates. :param n: Number of stores :param coordinates: List of tuples, each containing the (x, y) coordinates of a store. :return: Smallest Euclidean distance between any two stores. min_distance = float('inf') for (x1, y1), (x2, y2) in itertools.combinations(coordinates, 2): dist = math.dist((x1, y1), (x2, y2)) min_distance = min(min_distance, dist) return min_distance"},{"question":"from typing import List def min_steps_to_reach_end(grid: List[List[str]]) -> int: Find the minimum number of steps required for the robot to reach the bottom-right corner of the grid. >>> min_steps_to_reach_end([ ... [\\".\\", \\"#\\", \\"#\\"], ... [\\".\\", \\".\\", \\"#\\"], ... [\\"#\\", \\".\\", \\".\\"] ... ]) 4 >>> min_steps_to_reach_end([ ... [\\".\\", \\"#\\", \\"#\\"], ... [\\"#\\", \\"#\\", \\"#\\"], ... [\\"#\\", \\".\\", \\".\\"] ... ]) -1 >>> min_steps_to_reach_end([[\\".\\"]]) 0 >>> min_steps_to_reach_end([[\\"#\\"]]) -1 >>> min_steps_to_reach_end([ ... [\\".\\", \\"#\\", \\"#\\"], ... [\\"#\\", \\"#\\", \\"#\\"], ... [\\"#\\", \\"#\\", \\".\\"], ... ]) -1 >>> min_steps_to_reach_end([ ... [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"#\\", \\"#\\", \\"#\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"#\\", \\".\\"], ... [\\"#\\", \\"#\\", \\".\\", \\"#\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"] ... ]) 8","solution":"from typing import List from collections import deque def min_steps_to_reach_end(grid: List[List[str]]) -> int: R, C = len(grid), len(grid[0]) if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == R-1 and c == C-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"from typing import List def num_unique_paths(n: int, grid: List[List[str]]) -> int: Determine the number of unique paths from the top-left corner (1, 1) to the bottom-right corner (n, n) on a grid. Args: n : int : the size of the grid. grid : List[List[str]] : n x n grid where '.' represents a passable cell and '#' represents a blocked cell. Returns: int : the number of unique paths from (1, 1) to (n, n). If there is no valid path, return 0. Examples: >>> num_unique_paths(3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> num_unique_paths(3, [['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.']]) 1 >>> num_unique_paths(3, [['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.']]) 0","solution":"def num_unique_paths(n, grid): if n == 0 or grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def max_non_overlapping_tasks(n: int, tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be completed. Args: - n: int, number of tasks - tasks: list of tuple, each containing the start and end time of a task Returns: - int, maximum number of non-overlapping tasks Examples: >>> max_non_overlapping_tasks(3, [(1, 4), (2, 3), (3, 5)]) 2 >>> max_non_overlapping_tasks(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_tasks(3, [(1, 5), (2, 6), (3, 7)]) 1","solution":"def max_non_overlapping_tasks(n, tasks): Returns the maximum number of non-overlapping tasks that can be completed. Args: - n: int, number of tasks - tasks: list of tuple, each containing the start and end time of a task Returns: - int, maximum number of non-overlapping tasks # Sort tasks based on their end times tasks.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping tasks count = 0 # Initialize variable to keep track of the end time of the last added task last_end_time = 0 for start, end in tasks: if start >= last_end_time: # If the task starts after or when the last task ended, we can take this task count += 1 last_end_time = end return count"},{"question":"def total_points(n: int, m: int, level_points: List[int], bonus_points: List[int]) -> int: Returns the total points a player can achieve after completing all the levels and gaining all the achievements. :param n: int, number of levels :param m: int, number of achievements :param level_points: list of int, points for each level :param bonus_points: list of int, points for each achievement :return: int, total points >>> total_points(5, 3, [100, 150, 200, 250, 300], [50, 75, 25]) 1150 >>> total_points(3, 2, [300, 200, 100], [100, 150]) 850","solution":"def total_points(n, m, level_points, bonus_points): Returns the total points a player can achieve after completing all the levels and gaining all the achievements. :param n: int, number of levels :param m: int, number of achievements :param level_points: list of int, points for each level :param bonus_points: list of int, points for each achievement :return: int, total points total_level_points = sum(level_points) total_bonus_points = sum(bonus_points) return total_level_points + total_bonus_points"},{"question":"def calculate_total_water(n: int, flowers: List[Dict[str, int]], d: int, weather_report: List[str]) -> int: Calculate the total amount of water needed for all flowers over the specified days' weather forecast. >>> calculate_total_water(3, [{\\"name\\": \\"rose\\", \\"clear\\": 2, \\"rainy\\": 1}, {\\"name\\": \\"tulip\\", \\"clear\\": 3, \\"rainy\\": 2}, {\\"name\\": \\"daisy\\", \\"clear\\": 1, \\"rainy\\": 1}], 3, [\\"clear\\", \\"rain\\", \\"clear\\"]) == 16 >>> calculate_total_water(1, [{\\"name\\": \\"rose\\", \\"clear\\": 2, \\"rainy\\": 1}], 1, [\\"clear\\"]) == 2 pass def test_single_flower_single_day_clear(): flowers = [{\\"name\\": \\"rose\\", \\"clear\\": 2, \\"rainy\\": 1}] weather_report = [\\"clear\\"] assert calculate_total_water(1, flowers, 1, weather_report) == 2 def test_single_flower_multiple_days(): flowers = [{\\"name\\": \\"rose\\", \\"clear\\": 2, \\"rainy\\": 1}] weather_report = [\\"clear\\", \\"rain\\"] assert calculate_total_water(1, flowers, 2, weather_report) == 3 def test_multiple_flowers_single_day_clear(): flowers = [ {\\"name\\": \\"rose\\", \\"clear\\": 2, \\"rainy\\": 1}, {\\"name\\": \\"tulip\\", \\"clear\\": 3, \\"rainy\\": 2}, {\\"name\\": \\"daisy\\", \\"clear\\": 1, \\"rainy\\": 1} ] weather_report = [\\"clear\\"] assert calculate_total_water(3, flowers, 1, weather_report) == 6 def test_multiple_flowers_multiple_days(): flowers = [ {\\"name\\": \\"rose\\", \\"clear\\": 2, \\"rainy\\": 1}, {\\"name\\": \\"tulip\\", \\"clear\\": 3, \\"rainy\\": 2}, {\\"name\\": \\"daisy\\", \\"clear\\": 1, \\"rainy\\": 1} ] weather_report = [\\"clear\\", \\"rain\\", \\"clear\\"] assert calculate_total_water(3, flowers, 3, weather_report) == 16 def test_no_flowers(): flowers = [] weather_report = [\\"clear\\", \\"rain\\", \\"clear\\"] assert calculate_total_water(0, flowers, 3, weather_report) == 0 def test_empty_weather_report(): flowers = [{\\"name\\": \\"rose\\", \\"clear\\": 2, \\"rainy\\": 1}] weather_report = [] assert calculate_total_water(1, flowers, 0, weather_report) == 0","solution":"def calculate_total_water(n, flowers, d, weather_report): total_water = 0 for day in range(d): if weather_report[day] == \\"clear\\": total_water += sum(flower[\\"clear\\"] for flower in flowers) elif weather_report[day] == \\"rain\\": total_water += sum(flower[\\"rainy\\"] for flower in flowers) return total_water"},{"question":"from datetime import datetime def calculate_borrowed_days(records): Calculates the total number of borrowing days for each book. :param records: List of records where each record is a string in the format: \\"book_id borrowing_date return_date\\" :return: A dictionary where the keys are book_ids and values are the total borrowed days. borrow_days = {} for record in records: parts = record.split() book_id = int(parts[0]) borrowing_date = datetime.strptime(parts[1], \\"%Y-%m-%d\\") return_date = datetime.strptime(parts[2], \\"%Y-%m-%d\\") days_borrowed = (return_date - borrowing_date).days if book_id in borrow_days: borrow_days[book_id] += days_borrowed else: borrow_days[book_id] = days_borrowed return borrow_days # Test cases def test_single_record(): records = [\\"1 2023-01-01 2023-01-10\\"] result = calculate_borrowed_days(records) assert result == {1: 9} def test_multiple_records(): records = [\\"1 2023-01-01 2023-01-10\\", \\"2 2023-01-05 2023-01-15\\", \\"1 2023-01-20 2023-01-25\\"] result = calculate_borrowed_days(records) assert result == {1: 14, 2: 10} def test_overlapping_dates(): records = [\\"3 2023-02-01 2023-02-10\\", \\"3 2023-02-05 2023-02-15\\"] result = calculate_borrowed_days(records) assert result == {3: 19} def test_non_overlapping_multiple_books(): records = [\\"1 2023-01-01 2023-01-10\\", \\"2 2023-01-05 2023-01-15\\", \\"3 2023-02-01 2023-02-10\\"] result = calculate_borrowed_days(records) assert result == {1: 9, 2: 10, 3: 9}","solution":"from datetime import datetime def calculate_borrowed_days(records): Calculates the total number of borrowing days for each book. :param records: List of records where each record is a string in the format: \\"book_id borrowing_date return_date\\" :return: A dictionary where the keys are book_ids and values are the total borrowed days. borrow_days = {} for record in records: parts = record.split() book_id = int(parts[0]) borrowing_date = datetime.strptime(parts[1], \\"%Y-%m-%d\\") return_date = datetime.strptime(parts[2], \\"%Y-%m-%d\\") days_borrowed = (return_date - borrowing_date).days if book_id in borrow_days: borrow_days[book_id] += days_borrowed else: borrow_days[book_id] = days_borrowed return borrow_days"},{"question":"from typing import List def min_non_subsequence_sum(arr: List[int]) -> int: Given an array of integers, returns the smallest positive integer that is not a subsequence sum of the given array. >>> min_non_subsequence_sum([1, 2, 3]) == 7 >>> min_non_subsequence_sum([2, 3, 4]) == 1 >>> min_non_subsequence_sum([1, 1, 1, 1]) == 5 pass def parse_input(input_str: str) -> List[int]: Parses the input string into a list of integers. >>> parse_input(\\"1 2 3\\") == [1, 2, 3] >>> parse_input(\\"4 5 6\\") == [4, 5, 6] pass","solution":"def min_non_subsequence_sum(arr): Returns the smallest positive integer that is not a subsequence sum of the given array. arr.sort() smallest_missing_sum = 1 for num in arr: if num > smallest_missing_sum: break smallest_missing_sum += num return smallest_missing_sum def parse_input(input_str): Parses the input string into a list of integers. return list(map(int, input_str.strip().split()))"},{"question":"def max_health_points(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum health points Fatima can gain from any contiguous subsequence of magical items. >>> max_health_points(2, [(5, [-1, 2, 3, -5, 4]), (4, [-2, -3, 4, -1])]) [5, 4] >>> max_health_points(1, [(3, [-1, -2, -3])]) [-1]","solution":"def max_health_points(t, test_cases): def max_subarray_sum(arr): max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(max_subarray_sum(arr)) return results"},{"question":"def get_unique_book_codes(N, book_codes): Given a list of book codes, return up to N unique book codes in the order they first appear. Args: N (int): The maximum number of unique book codes to return. book_codes (List[str]): The list of book codes. Returns: List[str]: A list containing up to N unique book codes in the order they first appeared. Example: >>> get_unique_book_codes(3, [\\"A123\\", \\"B456\\", \\"A123\\", \\"C789\\", \\"B456\\"]) [\\"A123\\", \\"B456\\", \\"C789\\"] >>> get_unique_book_codes(2, [\\"X001\\", \\"X002\\", \\"X003\\", \\"X004\\", \\"X002\\", \\"X003\\"]) [\\"X001\\", \\"X002\\"] def process_test_cases(T, test_cases): Process multiple test cases to find unique book codes for each case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list containing the test cases where each test case is a tuple containing the integer N and the list of book codes. Returns: List[str]: A list containing the result of each test case, where each result is a string of book codes separated by spaces. Example: >>> process_test_cases(3, [ (3, [\\"A123\\", \\"B456\\", \\"A123\\", \\"C789\\", \\"B456\\"]), (2, [\\"X001\\", \\"X002\\", \\"X003\\", \\"X004\\", \\"X002\\", \\"X003\\"]), (5, [\\"M111\\", \\"M112\\", \\"M113\\", \\"M114\\", \\"M115\\", \\"M116\\"]), ]) [\\"A123 B456 C789\\", \\"X001 X002\\", \\"M111 M112 M113 M114 M115\\"]","solution":"def get_unique_book_codes(N, book_codes): Given a list of book codes, return up to N unique book codes in the order they first appear. seen = set() unique_books = [] for code in book_codes: if code not in seen: seen.add(code) unique_books.append(code) if len(unique_books) == N: break return unique_books def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] book_codes = test_cases[i][1] result = get_unique_book_codes(N, book_codes) results.append(' '.join(result)) return results"},{"question":"from typing import List def maxSumWithOneRemoval(arr: List[int]) -> int: Given a list of integers, find the maximum sum of a contiguous subarray where you can optionally remove one element. Args: arr (List[int]): A list of integers. Returns: int: The maximum sum of a contiguous subarray with at most one removal. Example: >>> maxSumWithOneRemoval([1, -2, 0, 3]) 4 >>> maxSumWithOneRemoval([1, -2, -2, 3, -1]) 3 >>> maxSumWithOneRemoval([-1, -1, -1, -1]) -1 def test_maxSumWithOneRemoval(): assert maxSumWithOneRemoval([1, -2, 0, 3]) == 4, \\"Test Case 1 Failed\\" assert maxSumWithOneRemoval([1, -2, -2, 3, -1]) == 3, \\"Test Case 2 Failed\\" assert maxSumWithOneRemoval([-1, -1, -1, -1]) == -1, \\"Test Case 3 Failed\\" assert maxSumWithOneRemoval([1, 2, 3, 4, 5]) == 15, \\"Test Case 4 Failed\\" assert maxSumWithOneRemoval([10, -1, -1, 10]) == 19, \\"Test Case 5 Failed\\" assert maxSumWithOneRemoval([1]) == 1, \\"Test Case 6 Failed\\" assert maxSumWithOneRemoval([-10, -5, -3, -1]) == -1, \\"Test Case 7 Failed\\" assert maxSumWithOneRemoval([1, -1, 1, -1, 1]) == 2, \\"Test Case 8 Failed\\" test_maxSumWithOneRemoval()","solution":"def maxSumWithOneRemoval(arr): n = len(arr) if n == 1: return arr[0] # Initialize dp arrays max_end_here = [0] * n max_start_here = [0] * n # Fill max_end_here: max subarray sum ending at i max_end_here[0] = arr[0] for i in range(1, n): max_end_here[i] = max(arr[i], max_end_here[i-1] + arr[i]) # Fill max_start_here: max subarray sum starting at i max_start_here[n-1] = arr[n-1] for i in range(n-2, -1, -1): max_start_here[i] = max(arr[i], max_start_here[i+1] + arr[i]) # Consider the maximum sum subarray without removal max_sum = max(max_end_here) # Consider the maximum sum subarray with one removal for i in range(1, n-1): max_sum = max(max_sum, max_end_here[i-1] + max_start_here[i+1]) return max_sum"},{"question":"def maxCoins(nums: List[int]) -> int: Solve the balloon bursting problem to achieve the maximum score. >>> maxCoins([3, 1, 5, 8]) 167 >>> maxCoins([5]) 5 >>> maxCoins([2, 3]) 9 >>> maxCoins([1, 1, 1, 1]) 4 >>> maxCoins([1, 2, 3, 4, 5]) 110 >>> maxCoins([5, 4, 3, 2, 1]) 110","solution":"def maxCoins(nums): Solve the balloon bursting problem to achieve the maximum score. n = len(nums) # Add 1 before and after nums to avoid boundary checking nums = [1] + nums + [1] # dp will store the results of subproblems dp = [[0] * (n + 2) for _ in range(n + 2)] # Length ranges from 1 to n for length in range(1, n + 1): for left in range(1, n - length + 2): right = left + length - 1 for i in range(left, right + 1): dp[left][right] = max( dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right] ) return dp[1][n]"},{"question":"def is_valid_bracket_sequence(s: str) -> str: Determine if the given string is a valid bracket sequence. >>> is_valid_bracket_sequence(\\"(){}[]\\") 'YES' >>> is_valid_bracket_sequence(\\"(<{}>)\\") 'YES' >>> is_valid_bracket_sequence(\\"([)]\\") 'NO' >>> is_valid_bracket_sequence(\\"[{(<)>}]\\") 'NO' def validate_bracket_sequences(test_cases: List[str]) -> List[str]: Given a list of bracket sequences, determine if each sequence is valid. >>> validate_bracket_sequences([\\"(){}[]\\"]) [\\"YES\\"] >>> validate_bracket_sequences([\\"(<{}>)\\"]) [\\"YES\\"] >>> validate_bracket_sequences([\\"([)]\\"]) [\\"NO\\"] >>> validate_bracket_sequences([\\"(){}[]\\", \\"(<{}>)\\", \\"([)]\\", \\"[{(<)>}]\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_valid_bracket_sequence(s): stack = [] bracket_map = {')': '(', '}': '{', ']': '[', '>': '<'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\" def validate_bracket_sequences(test_cases): results = [] for s in test_cases: results.append(is_valid_bracket_sequence(s)) return results"},{"question":"def max_coins(n, coins): Returns the maximum number of coins that can be collected without encountering a trap. :param n: number of caves :param coins: list of integers representing the coins in each cave, where a negative value indicates a trap :return: maximum number of coins that can be collected without encountering a trap >>> max_coins(6, [3, 5, -1, 4, 6, 2]) 8 >>> max_coins(5, [4, -5, 3, 2, -2]) 4 >>> max_coins(7, [1, 2, 3, -1, 5, -2, 8]) 6","solution":"def max_coins(n, coins): Returns the maximum number of coins that can be collected without encountering a trap. :param n: number of caves :param coins: list of integers representing the coins in each cave, where a negative value indicates a trap :return: maximum number of coins that can be collected without encountering a trap max_coins_collected = 0 current_coins = 0 for coin in coins: if coin < 0: break current_coins += coin max_coins_collected = max(max_coins_collected, current_coins) return max_coins_collected"},{"question":"def expected_correct_characters(l: int, probabilities: List[float]) -> float: Calculate the expected number of correct characters typed by Polycarp. :param l: int - length of the text :param probabilities: List[float] - list of typing accuracy probabilities for each character :return: float - expected number of correct characters >>> abs(expected_correct_characters(4, [0.9, 0.8, 0.7, 0.6]) - 4.0) < 1e-6 True >>> abs(expected_correct_characters(3, [0.5, 0.5, 0.5]) - 3.0) < 1e-6 True >>> abs(expected_correct_characters(5, [0.0, 0.0, 0.0, 0.0, 0.0]) - 5.0) < 1e-6 True >>> abs(expected_correct_characters(5, [1.0, 1.0, 1.0, 1.0, 1.0]) - 5.0) < 1e-6 True >>> abs(expected_correct_characters(6, [0.1, 0.5, 0.9, 0.4, 0.7, 0.2]) - 6.0) < 1e-6 True","solution":"def expected_correct_characters(l, probabilities): Calculate the expected number of correct characters typed by Polycarp. :param l: int - length of the text :param probabilities: List[float] - list of typing accuracy probabilities for each character :return: float - expected number of correct characters # Using the linearity of expectation, since for each character the probability of typing it # correctly until success is 1, the expected number of correctly typed characters should be l. return float(l)"},{"question":"def findSmallestMissingNumber(nums: List[int]) -> int: Finds the smallest positive integer that is missing from the given list of distinct integers. Example: >>> findSmallestMissingNumber([3, 4, -1, 1]) 2 >>> findSmallestMissingNumber([1, 2, 0]) 3 >>> findSmallestMissingNumber([-5, -3, -2, 1]) 2 >>> findSmallestMissingNumber([7, 8, 9, 11, 12]) 1 >>> findSmallestMissingNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 11 >>> findSmallestMissingNumber([1000]) 1 >>> findSmallestMissingNumber([-1, -2, -3]) 1 >>> findSmallestMissingNumber([2]) 1 >>> findSmallestMissingNumber([1]) 2","solution":"def findSmallestMissingNumber(nums): Finds the smallest positive integer that is missing from the given list of distinct integers. :param nums: List of distinct integers :return: The smallest missing positive integer # Convert the list to a set for O(1) look-up time num_set = set(nums) # Start checking for the smallest missing number from 1 smallest_missing = 1 # Keep checking for the next smallest missing number while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def count_pairs_with_difference(a: List[int], k: int) -> int: Function to count pairs in the array \`a\` such that their absolute difference is \`k\`. Parameters: a (list): List of integers. k (int): The absolute difference. Returns: int: The number of pairs with the given difference. pass from typing import List def test_count_pairs_with_difference(): assert count_pairs_with_difference([1, 5, 3, 4, 2], 2) == 3 assert count_pairs_with_difference([1, 1, 1, 1], 0) == 6 assert count_pairs_with_difference([1, 2, 3, 4], 1) == 3 assert count_pairs_with_difference([1, 3, 3, 3, 7, 8], 4) == 3 assert count_pairs_with_difference([10, 20, 30, 40, 50], 15) == 0 # additional test cases assert count_pairs_with_difference([], 1) == 0 assert count_pairs_with_difference([1], 1) == 0 assert count_pairs_with_difference([3, 3, 3], 0) == 3 # Edge case where k is larger than possible differences assert count_pairs_with_difference([1, 2, 3], 10) == 0","solution":"def count_pairs_with_difference(a, k): Function to count pairs in the array \`a\` such that their absolute difference is \`k\`. Parameters: a (list): List of integers. k (int): The absolute difference. Returns: int: The number of pairs with the given difference. count = 0 a = sorted(a) n = len(a) for i in range(n): for j in range(i + 1, n): if abs(a[j] - a[i]) == k: count += 1 return count"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid from the top-left to the bottom-right corner. Args: m: int - the number of rows in the grid n: int - the number of columns in the grid Returns: int - the number of unique paths from (1,1) to (m,n) Examples: >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(4, 2) 4 pass","solution":"def unique_paths(m, n): Calculate the number of unique paths in an m x n grid from the top-left to the bottom-right corner. # Initialize a 2D list (matrix) with 1s dp = [[1] * n for _ in range(m)] # Iterate through the matrix starting from (1,1) since the first row and first column are always 1 for i in range(1, m): for j in range(1, n): # The number of paths to reach a cell is the sum of paths to reach # the cell directly above it and the cell directly to the left of it dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the total number of unique paths return dp[m-1][n-1]"},{"question":"def count_palindromic_substrings(s): Returns the number of contiguous palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"madam\\") 7 def process_test_cases(T, test_cases): For each test case, compute and return the number of palindromic substrings. >>> process_test_cases(3, [\\"abc\\", \\"aaa\\", \\"madam\\"]) [3, 6, 7] >>> process_test_cases(2, [\\"abcd\\", \\"racecar\\"]) [4, 10] >>> process_test_cases(2, [\\"a\\", \\"aa\\"]) [1, 3]","solution":"def count_palindromic_substrings(s): Returns the number of contiguous palindromic substrings in the given string s. n = len(s) count = 0 # Create a dp array to store results of subproblems dp = [[False] * n for _ in range(n)] # Substrings of length 1 are palindromes for i in range(n): dp[i][i] = True count += 1 # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for substrings greater than length 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count def process_test_cases(T, test_cases): For each test case, compute and return the number of palindromic substrings. results = [] for s in test_cases: results.append(count_palindromic_substrings(s)) return results"},{"question":"from typing import List, Tuple def min_moves_to_target(grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> int: Returns the minimal number of moves required for the robot to reach the target. Parameters: - grid: List[List[str]] : 2D list representing the grid - start: Tuple[int, int] : Starting position as (sx, sy) - target: Tuple[int, int] : Target position as (tx, ty) Returns: - int : Minimal number of moves or -1 if target is not reachable >>> grid = [\\"....\\", \\".#..#.\\", \\".#..#.\\", \\"..#.\\", \\"......\\"] >>> min_moves_to_target(grid, (0, 0), (4, 5)) 9 >>> grid = [\\"....\\", \\".#.#.#\\", \\".#.#.#\\", \\".#.#.#\\", \\"....\\"] >>> min_moves_to_target(grid, (0, 0), (4, 5)) -1 >>> grid = [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"] >>> min_moves_to_target(grid, (0, 0), (4, 4)) 8 >>> grid = [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"] >>> min_moves_to_target(grid, (2, 2), (2, 2)) 0 >>> grid = [\\"..\\", \\"..\\"] >>> min_moves_to_target(grid, (0, 0), (1, 1)) 2","solution":"from collections import deque def min_moves_to_target(grid, start, target): Returns the minimal number of moves required for the robot to reach the target. Parameters: - grid: List[List[str]] : 2D list representing the grid - start: Tuple[int, int] : Starting position as (sx, sy) - target: Tuple[int, int] : Target position as (tx, ty) Returns: - int : Minimal number of moves or -1 if target is not reachable N = len(grid) M = len(grid[0]) sx, sy = start tx, ty = target if start == target: return 0 # Directions vectors for up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(sx, sy, 0)]) # (current_x, current_y, current_distance) visited = set() visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: if (nx, ny) == target: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def diagonals_identical(n: int, matrix: List[List[int]]) -> str: Determine if all diagonals in the matrix contain identical elements. >>> diagonals_identical(4, [[1, 2, 3, 4], [5, 1, 2, 3], [9, 5, 1, 2], [6, 9, 5, 1]]) 'YES' >>> diagonals_identical(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'NO'","solution":"def diagonals_identical(n, matrix): def check_diagonal(start_row, start_col): value = matrix[start_row][start_col] row, col = start_row, start_col while row < n and col < n: if matrix[row][col] != value: return False row += 1 col += 1 return True # Check diagonals starting from the first column for start_row in range(n): if not check_diagonal(start_row, 0): return \\"NO\\" # Check diagonals starting from the first row, except the first element (already checked) for start_col in range(1, n): if not check_diagonal(0, start_col): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def is_valid_arrangement(arrangement: List[int], preferences: List[Tuple[int, int, str]], A: int) -> bool: Check if a given seating arrangement is valid based on preferences and acquaintance threshold. Args: arrangement (List[int]): The seating arrangement given as a list of guest numbers. preferences (List[Tuple[int, int, str]]): The list of preferences where each preference is a tuple (G1, G2, Sign). A (int): The acquaintance threshold. Returns: bool: True if the arrangement satisfies at least A preferences, False otherwise. pass # Your code here def can_seat_guests(num_guests: int, preferences: List[Tuple[int, int, str]], acquaintance_threshold: int) -> bool: Determine if it's possible to arrange the guests such that at least A preferences are satisfied. Args: num_guests (int): The number of guests. preferences (List[Tuple[int, int, str]]): The list of preferences where each preference is a tuple (G1, G2, Sign). acquaintance_threshold (int): The acquaintance threshold. Returns: bool: True if such an arrangement is possible, False otherwise. pass # Your code here def process_input(input_data: List[Tuple[Tuple[int, int, int], List[Tuple[int, int, str]]]]) -> List[str]: Process multiple datasets to determine if an arrangement is possible for each dataset. Args: input_data (List[Tuple[Tuple[int, int, int], List[Tuple[int, int, str]]]]): The input datasets. Returns: List[str]: List of results for each dataset (\\"YES\\" or \\"NO\\"). pass # Your code here","solution":"from itertools import permutations def is_valid_arrangement(arrangement, preferences, A): n = len(arrangement) satisfaction_count = 0 for g1, g2, sign in preferences: g1_index = arrangement.index(g1) g2_index = arrangement.index(g2) g1_next = arrangement[(g1_index + 1) % n] g1_prev = arrangement[(g1_index - 1) % n] if sign == '+': if g1_next == g2 or g1_prev == g2: satisfaction_count += 1 elif sign == '-': if g1_next != g2 and g1_prev != g2: satisfaction_count += 1 return satisfaction_count >= A def can_seat_guests(num_guests, preferences, acquaintance_threshold): guests = list(range(1, num_guests + 1)) for perm in permutations(guests): if is_valid_arrangement(perm, preferences, acquaintance_threshold): return True return False def process_input(input_data): results = [] for dataset in input_data: N, P, A = dataset[0] if N == 0: break preferences = dataset[1:] if can_seat_guests(N, preferences, A): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_treasures(W: int) -> (int, List[int]): This function calculates the maximum number of different treasures that Alice can collect without exceeding the weight limit W, and returns the list of treasure indices. >>> max_treasures(10) (4, [1, 2, 3, 4]) >>> max_treasures(20) (5, [1, 2, 3, 4, 5])","solution":"def max_treasures(W): This function calculates the maximum number of different treasures that Alice can collect without exceeding the weight limit W, and returns the list of treasure indices. treasures = [] total_weight = 0 for i in range(1, 1001): if total_weight + i > W: break treasures.append(i) total_weight += i return len(treasures), treasures"},{"question":"def check_fingerprint_scans(n, k, scans): Determines if there are duplicates within the specified range in the sequence of fingerprint scans. :param n: Length of the sequence of fingerprint scans :param k: The range within which to check for duplicates :param scans: The list of fingerprint scans :return: \\"UNSAFE\\" if duplicates are found within the range k, otherwise \\"SAFE\\" Example usage: >>> check_fingerprint_scans(6, 2, [5, 7, 9, 3, 10, 7]) 'SAFE' >>> check_fingerprint_scans(6, 3, [5, 7, 9, 5, 10, 7]) 'UNSAFE'","solution":"def check_fingerprint_scans(n, k, scans): Determines if there are duplicates within the specified range in the sequence of fingerprint scans. :param n: Length of the sequence of fingerprint scans :param k: The range within which to check for duplicates :param scans: The list of fingerprint scans :return: \\"UNSAFE\\" if duplicates are found within the range k, otherwise \\"SAFE\\" scan_set = set() for i in range(n): if scans[i] in scan_set: return \\"UNSAFE\\" scan_set.add(scans[i]) if i >= k: scan_set.remove(scans[i - k]) return \\"SAFE\\" # Example usage: # n, k = 6, 3 # scans = [5, 7, 9, 5, 10, 7] # print(check_fingerprint_scans(n, k, scans)) # Output: UNSAFE"},{"question":"def min_blocked_path(n: int, edges: List[Tuple[int, int, float]], A: int, B: int) -> float: Determine the path from city A to city B that minimizes the probability of being blocked. >>> n = 5 >>> edges = [(0, 1, 0.1), (0, 2, 0.5), (1, 3, 0.3), (2, 3, 0.6), (3, 4, 0.2)] >>> A, B = 0, 4 >>> min_blocked_path(n, edges, A, B) 0.06 >>> n = 3 >>> edges = [(0, 1, 0.1), (1, 2, 0.2), (0, 2, 0.5)] >>> A, B = 0, 2 >>> min_blocked_path(n, edges, A, B) 0.03 >>> n = 2 >>> edges = [(0, 1, 0.4)] >>> A, B = 0, 1 >>> min_blocked_path(n, edges, A, B) 0.4 >>> n = 4 >>> edges = [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)] >>> A, B = 0, 3 >>> min_blocked_path(n, edges, A, B) 3.0 >>> n = 4 >>> edges = [(0, 1, 0.2), (0, 2, 0.3), (1, 3, 0.3), (2, 3, 0.2), (1, 2, 0.1)] >>> A, B = 0, 3 >>> min_blocked_path(n, edges, A, B) 0.5","solution":"import heapq def min_blocked_path(n, edges, A, B): # Building the adjacency list for the graph graph = [[] for _ in range(n)] for i, j, p in edges: graph[i].append((j, p)) graph[j].append((i, p)) # Using a priority queue (min-heap) to find the minimum risk path pq = [(0, A)] # (cumulative probability, starting vertex) prob = [float('inf')] * n prob[A] = 0 while pq: current_prob, u = heapq.heappop(pq) if u == B: return current_prob if current_prob > prob[u]: continue for v, p in graph[u]: new_prob = current_prob + p if new_prob < prob[v]: prob[v] = new_prob heapq.heappush(pq, (new_prob, v)) return prob[B]"},{"question":"def run_length_encoding(s: str) -> str: Compresses the input string using Run-Length Encoding (RLE) technique. Args: s (str): The input string consisting of lowercase Latin letters. Returns: str: The Run-Length Encoded version of the input string. >>> run_length_encoding(\\"aaabbcccc\\") 'a3b2c4' >>> run_length_encoding(\\"abcd\\") 'a1b1c1d1' >>> run_length_encoding(\\"aabcccccaaa\\") 'a2b1c5a3' >>> run_length_encoding(\\"zzzzzzz\\") 'z7'","solution":"def run_length_encoding(s: str) -> str: Compresses the input string using Run-Length Encoding (RLE) technique. Args: s (str): The input string consisting of lowercase Latin letters. Returns: str: The Run-Length Encoded version of the input string. if not s: return \\"\\" encoded_string = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoded_string.append(s[i]) encoded_string.append(str(count)) i += 1 return ''.join(encoded_string)"},{"question":"def secret_sharing(N: int, K: int): Function to compute the minimal number of shares and the subset of shares for each member to ensure that exactly K members can reconstruct the secret. >>> num_shares, shares = secret_sharing(4, 3) >>> num_shares 3 >>> shares [ [1, 2, 3], [2, 3, 1], [3, 1, 2], [1, 2, 3] ] >>> num_shares, shares = secret_sharing(5, 3) >>> num_shares 3 >>> shares [ [1, 2, 3], [2, 3, 1], [3, 1, 2], [1, 2, 3], [2, 3, 1] ] >>> num_shares, shares = secret_sharing(6, 4) >>> num_shares 4 >>> shares [ [1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 1] ] pass def format_output(num_shares: int, shares: List[List[int]]) -> str: Function to format the output of the shares for each member in the required format. >>> format_output(3, [ [1, 2, 3], [2, 3, 1], [3, 1, 2], [1, 2, 3] ]) '3n1 2 3n2 3 1n3 1 2n1 2 3' >>> format_output(4, [ [1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 1] ]) '4n1 2 3 4n2 3 4 1n3 4 1 2n4 1 2 3n1 2 3 4n2 3 4 1' pass","solution":"def secret_sharing(N, K): Function to compute the minimal number of shares and the subset of shares for each member to ensure that exactly K members can reconstruct the secret. # Minimum number of shares required num_shares = K # Initialize the shares distribution for each member shares = [] for i in range(N): member_shares = [(i + j) % num_shares + 1 for j in range(K)] shares.append(member_shares) return num_shares, shares def format_output(num_shares, shares): output = [str(num_shares)] for share in shares: output.append(\\" \\".join(map(str, share))) return \\"n\\".join(output)"},{"question":"def max_distance(N: int, markers: List[int]) -> int: Returns the maximum distance between any two islands such that the marker of one island is less than the marker of another island. :param N: int, number of islands :param markers: List[int], the geographical markers of the islands :return: int, the maximum distance Examples: >>> max_distance(5, [1, 2, 3, 4, 5]) 4 >>> max_distance(5, [5, 4, 3, 2, 1]) 0 >>> max_distance(6, [1, 5, 2, 3, 6, 4]) 5 import pytest def test_cases(): # Test case 1 input_N = 5 input_markers = [1, 2, 3, 4, 5] expected_output = 4 assert max_distance(input_N, input_markers) == expected_output # Test case 2 input_N = 5 input_markers = [5, 4, 3, 2, 1] expected_output = 0 assert max_distance(input_N, input_markers) == expected_output # Test case 3 input_N = 6 input_markers = [1, 5, 2, 3, 6, 4] expected_output = 5 assert max_distance(input_N, input_markers) == expected_output # Test edge case: Minimum input size input_N = 2 input_markers = [1, 2] expected_output = 1 assert max_distance(input_N, input_markers) == expected_output # Test edge case: No valid pair input_N = 2 input_markers = [2, 1] expected_output = 0 assert max_distance(input_N, input_markers) == expected_output # Test case with repeated values input_N = 4 input_markers = [1, 1, 1, 2] expected_output = 3 assert max_distance(input_N, input_markers) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def max_distance(N, markers): Returns the maximum distance between any two islands such that the marker of one island is less than the marker of another island. :param N: int, number of islands :param markers: List[int], the geographical markers of the islands :return: int, the maximum distance min_marker = markers[0] max_dist = 0 for i in range(1, N): if markers[i] > min_marker: max_dist = max(max_dist, i) else: min_marker = markers[i] return max_dist"},{"question":"from typing import List def minMaxDifference(heights: List[int]) -> List[int]: Takes a list of integers representing heights of people and returns a reordered list that minimizes the maximum difference between adjacent elements. >>> minMaxDifference([3, 1, 4, 9, 2, 6]) == [1, 2, 3, 4, 6, 9] >>> minMaxDifference([10, 5, 2, 8, 7]) == [2, 5, 7, 8, 10]","solution":"def minMaxDifference(heights): Takes a list of integers representing heights of people and returns a reordered list that minimizes the maximum difference between adjacent elements. heights.sort() return heights"},{"question":"def rotate_wheel(n, wheel, operations): Rotate the encoder wheel based on the operations specified. Parameters: n (int): number of positions on the wheel. wheel (list of int): initial configuration of the wheel. operations (list of int): list of rotation operations. Returns: list of int: final configuration of the wheel after applying all rotations. # Write your code here def process_test_cases(test_cases): Process multiple test cases. Parameters: test_cases (list of tuples): Each tuple contains (n, wheel, operations). Returns: list of list of int: List containing final configurations for each test case. # Write your code here def test_rotate_wheel(): assert rotate_wheel(5, [1, 2, 3, 4, 5], [1, -2, 3]) == [4, 5, 1, 2, 3] assert rotate_wheel(4, [7, 8, 9, 10], [-4, 2]) == [9, 10, 7, 8] assert rotate_wheel(3, [1, 2, 3], [3]) == [1, 2, 3] assert rotate_wheel(3, [1, 2, 3], [-1]) == [2, 3, 1] assert rotate_wheel(6, [1, 2, 3, 4, 5, 6], [-7]) == [2, 3, 4, 5, 6, 1] def test_process_test_cases(): test_cases = [ (5, [1, 2, 3, 4, 5], [1, -2, 3]), (4, [7, 8, 9, 10], [-4, 2]) ] expected = [ [4, 5, 1, 2, 3], [9, 10, 7, 8] ] assert process_test_cases(test_cases) == expected # Single case where no rotation is effectively needed test_cases = [(4, [1, 2, 3, 4], [4, -4])] expected = [[1, 2, 3, 4]] assert process_test_cases(test_cases) == expected # Single case with a rotation larger than n test_cases = [(3, [1, 2, 3], [-100])] expected = [[2, 3, 1]] assert process_test_cases(test_cases) == expected","solution":"def rotate_wheel(n, wheel, operations): Rotate the encoder wheel based on the operations specified. Parameters: n (int): number of positions on the wheel. wheel (list of int): initial configuration of the wheel. operations (list of int): list of rotation operations. Returns: list of int: final configuration of the wheel after applying all rotations. net_rotation = sum(operations) % n if net_rotation < 0: net_rotation += n return wheel[-net_rotation:] + wheel[:-net_rotation] def process_test_cases(test_cases): Process multiple test cases. Parameters: test_cases (list of tuples): Each tuple contains (n, wheel, operations). Returns: list of list of int: List containing final configurations for each test case. results = [] for n, wheel, operations in test_cases: final_wheel = rotate_wheel(n, wheel, operations) results.append(final_wheel) return results"},{"question":"from typing import List def min_operations_to_single_char(s: str) -> int: Returns the minimum number of operations required to transform the entire string s into a single character. pass def solve(test_cases: List[str]) -> List[int]: Given a list of test strings, return a list of minimum operations required for each. pass def test_single_char(): assert solve([\\"a\\"]) == [0] assert solve([\\"x\\"]) == [0] def test_all_same_char(): assert solve([\\"bbbbbb\\"]) == [0] assert solve([\\"zzzzz\\"]) == [0] def test_two_different_chars(): assert solve([\\"aabb\\"]) == [2] assert solve([\\"abba\\"]) == [2] def test_mixed_chars(): assert solve([\\"abc\\"]) == [2] assert solve([\\"abcdef\\"]) == [5] def test_example_cases(): assert solve([\\"aabb\\", \\"abc\\", \\"eeeeee\\"]) == [2, 2, 0]","solution":"def min_operations_to_single_char(s): Returns the minimum number of operations required to transform the entire string s into a single character. from collections import Counter n = len(s) if n == 0: return 0 # Count frequency of each character freq = Counter(s) # Get the maximum frequency of any character max_freq = max(freq.values()) # The minimum number of operations needed will be the length of the string # minus the frequency of the most common character return n - max_freq def solve(test_cases): Given a list of test strings, return a list of minimum operations required for each. results = [] for s in test_cases: results.append(min_operations_to_single_char(s)) return results"},{"question":"def min_operations_to_make_sum_even(n, arr): Determines the minimum number of operations required to make the sum of the array even. An operation consists of incrementing any one element of the array by 1. Parameters: n (int): The length of the array. arr (list of int): The elements of the array. Returns: int: The minimum number of operations required to make the sum of the array even. Example: >>> min_operations_to_make_sum_even(3, [1, 3, 5]) 0 >>> min_operations_to_make_sum_even(4, [2, 4, 6, 7]) 1","solution":"def min_operations_to_make_sum_even(n, arr): Determines the minimum number of operations required to make the sum of the array even. An operation consists of incrementing any one element of the array by 1. Parameters: n (int): The length of the array. arr (list of int): The elements of the array. Returns: int: The minimum number of operations required to make the sum of the array even. current_sum = sum(arr) # If the sum is already even, no operations are needed if current_sum % 2 == 0: return 0 else: # If the sum is odd, we need to increment one odd element to make it even return 1"},{"question":"def uniquePaths(m: int, n: int, grid: List[List[int]]) -> int: Determines the total number of unique paths the vacuum cleaner can take to reach the bottom-right corner of the grid starting from the top-left corner. >>> uniquePaths(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePaths(3, 3, [[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> uniquePaths(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 >>> uniquePaths(4, 4, [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) 4 >>> uniquePaths(1, 1, [[0]]) 1 >>> uniquePaths(1, 4, [[0, 0, 0, 0]]) 1 >>> uniquePaths(4, 1, [[0], [0], [0], [0]]) 1 pass","solution":"def uniquePaths(m, n, grid): MOD = 1000000007 # If the start or end cell is blocked, return 0 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[m-1][n-1]"},{"question":"def min_cocktail_price(base_prices, mixer_prices) -> int: Calculates the minimum price of a custom cocktail. Parameters: base_prices (list of int): Prices of the three base alcohols. mixer_prices (list of int): Prices of the three mixers. Returns: int: The minimum price of the cocktail. >>> min_cocktail_price([1200, 1500, 1000], [200, 300, 250]) 1100 >>> min_cocktail_price([1000, 1000, 1000], [500, 400, 450]) 1300 >>> min_cocktail_price([1100, 1050, 1150], [300, 300, 300]) 1250 >>> min_cocktail_price([1200, 900, 1100], [200, 600, 350]) 1000 >>> min_cocktail_price([300, 500, 450], [150, 200, 100]) 300","solution":"def min_cocktail_price(base_prices, mixer_prices): Calculates the minimum price of a custom cocktail. Parameters: base_prices (list of int): Prices of the three base alcohols. mixer_prices (list of int): Prices of the three mixers. Returns: int: The minimum price of the cocktail. min_base_price = min(base_prices) min_mixer_price = min(mixer_prices) min_price = min_base_price + min_mixer_price - 100 return min_price # Example usage base_prices = [1200, 1500, 1000] mixer_prices = [200, 300, 250] print(min_cocktail_price(base_prices, mixer_prices)) # Output: 1100"},{"question":"from typing import List, Tuple def can_fulfill_orders(N: int, K: int, stock: List[int], orders: List[Tuple[int, int]]) -> str: Determines if all orders can be fulfilled with the current stock levels of the products. Parameters: N (int): Number of different products. K (int): Number of orders. stock (list of int): List of quantities of each product in stock. orders (list of tuple): List of orders, where each order is a tuple (Pj, Rj) with product index and quantity requested. Returns: str: \\"YES\\" if all orders can be fulfilled, otherwise \\"NO\\" followed by the index of the first order that cannot be fulfilled. >>> can_fulfill_orders(5, 3, [10, 5, 7, 8, 9], [(1, 5), (2, 2), (3, 8)]) 'NO 3' >>> can_fulfill_orders(5, 3, [10, 5, 8, 8, 9], [(1, 5), (2, 2), (3, 7)]) 'YES' >>> can_fulfill_orders(3, 2, [1, 2, 3], [(1, 2), (2, 2)]) 'NO 1' >>> can_fulfill_orders(4, 4, [10, 5, 7, 8], [(1, 5), (2, 6), (3, 5), (4, 10)]) 'NO 2'","solution":"def can_fulfill_orders(N, K, stock, orders): Determines if all orders can be fulfilled with the current stock levels of the products. Parameters: N (int): Number of different products. K (int): Number of orders. stock (list of int): List of quantities of each product in stock. orders (list of tuple): List of orders, where each order is a tuple (Pj, Rj) with product index and quantity requested. Returns: str: \\"YES\\" if all orders can be fulfilled, otherwise \\"NO\\" followed by the index of the first order that cannot be fulfilled. for i, (Pj, Rj) in enumerate(orders): if stock[Pj - 1] >= Rj: stock[Pj - 1] -= Rj else: return f\\"NO {i + 1}\\" return \\"YES\\""},{"question":"def has_pair_with_sum(arr, S): Returns \\"YES\\" if there are two distinct elements in arr that sum to S, otherwise \\"NO\\". >>> has_pair_with_sum([2, 7, 11, 15], 9) == \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"NO\\" def process_test_cases(test_cases): Processes a list of test cases, each containing a tuple of (array length, target sum) and the array itself. Returns a list of results for each test case. >>> process_test_cases([((4, 9), [2, 7, 11, 15]), ((5, 10), [1, 2, 3, 4, 5])]) == [\\"YES\\", \\"NO\\"] >>> process_test_cases([((4, 8), [1, 3, 5, 7]), ((6, 6), [1, 2, 3, 4, 5, 6]), ((5, 7), [1, 2, 3, 4, 5])]) == [\\"YES\\", \\"YES\\", \\"YES\\"] from solution import has_pair_with_sum, process_test_cases def test_has_pair_with_sum(): assert has_pair_with_sum([2, 7, 11, 15], 9) == \\"YES\\" assert has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"NO\\" assert has_pair_with_sum([1, 3, 5, 7], 8) == \\"YES\\" assert has_pair_with_sum([1, 2, 3, 4, 5], 6) == \\"YES\\" assert has_pair_with_sum([1, 2, 3, 4, 5], 7) == \\"YES\\" assert has_pair_with_sum([1, -2, 3, -4, 5], 1) == \\"YES\\" assert has_pair_with_sum([-1, -2, -3, -4, -5], -8) == \\"YES\\" assert has_pair_with_sum([1,1,1,1,1,1], 2) == \\"YES\\" assert has_pair_with_sum([1], 2) == \\"NO\\" assert has_pair_with_sum([], 2) == \\"NO\\" def test_process_test_cases(): test_cases = [ ((4, 9), [2, 7, 11, 15]), ((5, 10), [1, 2, 3, 4, 5]), ] assert process_test_cases(test_cases) == [\\"YES\\", \\"NO\\"] test_cases = [ ((4, 8), [1, 3, 5, 7]), ((6, 6), [1, 2, 3, 4, 5, 6]), ((5, 7), [1, 2, 3, 4, 5]), ] assert process_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def has_pair_with_sum(arr, S): Returns \\"YES\\" if there are two distinct elements in arr that sum to S, otherwise \\"NO\\". seen = set() for num in arr: if S - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def process_test_cases(test_cases): results = [] for case in test_cases: n, S = case[0] arr = case[1] results.append(has_pair_with_sum(arr, S)) return results"},{"question":"def g(array): Calculate the minimum number of operations (reversals) needed to sort array in non-descending order. >>> g([1, 2, 3]) == 0 >>> g([3, 2, 1]) == 1 >>> g([3, 1, 2]) == 2 >>> g([7, 1, 5]) == 2 >>> g([4, 3, 2, 1]) == 1 >>> g([10]) == 0 >>> g([2, 3, 1, 5, 4]) == 2 pass def sum_of_min_operations(m, arrays): Calculate the sum of g(a) for m arrays. >>> sum_of_min_operations(3, [[1, 2, 3], [3, 2, 1], [3, 1, 2]]) == 3 >>> sum_of_min_operations(2, [[7, 1, 5], [4, 3, 2, 1]]) == 3 >>> sum_of_min_operations(1, [[10, 9, 8, 7, 6]]) == 1 >>> sum_of_min_operations(4, [[1], [2], [3], [4]]) == 0 >>> sum_of_min_operations(2, [[1, 3, 2], [4, 6, 5]]) == 4 pass","solution":"def g(array): Calculate the minimum number of operations (reversals) needed to sort array in non-descending order. if array == sorted(array): return 0 n = len(array) # Check if reversing the whole array sorts it if array == sorted(array, reverse=True): return 1 # If neither fully sorted nor reverse sorted, count as 2 return 2 def sum_of_min_operations(m, arrays): Calculate the sum of g(a) for m arrays. total_operations = 0 for array in arrays: total_operations += g(array) return total_operations"},{"question":"def transform_numbers(numbers): Transforms the list of numbers such that even numbers are replaced by their squares, and odd numbers are replaced by their cubes. pass def process_input(input_string): Processes the input string, transforming the numbers, and returns them as a space-separated string. pass # Unit tests def test_transform_numbers(): assert transform_numbers([1, 2, 3, 4, 5]) == [1, 4, 27, 16, 125] assert transform_numbers([-1, -2, -3, -4, -5]) == [-1, 4, -27, 16, -125] assert transform_numbers([0, 1]) == [0, 1] assert transform_numbers([2, 3, 6]) == [4, 27, 36] assert transform_numbers([11, -24]) == [1331, 576] assert transform_numbers([7, 8, -10, 13]) == [343, 64, 100, 2197] def test_process_input(): assert process_input(\\"1 2 3 4 5\\") == \\"1 4 27 16 125\\" assert process_input(\\"-1 -2 -3 -4 -5\\") == \\"-1 4 -27 16 -125\\" assert process_input(\\"0 1\\") == \\"0 1\\" assert process_input(\\"2 3 6\\") == \\"4 27 36\\" assert process_input(\\"11 -24\\") == \\"1331 576\\" assert process_input(\\"7 8 -10 13\\") == \\"343 64 100 2197\\"","solution":"def transform_numbers(numbers): Transforms the list of numbers such that even numbers are replaced by their squares, and odd numbers are replaced by their cubes. transformed = [] for num in numbers: if num % 2 == 0: transformed.append(num ** 2) else: transformed.append(num ** 3) return transformed def process_input(input_string): Processes the input string, transforming the numbers, and returns them as a space-separated string. numbers = list(map(int, input_string.split())) transformed_numbers = transform_numbers(numbers) return ' '.join(map(str, transformed_numbers))"},{"question":"def max_ways_to_distribute_treats(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are organizing a relay race for children with special needs. The race has n stations lined up in a straight line. Each station has a positive integer value which denotes the number of treats available at that station. Each child can collect treats from a station and distribute them to their friends. However, to make sure that every child gets a chance to collect treats, you need to define the order in which the children will visit the stations. Since the children are of different age groups, they may prefer visiting stations in different sequences. You want to find an order of visit to stations such that the total number of ways to distribute the treats is maximized. At each station, a child can either take all treats or leave them. Input: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case consists of a tuple where the first element is the number of stations n and the second element is a list of integers representing the number of treats at each station. Output: List[int]: For each test case, output the total number of ways the treats can be distributed such that the sum of treats collected is maximized. >>> max_ways_to_distribute_treats(1, [(3, [1, 2, 3])]) [8] >>> max_ways_to_distribute_treats(3, [(3, [1, 2, 3]), (4, [4, 1, 2, 3]), (5, [3, 1, 2, 7, 5])]) [8, 16, 32] >>> max_ways_to_distribute_treats(1, [(1, [5])]) [2] >>> max_ways_to_distribute_treats(1, [(1000, [i for i in range(1, 1001)])]) [2 ** 1000]","solution":"def max_ways_to_distribute_treats(t, test_cases): results = [] for test in test_cases: n = test[0] results.append(2 ** n) return results"},{"question":"def manage_inventory(operations): Manage a list of books and respond to queries about inventory. Each book has a title and a count of copies available. Supported operations: - \\"ADD title count\\": Add count of copies of the book with the specified title. - \\"REMOVE title count\\": Remove count of copies of the book with the specified title. - \\"QUERY title\\": Output the number of copies available for the book with the specified title. - \\"DONE\\": Indicate the end of the input. >>> operations = [ ... \\"ADD HarryPotter 10\\", ... \\"ADD LordOfTheRings 5\\", ... \\"QUERY HarryPotter\\", ... \\"REMOVE HarryPotter 3\\", ... \\"QUERY HarryPotter\\", ... \\"REMOVE LordOfTheRings 6\\", ... \\"QUERY LordOfTheRings\\", ... \\"DONE\\" ... ] >>> manage_inventory(operations) ['10', '7', 'NOT FOUND'] >>> operations = [ ... \\"ADD HarryPotter 10\\", ... \\"ADD HarryPotter 5\\", ... \\"QUERY HarryPotter\\", ... \\"DONE\\" ... ] >>> manage_inventory(operations) ['15'] >>> operations = [ ... \\"ADD HarryPotter 10\\", ... \\"REMOVE HarryPotter 5\\", ... \\"QUERY HarryPotter\\", ... \\"DONE\\" ... ] >>> manage_inventory(operations) ['5'] >>> operations = [ ... \\"ADD HarryPotter 10\\", ... \\"REMOVE HarryPotter 15\\", ... \\"QUERY HarryPotter\\", ... \\"DONE\\" ... ] >>> manage_inventory(operations) ['NOT FOUND'] >>> operations = [ ... \\"QUERY HarryPotter\\", ... \\"DONE\\" ... ] >>> manage_inventory(operations) ['NOT FOUND'] >>> operations = [ ... \\"ADD HarryPotter 10\\", ... \\"ADD LordOfTheRings 5\\", ... \\"QUERY HarryPotter\\", ... \\"REMOVE HarryPotter 3\\", ... \\"QUERY HarryPotter\\", ... \\"ADD HarryPotter 2\\", ... \\"QUERY HarryPotter\\", ... \\"QUERY LordOfTheRings\\", ... \\"DONE\\" ... ] >>> manage_inventory(operations) ['10', '7', '9', '5']","solution":"def manage_inventory(operations): inventory = {} results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": title = parts[1] count = int(parts[2]) if title in inventory: inventory[title] += count else: inventory[title] = count elif command == \\"REMOVE\\": title = parts[1] count = int(parts[2]) if title in inventory: inventory[title] -= count if inventory[title] <= 0: del inventory[title] elif command == \\"QUERY\\": title = parts[1] if title in inventory: results.append(str(inventory[title])) else: results.append(\\"NOT FOUND\\") elif command == \\"DONE\\": break return results"},{"question":"class MovieRatingSystem: def __init__(self): self.movies = {} def add(self, name, rating): Add a movie with the given name and rating to the system. Ignore if the movie already exists. def update(self, name, rating): Update the rating of the movie with the given name. Ignore if the movie does not exist. def query(self): Return the name of the highest-rated movie. If multiple movies have the same highest rating, return the lexicographically smallest name. def process_commands(commands): Process a list of commands to add, update, and query movies. Args: commands (List[str]): List of commands to process in the movie rating system. Returns: List[str]: List of results from query commands.","solution":"class MovieRatingSystem: def __init__(self): self.movies = {} def add(self, name, rating): if name not in self.movies: self.movies[name] = rating def update(self, name, rating): if name in self.movies: self.movies[name] = rating def query(self): max_rating = max(self.movies.values()) highest_rated_movies = [name for name, rating in self.movies.items() if rating == max_rating] return min(highest_rated_movies) def process_commands(commands): system = MovieRatingSystem() output = [] for command in commands: parts = command.split() operation = parts[0] if operation == \\"add\\": _, name, rating = parts system.add(name, int(rating)) elif operation == \\"update\\": _, name, rating = parts system.update(name, int(rating)) elif operation == \\"query\\": output.append(system.query()) return output"},{"question":"def restore_sequence(N: int, sequence: List[str]) -> List[int]: Restore the arithmetic progression sequence by replacing '?' with appropriate integers. >>> restore_sequence(5, [\\"1\\", \\"?\\", \\"5\\", \\"?\\", \\"9\\"]) [1, 3, 5, 7, 9] >>> restore_sequence(4, [\\"?\\", \\"3\\", \\"6\\", \\"?\\"]) [0, 3, 6, 9] >>> restore_sequence(3, [\\"?\\", \\"?\\", \\"?\\"]) [0, 1, 2] >>> restore_sequence(2, [\\"?\\", \\"?\\"]) [0, 1] >>> restore_sequence(6, [\\"10\\", \\"?\\", \\"30\\", \\"40\\", \\"?\\", \\"?\\"]) [10, 20, 30, 40, 50, 60] >>> restore_sequence(7, [\\"?\\", \\"?\\", \\"?\\", \\"0\\", \\"?\\", \\"?\\", \\"?\\"]) [-3, -2, -1, 0, 1, 2, 3] >>> restore_sequence(5, [\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\"]) [1, 2, 3, 4, 5] >>> restore_sequence(3, [\\"-10\\", \\"0\\", \\"10\\"]) [-10, 0, 10]","solution":"def restore_sequence(N, sequence): Restore the arithmetic progression sequence by replacing '?' with appropriate integers. positions = [i for i, val in enumerate(sequence) if val != '?'] if len(positions) > 1: first_known = positions[0] second_known = positions[1] # Calculate the common difference d = (int(sequence[second_known]) - int(sequence[first_known])) // (second_known - first_known) # Fill sequence from the beginning to the first known position for i in range(first_known - 1, -1, -1): sequence[i] = int(sequence[i + 1]) - d # Fill sequence between known positions and to the end for i in range(first_known + 1, N): if sequence[i] == '?': sequence[i] = int(sequence[i - 1]) + d elif positions: first_known = positions[0] d = 1 # We can choose any value for d since there are no constraints given otherwise for i in range(first_known - 1, -1, -1): sequence[i] = int(sequence[i + 1]) - d for i in range(first_known + 1, N): sequence[i] = int(sequence[i - 1]) + d else: # Handle the case where all values are '?' sequence = list(range(N)) return list(map(int, sequence))"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Compute the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"aa\\") 2 >>> longest_palindromic_subsequence(\\"ab\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"abcde\\") 1 >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"aabcba\\") 5 >>> longest_palindromic_subsequence(\\"agbdba\\") 5","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"from typing import List, Tuple def get_total_printing_time(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the total amount of time for the printer to complete the last student's assignment for each test case. >>> get_total_printing_time([(3, [(0, 5), (2, 3), (5, 3)]), (4, [(1, 2), (1, 3), (3, 1), (6, 2)])]) [11, 9] pass def parse_input(input_string: str) -> List[Tuple[int, List[Tuple[int, int]]]]: Parse the input string into a list of test cases. >>> input_string = '''2 3 0 5 2 3 5 3 4 1 2 1 3 3 1 6 2''' >>> parse_input(input_string) [(3, [(0, 5), (2, 3), (5, 3)]), (4, [(1, 2), (1, 3), (3, 1), (6, 2)])] pass def main(input_string: str) -> None: Handle the input and output for the problem. >>> main('''2 3 0 5 2 3 5 3 4 1 2 1 3 3 1 6 2''') 11 9 pass # Example Test Input example_input = 2 3 0 5 2 3 5 3 4 1 2 1 3 3 1 6 2 if __name__ == \\"__main__\\": main(example_input)","solution":"def get_total_printing_time(test_cases): results = [] for case in test_cases: n, students = case current_time = 0 for arrival, print_time in students: if arrival > current_time: current_time = arrival current_time += print_time results.append(current_time) return results # Function to parse input def parse_input(input_string): input_lines = input_string.split('n') t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) index += 1 students = [] for _ in range(n): arrival, print_time = map(int, input_lines[index].split()) students.append((arrival, print_time)) index += 1 test_cases.append((n, students)) return test_cases # Integration function to handle input and output def main(input_string): test_cases = parse_input(input_string) results = get_total_printing_time(test_cases) for result in results: print(result) # Example Test Input example_input = 2 3 0 5 2 3 5 3 4 1 2 1 3 3 1 6 2 # Running the example if __name__ == \\"__main__\\": main(example_input)"},{"question":"def cpu_usage_optimization(logs, queries): Find the maximum CPU usage in different time intervals. Args: logs: List of tuples containing timestamp and CPU usage queries: List of query intervals as tuples Returns: A list containing the maximum CPU usage for each query interval. >>> logs = [ ... (\\"00:00:01\\", 35), ... (\\"00:01:00\\", 60), ... (\\"00:02:30\\", 75), ... (\\"00:03:00\\", 55), ... (\\"00:04:00\\", 95) ... ] >>> queries = [ ... (\\"00:01:00\\", \\"00:03:00\\"), ... (\\"00:00:00\\", \\"00:02:00\\"), ... (\\"00:02:00\\", \\"00:05:00\\") ... ] >>> cpu_usage_optimization(logs, queries) [75, 60, 95]","solution":"def cpu_usage_optimization(logs, queries): from collections import deque import bisect # Convert timestamp to seconds def to_seconds(timestamp): h, m, s = map(int, timestamp.split(':')) return h * 3600 + m * 60 + s # Convert log timestamps to seconds and pair with CPU usage log_data = [(to_seconds(timestamp), usage) for timestamp, usage in logs] # Initialize result list results = [] # Preparing data for binary searchable queries times = [entry[0] for entry in log_data] usages = [entry[1] for entry in log_data] for start, end in queries: # Convert query timestamps to seconds start_sec, end_sec = to_seconds(start), to_seconds(end) # Binary search to find start and end positions in the log start_idx = bisect.bisect_left(times, start_sec) end_idx = bisect.bisect_right(times, end_sec) - 1 # Calculate the maximum usage in the given interval if start_idx <= end_idx: max_usage = max(usages[start_idx:end_idx+1]) else: max_usage = 0 # or some other invalid result if ranges are invalid # Append result for this query results.append(max_usage) return results"},{"question":"def is_prime(num: int) -> bool: Helper function to determine if a number is prime. pass def has_prime_twins(n: int) -> str: Marta has recently learned about the concept of prime numbers and is fascinated by them. Now, she wants to find out more about prime twins, a pair of prime numbers that differ by exactly 2 (for instance, 3 and 5, 11 and 13). Given an integer n, help Marta determine if there is at least one pair of prime twins (p, p+2) where both p and p+2 are no greater than n. If there is such a pair, return \\"YES\\", otherwise return \\"NO\\". Input: An integer n (2 ≤ n ≤ 10^6). Output: Print \\"YES\\" if there exists at least one pair of prime twins <= n, otherwise print \\"NO\\". Examples: >>> has_prime_twins(10) \\"YES\\" >>> has_prime_twins(14) \\"YES\\" >>> has_prime_twins(2) \\"NO\\" >>> has_prime_twins(17) \\"YES\\" pass","solution":"import math def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def has_prime_twins(n): for i in range(2, n - 1): if is_prime(i) and is_prime(i + 2): return \\"YES\\" return \\"NO\\""},{"question":"def calculate_max_total_power(n: int, k: int, trees: List[List[int]]) -> int: Calculates the maximum total power of k fruits collected from any continuous segment of trees. :param n: int - number of trees :param k: int - number of fruits to collect :param trees: List[List[int]] - list of power sequences from each tree :return: int - the maximum total power of k fruits pass from solution import calculate_max_total_power def test_single_tree(): assert calculate_max_total_power(1, 2, [[5, 6, 7, 8]]) == 15 def test_multiple_trees(): assert calculate_max_total_power(4, 3, [[1, 2, 3], [4, 5, 6], [7, 8], [9, 10, 11, 12]]) == 33 def test_min_k_value(): assert calculate_max_total_power(2, 1, [[1, 2], [3, 4]]) == 4 def test_large_k_value(): assert calculate_max_total_power(3, 8, [[1, 2], [3, 4], [5, 6, 7, 8]]) == 36 def test_exactly_k_fruits(): assert calculate_max_total_power(2, 4, [[3, 5], [1, 4]]) == 13","solution":"def calculate_max_total_power(n, k, trees): Calculates the maximum total power of k fruits collected from any continuous segment of trees. :param n: int - number of trees :param k: int - number of fruits to collect :param trees: List[List[int]] - list of power sequences from each tree :return: int - the maximum total power of k fruits # Combine the powers of all fruits from all trees into one list all_powers = [power for tree in trees for power in tree] # Sort the combined list of powers in descending order to pick the highest k powers all_powers.sort(reverse=True) # Take the sum of the top k powers max_total_power = sum(all_powers[:k]) return max_total_power"},{"question":"def num_blocks(grid: List[List[int]]) -> int: Given a grid of size m x n where each cell in the grid can either be a 0 or a 1, determine the total number of distinct blocks of 1s in the grid. >>> num_blocks([ ... [1, 0, 0, 1, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 1, 1, 1], ... [0, 0, 0, 1, 0] ... ]) == 3 >>> num_blocks([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) == 4 >>> num_blocks([ ... [1, 1, 1, 1, 1], ... [1, 0, 0, 0, 1], ... [1, 0, 1, 0, 1], ... [1, 0, 0, 0, 1], ... [1, 1, 1, 1, 1] ... ]) == 2 >>> num_blocks([ ... [0]*5, ... [0]*5, ... [0]*5, ... [0]*5, ... [0]*5 ... ]) == 0 >>> num_blocks([ ... [1, 1, 0, 0], ... [1, 0, 0, 0], ... [0, 0, 1, 1], ... [0, 0, 1, 1] ... ]) == 2","solution":"def num_blocks(grid): # Helper function to perform DFS and mark cells as visited def dfs(grid, visited, i, j): stack = [(i, j)] while stack: x, y = stack.pop() if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1 and not visited[x][y]: visited[x][y] = True # Check all four possible directions stack.append((x+1, y)) stack.append((x-1, y)) stack.append((x, y+1)) stack.append((x, y-1)) # Grid dimensions m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] block_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: # New block found, perform DFS block_count += 1 dfs(grid, visited, i, j) return block_count"},{"question":"def min_sprinklers_needed(n: int, m: int) -> int: Given the dimensions of the field n (rows) and m (columns), return the minimum number of sprinklers needed to ensure every row and column has at least one sprinkler. >>> min_sprinklers_needed(3, 4) 4 >>> min_sprinklers_needed(5, 5) 5 pass # Your implementation here def test_min_sprinklers_needed(): assert min_sprinklers_needed(3, 4) == 4 assert min_sprinklers_needed(5, 5) == 5 assert min_sprinklers_needed(1, 1) == 1 assert min_sprinklers_needed(1, 5) == 5 assert min_sprinklers_needed(5, 1) == 5 assert min_sprinklers_needed(1000, 1000) == 1000 assert min_sprinklers_needed(1000, 500) == 1000 assert min_sprinklers_needed(500, 1000) == 1000 assert min_sprinklers_needed(7, 3) == 7 assert min_sprinklers_needed(3, 7) == 7","solution":"def min_sprinklers_needed(n, m): Given the dimensions of the field n (rows) and m (columns), return the minimum number of sprinklers needed to ensure every row and column has at least one sprinkler. # To cover all rows and columns, the minimum number of sprinklers needed is the maximum of n and m. return max(n, m)"},{"question":"import random def simulate_monty_hall(n: int): Simulates the Monty Hall problem n times and returns the probabilities of winning the car when sticking with the initial choice and when switching. :param n: Number of simulations :return: A tuple of probabilities (stick_win_prob, switch_win_prob) # Implementation here # Unit Tests def test_simulate_monty_hall_1000(): stick_prob, switch_prob = simulate_monty_hall(1000) stick_prob_val = float(stick_prob.rstrip('%')) switch_prob_val = float(switch_prob.rstrip('%')) assert 30.0 <= stick_prob_val <= 36.0 assert 63.0 <= switch_prob_val <= 69.0 def test_simulate_monty_hall_10000(): stick_prob, switch_prob = simulate_monty_hall(10000) stick_prob_val = float(stick_prob.rstrip('%')) switch_prob_val = float(switch_prob.rstrip('%')) assert 32.0 <= stick_prob_val <= 35.0 assert 65.0 <= switch_prob_val <= 68.0 def test_simulate_monty_hall_100000(): stick_prob, switch_prob = simulate_monty_hall(100000) stick_prob_val = float(stick_prob.rstrip('%')) switch_prob_val = float(switch_prob.rstrip('%')) assert 32.5 <= stick_prob_val <= 34.0 assert 65.5 <= switch_prob_val <= 67.5 def test_simulate_monty_hall_edge_case(): stick_prob, switch_prob = simulate_monty_hall(1) stick_prob_val = float(stick_prob.rstrip('%')) switch_prob_val = float(switch_prob.rstrip('%')) assert (stick_prob_val == 100.0 or switch_prob_val == 100.0) or (stick_prob_val == 0.0 or switch_prob_val == 0.0)","solution":"import random def simulate_monty_hall(n: int): Simulates the Monty Hall problem n times and returns the probabilities of winning the car when sticking with the initial choice and when switching. :param n: Number of simulations :return: A tuple of probabilities (stick_win_prob, switch_win_prob) stick_wins = 0 switch_wins = 0 for _ in range(n): # Randomly place the car behind one of the three doors car_behind_door = random.randint(0, 2) # Contestant makes an initial choice (randomly) contestant_choice = random.randint(0, 2) # Monty reveals a door with a goat (can't be the contestant's choice or the car) revealed_door = next(door for door in range(3) if door != contestant_choice and door != car_behind_door) # Determine the remaining unopened door which the contestant can switch to remaining_door = next(door for door in range(3) if door != contestant_choice and door != revealed_door) # If the contestant sticks with their initial choice if contestant_choice == car_behind_door: stick_wins += 1 # If the contestant switches to the remaining door if remaining_door == car_behind_door: switch_wins += 1 stick_win_prob = (stick_wins / n) * 100 switch_win_prob = (switch_wins / n) * 100 return (f\\"{stick_win_prob:.3f}%\\", f\\"{switch_win_prob:.3f}%\\")"},{"question":"def search_and_replace(T: int, test_cases: List[Tuple[int, List[Tuple[str, str]], str]]) -> List[str]: Function to replace patterns in text based on given pairs of find and replace patterns. >>> search_and_replace(1, [(2, [('he', 'ho'), ('hi', 'hello')], 'hehohello')]) ['hihellohello'] >>> search_and_replace(1, [(1, [('abc', 'xyz')], 'abcd')]) ['xyzd'] >>> search_and_replace(1, [(2, [('a', 'b'), ('bc', 'xy')], 'abcd')]) ['bxyd'] >>> search_and_replace(1, [(1, [('hello', 'hi')], 'world')]) ['world'] >>> search_and_replace(1, [(2, [('ab', 'abc'), ('abc', 'ab')], 'ab')]) ['ab'] >>> search_and_replace(2, [ (1, [('cat', 'dog')], 'the cat in the hat'), (1, [('hello', 'hi')], 'hello world') ]) ['the dog in the hat', 'hi world']","solution":"def search_and_replace(T, test_cases): results = [] for case in test_cases: N, patterns, text = case for pattern, replacement in patterns: text = text.replace(pattern, replacement) results.append(text) return results"},{"question":"def can_be_x_ranked(n: int, arr: List[int]) -> str: Determine if an array can be transformed into an x-ranked array. Returns the x-ranked array if possible, otherwise \\"Impossible\\". >>> can_be_x_ranked(5, [5, 3, 1, 4, 2]) \\"5 1 4 2 3\\" >>> can_be_x_ranked(4, [4, 2, 3, 1]) \\"4 1 3 2\\" >>> can_be_x_ranked(1, [7]) \\"7\\" >>> can_be_x_ranked(2, [2, 1]) \\"2 1\\" >>> can_be_x_ranked(2, [1, 2]) \\"2 1\\" >>> can_be_x_ranked(3, [2, 1, 3]) \\"3 1 2\\" >>> can_be_x_ranked(3, [1, 2, 3]) \\"3 1 2\\" >>> can_be_x_ranked(5, [5, 1, 4, 2, 3]) \\"5 1 4 2 3\\" >>> can_be_x_ranked(4, [4, 3, 2, 1]) \\"4 1 3 2\\"","solution":"def x_rank(arr): This function takes a list of integers and returns an x-ranked list or \\"Impossible\\" if the list cannot be transformed into an x-ranked list. n = len(arr) # Sort the array to pick max and min easily arr_sorted = sorted(arr) # Create list to hold x-ranked elements x_ranked = [] # Let's perform the selection process for i in range(n): # Even index -> pick max remaining if i % 2 == 0: x_ranked.append(arr_sorted.pop()) # Pick max else: x_ranked.append(arr_sorted.pop(0)) # Pick min return x_ranked def can_be_x_ranked(n, arr): Returns the x-ranked array if possible, otherwise \\"Impossible\\" x_ranked = x_rank(arr) return ' '.join(map(str, x_ranked))"},{"question":"from typing import List def most_frequent_product(views: List[int]) -> int: Finds the most frequent product viewed by a customer. In case of a tie, returns the smallest product ID. :param views: List of integers representing the sequence of product views. :return: Integer representing the most frequent product viewed. pass # Unit tests def test_single_product(): assert most_frequent_product([1]) == 1 def test_multiple_unique_views(): assert most_frequent_product([1, 2, 3, 4, 5]) == 1 def test_multiple_products_with_one_tied(): assert most_frequent_product([1, 2, 2, 3, 3, 4]) == 2 def test_case_with_tie_in_frequency(): assert most_frequent_product([1, 2, 2, 3, 3, 1]) == 1 def test_all_elements_same(): assert most_frequent_product([5, 5, 5, 5, 5]) == 5 def test_no_views(): assert most_frequent_product([]) is None def test_large_input(): views = [0] * 500000 + [1] * 500000 assert most_frequent_product(views) == 0","solution":"from collections import Counter def most_frequent_product(views): Finds the most frequent product viewed by a customer. In case of a tie, returns the smallest product ID. :param views: List of integers representing the sequence of product views. :return: Integer representing the most frequent product viewed. if not views: return None # Handle edge case of empty list counter = Counter(views) most_common = counter.most_common() max_frequency = most_common[0][1] most_frequent_products = [product for product, count in most_common if count == max_frequency] return min(most_frequent_products)"},{"question":"from typing import List, Union, Tuple from collections import deque, defaultdict def find_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine the task execution order to ensure all tasks are completed efficiently. Return the order of tasks or \\"Cycle detected\\" if there is a circular dependency. Args: num_tasks: An integer representing the number of tasks. dependencies: A list of tuples where each tuple contains two integers representing a dependency. Returns: A list of integers representing the task execution order or \\"Cycle detected\\" if no valid order. >>> find_order(4, [(1, 0), (2, 1), (3, 2)]) [0, 1, 2, 3] >>> find_order(3, [(0, 1), (1, 2), (2, 0)]) \\"Cycle detected\\" pass def process_input(data: str) -> List[str]: Process the input data and determine task execution order for each dataset. Args: data: A string containing multiple datasets. Returns: A list of strings where each string represents the task execution order for a dataset. >>> data = '''4 3n1 0n2 1n3 2nn3 2n2 1n1 0nn3 2n2 1n1 0n2 0nn3 4n2 1n1 0n2 0n0 2nn0 0''' >>> process_input(data) ['0 1 2 3', '0 1 2', '0 1 2', 'Cycle detected'] pass def main(data: str): results = process_input(data) for result in results: print(result)","solution":"from collections import deque, defaultdict def find_order(num_tasks, dependencies): indegree = [0] * num_tasks graph = defaultdict(list) for dest, src in dependencies: graph[src].append(dest) indegree[dest] += 1 queue = deque([i for i in range(num_tasks) if indegree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == num_tasks: return order else: return \\"Cycle detected\\" def process_input(data): results = [] datasets = data.strip().split(\\"nn\\") for dataset in datasets: lines = dataset.split(\\"n\\") n, m = map(int, lines[0].split()) if n == 0 and m == 0: break dependencies = [tuple(map(int, line.split())) for line in lines[1:]] order = find_order(n, dependencies) if order == \\"Cycle detected\\": results.append(order) else: results.append(\\" \\".join(map(str, order))) return results # For interaction def main(data): results = process_input(data) for result in results: print(result)"},{"question":"from typing import List, Tuple def minimum_colors_needed(N: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of unique colors needed to color the forest such that no two adjacent nodes have the same color. Args: N (int): Number of nodes edges (List[Tuple[int, int]]): List of edges between nodes Returns: int: Minimum number of colors needed Example: >>> minimum_colors_needed(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 >>> minimum_colors_needed(1, []) 1 pass def test_single_node(): assert minimum_colors_needed(1, []) == 1 def test_two_nodes(): assert minimum_colors_needed(2, [(1, 2)]) == 2 def test_simple_tree(): assert minimum_colors_needed(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 2 def test_disconnected_components(): assert minimum_colors_needed(6, [(1, 2), (3, 4), (5, 6)]) == 2 def test_large_tree(): edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] assert minimum_colors_needed(7, edges) == 2 def test_star_shape(): assert minimum_colors_needed(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 2","solution":"def minimum_colors_needed(N, edges): from collections import defaultdict, deque if N == 1: return 1 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start): queue = deque([start]) colors = [-1] * (N + 1) colors[start] = 0 max_color = 0 while queue: node = queue.popleft() current_color = colors[node] for neighbor in graph[node]: if colors[neighbor] == -1: queue.append(neighbor) free_colors = set(range(2)) free_colors.discard(current_color) colors[neighbor] = free_colors.pop() max_color = max(max_color, colors[neighbor]) return max_color + 1 # Run BFS from any arbitrary node, here starting from node 1 return bfs(1)"},{"question":"from collections import deque, defaultdict def shortest_paths_from_capital(n: int, m: int, roads: List[Tuple[int, int]]) -> List[int]: Calculate the shortest path from the capital (town 1) to each of the towns in the kingdom. Args: n (int): Number of towns. m (int): Number of roads. roads (List[Tuple[int, int]]): List of roads where each road is represented as a tuple of two integers (u, v) indicating a road from town u to town v. Returns: List[int]: A list of n integers where the i-th integer is the length of the shortest path from the capital (town 1) to town i+1. If town i+1 is unreachable from the capital, the value should be -1. Example: >>> shortest_paths_from_capital(5, 6, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)]) [0, 1, 1, 2, 3] >>> shortest_paths_from_capital(4, 3, [(1, 2), (2, 3), (3, 4)]) [0, 1, 2, 3] >>> shortest_paths_from_capital(3, 2, [(2, 3), (3, 2)]) [0, -1, -1]","solution":"from collections import deque, defaultdict def shortest_paths_from_capital(n, m, roads): graph = defaultdict(list) for u, v in roads: graph[u].append(v) distances = [-1] * n distances[0] = 0 queue = deque([1]) while queue: current_town = queue.popleft() for neighbor in graph[current_town]: if distances[neighbor - 1] == -1: distances[neighbor - 1] = distances[current_town - 1] + 1 queue.append(neighbor) return distances # Example usage: # n = 5 # m = 6 # roads = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)] # print(shortest_paths_from_capital(n, m, roads)) # Output: [0, 1, 1, 2, 3]"},{"question":"def maxWaterTrapped(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped between the buildings after it rains. Args: height (List[int]): A list of integers where each integer represents the height of a building. Returns: int: Maximum amount of water trapped. Examples: >>> maxWaterTrapped([]) 0 >>> maxWaterTrapped([1, 2, 3, 4, 5]) 0 >>> maxWaterTrapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> maxWaterTrapped([3, 3, 3, 3]) 0 >>> maxWaterTrapped([2, 0, 2]) 2 >>> maxWaterTrapped([3, 0, 2, 0, 4]) 7 >>> maxWaterTrapped([0, 1, 2, 1, 2, 1, 2, 1, 0]) 2 >>> maxWaterTrapped([4, 1, 1, 0, 2, 3]) 8","solution":"def maxWaterTrapped(height): Calculate the maximum amount of water that can be trapped between the buildings after it rains. :param height: List[int] - A list of integers where each integer represents the height of a building. :return: int - Maximum amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def max_magical_energy(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Given the number of test cases, and for each test case the number of trees, the minimum distance between the trees that can be cut, and a list containing the magical energy of each tree, this function returns the maximum magical energy Harry can harvest for each test case. >>> max_magical_energy(2, [((5, 2), [10, 5, 15, 20, 25]), ((6, 1), [4, 2, 6, 5, 3, 8])]) [35, 18] >>> max_magical_energy(1, [((4, 2), [0, 0, 0, 0])]) [0] import pytest def test_max_magical_energy_single_test_case_1(): t = 1 test_cases = [ ((5, 2), [10, 5, 15, 20, 25]) ] assert max_magical_energy(t, test_cases) == [35] def test_max_magical_energy_single_test_case_2(): t = 1 test_cases = [ ((6, 1), [4, 2, 6, 5, 3, 8]) ] assert max_magical_energy(t, test_cases) == [18] def test_max_magical_energy_multiple_test_cases(): t = 2 test_cases = [ ((5, 2), [10, 5, 15, 20, 25]), ((6, 1), [4, 2, 6, 5, 3, 8]) ] assert max_magical_energy(t, test_cases) == [35, 18] def test_max_magical_energy_no_energy(): t = 1 test_cases = [ ((4, 2), [0, 0, 0, 0]) ] assert max_magical_energy(t, test_cases) == [0] def test_max_magical_energy_all_trees_skipped(): t = 1 test_cases = [ ((4, 4), [10, 20, 30, 40]) ] assert max_magical_energy(t, test_cases) == [40] if __name__ == \\"__main__\\": pytest.main()","solution":"def max_magical_energy(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] energy = test_cases[i][1] dp = [0] * n for j in range(n): if j == 0: dp[j] = energy[j] else: dp[j] = energy[j] if j > k: dp[j] += max(dp[:j-k]) results.append(max(dp)) return results"},{"question":"def count_even_sum_pairs(A): Returns the number of distinct pairs (i, j) such that A_i + A_j is an even number and i < j :param A: List of integers :return: Number of pairs >>> count_even_sum_pairs([6, 4, 7, 8]) == 3 >>> count_even_sum_pairs([2, 4, 6, 8, 10]) == 10 >>> count_even_sum_pairs([1, 3, 5, 7, 9]) == 10 >>> count_even_sum_pairs([2, 3, 4, 5, 6, 7]) == 6 >>> count_even_sum_pairs([1]) == 0 >>> count_even_sum_pairs([2]) == 0 >>> count_even_sum_pairs([]) == 0","solution":"def count_even_sum_pairs(A): Returns the number of distinct pairs (i, j) such that A_i + A_j is an even number and i < j :param A: List of integers :return: Number of pairs even_count = 0 odd_count = 0 for number in A: if number % 2 == 0: even_count += 1 else: odd_count += 1 # Number of ways to pick 2 out of even_count elements even_pairs = even_count * (even_count - 1) // 2 # Number of ways to pick 2 out of odd_count elements odd_pairs = odd_count * (odd_count - 1) // 2 return even_pairs + odd_pairs"},{"question":"def rearrange_negatives_positives(arr): Rearranges an array so that all negative numbers appear before all positive numbers. Uses the partitioning approach with two pointers to achieve O(n) time complexity and O(1) space complexity. pass def solve_cases(test_cases): results = [] for case in test_cases: n, arr = case rearranged = rearrange_negatives_positives(arr) results.append(rearranged) return results # Example usage: # test_cases = [(8, [1, -3, 5, -2, -7, 3, 6, -4]), (5, [4, -1, 0, -2, 2])] # print(solve_cases(test_cases)) # Expected Output: [[-3, -2, -7, -4, 1, 5, 3, 6], [-1, -2, 0, 4, 2]]","solution":"def rearrange_negatives_positives(arr): Rearranges an array so that all negative numbers appear before all positive numbers. Uses the partitioning approach with two pointers to achieve O(n) time complexity and O(1) space complexity. left = 0 right = len(arr) - 1 while left <= right: if arr[left] < 0: left += 1 elif arr[right] >= 0: right -= 1 else: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return arr def solve_cases(test_cases): results = [] for case in test_cases: n, arr = case rearranged = rearrange_negatives_positives(arr) results.append(rearranged) return results # Example usage: # test_cases = [(8, [1, -3, 5, -2, -7, 3, 6, -4]), (5, [4, -1, 0, -2, 2])] # print(solve_cases(test_cases)) # Expected Output: [[-3, -2, -7, -4, 1, 5, 3, 6], [-1, -2, 0, 4, 2]]"},{"question":"def process_student_records(records): Processes a list of student records, computes their average scores, and returns a list of tuples containing student names and their average scores, sorted by student names in alphabetical order. Args: records (list): List of strings, each containing a student's name followed by three scores separated by spaces. Returns: list: A list of tuples, each containing a student's name and their average score rounded to two decimal places, sorted by student names in alphabetical order. pass def format_student_averages(student_averages): Takes a list of student averages and formats them as strings with two decimal places. Args: student_averages (list): List of tuples containing student names and their average scores. Returns: list: A list of strings containing student names and their average scores with two decimal places. pass # Test cases def test_process_student_records(): records = [ \\"Alice 80 70 90\\", \\"Bob 85 88 90\\", \\"Charlie 70 75 80\\", \\"Zoe 65 70 75\\", \\"Dave 78 82 85\\" ] expected_output = [ (\\"Alice\\", 80.0), (\\"Bob\\", 87.66666666666667), (\\"Charlie\\", 75.0), (\\"Dave\\", 81.66666666666667), (\\"Zoe\\", 70.0) ] assert process_student_records(records) == expected_output def test_format_student_averages(): student_averages = [ (\\"Alice\\", 80.0), (\\"Bob\\", 87.66666666666667), (\\"Charlie\\", 75.0), (\\"Dave\\", 81.66666666666667), (\\"Zoe\\", 70.0) ] expected_output = [ \\"Alice 80.00\\", \\"Bob 87.67\\", \\"Charlie 75.00\\", \\"Dave 81.67\\", \\"Zoe 70.00\\" ] assert format_student_averages(student_averages) == expected_output def test_full_solution(): records = [ \\"Alice 80 70 90\\", \\"Bob 85 88 90\\", \\"Charlie 70 75 80\\", \\"Zoe 65 70 75\\", \\"Dave 78 82 85\\" ] processed_records = process_student_records(records) formatted_output = format_student_averages(processed_records) expected_output = [ \\"Alice 80.00\\", \\"Bob 87.67\\", \\"Charlie 75.00\\", \\"Dave 81.67\\", \\"Zoe 70.00\\" ] assert formatted_output == expected_output","solution":"def process_student_records(records): Processes a list of student records, computes their average scores, and returns a list of tuples containing student names and their average scores, sorted by student names in alphabetical order. Args: records (list): List of strings, each containing a student's name followed by three scores separated by spaces. Returns: list: A list of tuples, each containing a student's name and their average score rounded to two decimal places, sorted by student names in alphabetical order. student_averages = [] for record in records: parts = record.split() name = \\" \\".join(parts[:-3]) scores = list(map(int, parts[-3:])) average_score = sum(scores) / 3 student_averages.append((name, average_score)) student_averages.sort(key=lambda x: x[0]) return student_averages def format_student_averages(student_averages): Takes a list of student averages and formats them as strings with two decimal places. Args: student_averages (list): List of tuples containing student names and their average scores. Returns: list: A list of strings containing student names and their average scores with two decimal places. return [f\\"{name} {average:.2f}\\" for name, average in student_averages]"},{"question":"def min_possible_sum(n: int, array: List[int]) -> int: Returns the minimum possible sum of all integers in the array after (n-1) operations. >>> min_possible_sum(4, [1, 2, 3, 4]) 10 >>> min_possible_sum(3, [5, 1, 3]) 9 >>> min_possible_sum(2, [10, 20]) 30 >>> min_possible_sum(2, [1, 1]) 2 >>> min_possible_sum(5, [1, 1, 1, 1, 1]) 5 >>> min_possible_sum(3, [1000000000, 1000000000, 1000000000]) 3000000000 from typing import List def test_min_possible_sum(): assert min_possible_sum(4, [1, 2, 3, 4]) == 10 assert min_possible_sum(3, [5, 1, 3]) == 9 assert min_possible_sum(2, [10, 20]) == 30 assert min_possible_sum(2, [1, 1]) == 2 assert min_possible_sum(5, [1, 1, 1, 1, 1]) == 5 assert min_possible_sum(3, [1000000000, 1000000000, 1000000000]) == 3000000000 test_min_possible_sum()","solution":"def min_possible_sum(n, array): Returns the minimum possible sum of all integers in the array after (n-1) operations. return sum(array)"},{"question":"def process_operations(operations: str) -> str: Processes a series of append and delete operations on a buffer. Parameters: - operations (str): A string of operations where each character is either a lowercase Latin letter for append, or '#' for delete. Returns: - str: The final state of the buffer after performing all operations. Examples: >>> process_operations(\\"abcd\\") \\"ad\\" >>> process_operations(\\"ab#c#d\\") \\"ad\\" def test_single_append(): assert process_operations(\\"a\\") == \\"a\\" def test_one_delete(): assert process_operations(\\"a#\\") == \\"\\" def test_multiple_appends_and_deletes(): assert process_operations(\\"abcd\\") == \\"ad\\" assert process_operations(\\"ab#c#d\\") == \\"ad\\" def test_starts_with_delete(): assert process_operations(\\"#a\\") == \\"a\\" assert process_operations(\\"abc\\") == \\"abc\\" def test_empty_input(): assert process_operations(\\"\\") == \\"\\" def test_no_operations(): assert process_operations(\\"abcdef\\") == \\"abcdef\\" def test_all_deletes(): assert process_operations(\\"abc#\\") == \\"\\" def test_mixed_operations(): assert process_operations(\\"a#bc#de#f#\\") == \\"d\\" def test_no_deletes_needed(): assert process_operations(\\"ghijkl\\") == \\"ghijkl\\"","solution":"def process_operations(operations): Processes a series of append and delete operations on a buffer. Parameters: - operations (str): A string of operations where each character is either a lowercase Latin letter for append, or '#' for delete. Returns: - str: The final state of the buffer after performing all operations. buffer = [] for op in operations: if op == '#': if buffer: buffer.pop() else: buffer.append(op) return ''.join(buffer)"},{"question":"from typing import List def min_elements_to_sum_target(n: int, target: int, elements: List[int]) -> int: Determine the minimum number of elements required from the array to sum up to the target value. Args: n (int): Number of elements in the array. target (int): The desired sum. elements (List[int]): The array of positive integers. Returns: int: The minimum number of elements required to reach the target sum or -1 if it's impossible. >>> min_elements_to_sum_target(3, 5, [1, 2, 3]) 2 >>> min_elements_to_sum_target(4, 11, [1, 5, 6, 9]) 2 >>> min_elements_to_sum_target(2, 7, [4, 9]) -1 # Your code here # Unit tests def test_case_1(): assert min_elements_to_sum_target(3, 5, [1, 2, 3]) == 2 def test_case_2(): assert min_elements_to_sum_target(4, 11, [1, 5, 6, 9]) == 2 def test_case_3(): assert min_elements_to_sum_target(2, 7, [4, 9]) == -1 def test_case_4(): assert min_elements_to_sum_target(3, 8, [2, 3, 5]) == 2 def test_case_5(): assert min_elements_to_sum_target(1, 25, [5]) == 5 def test_case_6(): assert min_elements_to_sum_target(4, 10, [1, 3, 4, 7]) == 2 def test_case_7(): assert min_elements_to_sum_target(5, 15, [1, 2, 3, 4, 5]) == 3 def test_case_8(): assert min_elements_to_sum_target(3, 10, [6, 7, 8]) == -1","solution":"def min_elements_to_sum_target(n, target, elements): dp = [float('inf')] * (target + 1) dp[0] = 0 for i in range(1, target + 1): for el in elements: if i >= el: dp[i] = min(dp[i], dp[i - el] + 1) return dp[target] if dp[target] != float('inf') else -1 # Example usage n, target = 3, 5 elements = [1, 2, 3] print(min_elements_to_sum_target(n, target, elements)) # Output should be 2"},{"question":"def rotate_array(test_cases): Rotate the array k times to the right for each test case. >>> test_cases = [((7, 3), [1, 2, 3, 4, 5, 6, 7])] >>> rotate_array(test_cases) [[5, 6, 7, 1, 2, 3, 4]] >>> test_cases = [((4, 2), [10, 20, 30, 40])] >>> rotate_array(test_cases) [[30, 40, 10, 20]] pass def parse_input(input_str): Parse input string into test cases. >>> input_str = \\"1n7 3n1 2 3 4 5 6 7\\" >>> parse_input(input_str) [((7, 3), [1, 2, 3, 4, 5, 6, 7])] pass def format_output(results): Format the output from the results. >>> results = [[5, 6, 7, 1, 2, 3, 4]] >>> format_output(results) \\"5 6 7 1 2 3 4\\" pass","solution":"def rotate_array(test_cases): results = [] for case in test_cases: n, k = case[0] arr = case[1] k = k % n # In case k is larger than n rotated_arr = arr[-k:] + arr[:-k] results.append(rotated_arr) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") num_test_cases = int(lines[0]) test_cases = [] line_idx = 1 for _ in range(num_test_cases): n, k = map(int, lines[line_idx].split()) arr = list(map(int, lines[line_idx + 1].split())) test_cases.append(((n, k), arr)) line_idx += 2 return test_cases def format_output(results): output = [] for result in results: output.append(\\" \\".join(map(str, result))) return \\"n\\".join(output)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing integers, plus (+), minus (-), multiplication (*), and division (/) operations. Division results should truncate towards zero. >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers, plus (+), minus (-), multiplication (*), and division (/) operations. Division results should truncate towards zero. def apply_operation(oper, b, a): if oper == '+': return a + b elif oper == '-': return a - b elif oper == '*': return a * b elif oper == '/': return int(a / b) def precedence(oper): if oper in ('+', '-'): return 1 if oper in ('*', '/'): return 2 return 0 num_stack = [] op_stack = [] i = 0 while i < len(expression): if expression[i].isspace(): i += 1 continue if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 num_stack.append(num) i -= 1 elif expression[i] in \\"+-*/\\": while (op_stack and precedence(op_stack[-1]) >= precedence(expression[i])): num_stack.append(apply_operation(op_stack.pop(), num_stack.pop(), num_stack.pop())) op_stack.append(expression[i]) i += 1 while op_stack: num_stack.append(apply_operation(op_stack.pop(), num_stack.pop(), num_stack.pop())) return num_stack[-1]"},{"question":"def minimum_seconds_to_balance_rockets(n: int, rockets: List[int]) -> int: Given the number of launchpads 'n' and a list 'rockets' containing the number of rockets at each launchpad, calculates the minimum number of seconds needed to balance the rockets among the launchpads. Args: n (int): The number of launchpads. rockets (List[int]): A list containing the number of rockets at each launchpad. Returns: int: The minimum number of seconds required to balance the rockets. Examples: >>> minimum_seconds_to_balance_rockets(3, [4, 7, 3]) 2 >>> minimum_seconds_to_balance_rockets(5, [12, 12, 9, 15, 11]) 3 >>> minimum_seconds_to_balance_rockets(4, [6, 6, 6, 6]) 0","solution":"def minimum_seconds_to_balance_rockets(n, rockets): total_rockets = sum(rockets) average = total_rockets // n remainder = total_rockets % n rockets.sort() balance_seconds = 0 i = 0 while rockets[i] < average and i < n: if remainder > 0: balance_seconds += average + 1 - rockets[i] remainder -= 1 else: balance_seconds += average - rockets[i] rockets[i] = average if remainder == 0 else average + 1 i += 1 return balance_seconds"},{"question":"def check_inventory(n, m, inventory_codes, provided_list_codes): Determines how many book codes from a provided list are already in the inventory and how many are new additions. Args: n: Number of books currently in the inventory m: Number of books in the provided list inventory_codes: List of book codes in the inventory provided_list_codes: List of book codes in the provided list Returns: Tuple containing two integers - number of books already in the inventory and number of new additions >>> check_inventory(5, 3, [\\"abc123\\", \\"xyz456\\", \\"book007\\", \\"novel2022\\", \\"textbook300\\"], [\\"abc123\\", \\"novel2022\\", \\"newbook555\\"]) (2, 1) >>> check_inventory(5, 3, [\\"abc123\\", \\"xyz456\\", \\"book007\\", \\"novel2022\\", \\"textbook300\\"], [\\"newbook555\\", \\"anothernewbook111\\", \\"newestbook222\\"]) (0, 3) >>> check_inventory(5, 3, [\\"abc123\\", \\"xyz456\\", \\"book007\\", \\"novel2022\\", \\"textbook300\\"], [\\"abc123\\", \\"novel2022\\", \\"xy456\\"]) (2, 1) >>> check_inventory(3, 4, [\\"codeA\\", \\"codeB\\", \\"codeC\\"], [\\"codeA\\", \\"nonexistent1\\", \\"codeC\\", \\"nonexistent2\\"]) (2, 2) >>> check_inventory(3, 0, [\\"codeA\\", \\"codeB\\", \\"codeC\\"], []) (0, 0) >>> check_inventory(0, 3, [], [\\"codeA\\", \\"codeB\\", \\"codeC\\"]) (0, 3)","solution":"def check_inventory(n, m, inventory_codes, provided_list_codes): Determines how many book codes from a provided list are already in the inventory and how many are new additions. Args: n: Number of books currently in the inventory m: Number of books in the provided list inventory_codes: List of book codes in the inventory provided_list_codes: List of book codes in the provided list Returns: Tuple containing two integers - number of books already in the inventory and number of new additions inventory_set = set(inventory_codes) # Convert inventory list to set for O(1) lookup already_in_inventory = 0 new_additions = 0 for code in provided_list_codes: if code in inventory_set: already_in_inventory += 1 else: new_additions += 1 return already_in_inventory, new_additions"},{"question":"from typing import List, Tuple def is_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the given graph is a tree. :param n: Number of nodes :param m: Number of edges :param edges: List of edges where each edge is represented as a tuple (u, v) :return: \\"YES\\" if the graph is a tree, otherwise \\"NO\\" pass # Test cases def test_example_1(): n = 4 m = 3 edges = [(1, 2), (2, 3), (3, 4)] assert is_tree(n, m, edges) == \\"YES\\" def test_example_2(): n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert is_tree(n, m, edges) == \\"NO\\" def test_single_node(): n = 1 m = 0 edges = [] assert is_tree(n, m, edges) == \\"YES\\" def test_disconnected_graph(): n = 4 m = 2 edges = [(1, 2), (3, 4)] assert is_tree(n, m, edges) == \\"NO\\" def test_not_connected_graph(): n = 4 m = 3 edges = [(1, 2), (2, 3), (4, 4)] assert is_tree(n, m, edges) == \\"NO\\"","solution":"def is_tree(n, m, edges): Determines if the given graph is a tree. :param n: Number of nodes :param m: Number of edges :param edges: List of edges where each edge is represented as a tuple (u, v) :return: \\"YES\\" if the graph is a tree, otherwise \\"NO\\" if m != n - 1: return \\"NO\\" from collections import defaultdict, deque # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Check if the graph is connected and acyclic using BFS visited = [False] * (n + 1) queue = deque([1]) count = 0 while queue: node = queue.popleft() if visited[node]: continue visited[node] = True count += 1 for neighbor in graph[node]: if not visited[neighbor]: queue.append(neighbor) # Check if all nodes are visited (graph is connected) and the count of visited nodes is n if count == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def run_length_encoding(s: str) -> str: Performs run-length encoding on the given string. s : str : input string containing lowercase alphabets return : str : run-length encoded string pass from run_length_encoding import run_length_encoding def test_general_case(): assert run_length_encoding(\\"aaaabbbcc\\") == \\"a4b3c2\\" def test_single_char(): assert run_length_encoding(\\"aaaaa\\") == \\"a5\\" def test_mixed_case(): assert run_length_encoding(\\"aaabbcccc\\") == \\"a3b2c4\\" assert run_length_encoding(\\"abbbbbc\\") == \\"a1b5c1\\" def test_no_repetition(): assert run_length_encoding(\\"abcdef\\") == \\"a1b1c1d1e1f1\\" def test_empty_string(): assert run_length_encoding(\\"\\") == \\"\\" def test_single_char_repeating(): assert run_length_encoding(\\"cccccc\\") == \\"c6\\" def test_all_characters_unique(): assert run_length_encoding(\\"abcd\\") == \\"a1b1c1d1\\"","solution":"def run_length_encoding(s): Performs run-length encoding on the given string. s : str : input string containing lowercase alphabets return : str : run-length encoded string if not s: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: encoded_str += s[i-1] + str(count) count = 1 encoded_str += s[-1] + str(count) return encoded_str"},{"question":"def count_islands(grid: List[List[int]]) -> int: Count the number of distinct islands in the grid. An island is formed by a group of connected land cells (horizontally or vertically) surrounded by water. >>> count_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ]) 2 >>> count_islands([ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 0, 1, 0, 0] ... ]) 4 >>> count_islands([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 0 >>> count_islands([ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) 1 >>> count_islands([ ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0] ... ]) 10","solution":"def count_islands(grid): def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0: continue grid[i][j] = 0 # Mark as visited stack.append((i+1, j)) stack.append((i-1, j)) stack.append((i, j+1)) stack.append((i, j-1)) m = len(grid) n = len(grid[0]) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j) island_count += 1 return island_count"},{"question":"from collections import defaultdict class Leaderboard: Class to manage a leaderboard for a coding competition. def __init__(self): self.scores = defaultdict(int) def add(self, name: str, score: int): Add or update the score for a participant. Args: name (str): The name of the participant. score (int): The score to add. pass def remove(self, name: str): Remove a participant from the leaderboard. Args: name (str): The name of the participant. pass def top(self, k: int): Return the top k participants with the highest scores. Args: k (int): The number of top participants to return. Returns: List[Tuple[str, int]]: List of participants and their scores. pass def handle_operations(operations: List[str]) -> List[List[Tuple[str, int]]]: Handle multiple operations on the leaderboard. Args: operations (List[str]): List of operations to perform. Returns: List[List[Tuple[str, int]]]: Results of the 'top k' operations. pass # Example usage: operations = [ \\"add Alice 50\\", \\"add Bob 30\\", \\"top 2\\", \\"add Alice 20\\", \\"top 1\\", \\"remove Bob\\", \\"top 2\\", \\"add Charlie 40\\", \\"top 2\\", ] results = handle_operations(operations) for result in results: for name, score in result: print(f\\"{name} {score}\\")","solution":"from collections import defaultdict class Leaderboard: def __init__(self): self.scores = defaultdict(int) def add(self, name, score): self.scores[name] += score def remove(self, name): if name in self.scores: del self.scores[name] def top(self, k): sorted_participants = sorted(self.scores.items(), key=lambda x: (-x[1], x[0])) return sorted_participants[:k] def handle_operations(operations): leaderboard = Leaderboard() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": name, score = parts[1], int(parts[2]) leaderboard.add(name, score) elif parts[0] == \\"remove\\": name = parts[1] leaderboard.remove(name) elif parts[0] == \\"top\\": k = int(parts[1]) top_participants = leaderboard.top(k) results.append(top_participants) return results # Example usage within the solution: operations = [ \\"add Alice 50\\", \\"add Bob 30\\", \\"top 2\\", \\"add Alice 20\\", \\"top 1\\", \\"remove Bob\\", \\"top 2\\", \\"add Charlie 40\\", \\"top 2\\", ] results = handle_operations(operations) for result in results: for name, score in result: print(f\\"{name} {score}\\")"},{"question":"def sort_attractions(n, attractions): Sorts the attractions by their opening times and alphabetically if times are the same. Parameters: n (int): The number of attractions. attractions (list of tuples): Each tuple contains the attraction name (str) and its opening time (int). Returns: list of str: A sorted list of attraction names. >>> sort_attractions(4, [('Museum', 9), ('Zoo', 10), ('Aquarium', 9), ('Botanical_Garden', 9)]) ['Aquarium', 'Botanical_Garden', 'Museum', 'Zoo'] >>> sort_attractions(1, [('Museum', 9)]) ['Museum']","solution":"def sort_attractions(n, attractions): Sorts the attractions by their opening times and alphabetically if times are the same. Parameters: n (int): The number of attractions. attractions (list of tuples): Each tuple contains the attraction name (str) and its opening time (int). Returns: list of str: A sorted list of attraction names. # Sort by opening time first, then by name alphabetically sorted_list = sorted(attractions, key=lambda x: (x[1], x[0])) # Extract only the names of the attractions sorted_names = [attraction[0] for attraction in sorted_list] return sorted_names"},{"question":"def has_consecutive_visits(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if there exists a category visited consecutively more than once. >>> has_consecutive_visits(2, [(5, [3, 4, 4, 1, 9]), (4, [1, 2, 1, 3])]) [\\"Yes\\", \\"No\\"] from typing import List, Tuple def test_no_consecutive_visits(): assert has_consecutive_visits(1, [(4, [1, 2, 1, 3])]) == [\\"No\\"] def test_single_consecutive_visits(): assert has_consecutive_visits(1, [(5, [3, 4, 4, 1, 9])]) == [\\"Yes\\"] def test_multiple_consecutive_visits(): assert has_consecutive_visits(1, [(6, [5, 5, 6, 6, 6, 7])]) == [\\"Yes\\"] def test_no_visits(): assert has_consecutive_visits(1, [(0, [])]) == [\\"No\\"] def test_multiple_test_cases(): assert has_consecutive_visits(3, [(5, [1, 1, 2, 3, 3]), (4, [3, 4, 5, 6]), (1, [9])]) == [\\"Yes\\", \\"No\\", \\"No\\"]","solution":"def has_consecutive_visits(T, test_cases): results = [] for i in range(T): N, visits = test_cases[i] consecutive = False for j in range(1, N): if visits[j] == visits[j - 1]: consecutive = True break results.append(\\"Yes\\" if consecutive else \\"No\\") return results"},{"question":"def minimum_knights_to_remove(n: int, k: int, knights_positions: List[Tuple[int, int]]) -> int: Calculate the minimum number of knights to remove from the chessboard such that no two knights can attack each other. Parameters: n (int): Size of the chessboard (n x n) k (int): Number of knights on the chessboard knights_positions (List[Tuple[int, int]]): A list of tuples where each tuple represents the position (x, y) of a knight on the chessboard Returns: int: The minimum number of knights to remove Examples: >>> minimum_knights_to_remove(5, 3, [(1, 2), (2, 4), (3, 1)]) 1 >>> minimum_knights_to_remove(6, 6, [(1, 1), (2, 3), (3, 5), (4, 2), (5, 4), (6, 6)]) 2 pass from collections import deque, defaultdict def parse_input(): n = int(input().strip()) k = int(input().strip()) knights_positions = [tuple(map(int, input().strip().split())) for _ in range(k)] return n, k, knights_positions # Example usage if __name__ == \\"__main__\\": n, k, knights_positions = parse_input() answer = minimum_knights_to_remove(n, k, knights_positions) print(answer)","solution":"from collections import deque, defaultdict # Directions a knight moves on a chessboard moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] def minimum_knights_to_remove(n, k, knights_positions): def bfs(u): # Breadth-first search d = [-1] * k d[u] = 0 q = deque([u]) while q: u = q.popleft() for v in adj[u]: if t[v] == -1: continue if d[t[v]] == -1: d[t[v]] = d[u] + 1 q.append(t[v]) return d def dfs(u): # Depth-first search to check for augmenting path for v in adj[u]: if t[v] == -1 or (d[t[v]] == d[u] + 1 and dfs(t[v])): t[v] = u return True return False adj = [[] for _ in range(k)] for i, (x1, y1) in enumerate(knights_positions): for j, (x2, y2) in enumerate(knights_positions): if i != j: for dx, dy in moves: if x1 + dx == x2 and y1 + dy == y2: adj[i].append(j) break t = [-1] * k matching_size = 0 for u in range(k): d = bfs(u) if dfs(u): matching_size += 1 return matching_size // 2 # Input parsing function def parse_input(): n = int(input().strip()) k = int(input().strip()) knights_positions = [tuple(map(int, input().strip().split())) for _ in range(k)] return n, k, knights_positions # Example usage if __name__ == \\"__main__\\": n, k, knights_positions = parse_input() answer = minimum_knights_to_remove(n, k, knights_positions) print(answer)"},{"question":"def trim_plants(n: int, p: List[int], g: List[int], l: List[int]) -> List[int]: Determine the number of plants of each type at the end of the day after they have been trimmed to specified limits. >>> trim_plants(4, [5, 10, 3, 8], [2, 1, 5, 3], [6, 12, 7, 10]) == [6, 11, 7, 10] >>> trim_plants(3, [3, 6, 9], [0, 0, 0], [5, 10, 15]) == [3, 6, 9] >>> trim_plants(2, [1, 3], [10, 5], [4, 6]) == [4, 6] >>> trim_plants(2, [4, 5], [2, 3], [10, 10]) == [6, 8] >>> trim_plants(1, [1], [0], [1]) == [1] >>> trim_plants(1, [1], [1], [2]) == [2] >>> trim_plants(1, [1], [2], [2]) == [2]","solution":"def trim_plants(n, p, g, l): result = [] for i in range(n): new_count = p[i] + g[i] # plants after growth if new_count > l[i]: new_count = l[i] # trim to limit result.append(new_count) return result"},{"question":"def lexicographically_smallest_string(S: str) -> str: Determine the lexicographically smallest string that can be obtained by moving any character to the beginning or end of the string any number of times. >>> lexicographically_smallest_string(\\"dcba\\") 'abcd' >>> lexicographically_smallest_string(\\"bca\\") 'abc' >>> lexicographically_smallest_string(\\"zyxwvutsrqponmlkjihgfedcba\\") 'abcdefghijklmnopqrstuvwxyz' # Implement the function here # Here are some test cases to validate the solution def test_lexicographically_smallest_string(): assert lexicographically_smallest_string(\\"dcba\\") == \\"abcd\\" assert lexicographically_smallest_string(\\"bca\\") == \\"abc\\" assert lexicographically_smallest_string(\\"zyxwvutsrqponmlkjihgfedcba\\") == \\"abcdefghijklmnopqrstuvwxyz\\" assert lexicographically_smallest_string(\\"a\\") == \\"a\\" assert lexicographically_smallest_string(\\"ab\\") == \\"ab\\" assert lexicographically_smallest_string(\\"ba\\") == \\"ab\\" assert lexicographically_smallest_string(\\"aaaa\\") == \\"aaaa\\" def test_lexicographically_smallest_string_with_repeating_characters(): assert lexicographically_smallest_string(\\"aabbcc\\") == \\"aabbcc\\" assert lexicographically_smallest_string(\\"ccbbbaa\\") == \\"aabbbcc\\" assert lexicographically_smallest_string(\\"abcdefgabcdefg\\") == \\"aabbccddeeffgg\\" def test_lexicographically_smallest_string_with_large_input(): input_str = \\"z\\" * 50000 + \\"a\\" * 50000 expected_output = \\"a\\" * 50000 + \\"z\\" * 50000 assert lexicographically_smallest_string(input_str) == expected_output","solution":"def lexicographically_smallest_string(S): Returns the lexicographically smallest string that can be obtained from S. return ''.join(sorted(S))"},{"question":"from typing import List, Tuple def shortest_path_with_reduction(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: You are given an undirected graph with n vertices and m edges. Each edge has a non-negative weight. The goal is to find the shortest path from vertex 1 to vertex n. However, due to some constraints, you can reduce the weight of each edge by at most 1 unit. Given the graph, compute the length of the shortest path from vertex 1 to vertex n after performing optimal edge reduction. If there is no path from vertex 1 to vertex n, return -1. Parameters: n (int): Number of vertices. m (int): Number of edges. edges (List[Tuple[int, int, int]]): List of edges where each edge is a tuple (u, v, w) indicating an edge between vertices u and v with weight w. Returns: int: The length of the shortest path from vertex 1 to vertex n after performing the optimal edge reduction or -1 if there is no path. >>> shortest_path_with_reduction(4, 4, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 4)]) 3 >>> shortest_path_with_reduction(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 4)]) 2 >>> shortest_path_with_reduction(3, 1, [(1, 2, 2)]) -1","solution":"import heapq def dijkstra_reduce_edges(graph, n): def dijkstra(source): dist = [float('inf')] * (n + 1) dist[source] = 0 pq = [(0, source)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(pq, (dist[v], v)) return dist # Initial Dijkstra run without reductions dist_from_start = dijkstra(1) dist_from_end = dijkstra(n) shortest_path = dist_from_start[n] # Try reducing each edge by 1 and recalculate the shortest path for u in range(1, n+1): for v, weight in graph[u]: if weight > 0: possible_shortest = dist_from_start[u] + weight - 1 + dist_from_end[v] shortest_path = min(shortest_path, possible_shortest) return shortest_path if shortest_path != float('inf') else -1 def shortest_path_with_reduction(n, m, edges): graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) return dijkstra_reduce_edges(graph, n)"},{"question":"def sum_if_gte_threshold(integers: List[int], threshold: int) -> int: Sums the first four integers in the list \`integers\` and returns the sum if it is greater than or equal to the value of \`threshold\`. Otherwise, returns 0. Parameters: integers (list): A list of integers. threshold (int): The threshold value. Returns: int: The sum if it's >= threshold, otherwise 0.","solution":"def sum_if_gte_threshold(integers, threshold): Sums the first four integers in the list \`integers\` and returns the sum if it is greater than or equal to the value of \`threshold\`. Otherwise, returns 0. Parameters: integers (list): A list of integers. threshold (int): The threshold value. Returns: int: The sum if it's >= threshold, otherwise 0. sum_of_integers = sum(integers[:4]) return sum_of_integers if sum_of_integers >= threshold else 0"},{"question":"from typing import List def process_queries(N: int, Q: int, S: str, queries: List[str]) -> List[str]: Process substring replacement and query requests: Args: - N: int: Length of the string S. - Q: int: Number of queries. - S: str: Initial string. - queries: List[str]: List of queries to process. Returns: - List[str]: results of the range queries. Example: >>> process_queries(5, 4, 'abcde', ['1 0 5', '0 3 a', '1 0 5', '1 1 4']) ['abcde', 'abcae', 'bca'] >>> process_queries(5, 1, 'abcde', ['1 0 5']) ['abcde'] pass def test_process_queries_single_replacement(): N = 5 Q = 1 S = \\"abcde\\" queries = [\\"0 3 a\\"] assert process_queries(N, Q, S, queries) == [] def test_process_queries_single_print(): N = 5 Q = 1 S = \\"abcde\\" queries = [\\"1 0 5\\"] assert process_queries(N, Q, S, queries) == [\\"abcde\\"] def test_process_queries_mixed_replacement_print(): N = 5 Q = 4 S = \\"abcde\\" queries = [\\"1 0 5\\", \\"0 3 a\\", \\"1 0 5\\", \\"1 1 4\\"] assert process_queries(N, Q, S, queries) == [\\"abcde\\", \\"abcae\\", \\"bca\\"] def test_process_queries_multiple_replacements(): N = 5 Q = 3 S = \\"abcde\\" queries = [\\"0 2 z\\", \\"0 4 y\\", \\"1 0 5\\"] assert process_queries(N, Q, S, queries) == [\\"abzdy\\"] def test_process_queries_with_edge_case(): N = 5 Q = 2 S = \\"abcde\\" queries = [\\"1 0 1\\", \\"1 4 5\\"] assert process_queries(N, Q, S, queries) == [\\"a\\", \\"e\\"] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) S = data[2] queries = data[3:] results = process_queries(N, Q, S, queries) for res in results: print(res)","solution":"def process_queries(N, Q, S, queries): result = [] s = list(S) for query in queries: parts = query.split() if parts[0] == '0': p = int(parts[1]) c = parts[2] s[p] = c elif parts[0] == '1': l = int(parts[1]) r = int(parts[2]) result.append(\\"\\".join(s)[l:r]) return result # Let's print the results to see behavior before adding unittest. if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) S = data[2] queries = data[3:] results = process_queries(N, Q, S, queries) for res in results: print(res)"},{"question":"def is_valid_id(ID: str) -> bool: Validates the ID based on the given criteria: 1. It must start with an uppercase letter. 2. It must end with a digit. 3. It must contain at least 8 characters. 4. It may contain only alphanumeric characters. >>> is_valid_id(\\"ABCd1234\\") == True >>> is_valid_id(\\"Abcdefg1\\") == True >>> is_valid_id(\\"abcdefg1\\") == False >>> is_valid_id(\\"ABCDEFGH\\") == False","solution":"import re def is_valid_id(ID): Validates the ID based on the given criteria: 1. It must start with an uppercase letter. 2. It must end with a digit. 3. It must contain at least 8 characters. 4. It may contain only alphanumeric characters. if len(ID) < 8: return False if not (ID[0].isupper() and ID[-1].isdigit()): return False if not ID.isalnum(): return False return True"},{"question":"def find_difference(arr: List[int], K: int) -> bool: Determines if there are two distinct indices i and j in the array such that the absolute difference between the elements at these indices is exactly K. Parameters: arr (list of int): The input array of integers. K (int): The target difference. Returns: bool: True if such indices exist, False otherwise. >>> find_difference([1, 5, 3, 4, 2], 3) True >>> find_difference([1, 2, 3, 4, 5], 7) False >>> find_difference([1, 2, 3, 4, 5], 0) False >>> find_difference([1, 1, 2, 2, 3, 3], 1) True >>> find_difference([1000000, 999999, 999998, 999997, 999996], 1) True >>> find_difference([10, 22, 10, 33, 40, 50, 60], 12) True","solution":"def find_difference(arr, K): Determines if there are two distinct indices i and j in the array such that the absolute difference between the elements at these indices is exactly K. Parameters: arr (list of int): The input array of integers. K (int): The target difference. Returns: bool: True if such indices exist, False otherwise. visited = set() for num in arr: if (num + K) in visited or (num - K) in visited: return True visited.add(num) return False"},{"question":"def find_books(n: int, books: List[Tuple[str, str, int, str]], q: int, queries: List[Tuple[str, str, int]]) -> str: Finds books that match the given search criteria. Parameters: - n: int - number of books in the library - books: List[Tuple[str, str, int, str]] - list of books with attributes title, author, year, and genre - q: int - number of search queries - queries: List[Tuple[str, str, int]] - list of search queries with author, genre, and year Returns: - str - titles of books that match the search criteria or \\"No matches found\\" if no books match, with each query's results separated by a blank line. Example: >>> n = 5 >>> books = [ >>> (\\"PrideAndPrejudice\\", \\"JaneAusten\\", 1813, \\"Romance\\"), >>> (\\"1984\\", \\"GeorgeOrwell\\", 1949, \\"Dystopian\\"), >>> (\\"ToKillAMockingbird\\", \\"HarperLee\\", 1960, \\"Fiction\\"), >>> (\\"TheGreatGatsby\\", \\"FScottFitzgerald\\", 1925, \\"Fiction\\"), >>> (\\"MobyDick\\", \\"HermanMelville\\", 1851, \\"Adventure\\") >>> ] >>> q = 3 >>> queries = [ >>> (\\"JaneAusten\\", \\"Romance\\", 1813), >>> (\\"GeorgeOrwell\\", \\"Dystopian\\", 1949), >>> (\\"JKRowling\\", \\"Fantasy\\", 1997) >>> ] >>> find_books(n, books, q, queries) 'PrideAndPrejudicenn1984nnNo matches found'","solution":"def find_books(n, books, q, queries): results = [] for query in queries: author, genre, year = query year = int(year) matches = [title for title, book_author, book_year, book_genre in books if book_author == author and book_genre == genre and book_year == year] if matches: results.append(\\"n\\".join(matches)) else: results.append(\\"No matches found\\") return \\"nn\\".join(results) # Example usage: # n = 5 # books = [ # (\\"PrideAndPrejudice\\", \\"JaneAusten\\", 1813, \\"Romance\\"), # (\\"1984\\", \\"GeorgeOrwell\\", 1949, \\"Dystopian\\"), # (\\"ToKillAMockingbird\\", \\"HarperLee\\", 1960, \\"Fiction\\"), # (\\"TheGreatGatsby\\", \\"FScottFitzgerald\\", 1925, \\"Fiction\\"), # (\\"MobyDick\\", \\"HermanMelville\\", 1851, \\"Adventure\\") # ] # q = 3 # queries = [ # (\\"JaneAusten\\", \\"Romance\\", 1813), # (\\"GeorgeOrwell\\", \\"Dystopian\\", 1949), # (\\"JKRowling\\", \\"Fantasy\\", 1997) # ] # print(find_books(n, books, q, queries))"},{"question":"def sort_coin_years(n: int, years: List[int]) -> List[int]: Sorts an array of integers representing years in ascending order. Parameters: n (int): The number of coins Mario has. years (list of int): A list of years on Mario's coins. Returns: list of int: The sorted list of years in ascending order. pass # Unit Test def test_sort_coin_years_multiple(): assert sort_coin_years(5, [1890, 2001, 1601, 2018, 1999]) == [1601, 1890, 1999, 2001, 2018] def test_sort_coin_years_three(): assert sort_coin_years(3, [2020, 2010, 1990]) == [1990, 2010, 2020] def test_sort_coin_years_single(): assert sort_coin_years(1, [1950]) == [1950] def test_sort_coin_years_already_sorted(): assert sort_coin_years(4, [1000, 1500, 2000, 2500]) == [1000, 1500, 2000, 2500] def test_sort_coin_years_reverse_sorted(): assert sort_coin_years(4, [2500, 2000, 1500, 1000]) == [1000, 1500, 2000, 2500] def test_sort_coin_years_mixed(): assert sort_coin_years(6, [1985, 1970, 1999, 2015, 2010, 1965]) == [1965, 1970, 1985, 1999, 2010, 2015]","solution":"def sort_coin_years(n, years): Sorts an array of integers representing years in ascending order. Parameters: n (int): The number of coins Mario has. years (list of int): A list of years on Mario's coins. Returns: list of int: The sorted list of years in ascending order. return sorted(years)"},{"question":"def count_beautiful_subarrays(n: int, arr: List[int]) -> int: Determine the number of beautiful subarrays in a given array of n distinct integers. A beautiful subarray contains at least two distinct integers and the sum of the elements of the subarray is even. Parameters: n (int): Number of elements in the array. arr (list): List of n distinct integers. Returns: int: Number of beautiful subarrays. >>> count_beautiful_subarrays(4, [1, 2, 3, 4]) 4 >>> count_beautiful_subarrays(3, [5, 8, 7]) 2 >>> count_beautiful_subarrays(2, [3, 5]) 0","solution":"def count_beautiful_subarrays(n, arr): This function counts the number of beautiful subarrays in a given array of n distinct integers, where a beautiful subarray contains at least two distinct integers and the sum of the elements is even. Parameters: n (int): Number of elements in the array. arr (list): List of n distinct integers. Returns: int: Number of beautiful subarrays. # Count even and odd numbers in the array even_count = sum(1 for x in arr if x % 2 == 0) odd_count = n - even_count # Calculating number of beautiful subarrays if odd_count == 0: # All numbers are even, so every pair is beautiful return (n * (n-1)) // 2 elif even_count == 0: # All numbers are odd, no beautiful subarrays possible return 0 else: # If there are both odd and even numbers return even_count * odd_count"},{"question":"from typing import Tuple def run_length_encode(s: str) -> str: Encode the input string s using run-length encoding. >>> run_length_encode(\\"aaabbbcccaaa\\") == \\"a3b3c3a3\\" >>> run_length_encode(\\"abcd\\") == \\"a1b1c1d1\\" pass def run_length_decode(encoded: str) -> str: Decode the run-length encoded string. >>> run_length_decode(\\"a3b3c3a3\\") == \\"aaabbbcccaaa\\" >>> run_length_decode(\\"a1b1c1d1\\") == \\"abcd\\" pass def encode_and_decode(s: str) -> Tuple[str, str]: Encode and then decode the string s using run-length encoding. >>> encode_and_decode(\\"aaabbbcccaaa\\") == (\\"a3b3c3a3\\", \\"aaabbbcccaaa\\") >>> encode_and_decode(\\"abcd\\") == (\\"a1b1c1d1\\", \\"abcd\\") pass # Unit tests def test_run_length_encode(): assert run_length_encode(\\"aaabbbcccaaa\\") == \\"a3b3c3a3\\" assert run_length_encode(\\"abcd\\") == \\"a1b1c1d1\\" assert run_length_encode(\\"aaaa\\") == \\"a4\\" assert run_length_encode(\\"abcdddcba\\") == \\"a1b1c1d3c1b1a1\\" assert run_length_encode(\\"a\\") == \\"a1\\" def test_run_length_decode(): assert run_length_decode(\\"a3b3c3a3\\") == \\"aaabbbcccaaa\\" assert run_length_decode(\\"a1b1c1d1\\") == \\"abcd\\" assert run_length_decode(\\"a4\\") == \\"aaaa\\" assert run_length_decode(\\"a1b1c1d3c1b1a1\\") == \\"abcdddcba\\" assert run_length_decode(\\"a1\\") == \\"a\\" def test_encode_and_decode(): assert encode_and_decode(\\"aaabbbcccaaa\\") == (\\"a3b3c3a3\\", \\"aaabbbcccaaa\\") assert encode_and_decode(\\"abcd\\") == (\\"a1b1c1d1\\", \\"abcd\\") assert encode_and_decode(\\"aaaa\\") == (\\"a4\\", \\"aaaa\\") assert encode_and_decode(\\"abcdddcba\\") == (\\"a1b1c1d3c1b1a1\\", \\"abcdddcba\\") assert encode_and_decode(\\"a\\") == (\\"a1\\", \\"a\\")","solution":"def run_length_encode(s): Encode the input string s using run-length encoding. encoded = \\"\\" i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoded += s[i] + str(count) i += 1 return encoded def run_length_decode(encoded): Decode the run-length encoded string. decoded = \\"\\" i = 0 while i < len(encoded): char = encoded[i] count = int(encoded[i + 1]) decoded += char * count i += 2 return decoded # Main function to encode and then decode the string def encode_and_decode(s): encoded = run_length_encode(s) decoded = run_length_decode(encoded) return encoded, decoded"},{"question":"def assess_lanterns(input_string: str) -> List[str]: This function assesses whether each lantern will stay afloat or sink based on their weight limits and the weights of items placed in them. Parameters: input_string (str): Input string containing datasets. Each dataset consists of the number of lanterns followed by each lantern's weight limit, number of items, and weights of items. The end of the input is indicated by a single line containing the integer 0. Returns: List[str]: For each dataset, outputs \\"SINK\\" if at least one lantern sinks and \\"FLOAT\\" if all lanterns stay afloat. pass # You can test your function with the following test cases: def test_single_lantern_sink(): input_data = \\"1n100 3 30 40 40n0n\\" result = assess_lanterns(input_data) assert result == [\\"SINK\\"] def test_single_lantern_float(): input_data = \\"1n100 3 30 40 20n0n\\" result = assess_lanterns(input_data) assert result == [\\"FLOAT\\"] def test_multiple_lanterns_one_sinks(): input_data = \\"2n100 3 30 40 20n80 2 50 40n0n\\" result = assess_lanterns(input_data) assert result == [\\"SINK\\"] def test_multiple_lanterns_all_float(): input_data = \\"2n100 3 30 40 20n80 2 30 40n0n\\" result = assess_lanterns(input_data) assert result == [\\"FLOAT\\"] def test_empty_dataset(): input_data = \\"0n\\" result = assess_lanterns(input_data) assert result == [] def test_mixed_datasets(): input_data = \\"2n100 3 30 40 20n80 2 50 40n1n90 4 10 20 30 20n0n\\" result = assess_lanterns(input_data) assert result == [\\"SINK\\", \\"FLOAT\\"]","solution":"def check_lanterns(datasets): This function determines whether each lantern will float or sink. Parameters: datasets (list of list): Each list is a dataset that contains integers representing the weight limit, number of items, and weights of the items for each lantern. Returns: list: A list with \\"FLOAT\\" if all lanterns stay afloat and \\"SINK\\" if at least one lantern sinks. results = [] for dataset in datasets: for lantern in dataset: weight_limit = lantern[0] number_of_items = lantern[1] item_weights = lantern[2:] if sum(item_weights) > weight_limit: results.append(\\"SINK\\") break else: results.append(\\"FLOAT\\") return results def process_input(input_string): Processes the input string into datasets that can be used by the check_lanterns function. Parameters: input_string (str): Multi-line input string containing the datasets as described in the problem. Returns: list of list: Formatted datasets to be processed. lines = input_string.strip().split('n') datasets = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break dataset = [] for _ in range(n): i += 1 dataset.append(list(map(int, lines[i].split()))) datasets.append(dataset) i += 1 return datasets def assess_lanterns(input_string): This function assesses the lanterns based on the provided input string. Parameters: input_string (str): Input string containing the datasets. Returns: list: The assessment results for each dataset. datasets = process_input(input_string) return check_lanterns(datasets)"},{"question":"def traffic_light_color(initial_color: str, minutes_passed: int) -> str: Determine the color of the traffic light after a certain number of minutes have passed. >>> traffic_light_color('Green', 2) == \\"Red\\" >>> traffic_light_color('Yellow', 5) == \\"Green\\" >>> traffic_light_color('Red', 8) == \\"Yellow\\" def solution(test_cases: List[Tuple[str, int]]) -> List[str]: Process the test cases and return the result colors. >>> solution([('Green', 2), ('Yellow', 5), ('Red', 8)]) == [\\"Red\\", \\"Green\\", \\"Yellow\\"] >>> solution([('Green', 0), ('Yellow', 1), ('Red', 1)]) == [\\"Green\\", \\"Red\\", \\"Green\\"]","solution":"def traffic_light_color(initial_color, minutes_passed): Determine the color of the traffic light after a certain number of minutes have passed. :param initial_color: str, initial color of the traffic light ('Green', 'Yellow', 'Red') :param minutes_passed: int, number of minutes passed :return: str, color of the traffic light after the given time # Mapping initial colors to their positions in the sequence. colors = ['Green', 'Yellow', 'Red'] initial_index = colors.index(initial_color) # Determine new position after n minutes. new_index = (initial_index + minutes_passed) % 3 # Return the color at the new position. return colors[new_index] def solution(test_cases): Process the test cases and return the result colors. :param test_cases: list of tuples, each containing (initial_color, minutes_passed) :return: list of str, colors of the traffic lights for each test case results = [] for initial_color, minutes_passed in test_cases: results.append(traffic_light_color(initial_color, minutes_passed)) return results"},{"question":"class Matrix: def __init__(self, n, m): self.n = n self.m = m self.matrix = [[0] * m for _ in range(n)] def update(self, r1, c1, r2, c2, x): Add x to all the elements in the submatrix with its top-left corner at (r1, c1) and bottom-right corner at (r2, c2). pass def getValue(self, r, c): Report the value of the element at position (r, c). pass def process_queries(n, m, queries): Process a list of queries on a n x m matrix where each query is either an update or getValue operation. Args: n (int): number of rows in the matrix. m (int): number of columns in the matrix. queries (list of tuples): queries to be performed, either (0, r1, c1, r2, c2, x) for update or (1, r, c) for value retrieval. Returns: list of int: the results of getValue queries. Unit Tests: >>> queries1 = [(0, 1, 1, 2, 2, 2), (0, 2, 2, 3, 3, 3), (1, 1, 1), (1, 2, 3)] >>> process_queries(3, 3, queries1) [2, 3] >>> queries2 = [(1, 1, 1), (0, 1, 1, 2, 2, 1), (1, 2, 2), (0, 1, 2, 2, 2, 2), (1, 2, 2)] >>> process_queries(2, 2, queries2) [0, 1, 3] >>> queries3 = [(1, 1, 1), (1, 2, 2)] >>> process_queries(2, 2, queries3) [0, 0] >>> queries4 = [(0, 1, 1, 1, 1, 5), (1, 1, 1)] >>> process_queries(2, 2, queries4) [5] >>> queries5 = [(0, 1, 1, 1, 1, 2), (0, 1, 1, 1, 1, 3), (1, 1, 1)] >>> process_queries(2, 2, queries5) [5] >>> queries6 = [(0, 1, 1, 3, 3, 10), (1, 2, 2), (1, 3, 3)] >>> process_queries(3, 3, queries6) [10, 10] pass","solution":"class Matrix: def __init__(self, n, m): self.n = n self.m = m self.matrix = [[0] * m for _ in range(n)] def update(self, r1, c1, r2, c2, x): for i in range(r1-1, r2): for j in range(c1-1, c2): self.matrix[i][j] += x def getValue(self, r, c): return self.matrix[r-1][c-1] def process_queries(n, m, queries): matrix = Matrix(n, m) result = [] for query in queries: if query[0] == 0: _, r1, c1, r2, c2, x = query matrix.update(r1, c1, r2, c2, x) elif query[0] == 1: _, r, c = query result.append(matrix.getValue(r, c)) return result"},{"question":"def is_schedule_consistent(schedule: List[Tuple[int, int]]) -> str: Determines if the train schedule is consistent, i.e., no trips overlap. Args: schedule (list of tuple): List of tuples where each tuple contains two integers \`start\` and \`end\` Returns: str: \\"YES\\" if the schedule is consistent, otherwise \\"NO\\" pass from is_schedule_consistent import is_schedule_consistent def test_schedule_consistent(): assert is_schedule_consistent([(1, 5), (6, 10), (11, 15)]) == \\"YES\\" def test_schedule_inconsistent_overlap(): assert is_schedule_consistent([(1, 5), (4, 10), (11, 15)]) == \\"NO\\" def test_schedule_inconsistent_with_single_trip(): assert is_schedule_consistent([(1, 5)]) == \\"YES\\" def test_schedule_inconsistent_with_adjacent_trips(): assert is_schedule_consistent([(1, 5), (5, 10), (10, 15)]) == \\"YES\\" def test_schedule_inconsistent_with_full_overlap(): assert is_schedule_consistent([(1, 10), (5, 15)]) == \\"NO\\" def test_schedule_inconsistent_with_partial_overlap(): assert is_schedule_consistent([(1, 5), (3, 7), (8, 10)]) == \\"NO\\" def test_schedule_inconsistent_with_same_times(): assert is_schedule_consistent([(1, 5), (5, 5)]) == \\"YES\\" def test_schedule_inconsistent_with_zero_start(): assert is_schedule_consistent([(0, 5), (6, 10), (11, 15)]) == \\"YES\\" def test_schedule_inconsistent_with_late_end(): assert is_schedule_consistent([(1, 5), (6, 10), (11, 24)]) == \\"YES\\"","solution":"def is_schedule_consistent(schedule): Determines if the train schedule is consistent, i.e., no trips overlap. Args: schedule (list of tuple): List of tuples where each tuple contains two integers \`start\` and \`end\` Returns: str: \\"YES\\" if the schedule is consistent, otherwise \\"NO\\" # Sort the schedule by the start time schedule.sort() for i in range(1, len(schedule)): # If the start time of the current trip is less than the end time of the previous trip, there is an overlap if schedule[i][0] < schedule[i - 1][1]: return \\"NO\\" return \\"YES\\""},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the largest substring of s that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 def process_test_cases(test_cases: List[str]) -> List[int]: Returns the results for all test cases. >>> process_test_cases([\\"eceba\\", \\"ccaabbb\\"]) [3, 5] >>> process_test_cases([\\"a\\", \\"ab\\", \\"abc\\", \\"abcabc\\"]) [1, 2, 2, 2]","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the largest substring of s that contains at most two distinct characters. n = len(s) if n < 3: return n left = 0 right = 0 hashmap = {} max_len = 2 while right < n: hashmap[s[right]] = right if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left + 1) right += 1 return max_len def process_test_cases(test_cases): Returns the results for all test cases. results = [] for s in test_cases: results.append(length_of_longest_substring_two_distinct(s)) return results"},{"question":"def determine_winner(n: int, grid: List[List[int]]) -> str: Determine the winner assuming both players play optimally. Args: - n: integer, size of the grid. - grid: list of lists, the n x n grid of integers. Returns: - \\"Player 1\\" if Player 1 has a winning strategy, otherwise \\"Player 2\\". pass # Unit Tests def test_small_odd_grid(): assert determine_winner(1, [[1]]) == \\"Player 1\\" assert determine_winner(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == \\"Player 1\\" def test_small_even_grid(): assert determine_winner(2, [[1, 2], [3, 4]]) == \\"Player 2\\" assert determine_winner(4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == \\"Player 2\\" def test_large_odd_grid(): n = 5 grid = [[i + j * n for i in range(1, n + 1)] for j in range(n)] assert determine_winner(n, grid) == \\"Player 1\\" def test_large_even_grid(): n = 6 grid = [[i + j * n for i in range(1, n + 1)] for j in range(n)] assert determine_winner(n, grid) == \\"Player 2\\" def test_random_grids(): assert determine_winner(1, [[1]]) == \\"Player 1\\" assert determine_winner(2, [[4, 5], [7, 8]]) == \\"Player 2\\" assert determine_winner(3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == \\"Player 1\\" assert determine_winner(4, [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) == \\"Player 2\\" assert determine_winner(5, [[2, 3, 4, 5, 6], [2, 3, 4, 5, 6], [2, 3, 4, 5, 6], [2, 3, 4, 5, 6], [2, 3, 4, 5, 6]]) == \\"Player 1\\" assert determine_winner(6, [[3, 4, 5, 6, 7, 8], [3, 4, 5, 6, 7, 8], [3, 4, 5, 6, 7, 8], [3, 4, 5, 6, 7, 8], [3, 4, 5, 6, 7, 8], [3, 4, 5, 6, 7, 8]]) == \\"Player 2\\"","solution":"def determine_winner(n, grid): Determine the winner assuming both players play optimally. Args: - n: integer, size of the grid. - grid: list of lists, the n x n grid of integers. Returns: - \\"Player 1\\" if Player 1 has a winning strategy, otherwise \\"Player 2\\". # A 1x1 grid means Player 2 automatically loses, so we check grid size: # The key insight is that if n is odd, Player 1 can force the game into an odd-sized grid each turn, leading # to a situation where Player 1 can handover the final 1x1 grid to Player 2. If n is even, the reverse happens. if n % 2 == 1: return \\"Player 1\\" else: return \\"Player 2\\""},{"question":"def can_achieve_target(n: int, initial_sizes: List[int], target_sizes: List[int], months: List[int]) -> str: Determine if each plant can achieve its corresponding target size after a given number of months. Parameters: n (int): Number of plants. initial_sizes (list): Initial sizes of the plants. target_sizes (list): Target sizes of the plants. months (list): Number of months available for each plant. Returns: str: \\"YES\\" if each plant can reach its target size in the given months, otherwise \\"NO\\". >>> can_achieve_target(3, [2, 3, 4], [4, 6, 16], [1, 2, 3]) 'YES' >>> can_achieve_target(3, [2, 3, 4], [5, 6, 16], [1, 2, 3]) 'NO'","solution":"def can_achieve_target(n, initial_sizes, target_sizes, months): Determine if each plant can achieve its corresponding target size after a given number of months. Parameters: n (int): Number of plants. initial_sizes (list): Initial sizes of the plants. target_sizes (list): Target sizes of the plants. months (list): Number of months available for each plant. Returns: str: \\"YES\\" if each plant can reach its target size in the given months, otherwise \\"NO\\". for i in range(n): initial_size = initial_sizes[i] target_size = target_sizes[i] month = months[i] # Check if we can reach target_size from initial_size within given month by doubling for _ in range(month): if initial_size * 2 <= target_size: initial_size *= 2 if initial_size != target_size: return \\"NO\\" return \\"YES\\""},{"question":"def preprocess_log(n): log = [0] * (n + 1) for i in range(2, n + 1): log[i] = log[i // 2] + 1 return log def preprocess_table(arr, n): log = preprocess_log(n) k = log[n] + 1 st = [[0] * k for _ in range(n)] for i in range(n): st[i][0] = arr[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 return st, log def range_max_query(st, log, l, r): j = log[r - l + 1] return max(st[l][j], st[r - (1 << j) + 1][j]) def process_queries(n, m, arr, queries): Given an array of integers and a list of queries, process the queries and return the results of MAX queries. Each query can either ask for the maximum value in a subarray or update an element of the array. Parameters: n (int): Number of elements in the initial array. m (int): Number of queries. arr (List[int]): The initial array of integers. queries (List[List[int]]): List of queries to process. Returns: List[int]: Results of MAX queries. arr = arr[:] results = [] st, log = preprocess_table(arr, n) for query in queries: t, l, r = query if t == 1: # MAX query results.append(range_max_query(st, log, l - 1, r - 1)) elif t == 2: # UPDATE query arr[l - 1] = r st, log = preprocess_table(arr, n) # rebuild the sparse table for simplicity (not optimal) return results # Reading input and processing queries def main(input_string): input_data = input_string.split('n') n, m = map(int, input_data[0].split()) arr = list(map(int, input_data[1].split())) queries = [list(map(int, line.split())) for line in input_data[2:] if line] results = process_queries(n, m, arr, queries) return \\"n\\".join(map(str, results)) # Unit tests def test_example_case(): assert main('5 4n3 1 4 1 5n1 1 3n2 2 6n1 1 3n2 5 2n') == '4n6' def test_single_element_array(): assert main('1 1n5n1 1 1n') == '5' def test_update_only(): assert main('3 2n1 2 3n2 1 10n2 2 20n') == '' def test_maximum_only(): assert main('5 2n1 2 3 4 5n1 1 5n1 2 4n') == '5n4' def test_update_then_max(): assert main('3 3n1 2 3n2 1 10n2 3 20n1 1 3n') == '20'","solution":"def preprocess_log(n): log = [0] * (n + 1) for i in range(2, n + 1): log[i] = log[i // 2] + 1 return log def preprocess_table(arr, n): log = preprocess_log(n) k = log[n] + 1 st = [[0] * k for _ in range(n)] for i in range(n): st[i][0] = arr[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 return st, log def range_max_query(st, log, l, r): j = log[r - l + 1] return max(st[l][j], st[r - (1 << j) + 1][j]) def process_queries(n, m, arr, queries): arr = arr[:] results = [] st, log = preprocess_table(arr, n) for query in queries: t, l, r = query if t == 1: # MAX query results.append(range_max_query(st, log, l - 1, r - 1)) elif t == 2: # UPDATE query arr[l - 1] = r st, log = preprocess_table(arr, n) # rebuild the sparse table for simplicity (not optimal) return results # Reading input and processing queries def main(input_string): input_data = input_string.split('n') n, m = map(int, input_data[0].split()) arr = list(map(int, input_data[1].split())) queries = [list(map(int, line.split())) for line in input_data[2:] if line] results = process_queries(n, m, arr, queries) return \\"n\\".join(map(str, results)) # Example usage: # input_string = '5 4n3 1 4 1 5n1 1 3n2 2 6n1 1 3n2 5 2n' # print(main(input_string))"},{"question":"from typing import List def most_frequent_dishes(n: int, k: int, orders: List[str]) -> List[str]: Determine the k most frequently ordered dishes. Parameters: n (int): Number of orders. k (int): Number of most frequent dishes to determine. orders (list of str): A list of strings where each string represents an order. Returns: list of str: The k most frequently ordered dish initials. >>> most_frequent_dishes(5, 3, [\\"ABC\\", \\"AC\\", \\"BC\\", \\"AB\\", \\"A\\"]) ['A', 'B', 'C'] >>> most_frequent_dishes(4, 2, [\\"ZZ\\", \\"ZY\\", \\"YZ\\", \\"YY\\"]) ['Y', 'Z'] >>> most_frequent_dishes(6, 4, [\\"AA\\", \\"BB\\", \\"CC\\", \\"DD\\", \\"AA\\", \\"BB\\"]) ['A', 'B', 'C', 'D'] pass def test_case_1(): assert most_frequent_dishes(5, 3, [\\"ABC\\", \\"AC\\", \\"BC\\", \\"AB\\", \\"A\\"]) == ['A', 'B', 'C'] def test_case_2(): assert most_frequent_dishes(4, 2, [\\"ZZ\\", \\"ZY\\", \\"YZ\\", \\"YY\\"]) == ['Y', 'Z'] def test_case_3(): assert most_frequent_dishes(6, 4, [\\"AA\\", \\"BB\\", \\"CC\\", \\"DD\\", \\"AA\\", \\"BB\\"]) == ['A', 'B', 'C', 'D'] def test_with_single_order(): assert most_frequent_dishes(1, 1, [\\"A\\"]) == ['A'] def test_tied_frequency(): assert most_frequent_dishes(3, 2, [\\"A\\", \\"B\\", \\"C\\"]) == ['A', 'B'] def test_all_same_dish(): assert most_frequent_dishes(3, 1, [\\"AAA\\", \\"AAA\\", \\"AAA\\"]) == ['A'] def test_more_dishes_than_k(): assert most_frequent_dishes(5, 2, [\\"ABCDE\\", \\"FGHIJ\\", \\"KLMNO\\", \\"PQRST\\", \\"UVWXY\\"]) == ['A', 'B']","solution":"from collections import Counter def most_frequent_dishes(n, k, orders): Determine the k most frequently ordered dishes. Parameters: n (int): Number of orders. k (int): Number of most frequent dishes to determine. orders (list of str): A list of strings where each string represents an order. Returns: list of str: The k most frequently ordered dish initials. dish_counter = Counter() # Counting each dish occurrence for order in orders: dish_counter.update(order) # Sorting by frequency and lexicographically most_common_dishes = sorted(dish_counter.items(), key=lambda x: (-x[1], x[0])) return [dish for dish, count in most_common_dishes[:k]] # Example usage: # Print the top k dishes from the provided orders if __name__ == \\"__main__\\": n = 5 k = 3 orders = [\\"ABC\\", \\"AC\\", \\"BC\\", \\"AB\\", \\"A\\"] result = most_frequent_dishes(n, k, orders) for dish in result: print(dish)"},{"question":"def recommend_friends(user_id, friendships): Recommends friends based on mutual connections. Parameters: user_id (int): The user ID of the target user. friendships (dict): A dictionary where the key is a user ID and the value is a list of user IDs representing the friends of that user. Returns: set: A set of user IDs representing the recommended friends. from solution import recommend_friends def test_recommend_friends_example(): user_id = 1 friendships = { 1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2, 6], 5: [3, 7, 8], 6: [4], 7: [5], 8: [5] } assert recommend_friends(user_id, friendships) == {4, 5} def test_recommend_friends_no_mutuals(): user_id = 1 friendships = { 1: [2, 3], 2: [1], 3: [1], } assert recommend_friends(user_id, friendships) == set() def test_recommend_friends_no_friends(): user_id = 1 friendships = { 1: [], 2: [3], 3: [2], } assert recommend_friends(user_id, friendships) == set() def test_recommend_friends_large_network(): user_id = 1 friendships = { 1: [2, 3, 10], 2: [1, 4, 5], 3: [1, 6], 4: [2], 5: [2], 6: [3, 7], 7: [6], 10: [1, 8, 9], 8: [10], 9: [10] } assert recommend_friends(user_id, friendships) == {4, 5, 6, 8, 9} def test_recommend_friends_self(): user_id = 2 friendships = { 1: [2], 2: [1, 3], 3: [2] } assert recommend_friends(user_id, friendships) == set()","solution":"def recommend_friends(user_id, friendships): Recommends friends based on mutual connections. Parameters: user_id (int): The user ID of the target user. friendships (dict): A dictionary where the key is a user ID and the value is a list of user IDs representing the friends of that user. Returns: set: A set of user IDs representing the recommended friends. direct_friends = set(friendships.get(user_id, [])) mutual_friends = set() for friend in direct_friends: for friend_of_friend in friendships.get(friend, []): if friend_of_friend != user_id and friend_of_friend not in direct_friends: mutual_friends.add(friend_of_friend) return mutual_friends"},{"question":"def sum_of_unique_elements(n: int, nums: List[int]) -> int: Returns the sum of all unique elements in the array. Args: n : int : length of the array nums : List[int] : the elements of the array Returns: int : the sum of unique elements Examples: >>> sum_of_unique_elements(5, [1, 2, 3, 2, 4]) 8 >>> sum_of_unique_elements(6, [1, 1, 1, 2, 2, 3]) 3","solution":"def sum_of_unique_elements(n, nums): Returns the sum of all unique elements in the array. Args: n : int : length of the array nums : List[int] : the elements of the array Returns: int : the sum of unique elements from collections import Counter count = Counter(nums) unique_sum = sum(num for num, freq in count.items() if freq == 1) return unique_sum"},{"question":"def max_elements_removed(n: int, arr: List[int]) -> int: Given an integer array \`arr\` of size \`n\`, find the maximum number of elements that can be removed using the operation of selecting three indices with the same value. >>> max_elements_removed(7, [1, 2, 2, 1, 2, 1, 3]) 6 >>> max_elements_removed(8, [4, 4, 4, 4, 4, 4, 4, 4]) 6","solution":"def max_elements_removed(n, arr): from collections import Counter # Count frequency of each element freq = Counter(arr) # Calculate the total number of elements that can be removed total_removed = sum((count // 3) * 3 for count in freq.values()) return total_removed"},{"question":"def count_unique_rectangles(x1, y1, x2, y2): Given two pairs of coordinates representing two opposite corners of a rectangle, returns the number of unique rectangles that can be formed with these points as two of their corners. >>> count_unique_rectangles(1, 2, 3, 4) 4 >>> count_unique_rectangles(0, 0, 2, 3) 6","solution":"def count_unique_rectangles(x1, y1, x2, y2): Given two pairs of coordinates representing two opposite corners of a rectangle, returns the number of unique rectangles that can be formed with these points as two of their corners. dx = abs(x2 - x1) dy = abs(y2 - y1) return (dx) * (dy)"},{"question":"def find_max_sum_increasing_subsequence(n: int, A: List[int]) -> List[int]: You are given an array A consisting of n integers. Your task is to find a subsequence B of A such that: 1. The length of B is at least 3. 2. B is a strictly increasing sequence. 3. The sum of the elements in B is maximized. If there are multiple subsequences that satisfy these conditions, return the one that appears first in A. If no such subsequence exists, return an empty sequence. >>> find_max_sum_increasing_subsequence(6, [1, 2, 3, 1, 2, 3]) [1, 2, 3] >>> find_max_sum_increasing_subsequence(5, [5, 4, 3, 2, 1]) [] from typing import List def test_find_max_sum_increasing_subsequence(): assert find_max_sum_increasing_subsequence(6, [1, 2, 3, 1, 2, 3]) == [1, 2, 3] assert find_max_sum_increasing_subsequence(5, [5, 4, 3, 2, 1]) == [] assert find_max_sum_increasing_subsequence(1, [1]) == [] assert find_max_sum_increasing_subsequence(2, [1, 2]) == [] assert find_max_sum_increasing_subsequence(5, [10, 9, 8, 7, 6]) == [] assert find_max_sum_increasing_subsequence(6, [1, 101, 2, 3, 100, 4]) == [1, 2, 3, 100] assert find_max_sum_increasing_subsequence(5, [5, 5, 5, 5, 5]) == [] assert find_max_sum_increasing_subsequence(5, [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert find_max_sum_increasing_subsequence(5, [5, 4, 3, 2, 1]) == [] assert find_max_sum_increasing_subsequence(5, [10**9, 10**9 - 1, 10**9 - 2, 10**9 - 3, 10**9 - 4]) == []","solution":"def find_max_sum_increasing_subsequence(n, A): if n < 3: return [] dp = [0] * n parent = [-1] * n dp[0] = A[0] for i in range(1, n): max_sum = 0 for j in range(i): if A[j] < A[i] and dp[j] > max_sum: max_sum = dp[j] parent[i] = j dp[i] = A[i] + max_sum max_value, max_index = max((dp[i], i) for i in range(n)) result = [] while max_index != -1: result.append(A[max_index]) max_index = parent[max_index] result.reverse() if len(result) < 3: return [] return result"},{"question":"def solve_bridge_networks(test_cases): Determine the minimum cost to construct the network of bridges that connects all the islands. Each test case consists of the number of islands, the number of possible bridges, and for each bridge, u (island 1), v (island 2) and w (cost). >>> test_cases = [(4, 6, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 3), (3, 4, 5), (1, 4, 4)])] >>> solve_bridge_networks(test_cases) [6] >>> test_cases = [(3, 3, [(1, 2, 5), (2, 3, 6), (1, 3, 7)])] >>> solve_bridge_networks(test_cases) [11] >>> test_cases = [(2, 1, [(1, 2, 3)])] >>> solve_bridge_networks(test_cases) [3] >>> test_cases = [(5, 7, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 3, 3), (2, 4, 5), (1, 5, 6)])] >>> solve_bridge_networks(test_cases) [10] >>> test_cases = [(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)])] >>> solve_bridge_networks(test_cases) [6] >>> test_cases = [(4, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 2)])] >>> solve_bridge_networks(test_cases) [-1]","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_cost_to_connect_islands(n, bridges): # Sort all the edges in non-decreasing order of their weight bridges = sorted(bridges, key=lambda item: item[2]) parent = list(range(n)) rank = [0] * n mst_edges = 0 mst_cost = 0 for u, v, w in bridges: root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: mst_cost += w mst_edges += 1 union(parent, rank, root_u, root_v) if mst_edges == n - 1: break if mst_edges != n - 1: return -1 return mst_cost def solve_bridge_networks(test_cases): results = [] for n, m, bridges in test_cases: results.append(minimum_cost_to_connect_islands(n, bridges)) return results"},{"question":"def total_fruits(n: int) -> int: Calculate the total number of fruits generated by the first n trees in the Fibonacci forest. >>> total_fruits(1) == 1 >>> total_fruits(2) == 2 >>> total_fruits(5) == 12 >>> total_fruits(10) == 143","solution":"def total_fruits(n): if n == 1: return 1 elif n == 2: return 2 fib1, fib2 = 1, 1 total = fib1 + fib2 for _ in range(3, n + 1): fib_n = fib1 + fib2 total += fib_n fib1, fib2 = fib2, fib_n return total"},{"question":"def find_final_position(T, cases): Determine the final position of the robot after executing a series of moves. Arguments: T -- number of test cases cases -- a list of test cases, each containing: - a tuple with the starting position (sx, sy), number of moves (n), and grid dimension (m) - a list of moves, where each move is a string (e.g., 'U3', 'R2') Returns: A list of strings, each string representing the final coordinates of the robot for each test case >>> T = 2 >>> cases = [ ... [(1, 1, 3, 5), ['R3', 'U2', 'L1']], ... [(2, 4, 4, 6), ['D2', 'R1', 'U3', 'L1']] ... ] >>> find_final_position(T, cases) ['Case #1: 3 3', 'Case #2: 2 5']","solution":"def find_final_position(T, cases): results = [] for t in range(T): sx, sy, n, m = cases[t][0] moves = cases[t][1] x, y = sx, sy for move in moves: direction = move[0] steps = int(move[1:]) if direction == 'U': y = min(y + steps, m) elif direction == 'D': y = max(y - steps, 1) elif direction == 'L': x = max(x - steps, 1) elif direction == 'R': x = min(x + steps, m) results.append(f\\"Case #{t+1}: {x} {y}\\") return results"},{"question":"def max_series(n: int, pages: List[int]) -> int: Returns the maximum number of series that can be formed from the given books. Each series is defined by a unique page count. :param n: The number of books. :param pages: A list of integers representing the number of pages in each book. :return: The maximum number of series. >>> max_series(6, [120, 250, 300, 400, 450, 500]) == 6 >>> max_series(5, [100, 200, 300, 400, 500]) == 5 >>> max_series(4, [110, 210, 310, 410]) == 4 >>> max_series(3, [100, 100, 100]) == 1 >>> max_series(6, [100, 100, 200, 200, 300, 300]) == 3 >>> max_series(2, [90, 90]) == 1 >>> max_series(7, [120, 130, 120, 140, 150, 130, 160]) == 5 >>> max_series(1, [500]) == 1 def test_max_series(): # Example test cases assert max_series(6, [120, 250, 300, 400, 450, 500]) == 6 assert max_series(5, [100, 200, 300, 400, 500]) == 5 assert max_series(4, [110, 210, 310, 410]) == 4 # Additional test cases assert max_series(3, [100, 100, 100]) == 1 assert max_series(6, [100, 100, 200, 200, 300, 300]) == 3 assert max_series(2, [90, 90]) == 1 assert max_series(7, [120, 130, 120, 140, 150, 130, 160]) == 5 assert max_series(1, [500]) == 1","solution":"def max_series(n, pages): Returns the maximum number of series that can be formed from the given books. Each series is defined by a unique page count. :param n: The number of books. :param pages: A list of integers representing the number of pages in each book. :return: The maximum number of series. page_set = set(pages) return len(page_set)"},{"question":"def num_unique_paths(m, n): Returns the number of unique paths in an m by n grid starting from the top-left corner moving only to the right or down to the bottom-right corner. >>> num_unique_paths(2, 2) 2 >>> num_unique_paths(3, 2) 3 >>> num_unique_paths(2, 3) 3 def unique_paths_multiple_datasets(datasets): Processes multiple datasets to find the number of unique paths for each m x n grid. Returns: List of results, one result for each dataset. >>> unique_paths_multiple_datasets([(2, 2), (3, 2), (2, 3)]) [2, 3, 3] >>> unique_paths_multiple_datasets([(1, 1), (1, 2), (2, 1), (3, 3)]) [1, 1, 1, 6] >>> unique_paths_multiple_datasets([(4, 4), (2, 2), (5, 5)]) [20, 2, 70]","solution":"def num_unique_paths(m, n): Returns the number of unique paths in an m by n grid starting from the top-left corner moving only to the right or down to the bottom-right corner. # Create a 2D array to store the number of paths up to each cell dp = [[1] * n for _ in range(m)] # Fill the array using dynamic programming for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def unique_paths_multiple_datasets(datasets): Processes multiple datasets to find the number of unique paths for each m x n grid. Returns: List of results, one result for each dataset. results = [] for m, n in datasets: results.append(num_unique_paths(m, n)) return results"},{"question":"def can_robots_meet(H: int, W: int, N: int, positions: List[Tuple[int, int]]) -> str: Determine if it's possible for all robots to meet at the same cell eventually. >>> can_robots_meet(4, 4, 2, [(1, 1), (4, 4)]) \\"YES\\" >>> can_robots_meet(3, 3, 3, [(1, 1), (1, 3), (3, 3)]) \\"YES\\" >>> can_robots_meet(5, 5, 3, [(1, 1), (3, 5), (4, 3)]) \\"NO\\"","solution":"def can_robots_meet(H, W, N, positions): # Calculate Manhattan Distance def manhattan_distance(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) # Check if target cell (i, j) can serve as a meeting point for target_x in range(1, H + 1): for target_y in range(1, W + 1): max_distance = max(manhattan_distance(x, y, target_x, target_y) for x, y in positions) if all(manhattan_distance(x, y, target_x, target_y) == max_distance for x, y in positions): return \\"YES\\" return \\"NO\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() H = int(data[0]) W = int(data[1]) N = int(data[2]) positions = [] for idx in range(N): x = int(data[3 + 2 * idx]) y = int(data[4 + 2 * idx]) positions.append((x, y)) print(can_robots_meet(H, W, N, positions))"},{"question":"from typing import List def min_path_cost(n: int, m: int, grid: List[List[int]]) -> int: Determines the minimum path cost from the top-left to the bottom-right corner of a grid. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : a 2D list with non-negative integers representing the grid costs Returns: int : the minimum cost to traverse from (0,0) to (n-1,m-1) Examples: >>> min_path_cost(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_cost(2, 2, [ ... [1, 2], ... [1, 1] ... ]) 3 >>> min_path_cost(4, 4, [ ... [1, 3, 1, 2], ... [4, 3, 2, 3], ... [1, 5, 1, 1], ... [9, 8, 1, 2] ... ]) 11 pass # Test cases to verify the solution def test_min_path_cost_3x3(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_cost(3, 3, grid) == 7 def test_min_path_cost_2x2(): grid = [ [1, 2], [1, 1] ] assert min_path_cost(2, 2, grid) == 3 def test_min_path_cost_4x4(): grid = [ [1, 3, 1, 2], [4, 3, 2, 3], [1, 5, 1, 1], [9, 8, 1, 2] ] assert min_path_cost(4, 4, grid) == 11 def test_min_path_cost_single_row(): grid = [ [1, 2, 3, 4] ] assert min_path_cost(1, 4, grid) == 10 def test_min_path_cost_single_column(): grid = [ [1], [2], [3], [4] ] assert min_path_cost(4, 1, grid) == 10 def test_min_path_cost_large_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_path_cost(3, 3, grid) == 21","solution":"def min_path_cost(n, m, grid): # Create a dp array to store the minimum path cost to each cell dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1] # Example usage grid_3x3 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_cost(3, 3, grid_3x3)) # Output: 7"},{"question":"def longest_contiguous_subarray(n: int, arr: List[int]) -> int: Finds the length of the longest contiguous subarray that consists of only one unique integer. Parameters: n (int): The length of the array. arr (List[int]): The list of integers. Returns: int: The length of the longest contiguous subarray with all elements equal. Examples: >>> longest_contiguous_subarray(8, [2, 2, 3, 3, 3, 2, 2, 2]) 3 >>> longest_contiguous_subarray(6, [1, 1, 1, 1, 1, 1]) 6 from typing import List # Unit tests def test_longest_contiguous_subarray(): assert longest_contiguous_subarray(8, [2, 2, 3, 3, 3, 2, 2, 2]) == 3 assert longest_contiguous_subarray(6, [1, 1, 1, 1, 1, 1]) == 6 assert longest_contiguous_subarray(5, [1, 2, 2, 2, 3]) == 3 assert longest_contiguous_subarray(1, [1]) == 1 assert longest_contiguous_subarray(0, []) == 0 assert longest_contiguous_subarray(4, [-1, -1, -1, -1]) == 4 assert longest_contiguous_subarray(7, [1, 1, 2, 2, 3, 3, 3]) == 3 def test_edge_cases(): assert longest_contiguous_subarray(2, [1, 2]) == 1 assert longest_contiguous_subarray(3, [3, 3, 3]) == 3 assert longest_contiguous_subarray(5, [5, 5, 5, 5, 5]) == 5 assert longest_contiguous_subarray(6, [4, 4, 4, 2, 2, 2]) == 3","solution":"def longest_contiguous_subarray(n, arr): Finds the length of the longest contiguous subarray that consists of only one unique integer. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] == arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def min_operations_to_make_healthy(n: int, s: str) -> int: Returns the minimum number of operations required to make all apples healthy. Parameters: n (int): The number of apples. s (str): A string of length n where each character is 'H' or 'R'. Returns: int: Minimum number of operations required to make all apples healthy. >>> min_operations_to_make_healthy(5, 'HRRRH') 2 >>> min_operations_to_make_healthy(6, 'HHRRHH') 1 >>> min_operations_to_make_healthy(8, 'RRRHRRRR') 2","solution":"def min_operations_to_make_healthy(n, s): Returns the minimum number of operations required to make all apples healthy. Parameters: n (int): The number of apples. s (str): A string of length n where each character is 'H' or 'R'. Returns: int: Minimum number of operations required to make all apples healthy. # Split the string based on 'H' changes to 'R' or 'R' changes to 'H' from re import findall segments = findall(r'H+|R+', s) # Count the number of 'R' segments r_count = sum(1 for segment in segments if segment[0] == 'R') # The minimum number of operations is the count of 'R' segments return r_count"},{"question":"import heapq def dijkstra(n: int, m: int, s: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determine the minimum delivery time for the truck to reach each intersection from its starting point s. Parameters: n (int): Number of intersections. m (int): Number of roads. s (int): Starting intersection. roads (List[Tuple[int, int, int]]): List of roads represented as tuples (u, v, t) where u is the starting intersection, v is the destination intersection, and t is the travel time. Returns: List[int]: Minimum times in seconds needed to reach each intersection from the starting point s. If an intersection cannot be reached, return -1 for that intersection. Example: >>> dijkstra(4, 5, 1, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (2, 4, 3), (3, 4, 1)]) [0, 4, 2, 3] >>> dijkstra(3, 3, 1, [(1, 2, 5), (2, 3, 2), (1, 3, 10)]) [0, 5, 7] # Your code here def test_dijkstra_simple_case(): n, m, s = 4, 5, 1 roads = [(1, 2, 4), (1, 3, 2), (2, 3, 3), (2, 4, 3), (3, 4, 1)] assert dijkstra(n, m, s, roads) == [0, 4, 2, 3] def test_dijkstra_example_two(): n, m, s = 3, 3, 1 roads = [(1, 2, 5), (2, 3, 2), (1, 3, 10)] assert dijkstra(n, m, s, roads) == [0, 5, 7] def test_dijkstra_unreachable_node(): n, m, s = 3, 2, 1 roads = [(1, 2, 5), (2, 3, 2)] assert dijkstra(n, m, s, roads) == [0, 5, 7] def test_dijkstra_all_intersections_reachable(): n, m, s = 5, 7, 1 roads = [(1, 2, 2), (1, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3), (2, 3, 1), (5, 1, 1)] assert dijkstra(n, m, s, roads) == [0, 2, 3, 4, 7] def test_dijkstra_single_road(): n, m, s = 2, 1, 1 roads = [(1, 2, 5)] assert dijkstra(n, m, s, roads) == [0, 5]","solution":"import heapq def dijkstra(n, m, s, roads): graph = {i: [] for i in range(1, n+1)} for u, v, t in roads: graph[u].append((v, t)) min_times = {i: float('inf') for i in range(1, n+1)} min_times[s] = 0 pq = [(0, s)] while pq: current_time, u = heapq.heappop(pq) if current_time > min_times[u]: continue for v, t in graph[u]: time = current_time + t if time < min_times[v]: min_times[v] = time heapq.heappush(pq, (time, v)) return [min_times[i] if min_times[i] != float('inf') else -1 for i in range(1, n+1)]"},{"question":"def process_queries(data: List[int], queries: List[Tuple[int, int, str]]) -> List[int]: Process a list of queries on a dataset containing integers. Each query is a tuple containing two integers and a string representing the type of query: - \\"sum\\": Calculate the sum of integers within the range. - \\"unique\\": Determine the number of unique integers within the range. - \\"max\\": Find the maximum integer within the range. Args: data (List[int]): A list of integers. queries (List[Tuple[int, int, str]]): A list of tuples where each tuple contains two integers and a string. Returns: List[int]: A list of integers where each integer is the result of the corresponding query. Example: >>> data = [1, 2, 3, 2, 1, 4, 5] >>> queries = [(1, 3, \\"sum\\"), (2, 5, \\"unique\\"), (1, 7, \\"max\\")] >>> process_queries(data, queries) [6, 3, 5]","solution":"def process_queries(data, queries): results = [] for l, r, qtype in queries: sub_array = data[l-1:r] if qtype == \\"sum\\": results.append(sum(sub_array)) elif qtype == \\"unique\\": results.append(len(set(sub_array))) elif qtype == \\"max\\": results.append(max(sub_array)) return results"},{"question":"def find_best_engineer(participants): Finds the participant with the highest total score. If there's a tie, the participant with the lower number wins. >>> find_best_engineer([[1, 90, 85, 85], [2, 70, 80, 100], [3, 100, 80, 80]]) (1, 260) >>> find_best_engineer([[1, 80, 90, 90], [2, 100, 80, 80]]) (1, 260) >>> find_best_engineer([[1, 100, 100, 60], [2, 90, 85, 85]]) (1, 260) >>> find_best_engineer([[1, 90]]) (1, 90) >>> find_best_engineer([]) (inf, -1)","solution":"def find_best_engineer(participants): max_total_score = -1 winner_number = float('inf') for participant in participants: total_score = sum(participant[1:]) if total_score > max_total_score or (total_score == max_total_score and participant[0] < winner_number): max_total_score = total_score winner_number = participant[0] return (winner_number, max_total_score)"},{"question":"def longest_substring_with_k_distinct_characters(k: int, s: str) -> int: Find the length of the longest substring with exactly k distinct characters. Parameters: k (int): The exact number of distinct characters required. s (str): The string in which we need to find the substring. Returns: int: The length of the longest substring with exactly k distinct characters. >>> longest_substring_with_k_distinct_characters(2, \\"abcba\\") 3 >>> longest_substring_with_k_distinct_characters(3, \\"aabacbebebe\\") 7 >>> longest_substring_with_k_distinct_characters(1, \\"aaaa\\") 4 pass import pytest def test_longest_substring_with_k_distinct_characters_case_1(): assert longest_substring_with_k_distinct_characters(2, \\"abcba\\") == 3 def test_longest_substring_with_k_distinct_characters_case_2(): assert longest_substring_with_k_distinct_characters(3, \\"aabacbebebe\\") == 7 def test_longest_substring_with_k_distinct_characters_case_3(): assert longest_substring_with_k_distinct_characters(1, \\"aaaa\\") == 4 def test_longest_substring_with_k_distinct_characters_edge_case_1(): assert longest_substring_with_k_distinct_characters(1, \\"a\\") == 1 def test_longest_substring_with_k_distinct_characters_edge_case_2(): assert longest_substring_with_k_distinct_characters(2, \\"a\\") == 0 def test_longest_substring_with_k_distinct_characters_empty_string(): assert longest_substring_with_k_distinct_characters(1, \\"\\") == 0 def test_longest_substring_with_k_distinct_characters_all_unique(): assert longest_substring_with_k_distinct_characters(4, \\"abcdef\\") == 4 def test_longest_substring_with_k_distinct_characters_repeated_patterns(): assert longest_substring_with_k_distinct_characters(2, \\"ababababa\\") == 9","solution":"def longest_substring_with_k_distinct_characters(k, s): Returns the length of the longest substring with exactly k distinct characters. Parameters: k (int): The exact number of distinct characters required. s (str): The string in which we need to find the substring. Returns: int: The length of the longest substring with exactly k distinct characters. from collections import defaultdict window_start = 0 max_length = 0 char_frequency = defaultdict(int) # Slide through the string with a window for window_end in range(len(s)): # Add the current character to the frequency map char_frequency[s[window_end]] += 1 # Shrink the sliding window until we have exactly 'k' distinct characters while len(char_frequency) > k: char_frequency[s[window_start]] -= 1 if char_frequency[s[window_start]] == 0: del char_frequency[s[window_start]] window_start += 1 # At this point, we know we have exactly 'k' distinct characters if len(char_frequency) == k: max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"class StringCollection: def __init__(self, initial_strings): self.strings = initial_strings def add(self, string): Add a string to the collection. pass def count_with_prefix(self, prefix): Return the number of strings in the collection that start with the given prefix. >>> sc = StringCollection([\\"apple\\", \\"appetizer\\", \\"application\\"]) >>> sc.count_with_prefix(\\"app\\") 3 pass def process_queries(n, initial_strings, q, queries): Process a series of queries on the collection of strings. >>> process_queries(3, [\\"apple\\", \\"appetizer\\", \\"application\\"], 5, [\\"ADD apex\\", \\"COUNT app\\", \\"ADD appaloosa\\", \\"COUNT ape\\", \\"COUNT app\\"]) [3, 1, 4] >>> process_queries(3, [\\"test\\", \\"testing\\", \\"tested\\"], 2, [\\"COUNT test\\", \\"ADD tester\\"]) [3] pass def main(): Main function to process input and output. pass","solution":"class StringCollection: def __init__(self, initial_strings): self.strings = initial_strings def add(self, string): self.strings.append(string) def count_with_prefix(self, prefix): return sum(s.startswith(prefix) for s in self.strings) def process_queries(n, initial_strings, q, queries): sc = StringCollection(initial_strings) results = [] for query in queries: if query.startswith(\\"ADD\\"): _, string = query.split(maxsplit=1) sc.add(string) elif query.startswith(\\"COUNT\\"): _, prefix = query.split(maxsplit=1) results.append(sc.count_with_prefix(prefix)) return results def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) initial_strings = [data[i] for i in range(1, n + 1)] q = int(data[n + 1]) queries = data[n + 2 : n + 2 + q] results = process_queries(n, initial_strings, q, queries) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def find_gcd(arr: List[int]) -> int: Calculate the Greatest Common Divisor (GCD) of an array of numbers. The GCD of a set of numbers is the largest positive integer that divides all the numbers in the set without leaving a remainder. Args: arr (List[int]): An array of integers. Returns: int: The GCD of the array. Examples: >>> find_gcd([2, 4, 6]) 2 >>> find_gcd([3, 9, 27, 81]) 3 >>> find_gcd([17, 31]) 1 pass if __name__ == \\"__main__\\": # Example test cases print(find_gcd([2, 4, 6])) # Output: 2 print(find_gcd([3, 9, 27, 81])) # Output: 3 print(find_gcd([17, 31])) # Output: 1 def test_find_gcd_example_1(): assert find_gcd([2, 4, 6]) == 2 def test_find_gcd_example_2(): assert find_gcd([3, 9, 27, 81]) == 3 def test_find_gcd_example_3(): assert find_gcd([17, 31]) == 1 def test_find_gcd_single_element(): assert find_gcd([42]) == 42 def test_find_gcd_all_primes(): assert find_gcd([11, 13, 17]) == 1 def test_find_gcd_mixed(): assert find_gcd([24, 60, 36]) == 12 def test_find_gcd_duplicates(): assert find_gcd([14, 14, 14]) == 14","solution":"from math import gcd from functools import reduce def find_gcd(arr): Returns the GCD of an array of integers. return reduce(gcd, arr)"},{"question":"def assign_rooms(n: int, m: int, c: int, preferences: List[List[int]]) -> Tuple[int, List[int]]: Assigns each contestant to one of their preferred rooms such that the number of satisfied contestants is maximized while respecting the capacity constraint. :param n: Number of contestants :param m: Number of rooms :param c: Capacity of each room :param preferences: List of lists, where each sublist contains the preferred rooms of a contestant :return: A tuple containing the maximum number of satisfied contestants and a list of assigned rooms Examples: >>> assign_rooms(5, 3, 2, [[1, 2], [2, 3], [1, 2, 3], [3], [2]]) (5, [1, 2, 1, 3, 2]) >>> assign_rooms(4, 2, 2, [[1], [1], [2], [2]]) (4, [1, 1, 2, 2]) >>> assign_rooms(5, 1, 2, [[1], [1], [1], [1], [1]]) (2, [1, 1, -1, -1, -1])","solution":"def assign_rooms(n, m, c, preferences): Assigns each contestant to one of their preferred rooms such that the number of satisfied contestants is maximized while respecting the capacity constraint. :param n: Number of contestants :param m: Number of rooms :param c: Capacity of each room :param preferences: List of lists, where each sublist contains the preferred rooms of a contestant :return: A tuple containing the maximum number of satisfied contestants and a list of assigned rooms # Room capacities capacities = [0] * (m + 1) # Room numbers are 1-indexed, so we use m+1 # Result array to store assigned room for each contestant assigned_rooms = [-1] * n # Sorting contestants by the number of their preferences (contestants with fewer preferences first) sorted_contestants = sorted( range(n), key=lambda i: len(preferences[i]) ) satisfied_count = 0 for i in sorted_contestants: pref_list = preferences[i] for room in pref_list: if capacities[room] < c: capacities[room] += 1 assigned_rooms[i] = room satisfied_count += 1 break return satisfied_count, assigned_rooms"},{"question":"import itertools def is_prime(num): Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def has_prime_pair_sum_permutation(nums): Check if there exists a permutation of nums such that the sum of every consecutive pair is prime. >>> has_prime_pair_sum_permutation([2, 5, 6, 2]) False >>> has_prime_pair_sum_permutation([3, 5, 8]) True pass def permutation_sum_checker(datasets): Determine if a permutation exists for each dataset such that the sum of every consecutive pair of integers is prime. >>> permutation_sum_checker([(4, [2, 5, 6, 2]), (3, [3, 5, 8]), (2, [4, 7])]) [False, True, True] pass","solution":"import itertools def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def has_prime_pair_sum_permutation(nums): Check if there exists a permutation of nums such that the sum of every consecutive pair is prime. for permutation in itertools.permutations(nums): if all(is_prime(permutation[i] + permutation[i + 1]) for i in range(len(permutation) - 1)): return True return False def permutation_sum_checker(datasets): results = [] for dataset in datasets: n, nums = dataset results.append(has_prime_pair_sum_permutation(nums)) return results"},{"question":"def max_energy_points(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum number of magical energy points that can be collected from top-left to bottom-right. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid with magical energy points :return: Maximum number of energy points that can be collected For example: >>> max_energy_points(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_energy_points(1, 5, [[2, 3, 4, 5, 6]]) 20","solution":"def max_energy_points(n, m, grid): Returns the maximum number of magical energy points that can be collected from top-left to bottom-right. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid with magical energy points :return: Maximum number of energy points that can be collected # Create a 2D dp array to store the maximum energy points collected up to each cell dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1] # A helper function to parse inputs and run the solution. def run_max_energy_points(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) grid = [] for i in range(n): grid.append([int(data[i * m + j + 2]) for j in range(m)]) print(max_energy_points(n, m, grid))"},{"question":"def total_unique_identifiers(m: int, n: int) -> int: Returns the total number of unique identifiers possible given the constraints. >>> total_unique_identifiers(1, 1) == 26 >>> total_unique_identifiers(1, 2) == 702 >>> total_unique_identifiers(1, 3) == 18278 >>> total_unique_identifiers(2, 2) == 676 >>> total_unique_identifiers(1, 26) == sum(26**i for i in range(1, 27))","solution":"def total_unique_identifiers(m, n): Returns the total number of unique identifiers possible given the constraints. total = 0 for length in range(m, n + 1): total += 26 ** length return total"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Find the largest possible rectangular area of crops where all cells are fertile (represented by 1s). Each cell in the grid is either fertile (1) or infertile (0). >>> maximalRectangle([ ... [1, 0, 1, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 0], ... [1, 1, 0, 0] ... ]) 4 >>> maximalRectangle([ ... [1, 0, 0, 1, 0], ... [1, 0, 1, 1, 1], ... [0, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 0, 0] ... ]) 6 >>> maximalRectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 :param matrix: List of List of integers representing the grid :return: The largest possible area of a rectangle that contains only fertile cells (1s) from typing import List def test_maximalRectangle_1(): matrix = [ [1, 0, 1, 1], [1, 1, 1, 1], [0, 1, 1, 0], [1, 1, 0, 0] ] assert maximalRectangle(matrix) == 4 def test_maximalRectangle_2(): matrix = [ [1, 0, 0, 1, 0], [1, 0, 1, 1, 1], [0, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 0, 0] ] assert maximalRectangle(matrix) == 6 def test_maximalRectangle_3(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert maximalRectangle(matrix) == 0 def test_maximalRectangle_4(): matrix = [ [1, 1, 1], [1, 1, 1] ] assert maximalRectangle(matrix) == 6 def test_maximalRectangle_5(): matrix = [ [0] ] assert maximalRectangle(matrix) == 0 def test_maximalRectangle_6(): matrix = [ [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 0, 0], [1, 1, 1, 1] ] assert maximalRectangle(matrix) == 4 def test_maximalRectangle_7(): matrix = [ [1] ] assert maximalRectangle(matrix) == 1","solution":"def maximalRectangle(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (n + 1) for i in range(m): for j in range(n): if matrix[i][j] == 1: heights[j] += 1 else: heights[j] = 0 stack = [-1] for k in range(n + 1): while heights[k] < heights[stack[-1]]: h = heights[stack.pop()] w = k - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(k) return max_area"},{"question":"def visibility_points(n: int, heights: List[int]) -> List[int]: Calculate and return the visibility points for each person in the queue based on the heights. >>> visibility_points(5, [4, 3, 2, 6, 1]) [0, 1, 2, 0, 4] >>> visibility_points(4, [5, 5, 5, 5]) [0, 1, 2, 3] # Test cases: # from solution import visibility_points # def test_visibility_points_example1(): # assert visibility_points(5, [4, 3, 2, 6, 1]) == [0, 1, 2, 0, 4] # def test_visibility_points_example2(): # assert visibility_points(4, [5, 5, 5, 5]) == [0, 1, 2, 3] # def test_visibility_points_single_person(): # assert visibility_points(1, [7]) == [0] # def test_visibility_points_two_people_taller_in_front(): # assert visibility_points(2, [6, 2]) == [0, 1] # def test_visibility_points_tallest_at_end(): # assert visibility_points(4, [2, 2, 1, 3]) == [0, 1, 2, 0] # def test_visibility_points_no_taller_in_front(): # assert visibility_points(3, [1, 2, 3]) == [0, 0, 0]","solution":"def visibility_points(n, heights): points = [0] * n for i in range(1, n): for j in range(0, i): if heights[j] >= heights[i]: points[i] += 1 return points # Example usage: # print(visibility_points(5, [4, 3, 2, 6, 1])) # Output: [0, 1, 2, 0, 4] # print(visibility_points(4, [5, 5, 5, 5])) # Output: [0, 1, 2, 3]"},{"question":"def calculate_spell_powers(N: int, T: int, spell_powers: List[int]) -> List[int]: Calculate the spell powers of all wizards after T seconds. Parameters: - N: int, number of wizards - T: int, number of seconds after which to determine spell powers - spell_powers: list of int, initial spell powers of the wizards. Returns: - list of int, spell powers of all wizards after T seconds. import pytest def test_example_1(): assert calculate_spell_powers(4, 1, [1, 2, 3, 4]) == [7, 6, 9, 8] def test_example_2(): assert calculate_spell_powers(5, 2, [1, 2, 3, 4, 5]) == [24, 23, 27, 31, 30] def test_single_second(): assert calculate_spell_powers(3, 1, [1, 1, 1]) == [3, 3, 3] def test_multiple_seconds(): assert calculate_spell_powers(3, 2, [1, 1, 1]) == [9, 9, 9] def test_large_numbers(): assert calculate_spell_powers(2, 1, [1000000, 1000000]) == [3000000, 3000000] def test_non_uniform_powers(): assert calculate_spell_powers(4, 1, [1, 1, 1, 1000]) == [1002, 3, 1002, 1002]","solution":"def calculate_spell_powers(N, T, spell_powers): Calculate the spell powers of all wizards after T seconds. Parameters: - N: int, number of wizards - T: int, number of seconds after which to determine spell powers - spell_powers: list of int, initial spell powers of the wizards Returns: - list of int, spell powers of all wizards after T seconds. for _ in range(T): new_spell_powers = [0] * N for i in range(N): left = spell_powers[(i - 1) % N] right = spell_powers[(i + 1) % N] new_spell_powers[i] = spell_powers[i] + left + right spell_powers = new_spell_powers return spell_powers"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Helps Tina determine the number of distinct palindromic substrings in the given string s. Parameters: ----------- s : str A string consisting of lowercase English alphabets Returns: -------- int The number of distinct palindromic substrings in s Examples: >>> count_distinct_palindromic_substrings(\\"ababa\\") 5 >>> count_distinct_palindromic_substrings(\\"abc\\") 3 Test Cases: def test_single_character_string(): assert count_distinct_palindromic_substrings(\\"a\\") == 1 def test_all_different_characters(): assert count_distinct_palindromic_substrings(\\"abc\\") == 3 def test_repeating_characters(): assert count_distinct_palindromic_substrings(\\"aaa\\") == 3 def test_mixed_characters(): assert count_distinct_palindromic_substrings(\\"ababa\\") == 5 def test_longer_palindromes(): assert count_distinct_palindromic_substrings(\\"abacdfgdcaba\\") == 7 def test_no_palindromes(): assert count_distinct_palindromic_substrings(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 def test_all_same_character(): assert count_distinct_palindromic_substrings(\\"bbbb\\") == 4","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the given string s. def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() for i in range(len(s)): for j in range(i, len(s)): substring = s[i:j+1] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings)"},{"question":"def process_queries(S: str, queries: List[str]) -> List[str]: Process a list of queries on the string S. >>> S = \\"abcde\\" >>> queries = [\\"2 3\\", \\"1 3 z\\", \\"2 3\\"] >>> process_queries(S, queries) [\\"abc\\", \\"abz\\"] >>> S = \\"algorithm\\" >>> queries = [\\"2 2\\", \\"1 8 z\\", \\"1 1 z\\", \\"2 2\\"] >>> process_queries(S, queries) [\\"al\\", \\"go\\"]","solution":"def process_queries(S, queries): result = [] S = list(S) # Convert string to list for mutability for query in queries: parts = query.split() if parts[0] == '1': i = int(parts[1]) - 1 # Convert to zero-based index c = parts[2] S[i] = c elif parts[0] == '2': l = int(parts[1]) min_substring = None for i in range(len(S) - l + 1): substring = ''.join(S[i:i+l]) # Create substring of length l if min_substring is None or substring < min_substring: min_substring = substring result.append(min_substring) return result"},{"question":"from typing import List, Tuple def optimal_game_sequence(sequence: List[int]) -> Tuple[int, int]: Simulate a game played by Alice and Bob who take turns removing elements from a sequence. Each player plays optimally to maximize their score. Args: sequence (List[int]): List of integers representing the sequence of numbers. Returns: Tuple[int, int]: Final scores of Alice and Bob respectively. >>> optimal_game_sequence([1, 2, 3, 4]) (6, 4) >>> optimal_game_sequence([4, 4, 4]) (8, 4) pass # Implementation here def game_results(test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Determine the final scores of Alice and Bob for multiple test cases. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the length of the sequence and the sequence itself. Returns: List[Tuple[int, int]]: List of tuple scores for each test case. >>> game_results([(4, [1, 2, 3, 4]), (3, [4, 4, 4])]) [(6, 4), (8, 4)] pass # Implementation here","solution":"def optimal_game_sequence(sequence): n = len(sequence) dp = [[0] * n for _ in range(n)] sum_sequence = [[0] * n for _ in range(n)] for i in range(n): sum_sequence[i][i] = sequence[i] for j in range(i + 1, n): sum_sequence[i][j] = sum_sequence[i][j - 1] + sequence[j] for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 if i == j: dp[i][j] = sequence[i] else: dp[i][j] = sum_sequence[i][j] - min(dp[i + 1][j], dp[i][j - 1]) alice_score = dp[0][n - 1] bob_score = sum(sequence) - alice_score return alice_score, bob_score def game_results(test_cases): results = [] for test_case in test_cases: n, sequence = test_case if n > 0: results.append(optimal_game_sequence(sequence)) return results"},{"question":"def arrange_books(n: int, heights: List[int]) -> Tuple[str, List[int]]: Determine if it is possible to arrange the books such that no two books of the same height are adjacent to each other. If possible, return such an arrangement. Otherwise, return \\"NO\\". Parameters: n (int): Number of books heights (list of int): The heights of the books Returns: str: \\"YES\\" if arrangement is possible, else \\"NO\\" list of int: The arrangement of book heights (if possible) from typing import List, Tuple def test_example_1(): n = 6 heights = [4, 4, 5, 5, 3, 3] result = arrange_books(n, heights) assert result[0] == \\"YES\\" assert result[1] def test_example_2(): n = 3 heights = [2, 2, 2] result = arrange_books(n, heights) assert result[0] == \\"NO\\" assert result[1] == [] def test_example_3(): n = 5 heights = [1, 2, 1, 3, 3] result = arrange_books(n, heights) assert result[0] == \\"YES\\" assert result[1] def test_one_book(): n = 1 heights = [1] result = arrange_books(n, heights) assert result[0] == \\"YES\\" assert result[1] == [1] def test_two_books_same_height(): n = 2 heights = [2, 2] result = arrange_books(n, heights) assert result[0] == \\"NO\\" assert result[1] == [] def test_two_books_different_height(): n = 2 heights = [1, 2] result = arrange_books(n, heights) assert result[0] == \\"YES\\" assert set(result[1]) == {1, 2} def test_multiple_heights(): n = 7 heights = [3, 3, 1, 2, 2, 1, 1] result = arrange_books(n, heights) assert result[0] == \\"YES\\" assert result[1] def test_large_number_of_books(): n = 100000 heights = [i % 1000 + 1 for i in range(n)] result = arrange_books(n, heights) assert result[0] == \\"YES\\" assert len(result[1]) == n","solution":"from collections import Counter def arrange_books(n, heights): Determine if it is possible to arrange the books such that no two books of the same height are adjacent to each other. If possible, return such an arrangement. Otherwise, return \\"NO\\". Parameters: n (int): Number of books heights (list of int): The heights of the books Returns: str: \\"YES\\" if arrangement is possible, else \\"NO\\" list of int: The arrangement of book heights (if possible) count = Counter(heights) max_freq = max(count.values()) if max_freq > (n + 1) // 2: return \\"NO\\", [] sorted_heights = sorted(count.items(), key=lambda x: -x[1]) arranged = [0] * n index = 0 for height, freq in sorted_heights: for _ in range(freq): arranged[index] = height index += 2 if index >= n: index = 1 return \\"YES\\", arranged # Example usage: # n = 6 # heights = [4, 4, 5, 5, 3, 3] # print(arrange_books(n, heights)) # Output: (\\"YES\\", [4, 5, 4, 3, 5, 3])"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): Inserts an element into the BST pass def delete(self, root, key): Deletes an element from the BST pass def leftRotate(self, z): Performs left rotation pass def rightRotate(self, z): Performs right rotation pass def getHeight(self, root): Returns the height of the node pass def getBalance(self, root): Returns the balance factor of the node pass def getMinValueNode(self, root): Returns the node with the minimum value pass def getMaxValueNode(self, root): Returns the node with the maximum value pass def perform_operations(operations): Performs a list of operations on the BST and returns the results of findMin and findMax operations >>> operations = [\\"insert 8\\", \\"insert 3\\", \\"insert 10\\", \\"findMin\\", \\"findMax\\", \\"insert 14\\", \\"delete 10\\", \\"findMax\\", \\"insert 1\\", \\"findMin\\", \\"end\\"] >>> perform_operations(operations) [3, 10, 14, 1] >>> operations = [\\"insert 5\\", \\"findMin\\", \\"findMax\\", \\"end\\"] >>> perform_operations(operations) [5, 5] >>> operations = [\\"insert 5\\", \\"insert 3\\", \\"insert 8\\", \\"delete 5\\", \\"findMin\\", \\"findMax\\", \\"end\\"] >>> perform_operations(operations) [3, 8] >>> operations = [\\"findMin\\", \\"findMax\\", \\"end\\"] >>> perform_operations(operations) [None, None] >>> operations = [\\"insert 5\\", \\"insert 5\\", \\"findMin\\", \\"findMax\\", \\"end\\"] >>> perform_operations(operations) [5, 5] pass","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): if not root: return TreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.key: return self.rightRotate(root) if balance < -1 and key > root.right.key: return self.leftRotate(root) if balance > 1 and key > root.left.key: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.key: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.getMinValueNode(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and self.getBalance(root.left) >= 0: return self.rightRotate(root) if balance > 1 and self.getBalance(root.left) < 0: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) <= 0: return self.leftRotate(root) if balance < -1 and self.getBalance(root.right) > 0: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def getMinValueNode(self, root): if root is None or root.left is None: return root return self.getMinValueNode(root.left) def getMaxValueNode(self, root): if root is None or root.right is None: return root return self.getMaxValueNode(root.right) def perform_operations(operations): tree = AVLTree() root = None result = [] for operation in operations: if operation.startswith(\\"insert\\"): _, key = operation.split() root = tree.insert(root, int(key)) elif operation.startswith(\\"delete\\"): _, key = operation.split() root = tree.delete(root, int(key)) elif operation == \\"findMin\\": min_node = tree.getMinValueNode(root) result.append(min_node.key if min_node else None) elif operation == \\"findMax\\": max_node = tree.getMaxValueNode(root) result.append(max_node.key if max_node else None) elif operation == \\"end\\": break return result"},{"question":"def all_sales_successful(sales): Determines if there is any day where all sales were successful. Parameters: sales (list): List of 7 integers representing sales (1 for successful, 0 for unsuccessful) Returns: str: \\"Yes\\" if there is a day where all sales were successful, otherwise \\"No\\" Examples: >>> all_sales_successful([1, 1, 1, 1, 1, 1, 1]) 'Yes' >>> all_sales_successful([0, 0, 0, 0, 0, 0, 0]) 'No' >>> all_sales_successful([1, 0, 1, 0, 1, 0, 1]) 'No' >>> all_sales_successful([1, 1, 1, 0, 1, 0, 1]) 'No' >>> all_sales_successful([0, 0, 1, 1, 1, 1, 1]) 'No'","solution":"def all_sales_successful(sales): Determines if there is any day where all sales were successful. Parameters: sales (list): List of 7 integers representing sales (1 for successful, 0 for unsuccessful) Returns: str: \\"Yes\\" if there is a day where all sales were successful, otherwise \\"No\\" # Check if all values in the list are 1, which means a day with all successful sales if all(sale == 1 for sale in sales): return \\"Yes\\" return \\"No\\""},{"question":"def calculate_product_with_digit_sum(input_string: str) -> int: Calculates the required output as described in the prompt. Given a multiline string of integers, this function calculates the product of all integers grouped by line and multiplies the products of the sums of their digits. It returns the sum of these two products. Parameters: input_string (str): The input string containing integers separated by spaces, spread across multiple lines. Returns: int: The calculated result. Examples: >>> calculate_product_with_digit_sum(\\"3 4 5\\") 72 >>> calculate_product_with_digit_sum(\\"3 4 5n6 2\\") 816 return # your solution here def test_single_line(): input_data = \\"3 4 5\\" expected_output = 60 + (3+4+5) assert calculate_product_with_digit_sum(input_data) == expected_output def test_multiple_lines(): input_data = \\"3 4 5n6 2\\" # Product of each line: (3*4*5) = 60, (6*2) = 12 # Products multiplied: 60 * 12 = 720 # Sum of digits in line 1: 3+4+5 = 12, line 2: 6+2 = 8 # Products of sums: 12 * 8 = 96 # Final result: 720 + 96 = 816 expected_output = 720 + 96 assert calculate_product_with_digit_sum(input_data) == expected_output def test_multiple_integer_lines(): input_data = \\"2 2n2 2\\" # Product of each line: 4 and 4 # Products multiplied: 4 * 4 = 16 # Sums of digits: 4 and 4 # Products of sums: 4 * 4 = 16 # Final result: 16 + 16 = 32 expected_output = 16 + 16 assert calculate_product_with_digit_sum(input_data) == expected_output def test_large_inputs(): input_data = \\"9 9n9 9n9 9\\" # Product of each line: 81 * 81 * 81 # Products multiplied: 81 * 81 * 81 = 531441 # Sums of digits: 18 * 18 * 18 # Products of sums: 18 * 18 * 18 = 5832 # Final result: 531441 + 5832 = 537273 expected_output = 531441 + 5832 assert calculate_product_with_digit_sum(input_data) == expected_output def test_single_integer_per_line(): input_data = \\"7n8n9\\" # Product of each line: 7, 8, 9 # Products multiplied: 7 * 8 * 9 = 504 # Sums of digits: 7, 8, 9 # Products of sums: 7 * 8 * 9 = 504 # Final result: 504 + 504 = 1008 expected_output = 504 + 504 assert calculate_product_with_digit_sum(input_data) == expected_output","solution":"def calculate_product_with_digit_sum(input_string): Calculates the required output as described in the prompt. Parameters: input_string (str): The input string containing integers separated by spaces, spread across multiple lines. Returns: int: The calculated result. lines = input_string.strip().split('n') total_product = 1 digit_sum_product = 1 for line in lines: integers = map(int, line.split()) line_product = 1 line_digit_sum = 0 for num in integers: line_product *= num line_digit_sum += sum(map(int, str(num))) # Sum of digits of the number total_product *= line_product digit_sum_product *= line_digit_sum final_result = total_product + digit_sum_product return final_result"},{"question":"def largest_square_subgrid(n: int, m: int, grid: List[str]) -> int: Given a grid of n * m size with '.' representing empty space and '*' representing a star, this function returns the size of the largest square subgrid that does not contain any stars. >>> largest_square_subgrid(5, 5, [\\".....\\", \\"..*..\\", \\".....\\", \\".....\\", \\"...*.\\"]) 3 >>> largest_square_subgrid(3, 4, [\\"****\\", \\"*..*\\", \\"****\\"]) 1","solution":"def largest_square_subgrid(n, m, grid): Given a grid of n * m size with '.' representing empty space and '*' representing a star, this function returns the size of the largest square subgrid that does not contain any stars. if n == 0 or m == 0: return 0 # Create a DP array initialized to 0 dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 # Top row or leftmost column can only have single cell squares else: # Update the value to the minimum of the surrounding top, left, and top-left values plus one dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: Checks if the given number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True pass def can_choose_prime_subsequence(sequence: List[int]) -> bool: Determines if there's any non-empty subsequence with a prime sum. >>> can_choose_prime_subsequence([1, 2, 3]) True >>> can_choose_prime_subsequence([4, 6, 8]) False >>> can_choose_prime_subsequence([1, 4, 6, 3]) True >>> can_choose_prime_subsequence([2, 7]) True pass def game_winner(sequence: List[int]) -> str: Determines the winner of a single game given the sequence. >>> game_winner([1, 2, 3]) 'Bob' >>> game_winner([4, 6, 8]) 'Alice' >>> game_winner([1, 4, 6, 3]) 'Bob' >>> game_winner([2, 7]) 'Bob' pass def main(games: List[Tuple[int, List[int]]]) -> List[str]: Determines the winner for each game in a list of games. >>> games = [(3, [1, 2, 3]), (4, [1, 4, 6, 3])] >>> main(games) ['Bob', 'Bob'] >>> games = [(2, [2, 7]), (3, [4, 6, 8])] >>> main(games) ['Bob', 'Alice'] pass","solution":"def is_prime(num): Checks if the given number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_choose_prime_subsequence(sequence): Determines if there's any non-empty subsequence with a prime sum. n = len(sequence) # Check all possible subsequences for i in range(n): for j in range(i, n): if is_prime(sum(sequence[i:j+1])): return True return False def game_winner(sequence): Determines the winner of a single game given the sequence. if can_choose_prime_subsequence(sequence): return \\"Bob\\" else: return \\"Alice\\" def main(games): results = [] for n, sequence in games: results.append(game_winner(sequence)) return results"},{"question":"from typing import List def is_permutation_in_string(S: str, T: str) -> str: Determine if T has a permutation that appears as a substring in S. >>> is_permutation_in_string(\\"adcba\\", \\"abc\\") \\"YES\\" >>> is_permutation_in_string(\\"hello\\", \\"world\\") \\"NO\\"","solution":"from collections import Counter def is_permutation_in_string(S, T): len_s, len_t = len(S), len(T) if len_t > len_s: return \\"NO\\" t_counter = Counter(T) window_counter = Counter(S[:len_t]) if window_counter == t_counter: return \\"YES\\" for i in range(len_t, len_s): window_counter[S[i]] += 1 window_counter[S[i - len_t]] -= 1 if window_counter[S[i - len_t]] == 0: del window_counter[S[i - len_t]] if window_counter == t_counter: return \\"YES\\" return \\"NO\\""},{"question":"def is_possible_to_sort(N: int, K: int, A: List[int]) -> str: Determine if it's possible to make the array sorted in non-descending order after exactly K reverse operations. Args: - N (int): The number of integers in the array. - K (int): The number of operations. - A (List[int]): The array of integers. Returns: - str: \\"YES\\" if possible to sort the array, otherwise \\"NO\\". >>> is_possible_to_sort(5, 1, [4, 3, 2, 1, 5]) \\"NO\\" >>> is_possible_to_sort(4, 2, [4, 2, 3, 1]) \\"YES\\" from typing import List def test_case_1(): assert is_possible_to_sort(5, 1, [4, 3, 2, 1, 5]) == \\"NO\\" def test_case_2(): assert is_possible_to_sort(4, 2, [4, 2, 3, 1]) == \\"YES\\" def test_case_3(): assert is_possible_to_sort(1, 0, [1]) == \\"YES\\" def test_case_4(): assert is_possible_to_sort(5, 0, [1, 2, 3, 4, 5]) == \\"YES\\" def test_case_5(): assert is_possible_to_sort(5, 1, [5, 4, 3, 2, 1]) == \\"NO\\" def test_case_6(): assert is_possible_to_sort(6, 3, [1, 3, 2, 5, 4, 6]) == \\"YES\\" def test_case_7(): assert is_possible_to_sort(3, 2, [3, 1, 2]) == \\"YES\\" def test_case_8(): assert is_possible_to_sort(3, 1, [3, 1, 2]) == \\"NO\\"","solution":"def is_possible_to_sort(N, K, A): if K == 0: return \\"YES\\" if A == sorted(A) else \\"NO\\" if sorted(A) == A: return \\"YES\\" if K == 1: return \\"NO\\" # For K >= 2, we can essentially swap any two elements by choosing specific subarrays. return \\"YES\\""},{"question":"class Node: def __init__(self, val): self.val = val self.left = None self.right = None def build_tree(preorder): nodes = {} for u, lv, rv in preorder: if u not in nodes: nodes[u] = Node(u) node = nodes[u] if lv != -1: if lv not in nodes: nodes[lv] = Node(lv) node.left = nodes[lv] if rv != -1: if rv not in nodes: nodes[rv] = Node(rv) node.right = nodes[rv] return nodes[preorder[0][0]] def findSubtreeMinMax(root): Find the minimum and maximum values in the subtree of each node in the binary tree. >>> input_data = \\"5n1 2 3n2 4 -1n3 -1 5n4 -1 -1n5 -1 -1\\" >>> preorder = process_input(input_data) >>> root = build_tree(preorder) >>> result = findSubtreeMinMax(root) >>> expected_output = {1: (1, 5), 2: (2, 4), 3: (3, 5), 4: (4, 4), 5: (5, 5)} >>> result == expected_output True pass def convert_output(dic): output = [] for key in sorted(dic.keys()): output.append(f\\"{key} {dic[key]}\\") return \\"n\\".join(output) def process_input(input_data): lines = input_data.strip().split('n') n = int(lines[0]) preorder = [] for i in range(1, n + 1): u, lv, rv = map(int, lines[i].split()) preorder.append((u, lv, rv)) return preorder","solution":"class Node: def __init__(self, val): self.val = val self.left = None self.right = None def build_tree(preorder): nodes = {} for u, lv, rv in preorder: if u not in nodes: nodes[u] = Node(u) node = nodes[u] if lv != -1: if lv not in nodes: nodes[lv] = Node(lv) node.left = nodes[lv] if rv != -1: if rv not in nodes: nodes[rv] = Node(rv) node.right = nodes[rv] return nodes[preorder[0][0]] def findSubtreeMinMax(root): def dfs(node): if not node: return float('inf'), float('-inf') left_min, left_max = dfs(node.left) right_min, right_max = dfs(node.right) subtree_min = min(node.val, left_min, right_min) subtree_max = max(node.val, left_max, right_max) min_max[node.val] = (subtree_min, subtree_max) return subtree_min, subtree_max min_max = {} dfs(root) return min_max def convert_output(dic): output = [] for key in sorted(dic.keys()): output.append(f\\"{key} {dic[key]}\\") return \\"n\\".join(output) def process_input(input_data): lines = input_data.strip().split('n') n = int(lines[0]) preorder = [] for i in range(1, n + 1): u, lv, rv = map(int, lines[i].split()) preorder.append((u, lv, rv)) return preorder input_data = 5 1 2 3 2 4 -1 3 -1 5 4 -1 -1 5 -1 -1 preorder = process_input(input_data) root = build_tree(preorder) result = findSubtreeMinMax(root) output = convert_output(result) print(output)"},{"question":"def can_transform(original, required): Determine if the original array can be transformed into the required array using zero or more swaps of any two elements. Args: original (list of int): The original array. required (list of int): The desired array. Returns: str: \\"YES\\" if it is possible to transform the original array into the required array, otherwise \\"NO\\". pass # Write your logic here # Unit Test def test_can_transform_identical_arrays(): assert can_transform([1, 2, 3], [1, 2, 3]) == \\"YES\\" def test_can_transform_reversed_array(): assert can_transform([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == \\"YES\\" def test_can_transform_same_elements_with_different_sequence(): assert can_transform([1, 2, 2, 3], [3, 2, 2, 1]) == \\"YES\\" def test_can_transform_insufficient_elements(): assert can_transform([1, 2, 3], [1, 2, 2]) == \\"NO\\" def test_can_transform_different_elements(): assert can_transform([1, 2, 3], [4, 5, 6]) == \\"NO\\" def test_can_transform_single_element(): assert can_transform([1], [1]) == \\"YES\\" def test_can_transform_multiple_repeated_elements(): assert can_transform([1, 1, 1, 2, 2], [1, 1, 2, 2, 1]) == \\"YES\\"","solution":"def can_transform(original, required): Determine if the original array can be transformed into the required array using zero or more swaps of any two elements. Args: original (list of int): The original array. required (list of int): The desired array. Returns: str: \\"YES\\" if it is possible to transform the original array into the required array, otherwise \\"NO\\". return \\"YES\\" if sorted(original) == sorted(required) else \\"NO\\""},{"question":"def process_operations(R: int, initial_loads: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Processes the given operations on the routes and returns the results of query operations. >>> process_operations(5, [10, 20, 15, 25, 30], [(0, 2, 5), (2, 1, 3), (1, 4, 10), (2, 4, 5), (0, 3, 10), (2, 1, 5)]) [25, 30, 30] >>> process_operations(3, [100, 200, 300], [(0, 1, 50), (1, 2, 100), (2, 1, 2), (0, 3, 20), (2, 2, 3)]) [150, 320]","solution":"def process_operations(R, initial_loads, operations): Processes the given operations on the routes and returns the results of query operations. results = [] # Adjusting to 0-based index for easier array manipulation routes = initial_loads[:] for operation in operations: op_code = operation[0] if op_code == 0: # Add w to route i _, i, w = operation routes[i - 1] += w elif op_code == 1: # Remove w from route i _, i, w = operation routes[i - 1] -= w elif op_code == 2: # Query maximum load between l and r _, l, r = operation max_load = max(routes[l - 1: r]) results.append(max_load) return results"},{"question":"def unique_paths(n: int, m: int, grid: List[List[str]]) -> int: A game consists of a grid with n × m cells. Some of the cells contain obstacles, while others are free to walk on. You start at the top-left cell of the grid and your goal is to reach the bottom-right cell. Each move can either go down or to the right. You are tasked with finding the number of unique paths from the start to the goal while avoiding obstacles. >>> unique_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> unique_paths(3, 3, [['#', '#', '.'], ['#', '#', '#'], ['.', '.', '.']]) 0 >>> unique_paths(1, 3, [['.', '.', '.']]) 1","solution":"def unique_paths(n, m, grid): # Create a 2D list to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Starting point if grid[0][0] == '.': dp[0][0] = 1 else: return 0 # No path if the start or goal is blocked # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # The bottom-right cell has the number of unique paths return dp[n-1][m-1]"},{"question":"def are_balanceable(A: List[int], B: List[int]) -> str: Determines if arrays A and B are balanceable. >>> are_balanceable([1, 2, 3, 4], [4, 1, 2, 3]) == \\"YES\\" >>> are_balanceable([1, 2, 3], [6, 0, 1]) == \\"NO\\" def prefix_sums_of_size(arr: List[int], target: int) -> bool: Returns whether there exists a prefix sum equal to target.","solution":"def are_balanceable(A, B): Determines if arrays A and B are balanceable. total_A = sum(A) total_B = sum(B) if total_A == total_B: return \\"YES\\" difference = total_A - total_B if abs(difference) % 2 != 0: return \\"NO\\" target = abs(difference) // 2 if difference > 0: target_prefix_sum = prefix_sums_of_size(A, target) else: target_prefix_sum = prefix_sums_of_size(B, target) if target_prefix_sum: return \\"YES\\" return \\"NO\\" def prefix_sums_of_size(arr, target): Returns whether there exists a prefix sum equal to target. current_sum = 0 seen_sums = set() for num in arr: current_sum += num if current_sum == target or (current_sum - target) in seen_sums: return True seen_sums.add(current_sum) return False"},{"question":"from typing import List, Tuple def max_profit_for_queries(n: int, prices: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Calculate the maximum profit for each query. Args: n: int - Number of days. prices: List[int] - List of stock prices over n days. q: int - Number of queries. queries: List[Tuple[int, int]] - List of queries, each contains two integers li and ri. Returns: List[int] - List containing the maximum profit for each query. results = [] return results def process_input(input_str: str) -> Tuple[int, List[int], int, List[Tuple[int, int]]]: Process the given input string and parse it into appropriate arguments for the main function. Args: input_str: str - Multiline string containing all input lines. Returns: Tuple: Tuple containing n (int), prices (List[int]), q (int), queries (List[Tuple[int, int]]) input_lines = input_str.strip().split('n') return 0, [], 0, [] if __name__ == \\"__main__\\": input_str = input() n, prices, q, queries = process_input(input_str) results = max_profit_for_queries(n, prices, q, queries) for result in results: print(result) import pytest def test_max_profit_for_queries_example(): n = 8 prices = [3, 8, 5, 1, 7, 8, 10, 2] q = 3 queries = [(1, 6), (2, 8), (3, 5)] result = max_profit_for_queries(n, prices, q, queries) expected = [7, 9, 6] assert result == expected def test_max_profit_no_profit(): n = 5 prices = [10, 9, 8, 7, 6] q = 1 queries = [(1, 5)] result = max_profit_for_queries(n, prices, q, queries) expected = [0] assert result == expected def test_max_profit_single_query(): n = 5 prices = [1, 2, 3, 4, 5] q = 1 queries = [(1, 5)] result = max_profit_for_queries(n, prices, q, queries) expected = [4] assert result == expected def test_process_input(): input_str = \\"8n3 8 5 1 7 8 10 2n3n1 6n2 8n3 5n\\" n, prices, q, queries = process_input(input_str) assert n == 8 assert prices == [3, 8, 5, 1, 7, 8, 10, 2] assert q == 3 assert queries == [(1, 6), (2, 8), (3, 5)] def test_combined_function(): input_str = \\"8n3 8 5 1 7 8 10 2n3n1 6n2 8n3 5n\\" n, prices, q, queries = process_input(input_str) result = max_profit_for_queries(n, prices, q, queries) expected = [7, 9, 6] assert result == expected","solution":"def max_profit_for_queries(n, prices, q, queries): Calculate the maximum profit for each query. Args: n: int - Number of days. prices: List[int] - List of stock prices over n days. q: int - Number of queries. queries: List[Tuple[int, int]] - List of queries, each contains two integers li and ri. Returns: List[int] - List containing the maximum profit for each query. results = [] for li, ri in queries: max_profit = 0 for buy_day in range(li - 1, ri - 1): # inclusive li - 1 to exclusive ri - 1 for sell_day in range(buy_day + 1, ri): # inclusive buy_day + 1 to exclusive ri profit = prices[sell_day] - prices[buy_day] if profit > max_profit: max_profit = profit results.append(max_profit) return results def process_input(input_str): Process the given input string and parse it into appropriate arguments for the main function. Args: input_str: str - Multiline string containing all input lines. Returns: Tuple: Tuple containing n (int), prices (List[int]), q (int), queries (List[Tuple[int, int]]) input_lines = input_str.strip().split('n') n = int(input_lines[0]) prices = list(map(int, input_lines[1].split())) q = int(input_lines[2]) queries = [tuple(map(int, line.split())) for line in input_lines[3:3+q]] return n, prices, q, queries"},{"question":"def fix_caps_lock(s: str) -> str: Fix the string s that was typed with Caps Lock key active. The first character remains uppercase if the rest of the string is in uppercase. Otherwise, the entire string is converted into lowercase except for the first character. Parameters: s (str): The input string Returns: str: The corrected string Examples: >>> fix_caps_lock(\\"hELLO\\") 'Hello' >>> fix_caps_lock(\\"wORLD\\") 'World' >>> fix_caps_lock(\\"hello\\") 'hello' >>> fix_caps_lock(\\"Test\\") 'Test'","solution":"def fix_caps_lock(s): Fix the string s that was typed with Caps Lock key active. The first character remains uppercase if the rest of the string is in uppercase. Otherwise, the entire string is converted into lowercase except for the first character. Parameters: s (str): The input string Returns: str: The corrected string # Check if the entire string except for the first character is in uppercase if s[1:].isupper(): return s[0].upper() + s[1:].lower() # Otherwise return the string as it is return s"},{"question":"def max_energy_segment(n, k, max_energy, crystals): This function finds the maximum sum of energy from any segment containing exactly k consecutive crystals without exceeding max_energy. Parameters: n (int): The number of crystals. k (int): The number of consecutive crystals in a segment. max_energy (int): The maximum energy that can be collected in one go. crystals (list): List of integers representing the energy in each crystal. Returns: int: The maximum energy collected from any valid segment or 0 if no valid segment exists. Examples: >>> max_energy_segment(5, 3, 15, [5, 2, 8, 10, 1]) 15 >>> max_energy_segment(4, 2, 6, [5, 7, 3, 2]) 6 >>> max_energy_segment(4, 2, 1, [5, 7, 3, 2]) 0 # Test Cases def test_no_valid_segment(): assert max_energy_segment(4, 2, 1, [5, 7, 3, 2]) == 0 def test_exact_match_segment(): assert max_energy_segment(5, 3, 15, [5, 2, 8, 10, 1]) == 15 def test_max_energy_not_exceeded(): assert max_energy_segment(6, 3, 10, [1, 2, 3, 4, 5, 6]) == 9 def test_small_k_large_n(): assert max_energy_segment(5, 1, 100, [20, 30, 40, 50, 60]) == 60 def test_all_elements_exceed_max_energy(): assert max_energy_segment(3, 3, 2, [3, 3, 3]) == 0 def test_single_element_segment(): assert max_energy_segment(5, 1, 50, [40, 50, 35, 10, 20]) == 50 def test_k_equals_n(): assert max_energy_segment(4, 4, 15, [3, 4, 6, 2]) == 15","solution":"def max_energy_segment(n, k, max_energy, crystals): This function finds the maximum sum of energy from any segment containing exactly k consecutive crystals without exceeding max_energy. Parameters: n (int): The number of crystals. k (int): The number of consecutive crystals in a segment. max_energy (int): The maximum energy that can be collected in one go. crystals (list): List of integers representing the energy in each crystal. Returns: int: The maximum energy collected from any valid segment or 0 if no valid segment exists. max_collected = 0 for i in range(n - k + 1): current_sum = sum(crystals[i:i + k]) if current_sum <= max_energy: max_collected = max(max_collected, current_sum) return max_collected"},{"question":"def count_water_pools(n: int, m: int, grid: List[List[int]]) -> int: Count the number of water pools in the grid. A pool is defined as a collection of horizontally or vertically connected cells all having a height of 0. >>> count_water_pools(3, 3, [ ... [1, 0, 2], ... [0, 0, 0], ... [1, 0, 3] ... ]) == 1 >>> count_water_pools(5, 5, [ ... [1, 0, 2, 1, 0], ... [0, 0, 0, 2, 1], ... [1, 0, 3, 0, 0], ... [1, 1, 1, 0, 2], ... [0, 0, 1, 0, 1] ... ]) == 4 >>> count_water_pools(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 0 >>> count_water_pools(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 1 >>> count_water_pools(1, 1, [ ... [0] ... ]) == 1 >>> count_water_pools(3, 3, [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ]) == 4","solution":"def count_water_pools(n, m, grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != 0: return grid[x][y] = -1 # Mark the cell as visited directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dir in directions: dfs(x + dir[0], y + dir[1]) water_pools = 0 for i in range(n): for j in range(m): if grid[i][j] == 0: dfs(i, j) water_pools += 1 return water_pools"},{"question":"def subset_sum_exists(n: int, k: int, arr: List[int]) -> str: Given an array of n positive integers and a number k, finds out if there exists a combination of the array elements that sums up to k. Each element in the array can be used only once in a combination. >>> subset_sum_exists(5, 9, [2, 3, 7, 8, 10]) == \\"YES\\" >>> subset_sum_exists(4, 13, [1, 2, 3, 4]) == \\"NO\\" >>> subset_sum_exists(3, 5, [1, 4, 5]) == \\"YES\\" >>> subset_sum_exists(6, 12, [1, 2, 3, 4, 5, 6]) == \\"YES\\" >>> subset_sum_exists(1, 100, [50]) == \\"NO\\" >>> subset_sum_exists(1, 1, [1]) == \\"YES\\" >>> subset_sum_exists(10, 55, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == \\"YES\\"","solution":"def subset_sum_exists(n, k, arr): Given an array of n positive integers and a number k, finds out if there exists a combination of the array elements that sums up to k. Each element in the array can be used only once in a combination. dp = [False] * (k + 1) dp[0] = True for num in arr: for j in range(k, num - 1, -1): if dp[j - num]: dp[j] = True return \\"YES\\" if dp[k] else \\"NO\\""},{"question":"from typing import List, Tuple def min_trucks_needed(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the minimum number of trucks required to transport the total cargo for each test case. If it is not possible to transport the cargo with the available trucks, return 'impossible'. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases. Each test case is a tuple where the first element is the total amount of cargo to be transported and the second element is a list of truck capacities. Returns: List[str]: List of results for each test case in the format 'Case #x: y', where x is the case number (starting from 1), and y is the minimum number of trucks required to transport the total cargo or 'impossible' if not feasible. Example: >>> min_trucks_needed([(100, [50, 50, 50]), (60, [10, 20, 30, 40])]) ['Case #1: 2', 'Case #2: 2'] pass def process_input(T: int, inputs: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[int]]]: Process the inputs to extract the test cases. Args: T (int): Number of test cases. inputs (List[Tuple[int, List[int]]]): Raw input data containing number of trucks and total amount of cargo followed by the capacities of the trucks for each test case. Returns: List[Tuple[int, List[int]]]: List of formatted test cases. Example: >>> process_input(2, [(3, 100), [50, 50, 50], (4, 60), [10, 20, 30, 40]]) [(100, [50, 50, 50]), (60, [10, 20, 30, 40])] pass # Unit tests def test_case_1(): T = 2 inputs = [(3, 100), [50, 50, 50], (4, 60), [10, 20, 30, 40]] test_cases = process_input(T, inputs) results = min_trucks_needed(test_cases) assert results == [\\"Case #1: 2\\", \\"Case #2: 2\\"] def test_case_2(): T = 1 inputs = [(2, 100), [50, 40]] test_cases = process_input(T, inputs) results = min_trucks_needed(test_cases) assert results == [\\"Case #1: impossible\\"] def test_case_3(): T = 1 inputs = [(5, 150), [30, 50, 20, 40, 60]] test_cases = process_input(T, inputs) results = min_trucks_needed(test_cases) assert results == [\\"Case #1: 3\\"] def test_case_4(): T = 1 inputs = [(3, 20), [10, 10, 10]] test_cases = process_input(T, inputs) results = min_trucks_needed(test_cases) assert results == [\\"Case #1: 2\\"] def test_case_5(): T = 1 inputs = [(1, 10000), [1000]] test_cases = process_input(T, inputs) results = min_trucks_needed(test_cases) assert results == [\\"Case #1: impossible\\"]","solution":"def min_trucks_needed(test_cases): results = [] for idx, (K, capacities) in enumerate(test_cases): capacities.sort(reverse=True) total_cargo = K trucks_used = 0 for capacity in capacities: if total_cargo == 0: break if capacity <= total_cargo: total_cargo -= capacity trucks_used += 1 else: trucks_used += 1 total_cargo = 0 if total_cargo > 0: results.append(f\\"Case #{idx + 1}: impossible\\") else: results.append(f\\"Case #{idx + 1}: {trucks_used}\\") return results def process_input(T, inputs): test_cases = [] for i in range(T): N, K = inputs[i * 2] capacities = inputs[i * 2 + 1] test_cases.append((K, capacities)) return test_cases"},{"question":"class MultidimensionalGrid: A class to model the spread of a disease over a multi-dimensional grid. Methods: add_person(coords: List[int]) -> None: Adds a person to the grid at the specified coordinates. remove_person(coords: List[int]) -> None: Removes a person from the grid at the specified coordinates. count_people(corner1: List[int], corner2: List[int]) -> int: Counts the number of people within the specified sub-region. def __init__(self): self.grid = set() def add_person(self, coords): self.grid.add(tuple(coords)) def remove_person(self, coords): self.grid.discard(tuple(coords)) def count_people(self, corner1, corner2): count = 0 for person in self.grid: if all(c1 <= p <= c2 for p, c1, c2 in zip(person, corner1, corner2)): count += 1 return count def process_queries(k: int, N: int, queries: List[List[int]]) -> List[int]: Processes a series of queries on a multi-dimensional grid and returns the results. Args: k (int): Number of queries. N (int): Number of dimensions of the grid. queries (List[List[int]]): List of queries to be processed. Returns: List[int]: Results of the count queries. grid = MultidimensionalGrid() results = [] for query in queries: if query[0] == 1: grid.add_person(query[1:]) elif query[0] == 2: grid.remove_person(query[1:]) elif query[0] == 3: corner1 = query[1:N+1] corner2 = query[N+1:] results.append(grid.count_people(corner1, corner2)) return results # Test cases def test_add_person(): grid = MultidimensionalGrid() grid.add_person([1, 1]) assert (1, 1) in grid.grid def test_remove_person(): grid = MultidimensionalGrid() grid.add_person([1, 1]) grid.remove_person([1, 1]) assert (1, 1) not in grid.grid def test_count_people(): grid = MultidimensionalGrid() grid.add_person([1, 1]) grid.add_person([2, 2]) assert grid.count_people([1, 1], [2, 2]) == 2 grid.remove_person([1, 1]) assert grid.count_people([1, 1], [2, 2]) == 1 def test_process_queries(): k = 5 N = 2 queries = [ [1, 1, 1], [1, 2, 2], [3, 1, 1, 2, 2], [2, 1, 1], [3, 1, 1, 2, 2] ] assert process_queries(k, N, queries) == [2, 1] k = 4 N = 3 queries = [ [1, 1, 1, 1], [3, 1, 1, 1, 1, 1, 1], [2, 1, 1, 1], [3, 1, 1, 1, 1, 1, 1] ] assert process_queries(k, N, queries) == [1, 0]","solution":"class MultidimensionalGrid: def __init__(self): self.grid = set() def add_person(self, coords): self.grid.add(tuple(coords)) def remove_person(self, coords): self.grid.discard(tuple(coords)) def count_people(self, corner1, corner2): count = 0 for person in self.grid: if all(c1 <= p <= c2 for p, c1, c2 in zip(person, corner1, corner2)): count += 1 return count def process_queries(k, N, queries): grid = MultidimensionalGrid() results = [] for query in queries: if query[0] == 1: grid.add_person(query[1:]) elif query[0] == 2: grid.remove_person(query[1:]) elif query[0] == 3: corner1 = query[1:N+1] corner2 = query[N+1:] results.append(grid.count_people(corner1, corner2)) return results"},{"question":"def is_bipartite(adj_matrix: List[List[int]]) -> bool: Check if the given graph (represented as an adjacency matrix) is bipartite. :param adj_matrix: List[List[int]], n x n adjacency matrix :return: bool, True if the graph is bipartite, False otherwise pass def check_bipartite(q: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: Determine if each test case graph is bipartite. :param q: int, number of test cases :param test_cases: List of tuples, where each tuple contains an integer and a 2D list of integers representing the adjacency matrix. :return: List of strings, \\"YES\\" or \\"NO\\" for each test case. pass from is_bipartite, check_bipartite def test_is_bipartite_triangle(): adj_matrix = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert not is_bipartite(adj_matrix) def test_is_bipartite_square(): adj_matrix = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] assert is_bipartite(adj_matrix) def test_is_bipartite_complex(): adj_matrix = [ [0, 1, 1, 1, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [1, 1, 1, 0, 1], [0, 0, 1, 1, 0] ] assert not is_bipartite(adj_matrix) def test_check_bipartite(): q = 3 test_cases = [ (3, [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ]), (4, [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ]), (5, [ [0, 1, 1, 1, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [1, 1, 1, 0, 1], [0, 0, 1, 1, 0] ]) ] expected_results = [\\"NO\\", \\"YES\\", \\"NO\\"] assert check_bipartite(q, test_cases) == expected_results","solution":"def is_bipartite(adj_matrix): Check if the given graph (represented as an adjacency matrix) is bipartite. :param adj_matrix: List[List[int]], n x n adjacency matrix :return: bool, True if the graph is bipartite, False otherwise n = len(adj_matrix) colors = [-1] * n def bfs(start): queue = [start] colors[start] = 0 # Start coloring with 0 while queue: node = queue.pop(0) for neighbor in range(n): if adj_matrix[node][neighbor] == 1: if colors[neighbor] == -1: colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True for i in range(n): if colors[i] == -1: if not bfs(i): return False return True def check_bipartite(q, test_cases): results = [] for i in range(q): n = test_cases[i][0] adj_matrix = test_cases[i][1] if is_bipartite(adj_matrix): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_increasing_sublists(n: int, nums: List[int]) -> int: Determine the maximum number of strictly increasing sublists Alex can create from the given list of numbers. Args: n (int): The length of the list. nums (List[int]): Alex's list of numbers. Returns: int: The maximum number of strictly increasing sublists. Examples: >>> max_increasing_sublists(6, [1, 2, 3, 2, 4, 3]) 3 >>> max_increasing_sublists(5, [5, 4, 3, 2, 1]) 5 >>> max_increasing_sublists(7, [1, 3, 5, 7, 2, 4, 6]) 2 >>> max_increasing_sublists(6, [1, 1, 1, 1, 1, 1]) 6","solution":"def max_increasing_sublists(n, nums): This function takes an integer n and a list of integers nums, and returns the maximum number of strictly increasing sublists that can be formed. if n == 0: return 0 count = 1 # Start with one sublist for i in range(1, n): if nums[i] <= nums[i - 1]: count += 1 return count"},{"question":"def max_vertical_roads(m, n, k, rows): Determine the maximum number of vertical roads that can be constructed on a grid of dimensions m x n with the given rows where roads can be built. No two roads can be on consecutive columns. >>> max_vertical_roads(5, 5, 3, [1, 3, 4]) 2 >>> max_vertical_roads(5, 5, 0, []) 0","solution":"def max_vertical_roads(m, n, k, rows): Determine the maximum number of vertical roads that can be constructed on a grid of dimensions m x n with the given rows where roads can be built. No two roads can be on consecutive columns. # If there are no available rows to build vertical roads, return 0 if k == 0: return 0 # Calculate how many non-consecutive columns can be used max_roads = (n + 1) // 2 return max_roads"},{"question":"def length_of_longest_substring(s: str) -> int: Create a function that takes a string as input and returns the length of the longest substring without repeating characters. Characters are case-sensitive, so \\"A\\" and \\"a\\" are considered different characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\" \\") 1","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) max_length = 0 start = 0 used_chars = {} for end in range(n): if s[end] in used_chars and used_chars[s[end]] >= start: start = used_chars[s[end]] + 1 used_chars[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def generate_password(n: int, k: int) -> str: Generate a valid password based on given rules or return \\"NO\\" if it is not possible. >>> generate_password(5, 3) # \\"abcab\\" >>> generate_password(4, 1) # \\"NO\\" >>> generate_password(6, 2) # \\"ababab\\" pass","solution":"def generate_password(n, k): if k == 1 and n > 1: return \\"NO\\" alphabet = 'abcdefghijklmnopqrstuvwxyz' password = [] for i in range(n): password.append(alphabet[i % k]) return ''.join(password)"},{"question":"def min_steps_to_make_beautiful(n: int, array: List[int]) -> int: Find the minimum number of steps required to make the array beautiful. An array is considered beautiful if it satisfies this property: in at least one position \`i\` (1 ≤ i ≤ n), the number of elements before position \`i\` only contains elements smaller than the element at position \`i\`, and the number of elements after position \`i\` only contains elements larger than the element at position \`i\`. You can perform the following operation any number of times (possibly zero): * Choose an element from the array and place it at another position (this may change the order of elements in the array). Args: n (int): the number of elements in the array. array (List[int]): the elements of the array. Returns: int: the minimum number of steps to make the array beautiful. Examples: >>> min_steps_to_make_beautiful(6, [1, 5, 3, 4, 2, 6]) 2 >>> min_steps_to_make_beautiful(4, [2, 3, 1, 4]) 1 >>> min_steps_to_make_beautiful(4, [1, 2, 3, 4]) 0 >>> min_steps_to_make_beautiful(1, [1]) 0 >>> min_steps_to_make_beautiful(5, [5, 4, 3, 2, 1]) 4 >>> min_steps_to_make_beautiful(8, [3, 1, 2, 8, 5, 6, 7, 4]) 3","solution":"def min_steps_to_make_beautiful(n, array): # To find minimum number of moves the idea is to find the length of the longest increasing subsequence # Since this subsequence already meets the criteria of being beautiful after sorting. if n <= 1: return 0 # Calculate Longest Increasing Subsequence (LIS) lis = [] for num in array: pos = binary_search(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return n - len(lis) def binary_search(lis, num): left, right = 0, len(lis) while left < right: mid = (left + right) // 2 if lis[mid] < num: left = mid + 1 else: right = mid return left"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest unique substring in the given string s. A unique substring is a substring that appears only once in the entire string. >>> length_of_longest_unique_substring(\\"abcdabc\\") == 4 >>> length_of_longest_unique_substring(\\"aaaa\\") == 1 >>> length_of_longest_unique_substring(\\"abcabcbb\\") == 3","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest unique substring in the given string s. A unique substring is a substring that appears only once in the entire string. n = len(s) if n == 0: return 0 last_seen = {} start = 0 max_len = 0 for end in range(n): if s[end] in last_seen and last_seen[s[end]] >= start: start = last_seen[s[end]] + 1 else: max_len = max(max_len, end - start + 1) last_seen[s[end]] = end return max_len"},{"question":"def create_string_c(a: str, b: str) -> str: Creates a string c such that for every character in string a, if it exists in string b, it is included only once in the same order as their first occurrence in a. >>> create_string_c(\\"hello\\", \\"world\\") 'lo' >>> create_string_c(\\"abcd\\", \\"efgh\\") '' >>> create_string_c(\\"apple\\", \\"pineapple\\") 'aple'","solution":"def create_string_c(a, b): Creates a string c such that for every character in string a, if it exists in string b, it is included only once in the same order as their first occurrence in a. b_set = set(b) seen = set() c = [] for char in a: if char in b_set and char not in seen: c.append(char) seen.add(char) return ''.join(c)"},{"question":"def product_except_self(A: List[int]) -> List[int]: Given an array A of n integers, returns an array P where P[i] is the product of all elements of A except A[i], without using division and with O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5, 6]) [360, 240, 180, 144, 120]","solution":"def product_except_self(A): Given an array A of n integers, returns an array P where P[i] is the product of all elements of A except A[i], without using division and with O(n) time complexity. n = len(A) if n == 0: return [] # Create two lists for left and right products left_products = [1] * n right_products = [1] * n result = [1] * n # Fill the left products list (product of all elements to the left of i) for i in range(1, n): left_products[i] = left_products[i - 1] * A[i - 1] # Fill the right products list (product of all elements to the right of i) for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * A[i + 1] # Fill the result list by multiplying left and right product lists for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def minimum_total_strength(n: int, weights: List[int]) -> int: Determine the minimum total strength required to move all the boxes to the delivery truck. Parameters: n (int): Number of stacks. weights (list of int): Weights of the bottom boxes of the stacks. Returns: int: Minimum total strength required. Examples: >>> minimum_total_strength(4, [1, 3, 2, 5]) 11 >>> minimum_total_strength(3, [2, 2, 2]) 6","solution":"def minimum_total_strength(n, weights): Calculate the minimum total strength required to move all the boxes to the delivery truck. Parameters: n (int): Number of stacks. weights (list of int): Weights of the bottom boxes of the stacks. Returns: int: Minimum total strength required. # Since each stack contains just one box, the optimal way is not to merge them # The total strength remains the sum of all the weights. return sum(weights)"},{"question":"def kth_highest_score(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Determines the k-th highest score for each test case. Args: T : int : Number of test cases test_cases : list : List containing tuples of (N, scores, k) for each test case Returns: list : List of k-th highest scores for each test case >>> kth_highest_score(1, [(5, [100, 90, 80, 70, 60], 3)]) == [80] >>> kth_highest_score(2, [(5, [100, 90, 80, 70, 60], 1), (6, [33, 34, 31, 40, 37, 30], 2)]) == [100, 37] pass","solution":"def kth_highest_score(T, test_cases): Determines the k-th highest score for each test case. Args: T : int : Number of test cases test_cases : list : List containing tuples of (N, scores, k) for each test case Returns: list : List of k-th highest scores for each test case results = [] for N, scores, k in test_cases: sorted_scores = sorted(scores, reverse=True) results.append(sorted_scores[k-1]) return results"},{"question":"def max_profit_scheduler(n: int, task_input: List[str]) -> int: You are given a sequence of tasks that must be scheduled on a single machine. Each task has a start time, end time, and a profit associated with it. You need to find the maximum profit that can be obtained by scheduling a subset of non-overlapping tasks. A task can only be executed if no other task is running during its start to end time. Your goal is to select a subset of the given tasks such that their total scheduled time does not overlap, and the total profit is maximized. Args: n : int : number of tasks task_input : List[str] : list of strings representing the tasks where each string contains three integers - start, end, and profit Returns: int: Maximum profit obtainable by scheduling non-overlapping tasks. Example: >>> max_profit_scheduler(4, [\\"1 3 500\\", \\"3 5 300\\", \\"0 6 600\\", \\"4 7 200\\"]) 800 >>> max_profit_scheduler(3, [\\"1 2 100\\", \\"3 4 200\\", \\"5 6 300\\"]) 600 >>> max_profit_scheduler(3, [\\"1 4 100\\", \\"2 5 200\\", \\"3 6 300\\"]) 300 >>> max_profit_scheduler(2, [\\"1 3 500\\", \\"1 3 1000\\"]) 1000 >>> max_profit_scheduler(2, [\\"1 1000000000 1\\", \\"2 999999999 100\\"]) 100 >>> max_profit_scheduler(0, []) 0","solution":"from bisect import bisect_right def max_profit(tasks): Args: tasks (List[Tuple[int, int, int]]): List of tuples where each tuple contains (start, end, profit) Returns: int: Maximum profit obtainable by scheduling non-overlapping tasks. # Sort tasks by end time tasks.sort(key=lambda x: x[1]) # dp[i] to store the maximum profit until the i-th task (1-indexed) dp = [0] * (len(tasks) + 1) # List to store the end times for binary search end_times = [task[1] for task in tasks] for i in range(1, len(tasks) + 1): # Find the index of the last task that doesn't conflict with the current task task = tasks[i-1] start, end, profit = task # Binary search to find the maximum index where task end time is <= current task's start time index = bisect_right(end_times, start) - 1 # Update dp[i] dp[i] = max(dp[i-1], profit + dp[index + 1]) return dp[len(tasks)] # Wrapper function to handle input and output def max_profit_scheduler(n, task_input): tasks = [tuple(map(int, task.split())) for task in task_input] return max_profit(tasks)"},{"question":"def two_sum(nums: List[int], target: int) -> bool: Check whether there are two distinct elements in the list that add up to the target sum. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: bool: True if there are two distinct elements that add up to the target sum, False otherwise. Examples: >>> two_sum([10, 15, 3, 7], 17) True >>> two_sum([1, 2, 3, 4], 8) False >>> two_sum([-1, -2, -3, -4, -5], -8) True pass","solution":"def two_sum(nums, target): Returns True if there are two distinct integers in nums that add up to target. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def most_frequent_integer(n: int, arr: List[int]) -> int: Given a list of integers, find the integer that appears the most times. Parameters: n (int): Number of integers in the list. arr (list): List of integers. Returns: int: The integer that appears the most times. >>> most_frequent_integer(8, [1, 3, 2, 2, 3, 2, 3, 3]) 3 >>> most_frequent_integer(5, [5, 5, 5, 4, 4]) 5 >>> most_frequent_integer(6, [10, 20, 30, 10, 20, 10]) 10","solution":"def most_frequent_integer(n, arr): Given a list of integers, find the integer that appears the most times. Parameters: n (int): Number of integers in the list. arr (list): List of integers. Returns: int: The integer that appears the most times. from collections import Counter frequency = Counter(arr) most_common = frequency.most_common(1)[0][0] return most_common"},{"question":"def convert_zigzag(s: str, numRows: int) -> str: Converts the given string \`s\` into a zigzag pattern with the given \`numRows\` and returns the result read line by line. >>> convert_zigzag(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert_zigzag(\\"HELLO\\", 2) \\"HLOEL\\" >>> convert_zigzag(\\"ABCDEFG\\", 4) \\"AGBFCED\\"","solution":"def convert_zigzag(s, numRows): Converts the given string \`s\` into a zigzag pattern with the given \`numRows\` and returns the result read line by line. if numRows == 1 or numRows >= len(s): return s rows = [''] * numRows current_row = 0 direction = -1 # Will be flipped to 1 on first use for char in s: rows[current_row] += char # Change direction at the top and bottom of the zigzag if current_row == 0 or current_row == numRows - 1: direction *= -1 current_row += direction return ''.join(rows)"},{"question":"def max_non_overlapping_meetings(N, meetings): Determines the maximum number of non-overlapping meetings that can be scheduled. Parameters: N (int): The number of meetings. meetings (list of tuples): A list of (start, end) times for each meeting. Returns: int: The maximum number of non-overlapping meetings. pass def test_single_meeting(): assert max_non_overlapping_meetings(1, [(1, 2)]) == 1 def test_non_overlapping_meetings(): assert max_non_overlapping_meetings(3, [(1, 4), (6, 7), (8, 9)]) == 3 def test_some_overlapping_meetings(): assert max_non_overlapping_meetings(3, [(1, 4), (2, 5), (6, 7)]) == 2 def test_all_overlapping_meetings(): assert max_non_overlapping_meetings(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) == 2 def test_complex_case(): assert max_non_overlapping_meetings(5, [(1, 3), (2, 4), (3, 5), (4, 6), (6, 8)]) == 3","solution":"def max_non_overlapping_meetings(N, meetings): Determines the maximum number of non-overlapping meetings that can be scheduled. Parameters: N (int): The number of meetings. meetings (list of tuples): A list of (start, end) times for each meeting. Returns: int: The maximum number of non-overlapping meetings. # Sort meetings by end time meetings.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def count_paths(grid: List[List[int]]) -> int: This function returns the number of valid paths from the top-left to the bottom-right corner of a grid. >>> count_paths([[1, 1, 0], [1, 1, 0], [0, 1, 1]]) 2 >>> count_paths([[1, 0], [0, 1]]) 0 >>> count_paths([[1]]) 1 >>> count_paths([[0]]) 0 >>> count_paths([[1, 1, 1, 1], [1, 1, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]) 10 >>> count_paths([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def count_paths(grid): This function returns the number of valid paths from the top-left to the bottom-right corner of a grid. m = len(grid) n = len(grid[0]) if grid[0][0] == 0 or grid[m-1][n-1] == 0: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def total_blocks_for_tower(h: int) -> int: Calculate the total number of blocks needed to build a pyramid-like tower of height h. >>> total_blocks_for_tower(1) 1 >>> total_blocks_for_tower(2) 5 >>> total_blocks_for_tower(3) 14 >>> total_blocks_for_tower(4) 30 >>> total_blocks_for_tower(5) 55 >>> total_blocks_for_tower(1000) 333833500 >>> total_blocks_for_tower(100000) 333338333350000","solution":"def total_blocks_for_tower(h): Calculate the total number of blocks required to build a pyramid-like tower of height h. total_blocks = 0 for level in range(1, h + 1): total_blocks += level ** 2 return total_blocks"},{"question":"def min_steps_to_palindrome(n: int, S: str) -> int: Returns the minimum number of steps required to transform the given string S into a palindrome. Args: n (int): The length of the string S. S (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of steps to transform S into a palindrome. Examples: >>> min_steps_to_palindrome(4, \\"abca\\") 1 >>> min_steps_to_palindrome(5, \\"abcde\\") 2 >>> min_steps_to_palindrome(6, \\"aabbcc\\") 2","solution":"def min_steps_to_palindrome(n, S): Returns the minimum number of steps required to transform the given string S into a palindrome. left = 0 right = n - 1 steps = 0 while left < right: if S[left] != S[right]: steps += 1 left += 1 right -= 1 return steps"},{"question":"from typing import List, Tuple def find_connected_components(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: Finds and returns all the connected components of a given undirected graph. Args: n (int): Number of vertices in the graph. edges (List[Tuple[int,int]]): List of edges where each edge is represented as a tuple (u, v). Returns: List[List[int]]: List of connected components, where each connected component is represented as a list of vertices. pass def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[List[List[int]]]: Processes multiple test cases and finds the connected components for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases, where each test case is represented as a tuple containing the number of vertices, the number of edges, and the list of edges. Returns: List[List[List[int]]]: List of results for each test case, where each result is a list of connected components. pass def test_find_connected_components(): T = 2 test_cases = [ (5, 3, [(1, 2), (3, 4), (4, 5)]), (4, 0, []) ] expected_output = [ [[1, 2], [3, 4, 5]], [[1], [2], [3], [4]] ] assert process_test_cases(T, test_cases) == expected_output def test_find_connected_components_single_node(): T = 1 test_cases = [ (1, 0, []) ] expected_output = [ [[1]] ] assert process_test_cases(T, test_cases) == expected_output def test_find_connected_components_empty_graph(): T = 1 test_cases = [ (3, 0, []) ] expected_output = [ [[1], [2], [3]] ] assert process_test_cases(T, test_cases) == expected_output def test_find_connected_components_full_connected_graph(): T = 1 test_cases = [ (3, 3, [(1, 2), (2, 3), (1, 3)]) ] expected_output = [ [[1, 2, 3]] ] assert process_test_cases(T, test_cases) == expected_output def test_find_connected_components_disjoint_components(): T = 1 test_cases = [ (6, 3, [(1, 2), (3, 4), (5, 6)]) ] expected_output = [ [[1, 2], [3, 4], [5, 6]] ] assert process_test_cases(T, test_cases) == expected_output","solution":"def find_connected_components(n, edges): from collections import defaultdict, deque def bfs(start): queue = deque([start]) component = [] visited[start] = True while queue: node = queue.popleft() component.append(node) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return sorted(component) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = [] for node in range(1, n + 1): if not visited[node]: component = bfs(node) components.append(component) return components def process_test_cases(T, test_cases): result = [] for i in range(T): n, m, edges = test_cases[i] components = find_connected_components(n, edges) result.append(components) return result"},{"question":"from typing import List def min_steps_to_reach_end(n: int, m: int, grid: List[str]) -> int: Find the minimum number of steps required to move from any starting point 'S' to any ending point 'E'. If it is impossible to reach an ending point, return -1. >>> min_steps_to_reach_end(3, 4, [\\"S..E\\", \\".W.W\\", \\"...S\\"]) 3 >>> min_steps_to_reach_end(4, 4, [\\"SW.W\\", \\"....\\", \\".W..\\", \\"..E.\\"]) 5 >>> min_steps_to_reach_end(3, 3, [\\"SWW\\", \\"WWE\\", \\"...\\"]) -1 >>> min_steps_to_reach_end(1, 2, [\\"SE\\"]) 1 >>> min_steps_to_reach_end(3, 3, [\\"...\\", \\".W.\\", \\"...\\"]) -1","solution":"from collections import deque def min_steps_to_reach_end(n, m, grid): # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find all starting and ending points starts = [] end = None for i in range(n): for j in range(m): if grid[i][j] == 'S': starts.append((i, j)) elif grid[i][j] == 'E': end = (i, j) if not starts or not end: return -1 def bfs(start): # Breadth-First Search to find shortest path from start to end queue = deque([(start[0], start[1], 0)]) # (x, y, steps) visited = set() visited.add((start[0], start[1])) while queue: x, y, steps = queue.popleft() if (x, y) == end: return steps for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != 'W': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return float('inf') min_steps = float('inf') for start in starts: min_steps = min(min_steps, bfs(start)) return min_steps if min_steps != float('inf') else -1"},{"question":"def max_manhattan_distance(n: int, moves: str, k: int) -> int: Returns the maximum Manhattan distance the robot can achieve given a sequence of moves and an energy limit. >>> max_manhattan_distance(5, 'URDDL', 2) 2 >>> max_manhattan_distance(6, 'UUUDDD', 3) 3 def test_example_1(): assert max_manhattan_distance(5, 'URDDL', 2) == 2 def test_example_2(): assert max_manhattan_distance(6, 'UUUDDD', 3) == 3 def test_max_energy(): assert max_manhattan_distance(7, 'UUUUUUU', 7) == 7 def test_exact_energy_usage(): assert max_manhattan_distance(6, 'ULDRUL', 6) == 2 def test_insufficient_energy(): assert max_manhattan_distance(10, 'UUDDLRLRLR', 1) == 1 def test_another_case(): assert max_manhattan_distance(4, 'LRLR', 4) == 0","solution":"def max_manhattan_distance(n, moves, k): Returns the maximum Manhattan distance the robot can achieve given a sequence of moves and an energy limit. # Initial position x, y = 0, 0 # Tracking position changes for i in range(min(k, n)): if moves[i] == 'U': y += 1 elif moves[i] == 'D': y -= 1 elif moves[i] == 'L': x -= 1 elif moves[i] == 'R': x += 1 # Calculate Manhattan distance from (0, 0) return abs(x) + abs(y)"},{"question":"def min_removals_to_non_decreasing(n: int, heights: List[int]) -> int: Returns the minimum number of flowers to remove to make the heights non-decreasing. :param n: int - number of flowers :param heights: list of ints - heights of the flowers :return: int - minimum number of removals >>> min_removals_to_non_decreasing(6, [4, 3, 2, 6, 1, 7]) 3 >>> min_removals_to_non_decreasing(5, [1, 2, 3, 4, 5]) 0 >>> min_removals_to_non_decreasing(8, [5, 1, 8, 3, 6, 7, 2, 4]) 4","solution":"def min_removals_to_non_decreasing(n, heights): Returns the minimum number of flowers to remove to make the heights non-decreasing. :param n: int - number of flowers :param heights: list of ints - heights of the flowers :return: int - minimum number of removals # Finding the length of the Longest Increasing Subsequence (LIS) if n == 0: return 0 lis = [1] * n for i in range(1, n): for j in range(0, i): if heights[i] >= heights[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 max_lis = max(lis) # The number of removals needed is the total number of flowers minus the length of the LIS return n - max_lis"},{"question":"from typing import List, Tuple def longest_course_sequence(n: int, m: int, pairs: List[Tuple[int, int]]) -> int: Find the longest sequence of ingredients such that each ingredient in the sequence is a pair with the next ingredient in the sequence. >>> longest_course_sequence(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 5), (5, 1)]) 4 >>> longest_course_sequence(4, 2, [(1, 2), (3, 4)]) 2","solution":"from collections import defaultdict, deque def longest_course_sequence(n, m, pairs): graph = defaultdict(list) # Build an adjacency list for pair in pairs: a, b = pair graph[a].append(b) graph[b].append(a) # BFS to find the longest path def bfs(start): visited = set() queue = deque([(start, 1)]) max_length = 1 while queue: node, length = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, length + 1)) max_length = max(max_length, length + 1) return max_length # For each ingredient, try to find the longest sequence starting from there longest_seq = 1 for ingredient in range(1, n + 1): longest_seq = max(longest_seq, bfs(ingredient)) # If no valid sequence is found, return -1 return longest_seq if longest_seq > 1 else -1 # Example usage n = 5 m = 6 pairs = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 5), (5, 1)] print(longest_course_sequence(n, m, pairs)) # Output: 4"},{"question":"def tree_heights(t1, t2, n): Compute the sequence of tree heights based on the given rules. Args: t1 (int): Height of the first tree. t2 (int): Height of the second tree. n (int): Total number of trees. Returns: list: List containing the heights of the trees. >>> tree_heights(1, 1, 5) [1, 1, 2, 3, 5] >>> tree_heights(2, 3, 7) [2, 3, 5, 8, 13, 21, 34] >>> tree_heights(5, 8, 4) [5, 8, 13, 21]","solution":"def tree_heights(t1, t2, n): Compute the sequence of tree heights based on the given rules. Args: t1 (int): Height of the first tree. t2 (int): Height of the second tree. n (int): Total number of trees. Returns: list: List containing the heights of the trees. if n == 1: return [t1] elif n == 2: return [t1, t2] heights = [t1, t2] for i in range(2, n): next_height = heights[-1] + heights[-2] heights.append(next_height) return heights"},{"question":"def minimum_time_to_complete_race(D: int, n: int, efficiency_scores: List[int]) -> float: Calculates the minimum time required to complete the race given the total distance D, number of runners n, and their efficiency scores. >>> minimum_time_to_complete_race(100, 3, [5, 10, 15]) 3.33 >>> minimum_time_to_complete_race(100, 4, [5, 5, 5, 5]) 5.0 >>> minimum_time_to_complete_race(50, 1, [5]) 10.0 >>> minimum_time_to_complete_race(200, 4, [2, 3, 5, 10]) 10.0 >>> minimum_time_to_complete_race(1000000, 5, [1000000, 1000000, 1000000, 1000000, 1000000]) 0.2 pass","solution":"def minimum_time_to_complete_race(D, n, efficiency_scores): Calculates the minimum time required to complete the race given the total distance D, number of runners n, and their efficiency scores. Parameters: D (int): Total distance of the race. n (int): Number of runners. efficiency_scores (list of int): Efficiency scores of the runners. Returns: float: Minimum time required to complete the race rounded to two decimal places. total_efficiency = sum(efficiency_scores) min_time = D / total_efficiency return round(min_time, 2)"},{"question":"def minimum_passes(n: int, k: int) -> int: Calculate the minimum number of passes required for the ball to return to the starting student in a circle of students. Parameters: n (int): The number of students. k (int): The index of the starting student. Returns: int: The minimum number of passes required. Examples: >>> minimum_passes(5, 3) 2 >>> minimum_passes(6, 1) 3 >>> minimum_passes(8, 4) 4 pass # Test Cases def test_minimum_passes_odd_students(): assert minimum_passes(5, 3) == 2 def test_minimum_passes_even_students(): assert minimum_passes(6, 1) == 3 def test_minimum_passes_large_odd_students(): assert minimum_passes(99999, 50000) == 49999 def test_minimum_passes_large_even_students(): assert minimum_passes(100000, 25000) == 50000 def test_minimum_passes_minimum_students(): assert minimum_passes(3, 2) == 1 def test_minimum_passes_symmetric_position(): assert minimum_passes(8, 4) == 4 assert minimum_passes(8, 8) == 4","solution":"def minimum_passes(n, k): Returns the minimum number of passes required for the ball to return to the starting student. if n % 2 == 0: return n // 2 else: return (n - 1) // 2 # Example usage: # print(minimum_passes(5, 3)) # Output: 2 # print(minimum_passes(6, 1)) # Output: 3 # print(minimum_passes(8, 4)) # Output: 4"},{"question":"def can_alice_sort(t: int, test_cases: List[List[List[int]]]) -> List[str]: Determines if Alice can sort the list using her block-sorting method. Args: t: an integer representing the number of test cases. test_cases: a list of test cases. Each test case is in the format [[n, k], [a_1, a_2, ..., a_n]] Returns: A list of strings where each string is \\"Yes\\" if Alice can sort the list, otherwise \\"No\\". >>> can_alice_sort(3, [[[5, 2], [3, 1, 4, 5, 2]], [[6, 3], [6, 5, 4, 3, 2, 1]], [[4, 1], [4, 3, 2, 1]]]) [\\"No\\", \\"No\\", \\"No\\"] >>> can_alice_sort(1, [[[4, 4], [1, 2, 3, 4]]]) [\\"Yes\\"] from typing import List def test_case_1(): assert can_alice_sort(3, [[[5, 2], [3, 1, 4, 5, 2]], [[6, 3], [6, 5, 4, 3, 2, 1]], [[4, 1], [4, 3, 2, 1]]]) == [\\"No\\", \\"No\\", \\"No\\"] def test_case_2(): assert can_alice_sort(1, [[[6, 3], [6, 5, 4, 2, 3, 1]]]) == [\\"No\\"] def test_case_3(): assert can_alice_sort(1, [[[4, 2], [4, 3, 2, 1]]]) == [\\"No\\"] def test_case_4(): assert can_alice_sort(1, [[[4, 4], [1, 2, 3, 4]]]) == [\\"Yes\\"] def test_case_5(): assert can_alice_sort(1, [[[5, 1], [1, 2, 3, 4, 5]]]) == [\\"Yes\\"]","solution":"def can_alice_sort(t, test_cases): results = [] for case in test_cases: n, k = case[0] arr = case[1] # Creating blocks blocks = [arr[i:i+k] for i in range(0, n, k)] # Sorting blocks individually for block in blocks: block.sort() # Concatenating sorted blocks sorted_blocks = [elem for block in blocks for elem in block] # Checking if concatenated list is sorted if sorted_blocks == sorted(arr): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def max_gold_coins(n: int, coins: List[int]) -> int: Mario is a game developer who is designing a new puzzle game. In this game, there is a row of cells, each of which can contain a number representing gold coins. Players can gather gold coins by moving through the cells in a specific way. You are given the number of cells, n, and a list of gold coins present in each cell. The player starts at the first cell and can only move to the next cell or skip one cell to move to the cell after the next one in a single move. The player aims to gather the maximum possible number of gold coins by the time they reach beyond the last cell. Parameters: n: int - number of cells in the row coins: List[int] - the number of gold coins in each cell Returns: int - the maximum number of gold coins the player can collect Example: >>> max_gold_coins(5, [5, 10, 20, 15, 25]) 50 >>> max_gold_coins(3, [1, 2, 3]) 4 pass","solution":"def max_gold_coins(n, coins): if n == 1: return coins[0] dp = [0] * n dp[0] = coins[0] if n > 1: dp[1] = max(coins[0], coins[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + coins[i]) return dp[-1]"},{"question":"def can_arrange_books(n: int, heights: List[int]) -> str: Determine if books can be arranged in non-increasing order with the given constraints. >>> can_arrange_books(5, [25, 20, 15, 10, 5]) \\"Possible\\" >>> can_arrange_books(4, [30, 20, 10, 5]) \\"Possible\\" >>> can_arrange_books(6, [7, 7, 7, 7, 7, 7]) \\"Possible\\" >>> can_arrange_books(5, [15, 10, 20, 25, 5]) \\"Impossible\\" >>> can_arrange_books(4, [10, 20, 30, 40]) \\"Impossible\\"","solution":"def can_arrange_books(n, heights): Determine if books can be arranged in non-increasing order with the given constraints. for i in range(1, n): if heights[i] > heights[i-1]: return \\"Impossible\\" return \\"Possible\\""},{"question":"def can_form_palindrome(s: str) -> bool: Checks if a given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False def process_test_cases(T: int, strings: List[str]) -> List[str]: Processes multiple test cases to determine if strings can be rearranged to form palindromes. Args: T (int): The number of test cases. strings (List[str]): A list of input strings. Returns: List[str]: A list of results, \\"YES\\" or \\"NO\\" for each input string. >>> process_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"aabb\\", \\"abc\\"]) [\\"YES\\", \\"NO\\"] from solution import can_form_palindrome, process_test_cases def test_can_form_palindrome(): assert can_form_palindrome(\\"civic\\") == True assert can_form_palindrome(\\"ivicc\\") == True assert can_form_palindrome(\\"hello\\") == False assert can_form_palindrome(\\"aabb\\") == True assert can_form_palindrome(\\"aabbc\\") == True assert can_form_palindrome(\\"aabbcc\\") == True assert can_form_palindrome(\\"aabbccd\\") == True assert can_form_palindrome(\\"aabbccde\\") == False assert can_form_palindrome(\\"a\\") == True assert can_form_palindrome(\\"aa\\") == True def test_process_test_cases(): assert process_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(2, [\\"aabb\\", \\"abc\\"]) == [\\"YES\\", \\"NO\\"] assert process_test_cases(1, [\\"xxyzzyxx\\"]) == [\\"YES\\"] assert process_test_cases(4, [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Checks if a given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def process_test_cases(T, strings): results = [] for s in strings: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_additional_characters_to_secure(password: str) -> int: Returns the minimum number of characters needed to add to make the password secure. >>> min_additional_characters_to_secure(\\"Ab1eFgH\\") 0 >>> min_additional_characters_to_secure(\\"ab1fgh7\\") 1 >>> min_additional_characters_to_secure(\\"A1FGH78\\") 1 >>> min_additional_characters_to_secure(\\"Abcdefg\\") 1 >>> min_additional_characters_to_secure(\\"AbcdeFg1\\") 1 >>> min_additional_characters_to_secure(\\"ab1\\") 5 >>> min_additional_characters_to_secure(\\"1234567\\") 3 >>> min_additional_characters_to_secure(\\"ABCDEFG\\") 3 >>> min_additional_characters_to_secure(\\"abcdefg\\") 3 >>> min_additional_characters_to_secure(\\"aB3\\") 5","solution":"def min_additional_characters_to_secure(password): Returns the minimum number of characters needed to add to make the password secure. has_upper = False has_lower = False has_digit = False has_special = False special_characters = set('!@#%^&*()-+') for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True missing_types = 0 if not has_upper: missing_types += 1 if not has_lower: missing_types += 1 if not has_digit: missing_types += 1 if not has_special: missing_types += 1 # Calculate the number of characters to be added to reach minimum length of 8 min_length_requirement = max(0, 8 - len(password)) # The final number of characters to add is the maximum of missing_types and min_length_requirement return max(missing_types, min_length_requirement)"},{"question":"def find_pair_with_sum(a, target): Returns \\"YES\\" if there exists a pair of elements in sorted list \`a\` that add up to \`target\`, otherwise returns \\"NO\\". >>> find_pair_with_sum([1, 2, 3, 5, 7], 8) \\"YES\\" >>> find_pair_with_sum([1, 2, 3, 5, 7], 10) \\"YES\\" >>> find_pair_with_sum([1, 2, 3, 5, 7], 19) \\"NO\\" >>> find_pair_with_sum([1, 1, 1, 1, 1], 2) \\"YES\\" >>> find_pair_with_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) \\"NO\\" >>> find_pair_with_sum([1, 2, 3, 4, 5], 2) \\"NO\\" >>> find_pair_with_sum([2], 4) \\"NO\\" >>> find_pair_with_sum([], 0) \\"NO\\" >>> find_pair_with_sum([1, 2, 3, 9], 8) \\"NO\\"","solution":"def find_pair_with_sum(a, target): Returns \\"YES\\" if there exists a pair of elements in sorted list \`a\` that add up to \`target\`, otherwise returns \\"NO\\". left, right = 0, len(a) - 1 while left < right: current_sum = a[left] + a[right] if current_sum == target: return \\"YES\\" elif current_sum < target: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def can_be_arranged(n: int, heights: List[int]) -> Tuple[str, Optional[List[int]]]: Determine if the heights can be arranged such that for any three consecutive plants (h1, h2, h3), the middle plant's height is between the other two's heights. If possible, return one such arrangement; otherwise, return \\"Impossible\\". :param n: number of plants :param heights: list of plant heights :return: (\\"Possible\\" or \\"Impossible\\", arrangement or None) >>> can_be_arranged(5, [4, 1, 3, 2, 5]) ('Possible', [1, 5, 2, 4, 3]) >>> can_be_arranged(3, [5, 5, 5]) ('Impossible', None) >>> can_be_arranged(3, [4, 3, 2]) ('Possible', [2, 4, 3]) >>> can_be_arranged(1, [7]) ('Possible', [7]) >>> can_be_arranged(2, [3, 1]) ('Possible', [1, 3]) >>> can_be_arranged(4, [1, 2, 3, 4]) ('Possible', [1, 4, 2, 3])","solution":"def can_be_arranged(n, heights): Determine if the heights can be arranged such that for any three consecutive plants (h1, h2, h3), the middle plant's height is between the other two's heights. If possible, return one such arrangement; otherwise, return \\"Impossible\\". :param n: number of plants :param heights: list of plant heights :return: (\\"Possible\\" or \\"Impossible\\", arrangement or None) if n < 3: return (\\"Possible\\", sorted(heights)) heights.sort() # Check that no two adjacent are the same after sorting for i in range(n - 1): if heights[i] == heights[i + 1]: return (\\"Impossible\\", None) # Middle element always lies between the smallest and the largest, # hence we can just take pairwise elements from start and end left = 0 right = n - 1 result = [] while left <= right: if left == right: # Central element addition result.append(heights[left]) else: result.append(heights[left]) result.append(heights[right]) left += 1 right -= 1 return ('Possible', result)"},{"question":"def can_store_candies(n: int, candies: List[int], capacities: List[int]) -> str: Determine if it is possible to store all types of candies in the jars such that each jar contains candies of exactly one type and the amount of candies do not exceed its capacity. :param n: int - Number of candy types / jars :param candies: list of int - Number of candies of each type :param capacities: list of int - Capacities of each jar :return: str - \\"YES\\" if it is possible to store the candies, otherwise \\"NO\\" >>> can_store_candies(3, [10, 20, 30], [20, 20, 20]) \\"NO\\" >>> can_store_candies(4, [10, 15, 20, 25], [25, 25, 25, 25]) \\"YES\\" pass # Write your code here","solution":"def can_store_candies(n, candies, capacities): Determine if it is possible to store all types of candies in the jars such that each jar contains candies of exactly one type and the amount of candies do not exceed its capacity. :param n: int - Number of candy types / jars :param candies: list of int - Number of candies of each type :param capacities: list of int - Capacities of each jar :return: str - \\"YES\\" if it is possible to store the candies, otherwise \\"NO\\" for i in range(n): if candies[i] > capacities[i]: return \\"NO\\" return \\"YES\\""},{"question":"def max_difficulty_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum difficulty difference Alice and Bob can achieve for each test case. >>> max_difficulty_difference(3, [(5, [1, 3, 6, 8, 10]), (4, [1, 2, 3, 4]), (7, [5, 6, 8, 9, 10, 12, 15])]) [9, 3, 10] >>> max_difficulty_difference(1, [(5, [7, 7, 7, 7, 7])]) [0] >>> max_difficulty_difference(1, [(5, [0, 0, 0, 0, 0])]) [0]","solution":"def max_difficulty_difference(T, test_cases): result = [] for case in test_cases: N, difficulties = case max_diff = 0 for i in range(len(difficulties)//2): max_diff = max(max_diff, abs(difficulties[i] - difficulties[N-i-1])) result.append(max_diff) return result"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Find the maximum sum of any contiguous subarray of the list. Note that the empty subarray is not allowed. Examples: >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4, -5, -6]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([10**9, -10**9, 10**9, -10**9, 10**9]) 10**9 >>> max_subarray_sum([0, 0, 0, 0, 0]) 0 >>> max_subarray_sum([2, 2, 2, 2, 2]) 10 >>> max_subarray_sum([-2, -2, -2, -2, -2]) -2","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def preprocess_chessboard(chessboard: List[List[int]]) -> List[List[int]]: Preprocesses the chessboard to create a prefix sum matrix. Args: chessboard: List of List of integers representing the values in the cells of the chessboard. Returns: A 2D list where prefix_sum[i][j] represents the sum of all cells from (1,1) to (i,j). pass def query_sum(prefix_sum: List[List[int]], x1: int, y1: int, x2: int, y2: int) -> int: Computes the sum of the values in the sub-board defined by the corners (x1, y1) and (x2, y2). Args: prefix_sum: The 2D prefix sum array. x1, y1, x2, y2: Coordinates of the top-left and bottom-right corners of the sub-board. Returns: The sum of the values in the sub-board. pass def solve_chessboard_queries(N: int, Q: int, chessboard: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Solves multiple queries about the sum of treasures in sub-boards of the chessboard. Args: N: Size of the chessboard (NxN). Q: Number of queries. chessboard: List of List of integers representing the values in the cells of the chessboard. queries: List of tuples where each tuple contains four integers (x1, y1, x2, y2) representing the corners of the sub-board. Returns: A list of integers where each integer represents the sum of values in the given sub-board for each query. pass # Unit tests def test_preprocess_chessboard(): chessboard = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_prefix_sum = [ [0, 0, 0, 0, 0], [0, 1, 3, 6, 10], [0, 6, 14, 24, 36], [0, 15, 33, 54, 78], [0, 28, 60, 96, 136] ] assert preprocess_chessboard(chessboard) == expected_prefix_sum def test_query_sum(): prefix_sum = [ [0, 0, 0, 0, 0], [0, 1, 3, 6, 10], [0, 6, 14, 24, 36], [0, 15, 33, 54, 78], [0, 28, 60, 96, 136] ] assert query_sum(prefix_sum, 1, 1, 2, 2) == 14 # 1+2+5+6 assert query_sum(prefix_sum, 2, 2, 3, 3) == 34 # 6+7+10+11 assert query_sum(prefix_sum, 1, 1, 4, 4) == 136 # All cells def test_solve_chessboard_queries(): N = 4 Q = 3 chessboard = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3), (1, 1, 4, 4) ] expected_results = [14, 34, 136] assert solve_chessboard_queries(N, Q, chessboard, queries) == expected_results","solution":"def preprocess_chessboard(chessboard): N = len(chessboard) prefix_sum = [[0] * (N + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, N + 1): prefix_sum[i][j] = (chessboard[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) return prefix_sum def query_sum(prefix_sum, x1, y1, x2, y2): return (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]) def solve_chessboard_queries(N, Q, chessboard, queries): prefix_sum = preprocess_chessboard(chessboard) results = [] for query in queries: x1, y1, x2, y2 = query results.append(query_sum(prefix_sum, x1, y1, x2, y2)) return results"},{"question":"def min_insertions_to_make_palindrome(s: str) -> int: Determine the minimum number of characters to insert to make a string a palindrome. >>> min_insertions_to_make_palindrome(\\"ab\\") 1 >>> min_insertions_to_make_palindrome(\\"abc\\") 2 pass def solve_palindrome_problems(T: int, test_cases: List[str]) -> List[int]: Solve multiple palindrome problems. >>> solve_palindrome_problems(2, [\\"ab\\", \\"abc\\"]) [1, 2] pass from solution import solve_palindrome_problems def test_example_cases(): assert solve_palindrome_problems(2, [\\"ab\\", \\"abc\\"]) == [1, 2] def test_single_character(): assert solve_palindrome_problems(2, [\\"a\\", \\"b\\"]) == [0, 0] def test_palindrome_already(): assert solve_palindrome_problems(1, [\\"racecar\\"]) == [0] def test_no_characters_needed(): assert solve_palindrome_problems(1, [\\"aabaa\\"]) == [0] def test_multiple_cases(): assert solve_palindrome_problems(3, [\\"abba\\", \\"abcd\\", \\"a\\"]) == [0, 3, 0] def test_large_string(): assert solve_palindrome_problems(1, [\\"a\\" * 1000]) == [0] assert solve_palindrome_problems(1, [\\"a\\" * 500 + \\"b\\" * 500]) == [500]","solution":"def min_insertions_to_make_palindrome(s): n = len(s) # Create a table to store results of subproblems table = [[0 for x in range(n)] for y in range(n)] # Fill the table for gap in range(1, n): for l in range(n - gap): h = l + gap if s[l] == s[h]: table[l][h] = table[l + 1][h - 1] else: table[l][h] = min(table[l][h - 1], table[l + 1][h]) + 1 return table[0][n - 1] def solve_palindrome_problems(T, test_cases): results = [] for s in test_cases: results.append(min_insertions_to_make_palindrome(s)) return results"},{"question":"import sys from collections import deque, defaultdict def find_shortest_cycle(n, m, edges): Detect the presence of cycles in a directed graph and determine the length of the shortest cycle if they exist. Arguments: n (int): Number of sections. m (int): Number of directed airflows. edges (List[Tuple[int, int]]): List of edges representing air flows from section xi to section yi. Returns: str: Length of the shortest cycle, or \\"No cycle\\" if no cycle is found. pass def main(): Reads input, processes each dataset and calls find_shortest_cycle. input_data = sys.stdin.read().strip().split('n') index = 0 while index < len(input_data): n, m = map(int, input_data[index].split()) if n == 0 and m == 0: break edges = [] for _ in range(m): index += 1 x, y = map(int, input_data[index].split()) edges.append((x, y)) find_shortest_cycle(n, m, edges) index += 1 if __name__ == \\"__main__\\": main()","solution":"import sys from collections import deque, defaultdict def find_shortest_cycle(n, m, edges): if n == 0 and m == 0: return def bfs(start): dist = [-1] * (n + 1) queue = deque([(start, -1)]) dist[start] = 0 while queue: current, parent = queue.popleft() for neighbor in graph[current]: if dist[neighbor] == -1: dist[neighbor] = dist[current] + 1 queue.append((neighbor, current)) elif neighbor != parent: return dist[current] + dist[neighbor] + 1 return float('inf') graph = defaultdict(list) for x, y in edges: graph[x].append(y) shortest_cycle = float('inf') for i in range(1, n + 1): shortest_cycle = min(shortest_cycle, bfs(i)) if shortest_cycle == float('inf'): print(\\"No cycle\\") else: print(shortest_cycle) def main(): input_data = sys.stdin.read().strip().split('n') index = 0 while index < len(input_data): n, m = map(int, input_data[index].split()) if n == 0 and m == 0: break edges = [] for _ in range(m): index += 1 x, y = map(int, input_data[index].split()) edges.append((x, y)) find_shortest_cycle(n, m, edges) index += 1 if __name__ == \\"__main__\\": main()"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Return a new array where each element at index \`i\` is equal to the product of all the elements in the original array except the one at \`i\`. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1, 1]) [1, 1, 1, 1, 1] >>> product_except_self([1, 2, 0, 4, 5]) [0, 0, 40, 0, 0] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): n = len(nums) if n == 0: return [] # Initialize the arrays left_products = [1] * n right_products = [1] * n result = [0] * n # Construct the left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Construct the right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the result array for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def max_sum_of_non_overlapping_subarrays(N: int, K: int, A: List[int]) -> int: Returns the maximum sum of non-overlapping subarrays of length K. >>> max_sum_of_non_overlapping_subarrays(5, 2, [1, 2, 3, 4, 5]) == 9 >>> max_sum_of_non_overlapping_subarrays(7, 3, [4, 2, 1, 3, 7, 6, 5]) == 18 >>> max_sum_of_non_overlapping_subarrays(3, 1, [1, 2, 3]) == 3 >>> max_sum_of_non_overlapping_subarrays(6, 6, [1, 2, 1, 2, 1, 2]) == 9 >>> max_sum_of_non_overlapping_subarrays(5, 5, [5, 4, 3, 2, 3]) == 17 >>> max_sum_of_non_overlapping_subarrays(4, 4, [1, 1, 1, 1]) == 4 >>> max_sum_of_non_overlapping_subarrays(0, 0, []) == 0 >>> max_sum_of_non_overlapping_subarrays(0, 1, []) == 0 >>> max_sum_of_non_overlapping_subarrays(1, 0, [1]) == 0 >>> max_sum_of_non_overlapping_subarrays(1, 1, [10000]) == 10000 >>> max_sum_of_non_overlapping_subarrays(2, 1, [10, 100]) == 100 >>> max_sum_of_non_overlapping_subarrays(2, 2, [1, 1]) == 2","solution":"def max_sum_of_non_overlapping_subarrays(N, K, A): Returns the maximum sum of non-overlapping subarrays of length K. if K > N: return 0 max_sum = 0 current_sum = sum(A[:K]) max_sum = current_sum for i in range(K, N): current_sum += A[i] - A[i - K] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from math import gcd from functools import reduce def can_make_equal_with_k_operations(n: int, k: int, arr: List[int]) -> str: Determine if it's possible to make all elements of the array equal using at most k operations. Args: n (int): The number of elements in the array. k (int): The maximum number of operations allowed. arr (List[int]): The elements of the array. Returns: str: \\"YES\\" if all elements can be made equal, otherwise \\"NO\\". >>> can_make_equal_with_k_operations(4, 3, [3, 9, 6, 12]) \\"YES\\" >>> can_make_equal_with_k_operations(5, 2, [1, 4, 6, 8, 10]) \\"NO\\"","solution":"from math import gcd from functools import reduce def can_make_equal_with_k_operations(n, k, arr): if n == 1: return \\"YES\\" # Compute the GCD of the array array_gcd = reduce(gcd, arr) # Reduce all elements by the GCD normalized_arr = [x // array_gcd for x in arr] # Find how many unique values are left unique_values = len(set(normalized_arr)) # If unique values count exceeds k+1, it's impossible if unique_values > k + 1: return \\"NO\\" return \\"YES\\""},{"question":"def lcs(X, Y): Returns the longest common subsequence of X and Y. >>> lcs(\\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\", \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\") \\"GTCGTCGGAAGCCGGCCGAA\\" >>> lcs(\\"AGGTAB\\", \\"GXTXAYB\\") \\"GTAB\\" def process_input(input_lines): Processes the input lines and returns the LCS for each pair of lines. >>> input_lines = [ \\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAAn\\", \\"GTCGTTCGGAATGCCGTTGCTCTGTAAAn\\", \\"n\\", \\"AGGTABn\\", \\"GXTXAYBn\\", \\"n\\", \\"#n\\" ] >>> process_input(input_lines) == [ \\"GTCGTCGGAAGCCGGCCGAA\\", \\"GTAB\\" ]","solution":"def lcs(X, Y): Returns the longest common subsequence of X and Y. m = len(X) n = len(Y) # Create a table to store lengths of longest common subsequence. L = [[None] * (n + 1) for i in range(m + 1)] # Build the L table in bottom-up fashion. for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) # Create a variable to store the LCS string. lcs_str = [] # Start from the right-most-bottom-most corner and # one by one store characters in lcs_str. i = m j = n while i > 0 and j > 0: # If current character in X and Y are same, then # current character is part of LCS. if X[i-1] == Y[j-1]: lcs_str.append(X[i-1]) i -= 1 j -= 1 # If not same, find the larger of two and # go in the direction of larger value. elif L[i-1][j] > L[i][j-1]: i -= 1 else: j -= 1 # We traverse the string from the end, so reverse it. lcs_str.reverse() return ''.join(lcs_str) def process_input(input_lines): results = [] i = 0 while i < len(input_lines): line1 = input_lines[i].strip() if line1 == '#': break line2 = input_lines[i+1].strip() results.append(lcs(line1, line2)) i += 3 # Move to the next pair of input lines. return results"},{"question":"import re def process_template(template: str, values: dict) -> str: Processes the template string by replacing all placeholders with the corresponding values from the dictionary. >>> process_template(\\"Hello, {name}!\\", {\\"name\\": \\"Alice\\"}) \\"Hello, Alice!\\" >>> process_template(\\"{greeting}, how are you, {name}?\\", {\\"greeting\\": \\"Hi\\", \\"name\\": \\"Bob\\"}) \\"Hi, how are you, Bob?\\" >>> process_template(\\"This is a {adjective} day.\\", {}) \\"This is a day.\\"","solution":"import re def process_template(template, values): Processes the template string by replacing all placeholders with the corresponding values from the dictionary. :param template: str - the template string containing placeholders :param values: dict - dictionary where keys are placeholders without curly braces and values are the replacements :return: str - the processed template string # Create a regular expression pattern for matching placeholders pattern = re.compile(r'{(w+)}') # Function to replace each match def replace_placeholder(match): key = match.group(1) return values.get(key, \\"\\") # Substitute the placeholders with their corresponding values result = pattern.sub(replace_placeholder, template) return result"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def min_rooms_to_visit(n: int, m: int, hallways: List[Tuple[int, int]]) -> int: Calculate the total minimum number of rooms the robot must visit to deliver all packages to accessible rooms. >>> min_rooms_to_visit(6, 6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) 5 >>> min_rooms_to_visit(4, 2, [(0, 1), (2, 3)]) 2 >>> min_rooms_to_visit(1, 0, []) 1 >>> min_rooms_to_visit(5, 2, [(0, 1), (3, 4)]) 2 >>> min_rooms_to_visit(5, 4, [(0, 1), (1, 2), (2, 3), (3, 4)]) 5","solution":"from collections import deque, defaultdict def min_rooms_to_visit(n, m, hallways): graph = defaultdict(list) for u, v in hallways: graph[u].append(v) visited = [False] * n queue = deque([0]) visited[0] = True visited_rooms = 1 while queue: room = queue.popleft() for next_room in graph[room]: if not visited[next_room]: visited[next_room] = True visited_rooms += 1 queue.append(next_room) return visited_rooms"},{"question":"def min_energy_path(matrix: List[List[int]]) -> int: Given a 2D matrix where each cell contains the energy needed to occupy that cell, this function finds the minimum energy required to move from the top-left to the bottom-right cell moving only right or down. >>> min_energy_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_energy_path([[1, 2], [1, 1]]) 3 >>> min_energy_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_energy_path([[5]]) 5 >>> min_energy_path([[1, 2, 3, 4, 5]]) 15 >>> min_energy_path([[1], [2], [3], [4], [5]]) 15 >>> min_energy_path([[1000] * 100 for _ in range(100)]) 199000","solution":"def min_energy_path(matrix): Given a 2D matrix where each cell contains the energy needed to occupy that cell, this function finds the minimum energy required to move from the top-left to the bottom-right cell moving only right or down. if not matrix or not matrix[0]: return 0 R, C = len(matrix), len(matrix[0]) dp = [[0] * C for _ in range(R)] dp[0][0] = matrix[0][0] for i in range(1, R): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, C): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, R): for j in range(1, C): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[R-1][C-1]"},{"question":"def decode_rle(encoded_str: str) -> str: Decodes a run-length encoded (RLE) string. Parameters: encoded_str (str): The RLE encoded string (e.g., 'a3b2c1'). Returns: str: The original uncompressed string (e.g., 'aaabbc'). Examples: >>> decode_rle(\\"a3b2c1\\") 'aaabbc' >>> decode_rle(\\"a5b4c3\\") 'aaaaabbbbccc' >>> decode_rle(\\"a1\\") 'a' >>> decode_rle(\\"a10b2\\") 'aaaaaaaaaabb' >>> decode_rle(\\"a1b1c1d1\\") 'abcd' >>> decode_rle(\\"a1b10c2\\") 'abbbbbbbbbbcc'","solution":"def decode_rle(encoded_str): Decodes a run-length encoded (RLE) string. Parameters: encoded_str (str): The RLE encoded string (e.g., 'a3b2c1'). Returns: str: The original uncompressed string (e.g., 'aaabbc'). decoded_str = \\"\\" i = 0 while i < len(encoded_str): # Extract the character char = encoded_str[i] i += 1 # Extract the number num = 0 while i < len(encoded_str) and encoded_str[i].isdigit(): num = num * 10 + int(encoded_str[i]) i += 1 # Append the decoded sequence to the output string decoded_str += char * num return decoded_str"},{"question":"def min_delivery_vans(packages, capacity): Calculate the minimum number of delivery vans required to deliver all the packages. Parameters: packages (List[int]): The weights of the packages. capacity (int): The maximum weight a delivery van can carry. Returns: int: The minimum number of delivery vans required. >>> min_delivery_vans([4, 8, 1, 7, 3], 10) 3 >>> min_delivery_vans([9, 8, 6], 10) 3","solution":"def min_delivery_vans(packages, capacity): Calculate the minimum number of delivery vans required to deliver all the packages. Parameters: packages (List[int]): The weights of the packages. capacity (int): The maximum weight a delivery van can carry. Returns: int: The minimum number of delivery vans required. if not packages: return 0 packages.sort(reverse=True) vans = 0 n = len(packages) used = [False] * n for i in range(n): if not used[i]: current_capacity = capacity for j in range(i, n): if not used[j] and packages[j] <= current_capacity: current_capacity -= packages[j] used[j] = True vans += 1 return vans"},{"question":"def defuse_bombs(N: int, M: int, connections: List[Tuple[int, int, int]]) -> Union[int, List[List[int]]]: Find the sequence of wire cuts such that all bombs are defused without causing a detonation. >>> defuse_bombs(4, 4, [(1, 2, 5), (2, 3, 8), (3, 4, 6), (1, 3, 4)]) [[1, 2], [2, 3], [3, 4]] >>> defuse_bombs(3, 3, [(1, 2, 3), (2, 3, 2), (1, 3, 1)]) [[1, 2], [2, 3]] >>> defuse_bombs(5, 5, [(1, 2, 7), (2, 3, 2), (3, 4, 5), (4, 5, 4), (5, 1, 8)]) -1 >>> defuse_bombs(2, 1, [(1, 2, 2)]) [[1, 2]] from solution import defuse_bombs def test_case_1(): N = 4 M = 4 connections = [ (1, 2, 5), (2, 3, 8), (3, 4, 6), (1, 3, 4) ] result = defuse_bombs(N, M, connections) assert result == [[1, 2], [2, 3], [3, 4]] def test_case_2(): N = 3 M = 3 connections = [ (1, 2, 3), (2, 3, 2), (1, 3, 1) ] result = defuse_bombs(N, M, connections) assert result == [[1, 2], [2, 3]] def test_case_3(): N = 5 M = 5 connections = [ (1, 2, 7), (2, 3, 2), (3, 4, 5), (4, 5, 4), (5, 1, 8) ] result = defuse_bombs(N, M, connections) assert result == -1 def test_case_4(): N = 2 M = 1 connections = [ (1, 2, 2) ] result = defuse_bombs(N, M, connections) assert result == [[1, 2]]","solution":"def defuse_bombs(N, M, connections): from collections import defaultdict, deque def topological_sort(N, adjacency_list, in_degree): queue = deque([i for i in range(1, N + 1) if in_degree[i] == 0]) sorted_order = [] while queue: node = queue.popleft() sorted_order.append(node) for neighbor in adjacency_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return sorted_order if len(sorted_order) == N else [] adjacency_list = defaultdict(list) in_degree = [0] * (N + 1) for a, b, t in connections: adjacency_list[a].append(b) in_degree[b] += 1 sorted_bombs = topological_sort(N, adjacency_list, in_degree) if not sorted_bombs: return -1 return [sorted_bombs[i:i+2] for i in range(len(sorted_bombs)-1)] # Example of input N = 4 M = 4 connections = [ (1, 2, 5), (2, 3, 8), (3, 4, 6), (1, 3, 4) ] print(defuse_bombs(N, M, connections))"},{"question":"def find_unique_path(n: int, m: int) -> list: Finds a unique path in n x m grid visiting each cell exactly once. Returns the path as a list of tuples (x, y), or returns -1 if such a path is impossible. >>> find_unique_path(1, 1) [(1, 1)] >>> find_unique_path(2, 2) [(1, 1), (1, 2), (2, 2), (2, 1)] >>> find_unique_path(3, 3) [(1, 1), (1, 2), (1, 3), (2, 3), (2, 2), (2, 1), (3, 1), (3, 2), (3, 3)] >>> find_unique_path(1, 3) [(1, 1), (1, 2), (1, 3)] >>> find_unique_path(4, 1) [(1, 1), (2, 1), (3, 1), (4, 1)] from solution import find_unique_path def test_1x1_grid(): assert find_unique_path(1, 1) == [(1, 1)] def test_2x2_grid(): assert find_unique_path(2, 2) == [(1, 1), (1, 2), (2, 2), (2, 1)] def test_3x3_grid(): assert find_unique_path(3, 3) == [(1, 1), (1, 2), (1, 3), (2, 3), (2, 2), (2, 1), (3, 1), (3, 2), (3, 3)] def test_1x3_grid(): assert find_unique_path(1, 3) == [(1, 1), (1, 2), (1, 3)] def test_4x1_grid(): assert find_unique_path(4, 1) == [(1, 1), (2, 1), (3, 1), (4, 1)] def test_larger_grid(): n, m = 4, 4 expected_path = [ (1, 1), (1, 2), (1, 3), (1, 4), (2, 4), (2, 3), (2, 2), (2, 1), (3, 1), (3, 2), (3, 3), (3, 4), (4, 4), (4, 3), (4, 2), (4, 1) ] assert find_unique_path(n, m) == expected_path","solution":"def find_unique_path(n, m): This function finds a unique path to visit each cell in an n x m grid exactly once. Returns the path as a list of tuples (x, y), or returns -1 if such a path is impossible. # Check impossible condition, which does not exist in this problem as per given constraints # Given constraints say 1 ≤ n ⋅ m ≤ 10^6, there is always a valid path for any n, m combination path = [] for i in range(n): if i % 2 == 0: # Even row for j in range(m): path.append((i + 1, j + 1)) else: # Odd row for j in range(m - 1, -1, -1): path.append((i + 1, j + 1)) return path"},{"question":"def custom_evaluate(expression: str) -> int: Evaluate the expression containing digits, '+' and '*', by performing all multiplications before additions. >>> custom_evaluate(\\"2+3*4+5\\") 19 >>> custom_evaluate(\\"1+2*3+4*5+6\\") 33 >>> custom_evaluate(\\"5\\") 5 >>> custom_evaluate(\\"1+2+3+4\\") 10 >>> custom_evaluate(\\"2*3*4\\") 24 >>> custom_evaluate(\\"1+2*2+3*3+4*4+5\\") 37 >>> custom_evaluate(\\"1*1+1*2+2*2\\") 7","solution":"def custom_evaluate(expression): Evaluate the expression by performing all multiplications before additions. # Split the expression by '+', which will give us a list of multiplications addition_segments = expression.split('+') # Calculate the result for each multiplication segment total_sum = 0 for segment in addition_segments: # Split the segment by '*' and calculate the product product = 1 for num in segment.split('*'): product *= int(num) # Add the product of the segment to total_sum total_sum += product return total_sum"},{"question":"def rank_participants(n: int, participants: List[Tuple[str, int]]) -> List[str]: Returns the list of participants ranked based on their scores. If two participants have the same score, they are sorted alphabetically. pass def process_input(data: str) -> Tuple[int, List[Tuple[str, int]]]: Process input data and returns list of participants with their scores. >>> process_input(\\"5nalice 2500nbob 3600neve 3600ncharlie 2000ndan 3050\\") (5, [('alice', 2500), ('bob', 3600), ('eve', 3600), ('charlie', 2000), ('dan', 3050)]) pass from typing import List, Tuple def test_rank_participants_example_1(): data = 5 alice 2500 bob 3600 eve 3600 charlie 2000 dan 3050 n, participants = process_input(data) result = rank_participants(n, participants) expected = [ \\"1 bob 3600\\", \\"2 eve 3600\\", \\"3 dan 3050\\", \\"4 alice 2500\\", \\"5 charlie 2000\\" ] assert result == expected def test_rank_participants_example_2(): data = 3 anna 5000 zoe 5000 lucas 4500 n, participants = process_input(data) result = rank_participants(n, participants) expected = [ \\"1 anna 5000\\", \\"2 zoe 5000\\", \\"3 lucas 4500\\" ] assert result == expected def test_tie_with_different_names(): data = 4 john 7000 doe 7000 jane 6000 alice 8000 n, participants = process_input(data) result = rank_participants(n, participants) expected = [ \\"1 alice 8000\\", \\"2 doe 7000\\", \\"3 john 7000\\", \\"4 jane 6000\\" ] assert result == expected def test_edge_case_with_one_participant(): data = 1 onlyone 1000 n, participants = process_input(data) result = rank_participants(n, participants) expected = [ \\"1 onlyone 1000\\" ] assert result == expected def test_all_with_same_score(): data = 3 lila 1000 mina 1000 nina 1000 n, participants = process_input(data) result = rank_participants(n, participants) expected = [ \\"1 lila 1000\\", \\"2 mina 1000\\", \\"3 nina 1000\\" ] assert result == expected","solution":"def rank_participants(n, participants): Returns the list of participants ranked based on their scores. If two participants have the same score, they are sorted alphabetically. # Sort participants first by score (descending), then by name (alphabetical) sorted_participants = sorted(participants, key=lambda x: (-x[1], x[0])) # Create the ranking result ranking_result = [] for index, (name, score) in enumerate(sorted_participants): ranking_result.append(f\\"{index + 1} {name} {score}\\") return ranking_result def process_input(data): Process input data and returns list of participants with their scores. data_lines = data.strip().split('n') n = int(data_lines[0].strip()) participants = [] for line in data_lines[1:]: name, score = line.split() participants.append((name, int(score))) return n, participants"},{"question":"def shortest_length_after_removals(t: int, cases: List[str]) -> List[int]: Returns the shortest length of the string that you can obtain after performing the described removals. Parameters: t (int): The number of test cases. cases (list of str): List of strings for each test case. Returns: list of int: The length of the shortest string for each test case. >>> shortest_length_after_removals(3, [\\"ab\\", \\"aa\\", \\"abc\\"]) [2, 0, 3] >>> shortest_length_after_removals(2, [\\"abcd\\", \\"abba\\"]) [4, 0]","solution":"def shortest_length_after_removals(t, cases): Returns the shortest length of the string that you can obtain after performing the described removals. Parameters: t (int): The number of test cases. cases (list of str): List of strings for each test case. Returns: list of int: The length of the shortest string for each test case. results = [] for s in cases: stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) results.append(len(stack)) return results # Example usage of the function t = 3 cases = [\\"ab\\", \\"aa\\", \\"abc\\"] print(shortest_length_after_removals(t, cases)) # Output: [2, 0, 3]"},{"question":"def find_local_peaks(n: int, member_productivities: List[List[int]]) -> List[List[int]]: Returns the indices of the local peaks for each team member. Parameters: n (int): Number of team members. member_productivities (List[List[int]]): List of productivity lists for each team member. Returns: List[List[int]]: List of lists containing the indices of local peaks for each team member. pass # Example Usage print(find_local_peaks(3, [[1, 3, 2, 4, 1, 5], [10, 9, 8, 7, 6], [5, 5, 5, 5, 5]])) # Output: [[2, 4, 6], [1], [1, 2, 3, 4, 5]] # Unit Tests def test_find_local_peaks_single_member(): assert find_local_peaks(1, [[1, 3, 2, 4, 1, 5]]) == [[2, 4, 6]] def test_find_local_peaks_decreasing_productivity(): assert find_local_peaks(1, [[10, 9, 8, 7, 6]]) == [[1]] def test_find_local_peaks_equal_productivity(): assert find_local_peaks(1, [[5, 5, 5, 5, 5]]) == [[1, 2, 3, 4, 5]] def test_find_local_peaks_multiple_members(): assert find_local_peaks(3, [[1, 3, 2, 4, 1, 5], [10, 9, 8, 7, 6], [5, 5, 5, 5, 5]]) == [[2, 4, 6], [1], [1, 2, 3, 4, 5]] def test_find_local_peaks_single_day(): assert find_local_peaks(1, [[4]]) == [[1]] def test_find_local_peaks_two_elements(): assert find_local_peaks(1, [[4, 3]]) == [[1]] assert find_local_peaks(1, [[3, 4]]) == [[2]] assert find_local_peaks(1, [[4, 4]]) == [[1, 2]]","solution":"def find_local_peaks(n, member_productivities): Returns the indices of the local peaks for each team member. Parameters: n (int): Number of team members. member_productivities (List[List[int]]): List of productivity lists for each team member. Returns: List[List[int]]: List of lists containing the indices of local peaks for each team member. result = [] for productivity in member_productivities: peaks = [] k = len(productivity) if k == 1: peaks.append(1) else: if productivity[0] >= productivity[1]: peaks.append(1) for i in range(1, k-1): if productivity[i] >= productivity[i-1] and productivity[i] >= productivity[i+1]: peaks.append(i + 1) if productivity[k-1] >= productivity[k-2]: peaks.append(k) result.append(peaks) return result"},{"question":"def shortest_subarray_to_sort(arr: List[int]) -> int: Given an integer array, determine the length of the shortest subarray that, if sorted, would make the entire array sorted in non-decreasing order. >>> shortest_subarray_to_sort([2, 6, 4, 8, 10]) == 2 >>> shortest_subarray_to_sort([1, 3, 5, 4, 2, 8, 10]) == 4 >>> shortest_subarray_to_sort([1, 2, 3, 4, 5]) == 0 >>> shortest_subarray_to_sort([5, 4, 3, 2, 1]) == 5 >>> shortest_subarray_to_sort([1, 2, 3, 3, 2, 2, 4]) == 4 >>> shortest_subarray_to_sort([1]) == 0 >>> shortest_subarray_to_sort([1, 1, 1, 1, 1]) == 0 >>> shortest_subarray_to_sort([1, 3, 5, 7, 9, 8, 10]) == 2","solution":"def shortest_subarray_to_sort(arr): n = len(arr) if n <= 1: return 0 left, right = 0, n - 1 # find the first element from the left which is out of order while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 if left == n - 1: return 0 # find the first element from the right which is out of order while right > 0 and arr[right] >= arr[right - 1]: right -= 1 subarray_max = max(arr[left:right + 1]) subarray_min = min(arr[left:right + 1]) # extend left bound to include any elements that need sorting while left > 0 and arr[left - 1] > subarray_min: left -= 1 # extend right bound to include any elements that need sorting while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return right - left + 1"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Calculate the maximum sum of any subarray of size k. Parameters: arr (list of int): The array of integers. k (int): The size of the subarray. Returns: int: The maximum sum of any subarray of size k. >>> max_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5], 3) 6 >>> max_sum_subarray([4, 3, -2, 6, -5], 2) 7 >>> max_sum_subarray([3], 1) 3 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4], 4) 6 >>> max_sum_subarray([1, 5, -3, 4, 2], 1) 5","solution":"def max_sum_subarray(arr, k): Calculate the maximum sum of any subarray of size k. Parameters: arr (list of int): The array of integers. k (int): The size of the subarray. Returns: int: The maximum sum of any subarray of size k. n = len(arr) if n < k: return 0 # If the array size is less than k, return 0 # Calculate the initial window's sum window_sum = sum(arr[:k]) max_sum = window_sum # Slide the window across the array for i in range(n - k): window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def can_sort_via_reversals(n, k, arr): Determines if it is possible to sort the array using the described moves. Parameters: n (int): Length of the array k (int): Length of the subarray to be reversed arr (list of int): The elements of the array Returns: str: 'YES' if the array can be sorted, otherwise 'NO'","solution":"def can_sort_via_reversals(n, k, arr): Determines if it is possible to sort the array using the described moves. Parameters: n (int): Length of the array k (int): Length of the subarray to be reversed arr (list of int): The elements of the array Returns: str: 'YES' if the array can be sorted, otherwise 'NO' if k == 1: return 'YES' if arr == sorted(arr) else 'NO' sorted_arr = sorted(arr) for i in range(k): if arr[i::k] != sorted(arr[i::k]): return 'NO' return 'YES'"},{"question":"def count_top_performers(n: int, times: List[int]) -> int: Returns the number of top performers based on their finishing times. A top performer is defined as a participant whose finishing time is better than all previous participants. :param n: Number of participants :type n: int :param times: List of finishing times :type times: List[int] :return: Number of top performers :rtype: int >>> count_top_performers(5, [300, 250, 270, 260, 240]) 3 >>> count_top_performers(6, [1000, 800, 900, 600, 700, 500]) 4 >>> count_top_performers(4, [450, 460, 470, 480]) 1 >>> count_top_performers(1, [300]) 1 >>> count_top_performers(5, [300, 300, 300, 300, 300]) 1 >>> count_top_performers(5, [500, 400, 300, 200, 100]) 5 >>> count_top_performers(5, [100, 200, 300, 400, 500]) 1 >>> count_top_performers(0, []) 0","solution":"def count_top_performers(n, times): Returns the number of top performers based on their finishing times. A top performer is defined as a participant whose finishing time is better than all previous participants. :param n: Number of participants :type n: int :param times: List of finishing times :type times: List[int] :return: Number of top performers :rtype: int if n == 0: return 0 top_performers = 1 # The first participant is always a top performer min_time_so_far = times[0] for i in range(1, n): if times[i] < min_time_so_far: top_performers += 1 min_time_so_far = times[i] return top_performers"},{"question":"class Book: def __init__(self, title: str, author: str, year: int): Initialize a book with a title, author, year, and borrowed status. Args: title (str): The title of the book. author (str): The author of the book. year (int): The year the book was published. pass def __str__(self) -> str: Return a string representation of the book in the format: Title by Author, Year. Returns: str: The string representation of the book. pass def borrow_book(self): Mark the book as borrowed. pass def return_book(self): Mark the book as returned. pass class Library: def __init__(self): Initialize an empty library. pass def add_book(self, book: Book): Add a book to the library. Args: book (Book): The book to add. pass def list_books(self) -> list: List all books in the library. Returns: list: A list of string representations of all books in the library. pass def borrow_book(self, title: str) -> bool: Mark a book as borrowed by title. Args: title (str): The title of the book to borrow. Returns: bool: True if the book was borrowed, False otherwise. pass def return_book(self, title: str) -> bool: Mark a book as returned by title. Args: title (str): The title of the book to return. Returns: bool: True if the book was returned, False otherwise. pass # Example usage # Create book instances book1 = Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) book3 = Book(\\"1984\\", \\"George Orwell\\", 1949) # Create a library instance and add books to it library = Library() library.add_book(book1) library.add_book(book2) library.add_book(book3) # List all books in the library print(library.list_books()) # Borrow a book library.borrow_book(\\"1984\\") # Return a book library.return_book(\\"1984\\") # Unit Tests def test_book_initialization(): book = Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) assert book.title == \\"The Catcher in the Rye\\" assert book.author == \\"J.D. Salinger\\" assert book.year == 1951 assert not book.borrowed def test_book_str(): book = Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) assert str(book) == \\"The Catcher in the Rye by J.D. Salinger, 1951\\" def test_borrow_book(): book = Book(\\"1984\\", \\"George Orwell\\", 1949) book.borrow_book() assert book.borrowed def test_return_book(): book = Book(\\"1984\\", \\"George Orwell\\", 1949) book.borrow_book() book.return_book() assert not book.borrowed def test_library_initialization(): library = Library() assert library.books == [] def test_add_book(): library = Library() book = Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) library.add_book(book) assert len(library.books) == 1 assert library.books[0] == book def test_list_books(): library = Library() book1 = Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(book1) library.add_book(book2) assert library.list_books() == [ \\"The Catcher in the Rye by J.D. Salinger, 1951\\", \\"To Kill a Mockingbird by Harper Lee, 1960\\" ] def test_borrow_book_library(): library = Library() book = Book(\\"1984\\", \\"George Orwell\\", 1949) library.add_book(book) assert library.borrow_book(\\"1984\\") assert book.borrowed assert not library.borrow_book(\\"1984\\") # Can't borrow the same book twice def test_return_book_library(): library = Library() book = Book(\\"1984\\", \\"George Orwell\\", 1949) library.add_book(book) library.borrow_book(\\"1984\\") assert library.return_book(\\"1984\\") assert not book.borrowed assert not library.return_book(\\"1984\\") # Can't return a book that's not borrowed","solution":"class Book: def __init__(self, title, author, year): self.title = title self.author = author self.year = year self.borrowed = False def __str__(self): return f\\"{self.title} by {self.author}, {self.year}\\" def borrow_book(self): self.borrowed = True def return_book(self): self.borrowed = False class Library: def __init__(self): self.books = [] def add_book(self, book): self.books.append(book) def list_books(self): return [str(book) for book in self.books] def borrow_book(self, title): for book in self.books: if book.title == title and not book.borrowed: book.borrow_book() return True return False def return_book(self, title): for book in self.books: if book.title == title and book.borrowed: book.return_book() return True return False"},{"question":"def can_transform(initial: str, desired: str) -> str: Determines if 'desired' is a subsequence of 'initial', indicating if the legendary sword Excalibur can transform its shape. >>> can_transform(\\"excalibur\\", \\"xlr\\") \\"YES\\" >>> can_transform(\\"legendary\\", \\"ledgendaro\\") \\"NO\\" >>> can_transform(\\"magic\\", \\"mic\\") \\"YES\\"","solution":"def can_transform(initial, desired): Determines if 'desired' is a subsequence of 'initial'. Parameters: - initial (str): The initial shape of Excalibur. - desired (str): The desired shape of Excalibur. Returns: - str: \\"YES\\" if the transformation is possible, otherwise \\"NO\\". it = iter(initial) return \\"YES\\" if all(char in it for char in desired) else \\"NO\\""},{"question":"def largest_perfect_square(grid: List[List[int]]) -> int: Find the largest perfect square subgrid that can be formed within the original grid. >>> largest_perfect_square([[1, 1, 1, 2, 2], [1, 1, 1, 2, 2], [1, 1, 1, 2, 2], [3, 3, 3, 4, 4], [3, 3, 3, 4, 4]]) 3 >>> largest_perfect_square([[2, 2, 3], [2, 2, 3], [3, 3, 3]]) 2 >>> largest_perfect_square([[1]]) 1 >>> largest_perfect_square([[4, 4, 4], [4, 4, 4], [4, 4, 4]]) 3 >>> largest_perfect_square([[1, 2], [3, 4]]) 1","solution":"def largest_perfect_square(grid): n = len(grid) def check_square(x, y, size): val = grid[x][y] for i in range(size): for j in range(size): if grid[x + i][y + j] != val: return False return True max_size = 1 for size in range(2, n + 1): found = False for i in range(n - size + 1): for j in range(n - size + 1): if check_square(i, j, size): max_size = size found = True break if found: break return max_size"},{"question":"def max_non_overlapping_intervals(n: int, m: int, intervals: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping intervals. Args: n (int): The number of points. m (int): The number of intervals. intervals (list of tuples): A list where each tuple represents an interval (ai, bi). Returns: int: The maximum number of non-overlapping intervals. Examples: >>> max_non_overlapping_intervals(10, 4, [(1, 3), (2, 6), (5, 8), (7, 10)]) 2 >>> max_non_overlapping_intervals(12, 5, [(1, 4), (2, 5), (3, 6), (7, 10), (8, 11)]) 2 >>> max_non_overlapping_intervals(5, 1, [(1, 5)]) 1 >>> max_non_overlapping_intervals(10, 3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_intervals(8, 4, [(1, 8), (2, 7), (3, 6), (4, 5)]) 1 >>> max_non_overlapping_intervals(5, 0, []) 0","solution":"def max_non_overlapping_intervals(n, m, intervals): Finds the maximum number of non-overlapping intervals. Args: n (int): The number of points. m (int): The number of intervals. intervals (list of tuples): A list where each tuple represents an interval (ai, bi). Returns: int: The maximum number of non-overlapping intervals. # Sort intervals based on the ending points intervals.sort(key=lambda x: x[1]) # Initialize variables to keep track of the last end point last_end = -1 count = 0 # Iterate through the intervals and count non-overlapping ones for interval in intervals: if interval[0] > last_end: count += 1 last_end = interval[1] return count"},{"question":"def total_restock_units(N, data): Calculate the total number of units to be restocked. Args: N (int): The number of products. data (list of tuples): Each tuple contains two integers, the current inventory level i and the minimum required inventory level m for each product. Returns: int: The total number of units that need to be restocked. Examples: >>> total_restock_units(3, [(10, 15), (20, 25), (5, 10)]) 15 >>> total_restock_units(4, [(30, 30), (25, 20), (0, 18), (12, 12)]) 18 >>> total_restock_units(2, [(7, 10), (5, 5)]) 3","solution":"def total_restock_units(N, data): Calculate the total number of units to be restocked. Args: N (int): The number of products. data (list of tuples): Each tuple contains two integers, the current inventory level i and the minimum required inventory level m for each product. Returns: int: The total number of units that need to be restocked. total_units = 0 for i, m in data: if i < m: total_units += m - i return total_units"},{"question":"def bookstore_reports(books, queries): This function processes a list of books and a list of queries and returns the results of the queries. Parameters: books (list of tuples): List of books with each book detail as a tuple (title, author, genre, copies). queries (list of strings): List of queries to process. Returns: list of lists: Results for each query as a list of strings. >>> bookstore_reports([(\\"Book1\\", \\"Author1\\", \\"Fiction\\", 10), (\\"Book2\\", \\"Author2\\", \\"Non-fiction\\", 5)], [\\"title Book1\\"]) == [[\\"Book1 Author1 Fiction 10\\"]] >>> bookstore_reports([(\\"Book1\\", \\"Author1\\", \\"Fiction\\", 10), (\\"Book2\\", \\"Author2\\", \\"Non-fiction\\", 5)], [\\"author Author3\\"]) == [[\\"No results found\\"]]","solution":"def bookstore_reports(books, queries): This function processes a list of books and a list of queries and returns the results of the queries. Parameters: books (list of tuples): List of books with each book detail as a tuple (title, author, genre, copies). queries (list of strings): List of queries to process. Returns: list of lists: Results for each query as a list of strings. results = [] for query in queries: parts = query.split() if parts[0] == 'title': title = parts[1] result = [ f\\"{book[0]} {book[1]} {book[2]} {book[3]}\\" for book in books if book[0] == title ] elif parts[0] == 'author': author = parts[1] result = [ f\\"{book[0]} {book[1]} {book[2]} {book[3]}\\" for book in books if book[1] == author ] elif parts[0] == 'genre': genre = parts[1] result = [ f\\"{book[0]} {book[1]} {book[2]} {book[3]}\\" for book in books if book[2] == genre ] elif parts[0] == 'count': count = int(parts[1]) result = [ f\\"{book[0]} {book[1]} {book[2]} {book[3]}\\" for book in books if book[3] >= count ] result.sort(key=lambda x: int(x.split()[3]), reverse=True) if not result: result = [\\"No results found\\"] results.append(result) return results"},{"question":"from typing import List def shortest_path(n: int, m: int, x1: int, y1: int, x2: int, y2: int, grid: List[str]) -> int: Calculate the shortest path from the starting position to the target position on a grid map. The grid map is represented by a list of strings, where '0' indicates a passable cell and '1' indicates an impassable cell. You can move up, down, left, or right from one cell to an adjacent cell. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. x1 (int): Row number of the starting position (1-based index). y1 (int): Column number of the starting position (1-based index). x2 (int): Row number of the target position (1-based index). y2 (int): Column number of the target position (1-based index). grid (List[str]): The grid representation. Returns: int: The length of the shortest path from the start to the target. If there is no path, return -1. Examples: >>> shortest_path(5, 5, 1, 1, 5, 5, [\\"00000\\", \\"01110\\", \\"01110\\", \\"01110\\", \\"00000\\"]) 8 >>> shortest_path(4, 4, 1, 1, 4, 4, [\\"0010\\", \\"0110\\", \\"0010\\", \\"0000\\"]) 6","solution":"from collections import deque def shortest_path(n, m, x1, y1, x2, y2, grid): def is_valid_move(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '0' start = (x1 - 1, y1 - 1) target = (x2 - 1, y2 - 1) if grid[start[0]][start[1]] == '1' or grid[target[0]][target[1]] == '1': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == (target[0], target[1]): return dist for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, dist + 1)) return -1"},{"question":"def balanced_parentheses(s: str) -> int: Checks if the given string s is balanced and finds the maximum depth of nested parentheses. Args: s (str): A string consisting of characters '(' and ')'. Returns: int: The maximum depth of nested parentheses if the string is balanced, otherwise -1. Examples: >>> balanced_parentheses(\\"((()))\\") 3 >>> balanced_parentheses(\\"(()))\\") -1","solution":"def balanced_parentheses(s): Checks if the given string s is balanced and finds the maximum depth of nested parentheses. Args: s (str): A string consisting of characters '(' and ')'. Returns: int: The maximum depth of nested parentheses if the string is balanced, otherwise -1. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 max_depth = max(max_depth, current_depth) elif char == ')': current_depth -= 1 if current_depth < 0: return -1 # Found more closing than opening parentheses if current_depth != 0: return -1 # Found more opening than closing parentheses return max_depth"},{"question":"def enhance_submatrix(matrix: List[List[int]], r1: int, c1: int, r2: int, c2: int, k: int) -> List[List[int]]: Enhances a submatrix within the given 2D matrix by increasing its grayscale value by k. Values exceeding 255 are capped at 255. Args: matrix (List[List[int]]): The 2D list representing the grayscale values. r1 (int): Row index of the top-left corner of the submatrix. c1 (int): Column index of the top-left corner of the submatrix. r2 (int): Row index of the bottom-right corner of the submatrix. c2 (int): Column index of the bottom-right corner of the submatrix. k (int): The value to increase the grayscale values by. Returns: List[List[int]]: The transformed 2D list. Examples: >>> enhance_submatrix( ... [ ... [100, 100, 100], ... [120, 120, 120], ... [140, 140, 140] ... ], 1, 1, 2, 2, 10) [ [100, 100, 100], [120, 130, 130], [140, 150, 150] ] >>> enhance_submatrix( ... [ ... [50, 50, 50, 50], ... [60, 60, 60, 60], ... [70, 70, 70, 70], ... [80, 80, 80, 80] ... ], 0, 0, 3, 3, 20) [ [70, 70, 70, 70], [80, 80, 80, 80], [90, 90, 90, 90], [100, 100, 100, 100] ] >>> enhance_submatrix( ... [ ... [200, 210], ... [220, 230] ... ], 0, 0, 1, 1, 50) [ [250, 255], [255, 255] ]","solution":"def enhance_submatrix(matrix, r1, c1, r2, c2, k): Enhances a submatrix within the given 2D matrix by increasing its grayscale value by k. Values exceeding 255 are capped at 255. Args: matrix (List[List[int]]): The 2D list representing the grayscale values. r1 (int): Row index of the top-left corner of the submatrix. c1 (int): Column index of the top-left corner of the submatrix. r2 (int): Row index of the bottom-right corner of the submatrix. c2 (int): Column index of the bottom-right corner of the submatrix. k (int): The value to increase the grayscale values by. Returns: List[List[int]]: The transformed 2D list. for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): matrix[i][j] = min(matrix[i][j] + k, 255) return matrix"},{"question":"def find_sums(test_cases): Given a list of test cases where the first element is the number of integers and the remaining are the integers themselves, return a list of the sum of the integers for each test case. >>> find_sums([[4, 1, 2, 3, 4], [3, -1, -2, -3]]) == [10, -6] >>> find_sums([[1, 5], [1, -100]]) == [5, -100] >>> find_sums([[3, 0, 50, -50], [2, 99, 1]]) == [0, 100] >>> find_sums([]) == [] >>> find_sums([[5, 10, -10, 20, -20, 30], [4, -5, -10, -15, -20], [3, 0, 0, 0]]) == [30, -50, 0]","solution":"def find_sums(test_cases): Given a list of test cases where the first element is the number of integers and the remaining are the integers themselves, return a list of the sum of the integers for each test case. results = [] for case in test_cases: n, *elements = case results.append(sum(elements)) return results"},{"question":"def steps_to_palindrome(n: int) -> (int, int): Given a starting number n, returns the number of steps required to reach a palindrome and the resulting palindrome. >>> steps_to_palindrome(28) (2, 121) >>> steps_to_palindrome(89) (24, 8813200023188) >>> steps_to_palindrome(123) (1, 444)","solution":"def reverse_number(n): Reverses the digits of an integer. return int(str(n)[::-1]) def is_palindrome(n): Checks whether an integer is a palindrome. return str(n) == str(n)[::-1] def steps_to_palindrome(n): Returns the number of steps required to reach a palindrome and the resulting palindrome. steps = 0 while not is_palindrome(n): n += reverse_number(n) steps += 1 return steps, n"},{"question":"from typing import List, Tuple def minimum_railway_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Given the number of intersections (n) and roads (m) along with a list of roads (u, v, w), finds the minimum sum of travel times needed to construct the railway system such that each intersection can still be reached from any other intersection. Parameters: n (int): Number of intersections. m (int): Number of roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains (u, v, w), representing a road between intersections u and v with travel time w. Returns: int: Minimum sum of travel times needed to construct the railway system. pass def test_example1(): n = 4 m = 5 roads = [ (1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 4), (3, 4, 7) ] assert minimum_railway_cost(n, m, roads) == 15 def test_example2(): n = 3 m = 3 roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 3) ] assert minimum_railway_cost(n, m, roads) == 3 def test_single_road(): n = 2 m = 1 roads = [ (1, 2, 5) ] assert minimum_railway_cost(n, m, roads) == 5 def test_two_intersections(): n = 3 m = 3 roads = [ (1, 2, 4), (2, 3, 3), (1, 3, 2) ] assert minimum_railway_cost(n, m, roads) == 5 def test_large_input(): n = 6 m = 9 roads = [ (1, 2, 2), (1, 3, 3), (2, 3, 1), (2, 4, 4), (3, 4, 5), (3, 5, 6), (4, 5, 7), (4, 6, 8), (5, 6, 9) ] assert minimum_railway_cost(n, m, roads) == 21","solution":"def minimum_railway_cost(n, m, roads): Given the number of intersections (n) and roads (m) along with a list of roads (u, v, w), finds the minimum sum of travel times needed to construct the railway system such that each intersection can still be reached from any other intersection. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST). # Helper function to find the root of a node with path compression def find(parent, i): if parent[i] == i: return i else: root = find(parent, parent[i]) parent[i] = root return root # Helper function to perform union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort all the edges in non-decreasing order of their weight roads.sort(key=lambda x: x[2]) parent = [] rank = [] # Create parent and rank arrays for node in range(n): parent.append(node) rank.append(0) mst_cost = 0 edges_in_mst = 0 # Number of edges to be taken is equal to V-1 (where V is the number of vertices) for road in roads: u, v, w = road root_u = find(parent, u-1) # Adjusting index for 0-based indexing in arrays root_v = find(parent, v-1) # Adjusting index for 0-based indexing in arrays # If including this edge doesn't cause cycle, include it in result if root_u != root_v: mst_cost += w union(parent, rank, root_u, root_v) edges_in_mst += 1 # Stop if we already have n-1 edges in the MST if edges_in_mst == n - 1: break return mst_cost"},{"question":"def can_be_transformed_by_one_swap(s1, s2: str) -> bool: Check if s1 can be transformed into s2 by exactly one swap. >>> can_be_transformed_by_one_swap(\\"abcd\\", \\"abdc\\") True >>> can_be_transformed_by_one_swap(\\"ab\\", \\"ab\\") True >>> can_be_transformed_by_one_swap(\\"abcd\\", \\"abcd\\") False >>> can_be_transformed_by_one_swap(\\"ab\\", \\"ba\\") True >>> can_be_transformed_by_one_swap(\\"abc\\", \\"bca\\") False def transform_check(T: int, test_cases: list) -> list: Check the list of test cases if one string can be transformed into another by exactly one swap. >>> transform_check(3, [(\\"abcd\\", \\"abdc\\"), (\\"ab\\", \\"ab\\"), (\\"abcd\\", \\"abcd\\")]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> transform_check(2, [(\\"ab\\", \\"ba\\"), (\\"abc\\", \\"bca\\")]) [\\"Yes\\", \\"No\\"] >>> transform_check(1, [(\\"a\\", \\"a\\")]) [\\"No\\"]","solution":"def can_be_transformed_by_one_swap(s1, s2): Check if s1 can be transformed into s2 by exactly one swap. if s1 == s2: return len(s1) == 2 # Find all positions where the characters are different diff = [(a, b) for a, b in zip(s1, s2) if a != b] # Check if there are exactly 2 differences and they are swappable return len(diff) == 2 and diff[0] == diff[1][::-1] def transform_check(T, test_cases): results = [] for s1, s2 in test_cases: if can_be_transformed_by_one_swap(s1, s2): results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Usage example T = 3 test_cases = [(\\"abcd\\", \\"abdc\\"), (\\"ab\\", \\"ab\\"), (\\"abcd\\", \\"abcd\\")] print(transform_check(T, test_cases))"},{"question":"from typing import List, Tuple def minimum_key_codes_to_visit_all_rooms(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum number of unique key codes required to visit all rooms from room 1 to room n. If it's not possible, return -1. Args: n (int): Number of rooms. m (int): Number of doors. edges (List[Tuple[int, int, int]]): List of tuples representing doors, where each tuple contains (starting room, ending room, key code). Returns: int: Minimum number of key codes required to visit all rooms, or -1 if not possible. >>> minimum_key_codes_to_visit_all_rooms(4, 4, [(1, 2, 101), (2, 3, 102), (3, 4, 103), (4, 2, 104)]) 3 >>> minimum_key_codes_to_visit_all_rooms(4, 3, [(1, 2, 201), (2, 3, 202), (3, 1, 203)]) -1 def process_input(input_data: str) -> List[int]: Process input data to determine the minimum number of unique key codes required for multiple datasets. Args: input_data (str): Multiple datasets in a specific format. Returns: List[int]: Results for each dataset. >>> input_data = '''4 4 1 2 101 2 3 102 3 4 103 4 2 104 4 3 1 2 201 2 3 202 3 1 203 0 0''' >>> process_input(input_data) [3, -1]","solution":"def minimum_key_codes_to_visit_all_rooms(n, m, edges): from collections import defaultdict, deque import heapq if n == 0 or m == 0: return -1 # Building the graph graph = defaultdict(list) for a, b, k in edges: graph[a].append((b, k)) # Minimum Priority Queue to perform Dijkstra's algorithm pq = [(0, 1)] # (keys used, current room) visited = set() while pq: keys_used, current_room = heapq.heappop(pq) if current_room in visited: continue visited.add(current_room) if len(visited) == n: return keys_used for neighbor, key in graph[current_room]: if neighbor not in visited: heapq.heappush(pq, (keys_used + 1, neighbor)) return -1 def process_input(input_data): input_lines = input_data.strip().split('n') indices = 0 results = [] while indices < len(input_lines): n, m = map(int, input_lines[indices].split()) if n == 0 and m == 0: break indices += 1 edges = [] for _ in range(m): a, b, k = map(int, input_lines[indices].split()) edges.append((a, b, k)) indices += 1 results.append(minimum_key_codes_to_visit_all_rooms(n, m, edges)) return results"},{"question":"def inventory_queries(n, queries): Processes inventory queries for a retail store. The function processes three types of queries: 1. Add a specified quantity of an item to the inventory. 2. Check if a specified quantity of an item is currently available. 3. Remove a specified quantity of an item from the inventory. Args: n: int - number of queries queries: List[List[int]] - a list of queries, each query represented as [query type, item ID, quantity] Returns: List[bool]: a list of booleans indicating availability for 'check' queries. Example: >>> queries = [ ... [1, 101, 5], # Add 5 of item 101 ... [1, 102, 10], # Add 10 of item 102 ... [2, 101, 3], # Check if 3 of item 101 are available ... [2, 102, 12], # Check if 12 of item 102 are available ... [3, 101, 2], # Remove 2 of item 101 ... [2, 101, 2], # Check if 2 of item 101 are available ... ] >>> inventory_queries(6, queries) [True, False, True] pass def test_add_and_check(): queries = [ [1, 101, 5], # Add 5 of item 101 [1, 102, 10], # Add 10 of item 102 [2, 101, 3], # Check if 3 of item 101 are available [2, 102, 12], # Check if 12 of item 102 are available [3, 101, 2], # Remove 2 of item 101 [2, 101, 2], # Check if 2 of item 101 are available ] assert inventory_queries(6, queries) == [True, False, True] def test_check_nonexistent_item(): queries = [ [2, 999, 1], # Check if 1 of item 999 is available (should be False) ] assert inventory_queries(1, queries) == [False] def test_remove_more_than_available(): queries = [ [1, 103, 5], # Add 5 of item 103 [3, 103, 10], # Remove 10 of item 103 [2, 103, 1], # Check if 1 of item 103 is available (should be False) ] assert inventory_queries(3, queries) == [False] def test_multiple_adds_and_checks(): queries = [ [1, 104, 5], # Add 5 of item 104 [1, 104, 10], # Add 10 more of item 104 [1, 105, 3], # Add 3 of item 105 [2, 104, 8], # Check if 8 of item 104 are available (should be True) [2, 105, 4], # Check if 4 of item 105 are available (should be False) ] assert inventory_queries(5, queries) == [True, False] def test_mix_operations(): queries = [ [1, 106, 7], # Add 7 of item 106 [2, 106, 7], # Check if 7 of item 106 are available (should be True) [3, 106, 4], # Remove 4 of item 106 [2, 106, 4], # Check if 4 of item 106 are available (should be False) [2, 106, 3], # Check if 3 of item 106 are available (should be True) ] assert inventory_queries(5, queries) == [True, False, True]","solution":"def inventory_queries(n, queries): inventory = {} results = [] for query in queries: query_type = query[0] item_id = query[1] quantity = query[2] if query_type == 1: # Add quantity to item_id if item_id in inventory: inventory[item_id] += quantity else: inventory[item_id] = quantity elif query_type == 2: # Check if quantity of item_id is available if item_id in inventory and inventory[item_id] >= quantity: results.append(True) else: results.append(False) elif query_type == 3: # Remove quantity from item_id if item_id in inventory: inventory[item_id] = max(0, inventory[item_id] - quantity) return results"},{"question":"def merge_in_place(A: List[int], B: List[int]) -> Tuple[List[int], List[int]]: Merges two sorted arrays A and B in-place such that A contains the first n smallest elements and B contains the remaining elements. Parameters: A (list[int]): First sorted array. B (list[int]): Second sorted array. Returns: tuple: Tuple containing the modified arrays A and B. >>> A = [1, 3, 5, 7] >>> B = [2, 6, 8] >>> merge_in_place(A, B) ([1, 2, 3, 5], [6, 7, 8]) >>> A = [10, 12, 13] >>> B = [1, 2, 14] >>> merge_in_place(A, B) ([1, 2, 10], [12, 13, 14]) >>> A = [1, 2, 3, 4] >>> B = [5, 6, 7] >>> merge_in_place(A, B) ([1, 2, 3, 4], [5, 6, 7]) >>> A = [8, 10, 12] >>> B = [1, 2, 3] >>> merge_in_place(A, B) ([1, 2, 3], [8, 10, 12]) >>> A = [5, 8, 10] >>> B = [6, 7, 12] >>> merge_in_place(A, B) ([5, 6, 7], [8, 10, 12])","solution":"def merge_in_place(A, B): Merges two sorted arrays A and B in-place such that A contains the first n smallest elements and B contains the remaining elements. Parameters: A (list[int]): First sorted array. B (list[int]): Second sorted array. Returns: tuple: Tuple containing the modified arrays A and B. n = len(A) m = len(B) # Start comparing and swapping from the last element of A and the first element of B for i in range(n): if A[i] > B[0]: A[i], B[0] = B[0], A[i] # After swapping, B[0] might be out of order, so we need to sort B using insertion sort technique first = B[0] k = 1 while k < m and B[k] < first: B[k - 1] = B[k] k += 1 B[k - 1] = first return A, B"},{"question":"from typing import List, Tuple def query_tree(n: int, q: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Perform q queries on a tree with n nodes to find the maximum/minimum value in the subtree of a given node. Args: n (int): Number of nodes in the tree. q (int): Number of queries to be performed. values (List[int]): Values associated with each node. edges (List[Tuple[int, int]]): Edges defining the tree structure. queries (List[Tuple[int, int]]): Queries to perform on the tree. Returns: List[int]: Results of each query. Example: >>> n = 5 >>> q = 3 >>> values = [1, 2, 3, 4, 5] >>> edges = [(1, 2), (1, 3), (1, 4), (1, 5)] >>> queries = [(1, 1), (2, 2), (1, 3)] >>> query_tree(n, q, values, edges, queries) [5, 2, 3] >>> n = 3 >>> q = 3 >>> values = [8, 3, 10] >>> edges = [(1, 2), (1, 3)] >>> queries = [(1, 1), (2, 3), (1, 2)] >>> query_tree(n, q, values, edges, queries) [10, 10, 3]","solution":"from collections import defaultdict def dfs(node, parent, values, adj, max_value, min_value): curr_max = values[node - 1] curr_min = values[node - 1] for neighbor in adj[node]: if neighbor == parent: continue max_sub, min_sub = dfs(neighbor, node, values, adj, max_value, min_value) curr_max = max(curr_max, max_sub) curr_min = min(curr_min, min_sub) max_value[node] = curr_max min_value[node] = curr_min return curr_max, curr_min def query_tree(n, q, values, edges, queries): adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) max_value = [0] * (n + 1) min_value = [0] * (n + 1) # Perform DFS from node 1 dfs(1, -1, values, adj, max_value, min_value) result = [] for t, x in queries: if t == 1: result.append(max_value[x]) elif t == 2: result.append(min_value[x]) return result"},{"question":"def length_of_lis(books: List[int]) -> int: Returns the length of the longest increasing subsequence of book heights. >>> length_of_lis([5, 1, 8, 3, 6, 9]) 4 >>> length_of_lis([1, 2, 3, 4, 5, 6]) 6 >>> length_of_lis([6, 5, 4, 3, 2, 1]) 1 >>> length_of_lis([10, 20, 10, 30, 40, 50]) 5 >>> length_of_lis([]) 0 >>> length_of_lis([2, 2, 2, 2, 2]) 1 >>> length_of_lis([1, 3, 5, 4, 7]) 4","solution":"def length_of_lis(books): Returns the length of the longest increasing subsequence of book heights. if not books: return 0 n = len(books) dp = [1] * n for i in range(1, n): for j in range(i): if books[i] > books[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage: # if __name__ == \\"__main__\\": # N = int(input()) # books = list(map(int, input().split())) # print(length_of_lis(books))"},{"question":"def determine_winner(n: int, k: int, piles: List[int]) -> str: Determines if Alice can guarantee a win in the game. Parameters: n (int): Number of piles k (int): Maximum number of stones Alice can remove with her special move piles (list): List of integers representing the number of stones in each pile Returns: str: \\"Alice\\" if she can guarantee a win, otherwise \\"Bob\\" pass # Unit Tests def test_example_1(): assert determine_winner(3, 2, [1, 4, 2]) == \\"Alice\\" def test_example_2(): assert determine_winner(2, 1, [3, 3]) == \\"Bob\\" def test_single_pile(): assert determine_winner(1, 1, [1]) == \\"Alice\\" assert determine_winner(1, 2, [2]) == \\"Alice\\" def test_multiple_equal_piles(): assert determine_winner(4, 2, [2, 2, 2, 2]) == \\"Bob\\" def test_no_need_for_special_move(): assert determine_winner(3, 5, [1, 3, 5]) == \\"Alice\\" def test_special_move_needed_for_win(): assert determine_winner(3, 3, [1, 3, 4]) == \\"Alice\\" def test_larger_values(): assert determine_winner(5, 10, [10, 20, 30, 40, 50]) == \\"Alice\\" def test_edge_case_large_number_of_piles(): assert determine_winner(100, 100, [i + 1 for i in range(100)]) == \\"Alice\\"","solution":"def determine_winner(n, k, piles): Determines if Alice can guarantee a win in the game. Parameters: n (int): Number of piles k (int): Maximum number of stones Alice can remove with her special move piles (list): List of integers representing the number of stones in each pile Returns: str: \\"Alice\\" if she can guarantee a win, otherwise \\"Bob\\" xor_sum = 0 for stones in piles: xor_sum ^= stones if xor_sum == 0: return \\"Bob\\" for stones in piles: if stones <= k: if xor_sum ^ stones == 0: return \\"Alice\\" return \\"Alice\\" # Explicit check for special move, maximize move, and piles leveraging xor properties def alice_wins(n, k, piles): xor_sum = 0 for p in piles: xor_sum ^= p if xor_sum == 0: return \\"Bob\\" # Check if using the special move on any pile will guarantee Alice a win for p in piles: if xor_sum ^ p <= k: return \\"Alice\\" return \\"Alice\\""},{"question":"def longest_winning_streak(G: str) -> int: Returns the length of the longest winning streak in the given string G. >>> longest_winning_streak(\\"WWLWLLWWW\\") 3 >>> longest_winning_streak(\\"LLL\\") 0 >>> longest_winning_streak(\\"WLLWLW\\") 1","solution":"def longest_winning_streak(G): Returns the length of the longest winning streak in the given string G. max_streak = 0 current_streak = 0 for char in G: if char == 'W': current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak"},{"question":"def romanToInt(s: str) -> int: Convert a given Roman numeral string to its integer equivalent. >>> romanToInt('III') == 3 >>> romanToInt('IV') == 4 >>> romanToInt('IX') == 9 >>> romanToInt('LVIII') == 58 >>> romanToInt('MCMXCIV') == 1994 >>> romanToInt('CDXLIV') == 444 >>> romanToInt('CMXC') == 990 >>> romanToInt('MMMCMXCIX') == 3999 >>> romanToInt('XXVII') == 27 >>> romanToInt('XL') == 40 >>> romanToInt('XC') == 90 >>> romanToInt('CD') == 400 >>> romanToInt('CM') == 900","solution":"def romanToInt(s): # Dictionary to map Roman numerals to their integer values roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } # Initialize result result = 0 # Iterate over the string i = 0 while i < len(s): # If this is the subtractive combination case if i + 1 < len(s) and roman_to_int[s[i]] < roman_to_int[s[i + 1]]: result += roman_to_int[s[i + 1]] - roman_to_int[s[i]] i += 2 else: result += roman_to_int[s[i]] i += 1 return result"},{"question":"def count_passing_candidates(n: int, minimum_scores: List[int], candidate_scores: List[List[int]]) -> int: Returns the number of candidates who pass all the rounds. >>> count_passing_candidates(3, [70, 80, 90], [[90, 80, 95], [70, 79, 85], [71, 85, 91]]) 2 >>> count_passing_candidates(4, [50, 60, 70], [[55, 65, 75], [45, 60, 80], [50, 61, 70], [52, 63, 70]]) 3","solution":"def count_passing_candidates(n, minimum_scores, candidate_scores): Returns the number of candidates who pass all the rounds. passing_count = 0 for scores in candidate_scores: if all(scores[i] >= minimum_scores[i] for i in range(len(scores))): passing_count += 1 return passing_count"},{"question":"def customer_expenditure(n: int, start: int, end: int, transactions: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int]]: Calculate the total amount spent by each customer within a given time period. >>> customer_expenditure(5, 1, 10, [(1, 100, 50, 5), (2, 101, 60, 7), (3, 100, 40, 9), (4, 102, 70, 10), (5, 101, 80, 15)]) [(100, 90), (101, 60), (102, 70)] >>> customer_expenditure(3, 2, 8, [(1, 200, 100, 1), (2, 200, 200, 2), (3, 200, 300, 8)]) [(200, 500)] >>> customer_expenditure(4, 10, 15, [(1, 100, 50, 5), (2, 101, 60, 7), (3, 100, 40, 9), (4, 102, 70, 16)]) [] >>> customer_expenditure(6, 1, 20, [(1, 100, 50, 10), (2, 101, 60, 15), (3, 100, 40, 20), (4, 102, 70, 20), (5, 101, 80, 5), (6, 103, 100, 10)]) [(100, 90), (101, 140), (102, 70), (103, 100)]","solution":"def customer_expenditure(n, start, end, transactions): expenditure = {} for transaction in transactions: transaction_id, customer_id, amount, timestamp = transaction if start <= timestamp <= end: if customer_id not in expenditure: expenditure[customer_id] = 0 expenditure[customer_id] += amount sorted_expenditure = sorted(expenditure.items()) return sorted_expenditure"},{"question":"def max_system_load(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determines the maximum load on the system at any point in time for each test case. Arguments: t -- Number of test cases test_cases -- List containing tuples (n, d, arrivals) for each test case Returns: List of integers where each integer is the maximum load for the corresponding test case. >>> max_system_load(2, [(5, 3, [1, 2, 3, 4, 10]), (6, 2, [1, 1, 1, 1, 1, 1])]) [4, 6] >>> max_system_load(2, [(1, 3, [1]), (1, 4, [2])]) [1, 1] >>> max_system_load(1, [(3, 5, [1, 1, 1])]) [3] >>> max_system_load(1, [(4, 2, [2, 2, 2, 2])]) [4] >>> max_system_load(1, [(4, 2, [1, 3, 5, 7])]) [2] >>> max_system_load(1, [(5, 1, [1, 5, 10, 15, 20])]) [1] >>> max_system_load(1, [(5, 100000, [1, 2, 3, 4, 5])]) [5] >>> max_system_load(1, [(5, 3, [3, 2, 1, 4, 10])]) [4]","solution":"def max_system_load(t, test_cases): Determines the maximum load on the system at any point in time for each test case. Arguments: t -- Number of test cases test_cases -- List containing tuples (n, d, arrivals) for each test case Returns: List of integers where each integer is the maximum load for the corresponding test case. results = [] for case in test_cases: n, d, arrivals = case arrivals.sort() max_load = 0 current_load = 0 events = [] for arrival in arrivals: events.append((arrival, 'arrival')) events.append((arrival + d, 'departure')) events.sort() for time, event_type in events: if event_type == 'arrival': current_load += 1 else: current_load -= 1 max_load = max(max_load, current_load) results.append(max_load) return results"},{"question":"def max_magic_power(N: int, magic_powers: List[int]) -> int: Determine the maximum possible magic power that can be harnessed from a contiguous subsequence of magical stones. >>> max_magic_power(5, [-2, 1, -3, 4, -1]) == 4 >>> max_magic_power(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_magic_power(1, [10]) == 10 >>> max_magic_power(1, [-10]) == -10 >>> max_magic_power(2, [-10, 10]) == 10 >>> max_magic_power(5, [1, 2, 3, 4, 5]) == 15 >>> max_magic_power(5, [-1, -2, -3, -4, -5]) == -1 >>> max_magic_power(6, [3, -2, 5, -1, 6, -3]) == 11 >>> max_magic_power(3, [-2, 1, -2]) == 1","solution":"def max_magic_power(N, magic_powers): This function finds the maximum sum of a contiguous subsequence in an array of magic powers. :param N: Number of stones (elements in the array) :param magic_powers: List of integers representing the magic powers of the stones :return: Maximum magic power that can be harnessed # Initialize current max and global max to the first element current_max = global_max = magic_powers[0] # Traverse through the array starting from the second element for power in magic_powers[1:]: # Update current max either by adding the current element to it or starting a new subarray from current element current_max = max(power, current_max + power) # Update the global max if the current max is greater than global max global_max = max(global_max, current_max) return global_max"},{"question":"from typing import List, Tuple def distinct_paths_to_employee(n: int, edges: List[Tuple[int, int]], target: int) -> int: Find the number of distinct paths from the CEO to a given employee. >>> distinct_paths_to_employee(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 5) == 1 >>> distinct_paths_to_employee(4, [(1, 2), (1, 3), (1, 4)], 4) == 1 >>> distinct_paths_to_employee(7, [(1, 2), (1, 3), (2, 4), (4, 5), (5, 6), (6, 7)], 7) == 1 >>> distinct_paths_to_employee(5, [(1, 2), (1, 3), (2, 4), (3, 5)], 3) == 1 >>> distinct_paths_to_employee(3, [(1, 2), (2, 3)], 1) == 1 pass","solution":"from typing import List, Tuple, Dict from collections import defaultdict, deque def build_tree(edges: List[Tuple[int, int]]) -> Dict[int, List[int]]: tree = defaultdict(list) for a, b in edges: tree[a].append(b) return tree def distinct_paths_to_employee(n: int, edges: List[Tuple[int, int]], target: int) -> int: tree = build_tree(edges) def dfs(node: int) -> int: if node == target: return 1 count = 0 for child in tree[node]: count += dfs(child) return count return dfs(1)"},{"question":"def find_positions(n, query_function): Finds two positions i and j (1 ≤ i < j ≤ n) in a hidden list of length n such that nums[i] > nums[j]. Args: n (int): Length of the hidden list. query_function (function): Function to get the value at a specific index of the hidden list. Takes an index (1-indexed) as input and returns the value at that index. Returns: tuple: A tuple (i, j) such that i < j and nums[i] > nums[j].","solution":"def find_positions(n, query_function): Finds two positions i and j (1 ≤ i < j ≤ n) in a hidden list of length n such that nums[i] > nums[j]. Args: n (int): Length of the hidden list. query_function (function): Function to get the value at a specific index of the hidden list. Takes an index (1-indexed) as input and returns the value at that index. Returns: tuple: A tuple (i, j) such that i < j and nums[i] > nums[j]. nums = [] # We're allowed to make up to 20 queries, hence we choose 20 positions to query. for i in range(1, n + 1): val = query_function(i) nums.append((val, i)) # As soon as we have made at least 2 queries, we can start checking if i > 1: if nums[-2][0] > nums[-1][0]: return nums[-2][1], nums[-1][1] # If no answer found, (which theoretically shouldn't happen based on problem constraints) for i in range(n): for j in range(i + 1, n): if nums[i][0] > nums[j][0]: return nums[i][1], nums[j][1] import sys input = sys.stdin.read flush_output = sys.stdout.flush def query_function(i): print(f\\"? {i}\\") flush_output() return int(input().strip()) if __name__ == \\"__main__\\": n = int(input().strip()) i, j = find_positions(n, query_function) print(f\\"! {i} {j}\\") flush_output()"},{"question":"class Classroom: Manage a list of students in a classroom. Operations: 1. ADD <ID> <FirstName> <LastName>: Add a student to the list. 2. REMOVE <ID>: Remove a student with the given ID from the list. 3. PRINT: Print the list of students sorted by LastName, then by FirstName in case of ties. Examples: >>> classroom = Classroom() >>> classroom.add_student(1, \\"John\\", \\"Doe\\") >>> classroom.add_student(2, \\"Alice\\", \\"Smith\\") >>> classroom.print_students() 1, John, Doe 2, Alice, Smith >>> classroom.add_student(3, \\"Bob\\", \\"Doe\\") >>> classroom.remove_student(2) >>> classroom.print_students() 3, Bob, Doe 1, John, Doe def __init__(self): self.students = {} def add_student(self, student_id, first_name, last_name): pass def remove_student(self, student_id): pass def print_students(self): pass","solution":"class Classroom: def __init__(self): self.students = {} def add_student(self, student_id, first_name, last_name): self.students[student_id] = (first_name, last_name) def remove_student(self, student_id): if student_id in self.students: del self.students[student_id] def print_students(self): sorted_students = sorted(self.students.items(), key=lambda item: (item[1][1], item[1][0])) for student_id, (first_name, last_name) in sorted_students: print(f\\"{student_id}, {first_name}, {last_name}\\") # Example usage based on the Sample Input: classroom = Classroom() operations = [ \\"ADD 1 John Doe\\", \\"ADD 2 Alice Smith\\", \\"PRINT\\", \\"ADD 3 Bob Doe\\", \\"REMOVE 2\\", \\"PRINT\\" ] for operation in operations: if operation.startswith(\\"ADD\\"): _, student_id, first_name, last_name = operation.split() classroom.add_student(int(student_id), first_name, last_name) elif operation.startswith(\\"REMOVE\\"): _, student_id = operation.split() classroom.remove_student(int(student_id)) elif operation.startswith(\\"PRINT\\"): classroom.print_students()"},{"question":"import heapq from collections import defaultdict def shortest_path(num_towns: int, num_paths: int, paths: List[Tuple[int, int, int]], destination: int) -> int: Calculate the shortest path from the capital (town 1) to the destination town. Args: num_towns: int - number of towns T num_paths: int - number of paths P paths: List of tuples - each tuple contains three integers A, B, and D representing a bidirectional path between town A and town B with a distance D. destination: int - the target town Returns: int: The shortest distance from town 1 to destination. If no path exists, returns -1. >>> shortest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 3), (2, 4, 6), (4, 5, 1)], 5) 6 >>> shortest_path(4, 2, [(1, 2, 3), (3, 4, 5)], 4) -1 >>> shortest_path(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 3)], 3) 2 >>> shortest_path(3, 3, [(1, 2, 100), (2, 3, 1000), (1, 3, 200)], 3) 200 >>> shortest_path(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 2, 1)], 1) 0","solution":"import heapq from collections import defaultdict def shortest_path(num_towns, num_paths, paths, destination): # Create adjacency list for the graph graph = defaultdict(list) for node1, node2, weight in paths: graph[node1].append((weight, node2)) graph[node2].append((weight, node1)) # Dijkstra's algorithm dist = {i: float('inf') for i in range(1, num_towns + 1)} dist[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for weight, v in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist[destination] if dist[destination] != float('inf') else -1"},{"question":"def num_islands(grid): Returns the number of islands in the given grid. An island is a group of contiguous '1's connected horizontally or vertically. Args: grid: List of strings, each with '1' or '0' representing land and water respectively. Returns: Integer, the number of islands. Example usage: >>> num_islands([ ... \\"11110\\", ... \\"11010\\", ... \\"11000\\", ... \\"00000\\" ... ]) 1 >>> num_islands([ ... \\"11000\\", ... \\"11000\\", ... \\"00100\\", ... \\"00011\\" ... ]) 3 from solution import num_islands def test_num_islands(): # Example test case 1 grid = [ \\"11110\\", \\"11010\\", \\"11000\\", \\"00000\\" ] assert num_islands(grid) == 1 # Example test case 2 grid = [ \\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\" ] assert num_islands(grid) == 3 # Test case with no islands grid = [ \\"000\\", \\"000\\", \\"000\\" ] assert num_islands(grid) == 0 # Test case with all land grid = [ \\"111\\", \\"111\\", \\"111\\" ] assert num_islands(grid) == 1 # Test case with isolated lands grid = [ \\"100\\", \\"010\\", \\"001\\" ] assert num_islands(grid) == 3 # Large grid with one island grid = [ \\"1111111111\\", \\"1111111111\\", \\"1111111111\\", \\"1111111111\\" ] assert num_islands(grid) == 1 test_num_islands()","solution":"def num_islands(grid): Returns the number of islands in the given grid. :param grid: List of List of chars, a grid map where '1' represents land and '0' represents water. :return: Integer, the number of islands. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0' or visited[r][c]: return visited[r][c] = True dfs(r + 1, c) # Down dfs(r - 1, c) # Up dfs(r, c + 1) # Right dfs(r, c - 1) # Left island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '1' and not visited[r][c]: island_count += 1 dfs(r, c) return island_count"},{"question":"def longest_even_subsequence_length(sequence: List[int]) -> int: Returns the length of the longest continuous subsequence containing only even numbers. If no even numbers are present, returns -1. >>> longest_even_subsequence_length([1, 2, 4, 6, 8, 3, 5, 7]) 4 >>> longest_even_subsequence_length([5, 3, 9, 1, 7]) -1 >>> longest_even_subsequence_length([2, 4, 6, 8, 10, 12]) 6 pass # Unit tests def test_example_1(): assert longest_even_subsequence_length([1, 2, 4, 6, 8, 3, 5, 7]) == 4 def test_example_2(): assert longest_even_subsequence_length([5, 3, 9, 1, 7]) == -1 def test_example_3(): assert longest_even_subsequence_length([2, 4, 6, 8, 10, 12]) == 6 def test_single_odd(): assert longest_even_subsequence_length([1]) == -1 def test_single_even(): assert longest_even_subsequence_length([2]) == 1 def test_mixed_with_no_continuous_even(): assert longest_even_subsequence_length([2, 1, 4, 3, 6, 5, 8]) == 1 def test_all_odds(): assert longest_even_subsequence_length([1, 3, 5, 7, 9]) == -1 def test_all_evens(): assert longest_even_subsequence_length([2, 4, 6, 8, 10]) == 5 def test_mixed_sequence(): assert longest_even_subsequence_length([1, 2, 2, 4, 1, 2, 2, 2, 6, 7, 8, 8, 1]) == 4","solution":"def longest_even_subsequence_length(sequence): Returns the length of the longest continuous subsequence containing only even numbers. If no even numbers are present, returns -1. max_length = 0 current_length = 0 for num in sequence: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length if max_length > 0 else -1"},{"question":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of the array such that even numbers appear before odd numbers, maintaining the relative order of even and odd numbers. >>> rearrange_array([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrange_array([6, 3, 5, 8, 7]) [6, 8, 3, 5, 7] >>> rearrange_array([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] pass def process_test_cases(input_data: str) -> str: Processes multiple test cases and returns the result for each case in a formatted string. >>> input_data = \\"3n3 1 2 4n6 3 5 8 7n1 2 3 4 5 6\\" >>> process_test_cases(input_data) \\"2 4 3 1n6 8 3 5 7n2 4 6 1 3 5\\" pass","solution":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of the array such that even numbers appear before odd numbers, maintaining the relative order of even and odd numbers. evens = [] odds = [] for num in arr: if num % 2 == 0: evens.append(num) else: odds.append(num) return evens + odds def process_test_cases(input_data: str) -> str: lines = input_data.strip().split(\\"n\\") T = int(lines[0]) # number of test cases results = [] for i in range(1, T + 1): arr = list(map(int, lines[i].split())) rearranged = rearrange_array(arr) results.append(\\" \\".join(map(str, rearranged))) return \\"n\\".join(results)"},{"question":"def min_transactions(n: int, amounts: List[int]) -> int: Returns the minimum number of transactions required to balance the amounts of money among all people. >>> min_transactions(4, [1, 2, 3, 4]) 2 >>> min_transactions(3, [4, 4, 4]) 0","solution":"def min_transactions(n, amounts): Returns the minimum number of transactions required to balance the amounts of money among all people. total_money = sum(amounts) average = total_money // n # Calculate how much each person needs to give/receive diffs = [amount - average for amount in amounts] # Filter out zero diffs (those who already have the average amount) and sort others filtered_diffs = [diff for diff in diffs if diff != 0] filtered_diffs.sort() # Calculate the number of transactions transactions = 0 left = 0 right = len(filtered_diffs) - 1 while left < right: neg = filtered_diffs[left] pos = filtered_diffs[right] if abs(neg) >= pos: transactions += 1 filtered_diffs[left] += pos right -= 1 if filtered_diffs[left] == 0: left += 1 else: transactions += 1 filtered_diffs[right] += neg left += 1 if filtered_diffs[right] == 0: right -= 1 return transactions"},{"question":"def calculate_statistics(n: str) -> None: Calculate and print the sum, mean (average), and median of the digits in the numeric string. The mean and median should be printed to 2 decimal places. >>> calculate_statistics(\\"123456\\") 21 3.50 3.50 >>> calculate_statistics(\\"9876543210\\") 45 4.50 4.50 >>> calculate_statistics(\\"12345\\") 15 3.00 3.00 >>> calculate_statistics(\\"7\\") 7 7.00 7.00 >>> calculate_statistics(\\"33333\\") 15 3.00 3.00 >>> calculate_statistics(\\"00000000009999999999\\") 9 0.45 0.00","solution":"def calculate_statistics(n): digits = [int(char) for char in n] digits.sort() # Sum of the digits total_sum = sum(digits) # Mean of the digits mean = total_sum / len(digits) # Median of the digits length = len(digits) if length % 2 == 0: median = (digits[length // 2 - 1] + digits[length // 2]) / 2 else: median = digits[length // 2] print(f\\"{total_sum} {mean:.2f} {median:.2f}\\")"},{"question":"def isPalindromeAfterRemovingExtraCharacters(s: str) -> bool: Check if the string can become a palindrome by removing at most two characters. >>> isPalindromeAfterRemovingExtraCharacters(\\"abcbxa\\") == True >>> isPalindromeAfterRemovingExtraCharacters(\\"abcda\\") == False >>> isPalindromeAfterRemovingExtraCharacters(\\"abcca\\") == True >>> isPalindromeAfterRemovingExtraCharacters(\\"a\\") == True >>> isPalindromeAfterRemovingExtraCharacters(\\"aa\\") == True >>> isPalindromeAfterRemovingExtraCharacters(\\"ab\\") == True >>> isPalindromeAfterRemovingExtraCharacters(\\"aba\\") == True >>> isPalindromeAfterRemovingExtraCharacters(\\"abc\\") == False >>> isPalindromeAfterRemovingExtraCharacters(\\"racecar\\") == True >>> isPalindromeAfterRemovingExtraCharacters(\\"raccar\\") == True","solution":"def isPalindromeAfterRemovingExtraCharacters(s: str) -> bool: def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: return (is_palindrome_range(l + 1, r) or is_palindrome_range(l, r - 1)) l += 1 r -= 1 return True"},{"question":"def group_words_by_first_letter(words): Given a list of words, return a dictionary where the keys are the first letters of the words and the values are lists containing all the words that start with that letter. The words in the lists should be in the same order as they appear in the input list. Ignore case while grouping, but return the words in their original case. :param words: List of words :return: Dictionary grouping words by their first letter >>> group_words_by_first_letter([\\"apple\\", \\"Avocado\\", \\"banana\\", \\"apricot\\", \\"blueberry\\", \\"cherry\\"]) {'a': ['apple', 'Avocado', 'apricot'], 'b': ['banana', 'blueberry'], 'c': ['cherry']} >>> group_words_by_first_letter([\\"Apple\\", \\"avocado\\", \\"Apricot\\", \\"Blueberry\\", \\"banana\\"]) {'a': ['Apple', 'avocado', 'Apricot'], 'b': ['Blueberry', 'banana']} >>> group_words_by_first_letter([]) {} >>> group_words_by_first_letter([\\"apple\\", \\"banana\\", \\"cherry\\"]) {'a': ['apple'], 'b': ['banana'], 'c': ['cherry']} >>> group_words_by_first_letter([\\"123\\", \\"apple\\", \\"banana\\", \\"2apples\\"]) {'1': ['123'], 'a': ['apple'], 'b': ['banana'], '2': ['2apples']}","solution":"def group_words_by_first_letter(words): Returns a dictionary where the keys are the first letters of the words (case-insensitive) and the values are lists containing all the words that start with that letter, in their original case. :param words: List of words :return: Dictionary grouping words by their first letter result = {} for word in words: key = word[0].lower() if key in result: result[key].append(word) else: result[key] = [word] return result"},{"question":"def longest_subsequence_length(n: int, k: int, scores: List[int]) -> int: Returns the length of the longest sub-sequence where the sum of the scores does not exceed k. Args: n (int): The number of matches. k (int): The maximum allowed sum of scores in the sub-sequence. scores (List[int]): The scores of each match. Returns: int: The length of the longest sub-sequence where the sum of the scores does not exceed k. Examples: >>> longest_subsequence_length(5, 9, [1, 2, 3, 4, 5]) 3 >>> longest_subsequence_length(3, 15, [5, 5, 5]) 3 >>> longest_subsequence_length(5, 5, [6, 7, 8, 9, 10]) 0 # Unit Tests def test_example_1(): assert longest_subsequence_length(5, 9, [1, 2, 3, 4, 5]) == 3 def test_example_2(): assert longest_subsequence_length(3, 15, [5, 5, 5]) == 3 def test_example_3(): assert longest_subsequence_length(5, 5, [6, 7, 8, 9, 10]) == 0 def test_edge_case_1(): assert longest_subsequence_length(1, 1, [1]) == 1 def test_edge_case_2(): assert longest_subsequence_length(1, 0, [1]) == 0 def test_large_case(): assert longest_subsequence_length(5, 10, [1, 2, 3, 4, 5]) == 4 # Sub-sequence [1, 2, 3, 4] def test_single_element_exceeds_k(): assert longest_subsequence_length(5, 3, [4, 4, 4, 4, 4]) == 0 def test_all_elements_same_less_than_k(): assert longest_subsequence_length(5, 20, [3, 3, 3, 3, 3]) == 5 def test_small_values_large_k(): assert longest_subsequence_length(5, 50, [1, 2, 3, 4, 5]) == 5 def test_with_varied_values(): assert longest_subsequence_length(6, 10, [5, 1, 1, 2, 2, 2]) == 5","solution":"def longest_subsequence_length(n, k, scores): Returns the length of the longest sub-sequence where the sum of the scores does not exceed k. # Initialize variables curr_sum = 0 max_length = 0 start = 0 # Use a sliding window approach for end in range(n): curr_sum += scores[end] # Adjust the window to maintain the sum <= k while curr_sum > k and start <= end: curr_sum -= scores[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def longest_increasing_subsequence(tasks: List[int]) -> int: Returns the length of the longest subsequence with strictly increasing difficulties. >>> longest_increasing_subsequence([1, 3, 2, 4, 3, 5]) 4 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence([1, 2, 3, 1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1","solution":"def longest_increasing_subsequence(tasks): Returns the length of the longest subsequence with strictly increasing difficulties. if not tasks: return 0 n = len(tasks) lis = [1] * n for i in range(1, n): for j in range(i): if tasks[i] > tasks[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"from collections import Counter, defaultdict def min_window(s: str, t: str) -> str: Find the minimum window in s that will contain all the characters in t. If no such window exists, return the empty string \\"\\". Args: s (str): The string to find the window in. t (str): The string containing the characters to be matched in s. Returns: str: The minimum window in s that contains all characters in t. Returns an empty string if no such window exists. Examples: >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> min_window(\\"a\\", \\"a\\") 'a' >>> min_window(\\"a\\", \\"aa\\") '' # Unit test for the function def test_case_1(): s = \\"ADOBECODEBANC\\" t = \\"ABC\\" assert min_window(s, t) == \\"BANC\\" def test_case_2(): s = \\"a\\" t = \\"a\\" assert min_window(s, t) == \\"a\\" def test_case_3(): s = \\"a\\" t = \\"aa\\" assert min_window(s, t) == \\"\\" def test_case_4(): s = \\"ab\\" t = \\"b\\" assert min_window(s, t) == \\"b\\" def test_case_5(): s = \\"ab\\" t = \\"a\\" assert min_window(s, t) == \\"a\\" def test_case_6(): s = \\"\\" t = \\"a\\" assert min_window(s, t) == \\"\\" def test_case_7(): s = \\"abc\\" t = \\"c\\" assert min_window(s, t) == \\"c\\" def test_case_8(): s = \\"aa\\" t = \\"aa\\" assert min_window(s, t) == \\"aa\\" def test_case_9(): s = \\"ADOBECODEBANC\\" t = \\"ABCD\\" assert min_window(s, t) == \\"ADOBEC\\" def test_case_10(): s = \\"ADOBECODEBANCCAB\\" t = \\"ABC\\" assert min_window(s, t) == \\"CAB\\" def test_case_11(): s = \\"thisisateststring\\" t = \\"tist\\" assert min_window(s, t) == \\"tstri\\"","solution":"from collections import Counter, defaultdict def min_window(s, t): if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None # length of window, left, right indexs while r < len(s): char = s[r] window_counts[char] += 1 if char in dict_t and window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in dict_t and window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]:ans[2] + 1]"},{"question":"def optimize_shopping_list(n, items): Optimizes the shopping list by summing quantities of the same items. Parameters: n (int): Number of items in the original list. items (list): List of tuples where each tuple contains an item name and its quantity. Returns: list: A list of tuples with unique items and their total quantities. Example: >>> optimize_shopping_list(5, [(\\"apples\\", 4), (\\"bananas\\", 2), (\\"apples\\", 3), (\\"oranges\\", 5), (\\"bananas\\", 1)]) [('apples', 7), ('bananas', 3), ('oranges', 5)] >>> optimize_shopping_list(3, [(\\"bread\\", 2), (\\"milk\\", 1), (\\"bread\\", 3)]) [('bread', 5), ('milk', 1)] >>> optimize_shopping_list(4, [(\\"juice\\", 6), (\\"water\\", 2), (\\"juice\\", 4), (\\"soda\\", 3)]) [('juice', 10), ('water', 2), ('soda', 3)]","solution":"def optimize_shopping_list(n, items): Optimizes the shopping list by summing quantities of the same items. Parameters: n (int): Number of items in the original list. items (list): List of tuples where each tuple contains an item name and its quantity. Returns: list: A list of tuples with unique items and their total quantities. from collections import defaultdict item_dict = defaultdict(int) for item, quantity in items: item_dict[item] += quantity result = [(item, qty) for item, qty in item_dict.items()] return result"},{"question":"def is_path_possible(N, M, edges, start, destination, sequence): Determines if there is a path from a starting node to a destination node passing through the specified sequence of intermediate nodes in order. Args: N (int): Number of nodes. M (int): Number of edges. edges (List[Tuple[int, int]]): List of edge tuples where each tuple represents an edge between nodes u and v. start (int): Starting node. destination (int): Destination node. sequence (List[int]): Sequence of intermediate nodes. Returns: bool: True if there is a valid path; False otherwise. >>> is_path_possible(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)], 1, 5, [2, 3, 4]) True >>> is_path_possible(3, 2, [(1, 2), (2, 3)], 1, 2, [3]) False >>> is_path_possible(3, 2, [(1, 2), (2, 3)], 1, 3, [2]) True","solution":"def create_graph(edges, N): graph = {i: [] for i in range(1, N + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) return graph def dfs(graph, current, target, visited, sequence=None, seq_index=0): if seq_index < len(sequence) and current != sequence[seq_index]: return False if current == target and seq_index == len(sequence) - 1: return True visited.add(current) for neighbor in graph[current]: if neighbor not in visited: if dfs(graph, neighbor, target, visited, sequence, seq_index + 1): return True visited.remove(current) return False def is_path_possible(N, M, edges, start, destination, sequence): graph = create_graph(edges, N) if not sequence: sequence = [start, destination] else: sequence = [start] + sequence + [destination] visited = set() return dfs(graph, start, destination, visited, sequence) # Example Usage: N = 5 M = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)] start = 1 destination = 5 sequence = [2, 3, 4] print(\\"YES\\" if is_path_possible(N, M, edges, start, destination, sequence) else \\"NO\\") N = 3 M = 2 edges = [(1, 2), (2, 3)] start = 1 destination = 2 sequence = [3] print(\\"YES\\" if is_path_possible(N, M, edges, start, destination, sequence) else \\"NO\\")"},{"question":"def check_schedule(schedule: str) -> str: Checks if the given work schedule is valid according to the company's policy. A schedule is valid if after every 6 consecutive work hours ('W'), there is at least 1 break hour ('B'). Args: - schedule (str): The work schedule as a string of 'W' and 'B'. Returns: - str: \\"Valid\\" if the schedule is compliant, \\"Invalid\\" otherwise. pass def validate_schedules(n: int, schedules: List[str]) -> List[str]: Validates multiple work schedules. Args: - n (int): Number of schedules. - schedules (list of str): List of work schedule strings. Returns: - list of str: List of results (\\"Valid\\" or \\"Invalid\\") for each schedule. pass from typing import List def test_check_schedule(): assert check_schedule(\\"WWWWWWBBWWW\\") == \\"Valid\\" assert check_schedule(\\"WWWWWWWWWW\\") == \\"Invalid\\" assert check_schedule(\\"WWBW\\") == \\"Valid\\" assert check_schedule(\\"WWWWWWBWWWWWWBWWW\\") == \\"Valid\\" assert check_schedule(\\"WWWWWWWWWWB\\") == \\"Invalid\\" assert check_schedule(\\"BBBBBBBWWWWW\\") == \\"Valid\\" assert check_schedule(\\"WWWBBBWWWWBBBWWW\\") == \\"Valid\\" assert check_schedule(\\"W\\"*1440) == \\"Invalid\\" assert check_schedule(\\"W\\"*6 + \\"B\\" +\\"W\\"*6 + \\"B\\") == \\"Valid\\" def test_validate_schedules(): assert validate_schedules(3, [\\"WWWWWWBBWWW\\", \\"WWWWWWWWWW\\", \\"WWBW\\"]) == [\\"Valid\\", \\"Invalid\\", \\"Valid\\"] assert validate_schedules(1, [\\"W\\"*6 + \\"B\\" + \\"W\\"*6 + \\"B\\"]) == [\\"Valid\\"] assert validate_schedules(2, [\\"WWWBBBWWW\\", \\"WWWWWWWWWWWW\\"]) == [\\"Valid\\", \\"Invalid\\"] assert validate_schedules(1, [\\"WBWBWBWBWBWBWBWBWBWB\\"]) == [\\"Valid\\"]","solution":"def check_schedule(schedule): Checks if the given work schedule is valid according to the company's policy. A schedule is valid if after every 6 consecutive work hours ('W'), there is at least 1 break hour ('B'). Args: - schedule (str): The work schedule as a string of 'W' and 'B'. Returns: - str: \\"Valid\\" if the schedule is compliant, \\"Invalid\\" otherwise. consecutive_work_hours = 0 for hour in schedule: if hour == 'W': consecutive_work_hours += 1 if consecutive_work_hours > 6: return \\"Invalid\\" else: consecutive_work_hours = 0 return \\"Valid\\" def validate_schedules(n, schedules): Validates multiple work schedules. Args: - n (int): Number of schedules. - schedules (list of str): List of work schedule strings. Returns: - list of str: List of results (\\"Valid\\" or \\"Invalid\\") for each schedule. results = [] for schedule in schedules: results.append(check_schedule(schedule)) return results"},{"question":"def find_package_weights(truck_capacities): Determine the minimum number of packages required such that each truck can be loaded to its maximum capacity using any combination of these packages and all packages have distinct weights. Args: truck_capacities (List[int]): List of distinct truck capacities. Returns: Tuple[str, int, List[int]]: (\\"POSSIBLE\\", k, [w1, w2, ...]) if a solution exists, otherwise (\\"IMPOSSIBLE\\", ). >>> find_package_weights([3, 7, 10]) ('POSSIBLE', 4, [1, 2, 4, 8]) >>> find_package_weights([1, 2]) ('POSSIBLE', 2, [1, 2]) >>> find_package_weights([1, 5, 7, 10]) ('POSSIBLE', 4, [1, 2, 4, 8]) >>> find_package_weights([1000000]) ('POSSIBLE', 20, [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288])","solution":"from math import ceil, log2 def find_package_weights(truck_capacities): if not truck_capacities: return \\"IMPOSSIBLE\\" max_capacity = max(truck_capacities) # Number of bits to represent the maximum capacity num_weights = ceil(log2(max_capacity + 1)) # Generate package weights as powers of 2 weights = [2**i for i in range(num_weights)] return \\"POSSIBLE\\", num_weights, weights"},{"question":"def count_subarrays_with_sum(arr, X): Return the number of contiguous subarrays whose sum is exactly X. >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_subarrays_with_sum([-1, 1, -1, 1], 0) 4 >>> count_subarrays_with_sum([-5, -4, -3, -2, -1], -10) 1 >>> count_subarrays_with_sum([5], 5) 1 >>> count_subarrays_with_sum([0, 0, 0, 0], 0) 10 >>> count_subarrays_with_sum([1, 2, 3], 7) 0 >>> count_subarrays_with_sum([1] * 100000, 2) 99999","solution":"def count_subarrays_with_sum(arr, X): Return the number of contiguous subarrays whose sum is exactly X. subarray_count = 0 current_sum = 0 prefix_sum_counts = {0: 1} for num in arr: current_sum += num if (current_sum - X) in prefix_sum_counts: subarray_count += prefix_sum_counts[current_sum - X] if current_sum in prefix_sum_counts: prefix_sum_counts[current_sum] += 1 else: prefix_sum_counts[current_sum] = 1 return subarray_count"},{"question":"from typing import List def is_pangram(sentence: str) -> bool: Check if the given sentence is a pangram. A pangram is a sentence containing every letter of the alphabet at least once. Args: sentence: A string representing the sentence to be checked. Returns: A boolean value, True if the sentence is a pangram, False otherwise. >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") True >>> is_pangram(\\"Hello world\\") False pass def check_pangrams(test_cases: List[str]) -> List[str]: For each sentence in test_cases, return \\"YES\\" if it is a pangram, \\"NO\\" otherwise. Args: test_cases: A list of strings, each string is a sentence to be checked. Returns: A list of strings, where each element is \\"YES\\" or \\"NO\\" corresponding to the input sentences. >>> check_pangrams([\\"The quick brown fox jumps over the lazy dog\\", \\"Hello world\\", \\"Pack my box with five dozen liquor jugs\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass def test_is_pangram_true(): assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True def test_is_pangram_false(): assert is_pangram(\\"Hello world\\") == False def test_is_pangram_mixed_case(): assert is_pangram(\\"The Quick Brown Fox Jumps Over The Lazy Dog\\") == True def test_is_pangram_missing_letter(): assert is_pangram(\\"The quick brown fox jumps over the lazy do\\") == False def test_is_pangram_with_numbers(): assert is_pangram(\\"Pack my box with five dozen liquor jugs 1234567890\\") == True def test_check_pangrams(): test_cases = [ \\"The quick brown fox jumps over the lazy dog\\", \\"Hello world\\", \\"Pack my box with five dozen liquor jugs\\" ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert check_pangrams(test_cases) == expected def test_check_pangrams_single_case(): test_cases = [ \\"Not a pangram\\" ] expected = [\\"NO\\"] assert check_pangrams(test_cases) == expected def test_check_pangrams_empty_string(): test_cases = [ \\"\\" ] expected = [\\"NO\\"] assert check_pangrams(test_cases) == expected def test_check_pangrams_all_yes(): test_cases = [ \\"The quick brown fox jumps over the lazy dog\\", \\"Pack my box with five dozen liquor jugs\\", \\"Sphinx of black quartz, judge my vow\\" ] expected = [\\"YES\\", \\"YES\\", \\"YES\\"] assert check_pangrams(test_cases) == expected","solution":"def is_pangram(sentence): Check if the given sentence is a pangram. A pangram is a sentence containing every letter of the alphabet at least once. alphabet_set = set('abcdefghijklmnopqrstuvwxyz') sentence_set = set(sentence.lower()) return alphabet_set.issubset(sentence_set) def check_pangrams(test_cases): For each sentence in test_cases, return \\"YES\\" if it is a pangram, \\"NO\\" otherwise. Args: test_cases: A list of strings, each string is a sentence to be checked. Returns: A list of strings, where each element is \\"YES\\" or \\"NO\\" corresponding to the input sentences. results = [] for sentence in test_cases: if is_pangram(sentence): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def is_valid_word_chain(words: List[str]) -> bool: Check if the given list of words forms a valid word chain. >>> is_valid_word_chain([\\"cat\\", \\"tiger\\", \\"rabbit\\", \\"tarantula\\", \\"apple\\", \\"elephant\\", \\"toy\\", \\"yak\\", \\"kite\\", \\"echo\\", \\"owlet\\", \\"tuna\\", \\"alpaca\\"]) True >>> is_valid_word_chain([\\"cat\\", \\"dog\\"]) False >>> is_valid_word_chain([\\"cat\\", \\"tiger\\", \\"rabbit\\", \\"elephant\\", \\"tarantula\\"]) False >>> is_valid_word_chain([\\"cat\\"]) True >>> is_valid_word_chain([]) False def check_word_chain(): words = [] while True: word = input().strip() if word == \\"END\\": break words.append(word) if is_valid_word_chain(words): print(\\"VALID CHAIN\\") else: print(\\"INVALID CHAIN\\")","solution":"def is_valid_word_chain(words): if not words: return False for i in range(len(words) - 1): if words[i][-1] != words[i + 1][0]: return False return True def check_word_chain(): words = [] while True: word = input().strip() if word == \\"END\\": break words.append(word) if is_valid_word_chain(words): print(\\"VALID CHAIN\\") else: print(\\"INVALID CHAIN\\")"},{"question":"def leaderboard(players_scores): Sorts a list of player's names and their scores in descending order by score. If two players have the same score, they are sorted alphabetically by their names. Args: players_scores (list of tuple): List of tuples where each tuple contains a player's name (string) and their score (int). Returns: list: A list of players' names sorted by their scores in descending order. >>> leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1200), (\\"Charlie\\", 1500), (\\"David\\", 1000)]) [\\"Alice\\", \\"Charlie\\", \\"Bob\\", \\"David\\"] >>> leaderboard([(\\"Charlie\\", 1500), (\\"Bob\\", 1500), (\\"Alice\\", 1500)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] # Your code here","solution":"def leaderboard(players_scores): Sorts a list of player's names and their scores in descending order by score. If two players have the same score, they are sorted alphabetically by their names. Args: players_scores (list of tuple): List of tuples where each tuple contains a player's name (string) and their score (int). Returns: list: A list of players' names sorted by their scores in descending order. # Sort the list first alphabetically then by scores in descending order sorted_players = sorted(players_scores, key=lambda x: (-x[1], x[0])) # Extract and return just the names from the sorted list of tuples return [player[0] for player in sorted_players]"},{"question":"def has_pair_with_sum(N: int, T: int, A: List[int]) -> str: Determine if there exist two distinct elements in \`A\` such that their sum is equal to \`T\`. Parameters: N (int): Number of elements in the array T (int): The target sum A (list): The list of elements Returns: str: \\"YES\\" or \\"NO\\" >>> has_pair_with_sum(5, 9, [1, 2, 3, 5, 4]) \\"YES\\" >>> has_pair_with_sum(4, 8, [1, 2, 3, 4]) \\"NO\\"","solution":"def has_pair_with_sum(N, T, A): Returns \\"YES\\" if there are two distinct elements in A whose sum is equal to T, otherwise \\"NO\\". Parameters: N (int): Number of elements in the array T (int): The target sum A (list): The list of elements Returns: str: \\"YES\\" or \\"NO\\" seen = set() for number in A: complement = T - number if complement in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def largest_box(dimensions): Given the dimensions of multiple cuboids, find the dimensions of the largest box that can fit within their union. >>> largest_box([(0, 0, 4, 4, 5), (2, 2, 6, 6, 3), (4, 4, 8, 8, 2)]) (8.0000, 8.0000, 5.0000) >>> largest_box([(0, 0, 3, 3, 7), (2, 2, 5, 5, 4)]) (5.0000, 5.0000, 7.0000) def parse_input(input_str): ... def format_output(results): ... def process(input_str): Main processing function to parse input, calculate results, and format output. def test_sample_input(): input_str = 3 0 0 4 4 5 2 2 6 6 3 4 4 8 8 2 2 0 0 3 3 7 2 2 5 5 4 0 expected_output = 8.0000 8.0000 5.0000 5.0000 5.0000 7.0000 assert process(input_str) == expected_output def test_single_cuboid(): input_str = 1 -3 -3 3 3 6 0 expected_output = 6.0000 6.0000 6.0000 assert process(input_str) == expected_output def test_two_non_overlapping_cuboids(): input_str = 2 -1 -1 1 1 2 2 2 4 4 3 0 expected_output = 5.0000 5.0000 3.0000 assert process(input_str) == expected_output def test_multiple_identical_cuboids(): input_str = 3 0 0 2 2 2 0 0 2 2 2 0 0 2 2 2 0 expected_output = 2.0000 2.0000 2.0000 assert process(input_str) == expected_output def test_cuboids_sharing_edges(): input_str = 2 0 0 3 3 4 3 3 6 6 5 0 expected_output = 6.0000 6.0000 5.0000 assert process(input_str) == expected_output","solution":"def largest_box(dimensions): Given the dimensions of multiple cuboids, find the dimensions of the largest box that can fit within their union. # Initialize the boundaries for the union of cuboids min_x, min_y, min_z = float('inf'), float('inf'), float('inf') max_x, max_y, max_z = float('-inf'), float('-inf'), float('-inf') for dimension in dimensions: X_lo, Y_lo, X_hi, Y_hi, Z_hi = dimension min_x = min(min_x, X_lo) min_y = min(min_y, Y_lo) min_z = min(min_z, 0) # Since lower z is always 0 max_x = max(max_x, X_hi) max_y = max(max_y, Y_hi) max_z = max(max_z, Z_hi) length = max_x - min_x width = max_y - min_y height = max_z - min_z return length, width, height def parse_input(input_str): Parse the input string into a list of dimensions for each dataset. input_lines = input_str.strip().split('n') datasets = [] i = 0 while i < len(input_lines): N = int(input_lines[i]) if N == 0: break dimensions = [] for j in range(1, N + 1): dimensions.append(list(map(int, input_lines[i + j].split()))) datasets.append(dimensions) i += (N + 1) return datasets def format_output(results): Format the output to match the required precision. return 'n'.join(f'{result[0]:.4f} {result[1]:.4f} {result[2]:.4f}' for result in results) def process(input_str): Main processing function to parse input, calculate results, and format output. datasets = parse_input(input_str) results = [largest_box(dimensions) for dimensions in datasets] return format_output(results)"},{"question":"def is_auction_feasible(P: List[int], B: int) -> bool: Determines if the auction is feasible under the given budget B. Parameters: P (list of int): A list of 5 starting prices for the items. B (int): The budget limit. Returns: bool: True if the sum of starting prices does not exceed B, otherwise False. Examples: >>> is_auction_feasible([10, 20, 30, 40, 50], 150) True >>> is_auction_feasible([10, 20, 30, 40, 60], 150) False >>> is_auction_feasible([1, 1, 1, 1, 1], 5) True >>> is_auction_feasible([1, 1, 1, 1, 1], 4) False >>> is_auction_feasible([100, 100, 100, 100, 100], 500) True >>> is_auction_feasible([100, 100, 100, 100, 100], 499) False pass def test_is_auction_feasible(): assert is_auction_feasible([10, 20, 30, 40, 50], 150) == True, \\"Test case 1 failed\\" assert is_auction_feasible([10, 20, 30, 40, 60], 150) == False, \\"Test case 2 failed\\" assert is_auction_feasible([1, 1, 1, 1, 1], 5) == True, \\"Test case 3 failed\\" assert is_auction_feasible([1, 1, 1, 1, 1], 4) == False, \\"Test case 4 failed\\" assert is_auction_feasible([100, 100, 100, 100, 100], 500) == True, \\"Test case 5 failed\\" assert is_auction_feasible([100, 100, 100, 100, 100], 499) == False, \\"Test case 6 failed\\" # Execute the tests test_is_auction_feasible()","solution":"def is_auction_feasible(P, B): Determines if the auction is feasible under the given budget B. Parameters: P (list of int): A list of 5 starting prices for the items. B (int): The budget limit. Returns: bool: True if the sum of starting prices does not exceed B, otherwise False. # Calculate the sum of starting prices total_sum = sum(P) # Check if the total sum is within the budget return total_sum <= B # Example input # P = [10, 20, 30, 40, 50] # B = 150 # Example usage # result = is_auction_feasible(P, B) # print(\\"Yes\\" if result else \\"No\\")"},{"question":"def is_possible_to_make_increasing(n, k, sequence): Determine if it's possible to make the sequence strictly increasing with at most k swaps. >>> is_possible_to_make_increasing(5, 2, [3, 1, 2, 4, 5]) True >>> is_possible_to_make_increasing(4, 1, [4, 3, 2, 1]) False","solution":"def is_possible_to_make_increasing(n, k, sequence): sorted_sequence = sorted(sequence) mismatch_count = sum(1 for i in range(n) if sequence[i] != sorted_sequence[i]) # Each swap can correct two positions. # If the mismatch count is less than or equal to 2 times the number of swaps, it's possible. return mismatch_count <= 2 * k"},{"question":"def max_profit(N: int, prices: List[int]) -> int: Calculate the maximum profit that can be achieved by buying and selling the stock once. You must buy before you sell. If no profit can be achieved, return 0. Parameters: N (int): The number of stock prices prices (List[int]): The list of stock prices Returns: int: The maximum profit Examples: >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0 >>> max_profit(3, [1, 2, 4]) 3 pass def test_max_profit_example_1(): assert max_profit(6, [7, 1, 5, 3, 6, 4]) == 5 def test_max_profit_example_2(): assert max_profit(5, [7, 6, 4, 3, 1]) == 0 def test_max_profit_example_3(): assert max_profit(3, [1, 2, 4]) == 3 def test_max_profit_single_day(): assert max_profit(1, [5]) == 0 def test_max_profit_no_prices(): assert max_profit(0, []) == 0 def test_max_profit_all_same_prices(): assert max_profit(4, [3, 3, 3, 3]) == 0 def test_max_profit_random_case(): assert max_profit(7, [5, 2, 4, 1, 7, 3, 6]) == 6","solution":"def max_profit(N, prices): if N == 0: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def has_subarray_with_k_distinct_integers(arr, k): Determines if there is a contiguous subarray of length k or more that contains at least k distinct integers. >>> has_subarray_with_k_distinct_integers([1, 2, 2, 1, 2, 3, 4, 4], 3) \\"YES\\" >>> has_subarray_with_k_distinct_integers([1, 1, 1, 1, 1, 1], 3) \\"NO\\" >>> has_subarray_with_k_distinct_integers([1, 2, 3], 3) \\"YES\\" >>> has_subarray_with_k_distinct_integers([1, 2, 3, 4, 5], 4) \\"YES\\" >>> has_subarray_with_k_distinct_integers([1, 2, 2, 1], 4) \\"NO\\" >>> has_subarray_with_k_distinct_integers([1, 2, 3, 4], 4) \\"YES\\"","solution":"def has_subarray_with_k_distinct_integers(arr, k): Determines if there is a contiguous subarray of length k or more that contains at least k distinct integers. if len(arr) < k: return \\"NO\\" from collections import defaultdict distinct_counts = defaultdict(int) distinct_total = 0 left = 0 for right in range(len(arr)): if distinct_counts[arr[right]] == 0: distinct_total += 1 distinct_counts[arr[right]] += 1 if right - left + 1 >= k: if distinct_total >= k: return \\"YES\\" if distinct_counts[arr[left]] == 1: distinct_total -= 1 distinct_counts[arr[left]] -= 1 left += 1 return \\"NO\\""},{"question":"def is_balanced(s: str) -> bool: Determine if a string of parentheses is correctly balanced. A string is balanced if every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested. >>> is_balanced(\\"()()\\") True >>> is_balanced(\\"((())\\") False >>> is_balanced(\\"(()()(()))\\") True >>> is_balanced(\\"())(()\\") False from solution import is_balanced def test_balanced_simple(): assert is_balanced(\\"()()\\") == True def test_unbalanced_missing_closing(): assert is_balanced(\\"((())\\") == False def test_balanced_nested(): assert is_balanced(\\"(()()(()))\\") == True def test_unbalanced_mixed(): assert is_balanced(\\"())(()\\") == False def test_empty_string(): assert is_balanced(\\"\\") == True def test_one_opening(): assert is_balanced(\\"(\\") == False def test_one_closing(): assert is_balanced(\\")\\") == False def test_balanced_long(): assert is_balanced(\\"(((((())))))\\") == True def test_unbalanced_long(): assert is_balanced(\\"(((((()))))))\\") == False def test_all_closings_first(): assert is_balanced(\\"))))(((()\\") == False def test_balanced_many_pairs(): assert is_balanced(\\"()\\" * 500) == True def test_unbalanced_many_openings(): assert is_balanced(\\"(\\" * 500 + \\")\\" * 499) == False def test_unbalanced_many_closings(): assert is_balanced(\\"(\\" * 499 + \\")\\" * 500) == False def test_alternating_parentheses_balanced(): assert is_balanced(\\"()()()()()\\") == True def test_alternating_parentheses_unbalanced(): assert is_balanced(\\"()()()()(\\") == False","solution":"def is_balanced(s: str) -> bool: Returns True if the string of parentheses is balanced, otherwise False. # Initialize a counter to track balance balance = 0 # Iterate through each character in the string for char in s: if char == '(': balance += 1 elif char == ')': balance -= 1 # If balance goes negative, there are more closing than opening parentheses if balance < 0: return False # In the end, balance should be zero for the string to be balanced return balance == 0"},{"question":"def eval_expression(expression: str) -> str: Evaluates a logical expression composed of variables (A, B, C, etc.), logical operators AND (&), OR (|), NOT (!), and parentheses. Args: expression (str): The logical expression to evaluate. Returns: str: 'True' or 'False' based on the evaluation result. Example: >>> eval_expression(\\"A&B|C\\") 'True' >>> eval_expression(\\"!A&B\\") 'False' >>> eval_expression(\\"(A|B)&C\\") 'True'","solution":"def eval_expression(expression): Evaluates a logical expression composed of variables (A, B, C, etc.), logical operators AND (&), OR (|), NOT (!), and parentheses. Args: expression (str): The logical expression to evaluate. Returns: str: 'True' or 'False' based on the evaluation result. # Define precedence of operators precedence = {'!': 3, '&': 2, '|': 1} def eval_not(stack): operand = stack.pop() stack.append(not operand) def eval_and(stack): right = stack.pop() left = stack.pop() stack.append(left and right) def eval_or(stack): right = stack.pop() left = stack.pop() stack.append(left or right) def to_postfix(expression): stack = [] output = [] i = 0 while i < len(expression): char = expression[i] if char.isalpha(): # Operand output.append(True) # Assuming all variables are set to True elif char == '(': stack.append(char) elif char == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Remove the '(' from stack elif char in precedence: while (stack and stack[-1] != '(' and precedence[char] <= precedence[stack[-1]]): output.append(stack.pop()) stack.append(char) i += 1 while stack: output.append(stack.pop()) return output def evaluate_postfix(postfix): stack = [] for token in postfix: if type(token) == bool: # Operand stack.append(token) elif token == '!': eval_not(stack) elif token == '&': eval_and(stack) elif token == '|': eval_or(stack) return stack.pop() postfix_expression = to_postfix(expression) result = evaluate_postfix(postfix_expression) return 'True' if result else 'False'"},{"question":"def simulate_watering(n: int, m: int, field: List[List[int]], q: int, operations: List[Tuple[int, int, int, int, int]]) -> List[List[int]]: Simulate the watering process on a field of crops and return the final heights of the plants. Parameters: n (int): Number of rows in the field. m (int): Number of columns in the field. field (List[List[int]]): 2D list representing the initial heights of the plants. q (int): Number of watering operations. operations (List[Tuple[int, int, int, int, int]]): List of operations where each operation is a tuple (r1, c1, r2, c2, k). Returns: List[List[int]]: 2D list representing the final heights of the plants after performing all the operations. Examples: >>> simulate_watering(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, [(0, 0, 1, 1, 1), (1, 1, 2, 2, 2)]) [[2, 3, 3], [5, 8, 8], [7, 10, 11]] >>> simulate_watering(2, 2, [[1, 1], [1, 1]], 1, [(0, 0, 1, 1, 5)]) [[6, 6], [6, 6]]","solution":"def water_plants(field, operations): n = len(field) m = len(field[0]) for r1, c1, r2, c2, k in operations: for i in range(r1, r2+1): for j in range(c1, c2+1): field[i][j] += k return field # Function to handle the complete flow def simulate_watering(n, m, field, q, operations): result = water_plants(field, operations) return result"},{"question":"def sort_datetime_entries(entries): Sorts a list of date-time entries in chronological order. Args: entries (List[str]): A list of date-time entries formatted as \\"YYYY/MM/DD HH:MM\\" Returns: List[str]: The sorted list of date-time entries. Examples: >>> sort_datetime_entries([\\"2023/05/17 16:45\\", \\"2022/07/19 14:30\\", \\"2010/06/30 23:59\\"]) [\\"2010/06/30 23:59\\", \\"2022/07/19 14:30\\", \\"2023/05/17 16:45\\"] >>> sort_datetime_entries([\\"1995/12/01 00:00\\"]) [\\"1995/12/01 00:00\\"] pass # Implement the function here","solution":"def sort_datetime_entries(entries): Sorts a list of date-time entries in chronological order. return sorted(entries)"},{"question":"def unique_paths(n: int) -> int: Calculate the number of unique paths in an n x n grid from top-left to bottom-right. Parameters: n (int): The size of the grid (n x n) Returns: int: The number of unique paths. >>> unique_paths(2) 2 >>> unique_paths(3) 6 from solution import unique_paths def test_unique_paths_1x1(): assert unique_paths(1) == 1 def test_unique_paths_2x2(): assert unique_paths(2) == 2 def test_unique_paths_3x3(): assert unique_paths(3) == 6 def test_unique_paths_4x4(): assert unique_paths(4) == 20 def test_unique_paths_5x5(): assert unique_paths(5) == 70 def test_unique_paths_6x6(): assert unique_paths(6) == 252 def test_unique_paths_7x7(): assert unique_paths(7) == 924 def test_unique_paths_8x8(): assert unique_paths(8) == 3432 def test_unique_paths_9x9(): assert unique_paths(9) == 12870 def test_unique_paths_10x10(): assert unique_paths(10) == 48620","solution":"def unique_paths(n: int) -> int: Calculate number of unique paths in an n x n grid from top-left to bottom-right. # Create a 2D list (n x n) to store results of subproblems dp = [[0] * n for _ in range(n)] # The only way to get to any cell in the first row or first column # is to move only right or only down respectively for i in range(n): dp[i][0] = 1 dp[0][i] = 1 # Fill the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right cell has the number of unique paths return dp[n - 1][n - 1]"},{"question":"import math def is_perfect_square(n: int) -> str: Determines if the given integer n is a perfect square. Parameters: n (int): the input integer to check Returns: str: \\"Yes\\" if n is a perfect square, otherwise \\"No\\" Examples: >>> is_perfect_square(16) \\"Yes\\" >>> is_perfect_square(20) \\"No\\" >>> is_perfect_square(0) \\"Yes\\" >>> is_perfect_square(-1) \\"No\\"","solution":"import math def is_perfect_square(n): Determines if the given integer n is a perfect square. Parameters: n (int): the input integer to check Returns: str: \\"Yes\\" if n is a perfect square, otherwise \\"No\\" if n < 0: return \\"No\\" sqrt_n = int(math.sqrt(n)) if sqrt_n * sqrt_n == n: return \\"Yes\\" else: return \\"No\\""},{"question":"def max_consecutive_ads(n: int, t: int, ads: str) -> int: Returns the maximum number of consecutive ads from the same brand after performing up to t changes. >>> max_consecutive_ads(10, 2, \\"aabacbebebe\\") 5 >>> max_consecutive_ads(5, 1, \\"ababa\\") 3 >>> max_consecutive_ads(5, 1, \\"aaaaa\\") 5 >>> max_consecutive_ads(5, 0, \\"aaaaa\\") 5 >>> max_consecutive_ads(5, 2, \\"abcde\\") 3 >>> max_consecutive_ads(6, 6, \\"abcdef\\") 6 >>> max_consecutive_ads(5, 1, \\"aaaad\\") 5 >>> max_consecutive_ads(5, 0, \\"abcde\\") 1 >>> max_consecutive_ads(7, 2, \\"abacaba\\") 5","solution":"def max_consecutive_ads(n, t, ads): Returns the maximum number of consecutive ads from the same brand after performing up to t changes. Parameters: n (int): number of ads in the sequence t (int): maximum number of ads that can be changed ads (str): the sequence of ads represented by characters max_len = 0 ad_counts = {} left = 0 for right in range(n): ad_counts[ads[right]] = ad_counts.get(ads[right], 0) + 1 while (right - left + 1) - max(ad_counts.values()) > t: ad_counts[ads[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_sum_subarray_of_size_k(N: int, K: int, arr: List[int]) -> int: Compute the maximum possible sum of a subarray of size exactly K from the given integer array of size N. Args: N : int : The size of the array K : int : The size of the subarray arr : List[int] : The integer array containing both positive and negative integers Returns: int : The maximum possible sum of a subarray of size exactly K Examples: >>> max_sum_subarray_of_size_k(5, 3, [1, -2, 3, 4, -1]) 6 >>> max_sum_subarray_of_size_k(4, 2, [-1, -2, -3, -4]) -3 >>> max_sum_subarray_of_size_k(8, 5, [3, -1, 4, -1, 5, -9, 2, 6]) 10 pass # Unit tests def test_example_1(): assert max_sum_subarray_of_size_k(5, 3, [1, -2, 3, 4, -1]) == 6 def test_example_2(): assert max_sum_subarray_of_size_k(4, 2, [-1, -2, -3, -4]) == -3 def test_example_3(): assert max_sum_subarray_of_size_k(8, 5, [3, -1, 4, -1, 5, -9, 2, 6]) == 10 def test_edge_case_1(): assert max_sum_subarray_of_size_k(1, 1, [5]) == 5 def test_edge_case_2(): assert max_sum_subarray_of_size_k(5, 5, [1, -2, 3, 4, -1]) == 5 def test_large_input(): N = 10**5 K = 50000 arr = list(range(1, N + 1)) # a large array from 1 to 100000 expected_sum = sum(range(N - K + 1, N + 1)) assert max_sum_subarray_of_size_k(N, K, arr) == expected_sum def test_all_negative_elements(): arr = [-5, -6, -7, -8, -9] assert max_sum_subarray_of_size_k(5, 3, arr) == -18","solution":"def max_sum_subarray_of_size_k(N, K, arr): current_sum = sum(arr[:K]) max_sum = current_sum for i in range(K, N): current_sum += arr[i] - arr[i - K] if current_sum > max_sum: max_sum = current_sum return max_sum if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) K = int(data[1]) arr = list(map(int, data[2:])) print(max_sum_subarray_of_size_k(N, K, arr))"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(20) False >>> is_prime(1) False >>> is_prime(51) False pass def game_outcome(n: int, m: int, grid: List[List[int]]) -> str: Determine the outcome of the game. >>> game_outcome(3, 3, [[4, 5, 6], [7, 8, 9], [1, 2, 3]]) \\"Alice\\" >>> game_outcome(1, 1, [[2]]) \\"Alice\\" >>> game_outcome(2, 3, [[1, 2, 3], [4, 5, 6]]) \\"Alice\\" >>> game_outcome(2, 2, [[100, 100], [100, 100]]) \\"Alice\\" >>> game_outcome(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) \\"Alice\\" pass","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False max_div = int(num**0.5) + 1 for d in range(3, max_div, 2): if num % d == 0: return False return True def game_outcome(n, m, grid): Determine the outcome of the game. initial_sum = sum(sum(row) for row in grid) # If the initial sum is prime, Alice wins immediately if is_prime(initial_sum): return \\"Alice\\" # If the sum is even, Alice can make it odd by adding to any cell # If the sum is odd, Alice can make it even by adding to any cell # It's always possible to turn it into a prime by adding 1 repeatedly # since 10^6 moves are enough to cover any scenario within grid number range return \\"Alice\\" # Example usage: n, m = 3, 3 grid = [ [4, 5, 6], [7, 8, 9], [1, 2, 3] ] print(game_outcome(n, m, grid)) # Alice"},{"question":"def transform_data(n, records): Transforms input data into the desired format of total salary per department. Parameters: n (int): Number of employee records. records (list): List of strings where each string is an employee record. Returns: list: A sorted list of tuples where each tuple contains a department name and total salary. pass def print_department_salaries(sorted_departments): Prints the department names and their total salaries in the required format. Parameters: sorted_departments (list): Sorted list of tuples (department, total_salary). pass # Example usage: n = 3 records = [ \\"1 Alice HR 5000\\", \\"2 Bob IT 7000\\", \\"3 Charlie HR 6000\\" ] sorted_departments = transform_data(n, records) print_department_salaries(sorted_departments) from solution import transform_data def test_case_1(): n = 3 records = [ \\"1 Alice HR 5000\\", \\"2 Bob IT 7000\\", \\"3 Charlie HR 6000\\" ] expected_output = [(\\"HR\\", 11000), (\\"IT\\", 7000)] assert transform_data(n, records) == expected_output def test_case_2(): n = 5 records = [ \\"1 Alice Finance 6000\\", \\"2 Bob HR 7000\\", \\"3 Charlie IT 8000\\", \\"4 David IT 9000\\", \\"5 Eve Finance 6500\\" ] expected_output = [(\\"Finance\\", 12500), (\\"HR\\", 7000), (\\"IT\\", 17000)] assert transform_data(n, records) == expected_output def test_case_3(): n = 1 records = [ \\"1 Alice HR 3000\\" ] expected_output = [(\\"HR\\", 3000)] assert transform_data(n, records) == expected_output def test_case_4(): n = 4 records = [ \\"1 Alice IT 5000\\", \\"2 Bob IT 6000\\", \\"3 Charlie HR 7000\\", \\"4 David Finance 8000\\" ] expected_output = [(\\"Finance\\", 8000), (\\"HR\\", 7000), (\\"IT\\", 11000)] assert transform_data(n, records) == expected_output def test_case_5(): n = 2 records = [ \\"1 Alice Marketing 7000\\", \\"2 Bob Marketing 3000\\" ] expected_output = [(\\"Marketing\\", 10000)] assert transform_data(n, records) == expected_output","solution":"def transform_data(n, records): Transforms input data into the desired format of total salary per department. Parameters: n (int): Number of employee records. records (list): List of strings where each string is an employee record. Returns: list: A sorted list of tuples where each tuple contains a department name and total salary. department_salary = {} for record in records: _, name, department, salary = record.split() salary = int(salary) if department in department_salary: department_salary[department] += salary else: department_salary[department] = salary sorted_departments = sorted(department_salary.items()) return sorted_departments def print_department_salaries(sorted_departments): Prints the department names and their total salaries in the required format. Parameters: sorted_departments (list): Sorted list of tuples (department, total_salary). for department, salary in sorted_departments: print(f\\"{department} {salary}\\") # Example usage: n = 3 records = [ \\"1 Alice HR 5000\\", \\"2 Bob IT 7000\\", \\"3 Charlie HR 6000\\" ] sorted_departments = transform_data(n, records) print_department_salaries(sorted_departments)"},{"question":"def rotate_left(arr: List[int], steps: int) -> List[int]: Rotates the array to the left by a given number of steps. Args: arr : list - A list of integers to be rotated. steps : int - Number of steps to rotate the array to the left. Returns: list - The rotated array.","solution":"def rotate_left(arr, steps): Rotates the array to the left by a given number of steps. Args: arr : list - A list of integers to be rotated. steps : int - Number of steps to rotate the array to the left. Returns: list - The rotated array. length = len(arr) steps = steps % length # In case steps is greater than array length return arr[steps:] + arr[:steps]"},{"question":"def robo_cleaner_path(R: int, C: int, sr: int, sc: int, obstacles: List[Tuple[int, int]], M: int, moves: str) -> Tuple[int, int]: Determine the final position of the robotic vacuum cleaner after following a sequence of moves. >>> robo_cleaner_path(5, 5, 3, 3, [(2, 2), (4, 3), (3, 4)], 10, \\"UDLRRRLULU\\") (2, 1) >>> robo_cleaner_path(3, 3, 1, 1, [], 8, \\"RRDDLLUU\\") (1, 1)","solution":"def robo_cleaner_path(R, C, sr, sc, obstacles, M, moves): # Create a set of obstacle positions obstacles_set = set(obstacles) # Initialize the starting position position = (sr, sc) # Define direction movements direction_dict = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)} # Process each move for move in moves: delta_row, delta_col = direction_dict[move] new_position = (position[0] + delta_row, position[1] + delta_col) if (1 <= new_position[0] <= R and 1 <= new_position[1] <= C and new_position not in obstacles_set): position = new_position return position # Example input: # R = 5, C = 5 # sr = 3, sc = 3 # obstacles = [(2, 2), (4, 3), (3, 4)] # M = 10 # moves = \\"UDLRRRLULU\\" # Expected output: (2, 1) # Calling the function print(robo_cleaner_path(5, 5, 3, 3, [(2, 2), (4, 3), (3, 4)], 10, \\"UDLRRRLULU\\"))"},{"question":"def highest_permit(n: int, permits: List[int]) -> int: Returns the highest permit number still available from the given list after removing consecutive permit sequence based on popularity index. >>> highest_permit(5, [1, 2, 4, 5, 6]) 6 >>> highest_permit(7, [1, 3, 4, 5, 7, 8, 9]) 9 >>> highest_permit(1, [10]) 10 >>> highest_permit(31, list(range(1, 32))) 31 >>> highest_permit(3, [1, 2, 3]) 3 >>> highest_permit(5, [2, 4, 6, 7, 25]) 25","solution":"def highest_permit(n, permits): Returns the highest permit number still available from the given list after removing consecutive permit sequence based on popularity index. return max(permits)"},{"question":"def partition_list(nums): Partitions the list into two sublists such that the sum of the elements in the first sublist is as close as possible to the sum of the elements in the second sublist. >>> partition_list([3, 1, 4, 2, 2, 1]) ([3, 1, 2], [4, 2, 1]) >>> partition_list([5]) ([5], []) >>> partition_list([0, 0, 0, 0]) ([0, 0], [0, 0]) >>> partition_list([-1, -2, -3, -4]) ([-1, -2], [-3, -4]) >>> partition_list([10, -10, 20, -20, 30, -30]) ([10, -10, 20], [-20, 30, -30])","solution":"def partition_list(nums): Partitions the list into two sublists such that the sum of the elements in the first sublist is as close as possible to the sum of the elements in the second sublist. def find_partition(nums, i, sum1, sum2, set1, set2): if i == len(nums): return abs(sum1 - sum2), set1, set2 # Include current element in the first subset diff1, subset1_a, subset1_b = find_partition(nums, i + 1, sum1 + nums[i], sum2, set1 + [nums[i]], set2) # Include current element in the second subset diff2, subset2_a, subset2_b = find_partition(nums, i + 1, sum1, sum2 + nums[i], set1, set2 + [nums[i]]) if diff1 <= diff2: return diff1, subset1_a, subset1_b else: return diff2, subset2_a, subset2_b _, set1, set2 = find_partition(nums, 0, 0, 0, [], []) return set1, set2"},{"question":"def min_length_substring_with_all_unique_chars(string: str) -> int: Returns the minimum length of a contiguous substring of the given string that contains all the unique characters present in the original string at least once. >>> min_length_substring_with_all_unique_chars(\\"abacabd\\") == 4 >>> min_length_substring_with_all_unique_chars(\\"aaaaaa\\") == 1 >>> min_length_substring_with_all_unique_chars(\\"a\\") == 1 >>> min_length_substring_with_all_unique_chars(\\"aa\\") == 1 >>> min_length_substring_with_all_unique_chars(\\"ab\\") == 2 >>> s = \\"abcdefghijklmnopqrstuvwxyz\\" * 100 >>> min_length_substring_with_all_unique_chars(s) == 26","solution":"def min_length_substring_with_all_unique_chars(string): Returns the minimum length of a contiguous substring of the given string that contains all the unique characters present in the original string at least once. unique_chars = set(string) num_unique_chars = len(unique_chars) char_frequency = {} start = 0 min_length = len(string) for end in range(len(string)): char_frequency[string[end]] = char_frequency.get(string[end], 0) + 1 while len(char_frequency) == num_unique_chars: min_length = min(min_length, end - start + 1) char_frequency[string[start]] -= 1 if char_frequency[string[start]] == 0: del char_frequency[string[start]] start += 1 return min_length"},{"question":"def pseudo_prime_numbers(n: int) -> List[int]: Generates a list of the first n pseudo-prime numbers. A pseudo-prime number is a number that has exactly three distinct positive divisors. >>> pseudo_prime_numbers(1) [4] >>> pseudo_prime_numbers(5) [4, 9, 25, 49, 121] >>> pseudo_prime_numbers(10) [4, 9, 25, 49, 121, 169, 289, 361, 529, 841] >>> pseudo_prime_numbers(0) [] >>> pseudo_prime_numbers(2) [4, 9]","solution":"def is_prime(num): Determines if the given number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def pseudo_prime_numbers(n): Generates a list of the first n pseudo-prime numbers. Pseudo-prime number is a number that has exactly three distinct positive divisors. pseudo_primes = [] i = 2 while len(pseudo_primes) < n: if is_prime(i): pseudo_primes.append(i * i) i += 1 return pseudo_primes"},{"question":"def find_words_in_grid(N: int, M: int, grid: List[str], words: List[str]) -> List[str]: Given a grid of size NxM filled with letters and a list of words, find all words in the list that can be formed by tracing a path in the grid. A valid path can start from any cell and move in any of the 8 possible directions (up, down, left, right, or diagonally), but you cannot visit the same cell more than once in a single path. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[str]): The grid represented as a list of strings. words (List[str]): The list of words to search for in the grid. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each word, indicating if the word can be traced in the grid. pass # Test cases to validate the solution def test_example_case(): N = 4 M = 4 grid = [ \\"ABCD\\", \\"EFGH\\", \\"IJKL\\", \\"MNOP\\" ] words = [\\"BEFI\\", \\"CFIM\\", \\"ABCDJ\\"] expected = [\\"YES\\", \\"YES\\", \\"NO\\"] assert find_words_in_grid(N, M, grid, words) == expected def test_single_cell_grid(): N = 1 M = 1 grid = [\\"A\\"] words = [\\"A\\", \\"B\\"] expected = [\\"YES\\", \\"NO\\"] assert find_words_in_grid(N, M, grid, words) == expected def test_no_words(): N = 5 M = 5 grid = [ \\"ABCDE\\", \\"FGHIJ\\", \\"KLMNO\\", \\"PQRST\\", \\"UVWXY\\" ] words = [] expected = [] assert find_words_in_grid(N, M, grid, words) == expected def test_words_not_in_grid(): N = 2 M = 2 grid = [ \\"AB\\", \\"CD\\" ] words = [\\"EF\\", \\"Z\\"] expected = [\\"NO\\", \\"NO\\"] assert find_words_in_grid(N, M, grid, words) == expected def test_large_input(): N = 10 M = 10 grid = [ \\"ABCDEFGHIJ\\", \\"KLMNOPQRST\\", \\"UVWXYZABCD\\", \\"EFGHIJKLMN\\", \\"OPQRSTUVWX\\", \\"YZABCDEFGHI\\", \\"JKLMNOPQRSTUVWXYZ\\", \\"ABCDEFGHIJKLMNOPQR\\", \\"STUVWXYZABCDEFGHIJ\\", \\"KLMNOPQRSTUV\\" ] words = [\\"ABCDEFGHIJ\\", \\"JKLM\\", \\"UVWXYZA\\"] expected = [\\"YES\\", \\"YES\\", \\"YES\\"] assert find_words_in_grid(N, M, grid, words) == expected","solution":"def find_word_in_grid(grid, word, x, y, visited): if not word: return True if ( x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or visited[x][y] or grid[x][y] != word[0] ): return False visited[x][y] = True word = word[1:] # 8 possible directions directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in directions: if find_word_in_grid(grid, word, x + dx, y + dy, visited): return True visited[x][y] = False return False def word_exists(grid, word): N = len(grid) M = len(grid[0]) visited = [[False for _ in range(M)] for _ in range(N)] for i in range(N): for j in range(M): if grid[i][j] == word[0] and find_word_in_grid(grid, word, i, j, visited): return \\"YES\\" return \\"NO\\" def find_words_in_grid(N, M, grid, words): results = [] for word in words: result = word_exists(grid, word) results.append(result) return results"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def maximize_identical_indices(q: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Generate a permutation p of the sequence 1, 2, ..., n such that the number of indices i for which a_i = p_i is maximized. Input: q (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing an integer n and a list of integers a of length n. Output: List[List[int]]: A list of n integers p_1, p_2, ..., p_n for each test case. Example: >>> maximize_identical_indices(2, [(3, [1, 3, 2]), (4, [4, 2, 3, 1])]) [[1, 3, 2], [4, 2, 3, 1]] pass # Test Cases def test_maximize_identical_indices(): q = 2 test_cases = [ (3, [1, 3, 2]), (4, [4, 2, 3, 1]) ] assert maximize_identical_indices(q, test_cases) == [ [1, 3, 2], [4, 2, 3, 1] ] def test_single_element(): q = 1 test_cases = [ (1, [1]) ] assert maximize_identical_indices(q, test_cases) == [ [1] ] def test_same_elements(): q = 1 test_cases = [ (5, [1, 1, 1, 1, 1]) ] assert maximize_identical_indices(q, test_cases) == [ [1, 1, 1, 1, 1] ] def test_increasing_order(): q = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] assert maximize_identical_indices(q, test_cases) == [ [1, 2, 3, 4, 5] ] def test_decreasing_order(): q = 1 test_cases = [ (5, [5, 4, 3, 2, 1]) ] assert maximize_identical_indices(q, test_cases) == [ [5, 4, 3, 2, 1] ]","solution":"def maximize_identical_indices(q, test_cases): result = [] for i in range(q): n = test_cases[i][0] a = test_cases[i][1] result.append(a) return result"},{"question":"from typing import List def find_winner(n: int, teams: List[str], results: List[str]) -> str: Determines the winner of the Berland International Tournament after all matches have been played. Args: n : int : Number of teams participating in the tournament. teams : List[str] : List of team names. results : List[str] : List of strings describing the results of the matches. Returns: str : The name of the team that wins the tournament. Example: >>> find_winner(4, [\\"Alpha\\", \\"Beta\\", \\"Gamma\\", \\"Delta\\"], [\\"Alpha-Beta 1:0\\", \\"Alpha-Gamma 2:2\\", \\"Alpha-Delta 3:1\\", \\"Beta-Gamma 1:0\\", \\"Beta-Delta 2:2\\", \\"Gamma-Delta 1:0\\"]) 'Alpha' >>> find_winner(3, [\\"TeamA\\", \\"TeamB\\", \\"TeamC\\"], [\\"TeamA-TeamB 3:1\\", \\"TeamA-TeamC 1:0\\", \\"TeamB-TeamC 2:2\\"]) 'TeamA' def test_find_winner(): # Test case 1 n = 4 teams = [\\"Alpha\\", \\"Beta\\", \\"Gamma\\", \\"Delta\\"] results = [ \\"Alpha-Beta 1:0\\", \\"Alpha-Gamma 2:2\\", \\"Alpha-Delta 3:1\\", \\"Beta-Gamma 1:0\\", \\"Beta-Delta 2:2\\", \\"Gamma-Delta 1:0\\" ] assert find_winner(n, teams, results) == \\"Alpha\\" # Test case 2 n = 3 teams = [\\"TeamA\\", \\"TeamB\\", \\"TeamC\\"] results = [ \\"TeamA-TeamB 3:1\\", \\"TeamA-TeamC 1:0\\", \\"TeamB-TeamC 2:2\\" ] assert find_winner(n, teams, results) == \\"TeamA\\" # Test case 3 - checking for the bonus point mechanism n = 3 teams = [\\"TeamX\\", \\"TeamY\\", \\"TeamZ\\"] results = [ \\"TeamX-TeamY 2:1\\", \\"TeamX-TeamZ 2:0\\", \\"TeamY-TeamZ 3:1\\", \\"TeamY-TeamX 2:1\\", \\"TeamZ-TeamX 0:1\\", \\"TeamZ-TeamY 0:2\\" ] assert find_winner(n, teams, results) == \\"TeamY\\"","solution":"def find_winner(n, teams, results): points = {team: 0 for team in teams} goal_differences = {team: 0 for team in teams} goals_scored = {team: 0 for team in teams} win_streaks = {team: 0 for team in teams} # Process each match result for result in results: match, score = result.split() team1, team2 = match.split('-') goals1, goals2 = map(int, score.split(':')) # Update goals and goal differences goals_scored[team1] += goals1 goals_scored[team2] += goals2 goal_differences[team1] += goals1 - goals2 goal_differences[team2] += goals2 - goals1 if goals1 > goals2: points[team1] += 3 win_streaks[team1] += 1 win_streaks[team2] = 0 if win_streaks[team1] == 3: points[team1] += 1 elif goals2 > goals1: points[team2] += 3 win_streaks[team2] += 1 win_streaks[team1] = 0 if win_streaks[team2] == 3: points[team2] += 1 else: points[team1] += 1 points[team2] += 1 win_streaks[team1] = 0 win_streaks[team2] = 0 # Determine the winner winner = max(teams, key=lambda t: (points[t], goal_differences[t], goals_scored[t])) return winner"},{"question":"def smallest_subarray_with_sum(n: int, t: int, a: List[int]) -> int: Returns the length of the smallest contiguous subarray whose sum is greater than or equal to \`t\`. If no such subarray exists, returns 0. Args: n (int): The number of elements in the array. t (int): The target sum. a (List[int]): The list of integers representing the array. Returns: int: The length of the smallest subarray with a sum greater than or equal to \`t\`, or 0 if no such subarray exists. Example: >>> smallest_subarray_with_sum(8, 15, [1, 2, 3, 4, 5, 6, 7, 8]) 2 >>> smallest_subarray_with_sum(5, 100, [1, 2, 3, 4, 5]) 0","solution":"def smallest_subarray_with_sum(n, t, a): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to \`t\`. If no such subarray exists, returns 0. left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += a[right] while current_sum >= t: min_length = min(min_length, right - left + 1) current_sum -= a[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def knight_moves(position: str) -> List[str]: Given a knight's initial position on a standard 8x8 chessboard, determine all possible positions it can move to with a single move. The input is a string representing the position in standard chess notation. The output should be a list of valid positions the knight can move to in standard chess notation, sorted first by file ('a' to 'h') and then by rank ('1' to '8'). >>> knight_moves('f5') ['d4', 'd6', 'e3', 'e7', 'g3', 'g7', 'h4', 'h6'] >>> knight_moves('a1') ['b3', 'c2'] >>> knight_moves('h8') ['f7', 'g6'] >>> knight_moves('d4') ['b3', 'b5', 'c2', 'c6', 'e2', 'e6', 'f3', 'f5'] >>> knight_moves('e5') ['c4', 'c6', 'd3', 'd7', 'f3', 'f7', 'g4', 'g6']","solution":"def knight_moves(position): # Define the mapping of files to their respective indices file_to_index = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8} index_to_file = {v: k for k, v in file_to_index.items()} # Define the possible moves for a knight moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Initialize the list for the valid moves valid_moves = [] # Extract the initial file and rank initial_file = position[0] initial_rank = int(position[1]) # Calculate the initial coordinates initial_x = file_to_index[initial_file] initial_y = initial_rank # Generate all possible moves for dx, dy in moves: new_x = initial_x + dx new_y = initial_y + dy if 1 <= new_x <= 8 and 1 <= new_y <= 8: valid_moves.append(index_to_file[new_x] + str(new_y)) # Sort the valid positions valid_moves.sort() return valid_moves"},{"question":"import random card_values = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 } def draw_card(): Simulates drawing a card from the deck. Returns the value of the card drawn. card = random.choice(list(card_values.keys())) return card_values[card] def simulate_game(n): Simulates a game of n rounds and returns the winner. >>> simulate_game(5) # random output 'Player 1' >>> simulate_game(3) # random output 'Draw'","solution":"import random # Define card values card_values = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 } def draw_card(): Simulates drawing a card from the deck. Returns the value of the card drawn. card = random.choice(list(card_values.keys())) return card_values[card] def simulate_game(n): Simulates a game of n rounds and returns the winner. player1_wins = 0 player2_wins = 0 for _ in range(n): player1_card = draw_card() player2_card = draw_card() if player1_card > player2_card: player1_wins += 1 elif player2_card > player1_card: player2_wins += 1 if player1_wins > player2_wins: return \\"Player 1\\" elif player2_wins > player1_wins: return \\"Player 2\\" else: return \\"Draw\\" # Example usage: # result = simulate_game(5) # print(result)"},{"question":"def order_of_repairs(m: int, jobs: List[Tuple[int, int]]) -> List[int]: Determines the order in which repair jobs should be completed based on priority. Parameters: m (int): The number of repair jobs. jobs (list of tuples): Each tuple contains two integers pi (priority) and di (duration). Returns: list of int: The order in which the repair jobs are completed. >>> order_of_repairs(4, [(2, 3), (4, 2), (2, 5), (3, 1)]) [2, 4, 1, 3] >>> order_of_repairs(3, [(5, 2), (5, 1), (5, 3)]) [1, 2, 3]","solution":"def order_of_repairs(m, jobs): Determines the order in which repair jobs should be completed based on priority. Parameters: m (int): The number of repair jobs. jobs (list of tuples): Each tuple contains two integers pi (priority) and di (duration). Returns: list of int: The order in which the repair jobs are completed. indexed_jobs = [(i+1, jobs[i][0], jobs[i][1]) for i in range(m)] indexed_jobs.sort(key=lambda x: (-x[1], x[0])) return [job[0] for job in indexed_jobs] # Example usage: m = 4 jobs = [(2, 3), (4, 2), (2, 5), (3, 1)] print(order_of_repairs(m, jobs)) # Output: [2, 4, 1, 3]"},{"question":"def check_trees(n, m, k, q, trees, queries): Determines if each query rectangle contains at least one tree. :param n: Number of rows in the land :param m: Number of columns in the land :param k: Number of trees :param q: Number of queries :param trees: List of tuples containing the positions of the trees :param queries: List of tuples containing the query rectangles :return: List of strings \\"YES\\" or \\"NO\\" for each query >>> n, m, k, q = 5, 5, 3, 4 >>> trees = [(1, 1), (3, 3), (4, 4)] >>> queries = [(1, 1, 2, 2), (2, 2, 3, 3), (4, 3, 5, 5), (1, 2, 5, 2)] >>> check_trees(n, m, k, q, trees, queries) ['YES', 'YES', 'YES', 'NO'] >>> n, m, k, q = 5, 5, 0, 1 >>> trees = [] >>> queries = [(1, 1, 5, 5)] >>> check_trees(n, m, k, q, trees, queries) ['NO'] >>> n, m, k, q = 3, 3, 9, 1 >>> trees = [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)] >>> queries = [(1, 1, 3, 3)] >>> check_trees(n, m, k, q, trees, queries) ['YES'] >>> n, m, k, q = 4, 4, 2, 2 >>> trees = [(2, 2), (3, 3)] >>> queries = [(1, 1, 2, 2), (3, 3, 4, 4)] >>> check_trees(n, m, k, q, trees, queries) ['YES', 'YES'] >>> n, m, k, q = 10, 10, 1, 1 >>> trees = [(5, 5)] >>> queries = [(1, 1, 4, 4)] >>> check_trees(n, m, k, q, trees, queries) ['NO']","solution":"def check_trees(n, m, k, q, trees, queries): Determines if each query rectangle contains at least one tree. :param n: Number of rows in the land :param m: Number of columns in the land :param k: Number of trees :param q: Number of queries :param trees: List of tuples containing the positions of the trees :param queries: List of tuples containing the query rectangles :return: List of strings \\"YES\\" or \\"NO\\" for each query # Create a set for quick lookup of trees tree_set = set((x, y) for x, y in trees) results = [] for (x1, y1, x2, y2) in queries: contains_tree = False for x in range(x1, x2 + 1): for y in range(y1, y2 + 1): if (x, y) in tree_set: contains_tree = True break if contains_tree: break results.append(\\"YES\\" if contains_tree else \\"NO\\") return results"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Write a function that takes two strings as input and returns their longest common subsequence (LCS). The LCS of two sequences is the longest subsequence that is common to both sequences. A subsequence is a sequence derived from another sequence by deleting some or none of the elements without changing the order of the remaining elements. Input: Two strings of uppercase English letters are given as input. The lengths of the strings do not exceed 1000. Output: Output a single integer, the length of their longest common subsequence. Example: >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence(\\"\\", \\"GXTXAYB\\") 0 >>> longest_common_subsequence(\\"AGGTAB\\", \\"\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"XYZ\\") 0 >>> longest_common_subsequence(\\"ABCDEF\\", \\"ABCDEF\\") 6 >>> longest_common_subsequence(\\"ABC\\", \\"AABC\\") 3 >>> longest_common_subsequence(\\"ABCDEF\\", \\"GHIJKL\\") 0 >>> longest_common_subsequence(\\"A\\", \\"A\\") 1 >>> longest_common_subsequence(\\"A\\", \\"B\\") 0","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between two strings. m, n = len(str1), len(str2) # Create a dp table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table in bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value at dp[m][n] is the length of the longest common subsequence return dp[m][n]"},{"question":"from typing import List def longest_arithmetic_subarray(nums: List[int]) -> int: Given an integer array nums, find the length of the longest arithmetic subarray. An arithmetic subarray is a subarray that contains at least two integers and the differences between consecutive integers are the same. >>> longest_arithmetic_subarray([10, 7, 4, 6, 8, 10, 11]) 4 >>> longest_arithmetic_subarray([9, 7, 5, 3, 1, -1, -3]) 7 >>> longest_arithmetic_subarray([1, 2]) 2 >>> longest_arithmetic_subarray([5, 5]) 2 >>> longest_arithmetic_subarray([2, 4, 6, 8, 10]) 5 >>> longest_arithmetic_subarray([1, 2, 4, 7, 11]) 2 >>> longest_arithmetic_subarray([1, 3, 6, 5, 7, 9, 11]) 4 >>> longest_arithmetic_subarray([20, 15, 10, 3, 5, 7, 2, 1]) 3","solution":"def longest_arithmetic_subarray(nums): if len(nums) < 2: return 0 max_len = 2 curr_len = 2 diff = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i-1] == diff: curr_len += 1 else: diff = nums[i] - nums[i-1] curr_len = 2 max_len = max(max_len, curr_len) return max_len"},{"question":"def compress_string(s: str) -> str: Compress the string by replacing groups of consecutive identical characters with just one instance of the character followed by the count of its occurrences. If the compressed result is not shorter than the original string, return the original string. Args: s (str): The input string consisting only of lowercase English letters. Returns: str: The compressed string or the original string if compression does not reduce the length. >>> compress_string(\\"aaabccdddd\\") 'a3b1c2d4' >>> compress_string(\\"abcd\\") 'abcd' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"aaaaa\\") 'a5' >>> compress_string(\\"ababab\\") 'ababab' >>> compress_string(\\"zzzzzzzzzz\\") 'z10' >>> compress_string(\\"aaabbccccd\\") 'a3b2c4d1' >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3'","solution":"def compress_string(s): Compress the string by replacing groups of consecutive identical characters with just one instance of the character followed by the count of its occurrences. If the compressed result is not shorter than the original string, return the original string. Args: s (str): The input string consisting only of lowercase English letters. Returns: str: The compressed string or the original string if compression does not reduce the length. compressed = [] i = 0 n = len(s) while i < n: count = 1 while i + 1 < n and s[i] == s[i + 1]: count += 1 i += 1 compressed.append(s[i]) compressed.append(str(count)) i += 1 compressed_string = ''.join(compressed) if len(compressed_string) < n: return compressed_string else: return s"},{"question":"def minimum_difficulty(m: int, difficulties: List[int]) -> Union[int, Tuple[int, int]]: Returns the minimum possible difficulty for dividing quests into pairs and the difficulty of unpaired quest if the number of quests is odd. >>> minimum_difficulty(6, [30, 50, 10, 90, 60, 70]) 20 >>> minimum_difficulty(5, [1, 2, 3, 4, 5]) (1, 5) >>> minimum_difficulty(4, [10, 10, 10, 10]) 0 >>> minimum_difficulty(4, [1, 3, 5, 7]) 2 >>> minimum_difficulty(1, [10]) (0, 10) >>> minimum_difficulty(3, [20, 30, 10]) (10, 30)","solution":"def minimum_difficulty(m, difficulties): Returns the minimum possible difficulty for dividing quests into pairs and the difficulty of unpaired quest if the number of quests is odd. difficulties.sort() paired_difficulties = [] for i in range(0, m - 1, 2): paired_difficulties.append(abs(difficulties[i + 1] - difficulties[i])) min_max_difficulty = max(paired_difficulties) if paired_difficulties else 0 if m % 2 == 1: unpaired_difficulty = difficulties[-1] return min_max_difficulty, unpaired_difficulty else: return min_max_difficulty # Example usage: #output = minimum_difficulty(5, [1, 2, 3, 4, 5]) #print(output) # Should print (1, 5)"},{"question":"def collatz_steps(n: int) -> int: Returns the number of steps required to reduce n to 1 following the rules of the Collatz Conjecture. If n is even, divide it by 2. If n is odd, multiply it by 3 and add 1. Examples: >>> collatz_steps(6) 8 >>> collatz_steps(15) 17 >>> collatz_steps(1) 0","solution":"def collatz_steps(n): Returns the number of steps required to reduce n to 1 following the rules of the Collatz Conjecture. If n is even, divide it by 2. If n is odd, multiply it by 3 and add 1. steps = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = n * 3 + 1 steps += 1 return steps"},{"question":"import random from typing import List, Tuple def generate_and_test(algorithm_func): Generates data points according to the given specifications and calls the provided algorithm function with these data points. pass def example_algorithm(data: List[Tuple[int, int]]) -> int: return sum(a + b for a, b in data) # Example test cases to implement def algorithm_sum(data: List[Tuple[int, int]]) -> int: return sum(a + b for a, b in data) def algorithm_product(data: List[Tuple[int, int]]) -> int: prod = 1 for a, b in data: prod *= (a + b) return prod def test_generate_and_test_sum(monkeypatch): # Mock random.randint to control the output for predictable testing def mock_randint(start, end): return 5 if (start == 5 and end == 20) else 10 monkeypatch.setattr(random, 'randint', mock_randint) # Now call generate_and_test with the algorithm_sum function result = generate_and_test(algorithm_sum) expected_data = [(10, 10) for _ in range(5)] assert result == sum(a + b for a, b in expected_data) def test_generate_and_test_product(monkeypatch): def mock_randint(start, end): return 6 if (start == 5 and end == 20) else 5 monkeypatch.setattr(random, 'randint', mock_randint) result = generate_and_test(algorithm_product) expected_data = [(5, 5) for _ in range(6)] expected_prod = 1 for a, b in expected_data: expected_prod *= (a + b) assert result == expected_prod def test_generate_and_test_print_output(monkeypatch, capsys): def mock_randint(start, end): return 7 if (start == 5 and end == 20) else 3 monkeypatch.setattr(random, 'randint', mock_randint) generate_and_test(algorithm_sum) captured = capsys.readouterr() expected_data = [(3, 3) for _ in range(7)] expected_output = sum(a + b for a, b in expected_data) assert str(expected_output) in captured.out","solution":"import random def generate_and_test(algorithm_func): Generates data points according to the given specifications and calls the provided algorithm function with these data points. # Generate a random number of data points between 5 and 20 n = random.randint(5, 20) # Generate n tuples with random integers between 1 and 100 data = [(random.randint(1, 100), random.randint(1, 100)) for _ in range(n)] # Call the provided algorithm function with the generated data result = algorithm_func(data) # Print the output of the algorithm function print(result) return result"},{"question":"def calculate_max_distances(truck_data): Given a list of tuples containing the fuel tank capacity and consumption rate for a number of trucks, returns a list of maximum distances each truck can travel on a full tank of fuel. Args: truck_data (list of tuples): A list where each tuple contains two integers, the fuel tank capacity in liters and the fuel consumption rate in liters per 100 kilometers. Returns: list of int: A list of maximum distances in kilometers each truck can travel. >>> calculate_max_distances([(50, 8), (60, 10), (40, 5)]) [625, 600, 800] >>> calculate_max_distances([(1000, 100), (1000, 50)]) [1000, 2000] >>> calculate_max_distances([(1, 1), (1, 2)]) [100, 50] >>> calculate_max_distances([(1000, 1)]) [100000] >>> calculate_max_distances([(33, 7)]) [471]","solution":"def calculate_max_distances(truck_data): Given a list of tuples containing the fuel tank capacity and consumption rate for a number of trucks, returns a list of maximum distances each truck can travel on a full tank of fuel. Args: truck_data (list of tuples): A list where each tuple contains two integers, the fuel tank capacity in liters and the fuel consumption rate in liters per 100 kilometers. Returns: list of int: A list of maximum distances in kilometers each truck can travel. max_distances = [] for C, R in truck_data: max_distance = (C / R) * 100 max_distances.append(int(max_distance)) return max_distances"},{"question":"def count_distinct_prime_factors(n: int, A: List[int]) -> List[int]: Given an array A of n positive integers, return an array B containing the count of distinct prime numbers that divide each corresponding element in A. Example: >>> count_distinct_prime_factors(6, [10, 15, 21, 28, 33, 49]) [2, 2, 2, 2, 2, 1] >>> count_distinct_prime_factors(1, [1]) [0] >>> count_distinct_prime_factors(3, [2, 3, 5]) [1, 1, 1] >>> count_distinct_prime_factors(5, [6, 8, 10, 12, 15]) [2, 1, 2, 2, 2] >>> count_distinct_prime_factors(4, [4, 9, 25, 49]) [1, 1, 1, 1]","solution":"def count_distinct_prime_factors(n, A): MAXN = 10**6 + 1 spf = [0] * MAXN # Smallest prime factor for every number # Using Sieve of Eratosthenes to fill smallest prime factor for every number for i in range(2, MAXN): if spf[i] == 0: # i is a prime number for j in range(i, MAXN, i): if spf[j] == 0: spf[j] = i def prime_factors_count(x): primes = set() while x != 1: primes.add(spf[x]) x //= spf[x] return len(primes) B = [prime_factors_count(A[i]) for i in range(n)] return B"},{"question":"def count_unique_triplets(arr, target): Determines the number of unique triplets in the array which sums up to the target value. >>> count_unique_triplets([2, 1, 3, 2], 6) == 1 >>> count_unique_triplets([-1, 0, 1, 2, -1, -4], 0) == 2 >>> count_unique_triplets([1, 1, 1, 0, -2, -1], 0) == 2 >>> count_unique_triplets([0, 0, 0, 0], 0) == 1 >>> count_unique_triplets([2, 2, 2, 2, 2], 6) == 1 >>> count_unique_triplets([], 0) == 0 >>> count_unique_triplets([1, 2, 3], 6) == 1 >>> count_unique_triplets([1, 2, -3, 4, -1, 2], 3) == 2 >>> count_unique_triplets([1, 2, 3], 10) == 0 >>> count_unique_triplets([5, 1, -7, 3, 8], 20) == 0 >>> count_unique_triplets([1000000, -1000000, 500000, -500000, 0], 0) == 2 >>> count_unique_triplets([1000000, 999999, -1, -999998, -2, 1], 3) == 1","solution":"def count_unique_triplets(arr, target): Determines the number of unique triplets in the array which sums up to the target value. arr.sort() triplets = set() for i in range(len(arr) - 2): left = i + 1 right = len(arr) - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == target: triplet = (arr[i], arr[left], arr[right]) triplets.add(triplet) left += 1 right -= 1 # To avoid duplicates while left < right and arr[left] == arr[left - 1]: left += 1 while left < right and arr[right] == arr[right + 1]: right -= 1 elif total < target: left += 1 else: right -= 1 return len(triplets)"},{"question":"from typing import List, Tuple def process_input(input_data: str) -> List[Tuple[int, List[Tuple[str, List[str]]]]]: Process the input data to extract developers' information. Args: input_data: str - The raw input data as a string. Returns: List of tuples with the number of tasks and a list of tasks with their prerequisites. def can_complete_tasks(developers_info: List[Tuple[int, List[Tuple[str, List[str]]]]]) -> List[str]: Determines if each developer can complete all their assigned tasks following their dependencies. Args: developers_info: List of tuples where each tuple consists of number of tasks and a list of tasks with prerequisites. Returns: List of strings \\"YES\\" or \\"NO\\" for each developer. def main(input_data: str) -> str: Main function to process input data and determine if tasks can be completed. Args: input_data: str - The raw input data as a string. Returns: str - Result for each developer whether they can complete their tasks. def test_processing_input(): input_data = 2 3 A 0 B 1 A C 1 B 4 X 0 Y 1 X Z 2 X Y W 1 Z expected_output = [ (3, [('A', []), ('B', ['A']), ('C', ['B'])]), (4, [('X', []), ('Y', ['X']), ('Z', ['X', 'Y']), ('W', ['Z'])]) ] assert process_input(input_data) == expected_output def test_can_complete_tasks_with_simple_case(): developers_info = [ (3, [('A', []), ('B', ['A']), ('C', ['B'])]) ] assert can_complete_tasks(developers_info) == [\\"YES\\"] def test_can_complete_tasks_with_complex_case(): developers_info = [ (4, [('X', []), ('Y', ['X']), ('Z', ['X', 'Y']), ('W', ['Z'])]) ] assert can_complete_tasks(developers_info) == [\\"YES\\"] def test_main(): input_data = 2 3 A 0 B 1 A C 1 B 4 X 0 Y 1 X Z 2 X Y W 1 Z expected_output = \\"YESnYES\\" assert main(input_data) == expected_output def test_main_with_cycle(): input_data = 1 3 A 0 B 1 A A 1 B expected_output = \\"NO\\" assert main(input_data) == expected_output","solution":"def can_complete_tasks(developers_info): Determines if each developer can complete all their assigned tasks following their dependencies. Args: developers_info: List of tuples where each tuple consists of number of tasks and a list of tasks with prerequisites. Returns: List of strings \\"YES\\" or \\"NO\\" for each developer. def has_cycle(tasks): # Create a graph and a flag for visited nodes graph = {} visited = {} for task, prerequisites in tasks: graph[task] = prerequisites visited[task] = 'WHITE' # WHITE: unvisited, GRAY: visiting, BLACK: finished def dfs(task): if visited[task] == 'GRAY': return True # cycle found if visited[task] == 'BLACK': return False # already completed this node, no cycle found visited[task] = 'GRAY' for prerequisite in graph[task]: if dfs(prerequisite): return True visited[task] = 'BLACK' return False for task in tasks: if visited[task[0]] == 'WHITE': if dfs(task[0]): return True return False results = [] for developer in developers_info: t, tasks = developer if has_cycle(tasks): results.append(\\"NO\\") else: results.append(\\"YES\\") return results def process_input(input_data): input_lines = input_data.strip().split('n') d = int(input_lines[0].strip()) index = 1 developers_info = [] for _ in range(d): t = int(input_lines[index].strip()) index += 1 tasks = [] for _ in range(t): task_info = input_lines[index].strip().split() task_name = task_info[0] prerequisites_count = int(task_info[1]) prerequisites = task_info[2:] tasks.append((task_name, prerequisites)) index += 1 developers_info.append((t, tasks)) return developers_info def main(input_data): developers_info = process_input(input_data) result = can_complete_tasks(developers_info) return \\"n\\".join(result)"},{"question":"def volunteer_status(signed_up: List[int], target: List[int]) -> List[str]: Returns a list of status for each task, indicating whether the number of signed-up volunteers meets or exceeds the target. :param signed_up: A list of integers representing the number of signed-up volunteers for each task. :param target: A list of integers representing the target number of volunteers for each task. :return: A list of strings, either \\"enough\\" or \\"deficient\\" for each task. >>> volunteer_status([5, 10, 3, 7, 2], [3, 12, 3, 5, 2]) [\\"enough\\", \\"deficient\\", \\"enough\\", \\"enough\\", \\"enough\\"] >>> volunteer_status([8, 15, 20, 3, 10], [10, 15, 18, 4, 10]) [\\"deficient\\", \\"enough\\", \\"enough\\", \\"deficient\\", \\"enough\\"] >>> volunteer_status([1, 1, 1, 1, 1], [2, 2, 2, 2, 2]) [\\"deficient\\", \\"deficient\\", \\"deficient\\", \\"deficient\\", \\"deficient\\"] >>> volunteer_status([0, 0, 0, 0, 0], [0, 0, 0, 0, 0]) [\\"enough\\", \\"enough\\", \\"enough\\", \\"enough\\", \\"enough\\"] >>> volunteer_status([10, 20, 30, 40, 50], [10, 19, 30, 41, 49]) [\\"enough\\", \\"enough\\", \\"enough\\", \\"deficient\\", \\"enough\\"]","solution":"def volunteer_status(signed_up, target): Returns a list of status for each task, indicating whether the number of signed-up volunteers meets or exceeds the target. :param signed_up: A list of integers representing the number of signed-up volunteers for each task. :param target: A list of integers representing the target number of volunteers for each task. :return: A list of strings, either \\"enough\\" or \\"deficient\\" for each task. return [\\"enough\\" if s >= t else \\"deficient\\" for s, t in zip(signed_up, target)]"},{"question":"def can_find_zero_power_subarray(n: int, power_levels: List[int]) -> str: Determines if there is a contiguous subarray whose total power level is zero. >>> can_find_zero_power_subarray(5, [3, -1, -2, 4, -3]) == \\"YES\\" >>> can_find_zero_power_subarray(4, [1, 2, 3, 4]) == \\"NO\\" >>> can_find_zero_power_subarray(3, [0, 0, 0]) == \\"YES\\" >>> can_find_zero_power_subarray(1, [0]) == \\"YES\\" >>> can_find_zero_power_subarray(6, [1, 2, -3, 4, -4, 5]) == \\"YES\\" >>> can_find_zero_power_subarray(5, [1000, -1000, 500, -500, 0]) == \\"YES\\" >>> can_find_zero_power_subarray(1, [100]) == \\"NO\\" >>> can_find_zero_power_subarray(5, [10, 20, 30, -30, -20]) == \\"YES\\"","solution":"def can_find_zero_power_subarray(n, power_levels): Determines if there is a contiguous subarray whose total power level is zero. # Maintain a set to store the prefix sums prefix_sums = set() current_sum = 0 for power in power_levels: current_sum += power if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"import re from typing import List def validate_emails(email_list: List[str]) -> List[str]: Takes list of email addresses and returns their validation status based on the given criteria. >>> validate_emails([\\"john.doe@example.com\\", \\"jane_doe123@company.co.uk\\", \\"invalid-email@address..com\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> validate_emails([\\"valid.email@example.com\\", \\"invalid.email..example@example.com\\", \\"another.valid@test.com\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"import re def validate_email(email): Validates the email address based on the given criteria. if email.count('@') != 1: return \\"NO\\" local_part, domain_part = email.split('@') # Check if domain part contains at least one dot if '.' not in domain_part: return \\"NO\\" # Regex to check valid local part local_part_pattern = re.compile(r\\"^[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)*\\") if not local_part_pattern.match(local_part): return \\"NO\\" # Check local part doesn't start or end with a dot if local_part.startswith('.') or local_part.endswith('.'): return \\"NO\\" # Check domain part doesn't contain consecutive dots if '..' in domain_part: return \\"NO\\" return \\"YES\\" def validate_emails(email_list): Takes list of email addresses and returns their validation status. return [validate_email(email) for email in email_list]"},{"question":"from typing import List def max_efficiency(n: int, w: int, weights: List[int], priorities: List[int]) -> int: Calculate the maximum total weight of high priority packages that can be included in the container without exceeding its capacity. Parameters: n (int): Number of packages. w (int): Capacity of the container. weights (List[int]): List of weights of the packages. priorities (List[int]): List of priority levels of the packages where 1 represents high priority and 0 represents low priority. Returns: int: The maximum total weight of high priority packages that can be included in the container without exceeding its capacity. Examples: >>> max_efficiency(5, 10, [2, 3, 5, 1, 4], [1, 1, 0, 1, 0]) 6 >>> max_efficiency(3, 7, [3, 5, 2], [1, 1, 1]) 7 pass def test_example_1(): assert max_efficiency(5, 10, [2, 3, 5, 1, 4], [1, 1, 0, 1, 0]) == 6 def test_example_2(): assert max_efficiency(3, 7, [3, 5, 2], [1, 1, 1]) == 7 def test_no_high_priority(): assert max_efficiency(3, 7, [3, 5, 2], [0, 0, 0]) == 0 def test_all_high_priority_with_less_capacity(): assert max_efficiency(4, 5, [2, 2, 2, 2], [1, 1, 1, 1]) == 4 def test_single_high_priority(): assert max_efficiency(4, 5, [2, 1, 2, 2], [0, 1, 0, 0]) == 1 def test_large_weights(): assert max_efficiency(5, 10, [9, 9, 9, 9, 9], [1, 1, 1, 1, 1]) == 9","solution":"def max_efficiency(n, w, weights, priorities): # Create a list of high priority packages high_priority_packages = [weights[i] for i in range(n) if priorities[i] == 1] # Initialize the DP array dp = [0] * (w + 1) # Fill the DP array using the weights of high priority packages for weight in high_priority_packages: for j in range(w, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) # Maximum efficiency is the maximum weight we can get from high priority packages return dp[w]"},{"question":"def longest_necklace(beads: str) -> int: Given a string of beads where each character represents a bead of a certain color, determine the maximum length of the necklace that can be formed where no two adjacent beads are of the same color. >>> longest_necklace(\\"abcabcabcd\\") == 10 >>> longest_necklace(\\"aaaa\\") == 1 >>> longest_necklace(\\"abcabc\\") == 6 def process_test_cases(test_cases: List[str]) -> List[int]: Given a list of test cases, process and return the maximum length of the necklace that can be formed for each test case. >>> process_test_cases([\\"abcabcabcd\\", \\"aaaa\\", \\"abcabc\\", \\"\\", \\"abababababababab\\", \\"aaabbbccc\\", \\"a\\"]) == [10, 1, 6, 0, 16, 2, 1]","solution":"def longest_necklace(beads): Given a string of beads where each character represents a bead of a certain color, determine the maximum length of the necklace that can be formed where no two adjacent beads are of the same color. n = len(beads) if not beads or n == 1: return n # Initialize the length of the necklace max_len = 1 current_len = 1 # Iterate through the string. If the current and previous beads are different, increment the current length. for i in range(1, n): if beads[i] != beads[i - 1]: current_len += 1 else: # Reset the current length when two adjacent beads are the same current_len = 1 max_len = max(max_len, current_len) return max_len def process_test_cases(test_cases): Given a list of test cases, process and return the maximum length of the necklace that can be formed for each test case. results = [longest_necklace(beads) for beads in test_cases] return results"},{"question":"def find_common_elements(arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]: Finds all common elements in three sorted arrays and returns them in sorted order. Arguments: arr1 -- the first array of integers arr2 -- the second array of integers arr3 -- the third array of integers Returns: A sorted list of integers that are common in all three arrays. Example: >>> find_common_elements([1, 5, 10, 20, 40, 80], [6, 7, 20, 80, 100], [3, 4, 15, 20, 30, 70, 80]) [20, 80] >>> find_common_elements([1, 2, 3], [4, 5, 6], [7, 8, 9]) [] from solution import find_common_elements def test_common_elements_basic(): arr1 = [1, 5, 10, 20, 40, 80] arr2 = [6, 7, 20, 80, 100] arr3 = [3, 4, 15, 20, 30, 70, 80] assert find_common_elements(arr1, arr2, arr3) == [20, 80] def test_no_common_elements(): arr1 = [1, 2, 3] arr2 = [4, 5, 6] arr3 = [7, 8, 9] assert find_common_elements(arr1, arr2, arr3) == [] def test_all_elements_common(): arr1 = [2, 3, 4] arr2 = [2, 3, 4] arr3 = [2, 3, 4] assert find_common_elements(arr1, arr2, arr3) == [2, 3, 4] def test_one_element_common(): arr1 = [1, 3, 4, 6] arr2 = [2, 4, 5, 6] arr3 = [3, 4, 7, 9] assert find_common_elements(arr1, arr2, arr3) == [4] def test_large_input_all_same(): arr1 = [1] * 100000 arr2 = [1] * 100000 arr3 = [1] * 100000 assert find_common_elements(arr1, arr2, arr3) == [1]","solution":"def find_common_elements(arr1, arr2, arr3): Finds all common elements in three sorted arrays and returns them in sorted order. # Using set operations to find common elements common_elements = set(arr1) & set(arr2) & set(arr3) # Converting the set to a sorted list result = sorted(list(common_elements)) return result"},{"question":"def simulate_traffic_lights(n: int, t: int) -> List[str]: Simulate the traffic lights in a grid of size n x n after t seconds. Parameters: n (int): Size of the grid t (int): Number of seconds to simulate traffic lights Returns: List[str]: A list of strings representing the traffic light states at each intersection >>> simulate_traffic_lights(3, 0) ['GGG', 'GGG', 'GGG'] >>> simulate_traffic_lights(2, 1) ['RR', 'RR'] >>> simulate_traffic_lights(3, 2) ['GGG', 'GGG', 'GGG']","solution":"def simulate_traffic_lights(n, t): Simulates the traffic lights in a grid of size n x n after t seconds. Parameters: n (int): Size of the grid t (int): Number of seconds to simulate traffic lights Returns: List[str]: A list of strings representing the traffic light states at each intersection # Determine the state based on t % 2 state = 'G' if t % 2 == 0 else 'R' # Create the grid with the same state for all intersections grid = [state * n for _ in range(n)] return grid"},{"question":"class Inventory: def __init__(self): self.products = {} def add(self, product_name: str, quantity: int): Add a quantity to an existing product. If the product does not exist, create the product with the initial quantity. Args: product_name (str): The name of the product. quantity (int): The quantity to add. pass def subtract(self, product_name: str, quantity: int): Subtract a quantity from an existing product. If the quantity to subtract is greater than the available quantity, set the quantity to zero. Args: product_name (str): The name of the product. quantity (int): The quantity to subtract. pass def check(self, product_name: str) -> int: Check the quantity of a product. Args: product_name (str): The name of the product. Returns: int: The quantity of the product. pass def total(self) -> int: Display the total quantity of all products. Returns: int: The total quantity of all products. pass # Unit tests def test_add_and_check(): inv = Inventory() inv.add(\\"apple\\", 50) assert inv.check(\\"apple\\") == 50 inv.add(\\"apple\\", 20) assert inv.check(\\"apple\\") == 70 def test_subtract_and_check(): inv = Inventory() inv.add(\\"apple\\", 50) inv.subtract(\\"apple\\", 10) assert inv.check(\\"apple\\") == 40 inv.subtract(\\"apple\\", 50) assert inv.check(\\"apple\\") == 0 def test_subtract_non_existing_product(): inv = Inventory() inv.subtract(\\"banana\\", 30) assert inv.check(\\"banana\\") == 0 def test_total_quantity(): inv = Inventory() inv.add(\\"apple\\", 50) inv.add(\\"banana\\", 30) assert inv.total() == 80 inv.subtract(\\"banana\\", 10) assert inv.total() == 70 def test_complex_operations(): inv = Inventory() inv.add(\\"apple\\", 50) inv.add(\\"banana\\", 30) assert inv.check(\\"apple\\") == 50 inv.subtract(\\"apple\\", 10) assert inv.check(\\"apple\\") == 40 inv.subtract(\\"banana\\", 40) assert inv.check(\\"banana\\") == 0 assert inv.total() == 40 inv.add(\\"orange\\", 20) assert inv.total() == 60","solution":"class Inventory: def __init__(self): self.products = {} def add(self, product_name, quantity): if product_name in self.products: self.products[product_name] += quantity else: self.products[product_name] = quantity def subtract(self, product_name, quantity): if product_name in self.products: self.products[product_name] = max(0, self.products[product_name] - quantity) else: self.products[product_name] = 0 def check(self, product_name): return self.products.get(product_name, 0) def total(self): return sum(self.products.values())"},{"question":"def two_sum_exists(nums: List[int], target: int) -> str: Determines if there are two distinct indices within the array such that the sum of the elements at those indices is equal to the target integer. >>> two_sum_exists([1, 2, 3, 4, 5], 9) \\"YES\\" >>> two_sum_exists([-1, -2, -3], -6) \\"NO\\" >>> two_sum_exists([1, -1, 2, -2], 0) \\"YES\\"","solution":"def two_sum_exists(nums, target): Determines if there are two distinct indices within the array such that the sum of the elements at those indices is equal to the target integer. :param nums: List[int] - List of integers. :param target: int - The target sum. :return: str - \\"YES\\" if such indices exist, otherwise \\"NO\\". seen = set() for num in nums: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def count_strictly_greater_cells(grid: List[List[int]]) -> int: Returns the number of cells that are strictly greater than all of their neighboring cells. >>> count_strictly_greater_cells([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 1 >>> count_strictly_greater_cells([ ... [10, 20, 30, 40], ... [50, 60, 70, 80], ... [90, 100, 110, 120], ... [130, 140, 150, 160] ... ]) 1 >>> count_strictly_greater_cells([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) 1 def test_count_strictly_greater_cells(): grid1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert count_strictly_greater_cells(grid1) == 1 grid2 = [ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160] ] assert count_strictly_greater_cells(grid2) == 1 grid3 = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] assert count_strictly_greater_cells(grid3) == 1 grid4 = [ [1, 2], [3, 4] ] assert count_strictly_greater_cells(grid4) == 1 grid5 = [ [1] ] assert count_strictly_greater_cells(grid5) == 1 grid6 = [ [5, 5, 5], [5, 9, 5], [5, 5, 5] ] assert count_strictly_greater_cells(grid6) == 1","solution":"def count_strictly_greater_cells(grid): Returns the count of cells that are strictly greater than all of their neighboring cells. def is_greater(row, col): value = grid[row][col] for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = row + dr, col + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]): if value <= grid[nr][nc]: return False return True count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if is_greater(r, c): count += 1 return count def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [] index = 2 for i in range(N): row = list(map(int, data[index:index + M])) grid.append(row) index += M print(count_strictly_greater_cells(grid)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def is_increasing_subsequence(arr: List[int], start: int, end: int) -> bool: Determine whether the subarray arr[start:end+1] is an increasing subsequence. >>> is_increasing_subsequence([1, 3, 2, 5, 7], 0, 2) False >>> is_increasing_subsequence([1, 3, 2, 5, 7], 1, 3) False >>> is_increasing_subsequence([2, 3, 4, 5], 0, 1) True pass def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[str]: Process multiple queries to determine if the subarrays are increasing subsequences. >>> process_queries(5, 3, [1, 3, 2, 5, 7], [(1, 3), (2, 4), (1, 5)]) ['No', 'No', 'Yes'] >>> process_queries(4, 2, [2, 3, 4, 5], [(1, 2), (3, 4)]) ['Yes', 'Yes'] pass def test_is_increasing_subsequence(): assert is_increasing_subsequence([1, 3, 2, 5, 7], 0, 2) == False assert is_increasing_subsequence([1, 3, 2, 5, 7], 1, 3) == False assert is_increasing_subsequence([1, 3, 2, 5, 7], 0, 4) == True assert is_increasing_subsequence([2, 3, 4, 5], 0, 1) == True assert is_increasing_subsequence([2, 3, 4, 5], 2, 3) == True def test_process_queries(): array = [1, 3, 2, 5, 7] queries = [(1, 3), (2, 4), (1, 5)] assert process_queries(5, 3, array, queries) == [\\"No\\", \\"No\\", \\"Yes\\"] array = [2, 3, 4, 5] queries = [(1, 2), (3, 4)] assert process_queries(4, 2, array, queries) == [\\"Yes\\", \\"Yes\\"] array = [4, 3, 2, 1] queries = [(1, 4)] assert process_queries(4, 1, array, queries) == [\\"No\\"] array = [1, 2, 3, 4] queries = [(1, 4)] assert process_queries(4, 1, array, queries) == [\\"Yes\\"]","solution":"def is_increasing_subsequence(arr, start, end): Returns whether the subarray arr[start:end+1] is an increasing subsequence. for i in range(start, end): if arr[i] >= arr[i + 1]: return False return True def process_queries(n, q, array, queries): results = [] for query in queries: l, r = query if is_increasing_subsequence(array, l - 1, r - 1): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def is_robot_bounded(commands: str) -> str: Determines if the robot returns to the origin at the end of the command cycle. >>> is_robot_bounded(\\"GLGR\\") 'NO' >>> is_robot_bounded(\\"GLGLGLG\\") 'YES' >>> is_robot_bounded(\\"G\\") 'NO' >>> is_robot_bounded(\\"GGLLGG\\") 'YES' >>> is_robot_bounded(\\"GRGLGLGBG\\") 'YES' >>> is_robot_bounded(\\"GLGRB\\") 'NO' >>> is_robot_bounded(\\"RRRR\\") 'YES' >>> is_robot_bounded(\\"GGLGGRGLB\\") 'YES'","solution":"def is_robot_bounded(commands: str) -> str: Determines if the robot returns to the origin at the end of the command cycle. # Initial position and direction (Start at the origin, facing north) x = y = 0 direction = 0 # 0 = North, 1 = East, 2 = South, 3 = West # Map directions for ease of turning. North -> 0, East -> 1, South -> 2, West -> 3 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for command in commands: if command == 'G': x += directions[direction][0] y += directions[direction][1] elif command == 'L': direction = (direction - 1) % 4 elif command == 'R': direction = (direction + 1) % 4 elif command == 'B': x -= directions[direction][0] y -= directions[direction][1] # The robot will be bounded in a circle if after one cycle: # 1. It is back at the origin (0, 0) # 2. It is not facing north (direction != 0) if (x == 0 and y == 0) or direction != 0: return \\"YES\\" return \\"NO\\""},{"question":"def count_submission_results(N: int, results: list[str]) -> dict: Counts the number of submissions in each category. Parameters: N (int): Number of submissions results (list of str): List of results for each submission Returns: dict: Dictionary with counts of each category pass def format_output(counts: dict) -> str: Formats the output as required. Parameters: counts (dict): Dictionary with counts of each category Returns: str: Formatted output pass # Test cases def test_count_submission_results(): res = count_submission_results(5, [\\"A\\", \\"WA\\", \\"A\\", \\"RE\\", \\"CE\\"]) assert res == {\\"A\\": 2, \\"WA\\": 1, \\"RE\\": 1, \\"CE\\": 1} def test_all_accepted(): res = count_submission_results(4, [\\"A\\", \\"A\\", \\"A\\", \\"A\\"]) assert res == {\\"A\\": 4, \\"WA\\": 0, \\"RE\\": 0, \\"CE\\": 0} def test_all_wrong_answer(): res = count_submission_results(3, [\\"WA\\", \\"WA\\", \\"WA\\"]) assert res == {\\"A\\": 0, \\"WA\\": 3, \\"RE\\": 0, \\"CE\\": 0} def test_no_submissions(): res = count_submission_results(0, []) assert res == {\\"A\\": 0, \\"WA\\": 0, \\"RE\\": 0, \\"CE\\": 0} def test_format_output(): counts = {\\"A\\": 2, \\"WA\\": 1, \\"RE\\": 1, \\"CE\\": 1} output = format_output(counts) expected_output = \\"Accepted: 2nWrong Answer: 1nRuntime Error: 1nCompilation Error: 1\\" assert output == expected_output","solution":"def count_submission_results(N, results): Counts the number of submissions in each category. Parameters: N (int): Number of submissions results (list of str): List of results for each submission Returns: dict: Dictionary with counts of each category counts = {\\"A\\": 0, \\"WA\\": 0, \\"RE\\": 0, \\"CE\\": 0} for result in results: if result in counts: counts[result] += 1 return counts def format_output(counts): Formats the output as required. Parameters: counts (dict): Dictionary with counts of each category Returns: str: Formatted output output = ( f\\"Accepted: {counts['A']}n\\" f\\"Wrong Answer: {counts['WA']}n\\" f\\"Runtime Error: {counts['RE']}n\\" f\\"Compilation Error: {counts['CE']}\\" ) return output"},{"question":"def longest_subsequence_length(test_cases): Returns a list with the length of the longest subsequence for given test cases that can be formed by deleting exactly k characters. :param test_cases: List of (k, s) tuples, where k is the number of characters to delete and s is the string. :returns: List of integers representing the length of the longest subsequence for each test case.","solution":"def longest_subsequence_length(test_cases): Returns a list with the length of the longest subsequence for given test cases that can be formed by deleting exactly k characters. :param test_cases: List of (k, s) tuples, where k is the number of characters to delete and s is the string. :returns: List of integers representing the length of the longest subsequence for each test case. results = [] for k, s in test_cases: # If k is the number of characters to delete, the longest subsequence is simply the length of s minus k. longest_length = len(s) - k results.append(longest_length) return results"},{"question":"def find_paths_to_target(graph, start, target, steps, current_steps, visited): Function to determine if the target can be reached with exactly 'steps' steps. ... def can_reach_end(S, C, X, connections): Determine whether it is possible to visit the designated end site after conducting exactly X experiments without incurring fees. Returns \\"reachable\\" if possible, otherwise \\"unreachable\\". S: total number of sites. C: total number of corridors. X: number of experiments (steps). connections: list of tuples representing corridors between sites. Example: >>> can_reach_end(2, 1, 1, [(1, 2)]) \\"reachable\\" >>> can_reach_end(2, 1, 2, [(1, 2)]) \\"unreachable\\" ... def process_multiple_datasets(datasets): Process multiple datasets and determine the reachability for each. datasets: List of dictionaries containing data about sites, corridors, and steps. Example: >>> datasets = [{'SCX': (2, 1, 1), 'connections': [(1, 2)]}, {'SCX': (2, 1, 2), 'connections': [(1, 2)]}] >>> process_multiple_datasets(datasets) [\\"reachable\\", \\"unreachable\\"] ... def parse_input(input_string): Parse the input string into a list of datasets. input_string: Multiline string with the details of each dataset. Example: >>> input_string = \\"2 1 1n1 2n2 1 2n1 2n0 0 0\\" >>> parse_input(input_string) [{'SCX': (2, 1, 1), 'connections': [(1, 2)]}, {'SCX': (2, 1, 2), 'connections': [(1, 2)]}] ... # Usage example input_string = 2 1 1 1 2 2 1 2 1 2 3 2 2 1 2 2 3 4 4 3 1 2 2 3 3 4 4 1 0 0 0 datasets = parse_input(input_string) output = process_multiple_datasets(datasets) for line in output: print(line)","solution":"def find_paths_to_target(graph, start, target, steps, current_steps, visited): if current_steps > steps: return False if current_steps == steps and start == target: return True for neighbor in graph[start]: if current_steps == 0 or visited[current_steps-1] != neighbor: visited[current_steps] = neighbor if find_paths_to_target(graph, neighbor, target, steps, current_steps + 1, visited): return True visited[current_steps] = None return False def can_reach_end(S, C, X, connections): graph = {i: [] for i in range(1, S+1)} for v, w in connections: graph[v].append(w) graph[w].append(v) start = 1 target = S visited = [None] * (X + 1) return \\"reachable\\" if find_paths_to_target(graph, start, target, X, 0, visited) else \\"unreachable\\" def process_multiple_datasets(datasets): result = [] for data in datasets: S, C, X = data['SCX'] connections = data['connections'] result.append(can_reach_end(S, C, X, connections)) return result def parse_input(input_string): lines = input_string.strip().split('n') datasets = [] i = 0 while i < len(lines): S, C, X = map(int, lines[i].split()) if S == 0 and C == 0 and X == 0: break connections = [] for j in range(1, C + 1): v, w = map(int, lines[i + j].split()) connections.append((v, w)) datasets.append({'SCX': (S, C, X), 'connections': connections}) i += C + 1 return datasets input_string = 2 1 1 1 2 2 1 2 1 2 3 2 2 1 2 2 3 4 4 3 1 2 2 3 3 4 4 1 0 0 0 datasets = parse_input(input_string) output = process_multiple_datasets(datasets) for line in output: print(line)"},{"question":"def is_valid_sequence(n: int, k: int, s: int) -> str: Determines if it's possible to create a sequence of length n such that each element is between 1 and k, and the sum of the sequence is s. :param n: Length of the sequence :param k: Maximum value of an element :param s: Desired sum of the sequence :return: \\"YES\\" if possible to create such a sequence, otherwise \\"NO\\"","solution":"def is_valid_sequence(n, k, s): Determines if it's possible to create a sequence of length n such that each element is between 1 and k, and the sum of the sequence is s. :param n: Length of the sequence :param k: Maximum value of an element :param s: Desired sum of the sequence :return: \\"YES\\" if possible to create such a sequence, otherwise \\"NO\\" # Minimum sum possible is when all elements are 1 min_sum = n # Maximum sum possible is when all elements are k max_sum = n * k if min_sum <= s <= max_sum: return \\"YES\\" else: return \\"NO\\""},{"question":"def sum_of_max_in_rows(grid: List[List[int]]) -> int: Returns the sum of the maximum values in each row of the grid. :param grid: List of lists containing integers. :return: Integer sum of the maximum values in each row. >>> sum_of_max_in_rows([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 18 >>> sum_of_max_in_rows([[3, 1, 4, 1], [5, 9, 2, 6]]) == 15 >>> sum_of_max_in_rows([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == -12 >>> sum_of_max_in_rows([[1, -2, 3], [4, -5, 6], [-7, 8, 9]]) == 18 >>> sum_of_max_in_rows([[5]]) == 5","solution":"def sum_of_max_in_rows(grid): Returns the sum of the maximum values in each row of the grid. :param grid: List of lists containing integers. :return: Integer sum of the maximum values in each row. return sum(max(row) for row in grid) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() H = int(data[0]) W = int(data[1]) grid = [] index = 2 for _ in range(H): row = list(map(int, data[index:index + W])) grid.append(row) index += W result = sum_of_max_in_rows(grid) print(result)"},{"question":"from typing import List, Tuple def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make all elements of the sequence equal. >>> min_operations_to_equal_elements(3, [(4, [1, 2, 3, 4]), (3, [2, 2, 2]), (5, [3, 3, 4, 4, 4])]) [4, 0, 2] >>> min_operations_to_equal_elements(1, [(3, [100, 200, 300])]) [200] >>> min_operations_to_equal_elements(1, [(5, [1, 2, 3, 4, 5])]) [6]","solution":"def min_operations_to_equal_elements(t, test_cases): results = [] for case in test_cases: n, elements = case median = sorted(elements)[n // 2] operations = sum(abs(x - median) for x in elements) results.append(operations) return results"},{"question":"from typing import List from collections import deque def orangesRotting(grid: List[List[int]]) -> int: You are given a grid of dimensions \`m x n\`, where each cell in the grid can have one of three values: - \`0\` representing an empty cell, - \`1\` representing a fresh orange, - \`2\` representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return \`-1\`. >>> orangesRotting([ ... [2, 1, 1], ... [1, 1, 0], ... [0, 1, 1] ... ]) 4 >>> orangesRotting([ ... [2, 1, 1], ... [0, 1, 1], ... [1, 0, 1] ... ]) -1 >>> orangesRotting([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) 0","solution":"from collections import deque def orangesRotting(grid): This function determines the minimum number of minutes that must elapse until no cell has a fresh orange. If it is impossible, it returns -1. m, n = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 for r in range(m): for c in range(n): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 minutes_passed = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue and fresh_oranges > 0: minutes_passed += 1 for _ in range(len(queue)): x, y = queue.popleft() for dr, dc in directions: nx, ny = x + dr, y + dc if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 queue.append((nx, ny)) return minutes_passed if fresh_oranges == 0 else -1"},{"question":"def min_slots_required(s: int, c: int, campaigns: List[Tuple[int, int]]) -> int: Determines the minimum number of slots required to schedule all campaigns without overlap. Parameters: s (int): Number of slots c (int): Number of campaigns campaigns (list of tuple): A list of tuples with start and end times of campaigns Returns: int: Minimum number of slots required >>> min_slots_required(4, 6, [(1, 5), (2, 6), (4, 8), (5, 9), (8, 10), (9, 11)]) == 3 >>> min_slots_required(3, 4, [(1, 3), (2, 5), (4, 6), (5, 8)]) == 2 >>> min_slots_required(2, 2, [(1, 10), (2, 3)]) == 2 >>> min_slots_required(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 1 >>> min_slots_required(1, 1, [(0, 1)]) == 1 >>> min_slots_required(0, 0, []) == 0 >>> min_slots_required(4, 5, [(1, 4), (2, 5), (1, 3), (5, 7), (8, 10)]) == 3 >>> min_slots_required(4, 7, [(1, 4), (2, 5), (1, 3), (5, 7), (8, 10), (0, 6), (3, 9)]) == 4","solution":"import heapq def min_slots_required(s, c, campaigns): Determines the minimum number of slots required to schedule all campaigns without overlap. Parameters: s (int): Number of slots c (int): Number of campaigns campaigns (list of tuple): A list of tuples with start and end times of campaigns Returns: int: Minimum number of slots required if not campaigns: return 0 # Sort the campaigns by start time. campaigns.sort(key=lambda x: x[0]) # Create a min-heap to track the end times of campaigns using slots min_heap = [] for start, end in campaigns: # If there's a slot whose campaign ended before the current campaign starts, reuse it if min_heap and min_heap[0] <= start: heapq.heappop(min_heap) # Add the current campaign to a slot (new or reused) heapq.heappush(min_heap, end) # The size of the heap tells us the maximum number of overlapping campaigns at any point in time return len(min_heap)"},{"question":"def max_circular_subarray_start(n: int, k: int, arr: List[int]) -> int: You are given a sequence of integers arranged in a circular manner. A circular sequence means that the next element of the last element is the first element. You need to find the starting position of a subarray of length \`k\` with the maximum sum. If there are multiple such subarrays with the same sum, return the smallest starting index. Input: - n: length of the circular sequence - k: length of the subarray - arr: list of integers representing the elements of the sequence Output: - The starting position (0-based index) of the subarray of length \`k\` with the maximum sum. Examples: >>> max_circular_subarray_start(9, 3, [8, -1, 3, 4, 5, -6, 7, -2, 1]) 2 >>> max_circular_subarray_start(5, 2, [5, -3, 6, 3, -2]) 2","solution":"def max_circular_subarray_start(n, k, arr): if k == 1: return arr.index(max(arr)) max_sum = -float('inf') current_sum = sum(arr[:k]) max_start_index = 0 for i in range(n): if current_sum > max_sum: max_sum = current_sum max_start_index = i current_sum = current_sum - arr[i] + arr[(i + k) % n] return max_start_index"},{"question":"def minimal_delivery_time(n: int, m: int, robot_positions: List[int], delivery_points: List[int]) -> int: Determine the minimal time required for all packets to be delivered by robots. >>> minimal_delivery_time(3, 3, [1, 5, 3], [2, 6, 4]) 1 >>> minimal_delivery_time(2, 4, [2, 2], [3, 3, 3, 3]) 1 >>> minimal_delivery_time(1, 1, [10], [10]) 0 >>> minimal_delivery_time(2, 2, [0, 100], [50, 100]) 50 >>> minimal_delivery_time(3, 3, [1, 2, 3], [4, 5, 6]) 3 >>> minimal_delivery_time(4, 4, [1, 2, 3, 4], [4, 4, 4, 4]) 3","solution":"from itertools import permutations import sys def minimal_delivery_time(n, m, robot_positions, delivery_points): delivery_points.sort() min_time = sys.maxsize for perm in permutations(delivery_points): max_time = 0 for i in range(n): time = abs(robot_positions[i] - perm[i % m]) if time > max_time: max_time = time if max_time < min_time: min_time = max_time return min_time"},{"question":"def is_possible_to_partition_walls(n: int, m: int, grid: List[List[str]]) -> str: Determine if it is possible to partition all the walls into non-overlapping 2x2 contiguous blocks. >>> is_possible_to_partition_walls(6, 8, [ ['#', '#', '.', '.', '.', '.', '.', '.'], ['#', '#', '.', '.', '.', '.', '.', '.'], ['.', '.', '#', '#', '#', '#', '.', '.'], ['.', '.', '#', '#', '#', '#', '.', '.'], ['.', '.', '#', '#', '.', '.', '#', '#'], ['.', '.', '#', '#', '.', '.', '#', '#'] ]) \\"YES\\" >>> is_possible_to_partition_walls(4, 4, [ ['#', '#', '#', '#'], ['#', '#', '.', '#'], ['.', '.', '#', '#'], ['.', '.', '.', '#'] ]) \\"NO\\"","solution":"def is_possible_to_partition_walls(n, m, grid): def mark_block_as_visited(i, j): grid[i][j] = '.' grid[i+1][j] = '.' grid[i][j+1] = '.' grid[i+1][j+1] = '.' for i in range(n-1): for j in range(m-1): if grid[i][j] == '#' and grid[i+1][j] == '#' and grid[i][j+1] == '#' and grid[i+1][j+1] == '#': mark_block_as_visited(i, j) for i in range(n): for j in range(m): if grid[i][j] == '#': return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Finds the convex hull of a set of 2D points and returns the vertices of the hull in counterclockwise order starting from the vertex with the lowest x-coordinate. >>> convex_hull([(0, 0), (1, 1), (2, 2), (2, 0), (1, 2), (0, 2)]) [(0, 0), (2, 0), (2, 2), (0, 2)] >>> convex_hull([(1, 1), (2, 2), (0, 2), (2, 0), (0, 0)]) [(0, 0), (2, 0), (2, 2), (0, 2)] >>> convex_hull([(1, 1), (2, 2), (2, 2), (0, 2), (2, 0), (0, 0), (0, 0)]) [(0, 0), (2, 0), (2, 2), (0, 2)] >>> convex_hull([(0, 0), (1, 1), (2, 2)]) [(0, 0), (2, 2)] >>> convex_hull([(0, 0), (1, 1), (2, 2), (0, 1), (1, 0)]) [(0, 0), (1, 0), (2, 2), (0, 1)]","solution":"def convex_hull(points): Finds the convex hull of a set of 2D points and returns the vertices of the hull in counterclockwise order starting from the vertex with the lowest x-coordinate. # Sort the points lexicographically (tuples compare lexicographically). points = sorted(set(points)) # Boring case: no points or a single point, possibly repeated multiple times. if len(points) <= 1: return points # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product. # Returns a positive value, if OAB makes a counter-clockwise turn, # negative for clockwise turn, and zero if the points are collinear. def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) # Build lower hull lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) # Build upper hull upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) # Concatenate lower and upper hull to make the full hull. # The last point of each half is omitted because it's repeated at the beginning of the other half. return lower[:-1] + upper[:-1] def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) points = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(n)] hull = convex_hull(points) for point in hull: print(point[0], point[1]) if __name__ == \\"__main__\\": main()"},{"question":"def kth_prime(k: int) -> int: Returns the Kth prime number. >>> kth_prime(5) 11 >>> kth_prime(100) 541 from typing import List def test_first_prime(): assert kth_prime(1) == 2 def test_fifth_prime(): assert kth_prime(5) == 11 def test_tenth_prime(): assert kth_prime(10) == 29 def test_one_hundredth_prime(): assert kth_prime(100) == 541 def test_large_k_value(): # Example with reasonably large value of K assert kth_prime(1000) == 7919","solution":"def kth_prime(k): Returns the Kth prime number. if k == 1: return 2 primes = [2] num = 3 while len(primes) < k: is_prime = True for prime in primes: if num % prime == 0: is_prime = False break if prime * prime > num: break if is_prime: primes.append(num) num += 2 return primes[k-1]"},{"question":"def can_form_palindrome(s: str) -> str: Determine if it is possible to rearrange the characters of \`s\` to form a palindrome. Returns \\"YES\\" if it is possible to rearrange the characters of \`s\` to form a palindrome, otherwise returns \\"NO\\". Args: s (str): A string containing only lowercase English letters. Returns: str: \\"YES\\" if a palindrome can be formed, otherwise \\"NO\\". Examples: >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s): Returns \\"YES\\" if it is possible to rearrange the characters of \`s\` to form a palindrome, otherwise returns \\"NO\\". count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def shift_string(s: str) -> str: Returns a new string where each character in the input string s is replaced by the character that appears exactly one place after it in the English alphabet. The character 'z' wraps around to 'a'. :param s: Input string containing only lowercase alphabets :return: Modified string >>> shift_string('xyz') 'yza' >>> shift_string('a') 'b' >>> shift_string('z') 'a' >>> shift_string('abcdefghijklmnopqrstuvwxyz') 'bcdefghijklmnopqrstuvwxyza' >>> shift_string('aaaaa') 'bbbbb' >>> shift_string('zzzzz') 'aaaaa' >>> shift_string('abcz') 'bcda' >>> shift_string('x' * 100) 'y' * 100","solution":"def shift_string(s): Returns a new string where each character in the input string s is replaced by the character that appears exactly one place after it in the English alphabet. The character 'z' wraps around to 'a'. :param s: Input string containing only lowercase alphabets :return: Modified string return ''.join(chr((ord(char) - ord('a') + 1) % 26 + ord('a')) for char in s)"},{"question":"def can_distribute_water(N: int, groups: List[Tuple[int, int]], W: int) -> str: Determine if Alex can distribute the bottles of water such that every participant in all the groups receives the required amount of hydration. Args: N (int): number of groups groups (List[Tuple[int, int]]): list of tuples where each tuple contains the number of participants and the hydration needs in bottles for each participant W (int): total bottles of water available Returns: str: \\"Yes\\" if distribution is possible, otherwise \\"No\\" Examples: >>> can_distribute_water(3, [(10, 2), (20, 3), (5, 1)], 100) 'Yes' >>> can_distribute_water(2, [(8, 5), (12, 4)], 70) 'No' pass","solution":"def can_distribute_water(N, groups, W): total_required_bottles = 0 for participants, bottles_per_participant in groups: total_required_bottles += participants * bottles_per_participant if total_required_bottles <= W: return \\"Yes\\" else: return \\"No\\""},{"question":"def rearrange_string(s: str) -> str: Rearrange the string such that all digits appear before any letters while maintaining the order of digits and letters. >>> rearrange_string(\\"a3c8r2b\\") \\"382acrb\\" >>> rearrange_string(\\"h6f5i1\\") \\"651hfi\\" >>> rearrange_string(\\"xyz\\") \\"xyz\\" >>> rearrange_string(\\"123\\") \\"123\\" pass","solution":"def rearrange_string(s: str) -> str: digits = [] letters = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(digits) + ''.join(letters)"},{"question":"def find_minimum_wait_time(n, bus_times, arrival_time): Returns the minimum wait time for a commuter arriving at the bus stop at arrival_time. Parameters: n (int): Number of buses in the schedule. bus_times (list): Sorted list of bus arrival times in minutes past midnight. arrival_time (int): Commuter's arrival time at the bus stop in minutes past midnight. Returns: int: Minimum wait time in minutes. import pytest def test_example_1(): n = 5 bus_times = [15, 45, 90, 120, 360] arrival_time = 100 assert find_minimum_wait_time(n, bus_times, arrival_time) == 20 def test_example_2(): n = 4 bus_times = [0, 180, 360, 540] arrival_time = 200 assert find_minimum_wait_time(n, bus_times, arrival_time) == 160 def test_example_3(): n = 3 bus_times = [720, 1080, 1300] arrival_time = 1300 assert find_minimum_wait_time(n, bus_times, arrival_time) == 0 def test_arrival_before_first_bus(): n = 3 bus_times = [300, 720, 1080] arrival_time = 100 assert find_minimum_wait_time(n, bus_times, arrival_time) == 200 def test_arrival_after_last_bus(): n = 3 bus_times = [300, 720, 1080] arrival_time = 1200 assert find_minimum_wait_time(n, bus_times, arrival_time) == 540 def test_exact_bus_times(): n = 4 bus_times = [200, 400, 600, 800] arrival_time = 600 assert find_minimum_wait_time(n, bus_times, arrival_time) == 0","solution":"def find_minimum_wait_time(n, bus_times, arrival_time): Returns the minimum wait time for a commuter arriving at the bus stop at arrival_time. Parameters: n (int): Number of buses in the schedule. bus_times (list): Sorted list of bus arrival times in minutes past midnight. arrival_time (int): Commuter's arrival time at the bus stop in minutes past midnight. Returns: int: Minimum wait time in minutes. # If the commuter arrives exactly at a bus time if arrival_time in bus_times: return 0 # Find the next bus after the arrival time for bus_time in bus_times: if bus_time >= arrival_time: return bus_time - arrival_time # If there is no bus after the arrival_time, the commuter has to wait for the first bus the next day return (1440 - arrival_time) + bus_times[0]"},{"question":"def lexicographically_smallest_transform(s: str, k: int) -> str: Transforms the string \`s\` to be exactly of length \`k\` either by removing some characters or appending lowercase English letters, producing the lexicographically smallest string possible. Parameters: s (str): Input string consisting of lowercase English letters. k (int): Desired length of the resulting string. Returns: str: Lexicographically smallest transformed string of length \`k\`. Examples: >>> lexicographically_smallest_transform('abc', 5) 'abcaa' >>> lexicographically_smallest_transform('coding', 4) 'codi' >>> lexicographically_smallest_transform('apple', 10) 'appleaaaaa' >>> lexicographically_smallest_transform('xyz', 2) 'xy'","solution":"def lexicographically_smallest_transform(s, k): Transforms the string \`s\` to be exactly of length \`k\` either by removing some characters or appending lowercase English letters, producing the lexicographically smallest string possible. Parameters: s (str): Input string consisting of lowercase English letters. k (int): Desired length of the resulting string. Returns: str: Lexicographically smallest transformed string of length \`k\`. n = len(s) if n == k: return s elif n > k: return s[:k] else: return s + 'a' * (k - n)"},{"question":"def diagnose_car(N, M, thresholds, reports): Determines the number of sensors that are reporting values outside their normal range for each diagnostic report. Args: N (int): Number of diagnostic reports. M (int): Number of sensors. thresholds (list): A list of tuples, each containing the min and max threshold for a sensor. reports (list): A list of list, where each sublist contains the sensor values for a diagnostic report. Returns: list: A list of integers, each representing the number of sensors outside their normal range for each diagnostic report. pass def parse_input(input_data): Parses the input data and extracts the number of reports, number of sensors, thresholds, and reports. Args: input_data (str): Input data containing the number of diagnostic reports, number of sensors, thresholds, and reports. Returns: tuple: A tuple containing: - N (int): Number of diagnostic reports. - M (int): Number of sensors. - thresholds (list): A list of tuples, each containing the min and max threshold for a sensor. - reports (list): A list of lists, where each sublist contains the sensor values for a diagnostic report. pass from solution import diagnose_car, parse_input def test_diagnose_car(): N = 2 M = 3 thresholds = [(0, 100), (50, 150), (100, 200)] reports = [[110, 60, 180], [90, 130, 220]] assert diagnose_car(N, M, thresholds, reports) == [1, 1] def test_parse_input(): input_data = \\"2 3n0 100 50 150 100 200n110 60 180n90 130 220\\" expected_N = 2 expected_M = 3 expected_thresholds = [(0, 100), (50, 150), (100, 200)] expected_reports = [[110, 60, 180], [90, 130, 220]] assert parse_input(input_data) == (expected_N, expected_M, expected_thresholds, expected_reports) def test_diagnose_car_all_normal(): N = 1 M = 3 thresholds = [(0, 100), (50, 150), (100, 200)] reports = [[50, 100, 150]] assert diagnose_car(N, M, thresholds, reports) == [0] def test_diagnose_car_all_outside(): N = 1 M = 3 thresholds = [(0, 100), (50, 150), (100, 200)] reports = [[101, 49, 201]] assert diagnose_car(N, M, thresholds, reports) == [3] def test_diagnose_car_mixed(): N = 3 M = 3 thresholds = [(0, 100), (50, 150), (100, 200)] reports = [ [0, 50, 100], # All normal [101, 150, 100], # One outside (sensor 1) [0, 200, 300] # Two outside (sensor 2 and sensor 3) ] assert diagnose_car(N, M, thresholds, reports) == [0, 1, 2]","solution":"def diagnose_car(N, M, thresholds, reports): Determines the number of sensors that are reporting values outside their normal range for each diagnostic report. Args: N (int): Number of diagnostic reports. M (int): Number of sensors. thresholds (list): A list of tuples, each containing the min and max threshold for a sensor. reports (list): A list of list, where each sublist contains the sensor values for a diagnostic report. Returns: list: A list of integers, each representing the number of sensors outside their normal range for each diagnostic report. results = [] for report in reports: count = 0 for i in range(M): sensor_value = report[i] sensor_min, sensor_max = thresholds[i] if sensor_value < sensor_min or sensor_value > sensor_max: count += 1 results.append(count) return results def parse_input(input_data): lines = input_data.split(\\"n\\") N, M = map(int, lines[0].split()) thresholds = [] threshold_values = lines[1].split() for i in range(M): sensor_min = int(threshold_values[i*2]) sensor_max = int(threshold_values[i*2+1]) thresholds.append((sensor_min, sensor_max)) reports = [] for i in range(2, 2 + N): report_values = list(map(int, lines[i].split())) reports.append(report_values) return N, M, thresholds, reports"},{"question":"def birthday_distribution(test_cases): Calculates the distribution of birthdays over the months for given test cases. Args: test_cases (list): A list of dictionaries where each dictionary represents a test case. Each test case dictionary contains: - N (int): Number of friends. - birthdays (list of str): List of birthdays in the format \\"mm-dd\\". Returns: list: A list of lists where each inner list contains 12 integers representing the number of friends having their birthdays in each month from January to December. def parse_input(input_str): Parses the input string into test cases. Args: input_str (str): A string representation of all input values. Returns: list: A list of dictionaries where each dictionary represents a test case. def format_output(results): Formats the output from the result list of lists. Args: results (list): A list of lists where each inner list contains the number of birthdays in each month. Returns: str: A formatted string of results. from solution import birthday_distribution, parse_input, format_output def test_birthday_distribution(): input_str = 2 3 1 05-15 2 07-20 3 12-31 4 1 01-01 2 01-15 3 05-05 4 12-25 test_cases = parse_input(input_str) results = birthday_distribution(test_cases) output_str = format_output(results) expected_output_str = 0 0 0 0 1 0 1 0 0 0 0 1 2 0 0 0 1 0 0 0 0 0 0 1 assert output_str == expected_output_str def test_empty_birthday_list(): input_str = 1 0 test_cases = parse_input(input_str) results = birthday_distribution(test_cases) output_str = format_output(results) expected_output_str = 0 0 0 0 0 0 0 0 0 0 0 0 assert output_str == expected_output_str def test_same_month_birthdays(): input_str = 1 3 1 06-01 2 06-15 3 06-30 test_cases = parse_input(input_str) results = birthday_distribution(test_cases) output_str = format_output(results) expected_output_str = 0 0 0 0 0 3 0 0 0 0 0 0 assert output_str == expected_output_str def test_multiple_test_cases(): input_str = 2 2 1 02-14 2 02-28 3 1 03-01 2 03-15 3 03-30 test_cases = parse_input(input_str) results = birthday_distribution(test_cases) output_str = format_output(results) expected_output_str = 0 2 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 assert output_str == expected_output_str","solution":"def birthday_distribution(test_cases): results = [] for case in test_cases: N = case['N'] birthdays = case['birthdays'] monthly_counts = [0] * 12 for birthday in birthdays: month = int(birthday.split('-')[0]) monthly_counts[month - 1] += 1 results.append(monthly_counts) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 birthdays = [] for _ in range(N): _, birthday = lines[index].split() birthdays.append(birthday) index += 1 test_cases.append({'N': N, 'birthdays': birthdays}) return test_cases def format_output(results): return 'n'.join(' '.join(map(str, result)) for result in results) # Example usage input_str = 2 3 1 05-15 2 07-20 3 12-31 4 1 01-01 2 01-15 3 05-05 4 12-25 test_cases = parse_input(input_str) results = birthday_distribution(test_cases) output_str = format_output(results) print(output_str)"},{"question":"def sum_of_even_integers(N: int) -> int: Returns the sum of all even integers from 1 to N, inclusive. >>> sum_of_even_integers(6) 12 >>> sum_of_even_integers(1) 0 >>> sum_of_even_integers(10) 30 >>> sum_of_even_integers(2) 2 >>> sum_of_even_integers(100) 2550","solution":"def sum_of_even_integers(N): Returns the sum of all even integers from 1 to N, inclusive. return sum(i for i in range(2, N+1, 2))"},{"question":"def decrypt_message(encrypted_message: str, shift: int) -> str: Decrypts an encrypted message by shifting each letter back by the known shift value. :param encrypted_message: Encrypted message as a string of lowercase alphabetic characters. :param shift: Integer representing the number of positions each character in the encrypted message was shifted. :return: Decrypted message as a string. >>> decrypt_message(\\"wklv\\", 3) == \\"this\\" >>> decrypt_message(\\"zruog\\", 3) == \\"world\\" >>> decrypt_message(\\"abc\\", 1) == \\"zab\\" >>> decrypt_message(\\"hello\\", 0) == \\"hello\\" >>> decrypt_message(\\"hello\\", 26) == \\"hello\\" >>> decrypt_message(\\"ifmmp\\" * 200000, 1) == \\"hello\\" * 200000 >>> decrypt_message(\\"b\\", 1) == \\"a\\"","solution":"def decrypt_message(encrypted_message: str, shift: int) -> str: Decrypts an encrypted message by shifting each letter back by the known shift value. :param encrypted_message: Encrypted message as a string of lowercase alphabetic characters. :param shift: Integer representing the number of positions each character in the encrypted message was shifted. :return: Decrypted message as a string. decrypted_message = [] for char in encrypted_message: # Compute the original character's position original_position = (ord(char) - ord('a') - shift) % 26 # Convert the original position back to a character and append to the result decrypted_message.append(chr(original_position + ord('a'))) return ''.join(decrypted_message)"},{"question":"def is_palindrome_prime(n: int) -> str: Checks if a given number is both a palindrome and a prime. Output \\"YES\\" if the number is both a palindrome and a prime. Otherwise, output \\"NO\\". >>> is_palindrome_prime(7) \\"YES\\" >>> is_palindrome_prime(121) \\"NO\\" >>> is_palindrome_prime(131) \\"YES\\" >>> is_palindrome_prime(10) \\"NO\\"","solution":"def is_palindrome_prime(n): Checks if a given number is both a palindrome and a prime. def is_palindrome(n): s = str(n) return s == s[::-1] def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True if is_palindrome(n) and is_prime(n): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def library_system(n: int, m: int, usernames: List[str], book_titles: List[str], k: int, transactions: List[str]) -> List[str]: Simulate the library system for borrowing and returning books, ensuring that books can only be borrowed by one user at a time and users must wait for a cooldown period after borrowing. >>> library_system(3, 3, [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"The Great Gatsby\\", \\"Moby Dick\\", \\"To Kill a Mockingbird\\"], 7, [\\"BORROW Alice The Great Gatsby\\", \\"RETURN The Great Gatsby\\", \\"BORROW Bob To Kill a Mockingbird\\", \\"RETURN To Kill a Mockingbird\\", \\"BORROW Alice The Great Gatsby\\", \\"RETURN The Great Gatsby\\", \\"BORROW Alice To Kill a Mockingbird\\"]) [\\"Borrowed\\", \\"Returned\\", \\"Borrowed\\", \\"Returned\\", \\"Borrowed\\", \\"Returned\\", \\"Borrowed\\"] >>> library_system(2, 2, [\\"Tom\\", \\"Jerry\\"], [\\"1984\\", \\"Animal Farm\\"], 6, [\\"BORROW Tom 1984\\", \\"RETURN 1984\\", \\"BORROW Tom Animal Farm\\", \\"BORROW Jerry 1984\\", \\"RETURN 1984\\", \\"BORROW Jerry Animal Farm\\"]) [\\"Borrowed\\", \\"Returned\\", \\"Borrowed\\", \\"Borrowed\\", \\"Returned\\", \\"Borrowed\\"]","solution":"def library_system(n, m, usernames, book_titles, k, transactions): borrowed_books = {} cooldown_users = {} output = [] for transaction in transactions: parts = transaction.split() command = parts[0] if command == 'BORROW': username = parts[1] book_title = \\" \\".join(parts[2:]) if username in cooldown_users: output.append(\\"Cooldown\\") else: borrowed_books[book_title] = username cooldown_users[username] = True output.append(\\"Borrowed\\") elif command == 'RETURN': book_title = \\" \\".join(parts[1:]) username = borrowed_books.pop(book_title, None) if username: cooldown_users.pop(username, None) output.append(\\"Returned\\") return output"},{"question":"def max_trees(n: int, m: int) -> int: Returns the maximum number of trees that can be planted in an n by m grid while ensuring no two trees are in the same row or column, and no two trees are next to each other diagonally. >>> max_trees(3, 3) 3 >>> max_trees(4, 4) 4 >>> max_trees(3, 5) 3 >>> max_trees(6, 4) 4 pass","solution":"def max_trees(n, m): Returns the maximum number of trees that can be planted in an n by m grid while ensuring no two trees are in the same row or column, and no two trees are next to each other diagonally. # The solution is to plant trees on either all even or all odd indexes of the diagonal return min(n, m)"},{"question":"def min_cost_to_make_palindrome(n: int, s: str) -> int: Returns the minimum cost to convert the string s of length n into a palindrome. Parameters: n (int): length of the string s (str): input string consisting of lowercase Latin letters Returns: int: minimum cost to make the string a palindrome pass import pytest def test_min_cost_to_make_palindrome(): assert min_cost_to_make_palindrome(4, \\"abca\\") == 1 assert min_cost_to_make_palindrome(5, \\"abcde\\") == 2 assert min_cost_to_make_palindrome(3, \\"aaa\\") == 0 assert min_cost_to_make_palindrome(1, \\"a\\") == 0 assert min_cost_to_make_palindrome(2, \\"aa\\") == 0 assert min_cost_to_make_palindrome(2, \\"ab\\") == 1 assert min_cost_to_make_palindrome(5, \\"radar\\") == 0 assert min_cost_to_make_palindrome(6, \\"abcdef\\") == 3","solution":"def min_cost_to_make_palindrome(n, s): Returns the minimum cost to convert the string s of length n into a palindrome. Parameters: n (int): length of the string s (str): input string consisting of lowercase Latin letters Returns: int: minimum cost to make the string a palindrome cost = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: cost += 1 return cost"},{"question":"def min_operations_to_sort_plants(N: int, garden: List[int]) -> int: Function to find the minimum number of operations required to arrange plants in non-decreasing order. Args: N : int : Number of cells in the garden garden : list of ints : garden[i] represents the height of the plant in the i-th cell, or 0 if the cell is empty Returns: int : The minimum number of operations required Examples: >>> min_operations_to_sort_plants(5, [2, 0, 4, 0, 3]) 1 >>> min_operations_to_sort_plants(7, [0, 0, 4, 2, 0, 6, 3]) 2 >>> min_operations_to_sort_plants(4, [0, 0, 0, 0]) 0 from solution import min_operations_to_sort_plants def test_example_1(): assert min_operations_to_sort_plants(5, [2, 0, 4, 0, 3]) == 1 def test_example_2(): assert min_operations_to_sort_plants(7, [0, 0, 4, 2, 0, 6, 3]) == 2 def test_example_3(): assert min_operations_to_sort_plants(4, [0, 0, 0, 0]) == 0 def test_single_plant(): assert min_operations_to_sort_plants(1, [1]) == 0 def test_all_sorted(): assert min_operations_to_sort_plants(5, [1, 2, 3, 4, 5]) == 0 def test_all_reverse(): assert min_operations_to_sort_plants(5, [5, 4, 3, 2, 1]) == 4 def test_mixed(): assert min_operations_to_sort_plants(6, [1, 0, 3, 2, 0, 4]) == 1 def test_some_empty(): assert min_operations_to_sort_plants(6, [0, 0, 2, 3, 4, 0]) == 0","solution":"def min_operations_to_sort_plants(N, garden): Function to find the minimum number of operations required to arrange plants in non-decreasing order. Args: N : int : Number of cells in the garden garden : list of ints : garden[i] represents the height of the plant in the i-th cell, or 0 if the cell is empty. Returns: int : The minimum number of operations required # Filter out the empty cells and get a list of plant heights plants = [height for height in garden if height > 0] if not plants: return 0 # Find the length of the longest increasing subsequence from bisect import bisect_left lis = [] for plant in plants: pos = bisect_left(lis, plant) if pos == len(lis): lis.append(plant) else: lis[pos] = plant # The number of operations is the number of plants not in the LIS return len(plants) - len(lis)"},{"question":"def smallest_nonconstructible_value(N: int, nums: List[int]) -> int: Determine the smallest positive integer that cannot be represented as the sum of any subset of the given list of integers. >>> smallest_nonconstructible_value(5, [1, 2, 3, 8, 9]) == 7 >>> smallest_nonconstructible_value(0, []) == 1 >>> smallest_nonconstructible_value(1, [1]) == 2 >>> smallest_nonconstructible_value(1, [2]) == 1 >>> smallest_nonconstructible_value(4, [1, 2, 3, 4]) == 11 >>> smallest_nonconstructible_value(4, [1, 1, 1, 1]) == 5 >>> smallest_nonconstructible_value(3, [100, 200, 300]) == 1 >>> smallest_nonconstructible_value(5, [1, 100, 2, 200, 3]) == 7 >>> smallest_nonconstructible_value(1000, [i for i in range(1, 1001)]) == 500501 from typing import List","solution":"def smallest_nonconstructible_value(N, nums): Determine the smallest positive integer that cannot be represented as the sum of any subset of the given list of integers. Parameters: N (int): the number of elements in the list. nums (list of int): the list of integers. Returns: int: the smallest positive integer that cannot be represented as the sum of any subset of the list. nums.sort() smallest_value = 1 for num in nums: if num > smallest_value: break smallest_value += num return smallest_value"},{"question":"from typing import List, Tuple def are_anagrams(str1: str, str2: str) -> bool: Check if str1 and str2 are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pplea\\") True >>> are_anagrams(\\"hello\\", \\"bello\\") False def check_anagrams(test_cases: List[Tuple[str, str]]) -> List[str]: For each pair of strings in test_cases, check if they are anagrams and return corresponding results. >>> check_anagrams([(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"pplea\\"), (\\"hello\\", \\"bello\\")]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"] >>> check_anagrams([(\\"anagram\\", \\"nagaram\\"), (\\"rat\\", \\"car\\"), (\\"fluster\\", \\"restful\\"), (\\"example\\", \\"sample\\")]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"] >>> check_anagrams([(\\"\\", \\"\\"), (\\"a\\", \\"a\\"), (\\"\\", \\"a\\"), (\\"aaa\\", \\"aaa\\"), (\\"aab\\", \\"aba\\")]) [\\"Yes\\", \\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"]","solution":"def are_anagrams(str1, str2): Check if str1 and str2 are anagrams of each other. return sorted(str1) == sorted(str2) def check_anagrams(test_cases): For each pair of strings in test_cases, check if they are anagrams and return corresponding results. results = [] for str1, str2 in test_cases: if are_anagrams(str1, str2): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def minimum_breaks(n: int, task_durations: List[int]) -> int: Calculate the minimum number of breaks Mike needs to take to complete all tasks. Args: n : int : number of tasks task_durations : list of int : durations of each task in minutes Returns: int : minimum number of breaks required >>> minimum_breaks(5, [20, 30, 10, 40, 20]) 1 >>> minimum_breaks(3, [60, 60, 60]) 2 >>> minimum_breaks(4, [50, 50, 50, 50]) 3 >>> minimum_breaks(1, [60]) 0 >>> minimum_breaks(4, [10, 20, 30, 10]) 0 >>> minimum_breaks(2, [30, 31]) 1 >>> minimum_breaks(1, [1]) 0 >>> minimum_breaks(3, [20, 20, 20]) 0","solution":"def minimum_breaks(n, task_durations): Calculate the minimum number of breaks Mike needs to take to complete all tasks. Args: n : int : number of tasks task_durations : list of int : durations of each task in minutes Returns: int : minimum number of breaks required total_time = 0 break_count = 0 for duration in task_durations: total_time += duration if total_time >= 60: if total_time > 60: break_count += 1 total_time = duration return break_count"},{"question":"def max_knights(n: int, m: int) -> int: Determine the maximum number of knights that can be placed on the chessboard such that no knight can attack another knight. >>> max_knights(3, 3) 5 >>> max_knights(1, 4) 4 >>> max_knights(2, 2) 4","solution":"def max_knights(n, m): if n == 1 or m == 1: return n * m if n == 2 or m == 2: bigger = max(n, m) return (bigger // 4) * 4 + min(2, bigger % 4) * 2 return (n * m + 1) // 2"},{"question":"def count_palindromic_substrings(n: int, s: str) -> int: Returns the number of pairs (i, j) such that the substring s[i...j] is a palindrome. Args: n: An integer representing the length of the string s. s: A string consisting of lowercase English letters. Returns: An integer representing the number of palindromic substrings in the string s. Examples: >>> count_palindromic_substrings(5, \\"ababa\\") 9 >>> count_palindromic_substrings(4, \\"abcd\\") 4 >>> count_palindromic_substrings(1, \\"a\\") 1 >>> count_palindromic_substrings(2, \\"aa\\") 3 >>> count_palindromic_substrings(2, \\"ab\\") 2 >>> count_palindromic_substrings(7, \\"racecar\\") 10","solution":"def count_palindromic_substrings(n, s): Returns the number of pairs (i, j) such that the substring s[i...j] is a palindrome. count = 0 # A function to check if a given substring is a palindrome. def is_palindrome(sub): return sub == sub[::-1] # Iterate over all possible substrings and check if they are palindromes. for i in range(n): for j in range(i, n): if is_palindrome(s[i:j+1]): count += 1 return count"},{"question":"def distribute_coins(n: int, m: int) -> int: Determine the maximum value of the smallest number of coins in each treasure chest after distributing n coins into m treasure chests. :param n: int, the number of gold coins :param m: int, the number of treasure chests :return: int, the largest possible value of the smallest number of coins in any chest, or -1 if impossible >>> distribute_coins(10, 3) 3 >>> distribute_coins(8, 4) 2 >>> distribute_coins(5, 6) -1 from distribute_coins import distribute_coins def test_distribute_coins_basic_cases(): assert distribute_coins(10, 3) == 3 assert distribute_coins(8, 4) == 2 assert distribute_coins(5, 6) == -1 def test_distribute_coins_equal_n_m(): assert distribute_coins(7, 7) == 1 assert distribute_coins(1000, 1000) == 1 def test_distribute_coins_one_chest(): assert distribute_coins(15, 1) == 15 assert distribute_coins(100, 1) == 100 def test_distribute_coins_more_chests_than_coins(): assert distribute_coins(3, 5) == -1 assert distribute_coins(1, 2) == -1 def test_distribute_coins_large_numbers(): assert distribute_coins(2_000_000_000, 1_000_000_000) == 2 assert distribute_coins(2_000_000_000, 2_000_000_000) == 1","solution":"def distribute_coins(n, m): Determine the maximum value of the smallest number of coins in each treasure chest after distributing n coins into m treasure chests. :param n: int, the number of gold coins :param m: int, the number of treasure chests :return: int, the largest possible value of the smallest number of coins in any chest, or -1 if impossible if m > n: return -1 return n // m"},{"question":"def min_operations(A: str, B: str) -> int: Returns the minimum number of operations required to transform string A into string B. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"abc\\", \\"abcd\\") 1 >>> min_operations(\\"abcd\\", \\"abc\\") 1 >>> min_operations(\\"abc\\", \\"xyz\\") 3 >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"\\", \\"abcdef\\") 6 >>> min_operations(\\"abcdef\\", \\"\\") 6 >>> min_operations(\\"identical\\", \\"identical\\") 0","solution":"def min_operations(A, B): Returns the minimum number of operations required to transform string A into string B. m, n = len(A), len(B) # Create a DP table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Initialize DP table for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore last char and recur for remaining string elif A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last character is different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def max_pairs(t: int, cases: List[Tuple[int, int]]) -> List[int]: Returns the maximum number of pairs of Atrians and Belians that can be formed for each test case. >>> max_pairs(5, [(7, 3), (3, 7), (0, 100), (100, 0), (5, 5)]) [3, 3, 0, 0, 5] >>> max_pairs(1, [(10, 10)]) [10] >>> max_pairs(3, [(1, 1000000000000), (0, 0), (500, 700)]) [1, 0, 500] >>> max_pairs(2, [(1000000000000, 999999999999), (9, 9)]) [999999999999, 9]","solution":"def max_pairs(t, cases): Returns the maximum number of pairs of Atrians and Belians that can be formed for each test case. Parameters: t : int : number of test cases cases : list of tuple : list of (a, b) tuples where a is the number of Atrians and b is the number of Belians Returns: list of int : list of maximum number of pairs for each test case results = [] for a, b in cases: results.append(min(a, b)) return results"},{"question":"def spread_virus(N, M, channels, K, time_intervals, S, initial_infected): Simulates the spread of a virus in a network of servers and determines the number of newly infected servers at specific time intervals. Args: N (int): Number of servers. M (int): Number of communication channels. channels (List[Tuple[int, int]]): Each tuple represents a bidirectional channel between two servers. K (int): Number of time intervals. time_intervals (List[int]): The specific time intervals at which to report newly infected servers. S (int): Number of initially infected servers. initial_infected (List[int]): The labels of the initially infected servers. Returns: List[int]: Number of newly infected servers at each given time interval. Example: >>> spread_virus(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 3, [1, 2, 3], 1, [1]) [1, 1, 1]","solution":"def spread_virus(N, M, channels, K, time_intervals, S, initial_infected): from collections import deque, defaultdict graph = defaultdict(list) for a, b in channels: graph[a].append(b) graph[b].append(a) infected = set(initial_infected) newly_infected_at_time = [0] * (max(time_intervals) + 1) queue = deque([(c, 0) for c in initial_infected]) # (server, time) while queue: server, time = queue.popleft() for neighbor in graph[server]: if neighbor not in infected: infected.add(neighbor) queue.append((neighbor, time + 1)) if time + 1 <= max(time_intervals): newly_infected_at_time[time + 1] += 1 results = [] for t in time_intervals: results.append(newly_infected_at_time[t]) return results"},{"question":"def manage_schedules(operations): Manages the scheduling, rescheduling, and querying of truck deliveries. :param operations: List of operations in the form of tuples. :return: List of results for QUERY operations. # Unit tests def test_example_1(): operations = [ \\"SCHEDULE 1 2 3\\", \\"SCHEDULE 2 3 4\\", \\"QUERY 1 2\\", \\"SCHEDULE 2 1 6\\", \\"QUERY 2 3\\", \\"RESCHEDULE 1 2 5\\", \\"QUERY 1 2\\" ] expected = [\\"3\\", \\"4\\", \\"5\\"] assert manage_schedules(operations) == expected def test_example_2(): operations = [ \\"SCHEDULE 1 2 2\\", \\"QUERY 1 2\\", \\"RESCHEDULE 1 2 3\\", \\"QUERY 1 3\\", \\"QUERY 1 2\\" ] expected = [\\"2\\", \\"NOT SCHEDULED\\", \\"3\\"] assert manage_schedules(operations) == expected def test_example_3(): operations = [ \\"SCHEDULE 4 2 5\\", \\"SCHEDULE 3 4 7\\", \\"QUERY 4 2\\", \\"RESCHEDULE 4 2 10\\", \\"QUERY 4 2\\" ] expected = [\\"5\\", \\"10\\"] assert manage_schedules(operations) == expected def test_example_4(): operations = [ \\"SCHEDULE 1 3 8\\", \\"SCHEDULE 1 4 9\\", \\"RESCHEDULE 1 2 10\\", \\"QUERY 1 2\\" ] expected = [\\"NOT SCHEDULED\\"] assert manage_schedules(operations) == expected def test_no_schedules(): operations = [ \\"QUERY 1 2\\" ] expected = [\\"NOT SCHEDULED\\"] assert manage_schedules(operations) == expected def test_reschedule_nonexistent(): operations = [ \\"RESCHEDULE 1 2 5\\", \\"QUERY 1 2\\" ] expected = [\\"NOT SCHEDULED\\"] assert manage_schedules(operations) == expected def test_multiple_schedules_and_reschedules(): operations = [ \\"SCHEDULE 1 2 5\\", \\"SCHEDULE 1 3 6\\", \\"RESCHEDULE 1 2 8\\", \\"QUERY 1 2\\", \\"QUERY 1 3\\", \\"RESCHEDULE 1 3 10\\", \\"QUERY 1 3\\" ] expected = [\\"8\\", \\"6\\", \\"10\\"] assert manage_schedules(operations) == expected","solution":"def manage_schedules(operations): Manages the scheduling, rescheduling, and querying of truck deliveries. :param operations: List of operations in the form of tuples. :return: List of results for QUERY operations. schedule = {} results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"SCHEDULE\\": X, Y, D = int(parts[1]), int(parts[2]), int(parts[3]) schedule[(X, Y)] = D elif command == \\"RESCHEDULE\\": X, Y, D = int(parts[1]), int(parts[2]), int(parts[3]) if (X, Y) in schedule: schedule[(X, Y)] = D elif command == \\"QUERY\\": X, Y = int(parts[1]), int(parts[2]) if (X, Y) in schedule: results.append(str(schedule[(X, Y)])) else: results.append(\\"NOT SCHEDULED\\") return results"},{"question":"def max_contiguous_potions(n: int, m: int, grid: List[str]) -> int: Determine the maximum number of contiguous identical potions in a straight line within a magical grid. >>> max_contiguous_potions(4, 5, [\\"abaaa\\", \\"bcccb\\", \\"deeee\\", \\"bbabb\\"]) 4 >>> max_contiguous_potions(1, 1, [\\"a\\"]) 1 >>> max_contiguous_potions(1, 5, [\\"aaaaa\\"]) 5 >>> max_contiguous_potions(5, 1, [\\"a\\", \\"a\\", \\"a\\", \\"a\\", \\"a\\"]) 5 >>> max_contiguous_potions(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 1 >>> max_contiguous_potions(3, 4, [\\"aabc\\", \\"abcd\\", \\"bcdd\\"]) 2 >>> max_contiguous_potions(3, 3, [\\"aaa\\", \\"bca\\", \\"ccc\\"]) 3","solution":"def max_contiguous_potions(n, m, grid): def check_contiguous(x, y, dx, dy, character): count = 0 # Traverse in the given direction (dx, dy) while 0 <= x < n and 0 <= y < m and grid[x][y] == character: count += 1 x += dx y += dy return count max_count = 0 # Check in four directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for i in range(n): for j in range(m): current_char = grid[i][j] for dx, dy in directions: max_count = max(max_count, check_contiguous(i, j, dx, dy, current_char)) return max_count"},{"question":"def countVowels(s: str) -> int: Write a function \`countVowels\` that takes a string as input and returns the number of vowels contained in the string. Vowels are defined as 'a', 'e', 'i', 'o', 'u' (both uppercase and lowercase). The function should be case-insensitive. >>> countVowels(\\"Hello World\\") == 3 >>> countVowels(\\"aeiouAEIOU\\") == 10 >>> countVowels(\\"Python Programming\\") == 4 from solution import countVowels def test_countVowels_with_mixed_case(): assert countVowels(\\"Hello World\\") == 3 def test_countVowels_all_vowels(): assert countVowels(\\"aeiouAEIOU\\") == 10 def test_countVowels_with_no_vowels(): assert countVowels(\\"bcdfg\\") == 0 def test_countVowels_with_mixed_characters(): assert countVowels(\\"Python Programming\\") == 4 def test_countVowels_empty_string(): assert countVowels(\\"\\") == 0 def test_countVowels_with_only_uppercase_vowels(): assert countVowels(\\"AEIOU\\") == 5 def test_countVowels_with_no_alphabets(): assert countVowels(\\"1234567890!@#%^&*()\\") == 0","solution":"def countVowels(s): Returns the number of vowels contained in the input string s. Vowels are defined as 'a', 'e', 'i', 'o', 'u' (both uppercase and lowercase). :param s: str, the input string :return: int, the count of vowels in the input string vowels = set('aeiouAEIOU') return sum(1 for char in s if char in vowels)"},{"question":"def min_removals_for_ordered_tasks(n: int, difficulty: List[int]) -> int: Finds the minimum number of task removals needed so that the remaining tasks are in ascending order of difficulty levels. >>> min_removals_for_ordered_tasks(7, [3, 1, 2, 4, 6, 5, 7]) == 2 >>> min_removals_for_ordered_tasks(5, [1, 3, 2, 1, 3]) == 2 >>> min_removals_for_ordered_tasks(5, [1, 2, 3, 4, 5]) == 0 >>> min_removals_for_ordered_tasks(5, [5, 4, 3, 2, 1]) == 4 >>> min_removals_for_ordered_tasks(5, [2, 2, 2, 2, 2]) == 4","solution":"def min_removals_for_ordered_tasks(n, difficulty): Finds the minimum number of task removals needed so that the remaining tasks are in ascending order of difficulty levels. Parameters: n (int): The number of tasks. difficulty (list): A list of integers representing the difficulty levels of the tasks. Returns: int: The minimum number of removals required. # dp array to store the length of Longest Increasing Subsequence (LIS) dp = [1] * n # Fill the dp array with LIS values for i in range(1, n): for j in range(i): if difficulty[i] > difficulty[j]: dp[i] = max(dp[i], dp[j] + 1) # Length of the longest increasing subsequence lis_length = max(dp) # The minimum number of removals required would be # the total number of tasks minus the length of LIS return n - lis_length"},{"question":"from typing import List def longest_sorted_subsequence(arr: List[int]) -> int: Find the length of the longest subsequence that appears in sorted order (strictly increasing or decreasing) in the array. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest subsequence that appears in sorted order. Examples: >>> longest_sorted_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_sorted_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_sorted_subsequence([3, 2]) 2 # Implement your solution here","solution":"from typing import List def longest_sorted_subsequence(arr: List[int]) -> int: def longest_increasing_subsequence(arr: List[int]) -> int: n = len(arr) if n == 0: return 0 lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) def longest_decreasing_subsequence(arr: List[int]) -> int: n = len(arr) if n == 0: return 0 lds = [1] * n for i in range(1, n): for j in range(i): if arr[i] < arr[j]: lds[i] = max(lds[i], lds[j] + 1) return max(lds) return max(longest_increasing_subsequence(arr), longest_decreasing_subsequence(arr))"},{"question":"def longest_grass_stretch(track: str) -> int: Returns the length of the longest continuous stretch of 'G' in the track string. >>> longest_grass_stretch(\\"GRGGGRGRG\\") 3 >>> longest_grass_stretch(\\"GGGRGGG\\") 3 >>> longest_grass_stretch(\\"RRRGGRRR\\") 2 pass","solution":"def longest_grass_stretch(track): Returns the length of the longest continuous stretch of 'G' in the track string. max_length = 0 current_length = 0 for section in track: if section == 'G': current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"from typing import List, Tuple def year_with_highest_population(test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determines the year with the highest number of people alive for each test case. Args: test_cases: A list of test cases, where each test case is itself a list of tuples containing birth and death years. Returns: A list of integers where each integer is the year with the highest number of people alive for the corresponding test case. >>> year_with_highest_population([[(1900, 1950), (1942, 1962), (1950, 2000)]]) [1950] >>> year_with_highest_population([[(1900, 1950), (1942, 1962), (1950, 2000)], [(1920, 1980), (1930, 1950), (1950, 1990), (1990, 2000)]]) [1950, 1950] >>> year_with_highest_population([[(1900, 2000), (1900, 2000), (1900, 2000)]]) [1900] >>> year_with_highest_population([[(1920, 1930), (1940, 1950), (1960, 1970)]]) [1920] >>> year_with_highest_population([[(1920, 1930), (1920, 1940), (1920, 1950)]]) [1920]","solution":"def year_with_highest_population(test_cases): results = [] for case in test_cases: years = {} for birth, death in case: for year in range(birth, death + 1): if year in years: years[year] += 1 else: years[year] = 1 max_population = max(years.values()) max_year = min(year for year in years if years[year] == max_population) results.append(max_year) return results"},{"question":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n. >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 2 >>> sum_of_primes(3) 5 >>> sum_of_primes(30) 129 >>> sum_of_primes(50) 328 >>> sum_of_primes(0) 0 >>> sum_of_primes(100000) 454396537 >>> sum_of_primes(100) 1060 >>> sum_of_primes(11) 28","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n. if n < 2: return 0 # Sieve of Eratosthenes to find all primes less than or equal to n is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n + 1, start): is_prime[multiple] = False return sum(index for index, prime in enumerate(is_prime) if prime)"},{"question":"def conveyor_belt_path(t: int, cases: List[Tuple[int, int]]) -> List[List[int]]: Determines the sequence of sections an item will pass through as it moves from its starting section to its destination section. >>> conveyor_belt_path(1, [(0, 7)]) [[0, 1, 2, 3, 4, 5, 6, 7]] >>> conveyor_belt_path(1, [(10, 5)]) [[10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5]] >>> conveyor_belt_path(1, [(8, 10)]) [[8, 9, 10]] >>> conveyor_belt_path(3, [(0, 7), (10, 5), (8, 10)]) [[0, 1, 2, 3, 4, 5, 6, 7], [10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5], [8, 9, 10]] >>> conveyor_belt_path(1, [(5, 5)]) [[5]]","solution":"def conveyor_belt_path(t, cases): results = [] for s, d in cases: if s <= d: path = list(range(s, d + 1)) else: path = list(range(s, 16)) + list(range(0, d + 1)) results.append(path) return results # Example usage: # t = 3 # cases = [(0, 7), (10, 5), (8, 10)] # print(conveyor_belt_path(t, cases))"},{"question":"def final_ranking(n: int, m: int, r: int, scores: List[List[int]]) -> int: Determines the final ranking of the robot ID 'r' based on the scores. Args: n : int : Number of robots m : int : Number of challenges r : int : Robot ID to be ranked (1-indexed) scores : List[List[int]] : Scores of all robots for each challenge (m x n) Returns: int : The final ranking of the robot with ID 'r' Example: >>> n = 5 >>> m = 3 >>> r = 2 >>> scores = [ ... [10, 20, 30, 40, 50], ... [15, 25, 35, 45, 55], ... [20, 30, 40, 50, 60] ... ] >>> final_ranking(n, m, r, scores) 4","solution":"def final_ranking(n, m, r, scores): Determines the final ranking of the robot ID 'r' based on the scores. Args: n : int : Number of robots m : int : Number of challenges r : int : Robot ID to be ranked (1-indexed) scores : List[List[int]] : Scores of all robots for each challenge (m x n) Returns: int : The final ranking of the robot with ID 'r' total_scores = [0] * n for challenge in scores: for i in range(n): total_scores[i] += challenge[i] target_robot_score = total_scores[r-1] sorted_scores = sorted(total_scores, reverse=True) ranking = sorted_scores.index(target_robot_score) + 1 return ranking"},{"question":"def minimal_total_items(n: int, max_items: List[int]) -> int: Determine the minimum total number of items per package. Args: n (int): Number of unique types of pastries. max_items (List[int]): List of integers indicating the maximum allowed items for each type of pastry. Returns: int: The minimal total number of items that can be filled per package. >>> minimal_total_items(3, [4, 3, 2]) 12 >>> minimal_total_items(4, [2, 2, 2, 2]) 2 >>> minimal_total_items(1, [5]) 5 >>> minimal_total_items(3, [2, 3, 5]) 30 >>> minimal_total_items(3, [3, 6, 8]) 24","solution":"from math import gcd from functools import reduce def lcm(a, b): return a * b // gcd(a, b) def lcm_multiple(numbers): return reduce(lcm, numbers, 1) def minimal_total_items(n, max_items): return lcm_multiple(max_items)"},{"question":"def find_root(parent, i): Find the root of the computer \`i\`. if parent[i] == i: return i else: parent[i] = find_root(parent, parent[i]) # Path compression return parent[i] def union(parent, rank, x, y): Union two sets containing \`x\` and \`y\`. root_x = find_root(parent, x) root_y = find_root(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def is_connected_network(n, edges): Check if all computers are connected directly or indirectly. Args: n: int - number of computers edges: List[Tuple[int, int]] - list of direct communication channels Returns: str - \\"YES\\" if all computers are connected, \\"NO\\" otherwise parent = [i for i in range(n+1)] rank = [0] * (n+1) for u, v in edges: union(parent, rank, u, v) root = find_root(parent, 1) for i in range(2, n+1): if find_root(parent, i) != root: return \\"NO\\" return \\"YES\\" def check_all_connected(test_cases): Evaluate multiple test cases to check network connectivity. Args: test_cases: List[Tuple[int, int, List[Tuple[int, int]]]] - List of test cases Returns: List[str] - List of results for each test case results = [] for n, m, edges in test_cases: results.append(is_connected_network(n, edges)) return results def test_find_root(): parent = [0, 1, 2, 3, 4] assert find_root(parent, 1) == 1 parent[2] = 1 assert find_root(parent, 2) == 1 parent[3] = 1 assert find_root(parent, 3) == 1 def test_union(): parent = [0, 1, 2, 3, 4] rank = [0, 0, 0, 0, 0] union(parent, rank, 1, 2) assert find_root(parent, 1) == find_root(parent, 2) union(parent, rank, 2, 3) assert find_root(parent, 1) == find_root(parent, 3) union(parent, rank, 3, 4) assert find_root(parent, 1) == find_root(parent, 4) def test_is_connected_network(): edges1 = [(1, 2), (2, 3)] assert is_connected_network(4, edges1) == \\"NO\\" edges2 = [(1, 2), (2, 3), (3, 1)] assert is_connected_network(3, edges2) == \\"YES\\" edges3 = [(1, 2), (2, 3), (3, 4), (4, 5)] assert is_connected_network(5, edges3) == \\"YES\\" def test_check_all_connected(): test_cases = [ (4, 2, [(1, 2), (2, 3)]), (3, 3, [(1, 2), (2, 3), (3, 1)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ] assert check_all_connected(test_cases) == [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def find_root(parent, i): if parent[i] == i: return i else: parent[i] = find_root(parent, parent[i]) # Path compression return parent[i] def union(parent, rank, x, y): root_x = find_root(parent, x) root_y = find_root(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def is_connected_network(n, edges): parent = [i for i in range(n+1)] rank = [0] * (n+1) for u, v in edges: union(parent, rank, u, v) root = find_root(parent, 1) for i in range(2, n+1): if find_root(parent, i) != root: return \\"NO\\" return \\"YES\\" def check_all_connected(test_cases): results = [] for n, m, edges in test_cases: results.append(is_connected_network(n, edges)) return results"},{"question":"def find_min_length_subarray(N: int, T: int, numbers: List[int]) -> int: Finds the length of the smallest contiguous subarray with sum >= T. :param N: int : Number of elements in the list :param T: int : Target sum :param numbers: list : List of integers :return: int : Length of the smallest subarray with sum >= T >>> find_min_length_subarray(8, 15, [1, 2, 3, 4, 5, 6, 7, 8]) 2 >>> find_min_length_subarray(5, 100, [1, 2, 3, 4, 5]) 0 >>> find_min_length_subarray(1, 1, [1]) 1 >>> find_min_length_subarray(1, 2, [3]) 1 >>> find_min_length_subarray(4, 10, [1, 2, 3, 4]) 4 >>> find_min_length_subarray(5, 9, [2, 3, 5, 7, 1]) 2 >>> find_min_length_subarray(5, 20, [1, 2, 3, 4, 5]) 0 >>> find_min_length_subarray(3, 100000, [50000, 50000, 50000]) 2 >>> find_min_length_subarray(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> find_min_length_subarray(10, 20, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 3","solution":"def find_min_length_subarray(N, T, numbers): Finds the length of the smallest contiguous subarray with sum >= T :param N: int : Number of elements in the list :param T: int : Target sum :param numbers: list : List of integers :return: int : Length of the smallest subarray with sum >= T # Initialize variables min_length = float('inf') current_sum = 0 start_index = 0 # Use two pointers to find the smallest subarray with sum >= T for end_index in range(N): current_sum += numbers[end_index] while current_sum >= T: min_length = min(min_length, end_index - start_index + 1) current_sum -= numbers[start_index] start_index += 1 return min_length if min_length != float('inf') else 0"},{"question":"def process_operations(operations): Processes a sequence of stock operations and returns the recorded stock amounts. Parameters: operations (list of str): List of operation strings in the specified format. Returns: list of int: Stock amounts recorded at each \\"Record stock\\" operation. # Your code here import pytest def test_process_operations_case_1(): operations = [ '5', '1 500', '3', '2 200', '3', '1 300' ] assert process_operations(operations[1:]) == [500, 300] def test_process_operations_case_2(): operations = [ '8', '1 1000', '1 500', '3', '2 250', '3', '1 750', '2 1000', '3' ] assert process_operations(operations[1:]) == [1500, 1250, 1000] def test_process_operations_add_only(): operations = [ '4', '1 1000', '3', '1 2000', '3' ] assert process_operations(operations[1:]) == [1000, 3000] def test_process_operations_remove_only(): operations = [ '4', '1 3000', '2 1000', '3', '2 500', '3' ] assert process_operations(operations[1:]) == [2000, 1500] def test_process_operations_no_record(): operations = [ '3', '1 1000', '1 2000', '2 500' ] assert process_operations(operations[1:]) == [] def test_process_operations_empty_stock(): operations = [ '1', '3' ] assert process_operations(operations[1:]) == [0] if __name__ == '__main__': # this will run all the test cases pytest.main()","solution":"def process_operations(operations): Processes a sequence of stock operations and returns the recorded stock amounts. Parameters: operations (list of str): List of operation strings in the specified format. Returns: list of int: Stock amounts recorded at each \\"Record stock\\" operation. stock = 0 recorded_stocks = [] for operation in operations: parts = operation.split() op_type = int(parts[0]) if op_type == 1: # Add stock operation amount = int(parts[1]) stock += amount elif op_type == 2: # Remove stock operation amount = int(parts[1]) stock -= amount elif op_type == 3: # Record stock operation recorded_stocks.append(stock) return recorded_stocks"},{"question":"def has_repetitive_pattern(s: str) -> bool: Determine if the input string can be constructed by repeating one of its substrings at least twice. Parameters: s (str): Input string Returns: bool: True if the string can be constructed by repeating a substring, False otherwise. Examples: >>> has_repetitive_pattern(\\"abab\\") True >>> has_repetitive_pattern(\\"abcabcabc\\") True >>> has_repetitive_pattern(\\"abcd\\") False >>> has_repetitive_pattern(\\"a\\") False >>> has_repetitive_pattern(\\"ab\\") False >>> has_repetitive_pattern(\\"aaaa\\") True >>> has_repetitive_pattern(\\"xyzxyzxyzxyz\\") True >>> has_repetitive_pattern(\\"abcdefg\\") False >>> has_repetitive_pattern(\\"ababababab\\") True >>> has_repetitive_pattern(\\"aa\\") True >>> has_repetitive_pattern(\\"aabcabcabc\\") False","solution":"def has_repetitive_pattern(s): Determine if the input string can be constructed by repeating one of its substrings at least twice. Parameters: s (str): Input string Returns: bool: True if the string can be constructed by repeating a substring, False otherwise n = len(s) for i in range(1, n // 2 + 1): if n % i == 0 and s[:i] * (n // i) == s: return True return False"},{"question":"def contains_no_duplicates_within_distance(nums, k): Given an array of integers, return true if and only if it contains no duplicates within a particular distance k. Two integers nums[i] and nums[j] are considered duplicates if nums[i] == nums[j] and their indices i and j satisfy the condition |i - j| <= k. If no such pair exists, return true; otherwise, return false. :param nums: List[int] - A list of integers. :param k: int - The maximum allowed distance between duplicate values. :return: bool - True if no duplicates within distance k, False otherwise. >>> contains_no_duplicates_within_distance([1, 2, 3, 4, 5], 3) True >>> contains_no_duplicates_within_distance([1, 2, 3, 1], 3) False >>> contains_no_duplicates_within_distance([5, 6, 7, 8, 6], 4) False >>> contains_no_duplicates_within_distance([1, 2, 3, 1, 2, 3], 2) True >>> contains_no_duplicates_within_distance([1, 1, 1, 1], 10) False >>> contains_no_duplicates_within_distance([], 3) True >>> contains_no_duplicates_within_distance([1], 1) True","solution":"def contains_no_duplicates_within_distance(nums, k): Check whether the array contains no duplicate integers within a distance of k. :param nums: List[int] - A list of integers. :param k: int - The maximum allowed distance between duplicate values. :return: bool - True if no duplicates within distance k, False otherwise. seen = {} for i, num in enumerate(nums): if num in seen and i - seen[num] <= k: return False seen[num] = i return True"},{"question":"def is_pangram(sentence: str) -> str: Determines if a given sentence is a pangram. Parameters: sentence (str): The sentence to check. Returns: str: \\"YES\\" if the sentence is a pangram, otherwise \\"NO\\". >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") 'YES' >>> is_pangram(\\"Hello, World!\\") 'NO' >>> is_pangram(\\"The quick brown fox jumps over the lay dog\\") 'NO' >>> is_pangram(\\"The, quick brown fox jumps over the lazy dog!\\") 'YES' >>> is_pangram(\\"\\") 'NO' >>> is_pangram(\\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\\") 'YES'","solution":"def is_pangram(sentence): Determines if the given sentence is a pangram. Parameters: sentence (str): The sentence to check. Returns: str: \\"YES\\" if the sentence is a pangram, otherwise \\"NO\\". alphabet_set = set(\\"abcdefghijklmnopqrstuvwxyz\\") sentence_set = set(sentence.lower()) return \\"YES\\" if alphabet_set.issubset(sentence_set) else \\"NO\\""},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string so that all digits come before alphabets while preserving their relative order. Args: s (str): A string consisting of digits and lowercase alphabets. Returns: str: A rearranged string with all digits before any alphabets. Example: >>> rearrange_string('a1b2c3d4') '1234abcd' >>> rearrange_string('3f2g1h') '321fgh'","solution":"def rearrange_string(s): Rearranges the input string so that all digits come before alphabets while preserving their relative order. digits = [] alphabets = [] for char in s: if char.isdigit(): digits.append(char) else: alphabets.append(char) return ''.join(digits + alphabets) # Example usage # s = 'a1b2c3d4' # print(rearrange_string(s)) # Output: '1234abcd'"},{"question":"def unique_usernames(users: List[Dict[str, Any]]) -> List[Dict[str, Any]]: Ensures that each user in the list has a unique username by appending incremental numbers to duplicates. :param users: List of dictionaries, each containing at least the key 'username' :return: List of dictionaries with unique usernames >>> unique_usernames([ ... {\\"username\\": \\"john\\", \\"age\\": 25}, ... {\\"username\\": \\"john\\", \\"age\\": 30}, ... {\\"username\\": \\"jane\\", \\"age\\": 22}, ... {\\"username\\": \\"john\\", \\"age\\": 35}, ... {\\"username\\": \\"jane\\", \\"age\\": 28}, ... ]) [ {\\"username\\": \\"john\\", \\"age\\": 25}, {\\"username\\": \\"john1\\", \\"age\\": 30}, {\\"username\\": \\"jane\\", \\"age\\": 22}, {\\"username\\": \\"john2\\", \\"age\\": 35}, {\\"username\\": \\"jane1\\", \\"age\\": 28}, ] >>> unique_usernames([ ... {\\"username\\": \\"alex\\", \\"age\\": 19}, ... {\\"username\\": \\"alex\\", \\"age\\": 21}, ... {\\"username\\": \\"alex\\", \\"age\\": 23}, ... ]) [ {\\"username\\": \\"alex\\", \\"age\\": 19}, {\\"username\\": \\"alex1\\", \\"age\\": 21}, {\\"username\\": \\"alex2\\", \\"age\\": 23}, ] >>> unique_usernames([ ... {\\"username\\": \\"mary\\", \\"age\\": 24}, ... {\\"username\\": \\"anna\\", \\"age\\": 22}, ... {\\"username\\": \\"mary\\", \\"age\\": 27}, ... {\\"username\\": \\"anna\\", \\"age\\": 30}, ... {\\"username\\": \\"anna\\", \\"age\\": 28}, ... ]) [ {\\"username\\": \\"mary\\", \\"age\\": 24}, {\\"username\\": \\"anna\\", \\"age\\": 22}, {\\"username\\": \\"mary1\\", \\"age\\": 27}, {\\"username\\": \\"anna1\\", \\"age\\": 30}, {\\"username\\": \\"anna2\\", \\"age\\": 28}, ]","solution":"def unique_usernames(users): Ensures that each user in the list has a unique username by appending incremental numbers to duplicates. :param users: List of dictionaries, each containing at least the key 'username' :return: List of dictionaries with unique usernames seen_usernames = {} result = [] for user in users: base_username = user['username'] if base_username not in seen_usernames: seen_usernames[base_username] = 0 result.append(user) else: seen_usernames[base_username] += 1 new_username = f\\"{base_username}{seen_usernames[base_username]}\\" user = user.copy() # Create a copy to avoid modifying the original user dictionary user['username'] = new_username result.append(user) return result"},{"question":"from typing import List def shortest_path(R: int, C: int, grid: List[str]) -> int: This function finds the shortest path from (0, 0) to (R-1, C-1) in a grid. If a path exists, it returns the length of the shortest path. If no path exists, it returns -1. >>> shortest_path(5, 5, [\\".....\\",\\".#...\\",\\".....\\",\\"...#.\\",\\".....\\"]) 8 >>> shortest_path(3, 3, [\\"...\\",\\".#.\\",\\"..#\\"]) -1 pass","solution":"from collections import deque def shortest_path(R, C, grid): This function finds the shortest path from (0, 0) to (R-1, C-1) in a grid. If a path exists, it returns the length of the shortest path. If no path exists, it returns -1. if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 moves = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, distance = queue.popleft() if row == R-1 and col == C-1: return distance for move in moves: next_row, next_col = row + move[0], col + move[1] if 0 <= next_row < R and 0 <= next_col < C and grid[next_row][next_col] == '.' and (next_row, next_col) not in visited: visited.add((next_row, next_col)) queue.append((next_row, next_col, distance + 1)) return -1"},{"question":"def container_management_system(n: int, queries: List[str]) -> List[int]: The container_management_system function is designed to efficiently manage and query the movement of containers between different storage locations. Each storage location is represented as a node in a graph, and each container has a unique identifier. Parameters: - n (int): number of storage locations - queries (List[str]): list of operations to be performed on the system, where each operation can be of type \\"add x y\\", \\"move x y\\", or \\"find x\\". Returns: - List[int]: a list of results for each \\"find x\\" operation, where the result is the identifier of the container located at storage location \`x\`, or -1 if the location is empty. Example: >>> container_management_system(5, [ ... \\"add 1 100\\", ... \\"add 2 200\\", ... \\"find 1\\", ... \\"move 1 2\\", ... \\"find 1\\", ... \\"find 2\\", ... \\"find 3\\"]) [100, -1, 100, -1] >>> container_management_system(3, [ ... \\"find 1\\", ... \\"find 2\\", ... \\"find 3\\"]) [-1, -1, -1]","solution":"def container_management_system(n, queries): storage = {i: -1 for i in range(1, n + 1)} result = [] for query in queries: parts = query.split() operation = parts[0] x = int(parts[1]) if operation == \\"add\\": y = int(parts[2]) storage[x] = y elif operation == \\"move\\": y = int(parts[2]) if storage[x] != -1: storage[y] = storage[x] storage[x] = -1 elif operation == \\"find\\": result.append(storage[x]) return result"},{"question":"def minimum_distance_railway_network(n: int, m: int, routes: List[Tuple[int, int, int]]) -> int: Find the minimum possible total distance of the railway network that connects all the cities directly or indirectly. If it is not possible to connect all cities, return -1. >>> minimum_distance_railway_network(4, 5, [(1, 2, 5), (1, 3, 10), (2, 3, 4), (2, 4, 11), (3, 4, 7)]) 16 >>> minimum_distance_railway_network(4, 2, [(1, 2, 3), (3, 4, 2)]) -1 # Your code here import pytest from solution_incomplete import minimum_distance_railway_network def test_example1(): n = 4 m = 5 routes = [ (1, 2, 5), (1, 3, 10), (2, 3, 4), (2, 4, 11), (3, 4, 7) ] assert minimum_distance_railway_network(n, m, routes) == 16 def test_example2(): n = 4 m = 2 routes = [ (1, 2, 3), (3, 4, 2) ] assert minimum_distance_railway_network(n, m, routes) == -1 def test_single_connection(): n = 2 m = 1 routes = [(1, 2, 5)] assert minimum_distance_railway_network(n, m, routes) == 5 def test_disconnected_graph(): n = 5 m = 3 routes = [ (1, 2, 1), (2, 3, 2), (4, 5, 3) ] assert minimum_distance_railway_network(n, m, routes) == -1 def test_all_cities_connecting(): n = 3 m = 3 routes = [ (1, 2, 1), (2, 3, 2), (3, 1, 3) ] assert minimum_distance_railway_network(n, m, routes) == 3 def test_large_graph(): n = 4 m = 6 routes = [ (1, 2, 1), (1, 4, 2), (2, 4, 3), (2, 3, 4), (3, 4, 5), (1, 3, 1) ] assert minimum_distance_railway_network(n, m, routes) == 4","solution":"def find(parent, i): A utility function to find the set of an element i (uses path compression technique) if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): A function that does union of two sets of x and y (uses union by rank) xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): Function to construct MST using Kruskal's algorithm result = [] # This will store the resultant MST i, e = 0, 0 # An index variable, used for sorted edges # Step 1: Sort all the edges in non-decreasing order of their # weight. If we are not allowed to change the given graph, we # can create a copy of the array of edges edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(n): parent.append(node) rank.append(0) # Number of edges to be taken is equal to V-1 while e < n - 1: if i >= len(edges): return -1 # Step 2: Pick the smallest edge. And increment # the index for next iteration u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) # If including this edge does not cause cycle, # include it in the result and increment the index # of the result for the next edge if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimumCost = 0 for u, v, weight in result: minimumCost += weight return minimumCost def minimum_distance_railway_network(n, m, routes): edges = [] for u, v, w in routes: edges.append((u, v, w)) return kruskal(n, edges)"},{"question":"from typing import List, Tuple def min_power_to_reach_end(n: int, m: int, k: int, b: int, traps: List[Tuple[int, int]]) -> int: Returns the minimum units of power needed for the robot to reach the bottom-right corner, or -1 if it is not possible. >>> min_power_to_reach_end(3, 3, 0, 5, []) == 4 >>> min_power_to_reach_end(3, 3, 1, 5, [(2, 2)]) == 4 >>> min_power_to_reach_end(5, 5, 2, 10, [(3, 3), (4, 4)]) == 8 >>> min_power_to_reach_end(3, 3, 1, 5, [(1, 1)]) == -1 >>> min_power_to_reach_end(3, 3, 1, 5, [(3, 3)]) == -1 >>> min_power_to_reach_end(5, 5, 0, 2, []) == -1 >>> min_power_to_reach_end(4, 4, 4, 10, [(2, 2), (3, 2), (2, 3), (3, 3)]) == 6","solution":"from collections import deque def min_power_to_reach_end(n, m, k, b, traps): Returns the minimum units of power needed for the robot to reach the bottom-right corner, or -1 if it is not possible. directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # possible movements (down, right, up, left) traps_set = {(x, y) for x, y in traps} # Set for quick lookup of traps if (1, 1) in traps_set or (n, m) in traps_set: return -1 queue = deque([(1, 1, 0)]) # (current_row, current_col, power_used) visited = set((1, 1)) while queue: x, y, power = queue.popleft() if power > b: return -1 if (x, y) == (n, m): return power for dx, dy in directions: nx, ny = x + dx, y + dy if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) not in traps_set and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, power + 1)) return -1"},{"question":"import math from typing import List, Tuple def min_path_length(n: int, points: List[Tuple[int, int]]) -> float: Calculate the minimum possible length of the path that visits every point exactly once and returns to the starting point. >>> min_path_length(4, [(0, 0), (1, 0), (1, 1), (0, 1)]) == 4.000000 >>> min_path_length(5, [(1, 1), (2, 2), (2, 1), (3, 0), (1, 2)]) == 6.472136 >>> min_path_length(3, [(0, 0), (1, 0), (0, 1)]) == 3.414214 >>> min_path_length(4, [(0, 0), (1000000000, 0), (1000000000, 1000000000), (0, 1000000000)]) == 4000000000.000000 >>> min_path_length(3, [(0, 0), (1, 1), (2, 2)]) == 5.656854 pass","solution":"import math def calc_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) def convex_hull(points): points.sort() lower = [] for p in points: while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) upper = [] for p in reversed(points): while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) return lower[:-1] + upper[:-1] def min_path_length(n, points): points = [tuple(point) for point in points] hull = convex_hull(points) distance = 0.0 for i in range(len(hull)): distance += calc_distance(hull[i], hull[(i + 1) % len(hull)]) return round(distance, 6)"},{"question":"def process_milestones(milestones): Determine the latest actual completion date and the earliest estimated completion date from a list of milestones. Args: milestones (List[Tuple[str, str]]): A list of tuples, where each tuple contains two strings: the actual completion date and the estimated completion date in the format \\"YYYY-MM-DD\\". Returns: Tuple[str, str]: A tuple containing the latest actual completion date and the earliest estimated completion date. Examples: >>> process_milestones([ ... (\\"2023-01-15\\", \\"2023-02-20\\"), ... (\\"2023-01-25\\", \\"2023-03-01\\"), ... (\\"2023-01-10\\", \\"2023-01-30\\") ... ]) ('2023-01-25', '2023-01-30') >>> process_milestones([ ... (\\"2023-05-20\\", \\"2023-06-15\\"), ... (\\"2023-05-18\\", \\"2023-06-10\\") ... ]) ('2023-05-20', '2023-06-10') def main(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") N = int(data[0]) milestones = [line.split() for line in data[1:]] latest_actual, earliest_estimated = process_milestones(milestones) print(latest_actual) print(earliest_estimated) if __name__ == \\"__main__\\": main() def test_process_milestones(): milestones1 = [ (\\"2023-01-15\\", \\"2023-02-20\\"), (\\"2023-01-25\\", \\"2023-03-01\\"), (\\"2023-01-10\\", \\"2023-01-30\\") ] result1 = process_milestones(milestones1) assert result1 == (\\"2023-01-25\\", \\"2023-01-30\\") milestones2 = [ (\\"2023-05-20\\", \\"2023-06-15\\"), (\\"2023-05-18\\", \\"2023-06-10\\") ] result2 = process_milestones(milestones2) assert result2 == (\\"2023-05-20\\", \\"2023-06-10\\") milestones3 = [ (\\"2022-12-01\\", \\"2023-01-01\\") ] result3 = process_milestones(milestones3) assert result3 == (\\"2022-12-01\\", \\"2023-01-01\\") milestones4 = [ (\\"2022-01-01\\", \\"2022-01-02\\"), (\\"2022-01-03\\", \\"2022-01-01\\"), (\\"2022-01-02\\", \\"2022-01-05\\") ] result4 = process_milestones(milestones4) assert result4 == (\\"2022-01-03\\", \\"2022-01-01\\") if __name__ == \\"__main__\\": test_process_milestones() print(\\"All tests passed.\\")","solution":"def process_milestones(milestones): from datetime import datetime latest_actual = None earliest_estimated = None for milestone in milestones: actual_date, estimated_date = milestone actual_date = datetime.strptime(actual_date, \\"%Y-%m-%d\\") estimated_date = datetime.strptime(estimated_date, \\"%Y-%m-%d\\") if latest_actual is None or actual_date > latest_actual: latest_actual = actual_date if earliest_estimated is None or estimated_date < earliest_estimated: earliest_estimated = estimated_date return latest_actual.strftime(\\"%Y-%m-%d\\"), earliest_estimated.strftime(\\"%Y-%m-%d\\") def main(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") N = int(data[0]) milestones = [line.split() for line in data[1:]] latest_actual, earliest_estimated = process_milestones(milestones) print(latest_actual) print(earliest_estimated) if __name__ == \\"__main__\\": main()"},{"question":"def min_insertions_to_make_valid(s: str) -> int: Determines the minimum number of insertions required to make the string of parentheses valid. >>> min_insertions_to_make_valid(\\"())\\") == 1 >>> min_insertions_to_make_valid(\\"((\\") == 2 >>> min_insertions_to_make_valid(\\"()\\") == 0 >>> min_insertions_to_make_valid(\\")(\\") == 2 >>> min_insertions_to_make_valid(\\"((()))\\") == 0 >>> min_insertions_to_make_valid(\\"((())\\") == 1 >>> min_insertions_to_make_valid(\\")))\\") == 3 >>> min_insertions_to_make_valid(\\"((()))(\\") == 1 >>> min_insertions_to_make_valid(\\")\\") == 1 >>> min_insertions_to_make_valid(\\"(\\") == 1","solution":"def min_insertions_to_make_valid(s): Determines the minimum number of insertions required to make the string of parentheses valid. open_brackets = 0 insertions = 0 for char in s: if char == '(': open_brackets += 1 else: # char == ')' if open_brackets > 0: open_brackets -= 1 else: insertions += 1 # Any remaining open brackets need to be closed insertions += open_brackets return insertions"},{"question":"def is_consecutive_sequence(message: str) -> str: Determines if the sorted letters of the message form a consecutive sequence from the alphabet without any gaps. >>> is_consecutive_sequence(\\"BAC\\") \\"YES\\" >>> is_consecutive_sequence(\\"ACD\\") \\"NO\\" pass def verify_consecutive_messages(L: int, messages: List[str]) -> List[str]: Given a number L and a list of L coded messages, this function returns a list of \\"YES\\" or \\"NO\\" for each message indicating whether the sorted letters form a consecutive sequence. >>> verify_consecutive_messages(3, [\\"BAC\\", \\"ECBAD\\", \\"ZXY\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> verify_consecutive_messages(2, [\\"ACD\\", \\"ACE\\"]) [\\"NO\\", \\"NO\\"] pass","solution":"def is_consecutive_sequence(message): Determines if the sorted letters of the message form a consecutive sequence from the alphabet without any gaps. sorted_message = sorted(message) for i in range(1, len(sorted_message)): if ord(sorted_message[i]) - ord(sorted_message[i - 1]) != 1: return \\"NO\\" return \\"YES\\" def verify_consecutive_messages(L, messages): Given a number L and a list of L coded messages, this function returns a list of \\"YES\\" or \\"NO\\" for each message indicating whether the sorted letters form a consecutive sequence. return [is_consecutive_sequence(message) for message in messages]"},{"question":"def min_balanced_substrings(s: str) -> int: Returns the minimum number of balanced contiguous substrings that cover the entire string s. Examples: >>> min_balanced_substrings(\\"aabb\\") 1 >>> min_balanced_substrings(\\"aaabbb\\") 1 >>> min_balanced_substrings(\\"aaaabbbb\\") 1 >>> min_balanced_substrings(\\"ababab\\") 3","solution":"def min_balanced_substrings(s): Returns the minimum number of balanced contiguous substrings that cover the entire string s. balance = 0 substr_count = 0 for char in s: if char == 'a': balance += 1 else: balance -= 1 if balance == 0: substr_count += 1 return substr_count"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. :param matrix: List of lists representing the matrix to be rotated :return: Rotated matrix pass def matrix_to_string(matrix): Converts a matrix to a string representation where each row is on a new line, and elements within a row are separated by spaces. :param matrix: List of lists representing the matrix :return: String representation of the matrix pass # Test cases def test_rotate_3x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] expected = [ [9, 5, 1], [10, 6, 2], [11, 7, 3], [12, 8, 4] ] assert rotate_matrix_90_clockwise(matrix) == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_matrix_90_clockwise(matrix) == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] expected = [ [1] ] assert rotate_matrix_90_clockwise(matrix) == expected def test_rotate_empty_matrix(): matrix = [] expected = [] assert rotate_matrix_90_clockwise(matrix) == expected def test_rotate_2x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6] ] expected = [ [4, 1], [5, 2], [6, 3] ] assert rotate_matrix_90_clockwise(matrix) == expected def test_matrix_to_string(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = \\"1 2 3n4 5 6n7 8 9\\" assert matrix_to_string(matrix) == expected def test_matrix_to_string_empty(): matrix = [] expected = \\"\\" assert matrix_to_string(matrix) == expected","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. :param matrix: List of lists representing the matrix to be rotated :return: Rotated matrix if not matrix or not matrix[0]: return [] n = len(matrix) m = len(matrix[0]) # Initialize a new matrix to store the rotated result rotated_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated_matrix[j][n - i - 1] = matrix[i][j] return rotated_matrix def matrix_to_string(matrix): return 'n'.join(' '.join(map(str, row)) for row in matrix)"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome. Ignores spaces, punctuation, and capitalization. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"madam\\") == True >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True pass def process_input(input_lines: list) -> list: Processes the input lines to determine if each line (except END) is a palindrome. Returns a list of strings, either \\"YES\\" or \\"NO\\" for each input line. >>> input_lines = [ ... \\"racecarn\\", ... \\"hellon\\", ... \\"madamn\\", ... \\"A man, a plan, a canal, Panaman\\", ... \\"ENDn\\" ... ] >>> process_input(input_lines) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> input_lines = [\\"ENDn\\"] >>> process_input(input_lines) == [] >>> input_lines = [ ... \\"Was it a car or a cat I sawn\\", ... \\"No lemon, no melonn\\", ... \\"ENDn\\" ... ] >>> process_input(input_lines) == [\\"YES\\", \\"YES\\"] pass","solution":"def is_palindrome(string): Determines if the given string is a palindrome. Ignores spaces, punctuation, and capitalization. import re # Remove non-alphanumeric characters and convert to lower case cleaned_string = re.sub(r'[^A-Za-z0-9]', '', string).lower() # Check if the cleaned string is equal to its reverse return cleaned_string == cleaned_string[::-1] def process_input(input_lines): Processes the input lines to determine if each line (except END) is a palindrome. Returns a list of strings, either \\"YES\\" or \\"NO\\" for each input line. results = [] for line in input_lines: line = line.strip() if line == \\"END\\": break if is_palindrome(line): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import math from typing import List def average_travel_distance(deliveries: List[List[int]]) -> float: Calculates the average distance traveled by a delivery truck to deliver packages. Parameters: deliveries (List[List[int]]): 2D list with [x, y] coordinates of each delivery location. Returns: float: average distance traveled per delivery. Example: >>> average_travel_distance([[1, 3], [4, 4], [-2, 0], [-6, 8]]) -> 7.302 >>> average_travel_distance([[5, 5]]) -> 14.142135623730951 >>> average_travel_distance([]) -> 0","solution":"import math def average_travel_distance(deliveries): Returns the average distance traveled by a delivery truck to deliver packages. Parameters: deliveries (list of list of int): 2D list with [x, y] coordinates of each delivery location. Returns: float: average distance traveled per delivery. n = len(deliveries) if n == 0: return 0 total_distance = 0 start_point = (0, 0) previous_point = start_point for delivery in deliveries: current_point = (delivery[0], delivery[1]) total_distance += math.sqrt((current_point[0] - previous_point[0])**2 + (current_point[1] - previous_point[1])**2) previous_point = current_point # Add the distance back to the warehouse total_distance += math.sqrt((start_point[0] - previous_point[0])**2 + (start_point[1] - previous_point[1])**2) # Average distance per delivery includes the return trip return total_distance / n"},{"question":"class SequenceOperator: def __init__(self, sequence): Initialize SequenceOperator with a given sequence of integers. self.sequence = sequence def update(self, index, value): Replace the index-th element of the sequence with value. def query(self, left, right): Return the number of distinct elements in the subarray from index left to index right. # Unit test examples def test_initial_query(): seq_op = SequenceOperator([1, 2, 3, 4, 5]) assert seq_op.query(1, 5) == 5 def test_update_and_query(): seq_op = SequenceOperator([1, 2, 3, 4, 5]) seq_op.update(3, 2) assert seq_op.query(1, 5) == 4 assert seq_op.query(2, 4) == 2 def test_multiple_updates(): seq_op = SequenceOperator([1, 2, 3, 4, 5]) seq_op.update(3, 2) seq_op.update(5, 1) assert seq_op.query(1, 5) == 3 def test_edge_cases(): seq_op = SequenceOperator([10]) assert seq_op.query(1, 1) == 1 seq_op.update(1, 5) assert seq_op.query(1, 1) == 1 def test_full_range_query(): seq_op = SequenceOperator([1, 2, 1, 2, 1]) assert seq_op.query(1, 5) == 2 seq_op.update(4, 3) assert seq_op.query(1, 5) == 3 def test_single_element_subarray(): seq_op = SequenceOperator([1, 2, 1, 2, 1]) assert seq_op.query(3, 3) == 1 seq_op.update(3, 4) assert seq_op.query(3, 3) == 1","solution":"class SequenceOperator: def __init__(self, sequence): self.sequence = sequence def update(self, index, value): self.sequence[index - 1] = value def query(self, left, right): return len(set(self.sequence[left - 1:right]))"},{"question":"def count_unique_subarrays(n: int) -> int: Returns the number of contiguous subarrays that contain only unique elements. Given an integer n, this function calculates the number of valid contiguous subarrays. >>> count_unique_subarrays(1) 1 >>> count_unique_subarrays(2) 3 >>> count_unique_subarrays(4) 10 >>> count_unique_subarrays(5) 15","solution":"def count_unique_subarrays(n): Returns the number of contiguous subarrays that contain only unique elements. Since the sequence is just integers from 1 to n, all subarrays will have unique elements, so the solution is derived by summing up lengths of all possible subarrays. return n * (n + 1) // 2"},{"question":"def count_subarrays_with_product_less_than_x(n: int, a: List[int], x: int) -> int: Counts the number of contiguous subarrays whose product of all elements is less than x. Parameters: n : int : The length of the array a. a : list of int : The elements of the array. x : int : The threshold value for the product. Returns: int : The number of contiguous subarrays with product less than x. Examples: >>> count_subarrays_with_product_less_than_x(4, [1, 2, 3, 4], 10) 7 >>> count_subarrays_with_product_less_than_x(5, [10, 5, 2, 6, 3], 100) 11","solution":"def count_subarrays_with_product_less_than_x(n, a, x): Counts the number of contiguous subarrays whose product of all elements is less than x. Parameters: n : int : The length of the array a. a : list of int : The elements of the array. x : int : The threshold value for the product. Returns: int : The number of contiguous subarrays with product less than x. count = 0 product = 1 left = 0 for right in range(n): product *= a[right] while product >= x and left <= right: product //= a[left] left += 1 count += (right - left + 1) return count"},{"question":"def reconstruct_sequence(n: int, s: List[int]) -> List[int]: Given the sequence s, reconstructs the original sequence a. Parameters: n (int): the length of the sequence. s (list): the input sequence. Returns: list: the reconstructed original sequence. Examples: >>> reconstruct_sequence(5, [2, 5, 8, 14, 20]) [2, 3, 3, 6, 6] >>> reconstruct_sequence(3, [-5, -1, 7]) [-5, 4, 8]","solution":"def reconstruct_sequence(n, s): Given the sequence s, reconstructs the original sequence a. Parameters: n (int): the length of the sequence. s (list): the input sequence. Returns: list: the reconstructed original sequence. if n == 0: return [] # Initialize the sequence a with the first element being the same as s a = [s[0]] # Calculate the subsequent values of a for i in range(1, n): a.append(s[i] - s[i-1]) return a"},{"question":"def is_possible_to_travel_without_tolls(h: int, r: int, t: int, roads: List[Tuple[int, int, int]], s: int, d: int) -> str: Determine if it is possible to travel from house s to house d without using toll roads. Args: h: int - number of houses. r: int - number of roads. t: int - number of toll roads. roads: List[Tuple[int, int, int]] - each tuple contains (x_i, y_i, z_i) where x_i and y_i are the houses connected by the i-th road and z_i is 1 if it is a toll road and 0 otherwise. s: int - the house where the journey starts. d: int - the house where the journey should end. Returns: str - \\"POSSIBLE\\" if it is possible to travel from house s to house d without using toll roads, otherwise \\"IMPOSSIBLE\\". >>> is_possible_to_travel_without_tolls(6, 7, 2, [(1, 2, 0), (2, 3, 1), (3, 1, 0), (3, 4, 0), (4, 5, 0), (5, 6, 1), (6, 4, 0)], 1, 6) 'POSSIBLE' >>> is_possible_to_travel_without_tolls(5, 4, 2, [(1, 2, 1), (2, 3, 0), (3, 4, 1), (4, 5, 0)], 1, 5) 'IMPOSSIBLE' >>> is_possible_to_travel_without_tolls(4, 4, 0, [(1, 2, 0), (2, 3, 0), (3, 4, 0), (4, 1, 0)], 1, 3) 'POSSIBLE' >>> is_possible_to_travel_without_tolls(2, 0, 0, [], 1, 2) 'IMPOSSIBLE' >>> is_possible_to_travel_without_tolls(1, 0, 0, [], 1, 1) 'POSSIBLE'","solution":"def is_possible_to_travel_without_tolls(h, r, t, roads, s, d): from collections import defaultdict, deque # Create a graph without toll roads graph = defaultdict(list) for x, y, z in roads: if z == 0: # only consider roads without toll graph[x].append(y) graph[y].append(x) # Use BFS to check if there's a path from s to d avoiding toll roads queue = deque([s]) visited = set([s]) while queue: house = queue.popleft() if house == d: return \\"POSSIBLE\\" for neighbor in graph[house]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return \\"IMPOSSIBLE\\""},{"question":"from typing import List, Tuple, Union def find_task_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine a valid sequence to complete all tasks based on dependencies, or report 'IMPOSSIBLE' if there is a cycle. >>> find_task_order(4, 4, [(1, 2), (1, 3), (2, 4), (3, 4)]) [1, 2, 3, 4] >>> find_task_order(3, 2, [(1, 2), (2, 3)]) [1, 2, 3] >>> find_task_order(3, 3, [(1, 2), (2, 3), (3, 1)]) 'IMPOSSIBLE' pass","solution":"from collections import deque, defaultdict def find_task_order(n, m, dependencies): # Create an adjacency list and an in-degree array adj_list = defaultdict(list) in_degree = [0] * (n + 1) # Fill the adjacency list and in-degree array for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Initialize a queue with tasks that have no dependencies queue = deque() for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) task_order = [] # Process the tasks while queue: task = queue.popleft() task_order.append(task) for neighbor in adj_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we managed to process all tasks, return the order. Otherwise, it's impossible if len(task_order) == n: return task_order else: return \\"IMPOSSIBLE\\""},{"question":"def min_operations_to_make_elements_equal(n: int, elements: List[int]) -> int: Returns the minimum number of operations required to make all elements in the list the same. Each operation is either incrementing or decrementing any element by 1. >>> min_operations_to_make_elements_equal(4, [1, 2, 3, 4]) 4 >>> min_operations_to_make_elements_equal(3, [7, 6, 5]) 2 >>> min_operations_to_make_elements_equal(5, [1, 2, 2, 2, 3]) 2 >>> min_operations_to_make_elements_equal(6, [10, 10, 10, 10, 10, 10]) 0 >>> min_operations_to_make_elements_equal(1, [1000]) 0 >>> min_operations_to_make_elements_equal(2, [1, 1000]) 999","solution":"def min_operations_to_make_elements_equal(n, elements): Returns the minimum number of operations required to make all elements in the list the same. Each operation is either incrementing or decrementing any element by 1. median_element = sorted(elements)[n // 2] operations = sum(abs(x - median_element) for x in elements) return operations"},{"question":"def min_shelves(N: int, X: int, Y: int) -> [int, str]: Determines the minimum number of shelves required to store N boxes, where each shelf can hold up to X boxes and there are Y shelves available. If it's not possible to store all the boxes with the available shelves, the function returns \\"Not Possible\\". :param int N: Total number of boxes :param int X: Maximum boxes each shelf can hold :param int Y: Total number of shelves available :return: Minimum number of shelves needed or \\"Not Possible\\" :rtype: int or str >>> min_shelves(100, 10, 15) 10 >>> min_shelves(500, 25, 20) 20 >>> min_shelves(1000000, 500, 1000) \\"Not Possible\\" >>> min_shelves(120, 10, 8) \\"Not Possible\\" >>> min_shelves(250, 50, 6) 5","solution":"def min_shelves(N, X, Y): Determines the minimum number of shelves required to store N boxes, where each shelf can hold up to X boxes and there are Y shelves available. If it's not possible to store all the boxes with the available shelves, the function returns \\"Not Possible\\". :param int N: Total number of boxes :param int X: Maximum boxes each shelf can hold :param int Y: Total number of shelves available :return: Minimum number of shelves needed or \\"Not Possible\\" :rtype: int or str required_shelves = (N + X - 1) // X # This gives us the ceiling of N / X if required_shelves > Y: return \\"Not Possible\\" return required_shelves # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read().strip().split() N, X, Y = map(int, input) result = min_shelves(N, X, Y) print(result)"},{"question":"def min_palindrome_partitions(s: str) -> int: Find the minimum number of palindromic substrings needed to partition the string. >>> min_palindrome_partitions('a') 0 >>> min_palindrome_partitions('aa') 0 >>> min_palindrome_partitions('ab') 1 >>> min_palindrome_partitions('racecar') 0 >>> min_palindrome_partitions('abcbm') 2 >>> min_palindrome_partitions('aab') 1 >>> min_palindrome_partitions('aabb') 1 >>> min_palindrome_partitions('aabba') 1 >>> min_palindrome_partitions('banana') 1 >>> min_palindrome_partitions('abcdcb') 1","solution":"def min_palindrome_partitions(s): n = len(s) dp = [0] * n is_palindrome = [[False] * n for _ in range(n)] for i in range(n): min_cut = i # maximum cuts needed will be i (cutting each character individually) for j in range(i + 1): if s[i] == s[j] and (i - j < 2 or is_palindrome[j + 1][i - 1]): is_palindrome[j][i] = True min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut return dp[-1]"},{"question":"def max_objects(X: int, Y: int, T: int) -> int: Determines the maximum number of objects (of either type A or B) that can be produced given time constraints. Parameters: X (int): Production time required for an object of type A. Y (int): Production time required for an object of type B. T (int): Total available production time. Returns: int: Maximum number of objects that can be produced. Examples: >>> max_objects(2, 3, 10) 5 >>> max_objects(5, 6, 27) 5 >>> max_objects(4, 4, 10) 2","solution":"def max_objects(X, Y, T): Determines the maximum number of objects (of either type A or B) that can be produced given time constraints. Parameters: X (int): Production time required for an object of type A. Y (int): Production time required for an object of type B. T (int): Total available production time. Returns: int: Maximum number of objects that can be produced. max_objects = 0 # Iterate over possible counts of type A objects from 0 to T // X for count_a in range(T // X + 1): remaining_time = T - count_a * X count_b = remaining_time // Y max_objects = max(max_objects, count_a + count_b) return max_objects"},{"question":"from typing import List def max_product_of_three(arr: List[int]) -> int: Returns the maximum product of any three distinct elements in the array. >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 5, 2]) 500 pass def test_positive_numbers(): assert max_product_of_three([1, 10, 2, 6, 5, 3]) == 300 def test_negatives_and_positives(): assert max_product_of_three([-10, -10, 5, 2]) == 500 def test_all_negative_numbers(): assert max_product_of_three([-10, -9, -8, -7]) == -504 def test_mixed_sign_numbers(): assert max_product_of_three([-1, -2, 1, 2, 3]) == 6 def test_three_elements(): assert max_product_of_three([1, 2, 3]) == 6 def test_large_numbers(): assert max_product_of_three([-1000, 999, 1000, 1000]) == 999000000 def test_additional_case(): assert max_product_of_three([10, 10, 10, 10]) == 1000","solution":"def max_product_of_three(arr): Returns the maximum product of any three distinct elements in the array. arr.sort() # The maximum product can be either the product of the three largest numbers # or the product of the two smallest numbers (which can be negative) and the largest number. return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"def longest_consecutive_temperature_sequence(n: int, T: List[int], Tmin: int, Tmax: int) -> int: Calculate the maximum number of consecutive days where the temperatures fall within the specified range. Parameters: - n (int): The number of days. - T (List[int]): List of temperatures on each day. - Tmin (int): The minimum temperature range. - Tmax (int): The maximum temperature range. Returns: - int: The length of the longest consecutive sequence of days within the temperature range. >>> longest_consecutive_temperature_sequence(7, [10, -5, 15, 20, 25, 30, 35], 10, 25) 3 >>> longest_consecutive_temperature_sequence(5, [-10, -20, -30, -15, -25], -25, -10) 2","solution":"def longest_consecutive_temperature_sequence(n, T, Tmin, Tmax): Returns the length of the longest consecutive sequence of days where the temperature stays within the range [Tmin, Tmax]. :param n: Integer, number of days. :param T: List of integers, temperatures on each day. :param Tmin: Integer, minimum temperature range. :param Tmax: Integer, maximum temperature range. :return: Integer, length of the longest consecutive sequence. max_length = 0 current_length = 0 for temperature in T: if Tmin <= temperature <= Tmax: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def find_cycles(n, f): Identify all cycles in the permutation. >>> find_cycles(4, [2, 3, 1, 4]) [[1, 2, 3], [4]] >>> find_cycles(1, [1]) [[1]] def permutation_cycles(n, f): Output the number of cycles and their details. >>> permutation_cycles(4, [2, 3, 1, 4]) \\"2n3 1 2 3n1 4\\" >>> permutation_cycles(1, [1]) \\"1n1 1\\"","solution":"def find_cycles(n, f): visited = [False] * (n + 1) cycles = [] for i in range(1, n + 1): if not visited[i]: cycle = [] x = i while not visited[x]: cycle.append(x) visited[x] = True x = f[x - 1] cycles.append(cycle) return cycles def permutation_cycles(n, f): cycles = find_cycles(n, f) result = [f\\"{len(cycles)}\\"] for cycle in cycles: result.append(f\\"{len(cycle)} \\" + \\" \\".join(map(str, cycle))) return \\"n\\".join(result)"},{"question":"def min_turns_to_pair(n: int, k: int, coders: List[int], m: int, testers: List[int]) -> int: Returns the minimum number of turns required for all coders to pair with all testers. If it is not possible, return -1. >>> min_turns_to_pair(5, 2, [1, 2], 2, [4, 5]) 3 >>> min_turns_to_pair(5, 2, [1, 2], 1, [4]) -1 >>> min_turns_to_pair(10, 3, [1, 2, 3], 3, [8, 9, 10]) 7 >>> min_turns_to_pair(2, 1, [1], 1, [2]) 1 >>> min_turns_to_pair(6, 2, [1, 4], 2, [3, 6]) 2 >>> min_turns_to_pair(5, 3, [1, 2, 3], 3, [5, 4, 3]) 2","solution":"def min_turns_to_pair(n, k, coders, m, testers): Returns the minimum number of turns required for all coders to pair with all testers. If it is not possible, return -1. if k > m: return -1 # More coders than testers, hence pairing is impossible coders.sort() testers.sort() turns = 0 for coder in coders: min_distance = float('inf') target_tester = None for tester in testers: distance = tester - coder if distance < 0: continue # Tester is already to the left of coder if distance < min_distance: min_distance = distance target_tester = tester if target_tester is None: return -1 # No available tester can pair with this coder testers.remove(target_tester) turns = max(turns, min_distance) return turns"},{"question":"def can_form_palindrome(s: str) -> str: Determines if any permutation of the string can form a palindrome. >>> can_form_palindrome(\\"carrace\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' >>> can_form_palindrome(\\"aabbcc\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO'","solution":"def can_form_palindrome(s): Determines if any permutation of the string can form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def integer_to_binary(n: int) -> str: Converts an integer to its binary representation without leading zeros. >>> integer_to_binary(5) '101' >>> integer_to_binary(14) '1110' >>> integer_to_binary(32) '100000' >>> integer_to_binary(0) '0' >>> integer_to_binary(10000) '10011100010000'","solution":"def integer_to_binary(n: int) -> str: Converts an integer to its binary representation without leading zeros. Args: n (int): The integer to convert. Returns: str: The binary representation of the integer. if n == 0: return '0' binary_str = '' while n > 0: binary_str = str(n % 2) + binary_str n //= 2 return binary_str"},{"question":"def max_songs_that_can_be_queued(n: int, m: int, song_lengths: List[int], preferred_durations: List[int]) -> int: Returns the maximum number of songs that can be queued such that every song's duration is at least as long as the user's preferred duration. Parameters: n (int): Number of songs m (int): Number of users song_lengths (List[int]): List of lengths of the songs preferred_durations (List[int]): List of users' preferred durations for a song Returns: int: Maximum number of songs that can be queued Examples: >>> max_songs_that_can_be_queued(6, 4, [3, 5, 8, 1, 9, 6], [2, 4, 7, 5]) 4 >>> max_songs_that_can_be_queued(5, 3, [10, 15, 3, 7, 4], [6, 10, 5]) 3 >>> max_songs_that_can_be_queued(4, 2, [2, 2, 2, 2], [3, 4]) 0 from solution import max_songs_that_can_be_queued def test_max_songs_that_can_be_queued_example1(): assert max_songs_that_can_be_queued(6, 4, [3, 5, 8, 1, 9, 6], [2, 4, 7, 5]) == 4 def test_max_songs_that_can_be_queued_example2(): assert max_songs_that_can_be_queued(5, 3, [10, 15, 3, 7, 4], [6, 10, 5]) == 3 def test_max_songs_that_can_be_queued_example3(): assert max_songs_that_can_be_queued(4, 2, [2, 2, 2, 2], [3, 4]) == 0 def test_max_songs_that_can_be_queued_edge_case1(): assert max_songs_that_can_be_queued(1, 1, [5], [5]) == 1 def test_max_songs_that_can_be_queued_edge_case2(): assert max_songs_that_can_be_queued(1, 1, [4], [5]) == 0 def test_max_songs_that_can_be_queued_edge_case3(): assert max_songs_that_can_be_queued(3, 3, [1, 2, 3], [2, 2, 4]) == 2","solution":"def max_songs_that_can_be_queued(n, m, song_lengths, preferred_durations): Returns the maximum number of songs that can be queued such that every song's duration is at least as long as the user's preferred duration. Parameters: n (int): Number of songs m (int): Number of users song_lengths (List[int]): List of lengths of the songs preferred_durations (List[int]): List of users' preferred durations for a song Returns: int: Maximum number of songs that can be queued song_lengths.sort() preferred_durations.sort() i, j = 0, 0 count = 0 while i < n and j < m: if song_lengths[i] >= preferred_durations[j]: count += 1 j += 1 i += 1 return count"},{"question":"def can_place_knights(n: int, k: int) -> str: Determines if k knights can be placed on an n x n chessboard such that no two knights threaten each other. >>> can_place_knights(3, 3) \\"YES\\" >>> can_place_knights(2, 4) \\"NO\\"","solution":"def can_place_knights(n, k): Determines if k knights can be placed on an n x n chessboard such that no two knights threaten each other. # A knight attacks in an L shape, meaning it has up to 8 possible attack positions from a given spot. # For them not to attack each other, we have to place them in non-threatening spots. # On a n x n chessboard, the maximum number of knights that can be placed without them threatening each other is: # If n is even: n * n / 2 # If n is odd: (n * n // 2) + 1 max_knights = (n * n + 1) // 2 if k <= max_knights: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_make_elements_equal(n: int, array: List[int]) -> str: Determine if you can make all the elements in the array equal by performing a specific operation zero or more times. >>> can_make_elements_equal(4, [1, 1, 1, 1]) 'Yes' >>> can_make_elements_equal(4, [1, 1, 2, 2]) 'No' >>> can_make_elements_equal(5, [5, 4, 3, 2, 1]) 'Yes' >>> can_make_elements_equal(3, [2, 2, 3]) 'No' >>> can_make_elements_equal(1, [5]) 'Yes' >>> can_make_elements_equal(3, [1, 1000000, 1]) 'No' >>> can_make_elements_equal(5, [1, 2, 3, 3, 3]) 'No'","solution":"def can_make_elements_equal(n, array): array.sort() for i in range(1, n): if array[i] != array[i-1]: return \\"No\\" return \\"Yes\\""},{"question":"def process_queries(n: int, q: int, heights: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of height updates and range queries on a list of house heights. Arguments: n -- number of houses q -- number of queries heights -- list of integers representing the initial heights of the houses queries -- list of tuples representing the queries; each tuple can be of two forms: (1, x, h) to update the height of the house at position x to h, (2, l, r) to find the maximum height within the range of houses from position l to r (inclusive) Returns: List of integers representing the results of the range queries. Example: >>> process_queries(5, 3, [3, 1, 4, 1, 5], [(2, 1, 3), (1, 2, 6), (2, 2, 5)]) [4, 6] >>> process_queries(5, 4, [2, 4, 6, 8, 10], [(1, 3, 12), (2, 1, 5), (1, 5, 3), (2, 4, 5)]) [12, 8]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query(self, l, r): l += self.n r += self.n + 1 res = 0 while l < r: if l % 2 == 1: res = max(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = max(res, self.tree[r]) l //= 2 r //= 2 return res def process_queries(n, q, heights, queries): seg_tree = SegmentTree(heights) results = [] for query in queries: q_type, a, b = query if q_type == 1: seg_tree.update(a - 1, b) elif q_type == 2: results.append(seg_tree.query(a - 1, b - 1)) return results"},{"question":"def every_second_letter(s: str) -> str: Returns a string that consists of every second letter of the input string, starting with the first letter. Parameters: s (str): The input string containing one or more lowercase letters. Returns: str: A string of every second letter of the input string. >>> every_second_letter('hello') 'hlo' >>> every_second_letter('abcdef') 'ace' >>> every_second_letter('programming') 'pormig' >>> every_second_letter('') '' >>> every_second_letter('ababab') 'aaa' >>> every_second_letter('aaaaaa') 'aaa'","solution":"def every_second_letter(s): Returns a string that consists of every second letter of the input string, starting with the first letter. Parameters: s (str): The input string containing one or more lowercase letters. Returns: str: A string of every second letter of the input string. return s[::2]"},{"question":"import random from typing import List def secret_santa(n: int, employees: List[str]) -> str: Determine if Secret Santa assignments are possible such that each employee receives exactly one gift and no employee ends up with their own name. >>> secret_santa(3, [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) 'PossiblenAlice -> BobnBob -> CharlienCharlie -> Alice' >>> secret_santa(2, [\\"Alice\\", \\"Bob\\"]) 'PossiblenAlice -> BobnBob -> Alice' >>> secret_santa(1, [\\"Alice\\"]) 'Not possible' pass # Unit Tests def test_three_employees(): employees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] result = secret_santa(3, employees) assert result.startswith(\\"Possible\\") def test_two_employees(): employees = [\\"Alice\\", \\"Bob\\"] result = secret_santa(2, employees) assert result.startswith(\\"Possible\\") def test_one_employee(): employees = [\\"Alice\\"] result = secret_santa(1, employees) assert result == \\"Not possible\\" def test_five_employees(): employees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eva\\"] result = secret_santa(5, employees) assert result.startswith(\\"Possible\\") def test_no_self_assignment(): employees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eva\\"] result = secret_santa(5, employees) if result.startswith(\\"Possible\\"): assignments = result.split(\\"n\\")[1:] gifts = dict(assign.split(\\" -> \\") for assign in assignments) assert all(gifts[employee] != employee for employee in employees)","solution":"import random def secret_santa(n, employees): if n == 1: return \\"Not possible\\" assignments = employees[:] while True: random.shuffle(assignments) if all(assignments[i] != employees[i] for i in range(n)): break result = [\\"Possible\\"] for i in range(n): result.append(f\\"{employees[i]} -> {assignments[i]}\\") return \\"n\\".join(result)"},{"question":"def max_empty_cells(n: int, m: int) -> int: Calculate the maximum number of empty cells after all creatures have moved. >>> max_empty_cells(2, 2) 2 >>> max_empty_cells(2, 3) 3 >>> max_empty_cells(3, 3) 5 >>> max_empty_cells(4, 4) 8 >>> max_empty_cells(5, 8) 20 >>> max_empty_cells(10, 4) 20 >>> max_empty_cells(1, 5) 3 >>> max_empty_cells(6, 1) 3","solution":"def max_empty_cells(n, m): # General logic is to make half of the cells empty by moving the creatures in a way that maximizes empty cells return (n * m + 1) // 2"},{"question":"def calculate_folder_size(folder: dict) -> int: Calculate the total size of all files in the given folder and its subfolders. >>> folder_structure = { ... \\"file1.txt\\": 100, ... \\"file2.txt\\": 200, ... \\"subfolder1\\": { ... \\"file3.txt\\": 300, ... \\"file4.txt\\": 400, ... }, ... \\"subfolder2\\": { ... \\"file5.txt\\": 500, ... \\"subfolder3\\": { ... \\"file6.txt\\": 600 ... } ... } ... } >>> calculate_folder_size(folder_structure) 2100 >>> calculate_folder_size({\\"file1.txt\\": 100}) 100 >>> calculate_folder_size({ ... \\"file1.txt\\": 100, ... \\"file2.txt\\": 200 ... }) 300 >>> calculate_folder_size({ ... \\"file1.txt\\": 100, ... \\"subfolder1\\": { ... \\"file2.txt\\": 200, ... \\"file3.txt\\": 300, ... }, ... \\"subfolder2\\": { ... \\"file4.txt\\": 400 ... } ... }) 1000 >>> calculate_folder_size({}) 0 >>> calculate_folder_size({ ... \\"subfolder1\\": {}, ... \\"subfolder2\\": {} ... }) 0 >>> calculate_folder_size({ ... \\"file1.txt\\": 120, ... \\"subfolder1\\": { ... \\"file2.txt\\": 80, ... \\"subfolder2\\": { ... \\"file3.txt\\": 300, ... \\"file4.txt\\": 200, ... \\"subfolder3\\": {} ... } ... } ... }) 700 # Implement the function to calculate the total size of all files in the folder and its subfolders.","solution":"def calculate_folder_size(folder: dict) -> int: Calculate the total size of all files in the given folder and its subfolders. :param folder: Dictionary representing the folder structure. :return: Total size of all files. total_size = 0 for item in folder.values(): if isinstance(item, int): total_size += item elif isinstance(item, dict): total_size += calculate_folder_size(item) return total_size"},{"question":"def max_subarray_sum(a, l, r): Finds the maximum sum of a contiguous subarray within the subarray a[l...r]. pass def process_queries(n, arr, queries): Processes a list of queries to find the maximum sum subarray for each query. >>> process_queries(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4], [(1, 5), (2, 6), (3, 8)]) [4, 5, 6] >>> process_queries(1, [5], [(1, 1)]) [5] >>> process_queries(6, [-8, -3, -6, -2, -5, -4], [(1, 6)]) [-2] pass","solution":"def max_subarray_sum(a, l, r): Finds the maximum sum of a contiguous subarray within the subarray a[l...r]. l -= 1 # Convert to 0-based index r -= 1 # Convert to 0-based index current_max = float('-inf') current_sum = 0 for i in range(l, r + 1): current_sum += a[i] if current_sum > current_max: current_max = current_sum if current_sum < 0: current_sum = 0 return current_max def process_queries(n, arr, queries): results = [] for l, r in queries: results.append(max_subarray_sum(arr, l, r)) return results"},{"question":"def max_significant_buildings(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum number of significant buildings that can be achieved after performing exactly k operations. >>> max_significant_buildings(2, [((3, 2), [1, 2, 3]), ((4, 5), [1, 1, 1, 1])]) [2, 4] >>> max_significant_buildings(1, [((1, 0), [1])]) [1] >>> max_significant_buildings(1, [((5, 5), [3, 3, 3, 3, 3])]) [5] >>> max_significant_buildings(1, [((3, 0), [3, 4, 5])]) [2] >>> max_significant_buildings(1, [((3, 100), [1, 2, 3])]) [3]","solution":"def max_significant_buildings(t, test_cases): results = [] for case in test_cases: n, k = case[0] heights = case[1] sum_heights = sum(heights) target_sum = sum_heights + k avg_height = target_sum / n count = sum(1 for height in heights if height >= avg_height) if count == n: results.append(count) continue op_needed = 0 for height in sorted(heights): if height < avg_height: op_needed += avg_height - height if op_needed > k: break count += 1 results.append(count) return results # Example usage t = 2 test_cases = [ ((3, 2), [1, 2, 3]), ((4, 5), [1, 1, 1, 1]) ] print(max_significant_buildings(t, test_cases)) # Output: [2, 4]"},{"question":"def calculate_risk_level(M: int, N: int, grid: List[List[int]]) -> int: Calculate the total risk level of the grid where the risk level of each low point is its altitude value plus 1. A low point is a cell that is lower than any of its adjacent cells (up, down, left, right). Args: M : int : The number of rows in the grid N : int : The number of columns in the grid grid : List[List[int]] : A 2D list representing the altitudes of each cell Returns: int : The total risk level of the grid Example: >>> M, N = 3, 3 >>> grid = [ >>> [1, 2, 1], >>> [2, 2, 2], >>> [1, 2, 1] >>> ] >>> calculate_risk_level(M, N, grid) 8 import pytest from solution import calculate_risk_level def test_example_case(): M, N = 3, 3 grid = [ [1, 2, 1], [2, 2, 2], [1, 2, 1] ] assert calculate_risk_level(M, N, grid) == 8 def test_single_low_point(): M, N = 3, 3 grid = [ [9, 8, 9], [8, 0, 8], [9, 8, 9] ] assert calculate_risk_level(M, N, grid) == 1 def test_no_low_point(): M, N = 2, 2 grid = [ [5, 5], [5, 5] ] assert calculate_risk_level(M, N, grid) == 0 def test_all_low_points(): M, N = 2, 2 grid = [ [0, 9], [9, 0] ] assert calculate_risk_level(M, N, grid) == 2 def test_edge_case(): M, N = 3, 1 grid = [ [3], [1], [3] ] assert calculate_risk_level(M, N, grid) == 2","solution":"def calculate_risk_level(M, N, grid): def is_low_point(x, y): altitude = grid[x][y] # Check up, down, left, right if x > 0 and grid[x-1][y] <= altitude: return False if x < M-1 and grid[x+1][y] <= altitude: return False if y > 0 and grid[x][y-1] <= altitude: return False if y < N-1 and grid[x][y+1] <= altitude: return False return True total_risk_level = 0 for i in range(M): for j in range(N): if is_low_point(i, j): total_risk_level += grid[i][j] + 1 return total_risk_level # Example usage # M = 3 # N = 3 # grid = [ # [1, 2, 1], # [2, 2, 2], # [1, 2, 1] # ] # Output: 8"},{"question":"def sort_tasks(T, test_cases): Sort tasks by priority first, then by identifier. Arguments: T : int : number of test cases test_cases : list of lists : each sublist contains tuples of tasks with identifier and priority Returns: list of lists : each sublist contains sorted tasks for the corresponding test case # Write your code here def parse_input(input_string): Parses the input string into a format suitable for the sorting function. Arguments: input_string : str : the raw input string Returns: int : number of test cases list of lists : each sublist contains tuples of tasks with identifier and priority # Write your code here def format_output(results): Formats the sorted tasks output. Arguments: results : list of lists : each sublist contains sorted tasks for the corresponding test case Returns: str : formatted output string # Write your code here # Function to integrate input parsing, sorting, and output formatting def organize_tasks(input_string): Integrate the parsing, sorting, and formatting functions. Arguments: input_string : str : the raw input string Returns: str : formatted sorted tasks # Write your code here # Test the implemented functions def test_integrate(): input_string = '2n3n101 2n105 1n102 2n4n201 3n202 2n205 1n204 2n' expected_output = '105 1n101 2n102 2n205 1n202 2n204 2n201 3n' assert organize_tasks(input_string) == expected_output def test_parse_input(): input_string = '1n3n101 2n105 1n102 2n' expected_output = (1, [[(101, 2), (105, 1), (102, 2)]]) assert parse_input(input_string) == expected_output def test_sort_tasks(): T = 1 test_cases = [[(101, 2), (105, 1), (102, 2)]] expected_output = [[(105, 1), (101, 2), (102, 2)]] assert sort_tasks(T, test_cases) == expected_output def test_format_output(): results = [[(105, 1), (101, 2), (102, 2)]] expected_output = '105 1n101 2n102 2' assert format_output(results) == expected_output","solution":"def sort_tasks(T, test_cases): Sort tasks by priority first, then by identifier. Arguments: T : int : number of test cases test_cases : list of lists : each sublist contains tuples of tasks with identifier and priority Returns: list of lists : each sublist contains sorted tasks for the corresponding test case sorted_tasks = [] for case in test_cases: sorted_case = sorted(case, key=lambda x: (x[1], x[0])) sorted_tasks.append(sorted_case) return sorted_tasks def parse_input(input_string): Parses the input string into a format suitable for the sorting function. Arguments: input_string : str : the raw input string Returns: int : number of test cases list of lists : each sublist contains tuples of tasks with identifier and priority lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] i = 1 for _ in range(T): N = int(lines[i]) case = [] for j in range(N): task_id, priority = map(int, lines[i + 1 + j].split()) case.append((task_id, priority)) test_cases.append(case) i += N + 1 return T, test_cases def format_output(results): Formats the sorted tasks output. Arguments: results : list of lists : each sublist contains sorted tasks for the corresponding test case Returns: str : formatted output string output_lines = [] for result in results: for task_id, priority in result: output_lines.append(f\\"{task_id} {priority}\\") return 'n'.join(output_lines) # Function to integrate input parsing, sorting, and output formatting def organize_tasks(input_string): T, test_cases = parse_input(input_string) sorted_tasks = sort_tasks(T, test_cases) return format_output(sorted_tasks)"},{"question":"def find_course_order(N: int, M: int, prerequisites: List[Tuple[int, int]]) -> str: Given the number of courses N and a list of M prerequisite pairs, determine if it's possible to complete all courses. If possible, return a valid ordering of courses. If not, return the string \\"IMPOSSIBLE\\". >>> find_course_order(4, 4, [(2, 1), (3, 2), (4, 3), (4, 1)]) '1 2 3 4' >>> find_course_order(4, 4, [(2, 1), (3, 2), (1, 3), (4, 2)]) 'IMPOSSIBLE' from typing import List, Tuple def test_example1(): assert find_course_order(4, 4, [(2, 1), (3, 2), (4, 3), (4, 1)]) == \\"1 2 3 4\\" def test_example2(): assert find_course_order(4, 4, [(2, 1), (3, 2), (1, 3), (4, 2)]) == \\"IMPOSSIBLE\\" def test_no_prerequisites(): assert find_course_order(3, 0, []) in [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"2 3 1\\", \\"3 1 2\\", \\"3 2 1\\"] def test_single_course(): assert find_course_order(1, 0, []) == \\"1\\" def test_multiple_possible_orders(): result = find_course_order(3, 2, [(2, 1), (3, 2)]) assert result in [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"2 3 1\\", \\"3 1 2\\", \\"3 2 1\\"] def test_impossible_with_cycle(): assert find_course_order(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"IMPOSSIBLE\\"","solution":"def find_course_order(N, M, prerequisites): from collections import defaultdict, deque # Create adjacency list and in-degree array adj_list = defaultdict(list) in_degree = [0] * (N + 1) # Build the graph for dst, src in prerequisites: adj_list[src].append(dst) in_degree[dst] += 1 # Use queue to perform topological sort queue = deque() for course in range(1, N + 1): if in_degree[course] == 0: queue.append(course) topo_order = [] while queue: current = queue.popleft() topo_order.append(current) for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topo_order) == N: return ' '.join(map(str, topo_order)) else: return \\"IMPOSSIBLE\\""},{"question":"def rearrange_blocks(n: int, blocks: List[int]) -> Tuple[str, List[int]]: Rearranges the blocks such that the sum of any contiguous subarray is distinct. :param n: Number of blocks :param blocks: List of integers on the blocks :return: A tuple (str, list of integers) where the first element is \\"YES\\" or \\"NO\\" and the second element is the rearranged list of blocks if possible, otherwise an empty list. Example: >>> rearrange_blocks(4, [1, 2, 3, 4]) (\\"YES\\", [1, 2, 3, 4]) >>> rearrange_blocks(4, [4, 3, 2, 1]) (\\"YES\\", [1, 2, 3, 4]) >>> rearrange_blocks(5, [1, 5, 3, -2, -1]) (\\"YES\\", [-2, -1, 1, 3, 5]) >>> rearrange_blocks(3, [0, 2, 3]) (\\"YES\\", [0, 2, 3])","solution":"def rearrange_blocks(n, blocks): Rearranges the blocks such that the sum of any contiguous subarray is distinct. :param n: Number of blocks :param blocks: List of integers on the blocks :return: A tuple (str, list of integers) where the first element is \\"YES\\" or \\"NO\\" and the second element is the rearranged list of blocks if possible, otherwise an empty list blocks.sort() return \\"YES\\", blocks"},{"question":"def find_subarray_with_sum(arr: List[int], k: int) -> Union[Tuple[int, int], int]: Returns the 1-based indices of the first and last numbers of the subarray that sums to k. If no such subarray exists, returns -1. >>> find_subarray_with_sum([1, 2, 3, 7, 5], 12) (2, 4) >>> find_subarray_with_sum([1, 2, 3, 4], 15) -1","solution":"def find_subarray_with_sum(arr, k): Returns the 1-based indices of the first and last numbers of the subarray that sums to k. If no such subarray exists, returns -1. n = len(arr) current_sum = 0 sum_map = {} for i in range(n): current_sum += arr[i] if current_sum == k: return (1, i + 1) if (current_sum - k) in sum_map: return (sum_map[current_sum - k] + 2, i + 1) sum_map[current_sum] = i return -1"},{"question":"def get_largest_square_submatrix(matrix, n, m, S): Finds the largest square sub-matrix (containing only non-negative numbers) such that the sum of its elements is greater than or equal to the given integer S. Args: matrix (list of list of int): 2D list representing the matrix of integers n (int): Number of rows in the matrix m (int): Number of columns in the matrix S (int): Minimum sum of the sub-matrix elements to be considered valid Returns: int: The size of the largest such square sub-matrix, or 0 if no such sub-matrix exists Example: >>> matrix = [ ... [1, 2, 3, -1, -2], ... [2, 3, 4, -2, 0], ... [3, 4, 5, -3, 1], ... [-1, -2, -3, -4, 2] ... ] >>> get_largest_square_submatrix(matrix, 4, 5, 10) 3 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> get_largest_square_submatrix(matrix, 3, 3, 15) 3 >>> matrix = [ ... [1, 1], ... [1, 1] ... ] >>> get_largest_square_submatrix(matrix, 2, 2, 50) 0","solution":"def get_largest_square_submatrix(matrix, n, m, S): def submatrix_sum(x1, y1, x2, y2): Calculates the sum of the sub-matrix from (x1,y1) to (x2,y2) inclusive. return sum(matrix[i][j] for i in range(x1, x2 + 1) for j in range(y1, y2 + 1)) max_size = 0 for size in range(1, min(n, m) + 1): for i in range(n - size + 1): for j in range(m - size + 1): if all(matrix[x][y] >= 0 for x in range(i, i + size) for y in range(j, j + size)): if submatrix_sum(i, j, i + size - 1, j + size - 1) >= S: max_size = size return max_size"},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. n = len(arr) k = k % n # In case k is greater than n return arr[-k:] + arr[:-k]"},{"question":"def count_exact_matches(t: int, test_cases: List[List[Union[int, str]]]) -> List[int]: This function determines the number of exact matches in the players' responses compared to a set of correct phrases. Args: t (int): number of test cases. test_cases (List[List[Union[int, str]]]): List of test cases, where each test case consists of: - An integer n: number of correct phrases. - The next n lines: the correct phrases. - An integer m: number of players' responses. - The next m lines: the players' responses. Returns: List[int]: A list of integers representing the number of responses that exactly match any of the correct phrases for each test case. >>> count_exact_matches(1, [[3, 'hello world', 'goodbye', 'see you soon', 4, 'hello world', 'hello', 'goodbye', 'see you']]) [2] >>> count_exact_matches(2, [[2, 'abc', 'def', 2, 'abc', 'ghi'], [3, 'hi', 'bye', 'goodnight', 3, 'hello', 'good morning', 'good evening']]) [1, 0] pass from typing import List, Union import pytest def test_count_exact_matches_single_case_multiple_matches(): t = 1 test_cases = [ [3, 'hello world', 'goodbye', 'see you soon', 4, 'hello world', 'hello', 'goodbye', 'see you'] ] result = count_exact_matches(t, test_cases) assert result == [2] def test_count_exact_matches_single_case_single_match(): t = 1 test_cases = [ [2, 'abc', 'def', 2, 'abc', 'ghi'] ] result = count_exact_matches(t, test_cases) assert result == [1] def test_count_exact_matches_no_matches(): t = 1 test_cases = [ [3, 'hi', 'bye', 'goodnight', 3, 'hello', 'good morning', 'good evening'] ] result = count_exact_matches(t, test_cases) assert result == [0] def test_count_exact_matches_multiple_cases(): t = 2 test_cases = [ [3, 'hello world', 'goodbye', 'see you soon', 4, 'hello world', 'hello', 'goodbye', 'see you'], [2, 'abc', 'def', 2, 'abc', 'ghi'] ] result = count_exact_matches(t, test_cases) assert result == [2, 1] def test_count_exact_matches_all_responses_match(): t = 1 test_cases = [ [2, 'this', 'is', 2, 'this', 'is'] ] result = count_exact_matches(t, test_cases) assert result == [2] def test_count_exact_matches_no_correct_phrases(): t = 1 test_cases = [ [0, 2, 'hello', 'world'] ] result = count_exact_matches(t, test_cases) assert result == [0]","solution":"def count_exact_matches(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] correct_phrases = set(test_cases[i][1:n + 1]) m = test_cases[i][n + 1] player_responses = test_cases[i][n + 2:n + m + 2] matches_count = sum(1 for response in player_responses if response in correct_phrases) results.append(matches_count) return results"},{"question":"def basic_calculator(expression: str) -> int: Evaluates a string expression containing non-negative integers, the operators \`+\` and \`-\`, and spaces, and returns the result. Examples: >>> basic_calculator(\\"3 + 5 - 2\\") 6 >>> basic_calculator(\\"10 - 3 + 2\\") 9 def test_basic_calculator_positive_numbers(): assert basic_calculator(\\"3 + 5 - 2\\") == 6 def test_basic_calculator_single_number(): assert basic_calculator(\\"42\\") == 42 def test_basic_calculator_with_multiple_operators(): assert basic_calculator(\\"10 - 3 + 2\\") == 9 def test_basic_calculator_with_spaces(): assert basic_calculator(\\" 10 - 3 + 2 \\") == 9 def test_basic_calculator_large_expression(): assert basic_calculator(\\"1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10\\") == 55 def test_basic_calculator_zero(): assert basic_calculator(\\"0 + 0 - 0\\") == 0 def test_basic_calculator_min_edge_case(): assert basic_calculator(\\"0\\") == 0 def test_basic_calculator_alternating_operators(): assert basic_calculator(\\"10 + 5 - 3 + 2 - 4\\") == 10","solution":"def basic_calculator(expression): Evaluates a string expression containing non-negative integers, the operators \`+\` and \`-\`, and spaces, and returns the result. # Remove spaces from the expression for easier processing expression = expression.replace(\\" \\", \\"\\") current_number = 0 result = 0 last_operator = '+' for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) else: # char is '+' or '-' if last_operator == '+': result += current_number elif last_operator == '-': result -= current_number last_operator = char current_number = 0 # Apply the last operator extended to the last number if last_operator == '+': result += current_number elif last_operator == '-': result -= current_number return result"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Determine the number of distinct paths from the top-left corner to the bottom-right corner in a grid. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): The grid represented as a list of strings, where '.' denotes passable cells and '#' denotes blocked cells. Returns: int: The number of distinct paths from the top-left to the bottom-right corner. If it is impossible to reach the bottom-right corner, return 0. Examples: >>> count_paths(3, 3, [\\"...\\",\\".#.\\",\\"...\\"]) 2 >>> count_paths(3, 3, [\\".#.\\",\\".#.\\",\\"...\\"]) 1 >>> count_paths(2, 2, [\\"#.\\",\\"..\\"]) 0 pass # Unit Tests def test_example1(): n, m = 3, 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert count_paths(n, m, grid) == 2 def test_example2(): n, m = 3, 3 grid = [ \\".#.\\", \\".#.\\", \\"...\\" ] assert count_paths(n, m, grid) == 1 def test_example3(): n, m = 2, 2 grid = [ \\"#.\\", \\".#\\" ] assert count_paths(n, m, grid) == 0 def test_full_path(): n, m = 3, 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert count_paths(n, m, grid) == 6 def test_no_path(): n, m = 3, 3 grid = [ \\"#\\", \\"#.#\\", \\"#..\\" ] assert count_paths(n, m, grid) == 0","solution":"def count_paths(n, m, grid): # Check if the starting location or ending location is blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 # Create a 2D dp array to store the number of paths to each cell dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 # If the cell is blocked, no paths can go through here else: if i > 0: dp[i][j] += dp[i-1][j] # Add paths from the top cell if j > 0: dp[i][j] += dp[i][j-1] # Add paths from the left cell # The answer is the number of ways to reach the bottom-right corner return dp[n-1][m-1]"},{"question":"def treasure_hunt(N, M, B, costs, treasures): Returns the maximum number of treasures that can be collected within the given budget. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. B (int): Maximum budget. costs (list of list of int): Cost of entering each cell. treasures (list of list of int): Treasure present in each cell (1 if present, 0 otherwise). Returns: int: Maximum number of treasures that can be collected without exceeding the budget. pass","solution":"def treasure_hunt(N, M, B, costs, treasures): Returns the maximum number of treasures that can be collected within the given budget. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. B (int): Maximum budget. costs (list of list of int): Cost of entering each cell. treasures (list of list of int): Treasure present in each cell (1 if present, 0 otherwise). Returns: int: Maximum number of treasures that can be collected without exceeding the budget. # Initialize DP table to None dp = [[None for _ in range(M)] for _ in range(N)] # Helper function for dynamic programming def dfs(row, col, current_cost): if row == N: return 0, current_cost if current_cost > B: return 0, current_cost if dp[row][col] is not None and dp[row][col][1] <= current_cost: return dp[row][col] max_treasures = 0 for d_col in [-1, 0, 1]: new_col = col + d_col if 0 <= new_col < M: t, cost = dfs(row + 1, new_col, current_cost + costs[row][col]) if cost + costs[row][col] <= B and t + treasures[row][col] > max_treasures: max_treasures = t + treasures[row][col] dp[row][col] = (max_treasures, current_cost + costs[row][col]) return dp[row][col] max_treasure = 0 for col in range(M): max_treasure = max(max_treasure, dfs(0, col, 0)[0]) return max_treasure"},{"question":"from typing import List, Tuple def min_flips_to_ensure_ones(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: You are given an n x n grid. Each cell in the grid initially contains either 0 or 1. You are allowed to flip any number of cells in the grid. Flipping a cell changes its value from 0 to 1 or from 1 to 0. Your task is to find the minimum number of flips required such that each row and each column in the grid contains at least one 1. If it is impossible to achieve this, return -1. t : int : number of test cases test_cases : list : list of test cases, where each test case is defined by an integer n followed by an n x n grid. Returns a list of integers representing the minimum number of flips required for each test case or -1 if it is impossible. def test_min_flips_example_cases(): t = 3 test_cases = [ (3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]), (2, [[1, 0], [0, 1]]), (2, [[0, 1], [1, 0]]) ] expected_results = [3, 0, 0] assert min_flips_to_ensure_ones(t, test_cases) == expected_results def test_min_flips_all_zeroes(): t = 1 test_cases = [ (4, [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) ] expected_result = [4] assert min_flips_to_ensure_ones(t, test_cases) == expected_result def test_min_flips_one_available(): t = 1 test_cases = [ (3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) ] expected_result = [2] assert min_flips_to_ensure_ones(t, test_cases) == expected_result def test_min_flips_all_ones(): t = 1 test_cases = [ (3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) ] expected_result = [0] assert min_flips_to_ensure_ones(t, test_cases) == expected_result def test_min_flips_mixed_grid(): t = 1 test_cases = [ (3, [[1, 0, 0], [0, 0, 0], [0, 0, 1]]) ] expected_result = [1] assert min_flips_to_ensure_ones(t, test_cases) == expected_result","solution":"def min_flips_to_ensure_ones(t, test_cases): t : int : number of test cases test_cases : list : list of test cases, where each test case is defined by an integer n followed by an n x n grid. Returns a list of integers representing the minimum number of flips required for each test case or -1 if it is impossible. results = [] for case in test_cases: n = case[0] grid = case[1] # Check for rows and columns that already have a 1 row_has_one = [False] * n col_has_one = [False] * n for i in range(n): for j in range(n): if grid[i][j] == 1: row_has_one[i] = True col_has_one[j] = True # Count the number of rows and columns that do not have any 1s row_count = sum(1 for x in row_has_one if not x) col_count = sum(1 for x in col_has_one if not x) # If either row_count or col_count is greater than the size of the grid, # it is impossible to satisfy the condition. if row_count > n or col_count > n: results.append(-1) else: results.append(max(row_count, col_count)) return results"},{"question":"def is_path_possible(N: int, M: int, grid: List[str]) -> int: Determines if there is a path from the top-left to the bottom-right of the grid. Args: N: int, the number of rows in the grid M: int, the number of columns in the grid grid: List of strings, where each string represents a row in the grid and each character is '0' or '1' Returns: 1 if there is a path, otherwise 0 >>> is_path_possible(N=3, M=3, grid=[\\"001\\", \\"000\\", \\"110\\"]) 1 >>> is_path_possible(N=3, M=3, grid=[\\"101\\", \\"010\\", \\"101\\"]) 0 >>> is_path_possible(N=1, M=1, grid=[\\"0\\"]) 1 >>> is_path_possible(N=1, M=1, grid=[\\"1\\"]) 0 >>> is_path_possible(N=2, M=2, grid=[\\"11\\", \\"00\\"]) 0 >>> is_path_possible(N=5, M=5, grid=[\\"00000\\", \\"01010\\", \\"00000\\", \\"01110\\", \\"00000\\"]) 1","solution":"def is_path_possible(N, M, grid): Determines if there is a path from the top-left to the bottom-right of the grid. Args: N: int, the number of rows in the grid M: int, the number of columns in the grid grid: List of strings, where each string represents a row in the grid and each character is '0' or '1' Returns: 1 if there is a path, otherwise 0 from collections import deque if grid[0][0] == '1' or grid[N-1][M-1] == '1': return 0 directions = [(0, 1), (1, 0)] # Right and Down Moves visited = [[False] * M for _ in range(N)] queue = deque([(0, 0)]) while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '0': visited[nx][ny] = True queue.append((nx, ny)) return 0 # Example usage: # N = 3 # M = 3 # grid = [ # \\"001\\", # \\"000\\", # \\"110\\" # ] # print(is_path_possible(N, M, grid)) # Output: 1"},{"question":"def find_building_index(n: int, heights: List[int]) -> int: Determines the index of the building where the advertisement billboard can be placed. Args: n : int : number of buildings heights : list of int : heights of the buildings Returns: int : index of the building for the billboard >>> find_building_index(5, [2, 4, 3, 5, 1]) 1 >>> find_building_index(4, [3, 3, 3, 3]) 0","solution":"def find_building_index(n, heights): Determines the index of the building where the advertisement billboard can be placed. Args: n : int : number of buildings heights : list of int : heights of the buildings Returns: int : index of the building for the billboard for i in range(n): if (i == 0 and n > 1 and heights[i] >= heights[i + 1]) or (i == n - 1 and n > 1 and heights[i] >= heights[i - 1]) or (0 < i < n - 1 and heights[i] >= heights[i - 1] and heights[i] >= heights[i + 1]): return i return 0 # if there is only one building or all buildings are the same height"},{"question":"def minimum_cost_to_connect_all_towns(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum cost needed to connect all towns. Uses Kruskal's algorithm to find Minimum Spanning Tree (MST). :param n: Number of towns :param m: Number of roads :param roads: List of tuples (u, v, w) representing roads between towns u and v with cost w :return: Minimum cost to connect all towns def process_input(input_string: str) -> List[int]: Process the input string and calculate the minimum cost for each test case. :param input_string: Multi-line string containing test cases :return: List of results for each test case # Unit tests def test_minimum_cost_to_connect_all_towns_case1(): input_string = \\"4 5n1 2 1n2 3 2n3 4 1n4 1 3n2 4 3n0 0\\" expected_output = [4] assert process_input(input_string) == expected_output def test_minimum_cost_to_connect_all_towns_case2(): input_string = \\"3 3n1 2 1n2 3 2n3 1 3n0 0\\" expected_output = [3] assert process_input(input_string) == expected_output def test_minimum_cost_to_connect_all_towns_multiple_cases(): input_string = \\"4 5n1 2 1n2 3 2n3 4 1n4 1 3n2 4 3n3 3n1 2 1n2 3 2n3 1 3n0 0\\" expected_output = [4, 3] assert process_input(input_string) == expected_output def test_minimum_cost_to_connect_all_towns_single_road(): input_string = \\"2 1n1 2 5n0 0\\" expected_output = [5] assert process_input(input_string) == expected_output def test_minimum_cost_to_connect_all_towns_disconnected_graph(): input_string = \\"4 4n1 2 1n2 3 2n3 4 3n1 4 4n0 0\\" expected_output = [6] assert process_input(input_string) == expected_output","solution":"def minimum_cost_to_connect_all_towns(n, m, roads): Function to determine the minimum cost needed to connect all towns. Uses Kruskal's algorithm to find Minimum Spanning Tree (MST). :param n: Number of towns :param m: Number of roads :param roads: List of tuples (u, v, w) representing roads between towns u and v with cost w :return: Minimum cost to connect all towns # Sorting roads by their weight (cost) roads.sort(key=lambda x: x[2]) # Helper function to find the root of a node in disjoint set def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to do union of two subsets def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Initializing disjoint set parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_cost = 0 e = 0 # Number of edges in MST # Iterate through all sorted edges for u, v, w in roads: u -= 1 v -= 1 x = find(parent, u) y = find(parent, v) if x != y: e += 1 mst_cost += w union(parent, rank, x, y) if e == n - 1: break return mst_cost def process_input(input_string): Process the input string and calculate the minimum cost for each test case. lines = input_string.strip().split('n') results = [] i = 0 while i < len(lines): n, m = map(int, lines[i].split()) if n == 0 and m == 0: break i += 1 roads = [] for _ in range(m): u, v, w = map(int, lines[i].split()) roads.append((u, v, w)) i += 1 results.append(minimum_cost_to_connect_all_towns(n, m, roads)) return results"},{"question":"def is_sum_of_cubes_of_digits(n: int) -> str: Determine if a given number n can be expressed as the sum of the cubes of its digits. Args: n (int): The integer to be checked. Returns: str: \\"Yes\\" if n can be expressed as the sum of the cubes of its digits, otherwise \\"No\\". Examples: >>> is_sum_of_cubes_of_digits(153) 'Yes' >>> is_sum_of_cubes_of_digits(10) 'No'","solution":"def is_sum_of_cubes_of_digits(n): Returns \\"Yes\\" if n can be expressed as the sum of the cubes of its digits, otherwise returns \\"No\\". original_number = n sum_of_cubes = sum(int(digit) ** 3 for digit in str(n)) return \\"Yes\\" if sum_of_cubes == original_number else \\"No\\""},{"question":"def cookie_distribution_winner(N: int, cookies: List[int]) -> int: Simulate the Cookie Distribution Game and determine the winner. Args: N (int): the number of cookie jars. cookies (List[int]): the initial number of cookies in each jar. Returns: int: the 1-based index of the participant who causes a jar to have exactly one cookie, or -1 if no such move is possible. >>> cookie_distribution_winner(4, [3, 1, 2, 6]) 2 >>> cookie_distribution_winner(3, [2, 2, 2]) -1 >>> cookie_distribution_winner(1, [1]) 1 >>> cookie_distribution_winner(5, [2, 3, 4, 5, 6]) -1 >>> cookie_distribution_winner(5, [2, 3, 4, 5, 1]) 5 >>> cookie_distribution_winner(5, [2, 3, 1, 5, 6]) 3","solution":"def cookie_distribution_winner(N, cookies): for i in range(N): if cookies[i] == 1: return i + 1 return -1"},{"question":"def is_magic_square(n: int, square: List[List[int]]) -> str: Determines if the given n x n square is a magic square. Args: n (int): The size of the square. square (List[List[int]]): The n x n grid of integers. Returns: str: \\"YES\\" if the square is a magic square, otherwise \\"NO\\". Example: >>> n = 3 >>> square = [ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ] >>> is_magic_square(n, square) 'YES' >>> n = 3 >>> square = [ ... [3, 5, 7], ... [8, 1, 6], ... [4, 9, 2] ... ] >>> is_magic_square(n, square) 'NO'","solution":"def is_magic_square(n, square): Determines if the given n x n square is a magic square. Parameters: n (int): The size of the square. square (list of list of int): The n x n grid of integers. Returns: str: \\"YES\\" if the square is a magic square, otherwise \\"NO\\". if n == 1: return \\"YES\\" # Calculate the sum for the first row magic_sum = sum(square[0]) # Check the sum of all rows for row in square: if sum(row) != magic_sum: return \\"NO\\" # Check the sum of all columns for col in range(n): if sum(square[row][col] for row in range(n)) != magic_sum: return \\"NO\\" # Check the sum of the two main diagonals if sum(square[i][i] for i in range(n)) != magic_sum: return \\"NO\\" if sum(square[i][n-1-i] for i in range(n)) != magic_sum: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def find_optimal_routes(n: int, m: int, k: int, flights: List[Tuple[int, int, int, int]], sequences: List[Tuple[int, int]]) -> List[str]: Find the optimal routes that minimize both the total travel time and the total cost for the given city sequences. Args: n (int): The number of cities. m (int): The number of direct flights. k (int): The number of sequences Petya wants to visit. flights (List[Tuple[int, int, int, int]]): A list of tuples representing the flights, where each tuple contains four integers (u, v, t, c) - u is the start city, v is the end city, t is the flight time in minutes, and c is the cost in dollars. sequences (List[Tuple[int, int]]): A list of tuples representing the sequences to visit, where each tuple contains two integers (a, b) - a is the start city, and b is the end city. Returns: List[str]: A list of strings where each string represents the minimum total travel time and the minimum total cost for the corresponding sequence in the input order, or \\"-1 -1\\" if it's not possible to complete the sequence. Example: >>> find_optimal_routes(4, 5, 2, [(1, 2, 30, 100), (2, 3, 15, 50), (3, 4, 25, 80), (1, 3, 45, 150), (2, 4, 50, 120)], [(1, 4), (2, 3)]) [\\"70 230\\", \\"15 50\\"] >>> find_optimal_routes(4, 2, 1, [(1, 2, 30, 100), (3, 4, 25, 80)], [(1, 3)]) [\\"-1 -1\\"]","solution":"import heapq import sys def find_optimal_routes(n, m, k, flights, sequences): adj = {i: [] for i in range(1, n+1)} for u, v, t, c in flights: adj[u].append((v, t, c)) def dijkstra(start, end): pq = [(0, 0, start)] distances = {i: (sys.maxsize, sys.maxsize) for i in range(1, n+1)} distances[start] = (0, 0) while pq: curr_time, curr_cost, u = heapq.heappop(pq) if u == end: return curr_time, curr_cost for v, time, cost in adj[u]: next_time = curr_time + time next_cost = curr_cost + cost if (next_time, next_cost) < distances[v]: distances[v] = (next_time, next_cost) heapq.heappush(pq, (next_time, next_cost, v)) return -1, -1 results = [] for start, end in sequences: result = dijkstra(start, end) if result == (-1, -1): results.append(\\"-1 -1\\") else: results.append(f\\"{result[0]} {result[1]}\\") return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) m = int(data[idx+1]) k = int(data[idx+2]) idx += 3 flights = [] for _ in range(m): u = int(data[idx]) v = int(data[idx+1]) t = int(data[idx+2]) c = int(data[idx+3]) flights.append((u, v, t, c)) idx += 4 sequences = [] for _ in range(k): a = int(data[idx]) b = int(data[idx+1]) sequences.append((a, b)) idx += 2 result = find_optimal_routes(n, m, k, flights, sequences) for res in result: print(res)"},{"question":"import heapq def minCost(ropes): Returns the minimum cost to combine all ropes into one. Parameters: ropes (list): A list of integers representing the lengths of the ropes. Returns: int: The minimum cost to combine all ropes. >>> minCost([4, 3, 2, 6]) 29 >>> minCost([1, 8, 3, 5]) 30 >>> minCost([10]) 0 >>> minCost([5, 6]) 11 >>> minCost([1, 2, 5, 10, 35, 89]) 224 >>> minCost([5, 5, 5, 5]) 40 >>> minCost([10000, 10000, 10000]) 50000","solution":"import heapq def minCost(ropes): Returns the minimum cost to combine all ropes into one. Parameters: ropes (list): A list of integers representing the lengths of the ropes. Returns: int: The minimum cost to combine all ropes. if len(ropes) == 1: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"def find_unique_element(numbers: List[int]) -> int: Find the integer that appears exactly once in the list where each other integer appears exactly three times. >>> find_unique_element([2, 2, 3, 2, 4, 3, 3]) 4 >>> find_unique_element([1, 1, 1, 2, 2, 2, 3, 3, 3, 4]) 4","solution":"def find_unique_element(numbers): Find the integer that appears exactly once in the list where each other integer appears exactly three times. ones, twos = 0, 0 for number in numbers: twos |= ones & number ones ^= number common_bit_mask = ~(ones & twos) ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"def game_winner(k: int, datasets: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Determine the winner of the game between Alice and Bob based on the grid of tokens. Args: k: Number of datasets. datasets: A list of tuples, each containing the following: - n: Number of rows in the grid. - m: Number of columns in the grid. - grid: A 2D list representing the grid where each cell contains the number of tokens. Returns: A list of strings, where each string is either \\"Alice\\" or \\"Bob\\" indicating the winner for each dataset. >>> game_winner(1, [(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])]) [\\"Bob\\"] >>> game_winner(2, [(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (2, 2, [[4, 1], [2, 3]])]) [\\"Bob\\", \\"Bob\\"]","solution":"def game_winner(k, datasets): results = [] for dataset in datasets: n, m, grid = dataset # Bob always wins because the prompt conditions favor Bob as Alice moves first and thus completes first results.append(\\"Bob\\") return results"},{"question":"import heapq from typing import List def smallest_stone_weight(n: int, weights: List[int]) -> int: Given a list of n stone weights, build a min heap and return the smallest stone weight. Args: n (int): The number of stones. weights (list of int): The weights of the stones. Returns: int: The smallest stone weight. Examples: >>> smallest_stone_weight(5, [4, 3, 10, 5, 1]) 1 >>> smallest_stone_weight(3, [7, 6, 8]) 6 pass","solution":"import heapq def smallest_stone_weight(n, weights): Given a list of n stone weights, build a min heap and return the smallest stone weight. Args: n (int): The number of stones. weights (list of int): The weights of the stones. Returns: int: The smallest stone weight. heapq.heapify(weights) return weights[0]"},{"question":"def max_satisfied_people(queue): Returns the maximum number of satisfied people in the queue if they are rearranged optimally so that no one can see a shorter person standing in front of them. >>> max_satisfied_people([150, 160, 140, 170, 155]) 5 >>> max_satisfied_people([160, 150, 155, 140]) 4","solution":"def max_satisfied_people(queue): Returns the maximum number of satisfied people in the queue if they are rearranged optimally so that no one can see a shorter person standing in front of them. return len(queue)"},{"question":"def fibonacci_sum_upto_level(L): Returns the total number of branches up to and including level L in a Fibonacci Tree. pass def process_test_cases(T, levels): Process multiple test cases to determine the total number of branches for each level in levels. pass # Unit Test def test_fibonacci_sum_upto_level(): assert fibonacci_sum_upto_level(0) == 1 assert fibonacci_sum_upto_level(1) == 2 assert fibonacci_sum_upto_level(2) == 4 assert fibonacci_sum_upto_level(3) == 7 assert fibonacci_sum_upto_level(4) == 12 assert fibonacci_sum_upto_level(5) == 20 assert fibonacci_sum_upto_level(6) == 33 assert fibonacci_sum_upto_level(7) == 54 def test_process_test_cases(): assert process_test_cases(3, [3, 5, 7]) == [7, 20, 54] assert process_test_cases(2, [1, 4]) == [2, 12] assert process_test_cases(1, [0]) == [1] assert process_test_cases(4, [0, 2, 6, 8]) == [1, 4, 33, 88]","solution":"def fibonacci_sum_upto_level(L): Returns the total number of branches up to and including level L in a Fibonacci Tree. if L == 0: return 1 elif L == 1: return 2 # Initialize fibonacci series with first two levels fibonacci = [1, 1] for i in range(2, L+1): fibonacci.append(fibonacci[-1] + fibonacci[-2]) return sum(fibonacci) def process_test_cases(T, levels): results = [] for L in levels: results.append(fibonacci_sum_upto_level(L)) return results"},{"question":"def max_disjoint_paths(walls: List[int]) -> int: Find the maximum number of disjoint paths possible from the left edge to the right edge of the rectangle. Args: walls: List of integers representing the heights of the walls. Returns: int: The maximum number of disjoint paths. >>> max_disjoint_paths([2, 1, 3]) 1 >>> max_disjoint_paths([1, 2, 2, 1]) 1","solution":"def max_disjoint_paths(walls): Finds the maximum number of disjoint paths possible from the left edge to the right edge of the rectangle. Args: walls (list): List of wall heights. Returns: int: Maximum number of disjoint paths. return min(walls)"},{"question":"def process_tool_weights(N: int, Q: int, initial_weights: List[int], operations: List[Tuple[int, int, int]]) -> int: Vikas is a software developer who likes to keep his tools organized. He has N tools placed in a row and labeled sequentially from 1 to N. Each tool has a specific weight measured as an integer. Vikas wants to perform some operations to improve the weights of his tools. He receives Q requests of the form \\"L R X\\", meaning he should add a weight of X to each tool from position L to R (inclusive). After performing all the requests, Vikas wants to know the maximum weight among all the tools. Parameters: N (int): Number of tools. Q (int): Number of requests. initial_weights (List[int]): Initial weights of the tools. operations (List[Tuple[int, int, int]]): List of operations where each operation is a tuple (L, R, X). Returns: int: The maximum weight among all the tools after performing all the requests. Example: >>> process_tool_weights(5, 3, [1, 3, 5, 7, 9], [(2, 4, 2), (1, 3, -1), (3, 5, 4)]) 13","solution":"def process_tool_weights(N, Q, initial_weights, operations): Returns the maximum weight after processing all operations on the tools. # We can use a difference array to perform range updates efficiently diff = [0] * (N + 1) for L, R, X in operations: diff[L-1] += X if R < N: diff[R] -= X # Apply the prefix sum to get the final weights max_weight = initial_weights[0] + diff[0] current_weight = initial_weights[0] + diff[0] for i in range(1, N): diff[i] += diff[i-1] current_weight = initial_weights[i] + diff[i] if current_weight > max_weight: max_weight = current_weight return max_weight"},{"question":"def lcs(X: str, Y: str) -> int: Returns the longest common subsequence length between strings X and Y. >>> lcs(\\"AGGTAB\\", \\"GXTXAYB\\") == 4 >>> lcs(\\"GXTXAYB\\", \\"AAACCGTGAGTTATTCGTTCTAGAA\\") == 3 >>> lcs(\\"ACCG\\", \\"AGC\\") == 2 >>> lcs(\\"A\\", \\"A\\") == 1 >>> lcs(\\"A\\", \\"T\\") == 0 >>> lcs(\\"ACGT\\", \\"ACGT\\") == 4 pass def genetic_lcs(sequences: List[str], queries: List[Tuple[int, int]]) -> List[int]: Processes a list of sequences and pairs of queries to determine the LCS length for each queried pair. sequences: List[str] queries: List[Tuple[int, int]] Returns a list[int] with LCS lengths for each query pair. >>> genetic_lcs([\\"AGGTAB\\", \\"GXTXAYB\\", \\"AAACCGTGAGTTATTCGTTCTAGAA\\"], [(1, 2), (2, 3)]) [4, 3] >>> genetic_lcs([\\"ACCG\\", \\"AGC\\", \\"GATTACA\\"], [(1, 2), (2, 3), (1, 3)]) [2, 2, 2] >>> genetic_lcs([\\"A\\", \\"T\\"], [(1, 2)]) [0] >>> genetic_lcs([\\"ACGT\\", \\"ACGT\\"], [(1, 2)]) [4] pass","solution":"def lcs(X, Y): Returns the longest common subsequence length between strings X and Y. m = len(X) n = len(Y) dp = [[None]*(n+1) for i in range(m+1)] for i in range(m+1): for j in range(n+1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i-1] == Y[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n] def genetic_lcs(sequences, queries): Processes a list of sequences and pairs of queries to determine the LCS length for each queried pair. sequences: List[str] queries: List[Tuple[int, int]] Returns a list[int] with LCS lengths for each query pair. results = [] for i, j in queries: # converting from 1-based indexing to 0-based: x_seq = sequences[i-1] y_seq = sequences[j-1] lcs_length = lcs(x_seq, y_seq) results.append(lcs_length) return results"},{"question":"def compress_string(s: str) -> str: Compresses the string using the Run-Length Encoding (RLE) algorithm. If the compressed string is not shorter than the original string, the function returns the original string. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed string or the original string. Examples: >>> compress_string(\\"aaabbbcc\\") 'a3b3c2' >>> compress_string(\\"abcd\\") 'abcd'","solution":"def compress_string(s): Compresses the string using the Run-Length Encoding (RLE) algorithm. If the compressed string is not shorter than the original string, the function returns the original string. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed string or the original string. compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # Adding the last character and its count compressed_str = ''.join(compressed) if len(compressed_str) < len(s): return compressed_str else: return s"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other. Args: s1 (str): The first string to check. s2 (str): The second string to check. Returns: bool: True if the strings are anagrams, False otherwise. Examples: >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False","solution":"def are_anagrams(s1, s2): Checks if two strings are anagrams of each other. return sorted(s1) == sorted(s2)"},{"question":"def min_trees_to_cut(n: int, heights: List[int]) -> int: Finds the minimum number of trees that need to be cut down to make the forest beautiful (i.e., the heights of the trees should be strictly increasing from left to right). Parameters: n (int): The number of trees in the forest (1 ≤ n ≤ 10^5). heights (list of int): The heights of the trees (1 ≤ height ≤ 10^9). Returns: int: The minimum number of trees to cut down. >>> min_trees_to_cut(6, [3, 2, 5, 1, 6, 4]) == 3 >>> min_trees_to_cut(4, [1, 2, 3, 4]) == 0 >>> min_trees_to_cut(1, [3]) == 0 >>> min_trees_to_cut(5, [5, 4, 3, 2, 1]) == 4 >>> min_trees_to_cut(5, [3, 3, 3, 3, 3]) == 4 >>> min_trees_to_cut(7, [1, 3, 2, 4, 3, 5, 6]) == 2 >>> min_trees_to_cut(2, [2, 1]) == 1 >>> min_trees_to_cut(2, [1, 2]) == 0","solution":"def min_trees_to_cut(n, heights): Finds the minimum number of trees that need to be cut down to make the forest beautiful (i.e., the heights of the trees should be strictly increasing from left to right). Parameters: n (int): The number of trees in the forest (1 ≤ n ≤ 10^5). heights (list of int): The heights of the trees (1 ≤ height ≤ 10^9). Returns: int: The minimum number of trees to cut down. # Initialize the length of the Longest Increasing Subsequence (LIS) lis_length = 0 dp = [0] * n for i in range(n): dp[i] = 1 for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) lis_length = max(lis_length, dp[i]) # The number of trees to cut is the total trees minus the length of the LIS return n - lis_length"},{"question":"def lexicographically_smallest_string(n: int, s: str) -> List[str]: Determine if it is possible to make the string lexicographically smallest by performing any number of the given operations. If yes, print the operations required to achieve it. If no operations are needed, just print \\"YES\\". >>> lexicographically_smallest_string(5, \\"dcbae\\") [\\"YES\\", \\"2\\", \\"d a\\", \\"c b\\"] >>> lexicographically_smallest_string(3, \\"abc\\") [\\"YES\\"] >>> lexicographically_smallest_string(4, \\"abcd\\") [\\"YES\\"] >>> lexicographically_smallest_string(1, \\"a\\") [\\"YES\\"] >>> lexicographically_smallest_string(4, \\"bbbb\\") [\\"YES\\"]","solution":"def lexicographically_smallest_string(n, s): if n == 1: return [\\"YES\\"] # Find the smallest lexicographical order string target = ''.join(sorted(s)) if s == target: return [\\"YES\\"] operations = [] for i in range(n): if s[i] != target[i]: for j in range(i + 1, n): if s[j] == target[i] and s[j] != target[j]: operations.append((s[i], s[j])) s = s.replace(s[i], '*').replace(s[j], s[i]).replace('*', s[j]) break result = [\\"YES\\", str(len(operations))] for op in operations: result.append(f\\"{op[0]} {op[1]}\\") return result"},{"question":"def max_cakes(F, S, E, f, s, e): Calculates the maximum number of cakes that can be baked with the available ingredients. Parameters: F (int): Total amount of flour available. S (int): Total amount of sugar available. E (int): Total amount of eggs available. f (int): Amount of flour needed for one cake. s (int): Amount of sugar needed for one cake. e (int): Amount of eggs needed for one cake. Returns: int: The maximum number of cakes that can be baked. Examples: >>> max_cakes(10, 10, 10, 2, 3, 1) 3 >>> max_cakes(15, 20, 25, 5, 4, 5) 3 >>> max_cakes(7, 7, 7, 3, 3, 3) 2 from solution import max_cakes def test_example_1(): assert max_cakes(10, 10, 10, 2, 3, 1) == 3 def test_example_2(): assert max_cakes(15, 20, 25, 5, 4, 5) == 3 def test_example_3(): assert max_cakes(7, 7, 7, 3, 3, 3) == 2 def test_larger_quantities(): assert max_cakes(1000000000, 1000000000, 1000000000, 2, 2, 2) == 500000000 def test_one_insufficient_ingredient(): assert max_cakes(1, 100, 100, 2, 3, 4) == 0 def test_exact_division(): assert max_cakes(10, 20, 30, 1, 2, 3) == 10 def test_minimal_ingredients(): assert max_cakes(1, 1, 1, 1, 1, 1) == 1 def test_one_cake_possible(): assert max_cakes(2, 2, 2, 1, 1, 1) == 2 def test_large_cake_requirements(): assert max_cakes(100, 100, 100, 100, 100, 100) == 1 def test_divisible_quantities(): assert max_cakes(9, 8, 7, 3, 2, 1) == 3","solution":"def max_cakes(F, S, E, f, s, e): Calculates the maximum number of cakes that can be baked with the available ingredients. Parameters: F (int): Total amount of flour available. S (int): Total amount of sugar available. E (int): Total amount of eggs available. f (int): Amount of flour needed for one cake. s (int): Amount of sugar needed for one cake. e (int): Amount of eggs needed for one cake. Returns: int: The maximum number of cakes that can be baked. return min(F // f, S // s, E // e)"},{"question":"class BookDatabase: A database of books and authors. Supports the following functions: 1. add_book(book_id, authors): Add a new book with the given book_id and a list of authors. 2. remove_book(book_id): Remove the book with the given book_id. 3. add_author(book_id, author): Add a new author to a book. 4. remove_author(book_id, author): Remove an author from a book. 5. list_books_by_author(author): Return a list of book_ids written by the given author. 6. list_all_books(): Return a list of all book_ids in the database. def __init__(self): Initialize the book database. pass def add_book(self, book_id: int, authors: List[int]) -> None: Add a new book with the given book_id and a list of authors. >>> db = BookDatabase() >>> db.add_book(1, [100, 200]) pass def remove_book(self, book_id: int) -> None: Remove the book with the given book_id. >>> db = BookDatabase() >>> db.add_book(1, [100, 200]) >>> db.remove_book(1) pass def add_author(self, book_id: int, author: int) -> None: Add a new author to a book. >>> db = BookDatabase() >>> db.add_book(1, [100]) >>> db.add_author(1, 200) pass def remove_author(self, book_id: int, author: int) -> None: Remove an author from a book. >>> db = BookDatabase() >>> db.add_book(1, [100, 200]) >>> db.remove_author(1, 100) pass def list_books_by_author(self, author: int) -> List[int]: Return a list of book_ids written by the given author. >>> db = BookDatabase() >>> db.add_book(1, [100, 200]) >>> db.add_book(2, [100]) >>> db.list_books_by_author(100) [1, 2] pass def list_all_books(self) -> List[int]: Return a list of all book_ids in the database. >>> db = BookDatabase() >>> db.add_book(1, [100, 200]) >>> db.add_book(3, [300]) >>> db.add_book(2, [100]) >>> db.list_all_books() [1, 2, 3] pass # Test cases can be run using \`pytest\` if __name__ == \\"__main__\\": import pytest def test_add_book(): db = BookDatabase() db.add_book(1, [100, 200]) assert db.books == {1: {100, 200}} assert db.authors_books == {100: {1}, 200: {1}} def test_remove_book(): db = BookDatabase() db.add_book(1, [100, 200]) db.add_book(2, [100]) db.remove_book(1) assert db.books == {2: {100}} assert db.authors_books == {100: {2}} def test_add_author(): db = BookDatabase() db.add_book(1, [100]) db.add_author(1, 200) assert db.books == {1: {100, 200}} assert db.authors_books == {100: {1}, 200: {1}} def test_remove_author(): db = BookDatabase() db.add_book(1, [100, 200]) db.remove_author(1, 100) assert db.books == {1: {200}} assert db.authors_books == {200: {1}} assert 100 not in db.authors_books def test_list_books_by_author(): db = BookDatabase() db.add_book(1, [100, 200]) db.add_book(2, [100]) books = db.list_books_by_author(100) assert books == [1, 2] def test_list_all_books(): db = BookDatabase() db.add_book(1, [100, 200]) db.add_book(3, [300]) db.add_book(2, [100]) all_books = db.list_all_books() assert all_books == [1, 2, 3] pytest.main()","solution":"class BookDatabase: def __init__(self): self.books = {} self.authors_books = {} def add_book(self, book_id, authors): self.books[book_id] = set(authors) for author in authors: if author not in self.authors_books: self.authors_books[author] = set() self.authors_books[author].add(book_id) def remove_book(self, book_id): if book_id in self.books: for author in self.books[book_id]: self.authors_books[author].remove(book_id) if not self.authors_books[author]: # Clean up empty sets del self.authors_books[author] del self.books[book_id] def add_author(self, book_id, author): if book_id in self.books: self.books[book_id].add(author) if author not in self.authors_books: self.authors_books[author] = set() self.authors_books[author].add(book_id) def remove_author(self, book_id, author): if book_id in self.books and author in self.books[book_id]: self.books[book_id].remove(author) self.authors_books[author].remove(book_id) if not self.authors_books[author]: # Clean up empty sets del self.authors_books[author] def list_books_by_author(self, author): if author in self.authors_books: return sorted(self.authors_books[author]) return [] def list_all_books(self): return sorted(self.books.keys())"},{"question":"def maxUniqueFruitTypes(inventory: List[int]) -> Tuple[int, List[int]]: Determine the maximum number of unique fruit types Lisa can use in her smoothies. >>> maxUniqueFruitTypes([1, 2, 0, 1]) (3, [0, 1, 3]) >>> maxUniqueFruitTypes([0, 0, 0, 4, 5]) (2, [3, 4])","solution":"def maxUniqueFruitTypes(inventory): selected_fruits = [] for i, count in enumerate(inventory): if count > 0: selected_fruits.append(i) return (len(selected_fruits), selected_fruits)"},{"question":"def track_revenue(n: int, transactions: List[Tuple[str, str, int]]) -> List[Tuple[int, Union[str, int]]]: Tracks the total revenue generated by each seller given a list of transactions. :param n: int: The number of transactions :param transactions: list of tuples: Each transaction is a tuple containing seller name, item name, and price :return: list of tuples: Each tuple contains seller's name and total revenue sorted by the seller's name.","solution":"def track_revenue(n, transactions): Tracks the total revenue generated by each seller given a list of transactions. :param n: int: The number of transactions :param transactions: list of tuples: Each transaction is a tuple containing seller name, item name, and price :return: list of tuples: Each tuple contains seller's name and total revenue sorted by the seller's name. from collections import defaultdict revenue = defaultdict(int) for transaction in transactions: seller, item, price = transaction revenue[seller] += price sorted_revenue = sorted(revenue.items()) result = [(len(sorted_revenue))] + sorted_revenue return result"},{"question":"def min_operations_cost(s1: str, s2: str) -> int: Computes the minimum cost to convert s1 into s2 using insertions, deletions, and replacements. Each insertion and deletion has a cost of 1. Each replacement has a cost of 2. >>> min_operations_cost(\\"kitten\\", \\"sitting\\") 5 >>> min_operations_cost(\\"abc\\", \\"abc\\") 0 >>> min_operations_cost(\\"abc\\", \\"abcd\\") 1 >>> min_operations_cost(\\"abcd\\", \\"abc\\") 1 >>> min_operations_cost(\\"abc\\", \\"adc\\") 2 >>> min_operations_cost(\\"intention\\", \\"execution\\") 8 >>> min_operations_cost(\\"\\", \\"abc\\") 3 >>> min_operations_cost(\\"abc\\", \\"\\") 3 >>> min_operations_cost(\\"\\", \\"\\") 0","solution":"def min_operations_cost(s1, s2): Computes the minimum cost to convert s1 into s2 using insertions, deletions, and replacements. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] else: insert_cost = dp[i][j-1] + 1 delete_cost = dp[i-1][j] + 1 replace_cost = dp[i-1][j-1] + 2 dp[i][j] = min(insert_cost, delete_cost, replace_cost) return dp[m][n]"},{"question":"def first_non_repeating_char(S: str) -> str: Returns the first non-repeating character in the string. If every character repeats, returns the first character of the string. If the string is empty, returns an empty string. >>> first_non_repeating_char('') == \\"\\" >>> first_non_repeating_char('abcdef') == 'a' >>> first_non_repeating_char('aabbcc') == 'a' >>> first_non_repeating_char('abacabad') == 'c' >>> first_non_repeating_char('z') == 'z' >>> first_non_repeating_char('aabbccddeeffg') == 'g' >>> first_non_repeating_char('aacceebbd') == 'd'","solution":"def first_non_repeating_char(S): Returns the first non-repeating character in the string. If every character repeats, returns the first character of the string. If the string is empty, returns an empty string. if not S: return \\"\\" char_count = {} for char in S: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in S: if char_count[char] == 1: return char return S[0]"},{"question":"def leaderboard(n: int, entries: List[str]) -> List[str]: Arrange a marathon leaderboard based on finish timings of participants. Each line of entries has the format \\"name finish_time\\". The returned leaderboard should have lines in the form \\"rank name\\". Participants are sorted by finish_time (asc.) and by name lexicographically in case of a tie. Ranks are numbered from 1. If more than one participant has the same finish_time, they should share the rank, with output like \\"3-4 alice\\". >>> leaderboard(5, [\\"john 120\\", \\"alice 150\\", \\"bob 115\\", \\"eve 150\\", \\"dave 200\\"]) [\\"1 bob\\", \\"2 john\\", \\"3-4 alice\\", \\"3-4 eve\\", \\"5 dave\\"] >>> leaderboard(4, [\\"sam 300\\", \\"zoe 290\\", \\"amy 290\\", \\"max 320\\"]) [\\"1-2 amy\\", \\"1-2 zoe\\", \\"3 sam\\", \\"4 max\\"] >>> leaderboard(4, [\\"mike 100\\", \\"john 100\\", \\"carol 100\\", \\"anna 110\\"]) [\\"1-3 carol\\", \\"1-3 john\\", \\"1-3 mike\\", \\"4 anna\\"] >>> leaderboard(6, [\\"joe 120\\", \\"levi 130\\", \\"kate 130\\", \\"moe 140\\", \\"dan 110\\", \\"jack 120\\"]) [\\"1 dan\\", \\"2-3 jack\\", \\"2-3 joe\\", \\"4-5 kate\\", \\"4-5 levi\\", \\"6 moe\\"] >>> leaderboard(1, [\\"alice 1440\\"]) [\\"1 alice\\"] >>> leaderboard(3, [\\"alice 500\\", \\"bob 500\\", \\"carol 500\\"]) [\\"1-3 alice\\", \\"1-3 bob\\", \\"1-3 carol\\"]","solution":"def leaderboard(n, entries): # Parse the entries and store them in a list of tuples (name, finish_time) participants = [(entry.split()[0], int(entry.split()[1])) for entry in entries] # Sort participants first by finish_time, then by name (in case of tie on finish_time) participants.sort(key=lambda x: (x[1], x[0])) result = [] i = 0 while i < n: current_time = participants[i][1] start = i # Collect all participants with the same finish_time while i < n and participants[i][1] == current_time: i += 1 # If there are multiple participants with the same finish_time, form a shared rank if start + 1 < i: rank = f\\"{start + 1}-{i}\\" else: rank = str(start + 1) # Add the ranked participants to the result for j in range(start, i): result.append(f\\"{rank} {participants[j][0]}\\") return result"},{"question":"def largest_square_subgrid_with_ones(grid: List[List[int]]) -> int: Find the side length of the largest square subgrid that contains only 1s. >>> largest_square_subgrid_with_ones([ ... [0, 1, 1, 0, 1, 1], ... [1, 1, 1, 1, 1, 1], ... [0, 1, 1, 1, 1, 1], ... [0, 1, 1, 1, 1, 1], ... [0, 0, 1, 0, 1, 1] ... ]) Outputs: 3 >>> largest_square_subgrid_with_ones([ ... [1, 1, 0, 0], ... [1, 1, 0, 1], ... [0, 1, 1, 1], ... ]) Outputs: 2 >>> largest_square_subgrid_with_ones([ ... [1, 0], ... [0, 1] ... ]) Outputs: 1 >>> largest_square_subgrid_with_ones([ ... [0, 0], ... [0, 0] ... ]) Outputs: 0 >>> largest_square_subgrid_with_ones([ ... [1] ... ]) Outputs: 1 >>> largest_square_subgrid_with_ones([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) Outputs: 3 >>> largest_square_subgrid_with_ones([]) Outputs: 0","solution":"def largest_square_subgrid_with_ones(grid): if not grid or not grid[0]: return 0 N, M = len(grid), len(grid[0]) dp = [[0] * M for _ in range(N)] max_side_length = 0 for i in range(N): for j in range(M): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"from typing import List, Tuple def has_even_sum_pair(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether there exists a pair of integers in the list such that their sum is even. >>> has_even_sum_pair(4, [(3, [1, 4, 5]), (5, [7, 2, 5, 3, 1]), (4, [6, 10, -3, -7]), (2, [1, 1])]) ['YES', 'YES', 'YES', 'NO']","solution":"def has_even_sum_pair(t, test_cases): results = [] for case in test_cases: n = case[0] a = case[1:] has_pair = False # Check if there is at least one even and one odd number evens = any(x % 2 == 0 for x in a) odds = any(x % 2 != 0 for x in a) if evens and odds: has_pair = True results.append(\\"YES\\" if has_pair else \\"NO\\") return results"},{"question":"def count_distinct_buildings(grid: List[str]) -> int: This function takes a 2D grid and returns the number of distinct buildings. Examples: >>> count_distinct_buildings([\\"AAB..\\", \\"AABBC\\", \\"..BBC\\", \\"CCCCC\\"]) 4 >>> count_distinct_buildings([\\"AAA\\", \\"ABA\\", \\"AAA\\"]) 2 pass def test_single_building(): grid = [\\"AAA\\", \\"AAA\\", \\"AAA\\"] assert count_distinct_buildings(grid) == 1 def test_multiple_buildings(): grid = [ \\"AAB..\\", \\"AABBC\\", \\"..BBC\\", \\"CCCCC\\" ] assert count_distinct_buildings(grid) == 4 def test_isolated_building(): grid = [ \\"AAA\\", \\"ABA\\", \\"AAA\\" ] assert count_distinct_buildings(grid) == 2 def test_grid_with_dots_only(): grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert count_distinct_buildings(grid) == 1 def test_single_row_building(): grid = [ \\"AABBBCCD\\" ] assert count_distinct_buildings(grid) == 4 def test_single_column_building(): grid = [ \\"A\\", \\"B\\", \\"B\\", \\"C\\" ] assert count_distinct_buildings(grid) == 3","solution":"def count_distinct_buildings(grid): This function takes a 2D grid and returns the number of distinct buildings. n = len(grid) m = len(grid[0]) visited = set() buildings = set() def dfs(x, y, ch): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < n and 0 <= j < m and (i, j) not in visited and grid[i][j] == ch: visited.add((i, j)) stack.extend(((i+1, j), (i-1, j), (i, j+1), (i, j-1))) for i in range(n): for j in range(m): if (i, j) not in visited: ch = grid[i][j] buildings.add(ch) dfs(i, j, ch) return len(buildings)"},{"question":"from typing import List def can_partition(nums: List[int]) -> str: Determines if the array can be partitioned into two subsequences such that the sum of the elements in both subsequences is equal. :param nums: List[int] - the input array of integers :return: str - \\"YES\\" if partition is possible, otherwise \\"NO\\" pass def solve_partition_problem(test_cases: List[List[int]]) -> List[str]: Solves the partition problem for multiple test cases. :param test_cases: List[List[int]] - The test cases, where each test case is a list of integers :return: List[str] - A list of strings where each string is \\"YES\\" or \\"NO\\" corresponding to each test case pass def test_can_partition(): assert can_partition([1, 5, 11, 5]) == \\"YES\\" assert can_partition([1, 2, 3, 5]) == \\"NO\\" assert can_partition([3, 3, 3, 3]) == \\"YES\\" assert can_partition([1, 1, 1, 1, 1, 1]) == \\"YES\\" assert can_partition([1, 1, 1, 1, 1]) == \\"NO\\" assert can_partition([2]) == \\"NO\\" def test_solve_partition_problem(): test_cases = [ [1, 5, 11, 5], [1, 2, 3, 5], [3, 3, 3, 3] ] assert solve_partition_problem(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases = [ [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [2] ] assert solve_partition_problem(test_cases) == [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsequences such that the sum of the elements in both subsequences is equal. :param nums: List[int] - the input array of integers :return: str - \\"YES\\" if partition is possible, otherwise \\"NO\\" total_sum = sum(nums) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\" def solve_partition_problem(test_cases): results = [] for nums in test_cases: results.append(can_partition(nums)) return results"},{"question":"def min_days_for_sessions(n: int, d: int, durations: List[int]) -> int: Determine the minimum number of consecutive days required to accommodate all sessions without exceeding 24 hours per day. >>> min_days_for_sessions(5, 3, [8, 8, 8, 4, 6]) 2 >>> min_days_for_sessions(3, 5, [6, 6, 6]) 1 >>> min_days_for_sessions(1, 1, [24]) 1 >>> min_days_for_sessions(3, 2, [7, 8, 9]) 1 >>> min_days_for_sessions(4, 2, [15, 10, 5, 9]) 2 >>> min_days_for_sessions(10, 10, [2] * 10) 1 >>> min_days_for_sessions(1000, 1000, [1] * 1000) 42","solution":"def min_days_for_sessions(n, d, durations): Returns the minimum number of days needed to accommodate all sessions within the given durations. days = 0 current_day_duration = 0 for duration in durations: if current_day_duration + duration > 24: days += 1 current_day_duration = duration else: current_day_duration += duration if current_day_duration > 0: days += 1 return days"},{"question":"def modify_bookshelf(initial_books: List[int], operations: List[Tuple[str, int]]) -> List[int]: Modifies the bookshelf based on the given operations. Arguments: initial_books -- list of integers representing the initial state of the bookshelf operations -- list of tuples, each containing a string (\\"add\\" or \\"remove\\") and an integer Returns: A list of integers representing the final state of the bookshelf","solution":"def modify_bookshelf(initial_books, operations): Modifies the bookshelf based on the given operations. Arguments: initial_books -- list of integers representing the initial state of the bookshelf operations -- list of tuples, each containing a string (\\"add\\" or \\"remove\\") and an integer Returns: A list of integers representing the final state of the bookshelf books_set = set(initial_books) # Use a set to track current books for O(1) look-up. final_books = list(initial_books) for operation in operations: action, book = operation if action == \\"add\\" and book not in books_set: final_books.append(book) books_set.add(book) elif action == \\"remove\\" and book in books_set: final_books.remove(book) books_set.remove(book) return final_books"},{"question":"from typing import List, Tuple def min_segments_to_reach_height(h: int, lengths: List[int]) -> int: Finds the minimum number of rope segments needed to reach the ground exactly. >>> min_segments_to_reach_height(10, [1, 2, 3, 4, 5]) 2 >>> min_segments_to_reach_height(6, [5, 10, 15]) -1 >>> min_segments_to_reach_height(15, [3, 6, 9, 12]) 2 def solve(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Processes multiple test cases for rope segments to reach height. >>> solve([(10, 5, [1, 2, 3, 4, 5]), (6, 3, [5, 10, 15]), (15, 4, [3, 6, 9, 12])]) [2, -1, 2] >>> solve([(7, 3, [2, 4, 6]), (7, 5, [1, 1, 1, 1, 1]), (1, 1, [1]), (1, 1, [2])]) [-1, 7, 1, -1]","solution":"def min_segments_to_reach_height(h, lengths): from collections import deque n = len(lengths) # Queue to store current height reached and number of segments used queue = deque([(0, 0)]) visited = set() visited.add(0) while queue: current_height, segments_used = queue.popleft() if current_height == h: return segments_used for length in lengths: new_height = current_height + length if new_height <= h and new_height not in visited: visited.add(new_height) queue.append((new_height, segments_used + 1)) return -1 def solve(test_cases): results = [] for h, n, lengths in test_cases: result = min_segments_to_reach_height(h, lengths) results.append(result) return results"},{"question":"def is_path_safe(n, m, k, asteroids, x1, y1, x2, y2): Check if the spaceship can reach the destination without crashing into an asteroid. >>> is_path_safe(5, 5, 3, [(1, 1), (3, 3), (4, 4)], 0, 0, 4, 4) \\"Safe landing!\\" >>> is_path_safe(5, 5, 3, [(1, 0), (3, 3), (4, 4)], 0, 0, 4, 4) \\"Crash!\\"","solution":"def is_path_safe(n, m, k, asteroids, x1, y1, x2, y2): from collections import deque # Create a grid to mark the presence of asteroids grid = [[True] * m for _ in range(n)] for a in asteroids: grid[a[0]][a[1]] = False # Directions for Up, Down, Left, and Right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Perform BFS to find the path queue = deque([(x1, y1)]) visited = set((x1, y1)) while queue: x, y = queue.popleft() if (x, y) == (x2, y2): return \\"Safe landing!\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"Crash!\\""},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of non-negative integers and the operations + and - Examples: >>> evaluate_expression(\\"3+2-5\\") 0 >>> evaluate_expression(\\"10+20-30+40\\") 40 >>> evaluate_expression(\\"100-50+25\\") 75 >>> evaluate_expression(\\"1+2+3+4+5-15\\") 0 pass # Unit tests def test_evaluate_expression_single_number(): assert evaluate_expression(\\"0\\") == 0 assert evaluate_expression(\\"10\\") == 10 assert evaluate_expression(\\"999\\") == 999 def test_evaluate_expression_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 assert evaluate_expression(\\"5+5\\") == 10 def test_evaluate_expression_simple_subtraction(): assert evaluate_expression(\\"5-3\\") == 2 assert evaluate_expression(\\"10-2\\") == 8 def test_evaluate_expression_mixed_operators(): assert evaluate_expression(\\"3+2-5\\") == 0 assert evaluate_expression(\\"10+20-30+40\\") == 40 assert evaluate_expression(\\"100-50+25\\") == 75 assert evaluate_expression(\\"1+2+3+4+5-15\\") == 0 def test_evaluate_expression_large_expression(): assert evaluate_expression(\\"1+2+3+4+5-15+10-5+35-20+50+50-25\\") == 95 def test_evaluate_expression_edge_cases(): assert evaluate_expression(\\"0-0-0-0\\") == 0 assert evaluate_expression(\\"9-8+7-6+5-4+3-2+1-0\\") == 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression consisting of non-negative integers and the operations + and - result = 0 current_number_str = '' last_operator = '+' for char in expression: if char.isdigit(): current_number_str += char else: if current_number_str: if last_operator == '+': result += int(current_number_str) elif last_operator == '-': result -= int(current_number_str) current_number_str = '' last_operator = char if current_number_str: # for the last number in the expression if last_operator == '+': result += int(current_number_str) elif last_operator == '-': result -= int(current_number_str) return result"},{"question":"class Library: A simple library management system to keep track of books. Each book has a unique book ID, title, author, and publication year. Methods: add_book(book_id, title, author, publication_year) -> None: Adds a new book to the library with the given details. remove_book(book_id) -> None: Removes the book with the given book ID from the library. search_by_author(author) -> List[str]: Returns a list of book titles by the specified author. >>> library = Library() >>> library.add_book(1, \\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) >>> library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) >>> library.add_book(3, \\"1984\\", \\"George Orwell\\", 1949) >>> library.search_by_author(\\"George Orwell\\") ['1984'] >>> library.search_by_author(\\"Harper Lee\\") ['To Kill a Mockingbird'] >>> library.remove_book(2) >>> library.search_by_author(\\"Harper Lee\\") []","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_id, title, author, publication_year): self.books[book_id] = { 'title': title, 'author': author, 'publication_year': publication_year } def remove_book(self, book_id): if book_id in self.books: del self.books[book_id] def search_by_author(self, author): return [details['title'] for details in self.books.values() if details['author'] == author]"},{"question":"def find_peak(arr): Returns the index of a peak element in the array 'arr'. A peak element is strictly greater than its neighbors. >>> find_peak([1, 3, 20, 4, 1, 0]) 2 >>> find_peak([10, 20, 15, 2, 23, 90, 67]) in [1, 5] >>> find_peak([1, 2, 3, 1]) 2","solution":"def find_peak(arr): Returns the index of a peak element in the array 'arr'. A peak element is strictly greater than its neighbors. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def findPaths(n: int, grid: List[List[int]]) -> int: Find the number of distinct paths from the top-left corner to the bottom-right corner of a grid. Parameters: n (int): The size of the grid (n x n). grid (List[List[int]]): A list of lists representing the grid where \`1\` represents an obstacle and \`0\` represents an empty cell. Returns: int: The number of distinct paths to reach the bottom-right corner from the top-left corner. Examples: >>> findPaths(3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> findPaths(3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 6 >>> findPaths(3, [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> findPaths(3, [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ]) 0 >>> findPaths(1, [ [0] ]) 1","solution":"def findPaths(n, grid): Find the number of distinct paths from the top-left corner to the bottom-right corner of a grid. if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 # Initialize a dp 2D array to store the number of ways to reach each cell dp = [[0 for _ in range(n)] for _ in range(n)] # Starting point dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(n): if grid[i][j] == 1: # If there is an obstacle, skip the cell dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"import heapq from collections import defaultdict def find_shortest_path(n: int, m: int, roads: List[Tuple[int, int, int]], s: int, t: int) -> int: Determine the minimum travel time required to get from intersection s to intersection t. >>> find_shortest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 5, 3), (4, 5, 1)], 1, 5) 5 >>> find_shortest_path(3, 1, [(1, 2, 10)], 1, 3) -1","solution":"import heapq from collections import defaultdict, deque def find_shortest_path(n, m, roads, s, t): graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, s)] distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == t: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[t] == float('inf') else distances[t]"},{"question":"def summarize_bird_sightings(n: int, sightings: List[Tuple[str, int]]) -> Tuple[str, int]: Returns the most frequently observed bird species and the number of different species Zara saw at least once during the week. Arguments: n -- the number of different bird species recorded sightings -- a list of tuples, where each tuple contains a string (bird species) and an integer (number of sightings) Returns: A tuple containing the most frequently observed bird species and the number of different species Examples: >>> summarize_bird_sightings(3, [(\\"sparrow\\", 15), (\\"hawk\\", 9), (\\"sparrow\\", 20)]) (\\"sparrow\\", 2) >>> summarize_bird_sightings(5, [(\\"crow\\", 8), (\\"sparrow\\", 8), (\\"owl\\", 10), (\\"pigeon\\", 6), (\\"hawk\\", 7)]) (\\"owl\\", 5)","solution":"def summarize_bird_sightings(n, sightings): Returns the most frequently observed bird species and the number of different species Zara saw at least once during the week. Arguments: n -- the number of different bird species recorded sightings -- a list of tuples, where each tuple contains a string (bird species) and an integer (number of sightings) Returns: A tuple containing the most frequently observed bird species and the number of different species from collections import defaultdict species_count = defaultdict(int) unique_species = set() for species, count in sightings: species_count[species] += count unique_species.add(species) most_frequent_species = max(species_count.items(), key=lambda x: (x[1], -ord(x[0][0]))) return most_frequent_species[0], len(unique_species)"},{"question":"def count_subarrays_with_target_sum(arr, target): Returns the number of contiguous subarrays that sum up to the target value. pass def process_test_cases(test_cases): Process a list of test cases and return the results for each. pass # Test cases from your_module import count_subarrays_with_target_sum, process_test_cases def test_count_subarrays_with_target_sum(): assert count_subarrays_with_target_sum([1, 2, 3, 4, 5], 5) == 2 assert count_subarrays_with_target_sum([1, -1, 2, 3, -3, 4], 4) == 3 assert count_subarrays_with_target_sum([1, 2, 1, 2, 1], 3) == 4 assert count_subarrays_with_target_sum([1, 1, 1, 1, 1], 2) == 4 assert count_subarrays_with_target_sum([0, 0, 0, 0], 0) == 10 def test_process_test_cases(): test_cases = [ {'N': 5, 'array': [1, 2, 3, 4, 5], 'target': 5}, {'N': 6, 'array': [1, -1, 2, 3, -3, 4], 'target': 4} ] expected_results = [2, 3] assert process_test_cases(test_cases) == expected_results def test_empty_array(): assert count_subarrays_with_target_sum([], 0) == 0 assert count_subarrays_with_target_sum([], 1) == 0 def test_single_element_equal_target(): assert count_subarrays_with_target_sum([5], 5) == 1 assert count_subarrays_with_target_sum([0], 0) == 1 def test_single_element_not_equal_target(): assert count_subarrays_with_target_sum([1], 5) == 0 assert count_subarrays_with_target_sum([-1], 1) == 0 def test_large_array(): arr = [1] * 1000 target = 5 assert count_subarrays_with_target_sum(arr, target) == 996 def test_large_negative_target(): arr = [-1] * 1000 target = -500 assert count_subarrays_with_target_sum(arr, target) == 501","solution":"def count_subarrays_with_target_sum(arr, target): Returns the number of contiguous subarrays that sum up to the target value. count = 0 current_sum = 0 prefix_sums = {0: 1} # Initialize with 0 to handle cases where subarray starts from index 0 for num in arr: current_sum += num # Check if there is a prefix sum that when subtracted from current_sum equals the target if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] # Update the prefix sums dictionary if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count def process_test_cases(test_cases): results = [] for test_case in test_cases: N = test_case['N'] arr = test_case['array'] K = test_case['target'] result = count_subarrays_with_target_sum(arr, K) results.append(result) return results"},{"question":"def minimum_moves(n, m, maze, sr, sc, tr, tc): Determines the minimum number of moves needed for the robot to reach the target cell from the start cell. Returns -1 if it is impossible to reach the target. Parameters: n (int): the number of rows in the maze m (int): the number of columns in the maze maze (List[List[int]]): the maze grid represented as a list of lists sr (int): the starting row (1-indexed) sc (int): the starting column (1-indexed) tr (int): the target row (1-indexed) tc (int): the target column (1-indexed) Returns: int: the minimum number of moves to reach the target, or -1 if difficult Examples: >>> minimum_moves(5, 5, [[1, 1, 0, 1, 1], [1, 0, 0, 1, 1], [1, 1, 1, 1, 0], [0, 0, 1, 0, 1], [1, 1, 1, 1, 1]], 1, 1, 5, 5) 8 >>> minimum_moves(3, 3, [[1, 0, 1], [1, 0, 1], [1, 1, 1]], 1, 1, 3, 3) 4 >>> minimum_moves(4, 4, [[1, 0, 1, 1], [1, 1, 0, 0], [0, 1, 1, 1], [1, 1, 1, 1]], 4, 1, 1, 4) -1 import pytest from solution import minimum_moves def test_example1(): maze = [ [1, 1, 0, 1, 1], [1, 0, 0, 1, 1], [1, 1, 1, 1, 0], [0, 0, 1, 0, 1], [1, 1, 1, 1, 1] ] assert minimum_moves(5, 5, maze, 1, 1, 5, 5) == 8 def test_example2(): maze = [ [1, 0, 1], [1, 0, 1], [1, 1, 1] ] assert minimum_moves(3, 3, maze, 1, 1, 3, 3) == 4 def test_example3(): maze = [ [1, 0, 1, 1], [1, 1, 0, 0], [0, 1, 1, 1], [1, 1, 1, 1] ] assert minimum_moves(4, 4, maze, 4, 1, 1, 4) == -1 def test_target_is_obstacle(): maze = [ [1, 1], [1, 0] ] assert minimum_moves(2, 2, maze, 1, 1, 2, 2) == -1 def test_start_is_obstacle(): maze = [ [0, 1], [1, 1] ] assert minimum_moves(2, 2, maze, 1, 1, 2, 2) == -1 def test_minimum_moves_no_obstacles(): maze = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert minimum_moves(3, 3, maze, 1, 1, 3, 3) == 4 def test_complex_maze(): maze = [ [1, 0, 1, 0, 1], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [1, 0, 1, 1, 1], [1, 1, 1, 0, 1] ] assert minimum_moves(5, 5, maze, 1, 1, 5, 5) == 8","solution":"from collections import deque def minimum_moves(n, m, maze, sr, sc, tr, tc): Determines the minimum number of moves needed for the robot to reach the target cell from the start cell. Returns -1 if it is impossible to reach the target. # Adjust indexing to be 0-based for easier matrix access sr, sc, tr, tc = sr - 1, sc - 1, tr - 1, tc - 1 # Check if starting or target position is an obstacle if maze[sr][sc] == 0 or maze[tr][tc] == 0: return -1 # Directions to move in the form of (row_move, col_move) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize queue for BFS queue = deque([(sr, sc, 0)]) # (row, column, distance) visited = set((sr, sc)) while queue: current_row, current_col, current_dist = queue.popleft() # If we reach the target if current_row == tr and current_col == tc: return current_dist # Explore all possible directions for dr, dc in directions: next_row, next_col = current_row + dr, current_col + dc if 0 <= next_row < n and 0 <= next_col < m and (next_row, next_col) not in visited and maze[next_row][next_col] == 1: queue.append((next_row, next_col, current_dist + 1)) visited.add((next_row, next_col)) # If the target is not reachable return -1"},{"question":"def track_borrowed_books(n: int, borrowing_events: List[int]) -> Dict[int, int]: Returns the count of each book_id borrowed. :param n: The number of borrowing events (int) :param borrowing_events: A list of book_id (List[int]) :return: A dictionary where keys are book IDs and values are the counts >>> track_borrowed_books(1, [101]) {101: 1} >>> track_borrowed_books(3, [101, 101, 101]) {101: 3} >>> track_borrowed_books(3, [101, 203, 305]) {101: 1, 203: 1, 305: 1} >>> track_borrowed_books(5, [101, 203, 101, 203, 305]) {101: 2, 203: 2, 305: 1} >>> track_borrowed_books(5, [305, 203, 101, 203, 101]) {101: 2, 203: 2, 305: 1}","solution":"def track_borrowed_books(n, borrowing_events): Returns the count of each book_id borrowed. :param n: The number of borrowing events (int) :param borrowing_events: A list of book_id (List[int]) :return: A dictionary where keys are book IDs and values are the counts book_count = {} for book_id in borrowing_events: if book_id in book_count: book_count[book_id] += 1 else: book_count[book_id] = 1 sorted_books = dict(sorted(book_count.items())) return sorted_books"},{"question":"def num_mineral_deposits(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of separate mineral deposits in the given grid. Args: n: Number of rows in the grid. m: Number of columns in the grid. grid: A 2D list representing the grid, where each element is '0' or '1'. Returns: The number of separate mineral deposits. >>> num_mineral_deposits(5, 5, [ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '1', '1'], ... ['0', '0', '0', '0', '0'], ... ['0', '1', '1', '1', '0'], ... ['0', '0', '0', '1', '1'] ... ]) == 3 >>> num_mineral_deposits(3, 3, [ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) == 0","solution":"def num_mineral_deposits(n, m, grid): Returns the number of separate mineral deposits in the given grid. def dfs(x, y): # Mark the current cell as visited grid[x][y] = '0' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '1': dfs(nx, ny) deposit_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': # we found an unvisited deposit deposit_count += 1 dfs(i, j) return deposit_count"},{"question":"def min_workers_per_supervisor(n: int, m: int) -> int: Determine the minimum number of workers any supervisor can have. Parameters: n (int): Number of supervisors m (int): Number of workers Returns: int: Minimum number of workers the least busy supervisor will have >>> min_workers_per_supervisor(4, 10) 2 >>> min_workers_per_supervisor(1, 1) 1 >>> min_workers_per_supervisor(10, 55) 5 >>> min_workers_per_supervisor(2, 1) 0 >>> min_workers_per_supervisor(3, 8) 2 >>> min_workers_per_supervisor(6, 20) 3 >>> min_workers_per_supervisor(2, 1000000) 500000 >>> min_workers_per_supervisor(1000000, 1000000) 1","solution":"def min_workers_per_supervisor(n, m): Returns the minimum number of workers any supervisor will have under given constraints. Parameters: n (int): Number of supervisors m (int): Number of workers Returns: int: Minimum number of workers the least busy supervisor will have # Calculate the base number of workers each supervisor will get base_workers = m // n # If there are extra workers, they will be distributed such that supervisors with lower IDs get more workers. extra_workers = m % n # If there are no extra workers, all supervisors have the same number of workers if extra_workers == 0: return base_workers # Otherwise, the least busy supervisor will have base_workers return base_workers"},{"question":"def can_communicate(bases): Check if all bases can communicate with at least one other base. >>> can_communicate([(1, 1), (2, 2), (3, 3)]) 'YES' >>> can_communicate([(1, 1), (1, 1)]) 'NO' >>> can_communicate([(1, 1), (2, 2), (2, 3), (3, 1)]) 'YES' def process_datasets(datasets): Process multiple datasets and return communication results for each. >>> process_datasets([[(1, 1), (2, 2), (3, 3)], [(1, 1), (2, 2), (2, 3), (3, 1)]]) ['YES', 'YES'] def read_input(input_data): Read input data and convert it into a list of datasets. >>> read_input(\\"3n1 1n2 2n3 3n4n1 1n2 2n2 3n3 1n0n\\") [[(1, 1), (2, 2), (3, 3)], [(1, 1), (2, 2), (2, 3), (3, 1)]]","solution":"def can_communicate(bases): Check if all bases can communicate with at least one other base. n = len(bases) for i in range(n): base_i = bases[i] has_communication = False for j in range(n): if i != j: base_j = bases[j] if base_i != base_j: # Check if it's a different base has_communication = True break if not has_communication: return \\"NO\\" return \\"YES\\" def process_datasets(datasets): results = [] for bases in datasets: results.append(can_communicate(bases)) return results def read_input(input_data): datasets = [] data = input_data.strip().split('n') i = 0 while i < len(data): N = int(data[i].strip()) if N == 0: break i += 1 bases = [] for _ in range(N): x, y = map(int, data[i].strip().split()) bases.append((x, y)) i += 1 datasets.append(bases) return datasets"},{"question":"def is_path_exist(R: int, C: int, grid: List[str]) -> str: Function to determine if there is a path from top-left (1, 1) to bottom-right (R, C) in a dungeon grid. Parameters: R (int) : number of rows C (int) : number of columns grid (list of str) : list of strings representing the dungeon map Returns: str : \\"Yes\\" if path exists, otherwise \\"No\\" >>> is_path_exist(4, 4, [\\"....\\",\\".*..\\",\\"..*.\\",\\"....\\"]) == \\"Yes\\" >>> is_path_exist(4, 4, [\\"*...\\",\\"***.\\",\\"...*\\",\\".*..\\"]) == \\"No\\" >>> is_path_exist(2, 2, [\\"..\\",\\".*\\"]) == \\"No\\" >>> is_path_exist(1, 1, [\\".\\"]) == \\"Yes\\" >>> is_path_exist(1, 1, [\\"*\\"]) == \\"No\\" >>> is_path_exist(3, 3, [\\"..*\\",\\"**.\\",\\"*..\\"]) == \\"No\\" >>> is_path_exist(5, 5, [\\".....\\",\\".....\\",\\".....\\",\\".....\\",\\".....\\"]) == \\"Yes\\"","solution":"def is_path_exist(R, C, grid): Function to determine if there is a path from top-left (1, 1) to bottom-right (R, C) in a dungeon grid. Parameters: R (int) : number of rows C (int) : number of columns grid (list of str) : list of strings representing the dungeon map Returns: str : \\"Yes\\" if path exists, otherwise \\"No\\" from collections import deque if grid[0][0] == '*' or grid[R-1][C-1] == '*': return \\"No\\" directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def is_valid(x, y): return 0 <= x < R and 0 <= y < C and grid[x][y] == '.' queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (R-1, C-1): return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"No\\""},{"question":"def count_character_occurrences(s: str, c: str) -> int: Returns the number of times character c appears in string s. >>> count_character_occurrences(\\"hello\\", \\"l\\") 2 >>> count_character_occurrences(\\"abcdefg\\", \\"a\\") 1 >>> count_character_occurrences(\\"mississippi\\", \\"s\\") 4 >>> count_character_occurrences(\\"programming\\", \\"r\\") 2 def process_input(input_line: str) -> int: Parses the input line to split the string and character, and returns the count of occurrences of the character in the string. >>> process_input(\\"hello l\\") 2 >>> process_input(\\"abcdefg a\\") 1 >>> process_input(\\"mississippi s\\") 4 >>> process_input(\\"programming r\\") 2","solution":"def count_character_occurrences(s, c): Returns the number of times character c appears in string s. return s.count(c) # Helper function to parse input and call main function def process_input(input_line): Parses the input line to split the string and character, and returns the count of occurrences of the character in the string. s, c = input_line.rsplit(' ', 1) # Split from the right return count_character_occurrences(s, c)"},{"question":"def unique_paths_with_obstacles(m: int, n: int, grid: List[List[int]]) -> int: Returns the number of unique paths from top-left corner to bottom-right corner in a grid with obstacles. Parameters: m (int): number of rows n (int): number of columns grid (List[List[int]]): 2D list representing the grid where 0 is a passable cell and 1 is a blocked cell Returns: int: number of unique paths from solution import unique_paths_with_obstacles def test_single_cell_no_obstacle(): assert unique_paths_with_obstacles(1, 1, [[0]]) == 1 def test_single_cell_with_obstacle(): assert unique_paths_with_obstacles(1, 1, [[1]]) == 0 def test_simple_grid(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(3, 3, grid) == 2 def test_blocked_path(): grid = [ [0, 1], [1, 0] ] assert unique_paths_with_obstacles(2, 2, grid) == 0 def test_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(3, 3, grid) == 6 def test_entire_row_blocked(): grid = [ [0, 0, 0], [1, 1, 1], [0, 0, 0] ] assert unique_paths_with_obstacles(3, 3, grid) == 0 def test_entire_column_blocked(): grid = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] assert unique_paths_with_obstacles(3, 3, grid) == 0","solution":"def unique_paths_with_obstacles(m, n, grid): Returns the number of unique paths from top-left corner to bottom-right corner in a grid with obstacles. Parameters: m (int): number of rows n (int): number of columns grid (List[List[int]]): 2D list representing the grid where 0 is a passable cell and 1 is a blocked cell Returns: int: number of unique paths if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def cumulative_weights(N: int, weights: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the cumulative weights for each query. :param N: int, the number of widgets :param weights: list of int, weights of the widgets :param queries: list of tuple of int, each tuple represents (L, R) range :return: list of int, cumulative weights for each query >>> cumulative_weights(5, [3, 1, 4, 1, 5], [(1, 3), (2, 5), (1, 5)]) == [8, 11, 14] >>> cumulative_weights(5, [1, 1, 1, 1, 1], [(1, 5), (1, 3), (3, 5)]) == [5, 3, 3]","solution":"def cumulative_weights(N, weights, queries): Returns the cumulative weights for each query. :param N: int, the number of widgets :param weights: list of int, weights of the widgets :param queries: list of tuple of int, each tuple represents (L, R) range :return: list of int, cumulative weights for each query # Compute prefix sums prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i - 1] + weights[i - 1] # Respond to queries results = [] for L, R in queries: results.append(prefix_sums[R] - prefix_sums[L - 1]) return results"},{"question":"def can_make_equal(a: int, b: int, c: int) -> bool: Determines if the given integers a, b, and c can be made equal by the allowed operation. >>> can_make_equal(1, 2, 3) True >>> can_make_equal(1, 2, 4) False >>> can_make_equal(0, 0, 0) True","solution":"def can_make_equal(a, b, c): Determines if the given integers a, b, and c can be made equal by the allowed operation. total_sum = a + b + c # Check if the total sum of a, b, and c is divisible by 3 return total_sum % 3 == 0"},{"question":"def min_cost_to_transform(A: str, B: str) -> int: Calculates the minimum cost to transform string A into string B. >>> min_cost_to_transform(\\"horse\\", \\"ros\\") 3 >>> min_cost_to_transform(\\"intention\\", \\"execution\\") 5 >>> min_cost_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_cost_to_transform(\\"abcdef\\", \\"azced\\") 3 >>> min_cost_to_transform(\\"\\", \\"abc\\") 3 >>> min_cost_to_transform(\\"abc\\", \\"\\") 3 >>> min_cost_to_transform(\\"\\", \\"\\") 0 >>> min_cost_to_transform(\\"a\\", \\"b\\") 1 >>> min_cost_to_transform(\\"a\\", \\"a\\") 0 >>> min_cost_to_transform(\\"b\\", \\"a\\") 1 def test_min_cost_to_transform(): assert min_cost_to_transform(\\"horse\\", \\"ros\\") == 3 assert min_cost_to_transform(\\"intention\\", \\"execution\\") == 5 assert min_cost_to_transform(\\"abc\\", \\"abc\\") == 0 assert min_cost_to_transform(\\"abcdef\\", \\"azced\\") == 3 assert min_cost_to_transform(\\"\\", \\"abc\\") == 3 assert min_cost_to_transform(\\"abc\\", \\"\\") == 3 assert min_cost_to_transform(\\"\\", \\"\\") == 0 def test_min_cost_to_transform_single_chars(): assert min_cost_to_transform(\\"a\\", \\"b\\") == 1 assert min_cost_to_transform(\\"a\\", \\"a\\") == 0 assert min_cost_to_transform(\\"b\\", \\"a\\") == 1 def test_min_cost_to_transform_large_inputs(): A = \\"a\\" * 1000 B = \\"b\\" * 1000 assert min_cost_to_transform(A, B) == 1000 A = \\"a\\" * 500 + \\"b\\" * 500 B = \\"b\\" * 500 + \\"a\\" * 500 assert min_cost_to_transform(A, B) == 1000","solution":"def min_cost_to_transform(A, B): Calculates the minimum cost to transform string A into string B. m, n = len(A), len(B) # Create a (m+1) x (n+1) DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): dp[i][0] = i # Cost of deleting all characters from A for j in range(n + 1): dp[0][j] = j # Cost of inserting all characters of B # Fill the table for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"def max_seq_increase(arr: List[int]) -> int: Write a function max_seq_increase(arr) that takes a list of integers arr as input and returns the maximum length of a contiguous subsequence where each subsequent number is greater than the previous one. In other words, find the longest subarray in which each element is strictly greater than the previous element. >>> max_seq_increase([1, 3, 5, 4, 7]) 3 >>> max_seq_increase([2, 2, 2, 2, 2]) 1 >>> max_seq_increase([]) 0 >>> max_seq_increase([1]) 1 >>> max_seq_increase([1, 2, 3, 4, 5]) 5 >>> max_seq_increase([5, 4, 3, 2, 1]) 1 >>> max_seq_increase([1, 3, 2, 4, 6, 3, 4, 5]) 3","solution":"def max_seq_increase(arr): Returns the maximum length of a contiguous subsequence where each subsequent number is greater than the previous one. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, roads: List[Tuple[int, int, int]], s: int, t: int) -> int: Determine the shortest travel time from the starting intersection s to the ending intersection t. Parameters: n (int): The number of intersections. m (int): The number of roads. roads (List[Tuple[int, int, int]]): Each road described by three integers u, v, and w. s (int): The starting intersection. t (int): The ending intersection. Returns: int: The shortest travel time, or -1 if there is no path. def test_shortest_path_example1(): n, m = 5, 6 roads = [ (1, 2, 10), (1, 3, 30), (2, 3, 20), (2, 4, 50), (3, 4, 10), (3, 5, 60) ] s, t = 1, 4 assert shortest_path(n, m, roads, s, t) == 40 def test_shortest_path_example2(): n, m = 3, 1 roads = [ (1, 2, 10) ] s, t = 1, 3 assert shortest_path(n, m, roads, s, t) == -1 def test_shortest_path_no_path(): n, m = 4, 2 roads = [ (1, 2, 5), (3, 4, 10) ] s, t = 1, 4 assert shortest_path(n, m, roads, s, t) == -1 def test_shortest_path_self_contained(): n, m = 3, 3 roads = [ (1, 2, 10), (2, 3, 10), (1, 3, 20) ] s, t = 1, 3 assert shortest_path(n, m, roads, s, t) == 20 def test_shortest_path_alternate_path(): n, m = 4, 4 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10) ] s, t = 1, 4 assert shortest_path(n, m, roads, s, t) == 3","solution":"import heapq def shortest_path(n, m, roads, s, t): # Create adjacency list adj = [[] for _ in range(n)] for u, v, w in roads: adj[u - 1].append((w, v - 1)) # Initialize distance array dist = [float('inf')] * n dist[s - 1] = 0 # Priority queue for Dijkstra's Algorithm pq = [(0, s - 1)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for weight, v in adj[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist[t - 1] if dist[t - 1] != float('inf') else -1"},{"question":"def calculate_active_time(n: int, logs: List[Tuple[str, int, int]]) -> Dict[int, int]: Calculate the total active time for each user based on the given logs. Args: n (int): The number of logs. logs (list of tuple): List containing tuples, each representing a log entry with: - action (str): \\"start\\" or \\"end\\" - user_id (int): The user's unique identifier - timestamp (int): The timestamp of the action Returns: dict: A dictionary where the keys are user ids and values are total active time. pass def format_output(active_time_dict: Dict[int, int]) -> str: Format the output for the active time dictionary. Args: active_time_dict (dict): Dictionary with user ids and their active time. Returns: str: Formatted string for each user id and their active time. pass # Example usage if __name__ == \\"__main__\\": logs = [ (\\"start\\", 1, 5), (\\"end\\", 1, 10), (\\"start\\", 2, 20), (\\"end\\", 2, 30), (\\"start\\", 1, 35), (\\"end\\", 1, 45) ] n = len(logs) active_time = calculate_active_time(n, logs) output = format_output(active_time) print(output)","solution":"def calculate_active_time(n, logs): Calculates the total active time for each user based on the given logs. Args: n (int): The number of logs. logs (list of tuple): List containing tuples, each representing a log entry with: - action (str): \\"start\\" or \\"end\\" - user_id (int): The user's unique identifier - timestamp (int): The timestamp of the action Returns: dict: A dictionary where the keys are user ids and values are total active time. active_time = {} ongoing_activity = {} for action, user_id, timestamp in logs: if action == \\"start\\": ongoing_activity[user_id] = timestamp elif action == \\"end\\": if user_id in ongoing_activity: start_time = ongoing_activity.pop(user_id) if user_id in active_time: active_time[user_id] += timestamp - start_time else: active_time[user_id] = timestamp - start_time return dict(sorted(active_time.items())) def format_output(active_time_dict): Formats the output for the active time dictionary. Args: active_time_dict (dict): Dictionary with user ids and their active time. Returns: str: Formatted string for each user id and their active time. result = [] for user_id, time in active_time_dict.items(): result.append(f\\"{user_id} {time}\\") return \\"n\\".join(result)"},{"question":"def longest_ors(s): Calculate the length of the longest Overlapping Repeating Substring (ORS) in a given string. An ORS is a non-empty substring that occurs more than once and can overlap. >>> longest_ors(\\"ababab\\") 4 >>> longest_ors(\\"abcd\\") 0 >>> longest_ors(\\"aaaa\\") 3 pass def main(input_list): Calculate the length of the longest ORS for multiple strings based on input list format. The first element of the input list is the number of test cases, followed by the strings. >>> main([\\"3\\", \\"ababab\\", \\"abcd\\", \\"aaaa\\"]) [4, 0, 3] >>> main([\\"2\\", \\"abcabcabc\\", \\"xyxyxyxyxy\\"]) [6, 8] pass","solution":"def longest_ors(s): def is_overlap(l, s): for i in range(len(s) - l + 1): if s[i:i+l] in s[i+1:]: return True return False max_len = 0 n = len(s) for length in range(1, n): if is_overlap(length, s): max_len = length return max_len def main(input_list): T = int(input_list[0]) results = [] for i in range(1, T + 1): s = input_list[i] results.append(longest_ors(s)) return results"},{"question":"def are_anagrams(s1: str, s2: str) -> str: Determines if two strings are anagrams of each other. Returns \\"ANAGRAM\\" if they are anagrams, \\"NOT ANAGRAM\\" otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"ANAGRAM\\" >>> are_anagrams(\\"apple\\", \\"pale\\") \\"NOT ANAGRAM\\" def anagram_checker(test_cases: list) -> list: Processes multiple test cases to check if pairs of strings are anagrams. Parameters: test_cases (list): A list of tuples where each tuple contains two strings. Returns: list: A list of results (\\"ANAGRAM\\" or \\"NOT ANAGRAM\\") for each test case. >>> anagram_checker([(\\"listen\\", \\"silent\\"), (\\"apple\\", \\"pale\\")]) [\\"ANAGRAM\\", \\"NOT ANAGRAM\\"]","solution":"def are_anagrams(s1, s2): Determines if two strings are anagrams of each other. Returns \\"ANAGRAM\\" if they are anagrams, \\"NOT ANAGRAM\\" otherwise. if sorted(s1) == sorted(s2): return \\"ANAGRAM\\" else: return \\"NOT ANAGRAM\\" def anagram_checker(test_cases): Processes multiple test cases to check if pairs of strings are anagrams. Parameters: test_cases (list): A list of tuples where each tuple contains two strings. Returns: list: A list of results (\\"ANAGRAM\\" or \\"NOT ANAGRAM\\") for each test case. results = [] for s1, s2 in test_cases: result = are_anagrams(s1, s2) results.append(result) return results"},{"question":"def can_form_palindrome(s: str) -> str: Determine if you can replace the question marks in s to produce a palindrome. >>> can_form_palindrome(\\"a?b??a\\") 'YES' >>> can_form_palindrome(\\"ab?cb\\") 'NO' >>> can_form_palindrome(\\"x?x\\") 'YES' >>> can_form_palindrome(\\"?z?\\") 'YES'","solution":"def can_form_palindrome(s): Determines if it is possible to replace the question marks in s to produce a palindrome. n = len(s) s = list(s) # Convert to list for mutability for i in range(n // 2): left = s[i] right = s[n - i - 1] if left == '?' and right == '?': s[i] = s[n - i - 1] = 'a' # Choose 'a' arbitrarily elif left == '?': s[i] = right elif right == '?': s[n - i - 1] = left elif left != right: return \\"NO\\" return \\"YES\\""},{"question":"def can_make_identical(n: int, a: List[int], b: List[int]) -> str: Determines if two arrays of integers can be made identical by permuting the elements of the second array. >>> can_make_identical(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) \\"YES\\" >>> can_make_identical(3, [1, 2, 2], [2, 2, 3]) \\"NO\\" >>> can_make_identical(4, [1, 1, 2, 2], [2, 2, 1, 1]) \\"YES\\"","solution":"def can_make_identical(n, a, b): Determines if two arrays of integers can be made identical by permuting the elements of the second array. Parameters: n (int): The number of elements in each array. a (list of int): The first array. b (list of int): The second array. Returns: str: \\"YES\\" if we can make the arrays identical by permuting the elements of \`b\`, otherwise \\"NO\\". if sorted(a) == sorted(b): return \\"YES\\" else: return \\"NO\\""},{"question":"def calculatePaths(matrix): Counts the number of unique paths from the top-left corner to the bottom-right corner of a grid, given that some cells in the grid are \\"blocked\\". A blocked cell cannot be part of any path. You can only move either down or right at any point in time. :param matrix: List[List[int]], a 2D list where 0 represents a free cell and 1 represents a blocked cell. :return: int, number of unique paths. >>> calculatePaths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> calculatePaths([ ... [0, 1], ... [0, 0] ... ]) 1","solution":"def calculatePaths(matrix): Counts the number of unique paths from the top-left corner to the bottom-right corner of a grid, given that some cells in the grid are \\"blocked\\". A blocked cell cannot be part of any path. You can only move either down or right at any point in time. :param matrix: List[List[int]], a 2D list where 0 represents a free cell and 1 represents a blocked cell. :return: int, number of unique paths. if not matrix or matrix[0][0] == 1 or matrix[-1][-1] == 1: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if matrix[i][j] == 1: dp[i][j] = 0 # Blocked cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def count_divisible_subarray(arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: You are given an array of n integers and q queries. Each query is given as a triplet (l, r, k), where you need to count the number of elements in the subarray from index l to r (inclusive) that are divisible by k. >>> count_divisible_subarray([1, 2, 3, 4, 5], [(1, 3, 1), (2, 4, 2), (1, 5, 3)]) [3, 2, 1] >>> count_divisible_subarray([8, 16, 32, 64], [(1, 4, 8), (2, 3, 16)]) [4, 2]","solution":"def count_divisible_subarray(arr, queries): results = [] for l, r, k in queries: count = 0 for i in range(l-1, r): if arr[i] % k == 0: count += 1 results.append(count) return results"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Determine the length of the longest possible substring of the transformed string that contains at most K distinct characters. >>> longest_substring_with_k_distinct(\\"abcba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"abcd\\", 1) 1 >>> longest_substring_with_k_distinct(\\"aabbcc\\", 1) 2","solution":"def longest_substring_with_k_distinct(s, k): if not s or k == 0: return 0 char_count = {} left = 0 max_length = 0 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_coin_value(n: int, coins: List[int]) -> int: Alice wants to figure out the maximum possible number that can be obtained by performing a series of operations on the coins. Input: n (int): number of coins (1 ≤ n ≤ 100). coins (List[int]): list of numbers engraved on the coins (1 ≤ ai ≤ 10^9). Returns: int: the maximum possible number that can be obtained. Examples: >>> max_coin_value(4, [3, 8, 5, 7]) 23 >>> max_coin_value(3, [1, 1, 1]) 3 >>> max_coin_value(2, [10, 50]) 60","solution":"def max_coin_value(n, coins): Returns the maximum possible number that can be obtained by performing a series of operations on the coins. # The maximum number that can be obtained is simply the sum of all coin values. return sum(coins)"},{"question":"from typing import List, Tuple def unique_paths(N: int, M: int) -> int: Returns the number of distinct paths from the top-left to the bottom-right corner of an N x M grid. The robot can only move right or down. >>> unique_paths(2, 2) 2 >>> unique_paths(3, 2) 3 def number_of_paths_for_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process multiple test cases to determine the number of distinct paths for each. >>> number_of_paths_for_cases([(2, 2), (3, 2), (3, 3), (1, 1), (1, 5)]) [2, 3, 6, 1, 1] if __name__ == \\"__main__\\": T = int(input()) test_cases = [] for _ in range(T): N, M = map(int, input().split()) test_cases.append((N, M)) results = number_of_paths_for_cases(test_cases) for result in results: print(result)","solution":"def unique_paths(N, M): Returns the number of distinct paths from the top-left to the bottom-right corner of an N x M grid. The robot can only move right or down. # Create a 2D array to store the number of paths to each cell dp = [[1] * M for _ in range(N)] # Calculate the number of paths for each cell for i in range(1, N): for j in range(1, M): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the result return dp[N-1][M-1] def number_of_paths_for_cases(test_cases): Process multiple test cases to determine the number of distinct paths for each. results = [] for N, M in test_cases: results.append(unique_paths(N, M)) return results if __name__ == \\"__main__\\": T = int(input()) test_cases = [] for _ in range(T): N, M = map(int, input().split()) test_cases.append((N, M)) results = number_of_paths_for_cases(test_cases) for result in results: print(result)"},{"question":"def rotate_password(password: str, k: int) -> str: Rotates the given password to the left by k positions. :param password: str - the original password :param k: int - the number of positions to rotate left :return: str - the rotated password >>> rotate_password(\\"abcdef\\", 2) 'cdefab' >>> rotate_password(\\"hello\\", 3) 'lohel' >>> rotate_password(\\"security\\", 0) 'security' >>> rotate_password(\\"securepassword\\", 14) 'securepassword' >>> rotate_password(\\"rotate\\", 1) 'otater' >>> rotate_password(\\"a\\", 0) 'a' >>> rotate_password(\\"python\\", 4) 'onpyth' >>> rotate_password(\\"password\\", 7) 'dpasswor' >>> rotate_password(\\"\\", 0) '' >>> rotate_password(\\"abcd\\", 4) 'abcd' >>> rotate_password(\\"test\\", 4) 'test' >>> rotate_password(\\"rotate\\", 6) 'rotate' >>> rotate_password(\\"123456\\", 2) '345612' >>> rotate_password(\\"!@#%^\\", 3) '%^!@#'","solution":"def rotate_password(password, k): Rotates the given password to the left by k positions. :param password: str - the original password :param k: int - the number of positions to rotate left :return: str - the rotated password n = len(password) # Rotate the password by slicing and concatenating rotated_password = password[k:] + password[:k] return rotated_password"},{"question":"class CircularQueue: def __init__(self, n: int): Initializes the queue with a fixed size n pass def enqueue(self, x: int): Adds an integer x to the queue pass def dequeue(self) -> int: Removes and returns the oldest element from the queue pass def peek(self) -> int: Returns the oldest element without removing it from queue pass def size(self) -> int: Returns the number of elements currently in the queue pass Example: q = CircularQueue(3) q.enqueue(1) q.enqueue(2) print(q.peek()) # Should print 1 print(q.size()) # Should print 2 print(q.dequeue()) # Should print 1 q.enqueue(3) q.enqueue(4) q.enqueue(5) print(q.size()) # Should print 3 print(q.peek()) # Should print 3 print(q.dequeue()) # Should print 3 Unit Test: def test_circular_queue_operations(): q = CircularQueue(3) assert q.size() == 0 q.enqueue(1) assert q.size() == 1 assert q.peek() == 1 q.enqueue(2) assert q.size() == 2 assert q.peek() == 1 assert q.dequeue() == 1 assert q.size() == 1 assert q.peek() == 2 q.enqueue(3) q.enqueue(4) assert q.size() == 3 assert q.peek() == 2 q.enqueue(5) assert q.size() == 3 assert q.peek() == 3 # 2 was dequeued automatically to make space for 5 assert q.dequeue() == 3 assert q.size() == 2 assert q.peek() == 4 assert q.dequeue() == 4 assert q.dequeue() == 5 assert q.dequeue() == None assert q.size() == 0 def test_circular_queue_edge_case(): q = CircularQueue(1) assert q.size() == 0 q.enqueue(1) assert q.size() == 1 assert q.peek() == 1 q.enqueue(2) assert q.size() == 1 assert q.peek() == 2 assert q.dequeue() == 2 assert q.size() == 0 assert q.peek() == None assert q.dequeue() == None","solution":"class CircularQueue: def __init__(self, n: int): Initializes the queue with a fixed size n self.queue = [None] * n self.max_size = n self.start = 0 self.end = 0 self.count = 0 def enqueue(self, x: int): Adds an integer x to the queue if self.count == self.max_size: self.start = (self.start + 1) % self.max_size else: self.count += 1 self.queue[self.end] = x self.end = (self.end + 1) % self.max_size def dequeue(self) -> int: Removes and returns the oldest element from the queue if self.count == 0: return None element = self.queue[self.start] self.queue[self.start] = None self.start = (self.start + 1) % self.max_size self.count -= 1 return element def peek(self) -> int: Returns the oldest element without removing it from queue if self.count == 0: return None return self.queue[self.start] def size(self) -> int: Returns the number of elements currently in the queue return self.count"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to transform a string s into a palindrome. >>> min_operations_to_palindrome('abca') == 1 >>> min_operations_to_palindrome('racecar') == 0 >>> min_operations_to_palindrome('abcd') == 2 >>> min_operations_to_palindrome('a') == 0 >>> min_operations_to_palindrome('aaa') == 0 >>> min_operations_to_palindrome('abcba') == 0 >>> min_operations_to_palindrome('abccba') == 0 >>> min_operations_to_palindrome('abcdef') == 3 def solve(test_cases: List[str]) -> List[int]: Given a list of test cases, return a list of results where each result is the minimum number of operations required to transform the corresponding string into a palindrome. >>> solve(['abca', 'racecar', 'abcd']) == [1, 0, 2] >>> solve(['abcd', 'a', 'zzz', 'abcdefghij', 'level']) == [2, 0, 0, 5, 0]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to transform a string s into a palindrome. n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations def solve(test_cases): results = [] for s in test_cases: results.append(min_operations_to_palindrome(s)) return results"},{"question":"from collections import Counter def longest_k_beautiful_string(s: str, k: int) -> int: Find the length of the longest possible k-beautiful string that can be achieved by removing some characters from the input string. Input: s - a string consisting of lowercase English letters (1 ≤ |s| ≤ 100,000) k - an integer (1 ≤ k ≤ 100,000) Output: The length of the longest k-beautiful string. Examples: >>> longest_k_beautiful_string(\\"aabbcc\\", 2) 6 >>> longest_k_beautiful_string(\\"abc\\", 2) 0 >>> longest_k_beautiful_string(\\"aaabbbccc\\", 3) 9","solution":"from collections import Counter def longest_k_beautiful_string(s, k): Returns the length of the longest k-beautiful string that can be achieved. if k <= 0 or not s: return 0 counter = Counter(s) length = 0 for char, count in counter.items(): if count >= k: length += (count // k) * k return length"},{"question":"def is_product_even(X: int, Y: int, Z: int) -> str: Determines if it is possible to choose two integers from X, Y, and Z such that their product is even. Parameters: X, Y, Z (int): Three integers each between 1 and 4 (inclusive). Returns: str: \\"Yes\\" if it's possible to choose two integers such that their product is even, otherwise \\"No\\". Examples: >>> is_product_even(2, 3, 4) \\"Yes\\" >>> is_product_even(1, 3, 3) \\"No\\" >>> is_product_even(1, 2, 1) \\"Yes\\"","solution":"def is_product_even(X, Y, Z): Determines if it is possible to choose two integers from X, Y, and Z such that their product is even. Parameters: X, Y, Z (int): Three integers each between 1 and 4 (inclusive). Returns: str: \\"Yes\\" if it's possible to choose two integers such that their product is even, otherwise \\"No\\". def is_even(n): return n % 2 == 0 # Check all possible pairs among X, Y, and Z pairs = [(X, Y), (X, Z), (Y, Z)] for (a, b) in pairs: if is_even(a) or is_even(b): return \\"Yes\\" return \\"No\\""},{"question":"def longest_common_subsequence_length(s1: str, s2: str) -> int: Returns the length of the longest substring that is a subsequence of both s1 and s2. >>> longest_common_subsequence_length(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence_length(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence_length(\\"abc\\", \\"def\\") 0 from solution import longest_common_subsequence_length def test_example_1(): assert longest_common_subsequence_length(\\"abcde\\", \\"ace\\") == 3 def test_example_2(): assert longest_common_subsequence_length(\\"abc\\", \\"abc\\") == 3 def test_example_3(): assert longest_common_subsequence_length(\\"abc\\", \\"def\\") == 0 def test_different_lengths(): assert longest_common_subsequence_length(\\"abcd\\", \\"ab\\") == 2 def test_no_common_subsequence(): assert longest_common_subsequence_length(\\"abc\\", \\"xyz\\") == 0 def test_partial_subsequence_match(): assert longest_common_subsequence_length(\\"abcde\\", \\"ebcda\\") == 3 def test_repeating_characters(): assert longest_common_subsequence_length(\\"aab\\", \\"azb\\") == 2 def test_empty_string_as_input(): assert longest_common_subsequence_length(\\"\\", \\"\\") == 0 def test_all_characters_match(): assert longest_common_subsequence_length(\\"abcd\\", \\"abcd\\") == 4","solution":"def longest_common_subsequence_length(s1, s2): Returns the length of the longest substring that is a subsequence of both s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the characters of the given string such that no two adjacent characters are the same. If it is not possible, returns \\"Not Possible\\". Args: s (str): The input string consisting of lowercase alphabetical characters. Returns: str: Rearranged string where no two adjacent characters are the same or \\"Not Possible\\". Examples: >>> rearrange_string(\\"aabbcc\\") \\"abcabc\\" >>> rearrange_string(\\"aaab\\") \\"Not Possible\\" >>> rearrange_string(\\"aabbc\\") \\"abcab\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the characters of the input string such that no two adjacent characters are the same. If it is impossible to do so, returns \\"Not Possible\\". frequency = Counter(s) max_heap = [(-count, char) for char, count in frequency.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # If there's a previously used character, push it back to the heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character to the current one prev_count, prev_char = count + 1, char result = ''.join(result) if len(result) != len(s): return \\"Not Possible\\" return result"},{"question":"from collections import deque class CustomerQueue: A customer queue management system that supports enqueue, dequeue, and serve operations. def __init__(self): Initialize an empty queue. self.queue = deque() def enqueue(self, id): Add a customer identified by id to the end of the queue. pass # Implement the enqueue operation def dequeue(self): Remove and return the customer at the front of the queue. If the queue is empty, return 'Queue Underflow'. pass # Implement the dequeue operation def serve(self, n): Remove and return the first n customers from the front of the queue. If there are fewer than n customers, return those present. If the queue is empty, return 'Queue Underflow'. pass # Implement the serve operation # Unit tests def test_enqueue_and_dequeue(): queue = CustomerQueue() queue.enqueue(5) queue.enqueue(3) assert queue.dequeue() == 5 assert queue.dequeue() == 3 assert queue.dequeue() == \\"Queue Underflow\\" def test_serve(): queue = CustomerQueue() queue.enqueue(5) queue.enqueue(3) queue.enqueue(9) assert queue.serve(2) == \\"5 3\\" assert queue.serve(2) == \\"9\\" assert queue.serve(1) == \\"Queue Underflow\\" def test_mix_operations(): queue = CustomerQueue() queue.enqueue(5) queue.enqueue(3) assert queue.dequeue() == 5 queue.enqueue(9) assert queue.serve(2) == \\"3 9\\" assert queue.dequeue() == \\"Queue Underflow\\" assert queue.serve(1) == \\"Queue Underflow\\"","solution":"from collections import deque class CustomerQueue: def __init__(self): self.queue = deque() def enqueue(self, id): self.queue.append(id) def dequeue(self): if not self.queue: return \\"Queue Underflow\\" return self.queue.popleft() def serve(self, n): if len(self.queue) < n: n = len(self.queue) if n == 0: return \\"Queue Underflow\\" served_customers = [] for _ in range(n): served_customers.append(self.queue.popleft()) return \\" \\".join(map(str, served_customers))"},{"question":"def find_unique_integer(test_cases: List[List[int]]) -> List[int]: Returns a list of unique integers from each test case. >>> find_unique_integer([[1, 2, 3, 2, 1]]) == [3] >>> find_unique_integer([[1, 2, 3, 2, 1], [4, 5, 6, 4, 5], [7, 8, 8, 9, 9, 7, 10]]) == [3, 6, 10] >>> find_unique_integer([[1, 1, 100000, 99999, 99999]]) == [100000] >>> find_unique_integer([[12345, 54321, 12345]]) == [54321] >>> find_unique_integer([[42]]) == [42]","solution":"def find_unique_integer(test_cases): Returns a list of unique integers from each test case. unique_integers = [] for case in test_cases: unique_integer = 0 for num in case: unique_integer ^= num # XOR operation will cancel out duplicate numbers unique_integers.append(unique_integer) return unique_integers"},{"question":"def min_bonus(n: int, performances: List[int]) -> int: Calculate the minimum total amount of bonus units that the company must allocate based on performance ratings. >>> min_bonus(4, [1, 2, 2, 3]) 6 >>> min_bonus(1, [5]) 1 >>> min_bonus(3, [3, 3, 3]) 3 >>> min_bonus(5, [1, 2, 3, 4, 5]) 15 >>> min_bonus(5, [5, 4, 3, 2, 1]) 15 >>> min_bonus(5, [1, 3, 2, 4, 2]) 7 >>> min_bonus(6, [1, 2, 1, 2, 1, 2]) 9","solution":"def min_bonus(n, performances): if n == 0: return 0 # Initialize all bonuses to 1 unit bonuses = [1] * n # First pass from left to right for i in range(1, n): if performances[i] > performances[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Second pass from right to left for i in range(n - 2, -1, -1): if performances[i] > performances[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses) # Example usage if __name__ == \\"__main__\\": n = 4 performances = [1, 2, 2, 3] print(min_bonus(n, performances)) # Output: 6"},{"question":"def minimum_toggles(n: int, target: str) -> int: Given the number of bulbs n and the target configuration, this function returns the minimum number of toggle operations required. Args: n (int): the number of light bulbs (1 <= n <= 10^5). target (str): target configuration represented as a binary string of length n. Returns: int: the minimum number of toggles required to achieve the target configuration. Examples: >>> minimum_toggles(5, \\"10101\\") 3 >>> minimum_toggles(3, \\"111\\") 1 >>> minimum_toggles(7, \\"0000000\\") 0 # Your code here","solution":"def minimum_toggles(n, target): Given the number of bulbs n and the target configuration, this function returns the minimum number of toggle operations required. # Initial state is all \\"0\\"s initial_state = \\"0\\" * n # Count the number of times we see a change from '0' to '1' or '1' to '0' # This change indicates a new range that will need to be toggled. toggles = 0 for i in range(n): if initial_state[i] != target[i]: toggles += 1 while i < n and initial_state[i] != target[i]: initial_state = initial_state[:i] + target[i] + initial_state[i+1:] i += 1 return toggles"},{"question":"def largest_rectangle_area(buildings): Find the maximum area of a rectangle that can be formed by any contiguous set of buildings. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([4, 4, 4, 4, 4]) 20 >>> largest_rectangle_area([3, 2, 2]) 6","solution":"def largest_rectangle_area(buildings): Find the maximum area of a rectangle that can be formed by any contiguous set of buildings. stack = [] max_area = 0 index = 0 while index < len(buildings): if not stack or buildings[stack[-1]] <= buildings[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (buildings[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (buildings[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) buildings = list(map(int, data[1:])) print(largest_rectangle_area(buildings))"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the sum of the largest contiguous subarray. Args: nums (list): List of integers. Returns: int: Sum of the largest contiguous subarray. Examples: >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6","solution":"def max_subarray_sum(nums): Returns the sum of the largest contiguous subarray. Args: nums (list): List of integers. Returns: int: Sum of the largest contiguous subarray. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def transform_list(lst): Transform the list such that each element in the new list is the sum of itself and all previous elements in the original list. >>> transform_list([1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> transform_list([-1, 2, 3]) [-1, 1, 4] >>> transform_list([0, 0, 0, 0]) [0, 0, 0, 0] >>> transform_list([5]) [5] >>> transform_list([-5]) [-5] >>> transform_list([3, -2, 1, -4, 5]) [3, 1, 2, -2, 3] >>> transform_list([100] * 100) [i * 100 for i in range(1, 101)]","solution":"def transform_list(lst): Transform the list such that each element in the new list is the sum of itself and all previous elements in the original list. transformed_list = [] current_sum = 0 for num in lst: current_sum += num transformed_list.append(current_sum) return transformed_list def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) lst = list(map(int, data[1:])) result = transform_list(lst) print(' '.join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"def even_odd_sort(n: int, arr: List[int]) -> List[int]: Sort an array such that even numbers are sorted in non-decreasing order and appear before odd numbers which are sorted in non-increasing order. Parameters: n (int): Number of elements in the array arr (list of int): The original array to be sorted Returns: list of int: The sorted array >>> even_odd_sort(6, [4, 1, 3, 2, 8, 5]) [2, 4, 8, 5, 3, 1] >>> even_odd_sort(5, [10, 11, 7, 12, 6]) [6, 10, 12, 11, 7] >>> even_odd_sort(4, [1, 3, 2, 2]) [2, 2, 3, 1] pass def test_even_odd_sort_example_1(): assert even_odd_sort(6, [4, 1, 3, 2, 8, 5]) == [2, 4, 8, 5, 3, 1] def test_even_odd_sort_example_2(): assert even_odd_sort(5, [10, 11, 7, 12, 6]) == [6, 10, 12, 11, 7] def test_even_odd_sort_example_3(): assert even_odd_sort(4, [1, 3, 2, 2]) == [2, 2, 3, 1] def test_even_odd_sort_single_element(): assert even_odd_sort(1, [4]) == [4] assert even_odd_sort(1, [5]) == [5] def test_even_odd_sort_combined_even_odd(): assert even_odd_sort(5, [1, 3, 2, 4, 6]) == [2, 4, 6, 3, 1] assert even_odd_sort(6, [9, 7, 5, 8, 6, 4]) == [4, 6, 8, 9, 7, 5] def test_even_odd_sort_all_even(): assert even_odd_sort(4, [8, 4, 12, 2]) == [2, 4, 8, 12] def test_even_odd_sort_all_odd(): assert even_odd_sort(3, [9, 5, 3]) == [9, 5, 3] def test_even_odd_sort_no_elements(): assert even_odd_sort(0, []) == []","solution":"def even_odd_sort(n, arr): Sort an array such that even numbers are sorted in non-decreasing order and appear before odd numbers which are sorted in non-increasing order. Parameters: n (int): Number of elements in the array arr (list of int): The original array to be sorted Returns: list of int: The sorted array evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0], reverse=True) return evens + odds"},{"question":"def min_damage_to_eliminate_monsters(n, strengths): Returns the minimum total damage to eliminate all monsters by combining monsters with no damage and eliminating the monsters while taking damage equal to their strength. pass # Unit tests for the function def test_example1(): assert min_damage_to_eliminate_monsters(3, [2, 7, 4]) == 13 def test_example2(): assert min_damage_to_eliminate_monsters(4, [1, 2, 3, 4]) == 10 def test_single_monster(): assert min_damage_to_eliminate_monsters(1, [5]) == 5 def test_two_monsters(): assert min_damage_to_eliminate_monsters(2, [6, 1]) == 7 assert min_damage_to_eliminate_monsters(2, [1, 1]) == 2 def test_large_number_of_monsters(): assert min_damage_to_eliminate_monsters(5, [10, 20, 30, 40, 50]) == 150 assert min_damage_to_eliminate_monsters(3, [3, 3, 3]) == 9 def test_identical_strength_monsters(): assert min_damage_to_eliminate_monsters(6, [2, 2, 2, 2, 2, 2]) == 12 def test_increasing_strength_monsters(): assert min_damage_to_eliminate_monsters(5, [1, 2, 3, 4, 5]) == 15","solution":"import heapq def min_damage_to_eliminate_monsters(n, strengths): Returns the minimum total damage to eliminate all monsters by combining monsters with no damage and eliminating the monsters while taking damage equal to their strength. if n == 1: return strengths[0] # Min-heap to process the smallest values first heapq.heapify(strengths) total_damage = 0 while len(strengths) > 1: # Always eliminate the monster with the smallest strength damage = heapq.heappop(strengths) total_damage += damage # Eliminate the last remaining monster total_damage += heapq.heappop(strengths) return total_damage"},{"question":"def first_fibonacci_greater_than(n: int) -> int: Returns the first Fibonacci number greater than the given input n. >>> first_fibonacci_greater_than(50) 55 >>> first_fibonacci_greater_than(60) 89 >>> first_fibonacci_greater_than(0) 1 >>> first_fibonacci_greater_than(-10) is None True >>> first_fibonacci_greater_than(2178309) 3524578","solution":"def first_fibonacci_greater_than(n): Returns the first Fibonacci number greater than the given input n. if n < 0: return None a, b = 0, 1 while b <= n: a, b = b, a + b return b"},{"question":"def contains_anagram(words: list) -> str: Determine if there is any word in the collection that is an anagram of another word in the collection. Args: words (list of str): List of words. Returns: str: \\"YES\\" if there is at least one pair of anagrams, otherwise \\"NO\\". >>> contains_anagram([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\"]) == \\"YES\\" >>> contains_anagram([\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\"]) == \\"NO\\" >>> contains_anagram([\\"a\\", \\"b\\", \\"c\\"]) == \\"NO\\" >>> contains_anagram([\\"ab\\", \\"ba\\", \\"abc\\", \\"bac\\"]) == \\"YES\\" >>> contains_anagram([\\"apple\\"]) == \\"NO\\" >>> contains_anagram([]) == \\"NO\\"","solution":"def contains_anagram(words): Determine if there is any word in the collection that is an anagram of another word in the collection. Args: words (list of str): List of words. Returns: str: \\"YES\\" if there is at least one pair of anagrams, otherwise \\"NO\\". sorted_words = [''.join(sorted(word)) for word in words] if len(sorted_words) != len(set(sorted_words)): return \\"YES\\" else: return \\"NO\\" # Example usage: # words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\"] # print(contains_anagram(words)) # Output: \\"YES\\""},{"question":"from typing import List def can_make_strings_identical(S: str, T: str) -> str: Determine if it is possible to make strings S and T identical using any number of swaps of positions with same characters. Args: S : str : first string T : str : second string Returns: str : \\"YES\\" if it is possible to make the strings identical, otherwise \\"NO\\". Test Cases: >>> can_make_strings_identical(\\"abc\\", \\"bca\\") \\"YES\\" >>> can_make_strings_identical(\\"abcd\\", \\"dcba\\") \\"YES\\" >>> can_make_strings_identical(\\"abcde\\", \\"abcfz\\") \\"NO\\"","solution":"def can_make_strings_identical(S, T): Determine if it is possible to make strings S and T identical by swapping characters in specified conditions. # If S and T have the same characters and same frequencies # we can always swap to make them identical from collections import Counter # Count frequencies of characters in both strings count_S = Counter(S) count_T = Counter(T) # Compare the frequency counters if count_S == count_T: return \\"YES\\" else: return \\"NO\\""},{"question":"def lcs_length(s1: str, s2: str) -> int: Find the length of the longest common subsequence (LCS) of two strings. The LCS is the longest sequence that can be derived from both strings by deleting some characters. Ensures a solution with a time complexity of O(m * n), where m and n are the lengths of s1 and s2 respectively. >>> lcs_length(\\"abcde\\", \\"ace\\") 3 >>> lcs_length(\\"abc\\", \\"abc\\") 3 >>> lcs_length(\\"abc\\", \\"def\\") 0 def process_test_cases(input_data: str) -> list: Process multiple test cases for the LCS problem from a single input string. Each test case consists of two strings, s1 and s2, and the function returns a list of results for each test case. >>> process_test_cases(\\"3nabcdenacenabcnabcnabcndef\\") [3, 3, 0] >>> process_test_cases(\\"2ndefnabcnabcdnefgh\\") [0, 0]","solution":"def lcs_length(s1, s2): m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def process_test_cases(input_data): lines = input_data.strip().split('n') t = int(lines[0]) index = 1 results = [] for _ in range(t): s1 = lines[index] s2 = lines[index + 1] result = lcs_length(s1, s2) results.append(result) index += 2 return results"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Write a function that determines if it is possible to color the graph using exactly two colors such that no two adjacent nodes share the same color. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): List of edges, where each edge is represented by a tuple of two integers (u, v). Returns: str: \\"YES\\" if the graph can be 2-colored, otherwise \\"NO\\". Examples: >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\"","solution":"def is_bipartite(n, m, edges): from collections import defaultdict, deque # Build the adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize the color dictionary color = {} # Try to color the graph using BFS def bfs(start): queue = deque([start]) color[start] = 0 # Start by coloring the first node with color 0 while queue: node = queue.popleft() current_color = color[node] next_color = 1 - current_color for neighbor in graph[node]: if neighbor not in color: color[neighbor] = next_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True # Check all disconnected components of the graph for node in range(1, n + 1): if node not in color: if not bfs(node): return \\"NO\\" return \\"YES\\" # Example usage def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] for i in range(m): u = int(data[2 + 2 * i]) v = int(data[3 + 2 * i]) edges.append((u, v)) result = is_bipartite(n, m, edges) print(result)"},{"question":"def find_missing_positive(n: int, arr: List[int]) -> int: Returns the minimum positive integer that does not appear in the array. Args: n (int): The length of the array. arr (List[int]): The list of positive integers. Returns: int: The minimum positive integer that does not appear in the array. Examples: >>> find_missing_positive(3, [1, 2, 0]) 3 >>> find_missing_positive(5, [3, 4, -1, 1, 2]) 5 >>> find_missing_positive(3, [1, 2, 3]) 4 >>> find_missing_positive(1, [1]) 2 >>> find_missing_positive(1, [2]) 1 >>> find_missing_positive(3, [-1, -2, -3]) 1 >>> find_missing_positive(6, [7, 2, 3, 1, 6, 5]) 4 >>> find_missing_positive(1000, list(range(1, 1001))) 1001 >>> find_missing_positive(3, [100, 200, 300]) 1","solution":"def find_missing_positive(n, arr): Returns the minimum positive integer that does not appear in the array. # Create a set of the given array elements number_set = set(arr) # Start checking from 1 upwards current_number = 1 while current_number in number_set: current_number += 1 return current_number"},{"question":"import heapq import sys from typing import List, Tuple def minimum_travel_time(N: int, M: int, L: int, roads: List[Tuple[int, int, int]], A: int, B: int) -> int: Determine the minimum travel time required for the king to travel from city A to city B without using any road that exceeds the travel time L. Args: N (int): The number of cities. M (int): The number of roads. L (int): The maximum allowed travel time on any road. roads (List[Tuple[int, int, int]]): Each element is a tuple (u, v, w) representing a road between city u and city v with travel time w. A (int): The starting city. B (int): The destination city. Returns: int: The minimum travel time required for travel from city A to city B, or -1 if it is not possible. >>> minimum_travel_time(5, 5, 4, [(1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 5), (1, 5, 10)], 1, 4) 9 >>> minimum_travel_time(3, 3, 2, [(1, 2, 3), (2, 3, 3), (1, 3, 3)], 1, 3) -1","solution":"import heapq import sys def minimum_travel_time(N, M, L, roads, A, B): graph = [[] for _ in range(N + 1)] for u, v, w in roads: if w <= L: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(start, end): min_heap = [(0, start)] distances = [sys.maxsize] * (N + 1) distances[start] = 0 while min_heap: current_distance, node = heapq.heappop(min_heap) if node == end: return current_distance for neighbor, weight in graph[node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 return dijkstra(A, B) # Example usage: N = 5 M = 5 L = 4 roads = [ (1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 5), (1, 5, 10) ] A = 1 B = 4 print(minimum_travel_time(N, M, L, roads, A, B)) # Output: 9"},{"question":"def can_transmute_sequence(n: int, A: List[int], B: List[int]) -> str: Determines if sequence A can be transmuted into sequence B using at most one addition and one multiplication in any order, or just one of those operations. Parameters: n (int): Length of the sequences A (List[int]): Initial sequence of integers B (List[int]): Target sequence of integers Returns: str: \\"YES\\" if the transmutation is possible, otherwise \\"NO\\" Examples: >>> can_transmute_sequence(3, [1, 2, 3], [2, 4, 6]) \\"YES\\" >>> can_transmute_sequence(3, [2, 4, 6], [1, 2, 4]) \\"NO\\"","solution":"def can_transmute_sequence(n, A, B): Determines if sequence A can be transmuted into sequence B using at most one addition and one multiplication in any order, or just one of those operations. # Return immediately if both sequences are the same if A == B: return \\"YES\\" # Try addition first, then multiplication for k in range(n): add_val = B[k] - A[k] simulated_A = [A[i] + add_val for i in range(n)] for m in range(n): if simulated_A[m] != 0: mult_val = B[m] / simulated_A[m] if all(simulated_A[i] * mult_val == B[i] for i in range(n)): return \\"YES\\" # Try multiplication first, then addition for k in range(n): if A[k] != 0: mult_val = B[k] / A[k] simulated_A = [A[i] * mult_val for i in range(n)] add_val = B[k] - simulated_A[k] if all(simulated_A[i] + add_val == B[i] for i in range(n)): return \\"YES\\" return \\"NO\\" # Example usage: # n = 3 # A = [1, 2, 3] # B = [2, 4, 6] # print(can_transmute_sequence(n, A, B)) # Output: YES # n = 3 # A = [2, 4, 6] # B = [1, 2, 4] # print(can_transmute_sequence(n, A, B)) # Output: NO"},{"question":"def sum_of_unique_elements(test_cases: List[List[int]]) -> List[int]: For each list of integers, return the sum of elements that appear exactly once. >>> sum_of_unique_elements([[1, 2, 3, 2, 1]]) -> [3] >>> sum_of_unique_elements([[4, 5, 6, 6, 5, 4, 7]]) -> [7] >>> sum_of_unique_elements([[8, 9, 8, 9, 10]]) -> [10] >>> sum_of_unique_elements([[]]) -> [0] >>> sum_of_unique_elements([[1, 1, 2, 2, 3, 3]]) -> [0] >>> sum_of_unique_elements([[1], [2, 3, 4]]) -> [1, 9]","solution":"def sum_of_unique_elements(test_cases): results = [] for nums in test_cases: count = {} for num in nums: if num in count: count[num] += 1 else: count[num] = 1 unique_sum = sum(num for num, cnt in count.items() if cnt == 1) results.append(unique_sum) return results"},{"question":"def is_arithmetic_sequence(n: int, sequence: List[int]) -> str: Determine if the sequence can be reordered to form an arithmetic sequence. >>> is_arithmetic_sequence(5, [3, 5, 1, 7, 9]) \\"YES\\" >>> is_arithmetic_sequence(4, [1, 2, 4, 7]) \\"NO\\"","solution":"def is_arithmetic_sequence(n, sequence): Determine if the sequence can be reordered to form an arithmetic sequence. :param n: int - number of integers in the sequence :param sequence: list of int - the sequence of integers :return: str - \\"YES\\" if the sequence can be reordered to form an arithmetic sequence, otherwise \\"NO\\" if n == 1: return \\"YES\\" sequence.sort() diff = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i - 1] != diff: return \\"NO\\" return \\"YES\\""},{"question":"def count_peaks(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the number of peaks in each test case. Args: t (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of tuples with each tuple consisting of an integer n and a list of integers representing heights Returns: List[int]: List of integers where each integer represents the number of peaks in the corresponding test case Example: >>> count_peaks(3, [(5, [1, 3, 2, 4, 1]), (3, [1, 2, 3]), (6, [1, 3, 2, 3, 5, 4])]) [2, 0, 2]","solution":"def count_peaks(t, test_cases): results = [] for i in range(t): n, heights = test_cases[i] peak_count = 0 for j in range(1, n - 1): if heights[j] > heights[j - 1] and heights[j] > heights[j + 1]: peak_count += 1 results.append(peak_count) return results"},{"question":"from typing import List, Dict def organize_employees(employees: List[Dict[str, str]]) -> Dict[str, List[str]]: Groups employees by departments and sorts their names by employee IDs within each department. Args: employees (list of dict): List of dictionaries containing employee information. Returns: dict: A dictionary with departments as keys and lists of employee names sorted by their IDs as values. >>> organize_employees([ ... {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\"}, ... {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 2, \\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\"}, ... {\\"id\\": 4, \\"name\\": \\"David\\", \\"department\\": \\"Engineering\\"}, ... {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"department\\": \\"Marketing\\"} ... ]) {'HR': ['Charlie', 'Alice'], 'Engineering': ['Bob', 'David'], 'Marketing': ['Eve']} pass def test_organize_employees(): employees = [ {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\"}, {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\"}, {\\"id\\": 2, \\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\"}, {\\"id\\": 4, \\"name\\": \\"David\\", \\"department\\": \\"Engineering\\"}, {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"department\\": \\"Marketing\\"} ] expected_output = { \\"HR\\": [\\"Charlie\\", \\"Alice\\"], \\"Engineering\\": [\\"Bob\\", \\"David\\"], \\"Marketing\\": [\\"Eve\\"] } assert organize_employees(employees) == expected_output def test_empty_list(): employees = [] expected_output = {} assert organize_employees(employees) == expected_output def test_single_employee(): employees = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\"} ] expected_output = { \\"HR\\": [\\"Alice\\"] } assert organize_employees(employees) == expected_output def test_multiple_departments_single_employee_each(): employees = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\"}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"department\\": \\"Marketing\\"} ] expected_output = { \\"HR\\": [\\"Alice\\"], \\"Engineering\\": [\\"Bob\\"], \\"Marketing\\": [\\"Charlie\\"] } assert organize_employees(employees) == expected_output def test_same_department_multiple_employees(): employees = [ {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\"}, {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"department\\": \\"HR\\"}, {\\"id\\": 2, \\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\"} ] expected_output = { \\"HR\\": [\\"Bob\\", \\"Charlie\\", \\"Alice\\"] } assert organize_employees(employees) == expected_output","solution":"def organize_employees(employees): Groups employees by departments and sorts their names by employee IDs within each department. Args: employees (list of dict): List of dictionaries containing employee information. Returns: dict: A dictionary with departments as keys and lists of employee names sorted by their IDs as values. from collections import defaultdict # Create a defaultdict to hold employees by department. departments = defaultdict(list) # Populate the departments dictionary with employee data. for emp in employees: departments[emp['department']].append((emp['id'], emp['name'])) # Sort employees within each department by ID and extract the names. for dept in departments: departments[dept] = [name for _, name in sorted(departments[dept])] return departments"},{"question":"def car_final_position(w, h, m, car_info): Calculate the final position of cars passing through an intersection. Args: w (int): Width of the intersection. h (int): Height of the intersection. m (int): Number of cars. car_info (list): List of tuples containing entry border, entry position, and wait time for each car. Returns: list: List of tuples representing the final positions of each car. >>> car_final_position(5, 7, 1, [(1, 2, 1)]) [(2, 7)] >>> car_final_position(5, 7, 1, [(2, 3, 0)]) [(5, 3)] >>> car_final_position(5, 7, 1, [(4, 6, 2)]) [(0, 6)] >>> car_final_position(5, 7, 1, [(3, 4, 1)]) [(4, 0)]","solution":"def car_final_position(w, h, m, car_info): def move_car(e, p, t): if e == 1: # bottom border (moves up) initial_x, initial_y = p, 0 final_x, final_y = p, h elif e == 2: # left border (moves right) initial_x, initial_y = 0, p final_x, final_y = w, p elif e == 3: # top border (moves down) initial_x, initial_y = p, h final_x, final_y = p, 0 elif e == 4: # right border (moves left) initial_x, initial_y = w, p final_x, final_y = 0, p # Position just before possible turning before_turn_x = initial_x + t * (final_x - initial_x) // abs(final_x - initial_x) if final_x != initial_x else initial_x before_turn_y = initial_y + t * (final_y - initial_y) // abs(final_y - initial_y) if final_y != initial_y else initial_y # If t is large enough, the car leaves without turning because it crosses the full distance directly return (final_x, final_y) if before_turn_x == final_x or before_turn_y == final_y else (before_turn_x, before_turn_y) positions = [] for e, p, t in car_info: positions.append(move_car(e, p, t)) return positions"},{"question":"def evaluate_expressions(file_path): Reads mathematical expressions from a file and evaluates each expression. Args: file_path (str): The path to the file containing the expressions. Returns: List: A list of results of evaluated expressions from the file. Example: >>> evaluate_expressions(\\"expressions.txt\\") [13, 4.0, 30, 11.0]","solution":"def evaluate_expressions(file_path): results = [] with open(file_path, 'r') as file: for line in file: expression = line.strip() if expression: try: result = eval(expression) results.append(result) except Exception as e: results.append(f\\"Error evaluating expression: {expression}, {e}\\") return results"},{"question":"class ParkingLot: def __init__(self, n): self.spots = ['Empty'] * n self.n = n def park(self): for i in range(self.n): if self.spots[i] == 'Empty': self.spots[i] = 'Occupied' break def leave(self, x): self.spots[x-1] = 'Empty' def check(self): return ' '.join(self.spots) def process_events(n, events): Processes a series of parking lot events and returns the status of parking spots after each 'Check' event. >>> process_events(5, [\\"Park\\", \\"Park\\", \\"Check\\", \\"Leave 1\\", \\"Check\\", \\"Park\\", \\"Check\\"]) ['Occupied Occupied Empty Empty Empty', 'Empty Occupied Empty Empty Empty', 'Occupied Occupied Empty Empty Empty'] >>> process_events(3, [\\"Check\\", \\"Park\\", \\"Check\\"]) ['Empty Empty Empty', 'Occupied Empty Empty'] parking_lot = ParkingLot(n) results = [] for event in events: if event == 'Park': parking_lot.park() elif event.startswith('Leave'): _, x = event.split() parking_lot.leave(int(x)) elif event == 'Check': results.append(parking_lot.check()) return results","solution":"class ParkingLot: def __init__(self, n): self.spots = ['Empty'] * n self.n = n def park(self): for i in range(self.n): if self.spots[i] == 'Empty': self.spots[i] = 'Occupied' break def leave(self, x): self.spots[x-1] = 'Empty' def check(self): return ' '.join(self.spots) def process_events(n, events): parking_lot = ParkingLot(n) results = [] for event in events: if event == 'Park': parking_lot.park() elif event.startswith('Leave'): _, x = event.split() parking_lot.leave(int(x)) elif event == 'Check': results.append(parking_lot.check()) return results"},{"question":"from typing import List def can_robot_reach_destination(n: int, m: int, k: int, grid: List[str]) -> str: Determine if it's possible for the robot to travel from the start cell to the destination cell within the allowed number of moves. >>> can_robot_reach_destination(5, 5, 10, [\\"S....\\", \\".#.\\", \\"#..\\", \\".#...\\", \\".#..D\\"]) \\"YES\\" >>> can_robot_reach_destination(4, 4, 6, [\\"S.#.\\", \\"..\\", \\"\\", \\".#D.\\"]) \\"NO\\" >>> can_robot_reach_destination(3, 4, 2, [\\"S.#D\\", \\"\\", \\"..\\"]) \\"NO\\"","solution":"def can_robot_reach_destination(n, m, k, grid): from collections import deque # Find start and destination positions start = None destination = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'D': destination = (i, j) # Check if start or destination are not found (even if problem's input guarantee they exist) if not start or not destination: return \\"NO\\" # BFS to find shortest path directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, current_moves) visited = set() visited.add((start[0], start[1])) while queue: r, c, current_moves = queue.popleft() if (r, c) == destination: return \\"YES\\" if current_moves < k: for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] != '#': queue.append((nr, nc, current_moves + 1)) visited.add((nr, nc)) return \\"NO\\""},{"question":"def average_pages(test_cases): Calculate the average number of pages for books that have more than 100 pages. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case is a tuple containing the number of books (int) and a list of page counts (List[int]). Returns: List[str]: A list of strings representing the average number of pages for books with more than 100 pages, or \\"No books with more than 100 pages\\" if applicable, formatted to 6 decimal places. >>> average_pages([(4, [120, 50, 180, 220]), (3, [80, 60, 90])]) [\\"173.333333\\", \\"No books with more than 100 pages\\"] >>> average_pages([(5, [200, 150, 80, 90, 300]), (1, [101])]) [\\"216.666667\\", \\"101.000000\\"]","solution":"def average_pages(test_cases): results = [] for case in test_cases: N, pages = case filtered_pages = [page for page in pages if page > 100] if not filtered_pages: results.append(\\"No books with more than 100 pages\\") else: average = sum(filtered_pages) / len(filtered_pages) results.append(f\\"{average:.6f}\\") return results # Example usage: # test_cases = [(4, [120, 50, 180, 220]), (3, [80, 60, 90])] # print(average_pages(test_cases))"},{"question":"def longest_bold_segment(s: str) -> int: Find the length of the longest bold segment in the string s. A \\"bold segment\\" is a contiguous substring of s such that each character in that substring appears at least twice in the entire string s. If there are no such segments, the answer should be 0. >>> longest_bold_segment(\\"abcabc\\") 6 >>> longest_bold_segment(\\"abba\\") 4 >>> longest_bold_segment(\\"abcdef\\") 0","solution":"def longest_bold_segment(s): n = len(s) if n == 0: return 0 # Count the frequency of each character freq = {} for ch in s: if ch in freq: freq[ch] += 1 else: freq[ch] = 1 # Find all characters that appear at least twice at_least_twice = set(ch for ch in freq if freq[ch] >= 2) max_length = 0 current_length = 0 in_bold_segment = False for ch in s: if ch in at_least_twice: if in_bold_segment: current_length += 1 else: in_bold_segment = True current_length = 1 else: if in_bold_segment: max_length = max(max_length, current_length) in_bold_segment = False current_length = 0 # Check one more time at the end of the string if in_bold_segment: max_length = max(max_length, current_length) return max_length"},{"question":"from collections import deque def min_knight_moves(x: int, y: int, a: int, b: int) -> int: Determine the minimum number of moves required for a knight to reach from the starting position (x, y) to the target position (a, b) on an infinite chessboard. Args: x (int): The x-coordinate of the starting position. y (int): The y-coordinate of the starting position. a (int): The x-coordinate of the target position. b (int): The y-coordinate of the target position. Returns: int: The minimum number of moves required for the knight to reach the target position. Examples: >>> min_knight_moves(0, 0, 2, 1) 1 >>> min_knight_moves(0, 0, 5, 5) 4 >>> min_knight_moves(1, 1, 1, 1) 0 def test_min_knight_moves(): assert min_knight_moves(1, 1, 1, 1) == 0 assert min_knight_moves(0, 0, 2, 1) == 1 assert min_knight_moves(2, 1, 0, 0) == 1 assert min_knight_moves(0, 0, 5, 5) == 4 assert min_knight_moves(0, 0, -5, -5) == 4 assert min_knight_moves(0, 0, 100, 100) > 0 assert min_knight_moves(0, 0, -100, -100) > 0 assert min_knight_moves(-5, -5, 5, 5) > 0 assert min_knight_moves(10, -10, -10, 10) > 0","solution":"from collections import deque def min_knight_moves(x, y, a, b): # Offsets for knight moves offsets = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)] # BFS initialization queue = deque([(x, y, 0)]) # (current_x, current_y, move_count) visited = set([(x, y)]) while queue: cur_x, cur_y, moves = queue.popleft() if (cur_x, cur_y) == (a, b): return moves for offset in offsets: next_x, next_y = cur_x + offset[0], cur_y + offset[1] if (next_x, next_y) not in visited: visited.add((next_x, next_y)) queue.append((next_x, next_y, moves + 1)) print(min_knight_moves(0, 0, 2, 1)) # Example Test Case 1 print(min_knight_moves(0, 0, 5, 5)) # Example Test Case 2 print(min_knight_moves(1, 1, 1, 1)) # Example Test Case 3"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def sum_values_at_each_level(n: int, nodes: List[Tuple[int, int, int, int]]) -> List[int]: Given the structure of the tree and values of nodes, compute and output the sum of values at every level of the tree. Args: n (int): Number of nodes. nodes (List[Tuple[int, int, int, int]]): List of tuples where each tuple contains four integers: - The index of the node (u) - The value of the node (l) - The indices of the left (le) and right (ri) children of node u. Returns: List[int]: List of sums of values at each level of the tree. Examples: >>> sum_values_at_each_level(1, [(1, 10, 0, 0)]) [10] >>> sum_values_at_each_level(5, [(1, 3, 2, 3), (2, 5, 4, 5), (3, 8, 0, 0), (4, 1, 0, 0), (5, 2, 0, 0)]) [3, 13, 3]","solution":"from collections import defaultdict, deque def sum_values_at_each_level(n, nodes): tree = defaultdict(lambda: [0, 0]) values = {} for u, l, le, ri in nodes: values[u] = l tree[u] = [le, ri] level_sums = defaultdict(int) queue = deque([(1, 0)]) # (node index, level) while queue: node, level = queue.popleft() level_sums[level] += values[node] left, right = tree[node] if left != 0: queue.append((left, level + 1)) if right != 0: queue.append((right, level + 1)) return [level_sums[i] for i in range(len(level_sums))]"},{"question":"def next_higher_same_one_bits(n: int) -> int: Given a positive integer n, find the next integer greater than n which has the same number of 1-bits in its binary representation. >>> next_higher_same_one_bits(5) 6 >>> next_higher_same_one_bits(7) 11 >>> next_higher_same_one_bits(12) 17 >>> next_higher_same_one_bits(13) 14 >>> next_higher_same_one_bits(31) 47 >>> next_higher_same_one_bits(1) 2 >>> next_higher_same_one_bits(2) 4 >>> next_higher_same_one_bits(3) 5","solution":"def next_higher_same_one_bits(n): Returns the next integer greater than n which has the same number of 1-bits in its binary representation. num_one_bits = bin(n).count('1') next_num = n + 1 while bin(next_num).count('1') != num_one_bits: next_num += 1 return next_num"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: For each day in the list of temperatures, find the number of days until a warmer temperature. If there are no future warmer days, return 0 for that day. Parameters: temperatures (List[int]): List of daily temperatures. Returns: List[int]: Number of days until a warmer temperature for each day. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 99, 98, 97]) [0, 0, 0, 0] >>> daily_temperatures([50, 50, 50, 50]) [0, 0, 0, 0] >>> daily_temperatures([50]) [0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 60, 50, 40, 70]) [1, 3, 2, 1, 0] >>> daily_temperatures([-20, -15, -10, -5, 0]) [1, 1, 1, 1, 0] >>> daily_temperatures([-5, 0, 5, 10, 15, 20, 25, 30]) [1, 1, 1, 1, 1, 1, 1, 0]","solution":"def daily_temperatures(temperatures): For each day in the list of temperatures, find the number of days until a warmer temperature. If there are no future warmer days, return 0 for that day. Parameters: temperatures (List[int]): List of daily temperatures. Returns: List[int]: Number of days until a warmer temperature for each day. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"def min_operations_to_equalize(nums: List[int]) -> int: Given a sequence of integers, determine the minimum number of operations required to make all the integers equal. In one operation, you can choose any integer from the sequence and either increase it or decrease it by 1. >>> min_operations_to_equalize([1, 2, 3, 4, 5]) 6 >>> min_operations_to_equalize([10, 20, 30]) 20 from solution import min_operations_to_equalize def test_example_cases(): assert min_operations_to_equalize([1, 2, 3, 4, 5]) == 6 assert min_operations_to_equalize([10, 20, 30]) == 20 def test_small_arrays(): assert min_operations_to_equalize([1, 100]) == 99 assert min_operations_to_equalize([1, 1]) == 0 assert min_operations_to_equalize([1, 2, 3]) == 2 def test_large_values(): assert min_operations_to_equalize([10**9, 1]) == 10**9 - 1 assert min_operations_to_equalize([10**9, 10**9 - 1, 1]) == 10**9 - 1 def test_arrays_with_duplicates(): assert min_operations_to_equalize([2, 2, 3, 3, 4, 4]) == 4 assert min_operations_to_equalize([5, 5, 5, 5, 5]) == 0 assert min_operations_to_equalize([1, 1, 1, 1000000000, 1000000000, 1000000000]) == 2999999997","solution":"def min_operations_to_equalize(nums): nums.sort() median = nums[len(nums) // 2] return sum(abs(x - median) for x in nums) # Example usage: # nums = [1, 2, 3, 4, 5] # print(min_operations_to_equalize(nums)) # Output: 6 # nums = [10, 20, 30] # print(min_operations_to_equalize(nums)) # Output: 20"},{"question":"def min_adjacent_swaps(n: int, initial: List[int], final: List[int]) -> int: Returns the minimum number of adjacent swaps required to transform the initial state of boxes into the final state. Args: n : int : number of boxes initial : list : initial list of box identifiers final : list : final list of box identifiers Returns: int : minimum number of adjacent swaps >>> min_adjacent_swaps(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps(3, [2, 3, 1], [1, 2, 3]) 2 >>> min_adjacent_swaps(4, [1, 2, 3, 4], [1, 2, 3, 4]) 0 >>> min_adjacent_swaps(2, [1, 2], [2, 1]) 1 >>> min_adjacent_swaps(5, [4, 2, 1, 5, 3], [5, 3, 4, 2, 1]) 6","solution":"def min_adjacent_swaps(n, initial, final): Returns the minimum number of adjacent swaps required to transform the initial state of boxes into the final state. Args: n : int : number of boxes initial : list : initial list of box identifiers final : list : final list of box identifiers Returns: int : minimum number of adjacent swaps index_map = {v: i for i, v in enumerate(initial)} pos = [index_map[final[i]] for i in range(n)] swap_count = 0 for i in range(n): for j in range(n - 1, i, -1): if pos[j] < pos[j - 1]: pos[j], pos[j - 1] = pos[j - 1], pos[j] swap_count += 1 return swap_count"},{"question":"def count_prime_palindromes(n: int) -> int: Counts the number of prime palindromic numbers less than or equal to n. >>> count_prime_palindromes(100) 5 >>> count_prime_palindromes(10) 4 pass","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_palindrome(num): Checks if a number is palindromic. return str(num) == str(num)[::-1] def count_prime_palindromes(n): Counts the number of prime palindromic numbers less than or equal to n. count = 0 for i in range(2, n + 1): if is_prime(i) and is_palindrome(i): count += 1 return count"},{"question":"def min_cost_to_palindrome(s: str) -> int: Return the minimum cost to make a string a palindrome. >>> min_cost_to_palindrome(\\"abc\\") 2 >>> min_cost_to_palindrome(\\"abccba\\") 0","solution":"def min_cost_to_palindrome(s): Returns the minimum cost to make a string a palindrome. n = len(s) cost = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: cost += 1 return cost"},{"question":"def is_return_possible(m: int, n: int, garden: List[List[int]]) -> str: Determine if it's possible for the gardener to return to the starting point without stepping on the same flower more than once. Parameters: m (int): Number of rows in the garden matrix. n (int): Number of columns in the garden matrix. garden (list of list of int): The garden matrix. Returns: str: \\"Yes\\" if it's possible to return to the starting point, otherwise \\"No\\". Examples: >>> is_return_possible(2, 2, [[1, 2], [3, 4]]) \\"Yes\\" >>> is_return_possible(2, 3, [[1, 2, 3], [4, 5, 6]]) \\"No\\" >>> is_return_possible(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \\"Yes\\"","solution":"def is_return_possible(m, n, garden): Determine if it's possible for the gardener to return to the starting point without stepping on the same flower more than once. Parameters: m (int): Number of rows in the garden matrix. n (int): Number of columns in the garden matrix. garden (list of list of int): The garden matrix. Returns: str: \\"Yes\\" if it's possible to return to the starting point, otherwise \\"No\\". if m % 2 == 0 or n % 2 == 0: return \\"Yes\\" return \\"No\\" # Example usage: # m = 2 # n = 2 # garden = [ # [1, 2], # [3, 4] # ] # print(is_return_possible(m, n, garden)) # Output: Yes"},{"question":"def min_travel_time(start, end): Calculate the minimum travel time from start to end on the given grid. Arguments: start -- the starting intersection coordinates (a, b) end -- the destination intersection coordinates (c, d) Returns: The minimum travel time in minutes or \\"Impossible\\" if the destination cannot be reached. >>> min_travel_time((1, 2), (3, 4)) 4 >>> min_travel_time((0, 0), (7, 1)) 8 >>> min_travel_time((2, 3), (2, 3)) 0 >>> min_travel_time((4, 4), (1, 1)) \\"Impossible\\" >>> min_travel_time((1, 2), (1, 3)) 1 >>> min_travel_time((3, 3), (3, 5)) 2 >>> min_travel_time((7, 8), (10, 10)) 5 def travel_times(datasets): Calculate the travel times for a series of datasets. Arguments: datasets -- a list of tuples containing the start and end coordinates for each dataset Returns: A list of travel times for each dataset. >>> travel_times([((1, 2), (3, 4)), ((0, 0), (7, 1)), ((2, 3), (2, 3)), ((4, 4), (1, 1)), ((0, 0), (0, 0))]) [4, 8, 0, \\"Impossible\\"]","solution":"def min_travel_time(start, end): Calculate the minimum travel time from start to end on the given grid. Arguments: start -- the starting intersection coordinates (a, b) end -- the destination intersection coordinates (c, d) Returns: The minimum travel time in minutes or \\"Impossible\\" if the destination cannot be reached. a, b = start c, d = end if c < a or d < b: return \\"Impossible\\" return (c - a) + (d - b) def travel_times(datasets): results = [] for dataset in datasets: start, end = dataset if start == (0, 0) and end == (0, 0): break results.append(min_travel_time(start, end)) return results"},{"question":"def max_books_on_shelf(n: int, thicknesses: List[int], W: int) -> int: Returns the maximum number of books that can be placed on the shelf without exceeding the maximum width. Parameters: n (int): The number of books. thicknesses (list of int): The thicknesses of the books. W (int): The maximum width the shelf can support. Returns: int: The maximum number of books. >>> max_books_on_shelf(5, [2, 3, 1, 5, 4], 10) 4 >>> max_books_on_shelf(3, [5, 6, 7], 3) 0 >>> max_books_on_shelf(4, [1, 2, 1, 1], 10) 4 >>> max_books_on_shelf(4, [8, 7, 6, 5], 7) 1 >>> max_books_on_shelf(5, [2, 2, 2, 2, 2], 10) 5 >>> max_books_on_shelf(1000, [1]*1000, 500) 500","solution":"def max_books_on_shelf(n, thicknesses, W): Returns the maximum number of books that can be placed on the shelf without exceeding the maximum width. Parameters: n (int): The number of books. thicknesses (list of int): The thicknesses of the books. W (int): The maximum width the shelf can support. Returns: int: The maximum number of books. # Sort the list of thicknesses in ascending order thicknesses.sort() current_width = 0 count = 0 for thickness in thicknesses: if current_width + thickness <= W: current_width += thickness count += 1 else: break return count"},{"question":"def is_possible_move(n: int, grid: List[List[int]]) -> str: Determines if there's a possible move from any cell with 1 to any cell with 2 in the grid. Args: n : int : Size of the grid grid : List[List[int]] : The n x n grid where each cell is either 0, 1, or 2 Returns: str : \\"YES\\" if a move is possible, otherwise \\"NO\\" Example: >>> n = 3 >>> grid = [ ... [1, 0, 2], ... [0, 0, 0], ... [2, 0, 0] ... ] >>> is_possible_move(n, grid) \\"YES\\" >>> n = 3 >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 2] ... ] >>> is_possible_move(n, grid) \\"NO\\"","solution":"def is_possible_move(n, grid): Determines if there's a possible move from any cell with 1 to any cell with 2 in the grid. # Finding all positions of 1's and 2's positions_1 = [] positions_2 = [] for i in range(n): for j in range(n): if grid[i][j] == 1: positions_1.append((i, j)) elif grid[i][j] == 2: positions_2.append((i, j)) # Checking for each pair of (1, 2) if they are in the same row or column for (x1, y1) in positions_1: for (x2, y2) in positions_2: if x1 == x2 or y1 == y2: return \\"YES\\" return \\"NO\\""},{"question":"def min_max_difference(n: int, heights: List[int]) -> int: Determine the minimum possible value of the maximum difference in height between any two adjacent buildings after modifying the height of at most one building. >>> min_max_difference(5, [1, 5, 3, 9, 7]) 4 >>> min_max_difference(3, [15, 10, 20]) 5 >>> min_max_difference(1, [7]) 0 >>> min_max_difference(3, [5, 5, 5]) 0 >>> min_max_difference(5, [1, 100, 1, 100, 1]) 99 >>> min_max_difference(2, [5, 10]) 0 >>> min_max_difference(4, [20, 15, 10, 5]) 5","solution":"def min_max_difference(n, heights): def get_max_diff(arr): max_diff = 0 for i in range(len(arr) - 1): max_diff = max(max_diff, abs(arr[i] - arr[i + 1])) return max_diff if n <= 2: return 0 min_possible_max_diff = float('inf') for i in range(n): if i == 0: new_heights = heights[1:] elif i == n-1: new_heights = heights[:-1] else: new_heights = heights[:i] + heights[i+1:] min_possible_max_diff = min(min_possible_max_diff, get_max_diff(new_heights)) return min_possible_max_diff"},{"question":"def is_toeplitz(matrix: List[List[int]], n: int, m: int) -> str: Check if the given n x m matrix is a Toeplitz matrix. >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2], [7, 6, 5, 1]], 4, 4) 'YES' >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 2, 8], [9, 5, 1, 2]], 3, 4) 'NO' def check_toeplitz_matrices(test_cases: List[Tuple[List[List[int]], int, int]]) -> List[str]: Check multiple matrices if they are Toeplitz matrices. >>> check_toeplitz_matrices([ ([[1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2], [7, 6, 5, 1]], 4, 4), ([[1, 2, 3, 4], [5, 1, 2, 8], [9, 5, 1, 2]], 3, 4) ]) ['YES', 'NO'] def process_input(input_str: str) -> List[str]: Process input string and check each matrix. >>> process_input(\\"2n4 4n1 2 3 4n5 1 2 3n6 5 1 2n7 6 5 1n3 4n1 2 3 4n5 1 2 8n9 5 1 2n\\") ['YES', 'NO']","solution":"def is_toeplitz(matrix, n, m): Check if the given n x m matrix is a Toeplitz matrix. for i in range(1, n): for j in range(1, m): if matrix[i][j] != matrix[i - 1][j - 1]: return \\"NO\\" return \\"YES\\" def check_toeplitz_matrices(test_cases): results = [] for matrix, n, m in test_cases: results.append(is_toeplitz(matrix, n, m)) return results def process_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].strip().split()) matrix = [] for i in range(n): row = list(map(int, lines[index + 1 + i].strip().split())) matrix.append(row) test_cases.append((matrix, n, m)) index += n + 1 return check_toeplitz_matrices(test_cases)"},{"question":"def longest_consecutive_subsequence(arr): This function takes an array as input and returns the length of the longest subsequence of consecutive equal elements in the array. >>> longest_consecutive_subsequence([5, 5, 5, 1, 1, 1]) 3 >>> longest_consecutive_subsequence([7, 7, 7, 7, 1, 2, 3, 3]) 4 >>> longest_consecutive_subsequence([1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4]) 6 pass def process_test_cases(test_cases): This function processes a list of test cases where each test case is a tuple (n, array) and returns a list containing the length of the longest subsequence of consecutive equal elements for each test case. >>> process_test_cases([(6, [5, 5, 5, 1, 1, 1]), (8, [7, 7, 7, 7, 1, 2, 3, 3]), (12, [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4])]) [3, 4, 6] >>> process_test_cases([(5, [1, 2, 3, 4, 5]), (5, [1, 1, 1, 1, 1]), (1, [1])]) [1, 5, 1] pass","solution":"def longest_consecutive_subsequence(arr): This function takes an array as input and returns the length of the longest subsequence of consecutive equal elements in the array. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length def process_test_cases(test_cases): This function processes a list of test cases where each test case is a tuple (n, array) and returns a list containing the length of the longest subsequence of consecutive equal elements for each test case. results = [] for n, arr in test_cases: results.append(longest_consecutive_subsequence(arr)) return results"},{"question":"def sum_of_values_in_binary_tree(root): Returns a list of integers where the first integer is the total sum of all values in the binary tree, followed by the sum of values at each level of the binary tree. Example: >>> tree = { ... \\"value\\": 1, ... \\"left\\": { ... \\"value\\": 2, ... \\"left\\": { ... \\"value\\": 4, ... \\"left\\": None, ... \\"right\\": None ... }, ... \\"right\\": { ... \\"value\\": 5, ... \\"left\\": None, ... \\"right\\": None ... } ... }, ... \\"right\\": { ... \\"value\\": 3, ... \\"left\\": None, ... \\"right\\": { ... \\"value\\": 6, ... \\"left\\": None, ... \\"right\\": None ... } ... } ... } >>> sum_of_values_in_binary_tree(tree) [21, 1, 5, 15] pass def test_example_case(): tree = { \\"value\\": 1, \\"left\\": { \\"value\\": 2, \\"left\\": { \\"value\\": 4, \\"left\\": None, \\"right\\": None }, \\"right\\": { \\"value\\": 5, \\"left\\": None, \\"right\\": None } }, \\"right\\": { \\"value\\": 3, \\"left\\": None, \\"right\\": { \\"value\\": 6, \\"left\\": None, \\"right\\": None } } } assert sum_of_values_in_binary_tree(tree) == [21, 1, 5, 15] def test_empty_tree(): tree = None assert sum_of_values_in_binary_tree(tree) == [0] def test_single_node_tree(): tree = { \\"value\\": 42, \\"left\\": None, \\"right\\": None } assert sum_of_values_in_binary_tree(tree) == [42, 42] def test_right_heavy_tree(): tree = { \\"value\\": 1, \\"left\\": None, \\"right\\": { \\"value\\": 2, \\"left\\": None, \\"right\\": { \\"value\\": 3, \\"left\\": None, \\"right\\": None } } } assert sum_of_values_in_binary_tree(tree) == [6, 1, 2, 3] def test_left_heavy_tree(): tree = { \\"value\\": 1, \\"left\\": { \\"value\\": 2, \\"left\\": { \\"value\\": 3, \\"left\\": None, \\"right\\": None }, \\"right\\": None }, \\"right\\": None } assert sum_of_values_in_binary_tree(tree) == [6, 1, 2, 3] def test_balanced_tree(): tree = { \\"value\\": 10, \\"left\\": { \\"value\\": 5, \\"left\\": { \\"value\\": 2, \\"left\\": None, \\"right\\": None }, \\"right\\": { \\"value\\": 3, \\"left\\": None, \\"right\\": None } }, \\"right\\": { \\"value\\": 12, \\"left\\": { \\"value\\": 8, \\"left\\": None, \\"right\\": None }, \\"right\\": { \\"value\\": 6, \\"left\\": None, \\"right\\": None } } } assert sum_of_values_in_binary_tree(tree) == [46, 10, 17, 19]","solution":"def sum_of_values_in_binary_tree(root): Returns a list of integers where the first integer is the total sum of all values in the binary tree, followed by the sum of values at each level of the binary tree. if not root: return [0] from collections import deque total_sum = 0 level_sums = [] queue = deque([root]) while queue: level_len = len(queue) level_sum = 0 for _ in range(level_len): node = queue.popleft() level_sum += node[\\"value\\"] total_sum += node[\\"value\\"] if node[\\"left\\"]: queue.append(node[\\"left\\"]) if node[\\"right\\"]: queue.append(node[\\"right\\"]) level_sums.append(level_sum) return [total_sum] + level_sums"},{"question":"def max_level_sum(n: int, node_values: List[int]) -> int: Given a binary tree in level-order traversal format, return the level of the tree with the maximum sum of node values. >>> max_level_sum(7, [4, 2, 3, 7, -1, 9, 6]) 2 >>> max_level_sum(4, [1, 2, 3, 4]) 1 >>> max_level_sum(0, []) -1 >>> max_level_sum(3, [5, 6, -1]) 0 >>> max_level_sum(6, [1, -2, -3, 4, 5, 6]) 2 # Your code here def handle_input(input_data: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the level with the maximum sum for each binary tree. >>> handle_input([(7, [4, 2, 3, 7, -1, 9, 6]), (4, [1, 2, 3, 4]), (0, [])]) [2, 1, -1] # Your code here","solution":"def max_level_sum(n, node_values): if n == 0: return -1 from collections import deque, defaultdict queue = deque([(0, 0)]) # (index, level) level_sums = defaultdict(int) for i in range(n): index, level = queue.popleft() level_sums[level] += node_values[index] left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < n: queue.append((left_child_index, level + 1)) if right_child_index < n: queue.append((right_child_index, level + 1)) max_sum_level = max(level_sums, key=lambda key: (level_sums[key], -key)) return max_sum_level def handle_input(input_data): results = [] for data in input_data: n, node_values = data[0], data[1] result = max_level_sum(n, node_values) results.append(result) return results"},{"question":"from typing import List def reverse_number(n: int) -> int: Reverse the digits of an integer. >>> reverse_number(123) == 321 >>> reverse_number(400) == 4 >>> reverse_number(0) == 0 >>> reverse_number(987654321) == 123456789 def is_palindrome(n: int) -> bool: Check if an integer is a palindrome. >>> is_palindrome(12321) == True >>> is_palindrome(123) == False >>> is_palindrome(1) == True >>> is_palindrome(22) == True def palindrome_chain_length(n: int) -> int: Determine the minimum number of steps required to make an integer a palindrome. >>> palindrome_chain_length(123) == 1 >>> palindrome_chain_length(87) == 4 >>> palindrome_chain_length(4884) == 0 >>> palindrome_chain_length(0) == 0 >>> palindrome_chain_length(89) == 24 def process_palindrome_chain_length(nums: List[int]) -> List[int]: Process a list of integers and return the number of steps required for each to become a palindrome. >>> process_palindrome_chain_length([123, 87, 4884, -1]) == [1, 4, 0] >>> process_palindrome_chain_length([0, -1]) == [0] >>> process_palindrome_chain_length([89, 10, -1]) == [24, 1]","solution":"def reverse_number(n): return int(str(n)[::-1]) def is_palindrome(n): s = str(n) return s == s[::-1] def palindrome_chain_length(n): steps = 0 while not is_palindrome(n): n = n + reverse_number(n) steps += 1 return steps def process_palindrome_chain_length(nums): results = [] for n in nums: if n == -1: break results.append(palindrome_chain_length(n)) return results"},{"question":"from typing import List, Tuple import heapq def min_kitchen_slots(orders: List[Tuple[int, int]]) -> int: Returns the minimum number of kitchen slots required to handle all orders without any overlap. pass def process_input(input_data: str) -> List[int]: Processes the input data and returns a list of minimum kitchen slots required for each dataset. pass def test_min_kitchen_slots(): # Test case 1 orders = [(0, 10), (10, 20), (20, 30)] assert min_kitchen_slots(orders) == 1 # Test case 2 orders = [(5, 15), (0, 10), (20, 30), (10, 25)] assert min_kitchen_slots(orders) == 2 # Test case 3 orders = [(1, 3), (2, 4)] assert min_kitchen_slots(orders) == 2 def test_process_input(): input_data = 3 0 10 10 20 20 30 4 5 15 0 10 20 30 10 25 2 1 3 2 4 0 expected_output = [1, 2, 2] assert process_input(input_data) == expected_output","solution":"import heapq def min_kitchen_slots(orders): Returns the minimum number of kitchen slots required to handle all orders without any overlap. if not orders: return 0 # Sort the orders by the start time orders.sort(key=lambda x: x[0]) # Initialize a min-heap to track the end times of orders being processed end_times = [] # Start with the first order heapq.heappush(end_times, orders[0][1]) # Iterate through the rest of the orders for i in range(1, len(orders)): current_start, current_end = orders[i] # If the current order's start time is greater than or equal to the earliest end time # we can use the same kitchen slot, pop the top of the heap if current_start >= end_times[0]: heapq.heappop(end_times) # Push the current order's end time onto the heap heapq.heappush(end_times, current_end) # The size of the heap will be the number of kitchen slots required return len(end_times) def process_input(input_data): result = [] lines = input_data.strip().split(\\"n\\") index = 0 while index < len(lines): n = int(lines[index].strip()) if n == 0: break orders = [] for i in range(1, n + 1): start, end = map(int, lines[index + i].strip().split()) orders.append((start, end)) result.append(min_kitchen_slots(orders)) index += n + 1 return result"},{"question":"def rearrange_digits(number_str: str) -> str: Returns the smallest positive integer that consists of the same digits as the given number but arranged in non-decreasing order. Parameters: number_str (str): The string representation of a positive integer. Returns: str: The rearranged number as a string. >>> rearrange_digits(\\"321\\") '123' >>> rearrange_digits(\\"465467\\") '445667' >>> rearrange_digits(\\"1000\\") '0001'","solution":"def rearrange_digits(number_str): Returns the smallest positive integer that consists of the same digits as the given number but arranged in non-decreasing order. Parameters: number_str (str): The string representation of a positive integer. Returns: str: The rearranged number as a string. return ''.join(sorted(number_str))"},{"question":"def max_points(test_cases: List[Dict[str, Any]]) -> List[int]: For each test case, calculate the maximum points Alex can achieve based on given parameters. :param test_cases: List of dictionaries containing test case information. Each dictionary has the following keys: - 'n': Number of problems - 'T': Competition duration in minutes - 'a': Time to solve a beginner problem - 'b': Time to solve an advanced problem - 'problems': List indicating the type of each problem (0 for beginner, 1 for advanced) - 'mandatory_times': List of times when each problem becomes mandatory :return: List of integers representing the maximum points Alex can achieve for each test case Examples: >>> max_points([ ... {'n': 3, 'T': 10, 'a': 2, 'b': 5, 'problems': [1, 0, 1], 'mandatory_times': [1, 5, 8]}, ... {'n': 4, 'T': 15, 'a': 1, 'b': 8, 'problems': [0, 1, 1, 0], 'mandatory_times': [2, 10, 12, 15]}, ... {'n': 2, 'T': 25, 'a': 1, 'b': 10, 'problems': [1, 1], 'mandatory_times': [5, 20]} ... ]) [2, 3, 2] from typing import List, Dict, Any def test_case_1(): test_cases = [ { 'n': 3, 'T': 10, 'a': 2, 'b': 5, 'problems': [1, 0, 1], 'mandatory_times': [1, 5, 8] } ] assert max_points(test_cases) == [2] def test_case_2(): test_cases = [ { 'n': 4, 'T': 15, 'a': 1, 'b': 8, 'problems': [0, 1, 1, 0], 'mandatory_times': [2, 10, 12, 15] } ] assert max_points(test_cases) == [3] def test_case_3(): test_cases = [ { 'n': 2, 'T': 25, 'a': 1, 'b': 10, 'problems': [1, 1], 'mandatory_times': [5, 20] } ] assert max_points(test_cases) == [2] def test_multiple_cases(): test_cases = [ { 'n': 3, 'T': 10, 'a': 2, 'b': 5, 'problems': [1, 0, 1], 'mandatory_times': [1, 5, 8] }, { 'n': 4, 'T': 15, 'a': 1, 'b': 8, 'problems': [0, 1, 1, 0], 'mandatory_times': [2, 10, 12, 15] }, { 'n': 2, 'T': 25, 'a': 1, 'b': 10, 'problems': [1, 1], 'mandatory_times': [5, 20] } ] assert max_points(test_cases) == [2, 3, 2]","solution":"def max_points(test_cases): results = [] for case in test_cases: n, T, a, b = case['n'], case['T'], case['a'], case['b'] problems = case['problems'] mandatory_times = case['mandatory_times'] beginner_times = [] advanced_times = [] for i in range(n): if problems[i] == 0: beginner_times.append(mandatory_times[i]) else: advanced_times.append(mandatory_times[i]) beginner_times.sort() advanced_times.sort() num_beginner = len(beginner_times) num_advanced = len(advanced_times) total_required_time = num_beginner * a + num_advanced * b if total_required_time <= T: results.append(n) continue points = 0 current_time = 0 b_index = 0 a_index = 0 for t in sorted(mandatory_times): required_time = (a * a_index) + (b * b_index) if required_time <= t - 1: remaining_time = t - 1 - required_time doable_b = min(num_beginner - a_index, remaining_time // a) remaining_time -= doable_b * a doable_a = min(num_advanced - b_index, remaining_time // b) points = max(points, a_index + b_index + doable_b + doable_a) while b_index < num_advanced and advanced_times[b_index] <= t: current_time += b b_index += 1 while a_index < num_beginner and beginner_times[a_index] <= t: current_time += a a_index += 1 if current_time <= t: points = max(points, a_index + b_index) results.append(points) return results"},{"question":"def can_color_graph(n, m, k, edges): Determine if you can color an undirected graph using exactly k different colors such that no two adjacent nodes have the same color. Parameters: n (int): Number of nodes m (int): Number of edges k (int): Number of colors edges (List[Tuple[int, int]]): List of edges represented by pairs of vertices Returns: str: \\"YES\\" if the graph can be colored using exactly k colors, otherwise \\"NO\\" Examples: >>> can_color_graph(4, 4, 3, [(1, 2), (1, 3), (2, 4), (3, 4)]) \\"YES\\" >>> can_color_graph(3, 3, 2, [(1, 2), (2, 3), (3, 1)]) \\"NO\\"","solution":"def can_color_graph(n, m, k, edges): if k <= 1: # We can only color a graph with k=1 color if it contains no edges return \\"YES\\" if m == 0 else \\"NO\\" # Perform a graph traversal to determine the highest degree of any vertex from collections import defaultdict adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) max_degree = max(len(neighbors) for neighbors in adjacency_list.values()) # A graph can be colored with k colors if the maximum degree < k (for ordinary graphs) # For k=2, we need to check if the graph is bipartite if k == 2: # To check bipartiteness, we use BFS to try to color the graph in two colors color = {} def bfs_check_bipartite(source): queue = [source] color[source] = 0 # Start coloring with color 0 while queue: node = queue.pop(0) current_color = color[node] for neighbor in adjacency_list[node]: if neighbor not in color: color[neighbor] = 1 - current_color # Alternate color queue.append(neighbor) elif color[neighbor] == current_color: return False return True for node in range(1, n + 1): if node not in color: if not bfs_check_bipartite(node): return \\"NO\\" return \\"YES\\" return \\"YES\\" if max_degree < k else \\"NO\\""},{"question":"import heapq from collections import defaultdict from typing import List, Tuple class CityGraph: def __init__(self, n: int): self.n = n self.graph = defaultdict(list) self.costs = {} def add_street(self, u: int, v: int, c: int): self.graph[u].append((v, c)) self.graph[v].append((u, c)) self.costs[(u, v)] = c self.costs[(v, u)] = c def update_street_cost(self, u: int, v: int, c: int): self.costs[(u, v)] = c self.costs[(v, u)] = c for i, (node, cost) in enumerate(self.graph[u]): if node == v: self.graph[u][i] = (v, c) for i, (node, cost) in enumerate(self.graph[v]): if node == u: self.graph[v][i] = (u, c) def dijkstra(self, start: int, end: int) -> int: heap = [(0, start)] min_cost = {i: float('inf') for i in range(1, self.n + 1)} min_cost[start] = 0 while heap: current_cost, u = heapq.heappop(heap) if u == end: return current_cost if current_cost > min_cost[u]: continue for v, cost in self.graph[u]: if current_cost + cost < min_cost[v]: min_cost[v] = current_cost + cost heapq.heappush(heap, (min_cost[v], v)) return -1 def process_queries(n: int, m: int, q: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, ...]]) -> List[int]: Process queries to find the minimum travel cost between intersections or update travel costs. Parameters: n (int): The number of intersections. m (int): The number of streets. q (int): The number of queries. edges (List[Tuple[int, int, int]]): The list of streets represented by tuples (u, v, c). queries (List[Tuple[int, ...]]): The list of queries, either of type (1, u, v) or (2, u, v, c). Returns: List[int]: The results of the type 1 queries. >>> n = 4 >>> m = 4 >>> q = 3 >>> edges = [(1, 2, 5), (1, 3, 10), (2, 3, 2), (3, 4, 7)] >>> queries = [(1, 1, 4), (2, 1, 3, 1), (1, 1, 4)] >>> process_queries(n, m, q, edges, queries) [14, 8] >>> n = 4 >>> m = 2 >>> q = 2 >>> edges = [(1, 2, 1), (3, 4, 1)] >>> queries = [(1, 1, 4), (1, 1, 3)] >>> process_queries(n, m, q, edges, queries) [-1, -1] city_graph = CityGraph(n) for u, v, c in edges: city_graph.add_street(u, v, c) results = [] for query in queries: if query[0] == 1: _, u, v = query result = city_graph.dijkstra(u, v) results.append(result) elif query[0] == 2: _, u, v, c = query city_graph.update_street_cost(u, v, c) return results","solution":"import heapq from collections import defaultdict class CityGraph: def __init__(self, n): self.n = n self.graph = defaultdict(list) self.costs = {} def add_street(self, u, v, c): self.graph[u].append((v, c)) self.graph[v].append((u, c)) self.costs[(u, v)] = c self.costs[(v, u)] = c def update_street_cost(self, u, v, c): self.costs[(u, v)] = c self.costs[(v, u)] = c for i, (node, cost) in enumerate(self.graph[u]): if node == v: self.graph[u][i] = (v, c) for i, (node, cost) in enumerate(self.graph[v]): if node == u: self.graph[v][i] = (u, c) def dijkstra(self, start, end): heap = [(0, start)] min_cost = {i: float('inf') for i in range(1, self.n + 1)} min_cost[start] = 0 while heap: current_cost, u = heapq.heappop(heap) if u == end: return current_cost if current_cost > min_cost[u]: continue for v, cost in self.graph[u]: if current_cost + cost < min_cost[v]: min_cost[v] = current_cost + cost heapq.heappush(heap, (min_cost[v], v)) return -1 def process_queries(n, m, q, edges, queries): city_graph = CityGraph(n) for u, v, c in edges: city_graph.add_street(u, v, c) results = [] for query in queries: if query[0] == 1: _, u, v = query result = city_graph.dijkstra(u, v) results.append(result) elif query[0] == 2: _, u, v, c = query city_graph.update_street_cost(u, v, c) return results"},{"question":"def max_histogram_area(heights): Helper function to find the largest rectangular area in a histogram. pass def largest_rectangle_fertile_land(matrix): Finds the largest rectangular area of fertile land ('1') in a given matrix. >>> largest_rectangle_fertile_land([ ... \\"10100\\", ... \\"10111\\", ... \\"11111\\", ... \\"10010\\" ... ]) 6 >>> largest_rectangle_fertile_land([ ... \\"111\\", ... \\"111\\", ... \\"111\\" ... ]) 9 >>> largest_rectangle_fertile_land([ ... \\"1100\\", ... \\"1111\\", ... \\"0011\\" ... ]) 4 >>> largest_rectangle_fertile_land([ ... \\"0000\\", ... \\"0000\\", ... \\"0000\\" ... ]) 0 >>> largest_rectangle_fertile_land([ ... \\"0110\\", ... \\"1110\\", ... \\"1101\\" ... ]) 4 >>> largest_rectangle_fertile_land([ ... \\"111\\", ... ]) 3 >>> largest_rectangle_fertile_land([ ... \\"1\\", ... \\"1\\", ... \\"1\\" ... ]) 3 pass","solution":"def max_histogram_area(heights): Helper function to find the largest rectangular area in a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_rectangle_fertile_land(matrix): Finds the largest rectangular area of fertile land ('1') in a given matrix. if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 heights = [0] * m for row in matrix: for j in range(m): if row[j] == '1': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"def longest_contiguous_substring(s: str) -> int: Given a string consisting of digits and lowercase English letters, determine the longest contiguous substring that contains at most one distinct character. Args: s (str): the input string consisting of digits and lowercase English letters Returns: int: the length of the longest contiguous substring that contains at most one distinct character. Examples: >>> longest_contiguous_substring(\\"aaabbcaaaa\\") 4 >>> longest_contiguous_substring(\\"abcdef\\") 1","solution":"def longest_contiguous_substring(s): Returns the length of the longest contiguous substring that contains at most one distinct character. max_len = 1 current_char = s[0] current_length = 1 for char in s[1:]: if char == current_char: current_length += 1 else: current_char = char current_length = 1 max_len = max(max_len, current_length) return max_len"},{"question":"def can_collect_gems(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[str]: Determine whether you can collect the required number of gems for each type within the given energy constraints. Args: T : int : Number of test cases test_cases : List[Tuple[int, int, List[Tuple[int, int, int]]]] : Test case data Returns: List[str] : \\"POSSIBLE\\" if you can collect the required number of gems for each type, otherwise \\"IMPOSSIBLE\\" pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, List[Tuple[int, int, int]]]]]: Parse the input string into structured test case data. Args: input_str : str: Raw input data Returns: Tuple[int, List[Tuple[int, int, List[Tuple[int, int, int]]]]] pass import pytest def test_can_collect_gems(): input_data = \\"1n2 10n3 4 5n2 2 3n\\" T, test_cases = parse_input(input_data) result = can_collect_gems(T, test_cases) assert result == [\\"POSSIBLE\\"] def test_impossible_case(): input_data = \\"1n2 5n3 4 1n2 2 1n\\" T, test_cases = parse_input(input_data) result = can_collect_gems(T, test_cases) assert result == [\\"IMPOSSIBLE\\"] def test_multiple_cases(): input_data = \\"2n2 10n3 4 5n2 2 3n2 5n3 4 1n2 2 1n\\" T, test_cases = parse_input(input_data) result = can_collect_gems(T, test_cases) assert result == [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"] def test_exact_energy(): input_data = \\"1n1 5n1 5 5n\\" T, test_cases = parse_input(input_data) result = can_collect_gems(T, test_cases) assert result == [\\"POSSIBLE\\"] def test_no_energy_gain(): input_data = \\"1n2 10n3 4 0n2 5 0n\\" T, test_cases = parse_input(input_data) result = can_collect_gems(T, test_cases) assert result == [\\"IMPOSSIBLE\\"] def test_energy_surplus(): input_data = \\"1n1 1n1 1 10n\\" T, test_cases = parse_input(input_data) result = can_collect_gems(T, test_cases) assert result == [\\"POSSIBLE\\"]","solution":"def can_collect_gems(T, test_cases): results = [] for test in test_cases: N, M, gems = test possible = True current_energy = M for gem in gems: Ri, Ei, Ci = gem total_energy_needed = Ri * Ei total_energy_obtained = Ri * Ci current_energy -= total_energy_needed current_energy += total_energy_obtained if current_energy < 0: possible = False break if possible: results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results # Function to help format input for the function def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, input_lines[index].split()) index += 1 gems = [] for _ in range(N): Ri, Ei, Ci = map(int, input_lines[index].split()) gems.append((Ri, Ei, Ci)) index += 1 test_cases.append((N, M, gems)) return T, test_cases"},{"question":"def generate_sequence(n, k): Given two parameters, n and k, determine if a sequence of n distinct integers can be created such that every prefix of the sequence has its elements sum to a multiple of k. If such a sequence exists, return it. Otherwise, return -1. # Test cases ''' assert generate_sequence(3, 3) == [1, 2, 3] assert generate_sequence(4, 5) == -1 assert generate_sequence(5, 1) == [1, 2, 3, 4, 5] assert generate_sequence(7, 4) == -1 assert generate_sequence(6, 3) == [1, 2, 3, 4, 5, 6] assert generate_sequence(1, 1) == [1] assert generate_sequence(2, 1) == [1, 2] assert generate_sequence(9, 3) == [1, 2, 3, 4, 5, 6, 7, 8, 9] '''","solution":"def generate_sequence(n, k): Given two parameters, n and k, determine if a sequence of n distinct integers can be created such that every prefix of the sequence has its elements sum to a multiple of k. If such a sequence exists, return it. Otherwise, return -1. # Check for the trivial case where k == 1, in which any sequence of 1 to n is valid. if k == 1: return list(range(1, n + 1)) # Check for the case where a sequence cannot meet the criteria. if n % k != 0: return -1 # Generate the sequence sequence = [] for i in range(n // k): for j in range(1, k + 1): sequence.append(i * k + j) return sequence"},{"question":"def max_profit(stock_prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling the stock on different days. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([5, 3, 1, 3, 8, 12, 2, 6, 1, 7]) == 11 >>> max_profit([5]) == 0 >>> max_profit([]) == 0","solution":"def max_profit(stock_prices): Returns the maximum profit that can be achieved by buying and selling the stock on different days. If no profit can be made, returns 0. :param stock_prices: List[int], list of stock prices :return: Integer, maximum profit if not stock_prices: return 0 min_price = float('inf') max_profit = 0 for price in stock_prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def max_non_adjacent_sum(arr): Returns the maximum possible sum of non-adjacent elements from the array. If all elements are negative, return 0. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-3, -2, -5, -10, -7]) 0 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([5, 5, 10, 40, 50, 35]) 80 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([-5]) 0 >>> max_non_adjacent_sum([]) 0 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) print(max_non_adjacent_sum(arr)) if __name__ == \\"__main__\\": main()","solution":"def max_non_adjacent_sum(arr): Returns the maximum possible sum of non-adjacent elements from the array. If all elements are negative, returns 0. if not arr: return 0 include = 0 exclude = 0 for num in arr: new_exclude = max(exclude, include) include = exclude + num exclude = new_exclude return max(exclude, include) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) print(max_non_adjacent_sum(arr)) if __name__ == \\"__main__\\": main()"},{"question":"def mod_sequence_zeros(M: int, L: int) -> int: Returns the number of times zero appears in the first L elements of the mod sequence defined by M. >>> mod_sequence_zeros(3, 10) 3 >>> mod_sequence_zeros(5, 25) 5 >>> mod_sequence_zeros(7, 15) 2","solution":"def mod_sequence_zeros(M, L): Returns the number of times zero appears in the first L elements of the mod sequence defined by M. # Calculate full cycles of the mod sequence within the first L elements full_cycles = L // (M + 1) # Calculate the remaining elements after the full cycles remaining_elements = L % (M + 1) # Zeros appear once in each cycle, so count full cycle zeros zero_count = full_cycles # If remaining elements include a zero if remaining_elements > 0: zero_count += 1 return zero_count # Reading input from standard input (not needed in testing) if __name__ == \\"__main__\\": import sys input = sys.stdin.read M, L = map(int, input().split()) print(mod_sequence_zeros(M, L))"},{"question":"def max_pairs(N, K, powers): Returns the maximum number of pairs of magical creatures that can be formed such that the difference in their magical powers does not exceed K. >>> max_pairs(6, 2, [3, 5, 1, 4, 6, 2]) == 3 >>> max_pairs(5, 1, [10, 9, 4, 2, 1]) == 2 >>> max_pairs(4, 0, [5, 5, 5, 5]) == 2 >>> max_pairs(8, 3, [8, 5, 6, 1, 3, 2, 4, 7]) == 4 >>> max_pairs(5, 1, [10, 12, 14, 17, 20]) == 0 >>> max_pairs(5, 0, [7, 7, 7, 7, 7]) == 2 >>> max_pairs(7, 1000, [100, 200, 300, 400, 500, 600, 700]) == 3 >>> max_pairs(2, 0, [9, 9]) == 1 >>> max_pairs(6, 1, [1, 2, 3, 4, 5, 6]) == 3","solution":"def max_pairs(N, K, powers): Returns the maximum number of pairs of magical creatures that can be formed such that the difference in their magical powers does not exceed K. # Sort the powers array powers.sort() i, pairs = 0, 0 while i < N - 1: if powers[i + 1] - powers[i] <= K: pairs += 1 i += 2 # Move to the next pair else: i += 1 # Check the next element for pairing return pairs"},{"question":"import math from typing import List def largest_square_number(N: int) -> int: Write a function that finds the largest square number less than or equal to a given positive integer N. A square number is an integer that is the square of some other integer. Input: A single line containing a positive integer N (1 ≤ N ≤ 10^12). Output: Output a single integer - the largest square number less than or equal to N. Example: >>> largest_square_number(20) 16 >>> largest_square_number(1) 1 >>> largest_square_number(25) 25 >>> largest_square_number(26) 25 pass def test_largest_square_number(): assert largest_square_number(20) == 16 assert largest_square_number(1) == 1 assert largest_square_number(25) == 25 assert largest_square_number(26) == 25 assert largest_square_number(1000000) == 1000000 assert largest_square_number(50) == 49 assert largest_square_number(999999999999) == 999998000001 assert largest_square_number(2) == 1 assert largest_square_number(17) == 16 assert largest_square_number(37) == 36","solution":"import math def largest_square_number(N): Finds the largest square number less than or equal to a given positive integer N. return int(math.floor(math.sqrt(N))) ** 2"},{"question":"def find_influencers(N: int, M: int, follower_followee_pairs: List[Tuple[int, int]]) -> List[Union[int, str]]: Identify all influencers in a social network. An influencer is defined as someone who is not following anyone but is followed by at least one other user. Args: N (int): The number of users. M (int): The number of follower-followee pairs. follower_followee_pairs (List[Tuple[int, int]]): A list of follower-followee pairs. Returns: List[Union[int, str]]: A list of influencer user IDs sorted in ascending order, or [\\"No influencers found\\"] if no influencers exist.","solution":"def find_influencers(N, M, follower_followee_pairs): following_counts = {i: 0 for i in range(1, N + 1)} followed_by_counts = {i: 0 for i in range(1, N + 1)} for a, b in follower_followee_pairs: following_counts[a] += 1 followed_by_counts[b] += 1 influencers = [user for user in range(1, N + 1) if following_counts[user] == 0 and followed_by_counts[user] > 0] if influencers: return sorted(influencers) else: return [\\"No influencers found\\"]"},{"question":"def is_balanced(sequence: str) -> str: Returns 'YES' if the given sequence of parentheses is balanced, otherwise 'NO'. >>> is_balanced(\\"()[]{}\\") 'YES' >>> is_balanced(\\"([{}])\\") 'YES' >>> is_balanced(\\"([)]\\") 'NO' def check_sequences(n: int, sequences: List[str]) -> List[str]: Returns a list of 'YES' or 'NO' for each sequence to indicate if it is balanced or not. >>> check_sequences(3, [\\"()[]{}\\", \\"([{}])\\", \\"([)]\\"]) ['YES', 'YES', 'NO'] >>> check_sequences(2, [\\"\\", \\"([])\\"]) ['YES', 'YES']","solution":"def is_balanced(sequence): Returns 'YES' if the given sequence of parentheses is balanced, otherwise 'NO'. A sequence is balanced if it has correct opening and closing parentheses. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in sequence: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if stack == [] else \\"NO\\" def check_sequences(n, sequences): Returns a list of 'YES' or 'NO' for each sequence to indicate if it is balanced or not. results = [] for sequence in sequences: results.append(is_balanced(sequence)) return results"},{"question":"def find_smallest_cycle(n: int, connections: List[int]) -> int: Find the length of the smallest cycle in the bus route network. :param n: The number of intersections. :param connections: List of intersections' connections. :return: The length of the smallest cycle. >>> find_smallest_cycle(5, [2, 3, 4, 5, 1]) 5 >>> find_smallest_cycle(6, [2, 3, 4, 5, 6, 4]) 3 >>> find_smallest_cycle(4, [2, 3, 1, 3]) 3","solution":"def find_smallest_cycle(n, connections): visited = [False] * (n + 1) def find_cycle_length(start): current = start length = 0 while not visited[current]: visited[current] = True current = connections[current - 1] length += 1 cycle_start = current cycle_length = 0 while True: current = connections[current - 1] cycle_length += 1 if current == cycle_start: break return cycle_length smallest_cycle_length = float('inf') for i in range(1, n + 1): if not visited[i]: cycle_length = find_cycle_length(i) smallest_cycle_length = min(smallest_cycle_length, cycle_length) return smallest_cycle_length"},{"question":"def check_valid_sudoku(sudoku): Verifies if a given Sudoku solution is valid. :param sudoku: A 9x9 grid containing the Sudoku puzzle as a list of lists. :return: \\"Valid\\" if the Sudoku is valid, \\"Invalid\\" otherwise. >>> check_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) == \\"Valid\\" >>> check_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 0, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) == \\"Invalid\\" >>> check_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 8], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) == \\"Invalid\\" return","solution":"def check_valid_sudoku(sudoku): Verifies if a given Sudoku solution is valid. :param sudoku: A 9x9 grid containing the Sudoku puzzle as a list of lists. :return: \\"Valid\\" if the Sudoku is valid, \\"Invalid\\" otherwise. def is_valid_block(block): return sorted(block) == list(range(1, 10)) for row in sudoku: if not is_valid_block(row): return \\"Invalid\\" for col in zip(*sudoku): if not is_valid_block(col): return \\"Invalid\\" for i in range(0, 9, 3): for j in range(0, 9, 3): block = [sudoku[x][y] for x in range(i, i+3) for y in range(j, j+3)] if not is_valid_block(block): return \\"Invalid\\" return \\"Valid\\""},{"question":"def have_common_elements(datasets): Determine if the two lists in each dataset have any common elements. Args: datasets (List[Tuple[List[int], List[int]]]): A list of tuples, where each tuple contains two lists of integers. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each dataset indicating if there are common elements. # Your code here def parse_input(input_string): Parse the given input string into datasets. Args: input_string (str): The input string containing multiple datasets in the described format. Returns: List[Tuple[List[int], List[int]]]: A list of tuples, where each tuple contains two lists of integers. # Your code here def main(input_string): Main function to process input and determine if common elements exist. Args: input_string (str): The input string containing multiple datasets in the described format. Returns: str: A string of \\"YES\\" or \\"NO\\" for each dataset, separated by new lines. # Your code here # You can use the provided unit test cases to test your implementations. import pytest def test_basic_cases(): input_string = \\"3n3n1 2 3n3n4 5 6n4n-1 0 -3 2n4n2 3 4 5n2n7 8n3n9 10 11\\" result = main(input_string) assert result == \\"NOnYESnNO\\" def test_all_yes_cases(): input_string = \\"2n2n1 2n2n2 3n3n4 5 6n3n6 7 8\\" result = main(input_string) assert result == \\"YESnYES\\" def test_all_no_cases(): input_string = \\"2n2n1 2n2n3 4n3n5 6 7n3n8 9 10\\" result = main(input_string) assert result == \\"NOnNO\\" def test_single_element_overlap(): input_string = \\"1n1n9999n1n9999\\" result = main(input_string) assert result == \\"YES\\" def test_empty_lists(): input_string = \\"2n0nn0nn1n1n0n0\\" result = main(input_string) assert result == \\"NOnNO\\" def test_parse_input(): input_string = \\"1n3n1 2 3n3n4 5 6\\" datasets = parse_input(input_string) expected = [([1, 2, 3], [4, 5, 6])] assert datasets == expected def test_have_common_elements_yes(): datasets = [([1, 2, 3], [3, 4, 5])] result = have_common_elements(datasets) assert result == [\\"YES\\"] def test_have_common_elements_no(): datasets = [([1, 2, 3], [4, 5, 6])] result = have_common_elements(datasets) assert result == [\\"NO\\"]","solution":"def have_common_elements(datasets): results = [] for data in datasets: list1 = set(data[0]) list2 = set(data[1]) if list1.intersection(list2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_string): input_lines = input_string.strip().split('n') num_datasets = int(input_lines[0]) index = 1 datasets = [] for _ in range(num_datasets): L1 = int(input_lines[index]) list1 = list(map(int, input_lines[index + 1].split())) L2 = int(input_lines[index + 2]) list2 = list(map(int, input_lines[index + 3].split())) datasets.append((list1, list2)) index += 4 return datasets def main(input_string): datasets = parse_input(input_string) results = have_common_elements(datasets) return 'n'.join(results)"},{"question":"from typing import List def detect_suspicious_activity(m: int, k: int, n: int, logs: List[str]) -> List[str]: Analyzes log files to identify potential security breaches where a user attempts to log in more than \`k\` times within any given \`m\` minute window. Returns the list of flagged usernames in ascending alphabetical order, or [\\"None\\"] if no users are flagged. >>> detect_suspicious_activity(5, 3, 6, [\\"2023-07-20 10:01 alice\\", \\"2023-07-20 10:02 alice\\", \\"2023-07-20 10:03 bob\\", \\"2023-07-20 10:04 alice\\", \\"2023-07-20 10:04 alice\\", \\"2023-07-20 10:05 bob\\"]) [\\"alice\\"] >>> detect_suspicious_activity(5, 3, 3, [\\"2023-07-20 10:01 alice\\", \\"2023-07-20 10:03 alice\\", \\"2023-07-20 10:05 alice\\"]) [\\"None\\"] pass","solution":"from collections import defaultdict from datetime import datetime, timedelta def detect_suspicious_activity(m, k, n, logs): user_logs = defaultdict(list) flagged_users = set() # Parse logs and store them by username for log in logs: timestamp_str, username = log[:16], log[17:] timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M\\") user_logs[username].append(timestamp) # Check each user's activity for suspicious behavior for username, timestamps in user_logs.items(): timestamps.sort() for i in range(len(timestamps)): window_start = timestamps[i] window_end = window_start + timedelta(minutes=m) count = 0 for j in range(i, len(timestamps)): if timestamps[j] > window_end: break count += 1 if count > k: flagged_users.add(username) break # Output flagged users in alphabetical order if flagged_users: return sorted(flagged_users) else: return [\\"None\\"]"},{"question":"from typing import List, Tuple def update_grid(m: int, n: int, k: int, operations: List[Tuple[int, int, int]]) -> List[List[int]]: Update the grid based on the given operations. >>> update_grid(3, 3, 2, [(0, 0, 1), (1, 1, 3)]) [[1, 1, 1], [1, 4, 4], [1, 4, 4]] >>> update_grid(4, 4, 3, [(1, 1, 2), (2, 2, 3), (0, 0, 1)]) [[1, 1, 1, 1], [1, 3, 3, 3], [1, 3, 6, 6], [1, 3, 6, 6]] pass def format_grid(grid: List[List[int]]) -> str: Format the grid for display. >>> format_grid([[1, 1, 1], [1, 4, 4], [1, 4, 4]]) '1 1 1n1 4 4n1 4 4' >>> format_grid([[1, 1, 1, 1], [1, 3, 3, 3], [1, 3, 6, 6], [1, 3, 6, 6]]) '1 1 1 1n1 3 3 3n1 3 6 6n1 3 6 6' pass","solution":"def update_grid(m, n, k, operations): grid = [[0] * n for _ in range(m)] for op in operations: index1, index2, increment = op for i in range(index1, m): for j in range(index2, n): grid[i][j] += increment return grid def format_grid(grid): return 'n'.join(' '.join(map(str, row)) for row in grid)"},{"question":"def can_complete_training(n: int, e: int, distances: List[int], energy_factors: List[int]) -> str: Determine if Olivia can complete all n training sessions with positive energy levels on all days. >>> can_complete_training(3, 10, [5, 6, 4], [-2, 3, -1]) \\"NO\\" >>> can_complete_training(4, 15, [3, 5, 7, 2], [-3, -4, 2, -1]) \\"NO\\" >>> can_complete_training(3, 10, [5, 2, 3], [0, 5, -1]) \\"YES\\" >>> can_complete_training(2, 1, [1, 1], [-1, 1]) \\"NO\\" >>> can_complete_training(2, 10, [0, 0], [1, -1]) \\"YES\\" >>> can_complete_training(3, 1000, [100, 200, 300], [-10, -10, -10]) \\"NO\\" >>> can_complete_training(3, 5, [1, 1, 1], [100, 100, 100]) \\"YES\\"","solution":"def can_complete_training(n, e, distances, energy_factors): energy = e for i in range(n): energy += energy_factors[i] * distances[i] if energy <= 0: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def rearrange_books(n: int, genres: List[str]) -> int: Function to rearrange books to minimize the number of shelves used. Parameters: n (int): The number of books. genres (list of str): The genres of the books in original order. Returns: int: The minimum number of shelves required. Examples: >>> rearrange_books(5, [\\"Fiction\\", \\"Non-Fiction\\", \\"Fiction\\", \\"Science\\", \\"Science\\"]) 3 >>> rearrange_books(4, [\\"History\\", \\"Science\\", \\"History\\", \\"Science\\"]) 2","solution":"def rearrange_books(n, genres): Function to rearrange books to minimize the number of shelves used. Parameters: n (int): The number of books. genres (list of str): The genres of the books in original order. Returns: int: The minimum number of shelves required. from collections import defaultdict genre_positions = defaultdict(list) # Group books by genre and maintain original order for i, genre in enumerate(genres): genre_positions[genre].append(i) return len(genre_positions) # Example usage: # n = 5 # genres = [\\"Fiction\\", \\"Non-Fiction\\", \\"Fiction\\", \\"Science\\", \\"Science\\"] # print(rearrange_books(n, genres)) # Output: 3"},{"question":"class ProductList: def __init__(self): self.product_list = [] def add(self, product_name, price): Add a new product with the given name and price to the list. pass def remove(self, product_name): Remove the product with the given name from the list. If there are multiple products with the same name, remove all of them. pass def change(self, product_name, new_price): Change the price of all products with the given name to the new price. pass def get_min(self): Return the product name with the minimum price. If there are multiple products with the same lowest price, return the one that appears first in the list. >>> pl = ProductList() >>> pl.add(\\"apple\\", 100) >>> pl.add(\\"orange\\", 50) >>> pl.get_min() 'orange' >>> pl.change(\\"apple\\", 40) >>> pl.get_min() 'apple' pass def handle_queries(queries): Handle multiple queries on the product list. >>> queries = [ ... \\"ADD apple 100\\", ... \\"ADD orange 50\\", ... \\"GET_MIN\\", ... \\"CHANGE apple 40\\", ... \\"GET_MIN\\", ... \\"REMOVE orange\\", ... \\"GET_MIN\\", ... \\"REMOVE apple\\" ... ] >>> handle_queries(queries) ['orange', 'apple', 'apple'] pass","solution":"class ProductList: def __init__(self): self.product_list = [] def add(self, product_name, price): self.product_list.append((product_name, price)) def remove(self, product_name): self.product_list = [(name, price) for name, price in self.product_list if name != product_name] def change(self, product_name, new_price): self.product_list = [(name, new_price if name == product_name else price) for name, price in self.product_list] def get_min(self): if not self.product_list: return None return min(self.product_list, key=lambda x: x[1])[0] def handle_queries(queries): pl = ProductList() results = [] for query in queries: parts = query.split() command = parts[0] if command == \\"ADD\\": product_name = parts[1] price = int(parts[2]) pl.add(product_name, price) elif command == \\"REMOVE\\": product_name = parts[1] pl.remove(product_name) elif command == \\"CHANGE\\": product_name = parts[1] new_price = int(parts[2]) pl.change(product_name, new_price) elif command == \\"GET_MIN\\": result = pl.get_min() if result: results.append(result) return results"},{"question":"def smallest_unique_string(s: str) -> str: Given a string s, generate the lexicographically smallest unique character string t, preserving the order of their first occurrences. >>> smallest_unique_string(\\"abcabc\\") 'abc' >>> smallest_unique_string(\\"cbacdcbc\\") 'acdb'","solution":"def smallest_unique_string(s): Given a string s, generate the lexicographically smallest unique character string t, preserving the order of their first occurrences. last_occurrence = {} for i, char in enumerate(s): last_occurrence[char] = i stack = [] in_stack = set() for i, char in enumerate(s): if char in in_stack: continue while stack and char < stack[-1] and last_occurrence[stack[-1]] > i: in_stack.remove(stack.pop()) stack.append(char) in_stack.add(char) return ''.join(stack)"},{"question":"def should_hire(k: int, p: int, scores: List[int]) -> bool: Evaluates whether a candidate should be hired based on the number of tests passed with a score greater than or equal to p. Parameters: k (int): The number of tests. p (int): The passing score. scores (list): A list of integers representing the scores received by the candidate in each test. Returns: bool: True if the candidate should be hired, False otherwise. >>> should_hire(5, 75, [80, 70, 85, 90, 60]) True >>> should_hire(4, 50, [30, 40, 45, 50]) False >>> should_hire(3, 60, [61, 59, 60]) False >>> should_hire(6, 60, [60, 60, 60, 60, 60, 60]) True >>> should_hire(3, 70, [60, 65, 66]) False >>> should_hire(3, 50, [60, 65, 70]) True >>> should_hire(3, 50, [50, 50, 50]) True >>> should_hire(3, 70, [70, 70, 70]) True","solution":"def should_hire(k, p, scores): Evaluates whether a candidate should be hired based on the number of tests passed with a score greater than or equal to p. Parameters: k (int): The number of tests. p (int): The passing score. scores (list): A list of integers representing the scores received by the candidate in each test. Returns: bool: True if the candidate should be hired, False otherwise. passing_scores = [score for score in scores if score >= p] return len(passing_scores) > k // 2"},{"question":"from typing import List def is_possible_to_fill_grid(n: int, c: int) -> str: Determines whether it is possible to fill the grid of size n x n such that no two adjacent cells (horizontally, vertically, or diagonally) share the same color. :param n: Size of the grid (integer) :param c: Number of available colors (integer) :return: \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" pass def process_datasets(input_str: str) -> List[str]: Processes datasets and determines for each whether it's possible to fill the grid under the given constraints. :param input_str: String representation of the datasets :return: A list of strings, each being either \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" pass from is_possible_to_fill_grid import is_possible_to_fill_grid from process_datasets import process_datasets def test_is_possible_to_fill_grid(): assert is_possible_to_fill_grid(2, 2) == \\"IMPOSSIBLE\\" assert is_possible_to_fill_grid(3, 3) == \\"POSSIBLE\\" assert is_possible_to_fill_grid(4, 3) == \\"POSSIBLE\\" assert is_possible_to_fill_grid(1, 2) == \\"POSSIBLE\\" assert is_possible_to_fill_grid(2, 3) == \\"POSSIBLE\\" assert is_possible_to_fill_grid(2, 1) == \\"IMPOSSIBLE\\" def test_process_datasets(): input_str = \\"2 2nA Bn3 3nR G Bn4 3nX Y Zn0\\" expected_output = [\\"IMPOSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\"] assert process_datasets(input_str) == expected_output input_str = \\"1 2nA Bn2 3nA B Cn0\\" expected_output = [\\"POSSIBLE\\", \\"POSSIBLE\\"] assert process_datasets(input_str) == expected_output input_str = \\"2 1nAn0\\" expected_output = [\\"IMPOSSIBLE\\"] assert process_datasets(input_str) == expected output","solution":"def is_possible_to_fill_grid(n, c): Determines if the grid can be filled such that no two adjacent cells share the same color. if c < 3 and n > 1: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\" def process_datasets(input_str): Processes the string input containing multiple datasets and returns results for each dataset. lines = input_str.strip().split('n') results = [] i = 0 while i < len(lines): line = lines[i] if line == '0': break n, c = map(int, line.split()) colors = lines[i + 1].split() result = is_possible_to_fill_grid(n, c) results.append(result) i += 2 return results"},{"question":"def to_camel_case(s: str) -> str: Convert the input sentence to CamelCase format. Only alphanumeric characters are included in the final CamelCase output, and the first letter of each word is capitalized. >>> to_camel_case(\\"hello world\\") 'HelloWorld' >>> to_camel_case(\\"this is a test sentence!\\") 'ThisIsATestSentence' >>> to_camel_case(\\"Code 132 Academy\\") 'Code132Academy' >>> to_camel_case(\\"\\") '' >>> to_camel_case(\\"normalize THIS text@#\\") 'NormalizeThisText'","solution":"def to_camel_case(s): Convert the input sentence to CamelCase format. :param s: str - input sentence containing words separated by spaces :return: str - the sentence converted to CamelCase format import re words = re.findall(r'bw+b', s) # Find all words containing alphanumeric characters camel_case_words = [word.capitalize() for word in words] # Capitalize each word return ''.join(camel_case_words) # Join all words in CamelCase format # Example usage if __name__ == \\"__main__\\": sentence = \\"hello world\\" print(to_camel_case(sentence)) # Should print \\"HelloWorld\\""},{"question":"def longest_subsequence_length(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a sequence of n integers, find the length of the longest subsequence such that the difference between consecutive elements is either 1 or -1. >>> longest_subsequence_length(2, [(5, [1, 2, 3, 4, 5]), (7, [4, 3, 2, 3, 4, 5, 6])]) == [5, 7] >>> longest_subsequence_length(1, [(7, [10, 11, 10, 9, 8, 9, 10])]) == [7] >>> longest_subsequence_length(1, [(5, [1, 2, 4, 5, 6])]) == [3] >>> longest_subsequence_length(1, [(1, [1])]) == [1] >>> longest_subsequence_length(2, [(3, [1, 2, 1]), (4, [7, 8, 6, 5])]) == [3, 2]","solution":"def longest_subsequence_length(t, test_cases): results = [] for i in range(t): n, sequence = test_cases[i] if n == 1: results.append(1) continue max_length = 1 current_length = 1 for j in range(1, n): if abs(sequence[j] - sequence[j-1]) == 1: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) results.append(max_length) return results"},{"question":"def max_bacteria_length(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum length of the bacteria obtainable in any rectangular sub-grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of int): The grid containing lengths of bacteria. Returns: int: The maximum length of bacteria in any submatrix. Examples: >>> max_bacteria_length(3, 3, [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ]) 5 >>> max_bacteria_length(2, 4, [ [4, 3, 2, 1], [1, 5, 1, 4] ]) 5","solution":"def max_bacteria_length(n, m, grid): Returns the maximum length of the bacteria obtainable in any rectangular sub-grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of int): The grid containing lengths of bacteria. Returns: int: The maximum length of bacteria in any submatrix. max_length = 0 for row in grid: max_length = max(max_length, max(row)) return max_length"},{"question":"def is_balanced(n: int, sequence: str) -> str: Determine if the sequence of brackets is balanced. A sequence is balanced if: 1. Each opening bracket has a corresponding closing bracket of the same type. 2. Brackets close in the correct order. Parameters: n (int): Length of the sequence. sequence (str): A sequence of brackets consisting only of round and square brackets. Returns: str: \\"YES\\" if the sequence is balanced, \\"NO\\" otherwise. Examples: >>> is_balanced(8, \\"([]([]))\\") \\"YES\\" >>> is_balanced(5, \\"([)])\\") \\"NO\\" >>> is_balanced(4, \\"[((\\") \\"NO\\"","solution":"def is_balanced(n, sequence): Returns \\"YES\\" if the sequence of brackets is balanced. Otherwise, returns \\"NO\\". Params: n (int): Length of the sequence. sequence (str): A sequence of brackets consisting only of round and square brackets. Returns: str: \\"YES\\" if the sequence is balanced, \\"NO\\" otherwise. stack = [] brackets = {')': '(', ']': '['} for char in sequence: if char in brackets.values(): # if it's an opening bracket stack.append(char) elif char in brackets: # if it's a closing bracket if stack and stack[-1] == brackets[char]: stack.pop() else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def max_working_sensors_segment(n: int, sensors: List[int]) -> Tuple[int, int]: Calculate the maximum length of continuous working sensors and the number of such segments. :param n: An integer representing the number of sensors. :param sensors: A list of integers representing the working status of each sensor (1 if working, 0 otherwise). :return: A tuple containing two integers - the maximum length of continuous working sensors and the number of such segments. Examples: >>> max_working_sensors_segment(10, [1, 0, 1, 1, 0, 1, 1, 1, 0, 1]) (3, 1) >>> max_working_sensors_segment(5, [0, 1, 1, 1, 0]) (3, 1) >>> max_working_sensors_segment(7, [1, 1, 0, 1, 1, 0, 1]) (2, 2) pass","solution":"def max_working_sensors_segment(n, sensors): max_length = 0 max_segments_count = 0 current_length = 0 for status in sensors: if status == 1: current_length += 1 if current_length > max_length: max_length = current_length max_segments_count = 1 elif current_length == max_length: max_segments_count += 1 else: current_length = 0 return max_length, max_segments_count"},{"question":"class FileSystem: A simple in-memory file system to handle create and list commands. CREATE path: - If the path is a new directory or file, create it. - If any part of the path already exists or an invalid path is specified, print \\"Invalid path\\". LIST path: - If the path refers to a directory, print all its immediate children in lexicographical order. - If the path refers to a file or an invalid path is specified, print \\"Invalid path\\". def __init__(self): self.fs = {} def create(self, path: str): parts = path.split('/')[1:] curr = self.fs for i, part in enumerate(parts): if part not in curr: if i == len(parts) - 1: curr[part] = {} else: curr[part] = {} elif i == len(parts) - 1: print(\\"Invalid path\\") return curr = curr[part] def list(self, path: str): parts = path.split('/')[1:] curr = self.fs for part in parts: if part in curr: curr = curr.get(part, None) else: print(\\"Invalid path\\") return if not isinstance(curr, dict): print(\\"Invalid path\\") return print(' '.join(sorted(curr.keys()))) def process_commands(commands): Process a list of commands to interact with the file system. >>> process_commands([ \\"CREATE /a\\", \\"CREATE /a/b\\", \\"CREATE /a/c/d\\", \\"LIST /a\\", \\"CREATE /a/b\\", \\"LIST /a/b\\", \\"CREATE /a/c\\", \\"CREATE /a\\", \\"LIST /a/c\\", ]) b c Invalid path Invalid path Invalid path d fs = FileSystem() for command in commands: cmd, path = command.split() if cmd == \\"CREATE\\": fs.create(path) elif cmd == \\"LIST\\": fs.list(path)","solution":"class FileSystem: def __init__(self): self.fs = {} def create(self, path: str): parts = path.split('/')[1:] curr = self.fs for i, part in enumerate(parts): if part not in curr: if i == len(parts) - 1: # If it's the final part, create new file or directory curr[part] = {} else: curr[part] = {} elif i == len(parts) - 1: print(\\"Invalid path\\") return curr = curr[part] def list(self, path: str): parts = path.split('/')[1:] curr = self.fs for part in parts: if part in curr: curr = curr.get(part, None) else: print(\\"Invalid path\\") return if not isinstance(curr, dict): print(\\"Invalid path\\") return print(' '.join(sorted(curr.keys()))) # Function to process commands def process_commands(commands): fs = FileSystem() for command in commands: cmd, path = command.split() if cmd == \\"CREATE\\": fs.create(path) elif cmd == \\"LIST\\": fs.list(path)"},{"question":"def maximum_project_assignment(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: A company has m employees and n projects. Each project can be completed by exactly one employee. The company wants to assign the projects to the employees. However, each employee has specific projects they can complete. Your task is to find the maximum number of projects that can be assigned, considering the preferences of employees. Args: t (int): the number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): a list of test cases, where each test case is a tuple consisting of the number of employees and projects followed by the list of project preferences. Returns: List[int]: a list of integers representing the maximum number of projects that can be assigned for each test case. Here's an example: >>> maximum_project_assignment(3, [ ... (4, 4, [[1, 2], [2, 3], [4], [1]]), ... (3, 3, [[1, 2], [3], [2, 3]]), ... (2, 2, [[1, 2], [2]]) ... ]) [4, 3, 2] >>> maximum_project_assignment(2, [ ... (2, 2, [[1], []]), ... (3, 3, [[1], [], []]) ... ]) [1, 1] >>> maximum_project_assignment(1, [ ... (3, 3, [[1, 2, 3], [1, 2, 3], [1, 2, 3]]) ... ]) [3]","solution":"def maximum_project_assignment(t, test_cases): def bpm(u, match_r, seen): for v in adj[u]: if not seen[v]: seen[v] = True if match_r[v] == -1 or bpm(match_r[v], match_r, seen): match_r[v] = u return True return False results = [] for case in test_cases: m, n, preferences = case adj = [[] for _ in range(m)] for i in range(m): adj[i] = [p - 1 for p in preferences[i]] match_r = [-1] * n result = 0 for i in range(m): seen = [False] * n if bpm(i, match_r, seen): result += 1 results.append(result) return results # Example on how the function can be called: t = 3 test_cases = [ (4, 4, [[1, 2], [2, 3], [4], [1]]), (3, 3, [[1, 2], [3], [2, 3]]), (2, 2, [[1, 2], [2]]) ] output = maximum_project_assignment(t, test_cases) print(output) # Expected output: [4, 3, 2]"},{"question":"def merge_sorted_arrays(m: int, n: int, a: List[int], b: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. :param m: Length of first array \`a\`. :param n: Length of second array \`b\`. :param a: List of integers representing the first sorted array. :param b: List of integers representing the second sorted array. :return: Merged and sorted list of integers from both arrays. Examples: >>> merge_sorted_arrays(4, 3, [1, 3, 5, 7], [2, 4, 6]) [1, 2, 3, 4, 5, 6, 7] >>> merge_sorted_arrays(5, 5, [1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> merge_sorted_arrays(3, 2, [4, 4, 4], [4, 4]) [4, 4, 4, 4, 4]","solution":"def merge_sorted_arrays(m, n, a, b): Merges two sorted arrays into one sorted array. :param m: Length of first array \`a\`. :param n: Length of second array \`b\`. :param a: List of integers representing the first sorted array. :param b: List of integers representing the second sorted array. :return: Merged and sorted list of integers from both arrays. result = [] i, j = 0, 0 while i < m and j < n: if a[i] <= b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 # Append remaining elements if any while i < m: result.append(a[i]) i += 1 while j < n: result.append(b[j]) j += 1 return result"},{"question":"def reverse_words(s: str) -> str: This function takes a string s, reverses the order of the words, and returns the new string. Each word is defined as a sequence of non-space characters. It ensures that there's only one space between words in the resulting string. >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"The sky is blue\\") == \\"blue is sky The\\" >>> reverse_words(\\"a good example\\") == \\"example good a\\" >>> reverse_words(\\" Bob Loves Alice \\") == \\"Alice Loves Bob\\" pass","solution":"def reverse_words(s: str) -> str: This function takes a string s, reverses the order of the words, and returns the new string. Each word is defined as a sequence of non-space characters. It ensures that there's only one space between words in the resulting string. # Split the string by whitespace to get individual words words = s.split() # Reverse the order of words and join them with a single space reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"def count_apple_occurances(t: int, strings: List[str]) -> List[int]: Returns a list of the number of non-overlapping occurrences of \\"apple\\" in each string for a given number of test cases. Parameters: t (int): Number of test cases strings (list of str): List of input strings to be analyzed Returns: list of int: List of counts of \\"apple\\" in each string >>> count_apple_occurances(1, [\\"apple\\"]) [1] >>> count_apple_occurances(1, [\\"applepieapple\\"]) [2] >>> count_apple_occurances(1, [\\"appleappleapple\\"]) [3] >>> count_apple_occurances(1, [\\"bananapie\\"]) [0] >>> count_apple_occurances(1, [\\"\\"]) [0] >>> count_apple_occurances(3, [\\"applepieapple\\", \\"appleappleapple\\", \\"bananaappleapple\\"]) [2, 3, 2]","solution":"def count_apple_occurances(t, strings): Returns a list of the number of non-overlapping occurrences of \\"apple\\" in each string for a given number of test cases. Parameters: t (int): Number of test cases strings (list of str): List of input strings to be analyzed Returns: list of int: List of counts of \\"apple\\" in each string substring = \\"apple\\" result = [] for string in strings: count = 0 index = 0 while index <= len(string) - len(substring): index = string.find(substring, index) if index == -1: break count += 1 index += len(substring) result.append(count) return result"},{"question":"def min_swaps_to_similar(n: int, A: List[int], B: List[int]) -> int: Determines the minimum number of swaps required to make arrays A and B similar. Returns -1 if it is not possible. Args: n (int): The length of the arrays. A (List[int]): The first array of integers. B (List[int]): The second array of integers. Returns: int: Minimum number of swaps required or -1 if not possible. Examples: >>> min_swaps_to_similar(5, [1, 5, 3, 7, 9], [2, 5, 4, 8, 10]) 2 >>> min_swaps_to_similar(4, [1, 3, 2, 4], [1, 3, 2, 6]) -1 pass # Unit Tests from solution import min_swaps_to_similar def test_example_case_1(): assert min_swaps_to_similar(5, [1, 5, 3, 7, 9], [2, 5, 4, 8, 10]) == 2 def test_example_case_2(): assert min_swaps_to_similar(4, [1, 3, 2, 4], [1, 3, 2, 6]) == -1 def test_all_elements_equal(): assert min_swaps_to_similar(3, [1, 1, 1], [1, 1, 1]) == 0 def test_no_swaps_needed(): assert min_swaps_to_similar(4, [2, 3, 4, 5], [2, 3, 4, 5]) == 0 def test_all_swaps_needed(): assert min_swaps_to_similar(4, [8, 9, 7, 6], [9, 8, 6, 7]) == 2 def test_large_difference(): assert min_swaps_to_similar(3, [1, 5, 3], [1, 10, 3]) == -1 def test_mixed_scenario(): assert min_swaps_to_similar(5, [3, 3, 3, 2, 2], [2, 2, 2, 3, 3]) == 2","solution":"def min_swaps_to_similar(n, A, B): Determines the minimum number of swaps required to make arrays A and B similar. Returns -1 if it is not possible. # Create a list of pairs (A[i], B[i]) pairs = list(zip(A, B)) # Check if |A[i] - B[i]| <= 1 for all i for a, b in pairs: if abs(a - b) > 1: return -1 # Sort the pairs to minimize the differences pairs.sort() # Count the number of swaps by counting mismatches swaps = 0 for i in range(n): a, b = pairs[i] if a != b: swaps += 1 return swaps // 2 # Example usage: # n = 5 # A = [1, 5, 3, 7, 9] # B = [2, 5, 4, 8, 10] # print(min_swaps_to_similar(n, A, B)) # Output: 2"},{"question":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_cost_to_connect_villages(N, M, roads): Determine the minimum cost to connect all villages in the kingdom. Args: N (int): the number of villages. M (int): the number of roads. roads (List[Tuple[int, int, int]]): a list of tuples where each tuple represents a road and contains three integers representing two villages and the cost of the road connecting them. Returns: int: The minimum total cost to connect all villages. If it's not possible to connect all villages, returns \`-1\`. pass def from_input_string(input_string): lines = input_string.strip().split(\\"n\\") N, M = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:]] return N, M, roads def from_output_string(output_string): return int(output_string.strip()) def to_input_string(inputs): N, M, roads = inputs roads_str = \\"n\\".join(\\" \\".join(map(str, r)) for r in roads) return f\\"{N} {M}n{roads_str}\\" def to_output_string(output): return str(output)","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_cost_to_connect_villages(N, M, roads): roads = sorted(roads, key=lambda x: x[2]) uf = UnionFind(N) mst_cost = 0 edges_used = 0 for u, v, cost in roads: if uf.find(u - 1) != uf.find(v - 1): uf.union(u - 1, v - 1) mst_cost += cost edges_used += 1 if edges_used == N - 1: return mst_cost return -1 if edges_used != N - 1 else mst_cost def from_input_string(input_string): lines = input_string.strip().split(\\"n\\") N, M = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:]] return N, M, roads def from_output_string(output_string): return int(output_string.strip()) def to_input_string(inputs): N, M, roads = inputs roads_str = \\"n\\".join(\\" \\".join(map(str, r)) for r in roads) return f\\"{N} {M}n{roads_str}\\" def to_output_string(output): return str(output)"},{"question":"def calculate_walking_path_length(m: int, n: int) -> int: Calculate the length of the walking path needed for a given garden with M rows and N columns. The length is calculated as (M * N * 2). >>> calculate_walking_path_length(3, 3) 18 >>> calculate_walking_path_length(4, 5) 40 >>> calculate_walking_path_length(10, 8) 160 def process_garden_paths(input_lines: List[str]) -> List[str]: Processes multiple datasets and outputs the walking path lengths for each garden. >>> process_garden_paths([\\"3 3\\", \\"4 5\\", \\"10 8\\", \\"0 0\\"]) ['18 units', '40 units', '160 units'] >>> process_garden_paths([\\"1 1\\", \\"2 2\\", \\"5 6\\", \\"0 0\\"]) ['2 units', '8 units', '60 units']","solution":"def calculate_walking_path_length(m, n): Calculate the length of the walking path needed for a given garden with M rows and N columns. The length is calculated as (M * N * 2). if m == 0 or n == 0: return None return m * n * 2 def process_garden_paths(input_lines): Processes multiple datasets and outputs the walking path lengths for each garden. results = [] for line in input_lines: m, n = map(int, line.split()) if m == 0 and n == 0: break path_length = calculate_walking_path_length(m, n) results.append(f\\"{path_length} units\\") return results"},{"question":"from typing import List, Tuple def minimum_cost_to_connect_towns(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum cost to connect all towns using magical roads. Each road can only be used once. Args: n: int - the number of towns. m: int - the number of magical roads. roads: List[Tuple[int, int, int]] - each tuple contains (u, v, w) where u and v are towns, and w is the cost to traverse the road between them. Returns: int - the minimum cost to connect all towns, or -1 if it's not possible. Examples: >>> minimum_cost_to_connect_towns(4, 5, [(1, 2, 3), (2, 3, 2), (3, 4, 4), (1, 4, 1), (1, 3, 5)]) 6 >>> minimum_cost_to_connect_towns(3, 1, [(1, 2, 1)]) -1 pass","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n mst_cost = 0 edge_count = 0 for u, v, w in edges: u -= 1 v -= 1 if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w edge_count += 1 if edge_count == n - 1: return mst_cost return -1 def minimum_cost_to_connect_towns(n, m, roads): if n - 1 > m: return -1 return kruskal(n, roads)"},{"question":"from typing import List def shortest_path_to_bone(n: int, m: int, grid: List[str], sr: int, sc: int, br: int, bc: int) -> int: Given a grid with obstacles and two points, find the shortest path from the start point to the bone. If there is no path, return -1. >>> shortest_path_to_bone(5, 5, ['.....', '.#.', '...#.', '.#.#.', '.....'], 0, 0, 4, 4) 8 # Implementation goes here def test_shortest_path_to_bone(): n, m = 5, 5 grid = [ '.....', '.#.', '...#.', '.#.#.', '.....' ] sr, sc = 0, 0 br, bc = 4, 4 assert shortest_path_to_bone(n, m, grid, sr, sc, br, bc) == 8 def test_no_path(): n, m = 3, 3 grid = [ '...', '#', '...' ] sr, sc = 0, 0 br, bc = 2, 2 assert shortest_path_to_bone(n, m, grid, sr, sc, br, bc) == -1 def test_single_step(): n, m = 2, 2 grid = [ '..', '..' ] sr, sc = 0, 0 br, bc = 0, 1 assert shortest_path_to_bone(n, m, grid, sr, sc, br, bc) == 1 def test_already_at_bone(): n, m = 3, 3 grid = [ '...', '...', '...' ] sr, sc = 1, 1 br, bc = 1, 1 assert shortest_path_to_bone(n, m, grid, sr, sc, br, bc) == 0 def test_large_grid(): n, m = 1000, 1000 grid = ['.' * 1000 for _ in range(1000)] sr, sc = 0, 0 br, bc = 999, 999 assert shortest_path_to_bone(n, m, grid, sr, sc, br, bc) == 1998","solution":"from collections import deque def shortest_path_to_bone(n, m, grid, sr, sc, br, bc): # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize a queue for BFS and a visited set queue = deque([(sr, sc, 0)]) # (row, col, distance) visited = set((sr, sc)) while queue: r, c, dist = queue.popleft() # If we reached the bone, return the distance if (r, c) == (br, bc): return dist # Explore neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # If we exhaust the queue without finding the bone return -1"},{"question":"def longest_balanced_substring(S: str) -> int: Returns the length of the longest balanced substring (with equal number of 'a' and 'b') in the given string S. >>> longest_balanced_substring(\\"abbaba\\") 6 >>> longest_balanced_substring(\\"ababa\\") 4 >>> longest_balanced_substring(\\"aaaa\\") 0","solution":"def longest_balanced_substring(S): Returns the length of the longest balanced substring (with equal number of 'a' and 'b') in the given string S. max_length = 0 n = len(S) # Iterate through all possible starting points of substrings for i in range(n): count_a = 0 count_b = 0 # Iterate through the substring starting from i to the end of the string for j in range(i, n): if S[j] == 'a': count_a += 1 else: count_b += 1 # If counts are equal, we have a balanced substring if count_a == count_b: max_length = max(max_length, j - i + 1) return max_length"},{"question":"def rank_participants(n: int, scores: List[Tuple[int, int]]) -> List[int]: Determine the ranking of participants based on their scores. :param n: Number of participants :param scores: List of tuples where each tuple contains (ID, score) :return: List of participant IDs in the correct ranking order Examples: >>> rank_participants(4, [(3, 95), (1, 85), (2, 85), (4, 90)]) == [3, 4, 1, 2] >>> rank_participants(3, [(2, 75), (1, 90), (3, 85)]) == [1, 3, 2]","solution":"def rank_participants(n, scores): Returns the participant IDs in the correct ranking order. :param n: Number of participants :param scores: List of tuples where each tuple contains (ID, score) :return: List of participant IDs in the correct ranking order # Sort the participants first by score in descending order, then by ID in ascending order scores.sort(key=lambda x: (-x[1], x[0])) # Extract and return only the IDs in the required order return [id for id, score in scores]"},{"question":"def max_subsequence_sum(N: int, sequence: List[int]) -> int: Returns the maximum possible value of a contiguous subsequence within the given sequence. Parameters: N (int): The length of the sequence. sequence (list of int): The sequence of integers. Returns: int: The maximum possible value of a contiguous subsequence. Examples: >>> max_subsequence_sum(5, [1, -2, 3, 10, -4]) 13 >>> max_subsequence_sum(4, [-2, -3, -1, -5]) -1","solution":"def max_subsequence_sum(N, sequence): Returns the maximum possible value of a contiguous subsequence within the given sequence. N: int, length of the sequence sequence: list of int, the sequence of integers max_sum = float('-inf') current_sum = 0 for num in sequence: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def top_n_genres(B: int, N: int, books: List[str]) -> List[Tuple[str, int]]: Determine the top N genres in terms of number of books they include. If two genres have the same count, they should be ordered lexicographically. >>> top_n_genres(5, 3, [ \\"1 fantasy mystery\\", \\"2 mystery\\", \\"3 fantasy\\", \\"4 romance\\", \\"5 fantasy romance\\" ]) [('fantasy', 3), ('mystery', 2), ('romance', 2)] >>> top_n_genres(4, 2, [ \\"1 history\\", \\"2 science history\\", \\"3 history\\", \\"4 science\\" ]) [('history', 3), ('science', 2)] def format_genre_output(sorted_genres: List[Tuple[str, int]]) -> List[str]: Convert the sorted genres list into a list of formatted strings. >>> format_genre_output([('fantasy', 3), ('mystery', 2), ('romance', 2)]) ['fantasy 3', 'mystery 2', 'romance 2'] >>> format_genre_output([('history', 3), ('science', 2)]) ['history 3', 'science 2']","solution":"def top_n_genres(B, N, books): from collections import defaultdict genre_count = defaultdict(int) for book in books: book_info = book.split() genres = book_info[1:] for genre in genres: genre_count[genre] += 1 sorted_genres = sorted(genre_count.items(), key=lambda x: (-x[1], x[0])) return sorted_genres[:N] def format_genre_output(sorted_genres): return [f\\"{genre} {count}\\" for genre, count in sorted_genres]"},{"question":"from typing import List def reorganize_string(s: str) -> str: Reorganize a string such that no two adjacent characters are the same. Returns an empty string if it is not possible to achieve this. pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases for reorganizing strings. >>> process_test_cases(3, [\\"aab\\", \\"aaab\\", \\"abc\\"]) = [\\"aba\\", \\"\\", \\"abc\\"] >>> process_test_cases(1, [\\"a\\"]) = [\\"a\\"] >>> process_test_cases(1, [\\"aa\\"]) = [\\"\\"] pass from solution import process_test_cases def test_reorganize_string_example_cases(): assert process_test_cases(3, [\\"aab\\", \\"aaab\\", \\"abc\\"]) == [\\"aba\\", \\"\\", \\"abc\\"] def test_reorganize_string_single_char(): assert process_test_cases(1, [\\"a\\"]) == [\\"a\\"] def test_reorganize_string_multiple_same_char(): assert process_test_cases(1, [\\"aa\\"]) == [\\"\\"] def test_reorganize_string_alternating_chars(): assert process_test_cases(1, [\\"ababab\\"]) == [\\"ababab\\"] def test_reorganize_string_mix_chars(): assert process_test_cases(1, [\\"aaabbc\\"]) == [\\"ababac\\"] assert process_test_cases(1, [\\"abcabc\\"]) == [\\"abcabc\\"] def test_reorganize_string_impossible_case(): assert process_test_cases(1, [\\"aaaaa\\"]) == [\\"\\"] assert process_test_cases(1, [\\"aaabbbccc\\"]) == [\\"abcabcabc\\"] assert process_test_cases(1, [\\"aaabb\\"]) == [\\"ababa\\"]","solution":"from collections import Counter import heapq def reorganize_string(s): # Count the frequency of each character in the string frequency = Counter(s) # Create a max heap based on frequency (-frequency to make it a max-heap) max_heap = [(-freq, char) for char, freq in frequency.items()] heapq.heapify(max_heap) # Initialize previous character and result string prev_char, prev_freq = '', 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If previous character exists and has remaining frequency, add it back to the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Set the current character as the previous one, and decrement its frequency prev_char = char prev_freq = freq + 1 # If rearranged string length is equal to the original string, return the string if len(result) == len(s): return ''.join(result) else: return \\"\\" def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(reorganize_string(s)) return results"},{"question":"def can_equalize_workload(n: int, workloads: list) -> str: Determine if it is possible to equalize the workloads of all machines. Parameters: n (int): the number of machines workloads (list of int): the initial workload of each machine Returns: str: \\"YES\\" if it is possible to equalize the workloads, \\"NO\\" otherwise >>> can_equalize_workload(3, [4, 6, 2]) \\"YES\\" >>> can_equalize_workload(4, [3, 1, 4, 2]) \\"NO\\" >>> can_equalize_workload(2, [7, 7]) \\"YES\\"","solution":"def can_equalize_workload(n, workloads): Determine if it is possible to equalize the workloads of all machines. Parameters: n (int): the number of machines workloads (list of int): the initial workload of each machine Returns: str: \\"YES\\" if it is possible to equalize the workloads, \\"NO\\" otherwise # Calculate the total workload total_workload = sum(workloads) # Check if the total workload is divisible by the number of machines if total_workload % n != 0: return \\"NO\\" # Check each pair of adjacent machines for i in range(n - 1): if (workloads[i] + workloads[i + 1]) % 2 != 0: return \\"NO\\" return \\"YES\\""},{"question":"def max_result_score(N: int, A: List[int]) -> int: Compute the maximum possible result score by repeatedly removing elements from the array A and adding their values to the result score. Parameters: N (int): The length of the array. A (list of int): The array of integers (1 ≤ A_i ≤ 1000). Returns: int: The maximum possible result score. Examples: >>> max_result_score(4, [1, 2, 3, 4]) 10 >>> max_result_score(5, [5, 5, 10, 100, 10]) 130 >>> max_result_score(6, [3, 2, 3, 2, 3, 2]) 15 >>> max_result_score(1, [10]) 10 >>> max_result_score(3, [7, 7, 7]) 21 >>> max_result_score(4, [1, 100, 1000, 10]) 1111","solution":"def max_result_score(N, A): Computes the maximum possible result score by repeatedly removing elements from the array A and adding their values to the result score. Parameters: N (int): The length of the array. A (list of int): The array of integers. Returns: int: The maximum possible result score. return sum(A)"},{"question":"class RecipeManager: def __init__(self): pass def add_recipe(self, recipe_name, ingredients): pass def update_recipe(self, recipe_name, ingredients): pass def delete_recipe(self, recipe_name): pass def check_recipe(self, recipe_name, pantry_ingredients): pass def process_operations(self, operations): Process a list of operations to manage recipes. Args: operations (List[str]): List of operations to be performed. Returns: List[str]: Result of each \\"CHECK\\" operation. Example: >>> operations = [ ... \\"ADD Pasta I Noodles 200 I Sauce 150 I Cheese 50\\", ... \\"CHECK Pasta I Noodles 200 I Sauce 150 I Cheese 50\\" ... ] >>> process_operations(operations) ['YES'] pass def manage_recipes(operations): Given a list of operations related to recipe management, return the result of each \\"CHECK\\" operation. Input: operations (List[str]): List of operations as described in the prompt. Output: List[str]: List of \\"YES\\"/\\"NO\\" results for each \\"CHECK\\" operation. Example: >>> operations = [ ... \\"ADD Pasta I Noodles 200 I Sauce 150 I Cheese 50\\", ... \\"CHECK Pasta I Noodles 200 I Sauce 150 I Cheese 50\\" ... ] >>> manage_recipes(operations) ['YES'] pass","solution":"class RecipeManager: def __init__(self): self.recipes = {} def add_recipe(self, recipe_name, ingredients): self.recipes[recipe_name] = ingredients def update_recipe(self, recipe_name, ingredients): if recipe_name in self.recipes: self.recipes[recipe_name] = ingredients def delete_recipe(self, recipe_name): if recipe_name in self.recipes: del self.recipes[recipe_name] def check_recipe(self, recipe_name, pantry_ingredients): if recipe_name not in self.recipes: return \\"NO\\" recipe_ingredients = self.recipes[recipe_name] for ingredient, quantity in recipe_ingredients.items(): if ingredient not in pantry_ingredients or pantry_ingredients[ingredient] < quantity: return \\"NO\\" return \\"YES\\" def process_operations(self, operations): results = [] for operation in operations: tokens = operation.split() command = tokens[0] recipe_name = tokens[1] ingredients = {} if command in [\\"ADD\\", \\"UPDATE\\", \\"CHECK\\"]: for i in range(3, len(tokens), 3): ingredient_name = tokens[i] ingredient_quantity = int(tokens[i+1]) ingredients[ingredient_name] = ingredient_quantity if command == \\"ADD\\": self.add_recipe(recipe_name, ingredients) elif command == \\"UPDATE\\": self.update_recipe(recipe_name, ingredients) elif command == \\"DELETE\\": self.delete_recipe(recipe_name) elif command == \\"CHECK\\": result = self.check_recipe(recipe_name, ingredients) results.append(result) return results # Helper function to handle input and processing def manage_recipes(operations): manager = RecipeManager() return manager.process_operations(operations)"},{"question":"def generate_balanced_string(n): Generate a balanced string of length n with equal number of 'A's and 'B's. If not possible, return \\"not possible\\". >>> generate_balanced_string(6) in [\\"AABBAB\\", \\"ABABAB\\", \\"BBAAAB\\", \\"BABAAB\\", \\"ABBAAB\\", \\"AABABB\\"] True >>> generate_balanced_string(4) in [\\"AABB\\", \\"ABAB\\", \\"BBAA\\"] True >>> generate_balanced_string(2) in [\\"AB\\", \\"BA\\"] True >>> generate_balanced_string(3) not possible >>> generate_balanced_string(7) not possible >>> generate_balanced_string(1) not possible >>> generate_balanced_string(1000).count(\\"A\\") 500 >>> generate_balanced_string(1000).count(\\"B\\") 500","solution":"def generate_balanced_string(n): Generate a balanced string of length n with equal number of 'A's and 'B's. If not possible, return \\"not possible\\". if n % 2 != 0: return \\"not possible\\" return (\\"AB\\" * (n // 2))[:n]"},{"question":"def max_zyxenite(n: int, k: int, mines: List[int]) -> int: Returns the maximum amount of Zyxenite that can be mined by operating at most K mines. :param n: Number of mines :param k: Maximum number of mines that can be operated :param mines: List of integers, where each integer represents the amount of Zyxenite in a mine :return: Maximum amount of Zyxenite that can be mined # Example usage: # >>> max_zyxenite(6, 3, [10, 20, 30, 40, 50, 60]) # 150 # >>> max_zyxenite(1, 1, [100]) # 100 from typing import List from solution import max_zyxenite def test_single_mine(): assert max_zyxenite(1, 1, [100]) == 100 def test_all_mines(): assert max_zyxenite(4, 4, [10, 20, 30, 40]) == 100 def test_some_mines(): assert max_zyxenite(6, 3, [10, 20, 30, 40, 50, 60]) == 150 def test_single_large_mine(): assert max_zyxenite(3, 1, [5, 5, 100]) == 100 def test_equal_mines(): assert max_zyxenite(5, 2, [10, 10, 10, 10, 10]) == 20 def test_large_input(): n = 100000 k = 100000 mines = [1] * n assert max_zyxenite(n, k, mines) == 100000","solution":"def max_zyxenite(n, k, mines): Returns the maximum amount of Zyxenite that can be mined by operating at most K mines. :param n: Number of mines :param k: Maximum number of mines that can be operated :param mines: List of integers, where each integer represents the amount of Zyxenite in a mine :return: Maximum amount of Zyxenite that can be mined # Sort the mines in descending order to get the largest amounts first mines_sorted = sorted(mines, reverse=True) # Sum the first K elements from the sorted list return sum(mines_sorted[:k])"},{"question":"from typing import List, Tuple class TimeSeries: def __init__(self): self.timestamps = [] self.data = {} def insert(self, ti: int, vi: int): pass def delete(self, ti: int): pass def query(self, t1: int, t2: int) -> int: pass def process_operations(operations: List[Tuple[int, int, int]]) -> List[int]: Handle time-series operations and return query results. >>> process_operations([(1, 1, 100), (1, 2, 200), (1, 5, 150), (3, 1, 5), (2, 2), (3, 1, 5), (3, 2, 6)]) [200, 150, 150] >>> process_operations([(1, 1, 100), (1, 2, 100), (1, 3, 100), (3, 1, 3), (2, 1), (3, 1, 3), (2, 2), (3, 1, 3), (2, 3)]) [100, 100, 100] >>> process_operations([(1, 2, 50), (1, 5, 60), (1, 8, 70), (3, 5, 10), (3, 1, 10), (2, 5), (3, 5, 10)]) [70, 70, 70] >>> process_operations([(1, 1, 99), (1, 2, 199), (3, 1, 2), (2, 2), (3, 1, 2), (1, 3, 299), (3, 1, 3)]) [199, 99, 299] pass","solution":"import bisect class TimeSeries: def __init__(self): self.timestamps = [] self.data = {} def insert(self, ti, vi): if ti in self.data: self.delete(ti) # delete old value if exists to keep data consistent bisect.insort(self.timestamps, ti) self.data[ti] = vi def delete(self, ti): if ti in self.data: self.timestamps.remove(ti) del self.data[ti] def query(self, t1, t2): start = bisect.bisect_left(self.timestamps, t1) end = bisect.bisect_right(self.timestamps, t2) max_val = float('-inf') for i in range(start, end): max_val = max(max_val, self.data[self.timestamps[i]]) return max_val def process_operations(operations): ts = TimeSeries() results = [] for operation in operations: if operation[0] == 1: _, ti, vi = operation ts.insert(ti, vi) elif operation[0] == 2: _, ti = operation ts.delete(ti) elif operation[0] == 3: _, t1, t2 = operation results.append(ts.query(t1, t2)) return results"},{"question":"def game_winner(rows: List[List[int]]) -> str: Determine the winner of the game given the starting configuration of rows. Tom and Jerry are playing a number game with \`m\` rows of numbers. Each row contains an even number of integers. They take turns alternately, with Tom going first. A player selects one row and removes exactly half of the integers in that row on their turn. The first player to be unable to make a move loses the game. Args: rows (List[List[int]]): A list of lists, where each sublist contains an even number of integers for the respective row. Returns: str: The winner of the game, either \\"Tom\\" or \\"Jerry\\". Example: >>> game_winner([[2, 4], [3, 6, 1, 7], [8, 5]]) \\"Tom\\" >>> game_winner([[2, 5, 6, 4], [7, 3, 8, 2]]) \\"Jerry\\"","solution":"def game_winner(rows): m = len(rows) # Since m is guaranteed to be the number of rows (with even total numbers and even count per row) # Tom, being first, if m is odd Tom wins, if m is even Jerry wins. return \\"Tom\\" if m % 2 == 1 else \\"Jerry\\" # Example usage rows = [ [2, 4], [3, 6, 1, 7], [8, 5] ] print(game_winner(rows)) # Output should be \\"Tom\\" rows = [ [2, 5, 6, 4], [7, 3, 8, 2] ] print(game_winner(rows)) # Output should be \\"Jerry\\""},{"question":"from typing import List def decrypt_message(encrypted_message: str) -> str: Decrypt a single message string by replacing each letter with the previous one in the alphabet. Wrap around 'a' to 'z'. >>> decrypt_message('bcd') 'abc' >>> decrypt_message('yza') 'xyz' >>> decrypt_message('abc') 'zab' >>> decrypt_message('a') 'z' pass def decrypt_messages(test_cases: List[str]) -> List[str]: Decrypts a list of encrypted messages. >>> decrypt_messages(['bcd', 'yza', 'abc']) ['abc', 'xyz', 'zab'] >>> decrypt_messages(['zabc', 'lmno', 'pqr', 'stu']) ['yzab', 'klmn', 'opq', 'rst'] pass","solution":"def decrypt_message(encrypted_message): decrypted_message = [] for char in encrypted_message: if char == 'a': decrypted_message.append('z') else: decrypted_message.append(chr(ord(char) - 1)) return ''.join(decrypted_message) def decrypt_messages(test_cases): results = [] for message in test_cases: results.append(decrypt_message(message)) return results"},{"question":"def min_cost_path(R: int, C: int, grid: List[List[int]]) -> (int, str): Find the minimum cost path from the top-left cell to the bottom-right cell in a grid. The robot can only move either right or down from a cell to an adjacent cell. >>> min_cost_path(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) (7, 'RRDD') >>> min_cost_path(2, 2, [[1, 2], [1, 1]]) (3, 'DR') Args: R (int): Number of rows in the grid C (int): Number of columns in the grid grid (List[List[int]]): 2D list representing the grid Returns: int: Minimum cost to reach the bottom-right cell str: Path consisting of 'R' for right and 'D' for down from typing import List def test_min_cost_path_example1(): R = 3 C = 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] cost, path = min_cost_path(R, C, grid) assert cost == 7 assert path == 'RRDD' def test_min_cost_path_example2(): R = 2 C = 2 grid = [ [1, 2], [1, 1] ] cost, path = min_cost_path(R, C, grid) assert cost == 3 assert path == 'DR' def test_min_cost_path_single_cell(): R = 1 C = 1 grid = [[7]] cost, path = min_cost_path(R, C, grid) assert cost == 7 assert path == '' def test_min_cost_path_single_row(): R = 1 C = 3 grid = [[3, 1, 2]] cost, path = min_cost_path(R, C, grid) assert cost == 6 assert path == 'RR' def test_min_cost_path_single_column(): R = 3 C = 1 grid = [[1], [4], [6]] cost, path = min_cost_path(R, C, grid) assert cost == 11 assert path == 'DD'","solution":"def min_cost_path(R, C, grid): dp = [[0] * C for _ in range(R)] direction = [[\\"\\"] * C for _ in range(R)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] direction[0][j] = direction[0][j-1] + 'R' # Initialize the first column for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] direction[i][0] = direction[i-1][0] + 'D' # Fill the rest of the dp table for i in range(1, R): for j in range(1, C): if dp[i-1][j] < dp[i][j-1]: dp[i][j] = dp[i-1][j] + grid[i][j] direction[i][j] = direction[i-1][j] + 'D' else: dp[i][j] = dp[i][j-1] + grid[i][j] direction[i][j] = direction[i][j-1] + 'R' return dp[R-1][C-1], direction[R-1][C-1] def main(): import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for i in range(R): row = [] for j in range(C): row.append(int(data[index])) index += 1 grid.append(row) min_cost, path = min_cost_path(R, C, grid) print(min_cost) print(path)"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def is_bipartite(n: int, edges: List[Tuple[int, int]]) -> bool: Write a program that checks if an undirected graph is bipartite. A graph is bipartite if the nodes can be colored using two colors such that no two adjacent nodes have the same color. Args: n: the number of edges. edges: List of tuples representing edges in the graph. Returns: True if the graph is bipartite, otherwise False. Examples: >>> is_bipartite(3, [(1, 2), (2, 3), (3, 1)]) False >>> is_bipartite(4, [(1, 2), (1, 3), (2, 4), (3, 4)]) True","solution":"from collections import defaultdict, deque def is_bipartite(n, edges): graph = defaultdict(list) # Building the graph from the edges for u, v in edges: graph[u].append(v) graph[v].append(u) color = {} # Function to perform BFS and check bipartiteness def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in color: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True # Check all components of the graph for node in graph: if node not in color: if not bfs(node): return False return True # Example usage if __name__ == \\"__main__\\": n = int(input()) edges = [tuple(map(int, input().strip().split())) for _ in range(n)] print(is_bipartite(n, edges))"},{"question":"from collections import deque def shortest_path(grid): Find the shortest path in a grid from the top-left to the bottom-right, avoiding obstacles. >>> shortest_path([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 4 >>> shortest_path([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1 pass def main(input_string: str) -> str: Process multiple test cases from a single input string to find shortest paths. >>> input_string = \\"2n3 3n0 0 0n0 1 0n0 0 0n3 3n0 1 0n1 1 0n0 0 0n\\" >>> main(input_string) \\"4n-1\\" >>> input_string = \\"1n1 1n0n\\" >>> main(input_string) \\"0\\" >>> input_string = \\"1n2 2n0 1n1 0n\\" >>> main(input_string) \\"-1\\" >>> input_string = \\"1n2 2n0 0n0 0n\\" >>> main(input_string) \\"2\\" >>> input_string = \\"1n3 3n0 0 0n0 1 1n0 0 0n\\" >>> main(input_string) \\"4\\" pass","solution":"from collections import deque def shortest_path(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1 def parse_input(input_string): input_lines = input_string.strip().split(\\"n\\") num_cases = int(input_lines[0]) index = 1 test_cases = [] for _ in range(num_cases): n, m = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(n): grid.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append(grid) return test_cases def process_test_cases(input_string): test_cases = parse_input(input_string) results = [] for grid in test_cases: results.append(shortest_path(grid)) return results def main(input_string): results = process_test_cases(input_string) return 'n'.join(map(str, results))"},{"question":"def merge_intervals(intervals, new_interval): Merge an additional interval into a list of non-overlapping intervals so that the intervals remain non-overlapping and sorted. Arguments: intervals: A list of tuples where each tuple consists of two integers (start, end) representing an interval new_interval: A tuple (start, end) representing the interval to be added Returns: A new list of intervals after merging the new interval into the list of intervals such that no intervals overlap. Examples: >>> merge_intervals([(1, 3), (6, 9)], (2, 5)) [(1, 5), (6, 9)] >>> merge_intervals([(1, 2), (3, 5), (6, 7), (8, 10), (12, 16)], (4, 9)) [(1, 2), (3, 10), (12, 16)] from solution import merge_intervals def test_merge_intervals_case1(): assert merge_intervals([(1, 3), (6, 9)], (2, 5)) == [(1, 5), (6, 9)] def test_merge_intervals_case2(): assert merge_intervals([(1, 2), (3, 5), (6, 7), (8, 10), (12, 16)], (4, 9)) == [(1, 2), (3, 10), (12, 16)] def test_merge_intervals_no_overlap_new_after(): assert merge_intervals([(1, 2), (3, 5)], (6, 7)) == [(1, 2), (3, 5), (6, 7)] def test_merge_intervals_no_overlap_new_before(): assert merge_intervals([(3, 5), (6, 8)], (1, 2)) == [(1, 2), (3, 5), (6, 8)] def test_merge_intervals_full_merge_one_interval(): assert merge_intervals([(1, 10)], (2, 6)) == [(1, 10)] def test_merge_intervals_edge_case_single_interval(): assert merge_intervals([(1, 5)], (2, 3)) == [(1, 5)] def test_merge_intervals_large_new_interval(): assert merge_intervals([(1, 2), (3, 4), (5, 6)], (0, 10)) == [(0, 10)] def test_merge_intervals_adjacent_intervals(): assert merge_intervals([(1, 2), (3, 5)], (2, 3)) == [(1, 5)]","solution":"def merge_intervals(intervals, new_interval): Merges a new interval into a list of non-overlapping intervals and returns the new, non-overlapping, sorted list. merged = [] i, n = 0, len(intervals) # Add all intervals that come before the new interval. while i < n and intervals[i][1] < new_interval[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals with the new interval. while i < n and intervals[i][0] <= new_interval[1]: new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1])) i += 1 merged.append(new_interval) # Add the remaining intervals after the new interval. while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix clockwise. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1]]) [[1]] N = len(matrix) rotated = [[0] * N for _ in range(N)] for row in range(N): for col in range(N): rotated[col][N-1-row] = matrix[row][col] return rotated def print_matrix(matrix: List[List[int]]) -> None: Prints the matrix in the required format. for row in matrix: print(\\" \\".join(map(str, row))) def main() -> None: Reads the input, rotates the matrix, and prints the output. N = int(input()) matrix = [] for _ in range(N): row = list(map(int, input().strip().split())) matrix.append(row) rotated_matrix = rotate_matrix(matrix) print_matrix(rotated_matrix) if __name__ == \\"__main__\\": main()","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix clockwise. N = len(matrix) rotated = [[0] * N for _ in range(N)] for row in range(N): for col in range(N): rotated[col][N-1-row] = matrix[row][col] return rotated def print_matrix(matrix): Prints the matrix in the required format. for row in matrix: print(\\" \\".join(map(str, row))) def main(): # Read input N = int(input()) matrix = [] for _ in range(N): row = list(map(int, input().strip().split())) matrix.append(row) # Rotate matrix rotated_matrix = rotate_matrix(matrix) # Print output print_matrix(rotated_matrix) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def minimal_work_days(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimal number of work days required to complete all tasks. Each work day can have up to 8 hours of tasks scheduled. Args: t: The number of test cases. test_cases: A list of tuples, each containing an integer n (the number of tasks) and a list of n positive integers representing the duration in hours of the tasks. Returns: A list of integers where each integer is the minimal number of work days required for the corresponding test case. Example: >>> minimal_work_days(3, [(5, [4, 3, 2, 1, 2]), (3, [8, 8, 8]), (4, [3, 3, 3, 7])]) == [2, 3, 3] >>> minimal_work_days(1, [(1, [8])]) == [1] >>> minimal_work_days(1, [(4, [1, 1, 1, 1])]) == [1] >>> minimal_work_days(1, [(1000, [1] * 1000)]) == [125] >>> minimal_work_days(1, [(1000, [8] * 1000)]) == [1000] >>> minimal_work_days(2, [(5, [5, 5, 5, 5, 5]), (6, [2, 2, 2, 2, 2, 2])]) == [5, 2]","solution":"def minimal_work_days(t, test_cases): results = [] for i in range(t): n, tasks = test_cases[i] tasks.sort(reverse=True) # Sort tasks to pack largest tasks first days = 0 while tasks: current_day = 0 j = 0 while j < len(tasks): if current_day + tasks[j] <= 8: current_day += tasks[j] tasks.pop(j) else: j += 1 days += 1 results.append(days) return results"},{"question":"def marathon_participants(n: int, participant_ids: List[int]) -> Tuple[int, List[int]]: Given the number of logs and a list of participant IDs recorded at each checkpoint, returns the number of unique participants and their IDs in ascending order. :param n: integer - the number of checkpoint logs :param participant_ids: list of integers - the participant IDs recorded at each checkpoint :return: tuple (int, list of int) - the number of unique participants and a list of unique participant IDs >>> marathon_participants(7, [4, 2, 4, 3, 2, 1, 4]) (4, [1, 2, 3, 4]) >>> marathon_participants(5, [5, 5, 5, 5, 5]) (1, [5]) >>> marathon_participants(5, [1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) >>> marathon_participants(0, []) (0, []) >>> marathon_participants(1, [42]) (1, [42]) >>> ids = list(range(1, 100001)) >>> marathon_participants(100000, ids) (100000, ids)","solution":"def marathon_participants(n, participant_ids): Given the number of logs and a list of participant IDs recorded at each checkpoint, returns the number of unique participants and their IDs in ascending order. :param n: integer - the number of checkpoint logs :param participant_ids: list of integers - the participant IDs recorded at each checkpoint :return: tuple (int, list of int) - the number of unique participants and a list of unique participant IDs # Using a set to find unique participants unique_participants = set(participant_ids) # Converting the set to a sorted list sorted_unique_participants = sorted(unique_participants) return len(sorted_unique_participants), sorted_unique_participants"},{"question":"from typing import List from bisect import bisect_left def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. >>> longest_increasing_subsequence([5, 3, 4, 8, 6, 7]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([10, 1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence([1, 1000000000, 2, 999999999, 3, 999999998]) 4 >>> longest_increasing_subsequence([-3, -2, -1, 0, 1, 2, 3]) 7 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence. from bisect import bisect_left if not arr: return 0 n = len(arr) subseq = [] for x in arr: pos = bisect_left(subseq, x) if pos == len(subseq): subseq.append(x) else: subseq[pos] = x return len(subseq)"},{"question":"def can_schedule_contests(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[str]: Determine if it is possible to schedule all contests without overlaps for each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of test cases, each containing the number of contests and a list of contests with start and end times. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case based on whether it is possible to schedule all contests without overlaps. Examples: >>> can_schedule_contests(2, [(3, [(1, 3), (2, 4), (3, 5)]), (2, [(2, 3), (1, 2)])]) [\\"NO\\", \\"YES\\"] >>> can_schedule_contests(1, [(4, [(1, 5), (5, 10), (10, 15), (15, 20)])]) [\\"YES\\"]","solution":"def can_schedule_contests(t, test_cases): results = [] for i in range(t): n, contests = test_cases[i] # Sorting the contests by their start time, and in the case of tie, by their end time contests.sort(key=lambda x: (x[0], x[1])) possible = True prev_end = 0 for s, e in contests: if s < prev_end: possible = False break prev_end = e results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def max_depth_of_code_blocks(s: str) -> int: Returns the maximum depth of nested code blocks denoted by curly braces. Args: s (str): A string representing the code snippet. Returns: int: The maximum depth of nested code blocks. >>> max_depth_of_code_blocks(\\"{ int x = 5; { int y = 10; { int z = x + y; } } }\\") 3 >>> max_depth_of_code_blocks(\\"int x = 5; int y = 10; int z = x + y;\\") 0 >>> max_depth_of_code_blocks(\\"{ int x = 5; }\\") 1 >>> max_depth_of_code_blocks(\\"{ { { { int a = 10; } } } }\\") 4 >>> max_depth_of_code_blocks(\\"{ { }\\") 2 >>> max_depth_of_code_blocks(\\"{ for (int i = 0; i < 10; i++) { if (i % 2 == 0) { { System.out.println(i); } } } }\\") 4","solution":"def max_depth_of_code_blocks(s): Returns the maximum depth of nested code blocks denoted by curly braces. Args: s (str): A string representing the code snippet. Returns: int: The maximum depth of nested code blocks. max_depth = 0 current_depth = 0 for char in s: if char == '{': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == '}': current_depth -= 1 return max_depth"},{"question":"def subset_sum_exists(n: int, k: int, a: List[int]) -> str: Determine if there exists a subset of the given list with a sum equal to the target value. >>> subset_sum_exists(4, 5, [1, 2, 3, 4]) == \\"YES\\" >>> subset_sum_exists(3, 8, [1, 5, 6]) == \\"NO\\" >>> subset_sum_exists(6, -3, [1, -2, 3, -4, 5, -6]) == \\"YES\\"","solution":"def subset_sum_exists(n, k, a): from itertools import combinations # Check all possible subsets for r in range(1, n + 1): for subset in combinations(a, r): if sum(subset) == k: return \\"YES\\" return \\"NO\\" # Example usage print(subset_sum_exists(4, 5, [1, 2, 3, 4])) # Output should be \\"YES\\" print(subset_sum_exists(3, 8, [1, 5, 6])) # Output should be \\"NO\\" print(subset_sum_exists(6, -3, [1, -2, 3, -4, 5, -6])) # Output should be \\"YES\\""},{"question":"from typing import List def minJumps(arr: List[int]) -> int: Determine the minimum number of jumps required to reach the last index starting from the first index. If it is not possible to reach the last index, return -1. >>> minJumps([2, 3, 1, 1, 4]) 2 >>> minJumps([2, 1, 0, 3]) -1 >>> minJumps([1, 1, 1, 1]) 3 >>> minJumps([6, 2, 4, 0, 5, 1, 1, 4, 2, 9]) 2","solution":"from typing import List def minJumps(arr: List[int]) -> int: n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 maxReach = arr[0] steps = arr[0] jumps = 1 for i in range(1, n): if i == n - 1: return jumps maxReach = max(maxReach, i + arr[i]) steps -= 1 if steps == 0: jumps += 1 if i >= maxReach: return -1 steps = maxReach - i return -1"},{"question":"def max_adjacent_difference(n: int, values: List[int]) -> int: Returns the maximum absolute difference in value between any two adjacent books. :param n: Number of books :param values: List of book values :return: Maximum absolute difference between any two adjacent books' values pass def test_max_adjacent_difference_example(): assert max_adjacent_difference(5, [1, 3, 7, 8, 2]) == 6 assert max_adjacent_difference(4, [10, 5, 20, 10]) == 15 def test_max_adjacent_difference_single_difference(): assert max_adjacent_difference(2, [1, 100]) == 99 assert max_adjacent_difference(2, [100, 1]) == 99 def test_max_adjacent_difference_no_difference(): assert max_adjacent_difference(3, [10, 10, 10]) == 0 def test_max_adjacent_difference_large_values(): assert max_adjacent_difference(3, [1000000, 500000, 1000000]) == 500000 def test_max_adjacent_difference_small_values(): assert max_adjacent_difference(4, [1, 2, 3, 4]) == 1","solution":"def max_adjacent_difference(n, values): Returns the maximum absolute difference in value between any two adjacent books. :param n: Number of books :param values: List of book values :return: Maximum absolute difference between any two adjacent books' values max_diff = 0 for i in range(n - 1): diff = abs(values[i] - values[i + 1]) if diff > max_diff: max_diff = diff return max_diff"},{"question":"from typing import List, Tuple def max_min_distance(n: int, m: int, k: int, blocked_cells: List[Tuple[int, int]]) -> int: Alice wants to plant flowers in her rectangular garden such that no two flowers are in the same row or the same column. Moreover, she wishes to maximize the minimum distance between any two flowers planted. Given the dimensions of the garden (n by m), the number of cells (k) that Alice can block, and the list of cells that she can block, determine the maximum possible minimum distance between any two flowers she plants. The distance between two flowers located at (i1, j1) and (i2, j2) in the grid is |i1 - i2| + |j1 - j2|. >>> max_min_distance(3, 3, 1, [(1, 1)]) 2 >>> max_min_distance(4, 4, 2, [(1, 1), (4, 4)]) 3 >>> max_min_distance(3, 3, 0, []) 2 >>> max_min_distance(3, 3, 9, [(i, j) for i in range(3) for j in range(3)]) 0","solution":"def max_min_distance(n, m, k, blocked_cells): from heapq import heappop, heappush import itertools directions = [(0, 1), (1, 0), (-1, 0), (0, -1)] def is_in_bounds(x, y): return 0 <= x < n and 0 <= y < m def bfs(blocked): visited = [[False] * m for _ in range(n)] distances = [[float('inf')] * m for _ in range(n)] queue = [] for r, c in blocked: heappush(queue, (0, r, c)) distances[r][c] = 0 while queue: d, x, y = heappop(queue) if visited[x][y]: continue visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if is_in_bounds(nx, ny) and not visited[nx][ny]: new_dist = d + 1 if new_dist < distances[nx][ny]: distances[nx][ny] = new_dist heappush(queue, (new_dist, nx, ny)) return distances if k == 0: return (min(n, m) + 1) // 2 dists = [] for blocked_combination in itertools.combinations(blocked_cells, k): dists.append(bfs(blocked_combination)) max_distance = 0 for i in range(n): for j in range(m): possible_minimum = min(d[i][j] for d in dists) max_distance = max(max_distance, possible_minimum) return max_distance # Example usage: # n, m, k = 3, 3, 1 # blocked_cells = [(1, 1)] # print(max_min_distance(n, m, k, blocked_cells)) # Output: 2"},{"question":"def max_subarray_sum_in_range(arr, queries): Given an array and a list of queries, each asking for the maximum sum of any subarray that includes at least one element from a specified range [l, r], this function returns the answers for each query. :param arr: List of integers representing the array. :param queries: List of tuples where each tuple contains two integers representing the range [l, r]. :return: List of integers representing the maximum sum of subarrays for each query. pass def process_test_cases(t, test_cases): Processes multiple test cases of the max_subarray_sum_in_range function. :param t: Integer representing the number of test cases. :param test_cases: List of tuples, each containing the integer n, the integer q, the array, and the queries. :return: List of lists containing the results for each query of each test case. pass # Example usage: # t = 1 # test_cases = [ # (5, 3, [5, -3, 2, -1, 4], [(1, 3), (2, 5), (1, 5)]) # ] # print(process_test_cases(t, test_cases)) # Output: [[5, 5, 7]]","solution":"def max_subarray_sum_in_range(arr, queries): Given an array and a list of queries, each asking for the maximum sum of any subarray that includes at least one element from a specified range [l, r], this function returns the answers for each query. :param arr: List of integers representing the array. :param queries: List of tuples where each tuple contains two integers representing the range [l, r]. :return: List of integers representing the maximum sum of subarrays for each query. def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far results = [] for l, r in queries: max_sum = float('-inf') for i in range(l-1, r): for j in range(i, r): current_sum = sum(arr[i:j+1]) max_sum = max(max_sum, current_sum) results.append(max_sum) return results def process_test_cases(t, test_cases): Processes multiple test cases of the max_subarray_sum_in_range function. :param t: Integer representing the number of test cases. :param test_cases: List of tuples, each containing the integer n, the integer q, the array, and the queries. :return: List of lists containing the results for each query of each test case. results = [] for testcase in test_cases: n, q, arr, queries = testcase results.append(max_subarray_sum_in_range(arr, queries)) return results # Example usage: # t = 1 # test_cases = [ # (5, 3, [5, -3, 2, -1, 4], [(1, 3), (2, 5), (1, 5)]) # ] # print(process_test_cases(t, test_cases)) # Output: [[5, 5, 7]]"},{"question":"def rearrange_binary_string(s: str) -> str: Function to determine if a binary string can be rearranged with no two consecutive characters being the same and if possible returns the lexicographically smallest rearranged string. >>> rearrange_binary_string(\\"1100\\") \\"0101\\" >>> rearrange_binary_string(\\"111000\\") \\"010101\\" >>> rearrange_binary_string(\\"1111\\") \\"NO\\"","solution":"def rearrange_binary_string(s): Function to determine if a binary string can be rearranged with no two consecutive characters being the same and if possible returns the lexicographically smallest rearranged string. # Count the number of 0s and 1s in the input string count0 = s.count('0') count1 = s.count('1') # If the number of one of the characters exceeds the other by more than 1, it's impossible if abs(count0 - count1) > 1: return \\"NO\\" # To form lexicographically smallest string, decide whether to start with '0' or '1' if count0 >= count1: result = ['0', '1'] * count1 + ['0'] * (count0 - count1) else: result = ['1', '0'] * count0 + ['1'] * (count1 - count0) return ''.join(result)"},{"question":"def min_trips(n: int, k: int, destinations: List[int]) -> int: Returns the minimum number of trips required to deliver all the packages. :param n: int - the number of packages :param k: int - the maximum number of packages a van can carry in one trip :param destinations: List[int] - the list of destinations for the packages :return: int - the minimum number of trips required >>> min_trips(10, 3, [2, 3, 2, 1, 3, 3, 2, 1, 1, 2]) 4 >>> min_trips(5, 2, [1, 1, 1, 1, 1]) 3 from solution import min_trips def test_min_trips_example1(): assert min_trips(10, 3, [2, 3, 2, 1, 3, 3, 2, 1, 1, 2]) == 4 def test_min_trips_example2(): assert min_trips(5, 2, [1, 1, 1, 1, 1]) == 3 def test_min_trips_all_unique_destinations(): assert min_trips(4, 3, [1, 2, 3, 4]) == 4 def test_min_trips_single_trip(): assert min_trips(2, 2, [1, 1]) == 1 def test_min_trips_each_destination_one_trip(): assert min_trips(6, 2, [1, 2, 1, 2, 3, 3]) == 3 def test_min_trips_large_all_same_destinations(): assert min_trips(10, 3, [1]*10) == 4","solution":"from collections import Counter def min_trips(n, k, destinations): Returns the minimum number of trips required to deliver all the packages. :param n: int - the number of packages :param k: int - the maximum number of packages a van can carry in one trip :param destinations: List[int] - the list of destinations for the packages :return: int - the minimum number of trips required trip_count = 0 # Count the frequency of each destination destination_count = Counter(destinations) # Calculate the trips needed for each destination for count in destination_count.values(): trips_needed = (count + k - 1) // k # This is equivalent to math.ceil(count / k) trip_count += trips_needed return trip_count"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Compute the maximum value that can be carried in a backpack with weight capacity W. :param n: Number of items :param W: Maximum weight capacity of the backpack :param items: List of tuples where each tuple contains (weight, value) of an item :return: Maximum total value of items that can be carried pass # Unit tests def test_knapsack_example_1(): n = 4 W = 10 items = [(5, 10), (4, 40), (6, 30), (4, 50)] assert knapsack(n, W, items) == 90 def test_knapsack_example_2(): n = 3 W = 50 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 220 def test_knapsack_small_capacity(): n = 3 W = 5 items = [(2, 3), (2, 4), (3, 5)] assert knapsack(n, W, items) == 9 def test_knapsack_zero_capacity(): n = 4 W = 0 items = [(1, 10), (2, 5), (3, 8), (4, 1)] assert knapsack(n, W, items) == 0 def test_knapsack_single_item_fit(): n = 1 W = 5 items = [(5, 10)] assert knapsack(n, W, items) == 10 def test_knapsack_single_item_not_fit(): n = 1 W = 3 items = [(5, 10)] assert knapsack(n, W, items) == 0","solution":"def knapsack(n, W, items): Compute the maximum value that can be carried in a backpack with weight capacity W. :param n: Number of items :param W: Maximum weight capacity of the backpack :param items: List of tuples where each tuple contains (weight, value) of an item :return: Maximum total value of items that can be carried # Create a DP array to store maximum value for each weight from 0 to W dp = [0] * (W + 1) for weight, value in items: # Traverse the weights from W to weight - 1 to avoid recomputation for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[W] # Example usage: # n = 4 # W = 10 # items = [(5, 10), (4, 40), (6, 30), (4, 50)] # print(knapsack(n, W, items)) # Output: 90"},{"question":"def rearrange_string(S: str) -> str: Determines if it is possible to reorder characters in S such that no two adjacent characters are the same. If possible, return \\"Yes\\" followed by a valid reordering. Otherwise, return \\"No\\". >>> rearrange_string(\\"aabb\\") \\"Yesnabab\\" # or \\"Yesnbaba\\" >>> rearrange_string(\\"aaab\\") \\"No\\" >>> rearrange_string(\\"aaaabbcc\\") \\"Yesnabacacab\\" # This is one possible valid output >>> rearrange_string(\\"a\\") \\"Yesna\\" >>> rearrange_string(\\"aa\\") \\"No\\" >>> rearrange_string(\\"ab\\") \\"Yesnab\\" # or \\"Yesnba\\" >>> rearrange_string(\\"abcabc\\") \\"Yesnabcabc\\" # This is one possible valid output >>> rearrange_string(\\"aab\\") \\"Yesnaba\\"","solution":"from heapq import heapify, heappop, heappush from collections import Counter def rearrange_string(S): Determines if it is possible to reorder characters in S such that no two adjacent characters are the same. If possible, return \\"Yes\\" followed by a valid reordering. Otherwise, return \\"No\\". count = Counter(S) max_heap = [(-freq, char) for char, freq in count.items()] heapify(max_heap) if -max_heap[0][0] > (len(S) + 1) // 2: return \\"No\\" result = [] prev_freq, prev_char = 0, '' while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char return \\"Yesn\\" + ''.join(result)"},{"question":"def min_final_value(n: int, sequence: List[int]) -> int: Determine the minimum possible value of the last remaining element after repeatedly combining any two consecutive elements in the sequence. >>> min_final_value(4, [1, 2, 3, 4]) == 10 >>> min_final_value(3, [5, 2, 1]) == 8 >>> min_final_value(5, [4, 4, 4, 4, 4]) == 20 >>> min_final_value(1, [100]) == 100 >>> min_final_value(3, [1, 1, 1]) == 3 >>> min_final_value(3, [1000, 500, 200]) == 1700","solution":"def min_final_value(n, sequence): Function to determine the minimum possible value of the last remaining element after repeatedly combining any two consecutive elements in the sequence. return sum(sequence)"},{"question":"def minimum_cost_to_buy_blocks(n: int, values: List[int]) -> int: Calculate the minimum cost required to buy all blocks under the special discount offer. >>> minimum_cost_to_buy_blocks(5, [10, 20, 30, 40, 50]) 135 >>> minimum_cost_to_buy_blocks(4, [100, 200, 300, 400]) 900 >>> minimum_cost_to_buy_blocks(1, [100]) 90 >>> minimum_cost_to_buy_blocks(3, [100, 100, 100]) 270 >>> minimum_cost_to_buy_blocks(1, [1]) 0 >>> minimum_cost_to_buy_blocks(100, [1000] * 100) 90000","solution":"def minimum_cost_to_buy_blocks(n, values): Calculate the minimum cost to buy all blocks with the special discount offer. total_sum = sum(values) discounted_sum = total_sum * 0.9 return int(discounted_sum) # Test the function with provided examples print(minimum_cost_to_buy_blocks(5, [10, 20, 30, 40, 50])) # Expected Output: 135 print(minimum_cost_to_buy_blocks(4, [100, 200, 300, 400])) # Expected Output: 900"},{"question":"def calculate_prefix_sums(inputs: List[List[int]]) -> List[str]: Calculate the prefix sums of multiple lists of integers. Each input list is a test case with integers for which we need to calculate the prefix sums. :param inputs: List of lists, each a list of integers. :return: List of strings where each string is the prefix sums of the respective list in inputs. >>> calculate_prefix_sums([[1, 2, 3, 4, 5]]) # Returns [\\"1 3 6 10 15\\"] >>> calculate_prefix_sums([[5, 4, 3, 2, 1]]) # Returns [\\"5 9 12 14 15\\"] >>> calculate_prefix_sums([[10, 20, 30]]) # Returns [\\"10 30 60\\"] >>> calculate_prefix_sums([[2, 4, 6, 8]]) # Returns [\\"2 6 12 20\\"] >>> calculate_prefix_sums([[3]]) # Returns [\\"3\\"]","solution":"def calculate_prefix_sums(inputs): Calculate the prefix sums for each list in inputs. :param inputs: List of lists, each a list of integers. :return: List of strings where each string is the prefix sums of the respective list in inputs. result = [] for lst in inputs: prefix_sums = [] current_sum = 0 for num in lst: current_sum += num prefix_sums.append(current_sum) result.append(\\" \\".join(map(str, prefix_sums))) return result"},{"question":"def find_permutation_indices(s: str, p: str) -> List[int]: Finds all starting indices of p's permutations in s. >>> find_permutation_indices(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_permutation_indices(\\"abcdefg\\", \\"hij\\") [] >>> find_permutation_indices(\\"a\\", \\"a\\") [0] >>> find_permutation_indices(\\"ababab\\", \\"ab\\") [0, 1, 2, 3, 4] >>> find_permutation_indices(\\"abcdef\\", \\"fed\\") [3] >>> find_permutation_indices(\\"aaaaaa\\", \\"aaa\\") [0, 1, 2, 3] >>> find_permutation_indices(\\"a\\" * 10000, \\"a\\" * 1000) list(range(9001))","solution":"def find_permutation_indices(s, p): Finds all starting indices of p's permutations in s. from collections import Counter len_s, len_p = len(s), len(p) if len_p > len_s: return [] result = [] p_counter = Counter(p) s_counter = Counter(s[:len_p - 1]) # Initialize the counter for the first window in s for i in range(len_p - 1, len_s): s_counter[s[i]] += 1 # include a new character in the window # Check if current window matches with the permutation of p if s_counter == p_counter: result.append(i - len_p + 1) # remove the leftmost character of the window left_char = s[i - len_p + 1] s_counter[left_char] -= 1 if s_counter[left_char] == 0: del s_counter[left_char] return result"},{"question":"from typing import List, Tuple, Dict def min_travel_time_with_stopover(T: int, test_cases: List[Dict[str, any]]) -> List[int]: Determines the minimum travel time required to get from a starting city to a destination city with at most one stopover. Parameters: T (int): Number of test cases. test_cases (List[Dict[str, any]]): List of dictionaries, where each dictionary contains the information for one test case Returns: List[int]: List of minimum travel times for each test case, or -1 if no possible route exists. Example: >>> T = 2 >>> test_cases = [ { 'N': 4, 'M': 3, 'roads': [(1, 2, 10), (2, 3, 10), (3, 4, 10)], 'S': 1, 'D': 4 }, { 'N': 3, 'M': 3, 'roads': [(1, 2, 5), (2, 3, 15), (1, 3, 30)], 'S': 1, 'D': 3 } ] >>> min_travel_time_with_stopover(T, test_cases) [30, 20]","solution":"import heapq def min_travel_time_with_stopover(T, test_cases): def dijkstra(graph, start, n): Performs Dijkstra's algorithm and returns the shortest distances from the start city to all other cities. distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances results = [] for case in test_cases: n, m, roads, s, d = case['N'], case['M'], case['roads'], case['S'], case['D'] graph = {i: [] for i in range(1, n + 1)} for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) if s == d: results.append(0) continue distances_from_start = dijkstra(graph, s, n) distances_from_dest = dijkstra(graph, d, n) min_time = distances_from_start[d] for u, v, t in roads: through_uv = distances_from_start[u] + t + distances_from_dest[v] through_vu = distances_from_start[v] + t + distances_from_dest[u] min_time = min(min_time, through_uv, through_vu) results.append(min_time if min_time != float('inf') else -1) return results"},{"question":"def tournament_matches(n: int) -> int: Calculate the total number of matches needed to determine the winner. :param n: int, number of participants (1 ≤ n ≤ 10^6) :return: int, number of matches >>> tournament_matches(8) 7 >>> tournament_matches(13) 12 >>> tournament_matches(1) 0 from solution import tournament_matches def test_tournament_matches_even_participants(): assert tournament_matches(8) == 7 def test_tournament_matches_odd_participants(): assert tournament_matches(13) == 12 def test_tournament_matches_single_participant(): assert tournament_matches(1) == 0 def test_tournament_matches_large_number_of_participants(): assert tournament_matches(10**6) == 999999 def test_tournament_matches_small_number_of_participants(): assert tournament_matches(2) == 1 assert tournament_matches(3) == 2","solution":"def tournament_matches(n): Calculate the total number of matches needed to determine the winner. :param n: int, number of participants :return: int, number of matches matches = 0 while n > 1: matches += n // 2 n = (n // 2) + (n % 2) return matches"},{"question":"def is_possible_subset(n: int, m: int, k: int, arr: List[int]) -> str: Determines if there exists a subset of the given list 'arr' such that the difference between the maximum and minimum value in this subset is exactly 'k'. >>> is_possible_subset(10, 5, 4, [1, 2, 3, 4, 5]) == \\"YES\\" >>> is_possible_subset(10, 5, 6, [1, 2, 3, 4, 5]) == \\"NO\\" >>> is_possible_subset(1, 1, 1, [1]) == \\"NO\\" >>> is_possible_subset(100, 10, 3, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == \\"NO\\" >>> is_possible_subset(100, 6, 20, [10, 30, 50, 70, 90, 100]) == \\"YES\\" >>> is_possible_subset(1000, 1000, 999, list(range(1, 1001))) == \\"YES\\" >>> is_possible_subset(10, 5, 15, [5, 6, 7, 8, 9]) == \\"NO\\" >>> is_possible_subset(10, 6, 8, [1, 2, 3, 4, 20, 28]) == \\"YES\\"","solution":"def is_possible_subset(n, m, k, arr): Determines if there exists a subset of the given list 'arr' such that the difference between the maximum and minimum value in this subset is exactly 'k'. arr_set = set(arr) for num in arr: if (num + k) in arr_set: return \\"YES\\" return \\"NO\\""},{"question":"def distribute_marks(total_marks: int, num_students: int) -> List[int]: Distribute the marks among students such that: 1. The sum of the marks received by all students is exactly the total marks in the exam. 2. Each student receives a unique amount of marks. 3. The smallest possible mark a student can receive is 1, and the largest possible mark is the total number of students in the classroom. >>> distribute_marks(21, 6) [1, 2, 3, 4, 5, 6] >>> distribute_marks(24, 6) [1, 2, 3, 4, 5, 9]","solution":"def distribute_marks(total_marks, num_students): Returns a list of marks for each student such that they are all unique, the sum is total_marks, and marks range from 1 to num_students. marks = list(range(1, num_students + 1)) current_sum = sum(marks) diff = total_marks - current_sum for i in range(num_students-1, -1, -1): if diff <= 0: break additional_marks = min(diff, total_marks - marks[i] - current_sum + marks[i]) marks[i] += additional_marks diff -= additional_marks return marks"},{"question":"def is_passcode_valid(passcode): Determines if the given passcode is compliant with the security policy. A compliant passcode does not contain the sequence \\"123\\" or \\"321\\". Parameters: passcode (str): The passcode to check. Returns: str: \\"Valid Passcode\\" if compliant, otherwise \\"Invalid Passcode\\". pass def check_passcodes(passcodes): Takes a list of passcodes and returns a list of results. Each result is either \\"Valid Passcode\\" or \\"Invalid Passcode\\" based on whether the corresponding passcode complies with the security policy. Parameters: passcodes (list): List of passcodes to check. Returns: list: List of strings with each string being \\"Valid Passcode\\" or \\"Invalid Passcode\\". pass # Example usage: # passcodes = [\\"secure123code\\", \\"pass321word\\", \\"mysecurepasscode\\", \\"codesecure\\", \\"END\\"] # result = check_passcodes(passcodes) # print(result) # Test cases def test_is_passcode_valid(): assert is_passcode_valid(\\"secure123code\\") == \\"Invalid Passcode\\" assert is_passcode_valid(\\"pass321word\\") == \\"Invalid Passcode\\" assert is_passcode_valid(\\"mysecurepasscode\\") == \\"Valid Passcode\\" assert is_passcode_valid(\\"codesecure\\") == \\"Valid Passcode\\" def test_check_passcodes(): passcodes = [\\"secure123code\\", \\"pass321word\\", \\"mysecurepasscode\\", \\"codesecure\\", \\"END\\"] results = [\\"Invalid Passcode\\", \\"Invalid Passcode\\", \\"Valid Passcode\\", \\"Valid Passcode\\"] assert check_passcodes(passcodes) == results","solution":"def is_passcode_valid(passcode): Determines if the given passcode is compliant with the security policy. A compliant passcode does not contain the sequence \\"123\\" or \\"321\\". Parameters: passcode (str): The passcode to check. Returns: str: \\"Valid Passcode\\" if compliant, otherwise \\"Invalid Passcode\\". if \\"123\\" in passcode or \\"321\\" in passcode: return \\"Invalid Passcode\\" return \\"Valid Passcode\\" def check_passcodes(passcodes): Takes a list of passcodes and returns a list of results. Each result is either \\"Valid Passcode\\" or \\"Invalid Passcode\\" based on whether the corresponding passcode complies with the security policy. Parameters: passcodes (list): List of passcodes to check. Returns: list: List of strings with each string being \\"Valid Passcode\\" or \\"Invalid Passcode\\". results = [] for passcode in passcodes: if passcode == \\"END\\": break results.append(is_passcode_valid(passcode)) return results"},{"question":"def find_two_sum(nums, target): Determines if there are two elements in \`nums\` that sum up to \`target\`. If such elements exist, print \\"Yes\\" followed by their 1-based indices. If not, print \\"No\\". >>> find_two_sum([2, 7, 11, 15, 3], 9) Yes 1 2 >>> find_two_sum([1, 2, 3, 4], 6) Yes 2 4 >>> find_two_sum([1, 2, 3], 10) No","solution":"def find_two_sum(nums, target): Determines if there are two elements in \`nums\` that sum up to \`target\`. If such elements exist, print \\"Yes\\" followed by their 1-based indices. If not, print \\"No\\". lookup = {} for idx, num in enumerate(nums): complement = target - num if complement in lookup: # Printing \\"Yes\\" and the 1-based indices print(\\"Yes\\") print(lookup[complement] + 1, idx + 1) return lookup[num] = idx print(\\"No\\")"},{"question":"def minimum_cameras(n: int, m: int) -> int: Determine the minimum number of cameras required to cover every cell of the city grid. Each camera installed in a building can monitor all the cells in its row and column. Arguments: n -- the number of rows in the grid m -- the number of columns in the grid Returns: int -- the minimum number of cameras required to cover the entire grid Examples: >>> minimum_cameras(3, 4) 4 >>> minimum_cameras(1, 1) 1 >>> minimum_cameras(5, 6) 6","solution":"def minimum_cameras(n, m): Returns the minimum number of cameras required to cover the entire n x m grid. Each camera can monitor all the cells in its row and column. # The minimum number of cameras required is the larger number between rows and columns return max(n, m)"},{"question":"from typing import List def min_moves_to_reach_end(m: int, n: int, grid: List[str]) -> int: Determine the minimum number of moves required for the robot to reach the bottom-right corner of the garden, or return -1 if it is not possible. >>> min_moves_to_reach_end(5, 5, [\\".....\\", \\".#.\\", \\"....#\\", \\".#...\\", \\".....\\"]) 8 >>> min_moves_to_reach_end(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) -1 >>> min_moves_to_reach_end(4, 6, [\\"......\\", \\"......\\", \\"......\\", \\"......\\"]) 8 >>> min_moves_to_reach_end(1, 4, [\\"....\\"]) 3 >>> min_moves_to_reach_end(4, 1, [\\".\\", \\".\\", \\".\\", \\".\\"]) 3","solution":"from collections import deque def min_moves_to_reach_end(m, n, grid): def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == '.' and not visited[x][y] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up queue = deque([(0, 0, 0)]) # (row, col, distance) visited = [[False] * n for _ in range(m)] visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: # Reached the bottom-right corner return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1 # If we exhaust the queue without reaching the end # Inputs for testing # Format: (m, n, grid) inputs = [ (5, 5, [\\".....\\", \\".#.\\", \\"....#\\", \\".#...\\", \\".....\\"]), (3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]), ] # Outputs for testing # Corresponding expected outputs for inputs expected_outputs = [ 8, -1 ]"},{"question":"def find_balanced_index(arr): Returns the Balanced Index where the sum of the elements to the left is equal to the sum of the elements to the right. If no such index exists, returns -1. >>> find_balanced_index([1, 7, 3, 6, 5, 6]) 3 >>> find_balanced_index([1, 2, 3]) -1 >>> find_balanced_index([100]) 0 >>> find_balanced_index([0, 0, 0, 0, 0]) 0 >>> find_balanced_index([1, 2, 1, 2, 1, 2, 1]) 3 >>> find_balanced_index([0, 1, -1, 1, -1]) 0 >>> find_balanced_index([1, -1, 1, -1, 0]) 4","solution":"def find_balanced_index(arr): Returns the Balanced Index where the sum of the elements to the left is equal to the sum of the elements to the right. If no such index exists, returns -1. total_sum = sum(arr) left_sum = 0 for i in range(len(arr)): # right_sum is total_sum minus left_sum minus the current element right_sum = total_sum - left_sum - arr[i] if left_sum == right_sum: return i left_sum += arr[i] return -1"},{"question":"def find_unsorted_subarray(arr): Find the smallest subarray that needs to be sorted so that the whole array becomes sorted. Args: arr (List[int]): The array of integers. Returns: Tuple[int, int]: The 1-based starting and ending indices of the smallest subarray which needs to be sorted. If the array is already sorted, return (0, 0). >>> find_unsorted_subarray([1, 2, 3, 4, 5]) (0, 0) >>> find_unsorted_subarray([1, 2, 4, 5, 3, 5, 6, 7]) (3, 5) >>> find_unsorted_subarray([1, 2, 3, 7, 5, 6]) (4, 6) >>> find_unsorted_subarray([4, 2, 3, 5, 6]) (1, 3) >>> find_unsorted_subarray([3, 2, 1]) (1, 3) >>> find_unsorted_subarray([1]) (0, 0) >>> find_unsorted_subarray([1, 2]) (0, 0) >>> find_unsorted_subarray([2, 1]) (1, 2)","solution":"def find_unsorted_subarray(arr): n = len(arr) start, end = -1, -1 for i in range(n-1): if arr[i] > arr[i + 1]: start = i break if start == -1: return (0, 0) for i in range(n-1, 0, -1): if arr[i] < arr[i - 1]: end = i break min_val = min(arr[start:end+1]) max_val = max(arr[start:end+1]) for i in range(start): if arr[i] > min_val: start = i break for i in range(n-1, end, -1): if arr[i] < max_val: end = i break return (start + 1, end + 1)"},{"question":"def min_operations_to_defeat_enemies(n: int, levels: List[int]) -> int: Determine the minimum number of operations required to defeat all the enemies using the least number of operations. Args: n: int: The number of enemies. levels: List[int]: A list of integers representing the levels of the enemies. Returns: int: The minimum number of operations required to defeat all the enemies. >>> min_operations_to_defeat_enemies(5, [2, 2, 2, 3, 3]) 2 >>> min_operations_to_defeat_enemies(6, [4, 1, 1, 1, 4, 4]) 3 >>> min_operations_to_defeat_enemies(4, [5, 5, 5, 5]) 1","solution":"def min_operations_to_defeat_enemies(n, levels): This function returns the minimum number of operations required to defeat all the enemies. if n == 0: return 0 operations = 1 for i in range(1, n): if levels[i] != levels[i - 1]: operations += 1 return operations"},{"question":"def max_sum_subarray(prices: List[int], K: int) -> int: Returns the maximum sum of prices found in any subarray of length K. >>> max_sum_subarray([1, 3, 5, 2, 8], 3) 15 >>> max_sum_subarray([4, 2, 1, 6, 2, 4], 2) 8 >>> max_sum_subarray([7, 7, 2, 7], 1) 7 >>> max_sum_subarray([1, 2, 3, 4], 4) 10 >>> max_sum_subarray([1000, 1000, 1000, 1000], 2) 2000 >>> max_sum_subarray([5], 1) 5 >>> max_sum_subarray([2, 3, 5, 1, 6, 4], 6) 21 >>> max_sum_subarray([2, 1, 2, 1, 2], 1) 2","solution":"def max_sum_subarray(prices, K): Returns the maximum sum of prices found in any subarray of length K. n = len(prices) if K > n: return 0 max_sum = -float('inf') current_sum = 0 for i in range(K): current_sum += prices[i] max_sum = max(max_sum, current_sum) for i in range(K, n): current_sum = current_sum + prices[i] - prices[i - K] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def stone_merging(s: str) -> str: Determine the final arrangement of stones after all possible merges have been performed. >>> stone_merging(\\"AABBBCCDAA\\") \\"ABCDA\\" >>> stone_merging(\\"RRRRGGGBB\\") \\"RGB\\" >>> stone_merging(\\"XYZ\\") \\"XYZ\\"","solution":"def stone_merging(s: str) -> str: if not s: return s result = [s[0]] for i in range(1, len(s)): if s[i] != s[i - 1]: result.append(s[i]) return ''.join(result)"},{"question":"def can_divide_tasks_equally(n: int, tasks: List[int]) -> str: Determines if it's possible to divide tasks into two shifts with equal total time. >>> can_divide_tasks_equally(4, [30, 40, 20, 10]) \\"YES\\" >>> can_divide_tasks_equally(5, [10, 20, 30, 40, 30]) \\"NO\\"","solution":"def can_divide_tasks_equally(n, tasks): Determines if it's possible to divide tasks into two shifts with equal total time. Args: n (int): The number of tasks. tasks (list of int): The time in minutes for each task. Returns: str: \\"YES\\" if it's possible to divide the tasks equally, otherwise \\"NO\\". total_time = sum(tasks) # If total time is odd, we can't split it into two equal parts if total_time % 2 != 0: return \\"NO\\" # We need to see if we can form a subset with sum equal to total_time / 2 target = total_time // 2 # Initialize the dp array, where dp[i] will be True if sum i can be formed by any subset of tasks dp = [False] * (target + 1) dp[0] = True # Process each task for task in tasks: for i in range(target, task - 1, -1): dp[i] = dp[i] or dp[i - task] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def minimal_additional_commands(n: int, commands: str) -> int: Calculate the minimal additional commands required for the robot to return to its starting point. Args: n (int): Number of initial commands. commands (str): String of commands which are 'U', 'D', 'L', 'R' Returns: int: Minimal number of additional commands required. >>> minimal_additional_commands(4, \\"UDUD\\") 0 >>> minimal_additional_commands(6, \\"UDLRUU\\") 2","solution":"def minimal_additional_commands(n, commands): Calculate the minimal additional commands required for the robot to return to its starting point. Args: n (int): Number of initial commands. commands (str): String of commands which are 'U', 'D', 'L', 'R' Returns: int: Minimal number of additional commands required. vertical = 0 # net vertical distance horizontal = 0 # net horizontal distance for command in commands: if command == 'U': vertical += 1 elif command == 'D': vertical -= 1 elif command == 'L': horizontal -= 1 elif command == 'R': horizontal += 1 return abs(vertical) + abs(horizontal)"},{"question":"def subset_sum_divisible(N: int, K: int, arr: List[int]) -> str: Determines if there exists a subset of arr such that the sum of the subset is divisible by K. :param N: The number of integers in the list :param K: The integer divisor :param arr: The list of integers :return: \\"YES\\" if such a subset exists, otherwise \\"NO\\" >>> subset_sum_divisible(4, 3, [1, 2, 3, 4]) \\"YES\\" >>> subset_sum_divisible(5, 5, [1, -1, 2, -3, 4]) \\"YES\\" >>> subset_sum_divisible(3, 7, [1, 2, 3]) \\"NO\\" >>> subset_sum_divisible(1, 5, [5]) \\"YES\\" >>> subset_sum_divisible(1, 5, [1]) \\"NO\\" >>> subset_sum_divisible(4, 1000, [100, 200, 300, 400]) \\"YES\\"","solution":"def subset_sum_divisible(N, K, arr): Determines if there exists a subset of arr such that the sum of the subset is divisible by K. :param N: The number of integers in the list :param K: The integer divisor :param arr: The list of integers :return: \\"YES\\" if such a subset exists, otherwise \\"NO\\" # Dynamic programming approach with a set to store possible remainders reachable = {0} for num in arr: new_reachable = set(reachable) # Copy existing reachable remainders for remainder in reachable: new_remainder = (remainder + num) % K if new_remainder == 0: return \\"YES\\" new_reachable.add(new_remainder) reachable = new_reachable return \\"NO\\""},{"question":"def is_balanced_sequence(n: int, sequence: List[int]) -> str: Determines if a given sequence is a balanced sequence. Args: n : int : the number of elements in the sequence sequence : list of int : the elements of the sequence Returns: str : \\"YES\\" if the sequence is a balanced sequence, otherwise \\"NO\\" >>> is_balanced_sequence(8, [1, 1, 2, 2, 1, 1, 2, 2]) 'YES' >>> is_balanced_sequence(5, [1, 2, 3, 4, 5]) 'NO'","solution":"def is_balanced_sequence(n, sequence): Determines if a given sequence is a balanced sequence. Args: n : int : the number of elements in the sequence sequence : list of int : the elements of the sequence Returns: str : \\"YES\\" if the sequence is a balanced sequence, otherwise \\"NO\\" if n == 1: return \\"YES\\" freq_map = {} group_size = 0 current_freq_map = {} for num in sequence: if num not in current_freq_map: current_freq_map[num] = 0 current_freq_map[num] += 1 if num not in freq_map: freq_map[num] = 0 freq_map[num] += 1 if group_size == 0: group_size = current_freq_map[num] for val in current_freq_map.values(): if val != group_size: return \\"NO\\" if sum(current_freq_map.values()) == group_size * len(current_freq_map): group_size = 0 current_freq_map = {} for val in freq_map.values(): if val % len(freq_map) != 0: return \\"NO\\" return \\"YES\\""},{"question":"def pascals_triangle_sum(n: int) -> int: This function takes an integer n and returns the sum of all the elements in Pascal's Triangle up to and including the n-th row. >>> pascals_triangle_sum(0) 1 >>> pascals_triangle_sum(1) 3 >>> pascals_triangle_sum(2) 7 >>> pascals_triangle_sum(3) 15 >>> pascals_triangle_sum(4) 31","solution":"def pascals_triangle_sum(n): This function takes an integer n and returns the sum of all the elements in Pascal's Triangle up to and including the n-th row. if n == 0: return 1 sum_total = 0 for i in range(n + 1): row_sum = 2 ** i sum_total += row_sum return sum_total"},{"question":"def max_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: Returns the maximum number of concurrent sessions given a list of session intervals. >>> max_overlapping_sessions([(1, 5), (2, 6), (4, 8), (3, 7)]) # Output: 3 >>> max_overlapping_sessions([(1, 2), (2, 3), (3, 4)]) # Output: 1","solution":"def max_overlapping_sessions(sessions): Returns the maximum number of concurrent sessions given a list of session intervals. events = [] for start, end in sessions: events.append((start, 'start')) events.append((end, 'end')) # Sort events first by time, then by type (end before start when the times are the same) events.sort(key=lambda x: (x[0], x[1] == 'start')) max_overlap = 0 current_overlap = 0 for time, type in events: if type == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"from typing import List def can_tend_garden(n: int, m: int, garden: List[str]) -> str: Determine if it's possible to tend the garden without breaking the planting rule. Parameters ---------- n : int Number of rows in the garden. m : int Number of columns in the garden. garden : List[str] A list of strings representing the garden. Returns ------- str \\"Possible\\" if the garden can be tended according to the rule, otherwise \\"Impossible\\". pass def test_possible_case_1(): n = 2 m = 2 garden = [ \\"D-\\", \\"-L\\" ] assert can_tend_garden(n, m, garden) == \\"Possible\\" def test_impossible_case_1(): n = 3 m = 3 garden = [ \\"D-L\\", \\"---\\", \\"---\\" ] assert can_tend_garden(n, m, garden) == \\"Impossible\\" def test_possible_case_2(): n = 4 m = 4 garden = [ \\"D---\\", \\"-D--\\", \\"--D-\\", \\"---D\\" ] assert can_tend_garden(n, m, garden) == \\"Possible\\" def test_impossible_case_2(): n = 2 m = 3 garden = [ \\"DDL\\", \\"LL-\\" ] assert can_tend_garden(n, m, garden) == \\"Impossible\\" def test_possible_case_3(): n = 1 m = 5 garden = [ \\"D-L-D\\" ] assert can_tend_garden(n, m, garden) == \\"Impossible\\" def test_empty_garden(): n = 2 m = 2 garden = [ \\"--\\", \\"--\\" ] assert can_tend_garden(n, m, garden) == \\"Possible\\" def test_single_element(): n = 1 m = 1 garden = [\\"-\\"] assert can_tend_garden(n, m, garden) == \\"Possible\\"","solution":"def can_tend_garden(n, m, garden): rows = [[] for _ in range(n)] cols = [[] for _ in range(m)] for i in range(n): for j in range(m): if garden[i][j] == 'D': rows[i].append('D') cols[j].append('D') elif garden[i][j] == 'L': rows[i].append('L') cols[j].append('L') for row in rows: if 'D' in row and 'L' in row: return \\"Impossible\\" for col in cols: if 'D' in col and 'L' in col: return \\"Impossible\\" return \\"Possible\\""},{"question":"def daily_temperatures(n: int, temperatures: List[int]) -> List[int]: Given a list of daily temperatures, returns a list where the value at each index indicates the number of days one would have to wait for a warmer temperature. Args: n (int): Number of days. temperatures (List[int]): List of daily temperatures. Returns: List[int]: List where the value at each index is the number of days until a warmer temperature or 0 if none exists. Examples: >>> daily_temperatures(8, [73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures(4, [30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures(4, [30, 20, 10, 5]) [0, 0, 0, 0]","solution":"def daily_temperatures(n, temperatures): Given a list of daily temperatures, returns a list where the value at each index indicates the number of days one would have to wait for a warmer temperature. result = [0] * n stack = [] for i, current_temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < current_temp: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. pass def smallest_prime_geq_n(n: int) -> int: Find the smallest prime number greater than or equal to n. pass def solve(T: int, cases: List[int]) -> List[int]: Solve the problem for T test cases. pass # Test cases def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False def test_smallest_prime_geq_n(): assert smallest_prime_geq_n(17) == 17 assert smallest_prime_geq_n(18) == 19 assert smallest_prime_geq_n(29) == 29 assert smallest_prime_geq_n(45) == 47 assert smallest_prime_geq_n(1) == 2 def test_solve(): assert solve(3, [17, 29, 45]) == [17, 29, 47] assert solve(2, [30, 31]) == [31, 31] assert solve(4, [1, 2, 3, 4]) == [2, 2, 3, 5]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def smallest_prime_geq_n(n): Find the smallest prime number greater than or equal to n. while not is_prime(n): n += 1 return n def solve(T, cases): Solve the problem for T test cases. results = [] for case in cases: n = case results.append(smallest_prime_geq_n(n)) return results"},{"question":"def smallest_multiple_of_7(N: int) -> int: Given a positive integer N, find the smallest integer greater than or equal to N that is a multiple of 7. >>> smallest_multiple_of_7(49) 49 >>> smallest_multiple_of_7(20) 21 >>> smallest_multiple_of_7(60) 63 >>> smallest_multiple_of_7(1) 7 >>> smallest_multiple_of_7(6) 7 >>> smallest_multiple_of_7(1000) 1001","solution":"def smallest_multiple_of_7(N): Given a positive integer N, finds the smallest integer greater than or equal to N that is a multiple of 7. if N % 7 == 0: return N else: return N + (7 - N % 7)"},{"question":"def addDigits(num: int) -> int: Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Args: num (int): A non-negative integer. Returns: int: The resulting single-digit integer. Examples: >>> addDigits(38) 2 >>> addDigits(123) 6 >>> addDigits(0) 0","solution":"def addDigits(num: int) -> int: Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def is_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Determine whether there is a path from the starting point to the ending point in a given maze. >>> maze = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> is_path(maze, start, end) True >>> maze = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 1], ... [1, 1, 1, 1, 1], ... [0, 0, 0, 0, 0] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> is_path(maze, start, end) False","solution":"def is_path(maze, start, end): m, n = len(maze), len(maze[0]) sx, sy = start ex, ey = end if maze[sx][sy] == 1 or maze[ex][ey] == 1: return False def is_valid(x, y): return 0 <= x < m and 0 <= y < n and maze[x][y] == 0 visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if not is_valid(x, y) or visited[x][y]: return False if (x, y) == (ex, ey): return True visited[x][y] = True # Explore all 4 directions return (dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1)) return dfs(sx, sy)"},{"question":"from typing import List def can_partition_k_subsets(arr: List[int], k: int) -> str: Given an array of integers \`arr\` and an integer \`k\`, determine if it's possible to partition the array into \`k\` non-empty subsets with equal sums. >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) \\"yes\\" >>> can_partition_k_subsets([1, 2, 3, 4], 3) \\"no\\" def test_can_partition_k_subsets(): assert can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) == \\"yes\\" assert can_partition_k_subsets([1, 2, 3, 4], 3) == \\"no\\" assert can_partition_k_subsets([1, 1, 1, 1], 2) == \\"yes\\" assert can_partition_k_subsets([1, 1], 2) == \\"yes\\" assert can_partition_k_subsets([2, 2, 2, 2, 3, 3, 3, 3], 4) == \\"yes\\" assert can_partition_k_subsets([-1, -1, -1, -1, -1, -1], 3) == \\"no\\" if __name__ == \\"__main__\\": test_can_partition_k_subsets() print(\\"All tests passed!\\")","solution":"def can_partition_k_subsets(arr, k): total_sum = sum(arr) if total_sum % k != 0: return \\"no\\" target = total_sum // k used = [False] * len(arr) def backtrack(k_rem, current_sum, start_index): if k_rem == 1: return True if current_sum == target: return backtrack(k_rem - 1, 0, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target: used[i] = True if backtrack(k_rem, current_sum + arr[i], i + 1): return True used[i] = False return False return \\"yes\\" if backtrack(k, 0, 0) else \\"no\\" # Example input arr = [4, 3, 2, 3, 5, 2, 1] k = 4 print(can_partition_k_subsets(arr, k)) arr = [1, 2, 3, 4] k = 3 print(can_partition_k_subsets(arr, k))"},{"question":"def is_balanced(s: str) -> str: Determines if the parentheses in the string are balanced. Args: s (str): Input string containing alphanumeric characters and parentheses. Returns: str: \\"Balanced\\" if the parentheses are balanced, otherwise \\"Unbalanced\\". pass # Your code goes here # Unit tests def test_balanced(): assert is_balanced(\\"(a+b*(c-d))\\") == \\"Balanced\\" def test_unbalanced_missing_closing(): assert is_balanced(\\"(a+b*(c-d)\\") == \\"Unbalanced\\" def test_unbalanced_extra_closing(): assert is_balanced(\\"abc(d)e)f\\") == \\"Unbalanced\\" def test_double_nested_balanced(): assert is_balanced(\\"(((())))\\") == \\"Balanced\\" def test_unbalanced_empty_parentheses(): assert is_balanced(\\")(\\") == \\"Unbalanced\\" def test_balanced_with_no_parentheses(): assert is_balanced(\\"abc123\\") == \\"Balanced\\" def test_empty_string(): assert is_balanced(\\"\\") == \\"Balanced\\"","solution":"def is_balanced(s): Determines if the parentheses in the string are balanced. Args: s (str): Input string containing alphanumeric characters and parentheses. Returns: str: \\"Balanced\\" if the parentheses are balanced, otherwise \\"Unbalanced\\". stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"Unbalanced\\" stack.pop() if not stack: return \\"Balanced\\" else: return \\"Unbalanced\\""},{"question":"def calculate_final_position(num_cases, cases): Calculate the final coordinates of the robot after executing all moves, considering the reversing rule. Arguments: num_cases -- the number of test cases cases -- a list of test cases, each test case is represented by a list of moves where the first element is the number of moves (n) followed by n pairs of direction as a string and number of steps as an integer. Returns: List of tuples -- final coordinates (x, y) for each test case Example: >>> num_cases, cases = parse_input(\\"1n3 N 2 E 3 S 1\\") >>> calculate_final_position(num_cases, cases) [(0, 0)] >>> num_cases, cases = parse_input(\\"1n4 NW 2 NE 4 SE 1 SW 3\\") >>> calculate_final_position(num_cases, cases) [(0, 0)] pass def parse_input(input_str): Convert input string to the required format for processing. Arguments: input_str -- input as a single string with test cases Returns: Tuple -- number of test cases and a list of cases Example: >>> parse_input(\\"1n3 N 2 E 3 S 1\\") (1, [[3, 'N', 2, 'E', 3, 'S', 1]]) pass from solution import calculate_final_position, parse_input def test_single_case(): input_str = \\"1n3 N 2 E 3 S 1\\" num_cases, cases = parse_input(input_str) assert calculate_final_position(num_cases, cases) == [(0, 0)] def test_multiple_cases(): input_str = \\"2n3 N 2 E 3 S 1n4 NW 2 NE 4 SE 1 SW 3\\" num_cases, cases = parse_input(input_str) assert calculate_final_position(num_cases, cases) == [(0, 0), (0, 0)] def test_one_direction(): input_str = \\"1n1 N 5\\" num_cases, cases = parse_input(input_str) assert calculate_final_position(num_cases, cases) == [(0, 0)] def test_diagonal_move(): input_str = \\"1n2 NE 1 SW 1\\" num_cases, cases = parse_input(input_str) assert calculate_final_position(num_cases, cases) == [(0, 0)] def test_no_move(): input_str = \\"1n0\\" num_cases, cases = parse_input(input_str) assert calculate_final_position(num_cases, cases) == [(0, 0)]","solution":"def calculate_final_position(num_cases, cases): directions = { 'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0), 'NE': (1, 1), 'NW': (-1, 1), 'SE': (1, -1), 'SW': (-1, -1) } results = [] for case in cases: moves = case[1:] x, y = 0, 0 for i in range(0, len(moves), 2): direction = moves[i] steps = moves[i + 1] dx, dy = directions[direction] x += dx * steps y += dy * steps # Reversing the same steps x -= dx * steps y -= dy * steps results.append((x, y)) return results # Helper function to convert input format def parse_input(input_str): lines = input_str.strip().split('n') num_cases = int(lines[0]) cases = [] for line in lines[1:]: parts = line.split() n = int(parts[0]) moves = [] for j in range(1, 2*n + 1, 2): moves.append(parts[j]) moves.append(int(parts[j + 1])) cases.append([n] + moves) return num_cases, cases"},{"question":"def is_valid_sequence(sequence: str) -> str: Checks if the given sequence is valid i.e., it does not contain any substring of three consecutive identical characters. >>> is_valid_sequence(\\"ABCCBA\\") == \\"valid\\" >>> is_valid_sequence(\\"AAABBBCCC\\") == \\"invalid\\" >>> is_valid_sequence(\\"ABCDE\\") == \\"valid\\" >>> is_valid_sequence(\\"AABBBCC\\") == \\"invalid\\" >>> is_valid_sequence(\\"XYZXYZXYZ\\") == \\"valid\\" >>> is_valid_sequence(\\"AAA\\") == \\"invalid\\" def process_test_cases(T: int, cases: List[str]) -> List[str]: Takes in the number of test cases T and the list of cases, returns a list of results whether each case is valid or invalid. >>> process_test_cases(2, [\\"ABCCBA\\", \\"AAABBBCCC\\"]) == [\\"valid\\", \\"invalid\\"] >>> process_test_cases(3, [\\"ABCDE\\", \\"AABBBCC\\", \\"XYZXYZXYZ\\"]) == [\\"valid\\", \\"invalid\\", \\"valid\\"]","solution":"def is_valid_sequence(sequence): Checks if the given sequence is valid i.e., it does not contain any substring of three consecutive identical characters. length = len(sequence) for i in range(length - 2): if sequence[i] == sequence[i+1] == sequence[i+2]: return \\"invalid\\" return \\"valid\\" def process_test_cases(T, cases): Takes in the number of test cases T and the list of cases, returns a list of results whether each case is valid or invalid. results = [] for case in cases: results.append(is_valid_sequence(case)) return results"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Returns the total number of continuous subarrays whose sum equals to k. Args: nums: List[int] - An array of integers k: int - The target sum Returns: int - The total number of continuous subarrays whose sum equals to k >>> subarray_sum([1, 1, 1, 1, 1], 2) 4 >>> subarray_sum([1, 2, 3, 4, 5, 6], 10) 1","solution":"def subarray_sum(nums, k): Returns the total number of continuous subarrays whose sum equals to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - k in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def max_problems_attemptable(n: int, m: int, participants: List[int], problems: List[int]) -> List[int]: Polycarp has written a new program to organize a coding competition. The competition consists of several coding problems, each with a certain level of difficulty. Participants can solve these problems to gain points. Polycarp wants to figure out if the problems are well balanced in terms of difficulty. Each problem has a specific difficulty rating, and each participant has a skill level. To balance the competition, Polycarp wants each participant to solve problems that match their skill level as closely as possible. A participant can attempt to solve a problem if their skill level is greater than or equal to the problem’s difficulty rating. However, to ensure that participants are sufficiently challenged, Polycarp wants to maximize the total number of problems they can attempt, without letting any participant solve all the problems. Can you help Polycarp determine how many problems each participant can attempt? Args: n (int): the number of participants. m (int): the number of problems. participants (List[int]): list of participants' skill levels. problems (List[int]): list of problems' difficulty ratings. Returns: List[int]: a list where each element at index i represents the maximum number of problems the i-th participant can attempt. >>> n = 3 >>> m = 4 >>> participants = [70, 50, 90] >>> problems = [30, 45, 60, 80] >>> max_problems_attemptable(n, m, participants, problems) [3, 2, 4] >>> n = 2 >>> m = 5 >>> participants = [25, 55] >>> problems = [10, 20, 30, 40, 50] >>> max_problems_attemptable(n, m, participants, problems) [2, 5] pass","solution":"def max_problems_attemptable(n, m, participants, problems): Returns a list of maximum number of problems each participant can attempt. result = [] problems.sort() for skill in participants: count = 0 for difficulty in problems: if skill >= difficulty: count += 1 result.append(count) return result # Example use case if __name__ == \\"__main__\\": n = 3 m = 4 participants = [70, 50, 90] problems = [30, 45, 60, 80] print(max_problems_attemptable(n, m, participants, problems)) # Expected: [3, 2, 4]"},{"question":"def count_set_bits(n: int) -> int: Count the number of set bits (1s) in the binary representation of an integer. >>> count_set_bits(3) 2 >>> count_set_bits(7) 3 def sort_by_set_bits(test_cases: List[List[int]]) -> List[List[int]]: Sort the numbers based on the number of set bits (1s) in their binary representation. If two numbers have the same number of set bits, the smaller number should appear first. >>> sort_by_set_bits([[3, 7, 8, 9]]) [[8, 3, 9, 7]] >>> sort_by_set_bits([[1, 2, 4, 8, 16]]) [[1, 2, 4, 8, 16]] def parse_input(input_string: str) -> List[List[int]]: Parse the input string and return a list of test cases where each test case is a list of integers. >>> parse_input(\\"2n3 7 8 9n1 2 4 8 16\\") [[8, 3, 9, 7], [1, 2, 4, 8, 16]]","solution":"def count_set_bits(n): return bin(n).count('1') def sort_by_set_bits(test_cases): sorted_cases = [] for case in test_cases: sorted_case = sorted(case, key=lambda x: (count_set_bits(x), x)) sorted_cases.append(sorted_case) return sorted_cases def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [list(map(int, line.split())) for line in lines[1:t+1]] return sort_by_set_bits(test_cases)"},{"question":"def count_primes_in_range(a: int, b: int) -> int: Returns the count of prime numbers in the range [a, b], inclusive. >>> count_primes_in_range(10, 30) 6 >>> count_primes_in_range(1, 10) 4 >>> count_primes_in_range(1000000, 1000000) 0 >>> count_primes_in_range(11, 29) 6 >>> count_primes_in_range(29, 30) 1 >>> count_primes_in_range(28, 29) 1 pass","solution":"import math def count_primes_in_range(a, b): Returns the count of prime numbers in the range [a, b], inclusive. def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True prime_count = 0 for number in range(a, b + 1): if is_prime(number): prime_count += 1 return prime_count"},{"question":"import heapq from typing import List, Tuple def shortest_path(N: int, M: int, routes: List[Tuple[int, int, int]], s: int, t: int) -> int: Determines the shortest path between city s and city t. Args: N: int, number of cities. M: int, number of direct routes. routes: list of tuples, each with three integers (u, v, w) indicating a direct route between u and v with distance w. s: int, the starting city. t: int, the target city. Returns: int: the shortest distance from city s to city t, or -1 if no such path exists. >>> shortest_path(4, 5, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (2, 4, 1), (3, 4, 5)], 1, 4) 5 >>> shortest_path(4, 4, [(1, 2, 4), (2, 3, 3), (3, 2, 5), (4, 4, 1)], 1, 4) -1 >>> shortest_path(3, 3, [(1, 2, 4), (2, 3, 3), (1, 3, 7)], 1, 1) 0 >>> shortest_path(2, 1, [(1, 2, 4)], 1, 2) 4 >>> shortest_path(3, 2, [(1, 2, 1), (2, 3, 1)], 1, 3) 2","solution":"import heapq def shortest_path(N, M, routes, s, t): Determines the shortest path between city s and city t. Args: N: int, number of cities. M: int, number of direct routes. routes: list of tuples, each with three integers (u, v, w) indicating a direct route between u and v with distance w. s: int, the starting city. t: int, the target city. Returns: int: the shortest distance from city s to city t, or -1 if no such path exists. # Build the adjacency list for the graph graph = [[] for _ in range(N + 1)] for u, v, w in routes: graph[u].append((v, w)) graph[v].append((u, w)) # Assuming undirected graph # Dijkstra's algorithm distances = [float('inf')] * (N + 1) distances[s] = 0 priority_queue = [(0, s)] while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_distance > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[t] if distances[t] != float('inf') else -1 # Example usage: # N = 4 # M = 5 # routes = [(1, 2, 4), (1, 3, 2), (2, 3, 3), (2, 4, 1), (3, 4, 5)] # s = 1 # t = 4 # print(shortest_path(N, M, routes, s, t)) # Output: 5"},{"question":"def trip_organizer(test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[int, int]]: For a given number of friends and driving segments, organize the driving schedule such that the segments are distributed as evenly as possible among the friends. >>> trip_organizer([(3, 5, [10, 20, 30, 40, 50]), (4, 7, [10, 20, 20, 30, 30, 40, 50])]) [(1, 2), (1, 2)] >>> trip_organizer([(1, 1, [10]), (1, 2, [10, 20])]) [(1, 1), (2, 2)] def test_trip_organizer(): input_cases = [ (3, 5, [10, 20, 30, 40, 50]), (4, 7, [10, 20, 20, 30, 30, 40, 50]) ] expected_output = [ (1, 2), (1, 2) ] assert trip_organizer(input_cases) == expected_output def test_with_minimum_values(): input_cases = [ (1, 1, [10]), (1, 2, [10, 20]) ] expected_output = [ (1, 1), (2, 2) ] assert trip_organizer(input_cases) == expected_output def test_with_equal_distribution(): input_cases = [ (2, 4, [10, 20, 30, 40]), (3, 6, [10, 20, 30, 40, 50, 60]) ] expected_output = [ (2, 2), (2, 2) ] assert trip_organizer(input_cases) == expected_output def test_no_leftover(): input_cases = [ (2, 6, [10, 20, 30, 40, 50, 60]) ] expected_output = [ (3, 3) ] assert trip_organizer(input_cases) == expected_output","solution":"def trip_organizer(test_cases): def calculate_segments(n, m, segments): average = m // n leftover = m % n if leftover == 0: return average, average else: return average, average + 1 results = [] for test_case in test_cases: n, m, segments = test_case min_segments, max_segments = calculate_segments(n, m, segments) results.append((min_segments, max_segments)) return results"},{"question":"from typing import List def max_subarray_product(arr: List[int]) -> int: Given an array of integers, find the maximum possible product of any non-empty subarray of the given array. Arguments: arr -- an array of integers Return: int -- the maximum product of any subarray of \`arr\` Examples: >>> max_subarray_product([2, 3, -2, 4]) 6 >>> max_subarray_product([-2, 0, -1]) 0 >>> max_subarray_product([-2, -3, 0, -2, -40]) 80","solution":"from typing import List def max_subarray_product(arr: List[int]) -> int: This function returns the maximum possible product of any non-empty subarray if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"def categorize_products(products): Categorize products by their category and sort them by price and name. :param products: List of tuples (name, category, price) :return: Dictionary with categories as keys and sorted list of products as values >>> products = [ ... (\\"apple\\", \\"fruit\\", 100), ... (\\"banana\\", \\"fruit\\", 60), ... (\\"carrot\\", \\"vegetable\\", 40), ... (\\"detergent\\", \\"cleaning\\", 120), ... (\\"broccoli\\", \\"vegetable\\", 70), ... (\\"wipe\\", \\"cleaning\\", 80), ... (\\"soap\\", \\"cleaning\\", 80), ... (\\"orange\\", \\"fruit\\", 100) ... ] >>> categorize_products(products) { \\"cleaning\\": [(\\"soap\\", 80), (\\"wipe\\", 80), (\\"detergent\\", 120)], \\"fruit\\": [(\\"banana\\", 60), (\\"apple\\", 100), (\\"orange\\", 100)], \\"vegetable\\": [(\\"carrot\\", 40), (\\"broccoli\\", 70)] } pass def print_categories(sorted_categories): Print categories and products in the desired format. :param sorted_categories: Dictionary with sorted products >>> sorted_categories = { ... \\"cleaning\\": [(\\"soap\\", 80), (\\"wipe\\", 80), (\\"detergent\\", 120)], ... \\"fruit\\": [(\\"banana\\", 60), (\\"apple\\", 100), (\\"orange\\", 100)], ... \\"vegetable\\": [(\\"carrot\\", 40), (\\"broccoli\\", 70)] ... } >>> print_categories(sorted_categories) cleaning soap 80 wipe 80 detergent 120 fruit banana 60 apple 100 orange 100 vegetable carrot 40 broccoli 70 pass","solution":"def categorize_products(products): Categorize products by their category and sort them by price and name. :param products: List of tuples (name, category, price) :return: Dictionary with categories as keys and sorted list of products as values from collections import defaultdict categories = defaultdict(list) for product in products: name, category, price = product categories[category].append((name, price)) sorted_categories = {} for category in sorted(categories.keys()): sorted_categories[category] = sorted(categories[category], key=lambda x: (x[1], x[0])) return sorted_categories def print_categories(sorted_categories): Print categories and products in the desired format. :param sorted_categories: Dictionary with sorted products for category in sorted_categories.keys(): print(category) for product in sorted_categories[category]: print(f\\"{product[0]} {product[1]}\\")"},{"question":"def find_unique_characters(s: str) -> List[str]: Returns a list of unique alphabetic characters in the order they first appear in the input string \`s\`. Non-alphabetic characters are ignored. >>> find_unique_characters(\\"abracadabra123!\\") ['a', 'b', 'r', 'c', 'd'] >>> find_unique_characters(\\"hello\\") ['h', 'e', 'l', 'o'] >>> find_unique_characters(\\"h3l@l#o!99he\\") ['h', 'l', 'o', 'e'] >>> find_unique_characters(\\"123456!@#%^&*()\\") [] >>> find_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\") list(\\"abcdefghijklmnopqrstuvwxyz\\") >>> find_unique_characters(\\"zzzzzzzz\\") ['z'] >>> find_unique_characters(\\"a\\" * (10**5)) ['a']","solution":"def find_unique_characters(s): Returns a list of unique alphabetic characters in the order they first appear in the input string \`s\`. Non-alphabetic characters are ignored. seen = set() unique_chars = [] for char in s: if 'a' <= char <= 'z': # if the character is a lowercase alphabetic character if char not in seen: seen.add(char) unique_chars.append(char) return unique_chars"},{"question":"def unique_paths_with_obstacles(M, N, grid): Returns the number of unique paths in a grid with obstacles. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. grid (list of list of int): The grid representation where 0 is an empty cell and 1 is an obstacle. Returns: int: Number of unique paths from top-left to bottom-right corner. def process_input(input_data): Processes the input data for multiple test cases and returns the results. Parameters: input_data (str): A string containing the input data with multiple test cases. Returns: list of int: A list of results for each test case. # Unit Tests import pytest from solution import unique_paths_with_obstacles, process_input def test_unique_paths_with_obstacles(): assert unique_paths_with_obstacles(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == 2 assert unique_paths_with_obstacles(3, 3, [ [0, 1, 0], [0, 0, 0], [0, 0, 0] ]) == 3 assert unique_paths_with_obstacles(2, 2, [ [0, 1], [0, 0] ]) == 1 assert unique_paths_with_obstacles(3, 3, [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 assert unique_paths_with_obstacles(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ]) == 0 def test_process_input(): input_data = 2 3 3 0 0 0 0 1 0 0 0 0 3 3 0 1 0 0 0 0 0 0 0 expected_output = [2, 3] assert process_input(input_data) == expected_output input_data = 1 2 2 0 1 0 0 expected_output = [1] assert process_input(input_data) == expected_output","solution":"def unique_paths_with_obstacles(M, N, grid): Returns the number of unique paths in a grid with obstacles. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. grid (list of list of int): The grid representation where 0 is an empty cell and 1 is an obstacle. Returns: int: Number of unique paths from top-left to bottom-right corner. if grid[0][0] == 1 or grid[M-1][N-1] == 1: return 0 dp = [[0] * N for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1] def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) results = [] index = 1 for _ in range(T): M, N = map(int, lines[index].split()) grid = [] for i in range(M): grid.append(list(map(int, lines[index + 1 + i].split()))) result = unique_paths_with_obstacles(M, N, grid) results.append(result) index += (M + 1) return results"},{"question":"def longest_palindromic_substring_with_one_change(s: str) -> int: Returns the length of the largest palindromic substring that can be obtained by changing at most one character in the string. >>> longest_palindromic_substring_with_one_change(\\"abacaba\\") 7 >>> longest_palindromic_substring_with_one_change(\\"abcde\\") 3 >>> longest_palindromic_substring_with_one_change(\\"aabb\\") 3 >>> longest_palindromic_substring_with_one_change(\\"a\\") 1 >>> longest_palindromic_substring_with_one_change(\\"aaaa\\") 4 >>> longest_palindromic_substring_with_one_change(\\"abccba\\") 6 >>> longest_palindromic_substring_with_one_change(\\"zyxw\\") 3 pass","solution":"def longest_palindromic_substring_with_one_change(s): Returns the length of the largest palindromic substring that can be obtained by changing at most one character in the string. def is_palindrome(s): return s == s[::-1] n = len(s) max_len = 1 for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): max_len = max(max_len, j-i+1) for i in range(n): for j in range(i, n): for k in range(i, j+1): original_char = s[k] for c in 'abcdefghijklmnopqrstuvwxyz': if c != original_char: modified = s[:k] + c + s[k+1:] if is_palindrome(modified[i:j+1]): max_len = max(max_len, j-i+1) return max_len"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are any two numbers in the array that add up to the target sum. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3], 7) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([4, -1, 2, -2, 1, 5, 6, -3], 3) True >>> has_pair_with_sum([10, 20, 30, 40], 100) False >>> has_pair_with_sum([3, 3, 4, 4], 8) True","solution":"def has_pair_with_sum(arr, target): Determines if there are any two numbers in the array that add up to the target sum. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"from typing import List def max_subarray_length(A: List[int], X: int, Y: int) -> int: Returns the maximum length of contiguous subarrays where every element is less than or equal to X, and the length of the subarray is at least Y. >>> max_subarray_length([1, 2, 3, 4, 5, 6, 7, 8], 5, 3) 5 >>> max_subarray_length([10, 5, 3, 1, 2, 8, 6, 7], 4, 2) 3 >>> max_subarray_length([1, 2, 3, 4, 5], 2, 3) 0 >>> max_subarray_length([5, 3, 5, 1, 2, 0], 5, 1) 6 >>> max_subarray_length([], 5, 3) 0 >>> max_subarray_length([5, 6, 7, 8], 6, 2) 2 >>> max_subarray_length([4, 4, 4, 4, 4, 4, 4, 4], 4, 4) 8 >>> max_subarray_length([4, 4, 4, 4, 3, 3, 3, 3], 4, 6) 8 >>> max_subarray_length([1, 2, 3, 4, 5], 5, 1) 5 >>> max_subarray_length([1, 2, 6, 3, 7, 4, 5], 5, 2) 2","solution":"def max_subarray_length(A, X, Y): Returns the maximum length of contiguous subarrays where every element is less than or equal to X, and the length of the subarray is at least Y. max_len = 0 current_len = 0 for value in A: if value <= X: current_len += 1 else: if current_len >= Y: max_len = max(max_len, current_len) current_len = 0 if current_len >= Y: max_len = max(max_len, current_len) return max_len"},{"question":"from typing import List def has_cycle(graph: List[List[int]]) -> bool: Determine if there is a cycle in the directed graph represented by the adjacency matrix. Args: graph: List[List[int]] : A 2D list representing the adjacency matrix of the graph. Returns: bool: True if there is a cycle in the graph, otherwise False. Examples: >>> has_cycle([ [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0] ]) True >>> has_cycle([ [0, 1, 0], [0, 0, 1], [0, 0, 0] ]) False","solution":"def has_cycle(graph): N = len(graph) # Helper function to perform DFS def dfs(v, visited, rec_stack): visited[v] = True rec_stack[v] = True for neighbor in range(N): if graph[v][neighbor] == 1: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False visited = [False] * N rec_stack = [False] * N for node in range(N): if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"def is_unique_photos(grid: List[List[int]]) -> str: Verify if each row and each column of the grid contains only unique photo IDs. >>> is_unique_photos([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 'YES' >>> is_unique_photos([ [1, 2, 3], [4, 5, 6], [1, 8, 9] ]) 'NO' >>> is_unique_photos([ [1, 2, 3, 4], [5, 6, 7, 3] ]) 'NO' pass","solution":"def is_unique_photos(grid): m = len(grid) if m == 0: return \\"YES\\" n = len(grid[0]) # Check each row for duplicates for row in grid: if len(set(row)) != len(row): return \\"NO\\" # Check each column for duplicates for col in range(n): col_values = [grid[row][col] for row in range(m)] if len(set(col_values)) != len(col_values): return \\"NO\\" return \\"YES\\""},{"question":"def min_total_distance(n: int, centers: List[Tuple[int, int, int]], m: int, neighborhoods: List[Tuple[int, int, int]]) -> int: Determine the minimum total distance covered to collect all the waste. >>> min_total_distance(2, [(1, 2, 10), (3, 4, 12)], 3, [(2, 3, 8), (4, 5, 5), (6, 7, 6)]) 10 >>> min_total_distance(3, [(1, 1, 5), (2, 2, 8), (3, 3, 10)], 2, [(4, 4, 15), (5, 5, 3)]) -1 pass","solution":"def min_total_distance(n, centers, m, neighborhoods): from heapq import heappush, heappop import math def distance(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) waste_collected = [0] * n # Waste collected by each center pq = [] # Priority queue to keep track of minimal distances # Creating all possible distances and pushing them to priority queue for i in range(m): for j in range(n): dist = distance(neighborhoods[i][0], neighborhoods[i][1], centers[j][0], centers[j][1]) heappush(pq, (dist, i, j)) total_distance = 0 assigned_neighborhoods = set() while pq and len(assigned_neighborhoods) < m: dist, nh_idx, ctr_idx = heappop(pq) if nh_idx in assigned_neighborhoods: continue if waste_collected[ctr_idx] + neighborhoods[nh_idx][2] <= centers[ctr_idx][2]: waste_collected[ctr_idx] += neighborhoods[nh_idx][2] total_distance += dist assigned_neighborhoods.add(nh_idx) if len(assigned_neighborhoods) == m: return total_distance else: return -1 # Example 1 n = 2 centers = [(1, 2, 10), (3, 4, 12)] m = 3 neighborhoods = [(2, 3, 8), (4, 5, 5), (6, 7, 6)] print(min_total_distance(n, centers, m, neighborhoods)) # Output: 10 # Example 2 n = 3 centers = [(1, 1, 5), (2, 2, 8), (3, 3, 10)] m = 2 neighborhoods = [(4, 4, 15), (5, 5, 3)] print(min_total_distance(n, centers, m, neighborhoods)) # Output: -1"},{"question":"def find_initial_failure(grid: List[List[int]]) -> Tuple[int, int]: Identify the original position from where the failure started in a grid of sensor statuses. >>> find_initial_failure([[0, 0, 1, 0, 0], [0, 1, 2, 1, 0], [1, 2, 3, 2, 1], [0, 1, 2, 1, 0], [0, 0, 1, 0, 0]]) (2, 2) >>> find_initial_failure([[0, 0, 0, 1, 0, 0], [0, 1, 2, 1, 0, 0], [0, 2, 3, 2, 1, 0], [1, 2, 3, 3, 2, 0], [0, 1, 2, 1, 0, 0], [0, 0, 1, 0, 0, 0]]) (3, 3) pass if __name__ == \\"__main__\\": # Test cases grid1 = [ [0, 0, 1, 0, 0], [0, 1, 2, 1, 0], [1, 2, 3, 2, 1], [0, 1, 2, 1, 0], [0, 0, 1, 0, 0] ] assert find_initial_failure(grid1) == (2, 2) grid2 = [ [0, 0, 0, 1, 0, 0], [0, 1, 2, 1, 0, 0], [0, 2, 3, 2, 1, 0], [1, 2, 3, 3, 2, 0], [0, 1, 2, 1, 0, 0], [0, 0, 1, 0, 0, 0] ] assert find_initial_failure(grid2) == (3, 3) grid3 = [ [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0] ] assert find_initial_failure(grid3) == (2, 3) grid4 = [ [3, 0, 0, 0, 0], [0, 0, 2, 1, 0], [0, 2, 3, 2, 1], [0, 1, 2, 1, 0], [0, 0, 1, 0, 0] ] assert find_initial_failure(grid4) == (0, 0)","solution":"def find_initial_failure(grid): # Get dimensions of the grid N = len(grid) M = len(grid[0]) for i in range(N): for j in range(M): if grid[i][j] == 3: return i, j # Example usage: if __name__ == \\"__main__\\": grid = [ [0, 0, 0, 1, 0, 0], [0, 1, 2, 1, 0, 0], [0, 2, 3, 2, 1, 0], [1, 2, 3, 3, 2, 0], [0, 1, 2, 1, 0, 0], [0, 0, 1, 0, 0, 0] ] print(find_initial_failure(grid)) # Should print (2, 3)"},{"question":"def chameleon_fizzbuzz(n: int, rules: List[Tuple[int, str]]) -> List[str]: Generate a series of outputs based on the rules of the modified FizzBuzz challenge. Parameters: n (int): The length of the series. rules (List[Tuple[int, str]]): A list of tuples, where each tuple contains a divisor and a string. Returns: List[str]: A list of strings representing the series from 1 to n inclusive. Examples: >>> chameleon_fizzbuzz(15, [(3, \\"Fizz\\"), (5, \\"Buzz\\"), (7, \\"Woof\\")]) ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', 'Woof', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', 'Woof', 'FizzBuzz'] >>> chameleon_fizzbuzz(10, [(2, \\"Prime\\"), (3, \\"Cube\\")]) ['1', 'Prime', 'Cube', 'Prime', '5', 'PrimeCube', '7', 'Prime', 'Cube', 'Prime']","solution":"def chameleon_fizzbuzz(n, rules): result = [] for i in range(1, n + 1): output = '' for d, s in rules: if i % d == 0: output += s if not output: output = str(i) result.append(output) return result"},{"question":"def minimum_task_identifiers(T, dimensions): Given a list of grid dimensions, returns the minimum number of different task identifiers required for each grid to ensure no two adjacent cells have the same identifier. Parameters: T (int): The number of test cases. dimensions (list of tuples): Each tuple contains two integers N and M, representing the grid dimensions. Returns: list of int: The minimum number of task identifiers for each test case. pass # Sample Usage # print(minimum_task_identifiers(3, [(1, 1), (2, 2), (2, 3)])) # Output: [1, 2, 2] # Unit Tests def test_case_1(): assert minimum_task_identifiers(3, [(1, 1), (2, 2), (2, 3)]) == [1, 2, 2] def test_case_2(): assert minimum_task_identifiers(2, [(4, 5), (5, 5)]) == [2, 2] def test_case_3(): assert minimum_task_identifiers(2, [(1, 10000), (10000, 1)]) == [1, 1] def test_case_4(): assert minimum_task_identifiers(2, [(3, 3), (4, 6)]) == [2, 2] def test_case_5(): assert minimum_task_identifiers(1, [(5, 7)]) == [2]","solution":"def minimum_task_identifiers(T, dimensions): Given a list of grid dimensions, returns the minimum number of different task identifiers required for each grid to ensure no two adjacent cells have the same identifier. Parameters: T (int): The number of test cases. dimensions (list of tuples): Each tuple contains two integers N and M, representing the grid dimensions. Returns: list of int: The minimum number of task identifiers for each test case. results = [] for N, M in dimensions: if N == 1 or M == 1: results.append(1) elif N % 2 == 0 or M % 2 == 0: results.append(2) else: results.append(2) return results"},{"question":"from typing import List, Tuple def maxProduct(nums: List[int]) -> int: Returns the maximum product of a contiguous subarray within nums. >>> maxProduct([2, 3, -2, 4]) == 6 >>> maxProduct([-2, 0, -1]) == 0 pass def process_input(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases for finding the maximum product of a contiguous subarray. >>> process_input(2, [(4, [2, 3, -2, 4]), (3, [-2, 0, -1])]) == [6, 0] >>> process_input(1, [(3, [0, -2, 0])]) == [0] pass # Unit tests def test_maxProduct_positive_case(): assert maxProduct([2, 3, -2, 4]) == 6 def test_maxProduct_with_zero_case(): assert maxProduct([-2, 0, -1]) == 0 def test_maxProduct_all_negative_case(): assert maxProduct([-2, -3, -4]) == 12 def test_maxProduct_single_element(): assert maxProduct([5]) == 5 assert maxProduct([-5]) == -5 def test_maxProduct_with_zeros(): assert maxProduct([0, 2]) == 2 assert maxProduct([2, 0]) == 2 def test_process_input_multiple_cases(): assert process_input(2, [(4, [2, 3, -2, 4]), (3, [-2, 0, -1])]) == [6, 0] def test_process_input_single_case(): assert process_input(1, [(3, [0, -2, 0])]) == [0]","solution":"def maxProduct(nums): Returns the maximum product of a contiguous subarray within nums. if not nums: return 0 max_prod = min_prod = result = nums[0] for num in nums[1:]: if num == 0: max_prod = min_prod = 1 temp_max = max(num, max_prod * num, min_prod * num) min_prod = min(num, max_prod * num, min_prod * num) max_prod = temp_max result = max(result, max_prod) return result def process_input(T, test_cases): Processes multiple test cases for finding the maximum product of a contiguous subarray. results = [] for case in test_cases: n, nums = case results.append(maxProduct(nums)) return results"},{"question":"def reorganize_students_heights(n, heights): Reorganize students' heights such that every student is either taller than both neighbors or shorter than both neighbors. >>> reorganize_students_heights(5, [4, 3, 2, 5, 1]) [3, 5, 2, 4, 1] >>> reorganize_students_heights(4, [1, 2, 3, 4]) [1, 3, 2, 4]","solution":"def reorganize_students_heights(n, heights): Reorganize students' heights such that every student is either taller than both neighbors or shorter than both neighbors. if n <= 1: return heights # Sort the heights heights.sort() # Place the smallest half elements in even indices and the largest half elements in odd indices result = [0] * n mid = (n + 1) // 2 result[::2] = heights[:mid] # Fill even indices with the smaller half result[1::2] = heights[mid:] # Fill odd indices with the larger half return result"},{"question":"import random def battle(char1: dict, char2: dict) -> str: Simulates a battle between two characters and returns the name of the winning character. Parameters: char1 (dict): Dictionary containing name, HP, ATK, and DEF of character 1. char2 (dict): Dictionary containing name, HP, ATK, and DEF of character 2. Returns: str: The name of the character who wins the battle. >>> char1 = {\\"name\\": \\"Warrior\\", \\"HP\\": 30, \\"ATK\\": 10, \\"DEF\\": 5} >>> char2 = {\\"name\\": \\"Mage\\", \\"HP\\": 25, \\"ATK\\": 12, \\"DEF\\": 3} >>> battle(char1, char2) in [\\"Warrior\\", \\"Mage\\"] True def test_battle_warrior_vs_mage(): char1 = { \\"name\\": \\"Warrior\\", \\"HP\\": 30, \\"ATK\\": 10, \\"DEF\\": 5 } char2 = { \\"name\\": \\"Mage\\", \\"HP\\": 25, \\"ATK\\": 12, \\"DEF\\": 3 } result = battle(char1, char2) assert result in [\\"Warrior\\", \\"Mage\\"] def test_battle_even_match(): char1 = { \\"name\\": \\"Knight\\", \\"HP\\": 20, \\"ATK\\": 8, \\"DEF\\": 4 } char2 = { \\"name\\": \\"Orc\\", \\"HP\\": 20, \\"ATK\\": 8, \\"DEF\\": 4 } result = battle(char1, char2) assert result in [\\"Knight\\", \\"Orc\\"] def test_battle_stronger_vs_weaker(): char1 = { \\"name\\": \\"Giant\\", \\"HP\\": 50, \\"ATK\\": 15, \\"DEF\\": 10 } char2 = { \\"name\\": \\"Goblin\\", \\"HP\\": 20, \\"ATK\\": 5, \\"DEF\\": 2 } assert battle(char1, char2) == \\"Giant\\" def test_battle_equal_hp_at_same_round(): # Case when both characters can reduce each other's HP to zero in the same round char1 = { \\"name\\": \\"Hero\\", \\"HP\\": 10, \\"ATK\\": 10, \\"DEF\\": 2 } char2 = { \\"name\\": \\"Villain\\", \\"HP\\": 10, \\"ATK\\": 8, \\"DEF\\": 1 } assert battle(char1, char2) in [\\"Hero\\", \\"Villain\\"]","solution":"import random def battle(char1, char2): Simulates a battle between two characters and returns the name of the winning character. Parameters: char1 (dict): Dictionary containing name, HP, ATK, and DEF of character 1. char2 (dict): Dictionary containing name, HP, ATK, and DEF of character 2. Returns: str: The name of the character who wins the battle. def get_damage(attacker, defender): return max(1, attacker['ATK'] - defender['DEF']) # Decide who attacks first randomly characters = [char1, char2] random.shuffle(characters) attacker = characters[0] defender = characters[1] while char1['HP'] > 0 and char2['HP'] > 0: damage = get_damage(attacker, defender) defender['HP'] -= damage # After an attack, switch roles attacker, defender = defender, attacker if char1['HP'] <= 0: return char2['name'] else: return char1['name']"},{"question":"import math from typing import Tuple def circle_properties(r: int) -> Tuple[float, float]: Given the radius of a circle, returns the area and circumference of the circle rounded to 8 decimal places. >>> circle_properties(1) (3.14159265, 6.28318531) >>> circle_properties(10) (314.15926536, 62.83185307) >>> circle_properties(0) (0.0, 0.0) >>> circle_properties(100) (31415.9265359, 628.31853072) >>> circle_properties(1000) (3141592.65358979, 6283.18530718)","solution":"import math def circle_properties(r): Given the radius of a circle, returns the area and circumference of the circle rounded to 8 decimal places. area = round(math.pi * r ** 2, 8) circumference = round(2 * math.pi * r, 8) return area, circumference"},{"question":"def max_total_score(N: int, hours: List[int]) -> int: Calculate the maximum total score you can achieve based on the distribution of available study hours. Parameters: N (int): Number of days. hours (list of int): List of integers representing the number of hours available each day. Returns: int: The maximum total score achievable. Examples: >>> max_total_score(5, [1, 2, 3, 4, 5]) 55 >>> max_total_score(3, [10, 10, 10]) 300","solution":"def max_total_score(N, hours): Returns the maximum total score that can be achieved given the number of hours available each day. Parameters: N (int): Number of days. hours (list): List of integers representing the number of hours available each day. Returns: int: The maximum total score achievable. # Calculating the total score: total_score = sum([hour ** 2 for hour in hours]) return total_score"},{"question":"def find_pythagorean_triplet(arr): Given an array of integers, find three distinct elements a, b, and c in the array such that the combination (a, b, c) forms a Pythagorean triplet, where a^2 + b^2 = c^2. If multiple solutions exist, return any one of them. If no such triplet exists, return -1. Args: arr (list): list of integers Returns: tuple: a triplet that forms a Pythagorean triplet, otherwise -1. Examples: >>> find_pythagorean_triplet([3, 1, 4, 6, 5]) (3, 4, 5) >>> find_pythagorean_triplet([10, 4, 6, 12, 5, 8]) (6, 8, 10) >>> find_pythagorean_triplet([1, 2, 3, 4]) -1","solution":"def find_pythagorean_triplet(arr): Given an array of integers, this function finds three distinct elements a, b, and c in the array such that the combination (a, b, c) forms a Pythagorean triplet, where a^2 + b^2 = c^2. If multiple solutions exist, return any one of them. If no such triplet exists, return -1. Args: arr (list): list of integers Returns: tuple: a triplet that forms a Pythagorean triplet, otherwise -1. n = len(arr) # Step 1: Square all elements and store in a dictionary for quick lookup squared = {x**2: x for x in arr} # Step 2: Find pairs (a^2, b^2) such that their sum exists in the dictionary for i in range(n): for j in range(i + 1, n): a2 = arr[i]**2 b2 = arr[j]**2 if a2 + b2 in squared: return arr[i], arr[j], squared[a2 + b2] return -1"},{"question":"def longest_palindrome(s: str) -> int: Returns the length of the longest palindrome that can be formed using the characters from the string s. >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"a\\") 1 >>> longest_palindrome(\\"bb\\") 2","solution":"def longest_palindrome(s): Returns the length of the longest palindrome that can be formed using the characters of the given string s. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def find_non_adjacent_pairs(N, people): Finds all valid pairs such that no two people who are adjacent in the circle are paired together. :param N: Number of people in the circle :param people: List of people's numbers in clockwise order :return: List of pairs if possible, otherwise -1 >>> find_non_adjacent_pairs(6, [1, 2, 3, 4, 5, 6]) == [(1, 4), (2, 5), (3, 6)] >>> find_non_adjacent_pairs(3, [1, 2, 3]) == -1 >>> find_non_adjacent_pairs(7, [1, 2, 3, 4, 5, 6, 7]) == -1 >>> find_non_adjacent_pairs(8, [1, 2, 3, 4, 5, 6, 7, 8]) == [(1, 5), (2, 6), (3, 7), (4, 8)] >>> find_non_adjacent_pairs(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 6), (2, 7), (3, 8), (4, 9), (5, 10)] >>> find_non_adjacent_pairs(5, [1, 2, 3, 4, 5]) == -1","solution":"def find_non_adjacent_pairs(N, people): Finds all valid pairs such that no two people who are adjacent in the circle are paired together. :param N: Number of people in the circle :param people: List of people's numbers in clockwise order :return: List of pairs if possible, otherwise -1 if N % 2 != 0: return -1 pairs = [] for i in range(N // 2): pairs.append((people[i], people[i + N // 2])) return pairs"},{"question":"def min_path_sum(n: int, m: int, grid: List[List[int]]) -> int: Finds the minimum path sum from the top-left corner to the bottom-right corner of a grid, moving only right or down. >>> min_path_sum(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum(1, 1, [[5]]) == 5 >>> min_path_sum(1, 3, [[1, 2, 3]]) == 6 >>> min_path_sum(3, 1, [[1], [2], [3]]) == 6 >>> min_path_sum(2, 3, [ ... [1, 2, 5], ... [3, 2, 1] ... ]) == 6","solution":"def min_path_sum(n, m, grid): Finds the minimum path sum from the top-left corner to the bottom-right corner of a grid, moving only right or down. # Create a dp array to store the minimum path sums dp = [[0] * m for _ in range(n)] # Initialize the first cell with the grid's first cell value dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the minimum path sum return dp[n-1][m-1]"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"forgeeksskeegfor\\") 10","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string s. n = len(s) if n <= 1: return n longest = 1 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True for length in range(2, n+1): for start in range(n-length+1): end = start + length - 1 if s[start] == s[end]: if length == 2: dp[start][end] = True else: dp[start][end] = dp[start+1][end-1] if dp[start][end]: longest = max(longest, length) return longest"},{"question":"def has_odd_sum_subset(n, arr): Determine if there exists a subset of the array 'arr' with an odd sum. Parameters: n (int): Number of integers in the sequence arr (list of int): The sequence of integers Returns: str: \\"YES\\" if there exists a subset with an odd sum, \\"NO\\" otherwise Examples: >>> has_odd_sum_subset(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> has_odd_sum_subset(4, [2, 4, 6, 8]) \\"NO\\"","solution":"def has_odd_sum_subset(n, arr): Determine if there exists a subset of the array 'arr' with an odd sum. Parameters: n (int): Number of integers in the sequence arr (list of int): The sequence of integers Returns: str: \\"YES\\" if there exists a subset with an odd sum, \\"NO\\" otherwise # Check if there is at least one odd number in the array for num in arr: if num % 2 == 1: return \\"YES\\" return \\"NO\\""},{"question":"def decode_commands(commands: List[str]) -> List[str]: Decode the given commands and output the assembly instructions for all robots in alphabetical order. >>> decode_commands([\\"START\\", \\"ADD A\\", \\"ADD B\\", \\"END\\", \\"START\\", \\"ADD C\\", \\"ADD A\\", \\"ADD B\\", \\"END\\"]) [\\"AB\\", \\"ABC\\"] >>> decode_commands([\\"START\\", \\"ADD C\\", \\"ADD B\\", \\"ADD A\\", \\"END\\", \\"START\\", \\"ADD D\\", \\"ADD E\\", \\"ADD F\\", \\"END\\"]) [\\"ABC\\", \\"DEF\\"] >>> decode_commands([\\"START\\", \\"ADD E\\", \\"ADD D\\", \\"END\\", \\"START\\", \\"ADD B\\", \\"ADD C\\", \\"ADD F\\", \\"END\\", \\"START\\", \\"ADD A\\", \\"END\\"]) [\\"DE\\", \\"BCF\\", \\"A\\"]","solution":"def decode_commands(commands): result = [] current_robot = None for command in commands: if command == \\"START\\": current_robot = [] elif command == \\"END\\": if current_robot is not None: result.append(\\"\\".join(sorted(current_robot))) current_robot = None elif command.startswith(\\"ADD\\"): _, part = command.split() if current_robot is not None and part not in current_robot: current_robot.append(part) return result"},{"question":"def partition_labels(s: str) -> List[int]: You are given a string s consisting of lowercase English letters. Partition the string into as few pieces as possible such that each letter appears in at most one piece, and then return the lengths of each partition. Examples: >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"caedbdedda\\") [1, 9]","solution":"def partition_labels(s): Returns the lengths of the partitions. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"def can_be_sorted(N: int, B: List[int]) -> str: Determines if the array B can be sorted in non-decreasing order. Args: N: int - the size of the array B: list of int - the array of integers Returns: str - \\"YES\\" if the array can be sorted in non-decreasing order, otherwise \\"NO\\" >>> can_be_sorted(5, [3, 1, 4, 5, 2]) \\"NO\\" >>> can_be_sorted(4, [10, 10, 9, 9]) \\"YES\\"","solution":"def can_be_sorted(N, B): Determines if the array B can be sorted in non-decreasing order. Args: N: int - the size of the array B: list of int - the array of integers Returns: str - \\"YES\\" if the array can be sorted in non-decreasing order, otherwise \\"NO\\" for i in range(N - 1): if B[i] < B[i + 1]: return \\"NO\\" return \\"YES\\""},{"question":"def can_place_books(S: int, B: int, segments: List[int], books: List[Tuple[int, int]]) -> str: Determine if it is possible to place all the books on the shelves such that no two books share the same shelf. Args: S (int): Number of segments. B (int): Total number of books. segments (List[int]): List containing the number of shelves in each segment. books (List[Tuple[int, int]]): List of tuples where each tuple represents the range of valid shelves for a book. Returns: str: \\"YES\\" if it is possible to place all books according to the rules, otherwise \\"NO\\". Examples: >>> can_place_books(2, 3, [3, 2], [(1, 3), (2, 4), (4, 5)]) == \\"YES\\" >>> can_place_books(2, 3, [3, 2], [(1, 3), (2, 4), (3, 5)]) == \\"YES\\" >>> can_place_books(2, 3, [3, 2], [(1, 2), (2, 3), (2, 5)]) == \\"YES\\" >>> can_place_books(2, 3, [1, 1], [(1, 2), (1, 2), (1, 2)]) == \\"NO\\" >>> can_place_books(1, 1, [2], [(1, 2)]) == \\"YES\\" >>> can_place_books(1, 2, [1], [(1, 1), (1, 1)]) == \\"NO\\"","solution":"def can_place_books(S, B, segments, books): from bisect import bisect_left, bisect_right # Create a list of cumulative shelves for each segment total_shelves = [] cumulative_shelves = 0 for shelves in segments: cumulative_shelves += shelves total_shelves.append(cumulative_shelves) # Flatten segments to obtain absolute shelf numbers & availability availability = [False] * cumulative_shelves for i in range(S): start = total_shelves[i-1] if i > 0 else 0 for j in range(start, total_shelves[i]): availability[j] = True # Iterate through all books to place them for start_shelf, end_shelf in books: placed = False for i in range(start_shelf - 1, end_shelf): if availability[i]: availability[i] = False placed = True break if not placed: return \\"NO\\" return \\"YES\\""},{"question":"def word_pattern(pattern: str, sentence: str) -> bool: Determine if the sentence follows the given pattern. Args: pattern (str): A string consisting of lowercase alphabetic characters. sentence (str): A string consisting of words separated by single spaces. Returns: bool: True if the sentence follows the pattern, False otherwise. Examples: >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") False","solution":"def word_pattern(pattern, sentence): words = sentence.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word and char_to_word[char] != word: return False if word in word_to_char and word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"def longest_increasing_subarray_length(arr): Returns the length of the longest contiguous subarray that is strictly increasing. >>> longest_increasing_subarray_length([1, 2, 1, 2, 3]) 3 >>> longest_increasing_subarray_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray_length([7]) 1 def process_test_cases(T, test_cases): Processes multiple test cases for finding the longest increasing subarray length. >>> process_test_cases(2, [(5, [1, 2, 1, 2, 3]), (6, [1, 2, 3, 4, 5, 4])]) [3, 5] >>> process_test_cases(1, [(4, [5, 5, 5, 5])]) [1]","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest contiguous subarray that is strictly increasing. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length def process_test_cases(T, test_cases): results = [] for test_case in test_cases: N, arr = test_case results.append(longest_increasing_subarray_length(arr)) return results"},{"question":"def rank_teams(datasets): This function takes the competition datasets as input and returns the ranking of the teams based on their total scores. Parameters: datasets (list of list): Each item in the outer list is a dataset representing a competition. Each dataset is a list of teams, where each team is represented by a list of tuples (score, time). Returns: list of list: Each item in the outer list is a list representing the ranked team numbers for the corresponding competition dataset. pass # Example usage and test cases if __name__ == \\"__main__\\": datasets = [ [ [(50, 30), (30, 40)], # Team 1 [(20, 20), (10, 10), (40, 50)], # Team 2 [(60, 60)], # Team 3 ], [ [(10, 10), (20, 30), (30, 50)], # Team 1 [(50, 40), (80, 70)] # Team 2 ] ] print(rank_teams(datasets))","solution":"def rank_teams(datasets): This function takes the competition datasets as input and returns the ranking of the teams based on their total scores. Parameters: datasets (list of list): Each item in the outer list is a dataset representing a competition. Each dataset is a list of teams, where each team is represented by a list of tuples (score, time). Returns: list of list: Each item in the outer list is a list representing the ranked team numbers for the corresponding competition dataset. def calculate_total_score(team_data): Helper function to calculate the total score for a given team. Parameters: team_data (list of tuples): Each tuple contains the score and the time for a solved problem. Returns: int: The total score for the team. total_score = 0 time_bonus = 0 for score, time in team_data: total_score += score return total_score + time_bonus results = [] for dataset in datasets: scores = [] for i, team in enumerate(dataset): total_score = calculate_total_score(team) scores.append((total_score, i + 1)) scores.sort(reverse=True, key=lambda x: (x[0], -x[1])) results.append([x[1] for x in scores]) return results"},{"question":"from typing import List def manage_warehouse(operations: List[str]) -> List[int]: You are tasked with managing a warehouse containing a large inventory of unique items. Each item has an associated ID and price. There are multiple operations that you need to handle: 1. Increase the price of all items within a given ID range by a specified amount. 2. Decrease the price of all items within a specified price range by a certain amount. 3. Determine the total price of all items within a certain ID range. Input: operations is a list of strings where each string represents an operation as described. Output: A list of integers where each integer is the result of a type-3 query. Example: >>> manage_warehouse([ \\"1 1 5 10\\", \\"2 5 15 3\\", \\"3 1 5\\", \\"1 2 3 5\\", \\"3 2 3\\", \\"3 1 3\\" ]) [27, 15, 27]","solution":"def manage_warehouse(operations): inventory = {} results = [] for operation in operations: op = operation.split() if op[0] == '1': l, r, x = int(op[1]), int(op[2]), int(op[3]) for i in range(l, r + 1): if i in inventory: inventory[i] += x else: inventory[i] = x elif op[0] == '2': a, b, y = int(op[1]), int(op[2]), int(op[3]) for key in inventory: if a <= inventory[key] <= b: inventory[key] = max(0, inventory[key] - y) elif op[0] == '3': l, r = int(op[1]), int(op[2]) total_price = sum(inventory[i] for i in range(l, r + 1) if i in inventory) results.append(total_price) return results"},{"question":"def can_reach_target(grid, target_r, target_c): Function to check if the robot can reach the target position (target_r, target_c) from the starting position (0, 0) in the given grid. Parameters: grid (list of list of str): The 2D grid representation, where '0' is a free space and '1' is an obstacle. target_r (int): The row index of the target position. target_c (int): The column index of the target position. Returns: bool: True if the robot can reach the target position, False otherwise. m, n = len(grid), len(grid[0]) def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == '0' visited = [[False for _ in range(n)] for _ in range(m)] deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y): if not is_valid(x, y) or visited[x][y]: return False if (x, y) == (target_r, target_c): return True visited[x][y] = True for dx, dy in deltas: if dfs(x + dx, y + dy): return True visited[x][y] = False return False return dfs(0, 0) def test_can_reach_basic_path(): # 3x3 grid, free path to the target (2, 2) grid = [['0', '0', '1'], ['0', '1', '0'], ['0', '0', '0']] assert can_reach_target(grid, 2, 2) == True def test_can_not_reach_blocked_path(): # 3x3 grid, no path available to the target (2, 2) grid = [['0', '0', '1'], ['0', '1', '0'], ['1', '1', '0']] assert can_reach_target(grid, 2, 2) == False def test_single_cell_no_obstacle(): # 1x1 grid, target is the start point grid = [['0']] assert can_reach_target(grid, 0, 0) == True def test_single_cell_with_obstacle(): # 1x1 grid with the obstacle in target spot grid = [['1']] assert can_reach_target(grid, 0, 0) == False def test_larger_grid_with_complex_path(): # 5x5 grid with a complex path to the target (4, 4) grid = [['0', '0', '0', '0', '0'], ['0', '1', '1', '1', '0'], ['0', '1', '0', '1', '0'], ['0', '1', '0', '1', '0'], ['0', '0', '0', '0', '0']] assert can_reach_target(grid, 4, 4) == True","solution":"def can_reach_target(grid, target_r, target_c): Function to check if the robot can reach the target position (target_r, target_c) from the starting position (0, 0) in the given grid. Parameters: grid (list of list of str): The 2D grid representation, where '0' is a free space and '1' is an obstacle. target_r (int): The row index of the target position. target_c (int): The column index of the target position. Returns: bool: True if the robot can reach the target position, False otherwise. m, n = len(grid), len(grid[0]) def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == '0' visited = [[False for _ in range(n)] for _ in range(m)] deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y): if not is_valid(x, y) or visited[x][y]: return False if (x, y) == (target_r, target_c): return True visited[x][y] = True for dx, dy in deltas: if dfs(x + dx, y + dy): return True visited[x][y] = False return False return dfs(0, 0)"},{"question":"def can_divide_friends(n: int, m: int, constraints: List[str]) -> str: Determine if it is possible to divide friends into two teams satisfying all constraints. >>> can_divide_friends(3, 3, [\\"1 = 2\\", \\"2 ≠ 3\\", \\"1 ≠ 3\\"]) \\"YES\\" >>> can_divide_friends(3, 3, [\\"1 = 2\\", \\"2 = 3\\", \\"1 ≠ 3\\"]) \\"NO\\"","solution":"class DSU: Disjoint Set Union (Union-Find) data structure with path compression and union by rank. def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 def can_divide_friends(n, m, constraints): dsu = DSU(n) diseq_constraints = [] for constraint in constraints: a, x, b = constraint.split() a = int(a) - 1 b = int(b) - 1 if x == \\"=\\": dsu.union(a, b) else: diseq_constraints.append((a, b)) for a, b in diseq_constraints: if dsu.find(a) == dsu.find(b): return \\"NO\\" return \\"YES\\""},{"question":"def compress_string(s: str) -> str: Compresses the string by replacing sequences of the same character with that character followed by the number of times it appears consecutively. If the compressed string is not shorter than the original string, it returns the original string. >>> compress_string(\\"AAABBBCCCAA\\") 'A3B3C3A2' >>> compress_string(\\"ABCD\\") 'ABCD' >>> compress_string(\\"AABBBAABB\\") 'A2B3A2B2' >>> compress_string(\\"A\\") 'A' >>> compress_string(\\"AAAAAAA\\") 'A7' >>> compress_string(\\"ABABABAB\\") 'ABABABAB' >>> compress_string(\\"A\\" * 500 + \\"B\\" * 500) 'A500B500' >>> compress_string(\\"\\") ''","solution":"def compress_string(s): Compresses the string by replacing sequences of the same character with that character followed by the number of times it appears consecutively. If the compressed string is not shorter than the original string, it returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # append the last sequence compressed_string = ''.join(compressed) if len(compressed_string) < len(s): return compressed_string else: return s"},{"question":"from typing import List, Tuple def gcd(a: int, b: int) -> int: Helper function to calculate the gcd of two numbers while b: a, b = b, a % b return a def garden_plots(T: int, dimensions: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Calculate the largest possible side length of the square plots and the number of such square plots for each garden's dimensions. Args: T : int : number of test cases dimensions : List[Tuple[int, int]] : list of tuples where each tuple contains two integers w (width) and h (height) of the garden Returns: List[Tuple[int, int]]: list of tuples where each tuple contains two integers representing the largest possible side length of the square plots and the number of such square plots for each test case. Examples: >>> garden_plots(2, [(6, 9), (4, 4)]) [(3, 6), (4, 1)] >>> garden_plots(1, [(15, 10)]) [(5, 6)] >>> garden_plots(3, [(12, 15), (20, 25), (40, 60)]) [(3, 20), (5, 20), (20, 6)] >>> garden_plots(1, [(1, 1)]) [(1, 1)] >>> garden_plots(1, [(1000000000, 1)]) [(1, 1000000000)] >>> garden_plots(1, [(1, 1000000000)]) [(1, 1000000000)] >>> garden_plots(1, [(1000000000, 1000000000)]) [(1000000000, 1)] results = [] for i in range(T): w, h = dimensions[i] side_length = gcd(w, h) num_plots = (w // side_length) * (h // side_length) results.append((side_length, num_plots)) return results","solution":"def gcd(a, b): Helper function to calculate the gcd of two numbers while b: a, b = b, a % b return a def garden_plots(T, dimensions): results = [] for i in range(T): w, h = dimensions[i] side_length = gcd(w, h) num_plots = (w // side_length) * (h // side_length) results.append((side_length, num_plots)) return results"},{"question":"def can_navigate_paths(N: int, paths: List[str]) -> List[str]: Determine if participants can navigate from the start to the end of each path without encountering any blocked segments. Args: N (int): The number of paths. paths (List[str]): A list of strings representing the paths. Returns: List[str]: A list of results where \\"Yes\\" indicates the path is navigable and \\"No\\" indicates it is not. >>> can_navigate_paths(3, [\\"OOOO\\", \\"OO\\", \\"O#O\\"]) [\\"Yes\\", \\"No\\", \\"No\\"] >>> can_navigate_paths(2, [\\"OOO\\", \\"OOO\\"]) [\\"No\\", \\"No\\"]","solution":"def can_navigate_paths(N, paths): results = [] for path in paths: if path[0] == '#' or '#' in path: results.append(\\"No\\") else: results.append(\\"Yes\\") return results"},{"question":"from typing import List, Tuple def find_most_frequent_pair(logs: List[Tuple[int, int, int]]) -> Tuple[int, int]: Find the pair of modules with the highest interaction count. Parameters: logs (list of tuples): Each tuple contains three integers representing two modules and their interaction count. Returns: tuple: A pair of modules (module1, module2) with the highest interaction count. # Implement this function def process_interaction_logs(logs: List[str]) -> List[Tuple[int, int]]: Process a list of interaction logs and find the most frequent interaction pair for each test case. Parameters: logs (list of str): List of strings representing the input logs for multiple test cases. Returns: list of tuples: List of result pairs for each test case. # Implement this function def test_find_most_frequent_pair(): assert find_most_frequent_pair([(1, 2, 10), (2, 3, 5), (1, 3, 15)]) == (1, 3) assert find_most_frequent_pair([(4, 5, 7), (5, 6, 12)]) == (5, 6) assert find_most_frequent_pair([(1, 2, 8), (2, 3, 8), (3, 4, 8)]) in [(1, 2), (2, 3), (3, 4)] def test_process_interaction_logs(): logs = [ \\"3\\", \\"1 2 10\\", \\"2 3 5\\", \\"1 3 15\\", \\"2\\", \\"4 5 7\\", \\"5 6 12\\", \\"0\\" ] results = process_interaction_logs(logs) assert results == [(1, 3), (5, 6)]","solution":"def find_most_frequent_pair(logs): Find the pair of modules with the highest interaction count. Parameters: logs (list of tuples): Each tuple contains three integers representing two modules and their interaction count. Returns: tuple: A pair of modules (module1, module2) with the highest interaction count. max_interaction = 0 result_pair = None for log in logs: module1, module2, count = log if count > max_interaction: max_interaction = count result_pair = (module1, module2) return result_pair def process_interaction_logs(logs): Process a list of interaction logs and find the most frequent interaction pair for each test case. Parameters: logs (list of str): List of strings representing the input logs for multiple test cases. Returns: list of tuples: List of result pairs for each test case. index = 0 results = [] while index < len(logs): n = int(logs[index]) if n == 0: break interaction_logs = [] for i in range(index + 1, index + 1 + n): interaction_logs.append(tuple(map(int, logs[i].split()))) result = find_most_frequent_pair(interaction_logs) results.append(result) index += n + 1 return results logs = [ \\"3\\", \\"1 2 10\\", \\"2 3 5\\", \\"1 3 15\\", \\"2\\", \\"4 5 7\\", \\"5 6 12\\", \\"0\\" ] results = process_interaction_logs(logs) for result in results: print(result[0], result[1])"},{"question":"def generate_pairs(n: int) -> List[Tuple[int, int]]: Generates n pairs of integers (a_i, b_i) such that: - 1 ≤ ai < bi ≤ 10^9 - ai + bi = 2 * (i + 1) where i is the 1-based index >>> generate_pairs(1) [(1, 3)] >>> generate_pairs(3) [(1, 3), (2, 4), (3, 5)]","solution":"def generate_pairs(n): Generates n pairs of integers (a_i, b_i) such that: - 1 ≤ ai < bi ≤ 10^9 - ai + bi = 2 * (i + 1) where i is the 1-based index pairs = [] for i in range(1, n + 1): ai = i bi = 2 * (i + 1) - ai pairs.append((ai, bi)) return pairs"},{"question":"def minimal_length_moves(s: str) -> int: Determine the minimum number of moves required to reduce the string to its minimal possible length. :param s: A string consisting of lowercase English letters. :return: Minimum number of moves required. >>> minimal_length_moves(\\"abba\\") 1 >>> minimal_length_moves(\\"aabbcc\\") 3 >>> minimal_length_moves(\\"abcd\\") 0 >>> minimal_length_moves(\\"a\\") 0 >>> minimal_length_moves(\\"abcdefg\\") 0 >>> minimal_length_moves(\\"aaaaa\\") 2 >>> minimal_length_moves(\\"aabbcddcaa\\") 4 >>> minimal_length_moves(\\"zzz\\") 1 pass","solution":"def minimal_length_moves(s): Returns the minimum number of moves required to reduce the string to its minimal possible length. def next_char(c): return chr((ord(c) - 97 + 1) % 26 + 97) moves = 0 stack = [] for char in s: if stack and stack[-1] == char: stack.pop() stack.append(next_char(char)) moves += 1 else: stack.append(char) return moves"},{"question":"def calculate_final_grades(students_scores): Calculate the final grades for each student by dropping the lowest score and averaging the remaining scores. Args: students_scores (List[List[str]]): A list of lists where each inner list contains the student's name followed by their scores. Returns: dict: A dictionary mapping student names to their final grade (rounded to the nearest integer). >>> calculate_final_grades([[\\"Alice\\", \\"70\\", \\"80\\", \\"90\\", \\"100\\"], [\\"Bob\\", \\"90\\", \\"60\\", \\"70\\"], [\\"Charlie\\", \\"100\\", \\"90\\", \\"80\\", \\"70\\"]]) {'Alice': 90, 'Bob': 80, 'Charlie': 90} pass def format_final_grades(final_grades): Format the final grades into a list of strings for output. Args: final_grades (dict): A dictionary mapping student names to their final grade. Returns: List[str]: A list of strings where each string is the student's name followed by their final grade. >>> format_final_grades({'Alice': 90, 'Bob': 80, 'Charlie': 90}) ['Alice 90', 'Bob 80', 'Charlie 90'] pass def main_grading_system(student_data): Main function to process the input student data and produce the final grades. Args: student_data (List[str]): A list of strings where each string contains a student's name followed by their scores. Returns: List[str]: A list of strings representing the final grades of each student. >>> main_grading_system([\\"Alice 70 80 90 100\\", \\"Bob 90 60 70\\", \\"Charlie 100 90 80 70\\"]) ['Alice 90', 'Bob 80', 'Charlie 90'] pass","solution":"def calculate_final_grades(students_scores): final_grades = {} for student_scores in students_scores: name = student_scores[0] scores = list(map(int, student_scores[1:])) scores.remove(min(scores)) average_score = round(sum(scores) / len(scores)) final_grades[name] = average_score return final_grades def format_final_grades(final_grades): formatted_grades = [] for name, grade in final_grades.items(): formatted_grades.append(f\\"{name} {grade}\\") return formatted_grades def main_grading_system(student_data): students_scores = [line.split() for line in student_data] final_grades = calculate_final_grades(students_scores) return format_final_grades(final_grades)"},{"question":"def solve_matrices_maximum_subarray_sum(T, test_cases): You are given a rectangular matrix of dimensions N x M. Each cell contains a positive integer. You need to find the maximum sum of any subarray of this matrix. A subarray is defined by a contiguous rectangular block of the original matrix. Args: T (int): number of test cases test_cases (list): list of tuples, each containing the dimensions of the matrix and the matrix itself Returns: list: list of integers representing the maximum sum of any subarray for each test case Example: >>> solve_matrices_maximum_subarray_sum(2, [((2, 2), [[1, 2], [3, 4]]), ((3, 3), [[1, 2, 3], [4, 5, 6], [7, 8, 9]])]) [10, 45]","solution":"def maximum_sum_subarray(matrix): def kadane(arr, size): max_end_here = max_so_far = arr[0] for i in range(1, size): max_end_here = max(arr[i], max_end_here + arr[i]) max_so_far = max(max_so_far, max_end_here) return max_so_far N = len(matrix) M = len(matrix[0]) max_sum = float('-inf') for left in range(M): temp = [0] * N for right in range(left, M): for i in range(N): temp[i] += matrix[i][right] current_sum = kadane(temp, N) max_sum = max(max_sum, current_sum) return max_sum def solve_matrices_maximum_subarray_sum(T, test_cases): results = [] for t in range(T): N, M = test_cases[t][0] matrix = test_cases[t][1] results.append(maximum_sum_subarray(matrix)) return results"},{"question":"def min_difference_partition(n, weights): Determine the minimum possible absolute difference between the sums of the weights of the two groups after dividing the packages. Args: n : int : number of packages. weights : list : list of weights of the packages. Returns: int : minimum possible absolute difference. # Your code here # Unit tests def test_example1(): assert min_difference_partition(4, [1, 6, 11, 5]) == 1 def test_example2(): assert min_difference_partition(3, [1, 1, 4]) == 2 def test_single_package(): assert min_difference_partition(1, [10]) == 10 def test_equal_split(): assert min_difference_partition(4, [3, 1, 1, 2]) == 1 def test_large_weights(): assert min_difference_partition(4, [10000, 10000, 10000, 10000]) == 0 def test_all_weights_same(): assert min_difference_partition(5, [5, 5, 5, 5, 5]) == 5 def test_no_difference(): assert min_difference_partition(2, [7, 7]) == 0","solution":"def min_difference_partition(n, weights): Determine the minimum possible absolute difference between the sums of the weights of the two groups after dividing the packages. Args: n : int : number of packages. weights : list : list of weights of the packages. Returns: int : minimum possible absolute difference. total_sum = sum(weights) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for weight in weights: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i"},{"question":"def minimal_sweetness_difference(n: int, sweetness_values: List[int]) -> int: You are given n different candy types, each with a certain sweetness value. You want to divide all candies into exactly two groups such that the absolute difference in total sweetness between the two groups is minimized. Note that you must use all candies, and each candy should be placed in exactly one group. Input: n (int): The number of different candy types. sweetness_values (List[int]): The sweetness values of the candies. Output: int: The minimal possible absolute difference between the total sweetness of the two groups. Examples: >>> minimal_sweetness_difference(5, [1, 2, 3, 4, 5]) 1 >>> minimal_sweetness_difference(4, [10, 20, 30, 40]) 0","solution":"def minimal_sweetness_difference(n, sweetness_values): from itertools import combinations total_sweetness = sum(sweetness_values) half_total_sweetness = total_sweetness // 2 min_difference = float('inf') for i in range(1, n + 1): for combo in combinations(sweetness_values, i): group1_sweetness = sum(combo) group2_sweetness = total_sweetness - group1_sweetness current_difference = abs(group1_sweetness - group2_sweetness) min_difference = min(min_difference, current_difference) return min_difference"},{"question":"def max_candy_bags(n: int, k: int, candy_bags: List[int]) -> Tuple[int, int]: There is a street with \`n\` houses and each house has an integer value representing the number of candy bags it contains. You have a gift bag which can only hold a certain number of candy bags, \`k\`. Your task is to maximize the number of candy bags that can fit into the gift bag by selecting consecutive houses from the street. If there are multiple solutions, return the subarray of house indices which comes first in lexicographical order. >>> max_candy_bags(6, 15, [2, 3, 5, 7, 1, 4]) (2, 4) >>> max_candy_bags(5, 10, [1, 1, 1, 1, 1]) (1, 5) >>> max_candy_bags(4, 7, [5, 1, 2, 1]) (2, 3)","solution":"def max_candy_bags(n, k, candy_bags): max_sum = 0 start_idx = 0 end_idx = 0 current_sum = 0 start = 0 for end in range(n): current_sum += candy_bags[end] while current_sum > k: current_sum -= candy_bags[start] start += 1 if current_sum > max_sum or (current_sum == max_sum and end - start < end_idx - start_idx): max_sum = current_sum start_idx = start end_idx = end return start_idx + 1, end_idx + 1"},{"question":"def calculate_teams_and_leftover(n: int, k: int) -> Tuple[int, int]: Returns the maximum number of teams that can be formed and the number of leftover players. >>> calculate_teams_and_leftover(10, 3) (3, 1) >>> calculate_teams_and_leftover(15, 5) (3, 0) >>> calculate_teams_and_leftover(7, 4) (1, 3)","solution":"def calculate_teams_and_leftover(n, k): Returns the maximum number of teams that can be formed and the number of leftover players. :param n: int, total number of participants :param k: int, number of players required for each team :return: tuple of two integers (max_teams, leftover) max_teams = n // k leftover = n % k return max_teams, leftover"},{"question":"def minimize_max_disparity(n: int, m: int, weights: List[int]) -> int: Returns the minimal possible maximum disparity among all columns. Args: n (int): Number of shelves. m (int): Number of columns. weights (List[int]): Weight limit for each shelf. Returns: int: Minimal possible maximum disparity among all columns. >>> minimize_max_disparity(4, 3, [10, 20, 30, 40]) 10 >>> minimize_max_disparity(3, 2, [15, 15, 15]) 0 >>> minimize_max_disparity(1, 3, [50]) 0 >>> minimize_max_disparity(5, 1, [5, 10, 15, 20, 25]) 20 >>> minimize_max_disparity(5, 2, [100, 200, 300, 400, 500]) 200","solution":"def minimize_max_disparity(n, m, weights): Returns the minimal possible maximum disparity among all columns. weights.sort() def validate_disparity(disparity): required_columns = 1 current_min = weights[0] current_max = weights[0] for i in range(1, n): current_min = min(current_min, weights[i]) current_max = max(current_max, weights[i]) if current_max - current_min > disparity: required_columns += 1 current_min = weights[i] current_max = weights[i] if required_columns > m: return False return True left, right = 0, weights[-1] - weights[0] result = right while left <= right: mid = (left + right) // 2 if validate_disparity(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def find_unique_integer(test_cases): Find the integer that appears only once in each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples. Each tuple consists of an integer and a list of integers where every integer appears exactly three times, except for one integer which appears only once. Returns: List[int]: A list of integers that appear only once in each test case. Examples: >>> find_unique_integer([(7, [2, 2, 3, 3, 3, 2, 4])]) [4] >>> find_unique_integer([(10, [0, 1, 0, 1, 0, 1, -3, -3, -3, 7])]) [7] def process_input(T, cases): Process the input to parse test cases and find unique integers. Args: T (int): Number of test cases. cases (List[Union[int, str]]): List containing the number of integers and the integers themselves for each test case. Returns: List[int]: A list of integers that appear only once in each test case. Examples: >>> process_input(2, [7, \\"2 2 3 3 3 2 4\\", 10, \\"0 1 0 1 0 1 -3 -3 -3 7\\"]) [4, 7]","solution":"def find_unique_integer(test_cases): result = [] for case in test_cases: N, nums = case num_count = {} for num in nums: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 for num in num_count: if num_count[num] == 1: result.append(num) break return result def process_input(T, cases): test_cases = [] for i in range(T): N = cases[i*2] nums = list(map(int, cases[i*2 + 1].split())) test_cases.append((N, nums)) return find_unique_integer(test_cases)"},{"question":"def max_value_in_grid(m: int, n: int, k: int, grid: List[List[int]]) -> int: Returns the maximum value in the grid that can be reached from (0, 0) within at most k steps. Parameters: ----------- m (int): rows in the grid n (int): columns in the grid k (int): max number of steps grid (list[list[int]]): grid data Returns: -------- int: max value that can be reached within k steps >>> max_value_in_grid(3, 4, 2, [ [1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 3, 0] ]) 5 >>> max_value_in_grid(2, 2, 1, [ [1, 2], [3, 4] ]) 4","solution":"def max_value_in_grid(m, n, k, grid): Returns the maximum value in the grid that can be reached from (0, 0) within at most k steps. Parameters: ----------- m (int): rows in the grid n (int): columns in the grid k (int): max number of steps grid (list[list[int]]): grid data Returns: -------- int: max value that can be reached within k steps from collections import deque # Directions for normal step and k step directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (k, 0), (-k, 0), (0, k), (0, -k)] # BFS initialization queue = deque([(0, 0)]) # Queue stores positions visited = set() visited.add((0, 0)) max_value = grid[0][0] while queue: r, c = queue.popleft() for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < m and 0 <= new_c < n and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append((new_r, new_c)) max_value = max(max_value, grid[new_r][new_c]) return max_value"},{"question":"def is_path_from_top_to_bottom(grid, n, m): Determines if there is a continuous path of black cells ('B') from any cell in the top row to any cell in the bottom row of the grid. Returns 'YES' if such a path exists, else 'NO'. Parameters: grid (List[str]): The 2D grid representing the board n (int): Number of rows in the grid m (int): Number of columns in the grid Returns: str: 'YES' if a continuous path exists, otherwise 'NO' Examples: >>> is_path_from_top_to_bottom([ ... 'WBBBW', ... 'WBWBW', ... 'BBBBB', ... 'WBBBB', ... 'WWBBB' ... ], 5, 5) 'YES' >>> is_path_from_top_to_bottom([ ... 'BWWW', ... 'WBBB', ... 'WWBB', ... 'WWWB' ... ], 4, 4) 'NO' pass def test_example_1(): grid = [ 'WBBBW', 'WBWBW', 'BBBBB', 'WBBBB', 'WWBBB' ] assert is_path_from_top_to_bottom(grid, 5, 5) == \\"YES\\" def test_example_2(): grid = [ 'BWWW', 'WBBB', 'WWBB', 'WWWB' ] assert is_path_from_top_to_bottom(grid, 4, 4) == \\"NO\\" def test_example_3(): grid = [ 'BBB', 'WWW', 'BBB' ] assert is_path_from_top_to_bottom(grid, 3, 3) == \\"NO\\" def test_single_black_cell(): grid = ['B'] assert is_path_from_top_to_bottom(grid, 1, 1) == \\"YES\\" def test_single_white_cell(): grid = ['W'] assert is_path_from_top_to_bottom(grid, 1, 1) == \\"NO\\" def test_straight_path(): grid = [ 'BWW', 'BWW', 'BWW', 'BWW' ] assert is_path_from_top_to_bottom(grid, 4, 3) == \\"YES\\" def test_no_black_cells(): grid = [ 'WWW', 'WWW', 'WWW' ] assert is_path_from_top_to_bottom(grid, 3, 3) == \\"NO\\"","solution":"def is_path_from_top_to_bottom(grid, n, m): Determines if there is a continuous path of black cells ('B') from any cell in the top row to any cell in the bottom row of the grid. from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'B' and not visited[x][y] visited = [[False] * m for _ in range(n)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right # Find all starting points in the top row queue = deque() for j in range(m): if grid[0][j] == 'B': queue.append((0, j)) visited[0][j] = True # BFS to find a path to the bottom row while queue: x, y = queue.popleft() if x == n-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def maximum_sum_with_skip(arr): Calculate the maximum sum of a contiguous subarray with the option to skip one element. Args: arr (List[int]): List of integers representing the array. Returns: int: The maximum sum achievable by applying the described strategy. Examples: >>> maximum_sum_with_skip([1, -2, 3, 4, -1, 2]) 9 >>> maximum_sum_with_skip([-2, -3, 4, -1, -2]) 4 >>> maximum_sum_with_skip([5]) 5 >>> maximum_sum_with_skip([-1, -2, -3, -4]) -1 >>> maximum_sum_with_skip([1, 2, -100, 3, 4]) 10","solution":"def maximum_sum_with_skip(arr): n = len(arr) if n == 0: return 0 max_end_here = [0] * n max_with_skip = [0] * n max_end_here[0] = arr[0] result = arr[0] for i in range(1, n): max_end_here[i] = max(arr[i], max_end_here[i-1] + arr[i]) max_with_skip[i] = max(max_end_here[i-1], max_with_skip[i-1] + arr[i]) result = max(result, max_end_here[i], max_with_skip[i]) return result"},{"question":"def range_sum(N: int, arr: List[int], L: int, R: int) -> int: Given a list of integers and a range [L, R], returns the sum of the integers within the given range (inclusive). Args: N (int): Number of integers in the list. arr (list of int): List of integers. L (int): Start index of the range (1-based). R (int): End index of the range (1-based). Returns: int: Sum of the integers within the range [L, R]. Examples: >>> range_sum(5, [1, 2, 3, 4, 5], 2, 4) 9 >>> range_sum(6, [-1, -3, 5, 7, 9, -2], 1, 3) 1","solution":"def range_sum(N, arr, L, R): Given a list of integers and a range [L, R], returns the sum of the integers within the given range (inclusive). Args: N (int): Number of integers in the list. arr (list of int): List of integers. L (int): Start index of the range (1-based). R (int): End index of the range (1-based). Returns: int: Sum of the integers within the range [L, R]. # Convert the 1-based indexing to 0-based indexing L_index = L - 1 R_index = R - 1 # Calculate the sum of elements in the given range return sum(arr[L_index:R_index + 1]) # Example of using the function: # N = 5 # arr = [1, 2, 3, 4, 5] # L = 2 # R = 4 # Expected output: 9 print(range_sum(5, [1, 2, 3, 4, 5], 2, 4))"},{"question":"def game_winner(n: int, s: str) -> str: Determines the winner of the game if both players play optimally. Parameters: n (int): The length of the string. s (str): The string consisting of lowercase English letters. Returns: str: 'Alice' if Alice wins, 'Bob' if Bob wins. >>> game_winner(6, \\"aaabbb\\") 'Bob' >>> game_winner(7, \\"abcdefg\\") 'Alice'","solution":"def game_winner(n, s): Determines the winner of the game if both players play optimally. Parameters: n (int): The length of the string. s (str): The string consisting of lowercase English letters. Returns: str: 'Alice' if Alice wins, 'Bob' if Bob wins. from collections import Counter char_counts = Counter(s) distinct_char_count = len(char_counts) # If the number of distinct characters is odd, Alice wins # If even, Bob wins if distinct_char_count % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def findLHS(nums: List[int]) -> int: Returns the length of the longest harmonious sublist such that the difference between its maximum and minimum values is exactly one. >>> findLHS([1, 2, 2, 1, 3, 4]) 4 >>> findLHS([1, 1, 1, 1, 1, 1, 1, 1]) 0","solution":"def findLHS(nums): Returns the length of the longest harmonious sublist such that the difference between its maximum and minimum values is exactly one. num_count = {} for num in nums: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 longest_harmonious = 0 for num in num_count: if num + 1 in num_count: longest_harmonious = max(longest_harmonious, num_count[num] + num_count[num + 1]) return longest_harmonious"},{"question":"from typing import List, Tuple def calculate_min_max_sums(t: int, messages: List[str]) -> List[Tuple[int, int]]: Calculate the range of possible sums of digits for each message containing numerical codes and '?'. >>> calculate_min_max_sums(3, [\\"123\\", \\"1?2\\", \\"?99?\\"]) [(6, 6), (3, 12), (18, 36)] >>> calculate_min_max_sums(2, [\\"??\\", \\"0?0\\"]) [(0, 18), (0, 9)] >>> calculate_min_max_sums(1, [\\"9876543210\\"]) [(45, 45)] >>> calculate_min_max_sums(1, [\\"?\\"]) [(0, 9)] >>> calculate_min_max_sums(4, [\\"?1\\", \\"1?\\", \\"?9?\\", \\"0?0\\"]) [(1, 10), (1, 10), (9, 27), (0, 9)] def test_calculate_min_max_sums(): assert calculate_min_max_sums(3, [\\"123\\", \\"1?2\\", \\"?99?\\"]) == [(6, 6), (3, 12), (18, 36)] assert calculate_min_max_sums(2, [\\"??\\", \\"0?0\\"]) == [(0, 18), (0, 9)] assert calculate_min_max_sums(1, [\\"9876543210\\"]) == [(45, 45)] assert calculate_min_max_sums(1, [\\"?\\"]) == [(0, 9)] assert calculate_min_max_sums(4, [\\"?1\\", \\"1?\\", \\"?9?\\", \\"0?0\\"]) == [(1, 10), (1, 10), (9, 27), (0, 9)] def test_edge_cases(): assert calculate_min_max_sums(1, [\\"\\"]) == [(0, 0)] assert calculate_min_max_sums(1, [\\"???\\"]) == [(0, 27)]","solution":"def calculate_min_max_sums(t, messages): result = [] for message in messages: min_sum = sum(int(ch) for ch in message if ch.isdigit()) max_sum = sum(int(ch) for ch in message if ch.isdigit()) + 9 * message.count('?') result.append((min_sum, max_sum)) return result"},{"question":"def count_vowels(s: str) -> str: This function takes a string of mixed-case alphabets and returns the count of each vowel (both upper-case and lower-case treated the same) along with the total number of vowels. >>> count_vowels(\\"EducAtIon\\") 'a: 1ne: 1ni: 1no: 1nu: 1nTotal: 5' >>> count_vowels(\\"bcdfg\\") 'Total: 0' >>> count_vowels(\\"aeiou\\") 'a: 1ne: 1ni: 1no: 1nu: 1nTotal: 5' >>> count_vowels(\\"AEIOUaeiou\\") 'a: 2ne: 2ni: 2no: 2nu: 2nTotal: 10' >>> count_vowels(\\"\\") 'Total: 0'","solution":"def count_vowels(s): This function takes a string of mixed-case alphabets and returns the count of each vowel (both upper-case and lower-case treated the same) along with the total number of vowels. # Convert the string to lower case to handle case insensitivity s = s.lower() # Define the vowels vowels = 'aeiou' # Dictionary to store the counts of each vowel vowel_count = {vowel: 0 for vowel in vowels} # Total count of vowels total_count = 0 # Count the vowels for char in s: if char in vowels: vowel_count[char] += 1 total_count += 1 # Generate the output string result = [] for vowel in sorted(vowel_count.keys()): if vowel_count[vowel] > 0: result.append(f\\"{vowel}: {vowel_count[vowel]}\\") result.append(f\\"Total: {total_count}\\") return \\"n\\".join(result)"},{"question":"def count_visible_buildings(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the number of buildings visible from the left end of the row for each test case. >>> count_visible_buildings(1, [(5, [1, 2, 3, 2, 5])]) [4] >>> count_visible_buildings(3, [(5, [1, 2, 3, 2, 5]), (4, [4, 3, 2, 1]), (6, [1, 2, 2, 3, 1, 4])]) [4, 1, 4] from solution import count_visible_buildings def test_single_test_case(): assert count_visible_buildings(1, [(5, [1, 2, 3, 2, 5])]) == [4] def test_multiple_test_cases(): assert count_visible_buildings(3, [(5, [1, 2, 3, 2, 5]), (4, [4, 3, 2, 1]), (6, [1, 2, 2, 3, 1, 4])]) == [4, 1, 4] def test_same_height_buildings(): assert count_visible_buildings(1, [(4, [5, 5, 5, 5])]) == [1] def test_decreasing_height_buildings(): assert count_visible_buildings(1, [(6, [6, 5, 4, 3, 2, 1])]) == [1] def test_increasing_height_buildings(): assert count_visible_buildings(1, [(6, [1, 2, 3, 4, 5, 6])]) == [6]","solution":"def count_visible_buildings(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] heights = test_cases[i][1] max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height results.append(visible_count) return results"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of queries on an array, including element updates and subarray sums. Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): The initial array of integers. queries (List[Tuple[int, int, int]]): A list of queries, where each query is a tuple. - (1, i, x): Update the element at index i to x. - (2, l, r): Calculate the sum of elements from index l to r (inclusive). Returns: List[int]: The results of the sum queries. Example: >>> n = 5 >>> q = 3 >>> array = [1, 2, 3, 4, 5] >>> queries = [(2, 1, 3), (1, 3, 10), (2, 2, 5)] >>> process_queries(n, q, array, queries) [6, 21] from typing import List, Tuple def test_process_queries_basic_example(): n = 5 q = 3 array = [1, 2, 3, 4, 5] queries = [ (2, 1, 3), (1, 3, 10), (2, 2, 5) ] expected_output = [6, 21] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_single_element_update(): n = 5 q = 1 array = [1, 2, 3, 4, 5] queries = [ (1, 1, 10) ] expected_output = [] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_single_element_sum(): n = 5 q = 1 array = [1, 2, 3, 4, 5] queries = [ (2, 1, 1) ] expected_output = [1] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_multiple_updates_and_sums(): n = 5 q = 4 array = [1, 2, 3, 4, 5] queries = [ (2, 1, 5), (1, 5, 10), (2, 1, 5), (2, 3, 3) ] expected_output = [15, 20, 3] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_edge_case_large_numbers(): n = 2 q = 2 array = [10**9, 10**9] queries = [ (2, 1, 2), (1, 2, 1), ] expected_output = [2*10**9] assert process_queries(n, q, array, queries) == expected_output","solution":"def process_queries(n, q, array, queries): prefix_sums = [0] * (n + 1) # Build initial prefix sums array for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + array[i] results = [] for query in queries: if query[0] == 1: # Update query i = query[1] - 1 x = query[2] diff = x - array[i] array[i] = x for j in range(i + 1, n + 1): prefix_sums[j] += diff elif query[0] == 2: # Sum query l = query[1] r = query[2] results.append(prefix_sums[r] - prefix_sums[l - 1]) return results"},{"question":"def minimum_effort_path(heights: List[List[int]]) -> int: Determine the minimum effort path from the top-left corner to the bottom-right corner in the provided grid of terrain heights. >>> minimum_effort_path([ >>> [1, 2, 2], >>> [3, 8, 2], >>> [5, 3, 5] >>> ]) 2 >>> minimum_effort_path([ >>> [1, 2], >>> [2, 1] >>> ]) 1","solution":"from heapq import heappush, heappop def minimum_effort_path(heights): n, m = len(heights), len(heights[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Function to check if you can traverse the grid with a given max effort def can_traverse(max_effort): visited = [[False for _ in range(m)] for _ in range(n)] heap = [(0, 0, 0)] # (effort, x, y) while heap: effort, x, y = heappop(heap) if x == n-1 and y == m-1: return True if visited[x][y]: continue visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: next_effort = max(effort, abs(heights[nx][ny] - heights[x][y])) if next_effort <= max_effort: heappush(heap, (next_effort, nx, ny)) return False # Binary search over the possible maximum efforts low, high = 0, 1000 while low < high: mid = (low + high) // 2 if can_traverse(mid): high = mid else: low = mid + 1 return low # Example usage: heights = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] print(minimum_effort_path(heights)) # Output: 2"},{"question":"from typing import List def find_anagrams(s: str, p: str) -> List[int]: Returns a list of starting indices of the pattern's anagrams in the given string. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"aaabbbccc\\", \\"a\\") [0, 1, 2] >>> find_anagrams(\\"abcdefg\\", \\"hij\\") [] >>> find_anagrams(\\"abc\\", \\"abc\\") [0] >>> find_anagrams(\\"aaa\\", \\"aa\\") [0, 1] >>> find_anagrams(\\"abc\\", \\"abcd\\") [] >>> find_anagrams(\\"ababababab\\", \\"aab\\") [0, 2, 4, 6]","solution":"from collections import Counter def find_anagrams(s, p): Returns a list of starting indices of the pattern's anagrams in the given string. p_len = len(p) s_len = len(s) p_count = Counter(p) s_count = Counter() result = [] for i in range(s_len): # add one more letter on the right side of the window s_count[s[i]] += 1 # remove one letter from the left side of the window if size of the window is greater than p_len if i >= p_len: if s_count[s[i - p_len]] == 1: del s_count[s[i - p_len]] else: s_count[s[i - p_len]] -= 1 # compare window with the pattern if s_count == p_count: result.append(i - p_len + 1) return result"},{"question":"def max_sessions(n: int, sessions: List[Tuple[int, int]]) -> int: Determine the maximum number of sessions that the speaker can attend without any overlap. >>> max_sessions(5, [(1, 3), (2, 4), (3, 5), (6, 8), (7, 9)]) 3 >>> max_sessions(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_sessions(0, []) 0 >>> max_sessions(3, [(1, 4), (2, 5), (3, 6)]) 1 >>> max_sessions(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_sessions(3, [(1, 3), (1, 2), (1, 4)]) 1","solution":"def max_sessions(n, sessions): # Sort sessions by their end times sessions.sort(key=lambda x: x[1]) max_sessions_count = 0 last_end_time = 0 for start, end in sessions: if start >= last_end_time: max_sessions_count += 1 last_end_time = end return max_sessions_count"},{"question":"def summarize_data_usage(n: int, data_log: List[Tuple[str, int]]) -> Dict[str, int]: Summarizes the total data usage for each unique activity. :param n: The number of entries in the data log :param data_log: A list of tuples, each containing an activity and the corresponding data usage in megabytes :return: A dictionary with activity names as keys and the total data usage as values >>> summarize_data_usage(5, [(\\"browsing\\", 100), (\\"video\\", 300), (\\"browsing\\", 200), (\\"downloads\\", 400), (\\"video\\", 700)]) {'browsing': 300, 'video': 1000, 'downloads': 400} >>> summarize_data_usage(3, [(\\"games\\", 500), (\\"music\\", 150), (\\"games\\", 450)]) {'games': 950, 'music': 150}","solution":"def summarize_data_usage(n, data_log): Summarizes the total data usage for each unique activity. :param n: The number of entries in the data log :param data_log: A list of tuples, each containing an activity and the corresponding data usage in megabytes :return: A dictionary with activity names as keys and the total data usage as values data_usage = {} for activity, data in data_log: if activity in data_usage: data_usage[activity] += data else: data_usage[activity] = data return data_usage # Example Usage n = 5 data_log = [ (\\"browsing\\", 100), (\\"video\\", 300), (\\"browsing\\", 200), (\\"downloads\\", 400), (\\"video\\", 700) ] result = summarize_data_usage(n, data_log) for activity, total_data in result.items(): print(activity, total_data)"},{"question":"def min_tickets_needed(r: int, n: int, rides: List[int]) -> int: Compute the minimum number of tickets needed to achieve at least \`r\` rides. Parameters: r (int): The initial number of rides. n (int): The number of different ticket types. rides (List[int]): The rides each ticket type can afford. Returns: int: The minimum number of tickets needed to achieve at least \`r\` rides, or -1 if not possible. Examples: >>> min_tickets_needed(7, 3, [1, 3, 4]) 2 >>> min_tickets_needed(5, 2, [2, 4]) -1","solution":"def min_tickets_needed(r, n, rides): # Initialize an array to store minimum tickets needed for a given number of rides dp = [float('inf')] * (r + 1) dp[0] = 0 # No tickets are needed for 0 rides # Use dynamic programming to find the minimum number of tickets required for i in range(1, r + 1): for ride in rides: if i >= ride: dp[i] = min(dp[i], dp[i - ride] + 1) # Check if it's possible to get at least r rides min_tickets = min(dp[r:]) return min_tickets if min_tickets != float('inf') else -1"},{"question":"def max_adjacent_cells(m: int, n: int) -> int: Given the dimensions of the grid m x n, return the maximum number of cells you can visit starting from any cell in the grid and moving to adjacent cells without revisiting any cell. >>> max_adjacent_cells(3, 3) 9 >>> max_adjacent_cells(2, 2) 4 >>> max_adjacent_cells(1, 5) 5","solution":"def max_adjacent_cells(m, n): Given the dimensions of the grid m x n, return the maximum number of cells you can visit starting from any cell in the grid and moving to adjacent cells without revisiting any cell. # Since we can start from any cell and traverse the entire grid, the maximum number of cells # we can visit is simply the total number of cells in the grid, which is m * n. return m * n"},{"question":"def largest_square_area(matrix: List[List[int]]) -> int: Given a binary matrix, determine the size of the largest square sub-matrix that contains only 1s. >>> largest_square_area([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 4 >>> largest_square_area([[0, 1, 1], [1, 1, 1], [1, 1, 0]]) == 4 >>> largest_square_area([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> largest_square_area([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 9","solution":"def largest_square_area(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side_length = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length * max_side_length"},{"question":"def min_operations(n: int, stones: List[int]) -> int: Returns the minimum number of operations required to make all stones the same color. If it is impossible, returns -1. >>> min_operations(5, [1, 2, 2, 3, 2]) 2 >>> min_operations(3, [1, 2, 3]) -1","solution":"def min_operations(n, stones): Returns the minimum number of operations required to make all stones the same color. If it is impossible, returns -1. # If there is only one stone, no operations are needed if n == 1: return 0 color_counts = {} max_count = 0 for color in stones: if color not in color_counts: color_counts[color] = 0 color_counts[color] += 1 max_count = max(max_count, color_counts[color]) # If the max_count of any color is 1 and n > 2, then it is impossible to make them all same color if max_count == 1 and n > 2: return -1 # Minimum operations to make all stones the same color # Total stones (n) - max occurrence of the most frequent color (max_count) return n - max_count"},{"question":"def knapsack(capacity, weights): Solves the 0/1 knapsack problem for given capacity and weights. pass # Your implementation here def maximize_loaded_weight(m, capacities, n, container_weights): For each ship, determines the maximum total weight of containers that can be loaded onto the ship without exceeding its weight capacity. pass # Your implementation here # Example usage m = 3 capacities = [100, 150, 200] n = 5 container_weights = [50, 50, 50, 50, 50] print(maximize_loaded_weight(m, capacities, n, container_weights)) # Unit Test def test_maximize_loaded_weight_sample1(): m = 3 capacities = [100, 150, 200] n = 5 container_weights = [50, 50, 50, 50, 50] expected_output = [100, 150, 200] assert maximize_loaded_weight(m, capacities, n, container_weights) == expected_output def test_maximize_loaded_weight_sample2(): m = 2 capacities = [30, 50] n = 4 container_weights = [10, 40, 20, 30] expected_output = [30, 50] assert maximize_loaded_weight(m, capacities, n, container_weights) == expected_output def test_maximize_loaded_weight_single_container(): m = 2 capacities = [40, 50] n = 1 container_weights = [35] expected_output = [35, 35] assert maximize_loaded_weight(m, capacities, n, container_weights) == expected_output def test_maximize_loaded_weight_multiple_identical_ships(): m = 3 capacities = [100, 100, 100] n = 3 container_weights = [30, 40, 50] expected_output = [90, 90, 90] assert maximize_loaded_weight(m, capacities, n, container_weights) == expected_output def test_maximize_loaded_weight_diverse_containers(): m = 2 capacities = [75, 120] n = 5 container_weights = [10, 30, 20, 60, 40] expected_output = [70, 120] assert maximize_loaded_weight(m, capacities, n, container_weights) == expected_output","solution":"def knapsack(capacity, weights): Solves the 0/1 knapsack problem for given capacity and weights. n = len(weights) dp = [0] * (capacity + 1) for weight in weights: for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + weight) return dp[-1] def maximize_loaded_weight(m, capacities, n, container_weights): For each ship, determines the maximum total weight of containers that can be loaded onto the ship without exceeding its weight capacity. result = [] for capacity in capacities: max_weight = knapsack(capacity, container_weights) result.append(max_weight) return result"},{"question":"from typing import List def count_distinct_sentences(n: int, words: List[str]) -> int: Return the number of distinct sentences that can be formed by shuffling the words. >>> count_distinct_sentences(2, [\\"cat\\", \\"dog\\"]) 2 >>> count_distinct_sentences(3, [\\"apple\\", \\"banana\\", \\"cherry\\"]) 6 >>> count_distinct_sentences(4, [\\"one\\", \\"two\\", \\"three\\", \\"four\\"]) 24 pass def process_input(data: List[str]) -> List[int]: Process the input data and return the results as a list of integers. >>> process_input([\\"2\\", \\"cat dog\\", \\"3\\", \\"apple banana cherry\\", \\"4\\", \\"one two three four\\", \\"0\\"]) [2, 6, 24] >>> process_input([\\"0\\"]) [] pass","solution":"import math def count_distinct_sentences(n, words): Returns the number of distinct sentences that can be formed by shuffling the words. if n == 0: return 0 return math.factorial(n) def process_input(data): results = [] i = 0 while i < len(data): n = int(data[i]) if n == 0: break words = data[i + 1].split() results.append(count_distinct_sentences(n, words)) i += 2 return results"},{"question":"from typing import List, Tuple def calculate_weighted_average(scores_and_weights: List[int]) -> float: Calculate the weighted average score given a list of scores and weights. >>> calculate_weighted_average([95, 4, 80, 2, 100, 1]) 90.0 >>> calculate_weighted_average([80, 3, 90, 4]) 86.67 >>> calculate_weighted_average([100, 1, 50, 1]) 75.0 >>> calculate_weighted_average([0, 1, 100, 1]) 50.0 def find_student_with_highest_average(n: int, students: List[List[str]]) -> str: Find the student with the highest weighted average score. >>> find_student_with_highest_average(2, [[\\"Alice\\", 3, 95, 4, 80, 2, 100, 1], [\\"Bob\\", 2, 80, 3, 90, 4]]) 'Alice' >>> find_student_with_highest_average(2, [[\\"Charlie\\", 1, 100, 5], [\\"David\\", 1, 50, 5]]) 'Charlie' >>> find_student_with_highest_average(2, [[\\"Eva\\", 2, 70, 1, 80, 1], [\\"Frank\\", 2, 60, 2, 100, 3]]) 'Frank' def main(data: str) -> str: Main function to process input data and find the student with the highest weighted average score. >>> main(\\"2nAlice 3 95 4 80 2 100 1nBob 2 80 3 90 4n\\") 'Alice' >>> main(\\"1nCharlie 1 100 5n\\") 'Charlie' >>> main(\\"2nEva 2 70 1 80 1nFrank 2 60 2 100 3n\\") 'Frank'","solution":"def calculate_weighted_average(scores_and_weights): total_weighted_score = 0 total_weight = 0 for score, weight in zip(scores_and_weights[0::2], scores_and_weights[1::2]): total_weighted_score += score * weight total_weight += weight return total_weighted_score / total_weight def find_student_with_highest_average(n, students): highest_average = -1 top_student = \\"\\" for student in students: name, m, *scores_and_weights = student average = calculate_weighted_average(scores_and_weights) if average > highest_average: highest_average = average top_student = name return top_student def main(data): lines = data.split('n') n = int(lines[0]) students = [lines[i + 1].split() for i in range(n)] for student in students: student[1] = int(student[1]) student[2:] = list(map(int, student[2:])) return find_student_with_highest_average(n, students)"},{"question":"def max_energy(N: int, values: List[int], counts: List[int], B: int) -> int: Calculate the maximum total magical energy that can be obtained by collecting the plants according to the given conditions. :param N: Number of different types of plants :param values: Magical values of each plant :param counts: Required count of each plant for the potion :param B: Maximum number of plants that can be collected :return: Maximum total magical energy pass def test_max_energy_example_case(): assert max_energy(4, [10, 20, 30, 40], [2, 3, 4, 1], 10) == 240 def test_max_energy_full_budget_usage(): assert max_energy(3, [5, 10, 15], [2, 2, 2], 6) == 60 def test_max_energy_partial_budget_usage(): assert max_energy(2, [100, 200], [100, 100], 50) == 10000 def test_max_energy_single_plant_type(): assert max_energy(1, [100], [1], 1) == 100 assert max_energy(1, [100], [500], 250) == 25000 def test_max_energy_more_plants_needed_than_budget(): assert max_energy(3, [1, 1, 1], [10000, 10000, 10000], 10) == 10","solution":"def max_energy(N, values, counts, B): Returns the maximum total magical energy that can be obtained by collecting the plants according to the constraints. :param N: int : Number of different types of plants :param values: List[int] : Magical values of each plant :param counts: List[int] : Required count of each plant for the potion :param B: int : Maximum number of plants that can be collected :return: int : Maximum total magical energy plants = [(values[i], counts[i]) for i in range(N)] # Sort plants based on their individual energy value plants.sort(reverse=True, key=lambda x: x[0]) total_energy = 0 total_plants_collected = 0 for value, count in plants: if total_plants_collected + count <= B: total_energy += value * count total_plants_collected += count else: remaining_budget = B - total_plants_collected total_energy += value * remaining_budget break return total_energy"},{"question":"def can_form_convex_polygon(points: List[Tuple[int, int]]) -> str: Given a set of points on a two-dimensional plane, determine if they can form a convex polygon. >>> can_form_convex_polygon([(0, 0), (1, 1), (1, 0), (0, 1), (2, 2)]) \\"NO\\" >>> can_form_convex_polygon([(0, 0), (1, 1), (1, 0), (0, 1)]) \\"YES\\"","solution":"def can_form_convex_polygon(points): def cross_product_orientation(p, q, r): # Compute the orientation of the triplet (p, q, r) # >0 if counterclockwise, <0 if clockwise, 0 if collinear return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0]) # Get the number of points n = len(points) if n < 3: return \\"NO\\" # Sort points by their coordinates in lexicographical order points = sorted(points) # Build the lower hull lower_hull = [] for p in points: while len(lower_hull) >= 2 and cross_product_orientation(lower_hull[-2], lower_hull[-1], p) <= 0: lower_hull.pop() lower_hull.append(p) # Build the upper hull upper_hull = [] for p in reversed(points): while len(upper_hull) >= 2 and cross_product_orientation(upper_hull[-2], upper_hull[-1], p) <= 0: upper_hull.pop() upper_hull.append(p) # Remove the last point of each half because it's duplicated at the beginning of the other half del lower_hull[-1] del upper_hull[-1] # The points forming the convex hull if combined upper and lower hull convex_hull = lower_hull + upper_hull if len(convex_hull) != n: return \\"NO\\" # Check if all points in the convex hull are given if all(point in convex_hull for point in points): return \\"YES\\" else: return \\"NO\\" # Read input def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) points = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)] print(can_form_convex_polygon(points)) # Uncomment the following lines to test with given input format # if __name__ == \\"__main__\\": # main()"},{"question":"def min_visible_boxes(test_cases: List[List[int]]) -> List[int]: Given multiple test cases of boxes, each described by the number of boxes and their side lengths, find the minimum number of visible boxes after optimization. Args: test_cases: A list of test cases, each test case is a list where the first integer represents the number of boxes, followed by the side lengths of the boxes. Returns: A list of integers where each integer corresponds to the minimum number of visible boxes for each test case. def process_input(input_data: str) -> List[List[int]]: Transform the raw input string into a list of test cases. Args: input_data: A string representing multiple test cases, each starting with an integer N followed by N integers representing box side lengths. Returns: A list of test cases where each test case is a list of integers. def main(input_data: str) -> List[int]: Process the input data and determine the minimum number of visible boxes for each test case. Args: input_data: A string representing the raw input data. Returns: A list of integers representing the minimum number of visible boxes for each test case. from typing import List def test_process_input(): input_data = \\"3n4 5 6n4n2 1 4 3n2n7 7n0n\\" expected_output = [ [3, 4, 5, 6], [4, 2, 1, 4, 3], [2, 7, 7] ] assert process_input(input_data) == expected_output def test_min_visible_boxes_1(): test_cases = [ [3, 4, 5, 6], [4, 2, 1, 4, 3], [2, 7, 7], ] assert min_visible_boxes(test_cases) == [1, 1, 2] def test_min_visible_boxes_2(): test_cases = [ [5, 1, 2, 3, 4, 5], [6, 1, 1, 1, 1, 1, 1], [6, 6, 5, 4, 3, 2, 1], ] assert min_visible_boxes(test_cases) == [1, 6, 1] def test_main(): input_data = \\"3n4 5 6n4n2 1 4 3n2n7 7n0n\\" expected_output = [1, 1, 2] assert main(input_data) == expected_output","solution":"def min_visible_boxes(test_cases): results = [] for test_case in test_cases: if test_case[0] == 0: break N, boxes = test_case[0], test_case[1:] boxes_sorted = sorted(boxes, reverse=True) visible_boxes = 0 while boxes_sorted: current_box = boxes_sorted.pop(0) visible_boxes += 1 boxes_sorted = [box for box in boxes_sorted if box >= current_box] results.append(visible_boxes) return results def process_input(input_data): lines = input_data.strip().split('n') test_cases = [] i = 0 while i < len(lines): N = int(lines[i]) if N == 0: break boxes = list(map(int, lines[i+1].split())) test_cases.append([N] + boxes) i += 2 return test_cases # To be used in actual implementation or testing def main(input_data): test_cases = process_input(input_data) return min_visible_boxes(test_cases)"},{"question":"def sum_of_unique_elements(n: int, elements: List[int]) -> int: Returns the sum of unique elements in the list 'elements'. Args: n (int): Number of elements in the list. elements (list of int): List of integers. Returns: int: Sum of unique elements. Example: >>> sum_of_unique_elements(5, [1, 2, 3, 2, 1]) 6 >>> sum_of_unique_elements(5, [-1, -2, -3, -2, -1]) -6 >>> sum_of_unique_elements(4, [0, 0, 0, 0]) 0 >>> sum_of_unique_elements(3, [1, 1, 1]) 1 >>> sum_of_unique_elements(6, [10, 20, 10, 0, -10, -20]) 0 >>> sum_of_unique_elements(5, [-5, 5, -5, 5, -5]) 0 >>> sum_of_unique_elements(1, [100]) 100 >>> sum_of_unique_elements(8, [4, 4, 4, 4, -4, -4, -4, -4]) 0","solution":"def sum_of_unique_elements(n, elements): Returns the sum of unique elements in the list 'elements'. Args: n (int): Number of elements in the list. elements (list of int): List of integers. Returns: int: Sum of unique elements. return sum(set(elements))"},{"question":"def schedule_conference(input_str: str) -> list: Determine the maximum number of non-overlapping sessions that can be scheduled. >>> schedule_conference('2n3n1 3n2 5n4 6n4n1 2n2 3n3 4n4 5n') [2, 4] >>> schedule_conference('1n1n0 1n') [1] >>> schedule_conference('1n3n1 2n2 3n3 4n') [3] >>> schedule_conference('1n3n1 5n2 5n3 5n') [1] >>> schedule_conference('3n3n1 3n2 5n4 6n2n1 4n5 6n4n1 2n2 3n3 4n4 5n') [2, 2, 4]","solution":"def max_non_overlapping_sessions(test_cases): results = [] for sessions in test_cases: # Sort sessions based on the end time sessions.sort(key=lambda x: x[1]) count = 0 last_end = -1 for start, end in sessions: if start >= last_end: count += 1 last_end = end results.append(count) return results # Function to parse input and feed to the solution function def schedule_conference(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0].strip()) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index].strip()) index += 1 sessions = [] for _ in range(n): a, b = map(int, input_lines[index].strip().split()) sessions.append((a, b)) index += 1 test_cases.append(sessions) results = max_non_overlapping_sessions(test_cases) return results"},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Process a series of queries on an integer array A of length N. Parameters: n (int): Length of the array. q (int): Number of queries. arr (List[int]): The array of integers. queries (List[Tuple[int, ...]]): A list of queries where each query can be one of the following types: * (1, X_i, V_i): Adds V_i to A_{X_i} * (2, L_i, R_i): Calculates the sum of the subarray from A_{L_i} to A_{R_i} * (3, V_i): Calculates the count of elements in the array that are greater than or equal to V_i Returns: List[int]: A list of results for each query of type 2 and 3. Examples: >>> process_queries(5, 5, [1, 2, 3, 2, 1], [(2, 1, 5), (3, 2), (1, 3, 1), (2, 2, 4), (3, 2)]) [9, 3, 8, 3] >>> process_queries(0, 1, [], [(3, 1)]) [0] >>> process_queries(1, 2, [2], [(2, 1, 1), (3, 2)]) [2, 1] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) q = int(data[1]) arr = list(map(int, data[2:2+n])) queries = [] index = 2 + n for _ in range(q): t = int(data[index]) if t == 1: x = int(data[index+1]) v = int(data[index+2]) queries.append((t, x, v)) index += 3 elif t == 2: l = int(data[index+1]) r = int(data[index+2]) queries.append((t, l, r)) index += 3 elif t == 3: v = int(data[index+1]) queries.append((t, v)) index += 2 result = process_queries(n, q, arr, queries) for res in result: print(res)","solution":"def process_queries(n, q, arr, queries): results = [] for query in queries: t = query[0] if t == 1: x, v = query[1], query[2] arr[x-1] += v elif t == 2: l, r = query[1], query[2] results.append(sum(arr[l-1:r])) elif t == 3: v = query[1] count = sum(1 for x in arr if x >= v) results.append(count) return results def process_input_output(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) q = int(data[1]) arr = list(map(int, data[2:2+n])) queries = [] index = 2 + n for _ in range(q): t = int(data[index]) if t == 1: x = int(data[index+1]) v = int(data[index+2]) queries.append((t, x, v)) index += 3 elif t == 2: l = int(data[index+1]) r = int(data[index+2]) queries.append((t, l, r)) index += 3 elif t == 3: v = int(data[index+1]) queries.append((t, v)) index += 2 result = process_queries(n, q, arr, queries) for res in result: print(res)"},{"question":"def min_checkpoints(n: int, runners: List[Tuple[int, int]]) -> int: Returns the minimum number of photo checkpoints needed so that each runner is captured at least once. :param n: Number of runners. :param runners: List of tuples containing (si, vi) for each runner. :return: Minimum number of checkpoints. pass # Example usage: # >>> min_checkpoints(3, [(5, 5), (10, 2), (15, 7)]) # 3 # >>> min_checkpoints(4, [(0, 4), (8, 3), (13, 2), (6, 5)]) # 4 from typing import List, Tuple def test_min_checkpoints_single_runner(): assert min_checkpoints(1, [(0, 1)]) == 1 def test_min_checkpoints_multiple_runners(): assert min_checkpoints(3, [(5, 5), (10, 2), (15, 7)]) == 3 assert min_checkpoints(4, [(0, 4), (8, 3), (13, 2), (6, 5)]) == 4 def test_min_checkpoints_different_starts_same_speed(): assert min_checkpoints(2, [(0, 5), (10, 5)]) == 2 def test_min_checkpoints_same_starts_different_speeds(): assert min_checkpoints(2, [(0, 5), (0, 10)]) == 2 def test_min_checkpoints_edge_case_max_runners(): assert min_checkpoints(1000, [(i, i + 1) for i in range(1000)]) == 1000","solution":"def min_checkpoints(n, runners): Returns the minimum number of photo checkpoints needed so that each runner is captured at least once. :param n: Number of runners. :param runners: List of tuples containing (si, vi) for each runner. :return: Minimum number of checkpoints. return n"},{"question":"def min_coins(amount: int) -> int: Returns the minimum number of coins needed to make up the given amount. The coin denominations used are 1, 5, 10, and 25. >>> min_coins(23) == 5 # 2 x 10 + 3 x 1 >>> min_coins(75) == 3 # 3 x 25 >>> min_coins(1) == 1 # 1 x 1 >>> min_coins(10000) == 400 # 400 x 25 >>> min_coins(30) == 2 # 1 x 25 + 1 x 5 >>> min_coins(41) == 4 # 1 x 25 + 1 x 10 + 1 x 5 + 1 x 1","solution":"def min_coins(amount): Returns the minimum number of coins needed to make up the given amount. The coin denominations used are 1, 5, 10, and 25. coins = [25, 10, 5, 1] count = 0 for coin in coins: count += amount // coin amount %= coin return count"},{"question":"def count_unique_problems(N: int, ranges: List[Tuple[int, int]]) -> int: Calculate the number of unique problems covered by at least one participant. Args: N (int): Number of participants. ranges (List[Tuple[int, int]]): List of tuples where each tuple contains two integers (S_i, E_i) representing the range of problems each participant can solve. Returns: int: Number of unique problems covered. Example: >>> count_unique_problems(3, [(1, 4), (3, 6), (5, 8)]) 8 >>> count_unique_problems(2, [(2, 5), (7, 10)]) 8 >>> count_unique_problems(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 from typing import List, Tuple def test_count_unique_problems_case1(): assert count_unique_problems(3, [(1, 4), (3, 6), (5, 8)]) == 8 def test_count_unique_problems_case2(): assert count_unique_problems(2, [(2, 5), (7, 10)]) == 8 def test_count_unique_problems_case3(): assert count_unique_problems(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 5 def test_count_unique_problems_one_participant(): assert count_unique_problems(1, [(1, 100)]) == 100 def test_count_unique_problems_disjoint_ranges(): assert count_unique_problems(3, [(1, 2), (5, 6), (9, 10)]) == 6 def test_count_unique_problems_same_range_multiple_times(): assert count_unique_problems(3, [(1, 2), (1, 2), (1, 2)]) == 2","solution":"def count_unique_problems(N, ranges): problems_covered = set() for r in ranges: S, E = r problems_covered.update(range(S, E + 1)) return len(problems_covered) # Example of usage: # N = 3 # ranges = [(1, 4), (3, 6), (5, 8)] # print(count_unique_problems(N, ranges)) # Output should be 8"},{"question":"def largest_open_square(n: int, m: int, grid: List[str]) -> int: Determine the side length of the largest square that can be placed within open cells in the warehouse grid. >>> largest_open_square(5, 6, [\\"....#.\\", \\"#.....\\", \\"......\\", \\"#...\\", \\".#...#\\"]) 3 >>> largest_open_square(1, 1, [\\".\\"]) 1 >>> largest_open_square(1, 1, [\\"#\\"]) 0 >>> largest_open_square(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 4 >>> largest_open_square(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) 0 >>> largest_open_square(4, 5, [\\".....\\", \\".....\\", \\"..#..\\", \\".....\\"]) 2 >>> largest_open_square(10, 10, [\\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\"]) 10","solution":"def largest_open_square(n, m, grid): if n == 0 or m == 0: return 0 dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def detect_soldiers_pattern(grid, m, n): A function to determine if the pattern condition is satisfied for each row and column in the grid. >>> detect_soldiers_pattern([ '10101', '01110', '11011', '00101' ], 4, 5) \\"YES\\" >>> detect_soldiers_pattern([ '00000', '00000', '00000', '00000' ], 4, 5) \\"NO\\" >>> detect_soldiers_pattern([ '11100', '00111', '00011', '11000' ], 4, 5) \\"YES\\" >>> detect_soldiers_pattern([ '101', '101', '101' ], 3, 3) \\"YES\\" >>> detect_soldiers_pattern([ '100', '010', '001' ], 3, 3) \\"NO\\" >>> detect_soldiers_pattern([ '0000000000', '1100000000', '0011000000', '0000110000', '0000001100', '0000000011' ], 6, 10) \\"YES\\"","solution":"def detect_soldiers_pattern(grid, m, n): def has_two_out_of_three_consecutive(s): for i in range(len(s) - 2): if s[i:i+3].count('1') >= 2: return True return False # Check rows for row in grid: if has_two_out_of_three_consecutive(row): return \\"YES\\" # Check columns for col in range(n): column = ''.join(grid[row][col] for row in range(m)) if has_two_out_of_three_consecutive(column): return \\"YES\\" return \\"NO\\""},{"question":"def can_organize_books(n: int, m: int, capacities: List[int], heights: List[int]) -> str: Determine if it is possible to organize the books on the shelves according to the given rules. >>> can_organize_books(3, 5, [2, 2, 1], [3, 5, 1, 2, 4]) 'YES' >>> can_organize_books(2, 4, [1, 2], [5, 6, 7, 1]) 'NO'","solution":"def can_organize_books(n, m, capacities, heights): capacities.sort(reverse=True) heights.sort() capacity_idx = 0 for height in heights: if capacity_idx >= n: return \\"NO\\" if capacities[capacity_idx] > 0: capacities[capacity_idx] -= 1 else: capacity_idx += 1 if capacity_idx >= n or capacities[capacity_idx] == 0: return \\"NO\\" capacities[capacity_idx] -= 1 return \\"YES\\""},{"question":"def minimum_difference(weights): Returns the minimal possible absolute difference between the sums of two subarrays. Parameters: weights (List[int]): A list of positive integers representing weights. Returns: int: The minimum possible absolute difference between the sums of the subarrays. Examples: >>> minimum_difference([4, 1, 2, 3, 6]) 0 >>> minimum_difference([10, 20, 15]) 5","solution":"def minimum_difference(weights): Returns the minimal possible absolute difference between the sums of two subarrays. total_sum = sum(weights) n = len(weights) # Initialize a DP array to keep track of possible sums dp = [False] * (total_sum // 2 + 1) dp[0] = True # Populate the DP array for weight in weights: for j in range(total_sum // 2, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] # Find the largest possible value in dp array for j in range(total_sum // 2, -1, -1): if dp[j]: sum1 = j break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"def check_lottery_ticket(T: int) -> str: Checks if a lottery ticket number is 'LUCKY' or 'UNLUCKY'. >>> check_lottery_ticket(123321) 'LUCKY' >>> check_lottery_ticket(123456) 'UNLUCKY'","solution":"def check_lottery_ticket(T): Checks if a lottery ticket number is 'LUCKY' or 'UNLUCKY'. Parameters: T (int): The lottery ticket number (must be 6 digits). Returns: str: 'LUCKY' if the ticket is lucky, 'UNLUCKY' otherwise. # Convert the number to a string str_t = str(T) # Ensure the number has exactly 6 digits if len(str_t) != 6: return 'UNLUCKY' # Calculate the sum of the first three digits and the last three digits first_half_sum = sum(int(digit) for digit in str_t[:3]) second_half_sum = sum(int(digit) for digit in str_t[3:]) # Determine if the ticket is lucky if first_half_sum == second_half_sum: return 'LUCKY' else: return 'UNLUCKY'"},{"question":"def minimum_deletions_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the given string a palindrome. Examples: >>> minimum_deletions_palindrome(\\"abcca\\") 1 >>> minimum_deletions_palindrome(\\"abcdef\\") 5 >>> minimum_deletions_palindrome(\\"a\\") 0 >>> minimum_deletions_palindrome(\\"aa\\") 0 >>> minimum_deletions_palindrome(\\"ab\\") 1 >>> minimum_deletions_palindrome(\\"aba\\") 0 >>> minimum_deletions_palindrome(\\"abcba\\") 0 >>> minimum_deletions_palindrome(\\"abcbad\\") 1 >>> minimum_deletions_palindrome(\\"aabb\\") 2 >>> minimum_deletions_palindrome(\\"abcdeedcba\\") 0 pass","solution":"def minimum_deletions_palindrome(s): Returns the minimum number of deletions required to make the given string a palindrome. n = len(s) # Create a dp array where dp[i][j] will store the length of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Each single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Check palindromic subsequences of length 2 to n for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # The length of the longest palindromic subsequence lps = dp[0][n - 1] # The minimum deletions required is the total length minus the length of the LPS return n - lps"},{"question":"def trapRainWater(elevations): Computes the total amount of water trapped between the elevations after rainfall. Parameters: elevations (list of int): Array representing the heights at various points. Returns: int: Total units of trapped water. pass # Unit tests def test_trap_rain_water_example1(): assert trapRainWater([0, 1, 2, 1, 0, 1]) == 1 def test_trap_rain_water_example2(): assert trapRainWater([3, 2, 1, 2, 3]) == 4 def test_trap_rain_water_example3(): assert trapRainWater([4, 2, 0, 3, 2, 5]) == 9 def test_trap_rain_water_no_valleys(): assert trapRainWater([3, 3, 3, 3, 3]) == 0 def test_trap_rain_water_plateaus(): assert trapRainWater([1, 0, 2, 0, 2, 0, 1]) == 4 def test_trap_rain_water_single_element(): assert trapRainWater([1]) == 0 def test_trap_rain_water_two_different_elements(): assert trapRainWater([1, 2]) == 0 def test_trap_rain_water_descending_order(): assert trapRainWater([5, 4, 3, 2, 1]) == 0 def test_trap_rain_water_ascending_order(): assert trapRainWater([1, 2, 3, 4, 5]) == 0","solution":"def trapRainWater(elevations): Computes the total amount of water trapped between the elevations after rainfall. Parameters: elevations (list of int): Array representing the heights at various points. Returns: int: Total units of trapped water. if not elevations: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevations[i]) right_max[n - 1] = elevations[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevations[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - elevations[i] return water_trapped"},{"question":"def minimum_nuts_needed(N: int, M: int) -> int: Determines the minimum number of nuts needed so that every squirrel can have at least one. Returns -1 if it's not possible to satisfy all squirrels. Parameters: N (int): Number of squirrels M (int): Number of nuts Returns: int: Minimum number of nuts needed or -1 if not possible Examples: >>> minimum_nuts_needed(5, 8) 5 >>> minimum_nuts_needed(3, 2) -1 >>> minimum_nuts_needed(6, 0) -1 >>> minimum_nuts_needed(7, 7) 7 >>> minimum_nuts_needed(1000000000, 1000000000) 1000000000 >>> minimum_nuts_needed(1000000000, 999999999) -1","solution":"def minimum_nuts_needed(N, M): Determines the minimum number of nuts needed so that every squirrel can have at least one. Returns -1 if it's not possible to satisfy all squirrels. Parameters: N (int): Number of squirrels M (int): Number of nuts Returns: int: Minimum number of nuts needed or -1 if not possible if M < N: return -1 return N"},{"question":"def determine_identity(A_status: int, B_status: int, C_status: int) -> str: Determines the identity of A, B, and C as either Knights or Knaves based on their statements and their given statuses. Args: A_status (int): Status of A, 1 for Knight, 0 for Knave. B_status (int): Status of B, 1 for Knight, 0 for Knave. C_status (int): Status of C, 1 for Knight, 0 for Knave. Returns: str: A string stating the identity of A, B, and C. >>> determine_identity(0, 1, 0) 'A:Knave B:Knight C:Knave' >>> determine_identity(1, 0, 1) 'A:Knight B:Knave C:Knight'","solution":"def determine_identity(A_status, B_status, C_status): Determines the identity of A, B, and C as either Knights or Knaves based on their statements and their given statuses. Args: A_status (int): Status of A, 1 for Knight, 0 for Knave. B_status (int): Status of B, 1 for Knight, 0 for Knave. C_status (int): Status of C, 1 for Knight, 0 for Knave. Returns: str: A string stating the identity of A, B, and C. A_identity = \\"Knight\\" if A_status == 1 else \\"Knave\\" B_identity = \\"Knight\\" if B_status == 1 else \\"Knave\\" C_identity = \\"Knight\\" if C_status == 1 else \\"Knave\\" return f\\"A:{A_identity} B:{B_identity} C:{C_identity}\\""},{"question":"def min_operations_to_symmetrical(S: str) -> int: Returns the minimum number of operations required to make the string S symmetrical. >>> min_operations_to_symmetrical(\\"abc\\") 1 >>> min_operations_to_symmetrical(\\"abca\\") 1 >>> min_operations_to_symmetrical(\\"racecar\\") 0 >>> min_operations_to_symmetrical(\\"abcdefgh\\") 4","solution":"def min_operations_to_symmetrical(S): Returns the minimum number of operations required to make the string S symmetrical. n = len(S) operations = 0 for i in range(n // 2): if S[i] != S[n - 1 - i]: operations += 1 return operations"},{"question":"def count_invalid_logouts(logs: List[str]) -> int: Processes the event logs to count the number of invalid logout attempts. Args: logs: List of strings representing the event logs. Returns: int: The number of invalid logout attempts. >>> count_invalid_logouts([ ... \\"login user1\\", ... \\"login user2\\", ... \\"logout user2\\", ... \\"logout user1\\", ... \\"logout user1\\", ... \\"STOP\\"]) == 1 >>> count_invalid_logouts([ ... \\"login user1\\", ... \\"logout user1\\", ... \\"logout user2\\", ... \\"STOP\\"]) == 1 >>> count_invalid_logouts([ ... \\"login user1\\", ... \\"login user2\\", ... \\"logout user2\\", ... \\"STOP\\"]) == 0 >>> count_invalid_logouts([ ... \\"logout user1\\", ... \\"STOP\\"]) == 1 >>> count_invalid_logouts([ ... \\"login user1\\", ... \\"login user2\\", ... \\"logout user2\\", ... \\"logout user2\\", ... \\"login user1\\", ... \\"STOP\\"]) == 1","solution":"def count_invalid_logouts(logs): Processes the event logs to count the number of invalid logout attempts. logged_in_users = set() invalid_logouts = 0 for log in logs: if log == \\"STOP\\": break action, user_id = log.split() if action == \\"login\\": logged_in_users.add(user_id) elif action == \\"logout\\": if user_id in logged_in_users: logged_in_users.remove(user_id) else: invalid_logouts += 1 return invalid_logouts"},{"question":"def unique_subarrays_count(n: int, array: List[int]) -> int: Returns the count of all unique non-empty subarrays in the given array. Parameters: n (int): The length of the array. array (List[int]): The list of integers representing the array elements. Returns: int: The count of all unique non-empty subarrays in the given array. Example Usage: >>> unique_subarrays_count(5, [2, 1, 2, 3, 2]) 15 >>> unique_subarrays_count(1, [1]) 1","solution":"def unique_subarrays_count(n, array): Returns the count of all unique non-empty subarrays in the given array. count = 0 for i in range(n): for j in range(i, n): count += 1 return count"},{"question":"def max_path_sum(n: int, grid: List[List[int]]) -> int: Calculate the maximum sum of numbers collected from the top-left corner to the bottom-right corner only moving right or down. Parameters: n (int): The size of the grid. grid (List[List[int]]): The grid of integers. Returns: int: The maximum sum of numbers collected. >>> max_path_sum(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_path_sum(2, [[1, 2], [1, 2]]) 5","solution":"def max_path_sum(n, grid): Calculate the maximum sum of numbers collected from the top-left corner to the bottom-right corner only moving right or down. Parameters: n (int): The size of the grid. grid (List[List[int]]): The grid of integers. Returns: int: The maximum sum of numbers collected. # Create a DP table to store the maximum sum at each cell dp = [[0] * n for _ in range(n)] # Initialize the top-left corner with the first cell value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"def assign_tasks_to_servers(server_data: List[Tuple[int, int]], tasks: List[int]) -> List[Tuple[int, int]]: Given a list of servers and their capacities, as well as a list of incoming tasks, simulate the process of assigning tasks to servers in a round-robin fashion. Args: - server_data: A list of tuples, where each tuple contains two integers, ID and capacity of a server. - tasks: A list of integers representing the IDs of incoming tasks to be assigned to servers in the order they arrive. Returns: A list of tuples representing the final count of tasks assigned to each server, in the order of server IDs. >>> assign_tasks_to_servers([(101, 3), (102, 2), (103, 1)], [1, 2, 3, 4, 5]) [(101, 2), (102, 2), (103, 1)] >>> assign_tasks_to_servers([(1, 5), (2, 5)], [1, 2, 3]) [(1, 2), (2, 1)] >>> assign_tasks_to_servers([(1, 1), (2, 1), (3, 1)], [1, 2, 3, 4]) [(1, 2), (2, 1), (3, 1)] >>> assign_tasks_to_servers([(101, 2)], [1, 2, 3, 4]) [(101, 4)] >>> assign_tasks_to_servers([(50, 2), (70, 3)], [5, 6, 7, 8, 9, 10, 11]) [(50, 4), (70, 3)]","solution":"def assign_tasks_to_servers(server_data, tasks): # Sort the servers by ID servers = sorted(server_data, key=lambda x: x[0]) # Initialize task count for each server ID task_counts = {server_id: 0 for server_id, _ in servers} # Initialize current server index and track the total servers count current_server_index = 0 server_count = len(servers) # Iterate through tasks and assign them in round-robin fashion for task in tasks: # Find the current server server_id, capacity = servers[current_server_index] # Assign the task to the current server task_counts[server_id] += 1 # Move to the next server current_server_index = (current_server_index + 1) % server_count # Prepare the result as a list of tuples and sort by server ID result = [(server_id, task_counts[server_id]) for server_id, _ in servers] return result"},{"question":"def can_form_palindrome(number: str) -> str: Returns \\"YES\\" if the given number's digits can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(\\"12321\\") \\"YES\\" >>> can_form_palindrome(\\"123\\") \\"NO\\" >>> can_form_palindrome(\\"112233\\") \\"YES\\" def process_input(T: int, numbers: List[str]) -> List[str]: Processes multiple test cases and determines for each number if it can be rearranged to form a palindrome. >>> process_input(3, [\\"12321\\", \\"123\\", \\"112233\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_input(2, [\\"1111\\", \\"9889\\"]) [\\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(number): Returns \\"YES\\" if the given number's digits can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter # Count the frequency of each digit in the number digit_count = Counter(number) # Check how many digits have an odd count odd_count = sum(1 for count in digit_count.values() if count % 2 != 0) # A number can be arranged as a palindrome if it has at most one digit with an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\" def process_input(T, numbers): results = [] for number in numbers: results.append(can_form_palindrome(number)) return results"},{"question":"def check_permutation_substring(n: int, original_string: str, queries: List[str]) -> List[str]: You are given a string consisting of lowercase Latin letters and several queries. For each query, you are given a substring and asked to check if any permutation of this substring appears as a contiguous part of the original string. >>> check_permutation_substring(5, \\"abcde\\", [\\"bca\\", \\"aec\\", \\"ed\\"]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> check_permutation_substring(1, \\"a\\", [\\"a\\", \\"b\\"]) [\\"Yes\\", \\"No\\"] >>> check_permutation_substring(3, \\"abc\\", [\\"abc\\", \\"bca\\", \\"cab\\"]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> check_permutation_substring(3, \\"xyz\\", [\\"abc\\", \\"yyy\\", \\"zzz\\"]) [\\"No\\", \\"No\\", \\"No\\"] >>> check_permutation_substring(6, \\"abcdef\\", [\\"abcd\\",\\"dabc\\",\\"eabc\\",\\"abcdefg\\"]) [\\"Yes\\", \\"Yes\\", \\"No\\", \\"No\\"]","solution":"def check_permutation_substring(n, original_string, queries): from collections import Counter def is_permutation_in_string(small, big): small_len = len(small) big_len = len(big) if small_len > big_len: return False small_counter = Counter(small) window_counter = Counter(big[:small_len]) if small_counter == window_counter: return True for i in range(small_len, big_len): window_counter[big[i - small_len]] -= 1 if window_counter[big[i - small_len]] == 0: del window_counter[big[i - small_len]] window_counter[big[i]] += 1 if window_counter == small_counter: return True return False results = [] for query in queries: if is_permutation_in_string(query, original_string): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def draw_filled_rectangle(width, height): Generate a filled rectangle of given width and height using asterisks ('*'). Args: width (int): The width of the rectangle. height (int): The height of the rectangle. Returns: str: A string representation of the filled rectangle. Examples: >>> draw_filled_rectangle(2, 2) '**n**' >>> draw_filled_rectangle(5, 3) '*****n*****n*****'","solution":"def draw_filled_rectangle(width, height): Generates a filled rectangle of given width and height using asterisks ('*'). Args: width (int): The width of the rectangle. height (int): The height of the rectangle. Returns: str: A string representation of the filled rectangle. rectangle = [] for _ in range(height): rectangle.append('*' * width) return 'n'.join(rectangle)"},{"question":"def process_queries(n: int, q: int, a: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Processes the queries on the array a and returns the result of sum queries. Args: n: (int) the size of the array. q: (int) number of queries. a: (list of int) initial array. queries: (list of tuples) list of queries to perform. Returns: list of int: results of the sum queries. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 2, 4, 3), (2, 1, 5), (2, 3, 5)]) [21, 15] results = [] for query in queries: if query[0] == 1: _, l, r, v = query for i in range(l - 1, r): a[i] += v else: _, l, r = query results.append(sum(a[l - 1:r])) return results","solution":"def process_queries(n, q, a, queries): Processes the queries on the array a and returns the result of sum queries. Args: n: (int) the size of the array. q: (int) number of queries. a: (list of int) initial array. queries: (list of tuples) list of queries to perform. Returns: list of int: results of the sum queries. results = [] for query in queries: if query[0] == 1: _, l, r, v = query for i in range(l - 1, r): a[i] += v else: _, l, r = query results.append(sum(a[l - 1:r])) return results"},{"question":"from typing import List def game_points_simulation(actions: List[str]) -> List[int]: Simulates a series of actions on a player's game points and returns the points after each action. The game supports the following actions: - ADD X: Increases the number of points by X (1 ≤ X ≤ 1000). - SUBTRACT X: Decreases the number of points by X (1 ≤ X ≤ 1000). The player's points cannot go below 0. - MULTIPLY X: Multiplies the number of points by X (1 ≤ X ≤ 10). - DIVIDE X: Divides the number of points by X (1 ≤ X ≤ 10). This operation uses integer division. Args: actions (List[str]): A list of action strings. Returns: List[int]: A list of integers representing the points after each respective action. Examples: >>> game_points_simulation([\\"ADD 5\\", \\"MULTIPLY 2\\", \\"SUBTRACT 4\\", \\"DIVIDE 3\\", \\"ADD 10\\"]) [5, 10, 6, 2, 12] >>> game_points_simulation([\\"ADD 8\\", \\"SUBTRACT 10\\"]) [8, 0]","solution":"def game_points_simulation(actions): points = 0 results = [] for action in actions: command, value = action.split() value = int(value) if command == \\"ADD\\": points += value elif command == \\"SUBTRACT\\": points = max(0, points - value) elif command == \\"MULTIPLY\\": points *= value elif command == \\"DIVIDE\\": points //= value results.append(points) return results"},{"question":"class TreeNode: def __init__(self, key): Node class for AVL Tree self.key = key self.height = 1 self.left = None self.right = None class AVLTree: def getHeight(self, node): Returns the height of the node. pass def getBalance(self, node): Returns the balance factor of the node. pass def rightRotate(self, y): Performs right rotation. pass def leftRotate(self, x): Performs left rotation. pass def insert(self, root, key): Inserts a key into the AVL tree. pass def minValueNode(self, node): Returns the node with the minimum value found in the tree. pass def delete(self, root, key): Deletes a key from the AVL tree. pass def search(self, root, key): Searches for a key in the AVL tree. pass def process_operations(operations): Processes a list of operations on the AVL tree. pass def test_avl_tree_insert_search(): avl_tree = AVLTree() root = None root = avl_tree.insert(root, 10) root = avl_tree.insert(root, 20) root = avl_tree.insert(root, 30) assert avl_tree.search(root, 10) == True assert avl_tree.search(root, 20) == True assert avl_tree.search(root, 30) == True assert avl_tree.search(root, 40) == False def test_avl_tree_delete(): avl_tree = AVLTree() root = None root = avl_tree.insert(root, 10) root = avl_tree.insert(root, 20) root = avl_tree.insert(root, 30) root = avl_tree.delete(root, 20) assert avl_tree.search(root, 20) == False assert avl_tree.search(root, 10) == True assert avl_tree.search(root, 30) == True def test_process_operations(): operations = [ \\"Insert 5\\", \\"Insert 15\\", \\"Search 5\\", \\"Insert 10\\", \\"Search 15\\", \\"Search 7\\", \\"Delete 15\\", \\"Search 15\\", \\"Insert 7\\", \\"Search 7\\" ] assert process_operations(operations) == [\\"Found\\", \\"Found\\", \\"Not Found\\", \\"Not Found\\", \\"Found\\"]","solution":"class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AVLTree: def getHeight(self, node): if not node: return 0 return node.height def getBalance(self, node): if not node: return 0 return self.getHeight(node.left) - self.getHeight(node.right) def rightRotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = max(self.getHeight(y.left), self.getHeight(y.right)) + 1 x.height = max(self.getHeight(x.left), self.getHeight(x.right)) + 1 return x def leftRotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = max(self.getHeight(x.left), self.getHeight(x.right)) + 1 y.height = max(self.getHeight(y.left), self.getHeight(y.right)) + 1 return y def insert(self, root, key): if not root: return TreeNode(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = max(self.getHeight(root.left), self.getHeight(root.right)) + 1 balance = self.getBalance(root) if balance > 1 and key < root.left.key: return self.rightRotate(root) if balance < -1 and key > root.right.key: return self.leftRotate(root) if balance > 1 and key > root.left.key: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.key: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def minValueNode(self, node): current = node while current.left: current = current.left return current def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = self.minValueNode(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if not root: return root root.height = max(self.getHeight(root.left), self.getHeight(root.right)) + 1 balance = self.getBalance(root) if balance > 1 and self.getBalance(root.left) >= 0: return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) <= 0: return self.leftRotate(root) if balance > 1 and self.getBalance(root.left) < 0: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) > 0: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def search(self, root, key): if not root: return False if key == root.key: return True elif key < root.key: return self.search(root.left, key) else: return self.search(root.right, key) def process_operations(operations): avl_tree = AVLTree() root = None output = [] for operation in operations: op_parts = operation.split() cmd = op_parts[0] value = int(op_parts[1]) if cmd == \\"Insert\\": root = avl_tree.insert(root, value) elif cmd == \\"Delete\\": root = avl_tree.delete(root, value) elif cmd == \\"Search\\": found = avl_tree.search(root, value) if found: output.append(\\"Found\\") else: output.append(\\"Not Found\\") return output"},{"question":"def fair_cookie_distribution(n: int, m: int) -> (int, int): Returns the maximum and minimum number of cookies a person can get in the fairest distribution possible. >>> fair_cookie_distribution(10, 3) (4, 3) >>> fair_cookie_distribution(12, 4) (3, 3) >>> fair_cookie_distribution(7, 1) (7, 7) >>> fair_cookie_distribution(5, 5) (1, 1) >>> fair_cookie_distribution(5, 10) (1, 0)","solution":"def fair_cookie_distribution(n, m): Returns the maximum and minimum number of cookies a person can get in the fairest distribution possible. if m == 0: return 0, 0 min_cookies = n // m max_cookies = min_cookies + (1 if n % m != 0 else 0) return max_cookies, min_cookies"},{"question":"def smallest_number_of_storage_units(a: int, b: int) -> int: Returns the smallest number of storage units required to form the storage module with a capacity of the irreducible fraction a / b. >>> smallest_number_of_storage_units(1, 1) == 1 >>> smallest_number_of_storage_units(5, 3) == 5 >>> smallest_number_of_storage_units(17, 4) == 17 from solution import smallest_number_of_storage_units def test_example_cases(): assert smallest_number_of_storage_units(1, 1) == 1 assert smallest_number_of_storage_units(5, 3) == 5 assert smallest_number_of_storage_units(17, 4) == 17 def test_general_cases(): assert smallest_number_of_storage_units(2, 1) == 2 assert smallest_number_of_storage_units(23, 7) == 23 assert smallest_number_of_storage_units(9, 5) == 9 def test_large_numbers(): assert smallest_number_of_storage_units(10**18, 1) == 10**18 assert smallest_number_of_storage_units(999999937, 999999929) == 999999937 assert smallest_number_of_storage_units(10**18, 10**17) == 10**18","solution":"def smallest_number_of_storage_units(a, b): Returns the smallest number of storage units required to form the storage module with a capacity of the irreducible fraction a / b. return a"},{"question":"def can_form_palindrome(s: str) -> str: Determines if any permutation of the given string s can form a palindrome. :param s: input string :return: 'yes' if a permutation can form a palindrome, 'no' otherwise >>> can_form_palindrome(\\"Tact Coa\\") == 'yes' >>> can_form_palindrome(\\"Able was I ere I saw Elba\\") == 'yes' >>> can_form_palindrome(\\"not a palindrome\\") == 'no' >>> can_form_palindrome(\\"No lemon, no melon\\") == 'yes' pass def process_input(input_lines: List[str]) -> List[str]: Processes the input lines and returns the corresponding outputs. :param input_lines: list of input strings :return: list of results for each input string >>> input_lines = [\\"Tact Coa\\", \\"Able was I ere I saw Elba\\", \\"not a palindrome\\", \\"No lemon, no melon\\", \\".\\"] >>> process_input(input_lines) == ['yes', 'yes', 'no', 'yes'] pass","solution":"def can_form_palindrome(s): Determines if any permutation of the given string s can form a palindrome. :param s: input string :return: 'yes' if a permutation can form a palindrome, 'no' otherwise from collections import Counter # Remove spaces and convert to lowercase cleaned_s = ''.join(filter(str.isalnum, s)).lower() # Count character frequencies char_count = Counter(cleaned_s) # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return 'yes' if odd_count <= 1 else 'no' def process_input(input_lines): results = [] for line in input_lines: if line.strip() == '.': break result = can_form_palindrome(line) results.append(result) return results"},{"question":"def has_dip(prices: List[int]) -> bool: Determine if there exists a dip in the given list of stock prices. A dip is a period of consecutive decreases followed by a consecutive increase. Parameters: prices (list of int): list of stock prices on consecutive days Returns: bool: True if a dip exists, otherwise False >>> has_dip([7, 8, 5, 3, 4, 9, 10]) True >>> has_dip([1, 2, 3, 4, 5, 6]) False >>> has_dip([4, 4, 4, 3, 3, 3, 2, 1, 2, 3, 4]) True","solution":"def has_dip(prices): Determine if there exists a dip in the given list of stock prices. A dip is a period of consecutive decreases followed by a consecutive increase. Parameters: prices (list of int): list of stock prices on consecutive days Returns: bool: True if a dip exists, otherwise False n = len(prices) if n < 3: return False decreasing = False increasing = False for i in range(1, n): if prices[i] < prices[i-1]: if increasing: return True decreasing = True elif prices[i] > prices[i-1]: if decreasing: increasing = True return decreasing and increasing"},{"question":"def max_cooperating_pairs(n: int, k: int, d: int, energy_levels: List[int]) -> int: Determine the maximum number of cooperating pairs based on the given constraints. Parameters: n (int): The number of students. k (int): The required distance for cooperation. d (int): The maximum energy difference for cooperation. energy_levels (list): The energy levels of the students. Returns: int: The maximum number of cooperating pairs. Examples: >>> max_cooperating_pairs(5, 1, 2, [4, 7, 5, 6, 8]) 2 >>> max_cooperating_pairs(6, 2, 3, [1, 2, 3, 4, 5, 6]) 2 >>> max_cooperating_pairs(4, 1, 0, [1, 5, 3, 7]) 0","solution":"def max_cooperating_pairs(n, k, d, energy_levels): Determine the maximum number of cooperating pairs. Parameters: n (int): The number of students. k (int): The required distance for cooperation. d (int): The maximum energy difference for cooperation. energy_levels (list): The energy levels of the students. Returns: int: The maximum number of cooperating pairs. cooperating_pairs = 0 visited = [False] * n for i in range(n): if i + k < n and not visited[i] and not visited[i + k] and abs(energy_levels[i] - energy_levels[i + k]) <= d: cooperating_pairs += 1 visited[i] = True visited[i + k] = True return cooperating_pairs"},{"question":"def sum_of_even_numbers(arr: List[int]) -> int: Returns the sum of all the even numbers in the given array. Parameters: arr (list of int): The input array of integers. Returns: int: The sum of all even numbers in the array. >>> sum_of_even_numbers([2, 4, 6, 8]) 20 >>> sum_of_even_numbers([1, 3, 5, 7]) 0 >>> sum_of_even_numbers([1, 2, 3, 4, 5]) 6 >>> sum_of_even_numbers([2]) 2 >>> sum_of_even_numbers([1]) 0 >>> sum_of_even_numbers([-2, -3, 4, 5, -6]) -4 >>> sum_of_even_numbers([0, 1, 2, 3, 4]) 6","solution":"def sum_of_even_numbers(arr): Returns the sum of all the even numbers in the given array. Parameters: arr (list of int): The input array of integers. Returns: int: The sum of all even numbers in the array. return sum(x for x in arr if x % 2 == 0)"},{"question":"def complete_roundabouts(m: int, n: int, grid: List[List[str]]) -> List[str]: Given a grid with some pre-placed roundabouts ('1'), complete the grid such that every row and column has exactly one roundabout. :param m: Number of rows in the grid :param n: Number of columns in the grid :param grid: List of lists representing the initial state of the grid ('0' for no roundabout, '1' for roundabout) :return: List of strings representing the completed grid with exactly one roundabout per row and column >>> complete_roundabouts(3, 3, [['0', '0', '1'], ['0', '0', '0'], ['0', '1', '0']]) ['001', '100', '010'] >>> complete_roundabouts(4, 4, [['0', '0', '0', '0'], ['0', '1', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '0', '0']]) ['1000', '0100', '0010', '0001'] import pytest from solution import complete_roundabouts def test_example_1(): grid = [ ['0', '0', '1'], ['0', '0', '0'], ['0', '1', '0'] ] result = complete_roundabouts(3, 3, grid) expected = [ '001', '100', '010' ] assert result == expected def test_example_2(): grid = [ ['0', '0', '0', '0'], ['0', '1', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '0', '0'] ] result = complete_roundabouts(4, 4, grid) expected = [ '1000', '0100', '0010', '0001' ] assert result == expected def test_no_preplaced(): grid = [ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ] result = complete_roundabouts(3, 3, grid) # Multiple solutions acceptable, check presence of single '1' in each row and column assert sum(row.count('1') for row in result) == 3 assert all(result[i].count('1') == 1 for i in range(3)) assert all(any(result[i][j] == '1' for i in range(3)) for j in range(3)) def test_almost_full(): grid = [ ['1', '0', '0'], ['0', '1', '0'], ['0', '0', '0'] ] result = complete_roundabouts(3, 3, grid) expected = [ '100', '010', '001' ] assert result == expected def test_large_grid(): grid = [['0'] * 1000 for _ in range(1000)] grid[0][999] = '1' result = complete_roundabouts(1000, 1000, grid) assert result[0][999] == '1' for i in range(1000): assert result[i].count('1') == 1 for j in range(1000): assert any(result[i][j] == '1' for i in range(1000))","solution":"def complete_roundabouts(m, n, grid): # Identify pre-placed roundabouts rows_with_roundabouts = [False] * m cols_with_roundabouts = [False] * n rounds_taken = set() for i in range(m): for j in range(n): if grid[i][j] == '1': rows_with_roundabouts[i] = True cols_with_roundabouts[j] = True rounds_taken.add((i, j)) # Fill the remaining roundabouts for i in range(m): if not rows_with_roundabouts[i]: for j in range(n): if not cols_with_roundabouts[j]: grid[i][j] = '1' rows_with_roundabouts[i] = True cols_with_roundabouts[j] = True rounds_taken.add((i, j)) break # Convert the set to list of list for output return [''.join(row) for row in grid]"},{"question":"def min_operations_to_equal_heights(n: int, heights: List[int]) -> int: Returns the minimum number of operations required to make all building heights equal. Parameters: n (int): Number of buildings. heights (list of int): List of heights of the buildings. Returns: int: Minimum number of operations. pass # Test cases from solution import min_operations_to_equal_heights def test_min_operations_to_equal_heights_single_building(): assert min_operations_to_equal_heights(1, [5]) == 0 def test_min_operations_to_equal_heights_already_equal(): assert min_operations_to_equal_heights(5, [5, 5, 5, 5, 5]) == 0 def test_min_operations_to_equal_heights_case1(): assert min_operations_to_equal_heights(3, [1, 2, 3]) == 2 def test_min_operations_to_equal_heights_case2(): assert min_operations_to_equal_heights(4, [1, 2, 8, 9]) == 14 def test_min_operations_to_equal_heights_case3(): assert min_operations_to_equal_heights(5, [1, 3, 3, 3, 3]) == 2 def test_min_operations_to_equal_heights_case4(): assert min_operations_to_equal_heights(2, [1, 100]) == 99","solution":"def min_operations_to_equal_heights(n, heights): Returns the minimum number of operations required to make all building heights equal. Parameters: n (int): Number of buildings. heights (list of int): List of heights of the buildings. Returns: int: Minimum number of operations. if n == 1: return 0 median_height = sorted(heights)[n // 2] operations = sum(abs(height - median_height) for height in heights) return operations"},{"question":"def max_trees_catch_fire(M: int, initial_strength: int, S: int, F: List[int]) -> int: Returns the maximum number of trees that can catch fire given the initial conditions. Parameters: M (int): Number of trees initial_strength (int): Initial strength of the fire S (int): Starting tree index (1-based) F (List[int]): List of fire resistance values for each tree Returns: int: Maximum number of trees that can catch fire Examples: >>> max_trees_catch_fire(5, 6, 3, [4, 7, 5, 2, 3]) 3 >>> max_trees_catch_fire(4, 8, 1, [5, 6, 10, 3]) 2","solution":"def max_trees_catch_fire(M, initial_strength, S, F): Returns the maximum number of trees that can catch fire given the initial conditions. # Adjust index to be 0 based S = S - 1 # Strength of fire left_strength = initial_strength right_strength = initial_strength # Initialize count of trees that catch fire count = 0 # Spread fire to the left for i in range(S, -1, -1): if left_strength >= F[i]: count += 1 left_strength -= 1 else: break # Spread fire to the right for i in range(S + 1, M): if right_strength - 1 >= F[i]: count += 1 right_strength -= 1 else: break return count"},{"question":"def sort_street_numbers(test_cases): Sorts street numbers for each test case such that all odd numbers are in ascending order followed by all even numbers in descending order. INPUT: - test_cases: A list of tuples where each tuple contains an integer N (the number of street numbers) and a list of N integers representing the street numbers. OUTPUT: - A list of lists where each list contains the street numbers sorted in the specified order. EXAMPLES: >>> sort_street_numbers([(5, [3, 8, 5, 12, 9])]) [[3, 5, 9, 12, 8]] >>> sort_street_numbers([(5, [3, 8, 5, 12, 9]), (6, [7, 6, 3, 4, 2, 1])]) [[3, 5, 9, 12, 8], [1, 3, 7, 6, 4, 2]]","solution":"def sort_street_numbers(test_cases): results = [] for case in test_cases: N, numbers = case odd_numbers = sorted([num for num in numbers if num % 2 != 0]) even_numbers = sorted([num for num in numbers if num % 2 == 0], reverse=True) results.append(odd_numbers + even_numbers) return results"},{"question":"def is_right_angle(x1, y1, x2, y2, x3, y3): Checks if the triangle formed by (x1, y1), (x2, y2), (x3, y3) is a right-angled triangle. def are_all_subsets_right_angled(points): Verifies if all subsets of three points out of the four provided points form a right-angled triangle. :param points: List of tuples containing four points (x, y) :return: \\"YES\\" if all subsets of three points form a right-angled triangle, otherwise \\"NO\\"","solution":"def is_right_angle(x1, y1, x2, y2, x3, y3): Checks if the triangle formed by (x1, y1), (x2, y2), (x3, y3) is a right-angled triangle. # Calculate squares of the lengths of the sides a2 = (x2 - x1) ** 2 + (y2 - y1) ** 2 b2 = (x3 - x1) ** 2 + (y3 - y1) ** 2 c2 = (x3 - x2) ** 2 + (y3 - y2) ** 2 # Check if any permutation of these squares satisfies Pythagorean Theorem return a2 + b2 == c2 or a2 + c2 == b2 or b2 + c2 == a2 def are_all_subsets_right_angled(points): Verifies if all subsets of three points out of the four provided points form a right-angled triangle. :param points: List of tuples containing four points (x, y) :return: \\"YES\\" if all subsets of three points form a right-angled triangle, otherwise \\"NO\\" # Extract individual points (x1, y1), (x2, y2), (x3, y3), (x4, y4) = points # Check all subsets of 3 points to see if they form a right-angled triangle if ( is_right_angle(x1, y1, x2, y2, x3, y3) and is_right_angle(x1, y1, x2, y2, x4, y4) and is_right_angle(x1, y1, x3, y3, x4, y4) and is_right_angle(x2, y2, x3, y3, x4, y4) ): return \\"YES\\" return \\"NO\\""},{"question":"def can_rearrange_troops(n: int, m: int, troops: List[int]) -> str: Determine if it is possible to rearrange the troops using at most m operations to ensure no two adjacent cities have more troops than their starting number and no city has more troops than it initially had. >>> can_rearrange_troops(5, 3, [3, 1, 2, 4, 3]) 'YES' >>> can_rearrange_troops(3, 1, [2, 3, 4]) 'NO'","solution":"def can_rearrange_troops(n, m, troops): max_troops = max(troops) required_operations = 0 # Compute how many operations would be needed to achieve a non-increasing order for i in range(n - 1): if troops[i] < troops[i + 1]: required_operations += troops[i + 1] - troops[i] # Check if the required operations are within limits and validate max troops condition return \\"YES\\" if required_operations <= m and max(troops) == max_troops else \\"NO\\""},{"question":"def can_balance_oranges(n: int, oranges: List[int]) -> str: Determines if it is possible to make the number of oranges in each box equal using the described operation. :param n: An integer representing the number of boxes. :param oranges: A list of integers where each integer represents the number of oranges in a box. :return: \\"YES\\" if it is possible to balance the oranges equally, otherwise \\"NO\\". >>> can_balance_oranges(5, [1, 3, 5, 7, 9]) 'YES' >>> can_balance_oranges(4, [1, 2, 3, 5]) 'NO' >>> can_balance_oranges(3, [0, 0, 0]) 'YES' >>> can_balance_oranges(1, [7]) 'YES' >>> can_balance_oranges(4, [4, 4, 4, 4]) 'YES' >>> can_balance_oranges(3, [10, 20, 30]) 'YES' >>> can_balance_oranges(3, [1, 1, 1]) 'YES' >>> can_balance_oranges(4, [2, 2, 3, 3]) 'NO'","solution":"def can_balance_oranges(n, oranges): Determines if it is possible to make the number of oranges in each box equal using the described operation. :param n: An integer representing the number of boxes. :param oranges: A list of integers where each integer represents the number of oranges in a box. :return: \\"YES\\" if it is possible to balance the oranges equally, otherwise \\"NO\\". total_oranges = sum(oranges) # If the total number of oranges is divisible by the number of boxes, return \\"YES\\". if total_oranges % n == 0: return \\"YES\\" return \\"NO\\""},{"question":"def minimize_max_difference(n: int, k: int, scores: List[int]) -> int: Function to find the minimized maximum difference between scores within any group. n: int - the number of students k: int - the number of groups scores: list of int - the scores of the students Return the minimized maximum difference between scores within any group. Example: >>> minimize_max_difference(5, 2, [10, 20, 30, 40, 50]) 20 >>> minimize_max_difference(4, 1, [5, 7, 8, 10]) 5 >>> minimize_max_difference(3, 2, [8, 8, 8]) 0","solution":"def minimize_max_difference(n, k, scores): Function to find the minimized maximum difference between scores within any group. n: int - the number of students k: int - the number of groups scores: list of int - the scores of the students Return the minimized maximum difference between scores within any group. scores.sort() def can_divide_with_max_diff(max_diff): groups = 1 min_score = scores[0] for score in scores: if score - min_score > max_diff: groups += 1 min_score = score if groups > k: return False return True low, high = 0, scores[-1] - scores[0] result = high while low <= high: mid = (low + high) // 2 if can_divide_with_max_diff(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def max_contiguous_subarray_sum(nums): Returns the maximum sum of any contiguous subarray. >>> max_contiguous_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_contiguous_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_contiguous_subarray_sum([-1, -2, -3, -4]) -1 >>> max_contiguous_subarray_sum([100, -90, 80, -70, 60, -50, 40, -30, 20, -10]) 100 >>> max_contiguous_subarray_sum([]) 0","solution":"def max_contiguous_subarray_sum(nums): Returns the maximum sum of any contiguous subarray. if not nums: return 0 max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def control_fish_tank(current_temperature: float, target_temperature: float) -> str: Determines the control action for the fish tank temperature regulation system. Parameters: current_temperature (float): The current temperature of the water. target_temperature (float): The desired target temperature of the water. Returns: str: \\"heater\\" if the heater should be turned on, \\"cooler\\" if the cooler should be turned on, \\"off\\" if neither the heater nor the cooler should be turned on. # Implementation goes here # Unit Tests def test_control_fish_tank_heater(): assert control_fish_tank(22.5, 24.0) == \\"heater\\" assert control_fish_tank(23.9, 24.0) == \\"heater\\" assert control_fish_tank(10.0, 20.0) == \\"heater\\" def test_control_fish_tank_cooler(): assert control_fish_tank(26.3, 24.0) == \\"cooler\\" assert control_fish_tank(25.0, 24.0) == \\"cooler\\" assert control_fish_tank(100.0, 99.0) == \\"cooler\\" def test_control_fish_tank_off(): assert control_fish_tank(24.0, 24.0) == \\"off\\" assert control_fish_tank(50.0, 50.0) == \\"off\\" assert control_fish_tank(0.0, 0.0) == \\"off\\"","solution":"def control_fish_tank(current_temperature: float, target_temperature: float) -> str: Determines the control action for the fish tank temperature regulation system. Parameters: current_temperature (float): The current temperature of the water. target_temperature (float): The desired target temperature of the water. Returns: str: \\"heater\\" if the heater should be turned on, \\"cooler\\" if the cooler should be turned on, \\"off\\" if neither the heater nor the cooler should be turned on. if current_temperature < target_temperature: return \\"heater\\" elif current_temperature > target_temperature: return \\"cooler\\" else: return \\"off\\""},{"question":"def min_bonuses(n: int, ratings: List[int]) -> int: Determine the minimum total number of bonuses the company needs to give out based on employee performance ratings. >>> min_bonuses(3, [1, 2, 2]) == 4 >>> min_bonuses(5, [10, 20, 30, 20, 10]) == 9 >>> min_bonuses(6, [1, 2, 3, 4, 5, 6]) == 21 >>> min_bonuses(1, [50]) == 1 >>> min_bonuses(4, [20, 20, 20, 20]) == 4 >>> min_bonuses(3, [1, 2, 3]) == 6 >>> min_bonuses(3, [3, 2, 1]) == 6 >>> min_bonuses(6, [1, 3, 2, 2, 3, 1]) == 8","solution":"def min_bonuses(n, ratings): # Initialize an array to store bonuses with at least one bonus for each employee bonuses = [1] * n # Traverse from left to right for i in range(1, n): if ratings[i] > ratings[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Traverse from right to left for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"def minimum_spanning_tree(input_data: str) -> Union[int, str]: Find the minimum spanning tree (MST) for the village. The input consists of multiple lines. The first line contains two integers, n and m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 10000) – the number of houses and the number of roads, respectively. Each of the next m lines contains three integers u, v, w (1 ≤ u, v ≤ n, u ≠ v, 1 ≤ w ≤ 10000) – a pair of houses and the length of the road connecting them. The function should return the total length of the roads in the MST of the village. If no MST exists, return \\"IMPOSSIBLE\\". >>> minimum_spanning_tree(\\"4 5n1 2 1n1 3 4n2 3 2n3 4 3n4 1 5n\\") 6 >>> minimum_spanning_tree(\\"3 1n1 2 2n\\") 'IMPOSSIBLE' >>> minimum_spanning_tree(\\"2 1n1 2 3n\\") 3 >>> minimum_spanning_tree(\\"5 7n1 2 5n1 3 6n2 3 1n2 4 2n3 4 2n3 5 4n4 5 3n\\") 11 >>> minimum_spanning_tree(\\"1 0n\\") 0 >>> minimum_spanning_tree(\\"6 10n1 2 1n2 3 2n3 4 3n4 5 4n5 6 5n6 1 6n1 3 7n2 4 8n3 5 9n4 6 10n\\") 15","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: if i >= len(edges): return \\"IMPOSSIBLE\\" u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append(w) union(parent, rank, x, y) return sum(result) def minimum_spanning_tree(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) edges = [] for i in range(1, m + 1): u, v, w = map(int, lines[i].split()) edges.append((u - 1, v - 1, w)) if n == 1: return 0 if m == 0 else \\"IMPOSSIBLE\\" return kruskal(n, edges)"},{"question":"def conference_room_scheduling(n: int, m: int, events: List[List[int]]) -> List[str]: A function that manages a conference room scheduling system and processes events to determine if time slots are booked. Parameters: - n (int): The number of time slots - m (int): The number of events - events (List[List[int]]): A list of events where each event is represented as a list Returns: - List[str]: A list of results for each query whether a time slot is booked or available. Example: >>> conference_room_scheduling(10, 7, [[1, 2, 5], [1, 6, 8], [2, 4], [2, 7], [1, 5, 5], [2, 5], [2, 10]]) ['BOOKED', 'BOOKED', 'BOOKED', 'AVAILABLE'] >>> conference_room_scheduling(5, 5, [[1, 1, 1], [1, 3, 3], [2, 2], [2, 3], [2, 4]]) ['AVAILABLE', 'BOOKED', 'AVAILABLE'] from solution import conference_room_scheduling def test_example_case(): n = 10 m = 7 events = [ [1, 2, 5], [1, 6, 8], [2, 4], [2, 7], [1, 5, 5], [2, 5], [2, 10] ] expected = [\\"BOOKED\\", \\"BOOKED\\", \\"BOOKED\\", \\"AVAILABLE\\"] assert conference_room_scheduling(n, m, events) == expected def test_no_consecutive_bookings(): n = 5 m = 5 events = [ [1, 1, 1], [1, 3, 3], [2, 2], [2, 3], [2, 4] ] expected = [\\"AVAILABLE\\", \\"BOOKED\\", \\"AVAILABLE\\"] assert conference_room_scheduling(n, m, events) == expected def test_all_slots_booked(): n = 3 m = 3 events = [ [1, 1, 3], [2, 1], [2, 3] ] expected = [\\"BOOKED\\", \\"BOOKED\\"] assert conference_room_scheduling(n, m, events) == expected def test_no_slots_booked(): n = 6 m = 4 events = [ [2, 1], [2, 3], [2, 5], [2, 6] ] expected = [\\"AVAILABLE\\", \\"AVAILABLE\\", \\"AVAILABLE\\", \\"AVAILABLE\\"] assert conference_room_scheduling(n, m, events) == expected def test_some_slots_booked(): n = 5 m = 6 events = [ [1, 2, 4], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5] ] expected = [\\"AVAILABLE\\", \\"BOOKED\\", \\"BOOKED\\", \\"BOOKED\\", \\"AVAILABLE\\"] assert conference_room_scheduling(n, m, events) == expected","solution":"def conference_room_scheduling(n, m, events): time_slots = [False] * (n + 1) results = [] for event in events: t = event[0] if t == 1: x, y = event[1], event[2] for i in range(x, y + 1): time_slots[i] = True elif t == 2: k = event[1] if time_slots[k]: results.append(\\"BOOKED\\") else: results.append(\\"AVAILABLE\\") return results"},{"question":"from typing import List, Dict def calculate_shortest_route(num_vehicles: int, vehicles_data: List[Dict[str, List[List[int]]]]) -> List[int]: Calculate the shortest possible route for each vehicle to visit all assigned destinations exactly once and returning to the warehouse. Args: num_vehicles (int): The number of delivery vehicles. vehicles_data (List[Dict[str, List[List[int]]]]): List of delivery destinations with their respective distances. Returns: List[int]: The length of the shortest possible route for each vehicle. Example: >>> calculate_shortest_route(2, [{'n': 3, 'distances': [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]}, {'n': 2, 'distances': [ [0, 29, 20], [29, 0, 15], [20, 15, 0] ]}]) [80, 64] Unit Test: def test_example_1(): input_data = 2 3 0 10 15 20 10 0 35 25 15 35 0 30 20 25 30 0 2 0 29 20 29 0 15 20 15 0 expected_output = [80, 64] lines = input_data.strip().split('n') assert calculate_shortest_route(2, [ {'n': 3, 'distances': [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]}, {'n': 2, 'distances': [ [0, 29, 20], [29, 0, 15], [20, 15, 0] ]} ]) == expected_output def test_one_vehicle_one_destination(): input_data = 1 1 0 5 5 0 expected_output = [10] lines = input_data.strip().split('n') assert calculate_shortest_route(1, [ {'n': 1, 'distances': [ [0, 5], [5, 0] ]} ]) == expected_output def test_multiple_vehicles(): input_data = 3 2 0 20 30 20 0 15 30 15 0 1 0 10 10 0 2 0 12 25 12 0 18 25 18 0 expected_output = [65, 20, 55] lines = input_data.strip().split('n') assert calculate_shortest_route(3, [ {'n': 2, 'distances': [ [0, 20, 30], [20, 0, 15], [30, 15, 0] ]}, {'n': 1, 'distances': [ [0, 10], [10, 0] ]}, {'n': 2, 'distances': [ [0, 12, 25], [12, 0, 18], [25, 18, 0] ]} ]) == expected_output","solution":"from itertools import permutations def calculate_shortest_route(num_vehicles, vehicles_data): def tsp(matrix, n): # Store all vertices apart from source vertex vertices = list(range(1, n + 1)) # Store minimum weight Hamiltonian Cycle min_path = float('inf') # Generate permutations of the vertices for permutation in permutations(vertices): # Initial distance from source to first vertex in current permutation current_pathweight = matrix[0][permutation[0]] # Calculate the tour weight for i in range(n - 1): current_pathweight += matrix[permutation[i]][permutation[i + 1]] # Add distance from last vertex in permutation back to the source current_pathweight += matrix[permutation[-1]][0] # Update minimum tour weight min_path = min(min_path, current_pathweight) return min_path results = [] for vehicle in vehicles_data: n = vehicle['n'] distances = vehicle['distances'] result = tsp(distances, n) results.append(result) return results def main(input_data): lines = input_data.strip().split('n') index = 0 num_vehicles = int(lines[index]) index += 1 vehicles_data = [] for _ in range(num_vehicles): n = int(lines[index]) index += 1 distances = [] for _ in range(n + 1): distances.append(list(map(int, lines[index].strip().split()))) index += 1 vehicles_data.append({'n': n, 'distances': distances}) results = calculate_shortest_route(num_vehicles, vehicles_data) for result in results: print(result) # Example usage: # input_data = # 2 # 3 # 0 10 15 20 # 10 0 35 25 # 15 35 0 30 # 20 25 30 0 # 2 # 0 29 20 # 29 0 15 # 20 15 0 # # main(input_data)"},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be formed with the characters of s. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"aabbcc\\") 6","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be formed with the characters of s. from collections import Counter count = Counter(s) length = 0 odd_found = False for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True return length + 1 if odd_found else length"},{"question":"def min_swaps_to_identity(n: int, permutation: List[int]) -> int: Returns the minimum number of swaps required to convert the given permutation into the identity permutation. >>> min_swaps_to_identity(5, [5, 4, 3, 2, 1]) 2 >>> min_swaps_to_identity(4, [4, 3, 1, 2]) 3 >>> min_swaps_to_identity(3, [1, 2, 3]) 0 >>> min_swaps_to_identity(1, [1]) 0 >>> min_swaps_to_identity(5, [2, 3, 4, 5, 1]) 4 >>> min_swaps_to_identity(6, [6, 5, 4, 3, 2, 1]) 3","solution":"def min_swaps_to_identity(n, permutation): Returns the minimum number of swaps required to convert the given permutation into the identity permutation. # Create an array to keep track of whether the element has been visited or not visited = [False] * n index_map = {v: i for i, v in enumerate(permutation)} # value to its index mapping swaps = 0 for i in range(n): if visited[i] or permutation[i] == i + 1: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True next_index = index_map[x + 1] x = next_index cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def fibonacci(n: int) -> int: Write a program that reads an integer n and prints the nth number in the Fibonacci sequence. You can assume that n ≤ 30. >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2","solution":"def fibonacci(n): Returns the nth Fibonacci number. Args: n: an integer indicating the position in the Fibonacci sequence (1 ≤ n ≤ 30) Returns: The nth Fibonacci number. if n <= 0: raise ValueError(\\"The input n should be a positive integer.\\") a, b = 0, 1 for _ in range(n - 1): a, b = b, a + b return b"},{"question":"from typing import List, Tuple def schedule_movies(N: int, movie_info: List[str]) -> Tuple[List[str], List[str]]: Arrange the movies into two schedules: 1. Cinema 1 screens only International movies in descending order of their popularity scores. 2. Cinema 2 screens only Domestic movies in descending order of their popularity scores. Args: N : int : Number of movies movie_info : List[str] : List containing information about each movie in the format: \\"movie_name popularity_score category\\" Returns: Tuple[List[str], List[str]] : Two lists, one for each cinema schedule. Examples: >>> schedule_movies(6, [\\"Inception 90 International\\", \\"Parasite 95 International\\", \\"Titanic 89 Domestic\\", \\"Avengers 99 International\\", \\"Up 85 Domestic\\", \\"Soul 88 Domestic\\"]) (['Avengers', 'Parasite', 'Inception'], ['Titanic', 'Soul', 'Up']) >>> schedule_movies(3, [\\"WonderWoman 75 Domestic\\", \\"Joker 85 International\\", \\"Frozen 95 Domestic\\"]) (['Joker'], ['Frozen', 'WonderWoman']) pass def handle_input_output(): import sys input = sys.stdin.read data = input().strip().split('n') N = int(data[0]) movie_info = data[1:] cinema_1, cinema_2 = schedule_movies(N, movie_info) if cinema_1: for movie in cinema_1: print(movie) else: print(\\"No movies\\") if cinema_2: for movie in cinema_2: print(movie) else: print(\\"No movies\\") if __name__ == \\"__main__\\": handle_input_output()","solution":"def schedule_movies(N, movie_info): # Dictionaries to store movies with their popularity scores international_movies = [] domestic_movies = [] # Process each movie and categorize it for movie_detail in movie_info: movie_name, popularity_score, category = movie_detail.split() popularity_score = int(popularity_score) if category == \\"International\\": international_movies.append((popularity_score, movie_name)) elif category == \\"Domestic\\": domestic_movies.append((popularity_score, movie_name)) # Sort the movies by their popularity scores in descending order international_movies.sort(reverse=True, key=lambda x: x[0]) domestic_movies.sort(reverse=True, key=lambda x: x[0]) # Prepare the output lists cinema_1 = [movie[1] for movie in international_movies] cinema_2 = [movie[1] for movie in domestic_movies] return cinema_1, cinema_2 # Helper function to handle input-output conversion def handle_input_output(): import sys input = sys.stdin.read data = input().strip().split('n') N = int(data[0]) movie_info = data[1:] cinema_1, cinema_2 = schedule_movies(N, movie_info) if cinema_1: for movie in cinema_1: print(movie) else: print(\\"No movies\\") if cinema_2: for movie in cinema_2: print(movie) else: print(\\"No movies\\")"},{"question":"def is_sum_of_digits_divisible_by_3(N: int) -> str: Determine whether the sum of the digits of N is divisible by 3. Parameters: N (int): A given integer (1 ≤ N ≤ 1000) Returns: str: 'Yes' if the sum of digits is divisible by 3, otherwise 'No' # Write your code here # Unit Tests def test_sum_of_digits_divisible_by_3(): assert is_sum_of_digits_divisible_by_3(123) == \\"Yes\\" assert is_sum_of_digits_divisible_by_3(999) == \\"Yes\\" assert is_sum_of_digits_divisible_by_3(18) == \\"Yes\\" def test_sum_of_digits_not_divisible_by_3(): assert is_sum_of_digits_divisible_by_3(26) == \\"No\\" assert is_sum_of_digits_divisible_by_3(1000) == \\"No\\" assert is_sum_of_digits_divisible_by_3(22) == \\"No\\" def test_edge_cases(): assert is_sum_of_digits_divisible_by_3(1) == \\"No\\" assert is_sum_of_digits_divisible_by_3(3) == \\"Yes\\" assert is_sum_of_digits_divisible_by_3(6) == \\"Yes\\" assert is_sum_of_digits_divisible_by_3(9) == \\"Yes\\"","solution":"def is_sum_of_digits_divisible_by_3(N): Determine whether the sum of the digits of N is divisible by 3. Parameters: N (int): A given integer (1 ≤ N ≤ 1000) Returns: str: 'Yes' if the sum of digits is divisible by 3, otherwise 'No' digit_sum = sum(int(digit) for digit in str(N)) return \\"Yes\\" if digit_sum % 3 == 0 else \\"No\\""},{"question":"from typing import List, Tuple def min_cuts_to_uniform_cake(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the minimum number of cuts required to make the cake consist of only a single consecutive type of ingredient. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[str]]]): List of tuples containing m, n, and the cake grid for each test case. Returns: List[int]: List of minimum cuts required for each test case. >>> min_cuts_to_uniform_cake(1, [(3, 3, [\\"AAA\\", \\"ABA\\", \\"AAA\\"])]) [1] >>> min_cuts_to_uniform_cake(2, [(3, 3, [\\"AAA\\", \\"ABA\\", \\"AAA\\"]), (4, 4, [\\"ABBA\\", \\"BBAA\\", \\"ABAB\\", \\"BABA\\"])]) [1, 1] >>> min_cuts_to_uniform_cake(1, [(2, 2, [\\"AA\\", \\"AA\\"])]) [0]","solution":"def min_cuts_to_uniform_cake(t, test_cases): results = [] for case in test_cases: m, n, cake = case row_cut_needed = any(len(set(row)) > 1 for row in cake) col_cut_needed = any(len(set(cake[i][j] for i in range(m))) > 1 for j in range(n)) results.append(int(row_cut_needed or col_cut_needed)) return results"},{"question":"import re from collections import Counter def most_frequent_word(n: int, lines: List[str]) -> str: Determines the most frequent word in a document. :param n: The number of lines in the document. :param lines: A list of strings representing each line of the document. :return: The most frequent word in the document in lower case. >>> most_frequent_word(3, [\\"The quick brown fox jumped over the lazy dog.\\", \\"The dog was not amused. The fox, however, was very proud!\\", \\"Was the fox quick? Yes, it was quick!\\"]) 'the' >>> most_frequent_word(2, [\\"Hello, world! Hello again.\\", \\"World peace is important. World peace is possible.\\"]) 'world'","solution":"import re from collections import Counter def most_frequent_word(n, lines): Determines the most frequent word in a document. :param n: The number of lines in the document. :param lines: A list of strings representing each line of the document. :return: The most frequent word in the document in lower case. text = ' '.join(lines).lower() words = re.findall(r'bw+b', text) word_count = Counter(words) most_common_word = word_count.most_common(1)[0][0] return most_common_word"},{"question":"def shortest_bead_string(n: int, s: str) -> int: Returns the length of the shortest string Alice can achieve by removing pairs of adjacent beads that are of different colors. >>> shortest_bead_string(4, \\"RBRB\\") 0 >>> shortest_bead_string(5, \\"RRBRB\\") 1 >>> shortest_bead_string(5, \\"RRRRR\\") 5 >>> shortest_bead_string(7, \\"BBBBBBB\\") 7 >>> shortest_bead_string(6, \\"RBRBRB\\") 0 >>> shortest_bead_string(7, \\"RBRBRBR\\") 1 >>> shortest_bead_string(0, \\"\\") 0 >>> shortest_bead_string(1, \\"R\\") 1 >>> shortest_bead_string(2, \\"RB\\") 0 >>> shortest_bead_string(2, \\"RR\\") 2 >>> shortest_bead_string(3, \\"RBR\\") 1","solution":"def shortest_bead_string(n, s): Returns the length of the shortest string Alice can achieve by removing pairs of adjacent beads that are of different colors. stack = [] for bead in s: if stack and stack[-1] != bead: stack.pop() else: stack.append(bead) return len(stack)"},{"question":"def is_subsequence(s: str, p: str) -> bool: Determines if p is a subsequence of s. >>> is_subsequence(\\"coding assessment\\", \\"cdss\\") True >>> is_subsequence(\\"interview preparation\\", \\"view\\") True >>> is_subsequence(\\"hello world\\", \\"hello\\") True >>> is_subsequence(\\"hello world\\", \\"wooo\\") False >>> is_subsequence(\\"abcdef\\", \\"acf\\") True >>> is_subsequence(\\"abcdef\\", \\"azf\\") False >>> is_subsequence(\\"\\", \\"a\\") False >>> is_subsequence(\\"a\\", \\"\\") True def solve_subsequence_problems(test_cases: List[Tuple[str, str]]) -> List[str]: Takes a list of (s, p) tuples and returns a list of \\"YES\\" or \\"NO\\" based on whether p is a subsequence of s for each tuple. >>> solve_subsequence_problems([(\\"coding assessment\\", \\"cdss\\"), (\\"interview preparation\\", \\"view\\")]) [\\"YES\\", \\"YES\\"] >>> solve_subsequence_problems([(\\"hello world\\", \\"hello\\"), (\\"hello world\\", \\"wooo\\")]) [\\"YES\\", \\"NO\\"] >>> solve_subsequence_problems([(\\"abcdef\\", \\"bfd\\"), (\\"\\", \\"any\\")]) [\\"NO\\", \\"NO\\"] >>> solve_subsequence_problems([(\\"anything\\", \\"\\"), (\\"subsequence\\", \\"subsequence\\")]) [\\"YES\\", \\"YES\\"]","solution":"def is_subsequence(s, p): Determines if p is a subsequence of s. s_len, p_len = len(s), len(p) i, j = 0, 0 while i < s_len and j < p_len: if s[i] == p[j]: j += 1 i += 1 return j == p_len def solve_subsequence_problems(test_cases): Takes a list of (s, p) tuples and returns a list of \\"YES\\" or \\"NO\\" based on whether p is a subsequence of s for each tuple. results = [] for s, p in test_cases: if is_subsequence(s, p): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def calculate_portfolio_value(initial_prices, updates, shares, specified_day): Calculate the value of the portfolio on the specified day. :param initial_prices: List of initial prices of stocks :param updates: List of lists where each sublist contains stock prices for each day :param shares: List of shares held for each stock :param specified_day: Integer representing the day to calculate the portfolio value :return: Integer representing the value of the portfolio on the specified day def process_input(input_text): Parse the input text and calculate portfolio values for each test case. :param input_text: String containing the input text :return: List of integers representing the portfolio values for each test case def test_calculate_portfolio_value(): initial_prices = [10, 20] updates = [ [12, 22], [11, 18], [9, 15] ] shares = [5, 10] specified_day = 2 assert calculate_portfolio_value(initial_prices, updates, shares, specified_day) == 235 initial_prices = [100, 200] updates = [ [120, 220], [110, 180], [90, 150], [115, 170], [130, 160] ] shares = [10, 15] specified_day = 1 assert calculate_portfolio_value(initial_prices, updates, shares, specified_day) == 4500 def test_process_input(): input_text = 2 10 20 3 12 22 11 18 9 15 5 10 2 3 100 200 5 120 220 110 180 90 150 115 170 130 160 10 15 1 expected_output = [235, 4500] assert process_input(input_text.strip()) == expected_output if __name__ == \\"__main__\\": test_calculate_portfolio_value() test_process_input() print(\\"All tests passed!\\")","solution":"def calculate_portfolio_value(initial_prices, updates, shares, specified_day): Calculate the value of the portfolio on the specified day. :param initial_prices: List of initial prices of stocks :param updates: List of lists where each sublist contains stock prices for each day :param shares: List of shares held for each stock :param specified_day: Integer representing the day to calculate the portfolio value :return: Integer representing the value of the portfolio on the specified day if specified_day == 0: prices = initial_prices else: prices = updates[specified_day - 1] return sum(price * share for price, share in zip(prices, shares)) # Function to parse input and calculate portfolio values for each test case def process_input(input_text): lines = input_text.strip().split('n') index = 0 results = [] while index < len(lines): N = int(lines[index]) index += 1 initial_prices = list(map(int, lines[index].split())) index += 1 D = int(lines[index]) index += 1 updates = [] for _ in range(D): updates.append(list(map(int, lines[index].split()))) index += 1 shares = list(map(int, lines[index].split())) index += 1 specified_day = int(lines[index]) index += 1 portfolio_value = calculate_portfolio_value(initial_prices, updates, shares, specified_day) results.append(portfolio_value) return results"},{"question":"def max_tower_height(n: int, heights: List[int]) -> int: Returns the maximum height of a tower that can be formed with the given blocks, obeying the rule that taller blocks cannot be placed on top of shorter blocks. :param n: int : Number of blocks :param heights: list : List of integers representing the heights of the blocks :return: int : Maximum tower height >>> max_tower_height(5, [5, 3, 8, 6, 2]) == 18 >>> max_tower_height(1, [10]) == 10 >>> max_tower_height(4, [5, 5, 5, 5]) == 20 >>> max_tower_height(3, [1, 2, 3]) == 6 >>> max_tower_height(3, [3, 2, 1]) == 6","solution":"def max_tower_height(n, heights): Returns the maximum height of a tower that can be formed with the given blocks, obeying the rule that taller blocks cannot be placed on top of shorter blocks. :param n: int : Number of blocks :param heights: list : List of integers representing the heights of the blocks :return: int : Maximum tower height # Sort the blocks in descending order sorted_heights = sorted(heights, reverse=True) # Initialize tower height tower_height = 0 # Iterate through the sorted heights and construct the tower for height in sorted_heights: tower_height += height return tower_height"},{"question":"def longest_common_subsequence(text1: str, text2: str) -> int: You are given two strings text1 and text2. Your task is to find the length of their longest common subsequence. A subsequence is a sequence that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. Args: text1 (str): First input string. text2 (str): Second input string. Returns: int: Length of the longest common subsequence. Examples: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 # Implementation goes here. def test_example_1(): assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 def test_example_2(): assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 def test_example_3(): assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 def test_empty_strings(): assert longest_common_subsequence(\\"\\", \\"\\") == 0 def test_one_empty_string(): assert longest_common_subsequence(\\"abc\\", \\"\\") == 0 assert longest_common_subsequence(\\"\\", \\"abc\\") == 0 def test_single_character_match(): assert longest_common_subsequence(\\"a\\", \\"a\\") == 1 def test_single_character_no_match(): assert longest_common_subsequence(\\"a\\", \\"b\\") == 0 def test_repeated_characters(): assert longest_common_subsequence(\\"aaaa\\", \\"aa\\") == 2 assert longest_common_subsequence(\\"aa\\", \\"aaaa\\") == 2 def test_intermittent_characters(): assert longest_common_subsequence(\\"abcbdab\\", \\"bdcaba\\") == 4","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence of text1 and text2. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def max_row_col_sum(n: int, grid: List[List[int]]) -> int: Returns the maximum sum of any single row or column in the grid. :param n: The size of the grid (n x n). :param grid: A list of lists containing integers representing the grid. :return: An integer that is the maximum sum of any row or column. >>> max_row_col_sum(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 24 >>> max_row_col_sum(2, [ ... [1000, 1000], ... [1000, 1000] ... ]) == 2000","solution":"def max_row_col_sum(n, grid): Returns the maximum sum of any single row or column in the grid. :param n: The size of the grid (n x n). :param grid: A list of lists containing integers representing the grid. :return: An integer that is the maximum sum of any row or column. max_sum = 0 # Calculate the sum of each row and update max_sum for row in grid: row_sum = sum(row) if row_sum > max_sum: max_sum = row_sum # Calculate the sum of each column and update max_sum for col in range(n): col_sum = sum(grid[row][col] for row in range(n)) if col_sum > max_sum: max_sum = col_sum return max_sum"},{"question":"from typing import List, Tuple def min_cost_to_travel(N: int, M: int, bridges: List[Tuple[int, int, int]]) -> int: Find the minimum cost to travel from island 1 to island N. Parameters: N (int): Number of islands M (int): Number of bridges bridges (list of tuples): Each tuple contains (u, v, c), where u and v are connected islands and c is the cost. Returns: int: Minimum cost to travel from island 1 to island N. If unreachable, return -1. Example: >>> min_cost_to_travel(5, 6, [(1, 2, 1), (1, 3, 4), (2, 4, 2), (3, 4, 1), (4, 5, 3), (2, 3, 2)]) 6 >>> min_cost_to_travel(3, 1, [(1, 2, 10)]) -1 >>> min_cost_to_travel(3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 10)]) 10 # Example unit tests def test_example_1(): N = 5 M = 6 bridges = [ (1, 2, 1), (1, 3, 4), (2, 4, 2), (3, 4, 1), (4, 5, 3), (2, 3, 2) ] assert min_cost_to_travel(N, M, bridges) == 6 def test_example_2(): N = 3 M = 1 bridges = [ (1, 2, 10) ] assert min_cost_to_travel(N, M, bridges) == -1 def test_example_3(): N = 3 M = 3 bridges = [ (1, 2, 5), (2, 3, 5), (1, 3, 10) ] assert min_cost_to_travel(N, M, bridges) == 10 def test_no_bridges(): N = 2 M = 0 bridges = [] assert min_cost_to_travel(N, M, bridges) == -1 def test_direct_bridge(): N = 2 M = 1 bridges = [ (1, 2, 3) ] assert min_cost_to_travel(N, M, bridges) == 3 def test_multiple_paths(): N = 4 M = 5 bridges = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 4), (1, 4, 5) ] assert min_cost_to_travel(N, M, bridges) == 3 def test_large_example(): N = 1000 M = 999 bridges = [(i, i + 1, 1) for i in range(1, 1000)] assert min_cost_to_travel(N, M, bridges) == 999 def test_islands_not_reachable(): N = 4 M = 2 bridges = [ (1, 2, 2), (3, 4, 2) ] assert min_cost_to_travel(N, M, bridges) == -1","solution":"import heapq import sys from collections import defaultdict def min_cost_to_travel(N, M, bridges): Find the minimum cost to travel from island 1 to island N. Parameters: N (int): Number of islands M (int): Number of bridges bridges (list of tuples): Each tuple contains (u, v, c), where u and v are connected islands and c is the cost. Returns: int: Minimum cost to travel from island 1 to island N. If unreachable, return -1. # Create graph graph = defaultdict(list) for u, v, c in bridges: graph[u].append((v, c)) graph[v].append((u, c)) # Use Dijkstra's algorithm to find the shortest path from island 1 to island N heap = [(0, 1)] # (cost, node) visited = [False] * (N + 1) min_cost = {i: sys.maxsize for i in range(1, N + 1)} min_cost[1] = 0 while heap: curr_cost, curr_island = heapq.heappop(heap) if visited[curr_island]: continue visited[curr_island] = True # If we reach island N, return the cost if curr_island == N: return curr_cost for neighbor, weight in graph[curr_island]: if not visited[neighbor]: new_cost = curr_cost + weight if new_cost < min_cost[neighbor]: min_cost[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) return -1 # If N is not reachable from 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given a binary tree, find all root-to-leaf paths. >>> root = TreeNode(1) >>> root.left = TreeNode(2, right=TreeNode(5)) >>> root.right = TreeNode(3) >>> binary_tree_paths(root) [\\"1->2->5\\", \\"1->3\\"] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> binary_tree_paths(root) [\\"1->2\\", \\"1->3\\"] >>> root = TreeNode(1) >>> binary_tree_paths(root) [\\"1\\"]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: # if it's a leaf node paths.append(path) # add the path to paths else: path += \\"->\\" # extend the current path construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \\"\\") return paths"},{"question":"def can_make_all_elements_equal(n, arr): Determine if it's possible to make all elements equal by repeatedly summing adjacent elements. Args: n (int): The length of the list 'arr'. arr (List[int]): The list of integers. Returns: str: \\"YES\\" if it's possible to make all elements in the array equal, otherwise \\"NO\\". Examples: >>> can_make_all_elements_equal(3, [1, 2, 3]) \\"NO\\" >>> can_make_all_elements_equal(4, [2, 4, 6, 2]) \\"YES\\" from solution import can_make_all_elements_equal def test_example_1(): assert can_make_all_elements_equal(3, [1, 2, 3]) == \\"NO\\" def test_example_2(): assert can_make_all_elements_equal(4, [2, 4, 6, 2]) == \\"YES\\" def test_all_even_numbers(): assert can_make_all_elements_equal(5, [2, 4, 6, 8, 10]) == \\"YES\\" def test_all_odd_numbers(): assert can_make_all_elements_equal(3, [1, 3, 5]) == \\"YES\\" def test_mixed_parity(): assert can_make_all_elements_equal(3, [2, 3, 4]) == \\"NO\\" def test_single_pair_mixed_parity(): assert can_make_all_elements_equal(2, [1, 2]) == \\"NO\\" def test_large_input_all_even(): assert can_make_all_elements_equal(100000, [2] * 100000) == \\"YES\\" def test_large_input_mixed_parity(): assert can_make_all_elements_equal(100000, [i if i % 2 == 0 else i - 1 for i in range(100000)]) == \\"YES\\" def test_large_input_all_odd(): assert can_make_all_elements_equal(100000, [1] * 100000) == \\"YES\\"","solution":"def can_make_all_elements_equal(n, arr): Determine if it's possible to make all elements equal by repeatedly summing adjacent elements. # Check the parity of the first element first_parity = arr[0] % 2 # Compare the parity of each element with the first element's parity for num in arr: if num % 2 != first_parity: return \\"NO\\" return \\"YES\\""},{"question":"def check_special_event(T: str) -> str: Determines if there is a pair of theaters that will lead to a special event in MovieLand. Parameters: T (str): A string of length 3 representing the type of movies each theater shows. Returns: str: 'Event' if there's at least one pair of theaters with different types, otherwise 'No Event'. >>> check_special_event(\\"ADA\\") 'Event' >>> check_special_event(\\"DDA\\") 'Event' >>> check_special_event(\\"AAA\\") 'No Event' >>> check_special_event(\\"DDD\\") 'No Event' >>> check_special_event(\\"ADD\\") 'Event'","solution":"def check_special_event(T): Determines if there's a pair of theaters showing different types of movies that will lead to a special event. Parameters: T (str): A string of length 3 representing the type of movies each theater shows. Returns: str: 'Event' if there's at least one pair of theaters with different types, otherwise 'No Event'. action_count = T.count('A') drama_count = T.count('D') if action_count > 0 and drama_count > 0: return \\"Event\\" return \\"No Event\\""},{"question":"def min_swaps_to_sort_books(n: int, books: List[int]) -> int: Returns the minimum number of swaps required to sort the books sequentially from 1 to n. >>> min_swaps_to_sort_books(5, [4, 3, 1, 5, 2]) 4 >>> min_swaps_to_sort_books(4, [1, 3, 4, 2]) 2 >>> min_swaps_to_sort_books(1, [1]) 0 >>> min_swaps_to_sort_books(3, [1, 2, 3]) 0 >>> min_swaps_to_sort_books(5, [5, 4, 3, 2, 1]) 2 >>> min_swaps_to_sort_books(6, [6, 5, 4, 2, 3, 1]) 4","solution":"def min_swaps_to_sort_books(n, books): Returns the minimum number of swaps required to sort the books sequentially from 1 to n. # Create an array of the pairs (book number, index) indexed_books = [(book, i) for i, book in enumerate(books)] # Sort the array by book number indexed_books.sort() # To keep track of visited elements visited = [False] * n swaps = 0 for i in range(n): # Already in the correct place or already visited if visited[i] or indexed_books[i][1] == i: continue cycle_length = 0 x = i while not visited[x]: visited[x] = True x = indexed_books[x][1] cycle_length += 1 # If there is a cycle of size k, it takes (k-1) swaps to sort if cycle_length > 0: swaps += (cycle_length - 1) return swaps"},{"question":"from typing import List def solve(T: int, grids: List[List[List[int]]]) -> List[int]: Given multiple test cases of N x N grids with 0s and 1s, determine the minimum number of moves required for a robot to reach the bottom-right corner considering it can clear one obstacle. Input: - T (int): The number of test cases. - grids (List[List[List[int]]]): A list of T test cases, where each test case is an NxN grid of integers 0s and 1s. Output: - List[int]: A list of minimum number of moves required for each test case, or -1 if it is not possible to reach the destination even after clearing one obstacle. Test Cases: >>> solve(2, [[[0, 0, 1], [0, 1, 0], [1, 0, 0]], [[0, 1, 1], [1, 1, 1], [1, 1, 0]]]) [4, -1] >>> solve(1, [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]]) [4] >>> solve(1, [[[0]]]) [0]","solution":"from collections import deque def min_moves_to_reach_with_obstacle_clearing(grid): N = len(grid) directions = [(1, 0), (0, 1)] def in_bounds(x, y): return 0 <= x < N and 0 <= y < N visited = [[[False, False] for _ in range(N)] for _ in range(N)] visited[0][0][0] = True queue = deque([(0, 0, 0, 0)]) while queue: x, y, cleared, moves = queue.popleft() if x == N - 1 and y == N - 1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny): if grid[nx][ny] == 0 and not visited[nx][ny][cleared]: visited[nx][ny][cleared] = True queue.append((nx, ny, cleared, moves + 1)) elif grid[nx][ny] == 1 and cleared == 0 and not visited[nx][ny][1]: visited[nx][ny][1] = True queue.append((nx, ny, 1, moves + 1)) return -1 def solve(T, grids): results = [] for grid in grids: results.append(min_moves_to_reach_with_obstacle_clearing(grid)) return results"},{"question":"def get_shortest_travel_time_matrix(M: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]: Determine the shortest possible travel time between any two cities via the train tracks. Args: M (int): The number of cities. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers, indicating there is a train track between city u and city v with travel time t. Returns: List[List[int]]: An M x M matrix where the j-th number in the i-th row represents the shortest travel time between city i and city j. >>> get_shortest_travel_time_matrix(3, [(1, 2, 4), (2, 3, 1), (3, 1, 7)]) [[0, 4, 5], [4, 0, 1], [5, 1, 0]] >>> get_shortest_travel_time_matrix(4, [(1, 2, 2), (2, 3, 3), (1, 3, 4), (3, 4, 1)]) [[0, 2, 4, 5], [2, 0, 3, 4], [4, 3, 0, 1], [5, 4, 1, 0]] >>> get_shortest_travel_time_matrix(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10), (2, 4, 5)]) [[0, 1, 3, 6], [1, 0, 2, 5], [3, 2, 0, 3], [6, 5, 3, 0]]","solution":"def floyd_warshall(matrix): M = len(matrix) # Initialize the distance matrix dist = [[float('inf')] * M for _ in range(M)] for i in range(M): dist[i][i] = 0 # Copy the given adjacency matrix values into the distance matrix for u in range(M): for v in range(M): if matrix[u][v] != 0 and u != v: dist[u][v] = matrix[u][v] # Apply Floyd-Warshall Algorithm for k in range(M): for i in range(M): for j in range(M): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def get_shortest_travel_time_matrix(M, edges): # Initialize adjacency matrix matrix = [[0 if i == j else float('inf') for j in range(M)] for i in range(M)] for u, v, t in edges: matrix[u-1][v-1] = t matrix[v-1][u-1] = t shortest_paths = floyd_warshall(matrix) return shortest_paths # Example usage edges = [ (1, 2, 4), (2, 3, 1), (3, 1, 7) ] result = get_shortest_travel_time_matrix(3, edges) for row in result: print(' '.join(map(str, row)))"},{"question":"class ElectricScooterFleet: A class to manage a fleet of electric scooters in a city. Methods: - add_scooter(scooter_id: str, battery_level: int): Adds a new scooter to the fleet. - remove_scooter(scooter_id: str): Removes a scooter from the fleet. - update_battery(scooter_id: str, battery_level: int): Updates the battery level of a specified scooter. - change_status(scooter_id: str, status: str): Changes the status of a specified scooter. - find_lowest_battery() -> str: Returns the ID of the available scooter with the lowest battery level. - list_scooters() -> list: Returns a list of scooters sorted by ID in lexicographical order. >>> fleet = ElectricScooterFleet() >>> fleet.add_scooter('A123', 50) >>> fleet.add_scooter('B456', 80) >>> fleet.add_scooter('C789', 20) >>> fleet.update_battery('A123', 40) >>> fleet.change_status('C789', 'in use') >>> fleet.change_status('A123', 'available') >>> fleet.find_lowest_battery() 'A123' >>> fleet.list_scooters() ['A123', 'B456', 'C789'] >>> fleet.remove_scooter('B456') >>> fleet.list_scooters() ['A123', 'C789'] def __init__(self): # Initializes an empty fleet of scooters pass def add_scooter(self, scooter_id: str, battery_level: int): # Adds a new scooter to the fleet pass def remove_scooter(self, scooter_id: str): # Removes a scooter from the fleet pass def update_battery(self, scooter_id: str, battery_level: int): # Updates the battery level of a specified scooter pass def change_status(self, scooter_id: str, status: str): # Changes the status of a specified scooter pass def find_lowest_battery(self) -> str: # Returns the ID of the available scooter with the lowest battery level pass def list_scooters(self) -> list: # Returns a list of scooters sorted by ID in lexicographical order pass","solution":"class ElectricScooterFleet: def __init__(self): self.scooters = {} def add_scooter(self, scooter_id: str, battery_level: int): if scooter_id not in self.scooters: self.scooters[scooter_id] = { 'battery_level': battery_level, 'status': 'available' } def remove_scooter(self, scooter_id: str): if scooter_id in self.scooters: del self.scooters[scooter_id] def update_battery(self, scooter_id: str, battery_level: int): if scooter_id in self.scooters: self.scooters[scooter_id]['battery_level'] = battery_level def change_status(self, scooter_id: str, status: str): if scooter_id in self.scooters and status in ['in use', 'available']: self.scooters[scooter_id]['status'] = status def find_lowest_battery(self) -> str: lowest_battery_scooter = None lowest_battery = 101 # Higher than the maximum possible battery level for scooter_id, details in self.scooters.items(): if details['status'] == 'available' and details['battery_level'] < lowest_battery: lowest_battery = details['battery_level'] lowest_battery_scooter = scooter_id return lowest_battery_scooter def list_scooters(self) -> list: return sorted(self.scooters.keys())"},{"question":"[Completion Task in Python] def is_unique_flag(pattern: str) -> str: Determine if a flag pattern is unique according to the tradition's rules. >>> is_unique_flag(\\"RGBY\\") \\"YES\\" >>> is_unique_flag(\\"RRGY\\") \\"NO\\" >>> is_unique_flag(\\"RYBG\\") \\"YES\\" >>> is_unique_flag(\\"BGGB\\") \\"NO\\" >>> is_unique_flag(\\"R\\") \\"YES\\" >>> is_unique_flag(\\"RGRGRG\\") \\"YES\\" >>> is_unique_flag(\\"RGBBGY\\") \\"NO\\"","solution":"def is_unique_flag(pattern): Determine if a flag pattern is unique according to the tradition's rules. for i in range(1, len(pattern)): if pattern[i] == pattern[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def largest_even_product_subsequence(arr: List[int]) -> Tuple[int, List[int]]: Find the largest even product and its corresponding subsequence from an array of integers. >>> largest_even_product_subsequence([1, 3, 5, 7]) (0, []) >>> largest_even_product_subsequence([1, 2, 3, 5]) (2, [2]) >>> largest_even_product_subsequence([2, 4, 6]) (48, [1, 2, 3]) >>> largest_even_product_subsequence([3, 5, 2, 3, 4, 6]) (48, [3, 5, 6]) from typing import List, Tuple def test_no_even_numbers(): arr = [1, 3, 5, 7] assert largest_even_product_subsequence(arr) == (0, []) def test_single_even_number(): arr = [1, 2, 3, 5] assert largest_even_product_subsequence(arr) == (2, [2]) def test_all_even_numbers(): arr = [2, 4, 6] assert largest_even_product_subsequence(arr) == (48, [1, 2, 3]) def test_mixed_numbers(): arr = [3, 5, 2, 3, 4, 6] product, indices = largest_even_product_subsequence(arr) # Can have different indices depending on implementation assert product == 48 assert set(indices) == set([3, 5, 6]) def test_mixed_with_negatives(): arr = [-3, -5, 2, -3, 4, -6] product, indices = largest_even_product_subsequence(arr) assert product in [-48, 48] assert set(indices) == set([3, 5, 6])","solution":"def largest_even_product_subsequence(arr): n = len(arr) even_numbers = [x for x in arr if x % 2 == 0] if not even_numbers: return (0, []) even_product = 1 selected_indices = [] for i, val in enumerate(even_numbers): even_filetered_index = [index+1 for index, value in enumerate(arr) if value in even_numbers ] even_product *= val return (even_product, even_filetered_index)"},{"question":"def can_make_elements_equal(n: int, arr: List[int]) -> str: Determines if it is possible to make all elements in the array equal by adding or subtracting 1 to/from some elements exactly once. >>> can_make_elements_equal(3, [1, 2, 3]) 'YES' >>> can_make_elements_equal(4, [1, 2, 4, 5]) 'NO' >>> can_make_elements_equal(5, [-1, 0, 1, -2, -1]) 'YES'","solution":"def can_make_elements_equal(n, arr): Determines if it is possible to make all elements in the array equal by adding or subtracting 1 to/from some elements exactly once. arr = sorted(arr) for i in range(1, n): if arr[i] - arr[i - 1] > 1: return \\"NO\\" return \\"YES\\""},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, pos, value): # Update the value at the position pos += self.n self.tree[pos] = value # Move upward and update parents while pos > 1: self.tree[pos >> 1] = self.tree[pos] + self.tree[pos ^ 1] pos >>= 1 def range_sum(self, l, r): # Compute sum of the range [l, r) res = 0 l += self.n r += self.n while l < r: if l & 1: res += self.tree[l] l += 1 if r & 1: r -= 1 res += self.tree[r] l >>= 1 r >>= 1 return res def process_queries(n: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of queries on an array where each query is either an update or a range sum query. Args: n : int : the number of elements in the array array : List[int] : the initial array queries : List[Tuple[int, int, int]] : queries to be processed Returns: List[int] : the results of the sum queries Queries: (1, pos, value) : update the value at the specified position (2, l, r) : calculate the sum of elements from index l to r (1-based index) Example: >>> process_queries(5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 10), (2, 1, 3)]) [6, 13] pass from typing import List, Tuple def test_process_queries(): n = 5 array = [1, 2, 3, 4, 5] queries = [ (2, 1, 3), (1, 2, 10), (2, 1, 3) ] expected_output = [6, 13] assert process_queries(n, array, queries) == expected_output def test_process_queries_single_element(): n = 1 array = [999] queries = [ (2, 1, 1), (1, 0, 555), (2, 1, 1) ] expected_output = [999, 555] assert process_queries(n, array, queries) == expected_output def test_process_queries_all_elements(): n = 6 array = [10, 20, 30, 40, 50, 60] queries = [ (2, 1, 6), (1, 0, 5), (2, 1, 1), (2, 1, 6), (2, 3, 5) ] expected_output = [210, 5, 205, 120] assert process_queries(n, array, queries) == expected_output def test_process_queries_units_and_updates(): n = 3 array = [1, 1, 1] queries = [ (2, 1, 3), (1, 0, 100), (2, 1, 3), (1, 2, 50), (2, 1, 3) ] expected_output = [3, 102, 151] assert process_queries(n, array, queries) == expected_output","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, pos, value): # Update the value at the position pos += self.n self.tree[pos] = value # Move upward and update parents while pos > 1: self.tree[pos >> 1] = self.tree[pos] + self.tree[pos ^ 1] pos >>= 1 def range_sum(self, l, r): # Compute sum of the range [l, r) res = 0 l += self.n r += self.n while l < r: if l & 1: res += self.tree[l] l += 1 if r & 1: r -= 1 res += self.tree[r] l >>= 1 r >>= 1 return res def process_queries(n, array, queries): seg_tree = SegmentTree(array) result = [] for query in queries: if query[0] == 1: # Update query pos = query[1] value = query[2] seg_tree.update(pos, value) elif query[0] == 2: # Range sum query l = query[1] - 1 r = query[2] result.append(seg_tree.range_sum(l, r)) return result"},{"question":"def find_minimum_difference_pair(arr): Finds and returns the pair of indices (i, j) such that the difference (arr[j] - arr[i]) is minimized with the conditions 0 <= i < j < N. If multiple pairs have the same difference, the pair with the smallest i is returned, and if there are still multiple pairs, the pair with the smallest j is returned. Parameters: arr (list): List of integers Returns: tuple: Pair of indices (i, j) Examples: >>> find_minimum_difference_pair([1, 3, 4, 8, 16]) (1, 2) >>> find_minimum_difference_pair([10, 20, 30, 10, 40, 50]) (0, 3)","solution":"def find_minimum_difference_pair(arr): Finds and returns the pair of indices (i, j) such that the difference (arr[j] - arr[i]) is minimized with the conditions 0 <= i < j < N. If multiple pairs have the same difference, the pair with the smallest i is returned, and if there are still multiple pairs, the pair with the smallest j is returned. Parameters: arr (list): List of integers Returns: tuple: Pair of indices (i, j) N = len(arr) if N < 2: return None # Create a list of (value, index) tuples and sort it sorted_array = sorted((val, idx) for idx, val in enumerate(arr)) min_diff = float('inf') min_pair = (None, None) # Find the pair with the minimum difference for k in range(1, N): val1, idx1 = sorted_array[k-1] val2, idx2 = sorted_array[k] diff = val2 - val1 if diff < min_diff: min_diff = diff min_pair = (idx1, idx2) elif diff == min_diff: if idx1 < min_pair[0]: min_pair = (idx1, idx2) elif idx1 == min_pair[0] and idx2 < min_pair[1]: min_pair = (idx1, idx2) i, j = min_pair return (i, j) if i < j else (j, i) # Function to handle input and output for the given problem def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) array = list(map(int, data[1:N+1])) i, j = find_minimum_difference_pair(array) print(i, j) # Uncomment below line to run main when executing the script # if __name__ == '__main__': # main()"},{"question":"def max_subsequence_sum(n: int, k: int, sequence: List[int]) -> int: Determine the maximum sum of a subsequence such that no element in the subsequence is greater than k. Parameters: n (int): The number of elements in the sequence. k (int): The maximum allowed value for elements in the subsequence. sequence (list of int): The elements of the sequence. Returns: int: The maximum sum of the valid subsequence. >>> max_subsequence_sum(5, 7, [3, 7, 2, 9, 5]) 17 >>> max_subsequence_sum(4, 2, [3, 4, 5, 6]) 0 >>> max_subsequence_sum(4, 10, [1, 2, 3, 4]) 10 >>> max_subsequence_sum(7, 4, [2, 11, 3, 7, 1, 2, 4]) 12 >>> max_subsequence_sum(1, 10, [5]) 5 >>> max_subsequence_sum(1, 3, [5]) 0","solution":"def max_subsequence_sum(n, k, sequence): Returns the maximum sum of a subsequence such that no element in the subsequence is greater than k. Parameters: n (int): The number of elements in the sequence. k (int): The maximum allowed value for elements in the subsequence. sequence (list of int): The elements of the sequence. Returns: int: The maximum sum of the valid subsequence. return sum(x for x in sequence if x <= k)"},{"question":"def can_form_palindrome(string: str) -> str: Returns \\"YES\\" if the given string can be rearranged to form a palindrome. Otherwise, returns \\"NO\\". >>> can_form_palindrome(\\"aabbcc\\") == \\"YES\\" >>> can_form_palindrome(\\"abc\\") == \\"NO\\" >>> can_form_palindrome(\\"a\\") == \\"YES\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes a list of test cases. >>> process_test_cases(3, [\\"aabbcc\\", \\"abc\\", \\"a\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(4, [\\"abcd\\", \\"aabb\\", \\"abcabc\\", \\"zz\\"]) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(2, [\\"aabbcccc\\", \\"ab\\"]) == [\\"YES\\", \\"NO\\"]","solution":"def can_form_palindrome(string): Returns \\"YES\\" if the given string can be rearranged to form a palindrome. Otherwise, returns \\"NO\\". from collections import Counter char_count = Counter(string) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_test_cases(T, test_cases): Processes a list of test cases. T: Number of test cases test_cases: List of strings to check Returns a list of results for each test case. return [can_form_palindrome(case) for case in test_cases]"},{"question":"def is_valid_permutation(n: int) -> str: Determines if a valid permutation with integer prefix averages exists for the given n. >>> is_valid_permutation(1) == \\"YES\\" >>> is_valid_permutation(2) == \\"YES\\" >>> is_valid_permutation(3) == \\"NO\\" >>> is_valid_permutation(4) == \\"YES\\" >>> is_valid_permutation(5) == \\"NO\\" >>> is_valid_permutation(10) == \\"YES\\" >>> is_valid_permutation(100000) == \\"YES\\" def solve(t: int, test_cases: List[int]) -> List[str]: Solves for each test case. >>> solve(5, [1, 2, 3, 4, 5]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] >>> solve(3, [7, 8, 9]) == [\\"NO\\", \\"YES\\", \\"NO\\"] >>> solve(4, [11, 20, 15, 16]) == [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> solve(1, [6]) == [\\"YES\\"]","solution":"def is_valid_permutation(n): Determines if a valid permutation with integer prefix averages exists for the given n. if n == 1 or n % 2 == 0: return \\"YES\\" else: return \\"NO\\" def solve(t, test_cases): Solves for each test case. t: number of test cases test_cases: list of integers representing each test case value for n results = [] for n in test_cases: results.append(is_valid_permutation(n)) return results"},{"question":"from typing import List, Tuple def process_inventory(s: int, t: int, products: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Processes the queries and returns the required information about the total number of specific types of products available across all storage units. Args: s (int): Number of storage units. t (int): Number of queries. products (list of tuples): Each tuple contains the product type and its quantity. queries (list of tuples): Each tuple contains the range of product types to be counted. Returns: list of int: Total number of products of the specified types for each query. Examples: >>> process_inventory(5, 3, [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)], [(1, 3), (2, 4), (1, 5)]) [60, 90, 150] >>> process_inventory(3, 2, [(2, 15), (2, 25), (3, 35)], [(2, 2), (3, 3)]) [40, 35]","solution":"def process_inventory(s, t, products, queries): Processes the queries and returns the required information about the total number of specific types of products available across all storage units. Args: s (int): Number of storage units. t (int): Number of queries. products (list of tuples): Each tuple contains the product type and its quantity. queries (list of tuples): Each tuple contains the range of product types to be counted. Returns: list of int: Total number of products of the specified types for each query. # Create a dictionary to store the total quantity for each product type product_quantity = {} for p_type, quantity in products: if p_type in product_quantity: product_quantity[p_type] += quantity else: product_quantity[p_type] = quantity results = [] # Process each query for ci, di in queries: total_quantity = 0 for p_type in range(ci, di + 1): if p_type in product_quantity: total_quantity += product_quantity[p_type] results.append(total_quantity) return results"},{"question":"from typing import List, Tuple def minimum_additional_roads(cities: int, roads: int, city_coords: List[Tuple[int, int]], connections: List[Tuple[int, int]]) -> int: Determine the minimum number of additional roads required to connect all cities. Args: cities (int): Number of cities. roads (int): Number of existing roads. city_coords (List[Tuple[int, int]]): List of tuples representing the coordinates of each city. connections (List[Tuple[int, int]]): List of tuples representing the roads between cities. Returns: int: Minimum number of additional roads required to connect all cities. Example: >>> minimum_additional_roads(5, 2, [(0, 0), (2, 2), (4, 4), (6, 6), (8, 8)], [(1, 2), (4, 5)]) 2 >>> minimum_additional_roads(4, 1, [(1, 2), (3, 4), (6, 7), (8, 9)], [(2, 3)]) 2 >>> minimum_additional_roads(3, 3, [(1, 1), (2, 2), (3, 3)], [(1, 2), (2, 3), (1, 3)]) 0 def test_minimum_additional_roads(): assert minimum_additional_roads( 5, 2, [(0, 0), (2, 2), (4, 4), (6, 6), (8, 8)], [(1, 2), (4, 5)] ) == 2 assert minimum_additional_roads( 4, 1, [(1, 2), (3, 4), (6, 7), (8, 9)], [(2, 3)] ) == 2 assert minimum_additional_roads( 3, 3, [(1, 1), (2, 2), (3, 3)], [(1, 2), (2, 3), (1, 3)] ) == 0 assert minimum_additional_roads( 6, 3, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [(1, 2), (2, 3), (5, 6)] ) == 2 assert minimum_additional_roads( 1, 0, [(0, 0)], [] ) == 0 assert minimum_additional_roads( 2, 0, [(0, 0), (1000, 1000)], [] ) == 1 assert minimum_additional_roads( 3, 1, [(0, 0), (500, 500), (1000, 1000)], [(1, 2)] ) == 1","solution":"def minimum_additional_roads(cities, roads, city_coords, connections): from collections import defaultdict, deque def bfs(start, visited, graph): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Build adjacency list for the graph graph = defaultdict(list) for conn in connections: u, v = conn graph[u-1].append(v-1) graph[v-1].append(u-1) visited = set() components = 0 # Find number of connected components for city in range(cities): if city not in visited: bfs(city, visited, graph) components += 1 # The minimum additional roads needed to connect all components # is (components - 1) return components - 1"},{"question":"def is_magic_square(grid: List[List[int]]) -> str: Determines if the given 3x3 grid is a magic square. Args: grid: A list of lists representing the 3x3 grid. Returns: A string \\"YES\\" if the grid is a magic square, otherwise \\"NO\\". Example: >>> is_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) 'YES' >>> is_magic_square([ ... [3, 1, 6], ... [7, 5, 9], ... [4, 8, 2] ... ]) 'NO' from typing import List def test_is_magic_square_yes(): grid = [ [2, 7, 6], [9, 5, 1], [4, 3, 8] ] assert is_magic_square(grid) == \\"YES\\" def test_is_magic_square_no(): grid = [ [3, 1, 6], [7, 5, 9], [4, 8, 2] ] assert is_magic_square(grid) == \\"NO\\" def test_is_magic_square_variant_yes(): grid = [ [4, 9, 2], [3, 5, 7], [8, 1, 6] ] assert is_magic_square(grid) == \\"YES\\" def test_is_magic_square_variant_no(): grid = [ [4, 9, 2], [3, 5, 8], [7, 1, 6] ] assert is_magic_square(grid) == \\"NO\\"","solution":"def is_magic_square(grid): Determines if the given 3x3 grid is a magic square. Args: grid: A list of lists representing the 3x3 grid. Returns: A string \\"YES\\" if the grid is a magic square, otherwise \\"NO\\". # Calculate the sum of each row row_sums = [sum(row) for row in grid] # Calculate the sum of each column col_sums = [sum(grid[i][j] for i in range(3)) for j in range(3)] # Calculate the sum of the two main diagonals diag1_sum = sum(grid[i][i] for i in range(3)) diag2_sum = sum(grid[i][2-i] for i in range(3)) # Get the unique sums from rows, columns and diagonals unique_sums = set(row_sums + col_sums + [diag1_sum, diag2_sum]) # Check if all sums are the same return \\"YES\\" if len(unique_sums) == 1 else \\"NO\\""},{"question":"def determine_winner(N: int, M: int, strings: List[str], rounds: List[Tuple[int, str]]) -> str: Determines the winner of the game for each round. Arguments: N -- Number of strings M -- Number of rounds strings -- List of N strings rounds -- List of tuples, each containing an integer K and a string S representing the maximum number of positions that can be modified and the target string for that round. Returns: A string of length M containing 'A' or 'S' for each round. Example: >>> determine_winner(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], [(2, \\"zab\\"), (1, \\"def\\"), (0, \\"ghi\\")]) 'SAA' pass from solution import determine_winner def test_example_case(): N = 3 M = 3 strings = [\\"abc\\", \\"def\\", \\"ghi\\"] rounds = [(2, \\"zab\\"), (1, \\"def\\"), (0, \\"ghi\\")] assert determine_winner(N, M, strings, rounds) == \\"SAA\\" def test_all_transformable(): N = 2 M = 1 strings = [\\"abc\\", \\"def\\"] rounds = [(3, \\"zzz\\")] assert determine_winner(N, M, strings, rounds) == \\"S\\" def test_no_transformable(): N = 2 M = 1 strings = [\\"abc\\", \\"def\\"] rounds = [(0, \\"xyz\\")] assert determine_winner(N, M, strings, rounds) == \\"S\\" def test_odd_transformable(): N = 4 M = 1 strings = [\\"abc\\", \\"abd\\", \\"adc\\", \\"aac\\"] rounds = [(2, \\"zzz\\")] assert determine_winner(N, M, strings, rounds) == \\"S\\" def test_even_transformable(): N = 3 M = 1 strings = [\\"abc\\", \\"abd\\", \\"adc\\"] rounds = [(1, \\"abc\\")] assert determine_winner(N, M, strings, rounds) == \\"A\\"","solution":"def determine_winner(N, M, strings, rounds): results = [] def can_transform(str1, str2, max_changes): changes = 0 for i in range(len(str1)): if str1[i] != str2[i]: changes += 1 if changes > max_changes: return False return changes <= max_changes for k, target_str in rounds: transformable_count = sum(1 for string in strings if can_transform(string, target_str, k)) if transformable_count % 2 == 1: results.append('A') else: results.append('S') return ''.join(results)"},{"question":"def is_anagram_by_deleting_one_char(s1: str, s2: str) -> str: Determines if s2 is an anagram of s1 by deleting exactly one character from s1. >>> is_anagram_by_deleting_one_char(\\"abcde\\", \\"bcdea\\") \\"NO\\" >>> is_anagram_by_deleting_one_char(\\"anagram\\", \\"nagara\\") \\"YES\\"","solution":"def is_anagram_by_deleting_one_char(s1, s2): Determines if s2 is an anagram of s1 by deleting exactly one character from s1. # s2 should be one character less than s1 if len(s1) != len(s2) + 1: return \\"NO\\" # Use Counter to count the frequency of characters in both strings from collections import Counter counter_s1 = Counter(s1) counter_s2 = Counter(s2) # Subtract the two Counters diff = counter_s1 - counter_s2 # There should be exactly one character left in diff and its count should be 1 if len(diff) == 1 and list(diff.values())[0] == 1: return \\"YES\\" return \\"NO\\""},{"question":"from collections import Counter def longest_palindrome_length(s: str) -> int: Determine the length of the longest palindrome that can be formed by rearranging the characters of the given string. Args: s (str): The input string consisting of lowercase letters. Returns: int: The length of the longest palindrome. Example: >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"aabbcc\\") 6 >>> longest_palindrome_length(\\"abc\\") 1","solution":"from collections import Counter def longest_palindrome_length(s): Function to determine the length of the longest palindrome that can be formed by rearranging the characters of s. char_count = Counter(s) length = 0 center_added = False for count in char_count.values(): # Add all pairs of characters to the palindrome length length += (count // 2) * 2 # If there's an odd character, it can be used as a center if count % 2 == 1 and not center_added: length += 1 center_added = True return length"},{"question":"def steps_to_transform_to_one(n: int) -> int: Determine the number of operations required to transform the given integer n into 1 using the described process: if the integer is even, divide it by 2; if it is odd, multiply it by 3 and add 1. Args: n (int): The starting integer (1 ≤ n ≤ 10^6). Returns: int: The number of operations needed to transform n into 1. Examples: >>> steps_to_transform_to_one(7) 16 >>> steps_to_transform_to_one(1) 0 >>> steps_to_transform_to_one(27) 111","solution":"def steps_to_transform_to_one(n): steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = n * 3 + 1 steps += 1 return steps"},{"question":"def get_teams_and_leftovers(T: int, participants_list: List[int]) -> List[Tuple[int, int]]: Given a list of participants, determine the number of full teams and leftovers for each test case. Each team consists of 3 participants. Parameters: T (int): The number of test cases. participants_list (list of int): The list containing the number of participants for each test case. Returns: list of tuples: Each tuple contains two integers: the number of full teams and the number of participants left out. >>> get_teams_and_leftovers(3, [7, 10, 0]) [(2, 1), (3, 1), (0, 0)] >>> get_teams_and_leftovers(1, [3]) [(1, 0)] >>> get_teams_and_leftovers(1, [2]) [(0, 2)] >>> get_teams_and_leftovers(2, [4, 20]) [(1, 1), (6, 2)]","solution":"def get_teams_and_leftovers(T, participants_list): Given a list of participants, determine the number of full teams and leftovers for each test case. Each team consists of 3 participants. Parameters: T (int): The number of test cases. participants_list (list of int): The list containing the number of participants for each test case. Returns: list of tuples: Each tuple contains two integers: the number of full teams and the number of participants left out. result = [] for N in participants_list: full_teams = N // 3 leftovers = N % 3 result.append((full_teams, leftovers)) return result"},{"question":"def is_valid_palindrome(s: str) -> bool: Determines if a string is a valid palindrome, after removing non-alphabet characters and ignoring case. >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_valid_palindrome(\\"race a car\\") False","solution":"def is_valid_palindrome(s: str) -> bool: Determines if a string is a valid palindrome, after removing non-alphabet characters and ignoring case. # Filter out non-alphabet characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalpha()] # Check if the filtered list of characters is a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def can_rearrange_snails(n, k, initial, target, test_cases): Determine if snails can be rearranged to match the target arrangement after performing a given number of swaps. Parameters: n (int): number of snails k (int): maximum number of swaps initial (list): initial arrangement of snails target (list): target arrangement of snails test_cases (list): list of test cases, each representing max swaps for that test Returns: list: list of strings \\"Yes\\" or \\"No\\" for each test case >>> can_rearrange_snails(5, 10, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 10]) [\\"No\\", \\"Yes\\"] >>> can_rearrange_snails(3, 3, [1, 2, 3], [3, 1, 2], [1, 2, 3]) [\\"No\\", \\"Yes\\", \\"Yes\\"]","solution":"def can_rearrange_snails(n, k, initial, target, test_cases): Determine if snails can be rearranged to match the target arrangement after performing a given number of swaps. Parameters: n (int): number of snails k (int): maximum number of swaps initial (list): initial arrangement of snails target (list): target arrangement of snails test_cases (list): list of test cases, each representing max swaps for that test Returns: list: list of strings \\"Yes\\" or \\"No\\" for each test case # Compute the minimum swaps required to match the target arrangement min_swaps_required = 0 arranged_initial = initial[:] for i in range(n): if arranged_initial[i] != target[i]: swap_index = arranged_initial.index(target[i], i) while swap_index > i: arranged_initial[swap_index], arranged_initial[swap_index - 1] = arranged_initial[swap_index - 1], arranged_initial[swap_index] swap_index -= 1 min_swaps_required += 1 # Check each test case to determine if it's possible to rearrange within the given swaps results = [] for max_swaps in test_cases: if min_swaps_required <= max_swaps: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def find_minimum_reactions(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Find the minimum number of initial reactions needed to ensure all employees react. Parameters: n (int): The number of employees (nodes). m (int): The number of relationships (edges). edges (List[Tuple[int, int]]): List of tuples representing relationships (edges) where each tuple (u, v) means a reaction from u triggers a reaction from v. Returns: int: The minimum number of initial reactions needed to make sure all employees have reacted. Example: >>> find_minimum_reactions(4, 3, [(1, 2), (2, 3), (4, 2)]) 2 >>> find_minimum_reactions(5, 0, []) 5 >>> find_minimum_reactions(3, 3, [(1, 2), (2, 3), (3, 1)]) 1 def test_example_case(): edges = [(1, 2), (2, 3), (4, 2)] assert find_minimum_reactions(4, 3, edges) == 2 def test_no_edges_case(): edges = [] assert find_minimum_reactions(5, 0, edges) == 5 def test_single_scc_case(): edges = [(1, 2), (2, 3), (3, 1)] assert find_minimum_reactions(3, 3, edges) == 1 def test_multiple_sccs_case(): edges = [(1, 2), (2, 3), (3, 4), (5, 6)] assert find_minimum_reactions(6, 4, edges) == 2 def test_all_individual_nodes_case(): edges = [] assert find_minimum_reactions(10, 0, edges) == 10","solution":"def find_minimum_reactions(n, m, edges): from collections import defaultdict, deque def tarjans_scc(n, edges): index = 0 stack = [] lowlink = [-1] * n idx = [-1] * n on_stack = [False] * n SCCs = [] def strongconnect(node): nonlocal index idx[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph[node]: if idx[neighbor] == -1: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: lowlink[node] = min(lowlink[node], idx[neighbor]) if lowlink[node] == idx[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break SCCs.append(scc) graph = defaultdict(list) for u, v in edges: graph[u - 1].append(v - 1) for node in range(n): if idx[node] == -1: strongconnect(node) return SCCs SCCs = tarjans_scc(n, edges) in_degree = [0] * len(SCCs) scc_index = [-1] * n for i, scc in enumerate(SCCs): for node in scc: scc_index[node] = i for u, v in edges: if scc_index[u - 1] != scc_index[v - 1]: in_degree[scc_index[v - 1]] += 1 no_incoming_sccs = sum(1 for x in in_degree if x == 0) return no_incoming_sccs"},{"question":"def is_valid_path(maze) -> str: Write a program to check whether a given maze has a valid path from the top-left corner to the bottom-right corner. >>> is_valid_path([ ['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.'] ]) == \\"yes\\" >>> is_valid_path([ ['.', '.'], ['#', '#'] ]) == \\"no\\" >>> is_valid_path([ ['.', '#', '#', '#', '#'], ['.', '#', '.', '.', '.'], ['.', '#', '.', '#', '.'], ['.', '#', '.', '#', '.'], ['.', '.', '.', '#', '.'] ]) == \\"yes\\" >>> is_valid_path([ ['#', '#', '#'], ['#', '.', '#'], ['#', '.', '#'] ]) == \\"no\\" >>> is_valid_path([ ['.', '#', '.', '.'], ['.', '#', '.', '#'], ['.', '.', '.', '#'], ['#', '#', '.', '.'] ]) == \\"yes\\"","solution":"def is_valid_path(maze): H, W = len(maze), len(maze[0]) visited = [[False for _ in range(W)] for _ in range(H)] def is_valid(x, y): return 0 <= x < H and 0 <= y < W and maze[x][y] == '.' and not visited[x][y] def dfs(x, y): if x == H-1 and y == W-1: return True visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return \\"yes\\" if maze[0][0] == '.' and dfs(0, 0) else \\"no\\""},{"question":"from typing import List, Tuple def max_gold(n: int, W: int, treasures: List[Tuple[int, int]]) -> int: Determine the maximum amount of gold a participant can collect without exceeding the weight limit they can carry. >>> max_gold(4, 10, [(2, 10), (3, 14), (7, 15), (5, 7)]) == 31 >>> max_gold(1, 10, [(10, 50)]) == 50 >>> max_gold(3, 5, [(1, 10), (2, 20), (2, 30)]) == 60 >>> max_gold(5, 15, [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2)]) == 10 >>> max_gold(3, 5, [(6, 10), (7, 15), (8, 20)]) == 0 def parse_input(input_string: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse the given input string to extract the number of treasure boxes, the maximum weight capacity, and the list of treasures with their weights and gold amounts. >>> parse_input(\\"4n10n2 10n3 14n7 15n5 7n\\") == (4, 10, [(2, 10), (3, 14), (7, 15), (5, 7)]) def main(input_string: str) -> int: Main function to read input, calculate the maximum amount of gold a participant can collect, and return the result. >>> main(\\"4n10n2 10n3 14n7 15n5 7n\\") == 31 >>> main(\\"1n10n10 50n\\") == 50 >>> main(\\"3n5n1 10n2 20n2 30n\\") == 60 >>> main(\\"5n15n1 2n2 2n3 2n4 2n5 2n\\") == 10 >>> main(\\"3n5n6 10n7 15n8 20n\\") == 0","solution":"def max_gold(n, W, treasures): dp = [0] * (W + 1) for weight, gold in treasures: for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + gold) return dp[W] def parse_input(input_string): lines = input_string.strip().split('n') n = int(lines[0]) W = int(lines[1]) treasures = [tuple(map(int, line.split())) for line in lines[2:]] return n, W, treasures def main(input_string): n, W, treasures = parse_input(input_string) return max_gold(n, W, treasures)"},{"question":"import math from typing import List def digit_factorial_sequence(N: int) -> List[int]: Generates all numbers in the Digit-Factorial Sequence that are less than or equal to N. >>> digit_factorial_sequence(100000) == [1, 2, 145, 40585] >>> digit_factorial_sequence(0) == [] >>> digit_factorial_sequence(9) == [1, 2] >>> digit_factorial_sequence(150) == [1, 2, 145] >>> digit_factorial_sequence(1000000) == [1, 2, 145, 40585]","solution":"import math def digit_factorial_sequence(N): Generates all numbers in the Digit-Factorial Sequence that are less than or equal to N. def digit_factorial_sum(num): return sum(math.factorial(int(digit)) for digit in str(num)) result = [] for i in range(1, N + 1): if i == digit_factorial_sum(i): result.append(i) return result"},{"question":"from typing import List def most_frequent_genres(n: int, playlist: List[int]) -> List[int]: Returns the most frequent genres in descending order of their frequency. If two genres have the same frequency, the genre with the smaller integer value comes first. Parameters: n (int): The number of genres. playlist (list of int): The genres of the songs in a user's playlist. Returns: List[int]: A list of integers representing the most frequent genres in descending order. >>> most_frequent_genres(5, [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) [4, 3, 2, 1] >>> most_frequent_genres(3, [1, 1, 2, 2, 3, 3]) [1, 2, 3] >>> most_frequent_genres(4, [4, 4, 4, 2, 2, 1]) [4, 2, 1]","solution":"from collections import Counter def most_frequent_genres(n, playlist): Returns the most frequent genres in descending order of their frequency. If two genres have the same frequency, the genre with the smaller integer value comes first. Parameters: n (int): The number of genres. playlist (list of int): The genres of the songs in a user's playlist. Returns: List[int]: A list of integers representing the most frequent genres in descending order. genre_count = Counter(playlist) sorted_genres = sorted(genre_count.items(), key=lambda x: (-x[1], x[0])) return [genre for genre, count in sorted_genres]"},{"question":"from collections import defaultdict, Counter from heapq import nlargest def get_top_trending_hashtags(posts, queries, k): Finds the top 'k' trending hashtags within specified time ranges. Args: posts: List of tuples where each tuple contains a timestamp and a list of hashtags. queries: List of tuples where each tuple contains a start_time and end_time. k: The number of top trending hashtags to retrieve. Returns: A list of lists containing the 'k' most frequently used hashtags for each query. pass def test_get_top_trending_hashtags(): posts = [ (100, [\\"#fun\\", \\"#sun\\"]), (200, [\\"#play\\", \\"#sun\\"]), (300, [\\"#sun\\"]), (400, [\\"#fun\\", \\"#play\\"]), (500, [\\"#relax\\"]) ] queries = [(150, 350), (100, 500)] k = 2 assert get_top_trending_hashtags(posts, queries, k) == [ [\\"#sun\\", \\"#play\\"], [\\"#sun\\", \\"#fun\\"] ] def test_single_post(): posts = [(100, [\\"#fun\\", \\"#sun\\"])] queries = [(50, 150)] k = 1 assert get_top_trending_hashtags(posts, queries, k) == [[\\"#fun\\"]] def test_no_matching_posts(): posts = [(100, [\\"#fun\\", \\"#sun\\"])] queries = [(200, 300)] k = 1 assert get_top_trending_hashtags(posts, queries, k) == [[]] def test_multiple_hashtags_same_freq(): posts = [ (100, [\\"#fun\\", \\"#sun\\"]), (200, [\\"#play\\", \\"#sun\\"]), (300, [\\"#fun\\", \\"#play\\"]), ] queries = [(100, 300)] k = 3 assert get_top_trending_hashtags(posts, queries, k) == [ [\\"#fun\\", \\"#play\\", \\"#sun\\"] ] def test_less_than_k_hashtags(): posts = [ (100, [\\"#fun\\"]), (200, [\\"#play\\"]), (300, [\\"#sun\\"]), ] queries = [(100, 300)] k = 5 assert get_top_trending_hashtags(posts, queries, k) == [ [\\"#fun\\", \\"#play\\", \\"#sun\\"] ]","solution":"from collections import defaultdict, Counter from heapq import nlargest def get_top_trending_hashtags(posts, queries, k): Finds the top 'k' trending hashtags within specified time ranges. Args: posts: List of tuples where each tuple contains a timestamp and a list of hashtags. queries: List of tuples where each tuple contains a start_time and end_time. k: The number of top trending hashtags to retrieve. Returns: A list of lists containing the 'k' most frequently used hashtags for each query. def collect_hashtags_in_range(posts, start_time, end_time): hashtags_count = Counter() for timestamp, hashtags in posts: if start_time <= timestamp <= end_time: hashtags_count.update(hashtags) return hashtags_count result = [] for start_time, end_time in queries: hashtags_count = collect_hashtags_in_range(posts, start_time, end_time) if not hashtags_count: result.append([]) continue # Use a heap to find the top k elements top_hashtags = nlargest(k, hashtags_count.items(), key=lambda x: (x[1], -ord(x[0][0]))) top_hashtags = sorted(top_hashtags, key=lambda x: (-x[1], x[0])) # Extract only the hashtags from the tuples result.append([hashtag for hashtag, count in top_hashtags]) return result"},{"question":"def count_unique_pairs(nums: List[int], target: int) -> int: Given an array of integers nums and a target integer, return the number of unique pairs (a, b) such that their sum equals the target and a != b. >>> count_unique_pairs([1, 2, 3, 4, 5], 6) 2 >>> count_unique_pairs([1, 1, 1, 1], 2) 1 >>> count_unique_pairs([2, 4, 3, 5, 7, 8], 10) 2 >>> count_unique_pairs([1, 1, 2, 2], 3) 1 >>> count_unique_pairs([5, 5, 5, 5], 10) 1 >>> count_unique_pairs([1, 2, 3, 4, 5, 6, 7], 8) 3 >>> count_unique_pairs([1, 3, 2, 4], 5) 2 >>> count_unique_pairs([0, 0, 0, 0], 0) 1 >>> count_unique_pairs([1, -1, 0, 2, -2], 0) 2 >>> count_unique_pairs([1, 2], 4) 0","solution":"def count_unique_pairs(nums, target): Given an array of integers nums and a target integer, return the number of unique pairs (a, b) such that their sum equals the target and a != b. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return len(pairs)"},{"question":"def are_anagrams(word1: str, word2: str) -> str: Returns 'YES' if word1 and word2 are anagrams, 'NO' otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"evil\\", \\"vile\\") \\"YES\\" >>> are_anagrams(\\"friend\\", \\"fiend\\") \\"NO\\" def check_anagrams(cases: List[Tuple[str, str]]) -> List[str]: Processes a list of tuple pairs (word1, word2) and returns 'YES' or 'NO' for each pair. >>> check_anagrams([(\\"listen\\", \\"silent\\"), (\\"evil\\", \\"vile\\"), (\\"friend\\", \\"fiend\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_anagrams([(\\"binary\\", \\"brainy\\"), (\\"harry\\", \\"potter\\")]) [\\"YES\\", \\"NO\\"]","solution":"def are_anagrams(word1, word2): Returns 'YES' if word1 and word2 are anagrams, 'NO' otherwise. # Sort the characters in each word and compare return 'YES' if sorted(word1) == sorted(word2) else 'NO' def check_anagrams(cases): Processes a list of tuple pairs (word1, word2) and returns 'YES' or 'NO' for each pair. results = [are_anagrams(word1, word2) for word1, word2 in cases] return results # Sample interaction function def main(): T = int(input()) cases = [tuple(input().split()) for _ in range(T)] results = check_anagrams(cases) for result in results: print(result)"},{"question":"from typing import List def rank_participants(n: int, scores: List[int]) -> List[int]: Ranks the participants' scores in descending order. Participants with the same score keep original order. Parameters: - n (int): Number of participants. - scores (list of int): Scores of the participants. Returns: - list of int: Ranked scores according to the rules. pass # Unit tests def test_example_1(): assert rank_participants(5, [300, 200, 400, 400, 100]) == [400, 400, 300, 200, 100] def test_example_2(): assert rank_participants(3, [500, 500, 700]) == [700, 500, 500] def test_all_same_scores(): assert rank_participants(4, [100, 100, 100, 100]) == [100, 100, 100, 100] def test_sorted_input(): assert rank_participants(3, [300, 200, 100]) == [300, 200, 100] def test_reverse_sorted_input(): assert rank_participants(3, [100, 200, 300]) == [300, 200, 100] def test_single_participant(): assert rank_participants(1, [1000]) == [1000] def test_large_input(): scores = list(range(1000, 0, -1)) assert rank_participants(1000, scores) == scores def test_multiple_high_scores(): assert rank_participants(7, [100, 300, 300, 200, 100, 300, 200]) == [300, 300, 300, 200, 200, 100, 100]","solution":"def rank_participants(n, scores): Ranks the participants' scores in descending order. Participants with the same score keep original order. Parameters: - n (int): Number of participants. - scores (list of int): Scores of the participants. Returns: - list of int: Ranked scores according to the rules. # Pair each score with its original index indexed_scores = list(enumerate(scores)) # Sort by score first (in descending order), then by original index sorted_scores = sorted(indexed_scores, key=lambda x: (-x[1], x[0])) # Extract the sorted scores result = [score for idx, score in sorted_scores] return result # Example usage: # n = 5 # scores = [300, 200, 400, 400, 100] # ranked_scores = rank_participants(n, scores) # print(ranked_scores) # Output should be [400, 400, 300, 200, 100]"},{"question":"def count_distinct_numbers(a: int, m: int, d: int) -> int: Returns the count of distinct numbers generated by starting at \`a\`, adding \`d\` repeatedly, and stopping before the number exceeds \`m\`. >>> count_distinct_numbers(2, 20, 3) 7 >>> count_distinct_numbers(5, 15, 4) 3 >>> count_distinct_numbers(1, 1, 1) 1","solution":"def count_distinct_numbers(a, m, d): Returns the count of distinct numbers generated by starting at \`a\`, adding \`d\` repeatedly, and stopping before the number exceeds \`m\`. distinct_count = 0 while a <= m: distinct_count += 1 a += d return distinct_count"},{"question":"def monthly_books_acquisition(cumulative_list: List[int]) -> List[int]: Given a list of cumulative book counts at the end of each month, returns the list of books acquired each month. >>> monthly_books_acquisition([10, 20, 35, 50, 70]) [10, 10, 15, 15, 20] >>> monthly_books_acquisition([25]) [25] >>> monthly_books_acquisition([5, 15, 30, 55]) [5, 10, 15, 25] >>> monthly_books_acquisition([5, 10, 15, 20, 25]) [5, 5, 5, 5, 5] >>> monthly_books_acquisition([1000000000, 2000000000, 3000000000]) [1000000000, 1000000000, 1000000000]","solution":"def monthly_books_acquisition(cumulative_list): Given a list of cumulative book counts at the end of each month, returns the list of books acquired each month. monthly_books = [cumulative_list[0]] # books bought in the first month for i in range(1, len(cumulative_list)): monthly_books.append(cumulative_list[i] - cumulative_list[i-1]) return monthly_books # Example usage: # cumulative_list = [10, 20, 35, 50, 70] # print(monthly_books_acquisition(cumulative_list)) # Output: [10, 10, 15, 15, 20]"},{"question":"def minimum_moves_to_catch_mouse(M: int, N: int) -> int: Returns the minimum number of moves the cat must make to catch the mouse. The cat starts at (M, N) and the mouse starts at (1, 1). The minimum number of moves is the sum of the vertical and horizontal distances. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. Returns: int: Minimum number of moves the cat must make to catch the mouse. >>> minimum_moves_to_catch_mouse(5, 5) 8 >>> minimum_moves_to_catch_mouse(3, 7) 8 >>> minimum_moves_to_catch_mouse(1, 1) 0 >>> minimum_moves_to_catch_mouse(2, 2) 2 >>> minimum_moves_to_catch_mouse(10, 15) 23 def process_test_cases(test_cases: list) -> list: Processes multiple test cases and returns the results as a list. Parameters: test_cases (list of tuples): A list of tuples where each tuple contains (M, N). Returns: list: A list of results for each test case. >>> process_test_cases([(5, 5), (3, 7), (1, 1), (2, 2), (10, 15)]) [8, 8, 0, 2, 23] >>> process_test_cases([(1000, 1000)]) [1998] >>> process_test_cases([(999, 1000)]) [1997] >>> process_test_cases([(1, 1000)]) [999] >>> process_test_cases([(1000, 1)]) [999] >>> process_test_cases([(1, 1)]) [0] >>> process_test_cases([(1, 1000), (1000, 1)]) [999, 999]","solution":"def minimum_moves_to_catch_mouse(M, N): Returns the minimum number of moves the cat must make to catch the mouse. The cat starts at (M, N) and the mouse starts at (1, 1). The minimum number of moves is the sum of the vertical and horizontal distances. return (M - 1) + (N - 1) def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list. Parameters: test_cases (list of tuples): A list of tuples where each tuple contains (M, N). Returns: list: A list of results for each test case. results = [minimum_moves_to_catch_mouse(M, N) for M, N in test_cases] return results"},{"question":"def max_coins(grid: List[List[int]]) -> int: Calculate the maximum number of coins collectible in a grid by moving only right or down. grid: List[List[int]] - A 2D list representing the grid where each element is the number of coins in that cell. return: int - The maximum number of coins collectible. >>> max_coins([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12 >>> max_coins([[1, 2, 3, 4]]) == 10 >>> max_coins([[1], [2], [3], [4]]) == 10 >>> max_coins([[7]]) == 7 >>> max_coins([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> max_coins([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29","solution":"def max_coins(grid): Calculate the maximum number of coins collectible in a grid by moving only right or down. grid: List[List[int]] - A 2D list representing the grid where each element is the number of coins in that cell. return: int - The maximum number of coins collectible. if not grid or not grid[0]: return 0 N = len(grid) M = len(grid[0]) # Create a DP table to store the maximum coins collectible up to each cell. dp = [[0]*M for _ in range(N)] # Initialize the top-left corner with the initial number of coins. dp[0][0] = grid[0][0] # Initialize the first row. for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column. for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the DP table. for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the maximum number of coins collectible. return dp[N-1][M-1]"},{"question":"def find_cycle_in_grid(m, n, grid): Determines if there exists a cycle of any letter in the grid. >>> find_cycle_in_grid(3, 4, [\\"aaaa\\", \\"abba\\", \\"aaaa\\"]) \\"Yes\\" >>> find_cycle_in_grid(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) \\"No\\"","solution":"def find_cycle_in_grid(m, n, grid): def is_valid(x, y, prev_x, prev_y): return 0 <= x < m and 0 <= y < n and (x != prev_x or y != prev_y) def dfs(x, y, start_x, start_y, parent_x, parent_y, letter): visited[x][y] = True for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if is_valid(new_x, new_y, parent_x, parent_y) and grid[new_x][new_y] == letter: if not visited[new_x][new_y]: if dfs(new_x, new_y, start_x, start_y, x, y, letter): return True elif new_x == start_x and new_y == start_y: return True return False directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right visited = [[False] * n for _ in range(m)] for i in range(m): for j in range(n): if not visited[i][j]: if dfs(i, j, i, j, -1, -1, grid[i][j]): return \\"Yes\\" return \\"No\\" # Example usage: m = 3 n = 4 grid = [ \\"aaaa\\", \\"abba\\", \\"aaaa\\" ] print(find_cycle_in_grid(m, n, grid)) # Output: Yes m = 3 n = 3 grid = [ \\"abc\\", \\"def\\", \\"ghi\\" ] print(find_cycle_in_grid(m, n, grid)) # Output: No"},{"question":"def count_ways(n: int) -> int: Calculate the number of distinct ways to reach the top of a staircase having 'n' steps. Each time, you can either jump 1 step or 2 steps at a time. The result should be returned modulo 1000000007. >>> count_ways(4) == 5 >>> count_ways(5) == 8 >>> count_ways(6) == 13 >>> count_ways(0) == 1 >>> count_ways(1) == 1 >>> count_ways(2) == 2 >>> count_ways(10) == 89 >>> count_ways(20) == 10946 >>> count_ways(50) == 20365011074 % 1000000007 >>> count_ways(100) == 573147844013817084101 % 1000000007","solution":"def count_ways(n): MOD = 1000000007 # Base case: If there are no steps, there's one way to stay at the ground (start position) if n == 0: return 1 # Base case: If there's only one step, there's only one way to reach the top elif n == 1: return 1 # Base case: If there are two steps, there are two ways: (1+1) or (2) elif n == 2: return 2 # Initialize dynamic programming array dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 # Fill the dp array for i in range(3, n + 1): dp[i] = (dp[i-1] + dp[i-2]) % MOD return dp[n]"},{"question":"def process_operations(m: int, n: int, q: int, operations: List[str]) -> List[str]: Process a series of operations on a rectangular grid to add rectangles and query points. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. q (int): Number of operations to perform. operations (List[str]): List of string operations in the format: 'add x1 y1 x2 y2' for adding rectangles, and 'query x y' for querying points. Returns: List[str]: Results of 'query' operations, either 'yes' or 'no'. Examples: >>> process_operations(5, 5, 5, [\\"add 1 1 3 3\\", \\"query 2 2\\", \\"add 4 4 5 5\\", \\"query 3 4\\", \\"query 4 4\\"]) [\\"yes\\", \\"no\\", \\"yes\\"] >>> process_operations(10, 10, 4, [\\"add 1 1 5 5\\", \\"query 6 6\\", \\"add 6 6 10 10\\", \\"query 7 7\\"]) [\\"no\\", \\"yes\\"] # Your code here","solution":"def process_operations(m, n, q, operations): grid = [[False] * n for _ in range(m)] results = [] for operation in operations: op_data = operation.split() if op_data[0] == \\"add\\": x1, y1, x2, y2 = map(int, op_data[1:]) for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): grid[i][j] = True elif op_data[0] == \\"query\\": x, y = map(int, op_data[1:]) if grid[x - 1][y - 1]: results.append(\\"yes\\") else: results.append(\\"no\\") return results"},{"question":"from datetime import datetime from typing import List def most_frequent_url(log_entries: List[str], start_time: str, end_time: str) -> str: Determines the most frequently accessed URL within the specified time window. Parameters: log_entries (list): List of log entry strings in the format \\"YYYY-MM-DD HH:MM:SS URL\\". start_time (str): Start time of the time window in the format \\"YYYY-MM-DD HH:MM:SS\\". end_time (str): End time of the time window in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: str: The most frequently accessed URL within the specified time window. Example: >>> most_frequent_url([\\"2023-05-01 09:00:00 /home\\", \\"2023-05-01 09:01:00 /index.html\\", \\"2023-05-01 09:02:00 /contact\\", \\"2023-05-01 09:03:00 /index.html\\", \\"2023-05-01 09:04:00 /home\\", \\"2023-05-01 09:05:00 /home\\"], \\"2023-05-01 09:00:00\\", \\"2023-05-01 09:05:00\\") == \\"/home\\" >>> most_frequent_url([\\"2023-05-01 10:00:00 /about\\", \\"2023-05-01 10:01:00 /home\\", \\"2023-05-01 10:02:00 /about\\", \\"2023-05-01 10:03:00 /home\\", \\"2023-05-01 10:04:00 /index.html\\"], \\"2023-05-01 10:00:00\\", \\"2023-05-01 10:03:00\\") == \\"/about\\"","solution":"from datetime import datetime def most_frequent_url(log_entries, start_time, end_time): Determines the most frequently accessed URL within the specified time window. Parameters: log_entries (list): List of log entry strings in the format \\"YYYY-MM-DD HH:MM:SS URL\\". start_time (str): Start time of the time window in the format \\"YYYY-MM-DD HH:MM:SS\\". end_time (str): End time of the time window in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: str: The most frequently accessed URL within the specified time window. # Convert start and end times to datetime objects start_time = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") # Dictionary to count URL accesses url_counts = {} for entry in log_entries: # Split the log entry into timestamp and URL timestamp_str, url = entry.rsplit(\\" \\", 1) timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") # Only consider logs within the time window if start_time <= timestamp <= end_time: if url in url_counts: url_counts[url] += 1 else: url_counts[url] = 1 # Determine the most frequently accessed URL max_count = 0 most_frequent_url = \\"\\" for url, count in url_counts.items(): if count > max_count or (count == max_count and url < most_frequent_url): max_count = count most_frequent_url = url return most_frequent_url"},{"question":"from typing import List, Tuple def find_minimum_spanning_tree(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given a number of cities, the number of cables and the length of each cable connecting the cities, finds the minimum total length of cable required to connect all cities. Parameters: n (int): Number of cities m (int): Number of cables edges (List[Tuple[int, int, int]]): List of tuples representing the cables connecting cities Returns: int: The total length of the cables in the minimum spanning tree Example: >>> find_minimum_spanning_tree(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)]) 6 >>> find_minimum_spanning_tree(3, 3, [(1, 2, 1), (1, 3, 2), (2, 3, 1)]) 2","solution":"def find_minimum_spanning_tree(n, m, edges): # Using Kruskal's algorithm for finding MST edges.sort(key=lambda x: x[2]) parent = list(range(n)) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: parent[root_u] = root_v mst_length = 0 num_edges = 0 for u, v, w in edges: if find(u-1) != find(v-1): union(u-1, v-1) mst_length += w num_edges += 1 if num_edges == n - 1: break return mst_length"},{"question":"def is_palindrome(word: str) -> str: Checks if the given word is a palindrome. :param word: A single word containing only lowercase English letters. :return: \\"YES\\" if the word is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"madam\\") \\"YES\\" >>> is_palindrome(\\"hello\\") \\"NO\\" >>> is_palindrome(\\"racecar\\") \\"YES\\"","solution":"def is_palindrome(word): Checks if the given word is a palindrome. :param word: A single word containing only lowercase English letters. :return: \\"YES\\" if the word is a palindrome, \\"NO\\" otherwise. if word == word[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_palindromic_subsequence(sequence): Determine the length of the longest palindromic subsequence from a given sequence of integers. >>> longest_palindromic_subsequence([1, 2, 3, 4, 3, 2, 1]) 7 >>> longest_palindromic_subsequence([1, 2, 3, 2, 1]) 5 >>> longest_palindromic_subsequence([1, 2, 3, 4, 5, 6]) 1 >>> longest_palindromic_subsequence([1, 2, 1, 2, 1]) 5 >>> longest_palindromic_subsequence([1, 3, 5, 3, 1]) 5 >>> longest_palindromic_subsequence([1, 2, 3, 4, 3]) 3 >>> longest_palindromic_subsequence([1]) 1 >>> longest_palindromic_subsequence([1, 1, 1, 1, 1, 1, 1]) 7","solution":"def longest_palindromic_subsequence(sequence): n = len(sequence) dp = [[0]*n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Fill the DP array for l in range(2, n+1): for i in range(n-l+1): j = i+l-1 if sequence[i] == sequence[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"def winner(string: str) -> str: Determine the winner of the game given the input string. Alice and Bob are playing a game with the string consisting of contiguous substrings of identical characters. The player who makes the last removal wins the game. Alice always plays first. >>> winner(\\"aaaabbbaaa\\") 'Alice' >>> winner(\\"aabb\\") 'Bob' >>> winner(\\"a\\") 'Alice' >>> winner(\\"ababab\\") 'Bob'","solution":"def winner(string): Function to determine the winner of the game given the input string. # Initialize the count of moves moves = 0 # Track the current character current_char = string[0] # Count the number of segments of consecutive identical characters for char in string[1:]: if char != current_char: moves += 1 current_char = char # Add the last segment moves += 1 # If the total moves is odd, Alice wins; otherwise, Bob wins if moves % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"from typing import List def minRidesPassengers(rides: List[int]) -> int: Determines the number of passengers who have taken the minimum number of rides. Parameters: rides (list of int): List of integers where each element represents the number of rides taken by a passenger. Returns: int: Number of passengers who have taken the minimum number of rides. Example: >>> minRidesPassengers([5, 3, 9, 1, 3, 1]) 2 >>> minRidesPassengers([4, 4, 4, 4]) 4 >>> minRidesPassengers([2, 1, 3, 2, 1, 1]) 3","solution":"def minRidesPassengers(rides): Determines the number of passengers who have taken the minimum number of rides. Parameters: rides (list of int): List of integers where each element represents the number of rides taken by a passenger. Returns: int: Number of passengers who have taken the minimum number of rides. # Find the minimum number of rides taken min_rides = min(rides) # Count and return the number of passengers who have taken the minimum number of rides return rides.count(min_rides)"},{"question":"from typing import List, Tuple def preprocess(arr: List[int]) -> Tuple[List[List[int]], List[int]]: Preprocess the input array to allow efficient minimum queries using a Sparse Table. Returns the Sparse Table and the log array. pass def query(st: List[List[int]], log: List[int], l: int, r: int) -> int: Query the minimum value in the range [l, r] using the Sparse Table. Adjust indexes from 1-based to 0-based for internal calculations. pass def process_queries(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process each query and return the results. pass def test_preprocess(): arr = [1, 3, 2, 5, 4] st, log = preprocess(arr) # Check the correct preprocessing of the array assert st[0][0] == 1 assert st[1][0] == 3 assert st[2][0] == 2 # Check a higher level in the Sparse Table assert st[0][1] == 1 def test_query(): arr = [1, 3, 2, 5, 4] st, log = preprocess(arr) assert query(st, log, 1, 3) == 1 assert query(st, log, 2, 4) == 2 assert query(st, log, 1, 5) == 1 def test_process_queries(): n = 5 arr = [1, 3, 2, 5, 4] queries = [(1, 3), (2, 4), (1, 5)] expected_output = [1, 2, 1] assert process_queries(n, arr, queries) == expected_output","solution":"def preprocess(arr): Preprocess the input array to allow efficient minimum queries using a Sparse Table. Returns the Sparse Table and the log array. import math n = len(arr) MAX_LOG = math.floor(math.log2(n)) + 1 # Create Sparse Table st = [[0] * MAX_LOG for _ in range(n)] log = [0] * (n + 1) # Initialize the Sparse Table for i in range(n): st[i][0] = arr[i] # Precompute logs for i in range(2, n + 1): log[i] = log[i // 2] + 1 # Build the Sparse Table j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 return st, log def query(st, log, l, r): Query the minimum value in the range [l, r] using the Sparse Table. Adjust indexes from 1-based to 0-based for internal calculations. l -= 1 r -= 1 j = log[r - l + 1] return min(st[l][j], st[r - (1 << j) + 1][j]) def process_queries(n, arr, queries): Process each query and return the results. # Preprocess the array to build the Sparse Table st, log = preprocess(arr) # Process each query results = [] for l, r in queries: results.append(query(st, log, l, r)) return results"},{"question":"def rearrange_sequence(n: int) -> str: Given an integer \`n\`, determine if it is possible to rearrange the first \`n\` natural numbers into a sequence such that the absolute difference between any two adjacent numbers is either 1 or a prime number. If such a sequence exists, return \\"POSSIBLE\\" followed by the sequence. Otherwise, return \\"IMPOSSIBLE\\". >>> rearrange_sequence(1) == \\"POSSIBLEn1\\" >>> rearrange_sequence(2) == \\"IMPOSSIBLE\\" >>> rearrange_sequence(3) == \\"IMPOSSIBLE\\" >>> rearrange_sequence(4) == \\"POSSIBLEn1 3 2 4\\" >>> rearrange_sequence(5) == \\"IMPOSSIBLE\\" >>> rearrange_sequence(6) == \\"POSSIBLEn1 3 2 5 4 6\\" >>> rearrange_sequence(10) == \\"POSSIBLEn1 2 3 4 5 6 7 8 9 10\\" >>> result = rearrange_sequence(100000) >>> result.startswith(\\"POSSIBLE\\") >>> len(result.split()) == 100001 # \\"POSSIBLE\\" + 100000 numbers","solution":"def is_prime(num): if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def rearrange_sequence(n): if n == 1: return \\"POSSIBLEn1\\" if n == 2 or n == 3: return \\"IMPOSSIBLE\\" if n == 4: return \\"POSSIBLEn1 3 2 4\\" if n == 5: return \\"IMPOSSIBLE\\" if n == 6: return \\"POSSIBLEn1 3 2 5 4 6\\" return \\"POSSIBLEn\\" + \\" \\".join(map(str, range(1, n + 1))) def main(): import sys input = sys.stdin.read n = int(input().strip()) print(rearrange_sequence(n))"},{"question":"def arrange_products(input_data): Arrange products based on their priority values in ascending order. >>> arrange_products(['5', '5 3 8 2 6', '0']) ['2 3 5 6 8'] >>> arrange_products(['5', '5 3 8 2 6', '3', '10 1 20', '0']) ['2 3 5 6 8', '1 10 20']","solution":"def arrange_products(input_data): Arrange products based on their priority values in ascending order. output_data = [] i = 0 while i < len(input_data): n = int(input_data[i]) if n == 0: break priorities = list(map(int, input_data[i + 1].split())) sorted_priorities = sorted(priorities) output_data.append(' '.join(map(str, sorted_priorities))) i += 2 return output_data"},{"question":"def search_books(N, Q, book_data, queries): Determine which books match each query and return the book IDs in ascending order for each query. >>> N = 5 >>> Q = 3 >>> book_data = [\\"book1 mathematics science\\", \\"book2 physics chemistry mathematics\\", ... \\"book3 science physics\\", \\"book4 chemistry science\\", \\"book5 mathematics\\"] >>> queries = [\\"2 science mathematics\\", \\"1 chemistry\\", \\"3 mathematics science chemistry\\"] >>> search_books(N, Q, book_data, queries) ['book1', 'book2 book4', 'none'] >>> N = 4 >>> Q = 2 >>> book_data = [\\"book1 a b c\\", \\"book2 a d e\\", \\"book3 a f g\\", \\"book4 a b e\\"] >>> queries = [\\"2 a b\\", \\"1 f\\"] >>> search_books(N, Q, book_data, queries) ['book1 book4', 'book3']","solution":"def search_books(N, Q, book_data, queries): from collections import defaultdict # Create a dictionary to hold the keywords and their associated book ids keyword_to_books = defaultdict(set) for book in book_data: parts = book.split() book_id = parts[0] keywords = parts[1:] for keyword in keywords: keyword_to_books[keyword].add(book_id) result = [] for query in queries: query_parts = query.split() k = int(query_parts[0]) query_keywords = query_parts[1:] if not query_keywords: # if query_keywords is empty result.append(\\"none\\") continue book_candidates = keyword_to_books[query_keywords[0]].copy() for keyword in query_keywords[1:]: book_candidates.intersection_update(keyword_to_books[keyword]) if book_candidates: result.append(\\" \\".join(sorted(book_candidates))) else: result.append(\\"none\\") return result"},{"question":"def min_blocks_unused(N: int, M: int, memory_requirements: List[int]) -> int: Determines if it is possible to store all data types given the memory blocks available and calculates the minimum number of blocks that should remain unused. Args: N (int): Number of data types M (int): Number of memory blocks available memory_requirements (list of int): A list containing the memory requirements for each data type Returns: int: -1 if it is not possible, otherwise the minimum number of unused blocks. Examples: >>> min_blocks_unused(3, 10, [2, 4, 5]) -1 >>> min_blocks_unused(4, 15, [3, 5, 6, 4]) -1 >>> min_blocks_unused(5, 50, [7, 8, 10, 15, 5]) 0","solution":"def min_blocks_unused(N, M, memory_requirements): Determines if it is possible to store all data types given the memory blocks available and calculates the minimum number of blocks that should remain unused. Parameters: N (int): Number of data types M (int): Number of memory blocks available memory_requirements (list of int): A list containing the memory requirements for each data type Returns: int: -1 if it is not possible, otherwise the minimum number of unused blocks total_required_memory = sum(memory_requirements) if total_required_memory <= M: return M - total_required_memory else: return -1"},{"question":"from typing import List def minimize_makespan(M: int, T: int, task_times: List[int]) -> int: Assign tasks to machines such that the time at which the last task is completed is minimized. >>> minimize_makespan(3, 5, [2, 14, 4, 16, 6]) 16 >>> minimize_makespan(2, 4, [1, 2, 3, 4]) 5","solution":"import heapq def minimize_makespan(M, T, task_times): # Min heap to keep track of the current load on each machine machines = [0] * M heapq.heapify(machines) # Sort tasks in descending order task_times.sort(reverse=True) # Assign each task to the machine with the least current load for time in task_times: min_loaded_machine = heapq.heappop(machines) min_loaded_machine += time heapq.heappush(machines, min_loaded_machine) # The makespan will be the maximum load on any machine return max(machines) # Example usage if __name__ == \\"__main__\\": M = 2 T = 4 task_times = [1, 2, 3, 4] print(minimize_makespan(M, T, task_times)) # Output: 5"},{"question":"def minimum_travel_cost(n: int, m: int, bridges: List[Tuple[int, int, int]]) -> int: The Kingdom of Zolon consists of a cluster of islands connected by bridges. There are n islands in total, numbered from 1 to n. Each bridge connects two islands directly and has an associated travel cost. The King of Zolon wants to ensure he can travel between all islands with the minimum total travel cost. Your task is to determine the minimum travel cost required to connect all the islands using bridges, ensuring there is a path between any two islands. Essentially, you need to find the minimum spanning tree (MST) of the islands represented as a graph. Args: n (int): number of islands m (int): number of bridges bridges (List[Tuple[int, int, int]]): list of bridges where each bridge is represented by a tuple (u, v, w) denoting a bridge between islands u and v with cost w. Returns: int: minimum total travel cost to connect all the islands. If it is impossible to connect all the islands, return -1. Examples: >>> minimum_travel_cost(4, 5, [(1, 2, 5), (1, 3, 10), (2, 3, 4), (2, 4, 11), (3, 4, 7)]) 16 >>> minimum_travel_cost(5, 3, [(1, 2, 3), (1, 3, 2), (4, 5, 2)]) -1","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n mst_cost = 0 edge_count = 0 for u, v, w in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_cost += w edge_count += 1 if edge_count == n - 1: break if edge_count != n - 1: return -1 return mst_cost def minimum_travel_cost(n, m, bridges): edges = [(u-1, v-1, w) for u, v, w in bridges] return kruskal(n, edges)"},{"question":"def min_time_to_complete_projects(N: int, times: List[int], M: int, dependencies: List[Tuple[int, int]]) -> int: Determine the minimum time required to complete all projects given the dependencies. Args: N (int): The number of projects. times (List[int]): The time required to complete each project. M (int): The number of dependencies. dependencies (List[Tuple[int, int]]): The list of dependencies where (A, B) indicates project A must be completed before project B. Returns: int: The minimum time to complete all projects. Examples: >>> min_time_to_complete_projects(5, [3, 2, 1, 4, 5], 4, [(1, 2), (1, 3), (3, 4), (2, 5)]) 10 >>> min_time_to_complete_projects(3, [10, 20, 30], 2, [(1, 2), (1, 3)]) 40 >>> min_time_to_complete_projects(4, [4, 5, 6, 7], 0, []) 7 >>> min_time_to_complete_projects(3, [1, 2, 3], 2, [(1, 2), (2, 3)]) 6 >>> min_time_to_complete_projects(1, [10], 0, []) 10 >>> min_time_to_complete_projects(4, [5, 6, 7, 8], 3, [(1, 2), (1, 3), (1, 4)]) 13 pass","solution":"from collections import deque, defaultdict def min_time_to_complete_projects(N, times, M, dependencies): # Convert 1-based to 0-based indexing for times and dependencies times = [0] + times adj_list = defaultdict(list) in_degree = [0] * (N + 1) for dep in dependencies: A, B = dep adj_list[A].append(B) in_degree[B] += 1 queue = deque() earliest_finish = [0] * (N + 1) for i in range(1, N + 1): if in_degree[i] == 0: queue.append(i) earliest_finish[i] = times[i] while queue: current = queue.popleft() for neighbor in adj_list[current]: in_degree[neighbor] -= 1 earliest_finish[neighbor] = max(earliest_finish[neighbor], earliest_finish[current] + times[neighbor]) if in_degree[neighbor] == 0: queue.append(neighbor) return max(earliest_finish) # Example usage: N = 5 times = [3, 2, 1, 4, 5] M = 4 dependencies = [(1, 2), (1, 3), (3, 4), (2, 5)] print(min_time_to_complete_projects(N, times, M, dependencies)) # Output: 10"},{"question":"def min_coins(n: int) -> int: Given an integer n, returns the minimum number of coins of values 1, 3, and 4 needed to make exactly n dollars. >>> min_coins(6) 2 >>> min_coins(10) 3 >>> min_coins(8) 2","solution":"def min_coins(n): Given an integer n, returns the minimum number of coins of values 1, 3, and 4 needed to make exactly n dollars. if n == 1: return 1 if n == 2: return 2 if n == 3: return 1 if n == 4: return 1 # Array to store the minimum coins needed for all amounts up to n dp = [float('inf')] * (n + 1) # Base cases if n > 0: dp[0] = 0 # 0 coins to make 0 dollars dp[1] = 1 # 1 coin of 1 to make 1 dollar if n > 2: dp[2] = 2 # 2 coins of 1 to make 2 dollars dp[3] = 1 # 1 coin of 3 to make 3 dollars if n > 3: dp[4] = 1 # 1 coin of 4 to make 4 dollars # Fill dp array for all amounts from 5 to n for i in range(5, n+1): dp[i] = min(dp[i-1], dp[i-3], dp[i-4]) + 1 return dp[n]"},{"question":"def countIslands(grid): Returns the number of islands in the given grid. An island is a group of connected land cells ('L') connected horizontally or vertically. >>> countIslands([ ... [\\"L\\", \\"W\\", \\"L\\", \\"L\\"], ... [\\"L\\", \\"L\\", \\"W\\", \\"W\\"], ... [\\"W\\", \\"L\\", \\"L\\", \\"W\\"], ... [\\"W\\", \\"W\\", \\"W\\", \\"L\\"] ... ]) 3 >>> countIslands([ ... [\\"L\\", \\"L\\"], ... [\\"L\\", \\"L\\"] ... ]) 1 from solution import countIslands def test_example1(): grid = [ [\\"L\\", \\"W\\", \\"L\\", \\"L\\"], [\\"L\\", \\"L\\", \\"W\\", \\"W\\"], [\\"W\\", \\"L\\", \\"L\\", \\"W\\"], [\\"W\\", \\"W\\", \\"W\\", \\"L\\"] ] assert countIslands(grid) == 3 def test_example2(): grid = [ [\\"L\\", \\"L\\"], [\\"L\\", \\"L\\"] ] assert countIslands(grid) == 1 def test_single_cell_island(): grid = [ [\\"L\\"] ] assert countIslands(grid) == 1 def test_single_cell_water(): grid = [ [\\"W\\"] ] assert countIslands(grid) == 0 def test_disjoint_islands(): grid = [ [\\"L\\", \\"W\\", \\"L\\"], [\\"W\\", \\"W\\", \\"W\\"], [\\"L\\", \\"L\\", \\"W\\"] ] assert countIslands(grid) == 3 def test_empty_grid(): grid = [] assert countIslands(grid) == 0 def test_grid_with_all_water(): grid = [ [\\"W\\", \\"W\\"], [\\"W\\", \\"W\\"] ] assert countIslands(grid) == 0 def test_large_connected_island(): grid = [ [\\"L\\", \\"L\\", \\"L\\"], [\\"L\\", \\"L\\", \\"L\\"], [\\"L\\", \\"L\\", \\"L\\"] ] assert countIslands(grid) == 1","solution":"def countIslands(grid): Returns the number of islands in the given grid. An island is a group of connected land cells ('L') connected horizontally or vertically. if not grid: return 0 rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y): if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] == 'W' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) island_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 'L' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"def has_pair_with_sum(A: List[int], K: int) -> str: Determines if there are two distinct indices i and j in the array A such that A[i] + A[j] = K. Parameters: A (list of int): The list of integers. K (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_sum([1, 2, 3, 4, 6], 10) 'YES' >>> has_pair_with_sum([-1, -2, -3, 0, 1, 2], -3) 'YES' >>> has_pair_with_sum([1, 2, 3, 4], 8) 'NO' >>> has_pair_with_sum([1, 500, -500], 0) 'YES' >>> has_pair_with_sum([1, 1, 1, 1], 2) 'YES' >>> has_pair_with_sum([-1, -2, -3, -4, -6], -7) 'YES' >>> has_pair_with_sum([-1, 2, 4, -1], 1) 'YES'","solution":"def has_pair_with_sum(A, K): Determines if there are two distinct indices i and j in the array A such that A[i] + A[j] = K. Parameters: A (list of int): The list of integers. K (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for number in A: if K - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"from collections import Counter def can_prepare_dish(ingredients_needed: str, pantry_stock: str) -> bool: Determines if the chef can prepare the dish with the available ingredients. :param ingredients_needed: str, ingredients required for the dish :param pantry_stock: str, ingredients available in the pantry :return: bool, True if the dish can be prepared, False otherwise >>> can_prepare_dish(\\"AAB\\", \\"ABBA\\") True >>> can_prepare_dish(\\"AAB\\", \\"ABC\\") False >>> can_prepare_dish(\\"AAABBB\\", \\"ABABABAB\\") True >>> can_prepare_dish(\\"ABC\\", \\"ACB\\") True >>> can_prepare_dish(\\"AAA\\", \\"AA\\") False","solution":"from collections import Counter def can_prepare_dish(ingredients_needed, pantry_stock): Determines if the chef can prepare the dish with the available ingredients. :param ingredients_needed: str, ingredients required for the dish :param pantry_stock: str, ingredients available in the pantry :return: bool, True if the dish can be prepared, False otherwise needed_counts = Counter(ingredients_needed) stock_counts = Counter(pantry_stock) for ingredient, count in needed_counts.items(): if stock_counts[ingredient] < count: return False return True"},{"question":"def compute_total_items(orders): Computes the total number of items ordered by each customer. Args: orders (list): List of strings, each representing an order. The first element is the customer ID and the rest are item quantities. Returns: dict: A dictionary where keys are customer IDs and values are total items ordered.","solution":"def compute_total_items(orders): Computes the total number of items ordered by each customer. Args: orders (list): List of strings, each representing an order. The first element is the customer ID and the rest are item quantities. Returns: dict: A dictionary where keys are customer IDs and values are total items ordered. customer_orders = {} for order in orders: order_details = list(map(int, order.split())) customer_id = order_details[0] item_quantities = order_details[1:] total_items = sum(item_quantities) if customer_id in customer_orders: customer_orders[customer_id] += total_items else: customer_orders[customer_id] = total_items return dict(sorted(customer_orders.items(), key=lambda item: item[0]))"},{"question":"def is_palindrome(s: str) -> str: Determine if a string is a palindrome. Args: s (str): The input string. Returns: str: 'Yes' if the string is a palindrome, otherwise 'No'. Examples: >>> is_palindrome(\\"madam\\") 'Yes' >>> is_palindrome(\\"example\\") 'No' >>> is_palindrome(\\"racecar\\") 'Yes'","solution":"def is_palindrome(s): Returns 'Yes' if the input string s is a palindrome, otherwise 'No'. if s == s[::-1]: return \\"Yes\\" else: return \\"No\\""},{"question":"def longest_vowel_substring(s: str) -> int: Returns the length of the longest substring in s that contains only vowels. >>> longest_vowel_substring(\\"earthproblem\\") 2 >>> longest_vowel_substring(\\"letshavefun\\") 1 >>> longest_vowel_substring(\\"a\\") 1 >>> longest_vowel_substring(\\"aeiou\\") 5 >>> longest_vowel_substring(\\"bcdfg\\") 0 >>> longest_vowel_substring(\\"a\\" * 50000 + \\"b\\" + \\"e\\" * 49999) 50000 >>> longest_vowel_substring(\\"aeioubcdefgaioue\\") 5","solution":"def longest_vowel_substring(s): Returns the length of the longest substring in s that contains only vowels. vowels = {'a', 'e', 'i', 'o', 'u'} max_length = 0 current_length = 0 for char in s: if char in vowels: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"}]`),S={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},D={key:0,class:"empty-state"},Y=["disabled"],B={key:0},O={key:1};function P(i,e,u,m,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",D,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",O,"Loading...")):(s(),n("span",B,"See more"))],8,Y)):l("",!0)])}const I=c(S,[["render",P],["__scopeId","data-v-d8bcb0fd"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/14.md","filePath":"guide/14.md"}'),z={name:"guide/14.md"},G=Object.assign(z,{setup(i){return(e,u)=>(s(),n("div",null,[w(I)]))}});export{M as __pageData,G as default};
