import{_ as c,o as s,c as r,a as t,m as _,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function S(n,e,u,m,i,a){return s(),r("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(u.poem.solution),1)])])])}const A=c(k,[["render",S],["__scopeId","data-v-0e3b9e33"]]),R=JSON.parse(`[{"question":"def can_form_query_string(T: int, test_cases: List[Tuple[int, List[str], str]]) -> List[str]: Determine if the given query string can be formed by concatenating one or more strings from the list. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[str], str]] : A list of test case tuples, each containing an integer N, a list of strings, and a query string Returns: List[str] : A list of 'YES' or 'NO' for each test case Example: >>> can_form_query_string(1, [(3, [\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaa\\")]) [\\"YES\\"] >>> can_form_query_string(1, [(3, [\\"a\\", \\"b\\", \\"c\\"], \\"abc\\")]) [\\"YES\\"] >>> can_form_query_string(1, [(3, [\\"a\\", \\"bb\\", \\"cc\\"], \\"abcc\\")]) [\\"NO\\"] pass from solution import can_form_query_string def test_case_1(): T = 1 test_cases = [ (3, [\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaa\\") ] assert can_form_query_string(T, test_cases) == [\\"YES\\"] def test_case_2(): T = 1 test_cases = [ (3, [\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") ] assert can_form_query_string(T, test_cases) == [\\"YES\\"] def test_case_3(): T = 1 test_cases = [ (3, [\\"a\\", \\"bb\\", \\"cc\\"], \\"abcc\\") ] assert can_form_query_string(T, test_cases) == [\\"NO\\"] def test_case_4(): T = 1 test_cases = [ (2, [\\"abc\\", \\"def\\"], \\"abcdef\\") ] assert can_form_query_string(T, test_cases) == [\\"YES\\"] def test_case_5(): T = 1 test_cases = [ (4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"], \\"abcdefghijklmnop\\") ] assert can_form_query_string(T, test_cases) == [\\"YES\\"]","solution":"def get_primes_up_to(n): primes = [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, n + 1): if sieve[start]: primes.append(start) for multiple in range(start * start, n + 1, start): sieve[multiple] = False return primes def get_prime_map(): primes = get_primes_up_to(101) prime_map = {chr(97 + i): primes[i] for i in range(26)} # Mapping 'a'..'z' to prime numbers return prime_map def get_string_product(s, prime_map): product = 1 for char in s: product *= prime_map[char] return product def can_form_query_string(T, test_cases): prime_map = get_prime_map() results = [] for i in range(T): N, string_list, query_string = test_cases[i] string_products = [get_string_product(s, prime_map) for s in string_list] query_product = get_string_product(query_string, prime_map) from itertools import combinations, chain possible_products = set() possible_products.add(1) # Add product of empty sequence for length in range(1, N+1): for comb in combinations(string_products, length): combined_product = 1 for prod in comb: combined_product *= prod possible_products.add(combined_product) if query_product in possible_products: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_subarray_sum(arr): Finds the maximum sum subarray from the given array of integers. Parameters: arr (list): A list of integers n (1 ≤ n ≤ 10^5), where elements are in range -10^4 ≤ a[i] ≤ 10^4. Returns: tuple: A tuple containing the maximum sum and a list representing one subarray with the maximum sum. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, [4, -1, 2, 1]) >>> max_subarray_sum([1, 2, 3, 4, 5]) (15, [1, 2, 3, 4, 5]) >>> max_subarray_sum([-1, -2, -3, -4, -5]) (-1, [-1]) >>> max_subarray_sum([5]) (5, [5]) >>> max_subarray_sum([-5]) (-5, [-5]) >>> max_subarray_sum([3, -2, 5, -1, 4]) (9, [3, -2, 5, -1, 4]) >>> large_input = list(range(-10000, 10001)) >>> max_subarray_sum(large_input)[0] 50005000 >>> max_subarray_sum([0, 0, 0, 0]) (0, [0]) >>> max_subarray_sum([-1, -2, -3, -4, -1, -2]) (-1, [-1])","solution":"def max_subarray_sum(arr): Finds the maximum sum subarray from the given array of integers. Parameters: arr (list): A list of integers n (1 ≤ n ≤ 10^5), where elements are in range -10^4 ≤ a[i] ≤ 10^4. Returns: tuple: A tuple containing the maximum sum and a list representing one subarray with the maximum sum. max_sum = float('-inf') current_sum = 0 start = 0 end = 0 s = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = s end = i if current_sum < 0: current_sum = 0 s = i + 1 return (max_sum, arr[start:end+1]) # Example input and invocation # Example output should be (6, [4, -1, 2, 1]) # print(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]))"},{"question":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. >>> cache = LRUCache(2) >>> cache.put(1, 10) >>> cache.put(2, 20) >>> cache.get(1) 10 >>> cache.put(3, 30) # evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 40) # evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 30 >>> cache.get(4) 40 self.capacity = capacity self.cache = dict() # maps key to node self.head = Node() # dummy head of the doubly linked list self.tail = Node() # dummy tail of the doubly linked list self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: Retrieve the value of the key if it exists in the cache, otherwise return -1. pass def put(self, key: int, value: int) -> None: Insert or update the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. pass def test_lru_cache(): cache = LRUCache(2) cache.put(1, 10) cache.put(2, 20) assert cache.get(1) == 10 cache.put(3, 30) assert cache.get(2) == -1 cache.put(4, 40) assert cache.get(1) == -1 assert cache.get(3) == 30 assert cache.get(4) == 40 def test_lru_cache_update(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) assert cache.get(1) == 10 assert cache.get(2) == 2 def test_lru_cache_evict(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 cache.put(2, 2) assert cache.get(1) == -1 assert cache.get(2) == 2 def test_lru_cache_capacity(): cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == 1 assert cache.get(2) == 2 assert cache.get(3) == 3 cache.put(4, 4) assert cache.get(1) == -1 assert cache.get(4) == 4 assert cache.get(3) == 3","solution":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = dict() # maps key to node self.head = Node() # dummy head of the doubly linked list self.tail = Node() # dummy tail of the doubly linked list self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node): prev_tail = self.tail.prev prev_tail.next = node self.tail.prev = node node.prev = prev_tail node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) elif len(self.cache) >= self.capacity: lru_node = self.head.next self._remove(lru_node) del self.cache[lru_node.key] new_node = Node(key, value) self._add(new_node) self.cache[key] = new_node"},{"question":"def find_unique_triplets(nums: List[int]) -> List[List[int]]: Returns a list of unique triplets [a, b, c] in nums such that a + b + c = 0. Triplets are ordered such that a <= b <= c. >>> find_unique_triplets([-1, 0, 1, 2, -1, -4]) [[-1, 0, 1], [-1, -1, 2]] >>> find_unique_triplets([0, 1, 1]) [] >>> find_unique_triplets([1, 2, 3, 4, 5]) [] >>> find_unique_triplets([0, 0, 0, 0]) [[0, 0, 0]] >>> find_unique_triplets([-2, 0, 1, 1, 2]) [[-2, 1, 1], [-2, 0, 2]] >>> find_unique_triplets([]) [] >>> find_unique_triplets([1]) [] >>> find_unique_triplets([1, -1]) [] >>> find_unique_triplets([-1, -1, 2, 2, 0, 0, 1, 1]) [[-1, 0, 1], [-1, -1, 2]]","solution":"def find_unique_triplets(nums): Returns a list of unique triplets [a, b, c] in nums such that a + b + c = 0. Triplets are ordered such that a <= b <= c. nums.sort() triplets = [] for i in range(len(nums)): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.append([nums[i], nums[left], nums[right]]) # Move \`left\` and \`right\` to the next different numbers while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"def longest_positive_sequence(arr): Given a list of integers, find the longest sequence of consecutive positive numbers in the list. If there are multiple sequences of the same length, return the first one that occurs. >>> longest_positive_sequence([3, 1, -4, 1, 2, 3, -1, 5, 4, 2]) [1, 2, 3] >>> longest_positive_sequence([3, 4, -1, 1, 2, -2, 1, 2]) [3, 4] >>> longest_positive_sequence([1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> longest_positive_sequence([-1, -2, -3, -4]) [] >>> longest_positive_sequence([]) [] >>> longest_positive_sequence([1]) [1] >>> longest_positive_sequence([-1, -2, -3]) [] >>> longest_positive_sequence([1, -1, 1, -1, 1]) [1] >>> longest_positive_sequence([-1, -2, -3, 1, 2, 3]) [1, 2, 3]","solution":"def longest_positive_sequence(arr): longest_seq = [] current_seq = [] for num in arr: if num > 0: current_seq.append(num) else: if len(current_seq) > len(longest_seq): longest_seq = current_seq current_seq = [] if len(current_seq) > len(longest_seq): # Check at the end of array longest_seq = current_seq return longest_seq"},{"question":"def can_assign_activities(n, efforts, capabilities): Determines if the activities can be assigned to friends such that no friend is assigned an activity that exceeds their capability. Parameters: n (int): Number of activities and friends. efforts (list of int): List containing effort required for each activity. capabilities (list of int): List containing capability of each friend. Returns: str: \\"YES\\" if it is possible to assign activities such that no friend’s assigned activity exceeds their capability, otherwise \\"NO\\". pass def test_all_capabilities_greater_than_efforts(): assert can_assign_activities(3, [3, 4, 5], [5, 6, 7]) == \\"YES\\" def test_all_capabilities_equal_efforts(): assert can_assign_activities(3, [3, 4, 5], [3, 4, 5]) == \\"YES\\" def test_unable_to_assign_due_to_high_effort(): assert can_assign_activities(3, [6, 4, 5], [5, 4, 3]) == \\"NO\\" def test_mixed_case_with_sorting_needed(): assert can_assign_activities(4, [1, 4, 2, 3], [3, 2, 1, 4]) == \\"YES\\" def test_single_activity_possible(): assert can_assign_activities(1, [1], [1]) == \\"YES\\" def test_single_activity_impossible(): assert can_assign_activities(1, [2], [1]) == \\"NO\\" def test_boundary_case(): assert can_assign_activities(5, [10, 20, 30, 40, 50], [50, 40, 30, 20, 10]) == \\"YES\\"","solution":"def can_assign_activities(n, efforts, capabilities): Determines if the activities can be assigned to friends such that no friend is assigned an activity that exceeds their capability. Parameters: n (int): Number of activities and friends. efforts (list of int): List containing effort required for each activity. capabilities (list of int): List containing capability of each friend. Returns: str: \\"YES\\" if it is possible to assign activities such that no friend’s assigned activity exceeds their capability, otherwise \\"NO\\". # Sort both lists in non-decreasing order. efforts.sort() capabilities.sort() # Compare each effort to each capability for i in range(n): if efforts[i] > capabilities[i]: return \\"NO\\" return \\"YES\\""},{"question":"def max_sum_subarray(arr: list[int], n: int, k: int) -> int: Returns the maximum sum of any contiguous subarray of length k. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 6, 3) 9 >>> max_sum_subarray([1, 1, 1, 1, 1], 5, 3) 3 >>> max_sum_subarray([-1, -2, -3, 4, 5, 6], 6, 3) 15 >>> max_sum_subarray([1, 2, 3, 4, 5], 5, 5) 15 >>> max_sum_subarray([5, 2, 1, 3, 4], 5, 1) 5 >>> max_sum_subarray([-3, -2, -6, -4], 4, 2) -5 >>> max_sum_subarray([1000], 1, 1) 1000","solution":"def max_sum_subarray(arr, n, k): Returns the maximum sum of any contiguous subarray of length k. # Calculate the sum of the first subarray of length k max_sum = current_sum = sum(arr[:k]) # Slide the window across the array for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def NestedArraySum(nested_array: list) -> int: Returns the sum of all integers in a nested array. >>> NestedArraySum([1, [2, [3, 4], 5], 6, [7, 8], 9]) 45 >>> NestedArraySum([1, [2, [3, [4, 5]], 6], 7, [[[8], 9]]]) 45 >>> NestedArraySum([1, 2, 3]) 6 >>> NestedArraySum([]) 0 >>> NestedArraySum([0, [0, 0], 0]) 0 >>> NestedArraySum([-1, [-2, [-3, -4], -5], -6, [-7, -8], -9]) -45 >>> NestedArraySum([1, [-2, [3, [4, -5]], 6], -7, [[8], -9]]) -1 # Your code here","solution":"def NestedArraySum(nested_array): Returns the sum of all integers in a nested array. total_sum = 0 def sum_helper(array): nonlocal total_sum for element in array: if isinstance(element, list): sum_helper(element) else: total_sum += element sum_helper(nested_array) return total_sum"},{"question":"def trap_rain_water(heights): Calculate the amount of water that can be trapped between buildings after it rains. Parameters: heights (List[int]): A list of non-negative integers representing the heights of the buildings. Returns: int: The total amount of trapped rainwater. Examples: >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rain_water([4,2,0,3,2,5]) 9 >>> trap_rain_water([]) 0 >>> trap_rain_water([4]) 0 >>> trap_rain_water([4, 2]) 0 >>> trap_rain_water([3, 3, 3, 3, 3]) 0 >>> trap_rain_water([5, 4, 3, 2, 1]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0","solution":"def trap_rain_water(heights): Calculate the total amount of trapped rainwater given the heights of the buildings. if not heights or len(heights) < 3: return 0 n = len(heights) # Initialize left_max and right_max arrays left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total amount of trapped water total_water = 0 for i in range(n): water_level = min(left_max[i], right_max[i]) if water_level > heights[i]: total_water += water_level - heights[i] return total_water"},{"question":"def max_subarray_sum(nums): Finds the maximum sum of any non-empty subarray in the list. Args: nums (List[int]): A list of integers. Returns: int: The maximum sum of any non-empty subarray. Examples: >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([-3, -1, -4, -2, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): Finds the maximum sum of any non-empty subarray in the list. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def calculate_score(input_string: str) -> int: Calculate the score of the input_string based on the criteria: - Vowels ('a', 'e', 'i', 'o', 'u') are worth 5 points each. - Consonants are worth 2 points each. - Digits ('0' to '9') are worth 3 points each. - Any other characters (including spaces and punctuation) are worth 0 points. >>> calculate_score(\\"Hello, World! 123\\") == 38 >>> calculate_score(\\"aeiouAEIOU\\") == 50 >>> calculate_score(\\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\\") == 42 * 2 >>> calculate_score(\\"0123456789\\") == 30 >>> calculate_score(\\"!@#%^&*()_+\\") == 0 >>> calculate_score(\\"\\") == 0","solution":"def calculate_score(input_string): Calculate the score of the input_string based on the criteria: - Vowels ('a', 'e', 'i', 'o', 'u') are worth 5 points each. - Consonants are worth 2 points each. - Digits ('0' to '9') are worth 3 points each. - Any other characters (including spaces and punctuation) are worth 0 points. vowels = set('aeiouAEIOU') consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ') digits = set('0123456789') score = 0 for char in input_string: if char in vowels: score += 5 elif char in consonants: score += 2 elif char in digits: score += 3 return score"},{"question":"from typing import List def can_partition(bookThicknesses: List[int]) -> bool: Determines if the book thicknesses can be partitioned into two groups with equal total thickness. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([5]) False >>> can_partition([5, 5, 5, 5]) True >>> can_partition([3, 1, 4, 2, 2]) True >>> can_partition([1, 1, 1, 1, 2, 2, 2, 2]) True >>> can_partition([1, 1, 1, 1, 2, 2, 2, 3]) False >>> can_partition([1, 2]) False >>> can_partition([50]*20) True","solution":"def can_partition(bookThicknesses): Determines if the book thicknesses can be partitioned into two groups with equal total thickness. total_sum = sum(bookThicknesses) # If the total sum is an odd number, it's not possible to partition it equally if total_sum % 2 != 0: return False target = total_sum // 2 n = len(bookThicknesses) # Create a boolean dp array to keep track of possible sums dp = [False] * (target + 1) dp[0] = True for thickness in bookThicknesses: for j in range(target, thickness - 1, -1): dp[j] = dp[j] or dp[j - thickness] return dp[target]"},{"question":"def longest_arithmetic_subsequence_length(n, sequence): Determine the length of the longest subsequence that is an arithmetic progression. >>> longest_arithmetic_subsequence_length(4, [3, 6, 9, 12]) 4 >>> longest_arithmetic_subsequence_length(5, [2, 4, 6, 8, 10]) 5 >>> longest_arithmetic_subsequence_length(4, [1, 2, 3, 5]) 3 pass def process_test_cases(test_cases): Process the given test cases to find the length of the longest arithmetic subsequence in each case. >>> process_test_cases([(4, [3, 6, 9, 12]), (5, [2, 4, 6, 8, 10])]) [4, 5] results = [] for n, sequence in test_cases: results.append(longest_arithmetic_subsequence_length(n, sequence)) return results","solution":"def longest_arithmetic_subsequence_length(n, sequence): if n == 1: return 1 dp = [{} for _ in range(n)] max_length = 2 for i in range(n): for j in range(i): diff = sequence[i] - sequence[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length def process_test_cases(test_cases): results = [] for n, sequence in test_cases: results.append(longest_arithmetic_subsequence_length(n, sequence)) return results"},{"question":"def max_subarray_sum(a: List[int]) -> int: Write a function that calculates the sum of the maximum subarray from a given list of integers. A subarray is a contiguous part of an array, and your function should find the subarray with the maximum possible sum and return this sum. :param a: List of integers :return: Integer sum of the maximum subarray Example: >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([0, -3, -2, -5, -4]) 0 from typing import List import unittest class TestMaxSubarraySum(unittest.TestCase): def test_single_element(self): self.assertEqual(max_subarray_sum([1]), 1) self.assertEqual(max_subarray_sum([-1]), -1) def test_all_positive(self): self.assertEqual(max_subarray_sum([1, 2, 3, 4, 5]), 15) def test_all_negative(self): self.assertEqual(max_subarray_sum([-1, -2, -3, -4, -5]), -1) def test_mixed_numbers(self): self.assertEqual(max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]), 7) def test_mixed_numbers_with_larger_negative(self): self.assertEqual(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]), 6) def test_zero_and_negatives(self): self.assertEqual(max_subarray_sum([0, -3, -2, -5, -4]), 0) def test_all_zeros(self): self.assertEqual(max_subarray_sum([0, 0, 0, 0]), 0) def test_positive_start_negative_end(self): self.assertEqual(max_subarray_sum([4, -1, 2, 1, -5, 4]), 6) if __name__ == \\"__main__\\": unittest.main()","solution":"def max_subarray_sum(a): Finds the sum of the maximum subarray using Kadane's algorithm. :param a: List of integers :return: Integer sum of the maximum subarray max_so_far = a[0] max_ending_here = a[0] for i in range(1, len(a)): max_ending_here = max(a[i], max_ending_here + a[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) if key < root.val: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def inorder_traversal(root, result): if root: inorder_traversal(root.left, result) result.append(root.val) inorder_traversal(root.right, result) def bst_inorder(arr): Given an array of integers, form a valid Binary Search Tree (BST), perform an in-order traversal, and return the in-order traversal sequence. >>> bst_inorder([5, 3, 7, 2, 4, 6, 8]) [2, 3, 4, 5, 6, 7, 8] >>> bst_inorder([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> bst_inorder([10, 5, 1, 7, 15, 12, 20]) [1, 5, 7, 10, 12, 15, 20]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) if key < root.val: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def inorder_traversal(root, result): if root: inorder_traversal(root.left, result) result.append(root.val) inorder_traversal(root.right, result) def bst_inorder(arr): if not arr: return [] root = None for key in arr: root = insert(root, key) result = [] inorder_traversal(root, result) return result"},{"question":"class KeyValueStore: A simple in-memory key-value store with advanced query capabilities over the stored data. The key-value store supports storing dictionaries and querying the data with a dot notation query string. Methods: - put(key: str, value: dict): Stores the dictionary \`value\` at the given \`key\`. - get(key: str) -> dict: Retrieves the dictionary stored at the given \`key\`. If the key does not exist, return \`None\`. - query(key: str, query_str: str) -> Any: Retrieves the value specified by the \`query_str\` argument from the dictionary stored at \`key\`. If any part of the query path does not exist, return \`None\`. Example usage: >>> store = KeyValueStore() >>> data = { >>> 'name': 'John Smith', >>> 'address': { >>> 'city': 'New York', >>> 'zipcode': '10001' >>> }, >>> 'email': 'john.smith@example.com' >>> } >>> store.put('user1', data) >>> print(store.get('user1')) { 'name': 'John Smith', 'address': { 'city': 'New York', 'zipcode': '10001' }, 'email': 'john.smith@example.com' } >>> print(store.query('user1', 'address.city')) 'New York' >>> print(store.query('user1', 'address.street')) None >>> print(store.query('user1', 'phone')) None","solution":"class KeyValueStore: def __init__(self): self.store = {} def put(self, key: str, value: dict): if not isinstance(value, dict): raise ValueError(\\"Value must be a dictionary\\") self.store[key] = value def get(self, key: str): return self.store.get(key) def query(self, key: str, query_str: str): data = self.store.get(key) if data is None: return None keys = query_str.split('.') for k in keys: if isinstance(data, dict) and k in data: data = data[k] else: return None return data"},{"question":"def update_inventory(inventory: dict, transactions: list) -> dict: Updates the inventory based on the given transactions. Parameters: inventory (dict): Dictionary with product names as keys and stock quantities as values. transactions (list): List of dictionaries where each dictionary contains 'product', 'action', and 'quantity'. Returns: dict: Updated inventory dictionary. Examples: >>> inventory = {\\"apple\\": 10, \\"banana\\": 5} >>> transactions = [ ... {\\"product\\": \\"apple\\", \\"action\\": \\"add\\", \\"quantity\\": 5}, ... {\\"product\\": \\"banana\\", \\"action\\": \\"remove\\", \\"quantity\\": 2}, ... {\\"product\\": \\"orange\\", \\"action\\": \\"add\\", \\"quantity\\": 10}, ... {\\"product\\": \\"banana\\", \\"action\\": \\"remove\\", \\"quantity\\": 6} ... ] >>> update_inventory(inventory, transactions) {'apple': 15, 'banana': 0, 'orange': 10} >>> inventory = {\\"apple\\": 5, \\"banana\\": 3} >>> transactions = [ ... {\\"product\\": \\"apple\\", \\"action\\": \\"remove\\", \\"quantity\\": 3}, ... {\\"product\\": \\"banana\\", \\"action\\": \\"add\\", \\"quantity\\": 2}, ... {\\"product\\": \\"grape\\", \\"action\\": \\"add\\", \\"quantity\\": 8}, ... {\\"product\\": \\"apple\\", \\"action\\": \\"remove\\", \\"quantity\\": 10} ... ] >>> update_inventory(inventory, transactions) {'apple': 0, 'banana': 5, 'grape': 8}","solution":"def update_inventory(inventory, transactions): Updates the inventory based on the given transactions. Parameters: inventory (dict): Dictionary with product names as keys and stock quantities as values. transactions (list): List of dictionaries where each dictionary contains 'product', 'action', and 'quantity'. Returns: dict: Updated inventory dictionary. for transaction in transactions: product = transaction.get('product') action = transaction.get('action') quantity = transaction.get('quantity') if not isinstance(quantity, int) or quantity < 0: continue if action not in [\\"add\\", \\"remove\\"]: continue if product not in inventory: inventory[product] = 0 if action == \\"add\\": inventory[product] += quantity elif action == \\"remove\\": inventory[product] = max(inventory[product] - quantity, 0) return inventory"},{"question":"def find_earliest_suitable_rack(T: int, test_cases: List[dict]) -> List[List[int]]: Find the earliest rack number where a product with a specific maximum weight can be stored in a specific section. >>> find_earliest_suitable_rack(1, [{'N': 5, 'W': [3, 1, 4, 2, 5], 'Q': 3, 'queries': [2, 3, 6]}]) [[1, 1, -1]] >>> find_earliest_suitable_rack(1, [{'N': 4, 'W': [5, 4, 3, 2], 'Q': 4, 'queries': [3, 5, 2, 1]}]) [[1, 1, 1, 1]]","solution":"def find_earliest_suitable_rack(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] W = test_cases[i]['W'] Q = test_cases[i]['Q'] product_queries = test_cases[i]['queries'] rack_suits = [] for query in product_queries: found = -1 for j in range(N): if W[j] >= query: found = j + 1 break rack_suits.append(found) results.append(rack_suits) return results"},{"question":"def is_interleaving(s1: str, s2: str, s3: str) -> bool: Determine if a string s3 is formed by an interleaving of s1 and s2. >>> is_interleaving(\\"abc\\", \\"def\\", \\"adbcef\\") True >>> is_interleaving(\\"abc\\", \\"def\\", \\"abdecf\\") True >>> is_interleaving(\\"abc\\", \\"def\\", \\"abdeqf\\") False >>> is_interleaving(\\"abc\\", \\"def\\", \\"abcddef\\") False >>> is_interleaving(\\"a\\", \\"b\\", \\"ab\\") True >>> is_interleaving(\\"a\\", \\"b\\", \\"ba\\") True >>> is_interleaving(\\"\\", \\"\\", \\"\\") True >>> is_interleaving(\\"a\\" * 50, \\"b\\" * 50, \\"a\\" * 50 + \\"b\\" * 50) True >>> is_interleaving(\\"a\\" * 50, \\"b\\" * 50, \\"ab\\" * 50) True","solution":"def is_interleaving(s1, s2, s3): Determines if s3 is formed by interleaving s1 and s2. if len(s1) + len(s2) != len(s3): return False dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)] dp[0][0] = True for i in range(1, len(s1) + 1): dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1] for j in range(1, len(s2) + 1): dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1] for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]) return dp[len(s1)][len(s2)]"},{"question":"def sortMatrixRows(matrix: List[List[int]]) -> List[List[int]]: Given a 2D list (matrix) of integers representing the delivery efficiency grid, this function sorts each row of the matrix in non-decreasing order and returns the modified matrix. Args: matrix (List[List[int]]): 2D list of integers representing the delivery efficiency grid. Returns: List[List[int]]: The sorted 2D list where each row is sorted in non-decreasing order. Examples: >>> sortMatrixRows([ ... [4, 2, 1], ... [5, 3, 8], ... [9, 6, 7] ... ]) [[1, 2, 4], [3, 5, 8], [6, 7, 9]] >>> sortMatrixRows([ ... [9, -1, 3], ... [0, -5, 2], ... [11, 4, -6] ... ]) [[-1, 3, 9], [-5, 0, 2], [-6, 4, 11]] >>> sortMatrixRows([ ... [0] ... ]) [[0]] >>> sortMatrixRows([ ... [3, 1, 2], ... [-1, -2, -3], ... [9, 5, 6] ... ]) [[1, 2, 3], [-3, -2, -1], [5, 6, 9]] >>> sortMatrixRows([ ... [5, 5, 5], ... [3, 3, 3], ... [1, 1, 1] ... ]) [[5, 5, 5], [3, 3, 3], [1, 1, 1]] >>> sortMatrixRows([]) []","solution":"def sortMatrixRows(matrix): This function takes a 2D list (matrix) of integers and sorts each row in non-decreasing order. :param matrix: List[List[int]] :return: List[List[int]] return [sorted(row) for row in matrix]"},{"question":"from typing import List, Tuple def find_longest_conseq_subseq(arr: List[int]) -> int: Finds the length of the longest subsequence of consecutive integers in the given array. Args: arr (List[int]): List of integers. Returns: int: Length of the longest subsequence of consecutive integers. >>> find_longest_conseq_subseq([2, 6, 1, 9, 4, 5, 3]) == 6 >>> find_longest_conseq_subseq([1, 9, 3, 10, 4, 20, 2]) == 4 >>> find_longest_conseq_subseq([6, 7, 8, 9, 10]) == 5 >>> find_longest_conseq_subseq([1, 2, 3, 4]) == 4 >>> find_longest_conseq_subseq([10, 20, 30]) == 1 >>> find_longest_conseq_subseq([]) == 0 def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the results. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple. The first element is an integer N, the number of elements in the sequence. The second element is a list of N integers. Returns: List[int]: List of results for each test case. >>> process_test_cases(4, [(7, [2, 6, 1, 9, 4, 5, 3]), (7, [1, 9, 3, 10, 4, 20, 2]), (5, [6, 7, 8, 9, 10]), (4, [1, 2, 3, 4])]) == [6, 4, 5, 4] >>> process_test_cases(3, [(3, [10, 20, 30]), (0, []), (7, [-1, 0, 1, 2, 3, 4, 5])]) == [1, 0, 7]","solution":"def find_longest_conseq_subseq(arr): Finds the length of the longest subsequence of consecutive integers in the given array. Args: arr (List[int]): List of integers. Returns: int: Length of the longest subsequence of consecutive integers. if not arr: return 0 unique_elements = set(arr) longest_length = 0 for element in unique_elements: if element - 1 not in unique_elements: current_length = 1 current_element = element while current_element + 1 in unique_elements: current_element += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple. The first element is an integer N, the number of elements in the sequence. The second element is a list of N integers. Returns: List[int]: List of results for each test case. results = [] for i in range(T): N, arr = test_cases[i] results.append(find_longest_conseq_subseq(arr)) return results"},{"question":"def distribute_tshirts(total_tshirts, small, medium, large): Distribute T-shirts fairly among students by starting with larger sizes first. Parameters: total_tshirts (int): The total number of T-shirts. small (int): The number of small T-shirts available. medium (int): The number of medium T-shirts available. large (int): The number of large T-shirts available. Returns: list: A list of T-shirt sizes distributed to students or an error message if there's a count mismatch. pass def test_exact_distribution(): assert distribute_tshirts(9, 3, 3, 3) == ['L', 'L', 'L', 'M', 'M', 'M', 'S', 'S', 'S'] def test_mix_distribution(): assert distribute_tshirts(5, 2, 2, 1) == ['L', 'M', 'M', 'S', 'S'] def test_no_small_tshirts(): assert distribute_tshirts(5, 0, 3, 2) == ['L', 'L', 'M', 'M', 'M'] def test_mismatch_in_tshirt_count(): assert distribute_tshirts(4, 1, 1, 1) == \\"Mismatch in T-shirt count\\" def test_only_large_tshirts(): assert distribute_tshirts(3, 0, 0, 3) == ['L', 'L', 'L'] def test_only_medium_tshirts(): assert distribute_tshirts(2, 0, 2, 0) == ['M', 'M'] def test_only_small_tshirts(): assert distribute_tshirts(1, 1, 0, 0) == ['S'] def test_zero_tshirts(): assert distribute_tshirts(0, 0, 0, 0) == [] def test_extra_small_tshirts(): assert distribute_tshirts(3, 3, 0, 0) == ['S', 'S', 'S']","solution":"def distribute_tshirts(total_tshirts, small, medium, large): Distribute T-shirts fairly among students by starting with larger sizes first. Parameters: total_tshirts (int): The total number of T-shirts. small (int): The number of small T-shirts available. medium (int): The number of medium T-shirts available. large (int): The number of large T-shirts available. Returns: list: A list of T-shirt sizes distributed to students or an error message if there's a count mismatch. if total_tshirts != small + medium + large: return \\"Mismatch in T-shirt count\\" # Start distributing from the largest size first distribution = ['L'] * large + ['M'] * medium + ['S'] * small return distribution"},{"question":"from typing import List, Tuple def minimum_distance(l: int, w: int, n: int) -> float: Calculate the minimum distance between trees planted evenly around the perimeter of a field. Parameters: l (int): Length of the field w (int): Width of the field n (int): Number of trees Returns: float: Minimum distance between any two consecutive trees >>> minimum_distance(10, 5, 30) 1.00 >>> minimum_distance(15, 5, 12) 3.33 def solve(test_cases: List[Tuple[int, int, int]]) -> List[float]: Calculate the minimum distances for multiple test cases. Parameters: test_cases (List[Tuple[int, int, int]]): List of test cases where each test case contains l, w, n Returns: List[float]: List of minimum distances for each test case >>> solve([(10, 5, 30), (15, 5, 12)]) [1.00, 3.33]","solution":"def minimum_distance(l, w, n): perimeter = 2 * (l + w) min_distance = perimeter / n return round(min_distance, 2) def solve(test_cases): results = [] for l, w, n in test_cases: results.append(minimum_distance(l, w, n)) return results"},{"question":"def sort_tickets(tickets): Sort the list of tickets such that all VIP tickets come before Regular tickets, and tickets of the same type retain their relative order. Args: tickets (List[Tuple[int, str]]): A list of tuples where each tuple contains two elements - an integer ID and a string type (either 'VIP' or 'Regular'). Returns: List[Tuple[int, str]]: The sorted list of tickets with all VIP tickets first, followed by Regular tickets. >>> sort_tickets([(1, 'Regular'), (2, 'VIP'), (3, 'VIP'), (4, 'Regular')]) [(2, 'VIP'), (3, 'VIP'), (1, 'Regular'), (4, 'Regular')] >>> sort_tickets([(1, 'VIP'), (2, 'VIP'), (3, 'VIP'), (4, 'VIP')]) [(1, 'VIP'), (2, 'VIP'), (3, 'VIP'), (4, 'VIP')] >>> sort_tickets([(1, 'Regular'), (2, 'Regular'), (3, 'Regular'), (4, 'Regular')]) [(1, 'Regular'), (2, 'Regular'), (3, 'Regular'), (4, 'Regular')] >>> sort_tickets([(7, 'Regular'), (5, 'VIP'), (1, 'VIP'), (6, 'Regular'), (3, 'VIP')]) [(5, 'VIP'), (1, 'VIP'), (3, 'VIP'), (7, 'Regular'), (6, 'Regular')] >>> sort_tickets([(5, 'Regular'), (2, 'Regular'), (3, 'VIP'), (1, 'Regular')]) [(3, 'VIP'), (5, 'Regular'), (2, 'Regular'), (1, 'Regular')] >>> sort_tickets([(4, 'Regular'), (1, 'VIP'), (2, 'VIP')]) [(1, 'VIP'), (2, 'VIP'), (4, 'Regular')] >>> sort_tickets([]) []","solution":"def sort_tickets(tickets): Sorts the list of tickets such that all VIP tickets come before Regular tickets, and tickets of the same type retain their relative order. vip_tickets = [ticket for ticket in tickets if ticket[1] == 'VIP'] regular_tickets = [ticket for ticket in tickets if ticket[1] == 'Regular'] return vip_tickets + regular_tickets"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Calculates the maximum path sum in a binary tree. >>> single_node = TreeNode(1) >>> max_path_sum(single_node) 1 >>> tree_two_levels = TreeNode(1, TreeNode(2), TreeNode(3)) >>> max_path_sum(tree_two_levels) 6 >>> complex_tree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> max_path_sum(complex_tree) 11 >>> negative_tree = TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> max_path_sum(negative_tree) 42 >>> all_negative_tree = TreeNode(-3, TreeNode(-2), TreeNode(-1)) >>> max_path_sum(all_negative_tree) -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Calculates the maximum path sum in a binary tree. The path may start and end at any node in the tree. def helper(node): nonlocal max_sum if not node: return 0 # Calculate sums of paths starting from the left child and right child left_sum = max(helper(node.left), 0) right_sum = max(helper(node.right), 0) # Calculate the sum passing through the current node current_path_sum = node.val + left_sum + right_sum # Update the global maximum sum max_sum = max(max_sum, current_path_sum) # Return the maximum sum of either left path or right path and the current node's value return node.val + max(left_sum, right_sum) max_sum = float('-inf') helper(root) return max_sum"},{"question":"def filter_palindromes(strings): Given a list of strings, return a new list containing the strings that are palindromes. A palindrome is a word that reads the same backward as forward after converting all letters to lowercase. Your implementation should be case insensitive. >>> filter_palindromes(['racecar', 'radar', 'apple', 'level', 'banana']) ['racecar', 'radar', 'level'] >>> filter_palindromes(['Deified', 'civic', 'rotor', 'hello', 'madam']) ['Deified', 'civic', 'rotor', 'madam'] >>> filter_palindromes(['Palindrome', 'Noon', 'refer', 'world']) ['Noon', 'refer'] >>> filter_palindromes(['']) [''] >>> filter_palindromes(['12321', '45654', 'apple', 'civic']) ['12321', '45654', 'civic'] pass # Unit Test def test_filter_palindromes_basic(): assert filter_palindromes(['racecar', 'radar', 'apple', 'level', 'banana']) == ['racecar', 'radar', 'level'] def test_filter_palindromes_mixed_case(): assert filter_palindromes(['Deified', 'civic', 'rotor', 'hello', 'madam']) == ['Deified', 'civic', 'rotor', 'madam'] def test_filter_palindromes_with_capitalization(): assert filter_palindromes(['Palindrome', 'Noon', 'refer', 'world']) == ['Noon', 'refer'] def test_filter_palindromes_empty_string(): assert filter_palindromes(['']) == [''] def test_filter_palindromes_with_numbers(): assert filter_palindromes(['12321', '45654', 'apple', 'civic']) == ['12321', '45654', 'civic'] def test_filter_palindromes_single_character(): assert filter_palindromes(['a', 'b', 'c']) == ['a', 'b', 'c'] def test_filter_palindromes_no_palindromes(): assert filter_palindromes(['apple', 'banana', 'pear']) == []","solution":"def filter_palindromes(strings): Returns a list containing the strings that are palindromes from the input list. A palindrome is a word that reads the same backward as forward after converting all letters to lowercase. return [s for s in strings if s.lower() == s[::-1].lower()]"},{"question":"def longest_substring_with_two_distinct_chars(s: str) -> str: Returns the longest contiguous substring that contains at most 2 distinct characters. If there are multiple substrings with the same maximum length, return the first one that appears in the string. >>> longest_substring_with_two_distinct_chars(\\"abcbbbbcccbdddadacb\\") 'bcbbbbcccb' >>> longest_substring_with_two_distinct_chars(\\"a\\") 'a' >>> longest_substring_with_two_distinct_chars(\\"ab\\") 'ab' >>> longest_substring_with_two_distinct_chars(\\"aaaa\\") 'aaaa' >>> longest_substring_with_two_distinct_chars(\\"\\") '' >>> longest_substring_with_two_distinct_chars(\\"abcde\\") 'ab' >>> longest_substring_with_two_distinct_chars(\\"aabbcc\\") 'aabb'","solution":"def longest_substring_with_two_distinct_chars(s): Returns the longest contiguous substring that contains at most 2 distinct characters. If there are multiple substrings with the same maximum length, return the first one that appears in the string. if not s: return \\"\\" left = 0 max_length = 0 max_substring = \\"\\" char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if right - left + 1 > max_length: max_length = right - left + 1 max_substring = s[left:right+1] return max_substring"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Given a list of stock prices, finds the maximum profit achievable by buying and selling the stock once. Returns 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([1, 2]) 1 >>> max_profit([3, 3, 3, 3]) 0 def process_test_cases(test_cases: List[List[int]]) -> List[int]: Given a list of test cases where each test case is a list of stock prices over consecutive days, returns a list of maximum possible profits for each test case. >>> process_test_cases([[7, 1, 5, 3, 6, 4], [1, 2], [3, 3, 3, 3]]) [5, 1, 0]","solution":"def max_profit(prices): Given a list of stock prices, finds the maximum profit achievable by buying and selling the stock once. Returns 0 if no profit is possible. min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def process_test_cases(test_cases): Given a list of test cases where each test case is a list of stock prices over consecutive days, returns a list of maximum possible profits for each test case. results = [] for prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"from datetime import datetime def check_if_all_returned_on_time(N: int, users_info: List[str]) -> str: Checks if all users have returned their books on time. Args: N: int: Number of users users_info: List[str]: List containing the status of book returns Returns: str: \\"YES\\" if all users have returned their books on time, otherwise \\"NO\\" followed by the user ID of the first user who has an overdue book. >>> check_if_all_returned_on_time(3, [\\"2023-09-10 2023-09-09 U1\\", \\"2023-09-11 2023-09-10 U2\\", \\"2023-09-12 2023-09-12 U3\\"]) 'YES' >>> check_if_all_returned_on_time(3, [\\"2023-09-10 2023-09-09 U1\\", \\"2023-09-11 2023-09-12 U2\\", \\"2023-09-12 2023-09-12 U3\\"]) 'NOnU2' >>> check_if_all_returned_on_time(2, [\\"2023-09-10 NOT-RETURNED U1\\", \\"2023-09-11 2023-09-10 U2\\"]) 'NOnU1' >>> check_if_all_returned_on_time(4, [\\"2023-09-10 2023-09-10 U1\\", \\"2023-09-11 2023-09-12 U2\\", \\"2023-09-12 NOT-RETURNED U3\\", \\"2023-09-10 2023-09-09 U4\\"]) 'NOnU2'","solution":"from datetime import datetime def check_if_all_returned_on_time(N, users_info): for user_info in users_info: due_date_str, return_date_str, user_id = user_info.split() due_date = datetime.strptime(due_date_str, \\"%Y-%m-%d\\") if return_date_str == \\"NOT-RETURNED\\": return \\"NOn\\" + user_id return_date = datetime.strptime(return_date_str, \\"%Y-%m-%d\\") if return_date > due_date: return \\"NOn\\" + user_id return \\"YES\\""},{"question":"def max_cards(T: int, test_cases: List[List[Union[int, List[int]]]]) -> List[int]: Find the maximum number of cards collected for each test case such that the absolute difference between the rareness of any two chosen cards is at most K. >>> max_cards(2, [[5, 3, [1, 2, 2, 3, 4]], [4, 1, [1, 5, 9, 13]]]) == [5, 1] >>> max_cards(1, [[1, 0, [5]]]) == [1] >>> max_cards(1, [[5, 0, [7, 7, 7, 7, 7]]]) == [5] >>> max_cards(1, [[5, 1000000, [1, 1000, 100000, 10000, 100]]]) == [5] >>> max_cards(1, [[6, 0, [1, 2, 3, 4, 5, 6]]]) == [1] >>> max_cards(1, [[4, 1, [1, 10, 20, 30]]]) == [1] >>> max_cards(1, [[3, 1, [1, 2, 3]]]) == [3]","solution":"def max_cards(T, test_cases): results = [] for case in test_cases: n, K, cards = case cards.sort() max_count = 1 current_count = 1 for i in range(1, n): if cards[i] - cards[i-1] <= K: current_count += 1 else: max_count = max(max_count, current_count) current_count = 1 max_count = max(max_count, current_count) results.append(max_count) return results"},{"question":"class Node(): def __init__(self, data, next=None): self.data = data self.next = next def reverse_list(head): Reverses a singly linked list and returns the new head of the reversed list. >>> head = Node(1, Node(2, Node(3))) >>> reversed_head = reverse_list(head) >>> reversed_head.data == 3 True >>> reversed_head.next.data == 2 True >>> reversed_head.next.next.data == 1 True >>> reversed_head.next.next.next == None True >>> head = Node(0, Node(1, Node(4, Node(9, Node(16))))) >>> reversed_head = reverse_list(head) >>> reversed_head.data == 16 True >>> reversed_head.next.data == 9 True >>> reversed_head.next.next.data == 4 True >>> reversed_head.next.next.next.data == 1 True >>> reversed_head.next.next.next.next.data == 0 True >>> reversed_head.next.next.next.next.next == None True","solution":"class Node(): def __init__(self, data, next=None): self.data = data self.next = next def reverse_list(head): Reverses a singly linked list and returns the new head of the reversed list. previous = None current = head while current: next_node = current.next # temporarily store the next node current.next = previous # reverse the current node's pointer previous = current # move the previous to this node current = next_node # move to the next node in the original list return previous"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a new array where each element at index i is the product of all the numbers in the original array except the one at i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([10]) [1] >>> product_except_self([]) [] def test_product_except_self_normal_case(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] def test_product_except_self_with_zero(): assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] def test_product_except_self_all_positive(): assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] def test_product_except_self_single_element(): assert product_except_self([10]) == [1] def test_product_except_self_empty_array(): assert product_except_self([]) == [] def test_product_except_self_negative_numbers(): assert product_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] def test_product_except_self_mixed_numbers(): assert product_except_self([2, -3, 4, -5]) == [60, -40, 30, -24]","solution":"def product_except_self(nums): Returns a new array where each element at index i is the product of all the numbers in the original array except the one at i. n = len(nums) if n == 0: return [] if n == 1: return [1] left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i-1] * nums[i-1] for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * nums[i+1] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def recommend_books(books: List[Tuple[str, float, float]], k: int) -> List[str]: Recommends the top k books based on their ratings. In case of tie in ratings: 1. Recommend the higher-priced book. 2. If price is also tied, recommend based on alphabetical order of the title. :param books: List of tuples (title, price, rating) :param k: Number of top books to recommend :return: List of recommended book titles >>> books = [(\\"Book A\\", 10.99, 4.5), ... (\\"Book B\\", 12.99, 4.7), ... (\\"Book C\\", 9.99, 4.7), ... (\\"Book D\\", 13.99, 4.2)] >>> k = 2 >>> recommend_books(books, k) [\\"Book B\\", \\"Book C\\"] >>> books = [(\\"Book X\\", 15.99, 4.3), ... (\\"Book Y\\", 8.99, 4.3), ... (\\"Book Z\\", 13.99, 4.1)] >>> k = 1 >>> recommend_books(books, k) [\\"Book X\\"] >>> books = [(\\"Book R\\", 11.99, 4.8), ... (\\"Book S\\", 17.99, 4.8), ... (\\"Book T\\", 11.99, 4.8), ... (\\"Book U\\", 9.99, 4.6)] >>> k = 2 >>> recommend_books(books, k) [\\"Book S\\", \\"Book R\\"]","solution":"def recommend_books(books, k): Recommends the top k books based on their ratings. In case of tie in ratings: 1. Recommend the higher-priced book. 2. If price is also tied, recommend based on alphabetical order of the title. :param books: List of tuples (title, price, rating) :param k: Number of top books to recommend :return: List of recommended book titles sorted_books = sorted(books, key=lambda x: (-x[2], -x[1], x[0])) return [book[0] for book in sorted_books[:k]]"},{"question":"def product_of_all_other_numbers(nums): Given a list of integers, returns a list where each integer is replaced with the product of all other integers in the list, without using division. pass # Unit Tests def test_example_1(): assert product_of_all_other_numbers([1, 2, 3, 4]) == [24, 12, 8, 6] def test_example_2(): assert product_of_all_other_numbers([5, 6, 2, 3]) == [36, 30, 90, 60] def test_single_value(): assert product_of_all_other_numbers([10]) == [1] def test_all_zeros(): assert product_of_all_other_numbers([0, 0, 0, 0]) == [0, 0, 0, 0] def test_one_zero(): assert product_of_all_other_numbers([1, 0, 3, 4]) == [0, 12, 0, 0] def test_two_elements(): assert product_of_all_other_numbers([3, 4]) == [4, 3] def test_negative_numbers(): assert product_of_all_other_numbers([-1, 2, -3, 4]) == [-24, 12, -8, 6] def test_mix_of_positive_and_negative_numbers(): assert product_of_all_other_numbers([-1, 2, 0, -4]) == [0, 0, 8, 0]","solution":"def product_of_all_other_numbers(nums): Given a list of integers, returns a list where each integer is replaced with the product of all other integers in the list, without using division. length = len(nums) # Initialize the lists to keep track of the left and right products left_products = [1] * length right_products = [1] * length # Fill the left_products array for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill the right_products array for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Create the result array by multiplying left and right products result = [left_products[i] * right_products[i] for i in range(length)] return result"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Determine the minimum number of operations required to make all elements of the array equal. In one operation, you can select any subarray of odd length and replace all elements with the median of the subarray. >>> min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) 4 >>> min_operations_to_equal_elements(3, [3, 3, 3]) 0 pass # Unit Test from solution import min_operations_to_equal_elements def test_all_elements_equal(): assert min_operations_to_equal_elements(3, [3, 3, 3]) == 0 def test_distinct_elements(): assert min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) == 4 def test_mixed_elements(): assert min_operations_to_equal_elements(5, [1, 2, 3, 2, 1]) == 2 def test_another_mixed_elements(): assert min_operations_to_equal_elements(7, [4, 4, 6, 6, 6, 5, 4]) == 2 def test_with_one_element(): assert min_operations_to_equal_elements(1, [1]) == 0","solution":"def min_operations_to_equal_elements(n, arr): unique_elements = set(arr) return len(unique_elements) - 1"},{"question":"def zigzag_array(arr: List[int], k: int) -> List[int]: Reorganizes an array of integers in a zigzag fashion. Parameters: arr (List[int]): Input array of integers k (int): Number of elements from the beginning to consider for zigzagging Returns: List[int]: Zigzag arranged array Examples: >>> zigzag_array([1, 4, 3, 2, 5], 5) [1, 4, 2, 5, 3] >>> zigzag_array([7, 1, 5, 4], 3) [1, 7, 4] >>> zigzag_array([9, 8, 7, 6, 5], 4) [8, 9, 6, 7] >>> zigzag_array([1, 2, 3], 5) [1, 3, 2] >>> zigzag_array([3, 1], 1) [3, 1]","solution":"def zigzag_array(arr, k): Reorganizes an array of integers in a zigzag fashion. Parameters: arr (List[int]): Input array of integers k (int): Number of elements from the beginning to consider for zigzagging Returns: List[int]: Zigzag arranged array if len(arr) <= 1 or k <= 1: return arr n = min(len(arr), k) result = arr[:n] for i in range(n-1): if (i % 2 == 0 and result[i] > result[i+1]) or (i % 2 == 1 and result[i] < result[i+1]): result[i], result[i+1] = result[i+1], result[i] return result + arr[n:]"},{"question":"def trap(height: List[int]) -> int: Returns the total volume of water that can be trapped after raining given the elevation map. Parameters: - height: List[int]: An array of integers representing the elevation map Returns: - int: The total volume of trapped water Example: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 pass from solution import trap def test_trap_example1(): assert trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_example2(): assert trap([4, 2, 0, 3, 2, 5]) == 9 def test_trap_no_water(): assert trap([1, 1, 1, 1, 1]) == 0 def test_trap_single_element(): assert trap([4]) == 0 def test_trap_empty(): assert trap([]) == 0 def test_trap_increasing(): assert trap([1, 2, 3, 4, 5]) == 0 def test_trap_decreasing(): assert trap([5, 4, 3, 2, 1]) == 0","solution":"def trap(height): Returns the total volume of water that can be trapped after raining given the elevation map. Parameters: - height: List[int]: An array of integers representing the elevation map Returns: - int: The total volume of trapped water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"from typing import List, Tuple def box_run(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Calculate the total time required for each test case in the Box Run game. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int, int]]): List of test cases, each a tuple containing three integers N (number of players), P (time interval in seconds), and K (target number of passes). Returns: List[int]: List of total times (in seconds) required for each test case to finish the game. pass # Example usage and test cases def test_box_run(): assert box_run(2, [(5, 2, 10), (3, 1, 5)]) == [20, 5] assert box_run(1, [(2, 100, 10000)]) == [1000000] assert box_run(3, [(1000000, 10, 5), (2, 5, 5), (10, 1, 1)]) == [50, 25, 1] assert box_run(2, [(10, 1000, 100000000), (5, 2, 500000000)]) == [100000000000, 1000000000] assert box_run(1, [(20, 50, 200)]) == [10000] test_box_run()","solution":"def box_run(T, test_cases): This function calculates the time required for each test case in the Box Run game. Parameters: T (int): number of test cases test_cases (list of tuple): each tuple contains three integers - N (number of players), P (time interval in seconds), and K (target number of passes). Returns: list: list of total times (in seconds) required for each test case to finish the game results = [] for case in test_cases: N, P, K = case total_time = K * P results.append(total_time) return results"},{"question":"def calculateTotalFunctionalValue(M: int, N: int) -> int: Calculate the total functional value of a batch of gears. :param M: Number of small gears :param N: Number of large gears (each large gear equal to 3 small gears) :return: Total functional value of the batch >>> calculateTotalFunctionalValue(4, 2) 10 >>> calculateTotalFunctionalValue(7, 1) 10 >>> calculateTotalFunctionalValue(5, 0) 5 >>> calculateTotalFunctionalValue(0, 3) 9 >>> calculateTotalFunctionalValue(0, 0) 0 >>> calculateTotalFunctionalValue(100, 50) 250 >>> calculateTotalFunctionalValue(-4, 2) 2 >>> calculateTotalFunctionalValue(4, -2) -2 >>> calculateTotalFunctionalValue(-4, -2) -10","solution":"def calculateTotalFunctionalValue(M, N): Calculate the total functional value of a batch of gears. :param M: Number of small gears :param N: Number of large gears (each large gear equal to 3 small gears) :return: Total functional value of the batch return M + (N * 3)"},{"question":"from collections import OrderedDict class Cache: Implements a Least Recently Used (LRU) caching mechanism with a maximum size \`n\`. Methods: - put(key, value): Insert or update the value associated with the key. - get(key): Return the value associated with the key if it exists; otherwise, return -1. - most_recent: Return the most recently used key. Example: cache = Cache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) # returns 1 cache.put(3, 3) # evicts key 2 cache.get(2) # returns -1 (not found) cache.put(4, 4) # evicts key 1 cache.get(1) # returns -1 (not found) cache.get(3) # returns 3 cache.get(4) # returns 4 cache.most_recent() # returns 4 def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def put(self, key: int, value: int) -> None: Insert or update the value associated with the key. def get(self, key: int) -> int: Return the value associated with the key if it exists; otherwise, return -1. def most_recent(self) -> int: Return the most recently used key. If the cache is empty, return -1. def test_put_get_basic(): cache = Cache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 assert cache.get(2) == 2 def test_cache_eviction(): cache = Cache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == -1 # 1 should be evicted assert cache.get(2) == 2 assert cache.get(3) == 3 def test_update_existing(): cache = Cache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) # update value of key 1 assert cache.get(1) == 10 def test_most_recent(): cache = Cache(2) cache.put(1, 1) cache.put(2, 2) assert cache.most_recent() == 2 cache.get(1) assert cache.most_recent() == 1 cache.put(3, 3) assert cache.most_recent() == 3 def test_cache_with_capacity_one(): cache = Cache(1) cache.put(1, 1) assert cache.get(1) == 1 cache.put(2, 2) assert cache.get(1) == -1 # 1 should be evicted assert cache.get(2) == 2 def test_cache_empty(): cache = Cache(2) assert cache.get(1) == -1 # cache is empty assert cache.most_recent() == -1 # no element in cache","solution":"from collections import OrderedDict class Cache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value def get(self, key: int) -> int: if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def most_recent(self) -> int: if not self.cache: return -1 return next(reversed(self.cache))"},{"question":"def decode_string(s: str) -> str: Decodes the given encoded string according to the encoding rule k[encoded_string]. Parameters: s (str): The encoded string Returns: str: The decoded string Examples: >>> decode_string(\\"3[a]\\") 'aaa' >>> decode_string(\\"3[a2[c]]\\") 'accaccacc' >>> decode_string(\\"2[abc3[cd]ef]\\") 'abccdcdcdefabccdcdcdef' >>> decode_string(\\"abc\\") 'abc' >>> decode_string(\\"10[a]\\") 'aaaaaaaaaa' >>> decode_string(\\"2[a2[b]3[c]]\\") 'abbcccabbccc' pass def test_single_repetition(): assert decode_string(\\"3[a]\\") == \\"aaa\\" def test_nested_repetition(): assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" def test_multiple_nested_repetition(): assert decode_string(\\"2[abc3[cd]ef]\\") == \\"abccdcdcdefabccdcdcdef\\" def test_no_repetition(): assert decode_string(\\"abc\\") == \\"abc\\" def test_single_character(): assert decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\" def test_different_characters(): assert decode_string(\\"2[a2[b]3[c]]\\") == \\"abbcccabbccc\\"","solution":"def decode_string(s: str) -> str: Decodes the given encoded string according to the encoding rule k[encoded_string]. Parameters: s (str): The encoded string Returns: str: The decoded string stack = [] current_num = 0 current_string = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = '' current_num = 0 elif char == ']': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"def factorial(n: int) -> int: Returns the factorial of the given number n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(7) 5040 pass def process_input(input_list: List[int]) -> List[int]: Processes input and calculates factorial for each number in the list. Args: input_list : list of integers where the first element is the number of test cases and the subsequent elements are the numbers for which the factorial needs to be calculated. Returns: list of integers : contains the results of factorial calculations >>> process_input([1, 5]) [120] >>> process_input([4, 1, 2, 5, 7]) [1, 2, 120, 5040] >>> process_input([2, 0, 20]) [1, 2432902008176640000] pass","solution":"def factorial(n): Returns the factorial of the given number n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def process_input(input_list): Processes input and calculates factorial for each number in the list. Args: input_list : list of integers where the first element is the number of test cases and the subsequent elements are the numbers for which the factorial needs to be calculated. Returns: list of integers : contains the results of factorial calculations N = input_list[0] results = [] for i in range(1, N + 1): results.append(factorial(input_list[i])) return results"},{"question":"def to_uppercase(word): Converts the word to uppercase. pass def starts_with_vowel(word): Returns True if the word starts with a vowel, False otherwise. pass def filter_and_transform_words(n, words): Filters words that start with a vowel and transforms them to uppercase. Parameters: n (int): Number of words (not used in function but included for context) words (list of str): List of words Returns: str: Space-separated string of filtered and transformed words pass from solution import filter_and_transform_words def test_filter_and_transform_words_all_vowels(): assert filter_and_transform_words(5, [\\"apple\\", \\"orange\\", \\"umbrella\\", \\"eagle\\", \\"igloo\\"]) == \\"APPLE ORANGE UMBRELLA EAGLE IGLOO\\" def test_filter_and_transform_words_no_vowels(): assert filter_and_transform_words(5, [\\"banana\\", \\"peach\\", \\"grape\\", \\"kiwi\\", \\"mango\\"]) == \\"\\" def test_filter_and_transform_words_mixed(): assert filter_and_transform_words(5, [\\"apple\\", \\"orange\\", \\"banana\\", \\"umbrella\\", \\"peach\\"]) == \\"APPLE ORANGE UMBRELLA\\" def test_filter_and_transform_words_single_word_vowel(): assert filter_and_transform_words(1, [\\"apple\\"]) == \\"APPLE\\" def test_filter_and_transform_words_single_word_no_vowel(): assert filter_and_transform_words(1, [\\"banana\\"]) == \\"\\"","solution":"def to_uppercase(word): Converts the word to uppercase. return word.upper() def starts_with_vowel(word): Returns True if the word starts with a vowel, False otherwise. return word[0].lower() in 'aeiou' def filter_and_transform_words(n, words): Filters words that start with a vowel and transforms them to uppercase. Parameters: n (int): Number of words (not used in function but included for context) words (list of str): List of words Returns: str: Space-separated string of filtered and transformed words filtered_words = filter(starts_with_vowel, words) transformed_words = map(to_uppercase, filtered_words) return ' '.join(transformed_words)"},{"question":"from typing import List def three_multiples(numbers: List[int]) -> List[int]: Returns a new list formed by appending all the multiples of 3 from the input list in the order they appear, followed by all other integers in reverse order. >>> three_multiples([1, 2, 3, 4, 5, 6, 7, 8, 9]) [3, 6, 9, 8, 7, 5, 4, 2, 1] >>> three_multiples([10, 3, 5, 9, 2, 15]) [3, 9, 15, 2, 5, 10] >>> three_multiples([10, 5, 8, 11]) [11, 8, 5, 10] >>> three_multiples([9, 18, 12, 6, 3]) [9, 18, 12, 6, 3]","solution":"from typing import List def three_multiples(numbers: List[int]) -> List[int]: Returns a new list formed by appending all the multiples of 3 from the input list in the order they appear, followed by all other integers in reverse order. multiples_of_three = [num for num in numbers if num % 3 == 0] non_multiples_of_three = [num for num in numbers if num % 3 != 0] return multiples_of_three + non_multiples_of_three[::-1]"},{"question":"def generate_subsets(nums): Given a list of unique integers, this function generates all possible subsets (the power set) of that list. The solution set does not contain duplicate subsets and is returned in a list where the elements are lists representing subsets. The subsets are sorted in ascending order of their elements, and the list of subsets is sorted lexicographically. >>> generate_subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> generate_subsets([9, 0, 2]) [[], [0], [0, 2], [0, 2, 9], [0, 9], [2], [2, 9], [9]]","solution":"def generate_subsets(nums): Returns the power set of the given list of unique integers as a list of sorted subsets. The subsets are sorted lexicographically. def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) result = [] nums.sort() backtrack(0, []) return result"},{"question":"from typing import List, Tuple def process_operations(operations: List[str]) -> List[int]: Processes a sequence of operations on an initially empty array and returns the results of SUM queries. Args: operations (list): A list of operations represented as strings. Returns: list: A list of integers representing the results of SUM queries. >>> process_operations([\\"INSERT 5\\", \\"INSERT 3\\", \\"SUM 2\\", \\"DELETE\\", \\"INSERT 10\\", \\"INSERT 7\\", \\"SUM 3\\"]) [8, 22] >>> process_operations([\\"INSERT 1\\", \\"INSERT 2\\", \\"SUM 2\\", \\"INSERT 3\\", \\"SUM 3\\"]) [3, 6] >>> process_operations([\\"INSERT 4\\", \\"INSERT 5\\", \\"DELETE\\", \\"INSERT 7\\", \\"SUM 2\\", \\"DELETE\\", \\"SUM 1\\"]) [11, 4] >>> process_operations([\\"INSERT 6\\", \\"SUM 1\\"]) [6] >>> process_operations([\\"INSERT 8\\", \\"INSERT 10\\", \\"DELETE\\", \\"DELETE\\", \\"INSERT 15\\", \\"SUM 1\\"]) [15]","solution":"def process_operations(operations): Processes a sequence of operations on an initially empty array and returns the results of SUM queries. Args: operations (list): A list of operations represented as strings. Returns: list: A list of integers representing the results of SUM queries. array = [] results = [] for operation in operations: parts = operation.split() if parts[0] == 'INSERT': array.append(int(parts[1])) elif parts[0] == 'DELETE': if array: array.pop() elif parts[0] == 'SUM': k = int(parts[1]) results.append(sum(array[-k:])) return results"},{"question":"from typing import List def sort_queries_by_frequency(queries: List[str]) -> List[str]: This function takes an array of customer queries and returns an array of the queries sorted by the frequency of their appearance. Queries that appear more frequently come before less frequent ones. If two queries have the same frequency, they are sorted in the order of their first appearance. >>> sort_queries_by_frequency([]) == [] >>> sort_queries_by_frequency([\\"help\\"]) == [\\"help\\"] >>> sort_queries_by_frequency([\\"help\\", \\"account\\", \\"help\\", \\"support\\", \\"account\\", \\"support\\", \\"support\\"]) == [\\"support\\", \\"help\\", \\"account\\"] >>> sort_queries_by_frequency([\\"help\\", \\"account\\", \\"support\\", \\"help\\", \\"account\\", \\"support\\"]) == [\\"help\\", \\"account\\", \\"support\\"] >>> sort_queries_by_frequency([\\"reset\\", \\"account\\", \\"help\\", \\"reset\\", \\"account\\", \\"support\\", \\"reset\\"]) == [\\"reset\\", \\"account\\", \\"help\\", \\"support\\"] # Implementation here","solution":"from collections import Counter def sort_queries_by_frequency(queries): This function takes an array of customer queries and returns an array of the queries sorted by the frequency of their appearance. Queries that appear more frequently come before less frequent ones. If two queries have the same frequency, they are sorted in the order of their first appearance. if not queries: return [] # Count frequencies and preserve the order of first appearance query_counter = Counter(queries) unique_queries = list(dict.fromkeys(queries)) # Sort queries by frequency and first appearance order unique_queries.sort(key=lambda x: (-query_counter[x], queries.index(x))) return unique_queries"},{"question":"def longest_subarray_with_sum_k(arr: List[int], k: int) -> int: Finds the length of the longest contiguous subarray with sum equal to k. Parameters: arr (list of int): List of integers representing the array. k (int): The target sum. Returns: int: The length of the longest contiguous subarray with sum equal to k. >>> longest_subarray_with_sum_k([1, 2, 3, 4, 5], 5) 2 >>> longest_subarray_with_sum_k([5], 5) 1 >>> longest_subarray_with_sum_k([1, 2, 3], 7) 0 >>> longest_subarray_with_sum_k([1, 2, 2], 5) 3 >>> longest_subarray_with_sum_k([1, 1, 1, 1, 1, 1], 2) 2 >>> longest_subarray_with_sum_k([-1, 2, 3, -2, 5], 4) 3 >>> longest_subarray_with_sum_k([1, 2, 3, 4, 5], 50) 0 >>> longest_subarray_with_sum_k([1, -1, 2, -2], 0) 4","solution":"def longest_subarray_with_sum_k(arr, k): Finds the length of the longest contiguous subarray with sum equal to k. Parameters: arr (list of int): List of integers representing the array. k (int): The target sum. Returns: int: The length of the longest contiguous subarray with sum equal to k. prefix_sum = 0 sum_map = {0: -1} max_length = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum - k in sum_map: max_length = max(max_length, i - sum_map[prefix_sum - k]) if prefix_sum not in sum_map: sum_map[prefix_sum] = i return max_length"},{"question":"from typing import List def collect_max_gold(grid: List[List[int]]) -> int: You are given a two-dimensional grid of potentially varying row lengths, where each cell represents the amount of gold in that particular cell. You may start from any position in the grid and move to an adjacent cell (up, down, left, or right) to collect gold until you decide to stop. However, you cannot visit a cell more than once during your traverse for each collection attempt. Write a function to find the maximum amount of gold you can collect. Args: grid (List[List[int]]): 2D grid representing the amount of gold in each cell Returns: int: Maximum amount of gold that can be collected Example: >>> collect_max_gold([ [0, 6, 0], [5, 8, 7], [0, 9, 0] ]) 24 >>> collect_max_gold([ [1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0] ]) 28 def test_collect_max_gold(): grid = [ [0, 6, 0], [5, 8, 7], [0, 9, 0] ] assert collect_max_gold(grid) == 24 def test_collect_max_gold_single_element(): grid = [ [4] ] assert collect_max_gold(grid) == 4 def test_collect_max_gold_no_gold(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert collect_max_gold(grid) == 0 def test_collect_max_gold_all_zeros_exempt_one(): grid = [ [0, 0, 0], [0, 5, 0], [0, 0, 0] ] assert collect_max_gold(grid) == 5 def test_collect_max_gold_rectangular_grid(): grid = [ [1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0] ] assert collect_max_gold(grid) == 28","solution":"from typing import List def collect_max_gold(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 max_gold = 0 rows, cols = len(grid), len(grid[0]) def dfs(x, y, current_gold): nonlocal max_gold if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] == 0: return old_gold = grid[x][y] grid[x][y] = 0 # Mark as visited current_gold += old_gold max_gold = max(max_gold, current_gold) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, current_gold) grid[x][y] = old_gold # Unmark for i in range(rows): for j in range(cols): if grid[i][j] > 0: dfs(i, j, 0) return max_gold"},{"question":"def sort_descending(lst: List[int]) -> List[int]: Sorts a list of integers in descending order without using any built-in sort function. Parameters: lst (list of int): List of integers to be sorted Returns: list of int: Sorted list of integers in descending order from typing import List # Test cases to validate the solution def test_sort_descending_single_element(): assert sort_descending([1]) == [1] def test_sort_descending_already_sorted(): assert sort_descending([9, 7, 5, 3, 1]) == [9, 7, 5, 3, 1] def test_sort_descending_unsorted_list(): assert sort_descending([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1] def test_sort_descending_with_negative_numbers(): assert sort_descending([10, -1, 2, 8, 0]) == [10, 8, 2, 0, -1] def test_sort_descending_all_negative_numbers(): assert sort_descending([-1, -10, -5, -2, -8]) == [-1, -2, -5, -8, -10] def test_sort_descending_all_zeros(): assert sort_descending([0, 0, 0]) == [0, 0, 0] def test_sort_descending_with_duplicate_numbers(): assert sort_descending([1, 2, 3, 2, 1, 2]) == [3, 2, 2, 2, 1, 1]","solution":"def sort_descending(lst): Sorts a list of integers in descending order using the bubble sort algorithm. Parameters: lst (list of int): List of integers to be sorted Returns: list of int: Sorted list of integers in descending order n = len(lst) for i in range(n): for j in range(0, n-i-1): if lst[j] < lst[j+1]: lst[j], lst[j+1] = lst[j+1], lst[j] return lst"},{"question":"import math from typing import List, Tuple def product(A: int, B: int) -> int: Returns the product P(A, B), defined as the factorial of the larger of two numbers A and B. If either A or B is 0, returns 1 (since the factorial of 0 is 1). pass def process_queries(T: int, queries: List[Tuple[int, int]]) -> List[int]: Processes T queries and returns a list with results for each query. >>> process_queries(5, [(3, 4), (0, 5), (6, 6), (1, 0), (7, 2)]) [24, 1, 720, 1, 5040] >>> process_queries(1, [(10, 10)]) [3628800] >>> process_queries(3, [(20, 15), (0, 0), (13, 5)]) [2432902008176640000, 1, 6227020800] pass","solution":"import math def product(A, B): Returns the product P(A, B), defined as the factorial of the larger of two numbers A and B. If either A or B is 0, returns 1 (since the factorial of 0 is 1). if A == 0 or B == 0: return 1 return math.factorial(max(A, B)) def process_queries(T, queries): Processes T queries and returns a list with results for each query. results = [] for A, B in queries: results.append(product(A, B)) return results"},{"question":"def sort_by_length(arr): Returns a new array of the strings sorted by their lengths in ascending order. If two strings have the same length, their relative order should be the same as in the original array. Parameters: arr (list): An array of strings. Returns: list: A new array of strings sorted by their lengths. Examples: >>> sort_by_length([\\"apple\\", \\"pie\\", \\"a\\", \\"banana\\", \\"grape\\"]) ['a', 'pie', 'apple', 'grape', 'banana'] >>> sort_by_length([\\"bat\\", \\"cat\\", \\"ant\\", \\"dog\\"]) ['bat', 'cat', 'ant', 'dog'] from solution import sort_by_length def test_sort_by_length_basic(): assert sort_by_length([\\"apple\\", \\"pie\\", \\"a\\", \\"banana\\", \\"grape\\"]) == [\\"a\\", \\"pie\\", \\"apple\\", \\"grape\\", \\"banana\\"] def test_sort_by_length_same_length(): assert sort_by_length([\\"bat\\", \\"cat\\", \\"ant\\", \\"dog\\"]) == [\\"bat\\", \\"cat\\", \\"ant\\", \\"dog\\"] def test_sort_by_length_empty_strings(): assert sort_by_length([\\"\\", \\"a\\", \\"aaa\\", \\"aa\\"]) == [\\"\\", \\"a\\", \\"aa\\", \\"aaa\\"] def test_sort_by_length_mixed_order(): assert sort_by_length([\\"aaaa\\", \\"b\\", \\"ccc\\", \\"dd\\"]) == [\\"b\\", \\"dd\\", \\"ccc\\", \\"aaaa\\"] def test_sort_by_length_all_same_length(): assert sort_by_length([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) == [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"] def test_sort_by_length_single_element(): assert sort_by_length([\\"onlyone\\"]) == [\\"onlyone\\"] def test_sort_by_length_no_elements(): assert sort_by_length([]) == []","solution":"def sort_by_length(arr): Returns a new array of the strings sorted by their lengths in ascending order. If two strings have the same length, their relative order should be the same as in the original array. Parameters: arr (list): An array of strings. Returns: list: A new array of strings sorted by their lengths. return sorted(arr, key=len)"},{"question":"def graph_coloring(graph): Determine the minimum number of colors needed to color the graph. :param graph: dict - adjacency list representing the graph :return: int - minimum number of colors required >>> graph_coloring({ ... 0: [1, 2], ... 1: [0, 2], ... 2: [0, 1, 3], ... 3: [2] ... }) # Output: 3 >>> graph_coloring({ ... 0: [1, 2, 3], ... 1: [0, 2], ... 2: [0, 1, 3], ... 3: [0, 2] ... }) # Output: 3 pass # Unit Tests def test_graph_coloring_example1(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } assert graph_coloring(graph) == 3 def test_graph_coloring_example2(): graph = { 0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2] } assert graph_coloring(graph) == 3 def test_graph_coloring_single_vertex(): graph = { 0: [] } assert graph_coloring(graph) == 1 def test_graph_coloring_disconnected_graph(): graph = { 0: [1], 1: [0], 2: [3], 3: [2] } assert graph_coloring(graph) == 2 def test_graph_coloring_line_graph(): graph = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2, 4], 4: [3] } assert graph_coloring(graph) == 2 def test_graph_coloring_large_graph(): graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 4], 3: [1, 5], 4: [2, 6], 5: [3], 6: [4] } assert graph_coloring(graph) == 3","solution":"def graph_coloring(graph): Determine the minimum number of colors needed to color the graph. :param graph: dict - adjacency list representing the graph :return: int - minimum number of colors required # Initialize coloring for all vertices as -1. color_result = {vertex: -1 for vertex in graph} # Assign the first color to the first vertex color_result[0] = 0 # Temporary array to store the available colors. True means available. available_colors = [True] * len(graph) # Assign colors to the remaining vertices for vertex in graph: # Process all adjacent vertices and mark their colors as unavailable for adjacent in graph[vertex]: if color_result[adjacent] != -1: available_colors[color_result[adjacent]] = False # Find the first available color for color in range(len(graph)): if available_colors[color]: color_result[vertex] = color break # Reset the available colors for the next iteration available_colors = [True] * len(graph) # The number of colors used is the highest numbered color + 1 return max(color_result.values()) + 1"},{"question":"def highest_product_of_three(arr): Calculate the largest possible product of any three integers in the array. Parameters: arr (list): List of integers. Returns: int: The maximum product of any three integers in the array. pass # Example Inputs and outputs print(highest_product_of_three([1, 10, 2, 6, 5, 3])) # Output: 300 - Explanation: The highest product is 10 * 6 * 5 = 300 print(highest_product_of_three([-10, -10, 1, 3, 2])) # Output: 300 - Explanation: The highest product is obtained by multiplying the two negative numbers resulting in a positive product: -10 * -10 * 3 = 300 print(highest_product_of_three([5, 9, 1, 7, 8, -3])) # Output: 504 - Explanation: The highest product is 9 * 8 * 7 = 504","solution":"def highest_product_of_three(arr): Calculate the largest possible product of any three integers in the array. Parameters: arr (list): List of integers. Returns: int: The maximum product of any three integers in the array. arr.sort() # The max product is either from the three largest numbers or from two smallest and one largest. max_product = max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]) return max_product"},{"question":"from typing import List def validate_employee_id(T: int, ids: List[str]) -> List[str]: Validates the format of employee IDs. Parameters: - T (int): Number of test cases. - ids (list of str): List of employee ID strings to validate. Returns: - list of str: List of \\"VALID\\" or \\"INVALID\\" for each ID based on validation. pass # Test cases def test_basic_cases(): assert validate_employee_id(5, [\\"ABC123\\", \\"A1C345\\", \\"XYZ789\\", \\"JKL000\\", \\"12CDEF\\"]) == [\\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"VALID\\", \\"INVALID\\"] def test_valid_ids(): assert validate_employee_id(3, [\\"DEF456\\", \\"GHI789\\", \\"MNO123\\"]) == [\\"VALID\\", \\"VALID\\", \\"VALID\\"] def test_invalid_length(): assert validate_employee_id(3, [\\"ABCDEFG\\", \\"HIJKLMN\\", \\"YZ12345\\"]) == [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] def test_invalid_format(): assert validate_employee_id(4, [\\"AB1234\\", \\"aBC123\\", \\"ABCDEFG\\", \\"ABC12D\\"]) == [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] def test_edge_cases(): assert validate_employee_id(2, [\\"AAA000\\", \\"ZZZ999\\"]) == [\\"VALID\\", \\"VALID\\"] def test_empty_cases(): assert validate_employee_id(0, []) == [] def test_mixed_cases(): assert validate_employee_id(4, [\\"X1X123\\", \\"ZZ1234\\", \\"XY0123\\", \\"ABC999\\"]) == [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"VALID\\"]","solution":"def validate_employee_id(T, ids): Validates the format of employee IDs. Parameters: - T (int): Number of test cases. - ids (list of str): List of employee ID strings to validate. Returns: - list of str: List of \\"VALID\\" or \\"INVALID\\" for each ID based on validation. results = [] for id in ids: if ( len(id) == 6 and id[:3].isupper() and id[:3].isalpha() and id[3:].isdigit() ): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def merge_sort(arr): Sorts a list of integers in ascending order using the merge sort algorithm. def merge(left, right): Merges two sorted lists into one sorted list. # To handle the specific problem format def sort_integers(n, arr): Sorts a list of n integers using merge sort and returns the sorted list. # Example usage if __name__ == \\"__main__\\": n = int(input()) arr = list(map(int, input().split())) sorted_list = sort_integers(n, arr) print(\\" \\".join(map(str, sorted_list))) # Test cases def test_merge_sort(): assert merge_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert merge_sort([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] assert merge_sort([]) == [] assert merge_sort([7]) == [7] assert merge_sort([4, 2, 7, 1]) == [1, 2, 4, 7] assert merge_sort([-1, -3, -2, 0]) == [-3, -2, -1, 0] def test_sort_integers(): assert sort_integers(6, [5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert sort_integers(5, [3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] assert sort_integers(0, []) == [] assert sort_integers(1, [7]) == [7] assert sort_integers(4, [4, 2, 7, 1]) == [1, 2, 4, 7] assert sort_integers(4, [-1, -3, -2, 0]) == [-3, -2, -1, 0] def test_edge_cases(): assert sort_integers(3, [0, 0, 0]) == [0, 0, 0] assert sort_integers(2, [10**6, -10**6]) == [-10**6, 10**6] assert sort_integers(3, [-1, 10**6, -10**6]) == [-10**6, -1, 10**6] assert sort_integers(3, [10**6, 10**6, 10**6]) == [10**6, 10**6, 10**6]","solution":"def merge_sort(arr): Sorts a list of integers in ascending order using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list # To handle the specific problem format def sort_integers(n, arr): Sorts a list of n integers using merge sort and returns the sorted list. return merge_sort(arr) # Example usage n = 5 arr = [3, 1, 4, 1, 5] sorted_list = sort_integers(n, arr) print(\\" \\".join(map(str, sorted_list)))"},{"question":"from itertools import permutations from typing import List def generate_unique_codes(chars: str, N: int) -> List[str]: Generate all possible unique strings of length N using the given characters from chars without repetition. :param chars: A string consisting of unique characters. :param N: The length of each generated unique string. :return: A list of all possible unique strings of length N. >>> set(generate_unique_codes(\\"abc\\", 2)) == set([\\"ab\\", \\"ac\\", \\"ba\\", \\"bc\\", \\"ca\\", \\"cb\\"]) True >>> set(generate_unique_codes(\\"a\\", 1)) == set([\\"a\\"]) True >>> set(generate_unique_codes(\\"abcd\\", 4)) == set([\\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\"]) True >>> set(generate_unique_codes(\\"abcd\\", 3)) == set([\\"abc\\", \\"abd\\", \\"acb\\", \\"acd\\", \\"adb\\", \\"adc\\", \\"bac\\", \\"bad\\", \\"bca\\", \\"bcd\\", \\"bda\\", \\"bdc\\", \\"cab\\", \\"cad\\", \\"cba\\", \\"cbd\\", \\"cda\\", \\"cdb\\", \\"dab\\", \\"dac\\", \\"dba\\", \\"dbc\\", \\"dca\\", \\"dcb\\"]) True >>> set(generate_unique_codes(\\"abcde\\", 1)) == set([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) True","solution":"from itertools import permutations def generate_unique_codes(chars: str, N: int): Generate all possible unique strings of length N using the given characters from chars without repetition. :param chars: A string consisting of unique characters. :param N: The length of each generated unique string. :return: A list of all possible unique strings of length N. return [''.join(p) for p in permutations(chars, N)]"},{"question":"def smallest_n_factorial_divisible_by_k(k: int) -> int: Find the smallest positive integer n such that n! is divisible by k. >>> smallest_n_factorial_divisible_by_k(6) 3 >>> smallest_n_factorial_divisible_by_k(10) 5 >>> smallest_n_factorial_divisible_by_k(24) 4 def process_test_cases(test_cases: List[int]) -> List[int]: Process multiple test cases to find the smallest n for each k. >>> process_test_cases([6, 10, 24]) [3, 5, 4] >>> process_test_cases([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> process_test_cases([7, 11, 13]) [7, 11, 13]","solution":"def smallest_n_factorial_divisible_by_k(k): Find the smallest positive integer n such that n! is divisible by k. if k == 1: return 1 # Function to find the prime factors of k and their counts def prime_factors_count(n): i = 2 factors = {} while i * i <= n: while (n % i) == 0: if i in factors: factors[i] += 1 else: factors[i] = 1 n //= i i += 1 if n > 1: factors[n] = 1 return factors factors = prime_factors_count(k) # Finding the minimum n that satisfies the number of each prime factor in n! n = 0 while True: n += 1 temp = n for p in factors: power_count = 0 multiplier = p while temp >= multiplier: power_count += temp // multiplier multiplier *= p if power_count < factors[p]: break else: return n def process_test_cases(test_cases): return [smallest_n_factorial_divisible_by_k(k) for k in test_cases]"},{"question":"def can_satisfy_all_guests(queries): Determine whether Anne can satisfy the chocolate demands of all her guests. Args: queries (List[Dict]): List of queries, where each query contains: 'M' (int): number of different types of chocolates, 'chocolate_quantities' (List[int]): list of quantities of each type of chocolate, 'guests' (List[Dict]): list of guests' demands with 'type' and 'quantity' keys. Returns: List[str]: List with \\"YES\\" or \\"NO\\" for each query. Examples: >>> input_data = \\"2n3n5 10 3n2n1 3n3 2n2n2 5n1n1 10\\" >>> queries = process_input(input_data) >>> can_satisfy_all_guests(queries) [\\"YES\\", \\"NO\\"] >>> input_data = \\"1n3n5 10 3n2n1 3n3 2\\" >>> queries = process_input(input_data) >>> can_satisfy_all_guests(queries) [\\"YES\\"] >>> input_data = \\"1n3n5 10 3n2n1 6n3 1\\" >>> queries = process_input(input_data) >>> can_satisfy_all_guests(queries) [\\"NO\\"] >>> input_data = \\"1n2n1 1n2n1 1n2 2\\" >>> queries = process_input(input_data) >>> can_satisfy_all_guests(queries) [\\"NO\\"] >>> input_data = \\"1n2n3 4n3n1 1n2 4n1 2\\" >>> queries = process_input(input_data) >>> can_satisfy_all_guests(queries) [\\"YES\\"] pass def process_input(input_data): Process the input data and return a structured list of queries. Args: input_data (str): Multiline string containing the input data. Returns: List[Dict]: List of queries with structured information. Examples: >>> input_data = \\"2n3n5 10 3n2n1 3n3 2n2n2 5n1n1 10\\" >>> process_input(input_data) [{'M': 3, 'chocolate_quantities': [5, 10, 3], 'guests': [{'type': 1, 'quantity': 3}, {'type': 3, 'quantity': 2}]}, {'M': 2, 'chocolate_quantities': [2, 5], 'guests': [{'type': 1, 'quantity': 10}]}] pass # Example usage: input_data = 2 3 5 10 3 2 1 3 3 2 2 2 5 1 1 10 queries = process_input(input_data) result = can_satisfy_all_guests(queries) for res in result: print(res)","solution":"def can_satisfy_all_guests(queries): results = [] for query in queries: M = query['M'] chocolate_quantities = query['chocolate_quantities'] guests = query['guests'] for guest in guests: T_i, D_i = guest['type'], guest['quantity'] if chocolate_quantities[T_i - 1] >= D_i: chocolate_quantities[T_i - 1] -= D_i else: results.append(\\"NO\\") break else: results.append(\\"YES\\") return results def process_input(input_data): lines = input_data.strip().split('n') index = 0 Q = int(lines[index]) index += 1 queries = [] for _ in range(Q): M = int(lines[index]) index += 1 chocolate_quantities = list(map(int, lines[index].split())) index += 1 G = int(lines[index]) index += 1 guests = [] for _ in range(G): T_i, D_i = map(int, lines[index].split()) guests.append({'type': T_i, 'quantity': D_i}) index += 1 queries.append({ 'M': M, 'chocolate_quantities': chocolate_quantities, 'guests': guests }) return queries # Example usage: input_data = 2 3 5 10 3 2 1 3 3 2 2 2 5 1 1 10 queries = process_input(input_data) result = can_satisfy_all_guests(queries) for res in result: print(res)"},{"question":"def longest_scenic_route(n: int, elevations: List[int]) -> int: Determine the length of the longest \\"scenic route\\" in the trail. A scenic route is a segment where the elevation strictly increases and then strictly decreases. The segment must contain at least three points to be considered scenic. >>> longest_scenic_route(10, [2, 1, 4, 7, 3, 2, 5, 4, 3, 1]) == 5 >>> longest_scenic_route(5, [1, 2, 3, 4, 5]) == 0 >>> longest_scenic_route(6, [1, 2, 3, 4, 3, 2]) == 6 >>> longest_scenic_route(7, [1, 3, 2, 4, 3, 6, 5]) == 3 >>> longest_scenic_route(3, [1, 2, 1]) == 3 >>> longest_scenic_route(5, [5, 5, 5, 5, 5]) == 0 # Write your code here","solution":"def longest_scenic_route(n, elevations): if n < 3: return 0 longest_route = 0 i = 1 while i < n - 1: # Find the start of an increasing sequence if elevations[i - 1] < elevations[i] and elevations[i] > elevations[i + 1]: left = i right = i # Expand to the left while left > 0 and elevations[left - 1] < elevations[left]: left -= 1 # Expand to the right while right < n - 1 and elevations[right + 1] < elevations[right]: right += 1 longest_route = max(longest_route, right - left + 1) # Move i to the right bound of the current scenic route i = right else: i += 1 return longest_route"},{"question":"def maxProductOfThreeNumbers(nums: List[int]) -> int: Given an array/list of integers, find the maximum product of any three distinct numbers in the array. >>> maxProductOfThreeNumbers([1, 2, 3, 4]) 24 >>> maxProductOfThreeNumbers([-10, -10, 5, 2]) 500 >>> maxProductOfThreeNumbers([-1, -2, -3, -4, -5]) -6 >>> maxProductOfThreeNumbers([1, 3, 9, -5, -6, -2]) 270 from solution import maxProductOfThreeNumbers def test_maxProductOfThreeNumbers_positive_numbers(): assert maxProductOfThreeNumbers([1, 2, 3, 4]) == 24 def test_maxProductOfThreeNumbers_mixed_sign_numbers(): assert maxProductOfThreeNumbers([-10, -10, 5, 2]) == 500 def test_maxProductOfThreeNumbers_all_negative_numbers(): assert maxProductOfThreeNumbers([-1, -2, -3, -4, -5]) == -6 def test_maxProductOfThreeNumbers_mixed_case(): assert maxProductOfThreeNumbers([1, 3, 9, -5, -6, -2]) == 270 def test_maxProductOfThreeNumbers_includes_zero(): assert maxProductOfThreeNumbers([1, 0, -1, 2, 3, -4]) == 12 def test_maxProductOfThreeNumbers_all_zero(): assert maxProductOfThreeNumbers([0, 0, 0, 0, 0, 0]) == 0 def test_maxProductOfThreeNumbers_large_numbers(): assert maxProductOfThreeNumbers([1000, 1000, -1000, -1000, 2]) == 1000000000","solution":"def maxProductOfThreeNumbers(nums): Returns the maximum product of any three distinct numbers in the array. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def four_sum(nums: List[int], target: int) -> List[Tuple[int]]: Finds all unique quadruplets in the list which sum up to the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [(-2, -1, 1, 2), (-2, 0, 0, 2), (-1, 0, 0, 1)] >>> four_sum([2, 2, 2, 2, 2], 8) [(2, 2, 2, 2)] >>> four_sum([-1, 0, 1, 2, -1, -4], -1) [(-4, 0, 1, 2), (-1, -1, 0, 1)] >>> four_sum([], 0) [] >>> four_sum([1, 2, 3, 4], 10) [(1, 2, 3, 4)] >>> four_sum([1, 1, 1, 1, 1, 1], 100) []","solution":"def four_sum(nums, target): Finds all unique quadruplets in the list which sum up to the target. :param nums: List of integers :param target: Target sum :return: List of tuples containing unique quadruplets that sum up to the target nums.sort() quadruplets = set() n = len(nums) for i in range(n-3): for j in range(i+1, n-2): left = j + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruplets.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return list(quadruplets)"},{"question":"def can_make_batches(n, needed, m, available, k): Determines if there are enough ingredients to make the specified number of batches of cookies. Parameters: n (int): number of different ingredients required for a batch of cookies needed (list of tuples): each tuple contains the name of an ingredient and the quantity needed for one batch m (int): number of different ingredients available in the pantry available (list of tuples): each tuple contains the name of an ingredient and the quantity available in the pantry k (int): number of batches of cookies to make Returns: str: \\"Yes\\" if enough ingredients are available, otherwise \\"No\\" pass # Unit Test def test_can_make_batches(): assert can_make_batches(4, [(\\"Flour\\", 2), (\\"Sugar\\", 1), (\\"Eggs\\", 3), (\\"Butter\\", 1)], 4, [(\\"Flour\\", 10), (\\"Sugar\\", 5), (\\"Eggs\\", 15), (\\"Butter\\", 5)], 3) == \\"Yes\\" assert can_make_batches(4, [(\\"Flour\\", 2), (\\"Sugar\\", 1), (\\"Eggs\\", 3), (\\"Butter\\", 1)], 4, [(\\"Flour\\", 5), (\\"Sugar\\", 5), (\\"Eggs\\", 15), (\\"Butter\\", 5)], 3) == \\"No\\" assert can_make_batches(3, [(\\"Flour\\", 1), (\\"Sugar\\", 2), (\\"Butter\\", 1)], 3, [(\\"Flour\\", 3), (\\"Sugar\\", 6), (\\"Butter\\", 3)], 2) == \\"Yes\\" assert can_make_batches(2, [(\\"Milk\\", 1), (\\"Sugar\\", 2)], 2, [(\\"Milk\\", 2), (\\"Sugar\\", 4)], 2) == \\"Yes\\" assert can_make_batches(2, [(\\"Milk\\", 2), (\\"Sugar\\", 3)], 2, [(\\"Milk\\", 4), (\\"Sugar\\", 4)], 2) == \\"No\\" # Running the tests test_can_make_batches()","solution":"def can_make_batches(n, needed, m, available, k): Determines if there are enough ingredients to make the specified number of batches of cookies. Parameters: n (int): number of different ingredients required for a batch of cookies needed (list of tuples): each tuple contains the name of an ingredient and the quantity needed for one batch m (int): number of different ingredients available in the pantry available (list of tuples): each tuple contains the name of an ingredient and the quantity available in the pantry k (int): number of batches of cookies to make Returns: str: \\"Yes\\" if enough ingredients are available, otherwise \\"No\\" # Convert needed and available lists to dictionaries for easy lookup needed_dict = dict(needed) available_dict = dict(available) # Check if there are enough ingredients for ingredient, quantity_needed in needed_dict.items(): total_quantity_needed = quantity_needed * k if available_dict.get(ingredient, 0) < total_quantity_needed: return \\"No\\" return \\"Yes\\""},{"question":"def race_results(competitors): Determine the top 3 finishes among several competitors based on their race times. Args: competitors (list): List of dictionaries, each containing 'name' (str) and 'time' (int) for each competitor. Returns: dict: A dictionary with keys '1st', '2nd', and '3rd' representing the top 3 positions. Tied competitors are separated by commas and denoted with either '(run-off)' or '(tie)'. Examples: >>> race_results([ ... {\\"name\\": \\"Alice\\", \\"time\\": 12983}, ... {\\"name\\": \\"Bob\\", \\"time\\": 13034}, ... {\\"name\\": \\"Charlie\\", \\"time\\": 12876}, ... {\\"name\\": \\"David\\", \\"time\\": 12983}, ... {\\"name\\": \\"Eve\\", \\"time\\": 13040} ... ]) {'1st': 'Charlie', '2nd': 'Alice, David (tie)', '3rd': 'Bob'} >>> race_results([ ... {\\"name\\": \\"Alice\\", \\"time\\": 11983}, ... {\\"name\\": \\"Bob\\", \\"time\\": 11983}, ... {\\"name\\": \\"Charlie\\", \\"time\\": 13876}, ... {\\"name\\": \\"David\\", \\"time\\": 12000}, ... {\\"name\\": \\"Eve\\", \\"time\\": 13940} ... ]) {'1st': 'Alice, Bob (run-off)', '2nd': 'David', '3rd': 'Charlie'} >>> race_results([ ... {\\"name\\": \\"Alice\\", \\"time\\": 12000}, ... {\\"name\\": \\"Bob\\", \\"time\\": 12000}, ... {\\"name\\": \\"Charlie\\", \\"time\\": 12000}, ... {\\"name\\": \\"David\\", \\"time\\": 12000} ... ]) {'1st': 'Alice, Bob, Charlie, David (run-off)'} >>> race_results([{\\"name\\": \\"Alice\\", \\"time\\": 12983}]) {'1st': 'Alice'} >>> race_results([ ... {\\"name\\": \\"Alice\\", \\"time\\": 12983}, ... {\\"name\\": \\"Bob\\", \\"time\\": 12876} ... ]) {'1st': 'Bob', '2nd': 'Alice'} >>> race_results([ ... {\\"name\\": \\"Charlie\\", \\"time\\": 11000}, ... {\\"name\\": \\"Bob\\", \\"time\\": 12000}, ... {\\"name\\": \\"Alice\\", \\"time\\": 12000}, ... {\\"name\\": \\"David\\", \\"time\\": 12000} ... ]) {'1st': 'Charlie', '2nd': 'Alice, Bob, David (tie)'}","solution":"def race_results(competitors): # Sort competitors first by time, then by name alphabetically sorted_competitors = sorted(competitors, key=lambda c: (c[\\"time\\"], c[\\"name\\"])) results = {} position = 1 count = 0 while count < 3 and position <= len(sorted_competitors): current_tied_group = [sorted_competitors[position - 1]] while (position < len(sorted_competitors) and sorted_competitors[position][\\"time\\"] == sorted_competitors[position - 1][\\"time\\"]): current_tied_group.append(sorted_competitors[position]) position += 1 if len(current_tied_group) > 1: if count == 0: results[\\"1st\\"] = \\", \\".join(c[\\"name\\"] for c in current_tied_group) + \\" (run-off)\\" else: results[f\\"{count + 1}nd\\" if count == 1 else '3rd'] = \\", \\".join(c[\\"name\\"] for c in current_tied_group) + \\" (tie)\\" else: results[f\\"{count + 1}st\\" if count == 0 else f\\"{count + 1}nd\\" if count == 1 else '3rd'] = current_tied_group[0][\\"name\\"] count += 1 position += 1 return results"},{"question":"def is_valid_sudoku(board): Check if a given 9x9 Sudoku board is valid. The board is valid if each row, each column, and each 3x3 sub-grid contains all numbers from 1 to 9 without repetition. If the board is valid, return \\"VALID\\". Otherwise, return \\"INVALID\\". Example: >>> board = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> is_valid_sudoku(board) 'VALID' >>> board = [ ... [5, 3, 3, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> is_valid_sudoku(board) 'INVALID'","solution":"def is_valid_sudoku(board): def is_valid_group(group): # Filter out all zeros (empty cells) group = [num for num in group if num != 0] # Check if there are any duplicates return len(group) == len(set(group)) for i in range(9): # Check rows if not is_valid_group(board[i]): return \\"INVALID\\" # Check columns column = [board[row][i] for row in range(9)] if not is_valid_group(column): return \\"INVALID\\" for i in range(3): for j in range(3): # Check 3x3 sub-grids sub_grid = [ board[x][y] for x in range(i*3, (i+1)*3) for y in range(j*3, (j+1)*3) ] if not is_valid_group(sub_grid): return \\"INVALID\\" return \\"VALID\\""},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ [1, 2], [3, 4] ] >>> rotate_matrix(matrix) >>> matrix [[3, 1], [4, 2]] # Your code here def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_5x5_matrix(): matrix = [ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(matrix) assert matrix == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def min_cost_to_reach_bottom_right(N: int, M: int, grid: List[List[int]]) -> int: Compute the minimum cost required for the robot to reach the bottom-right corner of the grid. >>> min_cost_to_reach_bottom_right(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_to_reach_bottom_right(1, 1, [[5]]) 5 from typing import List def test_min_cost_to_reach_bottom_right_example(): N, M = 3, 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_to_reach_bottom_right(N, M, grid) == 7 def test_min_cost_to_reach_bottom_right_single_cell(): N, M = 1, 1 grid = [ [5] ] assert min_cost_to_reach_bottom_right(N, M, grid) == 5 def test_min_cost_to_reach_bottom_right_single_row(): N, M = 1, 5 grid = [ [2, 3, 1, 4, 2] ] assert min_cost_to_reach_bottom_right(N, M, grid) == 12 def test_min_cost_to_reach_bottom_right_single_column(): N, M = 5, 1 grid = [ [2], [3], [1], [4], [2] ] assert min_cost_to_reach_bottom_right(N, M, grid) == 12 def test_min_cost_to_reach_bottom_right_larger_grid(): N, M = 4, 4 grid = [ [1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 3, 4], [4, 3, 2, 1] ] assert min_cost_to_reach_bottom_right(N, M, grid) == 14","solution":"def min_cost_to_reach_bottom_right(N, M, grid): # dp array to store the minimum cost to reach each cell dp = [[0] * M for _ in range(N)] # initialize the first cell dp[0][0] = grid[0][0] # populate the first row for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # populate the first column for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # build the dp array for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # the minimum cost to reach the bottom-right corner is found at dp[N-1][M-1] return dp[N-1][M-1]"},{"question":"def max_subarray_sum(arr: List[int]) -> int: This function takes an array of integers and returns the maximum sum of any contiguous subarray. >>> max_subarray_sum([-2, 1, -3]) == 1 >>> max_subarray_sum([-1, 2, 4, -3]) == 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([3, -2, 5, -1]) == 6 >>> max_subarray_sum([1]) == 1 def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function processes multiple test cases and returns results for each. >>> process_test_cases(2, [(3, [-2, 1, -3]), (4, [-1, 2, 4, -3])]) == [1, 6] >>> process_test_cases(1, [(5, [1, 2, 3, 4, 5])]) == [15] >>> process_test_cases(3, [(5, [-1, -2, -3, -4, -5]), (4, [3, -2, 5, -1]), (1, [1])]) == [-1, 6, 1]","solution":"def max_subarray_sum(arr): This function takes an array of integers and returns the maximum sum of any contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def process_test_cases(T, test_cases): This function processes multiple test cases and returns results for each. results = [] for i in range(T): N, arr = test_cases[i] results.append(max_subarray_sum(arr)) return results"},{"question":"def find_largest_group_of_walkable_paths(forest: List[List[int]]) -> int: Find the largest group of connected walkable paths (0s) in the forest. Args: forest: A list of lists representing the forest grid. Returns: An integer representing the size of the largest group of connected walkable paths. # Your code here # Test cases def test_largest_group_in_forest(): assert find_largest_group_of_walkable_paths([ [0, 0, 1], [1, 0, 1], [1, 0, 0] ]) == 5 assert find_largest_group_of_walkable_paths([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 0 assert find_largest_group_of_walkable_paths([ [0] ]) == 1 assert find_largest_group_of_walkable_paths([ [1] ]) == 0 assert find_largest_group_of_walkable_paths([ [0, 0, 1], [1, 1, 1], [1, 1, 0] ]) == 2 assert find_largest_group_of_walkable_paths([ [0, 0], [0, 0] ]) == 4","solution":"def find_largest_group_of_walkable_paths(forest): Find the largest group of connected walkable paths (0s) in the forest. Args: forest: A list of lists representing the forest grid. Returns: An integer representing the size of the largest group of connected walkable paths. # Get the dimensions of the forest rows = len(forest) cols = len(forest[0]) # Directions for moving in the grid (right, left, up, down) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] def bfs(r, c): queue = [(r, c)] forest[r][c] = 1 # Mark this cell as visited count = 1 # Initialize the group size counter while queue: cr, cc = queue.pop(0) for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < rows and 0 <= nc < cols and forest[nr][nc] == 0: # If the neighboring cell is walkable path (0) queue.append((nr, nc)) forest[nr][nc] = 1 # Mark this cell as visited count += 1 return count # Initialize the largest size of the group of walkable paths largest_group_size = 0 # Traverse the forest to find all groups of walkable paths for r in range(rows): for c in range(cols): if forest[r][c] == 0: # Perform BFS/DFS starting from this cell if it's a walkable path group_size = bfs(r, c) largest_group_size = max(largest_group_size, group_size) return largest_group_size"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_sublist(head: ListNode, m: int, n: int) -> ListNode: Reverse a sublist within a singly linked list from index m to n. Args: head (ListNode): The head of the singly linked list. m (int): The starting index of the sublist to be reversed (1-based index). n (int): The ending index of the sublist to be reversed (1-based index). Returns: ListNode: The head of the modified singly linked list. Examples: >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> m, n = 2, 4 >>> result = reverse_sublist(head, m, n) >>> linkedlist_to_list(result) [1, 4, 3, 2, 5] >>> head = list_to_linkedlist([1, 2, 3, 4, 5, 6]) >>> m, n = 3, 5 >>> result = reverse_sublist(head, m, n) >>> linkedlist_to_list(result) [1, 2, 5, 4, 3, 6] >>> head = list_to_linkedlist([1, 2]) >>> m, n = 1, 2 >>> result = reverse_sublist(head, m, n) >>> linkedlist_to_list(result) [2, 1] # Implement reversal of sublist here pass # Helper functions for testing def list_to_linkedlist(lst): dummy = ListNode(0) current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linkedlist_to_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_sublist(head: ListNode, m: int, n: int) -> ListNode: if not head or m == n: return head dummy = ListNode(0) dummy.next = head pre = dummy # Move \`pre\` to the node before the m-th node for _ in range(m - 1): pre = pre.next # \`start\` will point to the m-th node, \`then\` will point to the (m+1)-th node start = pre.next then = start.next # Reverse the sublist from m to n for _ in range(n - m): start.next = then.next then.next = pre.next pre.next = then then = start.next return dummy.next # Helper functions for testing def list_to_linkedlist(lst): dummy = ListNode(0) current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linkedlist_to_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst"},{"question":"def maximize_revenue() -> dict: Determines the optimal number of units to plant for carrots, potatoes, and broccoli to maximize revenue while respecting land, resource, and budget constraints. from scipy.optimize import linprog def test_maximize_revenue(): result = maximize_revenue() assert isinstance(result, dict) assert set(result.keys()) == {\\"Carrots\\", \\"Potatoes\\", \\"Broccoli\\"} # Check that none of the constraints are violated assert result[\\"Carrots\\"] + result[\\"Potatoes\\"] + result[\\"Broccoli\\"] <= 200 assert result[\\"Carrots\\"] <= 100 assert result[\\"Potatoes\\"] <= 100 assert result[\\"Broccoli\\"] <= 100 assert 0 <= result[\\"Carrots\\"] <= 100 assert 0 <= result[\\"Potatoes\\"] <= 100 assert 0 <= result[\\"Broccoli\\"] <= 100 total_cost = result[\\"Carrots\\"] * 0.5 + result[\\"Potatoes\\"] * 0.25 + result[\\"Broccoli\\"] * 1 assert total_cost <= 150 def test_max_revenue_feasibility(): result = maximize_revenue() total_units = result[\\"Carrots\\"] + result[\\"Potatoes\\"] + result[\\"Broccoli\\"] assert total_units <= 200, \\"Total units planted should be less than or equal to 200\\" cost = result[\\"Carrots\\"] * 0.5 + result[\\"Potatoes\\"] * 0.25 + result[\\"Broccoli\\"] * 1 assert cost <= 150, \\"Total planting cost should be within the budget of 150\\" def test_max_units_constraints(): result = maximize_revenue() assert result[\\"Carrots\\"] <= 100, \\"Carrots units should be within max limit\\" assert result[\\"Potatoes\\"] <= 100, \\"Potatoes units should be within max limit\\" assert result[\\"Broccoli\\"] <= 100, \\"Broccoli units should be within max limit\\" assert result[\\"Carrots\\"] >= 0, \\"Carrots units should be non-negative\\" assert result[\\"Potatoes\\"] >= 0, \\"Potatoes units should be non-negative\\" assert result[\\"Broccoli\\"] >= 0, \\"Broccoli units should be non-negative\\"","solution":"from scipy.optimize import linprog def maximize_revenue(): # Coefficients for the objective function (negative for maximization) c = [-2, -1, -4] # Coefficients for the inequality constraints A = [ [0.5, 0.25, 1], # Cost constraint [1, 0, 0], # Carrots constraint [0, 1, 0], # Potatoes constraint [0, 0, 1], # Broccoli constraint [1, 1, 1] # Total units constraint ] # Right-hand side for the inequality constraints b = [150, 100, 100, 100, 200] # Boundaries for each variable bounds = [(0, 100), (0, 100), (0, 100)] # Using linear programming to solve the maximization problem result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs') # Extracting the optimal number of units for each vegetable x_units = result.x solution = { \\"Carrots\\": int(x_units[0]), \\"Potatoes\\": int(x_units[1]), \\"Broccoli\\": int(x_units[2]) } return solution"},{"question":"def find_and_replace_operations(document: str, operations: List[Tuple[str, str]]) -> str: Perform a series of find-and-replace operations on the document string. :param document: A string representing the document :param operations: A list of tuples where each tuple contains two strings: the word to find and the word to replace it with :return: The modified document string after all operations # Your code here # Test cases def test_multiple_operations(): document = \\"the quick brown fox jumps over the lazy dog\\" operations = [(\\"the\\", \\"a\\"), (\\"quick\\", \\"slow\\"), (\\"lazy\\", \\"energetic\\")] assert find_and_replace_operations(document, operations) == \\"a slow brown fox jumps over a energetic dog\\" def test_no_operations(): document = \\"nothing changes here\\" operations = [] assert find_and_replace_operations(document, operations) == \\"nothing changes here\\" def test_single_operation(): document = \\"repeat repeat repeat\\" operations = [(\\"repeat\\", \\"done\\")] assert find_and_replace_operations(document, operations) == \\"done done done\\" def test_overlapping_words(): document = \\"this is a test, this is only a test\\" operations = [(\\"test\\", \\"experiment\\"), (\\"this\\", \\"that\\")] assert find_and_replace_operations(document, operations) == \\"that is a experiment, that is only a experiment\\" def test_replacement_word_containing_find_word(): document = \\"find and replace find\\" operations = [(\\"find\\", \\"find and replace\\")] assert find_and_replace_operations(document, operations) == \\"find and replace and replace find and replace\\"","solution":"def find_and_replace_operations(document, operations): Perform a series of find-and-replace operations on the document string. :param document: A string representing the document :param operations: A list of tuples where each tuple contains two strings: the word to find and the word to replace it with :return: The modified document string after all operations for find_word, replace_word in operations: document = document.replace(find_word, replace_word) return document"},{"question":"def rotate_matrix(matrix): Rotates a given N x N matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): A 2D list of integers representing the matrix. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] from solution import rotate_matrix def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_4x4_matrix(): matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) assert matrix == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_empty_matrix(): matrix = [] rotate_matrix(matrix) assert matrix == []","solution":"def rotate_matrix(matrix): Rotates a given N x N matrix by 90 degrees clockwise in place. :param matrix: List of lists, where each inner list represents a row of the matrix. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element top = matrix[i][j] # Move left element to top matrix[i][j] = matrix[n - j - 1][i] # Move bottom element to left matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] # Move right element to bottom matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] # Assign top element to right matrix[j][n - i - 1] = top"},{"question":"def longest_non_decreasing_streak(durations): Function to determine the longest streak of non-decreasing login durations. def process_input(input_data): Processes the input data and returns results for each test case. # Unit Tests def test_longest_non_decreasing_streak_all_increasing(): assert longest_non_decreasing_streak([1, 2, 3, 4, 5]) == 5 def test_longest_non_decreasing_streak_with_plateaus(): assert longest_non_decreasing_streak([1, 2, 2, 3, 3, 4]) == 6 def test_longest_non_decreasing_streak_with_drops(): assert longest_non_decreasing_streak([5, 3, 4, 2, 2, 5]) == 3 def test_longest_non_decreasing_streak_all_decreasing(): assert longest_non_decreasing_streak([5, 4, 3, 2, 1]) == 1 def test_process_input_single_case(): input_data = \\"1n5n30 60 60 45 90\\" assert process_input(input_data) == [3] def test_process_input_multiple_cases(): input_data = \\"2n5n30 60 60 45 90n6n20 25 25 30 30 35\\" assert process_input(input_data) == [3, 6] def test_process_input_edge_case(): input_data = \\"1n1n50\\" assert process_input(input_data) == [1]","solution":"def longest_non_decreasing_streak(durations): Function to determine the longest streak of non-decreasing login durations. max_streak = 1 current_streak = 1 for i in range(1, len(durations)): if durations[i] >= durations[i - 1]: current_streak += 1 else: current_streak = 1 if current_streak > max_streak: max_streak = current_streak return max_streak def process_input(input_data): Processes the input data and returns results for each test case. lines = input_data.strip().split('n') T = int(lines[0]) index = 1 results = [] for _ in range(T): N = int(lines[index]) durations = list(map(int, lines[index + 1].split())) results.append(longest_non_decreasing_streak(durations)) index += 2 return results"},{"question":"def findLongestIncreasingSubsequence(arr: List[int]) -> List[int]: Write a function that takes an array of integers as input and returns the longest strictly increasing subsequence within that array. If there are multiple subsequences of the same maximum length, return the one that appears first. >>> findLongestIncreasingSubsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> findLongestIncreasingSubsequence([]) [] >>> findLongestIncreasingSubsequence([10]) [10] >>> findLongestIncreasingSubsequence([10, 10, 10]) [10] >>> findLongestIncreasingSubsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> findLongestIncreasingSubsequence([5, 4, 3, 2, 1]) [5] >>> findLongestIncreasingSubsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> findLongestIncreasingSubsequence([1, 2, 1, 2, 1, 2, 1, 2, 3, 4, 1, 2, 3, 4]) [1, 2, 3, 4]","solution":"def findLongestIncreasingSubsequence(arr): if not arr: return [] n = len(arr) dp = [1] * n prev = [-1] * n max_length = 1 max_index = 0 for i in range(1, n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j if dp[i] > max_length: max_length = dp[i] max_index = i lis = [] while max_index != -1: lis.append(arr[max_index]) max_index = prev[max_index] return lis[::-1]"},{"question":"from typing import List def count_ways_to_climb(N: int) -> int: Returns the number of ways to climb N stairs where Sam can take 1 or 2 steps at a time. This problem is a classic dynamic programming problem and can be solved by recognizing the problem can be broken into sub-problems. >>> count_ways_to_climb(2) 2 >>> count_ways_to_climb(3) 3 >>> count_ways_to_climb(4) 5 def process_test_cases(T: int, cases: List[int]) -> List[int]: For each test case, computes the number of ways to climb the given number of stairs. >>> process_test_cases(3, [2, 3, 4]) [2, 3, 5] >>> process_test_cases(5, [1, 2, 3, 4, 5]) [1, 2, 3, 5, 8] from solution import count_ways_to_climb, process_test_cases def test_count_ways_to_climb(): assert count_ways_to_climb(2) == 2 # (1+1, 2) assert count_ways_to_climb(3) == 3 # (1+1+1, 1+2, 2+1) assert count_ways_to_climb(4) == 5 # (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2) assert count_ways_to_climb(5) == 8 # (1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1) def test_process_test_cases(): T = 3 cases = [2, 3, 4] assert process_test_cases(T, cases) == [2, 3, 5] T = 5 cases = [1, 2, 3, 4, 5] assert process_test_cases(T, cases) == [1, 2, 3, 5, 8] def test_edge_cases(): assert count_ways_to_climb(0) == 0 # No stairs to climb assert count_ways_to_climb(1) == 1 # Only one way to reach the first step # To run the tests, use the command: pytest","solution":"def count_ways_to_climb(N): Returns the number of ways to climb N stairs where Sam can take 1 or 2 steps at a time. This problem is a classic dynamic programming problem and can be solved by recognizing the problem can be broken into sub-problems. if N == 0: return 0 # DP array to store the number of ways to reach each stair dp = [0] * (N + 1) # Base cases dp[0] = 1 # 1 way to stay on the ground dp[1] = 1 # 1 way to climb to the first step # Fill the DP array for i in range(2, N + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[N] def process_test_cases(T, cases): results = [] for N in cases: results.append(count_ways_to_climb(N)) return results"},{"question":"def square_and_sort_evens(numbers: List[int]) -> List[int]: Returns a list containing the squares of all the even numbers from the input list, sorted in ascending order. :param numbers: List of integers :return: List of squared even numbers sorted in ascending order pass from solution import square_and_sort_evens def test_square_and_sort_evens_regular_list(): assert square_and_sort_evens([4, 3, 1, 6, 9, 8]) == [16, 36, 64] def test_square_and_sort_evens_mixed_list(): assert square_and_sort_evens([7, 2, 5, 8, 11, 4]) == [4, 16, 64] def test_square_and_sort_evens_no_evens(): assert square_and_sort_evens([1, 3, 5, 7]) == [] def test_square_and_sort_evens_negative_evens(): assert square_and_sort_evens([-4, -2, -6, 3, 5]) == [4, 16, 36] def test_square_and_sort_evens_empty_list(): assert square_and_sort_evens([]) == [] def test_square_and_sort_evens_all_evens(): assert square_and_sort_evens([2, 4, 6, 8]) == [4, 16, 36, 64] def test_square_and_sort_evens_mixed_sign_evens(): assert square_and_sort_evens([4, -4, 6, -6]) == [16, 16, 36, 36]","solution":"def square_and_sort_evens(numbers): Returns a list containing the squares of all the even numbers from the input list, sorted in ascending order. :param numbers: List of integers :return: List of squared even numbers sorted in ascending order # Filter the even numbers from the list evens = [num for num in numbers if num % 2 == 0] # Square the even numbers squared_evens = [num ** 2 for num in evens] # Sort the squared numbers squared_evens.sort() return squared_evens"},{"question":"def shipment_system(operations): Handles a sequence of operations related to container tracking in a shipment system. Parameters: operations (list of str): A list of operation strings. Returns: list of str: The results of query operations (type 3), where each result is either \\"YES\\" or \\"NO\\". # Implementation here # Unit tests def test_shipment_system_example(): operations = [ \\"1 ABC123\\", \\"1 XYZ789\\", \\"3 ABC123\\", \\"2 ABC123\\", \\"3 ABC123\\", \\"3 XYZ789\\", \\"2 XYZ789\\" ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert shipment_system(operations) == expected def test_shipment_system_single_container(): operations = [ \\"1 CONTAINER1\\", \\"3 CONTAINER1\\", \\"2 CONTAINER1\\", \\"3 CONTAINER1\\" ] expected = [\\"YES\\", \\"NO\\"] assert shipment_system(operations) == expected def test_shipment_system_no_queries(): operations = [ \\"1 CONTAINER1\\", \\"1 CONTAINER2\\", \\"2 CONTAINER1\\", \\"2 CONTAINER2\\" ] expected = [] assert shipment_system(operations) == expected def test_shipment_system_multiple_operations(): operations = [ \\"1 CONTAINER1\\", \\"3 CONTAINER1\\", \\"2 CONTAINER1\\", \\"3 CONTAINER1\\", \\"1 CONTAINER2\\", \\"3 CONTAINER2\\", \\"2 CONTAINER2\\", \\"3 CONTAINER2\\" ] expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert shipment_system(operations) == expected def test_shipment_system_readding_container(): operations = [ \\"1 CONTAINER1\\", \\"2 CONTAINER1\\", \\"1 CONTAINER1\\", \\"3 CONTAINER1\\" ] expected = [\\"YES\\"] assert shipment_system(operations) == expected","solution":"def shipment_system(operations): Handles a sequence of operations related to container tracking in a shipment system. Parameters: operations (list of str): A list of operation strings. Returns: list of str: The results of query operations (type 3), where each result is either \\"YES\\" or \\"NO\\". containers = set() result = [] for operation in operations: parts = operation.split() op_type = int(parts[0]) container_id = parts[1] if op_type == 1: containers.add(container_id) elif op_type == 2: containers.discard(container_id) elif op_type == 3: if container_id in containers: result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"import math def unique_characters_in_nth_permutation(n: int) -> int: Determine the number of unique characters in the n-th permutation of 'abcdefghijklmnopqrstuvwxyz' in lexicographic order. Parameters: n (int): The 1-based index of the permutation, where 1 <= n <= 403291461126605635584000000. Returns: int: The number of unique characters in the n-th permutation of the string. >>> unique_characters_in_nth_permutation(1) 26 >>> unique_characters_in_nth_permutation(2) 26 >>> unique_characters_in_nth_permutation(math.factorial(26)) 26 def test_unique_characters_in_nth_permutation_start(): assert unique_characters_in_nth_permutation(1) == 26 def test_unique_characters_in_nth_permutation_middle(): assert unique_characters_in_nth_permutation(math.factorial(26)//2) == 26 def test_unique_characters_in_nth_permutation_end(): assert unique_characters_in_nth_permutation(math.factorial(26)) == 26 def test_unique_characters_in_nth_permutation_out_of_bounds_low(): with pytest.raises(ValueError): unique_characters_in_nth_permutation(0) def test_unique_characters_in_nth_permutation_out_of_bounds_high(): with pytest.raises(ValueError): unique_characters_in_nth_permutation(math.factorial(26) + 1)","solution":"import math def unique_characters_in_nth_permutation(n): Given the 1-based index n, return the number of unique characters in the n-th permutation of the string 'abcdefghijklmnopqrstuvwxyz'. The output is always 26 since the permutations don't affect the count of unique characters. if n < 1 or n > math.factorial(26): raise ValueError(\\"n must be between 1 and 403291461126605635584000000 inclusive\\") return 26"},{"question":"def guess_number(respond_fn): Function to guess the number N by making optimal guesses based on feedback. respond_fn is a function that takes a guessed number as input and returns: \\"Too high!\\", \\"Too low!\\" or \\"Correct!\\". The function should use an optimal strategy to minimize the number of guesses. # Unit tests def test_guess_number_correct(): N = 42 responses = { 50: \\"Too high!\\", 25: \\"Too low!\\", 37: \\"Too low!\\", 43: \\"Too high!\\", 40: \\"Too low!\\", 41: \\"Too low!\\", 42: \\"Correct!\\" } def respond_fn(guess): return responses[guess] assert guess_number(respond_fn) == 42 def test_guess_number_correct_upper_boundary(): N = 75 responses = { 50: \\"Too low!\\", 75: \\"Correct!\\" } def respond_fn(guess): return responses[guess] assert guess_number(respond_fn) == 75 def test_guess_number_lowest(): N = 1 responses = { 50: \\"Too high!\\", 25: \\"Too high!\\", 12: \\"Too high!\\", 6: \\"Too high!\\", 3: \\"Too high!\\", 1: \\"Correct!\\" } def respond_fn(guess): return responses[guess] assert guess_number(respond_fn) == 1 def test_guess_number_highest(): N = 100 responses = { 50: \\"Too low!\\", 75: \\"Too low!\\", 88: \\"Too low!\\", 94: \\"Too low!\\", 97: \\"Too low!\\", 99: \\"Too low!\\", 100: \\"Correct!\\" } def respond_fn(guess): return responses[guess] assert guess_number(respond_fn) == 100","solution":"def guess_number(respond_fn): Function to guess the number N by making optimal guesses based on feedback. respond_fn is a function that takes a guessed number as input and returns: \\"Too high!\\", \\"Too low!\\" or \\"Correct!\\". low, high = 1, 100 while low <= high: guess = (low + high) // 2 response = respond_fn(guess) if response == \\"Correct!\\": return guess elif response == \\"Too high!\\": high = guess - 1 elif response == \\"Too low!\\": low = guess + 1"},{"question":"def is_bipartite(graph: dict) -> bool: Determines if a graph is bipartite using BFS color mapping. A bipartite graph is one where you can split the set of vertices into two sets such that no two vertices within the same set are adjacent. :param graph: Dictionary representing the adjacency list of the graph. :return: Boolean indicating if the graph is bipartite. Examples: >>> is_bipartite({ ... 1: [2, 3], ... 2: [1, 4], ... 3: [1, 5], ... 4: [2], ... 5: [3], ... }) True >>> is_bipartite({ ... 1: [2, 3], ... 2: [1, 3], ... 3: [1, 2], ... }) False >>> is_bipartite({ ... 1: [], ... }) True >>> is_bipartite({ ... 1: [2], ... 2: [1], ... 3: [4], ... 4: [3] ... }) True >>> is_bipartite({ ... 1: [2], ... 2: [1], ... }) True >>> is_bipartite({ ... 1: [2, 3, 4], ... 2: [1, 4], ... 3: [1, 5], ... 4: [1, 2, 5], ... 5: [3, 4], ... }) False >>> is_bipartite({ ... 1: [2], ... 2: [1], ... 3: [4], ... 4: [3, 5], ... 5: [4], ... }) True pass","solution":"from collections import deque def is_bipartite(graph: dict) -> bool: Determines if a graph is bipartite using BFS color mapping. :param graph: Dictionary representing the adjacency list of the graph. :return: Boolean indicating if the graph is bipartite. color = {} for node in graph: if node not in color: # Start BFS from this node queue = deque([node]) color[node] = 0 # Starting color while queue: current = queue.popleft() current_color = color[current] for neighbor in graph[current]: if neighbor not in color: queue.append(neighbor) color[neighbor] = 1 - current_color # Alternate color elif color[neighbor] == current_color: return False # Found same-color adjacent nodes return True"},{"question":"def polynomial_product(poly1, poly2): Returns the product of two polynomials represented by their coefficients in ascending order. :param poly1: List[int], coefficients of the first polynomial :param poly2: List[int], coefficients of the second polynomial :return: List[int], coefficients of the product polynomial >>> polynomial_product([1, 2], [2, 3]) [2, 7, 6] >>> polynomial_product([1, 0, -1], [1, 2]) [1, 2, -1, -2] >>> polynomial_product([3], [6]) [18] >>> polynomial_product([1, 2, 3], [4, 0, 5]) [4, 8, 17, 10, 15] >>> polynomial_product([1, -2, 1], [-1, 2]) [-1, 4, -5, 2] >>> polynomial_product([1, 0, 0, 0, 1], [1, 1]) [1, 1, 0, 0, 1, 1]","solution":"def polynomial_product(poly1, poly2): Returns the product of two polynomials represented by their coefficients in ascending order. :param poly1: List[int], coefficients of the first polynomial :param poly2: List[int], coefficients of the second polynomial :return: List[int], coefficients of the product polynomial product = [0] * (len(poly1) + len(poly2) - 1) for i in range(len(poly1)): for j in range(len(poly2)): product[i + j] += poly1[i] * poly2[j] return product"},{"question":"from typing import List def longest_increasing_subarray(nums: List[int]) -> int: Returns the length of the longest increasing subarray. Args: nums: List of integers. Returns: Length of the longest increasing subarray. Examples: >>> longest_increasing_subarray([1, 3, 5, 4, 7]) 3 >>> longest_increasing_subarray([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subarray([10, 20, 30, 10, 20, 30, 40]) 4 >>> longest_increasing_subarray([1, 2, 3, 4, 1, 2, 3, 4, 5]) 5 from solution import longest_increasing_subarray def test_example_1(): nums = [1, 3, 5, 4, 7] assert longest_increasing_subarray(nums) == 3 def test_example_2(): nums = [2, 2, 2, 2, 2] assert longest_increasing_subarray(nums) == 1 def test_example_3(): nums = [10, 20, 30, 10, 20, 30, 40] assert longest_increasing_subarray(nums) == 4 def test_example_4(): nums = [1, 2, 3, 4, 1, 2, 3, 4, 5] assert longest_increasing_subarray(nums) == 5 def test_single_element(): nums = [10] assert longest_increasing_subarray(nums) == 1 def test_all_decreasing(): nums = [5, 4, 3, 2, 1] assert longest_increasing_subarray(nums) == 1 def test_alternating(): nums = [1, 3, 2, 4, 3, 5] assert longest_increasing_subarray(nums) == 2 def test_empty_list(): nums = [] assert longest_increasing_subarray(nums) == 0 def test_equal_elements(): nums = [1, 1, 1, 1, 1] assert longest_increasing_subarray(nums) == 1 def test_large_increasing_sequence(): nums = list(range(1, 10001)) assert longest_increasing_subarray(nums) == 10000","solution":"def longest_increasing_subarray(nums): Returns the length of the longest increasing subarray. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def sort_dates(dates: List[str]) -> List[str]: Sort a list of dates in the format 'DD-MM-YYYY' in ascending order. >>> sort_dates([\\"14-02-2021\\", \\"03-11-2020\\", \\"25-12-2021\\", \\"01-01-2020\\"]) [\\"01-01-2020\\", \\"03-11-2020\\", \\"14-02-2021\\", \\"25-12-2021\\"] >>> sort_dates([\\"01-01-2021\\", \\"01-01-2020\\", \\"01-01-2022\\"]) [\\"01-01-2020\\", \\"01-01-2021\\", \\"01-01-2022\\"] >>> sort_dates([\\"01-12-2020\\", \\"01-01-2020\\", \\"01-11-2020\\"]) [\\"01-01-2020\\", \\"01-11-2020\\", \\"01-12-2020\\"] >>> sort_dates([\\"10-03-2021\\", \\"01-03-2021\\", \\"20-03-2021\\"]) [\\"01-03-2021\\", \\"10-03-2021\\", \\"20-03-2021\\"] >>> sort_dates([\\"25-12-2021\\"]) [\\"25-12-2021\\"] >>> sort_dates([]) []","solution":"def sort_dates(dates): Sort a list of dates in the format 'DD-MM-YYYY' in ascending order. # Convert each date to a tuple (YYYY, MM, DD) for easy sorting date_tuples = [(d.split('-')[2], d.split('-')[1], d.split('-')[0]) for d in dates] # Sort the list of tuples date_tuples.sort() # Convert the sorted tuples back to the original format 'DD-MM-YYYY' sorted_dates = [f\\"{day}-{month}-{year}\\" for year, month, day in date_tuples] return sorted_dates"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_bst(root: TreeNode) -> TreeNode: Convert a BST to a Greater Tree where each node's value is replaced by the sum of values greater than or equal to it. def bst_to_list(root): Helper function to convert BST to list (In-order Traversal) if root is None: return [] return bst_to_list(root.left) + [root.val] + bst_to_list(root.right) def test_convert_bst(): # Create BST root = TreeNode(4) root.left = TreeNode(1) root.right = TreeNode(6) root.left.left = TreeNode(0) root.left.right = TreeNode(2, right=TreeNode(3)) root.right.left = TreeNode(5) root.right.right = TreeNode(7, right=TreeNode(8)) # Convert BST convert_bst(root) # Get the result as list result = bst_to_list(root) # Expected result expected = [36, 36, 35, 33, 30, 26, 21, 15, 8] # Testing assert result == expected def test_empty_tree(): # Test with empty tree assert convert_bst(None) is None def test_single_node_tree(): # Test with a single node tree root = TreeNode(1) convert_bst(root) assert bst_to_list(root) == [1] def test_right_skewed_tree(): # Create a right skewed tree root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) # Convert BST convert_bst(root) # Get the result as list result = bst_to_list(root) # Expected result expected = [6, 5, 3] # Testing assert result == expected def test_left_skewed_tree(): # Create a left skewed tree root = TreeNode(3) root.left = TreeNode(2) root.left.left = TreeNode(1) # Convert BST convert_bst(root) # Get the result as list result = bst_to_list(root) # Expected result expected = [6, 5, 3] # Testing assert result == expected","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_bst(root: TreeNode) -> TreeNode: Convert a BST to a Greater Tree where each node's value is replaced by the sum of values greater than or equal to it. def reverse_inorder_traversal(node, acc_sum): if node is None: return acc_sum # Traverse the right subtree first acc_sum = reverse_inorder_traversal(node.right, acc_sum) # Update the current node's value node.val += acc_sum # Update the accumulator for the left subtree acc_sum = node.val # Traverse the left subtree return reverse_inorder_traversal(node.left, acc_sum) reverse_inorder_traversal(root, 0) return root # Helper function to convert BST to list (In-order Traversal) def bst_to_list(root): if root is None: return [] return bst_to_list(root.left) + [root.val] + bst_to_list(root.right)"},{"question":"from typing import List def fibonacci_mod(n: int, m: int) -> List[int]: Returns the first n Fibonacci numbers taken modulo m. >>> fibonacci_mod(5, 3) [0, 1, 1, 2, 0] >>> fibonacci_mod(7, 4) [0, 1, 1, 2, 3, 1, 0] >>> fibonacci_mod(10, 5) [0, 1, 1, 2, 3, 0, 3, 3, 1, 4] def test_fibonacci_mod_example_1(): assert fibonacci_mod(5, 3) == [0, 1, 1, 2, 0] def test_fibonacci_mod_example_2(): assert fibonacci_mod(7, 4) == [0, 1, 1, 2, 3, 1, 0] def test_fibonacci_mod_example_3(): assert fibonacci_mod(10, 5) == [0, 1, 1, 2, 3, 0, 3, 3, 1, 4] def test_fibonacci_mod_n_0(): assert fibonacci_mod(0, 3) == [] def test_fibonacci_mod_n_1(): assert fibonacci_mod(1, 3) == [0] def test_fibonacci_mod_large_n_small_m(): assert fibonacci_mod(20, 2) == [0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1] def test_fibonacci_mod_large_n_large_m(): assert fibonacci_mod(20, 1000) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 597, 584, 181]","solution":"from typing import List def fibonacci_mod(n: int, m: int) -> List[int]: Returns the first n Fibonacci numbers taken modulo m. if n == 0: return [] if n == 1: return [0] fib_mod_sequence = [0, 1] for i in range(2, n): next_fib_mod = (fib_mod_sequence[-1] + fib_mod_sequence[-2]) % m fib_mod_sequence.append(next_fib_mod) return fib_mod_sequence[:n]"},{"question":"def has_pair_with_sum(arr, target): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] equals target. >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([10**6, 10**5, 10**4, 10**3], 1010000) True >>> has_pair_with_sum([-10**6, -10**5, -10**4, -10**3], -1010000) True >>> has_pair_with_sum([0, 2, 8, -5], -5) True >>> has_pair_with_sum([3, 4, 3, 4], 6) True >>> has_pair_with_sum([1, 1, 1, 1], 2) True >>> has_pair_with_sum([1, 1, 1, 1], 3) False >>> has_pair_with_sum([2, 4], 6) True >>> has_pair_with_sum([10**3, -10**3, 10**6, -10**6], 0) True","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == target. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def longest_balanced_subarray(N, A): Returns the length of the longest contiguous sub-array where the number of 1s is exactly half of the total number of elements in the sub-array. def process_test_cases(T, test_cases): Processes multiple test cases to find the length of the longest contiguous sub-array where the number of 1s is exactly half of the total number of elements in the sub-array. Args: T -- The number of test cases. test_cases -- A list of tuples, where each tuple contains: - An integer N representing the number of elements in the array. - A list of N integers representing the array elements (either 0 or 1). Returns: A list of integers where each integer represents the answer for each corresponding test case. results = [] for case in test_cases: N, A = case result = longest_balanced_subarray(N, A) results.append(result) return results def test_longest_balanced_subarray(): assert longest_balanced_subarray(6, [1, 0, 1, 0, 1, 0]) == 6 assert longest_balanced_subarray(5, [1, 1, 1, 0, 0]) == 4 assert longest_balanced_subarray(4, [1, 1, 0, 0]) == 4 assert longest_balanced_subarray(2, [0, 1]) == 2 assert longest_balanced_subarray(2, [1, 1]) == 0 assert longest_balanced_subarray(1, [0]) == 0 def test_process_test_cases(): test_cases = [ (6, [1, 0, 1, 0, 1, 0]), (5, [1, 1, 1, 0, 0]), (4, [1, 1, 0, 0]) ] assert process_test_cases(3, test_cases) == [6, 4, 4]","solution":"def longest_balanced_subarray(N, A): Returns the length of the longest contiguous sub-array where the number of 1s is exactly half of the total number of elements in the sub-array. # We need to find sub-arrays where the count of 1s equals count of 0s # We use a map to store the first occurrence of a particular balance balance_map = {} balance = 0 max_length = 0 # Initialize balance_map with balance=0 at index -1 to cover the case of subarray starting from index 0 balance_map[0] = -1 for i in range(N): if A[i] == 1: balance += 1 else: balance -= 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length def process_test_cases(T, test_cases): results = [] for case in test_cases: N, A = case result = longest_balanced_subarray(N, A) results.append(result) return results"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that no two adjacent characters are the same. If it's not possible, return \\"No\\". Args: s: A string consisting of lowercase alphabets. Returns: One possible rearranged string or \\"No\\" if no such arrangement is possible. >>> rearrange_string(\\"aabbcc\\") 'abcabc' >>> rearrange_string(\\"aaaa\\") 'No' Unit Test: from solution import rearrange_string def test_basic_case(): assert rearrange_string(\\"aabbcc\\") == \\"abcabc\\" def test_all_same_characters(): assert rearrange_string(\\"aaaa\\") == \\"No\\" def test_possible_rearrangement(): rearranged = rearrange_string(\\"aaabbc\\") # Since multiple solutions possible, just check correctness assert rearranged != \\"No\\" and len(rearranged) == 6 for i in range(1, len(rearranged)): assert rearranged[i] != rearranged[i-1] def test_no_possible_rearrangement(): assert rearrange_string(\\"aaab\\") == \\"No\\" def test_single_character(): assert rearrange_string(\\"a\\") == \\"a\\" def test_large_input(): large_input = \\"a\\" * 50000 + \\"b\\" * 50000 rearranged = rearrange_string(large_input) # Check the length and validity of rearrangement assert rearranged != \\"No\\" and len(rearranged) == 100000 for i in range(1, len(rearranged)): assert rearranged[i] != rearranged[i-1]","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If it's not possible, return \\"No\\". # Counter to count the frequency of characters char_count = Counter(s) # Max heap using negative frequency count max_heap = [] for char, freq in char_count.items(): heappush(max_heap, (-freq, char)) result = [] prev_freq, prev_char = 0, '' while max_heap: # Pop the most frequent char freq, char = heappop(max_heap) # Append it to the result result.append(char) # If previous char was used more than once, push it back into heap if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Update previous char and its remaining count prev_freq, prev_char = freq + 1, char rearranged = ''.join(result) # Check if rearranged string's length matches the input string's length if len(rearranged) == len(s): return rearranged else: return \\"No\\""},{"question":"from typing import List def generatePermutations(nums: List[int]) -> List[List[int]]: Generates all possible permutations of a list of distinct integers. Args: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list containing all permutations of the input list. Examples: >>> generatePermutations([1, 2]) [[1, 2], [2, 1]] >>> generatePermutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] pass def test_generatePermutations_single_element(): assert generatePermutations([1]) == [(1,)] def test_generatePermutations_two_elements(): result = generatePermutations([1, 2]) expected = [(1, 2), (2, 1)] assert len(result) == 2 assert set(result) == set(expected) def test_generatePermutations_three_elements(): result = generatePermutations([1, 2, 3]) expected = [ (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1) ] assert len(result) == 6 assert set(result) == set(expected) def test_generatePermutations_four_elements(): result = generatePermutations([1, 2, 3, 4]) assert len(result) == 24 def test_generatePermutations_different_order(): result1 = generatePermutations([1, 2, 3]) result2 = generatePermutations([3, 2, 1]) assert set(result1) == set(result2)","solution":"from typing import List import itertools def generatePermutations(nums: List[int]) -> List[List[int]]: Generates all possible permutations of a list of distinct integers. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list containing all permutations of the input list. return list(itertools.permutations(nums))"},{"question":"from typing import List def lexicographically_smallest_array(nums: List[int], k: int) -> List[int]: Return the lexicographically smallest array possible after at most one k-length subarray reversal. >>> lexicographically_smallest_array([3, 2, 1, 4, 5, 6], 3) [1, 2, 3, 4, 5, 6] >>> lexicographically_smallest_array([4, 3, 2, 1, 6, 5], 2) [3, 4, 2, 1, 6, 5] pass def test_lexicographically_smallest_array_example1(): assert lexicographically_smallest_array([3, 2, 1, 4, 5, 6], 3) == [1, 2, 3, 4, 5, 6] def test_lexicographically_smallest_array_example2(): assert lexicographically_smallest_array([4, 3, 2, 1, 6, 5], 2) == [3, 4, 2, 1, 6, 5] def test_lexicographically_smallest_array_single_element(): assert lexicographically_smallest_array([1], 1) == [1] def test_lexicographically_smallest_array_no_reversal_needed(): assert lexicographically_smallest_array([1, 2, 3, 4, 5], 3) == [1, 2, 3, 4, 5] def test_lexicographically_smallest_array_full_reversal(): assert lexicographically_smallest_array([5, 4, 3, 2, 1], 5) == [1, 2, 3, 4, 5] def test_lexicographically_smallest_array_complex_case(): assert lexicographically_smallest_array([4, 3, 6, 1, 5, 2], 2) == [3, 4, 6, 1, 5, 2]","solution":"def lexicographically_smallest_array(nums, k): Return the lexicographically smallest array possible after at most one k-length subarray reversal. n = len(nums) if k == 1: return nums # Initialize the best possible array as the original array best = nums[:] # Try reversing each possible subarray of length k for i in range(n - k + 1): temp = nums[:i] + nums[i:i + k][::-1] + nums[i + k:] if temp < best: best = temp return best"},{"question":"from typing import List def unique_paths(grid: List[List[int]]) -> int: Finds the total number of unique paths from the start to the target location in a grid filled with obstacles. Args: grid (List[List[int]]): 2-D list representing the grid with obstacles. Returns: int: Total number of unique paths from the top-left to the bottom-right corner. Example: >>> unique_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 pass def test_unique_paths_example(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths(grid) == 2 def test_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths(grid) == 6 def test_start_blocked(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths(grid) == 0 def test_end_blocked(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert unique_paths(grid) == 0 def test_single_cell(): grid = [[0]] assert unique_paths(grid) == 1 def test_full_blocked_path(): grid = [ [0, 0, 0], [1, 1, 1], [0, 0, 0] ] assert unique_paths(grid) == 0 def test_corner_case(): grid = [ [0, 1], [1, 0] ] assert unique_paths(grid) == 0","solution":"from typing import List def unique_paths(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def merge_and_intersect(array1, array2): Define a function that takes two sorted arrays and merges them into a single sorted array without using any built-in sort functions. The resulting array should only include elements that are present in both of the input arrays. >>> merge_and_intersect([1, 3, 4, 5, 6], [2, 3, 5, 7]) [3, 5] >>> merge_and_intersect([1, 2, 3], [4, 5, 6]) [] >>> merge_and_intersect([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> merge_and_intersect([], [1, 2, 3]) [] >>> merge_and_intersect([1, 2, 3], []) [] >>> merge_and_intersect([1, 3, 4, 5, 6], [3]) [3] >>> merge_and_intersect([1000000, 2000000, 3000000], [1000000, 3000000]) [1000000, 3000000] >>> merge_and_intersect([1, 2, 2, 3, 3, 3], [2, 2, 3, 3, 4, 5]) [2, 3]","solution":"def merge_and_intersect(array1, array2): i, j = 0, 0 result = [] while i < len(array1) and j < len(array2): if array1[i] == array2[j]: if not result or result[-1] != array1[i]: # avoid duplicates in the result result.append(array1[i]) i += 1 j += 1 elif array1[i] < array2[j]: i += 1 else: j += 1 return result"},{"question":"def smallest_subarray_with_sum_at_least_k(arr, N, K): Returns the length of the smallest subarray with a sum of at least K. If no such subarray exists, return -1. >>> smallest_subarray_with_sum_at_least_k([2, 3, 1, 2, 4, 3], 6, 7) == 2 >>> smallest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 5, 20) == -1 >>> smallest_subarray_with_sum_at_least_k([1, 1, 1, 1, 1, 1], 6, 5) == 5 >>> smallest_subarray_with_sum_at_least_k([10, 2, 1, 1, 1], 5, 10) == 1 >>> smallest_subarray_with_sum_at_least_k([10000] * 100, 100, 50000) == 5 >>> smallest_subarray_with_sum_at_least_k([1, 2, 3, 8, 10, 10], 6, 18) == 2 >>> smallest_subarray_with_sum_at_least_k([100, 200, 300, 400], 4, 500) == 2","solution":"def smallest_subarray_with_sum_at_least_k(arr, N, K): Returns the length of the smallest subarray with a sum of at least K. If no such subarray exists, return -1. left = 0 current_sum = 0 min_length = float('inf') for right in range(N): current_sum += arr[right] while current_sum >= K: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Calculate the number of distinct islands in a given 2D grid. An island is a group of connected 1's (land) surrounded by 0's (water). Two cells are connected if they are horizontally or vertically adjacent. Islands are distinct if one island cannot be obtained from another by rotation, mirroring, or translation. Args: grid (List[List[int]]): The 2D grid of integers where 1 represents land and 0 represents water. Returns: int: The number of distinct islands. >>> grid = [ ... [1, 1, 0, 1, 1], ... [1, 0, 0, 0, 0], ... [0, 0, 1, 1, 0], ... [1, 1, 0, 0, 1] ... ] >>> numDistinctIslands(grid) 3 >>> grid = [ ... [1, 1, 0, 0], ... [1, 0, 0, 0], ... [0, 0, 1, 1], ... [0, 1, 1, 0] ... ] >>> numDistinctIslands(grid) 2 from solution import numDistinctIslands def test_numDistinctIslands_example1(): grid = [ [1, 1, 0, 1, 1], [1, 0, 0, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 0, 1] ] assert numDistinctIslands(grid) == 3 def test_numDistinctIslands_example2(): grid = [ [1, 1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0] ] assert numDistinctIslands(grid) == 2 def test_numDistinctIslands_single_cell_island(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert numDistinctIslands(grid) == 1 def test_numDistinctIslands_no_islands(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert numDistinctIslands(grid) == 0 def test_numDistinctIslands_same_shape_islands(): grid = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] assert numDistinctIslands(grid) == 1 def test_numDistinctIslands_diff_shapes(): grid = [ [1, 1, 0], [0, 1, 0], [1, 0, 1] ] assert numDistinctIslands(grid) == 2","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, path): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # mark visited path.append(direction) dfs(x + 1, y, 'D', path) dfs(x - 1, y, 'U', path) dfs(x, y + 1, 'R', path) dfs(x, y - 1, 'L', path) path.append('back') distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path = [] dfs(i, j, 'start', path) distinct_islands.add(''.join(path)) return len(distinct_islands)"},{"question":"def find_minimized_difference(blocks: List[int]) -> int: Given a list of blocks, where each value represents the number of buildings in a block, split the blocks into two groups such that the difference in the total number of buildings in the two groups is minimized. Return the minimized difference. >>> find_minimized_difference([3, 1, 4, 2, 2]) == 0 >>> find_minimized_difference([1, 2, 3, 9]) == 3 pass from find_minimized_difference import find_minimized_difference def test_even_split(): assert find_minimized_difference([3, 1, 4, 2, 2]) == 0 def test_large_difference(): assert find_minimized_difference([1, 2, 3, 9]) == 3 def test_single_block(): assert find_minimized_difference([10]) == 10 def test_two_blocks(): assert find_minimized_difference([10, 5]) == 5 def test_equal_blocks(): assert find_minimized_difference([10, 10, 10, 10]) == 0 def test_all_ones(): assert find_minimized_difference([1, 1, 1, 1, 1, 1]) == 0 def test_subtle_difference(): assert find_minimized_difference([1, 2, 3, 4, 5, 5, 6]) == 0 def test_zero_difference(): assert find_minimized_difference([2, 4, 1, 6]) == 1","solution":"def find_minimized_difference(blocks): Given a list of blocks, where each value represents the number of buildings in a block, split the blocks into two groups such that the difference in the total number of buildings in the two groups is minimized. Return the minimized difference. total_sum = sum(blocks) n = len(blocks) target = total_sum // 2 dp = [0] * (target + 1) for num in blocks: for j in range(target, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) return abs((total_sum - dp[target]) - dp[target])"},{"question":"def exists(grid: List[List[str]], word: str) -> bool: Check if a word exists in a 2D word grid. >>> exists([ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ], \\"abcced\\") True >>> exists([ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ], \\"see\\") True >>> exists([ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ], \\"abcb\\") False from typing import List def test_exists_word_found(): grid = [ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ] assert exists(grid, \\"abcced\\") == True assert exists(grid, \\"see\\") == True def test_exists_word_not_found(): grid = [ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ] assert exists(grid, \\"abcb\\") == False def test_exists_single_letter(): grid = [ ['a'] ] assert exists(grid, \\"a\\") == True assert exists(grid, \\"b\\") == False def test_exists_empty_word(): grid = [ ['a', 'b', 'c', 'e'] ] assert exists(grid, \\"\\") == True def test_exists_empty_grid(): grid = [] assert exists(grid, \\"a\\") == False def test_exists_large_grid(): grid = [ ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'] ] assert exists(grid, \\"aaaa\\") == True","solution":"def exists(grid, word): def dfs(x, y, word_idx): if word_idx == len(word): return True if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != word[word_idx]: return False temp = grid[x][y] grid[x][y] = '#' found = ( dfs(x + 1, y, word_idx + 1) or dfs(x - 1, y, word_idx + 1) or dfs(x, y + 1, word_idx + 1) or dfs(x, y - 1, word_idx + 1) ) grid[x][y] = temp return found for i in range(len(grid)): for j in range(len(grid[0])): if dfs(i, j, 0): return True return False"},{"question":"from typing import List def prime_factors_sum(n: int) -> int: Given an integer n, find the n-th element in the transformed sequence where each integer is replaced by the sum of its prime factors. >>> prime_factors_sum(1) 1 >>> prime_factors_sum(6) 5 >>> prime_factors_sum(10) 7 pass def test_prime_factors_sum_1(): assert prime_factors_sum(1) == 1 def test_prime_factors_sum_2(): assert prime_factors_sum(2) == 2 def test_prime_factors_sum_3(): assert prime_factors_sum(3) == 3 def test_prime_factors_sum_4(): assert prime_factors_sum(4) == 4 # 2 + 2 def test_prime_factors_sum_5(): assert prime_factors_sum(5) == 5 def test_prime_factors_sum_6(): assert prime_factors_sum(6) == 5 # 2 + 3 def test_prime_factors_sum_7(): assert prime_factors_sum(7) == 7 def test_prime_factors_sum_8(): assert prime_factors_sum(8) == 6 # 2 + 2 + 2 def test_prime_factors_sum_9(): assert prime_factors_sum(9) == 6 # 3 + 3 def test_prime_factors_sum_10(): assert prime_factors_sum(10) == 7 # 2 + 5","solution":"def prime_factors_sum(n: int) -> int: Returns the n-th element in the sequence where each integer is replaced by the sum of its prime factors. def sum_of_prime_factors(num): Calculates the sum of prime factors of a given number. factors_sum = 0 factor = 2 while factor * factor <= num: while (num % factor) == 0: factors_sum += factor num //= factor factor += 1 if num > 1: factors_sum += num return factors_sum if n == 1: return 1 return sum_of_prime_factors(n)"},{"question":"def sort_events(events): Sorts a list of events based on their timestamps in ascending order. Args: events (list of dict): A list of dictionaries, each containing 'event' and 'timestamp' keys. Returns: list of dict: The sorted list of events by timestamp. sorted_events = sorted(events, key=lambda event: event['timestamp']) return sorted_events # Unit Tests def test_sort_events_simple_case(): events = [ {\\"event\\": \\"User Login\\", \\"timestamp\\": \\"2023-01-01 12:00:00\\"}, {\\"event\\": \\"File Upload\\", \\"timestamp\\": \\"2023-01-01 12:00:05\\"}, {\\"event\\": \\"User Logout\\", \\"timestamp\\": \\"2023-01-01 13:00:00\\"} ] expected = [ {\\"event\\": \\"User Login\\", \\"timestamp\\": \\"2023-01-01 12:00:00\\"}, {\\"event\\": \\"File Upload\\", \\"timestamp\\": \\"2023-01-01 12:00:05\\"}, {\\"event\\": \\"User Logout\\", \\"timestamp\\": \\"2023-01-01 13:00:00\\"} ] assert sort_events(events) == expected def test_sort_events_unordered(): events = [ {\\"event\\": \\"File Upload\\", \\"timestamp\\": \\"2023-01-01 12:00:05\\"}, {\\"event\\": \\"User Login\\", \\"timestamp\\": \\"2023-01-01 12:00:00\\"}, {\\"event\\": \\"User Logout\\", \\"timestamp\\": \\"2023-01-01 13:00:00\\"} ] expected = [ {\\"event\\": \\"User Login\\", \\"timestamp\\": \\"2023-01-01 12:00:00\\"}, {\\"event\\": \\"File Upload\\", \\"timestamp\\": \\"2023-01-01 12:00:05\\"}, {\\"event\\": \\"User Logout\\", \\"timestamp\\": \\"2023-01-01 13:00:00\\"} ] assert sort_events(events) == expected def test_sort_events_with_same_day_different_times(): events = [ {\\"event\\": \\"Event A\\", \\"timestamp\\": \\"2023-02-01 09:00:00\\"}, {\\"event\\": \\"Event B\\", \\"timestamp\\": \\"2023-02-01 08:00:00\\"}, {\\"event\\": \\"Event C\\", \\"timestamp\\": \\"2023-02-01 07:00:00\\"} ] expected = [ {\\"event\\": \\"Event C\\", \\"timestamp\\": \\"2023-02-01 07:00:00\\"}, {\\"event\\": \\"Event B\\", \\"timestamp\\": \\"2023-02-01 08:00:00\\"}, {\\"event\\": \\"Event A\\", \\"timestamp\\": \\"2023-02-01 09:00:00\\"} ] assert sort_events(events) == expected def test_sort_events_with_different_days(): events = [ {\\"event\\": \\"Event X\\", \\"timestamp\\": \\"2023-01-02 10:00:00\\"}, {\\"event\\": \\"Event Y\\", \\"timestamp\\": \\"2023-01-01 10:00:00\\"}, {\\"event\\": \\"Event Z\\", \\"timestamp\\": \\"2023-01-03 10:00:00\\"} ] expected = [ {\\"event\\": \\"Event Y\\", \\"timestamp\\": \\"2023-01-01 10:00:00\\"}, {\\"event\\": \\"Event X\\", \\"timestamp\\": \\"2023-01-02 10:00:00\\"}, {\\"event\\": \\"Event Z\\", \\"timestamp\\": \\"2023-01-03 10:00:00\\"} ] assert sort_events(events) == expected def test_sort_events_single_element(): events = [ {\\"event\\": \\"Single Event\\", \\"timestamp\\": \\"2023-01-01 08:00:00\\"} ] expected = [ {\\"event\\": \\"Single Event\\", \\"timestamp\\": \\"2023-01-01 08:00:00\\"} ] assert sort_events(events) == expected def test_sort_events_with_various_times_in_day(): events = [ {\\"event\\": \\"Break Time\\", \\"timestamp\\": \\"2023-04-01 15:00:00\\"}, {\\"event\\": \\"Start Work\\", \\"timestamp\\": \\"2023-04-01 09:00:00\\"}, {\\"event\\": \\"Lunch Time\\", \\"timestamp\\": \\"2023-04-01 12:00:00\\"}, {\\"event\\": \\"End Work\\", \\"timestamp\\": \\"2023-04-01 18:00:00\\"} ] expected = [ {\\"event\\": \\"Start Work\\", \\"timestamp\\": \\"2023-04-01 09:00:00\\"}, {\\"event\\": \\"Lunch Time\\", \\"timestamp\\": \\"2023-04-01 12:00:00\\"}, {\\"event\\": \\"Break Time\\", \\"timestamp\\": \\"2023-04-01 15:00:00\\"}, {\\"event\\": \\"End Work\\", \\"timestamp\\": \\"2023-04-01 18:00:00\\"} ] assert sort_events(events) == expected","solution":"def sort_events(events): Sorts a list of events based on their timestamps in ascending order. Args: events (list of dict): A list of dictionaries, each containing 'event' and 'timestamp' keys. Returns: list of dict: The sorted list of events by timestamp. sorted_events = sorted(events, key=lambda event: event['timestamp']) return sorted_events"},{"question":"def word_break(s, word_dict): Determines if the string can be segmented into a space-separated sequence of one or more dictionary words. Returns a tuple of (bool, segmented_string) where segmented_string is the space-separated sequence or empty if segmentation is not possible. pass def parse_input_output(input_string): Parses the multi-line input_string and returns the corresponding output. pass # Test Cases def test_word_break(): assert word_break(\\"leetcode\\", {\\"leet\\", \\"code\\"}) == (True, \\"leet code\\") assert word_break(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) == (True, \\"apple pen apple\\") assert word_break(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) == (False, \\"\\") assert word_break(\\"\\", {\\"a\\", \\"b\\"}) == (True, \\"\\") assert word_break(\\"a\\", {\\"a\\"}) == (True, \\"a\\") assert word_break(\\"abcd\\", {\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"}) == (True, \\"a b cd\\") def test_parse_input_output(): input_string = \\"2nleetcoden2nleetncodenapplepenapplen3napplenpennapplen\\" expected_output = \\"Truenleet codenTruenapple pen apple\\" assert parse_input_output(input_string) == expected_output input_string = \\"1ncatsandogn5ncatsndognsandnandncatn\\" expected_output = \\"False\\" assert parse_input_output(input_string) == expected_output","solution":"def word_break(s, word_dict): Determines if the string can be segmented into a space-separated sequence of one or more dictionary words. Returns a tuple of (bool, segmented_string) where segmented_string is the space-separated sequence or empty if segmentation is not possible. n = len(s) dp = [False] * (n + 1) dp[0] = True backtrack = [-1] * (n + 1) for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in word_dict: dp[i] = True backtrack[i] = j break if not dp[n]: return False, \\"\\" # Backtracking to reconstruct the segmented string segments = [] idx = n while idx > 0: segments.append(s[backtrack[idx]:idx]) idx = backtrack[idx] return True, ' '.join(reversed(segments)) def parse_input_output(input_string): Parses the multi-line input_string and returns the corresponding output. lines = input_string.strip().split(\\"n\\") t = int(lines[0]) results = [] index = 1 for _ in range(t): s = lines[index] w = int(lines[index + 1]) word_dict = set(lines[index + 2:index + 2 + w]) index = index + 2 + w result = word_break(s, word_dict) if result[0]: results.append(f\\"Truen{result[1]}\\") else: results.append(\\"False\\") return \\"n\\".join(results)"},{"question":"from typing import List def count_removals_to_strictly_increasing(heights: List[int]) -> int: Returns the minimum number of removals needed to make the heights strictly increasing. >>> count_removals_to_strictly_increasing([1, 2, 2, 3, 4, 4, 5]) 2 >>> count_removals_to_strictly_increasing([1, 1, 1, 1]) 3 >>> count_removals_to_strictly_increasing([1, 2, 3, 4, 5]) 0 def test_no_removals_needed(): assert count_removals_to_strictly_increasing([1, 2, 3, 4, 5]) == 0 def test_removals_needed_at_ends(): assert count_removals_to_strictly_increasing([1, 1, 2, 3, 4]) == 1 assert count_removals_to_strictly_increasing([2, 3, 4, 5, 5]) == 1 def test_removals_needed_in_middle(): assert count_removals_to_strictly_increasing([1, 2, 2, 3, 4, 4, 5]) == 2 def test_all_elements_same(): assert count_removals_to_strictly_increasing([1, 1, 1, 1]) == 3 def test_empty_list(): assert count_removals_to_strictly_increasing([]) == 0 def test_one_element(): assert count_removals_to_strictly_increasing([1]) == 0 def test_two_elements_no_removal(): assert count_removals_to_strictly_increasing([1, 2]) == 0 def test_two_elements_with_removal(): assert count_removals_to_strictly_increasing([2, 2]) == 1","solution":"from typing import List def count_removals_to_strictly_increasing(heights: List[int]) -> int: Returns the minimum number of removals needed to make the heights strictly increasing. if not heights: return 0 removals = 0 n = len(heights) for i in range(1, n): if heights[i] == heights[i-1]: removals += 1 return removals"},{"question":"def find_winner(candies): Determines the winner of the candy picking game between Alice and Bob. Args: candies (list of int): An array representing the number of candies in each pile. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins or \\"Tie\\" if both have the same number of candies. # Your code here # Unit Tests def test_find_winner_basic_cases(): candies1 = [3, 9, 1, 2] assert find_winner(candies1) == \\"Alice\\" candies2 = [1, 2, 1, 2] assert find_winner(candies2) == \\"Tie\\" def test_find_winner_edges(): assert find_winner([]) == \\"Tie\\" assert find_winner([10]) == \\"Alice\\" assert find_winner([5, 5]) == \\"Tie\\" def test_find_winner_various_cases(): candies3 = [8, 7, 6, 5] assert find_winner(candies3) == \\"Alice\\" candies4 = [5, 8, 3, 3, 2] assert find_winner(candies4) == \\"Alice\\" candies5 = [20, 10, 5, 1] assert find_winner(candies5) == \\"Alice\\" def test_find_winner_alternate(): candies6 = [4, 4, 9, 9] # Alice picks 9, Bob picks 9, Alice picks 4, Bob picks 4 assert find_winner(candies6) == \\"Tie\\" candies7 = [20, 5, 5, 3] # Alice picks 20, Bob picks 5, Alice picks 5, Bob picks 3 assert find_winner(candies7) == \\"Alice\\" def test_find_winner_large_input(): candies8 = [i for i in range(1, 101)] assert find_winner(candies8) == \\"Alice\\" def test_find_winner_tied_output(): candies9 = [5, 5, 10, 10] assert find_winner(candies9) == \\"Tie\\"","solution":"def find_winner(candies): Determines the winner of the candy picking game between Alice and Bob. Args: candies (list of int): An array representing the number of candies in each pile. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins or \\"Tie\\" if both have the same number of candies. if not candies: return \\"Tie\\" # Sort candies in descending order candies.sort(reverse=True) # Initialize scores alice_score = 0 bob_score = 0 # Distribute candies for i in range(len(candies)): if i % 2 == 0: alice_score += candies[i] else: bob_score += candies[i] # Determine winner if alice_score > bob_score: return \\"Alice\\" elif bob_score > alice_score: return \\"Bob\\" else: return \\"Tie\\""},{"question":"import heapq class MedianFinder: Class to calculate the median from a stream of integers. def __init__(self): Initialize your data structure here. Use two heaps to store the lower half and the upper half of the numbers. self.max_heap = [] # Max-heap (inverted min-heap) for the lower half self.min_heap = [] # Min-heap for the upper half def addNum(self, num: int) -> None: Adds a number into the data structure. pass def findMedian(self) -> float: Returns the median of current data stream. pass # Unit Tests def test_median_finder_simple(): medianFinder = MedianFinder() medianFinder.addNum(1) medianFinder.addNum(2) assert medianFinder.findMedian() == 1.5 medianFinder.addNum(3) assert medianFinder.findMedian() == 2.0 def test_median_finder_single_element(): medianFinder = MedianFinder() medianFinder.addNum(4) assert medianFinder.findMedian() == 4.0 def test_median_finder_even_elements(): medianFinder = MedianFinder() medianFinder.addNum(6) medianFinder.addNum(10) assert medianFinder.findMedian() == 8.0 medianFinder.addNum(2) medianFinder.addNum(8) assert medianFinder.findMedian() == 7.0 def test_median_finder_odd_elements(): medianFinder = MedianFinder() medianFinder.addNum(1) medianFinder.addNum(5) medianFinder.addNum(3) assert medianFinder.findMedian() == 3.0 medianFinder.addNum(2) assert medianFinder.findMedian() == 2.5 medianFinder.addNum(4) assert medianFinder.findMedian() == 3.0 def test_median_finder_large_numbers(): medianFinder = MedianFinder() numbers = [i for i in range(1, 100001)] for num in numbers: medianFinder.addNum(num) assert medianFinder.findMedian() == 50000.5 def test_median_balancing(): medianFinder = MedianFinder() medianFinder.addNum(5) assert medianFinder.findMedian() == 5.0 medianFinder.addNum(15) assert medianFinder.findMedian() == 10.0 medianFinder.addNum(1) assert medianFinder.findMedian() == 5.0 medianFinder.addNum(3) assert medianFinder.findMedian() == 4.0 def test_median_with_negative_numbers(): medianFinder = MedianFinder() medianFinder.addNum(-1) medianFinder.addNum(-2) assert medianFinder.findMedian() == -1.5 medianFinder.addNum(-3) assert medianFinder.findMedian() == -2.0 def test_median_with_zero(): medianFinder = MedianFinder() medianFinder.addNum(0) assert medianFinder.findMedian() == 0.0 medianFinder.addNum(1) assert medianFinder.findMedian() == 0.5 medianFinder.addNum(-1) assert medianFinder.findMedian() == 0.0","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. Use two heaps to store the lower half and the upper half of the numbers. self.max_heap = [] # Max-heap (inverted min-heap) for the lower half self.min_heap = [] # Min-heap for the upper half def addNum(self, num: int) -> None: Adds a number into the data structure. # Add to max heap (invert the sign to use min-heap as max-heap) heapq.heappush(self.max_heap, -num) # Balance heaps: the largest in max_heap must be <= smallest in min_heap if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Ensure the heaps are balanced in size, max_heap can have one extra element if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: Returns the median of current data stream. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"from typing import List def daily_step_goal(steps: List[int], goal: int) -> List[bool]: Determines on which days step counts met or exceeded the daily step goal. Args: steps (list of int): A list of integers representing daily step counts. goal (int): The daily step goal. Returns: list of bool: A list of boolean values where True indicates the step count met or exceeded the goal. Examples: >>> daily_step_goal([10000, 8500, 12000, 9000, 7000, 11000, 9500], 10000) [True, False, True, False, False, True, False] >>> daily_step_goal([5000, 7000, 9000], 10000) [False, False, False] >>> daily_step_goal([15000, 5000, 10000, 20000], 10000) [True, False, True, True] # Test cases to validate the solution def test_daily_step_goal_all_meet(): assert daily_step_goal([10000, 10000, 10000], 10000) == [True, True, True] def test_daily_step_goal_none_meet(): assert daily_step_goal([5000, 7000, 9000], 10000) == [False, False, False] def test_daily_step_goal_some_meet(): assert daily_step_goal([10000, 8500, 12000, 9000, 7000, 11000, 9500], 10000) == [True, False, True, False, False, True, False] def test_daily_step_goal_with_mixed_values(): assert daily_step_goal([15000, 5000, 10000, 20000], 10000) == [True, False, True, True] def test_daily_step_goal_empty_list(): assert daily_step_goal([], 10000) == [] def test_daily_step_goal_one_element(): assert daily_step_goal([15000], 10000) == [True] assert daily_step_goal([5000], 10000) == [False]","solution":"def daily_step_goal(steps, goal): Determines on which days step counts met or exceeded the daily step goal. Args: steps (list of int): A list of integers representing daily step counts. goal (int): The daily step goal. Returns: list of bool: A list of boolean values where True indicates the step count met or exceeded the goal. return [step >= goal for step in steps]"},{"question":"def top_k_customers(N: int, K: int, customers: List[Tuple[int, float]]) -> List[int]: Takes the number of customers, number of top customers to output, and a list of tuples with customer ID and their rating. Returns a list of top K customer IDs with the highest ratings in descending order. In case of ties, the IDs are sorted in ascending order. >>> top_k_customers(5, 3, [(123, 4.5), (456, 3.8), (789, 4.5), (101, 2.9), (102, 5.0)]) == [102, 123, 789] >>> top_k_customers(6, 3, [(123, 4.5), (456, 3.8), (789, 4.5), (101, 4.5), (102, 5.0), (103, 3.8)]) == [102, 101, 123] >>> top_k_customers(4, 2, [(101, 4.0), (102, 4.0), (103, 4.0), (104, 4.0)]) == [101, 102] >>> top_k_customers(3, 5, [(201, 3.6), (202, 4.2), (203, 4.0)]) == [202, 203, 201] >>> top_k_customers(1, 1, [(301, 5.0)]) == [301]","solution":"def top_k_customers(N, K, customers): Takes the number of customers, number of top customers to output, and a list of tuples with customer ID and their rating. Returns a list of top K customer IDs with the highest ratings in descending order. In case of ties, the IDs are sorted in ascending order. # Sort customers first by descending rating, then by ascending customer ID sorted_customers = sorted(customers, key=lambda x: (-x[1], x[0])) # Extract top K customer IDs top_k_ids = [customer[0] for customer in sorted_customers[:K]] return top_k_ids"},{"question":"def findLargestSquare(grid: List[List[int]]) -> int: Design an algorithm to determine the largest possible square sub-grid where all the elements are the same in a given N x N grid of integers. >>> findLargestSquare([ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0], [1, 1, 0, 0] ]) 3 >>> findLargestSquare([ [0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ]) 2 >>> findLargestSquare([ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]) 1 >>> findLargestSquare([ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1] ]) 5 >>> findLargestSquare([]) 0 >>> findLargestSquare([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0","solution":"def findLargestSquare(grid): if not grid or not grid[0]: return 0 N = len(grid) dp = [[0 for _ in range(N)] for _ in range(N)] max_side = 0 for i in range(N): for j in range(N): if i == 0 or j == 0: dp[i][j] = grid[i][j] elif grid[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 0 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"from typing import List, Dict, Any def student_performance_evaluation(data: List[List[str]]) -> Dict[str, Any]: Evaluates the student performance based on the given data. Returns the student with the highest total score, the student with the highest Mathematics score, and the average scores for each subject. Example: >>> data = [ ... [\\"Alice\\", \\"20\\", \\"85\\", \\"78\\", \\"92\\"], ... [\\"Bob\\", \\"19\\", \\"90\\", \\"88\\", \\"95\\"], ... [\\"Charlie\\", \\"21\\", \\"88\\", \\"76\\", \\"89\\"], ... [\\"David\\", \\"22\\", \\"65\\", \\"85\\", \\"78\\"], ... [\\"Eve\\", \\"20\\", \\"91\\", \\"92\\", \\"90\\"] ... ] >>> result = student_performance_evaluation(data) >>> result[\\"Highest Total Score\\"] 'Bob' >>> result[\\"Highest Mathematics Score\\"] 'Eve' >>> result[\\"Average Scores\\"] {'Mathematics': 83.8, 'Physics': 83.8, 'Chemistry': 88.8} pass # Unit Tests def test_highest_total_score(): data = [ [\\"Alice\\", \\"20\\", \\"85\\", \\"78\\", \\"92\\"], [\\"Bob\\", \\"19\\", \\"90\\", \\"88\\", \\"95\\"], [\\"Charlie\\", \\"21\\", \\"88\\", \\"76\\", \\"89\\"], [\\"David\\", \\"22\\", \\"65\\", \\"85\\", \\"78\\"], [\\"Eve\\", \\"20\\", \\"91\\", \\"92\\", \\"90\\"] ] result = student_performance_evaluation(data) assert result[\\"Highest Total Score\\"] == \\"Bob\\" def test_highest_mathematics_score(): data = [ [\\"Alice\\", \\"20\\", \\"85\\", \\"78\\", \\"92\\"], [\\"Bob\\", \\"19\\", \\"90\\", \\"88\\", \\"95\\"], [\\"Charlie\\", \\"21\\", \\"88\\", \\"76\\", \\"89\\"], [\\"David\\", \\"22\\", \\"65\\", \\"85\\", \\"78\\"], [\\"Eve\\", \\"20\\", \\"91\\", \\"92\\", \\"90\\"] ] result = student_performance_evaluation(data) assert result[\\"Highest Mathematics Score\\"] == \\"Eve\\" def test_average_scores(): data = [ [\\"Alice\\", \\"20\\", \\"85\\", \\"78\\", \\"92\\"], [\\"Bob\\", \\"19\\", \\"90\\", \\"88\\", \\"95\\"], [\\"Charlie\\", \\"21\\", \\"88\\", \\"76\\", \\"89\\"], [\\"David\\", \\"22\\", \\"65\\", \\"85\\", \\"78\\"], [\\"Eve\\", \\"20\\", \\"91\\", \\"92\\", \\"90\\"] ] result = student_performance_evaluation(data) expected_averages = { \\"Mathematics\\": 83.8, \\"Physics\\": 83.8, \\"Chemistry\\": 88.8 } assert result[\\"Average Scores\\"] == expected_averages def test_single_student(): data = [ [\\"Alice\\", \\"20\\", \\"85\\", \\"78\\", \\"92\\"], ] result = student_performance_evaluation(data) assert result[\\"Highest Total Score\\"] == \\"Alice\\" assert result[\\"Highest Mathematics Score\\"] == \\"Alice\\" expected_averages = { \\"Mathematics\\": 85.0, \\"Physics\\": 78.0, \\"Chemistry\\": 92.0 } assert result[\\"Average Scores\\"] == expected_averages","solution":"def student_performance_evaluation(data): Evaluates the student performance based on the given data. Returns the student with the highest total score, the student with the highest Mathematics score, and the average scores for each subject. highest_total_score = None highest_math_score = None total_math_scores = 0 total_physics_scores = 0 total_chemistry_scores = 0 for student in data: name, age, math, physics, chemistry = student age, math, physics, chemistry = int(age), int(math), int(physics), int(chemistry) total_score = math + physics + chemistry if highest_total_score is None or total_score > highest_total_score[1]: highest_total_score = (name, total_score) if highest_math_score is None or math > highest_math_score[1]: highest_math_score = (name, math) total_math_scores += math total_physics_scores += physics total_chemistry_scores += chemistry num_students = len(data) avg_math_score = round(total_math_scores / num_students, 1) avg_physics_score = round(total_physics_scores / num_students, 1) avg_chemistry_score = round(total_chemistry_scores / num_students, 1) results = { \\"Highest Total Score\\": highest_total_score[0], \\"Highest Mathematics Score\\": highest_math_score[0], \\"Average Scores\\": { \\"Mathematics\\": avg_math_score, \\"Physics\\": avg_physics_score, \\"Chemistry\\": avg_chemistry_score } } return results # Example usage data = [ [\\"Alice\\", \\"20\\", \\"85\\", \\"78\\", \\"92\\"], [\\"Bob\\", \\"19\\", \\"90\\", \\"88\\", \\"95\\"], [\\"Charlie\\", \\"21\\", \\"88\\", \\"76\\", \\"89\\"], [\\"David\\", \\"22\\", \\"65\\", \\"85\\", \\"78\\"], [\\"Eve\\", \\"20\\", \\"91\\", \\"92\\", \\"90\\"] ] print(student_performance_evaluation(data))"},{"question":"def maximize_sum(arr: List[int]) -> int: Function to compute the maximum sum of an integer array by performing operations to maximize the sum. Each operation consists of choosing one or two adjacent elements and replacing them with their greatest common divisor (GCD). :param arr: List[int] - list of integers :return: int - the maximum sum of the array after at most n-1 operations Examples: >>> maximize_sum([4, 6, 8]) 18 >>> maximize_sum([2, 3, 5, 7, 11]) 28 >>> maximize_sum([12, 15, 18, 21]) 66 >>> maximize_sum([3, 6, 9, 12, 15, 18]) 63 from typing import List def test_maximize_sum_single_element(): assert maximize_sum([5]) == 5 assert maximize_sum([999999]) == 999999 def test_maximize_sum_basic_examples(): assert maximize_sum([4, 6, 8]) == 18 assert maximize_sum([2, 3, 5, 7, 11]) == 28 assert maximize_sum([12, 15, 18, 21]) == 66 assert maximize_sum([3, 6, 9, 12, 15, 18]) == 63 def test_maximize_sum_large_numbers(): assert maximize_sum([1000000, 999999, 999998]) == 2999997 assert maximize_sum([100, 200, 300, 400, 500, 600]) == 2100 def test_maximize_sum_mixed_values(): assert maximize_sum([100, 1, 1000, 1]) == 1102 assert maximize_sum([3, 10, 1000, 2, 3]) == 1018 def test_maximize_sum_all_ones(): assert maximize_sum([1, 1, 1, 1, 1]) == 5","solution":"def maximize_sum(arr): Function to compute the maximum sum of array with given constraints. return sum(arr)"},{"question":"def rotate_matrix(matrix): Rotates a given NxN 2D matrix 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix([ ... [ 1, 2, 3, 4], ... [ 5, 6, 7, 8], ... [ 9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == [ ... [13, 9, 5, 1], ... [14, 10, 6, 2], ... [15, 11, 7, 3], ... [16, 12, 8, 4] ... ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) == [ ... [3, 1], ... [4, 2] ... ] >>> rotate_matrix([ ... [1] ... ]) == [ ... [1] ... ]","solution":"def rotate_matrix(matrix): Rotates a given NxN 2D matrix 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def is_consecutive(lst: List[int]) -> bool: Determine if the list of numbers can be rearranged to form a continuous sequence where each number appears exactly once. >>> is_consecutive([5, 4, 2, 1, 3]) => True >>> is_consecutive([1, 2, 4, 6, 5]) => False >>> is_consecutive([9, 7, 8]) => True def test_is_consecutive(): assert is_consecutive([5, 4, 2, 1, 3]) == True assert is_consecutive([1, 2, 4, 6, 5]) == False assert is_consecutive([9, 7, 8]) == True assert is_consecutive([]) == False assert is_consecutive([1, 1, 2, 3, 4]) == False assert is_consecutive([1, 2, 3, 4, 5]) == True assert is_consecutive([10, 11, 12, 13, 14, 15]) == True assert is_consecutive([10, 11, 12, 13, 15]) == False assert is_consecutive([3]) == True assert is_consecutive([100, 101, 102, 103, 104, 105, 106, 107]) == True assert is_consecutive([100, 102, 103, 104, 105, 106, 107]) == False assert is_consecutive([-1, 0, 1, 2, 3, 4]) == True assert is_consecutive([-3, -2, -1, 0, 1, 2]) == True","solution":"def is_consecutive(lst): if not lst: return False min_num = min(lst) max_num = max(lst) expected_length = max_num - min_num + 1 return len(lst) == expected_length and len(set(lst)) == expected_length"},{"question":"from typing import List, Tuple def shortest_friendship_path(users: List[List[int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the shortest path of friendship between users. Args: users (List[List[int]]): A list of lists where each sublist contains the friends of each user. queries (List[Tuple[int, int]]): A list of tuples representing the query pairs. Returns: List[int]: A list of integers representing the shortest path lengths for each query. >>> users = [ ... [1, 2], # Friends of User 0 ... [0, 2], # Friends of User 1 ... [0, 1, 3], # Friends of User 2 ... [2, 4], # Friends of User 3 ... [3] # Friends of User 4 ... ] >>> queries = [ ... (0, 4), # Query 1 ... (1, 3), # Query 2 ... (0, 2) # Query 3 ... ] >>> shortest_friendship_path(users, queries) [3, 2, 1] >>> users = [ ... [1], # Friends of User 0 ... [0], # Friends of User 1 ... [], # Friends of User 2 ... [4], # Friends of User 3 ... [3] # Friends of User 4 ... ] >>> queries = [ ... (0, 2), # Query 1 ... (1, 4), # Query 2 ... (2, 3) # Query 3 ... ] >>> shortest_friendship_path(users, queries) [-1, -1, -1] >>> users = [ ... [1], # Friends of User 0 ... [0] # Friends of User 1 ... ] >>> queries = [ ... (0, 1), # Query 1 ... (1, 0) # Query 2 ... ] >>> shortest_friendship_path(users, queries) [1, 1] >>> users = [[]] >>> queries = [ ... (0, 0) # Query 1 ... ] >>> shortest_friendship_path(users, queries) [0]","solution":"from collections import deque def shortest_friendship_path(users, queries): def bfs(start, end): if start == end: return 0 visited = [False] * len(users) distance = [0] * len(users) queue = deque([start]) visited[start] = True while queue: user = queue.popleft() for friend in users[user]: if not visited[friend]: queue.append(friend) visited[friend] = True distance[friend] = distance[user] + 1 if friend == end: return distance[friend] return -1 results = [] for a, b in queries: results.append(bfs(a, b)) return results"},{"question":"def rotate_2d_matrix(matrix): Rotates an nxn 2D matrix 90 degrees clockwise in-place. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_2d_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] # Test cases def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_2d_matrix(matrix) assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] rotate_2d_matrix(matrix) assert matrix == expected def test_rotate_single_element_matrix(): matrix = [ [1] ] expected = [ [1] ] rotate_2d_matrix(matrix) assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] rotate_2d_matrix(matrix) assert matrix == expected def test_rotate_5x5_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] rotate_2d_matrix(matrix) assert matrix == expected","solution":"def rotate_2d_matrix(matrix): Rotates an nxn 2D matrix 90 degrees clockwise in-place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp"},{"question":"def equalize_array(arr): Returns the minimum number of deletions required to make all the elements of the array equal. Examples: >>> equalize_array([3, 3, 2, 1, 3]) 2 >>> equalize_array([1, 2, 2, 3]) 2 >>> equalize_array([1, 1, 1, 1]) 0 from collections import Counter # Unit Tests from solution import equalize_array def test_equalize_array_example_1(): assert equalize_array([3, 3, 2, 1, 3]) == 2 def test_equalize_array_example_2(): assert equalize_array([1, 2, 2, 3]) == 2 def test_equalize_array_example_3(): assert equalize_array([1, 1, 1, 1]) == 0 def test_equalize_array_all_unique(): assert equalize_array([1, 2, 3, 4]) == 3 def test_equalize_array_multiple_frequencies(): assert equalize_array([4, 4, 2, 2, 2, 1, 1]) == 4 def test_equalize_array_single_element(): assert equalize_array([4]) == 0 def test_equalize_array_large_number_of_elements(): assert equalize_array([1]*1000 + [2]*500 + [3]*300) == 800","solution":"def equalize_array(arr): Returns the minimum number of deletions required to make all the elements of the array equal. from collections import Counter # Count the frequency of each element in the array freq = Counter(arr) # Find the maximum frequency of any element max_freq = max(freq.values()) # The minimum deletions required will be the total number of elements # minus the number of elements of the most frequent value return len(arr) - max_freq"},{"question":"def digital_root(n): Returns the digital root of a number. >>> digital_root(678) 3 >>> digital_root(12345) 6 >>> digital_root(99999) 9 def shield_activation_code(N, K): Returns the K-th number in the sequence starting from N. >>> shield_activation_code(678, 1) 678 >>> shield_activation_code(678, 2) 681 >>> shield_activation_code(678, 3) 681 >>> shield_activation_code(678, 4) 687 >>> shield_activation_code(678, 5) 687 def format_shield_activation_code(N, K): Formats the result according to the desired output. >>> format_shield_activation_code(678, 1) \\"Shield activation code at position 1 is 678.\\" >>> format_shield_activation_code(678, 2) \\"Shield activation code at position 2 is 681.\\" >>> format_shield_activation_code(678, 3) \\"Shield activation code at position 3 is 681.\\" >>> format_shield_activation_code(678, 4) \\"Shield activation code at position 4 is 687.\\" >>> format_shield_activation_code(678, 5) \\"Shield activation code at position 5 is 687.\\"","solution":"def digital_root(n): Returns the digital root of a number. while n >= 10: n = sum(int(digit) for digit in str(n)) return n def shield_activation_code(N, K): Returns the K-th number in the sequence starting from N. sequence = [N] for i in range(1, K): if i % 2 == 0: # even index (1 based index, hence i % 2 == 0 means odd indexed positions) sequence.append(sequence[-1]) else: current = sequence[-1] next_num = current + digital_root(current) sequence.append(next_num) return sequence[K-1] def format_shield_activation_code(N, K): Formats the result according to the desired output. code = shield_activation_code(N, K) return f\\"Shield activation code at position {K} is {code}.\\""},{"question":"def job_matching(positions, candidates): positions: List of dictionaries, each containing 'title' (job title) and 'skills' (set of required skills) candidates: List of dictionaries, each containing 'name' (candidate's name) and 'skills' (set of skills the candidate has) Returns: Dictionary where each job title is matched with the most suitable candidate's name >>> positions = [ >>> {'title': 'Software Engineer', 'skills': {'Python', 'Django', 'REST'}}, >>> {'title': 'Data Scientist', 'skills': {'Python', 'Machine Learning', 'Statistics'}} >>> ] >>> candidates = [ >>> {'name': 'Alice', 'skills': {'Python', 'Django', 'REST', 'GraphQL'}}, >>> {'name': 'Bob', 'skills': {'Python', 'Machine Learning', 'Statistics', 'SQL'}}, >>> {'name': 'Charlie', 'skills': {'Python', 'REST'}} >>> ] >>> job_matching(positions, candidates) {'Software Engineer': 'Alice', 'Data Scientist': 'Bob'} pass from solution import job_matching def test_job_matching_single_position_single_candidate(): positions = [{'title': 'Developer', 'skills': {'Python'}}] candidates = [{'name': 'Alice', 'skills': {'Python', 'Django'}}] result = job_matching(positions, candidates) assert result == {'Developer': 'Alice'} def test_job_matching_single_position_multiple_candidates(): positions = [{'title': 'Designer', 'skills': {'Photoshop'}}] candidates = [ {'name': 'Bob', 'skills': {'Photoshop', 'Illustrator'}}, {'name': 'Charlie', 'skills': {'Photoshop'}} ] result = job_matching(positions, candidates) assert result == {'Designer': 'Bob'} def test_job_matching_multiple_positions_multiple_candidates(): positions = [ {'title': 'Software Engineer', 'skills': {'Python', 'Django', 'REST'}}, {'title': 'Data Scientist', 'skills': {'Python', 'Machine Learning', 'Statistics'}} ] candidates = [ {'name': 'Alice', 'skills': {'Python', 'Django', 'REST', 'GraphQL'}}, {'name': 'Bob', 'skills': {'Python', 'Machine Learning', 'Statistics', 'SQL'}}, {'name': 'Charlie', 'skills': {'Python', 'REST'}} ] result = job_matching(positions, candidates) assert result == {'Software Engineer': 'Alice', 'Data Scientist': 'Bob'} def test_job_matching_no_suitable_candidates(): positions = [{'title': 'Manager', 'skills': {'Leadership'}}] candidates = [{'name': 'Alice', 'skills': {'Python'}}] result = job_matching(positions, candidates) assert result == {} def test_job_matching_candidates_with_equal_skills(): positions = [{'title': 'Analyst', 'skills': {'Excel'}}] candidates = [ {'name': 'Dana', 'skills': {'Excel'}}, {'name': 'Eve', 'skills': {'Excel'}} ] result = job_matching(positions, candidates) assert result == {'Analyst': 'Dana'}","solution":"def job_matching(positions, candidates): positions: List of dictionaries, each containing 'title' (job title) and 'skills' (set of required skills) candidates: List of dictionaries, each containing 'name' (candidate's name) and 'skills' (set of skills the candidate has) Returns: Dictionary where each job title is matched with the most suitable candidate's name matched_jobs = {} for position in positions: job_title = position['title'] required_skills = position['skills'] best_candidate = None best_candidate_skills_count = -1 for candidate in candidates: candidate_name = candidate['name'] candidate_skills = candidate['skills'] if required_skills.issubset(candidate_skills): if len(candidate_skills) > best_candidate_skills_count: best_candidate = candidate_name best_candidate_skills_count = len(candidate_skills) if best_candidate: matched_jobs[job_title] = best_candidate return matched_jobs"},{"question":"class ParkingLot: def __init__(self, max_spaces): Initialize the ParkingLot with a maximum number of spaces. pass def enter(self, vehicleType): A vehicle enters the parking lot. vehicleType can be \\"car\\" or \\"motorcycle\\". A car takes one parking space, and a motorcycle takes half a parking space. Returns True if the vehicle successfully enters, else False. pass def exit(self, vehicleType): A vehicle exits the parking lot. vehicleType can be \\"car\\" or \\"motorcycle\\". Returns True if the vehicle successfully exits, else False. pass def getAvailableSpaces(self): Retrieve the number of available spaces in the parking lot. pass # Test cases to verify the implementation def test_parking_lot_init(): parking_lot = ParkingLot(10) assert parking_lot.getAvailableSpaces() == 10 def test_enter_car(): parking_lot = ParkingLot(10) assert parking_lot.enter(\\"car\\") == True assert parking_lot.getAvailableSpaces() == 9 def test_enter_motorcycle(): parking_lot = ParkingLot(10) assert parking_lot.enter(\\"motorcycle\\") == True assert parking_lot.getAvailableSpaces() == 9.5 def test_exit_car(): parking_lot = ParkingLot(10) parking_lot.enter(\\"car\\") assert parking_lot.exit(\\"car\\") == True assert parking_lot.getAvailableSpaces() == 10 def test_exit_motorcycle(): parking_lot = ParkingLot(10) parking_lot.enter(\\"motorcycle\\") assert parking_lot.exit(\\"motorcycle\\") == True assert parking_lot.getAvailableSpaces() == 10 def test_exit_non_existing_car(): parking_lot = ParkingLot(10) assert parking_lot.exit(\\"car\\") == False def test_exit_non_existing_motorcycle(): parking_lot = ParkingLot(10) assert parking_lot.exit(\\"motorcycle\\") == False def test_enter_car_when_full(): parking_lot = ParkingLot(1) assert parking_lot.enter(\\"car\\") == True assert parking_lot.enter(\\"car\\") == False def test_enter_motorcycle_when_full(): parking_lot = ParkingLot(0.5) assert parking_lot.enter(\\"motorcycle\\") == True assert parking_lot.enter(\\"motorcycle\\") == False def test_full_cycle(): parking_lot = ParkingLot(10) assert parking_lot.enter(\\"car\\") == True assert parking_lot.enter(\\"motorcycle\\") == True assert parking_lot.getAvailableSpaces() == 8.5 assert parking_lot.enter(\\"car\\") == True assert parking_lot.getAvailableSpaces() == 7.5 assert parking_lot.exit(\\"car\\") == True assert parking_lot.getAvailableSpaces() == 8.5 assert parking_lot.exit(\\"motorcycle\\") == True assert parking_lot.getAvailableSpaces() == 9 assert parking_lot.exit(\\"car\\") == True assert parking_lot.getAvailableSpaces() == 10","solution":"class ParkingLot: def __init__(self, max_spaces): self.max_spaces = max_spaces self.available_spaces = max_spaces self.car_count = 0 self.motorcycle_count = 0 def enter(self, vehicleType): if vehicleType == \\"car\\": if self.available_spaces >= 1: self.available_spaces -= 1 self.car_count += 1 return True else: return False elif vehicleType == \\"motorcycle\\": if self.available_spaces >= 0.5: self.available_spaces -= 0.5 self.motorcycle_count += 1 return True else: return False return False def exit(self, vehicleType): if vehicleType == \\"car\\" and self.car_count > 0: self.available_spaces += 1 self.car_count -= 1 return True elif vehicleType == \\"motorcycle\\" and self.motorcycle_count > 0: self.available_spaces += 0.5 self.motorcycle_count -= 1 return True return False def getAvailableSpaces(self): return self.available_spaces"},{"question":"def searchInRotatedArray(nums, target): Searches for a target value in a rotated sorted array and returns its index. If the target is not found, returns -1. Args: nums: List[int] - a rotated, sorted array of integers. target: int - the target value to search for. Returns: int - the index of the target value in the array, or -1 if the target is not found. Examples: >>> searchInRotatedArray([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> searchInRotatedArray([4, 5, 6, 7, 0, 1, 2], 3) -1 from solution import searchInRotatedArray def test_example_1(): arr = [4, 5, 6, 7, 0, 1, 2] target = 0 assert searchInRotatedArray(arr, target) == 4 def test_example_2(): arr = [4, 5, 6, 7, 0, 1, 2] target = 3 assert searchInRotatedArray(arr, target) == -1 def test_single_element_found(): arr = [1] target = 1 assert searchInRotatedArray(arr, target) == 0 def test_single_element_not_found(): arr = [1] target = 2 assert searchInRotatedArray(arr, target) == -1 def test_empty_array(): arr = [] target = 1 assert searchInRotatedArray(arr, target) == -1 def test_larger_example_found(): arr = [15, 18, 2, 3, 6, 12] target = 3 assert searchInRotatedArray(arr, target) == 3 def test_larger_example_not_found(): arr = [15, 18, 2, 3, 6, 12] target = 13 assert searchInRotatedArray(arr, target) == -1","solution":"def searchInRotatedArray(nums, target): Searches for a target value in a rotated sorted array and returns its index. If the target is not found, returns -1. if not nums: # if the list is empty return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine if the left or right half is sorted if nums[left] <= nums[mid]: # Left half is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def contains_nearby_almost_duplicate(nums, k, t): Determines if the list contains two distinct indices i and j such that: - the absolute difference between nums[i] and nums[j] is at most t, - the absolute difference between i and j is at most k. pass from contains_nearby_almost_duplicate import contains_nearby_almost_duplicate def test_example_1(): assert contains_nearby_almost_duplicate([1, 2, 3, 1], 3, 0) == True def test_example_2(): assert contains_nearby_almost_duplicate([1, 0, 1, 1], 1, 2) == True def test_example_3(): assert contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 2, 3) == False def test_no_elements(): assert contains_nearby_almost_duplicate([], 1, 1) == False def test_single_element(): assert contains_nearby_almost_duplicate([1], 1, 1) == False def test_negatives_1(): assert contains_nearby_almost_duplicate([-1, -1], 1, 0) == True def test_negatives_2(): assert contains_nearby_almost_duplicate([-5, -3, -1, 1], 2, 3) == True def test_large_t(): assert contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 4, 100) == True def test_large_k(): assert contains_nearby_almost_duplicate([1, 2, 3, 1], 100, 0) == True def test_empty_k_t(): assert contains_nearby_almost_duplicate([1, 0, 1], 0, 0) == False","solution":"def contains_nearby_almost_duplicate(nums, k, t): Determines if the list contains two distinct indices i and j such that: - the absolute difference between nums[i] and nums[j] is at most t, - the absolute difference between i and j is at most k. if t < 0: return False n = len(nums) dict_buckets = {} bucket_size = t + 1 for i in range(n): bucket_num = nums[i] // bucket_size if bucket_num in dict_buckets: return True if (bucket_num - 1 in dict_buckets and abs(nums[i] - dict_buckets[bucket_num - 1]) < bucket_size): return True if (bucket_num + 1 in dict_buckets and abs(nums[i] - dict_buckets[bucket_num + 1]) < bucket_size): return True dict_buckets[bucket_num] = nums[i] if i >= k: del dict_buckets[nums[i - k] // bucket_size] return False"},{"question":"def max_subarray_sum_distinct_elements(arr: List[int], k: int) -> int: Finds the maximum sum of a subarray of length k such that all elements in the subarray are distinct. Args: arr (List[int]): The input array. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k with all distinct elements. Example: >>> max_subarray_sum_distinct_elements([4,5,0,4,5,9,7,1], 3) 21 >>> max_subarray_sum_distinct_elements([2,2,2,2,2], 2) 0 >>> max_subarray_sum_distinct_elements([1,2,3,4,5], 5) 15 from solution import max_subarray_sum_distinct_elements def test_example_1(): assert max_subarray_sum_distinct_elements([4,5,0,4,5,9,7,1], 3) == 21 def test_example_2(): assert max_subarray_sum_distinct_elements([2,2,2,2,2], 2) == 0 def test_example_3(): assert max_subarray_sum_distinct_elements([1,2,3,4,5], 5) == 15 def test_subarray_in_middle(): assert max_subarray_sum_distinct_elements([1,2,2,4,5,6], 3) == 15 # Subarray [4, 5, 6] def test_entire_array_is_subarray(): assert max_subarray_sum_distinct_elements([10,20,30], 3) == 60 def test_single_element_subarray(): assert max_subarray_sum_distinct_elements([10,20,30], 1) == 30 def test_no_valid_subarray_with_distinct_elements(): assert max_subarray_sum_distinct_elements([1, 1, 1, 1, 1], 5) == 0 # no subarray of length 5 with distinct elements def test_duplicates_adjacent(): assert max_subarray_sum_distinct_elements([4, 4, 5, 6, 7, 8], 3) == 21 # Subarray [6, 7, 8]","solution":"def max_subarray_sum_distinct_elements(arr, k): Finds the maximum sum of a subarray of length k such that all elements in the subarray are distinct. Args: arr (List[int]): The input array. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k with all distinct elements. n = len(arr) max_sum = 0 for i in range(n - k + 1): subarray = arr[i:i + k] if len(subarray) == len(set(subarray)): max_sum = max(max_sum, sum(subarray)) return max_sum"},{"question":"class Bookstore: def __init__(self): Initialize the bookstore's inventory as an empty dictionary. def add_book(self, book_id: int, quantity: int) -> None: Add a new book or update the quantity of an existing book. >>> bookstore = Bookstore() >>> bookstore.add_book(101, 20) >>> bookstore.inventory[101] 20 >>> bookstore.add_book(101, 10) >>> bookstore.inventory[101] 30 def update_quantity(self, book_id: int, quantity: int) -> None: Update the quantity for a given book_id to the new quantity. >>> bookstore = Bookstore() >>> bookstore.add_book(102, 15) >>> bookstore.update_quantity(102, 20) >>> bookstore.inventory[102] 20 def process_purchase(self, book_id: int, quantity: int) -> None: Process the purchase of a book. If the book_id exists and there is sufficient stock, reduce the quantity. Otherwise, print the relevant message. >>> bookstore = Bookstore() >>> bookstore.add_book(101, 20) >>> bookstore.process_purchase(101, 5) >>> bookstore.inventory[101] 15 >>> bookstore.process_purchase(101, 15) >>> captured_output.getvalue().strip() \\"Insufficient stock\\" >>> bookstore.process_purchase(103, 1) >>> captured_output.getvalue().strip() \\"Book ID not found\\" def handle_operations(operations: List[str]) -> None: Handle the list of operations to manage the bookstore inventory. >>> operations = [ \\"add 101 20\\", \\"add 102 15\\", \\"purchase 101 5\\", \\"update 102 20\\", \\"purchase 103 1\\", ] >>> handle_operations(operations) Book ID not found","solution":"class Bookstore: def __init__(self): Initialize the bookstore's inventory as an empty dictionary. self.inventory = {} def add_book(self, book_id, quantity): Add a new book or update the quantity of an existing book. if book_id in self.inventory: self.inventory[book_id] += quantity else: self.inventory[book_id] = quantity def update_quantity(self, book_id, quantity): Update the quantity for a given book_id to the new quantity. self.inventory[book_id] = quantity def process_purchase(self, book_id, quantity): Process the purchase of a book. If the book_id exists and there is sufficient stock, reduce the quantity. Otherwise, print the relevant message. if book_id not in self.inventory: print(\\"Book ID not found\\") elif self.inventory[book_id] < quantity: print(\\"Insufficient stock\\") else: self.inventory[book_id] -= quantity def handle_operations(operations): bookstore = Bookstore() for operation in operations: op = operation.split() if op[0] == \\"add\\": bookstore.add_book(int(op[1]), int(op[2])) elif op[0] == \\"update\\": bookstore.update_quantity(int(op[1]), int(op[2])) elif op[0] == \\"purchase\\": bookstore.process_purchase(int(op[1]), int(op[2]))"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. pass def filter_primes(lst: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the input list. >>> filter_primes([-10, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([0, 1, 2, 15, 19, 22, 23, 24, 25, 29]) [2, 19, 23, 29] >>> filter_primes([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] pass from typing import List def test_filter_primes_empty(): assert filter_primes([]) == [] def test_filter_primes_no_primes(): assert filter_primes([-10, -3, 0, 1, 4, 6, 8, 9, 10]) == [] def test_filter_primes_with_primes(): assert filter_primes([-10, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] def test_filter_primes_all_numbers(): assert filter_primes([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_filter_primes_mixed(): assert filter_primes([0, 1, 2, 15, 19, 22, 23, 24, 25, 29]) == [2, 19, 23, 29]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Returns a new list containing only the prime numbers from the input list. return [x for x in lst if is_prime(x)]"},{"question":"from typing import List def lexicographically_smallest_array(n: int, k: int, A: List[int]) -> List[int]: Given an array A of n integers, and an integer k, this function returns the lexicographically smallest array that can be obtained by repeatedly reversing any contiguous subarray of length k. Args: n (int): Size of the array. k (int): Length of the subarray that can be reversed. A (List[int]): The array of integers. Returns: List[int]: Lexicographically smallest array after any number of reversals. Examples: >>> lexicographically_smallest_array(5, 3, [4, 3, 1, 2, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_array(6, 2, [5, 3, 4, 1, 6, 2]) [1, 2, 3, 4, 5, 6] pass def test_example1(): n = 5 k = 3 A = [4, 3, 1, 2, 5] assert lexicographically_smallest_array(n, k, A) == [1, 2, 3, 4, 5] def test_example2(): n = 6 k = 2 A = [5, 3, 4, 1, 6, 2] assert lexicographically_smallest_array(n, k, A) == [1, 2, 3, 4, 5, 6] def test_single_element(): n = 1 k = 1 A = [1] assert lexicographically_smallest_array(n, k, A) == [1] def test_already_sorted(): n = 4 k = 2 A = [1, 2, 3, 4] assert lexicographically_smallest_array(n, k, A) == [1, 2, 3, 4] def test_k_greater_than_half_n(): n = 5 k = 3 A = [3, 2, 1, 5, 4] assert lexicographically_smallest_array(n, k, A) == [1, 2, 3, 4, 5] def test_reverse_entire_array(): n = 4 k = 4 A = [4, 3, 2, 1] assert lexicographically_smallest_array(n, k, A) == [1, 2, 3, 4]","solution":"from typing import List def lexicographically_smallest_array(n: int, k: int, A: List[int]) -> List[int]: if k == 1: # If k is 1, we can't change the array. Return it as is. return A A_sorted = sorted(A) # Since k > 1, the array can be sorted completely if k > n // 2: return A_sorted # Bubble sort approach to repeatedly find the smallest possible array while True: changed = False for i in range(n - k + 1): new_subarray = A[:i] + list(reversed(A[i:i + k])) + A[i + k:] if new_subarray < A: A = new_subarray changed = True if not changed: break return A"},{"question":"class Library: Library class to manage book lending and track borrowed books. Methods: - add_book(book_title): Adds a book to the library. - borrow_book(book_title): Lends out a book to a member. - return_book(book_title): Returns a book back to the library. - get_inventory(): Lists all books and their current status in the library. - get_borrowed_books(): Lists all borrowed books. Examples: >>> library = Library() >>> library.add_book(\\"Harry Potter\\") >>> library.add_book(\\"The Great Gatsby\\") >>> library.get_inventory() ['Harry Potter: available', 'The Great Gatsby: available'] >>> library.borrow_book(\\"Harry Potter\\") 'Harry Potter has been borrowed.' >>> library.get_inventory() ['Harry Potter: borrowed', 'The Great Gatsby: available'] >>> library.get_borrowed_books() ['Harry Potter: borrowed'] >>> library.return_book(\\"Harry Potter\\") 'Harry Potter has been returned.' >>> library.get_inventory() ['Harry Potter: available', 'The Great Gatsby: available'] def test_add_book(): library = Library() library.add_book(\\"Harry Potter\\") library.add_book(\\"The Great Gatsby\\") assert library.get_inventory() == [\\"Harry Potter: available\\", \\"The Great Gatsby: available\\"] def test_borrow_book(): library = Library() library.add_book(\\"Harry Potter\\") result = library.borrow_book(\\"Harry Potter\\") assert result == \\"Harry Potter has been borrowed.\\" with pytest.raises(ValueError, match=\\"The book is already borrowed\\"): library.borrow_book(\\"Harry Potter\\") with pytest.raises(ValueError, match=\\"The book does not exist in the library\\"): library.borrow_book(\\"The Great Gatsby\\") def test_return_book(): library = Library() library.add_book(\\"Harry Potter\\") with pytest.raises(ValueError, match=\\"The book was not borrowed\\"): library.return_book(\\"Harry Potter\\") library.borrow_book(\\"Harry Potter\\") result = library.return_book(\\"Harry Potter\\") assert result == \\"Harry Potter has been returned.\\" with pytest.raises(ValueError, match=\\"The book was not borrowed\\"): library.return_book(\\"Harry Potter\\") with pytest.raises(ValueError, match=\\"The book does not exist in the library\\"): library.return_book(\\"The Great Gatsby\\") def test_get_inventory(): library = Library() library.add_book(\\"Harry Potter\\") library.add_book(\\"The Great Gatsby\\") library.borrow_book(\\"Harry Potter\\") inventory = library.get_inventory() assert inventory == [\\"Harry Potter: borrowed\\", \\"The Great Gatsby: available\\"] def test_get_borrowed_books(): library = Library() library.add_book(\\"Harry Potter\\") library.add_book(\\"The Great Gatsby\\") library.borrow_book(\\"Harry Potter\\") borrowed_books = library.get_borrowed_books() assert borrowed_books == [\\"Harry Potter: borrowed\\"] library.borrow_book(\\"The Great Gatsby\\") borrowed_books = library.get_borrowed_books() assert borrowed_books == [\\"Harry Potter: borrowed\\", \\"The Great Gatsby: borrowed\\"]","solution":"class Library: def __init__(self): self.books = {} # Dictionary to store book title as key and availability as value (True: borrowed, False: available) def add_book(self, book_title): book_title = book_title.lower() if book_title not in self.books: self.books[book_title] = False def borrow_book(self, book_title): book_title_key = book_title.lower() if book_title_key not in self.books: raise ValueError(\\"The book does not exist in the library\\") if self.books[book_title_key]: raise ValueError(\\"The book is already borrowed\\") self.books[book_title_key] = True return f\\"{book_title} has been borrowed.\\" def return_book(self, book_title): book_title_key = book_title.lower() if book_title_key not in self.books: raise ValueError(\\"The book does not exist in the library\\") if not self.books[book_title_key]: raise ValueError(\\"The book was not borrowed\\") self.books[book_title_key] = False return f\\"{book_title} has been returned.\\" def get_inventory(self): inventory = [] for title, status in self.books.items(): book_title = title.title() book_status = 'borrowed' if status else 'available' inventory.append(f\\"{book_title}: {book_status}\\") return sorted(inventory) def get_borrowed_books(self): borrowed_books = [] for title, status in self.books.items(): if status: book_title = title.title() borrowed_books.append(f\\"{book_title}: borrowed\\") return sorted(borrowed_books)"},{"question":"def asteroidCollision(asteroids: List[int]) -> List[int]: Write a function that determines the state of asteroids after all collisions. You are given an array of integers \`asteroids\` representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). >>> asteroidCollision([5, 10, -5]) [5, 10] >>> asteroidCollision([8, -8]) [] >>> asteroidCollision([10, 2, -5]) [10] >>> asteroidCollision([-2, -1, 1, 2]) [-2, -1, 1, 2] # Your implementation here. def test_asteroidCollision_example_1(): assert asteroidCollision([5, 10, -5]) == [5, 10] def test_asteroidCollision_example_2(): assert asteroidCollision([8, -8]) == [] def test_asteroidCollision_example_3(): assert asteroidCollision([10, 2, -5]) == [10] def test_asteroidCollision_example_4(): assert asteroidCollision([-2, -1, 1, 2]) == [-2, -1, 1, 2] def test_asteroidCollision_large_to_small_collision(): assert asteroidCollision([1, -2]) == [-2] def test_asteroidCollision_no_collisions(): assert asteroidCollision([1, 2, 3]) == [1, 2, 3] def test_asteroidCollision_all_explode(): assert asteroidCollision([5, 10, -10, -5]) == [] def test_asteroidCollision_alternating_collisions(): assert asteroidCollision([5, -5, 6, -6, 7, -7]) == [] def test_asteroidCollision_edge_case_single_asteroid(): assert asteroidCollision([1]) == [1] def test_asteroidCollision_edge_case_single_negative_asteroid(): assert asteroidCollision([-1]) == [-1]","solution":"def asteroidCollision(asteroids): stack = [] for asteroid in asteroids: while stack and asteroid < 0 < stack[-1]: if stack[-1] < -asteroid: stack.pop() continue elif stack[-1] == -asteroid: stack.pop() break else: stack.append(asteroid) return stack"},{"question":"from typing import List, Tuple def can_travel_between_regions(n: int, m: int, roads: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if it's possible to travel from one region to another using one or more roads. Args: n: Number of regions. m: Number of roads. roads: List of tuples representing the roads where each tuple is (u, v) meaning there is a road from region u to region v. queries: List of tuples representing the queries where each tuple is (x, y) meaning you have to check if there is a path from region x to region y. Returns: A list of strings \\"Yes\\" or \\"No\\" for each query indicating if there is a path from x_i to y_i. Examples: >>> can_travel_between_regions(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)], [(1, 5), (3, 1), (1, 4)]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> can_travel_between_regions(4, 3, [(1, 2), (2, 3), (3, 4)], [(1, 4), (4, 1), (2, 3), (3, 1)]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"] >>> can_travel_between_regions(3, 0, [], [(1, 2), (2, 3)]) [\\"No\\", \\"No\\"] >>> can_travel_between_regions(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)], [(1, 3), (2, 1), (4, 6), (6, 5)]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"] >>> can_travel_between_regions(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)], [(1, 4), (4, 1), (2, 4), (3, 1)]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"]","solution":"from collections import defaultdict, deque def can_travel_between_regions(n, m, roads, queries): graph = defaultdict(list) for u, v in roads: graph[u].append(v) def bfs(start, end): queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False results = [] for start, end in queries: if bfs(start, end): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"class InventoryManagement: Simulates a basic inventory management system for a small store. The system should perform the following operations: 1. Add a Product: Add a new product to the inventory. 2. Remove a Product: Remove a product from the inventory. 3. Update Stock: Update the stock quantity of a product. 4. Calculate Total Inventory Value: Calculate the total value of the inventory. >>> inv = InventoryManagement() >>> inv.add_product(\\"p1\\", \\"Apple\\", 2.5) >>> inv.update_stock(\\"p1\\", 100) >>> inv.calculate_total_value() 300.00 def __init__(self): self.inventory = {} def add_product(self, id: str, name: str, price: float): pass def remove_product(self, id: str): pass def update_stock(self, id: str, quantity: int): pass def calculate_total_value(self): pass from solution import InventoryManagement def test_add_product(): inv = InventoryManagement() inv.add_product(\\"p1\\", \\"Apple\\", 2.5) assert inv.inventory[\\"p1\\"] == {\\"name\\": \\"Apple\\", \\"price\\": 2.5, \\"quantity\\": 0} def test_remove_product(): inv = InventoryManagement() inv.add_product(\\"p1\\", \\"Apple\\", 2.5) inv.remove_product(\\"p1\\") assert \\"p1\\" not in inv.inventory def test_update_stock(): inv = InventoryManagement() inv.add_product(\\"p1\\", \\"Apple\\", 2.5) inv.update_stock(\\"p1\\", 100) assert inv.inventory[\\"p1\\"][\\"quantity\\"] == 100 def test_update_stock_nonexistent_product(capsys): inv = InventoryManagement() inv.add_product(\\"p1\\", \\"Apple\\", 2.5) inv.update_stock(\\"p2\\", 100) captured = capsys.readouterr() assert captured.out == \\"Error: Product not foundn\\" def test_calculate_total_value(capsys): inv = InventoryManagement() inv.add_product(\\"p1\\", \\"Apple\\", 2.5) inv.update_stock(\\"p1\\", 100) inv.add_product(\\"p2\\", \\"Banana\\", 1.0) inv.update_stock(\\"p2\\", 50) inv.calculate_total_value() captured = capsys.readouterr() assert captured.out == \\"300.00n\\"","solution":"class InventoryManagement: def __init__(self): self.inventory = {} def add_product(self, id, name, price): self.inventory[id] = {\\"name\\": name, \\"price\\": price, \\"quantity\\": 0} def remove_product(self, id): if id in self.inventory: del self.inventory[id] def update_stock(self, id, quantity): if id in self.inventory: self.inventory[id][\\"quantity\\"] = quantity else: print(\\"Error: Product not found\\") def calculate_total_value(self): total_value = sum(item[\\"price\\"] * item[\\"quantity\\"] for item in self.inventory.values()) print(f\\"{total_value:.2f}\\")"},{"question":"def can_rearrange_without_adjacent_duplicates(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: You are given a sequence of positive integers. Your task is to determine if it is possible to rearrange these integers in such a way that no two adjacent integers are equal. If such an arrangement exists, print \\"YES\\". Otherwise, print \\"NO\\". Args: T : int : The number of test cases. test_cases : List[Tuple[int, List[int]]] : Each test case containing a tuple with an integer N and a list of N integers. Returns: List[str] : A list of strings, either \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_rearrange_without_adjacent_duplicates(2, [(5, [1, 2, 2, 3, 3]), (3, [2, 2, 2])]) [\\"YES\\", \\"NO\\"] >>> can_rearrange_without_adjacent_duplicates(1, [(6, [1, 1, 1, 2, 2, 2])]) [\\"YES\\"] pass from solution import can_rearrange_without_adjacent_duplicates def test_case_1(): T = 2 test_cases = [ (5, [1, 2, 2, 3, 3]), (3, [2, 2, 2]) ] assert can_rearrange_without_adjacent_duplicates(T, test_cases) == [\\"YES\\", \\"NO\\"] def test_case_2(): T = 1 test_cases = [ (6, [1, 1, 1, 2, 2, 2]) ] assert can_rearrange_without_adjacent_duplicates(T, test_cases) == [\\"YES\\"] def test_case_3(): T = 1 test_cases = [ (4, [1, 2, 2, 2]) ] assert can_rearrange_without_adjacent_duplicates(T, test_cases) == [\\"NO\\"] def test_case_4(): T = 3 test_cases = [ (4, [1, 1, 2, 3]), (5, [4, 4, 4, 4, 4]), (7, [1, 2, 3, 1, 2, 3, 1]) ] assert can_rearrange_without_adjacent_duplicates(T, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_case_5(): T = 1 test_cases = [ (1, [7]) ] assert can_rearrange_without_adjacent_duplicates(T, test_cases) == [\\"YES\\"]","solution":"def can_rearrange_without_adjacent_duplicates(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] # Count the occurrences of each element count = {} for num in sequence: if num in count: count[num] += 1 else: count[num] = 1 # Find the maximum occurrence max_occurrence = max(count.values()) if max_occurrence > (N + 1) // 2: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def count_islands(grid): Count the number of islands in the given grid. Args: grid (List[List[str]]): 2D map of '1's (land) and '0's (water) Returns: int: Number of islands Examples: >>> count_islands([['1']]) == 1 >>> count_islands([['0']]) == 0 >>> count_islands([['1', '1'], ['1', '1']]) == 1 >>> count_islands([['0', '0'], ['0', '0']]) == 0 >>> count_islands([ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'] ]) == 3 >>> count_islands([ ['1', '0'], ['1', '0'], ['1', '0'], ['1', '0'] ]) == 1 >>> count_islands([ ['1', '1', '1', '1'] ]) == 1 >>> count_islands([ ['1', '0', '1', '0'], ['0', '0', '0', '0'], ['1', '0', '1', '0'] ]) == 4 >>> count_islands([ ['1', '1', '0', '1', '0'], ['1', '0', '0', '1', '1'], ['0', '0', '1', '0', '0'], ['1', '1', '0', '1', '1'] ]) == 5 pass","solution":"def count_islands(grid): Count the number of islands in the given grid. Args: grid (List[List[str]]): 2D map of '1's (land) and '0's (water) Returns: int: Number of islands if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def bfs(r, c): queue = [(r, c)] while queue: x, y = queue.pop(0) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == '1': queue.append((nx, ny)) visited[nx][ny] = True island_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == '1' and not visited[i][j]: bfs(i, j) island_count += 1 return island_count"},{"question":"def max_seats_close_together(n, k, seats): # Find the maximum number of seats on contiguous benches pass def can_place_friends(seats, n, k, min_dist): # Helper function to check if friends can be placed with a given minimum distance pass def max_distance_spread_out(n, k, seats): # Find the maximum minimum distance between chosen benches pass def friends_on_benches(t, test_cases): Determine the seating arrangement for friends on benches. Args: - t (int): The number of test cases - test_cases (List[Tuple[int, int, List[int], int]]): List of test cases Each test case contains: - n (int): Number of benches - k (int): Number of friends - seats (List[int]): Number of seats on each bench - p (int): Preference (0 for close together, 1 for spread out) Returns: - List[int]: Result for each test case >>> friends_on_benches(2, [(7, 3, [4, 5, 3, 2, 8, 6, 7], 0), (6, 2, [10, 20, 30, 40, 50, 60], 1)]) [21, 50] pass from solution import friends_on_benches def test_separate_friends(): test_cases = [ (7, 3, [4, 5, 3, 2, 8, 6, 7], 0), (6, 2, [10, 20, 30, 40, 50, 60], 1) ] assert friends_on_benches(2, test_cases) == [21, 50] def test_close_together_basic(): test_cases = [ (3, 2, [1, 2, 3], 0) ] assert friends_on_benches(1, test_cases) == [5] def test_spread_out_basic(): test_cases = [ (5, 3, [1, 2, 8, 4, 9], 1) ] assert friends_on_benches(1, test_cases) == [3] def test_edge_case_min_benches(): test_cases = [ (1, 1, [5], 0), (1, 1, [5], 1) ] assert friends_on_benches(2, test_cases) == [5, 0] def test_edge_most_seats(): test_cases = [ (4, 2, [20, 19, 18, 17], 0), (4, 2, [20, 19, 18, 17], 1) ] assert friends_on_benches(2, test_cases) == [39, 3]","solution":"def max_seats_close_together(n, k, seats): max_sum = 0 for i in range(n - k + 1): max_sum = max(max_sum, sum(seats[i:i + k])) return max_sum def can_place_friends(seats, n, k, min_dist): count = 1 last_pos = seats[0] for i in range(1, n): if seats[i] - last_pos >= min_dist: count += 1 last_pos = seats[i] if count == k: return True return False def max_distance_spread_out(n, k, seats): seats.sort() left, right = 1, seats[-1] - seats[0] max_dist = 0 while left <= right: mid = (left + right) // 2 if can_place_friends(seats, n, k, mid): max_dist = mid left = mid + 1 else: right = mid - 1 return max_dist def friends_on_benches(t, test_cases): results = [] for test_case in test_cases: n, k, seats, p = test_case if p == 0: result = max_seats_close_together(n, k, seats) else: result = max_distance_spread_out(n, k, seats) results.append(result) return results"},{"question":"def is_geometric_progression(arr: List[int]) -> Union[Tuple[bool, int], bool]: Determines if the input array forms a geometric progression. Parameters: arr (list): The strictly increasing array of positive integers. Returns: tuple: (True, common ratio) if the array forms a geometric progression, else False. Examples: >>> is_geometric_progression([2, 6, 18, 54]) (True, 3) >>> is_geometric_progression([3, 9, 27, 80]) False >>> is_geometric_progression([5, 25, 125]) (True, 5) from solution import is_geometric_progression def test_geometric_progression_valid(): assert is_geometric_progression([2, 6, 18, 54]) == (True, 3) assert is_geometric_progression([5, 25, 125]) == (True, 5) assert is_geometric_progression([1, 2, 4, 8, 16]) == (True, 2) assert is_geometric_progression([3, 9, 27, 81]) == (True, 3) def test_geometric_progression_invalid(): assert is_geometric_progression([3, 9, 27, 80]) == False assert is_geometric_progression([1, 2, 5, 8]) == False assert is_geometric_progression([10, 20, 40, 85]) == False def test_single_element_array(): assert is_geometric_progression([5]) == False def test_two_element_array(): assert is_geometric_progression([5, 10]) == (True, 2) assert is_geometric_progression([7, 14]) == (True, 2) def test_edge_cases(): assert is_geometric_progression([1, 1]) == (True, 1) # special case where all elements are the same","solution":"def is_geometric_progression(arr): Determines if the input array forms a geometric progression. Parameters: arr (list): The strictly increasing array of positive integers. Returns: tuple: (True, common ratio) if the array forms a geometric progression, else False. if len(arr) < 2: return False ratio = arr[1] / arr[0] for i in range(1, len(arr) - 1): if arr[i + 1] / arr[i] != ratio: return False return True, ratio"},{"question":"def process_queries(n, weights, edges, queries): Processes several queries to determine the maximum weight found on the unique path between two given nodes in a tree. Parameters: - n (int): Number of components in the toy tree. - weights (List[int]): List of weights for each component. - edges (List[Tuple[int, int]]): List of edges connecting the components. - queries (List[str]): List of queries to be processed in the format \\"M x y\\", asking for the maximum weight on the path from x to y. Returns: - List[int]: List of results for each query. >>> n = 5 >>> weights = [10, 30, 50, 70, 90] >>> edges = [(1, 2), (2, 3), (2, 4), (4, 5)] >>> queries = [\\"M 1 3\\", \\"M 1 5\\", \\"M 4 5\\"] >>> process_queries(n, weights, edges, queries) [50, 90, 90] >>> n = 3 >>> weights = [5, 20, 15] >>> edges = [(1, 2), (1, 3)] >>> queries = [\\"M 2 3\\"] >>> process_queries(n, weights, edges, queries) [20] >>> n = 4 >>> weights = [1, 2, 3, 4] >>> edges = [(1, 2), (2, 3), (3, 4)] >>> queries = [\\"M 1 4\\"] >>> process_queries(n, weights, edges, queries) [4] >>> n = 7 >>> weights = [20, 5, 1, 4, 6, 8, 7] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] >>> queries = [\\"M 4 7\\", \\"M 5 6\\", \\"M 1 6\\"] >>> process_queries(n, weights, edges, queries) [20, 20, 20] >>> n = 6 >>> weights = [5, 4, 3, 2, 1, 6] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)] >>> queries = [\\"M 3 6\\", \\"M 1 6\\", \\"M 2 3\\"] >>> process_queries(n, weights, edges, queries) [6, 6, 5]","solution":"from collections import defaultdict, deque def preprocess_lca_and_max_weights(n, weights, edges): # Adjacency list of the tree tree = defaultdict(list) for u, v in edges: tree[u-1].append(v-1) tree[v-1].append(u-1) # Depth and parent info depth = [-1] * n parent = [[-1] * n for _ in range(17)] # Assuming at most log2(35000) ~ 17 levels max_weight = [[-1] * n for _ in range(17)] # To record the maximum weights in 2^i steps # BFS to compute depth and immediate parents q = deque([0]) depth[0] = 0 while q: u = q.popleft() for v in tree[u]: if depth[v] == -1: depth[v] = depth[u] + 1 parent[0][v] = u max_weight[0][v] = weights[u] q.append(v) # Precompute the 2^i parents and max weights for i in range(1, 17): for u in range(n): if parent[i-1][u] != -1: parent[i][u] = parent[i-1][parent[i-1][u]] max_weight[i][u] = max(max_weight[i-1][u], max_weight[i-1][parent[i-1][u]]) return depth, parent, max_weight def find_max_weight(x, y, depth, parent, max_weight, weights): if depth[x] < depth[y]: x, y = y, x result = weights[x] delta = depth[x] - depth[y] # Move x to the same level as y for i in range(17): if (delta >> i) & 1: result = max(result, max_weight[i][x]) x = parent[i][x] if x == y: return result for i in range(16, -1, -1): if parent[i][x] != parent[i][y]: result = max(result, max_weight[i][x], max_weight[i][y]) x = parent[i][x] y = parent[i][y] result = max(result, max_weight[0][x], max_weight[0][y], weights[parent[0][x]]) return result def process_queries(n, weights, edges, queries): depth, parent, max_weight = preprocess_lca_and_max_weights(n, weights, edges) results = [] for query in queries: _, x, y = query.split() x, y = int(x)-1, int(y)-1 max_w = find_max_weight(x, y, depth, parent, max_weight, weights) results.append(max_w) return results"},{"question":"from collections import deque from typing import List def wallsAndGates(rooms: List[List[int]]) -> None: Fill each empty room with the distance to its nearest gate. Args: - rooms: A 2D grid of integers where -1 represents a wall or an obstacle, 0 represents a gate, and INF represents an empty room (2^31 - 1). This function modifies the 'rooms' grid in-place. Example: >>> INF = 2**31 - 1 >>> rooms = [ ... [INF, -1, 0, INF], ... [INF, INF, INF, -1], ... [INF, -1, INF, -1], ... [0, -1, INF, INF] ... ] >>> wallsAndGates(rooms) >>> rooms [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] >>> rooms = [] >>> wallsAndGates(rooms) >>> rooms [] >>> rooms = [ ... [INF, INF], ... [INF, 0] ... ] >>> wallsAndGates(rooms) >>> rooms [ [2, 1], [1, 0] ] >>> rooms = [ ... [INF, INF], ... [INF, INF] ... ] >>> wallsAndGates(rooms) >>> rooms [ [INF, INF], [INF, INF] ] >>> rooms = [ ... [0, -1], ... [-1, 0] ... ] >>> wallsAndGates(rooms) >>> rooms [ [0, -1], [-1, 0] ] >>> rooms = [ ... [-1, -1, -1], ... [-1, 0, -1], ... [-1, -1, -1] ... ] >>> wallsAndGates(rooms) >>> rooms [ [-1, -1, -1], [-1, 0, -1], [-1, -1, -1] ]","solution":"from collections import deque from typing import List def wallsAndGates(rooms: List[List[int]]) -> None: INF = 2**31 - 1 if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all gates' positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions for the neighbors: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy # If the new position is within bounds and is an empty room if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"from typing import List, Tuple class CowFarm: def __init__(self, production_rates: List[int]): self.production_rates = production_rates self.prefix_sums = self._build_prefix_sums() def _build_prefix_sums(self) -> List[int]: pass def update(self, i: int, x: int) -> None: pass def query(self, l: int, r: int) -> int: pass def process_operations(M: int, Q: int, production_rates: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process a list of operations to update or query cow milk production. Args: M: The number of cows. Q: The number of operations. production_rates: A list of initial milk production rates for each cow. operations: A list of operations to be performed. Returns: A list of results for each query operation. >>> M = 5 >>> Q = 4 >>> production_rates = [2, 1, 3, 4, 5] >>> operations = [(2, 2, 4), (1, 3, 10), (2, 3, 5), (2, 1, 5)] >>> process_operations(M, Q, production_rates, operations) [8, 19, 22] >>> M = 3 >>> Q = 3 >>> production_rates = [10, 20, 30] >>> operations = [(2, 1, 2), (1, 2, 15), (2, 1, 3)] >>> process_operations(M, Q, production_rates, operations) [30, 55] pass import pytest def test_example_case_1(): M = 5 Q = 4 production_rates = [2, 1, 3, 4, 5] operations = [ [2, 2, 4], [1, 3, 10], [2, 3, 5], [2, 1, 5], ] assert process_operations(M, Q, production_rates, operations) == [8, 19, 22] def test_example_case_2(): M = 3 Q = 3 production_rates = [10, 20, 30] operations = [ [2, 1, 2], [1, 2, 15], [2, 1, 3], ] assert process_operations(M, Q, production_rates, operations) == [30, 55] def test_update_operation(): M = 4 Q = 2 production_rates = [5, 10, 20, 30] operations = [ [1, 2, 15], [2, 1, 4], ] assert process_operations(M, Q, production_rates, operations) == [70] def test_no_operations(): M = 3 Q = 0 production_rates = [3, 6, 9] operations = [] assert process_operations(M, Q, production_rates, operations) == [] def test_multiple_updates(): M = 3 Q = 4 production_rates = [1, 1, 1] operations = [ [1, 1, 10], [1, 2, 20], [1, 3, 30], [2, 1, 3], ] assert process_operations(M, Q, production_rates, operations) == [60]","solution":"class CowFarm: def __init__(self, production_rates): self.production_rates = production_rates self.prefix_sums = self._build_prefix_sums() def _build_prefix_sums(self): prefix_sums = [0] * (len(self.production_rates) + 1) for i in range(1, len(prefix_sums)): prefix_sums[i] = prefix_sums[i-1] + self.production_rates[i-1] return prefix_sums def update(self, i, x): difference = x - self.production_rates[i-1] self.production_rates[i-1] = x for j in range(i, len(self.prefix_sums)): self.prefix_sums[j] += difference def query(self, l, r): return self.prefix_sums[r] - self.prefix_sums[l-1] def process_operations(M, Q, production_rates, operations): farm = CowFarm(production_rates) results = [] for op in operations: if op[0] == 1: farm.update(op[1], op[2]) elif op[0] == 2: results.append(farm.query(op[1], op[2])) return results"},{"question":"def reverseValidArray(arr): Returns a new array where each integer is reversed. If the input is not an array, the function should return 'Invalid input'. If the array contains elements that are not integers, the function should return 'Invalid element'. If the array is empty, it should return an empty array. Examples: >>> reverseValidArray([123, 456]) [321, 654] >>> reverseValidArray([12, -34]) [21, -43] >>> reverseValidArray(['a', 123]) 'Invalid element' >>> reverseValidArray(123) 'Invalid input' >>> reverseValidArray([]) [] from solution import reverseValidArray def test_reverseValidArray_valid_input_positive_numbers(): result = reverseValidArray([123, 456]) assert result == [321, 654] def test_reverseValidArray_valid_input_negative_numbers(): result = reverseValidArray([12, -34]) assert result == [21, -43] def test_reverseValidArray_valid_empty_input(): result = reverseValidArray([]) assert result == [] def test_reverseValidArray_invalid_element(): result = reverseValidArray(['a', 123]) assert result == 'Invalid element' def test_reverseValidArray_invalid_input_non_list(): result = reverseValidArray(123) assert result == 'Invalid input' def test_reverseValidArray_invalid_input_mixed_elements(): result = reverseValidArray([123, 456, 'xyz']) assert result == 'Invalid element' def test_reverseValidArray_single_element(): result = reverseValidArray([123]) assert result == [321] def test_reverseValidArray_all_negative_numbers(): result = reverseValidArray([-1, -22, -333]) assert result == [-1, -22, -333] def test_reverseValidArray_zeros(): result = reverseValidArray([0, -0]) assert result == [0, 0]","solution":"def reverseValidArray(arr): Returns a new array where each integer is reversed. if not isinstance(arr, list): return 'Invalid input' reversed_array = [] for element in arr: if not isinstance(element, int): return 'Invalid element' reversed_element = int(str(element)[::-1]) if element >= 0 else -int(str(-element)[::-1]) reversed_array.append(reversed_element) return reversed_array"},{"question":"def process_stack_operations(operations: str) -> list: Processes a sequence of stack operations and returns the remaining elements in the stack after performing all operations. If a pop operation is attempted on an empty stack, the sequence is invalid and the function returns an empty list. Parameters: operations (str): A string representing a sequence of \\"push x\\" and \\"pop\\" operations. Returns: list: The remaining elements in the stack or an empty list if the sequence is invalid. Example: >>> process_stack_operations(\\"push 1 push 2 pop push 3 pop push 4 push 5 pop\\") [1, 4] >>> process_stack_operations(\\"push 1 push 2 pop pop pop\\") [] >>> process_stack_operations(\\"push 1 push 2 push 3 pop push 4 push 5 pop pop\\") [1, 2] Unit Test: from process_stack_operations import process_stack_operations def test_valid_operations(): assert process_stack_operations(\\"push 1 push 2 pop push 3 pop push 4 push 5 pop\\") == [1, 4] assert process_stack_operations(\\"push 1 push 2 pop pop pop\\") == [] assert process_stack_operations(\\"push 1 push 2 push 3 pop push 4 push 5 pop pop\\") == [1, 2] def test_invalid_pop_on_empty_stack(): assert process_stack_operations(\\"pop\\") == [] assert process_stack_operations(\\"push 1 pop pop\\") == [] assert process_stack_operations(\\"push 3 pop pop push 5\\") == [] def test_no_operations(): assert process_stack_operations(\\"\\") == [] def test_single_push(): assert process_stack_operations(\\"push 7\\") == [7] def test_multiple_push_and_pop(): assert process_stack_operations(\\"push 1 push 2 push 3 pop pop push 4 push 5 pop pop\\") == [1] assert process_stack_operations(\\"push 1 push 2 push 3 push 4 pop pop pop pop\\") == [] assert process_stack_operations(\\"push 1 push 2 push 3 pop pop pop push 4 push 5 pop\\") == [4] def test_push_with_large_numbers(): assert process_stack_operations(\\"push 1000000000 push 999999999 pop\\") == [1000000000]","solution":"def process_stack_operations(operations): Processes a sequence of stack operations and returns the remaining elements in the stack after performing all operations. If a pop operation is attempted on an empty stack, the sequence is invalid and the function returns an empty list. Parameters: operations (str): A string representing a sequence of \\"push x\\" and \\"pop\\" operations. Returns: list: The remaining elements in the stack or an empty list if the sequence is invalid. stack = [] ops = operations.split() i = 0 while i < len(ops): if ops[i] == \\"push\\": i += 1 stack.append(int(ops[i])) elif ops[i] == \\"pop\\": if not stack: return [] stack.pop() i += 1 return stack"},{"question":"def can_place_fountain(testcases: List[Tuple[int, int, int, int]]) -> List[str]: Determine if a square fountain can be placed in the center of a rectangular park while adhering to the safety distance regulations. Args: testcases (List[Tuple[int, int, int, int]]): A list of tuples where each tuple contains four integers l, b, s, d representing the dimensions of the park and the side and required distance of the fountain. Returns: List[str]: List of strings \\"YES\\" or \\"NO\\" for each testcase indicating if the fountain can be placed or not. >>> can_place_fountain([(6, 8, 2, 1), (6, 8, 4, 1), (6, 8, 6, 3)]) [\\"YES\\", \\"YES\\", \\"NO\\"] from solution import can_place_fountain def test_case_1(): testcases = [(6, 8, 2, 1)] assert can_place_fountain(testcases) == [\\"YES\\"] def test_case_2(): testcases = [(6, 8, 4, 1)] assert can_place_fountain(testcases) == [\\"YES\\"] def test_case_3(): testcases = [(6, 8, 6, 3)] assert can_place_fountain(testcases) == [\\"NO\\"] def test_multiple_cases(): testcases = [(6, 8, 2, 1), (6, 8, 4, 1), (6, 8, 6, 3)] assert can_place_fountain(testcases) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_case_no_fit(): testcases = [(10, 10, 10, 1)] assert can_place_fountain(testcases) == [\\"NO\\"] def test_case_just_fits(): testcases = [(10, 10, 8, 1)] assert can_place_fountain(testcases) == [\\"YES\\"]","solution":"def can_place_fountain(testcases): results = [] for l, b, s, d in testcases: if (s + 2 * d <= l) and (s + 2 * d <= b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_point_inside_garden(x, y, gardens): Checks if a point (x, y) is inside any of the given gardens. Each garden is represented as a tuple (x1, y1, x2, y2). Returns 'Inside' if the point is inside any garden, otherwise 'Outside'. pass def check_points_in_gardens(W, H, gardens, points): Takes the width and height of the palace, list of gardens, and list of points. Returns a list of results for each point, stating 'Inside' or 'Outside'. pass # Sample input to test the function W = 10 H = 10 gardens = [(1, 1, 4, 5), (5, 5, 8, 8)] points = [(2, 2), (6, 6), (0, 0)] results = check_points_in_gardens(W, H, gardens, points) print(results) # Expected Output: ['Inside', 'Inside', 'Outside'] def test_is_point_inside_garden(): gardens = [(1, 1, 4, 5), (5, 5, 8, 8)] assert is_point_inside_garden(2, 2, gardens) == \\"Inside\\" assert is_point_inside_garden(6, 6, gardens) == \\"Inside\\" assert is_point_inside_garden(0, 0, gardens) == \\"Outside\\" assert is_point_inside_garden(4, 5, gardens) == \\"Inside\\" assert is_point_inside_garden(8, 8, gardens) == \\"Inside\\" assert is_point_inside_garden(9, 9, gardens) == \\"Outside\\" def test_check_points_in_gardens(): W = 10 H = 10 gardens = [(1, 1, 4, 5), (5, 5, 8, 8)] points = [(2, 2), (6, 6), (0, 0)] assert check_points_in_gardens(W, H, gardens, points) == [\\"Inside\\", \\"Inside\\", \\"Outside\\"] points = [(3, 4), (7, 7), (1, 1), (8, 8), (9, 9)] assert check_points_in_gardens(W, H, gardens, points) == [\\"Inside\\", \\"Inside\\", \\"Inside\\", \\"Inside\\", \\"Outside\\"] def test_check_edge_cases(): W = 10 H = 10 gardens = [(1, 1, 4, 5), (5, 5, 8, 8)] points = [(4, 5), (5, 5), (8, 8), (1, 1)] assert check_points_in_gardens(W, H, gardens, points) == [\\"Inside\\", \\"Inside\\", \\"Inside\\", \\"Inside\\"] points = [(0, 0), (10, 10), (4, 6), (9, 9)] assert check_points_in_gardens(W, H, gardens, points) == [\\"Outside\\", \\"Outside\\", \\"Outside\\", \\"Outside\\"]","solution":"def is_point_inside_garden(x, y, gardens): Checks if a point (x, y) is inside any of the given gardens. Each garden is represented as a tuple (x1, y1, x2, y2). Returns 'Inside' if the point is inside any garden, otherwise 'Outside'. for (x1, y1, x2, y2) in gardens: if x1 <= x <= x2 and y1 <= y <= y2: return \\"Inside\\" return \\"Outside\\" def check_points_in_gardens(W, H, gardens, points): Takes the width and height of the palace, list of gardens, and list of points. Returns a list of results for each point, stating 'Inside' or 'Outside'. results = [] for (x, y) in points: results.append(is_point_inside_garden(x, y, gardens)) return results # Sample input to test the function W = 10 H = 10 gardens = [(1, 1, 4, 5), (5, 5, 8, 8)] points = [(2, 2), (6, 6), (0, 0)] results = check_points_in_gardens(W, H, gardens, points) print(results) # Expected Output: ['Inside', 'Inside', 'Outside']"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> None: Rotates an NxN 2D matrix 90 degrees clockwise in-place. from typing import List def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_5x5_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(matrix) assert matrix == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates an NxN 2D matrix 90 degrees clockwise in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"import numpy as np def split_array(R, C, K, array_content): Splits the given array of size R x C into K equal parts along axis 0. :param R: Number of rows in the array :param C: Number of columns in the array :param K: Number of parts to split the array into :param array_content: List of lists representing the array :return: List of arrays, each of size (R // K) x C # Example usage R, C, K = 6, 6, 3 array_content = [ [1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36] ] result = split_array(R, C, K, array_content) for arr in result: print(arr) # Test cases def test_split_array(): R, C, K = 6, 6, 3 array_content = [ [1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36] ] expected_result = [ [ [1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12] ], [ [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24] ], [ [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36] ], ] result = split_array(R, C, K, array_content) for i in range(K): assert (result[i] == expected_result[i]).all() def test_split_array_different_input(): R, C, K = 4, 4, 2 array_content = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_result = [ [ [1, 2, 3, 4], [5, 6, 7, 8] ], [ [9, 10, 11, 12], [13, 14, 15, 16] ], ] result = split_array(R, C, K, array_content) for i in range(K): assert (result[i] == expected_result[i]).all()","solution":"import numpy as np def split_array(R, C, K, array_content): Splits the given array of size R x C into K equal parts along axis 0. :param R: Number of rows in the array :param C: Number of columns in the array :param K: Number of parts to split the array into :param array_content: List of lists representing the array :return: List of arrays, each of size (R // K) x C array = np.array(array_content) split_arrays = np.split(array, K, axis=0) return split_arrays # Example usage R, C, K = 6, 6, 3 array_content = [ [1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36] ] result = split_array(R, C, K, array_content) for arr in result: print(arr)"},{"question":"def find_subarrays_with_same_sum(arr, k): This function checks if there exist two non-overlapping subarrays of length exactly K with the same sum. pass def process_test_cases(T, test_cases): This function processes multiple test cases and uses find_subarrays_with_same_sum to determine the result. pass # Example usage and test cases: if __name__ == \\"__main__\\": import pytest def test_find_subarrays_with_same_sum_positive(): assert find_subarrays_with_same_sum([1, 2, 3, 4, 1, 2, 3], 3) == \\"YES\\" assert find_subarrays_with_same_sum([1, 1, 1, 1, 1, 1], 2) == \\"YES\\" def test_find_subarrays_with_same_sum_negative(): assert find_subarrays_with_same_sum([1, 2, 3, 4, 5], 2) == \\"NO\\" assert find_subarrays_with_same_sum([1, 2, 3, 4, 5, 6], 3) == \\"NO\\" def test_find_subarrays_with_same_sum_edge_cases(): assert find_subarrays_with_same_sum([1, 1, 1], 1) == \\"YES\\" assert find_subarrays_with_same_sum([-1, -2, -3, -4, -1, -2, -3], 3) == \\"YES\\" assert find_subarrays_with_same_sum([0, 0, 0, 0], 2) == \\"YES\\" def test_process_test_cases(): test_cases = [ [(7, 3), [1, 2, 3, 4, 1, 2, 3]], [(5, 2), [1, 2, 3, 4, 5]] ] assert process_test_cases(2, test_cases) == [\\"YES\\", \\"NO\\"] test_cases = [ [(3, 1), [1, 1, 1]], [(6, 2), [1, 2, 3, 1, 2, 3]] ] assert process_test_cases(2, test_cases) == [\\"YES\\", \\"YES\\"] pytest.main()","solution":"def find_subarrays_with_same_sum(arr, k): This function checks if there exist two non-overlapping subarrays of length exactly K with the same sum. sums_map = {} n = len(arr) # Compute the sum of the first 'k' elements current_sum = sum(arr[:k]) sums_map[current_sum] = [0] # Compute sums for subarrays of length 'k', starting from index 1 to n-k+1 for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum in sums_map: # Check if any stored index range [+K] does not overlap with the current range for start_index in sums_map[current_sum]: if abs(start_index - i) >= k: return \\"YES\\" sums_map[current_sum].append(i) else: sums_map[current_sum] = [i] return \\"NO\\" def process_test_cases(T, test_cases): results = [] for case in test_cases: N, K = case[0] arr = case[1] result = find_subarrays_with_same_sum(arr, K) results.append(result) return results"},{"question":"from typing import List, Tuple def count_pairs_with_product(arr: List[int], target: int) -> int: Determines the number of pairs (i, j) where 0 ≤ i < j < n and the product of the elements at positions i and j is equal to the given target value. >>> count_pairs_with_product([1, 3, 4, 2], 12) 1 >>> count_pairs_with_product([5, 4, 2, 1, 10], 20) 2 pass def solve(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Solves multiple test cases and returns results for each test case. >>> solve([(4, 12, [1, 3, 4, 2]), (5, 20, [5 4, 2, 1, 10])]) [1, 2] pass def parse_input(input_data: str) -> List[Tuple[int, int, List[int]]]: Parses the input data to extract the number of test cases and the details for each test case. >>> parse_input(\\"2n4 12n1 3 4 2n5 20n5 4 2 1 10\\") [(4, 12, [1, 3, 4, 2]), (5, 20, [5 4, 2, 1, 10])] pass def main(input_data: str) -> str: Handles the main execution of parsing input, solving the problem and formatting the output. >>> main(\\"2n4 12n1 3 4 2n5 20n5 4 2 1 10\\") \\"1n2\\" pass def test_count_pairs_with_product(): assert count_pairs_with_product([1, 3, 4, 2], 12) == 1 assert count_pairs_with_product([5, 4, 2, 1, 10], 20) == 2 def test_parse_input(): input_data = \\"2n4 12n1 3 4 2n5 20n5 4 2 1 10\\" expected_output = [(4, 12, [1, 3, 4, 2]), (5, 20, [5, 4, 2, 1, 10])] assert parse_input(input_data) == expected_output def test_solve(): test_cases = [(4, 12, [1, 3, 4, 2]), (5, 20, [5, 4, 2, 1, 10])] assert solve(test_cases) == [1, 2] def test_main(): input_data = \\"2n4 12n1 3 4 2n5 20n5 4 2 1 10\\" expected_output = \\"1n2\\" assert main(input_data) == expected_output","solution":"def count_pairs_with_product(arr, target): n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): if arr[i] * arr[j] == target: count += 1 return count def solve(test_cases): results = [] for n, target, arr in test_cases: results.append(count_pairs_with_product(arr, target)) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n, target = map(int, lines[index].split()) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, target, arr)) index += 2 return test_cases def main(input_data): test_cases = parse_input(input_data) result = solve(test_cases) return 'n'.join(map(str, result))"},{"question":"def rank_students(scores): Returns a ranking of students based on their average score. If two students have the same average score, they will be ranked alphabetically by their name. Args: scores (dict): The key is a string representing the student's name and the value is a list of integers representing the student's scores in different exams. Returns: List[Tuple[str, float]]: A list of tuples where each tuple contains a student's name and their average score, with the students sorted in descending order of their average score. If two students have the same average score, they should be sorted alphabetically by their name. >>> rank_students({ 'Alice': [90, 85, 88], 'Bob': [82, 85, 84], 'Charlie': [90, 85, 85] }) [('Alice', 87.67), ('Charlie', 86.67), ('Bob', 83.67)] >>> rank_students({ 'Dave': [80, 85, 90], 'Eve': [85, 90, 80], 'Frank': [75, 85, 95] }) [('Dave', 85.0), ('Eve', 85.0), ('Frank', 85.0)] from solution import rank_students def test_rank_students_typical_case(): scores = { 'Alice': [90, 85, 88], 'Bob': [82, 85, 84], 'Charlie': [90, 85, 85] } assert rank_students(scores) == [ ('Alice', 87.67), ('Charlie', 86.67), ('Bob', 83.67) ] def test_rank_students_tied_scores(): scores = { 'Dave': [80, 85, 90], 'Eve': [85, 90, 80], 'Frank': [75, 85, 95] } assert rank_students(scores) == [ ('Dave', 85.0), ('Eve', 85.0), ('Frank', 85.0) ] def test_rank_students_varied_scores(): scores = { 'George': [60, 70, 80], 'Helen': [90, 95, 85], 'Ian': [100, 90, 95] } assert rank_students(scores) == [ ('Ian', 95.0), ('Helen', 90.0), ('George', 70.0) ] def test_rank_students_single_student(): scores = { 'John': [70, 80, 90] } assert rank_students(scores) == [ ('John', 80.0) ] def test_rank_students_empty_scores(): scores = {} assert rank_students(scores) == [] def test_rank_students_single_exam(): scores = { 'Kate': [85], 'Laura': [95], 'Mona': [75] } assert rank_students(scores) == [ ('Laura', 95.0), ('Kate', 85.0), ('Mona', 75.0) ] def test_rank_students_multiple_tied_scores(): scores = { 'Nancy': [80, 80, 80], 'Oliver': [85, 85], 'Pete': [80, 80, 80], 'Quinn': [85, 85] } assert rank_students(scores) == [ ('Oliver', 85.0), ('Quinn', 85.0), ('Nancy', 80.0), ('Pete', 80.0) ]","solution":"def rank_students(scores): Returns a ranking of students based on their average score. If two students have the same average score, they will be ranked alphabetically by their name. # Calculate average scores and format to 2 decimal places average_scores = [(name, round(sum(marks) / len(marks), 2)) for name, marks in scores.items()] # Sort by average score in descending order, then by name alphabetically sorted_students = sorted(average_scores, key=lambda x: (-x[1], x[0])) return sorted_students"},{"question":"from typing import List class Hotel: A class to manage hotel reservations. Methods: check_in(guest_name: str, room_number: int) -> bool Attempts to check in the guest to the specified room. Returns \`False\` if the room is already occupied, and \`True\` otherwise. check_out(guest_name: str) -> bool Attempts to check out the guest from their room. Returns \`False\` if the guest is not found, and \`True\` otherwise. get_guest_room(guest_name: str) -> int Returns the room number occupied by the guest. Returns \`-1\` if the guest is not found. get_room_guest(room_number: int) -> str Returns the name of the guest occupying the room. Returns an empty string if the room is not occupied. get_all_guests() -> List[str] Returns a list of names of all currently checked-in guests in alphabetical order. get_all_rooms() -> List[int] Returns a list of room numbers that are currently occupied in numerical order. def __init__(self): ... def check_in(self, guest_name: str, room_number: int) -> bool: ... def check_out(self, guest_name: str) -> bool: ... def get_guest_room(self, guest_name: str) -> int: ... def get_room_guest(self, room_number: int) -> str: ... def get_all_guests(self) -> List[str]: ... def get_all_rooms(self) -> List[int]: ... # Example hotel = Hotel() hotel.check_in(\\"Alice\\", 101) # True hotel.check_in(\\"Bob\\", 102) # True hotel.check_in(\\"Alice\\", 101) # False (room already occupied) hotel.get_guest_room(\\"Alice\\") # 101 hotel.get_guest_room(\\"Charlie\\")# -1 (guest not found) hotel.get_room_guest(101) # \\"Alice\\" hotel.get_room_guest(103) # \\"\\" (room not occupied) hotel.check_out(\\"Bob\\") # True hotel.check_out(\\"Bob\\") # False (guest not found) hotel.get_all_guests() # ['Alice'] hotel.get_all_rooms() # [101] Unit Tests: def test_check_in(): hotel = Hotel() assert hotel.check_in(\\"Alice\\", 101) == True assert hotel.check_in(\\"Bob\\", 102) == True assert hotel.check_in(\\"Alice\\", 101) == False # Room 101 is already occupied def test_check_out(): hotel = Hotel() hotel.check_in(\\"Alice\\", 101) hotel.check_in(\\"Bob\\", 102) assert hotel.check_out(\\"Bob\\") == True assert hotel.check_out(\\"Bob\\") == False # Bob already checked out def test_get_guest_room(): hotel = Hotel() hotel.check_in(\\"Alice\\", 101) hotel.check_in(\\"Bob\\", 102) assert hotel.get_guest_room(\\"Alice\\") == 101 assert hotel.get_guest_room(\\"Charlie\\") == -1 def test_get_room_guest(): hotel = Hotel() hotel.check_in(\\"Alice\\", 101) hotel.check_in(\\"Bob\\", 102) assert hotel.get_room_guest(101) == \\"Alice\\" assert hotel.get_room_guest(103) == \\"\\" # Room 103 is not occupied def test_get_all_guests(): hotel = Hotel() hotel.check_in(\\"Alice\\", 101) hotel.check_in(\\"Bob\\", 102) hotel.check_in(\\"Charlie\\", 103) assert hotel.get_all_guests() == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_get_all_rooms(): hotel = Hotel() hotel.check_in(\\"Alice\\", 101) hotel.check_in(\\"Bob\\", 102) hotel.check_in(\\"Charlie\\", 103) assert hotel.get_all_rooms() == [101, 102, 103]","solution":"class Hotel: def __init__(self): # Dictionary to map room numbers to guest names self.rooms = {} # Dictionary to map guest names to room numbers self.guests = {} def check_in(self, guest_name: str, room_number: int) -> bool: if room_number in self.rooms: return False # Room is already occupied self.rooms[room_number] = guest_name self.guests[guest_name] = room_number return True def check_out(self, guest_name: str) -> bool: if guest_name not in self.guests: return False # Guest not found room_number = self.guests.pop(guest_name) del self.rooms[room_number] return True def get_guest_room(self, guest_name: str) -> int: return self.guests.get(guest_name, -1) def get_room_guest(self, room_number: int) -> str: return self.rooms.get(room_number, \\"\\") def get_all_guests(self) -> list: return sorted(self.guests.keys()) def get_all_rooms(self) -> list: return sorted(self.rooms.keys())"},{"question":"from typing import List def walls_and_gates(grid: List[List[int]]) -> None: Modifies the grid in-place to fill each empty room with the distance to its nearest gate. >>> INF = 2147483647 >>> grid = [ ... [INF, -1, 0, INF], ... [INF, INF, INF, -1], ... [INF, -1, INF, -1], ... [ 0, -1, INF, INF] ... ] >>> walls_and_gates(grid) >>> print(grid) [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] >>> grid = [] >>> walls_and_gates(grid) >>> print(grid) [] >>> grid = [ ... [INF, -1, INF], ... [INF, INF, INF], ... [INF, -1, INF] ... ] >>> walls_and_gates(grid) >>> print(grid) [ [INF, -1, INF], [INF, INF, INF], [INF, -1, INF] ] >>> grid = [ ... [-1, -1, -1], ... [-1, -1, -1], ... [-1, -1, -1] ... ] >>> walls_and_gates(grid) >>> print(grid) [ [-1, -1, -1], [-1, -1, -1], [-1, -1, -1] ] >>> grid = [ ... [INF] ... ] >>> walls_and_gates(grid) >>> print(grid) [ [INF] ] >>> grid = [ ... [0] ... ] >>> walls_and_gates(grid) >>> print(grid) [ [0] ]","solution":"from collections import deque from typing import List def walls_and_gates(grid: List[List[int]]) -> None: Modifies the grid in-place to fill each empty room with the distance to its nearest gate. if not grid: return m, n = len(grid), len(grid[0]) INF = 2147483647 # Directions for moving up, down, left, right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() # Initialize the queue with all gates for row in range(m): for col in range(n): if grid[row][col] == 0: queue.append((row, col)) while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == INF: grid[nr][nc] = grid[r][c] + 1 queue.append((nr, nc))"},{"question":"def shortest_subarray_with_sum_at_least(arr: List[int], n: int) -> int: Finds the length of the shortest contiguous subarray of arr whose sum is at least n. If no such subarray exists, return 0. >>> shortest_subarray_with_sum_at_least([2, 1, 5, 2, 3, 2], 7) 2 >>> shortest_subarray_with_sum_at_least([2, 1, 5, 2, 8], 7) 1 >>> shortest_subarray_with_sum_at_least([3, 4, 1, 1, 6], 8) 3 >>> shortest_subarray_with_sum_at_least([2, 1, 2], 7) 0 from typing import List def test_shortest_subarray_with_sum_at_least_case1(): assert shortest_subarray_with_sum_at_least([2, 1, 5, 2, 3, 2], 7) == 2 def test_shortest_subarray_with_sum_at_least_case2(): assert shortest_subarray_with_sum_at_least([2, 1, 5, 2, 8], 7) == 1 def test_shortest_subarray_with_sum_at_least_case3(): assert shortest_subarray_with_sum_at_least([3, 4, 1, 1, 6], 8) == 3 def test_shortest_subarray_with_sum_at_least_case4(): assert shortest_subarray_with_sum_at_least([2, 1, 2], 7) == 0 def test_shortest_subarray_with_sum_at_least_empty_array(): assert shortest_subarray_with_sum_at_least([], 1) == 0 def test_shortest_subarray_with_sum_at_least_single_element_exact_match(): assert shortest_subarray_with_sum_at_least([8], 8) == 1 def test_shortest_subarray_with_sum_at_least_single_element_no_match(): assert shortest_subarray_with_sum_at_least([5], 8) == 0 def test_shortest_subarray_with_sum_at_least_large_numbers(): assert shortest_subarray_with_sum_at_least([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 2 # [7, 8] or [8, 7] def test_shortest_subarray_with_sum_at_least_multiple_possible_subarrays(): assert shortest_subarray_with_sum_at_least([1, 1, 1, 1, 1, 1, 1, 1, 4, 5, 6], 11) == 2 # [6, 5]","solution":"def shortest_subarray_with_sum_at_least(arr, n): Finds the length of the shortest contiguous subarray of arr whose sum is at least n. If no such subarray exists, return 0. from collections import deque total, left = 0, 0 min_len = float('inf') # Initialize to a value larger than any possible subarray length for right in range(len(arr)): total += arr[right] while total >= n: min_len = min(min_len, right-left+1) total -= arr[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"from typing import List def find_user_intervals(logs: List[List[str]]) -> List[List]: You are given an array logs, where each element represents a log entry in format [userId, timestamp, activity]. The logs are not necessarily in any order. The activity could be either \\"enter\\" or \\"exit\\" which indicates that the user has entered or exited a room respectively. Return a list of lists where each inner list represents the time intervals during which each user was in the room. Each interval should be represented as [start_time, end_time]. The intervals should be sorted by start_time. If a user does not have a matching \\"exit\\" or \\"enter\\" activity, ignore it. >>> logs = [[\\"user1\\",\\"10:00\\",\\"enter\\"], [\\"user2\\",\\"10:30\\",\\"enter\\"], [\\"user1\\",\\"10:40\\",\\"exit\\"], [\\"user2\\",\\"11:00\\",\\"exit\\"], [\\"user1\\",\\"11:20\\",\\"enter\\"], [\\"user1\\",\\"12:00\\",\\"exit\\"]] >>> find_user_intervals(logs) [['user1', ['10:00', '10:40'], ['11:20', '12:00']], ['user2', ['10:30', '11:00']]] >>> logs = [[\\"user1\\",\\"09:00\\",\\"enter\\"], [\\"user1\\",\\"09:05\\",\\"exit\\"], [\\"user2\\",\\"09:10\\",\\"enter\\"], [\\"user2\\",\\"09:15\\",\\"exit\\"], [\\"user1\\",\\"09:20\\",\\"enter\\"], [\\"user1\\",\\"09:25\\",\\"exit\\"], [\\"user2\\",\\"09:30\\",\\"enter\\"], [\\"user2\\",\\"10:00\\",\\"exit\\"]] >>> find_user_intervals(logs) [['user1', ['09:00', '09:05'], ['09:20', '09:25']], ['user2', ['09:10', '09:15'], ['09:30', '10:00']]] >>> logs = [[\\"user1\\",\\"08:00\\",\\"enter\\"], [\\"user1\\",\\"08:35\\",\\"exit\\"], [\\"user1\\",\\"09:00\\",\\"enter\\"], [\\"user1\\",\\"09:05\\",\\"enter\\"], [\\"user1\\",\\"09:10\\",\\"exit\\"], [\\"user1\\",\\"10:00\\",\\"exit\\"]] >>> find_user_intervals(logs) [['user1', ['08:00', '08:35'], ['09:00', '09:10']]]","solution":"def find_user_intervals(logs): from collections import defaultdict # Dictionary to hold the result result = defaultdict(list) # Dictionary to hold the last enter time for each user enter_times = {} # Iterate through logs for log in logs: user_id, timestamp, activity = log if activity == \\"enter\\": if user_id in enter_times: # If there's already an active entry, skip this \\"enter\\" continue else: enter_times[user_id] = timestamp elif activity == \\"exit\\": if user_id in enter_times: # If there's no corresponding \\"enter\\", skip this \\"exit\\" result[user_id].append([enter_times[user_id], timestamp]) del enter_times[user_id] # Convert the dictionary to the required list format return [[user] + intervals for user, intervals in sorted(result.items(), key=lambda x: x[0])]"},{"question":"from collections import deque, defaultdict def min_time_to_complete_challenges(n, challenges): Determine the minimum time required to complete all challenges. Args: n : int : number of challenges challenges : List[Tuple[int, int, List[int]]] : list of challenges where each tuple contains - duration of the challenge - number of prerequisites - list of prerequisites (0-based index) Returns: int : minimum time required to complete all challenges Examples: >>> min_time_to_complete_challenges(4, [(3, 0), (2, 1, 1), (5, 1, 1), (4, 2, 2, 3)]) 12 >>> min_time_to_complete_challenges(1, [(5, 0)]) 5 # Test Cases def test_example_case(): challenges = [(3, 0), (2, 1, 1), (5, 1, 1), (4, 2, 2, 3)] assert min_time_to_complete_challenges(4, challenges) == 12 def test_no_prerequisites(): challenges = [(3, 0), (2, 0), (5, 0), (4, 0)] assert min_time_to_complete_challenges(4, challenges) == 5 def test_single_challenge(): challenges = [(5, 0)] assert min_time_to_complete_challenges(1, challenges) == 5 def test_chain_dependencies(): challenges = [(3, 0), (2, 1, 1), (4, 1, 2)] assert min_time_to_complete_challenges(3, challenges) == 9 def test_all_depend_on_first(): challenges = [(3, 0), (2, 1, 1), (5, 1, 1), (4, 1, 1)] assert min_time_to_complete_challenges(4, challenges) == 8 def test_more_complex_dependencies(): challenges = [ (3, 0), (2, 1, 1), (5, 1, 1), (4, 2, 2, 3), (1, 1, 4), (6, 1, 5) ] assert min_time_to_complete_challenges(6, challenges) == 19","solution":"from collections import deque, defaultdict def min_time_to_complete_challenges(n, challenges): indegree = [0] * n time_to_complete = [0] * n graph = defaultdict(list) # Parse the input and build the graph for i in range(n): duration = challenges[i][0] k = challenges[i][1] prerequisites = challenges[i][2:] time_to_complete[i] = duration for prereq in prerequisites: graph[prereq - 1].append(i) indegree[i] += 1 # Use Kahn's algorithm to find the topological order queue = deque() earliest_completion = [0] * n for i in range(n): if indegree[i] == 0: queue.append(i) earliest_completion[i] = time_to_complete[i] while queue: current = queue.popleft() for neighbor in graph[current]: indegree[neighbor] -= 1 earliest_completion[neighbor] = max(earliest_completion[neighbor], earliest_completion[current] + time_to_complete[neighbor]) if indegree[neighbor] == 0: queue.append(neighbor) return max(earliest_completion) # Example usage: # print(min_time_to_complete_challenges(4, [(3, 0), (2, 1, 1), (5, 1, 1), (4, 2, 2, 3)])) # Output: 12"},{"question":"from typing import List def max_coins(grid: List[List[int]]) -> int: Returns the maximum number of coins that can be collected starting from any cell in the first row to any cell in the last row, moving to the cell directly below, below-left, or below-right. Example: >>> grid = [ ... [3, 7, 4], ... [2, 8, 1], ... [3, 5, 6] ... ] >>> max_coins(grid) 21 # Unit Tests def test_single_path(): grid = [ [3, 7, 4], [2, 8, 1], [3, 5, 6] ] assert max_coins(grid) == 21 def test_single_cell(): grid = [[5]] assert max_coins(grid) == 5 def test_multiple_options(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_coins(grid) == 18 # The path is 3 -> 6 -> 9 def test_large_grid(): grid = [ [1, 2, 3], [4, 8, 6], [7, 5, 9], [3, 2, 8], [6, 4, 9] ] # Paths can vary, but the optimal path is 3 -> 8 -> 9 -> 8 -> 9 assert max_coins(grid) == 37 def test_first_cell_largest_value(): grid = [ [10, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_coins(grid) == 12 # The path is 10 -> 1 -> 1 def test_multiple_paths_with_same_result(): grid = [ [1, 1, 5], [5, 5, 1], [1, 1, 1] ] assert max_coins(grid) == 11 # Paths are 5 -> 5 -> 1 and both give 11","solution":"def max_coins(grid): Returns the maximum number of coins that can be collected starting from any cell in the first row to any cell in the last row, moving to the cell directly below, below-left, or below-right. n = len(grid) m = len(grid[0]) # Create a dp table where dp[r][c] will store the max coins that can be collected starting from cell (r, c) dp = [[0] * m for _ in range(n)] # Initialize the first row of dp table for j in range(m): dp[0][j] = grid[0][j] # Fill up the dp table row by row for i in range(1, n): for j in range(m): dp[i][j] = grid[i][j] # Move to the cell directly below dp[i][j] += dp[i-1][j] # Move to the cell below and to the left if j > 0: dp[i][j] = max(dp[i][j], grid[i][j] + dp[i-1][j-1]) # Move to the cell below and to the right if j < m - 1: dp[i][j] = max(dp[i][j], grid[i][j] + dp[i-1][j+1]) # The result will be the maximum value in the last row of the dp table return max(dp[-1])"},{"question":"from typing import List, Tuple def can_arrange_puzzles(T: int, test_cases: List[List[Tuple[int, int]]]) -> List[str]: Determine if puzzles can be arranged according to the owner's peculiar conditions. Parameters: T : int The number of test cases. test_cases : list of lists Each list represents a test case where the first element is the number of puzzles, and subsequent elements are tuples representing the rows and columns of the puzzles. Returns: list of str : For each test case, returns \\"YES\\" if the puzzles can be arranged as required, otherwise \\"NO\\". >>> can_arrange_puzzles(3, [[3, (2, 3), (2, 4), (2, 5)], [3, (3, 2), (4, 2), (5, 2)], [3, (2, 3), (4, 5), (3, 3)]]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_arrange_puzzles(1, [[4, (3, 3), (3, 3), (3, 3), (3, 3)]]) [\\"YES\\"] pass def test_can_arrange_puzzles(): # Example test cases assert can_arrange_puzzles(3, [ [3, (2, 3), (2, 4), (2, 5)], [3, (3, 2), (4, 2), (5, 2)], [3, (2, 3), (4, 5), (3, 3)], ]) == [\\"YES\\", \\"YES\\", \\"NO\\"] # Edge case where only one puzzle is present assert can_arrange_puzzles(2, [ [1, (2, 3)], [1, (4, 5)], ]) == [\\"YES\\", \\"YES\\"] # All puzzles are the same size assert can_arrange_puzzles(1, [ [4, (3, 3), (3, 3), (3, 3), (3, 3)], ]) == [\\"YES\\"] # No puzzles share the same dimension assert can_arrange_puzzles(1, [ [3, (1, 2), (3, 4), (5, 6)], ]) == [\\"NO\\"] # All puzzles differ only by one dimension assert can_arrange_puzzles(1, [ [3, (3, 4), (5, 4), (7, 4)], ]) == [\\"YES\\"] # Mixed test cases assert can_arrange_puzzles(2, [ [3, (7, 8), (7, 9), (7, 10)], [3, (4, 5), (6, 6), (8, 7)], ]) == [\\"YES\\", \\"NO\\"] if __name__ == \\"__main__\\": test_can_arrange_puzzles() print(\\"All tests passed.\\")","solution":"def can_arrange_puzzles(T, test_cases): Determine if puzzles can be arranged according to the owner's peculiar conditions. Parameters: T : int The number of test cases. test_cases : list of lists Each list represents a test case where the first element is the number of puzzles, and subsequent elements are tuples representing the rows and columns of the puzzles. Returns: list of str : For each test case, returns \\"YES\\" if the puzzles can be arranged as required, otherwise \\"NO\\". results = [] for case in test_cases: P = case[0] puzzles = case[1:] row_set = set() col_set = set() for r, c in puzzles: row_set.add(r) col_set.add(c) if len(row_set) == 1 or len(col_set) == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def find_k_records(records: List[Tuple[str, int]], timestamp: int, k: int) -> List[Tuple[str, int]]: Returns the first k records starting from the given timestamp. Parameters: records: List[Tuple[str, int]] - List of records where each record is a tuple of (name, timestamp) timestamp: int - The timestamp to start searching from k: int - The number of records to return Returns: List[Tuple[str, int]] - List of the first k records starting from the given timestamp >>> find_k_records([(\\"Alice\\", 1), (\\"Bob\\", 2), (\\"Carol\\", 3), (\\"Dave\\", 5)], 2, 2) [('Bob', 2), ('Carol', 3)] >>> find_k_records([(\\"Alice\\", 1), (\\"Bob\\", 2), (\\"Carol\\", 3), (\\"Dave\\", 5)], 4, 3) [('Dave', 5)] pass def test_find_k_records_exact_k(): records = [(\\"Alice\\", 1), (\\"Bob\\", 2), (\\"Carol\\", 3), (\\"Dave\\", 5)] timestamp = 2 k = 2 assert find_k_records(records, timestamp, k) == [(\\"Bob\\", 2), (\\"Carol\\", 3)] def test_find_k_records_fewer_records(): records = [(\\"Alice\\", 1), (\\"Bob\\", 2), (\\"Carol\\", 3), (\\"Dave\\", 5)] timestamp = 4 k = 3 assert find_k_records(records, timestamp, k) == [(\\"Dave\\", 5)] def test_find_k_records_empty_list(): records = [] timestamp = 2 k = 2 assert find_k_records(records, timestamp, k) == [] def test_find_k_records_no_matching_timestamp(): records = [(\\"Alice\\", 1), (\\"Bob\\", 2), (\\"Carol\\", 3), (\\"Dave\\", 5)] timestamp = 6 k = 2 assert find_k_records(records, timestamp, k) == [] def test_find_k_records_more_than_needed(): records = [(\\"Alice\\", 1), (\\"Bob\\", 2), (\\"Carol\\", 3), (\\"Dave\\", 5)] timestamp = 1 k = 4 assert find_k_records(records, timestamp, k) == [(\\"Alice\\", 1), (\\"Bob\\", 2), (\\"Carol\\", 3), (\\"Dave\\", 5)]","solution":"def find_k_records(records, timestamp, k): Returns the first k records starting from the given timestamp. Parameters: records: List[Tuple[str, int]] - List of records where each record is a tuple of (name, timestamp) timestamp: int - The timestamp to start searching from k: int - The number of records to return Returns: List[Tuple[str, int]] - List of the first k records starting from the given timestamp result = [] for record in records: if record[1] >= timestamp: result.append(record) if len(result) == k: break return result"},{"question":"from typing import List, Tuple def generate_matches(teams: List[str]) -> List[Tuple[str, str]]: Generate a list of all possible matches in a tournament where each team plays once against every other team. >>> generate_matches([\\"Team A\\", \\"Team B\\", \\"Team C\\"]) [(\\"Team A\\", \\"Team B\\"), (\\"Team A\\", \\"Team C\\"), (\\"Team B\\", \\"Team C\\")] >>> generate_matches([\\"Team A\\", \\"Team B\\"]) [(\\"Team A\\", \\"Team B\\")] >>> generate_matches([\\"Team A\\"]) [] >>> generate_matches([]) [] >>> generate_matches([\\"Team A\\", \\"Team B\\", \\"Team C\\", \\"Team D\\"]) [(\\"Team A\\", \\"Team B\\"), (\\"Team A\\", \\"Team C\\"), (\\"Team A\\", \\"Team D\\"), (\\"Team B\\", \\"Team C\\"), (\\"Team B\\", \\"Team D\\"), (\\"Team C\\", \\"Team D\\")] >>> generate_matches([\\"Team A\\", \\"Team B\\", \\"Team C\\", \\"Team D\\", \\"Team E\\"]) [(\\"Team A\\", \\"Team B\\"), (\\"Team A\\", \\"Team C\\"), (\\"Team A\\", \\"Team D\\"), (\\"Team A\\", \\"Team E\\"), (\\"Team B\\", \\"Team C\\"), (\\"Team B\\", \\"Team D\\"), (\\"Team B\\", \\"Team E\\"), (\\"Team C\\", \\"Team D\\"), (\\"Team C\\", \\"Team E\\"), (\\"Team D\\", \\"Team E\\")] pass def test_generate_matches_three_teams(): teams = [\\"Team A\\", \\"Team B\\", \\"Team C\\"] expected = [(\\"Team A\\", \\"Team B\\"), (\\"Team A\\", \\"Team C\\"), (\\"Team B\\", \\"Team C\\")] assert generate_matches(teams) == expected def test_generate_matches_two_teams(): teams = [\\"Team A\\", \\"Team B\\"] expected = [(\\"Team A\\", \\"Team B\\")] assert generate_matches(teams) == expected def test_generate_matches_one_team(): teams = [\\"Team A\\"] expected = [] assert generate_matches(teams) == expected def test_generate_matches_no_teams(): teams = [] expected = [] assert generate_matches(teams) == expected def test_generate_matches_four_teams(): teams = [\\"Team A\\", \\"Team B\\", \\"Team C\\", \\"Team D\\"] expected = [(\\"Team A\\", \\"Team B\\"), (\\"Team A\\", \\"Team C\\"), (\\"Team A\\", \\"Team D\\"), (\\"Team B\\", \\"Team C\\"), (\\"Team B\\", \\"Team D\\"), (\\"Team C\\", \\"Team D\\")] assert generate_matches(teams) == expected def test_generate_matches_unique_teams(): teams = [\\"Team A\\", \\"Team B\\", \\"Team C\\", \\"Team D\\", \\"Team E\\"] expected = [(\\"Team A\\", \\"Team B\\"), (\\"Team A\\", \\"Team C\\"), (\\"Team A\\", \\"Team D\\"), (\\"Team A\\", \\"Team E\\"), (\\"Team B\\", \\"Team C\\"), (\\"Team B\\", \\"Team D\\"), (\\"Team B\\", \\"Team E\\"), (\\"Team C\\", \\"Team D\\"), (\\"Team C\\", \\"Team E\\"), (\\"Team D\\", \\"Team E\\")] assert generate_matches(teams) == expected","solution":"from typing import List, Tuple def generate_matches(teams: List[str]) -> List[Tuple[str, str]]: from itertools import combinations if len(teams) < 2: return [] return list(combinations(teams, 2))"},{"question":"from typing import List def max_submatrix_sum(matrix: List[List[int]]) -> int: Given a matrix of integers, find the submatrix with the largest possible sum. The submatrix should be contiguous and can be of any size (1x1 to NxM). Args: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: int: The sum of the submatrix with the largest sum. Examples: >>> max_submatrix_sum([[1, -2, 0], [-3, 4, 2], [2, -1, 3]]) 8 >>> max_submatrix_sum([[5]]) 5 >>> max_submatrix_sum([[-2, 1, -3, 4, -1, 2]]) 5 >>> max_submatrix_sum([[1, 2, -1, 3]]) 5 >>> max_submatrix_sum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -1 from solution import max_submatrix_sum def test_max_submatrix_sum_basic(): matrix = [[1, -2, 0], [-3, 4, 2], [2, -1, 3]] assert max_submatrix_sum(matrix) == 8 def test_max_submatrix_sum_single_element(): assert max_submatrix_sum([[5]]) == 5 assert max_submatrix_sum([[-1]]) == -1 def test_max_submatrix_sum_row_matrix(): assert max_submatrix_sum([[1, 2, -1, 3]]) == 5 assert max_submatrix_sum([[-2, 1, -3, 4, -1, 2]]) == 5 def test_max_submatrix_sum_column_matrix(): assert max_submatrix_sum([[1], [2], [-1], [3]]) == 5 assert max_submatrix_sum([[-2], [1], [-3], [4], [-1], [2]]) == 5 def test_max_submatrix_sum_all_negative(): matrix = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]] assert max_submatrix_sum(matrix) == -1 def test_max_submatrix_sum_mixed(): matrix = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] assert max_submatrix_sum(matrix) == 29","solution":"from typing import List def max_submatrix_sum(matrix: List[List[int]]) -> int: def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far rows, cols = len(matrix), len(matrix[0]) max_sum = -float('inf') for left_col in range(cols): temp = [0] * rows for right_col in range(left_col, cols): for row in range(rows): temp[row] += matrix[row][right_col] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"from typing import List, Tuple def optimize_route(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: Determines the shortest path between two points in a grid filled with obstacles. Args: grid (List[List[int]]): 2D list representing the grid map where 0 indicates an open cell and 1 indicates an obstacle. start (Tuple[int, int]): Coordinates (row, col) of the start point. end (Tuple[int, int]): Coordinates (row, col) of the end point. Returns: List[Tuple[int, int]]: List of tuples representing the shortest path from start to end (inclusive), or an empty list if no path exists. Examples: >>> optimize_route([[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [1, 1, 0, 0]], (0, 0), (3, 3)) [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (3, 2), (3, 3)] >>> optimize_route([[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [1, 1, 0, 0]], (0, 0), (3, 1)) [] >>> optimize_route([[0, 1], [0, 0]], (0, 0), (1, 1)) [(0, 0), (1, 0), (1, 1)] # Add your code here # Unit tests def test_optimize_route_path_exists(): grid = [ [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [1, 1, 0, 0] ] start = (0, 0) end = (3, 3) result = optimize_route(grid, start, end) assert result == [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (3, 2), (3, 3)] def test_optimize_route_no_path(): grid = [ [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [1, 1, 0, 0] ] start = (0, 0) end = (3, 1) result = optimize_route(grid, start, end) assert result == [] def test_optimize_route_small_grid(): grid = [ [0, 1], [0, 0] ] start = (0, 0) end = (1, 1) result = optimize_route(grid, start, end) assert result == [(0, 0), (1, 0), (1, 1)] def test_optimize_route_start_is_end(): grid = [ [0, 1], [0, 0] ] start = (0, 0) end = (0, 0) result = optimize_route(grid, start, end) assert result == [(0, 0)] def test_optimize_route_path_with_blocked_end(): grid = [ [0, 1], [0, 0] ] start = (0, 0) end = (0, 1) result = optimize_route(grid, start, end) assert result == []","solution":"from collections import deque def optimize_route(grid, start, end): Find the shortest path in a 2D grid from start to end, avoiding obstacles. if start == end: return [start] rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # corresponding to up, down, left, right queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (current_row, current_col), path = queue.popleft() for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0: next_cell = (new_row, new_col) if next_cell == end: return path + [next_cell] if next_cell not in visited: visited.add(next_cell) queue.append(((new_row, new_col), path + [next_cell])) return []"},{"question":"def find_unique_triplets(arr, target): Find all unique triplets in the array which give the sum of the target. It should return a list of unique triplets in ascending order. >>> find_unique_triplets([-1, 0, 1, 2, -1, -4], 0) [(-1, -1, 2), (-1, 0, 1)] >>> find_unique_triplets([-1, 2, 1, -4, 3], 1) [(-4, 2, 3)] def process_test_cases(input_lines): Process the test cases input and find all unique triplets for each test case. It should return the formatted output for each test case as a list of strings. >>> process_test_cases([\\"2\\", \\"6\\", \\"-1 0 1 2 -1 -4\\", \\"0\\", \\"5\\", \\"-1 2 1 -4 3\\", \\"1\\"]) [\\"Case 1:\\", \\"-1 -1 2\\", \\"-1 0 1\\", \\"Case 2:\\", \\"-4 2 3\\"] >>> process_test_cases([\\"1\\", \\"4\\", \\"0 0 0 0\\", \\"0\\"]) [\\"Case 1:\\", \\"0 0 0\\"] from solution import find_unique_triplets, process_test_cases def test_find_unique_triplets(): arr = [-1, 0, 1, 2, -1, -4] target = 0 result = find_unique_triplets(arr, target) expected = [(-1, -1, 2), (-1, 0, 1)] assert result == expected arr = [-1, 2, 1, -4, 3] target = 1 result = find_unique_triplets(arr, target) expected = [(-4, 2, 3)] assert result == expected arr = [0, 0, 0, 0] target = 0 result = find_unique_triplets(arr, target) expected = [(0, 0, 0)] assert result == expected arr = [1, 2, 3] target = 6 result = find_unique_triplets(arr, target) expected = [(1, 2, 3)] assert result == expected arr = [1, 2, 3] target = 7 result = find_unique_triplets(arr, target) expected = [] assert result == expected def test_process_test_cases(): input_lines = [ \\"2\\", \\"6\\", \\"-1 0 1 2 -1 -4\\", \\"0\\", \\"5\\", \\"-1 2 1 -4 3\\", \\"1\\" ] expected_output = [ \\"Case 1:\\", \\"-1 -1 2\\", \\"-1 0 1\\", \\"Case 2:\\", \\"-4 2 3\\" ] result = process_test_cases(input_lines) assert result == expected_output input_lines = [ \\"1\\", \\"4\\", \\"0 0 0 0\\", \\"0\\" ] expected_output = [ \\"Case 1:\\", \\"0 0 0\\" ] result = process_test_cases(input_lines) assert result == expected_output input_lines = [ \\"1\\", \\"3\\", \\"1 2 3\\", \\"6\\" ] expected_output = [ \\"Case 1:\\", \\"1 2 3\\" ] result = process_test_cases(input_lines) assert result == expected_output input_lines = [ \\"1\\", \\"3\\", \\"1 2 3\\", \\"7\\" ] expected_output = [ \\"Case 1:\\", \\"No valid triplets\\" ] result = process_test_cases(input_lines) assert result == expected_output","solution":"def find_unique_triplets(arr, target): arr.sort() triplets = set() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: s = arr[i] + arr[left] + arr[right] if s == target: triplets.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 while left < right and arr[left] == arr[left - 1]: left += 1 while left < right and arr[right] == arr[right + 1]: right -= 1 elif s < target: left += 1 else: right -= 1 return sorted(triplets) def process_test_cases(input_lines): output = [] T = int(input_lines[0]) index = 1 for case_num in range(1, T + 1): n = int(input_lines[index]) index += 1 arr = list(map(int, input_lines[index].split())) index += 1 target = int(input_lines[index]) index += 1 triplets = find_unique_triplets(arr, target) output.append(f\\"Case {case_num}:\\") if triplets: for triplet in triplets: output.append(\\" \\".join(map(str, triplet))) else: output.append(\\"No valid triplets\\") return output"},{"question":"class Matrix: Represents a 2D matrix of arbitrary size with various operations. def __init__(self, data): Creates a new Matrix from the provided list of lists. raise NotImplementedError def __add__(self, other): Returns a new Matrix that is the result of adding them. raise NotImplementedError def __sub__(self, other): Returns a new Matrix that is the result of subtracting them. raise NotImplementedError def __eq__(self, other): Returns True if they have the same dimensions and all corresponding elements are equal. raise NotImplementedError def transpose(self): Returns a new Matrix that is the transpose of the matrix. raise NotImplementedError def multiply(self, other): Returns a new Matrix that is the result of multiplying the two matrices. raise NotImplementedError def determinant(self): Returns the determinant of a square matrix (raises an error if not square). raise NotImplementedError def to_list(self): Returns a list of lists representation of the matrix. raise NotImplementedError def __str__(self): Returns a string representation of the matrix in a readable form. raise NotImplementedError @property def rows(self): Gets the number of rows in the matrix. raise NotImplementedError @property def cols(self): Gets the number of columns in the matrix. raise NotImplementedError # Test cases def test_matrix_addition(): A = Matrix([[1, 2], [3, 4]]) B = Matrix([[5, 6], [7, 8]]) expected = Matrix([[6, 8], [10, 12]]) assert (A + B) == expected def test_matrix_subtraction(): A = Matrix([[5, 6], [7, 8]]) B = Matrix([[1, 2], [3, 4]]) expected = Matrix([[4, 4], [4, 4]]) assert (A - B) == expected def test_matrix_equality(): A = Matrix([[1, 2], [3, 4]]) B = Matrix([[1, 2], [3, 4]]) C = Matrix([[5, 6], [7, 8]]) assert A == B assert A != C def test_matrix_transpose(): A = Matrix([[1, 2], [3, 4]]) expected = Matrix([[1, 3], [2, 4]]) assert A.transpose() == expected def test_matrix_multiplication(): A = Matrix([[1, 2], [3, 4]]) B = Matrix([[5, 6], [7, 8]]) expected = Matrix([[19, 22], [43, 50]]) assert A.multiply(B) == expected def test_matrix_determinant(): A = Matrix([[1, 2], [3, 4]]) assert A.determinant() == -2 B = Matrix([[2, -3, 1], [2, 0, -1], [1, 4, 5]]) assert B.determinant() == 49 def test_matrix_to_list(): A = Matrix([[1, 2], [3, 4]]) assert A.to_list() == [[1, 2], [3, 4]] def test_matrix_string_representation(): A = Matrix([[1, 2], [3, 4]]) assert str(A) == \\"1 2n3 4\\" def test_matrix_creation_invalid(): with pytest.raises(ValueError): Matrix([[1, 2], [3]]) def test_matrix_addition_invalid(): A = Matrix([[1, 2], [3, 4]]) B = Matrix([[1, 2, 3], [4, 5, 6]]) with pytest.raises(ValueError): A + B def test_matrix_subtraction_invalid(): A = Matrix([[1, 2], [3, 4]]) B = Matrix([[1, 2, 3], [4, 5, 6]]) with pytest.raises(ValueError): A - B def test_matrix_multiplication_invalid(): A = Matrix([[1, 2], [3, 4]]) B = Matrix([[1, 2], [3, 4], [5, 6]]) with pytest.raises(ValueError): A.multiply(B) def test_determinant_invalid(): A = Matrix([[1, 2, 3], [4, 5, 6]]) with pytest.raises(ValueError): A.determinant()","solution":"class Matrix: def __init__(self, data): if not all(len(row) == len(data[0]) for row in data): raise ValueError(\\"All rows must have the same length\\") self.data = data self.rows = len(data) self.cols = len(data[0]) def __add__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions do not match for addition\\") result = [ [self.data[r][c] + other.data[r][c] for c in range(self.cols)] for r in range(self.rows) ] return Matrix(result) def __sub__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions do not match for subtraction\\") result = [ [self.data[r][c] - other.data[r][c] for c in range(self.cols)] for r in range(self.rows) ] return Matrix(result) def __eq__(self, other): return self.data == other.data def transpose(self): result = [[self.data[c][r] for c in range(self.rows)] for r in range(self.cols)] return Matrix(result) def multiply(self, other): if self.cols != other.rows: raise ValueError(\\"Matrices dimensions do not match for multiplication\\") result = [ [sum(self.data[r][k] * other.data[k][c] for k in range(self.cols)) for c in range(other.cols)] for r in range(self.rows) ] return Matrix(result) def determinant(self): if self.rows != self.cols: raise ValueError(\\"Determinant not defined for non-square matrices\\") def _det(matrix): if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): submatrix = [ row[:c] + row[c+1:] for row in matrix[1:] ] det += ((-1) ** c) * matrix[0][c] * _det(submatrix) return det return _det(self.data) def to_list(self): return self.data def __str__(self): return 'n'.join([' '.join(map(str, row)) for row in self.data])"},{"question":"class SudokuSolver: def __init__(self, board): Initialize the Sudoku solver with the board. :param board: List[List[int]] - A 2D list representing the Sudoku grid. pass def solve(self): Solves the Sudoku puzzle. :return: List[List[int]] - A 2D list representing the solved Sudoku grid. If the puzzle is unsolvable, return None. Example: >>> board = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> solver = SudokuSolver(board) >>> solver.solve() [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] pass def test_sudoku_solver_easy(): board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solver = SudokuSolver(board) solved_board = solver.solve() expected_board = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] assert solved_board == expected_board def test_sudoku_solver_already_solved(): board = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] solver = SudokuSolver(board) solved_board = solver.solve() assert solved_board == board def test_sudoku_solver_unsolvable(): board = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 8], [1, 9, 8, 0, 2, 0, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] solver = SudokuSolver(board) solved_board = solver.solve() assert solved_board == None","solution":"class SudokuSolver: def __init__(self, board): self.board = board def is_valid(self, num, row, col): # Check row for i in range(9): if self.board[row][i] == num: return False # Check column for i in range(9): if self.board[i][col] == num: return False # Check 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if self.board[i][j] == num: return False return True def solve_sudoku(self): for row in range(9): for col in range(9): if self.board[row][col] == 0: for num in range(1, 10): if self.is_valid(num, row, col): self.board[row][col] = num if self.solve_sudoku(): return True self.board[row][col] = 0 return False return True def solve(self): if self.solve_sudoku(): return self.board else: return None"},{"question":"from typing import List, Tuple def toggle_submatrix(n: int, m: int, k: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: You are given a grid of size N x M initially filled with zeros. There are K operations to be performed on this grid. Each operation will toggle the cells (i.e., change 0 to 1 or 1 to 0) in a given submatrix defined by its top-left and bottom-right corners. Parameters: - n (int): Number of rows. - m (int): Number of columns. - k (int): Number of operations. - operations (List[Tuple[int, int, int, int]]): List of operations, where each operation is defined by four integers (r1, c1, r2, c2) representing the top-left and bottom-right corners of the submatrix to be toggled. Returns: - List[List[int]]: The final state of the grid after performing all K operations. Example: >>> toggle_submatrix(4, 4, 2, [(1, 1, 2, 2), (2, 2, 4, 4)]) [[1, 1, 0, 0], [1, 0, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]] >>> toggle_submatrix(3, 3, 1, [(1, 1, 3, 3)]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] pass def format_grid(grid: List[List[int]]) -> str: Formats the grid for printing. Parameters: - grid (List[List[int]]): The grid to format. Returns: - str: The formatted grid as a string. pass # Unit tests def test_example_case(): n, m, k = 4, 4, 2 operations = [(1, 1, 2, 2), (2, 2, 4, 4)] result = toggle_submatrix(n, m, k, operations) expected = [ [1, 1, 0, 0], [1, 0, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], ] assert result == expected def test_single_toggle(): n, m, k = 3, 3, 1 operations = [(1, 1, 3, 3)] result = toggle_submatrix(n, m, k, operations) expected = [ [1, 1, 1], [1, 1, 1], [1, 1, 1], ] assert result == expected def test_sequential_toggles(): n, m, k = 3, 3, 2 operations = [(1, 1, 2, 2), (2, 2, 3, 3)] result = toggle_submatrix(n, m, k, operations) expected = [ [1, 1, 0], [1, 0, 1], [0, 1, 1], ] assert result == expected def test_no_operations(): n, m, k = 3, 3, 0 operations = [] result = toggle_submatrix(n, m, k, operations) expected = [ [0, 0, 0], [0, 0, 0], [0, 0, 0], ] assert result == expected def test_edge_case(): n, m, k = 1, 1, 1 operations = [(1, 1, 1, 1)] result = toggle_submatrix(n, m, k, operations) expected = [ [1], ] assert result == expected","solution":"def toggle_submatrix(n, m, k, operations): grid = [[0] * m for _ in range(n)] for op in operations: r1, c1, r2, c2 = op for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): grid[i][j] = 1 - grid[i][j] return grid def format_grid(grid): return 'n'.join(' '.join(map(str, row)) for row in grid) # Sample inputs n, m, k = 4, 4, 2 operations = [(1, 1, 2, 2), (2, 2, 4, 4)] grid = toggle_submatrix(n, m, k, operations) print(format_grid(grid))"},{"question":"from typing import List def max_sum_path(grid: List[List[int]]) -> int: Find the maximum sum path from the top-left to the bottom-right cell of the grid. You can only move to the right or down from each cell. >>> max_sum_path([ ... [1, 3, 6], ... [5, 8, 2], ... [7, 4, 9] ... ]) 27 >>> max_sum_path([[1, 4, 5]]) 10 >>> max_sum_path([[2], [3], [5]]) 10 >>> max_sum_path([ ... [1, 2], ... [1, 1] ... ]) 4 >>> max_sum_path([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_sum_path([ ... [1, 2, -1], ... [-1, -2, 1], ... [1, 1, 1] ... ]) 4","solution":"def max_sum_path(grid): rows = len(grid) cols = len(grid[0]) # Create a 2D dp array initialized to zero dp = [[0] * cols for _ in range(rows)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Fill the first row (since we can only move right) for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (since we can only move down) for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the result return dp[rows - 1][cols - 1]"},{"question":"def rotate_array(n: int, k: int, values: List[int]) -> List[int]: Rotates the array 'values' k steps to the right. :param n: Number of elements in the array. :param k: Number of rotations. :param values: List of integer values. :return: List of integers after k rotations. >>> rotate_array(5, 2, [1, 2, 3, 4, 5]) [4, 5, 1, 2, 3] >>> rotate_array(5, 0, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rotate_array(5, 5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rotate_array(1, 1, [1]) [1] >>> rotate_array(5, 12, [1, 2, 3, 4, 5]) [4, 5, 1, 2, 3] >>> rotate_array(7, 3, [10, 20, 30, 40, 50, 60, 70]) [50, 60, 70, 10, 20, 30, 40] >>> rotate_array(3, 4, [7, 8, 9]) [9, 7, 8] pass","solution":"def rotate_array(n, k, values): Rotates the array 'values' n steps to the right. k = k % n # In case k is larger than n return values[-k:] + values[:-k]"},{"question":"def binary_to_decimal(binary_list): Converts a list of binary numbers to their decimal equivalents. Parameters: binary_list (list of str): List of binary numbers as strings. Returns: list of int: List of decimal equivalents of the binary numbers. Example: >>> binary_to_decimal([\\"1010\\"]) [10] >>> binary_to_decimal([\\"111\\"]) [7] >>> binary_to_decimal([\\"10001\\"]) [17]","solution":"def binary_to_decimal(binary_list): Converts a list of binary numbers to their decimal equivalents. Parameters: binary_list (list of str): List of binary numbers as strings. Returns: list of int: List of decimal equivalents of the binary numbers. return [int(binary, 2) for binary in binary_list]"},{"question":"def distinct_substrings_count(s: str) -> int: Returns the count of distinct substrings of s. :param s: The input string consisting of lowercase English letters :return: The number of distinct substrings of the input string >>> distinct_substrings_count(\\"abc\\") 6 >>> distinct_substrings_count(\\"aaa\\") 3 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases to find the number of distinct substrings for each. :param t: Number of test cases :param test_cases: List of strings for each test case :return: List where each element is the count of distinct substrings of the corresponding test case string >>> process_test_cases(2, [\\"abc\\", \\"aaa\\"]) [6, 3] >>> process_test_cases(1, [\\"abab\\"]) [7]","solution":"def distinct_substrings_count(s): Returns the count of distinct substrings of s. substrings = set() # generate all possible substrings for i in range(len(s)): for j in range(i+1, len(s)+1): substrings.add(s[i:j]) return len(substrings) def process_test_cases(t, test_cases): Processes multiple test cases to find the number of distinct substrings for each. :param t: Number of test cases :param test_cases: List of strings for each test case :return: List where each element is the count of distinct substrings of the corresponding test case string results = [] for test_case in test_cases: results.append(distinct_substrings_count(test_case)) return results"},{"question":"from typing import List, Tuple def minimize_maximum_delay(t: int, test_cases: List[Tuple[int, List[Tuple[int, int, int]]]]) -> List[int]: Minimize the maximum data transfer delay between any pairs of computers in the network. Args: t: The number of test cases. test_cases: A list of tuples, each containing an integer n (number of computers) and a list of tuples with three integers u_i, v_i, s_i (computers connected by the ith cable and the speed of the cable). Returns: A list of integers representing the minimum of the maximum delays for data transfer between any pairs of computers in the network in milliseconds. Example: >>> minimize_maximum_delay(2, [(4, [(1, 2, 100), (2, 3, 50), (3, 4, 200)]), (3, [(1, 2, 1000), (2, 3, 500)])]) [20, 2] >>> minimize_maximum_delay(1, [(3, [(1, 2, 10), (2, 3, 20)])]) [100] >>> minimize_maximum_delay(1, [(5, [(1, 2, 5), (2, 3, 10), (3, 4, 15), (4, 5, 20)])]) [200]","solution":"import heapq def minimize_maximum_delay(t, test_cases): def prim_mst(n, edges): adj = [[] for _ in range(n)] for u, v, s in edges: u -= 1 v -= 1 delay = 1000 / s adj[u].append((v, delay)) adj[v].append((u, delay)) in_mst = [False] * n delays = [float('inf')] * n delays[0] = 0 pq = [(0, 0)] max_delay = 0 while pq: current_delay, u = heapq.heappop(pq) if in_mst[u]: continue in_mst[u] = True max_delay = max(max_delay, current_delay) for v, delay in adj[u]: if not in_mst[v] and delay < delays[v]: delays[v] = delay heapq.heappush(pq, (delay, v)) return int(max_delay) results = [] for test_case in test_cases: n, edges = test_case result = prim_mst(n, edges) results.append(result) return results"},{"question":"def sum_max_min_elements(test_cases): Find the sum of the maximum and minimum elements in the list for each test case. :param test_cases: A list of tuples, where each tuple contains an integer n and a list of n integers. :return: A list of integers, with each integer representing the sum of the maximum and minimum elements for the corresponding test case. >>> sum_max_min_elements([(5, [1, 2, 3, 4, 5]), (3, [10, 11, 12])]) [6, 22] >>> sum_max_min_elements([(1, [10]), (1, [5])]) [20, 10] >>> sum_max_min_elements([(3, [999999999, 1000000000, 999999998])]) [1999999998] >>> sum_max_min_elements([(4, [1, 2, 3, 4]), (5, [5, 4, 3, 2, 1]), (6, [100, 200, 300, 400, 500, 600])]) [5, 6, 700] >>> sum_max_min_elements([(4, [5, 5, 5, 5]), (3, [10, 10, 10])]) [10, 20]","solution":"def sum_max_min_elements(test_cases): results = [] for case in test_cases: n, elements = case max_element = max(elements) min_element = min(elements) results.append(max_element + min_element) return results # Reading input and preparing test_cases def prepare_test_cases(inputs): index = 0 T = inputs[index] index += 1 test_cases = [] for _ in range(T): n = inputs[index] index += 1 elements = inputs[index] index += 1 test_cases.append((n, elements)) return test_cases def main(inputs): test_cases = prepare_test_cases(inputs) return sum_max_min_elements(test_cases)"},{"question":"def binary_to_decimal(binary: str) -> int: Converts a binary string to its decimal value without using direct conversion functions. >>> binary_to_decimal(\\"110\\") 6 >>> binary_to_decimal(\\"1001\\") 9 >>> binary_to_decimal(\\"1111\\") 15 >>> binary_to_decimal(\\"0\\") 0 >>> binary_to_decimal(\\"0000\\") 0 >>> binary_to_decimal(\\"1\\") 1 >>> binary_to_decimal(\\"101010\\") 42 >>> binary_to_decimal(\\"11011011\\") 219","solution":"def binary_to_decimal(binary): Converts a binary string to its decimal value without using direct conversion functions. decimal_value = 0 base = 1 # represents 2^0 # Iterate over the binary string in reverse for digit in binary[::-1]: if digit == '1': decimal_value += base base *= 2 # Move to the next base (2^n) return decimal_value"},{"question":"def min_stamina(N: int, H: List[int]) -> int: Calculate the minimum initial stamina required to complete the hike without the stamina dropping below 1 at any point. >>> min_stamina(5, [2, -1, 4, -3, 2]) 6 >>> min_stamina(4, [1, -2, 1, -1]) 2","solution":"def min_stamina(N, H): current_stamina = 1 minimum_stamina = 1 for change in H: current_stamina -= change if current_stamina < 1: minimum_stamina += (1 - current_stamina) current_stamina = 1 return minimum_stamina"},{"question":"def peakIndices(nums: List[int]) -> List[int]: Returns the indices of peak elements in the list nums. A peak element is an element that is strictly greater than its neighbors. If the element is at the boundary of the list, it is only required to be greater than its single neighbor to be considered a peak. >>> peakIndices([1, 3, 2, 7, 6, 5]) [1, 3] >>> peakIndices([11, 15, 13, 21, 18, 20, 17]) [1, 3, 5]","solution":"def peakIndices(nums): Returns the indices of peak elements in the list nums. A peak element is one that is greater than its neighbors. n = len(nums) if n == 1: return [0] peaks = [] for i in range(n): if i == 0 and nums[i] > nums[i + 1]: peaks.append(i) elif i == n - 1 and nums[i] > nums[i - 1]: peaks.append(i) elif 0 < i < n - 1 and nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: peaks.append(i) return peaks"},{"question":"def does_trail_cross(n: int, coordinates: List[Tuple[int, int]]) -> str: Determine whether a hiking trail represented as a sequence of coordinates crosses itself. The function takes an integer n representing the number of coordinates followed by a list of tuples where each tuple represents the coordinates (x, y). Returns \\"Yes\\" if the trail crosses itself, otherwise returns \\"No\\". >>> does_trail_cross(4, [(1, 1), (2, 3), (3, 1), (1, 2)]) \\"Yes\\" >>> does_trail_cross(5, [(0, 0), (1, 1), (2, 2), (1, 3), (0, 2)]) \\"No\\"","solution":"def does_trail_cross(n, coordinates): def ccw(A, B, C): return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0]) def intersect(A, B, C, D): return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D) for i in range(n - 1): for j in range(i - 1): if intersect(coordinates[i], coordinates[i + 1], coordinates[j], coordinates[j + 1]): return \\"Yes\\" return \\"No\\" # Example Usage: # n = 4 # coordinates = [(1, 1), (2, 3), (3, 1), (1, 2)] # print(does_trail_cross(n, coordinates)) # Output: \\"Yes\\""},{"question":"def minimum_delivery_times(W: int, R: int, P: int, routes: List[Tuple[int, int, int, int]], packages: List[Tuple[int, int, int]]) -> List[str]: Determine the minimum time to deliver each package from its source waypoint to its destination waypoint. Args: W : int : Number of waypoints (2 <= W <= 1000) R : int : Number of routes (1 <= R <= 2000) P : int : Number of packages (1 <= P <= 100) routes : List[Tuple[int, int, int, int]] : Each route described by four integers (a, b, c, t). packages : List[Tuple[int, int, int]] : Each package described by three integers (s, d, w). Returns: List[str] : List of minimum times for each package or \\"unreachable\\" if package cannot be delivered. Test Cases: >>> minimum_delivery_times(3, 3, 1, [(0, 1, 5, 10), (1, 2, 5, 15), (0, 2, 2, 50)], [(0, 2, 5)]) [\\"25\\"] >>> minimum_delivery_times(4, 3, 1, [(0, 1, 4, 10), (1, 2, 6, 15), (2, 3, 6, 20)], [(0, 3, 8)]) [\\"unreachable\\"] >>> minimum_delivery_times(3, 3, 2, [(0, 1, 5, 10), (1, 2, 5, 15), (0, 2, 2, 50)], [(0, 2, 5), (0, 1, 25)]) [\\"25\\", \\"unreachable\\"] >>> minimum_delivery_times(3, 2, 1, [(0, 1, 5, 10), (1, 2, 5, 15)], [(2, 0, 5)]) [\\"25\\"]","solution":"import heapq import sys def dijkstra(W, adj, start, end, weight): INF = sys.maxsize distances = [INF] * W distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, cost, capacity in adj[current_node]: if weight <= capacity: distance = current_distance + cost if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] def minimum_delivery_times(W, R, P, routes, packages): adj = [[] for _ in range(W)] for a, b, c, t in routes: adj[a].append((b, t, c)) adj[b].append((a, t, c)) # Assuming bidirectional routes results = [] for s, d, w in packages: min_time = dijkstra(W, adj, s, d, w) if min_time == sys.maxsize: results.append(\\"unreachable\\") else: results.append(str(min_time)) return results # Example usage W = 3 R = 3 P = 1 routes = [ (0, 1, 5, 10), (1, 2, 5, 15), (0, 2, 2, 50) ] packages = [ (0, 2, 5) ] result = minimum_delivery_times(W, R, P, routes, packages) for r in result: print(r)"},{"question":"def balance_brackets(s): Checks if the brackets in the given string are balanced. >>> balance_brackets(\\"{[()]}\\") True >>> balance_brackets(\\"{[(])}\\") False >>> balance_brackets(\\"{([])}{}[]\\") True >>> balance_brackets(\\"([}{])\\") False >>> balance_brackets(\\"{\\") False >>> balance_brackets(\\"a[b]c{d}(e)\\") True >>> balance_brackets(\\"a[b}c{d}(e)\\") False >>> balance_brackets(\\"[[]]\\") True >>> balance_brackets(\\"[][]\\") True >>> balance_brackets(\\"[]{}()\\") True >>> balance_brackets(\\"[{]\\") False >>> balance_brackets(\\"[}\\") False","solution":"def balance_brackets(s): Checks if the brackets in the given string are balanced. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): # if it's an opening bracket stack.append(char) elif char in bracket_map.keys(): # if it's a closing bracket if stack == [] or bracket_map[char] != stack.pop(): return False else: continue # ignore non-bracket characters return stack == [] # True if balanced, False otherwise"},{"question":"def min_operations_to_equalize(n: int, a: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal, or -1 if it is not possible to make all the elements equal. Parameters: n (int): Size of the array. a (list): The elements of the array. Returns: int: Minimum number of operations required or -1 if it is not possible. Examples: >>> min_operations_to_equalize(3, [4, 6, 8]) 2 >>> min_operations_to_equalize(4, [3, 7, 5, 9]) 4 >>> min_operations_to_equalize(3, [1, 2, 3]) -1","solution":"def min_operations_to_equalize(n, a): Returns the minimum number of operations required to make all elements of the array equal, or -1 if it is not possible to make all the elements equal. Parameters: n (int): Size of the array. a (list): The elements of the array. Returns: int: Minimum number of operations required or -1 if it is not possible. # Check if there are any two elements with difference not even initial_parity = a[0] % 2 for num in a: if num % 2 != initial_parity: return -1 # Calculate the number of operations required to make all elements equal to the median a_sorted = sorted(a) median = a_sorted[n // 2] operations = sum(abs(x - median) // 2 for x in a) return operations"},{"question":"def max_tasks_sharing_k_tags(n: int, k: int, tasks: List[str]) -> int: Identifies the maximum number of tasks sharing at least k common tags from a given list of tasks. >>> max_tasks_sharing_k_tags(4, 2, [\\"task1 3 tag1 tag2 tag3\\", \\"task2 3 tag2 tag3 tag4\\", \\"task3 2 tag1 tag2\\", \\"task4 3 tag1 tag4 tag5\\"]) 3 >>> max_tasks_sharing_k_tags(3, 1, [\\"task1 2 tag1 tag2\\", \\"task2 2 tag3 tag4\\", \\"task3 2 tag2 tag3\\"]) 2 from solution import max_tasks_sharing_k_tags def test_example_1(): n = 4 k = 2 tasks = [ \\"task1 3 tag1 tag2 tag3\\", \\"task2 3 tag2 tag3 tag4\\", \\"task3 2 tag1 tag2\\", \\"task4 3 tag1 tag4 tag5\\" ] assert max_tasks_sharing_k_tags(n, k, tasks) == 3 def test_example_2(): n = 3 k = 1 tasks = [ \\"task1 2 tag1 tag2\\", \\"task2 2 tag3 tag4\\", \\"task3 2 tag2 tag3\\" ] assert max_tasks_sharing_k_tags(n, k, tasks) == 2 def test_no_common_tags(): n = 3 k = 1 tasks = [ \\"task1 2 tag1 tag2\\", \\"task2 2 tag3 tag4\\", \\"task3 2 tag5 tag6\\" ] assert max_tasks_sharing_k_tags(n, k, tasks) == 1 def test_all_tasks_common_tags(): n = 3 k = 1 tasks = [ \\"task1 1 tag1\\", \\"task2 1 tag1\\", \\"task3 1 tag1\\" ] assert max_tasks_sharing_k_tags(n, k, tasks) == 3 def test_minimum_common_tags(): n = 4 k = 2 tasks = [ \\"task1 2 tag1 tag2\\", \\"task2 2 tag1 tag2\\", \\"task3 2 tag1 tag3\\", \\"task4 2 tag2 tag3\\" ] assert max_tasks_sharing_k_tags(n, k, tasks) == 2","solution":"def max_tasks_sharing_k_tags(n, k, tasks): from collections import defaultdict def common_tags(tags1, tags2): return len(set(tags1) & set(tags2)) task_tags = [] for task in tasks: task_id, *tags = task.split()[1:] task_tags.append(tags) max_tasks = 0 for i in range(n): count = 1 # Counting the current task itself for j in range(i + 1, n): if common_tags(task_tags[i], task_tags[j]) >= k: count += 1 max_tasks = max(max_tasks, count) return max_tasks # Function usage example: n = 4 k = 2 tasks = [ \\"task1 3 tag1 tag2 tag3\\", \\"task2 3 tag2 tag3 tag4\\", \\"task3 2 tag1 tag2\\", \\"task4 3 tag1 tag4 tag5\\" ] print(max_tasks_sharing_k_tags(n, k, tasks)) # Output: 3"},{"question":"def count_ways_to_predicted_child(k: int) -> tuple: Returns the number of ways the ball can end up with child 1, child 2, and child 3, respectively after exactly k passes. >>> count_ways_to_predicted_child(2) (0, 1, 1) >>> count_ways_to_predicted_child(3) (2, 1, 1)","solution":"def count_ways_to_predicted_child(k): Returns the number of ways the ball can end up with child 1, child 2, and child 3, respectively after exactly k passes. # Ways to have ball with child 1, 2, and 3 after n passes dp1, dp2, dp3 = 0, 1, 1 # Initial state after 1 pass if k == 1: return dp1, dp2, dp3 for _ in range(2, k+1): new_dp1 = dp2 + dp3 new_dp2 = dp1 + dp3 new_dp3 = dp1 + dp2 dp1, dp2, dp3 = new_dp1, new_dp2, new_dp3 return dp1, dp2, dp3"},{"question":"def editDistance(s1: str, s2: str) -> int: Given two strings s1 and s2, determine the minimum number of operations required to convert s1 into s2. The allowed operations are: 1. Insert a character 2. Delete a character 3. Replace a character Args: s1 (str): the first string. s2 (str): the second string. Returns: int: the minimum number of operations needed to convert s1 to s2 >>> editDistance(\\"kitten\\", \\"sitting\\") 3 >>> editDistance(\\"flaw\\", \\"lawn\\") 2 >>> editDistance(\\"apple\\", \\"apple\\") 0 >>> editDistance(\\"a\\", \\"abc\\") 2 >>> editDistance(\\"abcdef\\", \\"ab\\") 4 >>> editDistance(\\"horse\\", \\"ros\\") 3 >>> editDistance(\\"intention\\", \\"execution\\") 5","solution":"def editDistance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. Arguments: s1 : str : the first string s2 : str : the second string to which we need to convert s1 Returns: int : the minimum number of operations needed to convert s1 to s2 m = len(s1) n = len(s2) # Create a DP table to store results of subproblems dp = [[0 for j in range(n+1)] for i in range(m+1)] # Fill dp array using the bottom-up approach for i in range(m+1): for j in range(n+1): # If first string is empty, the only option is to insert all characters of the second string if i == 0: dp[i][j] = j # If second string is empty, the only option is to remove all characters of the first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore the last character and recur for the remaining substring elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def Fibonacci(N: int) -> int: Return the Nth term of the Fibonacci series (0-based indexing). >>> Fibonacci(0) 0 >>> Fibonacci(1) 1 >>> Fibonacci(5) 5 >>> Fibonacci(99) 218922995834555169026","solution":"def Fibonacci(N): Return the Nth term of the Fibonacci series (0-based indexing). if N == 0: return 0 elif N == 1: return 1 a, b = 0, 1 for i in range(2, N + 1): a, b = b, a + b return b"},{"question":"def final_amounts(initial_X: int, initial_Y: int, evaporation_amount: int) -> Tuple[int, int]: Returns the final amounts of the substance in test tubes X and Y after evaporation and transfer. Parameters: - initial_X (int): Initial amount of substance in test tube X. - initial_Y (int): Initial amount of substance in test tube Y. - evaporation_amount (int): Amount of substance that evaporates from test tube X and is transferred from test tube Y to X. Returns: - tuple: Final amounts of the substance in test tubes X and Y. >>> final_amounts(500, 300, 100) (500, 200) >>> final_amounts(100, 100, 0) (100, 100) >>> final_amounts(700, 250, 250) (700, 0) >>> final_amounts(500, 500, 200) (500, 300) >>> final_amounts(1, 1, 1) (1, 0)","solution":"def final_amounts(initial_X, initial_Y, evaporation_amount): Returns the final amounts of the substance in test tubes X and Y after evaporation and transfer. Parameters: - initial_X (int): Initial amount of substance in test tube X. - initial_Y (int): Initial amount of substance in test tube Y. - evaporation_amount (int): Amount of substance that evaporates from test tube X and is transferred from test tube Y to X. Returns: - tuple: Final amounts of the substance in test tubes X and Y. final_X = initial_X - evaporation_amount + evaporation_amount final_Y = initial_Y - evaporation_amount return final_X, final_Y # Example usage: # print(final_amounts(500, 300, 100)) # Output: (500, 200)"},{"question":"def max_rocks_collected(N: int, M: int, field: List[str]) -> int: Determine the maximum number of rocks the rover can collect on its path from the top-left corner to the bottom-right corner. The rover starts at the top-left corner of the field (cell (1,1)) and moves to the bottom-right corner (cell (N, M)), moving only to the right or down. The rover cannot move into a cell that has a tree ('T'), but it can collect rocks ('R') from cells it visits. Args: N: int - the number of rows in the field M: int - the number of columns in the field field: List[str] - a list of strings representing the rows in the field Returns: int - the maximum number of rocks the rover can collect >>> max_rocks_collected(3, 4, ['.R..', '..R.', '.T..']) 2 >>> max_rocks_collected(2, 2, ['.R', 'R.']) 1","solution":"def max_rocks_collected(N, M, field): # Create a matrix to store the maximum rocks collected so far dp = [[0] * M for _ in range(N)] # Initialize the first cell if field[0][0] == 'R': dp[0][0] = 1 # Fill the first row for j in range(1, M): if field[0][j] == 'T': dp[0][j] = -1 elif dp[0][j - 1] != -1: dp[0][j] = dp[0][j - 1] + (1 if field[0][j] == 'R' else 0) # Fill the first column for i in range(1, N): if field[i][0] == 'T': dp[i][0] = -1 elif dp[i - 1][0] != -1: dp[i][0] = dp[i - 1][0] + (1 if field[i][0] == 'R' else 0) # Fill the rest of the dp matrix for i in range(1, N): for j in range(1, M): if field[i][j] == 'T': dp[i][j] = -1 else: from_up = dp[i - 1][j] if dp[i - 1][j] != -1 else 0 from_left = dp[i][j - 1] if dp[i][j - 1] != -1 else 0 if from_up != 0 or from_left != 0: dp[i][j] = max(from_up, from_left) + (1 if field[i][j] == 'R' else 0) # Return the maximum rocks collected when reaching the bottom-right corner return dp[N - 1][M - 1] if dp[N - 1][M - 1] != -1 else 0 # Reading input and calling the function to get the answer if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N, M = int(data[0]), int(data[1]) field = [] index = 2 for i in range(N): field.append(data[index]) index += 1 print(max_rocks_collected(N, M, field))"},{"question":"def find_smallest_repeating_unit(s: str) -> str: Determines if the string is repetitive and returns the smallest repeating unit if it is. If not, returns \\"None\\". >>> find_smallest_repeating_unit(\\"abcabcabc\\") == \\"abc\\" >>> find_smallest_repeating_unit(\\"aaaa\\") == \\"a\\" >>> find_smallest_repeating_unit(\\"ababa\\") == \\"None\\" >>> find_smallest_repeating_unit(\\"abccbaabccba\\") == \\"abccba\\"","solution":"def find_smallest_repeating_unit(s): Determines if the string is repetitive and returns the smallest repeating unit if it is. If not, returns \\"None\\". n = len(s) for i in range(1, n // 2 + 1): # Check if the length of substring i can divide the whole string if n % i == 0: substring = s[:i] repeated = substring * (n // i) if repeated == s: return substring return \\"None\\" # Example usage: # s = \\"abcabcabc\\" # print(find_smallest_repeating_unit(s)) # Output: \\"abc\\""},{"question":"def max_bonus_units(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of bonus units each employee should receive so that they all get the same amount and the number of units given out is maximized without exceeding M. >>> max_bonus_units(3, [(5, 23), (8, 64), (7, 100)]) == [4, 8, 14]","solution":"def max_bonus_units(T, test_cases): results = [] for case in test_cases: N, M = case max_units = M // N results.append(max_units) return results"},{"question":"def longest_palindromic_substring(text: str) -> str: Finds the longest palindromic substring in a given text. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"ac\\") \\"a\\" def process_input(input_lines: List[str]) -> str: Handles the input and formatting for the output. For each test case in input_lines, print the test case number and the longest palindromic substring.","solution":"def longest_palindromic_substring(text): Finds the longest palindromic substring in a given text. def extend_palindrome(left, right): while left >= 0 and right < len(text) and text[left] == text[right]: left -= 1 right += 1 return text[left+1:right] longest = \\"\\" for i in range(len(text)): # Odd length palindromes substr1 = extend_palindrome(i, i) # Even length palindromes substr2 = extend_palindrome(i, i + 1) # Check for the longer substring found if len(substr1) > len(longest): longest = substr1 if len(substr2) > len(longest): longest = substr2 return longest def process_input(input_lines): Handles the input and formatting for the output. case_number = 1 for line in input_lines: line = line.strip() if line == \\"END\\": break result = longest_palindromic_substring(line) print(f\\"Case #{case_number}n{result}n\\") case_number += 1"},{"question":"def max_minerals_collected(matrix: List[List[int]]) -> int: Determine the maximum number of minerals that can be collected when traveling from the top-left corner to the bottom-right corner of the matrix. You can only move either right or down from a cell. Args: matrix: A 2D list of integers representing the number of minerals in each cell. Returns: An integer representing the maximum number of minerals that can be collected on the path from the top-left corner to the bottom-right corner of the matrix. >>> max_minerals_collected([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 12 >>> max_minerals_collected([ [1, 2, 3, 4] ]) 10 >>> max_minerals_collected([ [1], [2], [3], [4] ]) 10 >>> max_minerals_collected([ [0] ]) 0 >>> max_minerals_collected([ [100, 100, 100], [100, 100, 100], [100, 100, 100] ]) 500 # Implementation here from typing import List def test_sample_input(): matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_minerals_collected(matrix) == 12 def test_single_row(): matrix = [ [1, 2, 3, 4] ] assert max_minerals_collected(matrix) == 10 def test_single_column(): matrix = [ [1], [2], [3], [4] ] assert max_minerals_collected(matrix) == 10 def test_minimum_case(): matrix = [ [0] ] assert max_minerals_collected(matrix) == 0 def test_large_values(): matrix = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] assert max_minerals_collected(matrix) == 500","solution":"def max_minerals_collected(matrix): if not matrix: return 0 M, N = len(matrix), len(matrix[0]) dp = [[0] * N for _ in range(M)] dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, M): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[M-1][N-1] # Input: matrix in form of a list of lists # output: maximum number of minerals collected"},{"question":"def numberOfWaysToSegment(S: str, N: int, dictionary: List[str]) -> int: This function returns the number of possible ways to segment the string S into a sequence of valid dictionary words. >>> numberOfWaysToSegment(\\"applepenapple\\", 3, [\\"apple\\", \\"pen\\", \\"applepen\\"]) 2 >>> numberOfWaysToSegment(\\"catsanddog\\", 5, [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) 2 >>> numberOfWaysToSegment(\\"catsandog\\", 5, [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) 0 >>> numberOfWaysToSegment(\\"\\", 3, [\\"apple\\", \\"pen\\", \\"applepen\\"]) 1 >>> numberOfWaysToSegment(\\"apple\\", 3, [\\"apple\\", \\"pen\\", \\"applepen\\"]) 1 >>> numberOfWaysToSegment(\\"abcd\\", 3, [\\"a\\", \\"b\\", \\"c\\"]) 0","solution":"def numberOfWaysToSegment(S, N, dictionary): This function returns the number of possible ways to segment the string S into a sequence of valid dictionary words. word_dict = set(dictionary) memo = {} def helper(s): if s in memo: return memo[s] if s == \\"\\": return 1 count = 0 for i in range(1, len(s) + 1): if s[:i] in word_dict: count += helper(s[i:]) memo[s] = count return count return helper(S)"},{"question":"def can_form_palindromes(T, test_cases): Determine if it is possible to remove the entire string by forming palindromes. Args: T (int): Number of test cases. test_cases (List[Tuple[int, str]]): List of tuples, each containing the length of the string and the string itself. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> can_form_palindromes(1, [(6, \\"abccba\\")]) [\\"YES\\"] >>> can_form_palindromes(1, [(7, \\"aacursed\\")]) [\\"NO\\"] >>> can_form_palindromes(1, [(10, \\"modoistool\\")]) [\\"NO\\"] >>> can_form_palindromes(1, [(1, \\"a\\")]) [\\"YES\\"] >>> can_form_palindromes(1, [(4, \\"aabb\\")]) [\\"YES\\"] >>> can_form_palindromes(1, [(5, \\"aabcd\\")]) [\\"NO\\"]","solution":"def can_form_palindromes(T, test_cases): def is_palindrome_possible(N, S): # Count the frequency of each character in the string char_count = {} for char in S: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count the number of characters with odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged as palindromes and removed, at most one character can have an odd frequency # (example: level, civic) return odd_count <= 1 results = [] for i in range(T): N, S = test_cases[i] if is_palindrome_possible(N, S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example Usage: # T = 3 # test_cases = [ # (6, \\"abccba\\"), # (7, \\"aacursed\\"), # (10, \\"modoistool\\") # ] # print(can_form_palindromes(T, test_cases)) # Output: ['YES', 'NO', 'NO']"},{"question":"def min_reward_difference(n: int, r: int, milestones: List[int]) -> int: In the Kingdom of XYZ, the government has decided to distribute rewards to its citizens for achieving various milestones. Each citizen has a unique milestone to achieve, and the government wants to ensure that they distribute the rewards fairly and efficiently. The milestones are given as an array of integers, where each integer represents the required units of achievement. Each citizen must be given a reward, but the total number of rewards the government can distribute is limited. The function distributes the rewards such that each citizen receives at least one reward, and the distribution is as evenly as possible. The goal is to minimize the difference between the maximum and minimum rewards given to any two citizens. >>> min_reward_difference(4, 10, [1, 2, 3, 4]) 1 >>> min_reward_difference(3, 7, [4, 5, 6]) 1","solution":"def min_reward_difference(n, r, milestones): # Sort the milestones to make the reward distribution easier to handle milestones.sort() # Calculate the minimum uniform distribution of rewards base_rewards = r // n extra_rewards = r % n rewards = [base_rewards] * n # Distribute the extra rewards as evenly as possible for i in range(extra_rewards): rewards[i] += 1 # Calculate the maximum and minimum rewards given max_reward = max(rewards) min_reward = min(rewards) # Return the difference between max and min rewards return max_reward - min_reward # Sample inputs from the task description to test the function print(min_reward_difference(4, 10, [1, 2, 3, 4])) # Expected Output: 1 print(min_reward_difference(3, 7, [4, 5, 6])) # Expected Output: 1"},{"question":"def check_sum_of_two_equals_third(A: int, B: int, C: int) -> str: Returns \\"YES\\" if the sum of any two integers is equal to the third integer. Otherwise, returns \\"NO\\". >>> check_sum_of_two_equals_third(2, 5, 7) \\"YES\\" >>> check_sum_of_two_equals_third(1, 2, 3) \\"YES\\" >>> check_sum_of_two_equals_third(0, 0, 1) \\"NO\\"","solution":"def check_sum_of_two_equals_third(A, B, C): Returns \\"YES\\" if the sum of any two integers is equal to the third integer. Otherwise, returns \\"NO\\". if A + B == C or B + C == A or C + A == B: return \\"YES\\" else: return \\"NO\\""},{"question":"def calculate_averages(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[List[float]]: Calculate the average of all contiguous subarrays of size K for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list containing tuples for each test case. Each tuple contains: - A tuple of two integers (N, K) where N is the size of the list and K is the size of the subarrays. - A list of N integers. Returns: List[List[float]]: A list containing the lists of averages of all contiguous subarrays of size K for each test case. >>> calculate_averages(2, [((5, 3), [1, 3, 2, 6, -1]), ((8, 4), [8, 7, 6, 8, 9, 7, 6, 5])]) [[2.00, 3.67, 2.33], [7.25, 7.50, 7.50, 7.50, 6.75]] >>> calculate_averages(1, [((6, 2), [1, 2, 3, 4, 5, 6])]) [[1.50, 2.50, 3.50, 4.50, 5.50]]","solution":"def calculate_averages(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] arr = test_cases[i][1] averages = [] window_sum = sum(arr[:K]) averages.append(round(window_sum / K, 2)) for j in range(K, N): window_sum = window_sum + arr[j] - arr[j - K] averages.append(round(window_sum / K, 2)) results.append(averages) return results"},{"question":"def calculate_total_score(task_scores, bonus, threshold): Calculate the total score for a team based on task scores and bonus. Parameters: - task_scores (list of int): Scores for each task completed. - bonus (int): Bonus points are awarded if more than 'threshold' tasks are completed. - threshold (int): Minimum number of tasks to be completed to earn the bonus. Returns: - int: Total score including any applicable bonus. Examples: >>> calculate_total_score([10, 20, 30, 40], 50, 3) 150 >>> calculate_total_score([15, 25], 40, 3) 40","solution":"def calculate_total_score(task_scores, bonus, threshold): Calculate the total score based on task scores and bonus. Parameters: - task_scores (list of int): Scores for each task completed. - bonus (int): Bonus points awarded if more than 'threshold' tasks are completed. - threshold (int): Minimum number of tasks to be completed to earn the bonus. Returns: - int: Total score including any applicable bonus. total_score = sum(task_scores) if len(task_scores) > threshold: total_score += bonus return total_score"},{"question":"def is_even_or_odd(sum_of_digits): Determines if the sum of digits is even or odd. Args: - sum_of_digits (int): The sum of the digits. Returns: - A string \\"Even\\" if the sum is even, \\"Odd\\" if the sum is odd. pass def sum_of_digits(n): Calculates the sum of the digits of a given integer. Args: - n (int): The integer to sum the digits of. Returns: - An integer representing the sum of the digits of n. pass def process_numbers(numbers): Processes a list of integers to determine if the sum of the digits of each number is even or odd. Args: - numbers (list of int): A list of integers. Returns: - A list of strings \\"Even\\" or \\"Odd\\" for each integer in numbers. pass def test_is_even_or_odd(): assert is_even_or_odd(6) == \\"Even\\" assert is_even_or_odd(15) == \\"Odd\\" assert is_even_or_odd(24) == \\"Even\\" assert is_even_or_odd(1) == \\"Odd\\" def test_sum_of_digits(): assert sum_of_digits(123) == 6 assert sum_of_digits(456) == 15 assert sum_of_digits(789) == 24 assert sum_of_digits(1000000000) == 1 def test_process_numbers(): assert process_numbers([123, 456, 789]) == [\\"Even\\", \\"Odd\\", \\"Even\\"] assert process_numbers([1, 22, 333, 4444]) == [\\"Odd\\", \\"Even\\", \\"Odd\\", \\"Even\\"] assert process_numbers([999999999, 88888888, 7777]) == [\\"Odd\\", \\"Even\\", \\"Even\\"] assert process_numbers([10, 20, 30, 40, 50]) == [\\"Odd\\", \\"Even\\", \\"Odd\\", \\"Even\\", \\"Odd\\"]","solution":"def is_even_or_odd(sum_of_digits): Determines if the sum of digits is even or odd. Args: - sum_of_digits (int): The sum of the digits. Returns: - A string \\"Even\\" if the sum is even, \\"Odd\\" if the sum is odd. return \\"Even\\" if sum_of_digits % 2 == 0 else \\"Odd\\" def sum_of_digits(n): Calculates the sum of the digits of a given integer. Args: - n (int): The integer to sum the digits of. Returns: - An integer representing the sum of the digits of n. return sum(int(digit) for digit in str(n)) def process_numbers(numbers): Processes a list of integers to determine if the sum of the digits of each number is even or odd. Args: - numbers (list of int): A list of integers. Returns: - A list of strings \\"Even\\" or \\"Odd\\" for each integer in numbers. results = [] for num in numbers: digit_sum = sum_of_digits(num) results.append(is_even_or_odd(digit_sum)) return results"},{"question":"def adventure_outcome(T, test_cases): Determines if John survives his adventure for each test case. Args: T (int): The number of test cases test_cases (List[Tuple[int, int, List[int]]]): A list of tuples, each containing: - E (int): Initial energy - N (int): Number of checkpoints - changes (List[int]): Energy change at each checkpoint Returns: List[str]: \\"SURVIVED\\" if John successfully traverses all checkpoints without his energy dropping to zero or below, otherwise \\"COLLAPSED\\". >>> adventure_outcome(3, [(10, 5, [-3, 4, -2, -1, 1]), (5, 3, [-1, -1, -4]), (8, 4, [2, -5, 3, -2])]) ['SURVIVED', 'COLLAPSED', 'SURVIVED'] >>> adventure_outcome(1, [(5, 3, [1, 1, 1])]) ['SURVIVED']","solution":"def adventure_outcome(T, test_cases): outcomes = [] for case in test_cases: E, N, changes = case survived = True for change in changes: E += change if E <= 0: survived = False break if survived: outcomes.append(\\"SURVIVED\\") else: outcomes.append(\\"COLLAPSED\\") return outcomes"},{"question":"def min_moves_to_remove_integers(n: int, arr: List[int]) -> int: Returns the minimum number of moves required to remove all integers from the array. If it is not possible to remove all integers, returns -1. >>> min_moves_to_remove_integers(4, [2, 4, 8, 16]) 4 >>> min_moves_to_remove_integers(2, [5, 7]) -1 >>> min_moves_to_remove_integers(1, [7]) -1 >>> min_moves_to_remove_integers(4, [2, 4, 4, 8]) 4 >>> min_moves_to_remove_integers(3, [3, 5, 7]) -1 >>> min_moves_to_remove_integers(3, [3, 6, 12]) 3 pass","solution":"def min_moves_to_remove_integers(n, arr): Returns the minimum number of moves required to remove all integers from the array. If it is not possible to remove all integers, returns -1. from collections import Counter # Count frequency of each element freq = Counter(arr) # Iterate each element to check if it can be used to remove other elements for key in sorted(freq): if freq[key] == 0: continue # Check if this key is a divisor of any other elements divisible_exists = False for candidate in freq: if candidate != key and candidate % key == 0: divisible_exists = True break # If the key is not a divisor of any other element, we cannot remove it if not divisible_exists: return -1 # If we can use this key to remove some elements for candidate in list(freq.keys()): if candidate % key == 0: del freq[candidate] # If we reach here, we were able to remove all elements return n"},{"question":"def findPattern(s: str, pat: str) -> int: Given a string s and a pattern pat, return the index of the first occurrence of the pattern in the string, or -1 if the pattern is not found. You are not allowed to use any built-in string searching functions. >>> findPattern(\\"hello\\", \\"ll\\") 2 >>> findPattern(\\"hello\\", \\"abc\\") -1","solution":"def findPattern(s, pat): Returns the index of the first occurrence of the pattern pat in the string s, or -1 if the pattern is not found. n, m = len(s), len(pat) # If pattern length is greater than the string length if m > n: return -1 # Loop through the string for i in range(n - m + 1): # Check if the substring of s starting at i matches pat if s[i:i + m] == pat: return i return -1"},{"question":"def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. >>> spiralOrder([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiralOrder([ ... [1] ... ]) [1] >>> spiralOrder([ ... [1, 2], ... [3, 4] ... ]) [1, 2, 4, 3] >>> spiralOrder([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) [1, 2, 3, 4, 5, 10, 15, 20, 25, 24, 23, 22, 21, 16, 11, 6, 7, 8, 9, 14, 19, 18, 17, 12, 13]","solution":"def spiralOrder(matrix): Returns the elements of the matrix in spiral order. # Define the directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] current_direction = 0 n = len(matrix) result = [] visited = [[False] * n for _ in range(n)] r = c = 0 for _ in range(n * n): result.append(matrix[r][c]) visited[r][c] = True next_r = r + directions[current_direction][0] next_c = c + directions[current_direction][1] if 0 <= next_r < n and 0 <= next_c < n and not visited[next_r][next_c]: r = next_r c = next_c else: current_direction = (current_direction + 1) % 4 r = r + directions[current_direction][0] c = c + directions[current_direction][1] return result"},{"question":"def longest_distinct_substring(s: str) -> int: Given a string consisting of only lowercase English letters, determine the maximum length of any segment where no character repeats. >>> longest_distinct_substring(\\"abcabcbb\\") 3 >>> longest_distinct_substring(\\"bbbbb\\") 1","solution":"def longest_distinct_substring(s): Returns the length of the longest segment with all distinct characters. n = len(s) max_length = 0 char_index_map = {} start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def range_sum_queries(n, arr, queries): Returns a list of sums for each query. :param n: int - The number of integers in the array :param arr: list - The array of integers :param queries: list of tuples - Each tuple contains starting and ending indices (L, R) for the query :return: list - Sums for each query Example: >>> range_sum_queries(5, [1, 2, 3, 4, 5], [(0, 2), (1, 3), (2, 4)]) [6, 9, 12] pass def parse_input(input_str): Parses the input string and returns the number of elements, the array of integers, and the list of queries. :param input_str: str - The input string in the specified format :return: tuple - Number of elements, array of integers, list of queries Example: >>> parse_input(\\"5 3n1 2 3 4 5n0 2n1 3n2 4\\") (5, [1, 2, 3, 4, 5], [(0, 2), (1, 3), (2, 4)]) pass def solve(input_str): Solves the range sum queries problem. :param input_str: str - The input string in the specified format :return: str - The output string with sums for each query separated by newlines Example: >>> solve(\\"5 3n1 2 3 4 5n0 2n1 3n2 4\\") \\"6n9n12\\" pass import pytest def test_parse_input(): input_str = \\"5 3n1 2 3 4 5n0 2n1 3n2 4\\" n, arr, queries = parse_input(input_str) assert n == 5 assert arr == [1, 2, 3, 4, 5] assert queries == [(0, 2), (1, 3), (2, 4)] def test_range_sum_queries(): n = 5 arr = [1, 2, 3, 4, 5] queries = [(0, 2), (1, 3), (2, 4)] result = range_sum_queries(n, arr, queries) assert result == [6, 9, 12] def test_solve(): input_str = \\"5 3n1 2 3 4 5n0 2n1 3n2 4\\" output_str = solve(input_str) assert output_str == \\"6n9n12\\" input_str = \\"5 1n-1 -2 -3 -4 -5n1 3\\" output_str = solve(input_str) assert output_str == \\"-9\\" input_str = \\"6 2n3 8 -2 4 1 7n0 5n2 4\\" output_str = solve(input_str) assert output_str == \\"21n3\\" # Run the tests pytest.main([__file__])","solution":"def range_sum_queries(n, arr, queries): Returns a list of sums for each query. :param n: int - The number of integers in the array :param arr: list - The array of integers :param queries: list of tuples - Each tuple contains starting and ending indices (L, R) for the query :return: list - Sums for each query # Calculate prefix sums prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] # Calculate sum for each query results = [] for l, r in queries: results.append(prefix_sums[r + 1] - prefix_sums[l]) return results def parse_input(input_str): data = input_str.strip().split('n') n, q = map(int, data[0].split()) arr = list(map(int, data[1].split())) queries = [] for i in range(2, 2 + q): l, r = map(int, data[i].split()) queries.append((l, r)) return n, arr, queries def solve(input_str): n, arr, queries = parse_input(input_str) results = range_sum_queries(n, arr, queries) return 'n'.join(map(str, results))"},{"question":"from typing import List def classify_ip(ip_address: str) -> str: Classify the given IP address as either 'Private' or 'Public'. Args: ip_address (str): The IP address to classify. Returns: str: 'Private' if the IP address is private, 'Public' otherwise. Examples: >>> classify_ip(\\"192.168.1.1\\") \\"Private\\" >>> classify_ip(\\"8.8.8.8\\") \\"Public\\" >>> classify_ip(\\"172.16.0.5\\") \\"Private\\" >>> classify_ip(\\"10.0.0.1\\") \\"Private\\" >>> classify_ip(\\"143.45.67.89\\") \\"Public\\" >>> classify_ip(\\"192.0.2.1\\") \\"Public\\" pass def classify_ip_addresses(ip_addresses: List[str]) -> List[str]: Classify a list of IP addresses as either 'Private' or 'Public'. Args: ip_addresses (List[str]): A list of IP addresses. Returns: List[str]: A list containing 'Private' or 'Public' for each IP address. Examples: >>> classify_ip_addresses([\\"192.168.1.1\\", \\"8.8.8.8\\", \\"172.16.0.5\\", \\"10.0.0.1\\", \\"143.45.67.89\\"]) [\\"Private\\", \\"Public\\", \\"Private\\", \\"Private\\", \\"Public\\"] pass","solution":"def classify_ip(ip_address): Classify the given IP address as either 'Private' or 'Public'. parts = list(map(int, ip_address.split('.'))) if parts[0] == 10: return \\"Private\\" elif parts[0] == 172 and 16 <= parts[1] <= 31: return \\"Private\\" elif parts[0] == 192 and parts[1] == 168: return \\"Private\\" else: return \\"Public\\" def classify_ip_addresses(ip_addresses): results = [] for ip in ip_addresses: results.append(classify_ip(ip)) return results"},{"question":"def max_growth_rate(n: int, plants: List[List[int]]) -> int: Calculate the maximum possible sum of growth rates over all possible (A, B, C) values. Args: n (int): The number of plants studied. plants (List[List[int]]): A list of lists, where each inner list contains four integers representing the soil type, units of sunlight, water amount, and growth rate for a plant. Returns: int: The maximum possible sum of growth rates over all possible (A, B, C) values. >>> max_growth_rate(5, [[1, 3, 5, 10], [2, 4, 6, 15], [3, 5, 7, 20], [1, 6, 8, 25], [2, 7, 9, 30]]) 100 >>> max_growth_rate(3, [[0, 0, 0, 5], [1, 2, 3, 10], [2, 4, 6, 15]]) 30","solution":"def max_growth_rate(n, plants): max_growth = 0 # Calculate total growth rate directly as g_i since we can optimize (A, B, C) to be (g_si, g_ui, g_wi) respectively for plant in plants: s, u, w, g = plant max_growth += g return max_growth # Example Usage with provided input n = 5 plants = [ [1, 3, 5, 10], [2, 4, 6, 15], [3, 5, 7, 20], [1, 6, 8, 25], [2, 7, 9, 30] ] # Output should be 100 print(max_growth_rate(n, plants))"},{"question":"def sum_odd_indexed_positions(T: int, strings: List[str]) -> List[int]: Calculate the sum of 1-based positions of characters that appear at odd positions in each string. Parameters: T (int): Number of test cases strings (list of str): List of strings for each test case Returns: list of int: List containing sum of 1-based positions of odd indexed characters Examples: >>> sum_odd_indexed_positions(1, ['abcde']) == [9] >>> sum_odd_indexed_positions(3, ['abcde', 'fghij', 'klmno']) == [9, 9, 9]","solution":"def sum_odd_indexed_positions(T, strings): Given T test cases containing strings of lowercase alphabets, this function returns a list of sums of 1-based positions of characters that appear at odd positions in each string. Parameters: T (int): Number of test cases strings (list of str): List of strings for each test case Returns: list of int: List containing sum of 1-based positions of odd indexed characters results = [] for s in strings: # Calculate the sum of 1-based positions (which are odd indexed in 0-based indexing) sum_positions = sum(i + 1 for i in range(0, len(s), 2)) results.append(sum_positions) return results"},{"question":"def sum_of_primes(n: int) -> int: Write a function that takes an integer and returns the sum of all prime numbers less than or equal to that integer. >>> sum_of_primes(10) == 17 # 2 + 3 + 5 + 7 = 17 >>> sum_of_primes(5) == 10 # 2 + 3 + 5 = 10 >>> sum_of_primes(2) == 2 # 2 = 2 >>> sum_of_primes(1) == 0 # There are no primes less than or equal to 1","solution":"def sum_of_primes(n: int) -> int: if n < 2: return 0 # Sieve of Eratosthenes algorithm to find all primes up to n sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes p = 2 while (p * p <= n): if sieve[p] == True: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 # Sum all primes less than or equal to n return sum(i for i in range(n + 1) if sieve[i])"},{"question":"class MaximumSubarraySum: A class to represent a Maximum Subarray Sum finder. Methods: __init__(self, nums: List[int], k: int) -> None Initializes the object with the given integer array 'nums' and the integer 'k'. maxSum(self) -> int Returns the maximum sum of a subarray with size 'k'. Example Usage: >>> maxSubarraySum = MaximumSubarraySum([1,2,3,4,5], 3) >>> maxSubarraySum.maxSum() 12 >>> maxSubarraySum = MaximumSubarraySum([100,200,300,400], 2) >>> maxSubarraySum.maxSum() 700 def __init__(self, nums: List[int], k: int) -> None: pass def maxSum(self) -> int: pass from typing import List def test_max_sum_example1(): maxSubarraySum = MaximumSubarraySum([1,2,3,4,5], 3) assert maxSubarraySum.maxSum() == 12 def test_max_sum_example2(): maxSubarraySum = MaximumSubarraySum([1,1,1,1,1,1,1,1], 4) assert maxSubarraySum.maxSum() == 4 def test_max_sum_example3(): maxSubarraySum = MaximumSubarraySum([100,200,300,400], 2) assert maxSubarraySum.maxSum() == 700 def test_max_sum_empty_array(): maxSubarraySum = MaximumSubarraySum([], 2) assert maxSubarraySum.maxSum() == 0 def test_max_sum_k_larger_than_array(): maxSubarraySum = MaximumSubarraySum([1,2], 3) assert maxSubarraySum.maxSum() == 0 def test_max_sum_negative_values(): maxSubarraySum = MaximumSubarraySum([-1, -2, -3, -4, -5], 2) assert maxSubarraySum.maxSum() == -3 def test_max_sum_all_zeros(): maxSubarraySum = MaximumSubarraySum([0, 0, 0, 0, 0], 3) assert maxSubarraySum.maxSum() == 0 def test_max_sum_mixed_signs(): maxSubarraySum = MaximumSubarraySum([-1, 2, -3, 4, -5, 6], 3) assert maxSubarraySum.maxSum() == 5","solution":"class MaximumSubarraySum: def __init__(self, nums, k): self.nums = nums self.k = k def maxSum(self): if not self.nums or self.k <= 0 or self.k > len(self.nums): return 0 max_sum = current_sum = sum(self.nums[:self.k]) for i in range(self.k, len(self.nums)): current_sum += self.nums[i] - self.nums[i - self.k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Returns the minimum path sum from the top-left to the bottom-right of a given grid. >>> shortest_path([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 7 >>> shortest_path([ [1, 2, 5], [3, 2, 1] ]) 6","solution":"def shortest_path(grid): Returns the minimum path sum from the top-left to the bottom-right of a given grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) for r in range(rows): for c in range(cols): if r == 0 and c == 0: continue # starting point elif r == 0: grid[r][c] += grid[r][c - 1] # can only come from the left elif c == 0: grid[r][c] += grid[r - 1][c] # can only come from above else: grid[r][c] += min(grid[r - 1][c], grid[r][c - 1]) # take the minimum of coming from left or above return grid[rows - 1][cols - 1]"},{"question":"def matrix_addition(n, m, matrix_a, matrix_b): Performs element-wise addition of two n x m matrices. Args: n (int): number of rows m (int): number of columns matrix_a (list of list of int): first matrix matrix_b (list of list of int): second matrix Returns: list of list of int: resulting matrix after element-wise addition >>> matrix_addition(2, 3, [[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]) [[8, 10, 12], [14, 16, 18]] >>> matrix_addition(2, 2, [[0, 0], [0, 0]], [[1, 1], [1, 1]]) [[1, 1], [1, 1]] >>> matrix_addition(2, 2, [[-1, -2], [-3, -4]], [[1, 2], [3, 4]]) [[0, 0], [0, 0]] >>> matrix_addition(1, 1, [[5]], [[10]]) [[15]] >>> matrix_addition(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) [[10, 10, 10], [10, 10, 10], [10, 10, 10]]","solution":"def matrix_addition(n, m, matrix_a, matrix_b): Performs element-wise addition of two n x m matrices. Args: n (int): number of rows m (int): number of columns matrix_a (list of list of int): first matrix matrix_b (list of list of int): second matrix Returns: list of list of int: resulting matrix after element-wise addition matrix_c = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): matrix_c[i][j] = matrix_a[i][j] + matrix_b[i][j] return matrix_c"},{"question":"def is_palindrome(n: int) -> bool: Determines if a given positive integer is a palindrome. >>> is_palindrome(121) # True >>> is_palindrome(123) # False >>> is_palindrome(12321) # True >>> is_palindrome(1234321) # True >>> is_palindrome(123456789) # False >>> is_palindrome(1000000001) # True","solution":"def is_palindrome(n: int) -> bool: Determines if a given positive integer is a palindrome. Parameters: n (int): The positive integer to check (1 ≤ n ≤ 10^9). Returns: bool: True if n is a palindrome, False otherwise. str_n = str(n) return str_n == str_n[::-1]"},{"question":"def check_identification_codes(codes): Checks if each identification code in the list follows the alternating letter-digit format, starting with a letter. >>> check_identification_codes([\\"A1B2C3\\", \\"1A2B3C\\", \\"A111B2\\"]) ['VALID', 'INVALID', 'INVALID'] >>> check_identification_codes([\\"M2N3P4Q5\\", \\"Z9Y4X7\\"]) ['VALID', 'VALID']","solution":"def check_identification_codes(codes): Checks if each identification code in the list follows the alternating letter-digit format, starting with a letter. results = [] for code in codes: is_valid = True if len(code) < 2 or not code[0].isalpha(): is_valid = False else: for i in range(1, len(code)): if i % 2 == 1 and not code[i].isdigit(): is_valid = False break elif i % 2 == 0 and not code[i].isalpha(): is_valid = False break results.append(\\"VALID\\" if is_valid else \\"INVALID\\") return results"},{"question":"def nthTerm(n: int) -> int: Returns the nth term of the series where the nth term is defined as the sum of the first n natural numbers each increased by n. nthTerm(1) -> 1 nthTerm(2) -> 5 nthTerm(3) -> 12 nthTerm(10) -> 145 nthTerm(25) -> 925","solution":"def nthTerm(n): Returns the nth term of the series where the nth term is defined as the sum of the first n natural numbers each increased by n. That is, nth term = n + (n+1) + (n+2) + ... + (2n-1). Parameters: n: an integer representing the nth term to find Returns: An integer representing the nth term of the series # Calculate the nth term using the formula n * (3n - 1) / 2 nth_term = n * (3*n - 1) // 2 return nth_term"},{"question":"def is_balanced(s: str) -> str: Returns 'YES' if the given string of brackets is balanced, otherwise returns 'NO'. >>> is_balanced(\\"{[()]}\\") \\"YES\\" >>> is_balanced(\\"{[(])}\\") \\"NO\\" >>> is_balanced(\\"{{[[(())]]}}\\") \\"YES\\" # Your code here def process_test_cases(test_cases: List[str]) -> List[str]: Processes each test case and returns corresponding results. >>> process_test_cases([\\"{[()]}\\", \\"{[(])}\\", \\"{{[[(())]]}}\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([\\"([])\\", \\"((())\\", \\")\\", \\"\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] # Your code here","solution":"def is_balanced(s): Returns 'YES' if the given string of brackets is balanced, otherwise returns 'NO'. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if stack == [] or stack.pop() != matching_bracket[char]: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(test_cases): Processes each test case and returns corresponding results. results = [] for s in test_cases: results.append(is_balanced(s)) return results"},{"question":"def rotate_buffer(n: int, k: int) -> List[int]: Perform k right rotations on a circular buffer of size n initialized with integers from 1 to n. :param n: The size of the buffer :param k: The number of right rotations to be performed :return: The resulting sequence after rotations Example: >>> rotate_buffer(5, 2) [4, 5, 1, 2, 3]","solution":"def rotate_buffer(n, k): Perform k right rotations on a circular buffer of size n initialized with integers from 1 to n. # Construct the initial buffer [1, 2, 3, ..., n] buffer = list(range(1, n + 1)) # Compute the effective number of rotations to avoid unnecessary full cycles k %= n # Perform the rotation rotated_buffer = buffer[-k:] + buffer[:-k] return rotated_buffer # Example usage: # print(rotate_buffer(5, 2)) # Expected output: [4, 5, 1, 2, 3]"},{"question":"def max_subsequence_sum(N: int, a: List[int]) -> int: Given an integer N and a list of N integers, find the maximum sum of any subsequence in the array. >>> max_subsequence_sum(5, [1, -2, 3, 4, -1]) 8 >>> max_subsequence_sum(8, [-4, -2, -3, -1, -7, -5, -6, -8]) -1","solution":"def max_subsequence_sum(N, a): max_neg = float('-inf') sum_positives = 0 all_negative = True for num in a: if num > 0: sum_positives += num all_negative = False else: if num > max_neg: max_neg = num if all_negative: return max_neg else: return sum_positives"},{"question":"def min_operations_to_sort(A): Returns the minimum number of adjacent swaps needed to make the sequence A non-decreasing. Args: A: list of integers Returns: int: minimum number of swaps Test cases: >>> min_operations_to_sort([1, 2, 3, 4, 5, 6]) 0 >>> min_operations_to_sort([6, 5, 4, 3, 2, 1]) 15 >>> min_operations_to_sort([3, 1, 2, 5, 4, 6]) 3 >>> min_operations_to_sort([1]) 0 >>> min_operations_to_sort([1, 2]) 0 >>> min_operations_to_sort([2, 1]) 1","solution":"def min_operations_to_sort(A): Returns the minimum number of adjacent swaps needed to make the sequence A non-decreasing. n = len(A) swaps = 0 for i in range(n): for j in range(0, n-i-1): if A[j] > A[j+1]: A[j], A[j+1] = A[j+1], A[j] swaps += 1 return swaps"},{"question":"def add(a, b): Compute the sum of two non-negative integers without using the '+' operator. >>> add(1, 2) 3 >>> add(2, 3) 5 >>> add(0, 0) 0 >>> add(0, 4) 4 >>> add(1000000000, 1000000000) 2000000000 >>> add(2147483647, 1) 2147483648 >>> add(10**9, 9) 1000000009 >>> add(5, 5) 10 >>> add(123456, 123456) 246912","solution":"def add(a, b): Returns the sum of a and b without using the '+' operator. # Iterate until there are no carries left while b != 0: # Carry now contains common set bits of a and b carry = a & b # Sum of bits of a and b where at least one of the bits is not set a = a ^ b # Carry is shifted by one so that adding it to a gives the required sum b = carry << 1 return a"},{"question":"def min_substrings_with_unique_chars(s: str) -> int: Returns the minimum number of substrings with unique characters. >>> min_substrings_with_unique_chars(\\"abac\\") 2 >>> min_substrings_with_unique_chars(\\"abcdefghijklmnopqrstuvwxyz\\") 1 >>> min_substrings_with_unique_chars(\\"aa\\") 2","solution":"def min_substrings_with_unique_chars(s): Returns the minimum number of substrings with unique characters. substrings_count = 0 unique_chars = set() for char in s: if char in unique_chars: substrings_count += 1 unique_chars = set() unique_chars.add(char) return substrings_count + 1 if unique_chars else substrings_count"},{"question":"def can_remove_largest_edge_and_keep_connected(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given a connected undirected graph with weighted edges, determine if it is possible to remove exactly one edge from the graph such that the resulting graph is still connected and the weight of that edge is the largest among all edges in the original graph. If it is possible, return the largest edge weight that can be removed while maintaining connectivity. If it is not possible, return -1. >>> can_remove_largest_edge_and_keep_connected(4, 4, [(1, 2, 3), (2, 3, 10), (3, 4, 5), (4, 1, 7)]) 10 >>> can_remove_largest_edge_and_keep_connected(3, 2, [(1, 2, 5), (2, 3, 8)]) -1 from typing import List, Tuple # Test cases def test_can_remove_largest_edge_and_keep_connected(): # Test case 1 n = 4 m = 4 edges = [(1, 2, 3), (2, 3, 10), (3, 4, 5), (4, 1, 7)] result = can_remove_largest_edge_and_keep_connected(n, m, edges) assert result == 10 # Test case 2 n = 3 m = 2 edges = [(1, 2, 5), (2, 3, 8)] result = can_remove_largest_edge_and_keep_connected(n, m, edges) assert result == -1 # Test case 3 n = 5 m = 6 edges = [(1, 2, 2), (1, 3, 3), (2, 4, 1), (4, 5, 4), (3, 5, 6), (1, 5, 5)] result = can_remove_largest_edge_and_keep_connected(n, m, edges) assert result == 6 # Test case 4 n = 5 m = 5 edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 10000)] result = can_remove_largest_edge_and_keep_connected(n, m, edges) assert result == 10000 # Execute tests test_can_remove_largest_edge_and_keep_connected()","solution":"def can_remove_largest_edge_and_keep_connected(n, m, edges): from collections import defaultdict import heapq # Initialize the adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Function to remove an edge and perform DFS to check connectivity def is_connected(removed_edge): visited = set() stack = [1] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor, weight in graph[node]: if (node, neighbor, weight) != removed_edge and (neighbor, node, weight) != removed_edge: stack.append(neighbor) return len(visited) == n # Sort edges by weight in descending order to check the largest ones first edges = sorted(edges, key=lambda x: -x[2]) for edge in edges: if is_connected(edge): return edge[2] return -1"},{"question":"def longest_palindrome(s: str) -> int: Determine the length of the longest palindrome that can be formed using the characters from the input string. :param s: Input string consisting of lowercase English letters :return: Length of the longest palindrome >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"a\\") 1","solution":"def longest_palindrome(s): Determine the length of the longest palindrome that can be formed using the characters from the input string. :param s: Input string consisting of lowercase English letters :return: Length of the longest palindrome from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Determine the minimum number of operations required to transform the string into a palindrome. >>> min_operations_to_palindrome(4, \\"abca\\") 1 >>> min_operations_to_palindrome(5, \\"abcba\\") 0 >>> min_operations_to_palindrome(1, \\"a\\") 0 >>> min_operations_to_palindrome(2, \\"ab\\") 1 >>> min_operations_to_palindrome(6, \\"abccba\\") 0 >>> min_operations_to_palindrome(7, \\"racecar\\") 0 >>> min_operations_to_palindrome(6, \\"abcdef\\") 3 >>> min_operations_to_palindrome(7, \\"abcdefg\\") 3","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of operations required to transform the string into a palindrome. operations = 0 left, right = 0, n - 1 while left < right: if s[left] != s[right]: operations += 1 left += 1 right -= 1 return operations"},{"question":"def longest_bitonic_subsequence(arr: List[int]) -> int: Find the length of the longest bitonic subsequence from given list of integers. A sequence is bitonic if it is first strictly increasing and then strictly decreasing. A purely increasing or purely decreasing sequence is also considered as bitonic with zero length of the respective decreasing or increasing part. >>> longest_bitonic_subsequence([12, 4, 78, 90, 45, 23]) 5 >>> longest_bitonic_subsequence([10, 20, 30, 40, 50, 40, 30, 20]) 8 >>> longest_bitonic_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_bitonic_subsequence([5, 4, 3, 2, 1]) 5 >>> longest_bitonic_subsequence([1, 3, 2]) 3 >>> longest_bitonic_subsequence([]) 0 # Your implementation here","solution":"def longest_bitonic_subsequence(arr): n = len(arr) if n == 0: return 0 # Initialize the increasing and decreasing subsequences arrays inc = [1] * n dec = [1] * n # Compute the longest increasing subsequence (LIS) for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Compute the longest decreasing subsequence (LDS) for i in reversed(range(n-1)): for j in range(i+1, n): if arr[i] > arr[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Find the maximum length of bitonic subsequence max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) # -1 is done to not double count the peak element return max_len def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): N = int(data[index]) index += 1 sequence = list(map(int, data[index:index + N])) index += N results.append(longest_bitonic_subsequence(sequence)) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def remove_duplicates(nums): Removes the duplicates from the sorted array in-place. Args: nums (list): Sorted list of integers Returns: int: The new length of the array with unique elements >>> nums = [1, 1, 2] >>> length = remove_duplicates(nums) >>> length 2 >>> nums[:length] [1, 2] >>> nums = [0,0,1,1,1,2,2,3,3,4] >>> length = remove_duplicates(nums) >>> length 5 >>> nums[:length] [0, 1, 2, 3, 4]","solution":"def remove_duplicates(nums): Removes the duplicates from the sorted array in-place. Args: nums (list): Sorted list of integers Returns: int: The new length of the array with unique elements if not nums: return 0 write_index = 1 for read_index in range(1, len(nums)): if nums[read_index] != nums[read_index - 1]: nums[write_index] = nums[read_index] write_index += 1 return write_index"},{"question":"def can_reach_end(grid): Determines if the robot can reach the bottom-right corner of the grid. Parameters: grid (list of list of int): The 2D grid representing the room. Returns: bool: True if the robot can reach the bottom-right corner, otherwise False. pass # Example test cases def test_can_reach_end(): # Test case 1 grid1 = [ [0, 0, 1], [0, 0, 0], [1, 0, 0] ] assert can_reach_end(grid1) == True # Test case 2 grid2 = [ [0, 1, 1], [1, 0, 0], [1, 1, 0] ] assert can_reach_end(grid2) == False # Test case 3 (single cell) grid3 = [ [0] ] assert can_reach_end(grid3) == True # Test case 4 (blocked start) grid4 = [ [1, 0], [0, 0] ] assert can_reach_end(grid4) == False # Test case 5 (blocked end) grid5 = [ [0, 0], [0, 1] ] assert can_reach_end(grid5) == False # Test case 6 (small grid reachable) grid6 = [ [0, 0], [0, 0] ] assert can_reach_end(grid6) == True # Test case 7 (large grid with path) grid7 = [ [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 1, 1, 0], [1, 0, 0, 0, 0] ] assert can_reach_end(grid7) == True # Test case 8 (large grid without path) grid8 = [ [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0], [1, 0, 0, 1, 0] ] assert can_reach_end(grid8) == False","solution":"def can_reach_end(grid): Determines if the robot can reach the bottom-right corner of the grid. Parameters: grid (list of list of int): The 2D grid representing the room. Returns: bool: True if the robot can reach the bottom-right corner, otherwise False. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False] * n for _ in range(m)] stack = [(0, 0)] while stack: x, y = stack.pop() if (x, y) == (m - 1, n - 1): return True if not visited[x][y]: visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: stack.append((nx, ny)) return False"},{"question":"from typing import List def sum_of_layers(N: int) -> int: Returns the sum of all numbers used in constructing the house with N layers. >>> sum_of_layers(3) 14 >>> sum_of_layers(1) 1 >>> sum_of_layers(4) 30 def solve(T: int, test_cases: List[int]) -> List[int]: Process multiple test cases and return results for each case as a list. >>> solve(3, [3, 1, 4]) [14, 1, 30] >>> solve(2, [2, 5]) [5, 55] >>> solve(1, [6]) [91]","solution":"def sum_of_layers(N): Returns the sum of all numbers used in constructing the house with N layers. return sum(i * i for i in range(1, N + 1)) def solve(T, test_cases): Process multiple test cases and return results for each case as a list. results = [] for N in test_cases: results.append(sum_of_layers(N)) return results"},{"question":"def is_palindrome(array): This function checks if the given array is a palindrome. :param array: List of integers :return: \\"YES\\" if the array is a palindrome, otherwise \\"NO\\" >>> is_palindrome([1, 2, 3, 2, 1]) 'YES' >>> is_palindrome([1, 2, 3, 4]) 'NO' >>> is_palindrome([7]) 'YES'","solution":"def is_palindrome(array): This function checks if the given array is a palindrome. :param array: List of integers :return: \\"YES\\" if the array is a palindrome, otherwise \\"NO\\" if array == array[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def most_frequent_character(s: str) -> str: Create a function that takes a string as input and returns the character that appears the most frequently. If there is a tie, return the character that appears first in the string. The input string will contain only lowercase letters and no spaces. >>> most_frequent_character(\\"hello\\") \\"l\\" >>> most_frequent_character(\\"aabbbcccc\\") \\"c\\" >>> most_frequent_character(\\"abcabc\\") \\"a\\" >>> most_frequent_character(\\"abcbaac\\") \\"a\\"","solution":"def most_frequent_character(s: str) -> str: from collections import defaultdict frequency = defaultdict(int) for char in s: frequency[char] += 1 max_freq = -1 result_char = None for char in s: if frequency[char] > max_freq: max_freq = frequency[char] result_char = char return result_char"},{"question":"def distribute_participants(T: int, test_cases: List[Tuple[int, int]]) -> List[List[int]]: Sam is organizing a marathon event where participants are grouped into teams. He needs a program to help him distribute participants into teams as evenly as possible. Each team should have at least one participant, and the number of participants in the teams should vary by no more than one. INPUT The first line contains an integer T, the number of test cases (1 ≤ T ≤ 20). Each of the next T lines contains two integers P (1 ≤ P ≤ 100) and N (1 ≤ N ≤ 50): - P is the number of participants. - N is the number of teams. OUTPUT For each test case, output N integers in a single line representing the number of participants in each team. The integers should be in non-decreasing order. SAMPLE INPUT 3 10 3 15 4 8 2 SAMPLE OUTPUT 3 3 4 3 4 4 4 4 4 Example usage: >>> distribute_participants(1, [(10, 3)]) [[3, 3, 4]] >>> distribute_participants(1, [(15, 4)]) [[3, 4, 4, 4]] >>> distribute_participants(1, [(8, 2)]) [[4, 4]]","solution":"def distribute_participants(T, test_cases): results = [] for i in range(T): P, N = test_cases[i] base_number = P // N remainder = P % N distribution = [base_number + 1] * remainder + [base_number] * (N - remainder) distribution.sort() results.append(distribution) return results"},{"question":"def total_lines_of_code(n: int, productivity_hours: List[Tuple[int, int]]) -> int: Calculate the total number of lines of code written by all developers. Parameters: n (int): Number of developers productivity_hours (list of tuples): List of tuples where each tuple contains (productivity rate, hours worked) Returns: int: Total lines of code written by all developers >>> total_lines_of_code(3, [(10, 5), (20, 4), (30, 6)]) 310 >>> total_lines_of_code(2, [(50, 8), (40, 7)]) 680","solution":"def total_lines_of_code(n, productivity_hours): Calculate the total number of lines of code written by all developers. Parameters: n (int): Number of developers productivity_hours (list of tuples): List of tuples where each tuple contains (productivity rate, hours worked) Returns: int: Total lines of code written by all developers total_lines = 0 for p, h in productivity_hours: total_lines += p * h return total_lines"},{"question":"def min_operations(s: str, t: str, mappings: List[Tuple[str, str]]) -> int: Determine the minimum number of operations required to transform string \`s\` into string \`t\` using the allowed character mappings. >>> min_operations(\\"abcd\\", \\"bcda\\", [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'a')]) == 4 >>> min_operations(\\"abc\\", \\"def\\", [('a', 'd'), ('b', 'e'), ('c', 'f')]) == 3 >>> min_operations(\\"abcd\\", \\"mnop\\", [('a', 'm'), ('b', 'n'), ('c', 'o'), ('d', 'p')]) == 4 >>> min_operations(\\"abcdefgh\\", \\"ijklmnop\\", [('a', 'i'), ('b', 'j'), ('c', 'k'), ('d', 'l'), ('e', 'm'), ('f', 'n'), ('g', 'o'), ('h', 'p')]) == 8 >>> min_operations(\\"abc\\", \\"abd\\", [('a', 'b')]) == -1","solution":"def min_operations(s, t, mappings): from collections import defaultdict import sys # Create a graph of allowed transformations graph = defaultdict(set) for a, b in mappings: graph[a].add(b) graph[b].add(a) # Function to perform BFS to find shortest transformation path def bfs(src, dest): if src == dest: return 0 queue = [(src, 0)] visited = set([src]) while queue: cur, steps = queue.pop(0) for neighbor in graph[cur]: if neighbor == dest: return steps + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return sys.maxsize total_operations = 0 for char_s, char_t in zip(s, t): if char_s != char_t: min_steps = bfs(char_s, char_t) if min_steps == sys.maxsize: return -1 total_operations += min_steps return total_operations"},{"question":"from typing import List def min_steps_to_reach_end(N: int, M: int, grid: List[str]) -> int: Returns the minimum number of steps required to reach (N-1, M-1) from (0, 0) in a NxM grid. If it's not possible to reach the destination, it returns -1. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[str]): NxM grid represented as a list of strings. Returns: int: The minimum steps to reach the destination, else -1 if unreachable. Examples: >>> min_steps_to_reach_end(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_steps_to_reach_end(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) -1","solution":"from collections import deque def min_steps_to_reach_end(N, M, grid): Returns the minimum number of steps required to reach (N-1, M-1) from (0, 0) in a NxM grid. If it's not possible to reach the destination, it returns -1. if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 # Directions: right, down, left, up directions = [(0,1), (1,0), (0,-1), (-1,0)] visited = [[False for _ in range(M)] for _ in range(N)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() if (x, y) == (N-1, M-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps+1)) return -1"},{"question":"def max_orders(n, times): Determines the maximum number of orders that can be packed without overlapping in their time windows. :param n: Number of orders :type n: int :param times: List of tuples, each containing the start and end time of the time window for each order :type times: list of tuples :return: Maximum number of non-overlapping orders :rtype: int # Implement your solution here # Example Unit Tests def test_max_orders_basic(): times = [(1, 3), (2, 5), (4, 6), (6, 7)] n = 4 assert max_orders(n, times) == 3 def test_max_orders_overlap(): times = [(1, 2), (2, 4), (3, 5)] n = 3 assert max_orders(n, times) == 2 def test_max_orders_no_overlap(): times = [(1, 2), (3, 4), (5, 6)] n = 3 assert max_orders(n, times) == 3 def test_max_orders_single_order(): times = [(0, 10)] n = 1 assert max_orders(n, times) == 1 def test_max_orders_custom_case(): times = [(1, 3), (3, 5), (0, 2), (4, 6), (5, 7)] n = 5 assert max_orders(n, times) == 3","solution":"def max_orders(n, times): Determines the maximum number of orders that can be packed without overlapping in their time windows. :param n: Number of orders :type n: int :param times: List of tuples, each containing the start and end time of the time window for each order :type times: list of tuples :return: Maximum number of non-overlapping orders :rtype: int # Sort orders by their end time times.sort(key=lambda x: x[1]) # Initialize variables to keep track of the end time of the last packed order and count of packed orders last_end_time = -1 count = 0 for start, end in times: if start >= last_end_time: # Pack this order and update the last end time last_end_time = end count += 1 return count"},{"question":"from typing import List def list_intersection(list1: List[int], list2: List[int]) -> List[int]: Takes two lists of integers and returns a list containing the elements common to both lists, without duplicates. The resulting list is sorted in ascending order. Examples: >>> list_intersection([1, 2, 2, 1], [2, 2]) [2] >>> list_intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> list_intersection([3, 3, 3], [3, 3, 3, 3]) [3] >>> list_intersection([1, 2, 3], [4, 5, 6]) [] >>> list_intersection([], [1, 2, 3]) [] >>> list_intersection([1, 2, 3], []) [] >>> list_intersection([1, 10**9], [-10**9, 0]) [] >>> list_intersection([-1, -2, -3], [-3, -4, -1]) [-3, -1]","solution":"from typing import List def list_intersection(list1: List[int], list2: List[int]) -> List[int]: # Use sets to find the common elements and use set intersection set1 = set(list1) set2 = set(list2) common_elements = set1.intersection(set2) # Convert to list and sort before returning return sorted(common_elements)"},{"question":"def game_winner(S: str) -> str: Determines the winner of the game given the starting string S. >>> game_winner('ababa') 'Alice' >>> game_winner('aaaa') 'Bob' # Implement the function from solution import game_winner def test_game_winner_odd_length_string(): # Alice wins when the length of the string is odd assert game_winner('ababa') == \\"Alice\\" assert game_winner('abcde') == \\"Alice\\" assert game_winner('a') == \\"Alice\\" def test_game_winner_even_length_string(): # Bob wins when the length of the string is even assert game_winner('aaaa') == \\"Bob\\" assert game_winner('abab') == \\"Bob\\" assert game_winner('abcdef') == \\"Bob\\" def test_game_winner_single_character(): # Edge case: single character string assert game_winner('a') == \\"Alice\\" def test_game_winner_multiple_characters_same(): # Every character is same and the length is even assert game_winner('aa') == \\"Bob\\" assert game_winner('bbbb') == \\"Bob\\" # Running all tests def run_all_tests(): test_game_winner_odd_length_string() test_game_winner_even_length_string() test_game_winner_single_character() test_game_winner_multiple_characters_same() print(\\"All tests passed!\\") run_all_tests()","solution":"def game_winner(S): Determines the winner of the game given the starting string S. Parameters: S (str): The initial string. Returns: str: \\"Alice\\" if Alice wins the game, otherwise \\"Bob\\". # If the length of the string is odd, Alice will have the last move # If the length of the string is even, Bob will have the last move if len(S) % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def max_gold_coins(m, n, grid): Returns the maximum number of gold coins that can be collected starting from any cell in the first column and reaching any cell in the last column. >>> max_gold_coins(3, 4, [ ... [1, 3, 1, 5], ... [2, 2, 4, 1], ... [5, 0, 2, 3] ... ]) 16 >>> max_gold_coins(4, 4, [ ... [1, 3, 3, 2], ... [2, 1, 4, 1], ... [0, 6, 4, 7], ... [0, 4, 2, 5] ... ]) 19 >>> max_gold_coins(1, 1, [ ... [10] ... ]) 10 >>> max_gold_coins(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_gold_coins(3, 3, [ ... [1000, 1000, 1000], ... [1000, 1000, 1000], ... [1000, 1000, 1000] ... ]) 3000","solution":"def max_gold_coins(m, n, grid): Returns the maximum number of gold coins that can be collected starting from any cell in the first column and reaching any cell in the last column. # Initialize a DP table to store the maximum coins collected up to each cell dp = [[0] * n for _ in range(m)] # Fill the first column with initial values from grid for i in range(m): dp[i][0] = grid[i][0] # Process each column from second to the last for j in range(1, n): for i in range(m): # Get the maximum coins we can collect from the three possible previous cells best_previous = dp[i][j-1] if i > 0: best_previous = max(best_previous, dp[i-1][j-1]) if i < m-1: best_previous = max(best_previous, dp[i+1][j-1]) # Update the current cell with the maximum coins collected dp[i][j] = grid[i][j] + best_previous # The result is the maximum value in the last column return max(dp[i][n-1] for i in range(m))"},{"question":"def encode_message(message: str, shift: int) -> str: Encode a message by shifting each letter by a fixed number of positions in the alphabet. >>> encode_message(\\"hello\\", 3) \\"khoor\\" >>> encode_message(\\"xyz\\", -2) \\"vwx\\" def process_input(input_str: str) -> str: Process input string to extract message and shift value, then encode the message. >>> process_input(\\"hello 3\\") \\"khoor\\" >>> process_input(\\"xyz -2\\") \\"vwx\\" # Test cases def test_encode_message_with_positive_shift(): assert encode_message(\\"hello\\", 3) == \\"khoor\\" def test_encode_message_with_negative_shift(): assert encode_message(\\"xyz\\", -2) == \\"vwx\\" def test_encode_message_with_large_shift(): assert encode_message(\\"abc\\", 1000) == \\"mno\\" def test_encode_message_with_negative_large_shift(): assert encode_message(\\"mno\\", -1000) == \\"abc\\" def test_process_input_function(): assert process_input(\\"hello 3\\") == \\"khoor\\" assert process_input(\\"xyz -2\\") == \\"vwx\\" assert process_input(\\"abc 1000\\") == \\"mno\\" assert process_input(\\"mno -1000\\") == \\"abc\\" def test_encode_message_with_zero_shift(): assert encode_message(\\"abc\\", 0) == \\"abc\\" assert encode_message(\\"xyz\\", 0) == \\"xyz\\"","solution":"def encode_message(message, shift): shift = shift % 26 # Handle large or negative shifts by using modulo 26 encoded_message = [] for char in message: new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) encoded_message.append(new_char) return ''.join(encoded_message) def process_input(input_str): parts = input_str.split() message = parts[0] shift = int(parts[1]) return encode_message(message, shift)"},{"question":"def sort_ingredients(input_string: str) -> str: Sorts a string of comma-separated ingredients alphabetically. >>> sort_ingredients(\\"flour,sugar,butter,eggs\\") 'butter,eggs,flour,sugar' >>> sort_ingredients(\\"salt,pepper,cumin,oregano,basil\\") 'basil,cumin,oregano,pepper,salt' >>> sort_ingredients(\\"chocolate,vanilla,cream,butter\\") 'butter,chocolate,cream,vanilla'","solution":"def sort_ingredients(input_string): Sorts a string of comma-separated ingredients alphabetically. Parameters: input_string (str): A string containing the ingredients separated by commas. Returns: str: A string of the ingredients sorted alphabetically, separated by commas. ingredients = input_string.split(',') sorted_ingredients = sorted(ingredients) return ','.join(sorted_ingredients)"},{"question":"def smallest_missing_non_negative_integer(n, arr): Determines the smallest non-negative integer that is not present in the list. Parameters: n (int): Number of integers in the list. arr (list of int): List of n distinct integers. Returns: int: The smallest non-negative integer not present in the list. Examples: >>> smallest_missing_non_negative_integer(5, [0, 3, 1, 6, 2]) 4 >>> smallest_missing_non_negative_integer(3, [-1, -2, -3]) 0 >>> smallest_missing_non_negative_integer(4, [0, 1, 2, 3]) 4","solution":"def smallest_missing_non_negative_integer(n, arr): Determines the smallest non-negative integer that is not present in the list. Parameters: n (int): Number of integers in the list. arr (list of int): List of n distinct integers. Returns: int: The smallest non-negative integer not present in the list. number_set = set(arr) smallest_missing = 0 while smallest_missing in number_set: smallest_missing += 1 return smallest_missing"},{"question":"from typing import List, Tuple def is_magic_square(matrix: List[List[int]]) -> bool: Check whether a 2D array (matrix) is a magic square. A magic square is a grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same. >>> is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) True >>> is_magic_square([[1, 2], [3, 4]]) False >>> is_magic_square([[8, 1, 6], [3, 5, 7], [4, 9, 2]]) True pass def magic_square_test_cases(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[bool]: Process multiple test cases to check for magic squares in given matrices. >>> magic_square_test_cases(3, [ ... (3, [[2, 7, 6], [9, 5, 1], [4, 3, 8]]), ... (2, [[1, 2], [3, 4]]), ... (3, [[8, 1, 6], [3, 5, 7], [4, 9, 2]]) ... ]) [True, False, True] pass # Unit tests def test_is_magic_square(): assert is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True assert is_magic_square([[1, 2], [3, 4]]) == False assert is_magic_square([[8, 1, 6], [3, 5, 7], [4, 9, 2]]) == True assert is_magic_square([[4, 9, 2], [3, 5, 7], [8, 1, 6]]) == True assert is_magic_square([[16, 23, 17], [78, 32, 45], [4, 14, 22]]) == False def test_magic_square_test_cases(): input_data = 3, [ (3, [[2, 7, 6], [9, 5, 1], [4, 3, 8]]), (2, [[1, 2], [3, 4]]), (3, [[8, 1, 6], [3, 5, 7], [4, 9, 2]]) ] expected_output = [True, False, True] assert magic_square_test_cases(*input_data) == expected_output","solution":"def is_magic_square(matrix): n = len(matrix) # Calculate the sum of the first row expected_sum = sum(matrix[0]) # Check rows for row in matrix: if sum(row) != expected_sum: return False # Check columns for col in range(n): if sum(matrix[row][col] for row in range(n)) != expected_sum: return False # Check diagonals if sum(matrix[i][i] for i in range(n)) != expected_sum: return False if sum(matrix[i][n-i-1] for i in range(n)) != expected_sum: return False return True def magic_square_test_cases(t, test_cases): results = [] for i in range(t): n, matrix = test_cases[i] results.append(is_magic_square(matrix)) return results"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Write a function that calculates the longest consecutive subsequence of integers in a list. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_subsequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 >>> longest_consecutive_subsequence([1, 2, 0, 1]) == 3 >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([1, 3, 5, 7, 9]) == 1 >>> longest_consecutive_subsequence([10, 9, 8, 1, 3, 2, 4, 100, 200, 300]) == 4 >>> longest_consecutive_subsequence([100]) == 1 >>> longest_consecutive_subsequence([-1]) == 1 >>> longest_consecutive_subsequence([1, 2, 2, 3]) == 3 >>> longest_consecutive_subsequence([0, 0, 0, 0]) == 1","solution":"def longest_consecutive_subsequence(arr): if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # This ensures we are starting from the beginning of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s, or an underscore (\\"_\\") if there is no such character. >>> first_non_repeating_character(\\"swiss\\") \\"w\\" >>> first_non_repeating_character(\\"aabbcc\\") \\"_\\" >>> first_non_repeating_character(\\"programming\\") \\"p\\" >>> first_non_repeating_character(\\"a\\") \\"a\\" >>> first_non_repeating_character(\\"abcabcabc\\") \\"_\\" >>> first_non_repeating_character(\\"\\") \\"_\\" >>> first_non_repeating_character(\\"abacabad\\") \\"c\\" >>> first_non_repeating_character(\\"abacabaabacaba\\") \\"_\\" >>> first_non_repeating_character(\\"abab\\") \\"_\\" >>> first_non_repeating_character(\\"abcdabcd\\") \\"_\\" >>> first_non_repeating_character(\\"abb\\") \\"a\\" >>> first_non_repeating_character(\\"aabc\\") \\"b\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s, or an underscore (\\"_\\") if there is no such character. from collections import OrderedDict # A dictionary to store the count of each character char_count = OrderedDict() # Count the occurrence of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with count 1 for char, count in char_count.items(): if count == 1: return char # If no non-repeating character is found, return \\"_\\" return \\"_\\""},{"question":"def min_non_empty_subarrays(test_cases: List[str]) -> List[int]: Determine the minimum number of non-empty consecutive subarrays of boxes for each test case. >>> min_non_empty_subarrays([\\"10001\\", \\"11111\\", \\"101010\\"]) == [2, 1, 3] >>> min_non_empty_subarrays([\\"00000\\"]) == [0] >>> min_non_empty_subarrays([\\"11111\\"]) == [1] >>> min_non_empty_subarrays([\\"1010101\\"]) == [4] >>> min_non_empty_subarrays([\\"110011\\", \\"100001\\"]) == [2, 2] >>> min_non_empty_subarrays([\\"1\\" + \\"0\\" * 998 + \\"1\\"]) == [2] def solve(input_string: str) -> List[int]: Process the input string representing multiple test cases and return the minimum number of non-empty consecutive subarrays for each test case. >>> solve(\\"3n10001n11111n101010\\") == [2, 1, 3] >>> solve(\\"1n00000\\") == [0] >>> solve(\\"1n11111\\") == [1] >>> solve(\\"1n1010101\\") == [4] >>> solve(\\"2n110011n100001\\") == [2, 2] >>> solve(\\"1n1\\" + \\"0\\" * 998 + \\"1\\") == [2]","solution":"def min_non_empty_subarrays(test_cases): results = [] for boxes in test_cases: count = 0 in_subarray = False for box in boxes: if box == '1' and not in_subarray: count += 1 in_subarray = True elif box == '0': in_subarray = False results.append(count) return results def solve(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = lines[1:T+1] results = min_non_empty_subarrays(test_cases) return results"},{"question":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def build_tree(levels): Build a binary tree from a list of integers representing level-order traversal where -1 represents a null node. >>> build_tree([1, 2, 3, -1, 5, -1, -1]) Tree with root 1, left child 2, right child 3 and right child of 2 with 5 >>> build_tree([1, 2, 3, 4, 5, 6, -1]) Tree with root 1, left child 2, right child 3 with left child 4 and 5 of 2 and left child 6 of 3 def left_view(root): Find the left view of the binary tree. >>> root = build_tree([1, 2, 3, -1, 5, -1, -1]) >>> left_view(root) [1, 2, 5] >>> root = build_tree([1, 2, 3, 4, 5, 6, -1]) >>> left_view(root) [1, 2, 4] def find_left_view_of_trees(T, test_cases): Process multiple test cases to find the left view of binary trees. >>> find_left_view_of_trees(2, [6, [1, 2, 3, -1, 5, -1, -1], 6, [1, 2, 3, 4, 5, 6, -1]]) [[1, 2, 5], [1, 2, 4]] >>> find_left_view_of_trees(1, [3, [1, -1, 2, -1, 3]]) [[1, 2, 3]]","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def build_tree(levels): if not levels or levels[0] == -1: return None root = TreeNode(levels[0]) queue = [root] i = 1 while queue and i < len(levels): current = queue.pop(0) if i < len(levels) and levels[i] != -1: current.left = TreeNode(levels[i]) queue.append(current.left) i += 1 if i < len(levels) and levels[i] != -1: current.right = TreeNode(levels[i]) queue.append(current.right) i += 1 return root def left_view_util(node, level, max_level, view): if not node: return if max_level[0] < level: view.append(node.val) max_level[0] = level left_view_util(node.left, level+1, max_level, view) left_view_util(node.right, level+1, max_level, view) def left_view(root): view = [] left_view_util(root, 1, [0], view) return view def find_left_view_of_trees(T, test_cases): result = [] for i in range(T): N = test_cases[i * 2] levels = test_cases[i * 2 + 1] root = build_tree(levels) result.append(left_view(root)) return result"},{"question":"def minimizeArray(arr: List[int]) -> int: Write a function that takes an array of integers and removes the minimum number of elements required so that no three consecutive elements are in increasing order. >>> minimizeArray([1, 2, 3, 5, 4]) 4 >>> minimizeArray([4, 3, 2, 1]) 4 >>> minimizeArray([1, 2, 3, 4, 5]) 3 >>> minimizeArray([3, 4, 2, 3, 4, 1]) 5 >>> minimizeArray([1, 2, 3, 3]) 3 >>> minimizeArray([1, 1, 1, 1]) 4 >>> minimizeArray([1]) 1 >>> minimizeArray([1, 2]) 2","solution":"def minimizeArray(arr): n = len(arr) if n < 3: return n removed_count = 0 i = 0 while i < n - 2: if arr[i] < arr[i + 1] < arr[i + 2]: removed_count += 1 if arr[i + 1] < arr[i + 2]: # Remove arr[i+1] i += 2 # Skip next check as we consider it \\"removed\\" else: i += 3 # Skip two elements if we removed third consecutive else: i += 1 return n - removed_count"},{"question":"def find_closest_zero_pair(arr: List[int]) -> List[int]: Given a list of integers, find two distinct elements such that their sum is closest to zero. If multiple pairs have the same closest-to-zero sum, return the one with the smallest absolute values of the elements. If there are still multiple pairs, return the lexicographically smallest pair (sorted order). >>> find_closest_zero_pair([-1, 2, 1, -4, 3, -2]) [-1, 1] >>> find_closest_zero_pair([1, 2, 3, 4, 5, 6]) [1, 2] >>> find_closest_zero_pair([-1, -2, -3, -4, -5, -6]) [-2, -1]","solution":"def find_closest_zero_pair(arr): arr = sorted(arr) left, right = 0, len(arr) - 1 closest_sum = float('inf') result = (float('inf'), float('inf')) while left < right: current_sum = arr[left] + arr[right] # If this pair is closer to zero, update result if abs(current_sum) < abs(closest_sum) or (abs(current_sum) == abs(closest_sum) and (abs(arr[left]), abs(arr[right])) < (abs(result[0]), abs(result[1]))): closest_sum = current_sum result = (arr[left], arr[right]) # Move left pointer rightwards or right pointer leftwards if current_sum < 0: left += 1 else: right -= 1 return sorted(result)"},{"question":"def min_adjacent_swaps(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of adjacent swaps required to sort multiple arrays in ascending order. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer representing the number of elements in the array, followed by a list of integers representing the elements of the array. Returns: List[int]: A list of integers representing the minimum number of adjacent swaps required to sort each array. >>> min_adjacent_swaps([(3, [3, 2, 1]), (4, [4, 3, 2, 1])]) [3, 6] >>> min_adjacent_swaps([(3, [1, 2, 3]), (4, [1, 2, 3, 4])]) [0, 0]","solution":"def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) # Number of elements remaining in the left subarray j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def min_adjacent_swaps(test_cases): results = [] for case in test_cases: N, arr = case temp_arr = [0]*N result = merge_sort_and_count(arr, temp_arr, 0, N-1) results.append(result) return results"},{"question":"def min_path_sum(grid): Given an n x n grid where some cells contain integers and the rest contain obstacles, find the minimum path sum from the upper left corner (1,1) to the lower right corner (n,n), considering the value of each cell in the path. You can move only to the right or down in each step. If a cell contains an obstacle, represented by the character '#', you cannot pass through that cell. Input: grid: List[List[str]] - A 2D list representing the n x n grid, where each element is either an integer as a string or '#'. Output: Returns a single integer representing the minimum path sum from the top-left to the bottom-right corner. If there is no valid path, return -1. Examples: >>> min_path_sum([[\\"1\\", \\"3\\", \\"1\\"], [\\"1\\", \\"5\\", \\"1\\"], [\\"4\\", \\"2\\", \\"1\\"]]) 7 >>> min_path_sum([[\\"1\\", \\"2\\", \\"3\\"], [\\"4\\", \\"#\\", \\"6\\"], [\\"7\\", \\"8\\", \\"9\\"]]) 21 >>> min_path_sum([[\\"1\\", \\"#\\", \\"3\\"], [\\"#\\", \\"#\\", \\"6\\"], [\\"7\\", \\"8\\", \\"9\\"]]) -1 pass # Unit Tests def test_min_path_sum(): grid = [ [\\"1\\", \\"3\\", \\"1\\"], [\\"1\\", \\"5\\", \\"1\\"], [\\"4\\", \\"2\\", \\"1\\"] ] assert min_path_sum(grid) == 7 def test_min_path_with_obstacle(): grid = [ [\\"1\\", \\"2\\", \\"3\\"], [\\"4\\", \\"#\\", \\"6\\"], [\\"7\\", \\"8\\", \\"9\\"] ] assert min_path_sum(grid) == 21 def test_no_valid_path(): grid = [ [\\"1\\", \\"#\\", \\"3\\"], [\\"#\\", \\"#\\", \\"6\\"], [\\"7\\", \\"8\\", \\"9\\"] ] assert min_path_sum(grid) == -1 def test_single_cell(): grid = [[\\"5\\"]] assert min_path_sum(grid) == 5 def test_single_cell_obstacle(): grid = [[\\"#\\"]] assert min_path_sum(grid) == -1 def test_large_grid(): n = 1000 grid = [[str(i*j) for j in range(1, n + 1)] for i in range(1, n + 1)] assert min_path_sum(grid) != -1 # We are not computing exact value, just ensuring it runs if __name__ == \\"__main__\\": test_min_path_sum() test_min_path_with_obstacle() test_no_valid_path() test_single_cell() test_single_cell_obstacle() test_large_grid() print(\\"All tests passed!\\")","solution":"def min_path_sum(grid): n = len(grid) dp = [[float('inf')] * n for _ in range(n)] if grid[0][0] == '#': return -1 dp[0][0] = int(grid[0][0]) for i in range(n): for j in range(n): if grid[i][j] == '#': continue current_value = int(grid[i][j]) if i > 0 and grid[i-1][j] != '#': dp[i][j] = min(dp[i][j], dp[i-1][j] + current_value) if j > 0 and grid[i][j-1] != '#': dp[i][j] = min(dp[i][j], dp[i][j-1] + current_value) return dp[-1][-1] if dp[-1][-1] != float('inf') else -1 # Example usage grid1 = [ [\\"1\\", \\"3\\", \\"1\\"], [\\"1\\", \\"5\\", \\"1\\"], [\\"4\\", \\"2\\", \\"1\\"] ] print(min_path_sum(grid1)) # Output: 7 grid2 = [ [\\"1\\", \\"2\\", \\"3\\"], [\\"4\\", \\"#\\", \\"6\\"], [\\"7\\", \\"8\\", \\"9\\"] ] print(min_path_sum(grid2)) # Output: 21"},{"question":"def count_unique_characters(s: str) -> int: Given a string, return the count of unique characters present in the string. >>> count_unique_characters(\\"hello\\") 4 >>> count_unique_characters(\\"mississippi\\") 4 >>> count_unique_characters(\\"a\\") 1 >>> count_unique_characters(\\"z\\") 1 >>> count_unique_characters(\\"abcdef\\") 6 >>> count_unique_characters(\\"aaaaaa\\") 1 >>> count_unique_characters(\\"abcabcabc\\") 3","solution":"def count_unique_characters(s): Returns the count of unique characters in the string s. return len(set(s))"},{"question":"def findPairWithSum(arr, target_sum): Returns a pair of integers from 'arr' that add up to 'target_sum'. If no such pair exists, returns an empty array. >>> findPairWithSum([3, 7, 5, 2, -4, 8, 11], 10) in ([7, 3], [3, 7]) True >>> findPairWithSum([1, 2, 3, 4, 5], 10) []","solution":"def findPairWithSum(arr, target_sum): Returns a pair of integers from 'arr' that add up to 'target_sum'. If no such pair exists, returns an empty array. Parameters: arr (list): List of integers target_sum (int): Target sum Returns: list: A list containing a pair of integers that add up to target_sum, or an empty list seen = set() for number in arr: complement = target_sum - number if complement in seen: return [number, complement] seen.add(number) return []"},{"question":"def find_pairs_with_sum(nums, target): Finds all unique pairs in the list that sum up to the given target. Returns a list of tuples representing the pairs. >>> find_pairs_with_sum([1, 5, 7, -1, 5, 3], 6) [(1, 5), (-1, 7)] >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8, 9], 7) [(2, 5), (3, 4)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum([-1, 1, 2, -2, 3, 3], 1) [(-2, 3), (-1, 2)] >>> find_pairs_with_sum([1, 1, 1, 1, 1, 1], 2) [(1, 1)] pass","solution":"def find_pairs_with_sum(nums, target): Finds all unique pairs in the list that sum up to the given target. Returns a list of tuples representing the pairs. seen = {} pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen[num] = True return list(pairs) def print_pairs(pairs): Prints the pairs in the requested format. if not pairs: print(\\"No pairs found.\\") else: for pair in pairs: print(f\\"({pair[0]}, {pair[1]})\\") # Input reading function def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) nums = list(map(int, data[1:N+1])) target = int(data[N+1]) pairs = find_pairs_with_sum(nums, target) print_pairs(pairs) if __name__ == \\"__main__\\": main()"},{"question":"def max_ice_creams(): Calculate the maximum number of ice creams that can be bought given the amount of money each friend has and the cost of one ice cream. Each friend has some amount of money, and you need to sum up all their amounts to find the total available money. Then, divide this total by the cost of an ice cream to find out the maximum number of ice creams they can buy. -----Constraints----- - All values in input are integers. - 1 leq numberOfFriends leq 1000 - 1 leq money[i] leq 1000 - 1 leq cost leq 1000 -----Input----- Input is given from Standard Input in the following format: numberOfFriends money1 money2 ... moneyN cost -----Output----- Print the maximum number of ice creams that can be bought.","solution":"def max_ice_creams(): import sys input = sys.stdin.read data = input().split() number_of_friends = int(data[0]) money = list(map(int, data[1:number_of_friends + 1])) cost = int(data[number_of_friends + 1]) total_money = sum(money) max_ice_cream = total_money // cost print(max_ice_cream)"},{"question":"def filter_and_sort_positive_numbers(arr): Returns a new array containing only the positive numbers from the input array, sorted in ascending order. If the input array does not contain any positive integers, returns an empty array. >>> filter_and_sort_positive_numbers([1, -2, 3, 0, -5, 4, -1]) [1, 3, 4] >>> filter_and_sort_positive_numbers([5, 3, 1, 2, 4]) [1, 2, 3, 4, 5] >>> filter_and_sort_positive_numbers([-1, -2, -3, -4]) [] >>> filter_and_sort_positive_numbers([0, 0, 1, 0, -1]) [1] >>> filter_and_sort_positive_numbers([-1]) [] >>> filter_and_sort_positive_numbers([100]) [100] >>> filter_and_sort_positive_numbers([0, 0, 0]) [] >>> filter_and_sort_positive_numbers([1, 3, 2, 2, 0, 4, 3]) [1, 2, 2, 3, 3, 4]","solution":"def filter_and_sort_positive_numbers(arr): Returns a new array containing only the positive numbers from the input array, sorted in ascending order. If the input array does not contain any positive integers, returns an empty array. return sorted([x for x in arr if x > 0])"},{"question":"def generate_cross_pattern(n: int) -> List[str]: Generates a cross pattern on an n x n grid where n is an odd integer. Parameters: n (int): The dimensions of the grid. Returns: List[str]: The n x n grid as a list of strings. Example: >>> generate_cross_pattern(5) [ \\"..*..\\", \\"..*..\\", \\"*****\\", \\"..*..\\", \\"..*..\\" ] >>> generate_cross_pattern(7) [ \\"...*...\\", \\"...*...\\", \\"...*...\\", \\"*******\\", \\"...*...\\", \\"...*...\\", \\"...*...\\" ]","solution":"def generate_cross_pattern(n): Generates a cross pattern on an n x n grid where n is an odd integer. Parameters: n (int): The dimensions of the grid. Returns: List[str]: The n x n grid as a list of strings. assert n % 2 == 1, \\"n must be odd\\" assert 3 <= n <= 999, \\"n must be between 3 and 999 (inclusive)\\" middle = n // 2 # Middle index grid = [] for i in range(n): row = [] for j in range(n): if i == middle or j == middle: row.append('*') else: row.append('.') grid.append(''.join(row)) return grid # Example usage: # result = generate_cross_pattern(5) # for row in result: # print(row)"},{"question":"def largest_rectangle_in_triangle(w: int, h: int) -> int: Given the width w and height h of a right-angled triangle, find the area of the largest rectangle that can fit entirely within this triangle. >>> largest_rectangle_in_triangle(6, 8) 24 >>> largest_rectangle_in_triangle(1, 1) 0 >>> largest_rectangle_in_triangle(10, 10) 50 >>> largest_rectangle_in_triangle(2, 2) 2 >>> largest_rectangle_in_triangle(100000, 100000) 5000000000 >>> largest_rectangle_in_triangle(1, 100000) 50000 >>> largest_rectangle_in_triangle(100000, 1) 50000","solution":"def largest_rectangle_in_triangle(w, h): Given the width w and height h of a right-angled triangle, find the area of the largest rectangle that can fit entirely within this triangle. # The largest rectangle inside a right-angled triangle has half the area of the rectangle # formed by the base (w) and the height (h) of the triangle divided by 2. return (w * h) // 2"},{"question":"def partition_invalid_sessions(events): Partition the list of events into valid sessions, or state that it is impossible to do so. :param events: List of integers representing entry and exit events. :return: Tuple (number of sessions, list of session lengths) or -1 if invalid. from solution import partition_invalid_sessions def test_valid_single_session(): assert partition_invalid_sessions([1, 2, -1, -2]) == (1, [4]) def test_valid_multiple_sessions(): assert partition_invalid_sessions([1, 2, -1, -2, 3, -3]) == (2, [4, 2]) def test_invalid_reentry(): assert partition_invalid_sessions([1, 1, -1, -1]) == -1 def test_invalid_leave_without_entry(): assert partition_invalid_sessions([1, 2, -1, 3, -3]) == -1 def test_invalid_members_remaining_on_stage(): assert partition_invalid_sessions([1, -1, 2, -2, 3, -3, 4]) == -1 def test_valid_complex_session(): assert partition_invalid_sessions([1, 2, -2, -1, 3, 4, -4, -3]) == (2, [4, 4]) def test_edge_case_empty_input(): assert partition_invalid_sessions([]) == (0, [])","solution":"def partition_invalid_sessions(events): Partition the list of events into valid sessions, or state that it is impossible to do so. :param events: List of integers representing entry and exit events. :return: Tuple (number of sessions, list of session lengths) or -1 if invalid. event_count = len(events) session_lengths = [] current_session = set() entered = set() session_start = 0 for i in range(event_count): event = events[i] member = abs(event) if event > 0: # Entry if member in current_session: return -1 # Member re-entering without leaving current_session.add(member) entered.add(member) else: # Exit if member not in entered: return -1 # Member leaving without entering if member not in current_session: return -1 # Member exiting without being on stage current_session.remove(member) if not current_session: session_lengths.append(i - session_start + 1) session_start = i + 1 entered.clear() if current_session: return -1 # Members still on stage return len(session_lengths), session_lengths"},{"question":"def check_growth_pattern(sequence: str, pattern: str) -> str: Checks if the growth pattern can be found within the sequence maintaining the same order. >>> check_growth_pattern(\\"3 5 1 10 6 9 8 15 18\\", \\"5 10 15\\") == \\"yes\\" >>> check_growth_pattern(\\"1 2 3 4 5\\", \\"2 5 1\\") == \\"no\\" >>> check_growth_pattern(\\"7 2 4 8 16 10 12\\", \\"8 10 12\\") == \\"yes\\" >>> check_growth_pattern(\\"1 2 3 4 5 6 7 8 9\\", \\"3 4 7 8\\") == \\"yes\\" >>> check_growth_pattern(\\"1 1 1 1 1\\", \\"1 1 1 1 1\\") == \\"yes\\" >>> check_growth_pattern(\\"1 3 3 4 5\\", \\"4 5 6\\") == \\"no\\" >>> check_growth_pattern(\\"10 20 30\\", \\"20 10\\") == \\"no\\"","solution":"def check_growth_pattern(sequence, pattern): Checks if the growth pattern can be found within the sequence maintaining the same order. seq_list = sequence.split() pat_list = pattern.split() seq_index = 0 pat_index = 0 while seq_index < len(seq_list) and pat_index < len(pat_list): if seq_list[seq_index] == pat_list[pat_index]: pat_index += 1 seq_index += 1 return \\"yes\\" if pat_index == len(pat_list) else \\"no\\""},{"question":"def is_inventory_empty(events: List[str]) -> bool: Determines if the inventory is empty after processing all events. Parameters: events (List[str]): List of events in the format \\"add X\\" or \\"remove X\\". Returns: bool: True if the inventory is empty, False otherwise. Example: >>> is_inventory_empty([\\"add 100\\", \\"remove 50\\", \\"add 50\\", \\"remove 100\\"]) True >>> is_inventory_empty([\\"add 50\\", \\"remove 20\\", \\"add 30\\", \\"remove 40\\"]) False inventory = 0 for event in events: action, count = event.split() count = int(count) if action == \\"add\\": inventory += count elif action == \\"remove\\": inventory -= count return inventory == 0","solution":"def is_inventory_empty(events): Determines if the inventory is empty after processing all events. Parameters: events (list of str): List of events in the format \\"add X\\" or \\"remove X\\". Returns: bool: True if the inventory is empty, False otherwise. inventory = 0 for event in events: action, count = event.split() count = int(count) if action == \\"add\\": inventory += count elif action == \\"remove\\": inventory -= count return inventory == 0"},{"question":"from typing import List def move_zeroes(arr: List[int]) -> List[int]: Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. >>> move_zeroes([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeroes([0, 0, 1]) [1, 0, 0] pass","solution":"from typing import List def move_zeroes(arr: List[int]) -> List[int]: Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. insert_pos = 0 # First pass: move non-zero elements to the front for num in arr: if num != 0: arr[insert_pos] = num insert_pos += 1 # Second pass: fill the rest of the positions with zeros while insert_pos < len(arr): arr[insert_pos] = 0 insert_pos += 1 return arr"},{"question":"def is_valid_chessboard(board: List[str]) -> bool: Checks if the given n x n chessboard has no two queens attacking each other. Args: board (List[str]): n x n chessboard represented as a list of strings. Returns: bool: True if no two queens attack each other, False otherwise. pass from solution import is_valid_chessboard def test_is_valid_chessboard_no_queens(): board = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert is_valid_chessboard(board) == True def test_is_valid_chessboard_single_queen(): board = [ \\"Q...\\", \\"....\\", \\"....\\", \\"....\\" ] assert is_valid_chessboard(board) == True def test_is_valid_chessboard_valid(): board = [ \\"Q...\\", \\"..Q.\\", \\"....\\", \\".Q..\\" ] assert is_valid_chessboard(board) == True def test_is_valid_chessboard_invalid_same_row(): board = [ \\"QQ..\\", \\"....\\", \\"....\\", \\"....\\" ] assert is_valid_chessboard(board) == False def test_is_valid_chessboard_invalid_same_column(): board = [ \\"Q...\\", \\"Q...\\", \\"....\\", \\"....\\" ] assert is_valid_chessboard(board) == False def test_is_valid_chessboard_invalid_same_diagonal(): board = [ \\"Q...\\", \\".Q..\\", \\"....\\", \\"....\\" ] assert is_valid_chessboard(board) == False def test_is_valid_chessboard_invalid_same_antidiagonal(): board = [ \\"...Q\\", \\"..Q.\\", \\"....\\", \\"....\\" ] assert is_valid_chessboard(board) == False","solution":"def is_valid_chessboard(board): Checks if the given n x n chessboard has no two queens attacking each other. Args: board (List[str]): n x n chessboard represented as a list of strings. Returns: bool: True if no two queens attack each other, False otherwise. n = len(board) # To track queens positions rows = set() cols = set() pos_diagonals = set() neg_diagonals = set() for r in range(n): for c in range(n): if board[r][c] == 'Q': # Check if the queen can be attacked if r in rows or c in cols or (r - c) in pos_diagonals or (r + c) in neg_diagonals: return False # Otherwise, mark the queen's attack paths rows.add(r) cols.add(c) pos_diagonals.add(r - c) neg_diagonals.add(r + c) return True"},{"question":"from typing import List def longest_path(grid: List[List[int]]) -> int: Find the length of the longest path of consecutive 1s in a grid. >>> longest_path([ ... [0, 1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1, 1], ... [0, 0, 1, 1, 1, 0], ... [1, 1, 0, 0, 0, 0], ... [1, 0, 1, 1, 0, 0] ... ]) 5 >>> longest_path([ ... [1, 1, 0], ... [1, 0, 1], ... [0, 1, 1] ... ]) 3","solution":"def longest_path(grid): def dfs(x, y): if (x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0): return 0 grid[x][y] = 0 # mark as visited by setting it to 0 length = 1 # start length of this path # explore all 4 possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: length = max(length, 1 + dfs(x + dx, y + dy)) grid[x][y] = 1 # restore the value (undo the visit marking) for other DFS runs return length n = len(grid) m = len(grid[0]) longest = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: longest = max(longest, dfs(i, j)) return longest"},{"question":"def min_positive_magic_power(N: int, magic_powers: List[int]) -> int: Returns the minimum positive magic power among all creatures with non-zero magic power at the end of the duel. If all creatures end up with zero magic power, returns -1. >>> min_positive_magic_power(3, [6, 9, 12]) 3 >>> min_positive_magic_power(2, [15, 25]) 5 >>> min_positive_magic_power(2, [0, 0]) -1 >>> min_positive_magic_power(1, [5]) 5 >>> min_positive_magic_power(3, [7, 11, 13]) 1 >>> min_positive_magic_power(3, [8, 15, 35]) 1 >>> min_positive_magic_power(4, [5, 5, 5, 5]) 5 >>> min_positive_magic_power(3, [1000000000, 1, 1]) 1","solution":"def min_positive_magic_power(N, magic_powers): Returns the minimum positive magic power among all creatures with non-zero magic power at the end of the duel. If all creatures end up with zero magic power, returns -1. from math import gcd def gcd_of_list(lst): Returns the GCD of elements in the list. if len(lst) == 1: return lst[0] current_gcd = lst[0] for num in lst[1:]: current_gcd = gcd(current_gcd, num) return current_gcd result_gcd = gcd_of_list(magic_powers) if result_gcd > 0: return result_gcd else: return -1"},{"question":"def final_score(test_cases): Given a list of test cases where each test case contains three integers representing the scores of three shots, returns a list with the highest score for each test case. >>> final_score([[7, 23, 15], [30, 18, 38], [19, 19, 19]]) [23, 38, 19] >>> final_score([[1, 2, 3], [50, 50, 50], [20, 10, 30]]) [3, 50, 30] def parse_input(input_string): Parses the input string to extract the test cases. >>> parse_input(\\"3n7 23 15n30 18 38n19 19 19\\") [[7, 23, 15], [30, 18, 38], [19, 19, 19]] >>> parse_input(\\"2n10 20 30n15 15 15\\") [[10, 20, 30], [15, 15, 15]]","solution":"def final_score(test_cases): Given a list of test cases where each test case contains three integers representing the scores of three shots, returns a list with the highest score for each test case. results = [] for scores in test_cases: results.append(max(scores)) return results def parse_input(input_string): Parses the input string to extract the test cases. input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] for i in range(1, T + 1): test_cases.append(list(map(int, input_lines[i].split()))) return test_cases"},{"question":"def process_operations(n: int, k: int, grid: List[List[int]], operations: List[str]) -> List[List[int]]: Perform a set of k operations on the n x n grid. The operations can be swaps, additions, or subtractions of the cell values. Args: n (int): Size of the grid (n x n) k (int): Number of operations to perform grid (List[List[int]]): The grid of integers operations (List[str]): List of operations to be performed on the grid Returns: List[List[int]]: The updated grid after performing all operations Examples: >>> process_operations(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], [ \\"swap 1 1 3 3\\", \\"add 2 2 10\\", \\"subtract 3 1 4\\" ]) [[9, 2, 3], [4, 15, 6], [3, 8, 1]] >>> process_operations(4, 2, [ [0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15] ], [ \\"add 1 1 5\\", \\"subtract 4 4 3\\" ]) [[5, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 12]]","solution":"def process_operations(n, k, grid, operations): for operation in operations: parts = operation.split() if parts[0] == \\"swap\\": r1, c1, r2, c2 = int(parts[1])-1, int(parts[2])-1, int(parts[3])-1, int(parts[4])-1 grid[r1][c1], grid[r2][c2] = grid[r2][c2], grid[r1][c1] elif parts[0] == \\"add\\": r, c, v = int(parts[1])-1, int(parts[2])-1, int(parts[3]) grid[r][c] += v elif parts[0] == \\"subtract\\": r, c, v = int(parts[1])-1, int(parts[2])-1, int(parts[3]) grid[r][c] -= v return grid"},{"question":"def max_count_of_a_after_removal(s: str) -> int: Given a string S of length N, return the maximum possible count of the letter 'a' in the string after removing exactly one substring. >>> max_count_of_a_after_removal(\\"abcda\\") 2 >>> max_count_of_a_after_removal(\\"aaaaa\\") 5","solution":"def max_count_of_a_after_removal(s): Returns the maximum possible count of the letter 'a' in the string after removing exactly one substring. n = len(s) total_count_a = s.count('a') if total_count_a == n: return total_count_a max_count_a = 0 count_a_prefix = [0] * (n + 1) for i in range(n): count_a_prefix[i + 1] = count_a_prefix[i] + (1 if s[i] == 'a' else 0) for i in range(n): for j in range(i, n): remaining_a = count_a_prefix[i] + (count_a_prefix[n] - count_a_prefix[j + 1]) max_count_a = max(max_count_a, remaining_a) return max_count_a"},{"question":"def longest_same_parity_subarray(nums): Returns the length of the longest contiguous subarray where all elements have the same parity (odd or even). >>> longest_same_parity_subarray([1, 2, 4, 6, 5, 7, 8]) == 3 >>> longest_same_parity_subarray([1, 3, 5, 2, 4, 6, 8, 7, 9]) == 4 >>> longest_same_parity_subarray([5]) == 1 >>> longest_same_parity_subarray([]) == 0 >>> longest_same_parity_subarray([1, 3]) == 2 >>> longest_same_parity_subarray([2, 4]) == 2 >>> longest_same_parity_subarray([1, 2]) == 1","solution":"def longest_same_parity_subarray(nums): Returns the length of the longest contiguous subarray where all elements have the same parity (odd or even). if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] % 2 == nums[i-1] % 2: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def encode_account_number(account_number: str) -> str: Encode the given account number using a specific set of rules. Each digit in the account number is taken modulo 9. The sum of the digits in the original account number is then taken modulo 9. If the sum is equal to 0, then the encoded account number is equal to the original account number. If the sum is not equal to 0, then each digit in the original account number is replaced by the sum modulo 9. >>> encode_account_number(\\"123\\") '666' >>> encode_account_number(\\"456\\") '666' >>> encode_account_number(\\"789\\") '666' def encode_multiple_account_numbers(T: int, account_numbers: list[str]) -> list[str]: Encode multiple account numbers using the encode_account_number function. >>> encode_multiple_account_numbers(3, [\\"123\\", \\"456\\", \\"789\\"]) ['666', '666', '666']","solution":"def encode_account_number(account_number): digit_sum = sum(int(digit) for digit in account_number) % 9 if digit_sum == 0: return account_number else: return ''.join(str(digit_sum) for _ in account_number) def encode_multiple_account_numbers(T, account_numbers): return [encode_account_number(account_number) for account_number in account_numbers]"},{"question":"def is_present_in_sequence(n: int) -> str: Determines if a given integer n is present as a contiguous subsequence within the infinite concatenation of the sequence defined by start = 1, and each next number is obtained by adding the reverse of the previous number. The initial terms of the sequence are: - 1 - 11 - 1111 - 11111111 - and so on Parameters: n (int): the integer to check in the infinite sequence Returns: str: \\"YES\\" if n is present in the sequence, \\"NO\\" otherwise >>> is_present_in_sequence(11) \\"YES\\" >>> is_present_in_sequence(10) \\"NO\\"","solution":"def is_present_in_sequence(n): Determines if a given integer n is present as a contiguous subsequence within the infinite concatenation of the sequence defined by start = 1, and each next number is obtained by adding the reverse of the previous number. The initial terms of the sequence are: - 1 - 11 - 1111 - 11111111 - and so on Parameters: n (int): the integer to check in the infinite sequence Returns: str: \\"YES\\" if n is present in the sequence, \\"NO\\" otherwise to_find = str(n) current_sequence = \\"1\\" while len(current_sequence) < 2 * len(to_find): if to_find in current_sequence: return \\"YES\\" current_sequence += current_sequence[::-1] return \\"YES\\" if to_find in current_sequence else \\"NO\\""},{"question":"def process_message_operations(n: int, operations: List[str]) -> List[int]: Processes a sequence of message operations and outputs the IDs of the messages that remain. >>> process_message_operations(5, [\\"send 1\\", \\"send 2\\", \\"recall 1\\", \\"send 3\\", \\"send 1\\"]) == [1, 2, 3] >>> process_message_operations(4, [\\"send 4\\", \\"recall 4\\", \\"send 4\\", \\"recall 4\\"]) == []","solution":"def process_message_operations(n, operations): Processes the message operations to find out which messages remain. Parameters: n (int): The number of operations. operations (list): The list of operations as strings. Returns: list: A sorted list of message IDs that were sent but not recalled. sent_messages = set() for operation in operations: action, _, message_id_str = operation.partition(' ') message_id = int(message_id_str) if action == 'send': sent_messages.add(message_id) elif action == 'recall': if message_id in sent_messages: sent_messages.remove(message_id) return sorted(sent_messages)"},{"question":"def largest_connected_component(n, edges): Find the size of the largest connected component in an undirected graph. n: int - the number of vertices in the graph edges: List[Tuple[int, int]] - the edges of the graph >>> largest_connected_component(6, [(1, 2), (1, 3), (3, 4), (2, 4), (5, 6)]) 4 >>> largest_connected_component(5, []) 1 >>> largest_connected_component(1, []) 1 >>> largest_connected_component(3, []) 1 >>> largest_connected_component(6, [(1, 2), (3, 4), (5, 6)]) 2 >>> largest_connected_component(4, [(1, 2), (2, 3), (3, 4)]) 4","solution":"def largest_connected_component(n, edges): from collections import defaultdict def dfs(node, visited, graph): stack = [node] component_size = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True component_size += 1 for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) return component_size # Building the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) largest_size = 0 for i in range(1, n + 1): if not visited[i]: component_size = dfs(i, visited, graph) largest_size = max(largest_size, component_size) return largest_size"},{"question":"def min_new_connections(n: int, connections: List[Tuple[int, int]]) -> int: Returns the minimum number of new connections required to make all computers connected directly or indirectly. Args: n: The number of computers. connections: A list of tuples where each tuple represents an existing connection between two computers. Returns: The minimum number of new connections required to connect all computers. >>> min_new_connections(6, [(1, 2), (2, 3), (4, 5)]) 2 >>> min_new_connections(5, []) 4 >>> min_new_connections(3, [(1, 2), (2, 3)]) 0","solution":"def min_new_connections(n, connections): Returns the minimum number of new connections required to make all computers connected. Parameters: n : int : Number of computers connections : List[Tuple[int,int]] : List of existing connections Returns: int : Number of new connections required from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited[node] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Create graph from connections graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) # Find number of connected components visited = [False] * (n + 1) num_connected_components = 0 for computer in range(1, n + 1): if not visited[computer]: num_connected_components += 1 bfs(computer) # Number of new connections needed is (num_connected_components - 1) return num_connected_components - 1"},{"question":"def min_bills_required(T, cases): Determine the minimum number of bills required to pay the exact amount using the given bills' values for multiple test cases. Args: T (int): The number of test cases. cases (list of tuples): Each tuple contains three elements: the number of different bill values (int), the amount to be paid (int), and a list of the bill values (list of int). Returns: list of int: A list where each element is the minimum number of bills needed for the corresponding test case, or -1 if it's not possible to make the exact amount with the given bills.","solution":"def min_bills_required(T, cases): results = [] for i in range(T): N, M = cases[i][:2] bill_values = cases[i][2] results.append(coin_change(bill_values, M)) return results def coin_change(bills, amount): dp = [float('inf')] * (amount + 1) dp[0] = 0 for bill in bills: for x in range(bill, amount + 1): dp[x] = min(dp[x], dp[x - bill] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List def optimal_score(sequence: List[int]) -> int: Calculate the maximum score Alice can achieve if both players play optimally. Alice and Bob take turns picking either the start or end of the sequence. Alice always starts first. Examples: --------- >>> optimal_score([1, 2, 9, 4]) 10 >>> optimal_score([5, 3, 7, 10]) 15 >>> optimal_score([8, 15, 3, 7]) 22","solution":"def optimal_score(sequence): n = len(sequence) # Create a memoization table to store intermediate results dp = [[0] * n for _ in range(n)] sum_seq = [[0] * n for _ in range(n)] # Initialize the simple base case for i in range(n): dp[i][i] = sequence[i] sum_seq[i][i] = sequence[i] # Fill the sums table - sum_seq[i][j] will hold the sum from sequence[i] to sequence[j] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 sum_seq[i][j] = sum_seq[i][j - 1] + sequence[j] # Fill the dp table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(sequence[i] + (sum_seq[i + 1][j] - dp[i + 1][j]), sequence[j] + (sum_seq[i][j - 1] - dp[i][j - 1])) return dp[0][n - 1]"},{"question":"def process_productivity_queries(productivities, queries): For each query, returns the maximum productivity of any team in the specified range (inclusive). Args: - productivities (list): List of integers where each integer represents the productivity of a team on a particular day. - queries (list(tuple)): List of tuples where each tuple contains two integers (start_day, end_day) representing the range of days for the query. Returns: - list: List of integers where each integer is the result of a query. >>> process_productivity_queries([1, 2, 3, 4, 5], [(1, 3)]) [3] >>> process_productivity_queries([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [3, 4, 5] >>> process_productivity_queries([1, 2, 3, 4, 5], [(2, 2)]) [2] >>> process_productivity_queries([2, 4, 3, 1, 5], [(1, 5)]) [5] >>> process_productivity_queries([10], [(1, 1)]) [10]","solution":"def process_productivity_queries(productivities, queries): For each query, returns the maximum productivity of any team in the specified range (inclusive). Args: - productivities (list): List of integers where each integer represents the productivity of a team on a particular day. - queries (list(tuple)): List of tuples where each tuple contains two integers (start_day, end_day) representing the range of days for the query. Returns: - list: List of integers where each integer is the result of a query. results = [] for l, r in queries: results.append(max(productivities[l-1:r])) return results"},{"question":"def minimum_xor_sequence_length(k): For a given integer k, determines the minimum possible length of the sequence of non-negative integers such that the bitwise XOR of the entire sequence is zero and all elements in the sequence do not exceed k. pass def solve_queries(queries): return [minimum_xor_sequence_length(k) for k in queries] # Test Cases assert solve_queries([1]) == [2] assert solve_queries([2]) == [2] assert solve_queries([3]) == [2] assert solve_queries([4, 0, 3]) == [-1, 1, 2] assert solve_queries([5, 6, 7]) == [-1, -1, -1] assert solve_queries([0, 1, 2, 3, 4]) == [1, 2, 2, 2, -1] assert solve_queries([0]) == [1] assert solve_queries([1000]) == [-1] assert solve_queries([999]) == [-1]","solution":"def minimum_xor_sequence_length(k): For a given integer k, determines the minimum possible length of the sequence of non-negative integers such that the bitwise XOR of the entire sequence is zero and all elements in the sequence do not exceed k. if k == 0: return 1 elif k == 1: return 2 elif k == 2 or k == 3: return 2 else: return -1 def solve_queries(queries): return [minimum_xor_sequence_length(k) for k in queries]"},{"question":"def longest_non_decreasing_subarray(temperatures: List[int]) -> int: Returns the length of the longest contiguous subarray of days with non-decreasing temperatures. >>> longest_non_decreasing_subarray([5, 6, 6, 4, 3, 8, 9]) 3 >>> longest_non_decreasing_subarray([1, 3, 5, 4, 5]) 3 from typing import List def test_example_1(): assert longest_non_decreasing_subarray([5, 6, 6, 4, 3, 8, 9]) == 3 def test_example_2(): assert longest_non_decreasing_subarray([1, 3, 5, 4, 5]) == 3 def test_all_increasing(): assert longest_non_decreasing_subarray([1, 2, 3, 4, 5]) == 5 def test_all_decreasing(): assert longest_non_decreasing_subarray([5, 4, 3, 2, 1]) == 1 def test_single_element(): assert longest_non_decreasing_subarray([10]) == 1 def test_alternating(): assert longest_non_decreasing_subarray([1, 3, 2, 4, 3, 5]) == 2 def test_all_same(): assert longest_non_decreasing_subarray([7, 7, 7, 7, 7]) == 5 def test_empty_array(): assert longest_non_decreasing_subarray([]) == 0 def test_random_case_1(): assert longest_non_decreasing_subarray([10, 9, 8, 7, 8, 9, 10, 11]) == 5 def test_max_values(): assert longest_non_decreasing_subarray([10**9, 10**9, 10**9, 10**9]) == 4","solution":"def longest_non_decreasing_subarray(temperatures): Returns the length of the longest contiguous subarray of days with non-decreasing temperatures. if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] >= temperatures[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def max_subarray_sum_within_limit(arr: List[int], N: int, L: int) -> int: Returns the maximum sum of a contiguous subarray with length not exceeding L. >>> max_subarray_sum_within_limit([4, -1, 2, 1, -7, 3, 5, -2], 8, 3) 6 >>> max_subarray_sum_within_limit([1, -2, 3, 4, -1, 2, 1, -5, 4], 9, 4) 8 >>> max_subarray_sum_within_limit([1, 2, 3, 4], 4, 2) 7 >>> max_subarray_sum_within_limit([-1, -2, -3, -4], 4, 2) -1 >>> max_subarray_sum_within_limit([0, 0, 0, 0, 0], 5, 3) 0 >>> max_subarray_sum_within_limit([7, 2, -5, 10, -3, 6], 6, 4) 14 >>> max_subarray_sum_within_limit([5, 0, 0, 5, -1], 5, 2) 5","solution":"def max_subarray_sum_within_limit(arr, N, L): Returns the maximum sum of a contiguous subarray with length not exceeding L. max_sum = float('-inf') current_sum = 0 window_start = 0 for window_end in range(N): current_sum += arr[window_end] # If the window length exceeds L, slide the window if window_end - window_start + 1 > L: current_sum -= arr[window_start] window_start += 1 # Ensure to update the max_sum when the size of the window is up to L max_sum = max(max_sum, current_sum) return max_sum # Example Usage # N, L = 8, 3 # arr = [4, -1, 2, 1, -7, 3, 5, -2] # print(max_subarray_sum_within_limit(arr, N, L)) # Output: 6"},{"question":"def find_max_min_positions(n: int, elements: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]: Returns the maximum and minimum values in the elements list along with their positions. The position is based on 1-based indexing. Parameters: n (int): Number of elements in the list elements (List[int]): List of integers Returns: Tuple[Tuple[int, int], Tuple[int, int]]: A tuple containing two tuples: - The first tuple contains the maximum value and its position - The second tuple contains the minimum value and its position Example: >>> find_max_min_positions(5, [3, 9, -2, 7, 4]) ((9, 2), (-2, 3)) >>> find_max_min_positions(6, [-1, 0, 1, -2, 2, -3]) ((2, 5), (-3, 6))","solution":"def find_max_min_positions(n, elements): Returns the maximum and minimum values in the elements list along with their positions. The position is based on 1-based indexing. max_value = max(elements) min_value = min(elements) max_pos = elements.index(max_value) + 1 min_pos = elements.index(min_value) + 1 return (max_value, max_pos), (min_value, min_pos)"},{"question":"def isPalindrome(S: str) -> bool: Checks if the input string S is a palindrome, ignoring case and non-alphanumeric characters. >>> isPalindrome(\\"A man, a plan, a canal: Panama\\") True >>> isPalindrome(\\"race a car\\") False >>> isPalindrome(\\"\\") True >>> isPalindrome(\\"a\\") True >>> isPalindrome(\\"A\\") True >>> isPalindrome(\\"No 'x' in Nixon\\") True >>> isPalindrome(\\"!!@ #\\") True >>> isPalindrome(\\"A!A\\") True >>> isPalindrome(\\"Able , was I saw eLba\\") True >>> isPalindrome(\\"A\\" * (10**5)) True >>> isPalindrome(\\"abcdefg\\") False","solution":"def isPalindrome(S): Checks if the input string S is a palindrome, ignoring case and non-alphanumeric characters. # Filter out non-alphanumeric characters and convert to lowercase filtered_str = ''.join(char.lower() for char in S if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_str == filtered_str[::-1]"},{"question":"def game_winner(n: int, array: List[int]) -> str: Determines the winner of the game based on the rules provided. Parameters: n (int): Initial number of elements in the array array (list of int): The elements of the initial array Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" otherwise >>> game_winner(5, [3, 1, 2, 5, 4]) \\"Alice\\" >>> game_winner(4, [10, 20, 10, 15]) \\"Bob\\"","solution":"def game_winner(n, array): Determines the winner of the game based on the rules provided. Parameters: n (int): Initial number of elements in the array array (list of int): The elements of the initial array Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" otherwise def is_strictly_increasing(a): Helper function to check if an array is strictly increasing. return all(a[i] < a[i + 1] for i in range(len(a) - 1)) if is_strictly_increasing(array) or n == 1: return \\"Alice\\" if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def is_valid_ip(ip: str) -> bool: Checks if the input string is a valid IP address. A valid IP address must be in the form of \`x.x.x.x\`, where \`x\` is a number from 0 to 255. Each segment \`x\` must not contain leading zeros except for \`0\` itself, which is treated as a single segment. >>> is_valid_ip(\\"192.168.0.1\\") # returns True >>> is_valid_ip(\\"256.100.50.0\\") # returns False >>> is_valid_ip(\\"1.2.03.4\\") # returns False >>> is_valid_ip(\\"10.10.10.10\\") # returns True >>> is_valid_ip(\\"10.10.10\\") # returns False >>> is_valid_ip(\\"10.10.10.256\\") # returns False","solution":"def is_valid_ip(ip): Checks if the input string is a valid IP address. :param ip: string, the IP address to validate :return: bool, True if the input string is a valid IP address, otherwise False parts = ip.split('.') # An IP address must have exactly four parts if len(parts) != 4: return False for part in parts: # Each part must be a number and within the valid range if not part.isdigit() or not 0 <= int(part) <= 255: return False # Each part should not have leading zeros except for '0' if part != '0' and part.startswith('0'): return False return True"},{"question":"def is_subsequence(s: str, t: str) -> str: Determines if t is a subsequence of s. Args: s (str): The original string. t (str): The subsequence candidate. Returns: str: \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\". Examples: >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"aecd\\") \\"NO\\" >>> is_subsequence(\\"hello\\", \\"helo\\") \\"YES\\" >>> is_subsequence(\\"hello\\", \\"world\\") \\"NO\\"","solution":"def is_subsequence(s, t): Determines if t is a subsequence of s. Args: s (str): The original string. t (str): The subsequence candidate. Returns: str: \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\". # Initialize two pointers i, j = 0, 0 # Traverse both strings while i < len(s) and j < len(t): # If characters match, move the subsequence pointer if s[i] == t[j]: j += 1 # Move the original string pointer i += 1 # If all characters in t were found in s in order, j should be equal to len(t) return \\"YES\\" if j == len(t) else \\"NO\\""},{"question":"from typing import List, Tuple def find_most_powerful_creatures(test_cases: List[Tuple[int, List[Tuple[str, List[Tuple[str, int]]]]]]) -> List[str]: In a fantasy world, identify the single most powerful creature for each type of creature. Args: test_cases: List of tuples where each tuple contains: - an integer M denoting the number of creature types. - a list of tuples for each type, where each tuple contains: - type name as a string - a list of tuples for each creature of that type, where each tuple contains: - creature name as a string - power as an integer Returns: List of strings where each string is the name of the most powerful creature for each type, in the order of their input appearance. Example: >>> find_most_powerful_creatures([ ... (2, [(\\"Dragons\\", [(\\"Drake\\", 8000), (\\"Wyvern\\", 8500), (\\"Longma\\", 9000)]), (\\"Elves\\", [(\\"Legolas\\", 7000), (\\"Alatariel\\", 7500)])]), ... (1, [(\\"Goblins\\", [(\\"Grim\\", 1500), (\\"Snarl\\", 1200), (\\"Slash\\", 1300)])]) ... ]) [\\"Longma\\", \\"Alatariel\\", \\"Grim\\"]","solution":"def find_most_powerful_creatures(test_cases): results = [] for test_case in test_cases: M, types = test_case for type_name, creatures in types: most_powerful_creature = max(creatures, key=lambda x: (x[1], -ord(x[0][0]))) results.append(most_powerful_creature[0]) return results"},{"question":"class SimpleCalculator: A simple calculator class with basic arithmetic operations. Methods: - add: Accepts two arguments and returns their sum. - subtract: Accepts two arguments and returns their difference. - multiply: Accepts two arguments and returns their product. - divide: Accepts two arguments and returns their quotient (integer division). Raises an error if the second argument is zero. def add(self, a, b): pass def subtract(self, a, b): pass def multiply(self, a, b): pass def divide(self, a, b): pass import pytest from solution import SimpleCalculator def test_add(): calc = SimpleCalculator() assert calc.add(2, 3) == 5 assert calc.add(-1, 1) == 0 assert calc.add(0, 0) == 0 def test_subtract(): calc = SimpleCalculator() assert calc.subtract(3, 2) == 1 assert calc.subtract(-1, -1) == 0 assert calc.subtract(0, 5) == -5 def test_multiply(): calc = SimpleCalculator() assert calc.multiply(2, 3) == 6 assert calc.multiply(-1, -1) == 1 assert calc.multiply(0, 5) == 0 def test_divide(): calc = SimpleCalculator() assert calc.divide(6, 3) == 2 assert calc.divide(-6, -3) == 2 assert calc.divide(-6, 3) == -2 def test_divide_by_zero(): calc = SimpleCalculator() with pytest.raises(ValueError, match=\\"Cannot divide by zero\\"): calc.divide(1, 0)","solution":"class SimpleCalculator: def add(self, a, b): return a + b def subtract(self, a, b): return a - b def multiply(self, a, b): return a * b def divide(self, a, b): if b == 0: raise ValueError(\\"Cannot divide by zero\\") return a // b"},{"question":"def classify_triangle(a, b, c): Classifies a triangle based on the lengths of its sides. Parameters: a (int): Length of side a b (int): Length of side b c (int): Length of side c Returns: str: Type of the triangle or \\"Not a triangle\\" if sides don't form a valid triangle Examples: >>> classify_triangle(5, 5, 5) \\"Equilateral\\" >>> classify_triangle(4, 4, 5) \\"Isosceles\\" >>> classify_triangle(3, 4, 5) \\"Scalene\\" >>> classify_triangle(1, 2, 3) \\"Not a triangle\\"","solution":"def classify_triangle(a, b, c): Classifies a triangle based on the lengths of its sides. Parameters: a (int): Length of side a b (int): Length of side b c (int): Length of side c Returns: str: Type of the triangle or \\"Not a triangle\\" if sides don't form a valid triangle # Check if the sides form a valid triangle if a + b <= c or a + c <= b or b + c <= a: return \\"Not a triangle\\" # Check for Equilateral triangle if a == b == c: return \\"Equilateral\\" # Check for Isosceles triangle if a == b or a == c or b == c: return \\"Isosceles\\" # If it's not Equilateral or Isosceles, it must be Scalene return \\"Scalene\\""},{"question":"import math def is_perfect_square(num): Check if a given number is a perfect square. if num < 0: return False sqrt_num = int(math.sqrt(num)) return sqrt_num * sqrt_num == num def has_pair_with_condition(n, integers): Checks if there exists a pair of integers (a, b) in the collection such that their product is a perfect square and b is greater than or equal to a^2 + a. n: int : number of integers in the collection integers: List[int] : collection of distinct integers Returns \\"YES\\" if such a pair exists, otherwise \\"NO\\".","solution":"import math def is_perfect_square(num): if num < 0: return False sqrt_num = int(math.sqrt(num)) return sqrt_num * sqrt_num == num def has_pair_with_condition(n, integers): integers_set = set(integers) for a in integers: for b in integers: if b >= a * a + a: product = a * b if is_perfect_square(product): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def count_increases(temperatures: List[int]) -> int: Counts the number of times the temperature increases compared to the previous day. :param temperatures: a list of integers where each integer represents a temperature. :return: an integer representing the count of days where the temperature was higher than the previous day. >>> count_increases([30, 31, 27, 29, 33, 34]) 4 >>> count_increases([30, 29, 28, 27, 26]) 0 >>> count_increases([30, 30, 30, 30]) 0 >>> count_increases([30, 40]) 1 >>> count_increases([40, 30]) 0 >>> count_increases([1, 2, 3, 4, 5]) 4 >>> count_increases([5, 4, 3, 2, 1]) 0 >>> count_increases([1, 2, 1, 2, 1, 2]) 3 >>> count_increases([10, 20, 10, 15, 10, 25]) 3","solution":"from typing import List def count_increases(temperatures: List[int]) -> int: Counts the number of times the temperature increases compared to the previous day. :param temperatures: a list of integers where each integer represents a temperature. :return: an integer representing the count of days where the temperature was higher than the previous day. count = 0 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i-1]: count += 1 return count"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple containing two distinct integers from the list that add up to the target sum. If no such pair exists, returns an empty tuple. :param nums: List of integers :param target: The target sum :return: Tuple of two integers adding up to target, or empty tuple if no such pair exists >>> find_pair_with_sum([1, 2, 3, 4, 5], 9) (4, 5) >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) (-3, -5) >>> find_pair_with_sum([-2, 1, 2, -1, 0], 0) (-2, 2) >>> find_pair_with_sum([1, 2, 3, -2, -1], 0) (2, -2) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) () >>> find_pair_with_sum([1, 2, 3, 2, 4, 5], 6) (2, 4)","solution":"def find_pair_with_sum(nums, target): Returns a tuple containing two distinct integers from the list that add up to the target sum. If no such pair exists, returns an empty tuple. :param nums: List of integers :param target: The target sum :return: Tuple of two integers adding up to target, or empty tuple if no such pair exists num_set = set() for num in nums: complement = target - num if complement in num_set: return (complement, num) num_set.add(num) return ()"},{"question":"def solve(t, test_cases): Determine the optimal coordinates to build the library so that the maximum walking distance to any house is minimized. :param t: Number of test cases :param test_cases: List of tuples, each containing the number of houses and a list of coordinates of the houses :return: List of tuples representing the optimal coordinates for each test case >>> solve(2, [(3, [(1, 1), (2, 2), (3, 3)]), (4, [(1, 2), (2, 1), (3, 4), (4, 3)])]) [(2, 2), (2, 2)] >>> solve(1, [(1, [(0, 0)])]) [(0, 0)] >>> solve(1, [(2, [(1, 0), (2, 0)])]) [(1, 0)] >>> solve(1, [(6, [(1, 2), (2, 1), (3, 4), (4, 3), (5, 6), (6, 5)])]) [(3, 3)] >>> solve(1, [(5, [(0, 0), (1, 1), (3, 3), (4, 4), (5, 5)])]) [(3, 3)]","solution":"def optimal_library_location(t, test_cases): results = [] for case in test_cases: n = case[0] coordinates = case[1] # Separate the x and y coordinates x_coords = [coordinate[0] for coordinate in coordinates] y_coords = [coordinate[1] for coordinate in coordinates] # Sort the coordinates x_coords.sort() y_coords.sort() # The optimal location for the library is at the median of the coordinates if n % 2 == 1: median_x = x_coords[n // 2] median_y = y_coords[n // 2] else: median_x = x_coords[(n // 2) - 1] median_y = y_coords[(n // 2) - 1] results.append((median_x, median_y)) return results # Here is the function that uses the arguments provided in the task. def solve(t, inputs): return optimal_library_location(t, inputs)"},{"question":"def third_largest_unique_value(arr): Returns the third largest unique value in the array. If the array has less than three unique values, returns the largest unique value. >>> third_largest_unique_value([3, 2, 1]) 1 >>> third_largest_unique_value([1, 2]) 2 >>> third_largest_unique_value([2, 2, 3, 1]) 1","solution":"def third_largest_unique_value(arr): Returns the third largest unique value in the array. If the array has less than three unique values, returns the largest unique value. unique_values = sorted(set(arr), reverse=True) if len(unique_values) < 3: return unique_values[0] return unique_values[2]"},{"question":"# Let's define a mapping of artists to their respective integer identifiers. artist_to_id = { \\"Leonardo da Vinci\\": 1, \\"Vincent van Gogh\\": 2, \\"Claude Monet\\": 3, \\"Pablo Picasso\\": 4, \\"Edvard Munch\\": 5 } def identify_artist(artist_name): Given the artist's name from the metadata, return the corresponding artist's identifier. return artist_to_id.get(artist_name, -1) # Unit tests: def test_identify_artist(): assert identify_artist(\\"Leonardo da Vinci\\") == 1 assert identify_artist(\\"Vincent van Gogh\\") == 2 assert identify_artist(\\"Claude Monet\\") == 3 assert identify_artist(\\"Pablo Picasso\\") == 4 assert identify_artist(\\"Edvard Munch\\") == 5 def test_identify_artist_invalid(): assert identify_artist(\\"Unknown Artist\\") == -1 assert identify_artist(\\"\\") == -1","solution":"# Let's define a mapping of artists to their respective integer identifiers. artist_to_id = { \\"Leonardo da Vinci\\": 1, \\"Vincent van Gogh\\": 2, \\"Claude Monet\\": 3, \\"Pablo Picasso\\": 4, \\"Edvard Munch\\": 5 } def identify_artist(artist_name): Given the artist's name from the metadata, return the corresponding artist's identifier. return artist_to_id.get(artist_name, -1)"},{"question":"def max_magical_power(dataset: str) -> List[int]: Calculates the maximum possible magical power that can be generated by combining the rods. Args: dataset (str): A string representation of multiple lines of datasets. Each dataset is a line containing the number of rods and their lengths, ending with a line that contains \\"-1\\". Returns: List[int]: A list of integers representing the maximum possible magical power for each dataset. >>> max_magical_power(\\"3 1 2 3n4 3 3 3 3n5 1 1 1 1 1n-1\\") [6, 81, 1] >>> max_magical_power(\\"1 5n-1\\") [5] >>> max_magical_power(\\"3 10 100 1000n-1\\") [1000000] >>> max_magical_power(\\"3 1 1 1n-1\\") [1] >>> max_magical_power(\\"-1\\") []","solution":"def max_magical_power(dataset): Calculates the maximum possible magical power that can be generated by combining the rods. data_lines = dataset.strip().split('n') results = [] for line in data_lines: if line.strip() == '-1': break parts = list(map(int, line.split())) n = parts[0] rods = parts[1:] if n != len(rods): raise ValueError(\\"Number of rods does not match the specified count\\") max_power = 1 for rod in rods: max_power *= rod results.append(max_power) return results # Example usage: # data = # 3 1 2 3 # 4 3 3 3 3 # 5 1 1 1 1 1 # -1 # print(max_magical_power(data))"},{"question":"def count_distinct_cyclic_shifts(s: str) -> int: Returns the number of distinct cyclic shifts for the given string s. >>> count_distinct_cyclic_shifts(\\"abcd\\") 4 >>> count_distinct_cyclic_shifts(\\"aaaa\\") 1 >>> count_distinct_cyclic_shifts(\\"abcabc\\") 3 def test_count_distinct_cyclic_shifts_example1(): assert count_distinct_cyclic_shifts(\\"abcd\\") == 4 def test_count_distinct_cyclic_shifts_example2(): assert count_distinct_cyclic_shifts(\\"aaaa\\") == 1 def test_count_distinct_cyclic_shifts_example3(): assert count_distinct_cyclic_shifts(\\"abcabc\\") == 3 def test_count_distinct_cyclic_shifts_all_same_chars(): assert count_distinct_cyclic_shifts(\\"bbbbbb\\") == 1 def test_count_distinct_cyclic_shifts_two_chars(): assert count_distinct_cyclic_shifts(\\"abab\\") == 2 def test_count_distinct_cyclic_shifts_single_char(): assert count_distinct_cyclic_shifts(\\"a\\") == 1 def test_count_distinct_cyclic_shifts_large_string(): assert count_distinct_cyclic_shifts(\\"abcdefghijklmnopqrstuvwxyz\\") == 26","solution":"def count_distinct_cyclic_shifts(s): Returns the number of distinct cyclic shifts for the given string s. n = len(s) cyclic_shifts = set() for i in range(n): shift = s[i:] + s[:i] cyclic_shifts.add(shift) return len(cyclic_shifts)"},{"question":"def total_distance(n: int, distances: List[int]) -> int: Calculate the total distance run by a team based on the number of runners and their respective distances. >>> total_distance(4, [250, 340, 180, 230]) 1000 >>> total_distance(1, [500]) 500 >>> total_distance(3, [200, 200, 200]) 600 >>> total_distance(5, [150, 250, 350, 450, 550]) 1750 >>> total_distance(2, [1, 1000]) 1001","solution":"def total_distance(n, distances): Returns the total distance run by the team. Parameters: n (int): Number of runners distances (list of int): List of distances run by each runner Returns: int: Total distance run by the team return sum(distances)"},{"question":"def is_rotation(s1: str, s2: str) -> str: Determines if s2 is a rotation of s1. >>> is_rotation(\\"abcde\\", \\"cdeab\\") 'YES' >>> is_rotation(\\"hello\\", \\"olehl\\") 'NO' >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") 'YES' >>> is_rotation(\\"abcd\\", \\"abdc\\") 'NO' >>> is_rotation(\\"\\", \\"\\") 'YES' >>> is_rotation(\\"a\\", \\"a\\") 'YES' >>> is_rotation(\\"a\\", \\"b\\") 'NO' >>> is_rotation(\\"ab\\", \\"ba\\") 'YES'","solution":"def is_rotation(s1, s2): Determines if s2 is a rotation of s1. if len(s1) != len(s2): return \\"NO\\" # Concatenate s1 with itself concatenated = s1 + s1 # Check if s2 is a substring of the concatenated string if s2 in concatenated: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_lights_to_connect_islands(T: int, test_cases: list) -> list: Calculate the minimum length of lights needed to connect all the islands in an optimal manner for each test case. >>> min_lights_to_connect_islands(2, [ (4, 5, [(1, 2, 1), (1, 3, 2), (4, 1, 4), (2, 4, 3), (3, 4, 5)]), (3, 3, [(1, 2, 7), (2, 3, 10), (3, 1, 5)]) ]) [6, 12] >>> min_lights_to_connect_islands(1, [ (3, 1, [(1, 2, 10)]) ]) [10] def find(parent, i): Helper function to find the set of an element i def union(parent, rank, x, y): Helper function to do union of two subsets x and y def solve(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) index += 2 edges = [] for _ in range(M): U = int(data[index]) V = int(data[index + 1]) L = int(data[index + 2]) edges.append((U, V, L)) index += 3 test_cases.append((N, M, edges)) results = min_lights_to_connect_islands(T, test_cases) for result in results: print(result)","solution":"def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def min_lights_to_connect_islands(T, test_cases): result = [] for test in test_cases: N, M, edges = test edges.sort(key=lambda x: x[2]) parent = list(range(N+1)) rank = [0] * (N+1) mst_weight = 0 edges_in_mst = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += w edges_in_mst += 1 if edges_in_mst == N - 1: break result.append(mst_weight) return result # This function is to read the inputs and call the min_lights_to_connect_islands def solve(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) index += 2 edges = [] for _ in range(M): U = int(data[index]) V = int(data[index + 1]) L = int(data[index + 2]) edges.append((U, V, L)) index += 3 test_cases.append((N, M, edges)) results = min_lights_to_connect_islands(T, test_cases) for result in results: print(result)"},{"question":"from typing import List def largest_square_area(n: int, m: int, garden: List[List[int]]) -> int: Determine the largest square area in the garden that contains only plants. >>> n, m, garden = 4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> largest_square_area(n, m, garden) 4 >>> n, m, garden = 3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> largest_square_area(n, m, garden) 0 >>> n, m, garden = 3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largest_square_area(n, m, garden) 9","solution":"def largest_square_area(n, m, garden): # Initialize a DP table with the same dimensions as garden dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if garden[i][j] == 1: if i == 0 or j == 0: # First row or first column can only have squares of side 1 dp[i][j] = 1 else: # Calculate the size of the square ending at (i, j) dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length * max_side_length # Input example: # n, m = 4, 5 # garden = [ # [1, 0, 1, 0, 0], # [1, 0, 1, 1, 1], # [1, 1, 1, 1, 1], # [1, 0, 0, 1, 0] # ] # The expected output for the example input is 4. # This can be tested using: print(largest_square_area(n, m, garden))"},{"question":"def count_pairs_with_sum(arr, target): Returns the number of pairs (i, j) where i != j and arr[i] + arr[j] == target. >>> count_pairs_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_pairs_with_sum([-1, -2, -3, -4], -5) 2 pass","solution":"def count_pairs_with_sum(arr, target): Returns the number of pairs (i, j) where i != j and arr[i] + arr[j] == target. count = 0 seen = set() for number in arr: complement = target - number if complement in seen: count += 1 seen.add(number) return count"},{"question":"def longest_consecutive_subsequence_length(n: int, arr: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers in the list. >>> longest_consecutive_subsequence_length(7, [100, 4, 200, 1, 3, 2, 101]) 4 >>> longest_consecutive_subsequence_length(1, [100]) 1 >>> longest_consecutive_subsequence_length(5, [10, 30, 20, 40, 50]) 1 >>> longest_consecutive_subsequence_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence_length(10, [10, 4, 20, 1, 3, 2, 11, 21, 5, 6]) 6 Examples based on unit tests: >>> longest_consecutive_subsequence_length(0, []) 0 >>> longest_consecutive_subsequence_length(5, [1000000000, 999999999, 999999998, 999999997, 999999996]) 5","solution":"def longest_consecutive_subsequence_length(n, arr): Returns the length of the longest subsequence of consecutive integers in the list. if n == 0: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Starting a new sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"import heapq from typing import List, Tuple def find_min_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum cost required for a truck to travel from intersection 1 to intersection n. >>> find_min_cost(4, 5, [(1, 2, 5), (2, 3, 10), (1, 3, 20), (2, 4, 0), (3, 4, 2)]) 5 >>> find_min_cost(3, 2, [(1, 2, 10), (1, 3, 5)]) 5 >>> find_min_cost(3, 1, [(1, 2, 10)]) -1 >>> find_min_cost(4, 2, [(1, 2, 5), (3, 4, 10)]) -1 >>> find_min_cost(5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 3, 5), (1, 4, 10)]) 8 >>> find_min_cost(2, 1, [(1, 2, 3)]) 3","solution":"import heapq def find_min_cost(n, m, roads): # Creating the graph as an adjacency list graph = [[] for _ in range(n + 1)] for u, v, c in roads: graph[u].append((v, c)) # Using Dijkstra's algorithm to find the shortest path def dijkstra(start): dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] heapq.heapify(pq) while pq: current_cost, u = heapq.heappop(pq) if current_cost > dist[u]: continue for v, cost in graph[u]: if current_cost + cost < dist[v]: dist[v] = current_cost + cost heapq.heappush(pq, (dist[v], v)) return dist distances = dijkstra(1) min_cost = distances[n] return min_cost if min_cost < float('inf') else -1"},{"question":"from typing import List def max_cars_borrow(n: int, k: int, cars: List[int]) -> int: Returns the maximum number of toy cars John can borrow while borrowing at most k different types. Parameters: n (int): The total number of toy cars. k (int): The maximum number of different types John can borrow. cars (list): The list of toy car types. Returns: int: The maximum number of toy cars John can borrow. Examples: >>> max_cars_borrow(10, 2, [1, 1, 2, 2, 2, 3, 3, 3, 4, 4]) 6 >>> max_cars_borrow(5, 3, [1, 2, 2, 2, 3]) 5","solution":"from collections import Counter def max_cars_borrow(n, k, cars): Returns the maximum number of toy cars John can borrow while borrowing at most k different types. Parameters: n (int): The total number of toy cars. k (int): The maximum number of different types John can borrow. cars (list): The list of toy car types. Returns: int: The maximum number of toy cars John can borrow. # Count the frequency of each car type car_count = Counter(cars) # Create a sorted list of counts in descending order sorted_counts = sorted(car_count.values(), reverse=True) # Sum up to k most frequent car counts max_borrowed = sum(sorted_counts[:k]) return max_borrowed"},{"question":"import heapq from typing import List, Tuple def min_cost_to_merge_piles(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum total cost to merge all piles into one single pile. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains the number of piles (n) and a list of integers representing the number of stones in each pile. Returns: List[int]: A list of integers where each integer represents the minimum total cost to merge all the piles into one single pile for the corresponding test case. pass # implementation here def parse_and_solve(input_str: str) -> str: Parse the input string and return the result for the problem. Args: input_str (str): The input string containing the number of test cases and pile configurations. Returns: str: The output string containing the minimum total cost for each test case. pass # implementation here # Unit tests def test_min_cost_to_merge_piles(): assert min_cost_to_merge_piles(3, [(4, [4, 3, 3, 2]), (3, [1, 2, 3]), (5, [1, 2, 3, 4, 5])]) == [24, 9, 33] assert min_cost_to_merge_piles(1, [(2, [1, 1])]) == [2] assert min_cost_to_merge_piles(2, [(3, [2, 4, 6]), (2, [10, 20])]) == [18, 30] assert min_cost_to_merge_piles(1, [(4, [1, 2, 3, 4])]) == [19] def test_parse_and_solve(): input_str = \\"3n4n4 3 3 2n3n1 2 3n5n1 2 3 4 5\\" expected_output = \\"24n9n33\\" assert parse_and_solve(input_str) == expected_output input_str = \\"1n2n1 1\\" expected_output = \\"2\\" assert parse_and_solve(input_str) == expected_output input_str = \\"2n3n2 4 6n2n10 20\\" expected_output = \\"18n30\\" assert parse_and_solve(input_str) == expected_output input_str = \\"1n4n1 2 3 4\\" expected_output = \\"19\\" assert parse_and_solve(input_str) == expected_output","solution":"import heapq def min_cost_to_merge_piles(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] piles = test_cases[i][1] heapq.heapify(piles) total_cost = 0 while len(piles) > 1: first = heapq.heappop(piles) second = heapq.heappop(piles) cost = first + second total_cost += cost heapq.heappush(piles, cost) results.append(total_cost) return results # Function to parse input and format output for the problem def parse_and_solve(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) piles = list(map(int, lines[index + 1].split())) test_cases.append((n, piles)) index += 2 results = min_cost_to_merge_piles(t, test_cases) return \\"n\\".join(map(str, results))"},{"question":"def min_colors_needed(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Returns the minimum number of colors needed to assign to the tracks such that no two tracks incident on the same station have the same color. >>> min_colors_needed(3, 3, [(1, 2), (2, 3), (3, 1)]) 2 >>> min_colors_needed(4, 4, [(1, 2), (1, 3), (1, 4), (2, 3)]) 3","solution":"def min_colors_needed(n, m, edges): Returns the minimum number of colors needed to assign to the tracks such that no two tracks incident on the same station have the same color. if m == 0: # No tracks return 0 # Initializing degrees of stations degrees = [0] * (n + 1) # Increment degree count for each station at both ends of each track for u, v in edges: degrees[u] += 1 degrees[v] += 1 # The minimum number of colors needed is maximum degree encountered + 1 max_degree = max(degrees) return max_degree"},{"question":"def append_column_sums(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: Takes the number of rows (n), number of columns (m), and the grid of numbers, returns the grid after appending the sum of each column as a new row at the bottom. >>> append_column_sums(4, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... [1, 1, 1]]) [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 1, 1], [13, 16, 19] ] >>> append_column_sums(1, 3, [ ... [1, 2, 3]]) [ [1, 2, 3], [1, 2, 3] ] >>> append_column_sums(3, 1, [ ... [1], ... [2], ... [3]]) [ [1], [2], [3], [6] ] >>> append_column_sums(4, 3, [ ... [1, 0, 2], ... [3, 5, -1], ... [2, 4, 3], ... [0, 1, -2]]) [ [1, 0, 2], [3, 5, -1], [2, 4, 3], [0, 1, -2], [6, 10, 2] ] pass","solution":"def append_column_sums(n, m, grid): Takes the number of rows (n), number of columns (m), and the grid of numbers, returns the grid after appending the sum of each column as a new row at the bottom. column_sums = [0] * m for row in grid: for i in range(m): column_sums[i] += row[i] grid.append(column_sums) return grid"},{"question":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest valid parentheses substring. >>> longest_valid_parentheses(\\"(()\\") 2 >>> longest_valid_parentheses(\\")()())\\") 4 >>> longest_valid_parentheses(\\"()(()))))\\") 6 >>> longest_valid_parentheses(\\"((()\\") 2 >>> longest_valid_parentheses(\\"))\\") 0 >>> longest_valid_parentheses(\\"(())\\") 4 >>> longest_valid_parentheses(\\"\\") 0 >>> longest_valid_parentheses(\\"()()()()\\") 8 def solve_test_cases(T: int, test_cases: List[str]) -> List[int]: Solves multiple test cases for the longest valid parentheses problem. >>> solve_test_cases(3, [\\"(()\\", \\")()())\\", \\"()(()))))\\"]) [2, 4, 6] >>> solve_test_cases(2, [\\"((()\\", \\" (())\\"]) [2, 4]","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid parentheses substring. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length def solve_test_cases(T, test_cases): results = [] for i in range(T): result = longest_valid_parentheses(test_cases[i]) results.append(result) return results"},{"question":"def min_boxes_required(n: int, W: int, weights: List[int]) -> int: Determines the minimum number of boxes required to package all products without exceeding the weight limit for any box. Parameters: n (int): Number of products. W (int): Maximum weight limit for each box. weights (list): List of weights of each product. Returns: int: Minimum number of boxes required. >>> min_boxes_required(5, 10, [2, 3, 4, 5, 8]) 3 >>> min_boxes_required(6, 8, [4, 4, 8, 6, 2, 3]) 4 >>> min_boxes_required(3, 10, [10, 10, 10]) 3 pass","solution":"def min_boxes_required(n, W, weights): Returns the minimum number of boxes required to pack all products without exceeding the weight limit W for any box. Parameters: n (int): Number of products. W (int): Maximum weight limit for each box. weights (list): List of weights of each product. Returns: int: Minimum number of boxes required. weights.sort(reverse=True) used_boxes = 0 while weights: box_weight = 0 items_to_remove = [] for i in range(len(weights)): if box_weight + weights[i] <= W: box_weight += weights[i] items_to_remove.append(i) for i in reversed(items_to_remove): # Remove items from end to beginning to avoid reindexing issues weights.pop(i) used_boxes += 1 return used_boxes"},{"question":"def can_form_palindrome(s: str) -> str: Determine whether the characters of the input string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(s): Check if we can rearrange the string to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. Args: s (str): The input string consisting of lowercase letters. Returns: str: \\"YES\\" if it is possible to rearrange the characters of the string to form a palindrome, otherwise \\"NO\\". from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def longest_word(s: str) -> str: Returns the longest word in the given string. If there are multiple words of the same length, returns the first one. >>> longest_word(\\"The quick brown fox jumped over the lazy dog\\") 'jumped' >>> longest_word(\\"Python programming is fun\\") 'programming' >>> longest_word(\\"Hello world\\") 'Hello'","solution":"def longest_word(s): Returns the longest word in the given string. If there are multiple words of the same length, returns the first one. words = s.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def min_turns(n: int, treasures: List[int]) -> int: Calculate the minimum number of turns required for participants to collect all treasures given the number of locations and the number of treasures at each location. >>> min_turns(5, [3, 7, 2, 5, 8]) 2 >>> min_turns(7, [1, 1, 1, 1, 1, 1, 1]) 3","solution":"def min_turns(n, treasures): Returns the minimum number of turns required to collect all treasures at given locations. Each turn one can visit consecutive groups of three locations. return (n + 2) // 3"},{"question":"def is_magic_square(grid): Determine if a 3x3 grid forms a magic square and return the magic constant or -1. def parse_input(input_string): Parse the input string into a list of integers. # Unit test functions def test_parse_input(): assert parse_input(\\"2 7 6 9 5 1 4 3 8\\") == [2, 7, 6, 9, 5, 1, 4, 3, 8] assert parse_input(\\"1 2 3 4 5 6 7 8 9\\") == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_is_magic_square(): assert is_magic_square([2, 7, 6, 9, 5, 1, 4, 3, 8]) == 15 assert is_magic_square([1, 2, 3, 4, 5, 6, 7, 8, 9]) == -1 assert is_magic_square([8, 1, 6, 3, 5, 7, 4, 9, 2]) == 15 assert is_magic_square([4, 9, 2, 3, 5, 7, 8, 1, 6]) == 15 assert is_magic_square([5, 10, 1, 7, 6, 2, 3, 12, 4]) == -1 def test_invalid_input(): assert is_magic_square([1, 2, 3, 4, 5]) == -1 assert is_magic_square([]) == -1","solution":"def is_magic_square(grid): Determine if a 3x3 grid forms a magic square and return the magic constant or -1. if len(grid) != 9: return -1 n = 3 magic_constant = sum(grid[:n]) for i in range(n): if sum(grid[i*n:(i+1)*n]) != magic_constant: # check rows return -1 if sum(grid[i::n]) != magic_constant: # check columns return -1 if sum(grid[::n+1]) != magic_constant: # check main diagonal return -1 if sum(grid[n-1:n*n-1:n-1]) != magic_constant: # check secondary diagonal return -1 return magic_constant def parse_input(input_string): Parse the input string into a list of integers. return list(map(int, input_string.strip().split()))"},{"question":"def is_prime(n): Checks if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def fibonacci(n): Returns the n-th Fibonacci number. The Fibonacci sequence starts from 0, 1, 1, 2, 3, 5, 8, ... >>> fibonacci(0) 0 >>> fibonacci(7) 13 def sum_of_evens(n): Returns the sum of all even numbers from 1 to n (inclusive). >>> sum_of_evens(1) 0 >>> sum_of_evens(4) 6 def process_number(n): Processes the number according to the problem description. >>> process_number(2) \\"2 is prime, 2th Fibonacci number is 1\\" >>> process_number(10) \\"10 is not prime, sum of evens is 30\\"","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def fibonacci(n): Returns the n-th Fibonacci number. The Fibonacci sequence starts from 0, 1, 1, 2, 3, 5, 8, ... if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def sum_of_evens(n): Returns the sum of all even numbers from 1 to n (inclusive). return sum(i for i in range(2, n + 1, 2)) def process_number(n): Processes the number according to the problem description. if is_prime(n): fib_num = fibonacci(n) return f\\"{n} is prime, {n}th Fibonacci number is {fib_num}\\" else: even_sum = sum_of_evens(n) return f\\"{n} is not prime, sum of evens is {even_sum}\\""},{"question":"def can_break_stick_to_three_parts(L: int, stick_lengths: List[int]) -> str: Returns \\"Yes\\" if it is possible to break the stick into three parts with lengths found in the array of stick_lengths, otherwise return \\"No\\". >>> can_break_stick_to_three_parts(10, [1, 2, 3, 4, 5]) \\"Yes\\" >>> can_break_stick_to_three_parts(10, [1, 1, 1, 1, 1]) \\"No\\" >>> can_break_stick_to_three_parts(6, [1, 2, 3]) \\"Yes\\" >>> can_break_stick_to_three_parts(1000, [200, 300, 500, 100, 200]) \\"Yes\\" >>> can_break_stick_to_three_parts(10, [1, 2]) \\"No\\" >>> can_break_stick_to_three_parts(15, [5, 5, 5, 5, 5]) \\"Yes\\" >>> can_break_stick_to_three_parts(10, [2, 3, 5]) \\"Yes\\" >>> can_break_stick_to_three_parts(10, [4, 2, 3, 1, 6]) \\"Yes\\" >>> can_break_stick_to_three_parts(10, [9, 8, 7, 4, 1]) \\"No\\"","solution":"def can_break_stick_to_three_parts(L, stick_lengths): Returns \\"Yes\\" if it is possible to break the stick into three parts with lengths found in the array of stick_lengths, otherwise return \\"No\\". n = len(stick_lengths) # Check all possible combinations of three sticks for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if stick_lengths[i] + stick_lengths[j] + stick_lengths[k] == L: return \\"Yes\\" return \\"No\\""},{"question":"from itertools import combinations def count_k_divisible_subsets(arr: List[int], k: int) -> int: Returns the count of unique subsets of \`arr\` such that the sum of the elements in each subset is divisible by \`k\`. >>> count_k_divisible_subsets([2, 4, 6, 8], 3) 5 >>> count_k_divisible_subsets([1, 2, 3], 100) 0 >>> count_k_divisible_subsets([100], 10) 1 >>> count_k_divisible_subsets([1, 2, 3, 4], 3) 5 >>> count_k_divisible_subsets([2, 4, 6, 8, 10, 12], 2) 63 >>> count_k_divisible_subsets([1, 1, 1, 1, 1], 1000) 0","solution":"from itertools import combinations def count_k_divisible_subsets(arr, k): Returns the count of unique subsets of \`arr\` such that the sum of the elements in each subset is divisible by \`k\`. n = len(arr) count = 0 for i in range(1, n + 1): for subset in combinations(arr, i): if sum(subset) % k == 0: count += 1 return count # Sample Input n = 4 arr = [2, 4, 6, 8] k = 3 # Sample Output print(count_k_divisible_subsets(arr, k))"},{"question":"import random def shuffle_deck(deck: List[int]) -> List[int]: Simulates a simplified version of a card shuffling algorithm. Parameters: deck (list of int): A list of integers representing a deck of cards. Returns: list of int: The shuffled deck. >>> shuffle_deck([1, 2, 3, 4, 5]) [3, 1, 4, 2, 5] # Example output, actual output will vary as shuffle is random >>> shuffle_deck([]) [] >>> shuffle_deck([1]) [1]","solution":"import random def shuffle_deck(deck): Simulates a simplified version of a card shuffling algorithm. Parameters: deck (list of int): A list of integers representing a deck of cards. Returns: list of int: The shuffled deck. shuffled_deck = deck[:] random.shuffle(shuffled_deck) return shuffled_deck"},{"question":"def is_valid_parentheses(s: str) -> str: Determines if the input string s is a valid parentheses expression. Every opening bracket must have a corresponding closing bracket of the same type. The pairs of brackets must be properly nested. :param s: String containing characters '(', ')', '{', '}', '[' and ']' :return: \\"YES\\" if the input is a valid parentheses expression, otherwise \\"NO\\" >>> is_valid_parentheses(\\"(){}[]\\") == \\"YES\\" >>> is_valid_parentheses(\\"({[)]}\\") == \\"NO\\" >>> is_valid_parentheses(\\"{[()()]}\\") == \\"YES\\"","solution":"def is_valid_parentheses(s): Determines if the input string s is a valid parentheses expression. :param s: String containing characters '(', ')', '{', '}', '[' and ']' :return: \\"YES\\" if the input is a valid parentheses expression, otherwise \\"NO\\" stack = [] matching_pairs = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_pairs.values(): stack.append(char) elif char in matching_pairs.keys(): if not stack or stack[-1] != matching_pairs[char]: return \\"NO\\" stack.pop() else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def separate_words_and_numbers(s: str) -> (list, list): Separates words and numbers from the input string s. >>> separate_words_and_numbers(\\"apple 42 banana 7 cherry 38\\") ([\\"apple\\", \\"banana\\", \\"cherry\\"], [42, 7, 38]) >>> separate_words_and_numbers(\\"word1 word2 100 200\\") ([\\"word1\\", \\"word2\\"], [100, 200]) >>> separate_words_and_numbers(\\"10 20 apple banana\\") ([\\"apple\\", \\"banana\\"], [10, 20]) >>> separate_words_and_numbers(\\"hello 5\\") ([\\"hello\\"], [5]) >>> separate_words_and_numbers(\\"tree 12 flower 45 bird 78 bee\\") ([\\"tree\\", \\"flower\\", \\"bird\\", \\"bee\\"], [12, 45, 78])","solution":"def separate_words_and_numbers(s): Separates words and numbers from the input string s. :param s: A string containing words and numbers separated by spaces. :return: A tuple containing two lists - (list of words, list of numbers) words = [] numbers = [] elements = s.split() for element in elements: if element.isdigit(): numbers.append(int(element)) else: words.append(element) return (words, numbers)"},{"question":"def lexicographically_smallest_array(N: int, K: int, A: List[int]) -> List[int]: Returns the lexicographically smallest array by reversing subarrays of length K any number of times. Parameters: N (int): The number of elements in the array. K (int): The length of subarrays to reverse. A (list): The list of integers. Returns: list: The lexicographically smallest array achievable. >>> lexicographically_smallest_array(4, 2, [3, 2, 1, 4]) [1, 2, 3, 4] >>> lexicographically_smallest_array(5, 3, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5]","solution":"def lexicographically_smallest_array(N, K, A): Returns the lexicographically smallest array by reversing subarrays of length K any number of times. Parameters: N (int): The number of elements in the array. K (int): The length of subarrays to reverse. A (list): The list of integers. Returns: list: The lexicographically smallest array achievable. if K == 1: return sorted(A) if K >= N: return sorted(A) for i in range(N - K + 1): A_segments = [] for j in range(i, N, K): A_segments.append(A[j:j+K]) A_segments = [sorted(segment) for segment in A_segments] result = [] for segment in A_segments: result.extend(segment) return sorted(result) # Example usage: # N = 4 # K = 2 # A = [3, 2, 1, 4] # print(lexicographically_smallest_array(N, K, A)) # Output: [1, 2, 3, 4]"},{"question":"def count_unique_items_restocked_more_than_once(test_cases): Given a list of test cases, each containing restocking event information, this function returns a list of integers representing the number of unique items that have been restocked more than once in each test case. Parameters: test_cases (list of list of tuples): Each list contains tuples representing restocking events with (itemId, quantity) Returns: list of int: Number of unique items restocked more than once for each test case Examples: >>> count_unique_items_restocked_more_than_once([ ... [(101, 20), (102, 15), (101, 25), (103, 30), (102, 10)], ... [(201, 5), (202, 10), (203, 15)], ... [(301, 40), (302, 50), (301, 30), (303, 20)] ... ]) [2, 0, 1] >>> count_unique_items_restocked_more_than_once([ ... [(101, 20)], ... [(201, 10)], ... [(301, 40)] ... ]) [0, 0, 0] from solution import count_unique_items_restocked_more_than_once def test_case_multiple_restocking_events(): test_cases = [ [(101, 20), (102, 15), (101, 25), (103, 30), (102, 10)], [(201, 5), (202, 10), (203, 15)], [(301, 40), (302, 50), (301, 30), (303, 20)] ] assert count_unique_items_restocked_more_than_once(test_cases) == [2, 0, 1] def test_case_single_restocking_event(): test_cases = [ [(101, 20)], [(201, 10)], [(301, 40)] ] assert count_unique_items_restocked_more_than_once(test_cases) == [0, 0, 0] def test_case_all_unique_items(): test_cases = [ [(101, 20), (102, 15), (103, 25), (104, 30), (105, 10)], [(201, 5), (202, 10), (203, 15), (204, 20)], [(301, 40), (302, 50), (303, 30), (304, 20)] ] assert count_unique_items_restocked_more_than_once(test_cases) == [0, 0, 0] def test_case_all_duplicated_items(): test_cases = [ [(101, 20), (101, 15), (101, 25), (101, 30), (101, 10)], [(201, 5), (201, 10), (201, 15), (201, 20)], [(301, 40), (301, 50), (301, 30), (301, 20)] ] assert count_unique_items_restocked_more_than_once(test_cases) == [1, 1, 1] def test_case_mixed_unique_and_duplicated_items(): test_cases = [ [(101, 20), (102, 15), (101, 25), (103, 30), (104, 10)], [(201, 5), (202, 10), (203, 15), (202, 20), (202, 25)], [(301, 40), (302, 50), (301, 30), (303, 20), (303, 10)] ] assert count_unique_items_restocked_more_than_once(test_cases) == [1, 1, 2]","solution":"def count_unique_items_restocked_more_than_once(test_cases): Given a list of test cases, each containing restocking event information, this function returns a list of integers representing the number of unique items that have been restocked more than once in each test case. Parameters: test_cases (list of list of tuples): Each list contains tuples representing restocking events with (itemId, quantity) Returns: list of int: Number of unique items restocked more than once for each test case results = [] for case in test_cases: item_count = {} for event in case: itemId, _ = event if itemId not in item_count: item_count[itemId] = 1 else: item_count[itemId] += 1 more_than_once_count = sum(1 for count in item_count.values() if count > 1) results.append(more_than_once_count) return results"},{"question":"from typing import List def min_total_cost(D: int, N: int, prices: List[List[int]]) -> int: Determine the minimum total cost to buy one coin of each rarity level. :param D: Number of days :param N: Number of distinct rarity levels :param prices: Prices of each coin for each rarity level over a span of days :return: Minimum total cost to buy one coin of each rarity level >>> min_total_cost(3, 3, [[1, 100, 2], [100, 1, 2], [1, 2, 1]]) 3 >>> min_total_cost(1, 1, [[5]]) 5","solution":"def min_total_cost(D, N, prices): from itertools import permutations min_cost = float('inf') # Generate all possible sequences of days day_indices = list(range(D)) for days in permutations(day_indices, N): current_cost = 0 for rar_level, day in enumerate(days, start=1): current_cost += prices[rar_level - 1][day] min_cost = min(min_cost, current_cost) return min_cost"},{"question":"def count_unique_substrings(k: int, s: str) -> int: Determines the number of unique substrings of length k that appear in string s. Input k: int, length of the substrings to consider s: str, input string consisting of lowercase English letters Output Returns an integer representing the number of unique substrings of length k. >>> count_unique_substrings(2, \\"abcabc\\") 3 >>> count_unique_substrings(3, \\"aaaaaa\\") 1 >>> count_unique_substrings(1, \\"abcd\\") 4 from solution import count_unique_substrings def test_example1(): assert count_unique_substrings(2, \\"abcabc\\") == 3 def test_example2(): assert count_unique_substrings(3, \\"aaaaaa\\") == 1 def test_example3(): assert count_unique_substrings(1, \\"abcd\\") == 4 def test_different_k(): assert count_unique_substrings(2, \\"abcde\\") == 4 assert count_unique_substrings(3, \\"abcde\\") == 3 def test_single_character_string(): assert count_unique_substrings(1, \\"a\\") == 1 def test_string_length_less_than_k(): assert count_unique_substrings(5, \\"abcd\\") == 0 def test_all_unique_substrings(): assert count_unique_substrings(2, \\"abcdefg\\") == 6 assert count_unique_substrings(3, \\"abcdefg\\") == 5 def test_all_same_characters(): assert count_unique_substrings(1, \\"aaaaa\\") == 1 assert count_unique_substrings(2, \\"aaaaa\\") == 1 assert count_unique_substrings(3, \\"aaaaa\\") == 1 assert count_unique_substrings(4, \\"aaaaa\\") == 1 assert count_unique_substrings(5, \\"aaaaa\\") == 1","solution":"def count_unique_substrings(k, s): Returns the number of unique substrings of length k in the string s. unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i + k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"def max_guests_seated(n: int, preferences: List[str]) -> int: Determines the maximum number of guests that can be seated according to their preferred side. Parameters: n (int): Number of guests. preferences (list of str): List of strings where each string is either \\"left\\", \\"right\\", or \\"none\\". Returns: int: The maximum number of guests seated according to preferences. pass # Example usage: n = 4 preferences = [\\"left\\", \\"right\\", \\"none\\", \\"none\\"] print(max_guests_seated(n, preferences)) # Expected output: 4 n = 5 preferences = [\\"left\\", \\"left\\", \\"right\\", \\"right\\", \\"none\\"] print(max_guests_seated(n, preferences)) # Expected output: 5","solution":"def max_guests_seated(n, preferences): Determines the maximum number of guests that can be seated according to their preferred side. Parameters: n (int): Number of guests. preferences (list of str): List of strings where each string is either \\"left\\", \\"right\\", or \\"none\\". Returns: int: The maximum number of guests seated according to preferences. left_preference = preferences.count(\\"left\\") right_preference = preferences.count(\\"right\\") no_preference = preferences.count(\\"none\\") max_seated = min(left_preference, right_preference) * 2 + no_preference if left_preference != right_preference: max_seated += abs(left_preference - right_preference) return max_seated # Example usage: # n = 4 # preferences = [\\"left\\", \\"right\\", \\"none\\", \\"none\\"] # print(max_guests_seated(n, preferences))"},{"question":"from typing import List, Tuple def decode_sequence_to_words(n: int, mappings: List[Tuple[str, str]], sequence: str) -> List[str]: Decode a sequence of digits into all possible words using dictionary mappings. Args: n (int): Number of unique digit-character mappings. mappings (List[Tuple[str, str]]): List of tuples where each tuple contains a digit and a string of characters. sequence (str): A string of digits to be decoded. Returns: List[str]: A list of all possible decoded words in lexicographical order. >>> decode_sequence_to_words(3, [('2', 'abc'), ('3', 'def'), ('5', 'jkl')], '23') ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> decode_sequence_to_words(2, [('2', 'abc'), ('3', 'def')], '2') ['a', 'b', 'c']","solution":"def decode_sequence_to_words(n, mappings, sequence): from itertools import product # Create a mapping dictionary from the input digit_to_chars = {mapping[0]: mapping[1] for mapping in mappings} # Generate all combinations of characters for the digit sequence combinations = list(product(*(digit_to_chars[digit] for digit in sequence))) # Concatenate tuples of characters to form full words words = [''.join(combination) for combination in combinations] # Sort words lexicographically words.sort() return words def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) mappings = [line.split() for line in data[1:n + 1]] sequence = data[n + 1] results = decode_sequence_to_words(n, mappings, sequence) for word in results: print(word)"},{"question":"def sublist_sums(arr: List[int], m: int) -> bool: Check if there exists at least one contiguous subarray whose sum equals to target integer m. >>> sublist_sums([1, 2, 3, 4, 5], 9) True >>> sublist_sums([1, 2, 3, 4, 5], 20) False >>> sublist_sums([-1, 4, 2, -3, 5], 3) True >>> sublist_sums([5], 5) True >>> sublist_sums([], 0) False","solution":"def sublist_sums(arr, m): Check if there exists at least one contiguous subarray whose sum equals to target integer m. current_sum = 0 sums_set = set() for num in arr: current_sum += num if current_sum == m or (current_sum - m) in sums_set: return True sums_set.add(current_sum) return False"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped within the histogram after raining. The histogram is represented as a non-negative integer array where each element represents the height of a bar and the width of each bar is 1 unit. Args: height (List[int]): A list of non-negative integers representing the height of bars. Returns: int: The total amount of water that can be trapped. Examples: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9","solution":"def trap(height): if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def find_maximum_value(grid: List[List[int]]) -> int: Determine the maximum value you can reach starting from any of the minimum value cells. Args: grid (List[List[int]]): A 2D list representing the grid of numbers. Returns: int: The maximum value reachable from the minimum value cells. Examples: >>> grid = [ ... [4, 5, 6], ... [3, 2, 1], ... [8, 7, 2] ... ] >>> find_maximum_value(grid) 8 >>> grid = [ ... [1, 4, 3, 1], ... [2, 1, 3, 4], ... [3, 2, 1, 2], ... [4, 3, 2, 1] ... ] >>> find_maximum_value(grid) 4 >>> grid = [ ... [5, 8], ... [7, 5] ... ] >>> find_maximum_value(grid) 8","solution":"def find_maximum_value(grid): n = len(grid) m = len(grid[0]) min_val = min(min(row) for row in grid) from collections import deque moves = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] max_val = min_val queue = deque() for i in range(n): for j in range(m): if grid[i][j] == min_val: queue.append((i, j)) visited[i][j] = True while queue: x, y = queue.popleft() max_val = max(max_val, grid[x][y]) for move in moves: nx, ny = x + move[0], y + move[1] if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] >= grid[x][y]: visited[nx][ny] = True queue.append((nx, ny)) return max_val"},{"question":"def wordBreakCount(s: str, dict: set) -> int: Given a string s and a dictionary of words dict, find the number of possible ways to break the string into a sequence of one or more dictionary words. >>> wordBreakCount(\\"catsanddog\\", {\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"}) 2 >>> wordBreakCount(\\"pineapplepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"}) 3 >>> wordBreakCount(\\"dog\\", {\\"dog\\"}) 1 >>> wordBreakCount(\\"catsandog\\", {\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"}) 0 >>> wordBreakCount(\\"appleapple\\", {\\"apple\\", \\"app\\", \\"le\\", \\"ple\\"}) 4","solution":"def wordBreakCount(s, dict): def dfs(index, memo): if index == len(s): return 1 if index in memo: return memo[index] count = 0 for end in range(index + 1, len(s) + 1): if s[index:end] in dict: count += dfs(end, memo) memo[index] = count return count return dfs(0, {})"},{"question":"def remove_columns(n, m, spreadsheet, k, columns_to_delete): Removes specified columns from the spreadsheet. Parameters: - n (int): Number of rows. - m (int): Number of columns. - spreadsheet (list of list of int): The plant attribute records. - k (int): Number of columns to delete. - columns_to_delete (list of int): List of column indices to delete (1-based indices). Returns: - list of list of int: The new spreadsheet with the specified columns removed. >>> n, m = 4, 5 >>> spreadsheet = [ ... [10, 20, 30, 40, 50], ... [60, 70, 80, 90, 100], ... [110, 120, 130, 140, 150], ... [160, 170, 180, 190, 200] ... ] >>> k = 2 >>> columns_to_delete = [2, 4] >>> remove_columns(n, m, spreadsheet, k, columns_to_delete) [[10, 30, 50], [60, 80, 100], [110, 130, 150], [160, 180, 200]] >>> n, m = 3, 4 >>> spreadsheet = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ] >>> k = 1 >>> columns_to_delete = [3] >>> remove_columns(n, m, spreadsheet, k, columns_to_delete) [[1, 2, 4], [5, 6, 8], [9, 10, 12]] def format_spreadsheet(spreadsheet): Formats the spreadsheet into a string with each row on a new line. Parameters: - spreadsheet (list of list of int): The spreadsheet to format. Returns: - str: The formatted spreadsheet as a string. >>> spreadsheet = [ ... [10, 30, 50], ... [60, 80, 100], ... [110, 130, 150], ... [160, 180, 200] ... ] >>> format_spreadsheet(spreadsheet) '10 30 50n60 80 100n110 130 150n160 180 200' >>> spreadsheet = [ ... [1, 2, 4], ... [5, 6, 8], ... [9, 10, 12] ... ] >>> format_spreadsheet(spreadsheet) '1 2 4n5 6 8n9 10 12'","solution":"def remove_columns(n, m, spreadsheet, k, columns_to_delete): Removes specified columns from the spreadsheet. Parameters: - n (int): Number of rows. - m (int): Number of columns. - spreadsheet (list of list of int): The plant attribute records. - k (int): Number of columns to delete. - columns_to_delete (list of int): List of column indices to delete (1-based indices). Returns: - list of list of int: The new spreadsheet with the specified columns removed. # Convert columns_to_delete to 0-based indices columns_to_delete = set(col - 1 for col in columns_to_delete) new_spreadsheet = [] for row in spreadsheet: new_row = [row[j] for j in range(m) if j not in columns_to_delete] new_spreadsheet.append(new_row) return new_spreadsheet def format_spreadsheet(spreadsheet): Formats the spreadsheet into a string with each row on a new line. Parameters: - spreadsheet (list of list of int): The spreadsheet to format. Returns: - str: The formatted spreadsheet as a string. return \\"n\\".join(\\" \\".join(map(str, row)) for row in spreadsheet)"},{"question":"def rotate(nums: List[int], k: int) -> List[int]: Rotate the list nums to the right by k steps. >>> rotate([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate([-1, -100, 3, 99], 2) [3, 99, -1, -100]","solution":"def rotate(nums, k): Rotates the list nums to the right by k steps. n = len(nums) k = k % n # To handle cases where k is greater than the length of the list # Reverse the whole list nums.reverse() # Reverse first k elements nums[:k] = reversed(nums[:k]) # Reverse the rest of the list nums[k:] = reversed(nums[k:]) return nums"},{"question":"def is_subsequence(pattern, source): Determines if the pattern is a subsequence of the source. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False # Implementation here def process_test_cases(test_cases): Processes multiple test cases to determine if each pattern is a subsequence of the corresponding source. >>> process_test_cases([(\\"abc\\", \\"ahbgdc\\"), (\\"axc\\", \\"ahbgdc\\")]) [\\"YES\\", \\"NO\\"] >>> process_test_cases([(\\"ace\\", \\"abcde\\"), (\\"aec\\", \\"abcde\\")]) [\\"YES\\", \\"NO\\"] # Implementation here","solution":"def is_subsequence(pattern, source): Determines if the pattern is a subsequence of the source. it = iter(source) return all(char in it for char in pattern) def process_test_cases(test_cases): Processes multiple test cases to determine if each pattern is a subsequence of the corresponding source. results = [] for pattern, source in test_cases: if is_subsequence(pattern, source): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longestIncreasingSubarray(arr: list) -> int: Finds the length of the longest strictly increasing subarray in the given array. Parameters: arr (list): A list of integers. Returns: int: Length of the longest strictly increasing subarray. Examples: >>> longestIncreasingSubarray([1, 3, 5, 4, 7]) 3 >>> longestIncreasingSubarray([2, 2, 2, 2, 2]) 1 >>> longestIncreasingSubarray([10]) 1 >>> longestIncreasingSubarray([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> longestIncreasingSubarray([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longestIncreasingSubarray([1, 2, 5, 3, 4, 7, 6, 8]) 3 >>> longestIncreasingSubarray([1, 3, 2, 4, 3, 5, 4, 6]) 2 >>> longestIncreasingSubarray([5, 5, 5, 5, 5]) 1 >>> longestIncreasingSubarray([]) 0","solution":"def longestIncreasingSubarray(arr): Finds the length of the longest strictly increasing subarray in the given array. Parameters: arr (list): A list of integers. Returns: int: Length of the longest strictly increasing subarray. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def distinct_race_numbers(d: int) -> int: Calculate how many distinct race numbers, when converted to base 5 and accounting for faulty display merging of digits 1 and 4, can be generated with up to \`d\` digits. >>> distinct_race_numbers(1) 4 >>> distinct_race_numbers(2) 16 >>> distinct_race_numbers(3) 64 >>> distinct_race_numbers(4) 256 >>> distinct_race_numbers(18) 68719476736","solution":"def distinct_race_numbers(d): Returns the number of distinct race numbers in base 5 considering faulty LED display up to d digits. :param d: Maximum digits in the race number :return: Distinct race numbers return 4 ** d"},{"question":"def find_kth_largest(nums: List[int], k: int) -> int: Finds the kth largest element in an unsorted array using sorting. Args: nums (list of int): The list of integers. k (int): The position of the largest element to find. Returns: int: The kth largest element in the array. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"def find_kth_largest(nums, k): Finds the kth largest element in an unsorted array using sorting. Args: nums (list of int): The list of integers. k (int): The position of the largest element to find. Returns: int: The kth largest element in the array. nums.sort(reverse=True) return nums[k - 1]"},{"question":"def max_items_count(T: int, test_cases: list) -> list: Determines the maximum number of items Tim can buy without exceeding his budget. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains: - N (int): Number of items - M (int): Total amount of money Tim has - prices (list of int): List of item prices Returns: list of int: Maximum number of items Tim can buy for each test case >>> max_items_count(3, [ ... (4, 50, [10, 20, 30, 40]), ... (5, 100, [25, 50, 75, 100, 125]), ... (3, 60, [15, 25, 35]) ... ]) [2, 2, 2] >>> max_items_count(1, [ ... (3, 50, [10, 20, 30]) ... ]) [2] >>> max_items_count(2, [ ... (3, 10, [1, 2, 3]), ... (3, 9, [3, 4, 5]) ... ]) [3, 2] >>> max_items_count(2, [ ... (4, 100, [20, 30, 40, 50]), ... (4, 100, [100, 100, 100, 100]) ... ]) [3, 1]","solution":"def max_items_count(T, test_cases): Determines the maximum number of items Tim can buy without exceeding his budget. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains: - N (int): Number of items - M (int): Total amount of money Tim has - prices (list of int): List of item prices Returns: list of int: Maximum number of items Tim can buy for each test case results = [] for case in test_cases: N, M, prices = case prices.sort() # Sort the prices in ascending order total_cost = 0 count = 0 for price in prices: if total_cost + price <= M: count += 1 total_cost += price else: break results.append(count) return results"},{"question":"def minimum_links_for_communication(T: int, cities: List[int]) -> List[int]: Given the number of test cases and the number of cities in each test case, return a list containing the minimum number of direct links required for each test case. >>> minimum_links_for_communication(2, [2, 4]) [1, 3] >>> minimum_links_for_communication(1, [1]) [0] >>> minimum_links_for_communication(3, [3, 5, 10]) [2, 4, 9]","solution":"def minimum_links_for_communication(T, cities): Given the number of test cases and the number of cities in each test case, return a list containing the minimum number of direct links required for each test case. results = [C - 1 for C in cities] return results"},{"question":"def calculate_min_bonuses(scores: List[int]) -> int: Calculate the minimum total number of bonuses required for employees based on their performance scores. Each employee has to get at least one bonus, and employees with higher scores than their neighbors must get more bonuses. >>> calculate_min_bonuses([1, 2, 2]) 4 >>> calculate_min_bonuses([10, 4, 5, 4]) 6 pass # Unit tests def test_case_1(): assert calculate_min_bonuses([1, 2, 2]) == 4 def test_case_2(): assert calculate_min_bonuses([10, 4, 5, 4]) == 6 def test_case_3(): assert calculate_min_bonuses([1, 2, 3, 4, 5]) == 15 def test_case_4(): assert calculate_min_bonuses([5, 4, 3, 2, 1]) == 15 def test_case_5(): assert calculate_min_bonuses([1]) == 1 def test_case_6(): assert calculate_min_bonuses([2, 2, 2, 2, 2]) == 5 def test_case_7(): assert calculate_min_bonuses([1, 2, 1, 2, 1]) == 7 def test_case_8(): assert calculate_min_bonuses([3, 6, 3, 6, 3]) == 7","solution":"def calculate_min_bonuses(scores): n = len(scores) bonuses = [1] * n for i in range(1, n): if scores[i] > scores[i - 1]: bonuses[i] = bonuses[i - 1] + 1 for i in range(n - 2, -1, -1): if scores[i] > scores[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"def count_enchanted_paths(N, M, positions): Calculate the total number of unique enchanted paths between all pairs of roses modulo 1000000007. :param N: int - the number of stones in the circle :param M: int - the number of stones with roses :param positions: List[int] - the positions of the stones with roses :return: int - the total number of enchanted paths modulo 1000000007. >>> count_enchanted_paths(8, 3, [1, 4, 7]) 3 >>> count_enchanted_paths(2, 2, [0, 1]) 1 >>> count_enchanted_paths(10, 2, [0, 5]) 1 >>> count_enchanted_paths(5, 3, [1, 2, 3]) 3 >>> count_enchanted_paths(100, 50, list(range(50))) 1225 pass","solution":"def count_enchanted_paths(N, M, positions): Returns the count of enchanted paths modulo 1000000007 given N stones, M stones with roses, and the positions of the roses. MOD = 1000000007 # Combinatorial calculation of number of pairs: C(M, 2) = M * (M - 1) / 2 num_paths = (M * (M - 1) // 2) % MOD return num_paths # Sample input N, M = 8, 3 positions = [1, 4, 7] output = count_enchanted_paths(N, M, positions) print(output) # Expected output: 3"},{"question":"def find_peak_elements(n: int, array: list[int]) -> list[int]: Finds the indices of all peak elements in an array. >>> find_peak_elements(6, [1, 3, 2, 4, 5, 3]) [1, 4] >>> find_peak_elements(5, [10, 20, 15, 2, 23]) [1, 4] >>> find_peak_elements(1, [7]) [0] >>> find_peak_elements(4, [1, 2, 3, 4]) [3] >>> find_peak_elements(4, [4, 3, 2, 1]) [0] >>> find_peak_elements(5, [2, 2, 2, 2, 2]) [0, 1, 2, 3, 4] >>> find_peak_elements(7, [1, 3, 2, 3, 2, 1, 4]) [1, 3, 6] >>> find_peak_elements(3, [3, 2, 5]) [0, 2] >>> find_peak_elements(4, [1, 2, 3, 2]) [2]","solution":"def find_peak_elements(n, array): Finds the indices of all peak elements in an array. Parameters: n (int): Number of elements in the array. array (list of int): The array of elements. Returns: list of int: Indices of all peak elements. peak_indices = [] for i in range(n): # Check if the current element is a peak if (i == 0 and n > 1 and array[i] >= array[i + 1]) or (i == n - 1 and n > 1 and array[i] >= array[i - 1]) or (0 < i < n - 1 and array[i] >= array[i - 1] and array[i] >= array[i + 1]): peak_indices.append(i) # Edge case for single element array if n == 1: peak_indices.append(0) return peak_indices"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to target. >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([3, 2, 4], 6) == [1, 2] >>> two_sum([1, 2, 3, 4, 5, 6], 11) == [4, 5] >>> two_sum([-1, -2, -3, -4, 5], 1) == [3, 4] >>> two_sum([3, 3, 4], 6) == [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to target. lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return [lookup[complement], i] lookup[num] = i return None # In case there is no solution, although the prompt guarantees one solution exists."},{"question":"def comparison(str1, str2): Compares two strings lexicographically in a case-insensitive manner. Returns: - 1 if str1 comes after str2 - -1 if str1 comes before str2 - 0 if str1 is identical to str2 >>> comparison(\\"apple\\", \\"banana\\") == -1 >>> comparison(\\"banana\\", \\"apple\\") == 1 >>> comparison(\\"orange\\", \\"Orange\\") == 0 >>> comparison(\\"Grape\\", \\"grape\\") == 0","solution":"def comparison(str1, str2): Compares two strings lexicographically in a case-insensitive manner. Returns: - 1 if str1 comes after str2 - -1 if str1 comes before str2 - 0 if str1 is identical to str2 str1_lower = str1.lower() str2_lower = str2.lower() if str1_lower > str2_lower: return 1 elif str1_lower < str2_lower: return -1 else: return 0"},{"question":"def total_union_length(intervals): Returns the total length of the union of the given intervals. >>> total_union_length([[1, 3], [2, 5], [6, 8]]) 6 >>> total_union_length([[1, 2], [2, 3], [3, 4], [4, 5]]) 4","solution":"def total_union_length(intervals): Returns the total length of the union of the given intervals. if not intervals: return 0 # Sort intervals based on the starting point intervals.sort() total_length = 0 current_start, current_end = intervals[0] for start, end in intervals[1:]: if start > current_end: # No overlap total_length += current_end - current_start current_start, current_end = start, end else: # Overlap, extend the current interval current_end = max(current_end, end) # Add the length of the last interval total_length += current_end - current_start return total_length"},{"question":"def min_operations(nums: List[int]) -> int: Returns the minimum number of operations to make all elements in the array equal. >>> min_operations([1, 2, 3, 4]) 3 >>> min_operations([1, 3, 1, 3]) 2 >>> min_operations([5]) 0 >>> min_operations([2, 2, 2, 2, 2]) 0 >>> min_operations([i for i in range(1, 10**5 + 1)]) 99999 >>> min_operations([i % 2 + 1 for i in range(10**5)]) 50000","solution":"def min_operations(nums): Returns the minimum number of operations to make all elements in the array equal. from collections import defaultdict freq = defaultdict(int) max_freq = 0 for num in nums: freq[num] += 1 max_freq = max(max_freq, freq[num]) return len(nums) - max_freq"},{"question":"def findLongestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> findLongestSubstring(\\"abcabcbb\\") == 3 # \\"abc\\" >>> findLongestSubstring(\\"bbbbb\\") == 1 # \\"b\\" >>> findLongestSubstring(\\"pwwkew\\") == 3 # \\"wke\\" >>> findLongestSubstring(\\"\\") == 0 # \\"\\" >>> findLongestSubstring(\\" \\") == 1 # \\" \\" >>> findLongestSubstring(\\"aab\\") == 2 # \\"ab\\" >>> findLongestSubstring(\\"dvdf\\") == 3 # \\"vdf\\" >>> findLongestSubstring(\\"anviaj\\") == 5 # \\"nviaj\\" >>> findLongestSubstring(\\"!@#a!@#\\") == 4 # \\"!@#a\\" >>> findLongestSubstring(\\"abcdef\\") == 6 # \\"abcdef\\" >>> findLongestSubstring(\\"abccba\\") == 3 # \\"abc\\"","solution":"def findLongestSubstring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def findShortestWord(s: str) -> int: Returns the length of the shortest word in the input string. :param s: A string containing words separated by single spaces. :return: The length of the shortest word(s) in the string. >>> findShortestWord(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> findShortestWord(\\"A journey of a thousand miles begins with a single step\\") 1 >>> findShortestWord(\\"Hello world\\") 5 >>> findShortestWord(\\"Code every day\\") 4","solution":"def findShortestWord(s: str) -> int: Returns the length of the shortest word in the input string. :param s: A string containing words separated by single spaces. :return: The length of the shortest word(s) in the string. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"from typing import List def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool: Determines if it is possible to finish all courses given the prerequisites. Args: - numCourses (int): The total number of courses. - prerequisites (List[List[int]]): List of course pairs [a, b] indicating that course a depends on course b. Returns: - bool: True if it is possible to finish all courses, False otherwise. Example: >>> canFinish(2, [[1, 0]]) True >>> canFinish(2, [[1, 0], [0, 1]]) False pass # Unit Tests def test_can_finish_all_courses(): assert canFinish(2, [[1, 0]]) == True def test_cannot_finish_due_to_cycle(): assert canFinish(2, [[1, 0], [0, 1]]) == False def test_no_prerequisites(): assert canFinish(3, []) == True def test_multiple_courses_without_cycle(): assert canFinish(4, [[1, 0], [2, 1], [3, 2]]) == True def test_complex_graph_with_cycle(): assert canFinish(4, [[1, 0], [2, 1], [3, 2], [1, 3]]) == False def test_multiple_courses_with_shared_dependencies(): assert canFinish(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) == True","solution":"from collections import defaultdict, deque def canFinish(numCourses, prerequisites): Determines if it is possible to finish all courses given the prerequisites. Args: - numCourses (int): The total number of courses. - prerequisites (List[List[int]]): List of course pairs [a, b] indicating that course a depends on course b. Returns: - bool: True if it is possible to finish all courses, False otherwise. indegree = [0] * numCourses adj_list = defaultdict(list) # Build the graph and the indegree array for dest, src in prerequisites: indegree[dest] += 1 adj_list[src].append(dest) # Initialize the queue with courses having zero in-degree queue = deque([i for i in range(numCourses) if indegree[i] == 0]) visited = 0 # Count of courses that have been visited while queue: course = queue.popleft() visited += 1 for neighbor in adj_list[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return visited == numCourses"},{"question":"def is_anagram_of_palindrome(text: str) -> bool: Determine if the given text is an anagram of a palindrome. >>> is_anagram_of_palindrome(\\"Tact Coa\\") True >>> is_anagram_of_palindrome(\\"Hello\\") False >>> is_anagram_of_palindrome(\\"Aa Bb Cc D\\") True >>> is_anagram_of_palindrome(\\"abcd\\") False pass","solution":"def is_anagram_of_palindrome(text: str) -> bool: Determine if the given text is an anagram of a palindrome. from collections import Counter # Normalize the text by converting to lowercase and removing spaces. cleaned_text = text.replace(\\" \\", \\"\\").lower() # Count the frequency of each character in the text. char_count = Counter(cleaned_text) # Check how many characters have an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a text to be an anagram of a palindrome: # - All characters must have even counts or exactly one character can have an odd count. return odd_count <= 1"},{"question":"def findMedian(a: int, b: int, c: int) -> int: Returns the median of three integers a, b, and c. >>> findMedian(3, 1, 2) 2 >>> findMedian(9, 7, 8) 8 >>> findMedian(5, 5, 5) 5 >>> findMedian(-1, 0, 1) 0 >>> findMedian(-3, -2, -1) -2 >>> findMedian(0, 1, 2) 1 >>> findMedian(-100000, 0, 100000) 0 >>> findMedian(5, 5, 1) 5 >>> findMedian(1, 5, 5) 5","solution":"def findMedian(a, b, c): Returns the median of three integers a, b, and c. nums = [a, b, c] nums.sort() return nums[1] # The middle value after sorting"},{"question":"def max_profit(prices: List[int]) -> int: This function takes a list of stock prices and returns the maximum profit that can be made by buying on one day and selling on a future day. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([5]) == 0 >>> max_profit([10, 9, 8, 7, 6, 5]) == 0 >>> max_profit([1, 2, 3, 4, 5, 6]) == 5 >>> max_profit([3, 2, 6, 1, 3, 7, 2, 6]) == 6 >>> max_profit([]) == 0","solution":"def max_profit(prices): This function takes a list of stock prices and returns the maximum profit that can be made by buying on one day and selling on a future day. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def maximize_plants(n, plants, m, budgets): Determine the maximum number of plants each customer will be able to buy given their budget and the plants available. >>> maximize_plants(4, [(5, 10), (3, 10), (2, 7), (4, 9)], 3, [12, 15, 8]) [3, 4, 2] >>> maximize_plants(2, [(100, 200), (50, 180)], 4, [60, 100, 150, 200]) [1, 1, 2, 2]","solution":"def maximize_plants(n, plants, m, budgets): # Order plants primarily by growth rate descending, secondarily by price ascending plants.sort(key=lambda x: (-x[1], x[0])) result = [] for budget in budgets: count = 0 remaining_budget = budget for price, growth in plants: if remaining_budget >= price: remaining_budget -= price count += 1 result.append(count) return result # Example test case print(maximize_plants(4, [(5, 10), (3, 10), (2, 7), (4, 9)], 3, [12, 15, 8])) # Expected output: [3, 4, 2] print(maximize_plants(2, [(100, 200), (50, 180)], 4, [60, 100, 150, 200])) # Expected output: [1, 1, 2, 2]"},{"question":"def manageInventory(operations): Manage the inventory data based on various operations. Parameters: operations (List[Tuple[str, int, Optional[int]]]): A list of operations to be performed on the inventory. Returns: List[int]: The results of \\"get\\" operations in order. >>> manageInventory([ (\\"add\\", 101, 50), (\\"add\\", 102, 20), (\\"subtract\\", 101, 30), (\\"get\\", 101), (\\"get\\", 102), (\\"get\\", 103) ]) [20, 20, 0] >>> manageInventory([ (\\"add\\", 101, 50), (\\"add\\", 101, 30), (\\"add\\", 102, 20), (\\"get\\", 101), (\\"get\\", 102), ]) [80, 20]","solution":"def manageInventory(operations): inventory = {} results = [] for operation in operations: op_type = operation[0] if op_type == \\"add\\": product_id = operation[1] quantity = operation[2] if product_id in inventory: inventory[product_id] += quantity else: inventory[product_id] = quantity elif op_type == \\"subtract\\": product_id = operation[1] quantity = operation[2] if product_id in inventory: inventory[product_id] = max(0, inventory[product_id] - quantity) elif op_type == \\"get\\": product_id = operation[1] results.append(inventory.get(product_id, 0)) return results"},{"question":"def minimize_max_difference(n: int, skills: List[int]) -> int: Determine the optimal way to pair students into teams such that the difference in their programming skills within each team is minimized. If there is only one student, output should be 0. >>> minimize_max_difference(1, [7]) 0 >>> minimize_max_difference(2, [5, 8]) 3 >>> minimize_max_difference(5, [12, 3, 17, 8, 5]) 2 >>> minimize_max_difference(4, [1, 6, 3, 8]) 2 >>> minimize_max_difference(6, [1000000, 2000000, 3000000, 4000000, 5000000, 6000000]) 1000000 >>> minimize_max_difference(5, [4, 4, 3, 3, 5]) 0","solution":"def minimize_max_difference(n, skills): This function returns the minimized maximum difference in skill levels within any team. if n == 1: return 0 skills.sort() min_max_diff = float('inf') for i in range(1, n): min_max_diff = min(min_max_diff, skills[i] - skills[i-1]) return min_max_diff"},{"question":"def has_repeated_subsequence(S: str) -> str: Check whether a string S has repeated subsequences. A subsequence is a sequence derived from another sequence by deleting some elements without changing the order of remaining elements. A repeated subsequence is a subsequence that appears at least twice in the string without overlapping. >>> has_repeated_subsequence(\\"abca\\") \\"YES\\" >>> has_repeated_subsequence(\\"abcd\\") \\"NO\\" >>> has_repeated_subsequence(\\"aaaa\\") \\"YES\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each string contains repeated subsequences. Args: T (int): Number of test cases. test_cases (List[str]): List of strings to be checked. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases(3, [\\"abca\\", \\"abcd\\", \\"aaaa\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"abcd\\", \\"aabb\\"]) [\\"NO\\", \\"YES\\"] >>> process_test_cases(1, [\\"abcde\\"]) [\\"NO\\"]","solution":"def has_repeated_subsequence(S): from collections import Counter if len(S) > 26: return \\"YES\\" freq = Counter(S) if any(count > 1 for count in freq.values()): return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(has_repeated_subsequence(S)) return results"},{"question":"def can_form_by_adding_one(A: str, B: str) -> bool: Determine if string B can be formed by rearranging characters of string A and adding exactly one character. Return a boolean value True if it's possible and False otherwise. >>> can_form_by_adding_one(\\"abc\\", \\"cbad\\") True >>> can_form_by_adding_one(\\"aabb\\", \\"abca\\") False >>> can_form_by_adding_one(\\"xyz\\", \\"xyzz\\") True","solution":"def can_form_by_adding_one(A, B): Determine if string B can be formed by rearranging characters of string A and adding exactly one character. Return a boolean value True if it's possible and False otherwise. if len(B) != len(A) + 1: return False from collections import Counter countA = Counter(A) countB = Counter(B) difference = countB - countA return len(difference) == 1 and list(difference.values())[0] == 1"},{"question":"def longest_left_longest_non_decreasing_subsequence(n, sequence): Returns the length of the longest left-longest non-decreasing subsequence of the given sequence. Args: n : int : the number of elements in the sequence sequence : list of int : the sequence of integers Returns: int : the length of the longest left-longest non-decreasing subsequence >>> longest_left_longest_non_decreasing_subsequence(6, [3, 1, 2, 2, 4, 5]) 1 >>> longest_left_longest_non_decreasing_subsequence(4, [9, 8, 7, 6]) 1 >>> longest_left_longest_non_decreasing_subsequence(5, [2, 2, 2, 2, 2]) 5","solution":"def longest_left_longest_non_decreasing_subsequence(n, sequence): Returns the length of the longest left-longest non-decreasing subsequence of the given sequence. Args: n : int : the number of elements in the sequence sequence : list of int : the sequence of integers Returns: int : the length of the longest left-longest non-decreasing subsequence if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sequence[i] >= sequence[i - 1]: current_length += 1 if current_length > max_length: max_length = current_length else: break return max_length"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(values): Build a binary tree from level-order traversal values. :param values: List of integers or None, representing level-order traversal of a binary tree. :return: TreeNode, the root of the binary tree. def inorder_traversal(root, result=None): Perform an in-order traversal of the binary tree. :param root: TreeNode, the root of the binary tree. :param result: List to store the values of in-order traversal. :return: List of integer values representing in-order traversal. def transform_to_bst(root): Transform the given binary tree into a binary search tree (BST) while maintaining the original structure. :param root: TreeNode, the root of the binary tree to be transformed. :return: TreeNode, the root of the transformed binary search tree. def process_trees(tree_lines): Read lines describing binary trees, transform each into a binary search tree and return in-order traversals of the trees. :param tree_lines: List of strings, each representing a binary tree in level-order traversal. :return: List of strings, each representing the in-order traversal of the transformed BST.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(values): if not values: return None it = iter(values) root = TreeNode(next(it)) queue = [root] while queue: node = queue.pop(0) try: left_val = next(it) if left_val is not None: node.left = TreeNode(left_val) queue.append(node.left) right_val = next(it) if right_val is not None: node.right = TreeNode(right_val) queue.append(node.right) except StopIteration: break return root def inorder_traversal(root, result=None): if result is None: result = [] if root is not None: inorder_traversal(root.left, result) result.append(root.value) inorder_traversal(root.right, result) return result def transform_to_bst(root): values = inorder_traversal(root, []) values.sort() index = [0] def convert_to_bst(node): if node is None: return convert_to_bst(node.left) node.value = values[index[0]] index[0] += 1 convert_to_bst(node.right) convert_to_bst(root) return root def process_trees(tree_lines): results = [] for line in tree_lines: if line == '.': break values = [int(x) if x != 'NULL' else None for x in line.split()] root = build_tree(values) transform_to_bst(root) inorder_result = inorder_traversal(root) results.append(' '.join(map(str, inorder_result))) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, sum): Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that the sum of the node values in the path equals the given sum. >>> root = build_tree([5, 4, 8, 11, \\"null\\", 13, 4, 7, 2, \\"null\\", \\"null\\", \\"null\\", \\"null\\", \\"null\\", 1]) >>> has_path_sum(root, 22) True >>> root = build_tree([5, 4, 8, 11, \\"null\\", 13, 4, 7, 2, \\"null\\", \\"null\\", \\"null\\", \\"null\\", \\"null\\", 1]) >>> has_path_sum(root, 27) False >>> root = build_tree([1, 2, 3]) >>> has_path_sum(root, 4) True >>> root = build_tree([1]) >>> has_path_sum(root, 1) True >>> has_path_sum(None, 0) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, sum): if not root: return False if not root.left and not root.right: return root.val == sum sum -= root.val return has_path_sum(root.left, sum) or has_path_sum(root.right, sum)"},{"question":"def find_pairs(nums, target): Write a function that takes two parameters - a list of integers and a target integer - and returns a list of unique pairs (an inner list with two elements) from the given list that sum up to the target integer. The pairs in the result list should be sorted in increasing order of their first element, and for pairs that have the same first element, sorted in increasing order of their second element. Each pair should appear only once in the result. >>> find_pairs([1, 2, 3, 4, 5], 5) == [[1, 4], [2, 3]] >>> find_pairs([1, 1, 2, 3, 4, 5], 6) == [[1, 5], [2, 4]] >>> find_pairs([3, 3, 4, 4, -1, -1, 0, 0], 3) == [[-1, 4], [0, 3]] >>> find_pairs([1, 5, 1, 5], 6) == [[1, 5]] >>> find_pairs([10, -2, 3, 7, 6, 1, -6, 5], 4) == [[-6, 10], [-2, 6], [1, 3]]","solution":"def find_pairs(nums, target): Returns a list of unique pairs from the nums list that sum up to the target integer. Each pair should be sorted in increasing order of their first element, and for pairs that have the same first element, sorted in increasing order of their second element. Each pair should appear only once in the result. nums.sort() seen = set() pairs = set() for i in range(len(nums)): complement = target - nums[i] if complement in seen: pair = tuple(sorted((nums[i], complement))) pairs.add(pair) seen.add(nums[i]) result = sorted(list(pairs)) return result"},{"question":"def robot_positions(N: int): Returns a list of N unique position numbers for the robots that satisfy the given conditions. If it is not possible, returns \\"Not possible\\". >>> robot_positions(1) [1] >>> robot_positions(2) [1, 2] >>> robot_positions(3) \\"Not possible\\"","solution":"def robot_positions(N): Returns a list of N unique position numbers for the robots that satisfy the given conditions. If it is not possible, returns \\"Not possible\\". # A quick observation reveals that N > 2 is not possible if N == 1: return [1] elif N == 2: return [1, 2] else: return \\"Not possible\\""},{"question":"def baton_passing_sequences(n: int, rounds: List[Tuple[int, int]]) -> List[int]: For each round, calculate the number of valid baton passing sequences given the number of participants and the starting and ending positions for each round. >>> baton_passing_sequences(5, [(1, 5), (2, 4), (1, 3)]) [1, 1, 1] >>> baton_passing_sequences(6, [(1, 6), (3, 5)]) [1, 1] >>> baton_passing_sequences(1, [(1, 1)]) [1] >>> baton_passing_sequences(2, [(1, 2), (2, 1)]) [1, 1] >>> baton_passing_sequences(1000, [(1, 1000)]) [1]","solution":"def baton_passing_sequences(n, rounds): For each round, calculate the number of valid baton passing sequences given the number of participants and the starting and ending positions for each round. import math def num_valid_sequences(s, e): if s == e: return 1 elif abs(s - e) == 1: return 1 else: return math.comb(abs(e - s) - 1, abs(s - e) - 1) results = [] for s, e in rounds: results.append(num_valid_sequences(s, e)) return results"},{"question":"def max_sum_subarray(arr, K): Returns a subarray of size K which has the maximum sum. Examples: >>> max_sum_subarray([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) [4, 2, 10, 23] >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) [5, 1, 3] >>> max_sum_subarray([4, 4, 4, 4], 2) [4, 4]","solution":"def max_sum_subarray(arr, K): Returns a subarray of size K which has the maximum sum. n = len(arr) if n < K: return [] max_sum = float('-inf') current_sum = 0 max_sum_start = 0 # Compute the sum of the first window of size K for i in range(K): current_sum += arr[i] # Initialize the max sum with the sum of the first window max_sum = current_sum # Slide the window over the array for i in range(K, n): current_sum += arr[i] - arr[i - K] if current_sum > max_sum: max_sum = current_sum max_sum_start = i - K + 1 return arr[max_sum_start:max_sum_start + K]"},{"question":"def max_complete_sets(n, k, cards): Returns the maximum number of complete sets that can be formed from the given deck. Parameters: n (int): The number of cards. k (int): The number of different types of cards. cards (list of int): List of integers representing the type of each card in the deck. Returns: int: The maximum number of complete sets. Examples: >>> max_complete_sets(9, 3, [1, 2, 3, 1, 2, 3, 3, 2, 1]) 3 >>> max_complete_sets(7, 3, [1, 2, 3, 1, 2, 1, 3]) 2","solution":"def max_complete_sets(n, k, cards): Returns the maximum number of complete sets that can be formed from the given deck. Parameters: n (int): The number of cards. k (int): The number of different types of cards. cards (list of int): List of integers representing the type of each card in the deck. Returns: int: The maximum number of complete sets. # Count the occurrences of each card type card_count = [0] * k for card in cards: card_count[card - 1] += 1 # decrement 1 for zero-based index # The number of complete sets is limited by the card type with the minimum count return min(card_count) # Example usage: # n = 9 # k = 3 # cards = [1, 2, 3, 1, 2, 3, 3, 2, 1] # print(max_complete_sets(n, k, cards)) # Output: 3"},{"question":"def highest_peak(elevations: List[int]) -> int: Returns the highest peak in the list of elevations. A peak is defined as a point that is higher than both its immediate left and immediate right points. The first and last points in the list cannot be peaks. If there are no peaks, return -1. Parameters: elevations (list of int): A list of integers representing the elevations of the hiking trail. Returns: int: The highest peak elevation or -1 if no peaks exist. >>> highest_peak([1, 2, 3, 4, 3, 2, 1]) 4 >>> highest_peak([5, 1, 2, 3, 1]) 3 >>> highest_peak([2, 2, 2, 2]) -1 >>> highest_peak([5, 4, 3, 2, 1]) -1","solution":"def highest_peak(elevations): Returns the highest peak in the list of elevations. Parameters: elevations (list of int): A list of integers representing the elevations of the hiking trail. Returns: int: The highest peak elevation or -1 if no peaks exist. if len(elevations) < 3: return -1 peak = -1 for i in range(1, len(elevations) - 1): if elevations[i] > elevations[i - 1] and elevations[i] > elevations[i + 1]: peak = max(peak, elevations[i]) return peak"},{"question":"def nextPermutation(arr: List[int]) -> None: Modify the list in place to produce the next lexicographical permutation. If the list is in the highest possible permutation, transform it into the lowest one. >>> arr = [1, 2, 3] >>> nextPermutation(arr) >>> arr [1, 3, 2] >>> arr = [3, 2, 1] >>> nextPermutation(arr) >>> arr [1, 2, 3] >>> arr = [1, 1, 5] >>> nextPermutation(arr) >>> arr [1, 5, 1]","solution":"def nextPermutation(arr): Modify the list in place to produce the next lexicographical permutation. # Find the largest index k such that arr[k] < arr[k + 1] k = len(arr) - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k == -1: # The array is in the highest possible permutation, so transform it into the lowest one arr.reverse() return # Find the largest index l greater than k such that arr[k] < arr[l] l = len(arr) - 1 while arr[k] >= arr[l]: l -= 1 # Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Reverse the sequence from arr[k + 1] to the end arr[k + 1:] = reversed(arr[k + 1:])"},{"question":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: The merged sorted array. Example: >>> mergeSortedArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([-7, -3, 0, 5], [-6, -2, 1, 3]) [-7, -6, -3, -2, 0, 1, 3, 5]","solution":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: The merged sorted array. i, j = 0, 0 merged_array = [] while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Add remaining elements from arr1 if there are any while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Add remaining elements from arr2 if there are any while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def countPossibleStrings(S: str) -> int: Given a string S consisting of lowercase letters and stars '*', where each star can be replaced by any character, find the number of distinct possible strings that can be formed by replacing the stars with lowercase letters 'a' to 'z'. >>> countPossibleStrings(\\"a*c\\") 26 >>> countPossibleStrings(\\"*b*\\") 676 >>> countPossibleStrings(\\"abc\\") 1 >>> countPossibleStrings(\\"***\\") 26**3 >>> countPossibleStrings(\\"\\") 1 >>> countPossibleStrings(\\"*\\"*100) 26**100","solution":"def countPossibleStrings(S): Returns the number of distinct possible strings that can be formed by replacing each '*' with any character from 'a' to 'z'. star_count = S.count('*') return 26 ** star_count"},{"question":"def min_operations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum number of operations required to make all elements in the array equal. >>> min_operations(3, [(4, [1, 2, 3, 4]), (3, [2, 2, 2]), (5, [5, 6, 7, 8, 9])]) [3, 0, 4] >>> min_operations(2, [(2, [1, 1]), (3, [3, 1, 3])]) [0, 1]","solution":"def min_operations(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] unique_elements = set(a) # If all elements are already the same if len(unique_elements) == 1: results.append(0) continue max_freq = max(a.count(x) for x in unique_elements) results.append(len(a) - max_freq) return results"},{"question":"def minimum_operations(S: str) -> int: Calculate the minimum number of operations required to make all characters in the string the same. :param S: A string containing only 'X' and 'Y'. :return: An integer representing the minimum number of operations required. Example: >>> minimum_operations(\\"XXXY\\") 1 >>> minimum_operations(\\"YXXXYXY\\") 3","solution":"def minimum_operations(S): Returns the minimum number of operations required to make all characters in the string the same. :param S: A string containing only 'X' and 'Y'. :return: Minimum number of operations. count_X = S.count('X') count_Y = S.count('Y') # The minimum number of operations would be converting all X's to Y's or all Y's to X's, # whichever is smaller return min(count_X, count_Y)"},{"question":"def generate_ascii_art(n: int) -> List[str]: Generates an ASCII art pattern with n rows. Each row contains a sequence of characters starting from 'A'. The length of each row increases by 1 compared to the previous row, and the first character of each row starts from the next character in the alphabet compared to the last row. Args: n (int): The number of rows. Returns: List[str]: A list of strings where each string represents a row of the pattern. >>> generate_ascii_art(4) ['A', 'BC', 'CDE', 'DEFG'] >>> generate_ascii_art(5) ['A', 'BC', 'CDE', 'DEFG', 'EFGHI'] >>> generate_ascii_art(1) ['A']","solution":"def generate_ascii_art(n): Generates an ASCII art pattern with n rows. Each row contains a sequence of characters starting from 'A'. The length of each row increases by 1 compared to the previous row, and the first character of each row starts from the next character in the alphabet compared to the last row. Args: n (int): The number of rows Returns: List[str]: A list of strings where each string represents a row of the pattern pattern = [] for i in range(n): start_char = chr(ord('A') + i) row = ''.join(chr(ord(start_char) + j) for j in range(i + 1)) pattern.append(row) return pattern"},{"question":"from typing import List from math import gcd from functools import reduce def find_gcd(arr: List[int]) -> int: Returns the GCD of a list of positive integers. >>> find_gcd([24, 36, 48]) 12 >>> find_gcd([5, 10, 15]) 5","solution":"from math import gcd from functools import reduce def find_gcd(arr): Returns the GCD of a list of positive integers. return reduce(gcd, arr)"},{"question":"def compress_string(s: str) -> str: Compress the string by using the counts of repeated characters. If the compressed string is not shorter, return the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aaabbbbcc\\") \\"a3b4c2\\" >>> compress_string(\\"aaaaa\\") \\"a5\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"abababab\\") \\"abababab\\"","solution":"def compress_string(s): Compress the string by using the counts of repeated characters. If the compressed string is not shorter, return the original string. compressed = [] count = 1 # Iterate over the string to build the compressed string for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Append the last group of characters compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"from typing import List def sumOfSubarrayMinimums(arr: List[int]) -> int: Implement a function sumOfSubarrayMinimums that, given an array of integers, returns the sum of the minimum value of every subarray of the given array. Since the result can be large, return the result modulo 10^9 + 7. Args: arr (List[int]): List of integers. Returns: int: Sum of the minimum value of every subarray modulo 10^9 + 7. Examples: >>> sumOfSubarrayMinimums([3, 1, 2, 4]) 17 >>> sumOfSubarrayMinimums([1]) 1 >>> sumOfSubarrayMinimums([2, 2, 2]) 12 >>> sumOfSubarrayMinimums([1, 2, 3, 4]) 20 >>> sumOfSubarrayMinimums([4, 3, 2, 1]) 20","solution":"from typing import List def sumOfSubarrayMinimums(arr: List[int]) -> int: MOD = 10**9 + 7 n = len(arr) left = [0] * n right = [0] * n # Initialize monotonic stacks stack = [] # Fill left distances for i in range(n): while stack and arr[stack[-1]] > arr[i]: stack.pop() left[i] = i + 1 if not stack else i - stack[-1] stack.append(i) # Clear stack to reuse stack = [] # Fill right distances for i in range(n-1, -1, -1): while stack and arr[stack[-1]] >= arr[i]: stack.pop() right[i] = n - i if not stack else stack[-1] - i stack.append(i) # Calculate result result = 0 for i in range(n): result = (result + arr[i] * left[i] * right[i]) % MOD return result"},{"question":"def max_tasks(costs, budget): Determines the maximum number of tasks that can be completed within the given budget. :param costs: List of integers representing the cost of each task :param budget: Integer representing the available budget :return: Maximum number of tasks that can be completed within the budget >>> max_tasks([5, 3, 8, 4, 2], 10) 3 >>> max_tasks([10, 10, 10], 10) 1","solution":"def max_tasks(costs, budget): Determines the maximum number of tasks that can be completed within the given budget. :param costs: List of integers representing the cost of each task :param budget: Integer representing the available budget :return: Maximum number of tasks that can be completed within the budget costs.sort() total_cost = 0 task_count = 0 for cost in costs: if total_cost + cost <= budget: total_cost += cost task_count += 1 else: break return task_count"},{"question":"import math from typing import List def countDistinctPrimeFactors(N: int) -> int: Returns the number of distinct prime factors of N. >>> countDistinctPrimeFactors(28) 2 >>> countDistinctPrimeFactors(60) 3 >>> countDistinctPrimeFactors(13) 1 >>> countDistinctPrimeFactors(1000000007) 1 >>> countDistinctPrimeFactors(100) 2 >>> countDistinctPrimeFactors(1) 0 >>> countDistinctPrimeFactors(2) 1","solution":"import math def countDistinctPrimeFactors(N): Returns the number of distinct prime factors of N. if N < 2: return 0 distinct_prime_factors = set() # Check for smallest factor 2 while N % 2 == 0: distinct_prime_factors.add(2) N //= 2 # Check for odd factors from 3 onwards for i in range(3, int(math.sqrt(N)) + 1, 2): while N % i == 0: distinct_prime_factors.add(i) N //= i # If N is still greater than 2, it must be a prime factor itself if N > 2: distinct_prime_factors.add(N) return len(distinct_prime_factors)"},{"question":"def prime_factors_sum(n: int) -> int: Find the sum of all unique prime factors of all numbers from 1 to \`n\` (inclusive). >>> prime_factors_sum(10) == 17 >>> prime_factors_sum(15) == 41 >>> prime_factors_sum(1) == 0 >>> prime_factors_sum(20) == 77 >>> prime_factors_sum(100) == 1060 pass # Implement the function here.","solution":"def prime_factors_sum(n: int) -> int: def sieve_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if is_prime[p] == True: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, limit + 1) if is_prime[p]] return primes primes = sieve_eratosthenes(n) return sum(primes)"},{"question":"def find_unique_number(nums): Returns the number that appears exactly once in the list where all other numbers appear exactly thrice. >>> find_unique_number([2, 2, 3, 2, 5, 5, 5]) == 3 >>> find_unique_number([8, 8, 7, 8]) == 7 >>> find_unique_number([10, 10, 10, 6, 6, 6, 8, 8, 8, 5]) == 5 >>> find_unique_number([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7]) == 7 >>> find_unique_number([42]) == 42 >>> find_unique_number([-1, -1, -1, -2, -2, -2, -3]) == -3 >>> find_unique_number([300, 300, 300, -300, -300, -300, 0, 0, 0, 1]) == 1 >>> find_unique_number([999999999, 999999999, 999999999, 123456789]) == 123456789 >>> find_unique_number([0, 0, 0, 0, 0, 0, 0, 1]) == 1","solution":"def find_unique_number(nums): Returns the number that appears exactly once in the list where all other numbers appear exactly thrice. Parameters: nums (list): List of integers Returns: int: The unique number ones, twos = 0, 0 for num in nums: twos |= ones & num ones ^= num common_mask = ~(ones & twos) ones &= common_mask twos &= common_mask return ones"},{"question":"def find_subsequence(arr, T): Returns \\"YES\\" if there's a contiguous subarray in arr that sums up to T, otherwise returns \\"NO\\". >>> find_subsequence([1, 2, 3, 4, 5], 9) \\"YES\\" >>> find_subsequence([1, 2, 3, 4, 5], 15) \\"YES\\" >>> find_subsequence([1, 2, 3, 4, 5], 8) \\"NO\\"","solution":"def find_subsequence(arr, T): Returns \\"YES\\" if there's a contiguous subarray in arr that sums up to T, otherwise \\"NO\\". current_sum = 0 start_index = 0 for end_index in range(len(arr)): current_sum += arr[end_index] # Shrink the window until the current_sum is <= T while current_sum > T and start_index <= end_index: current_sum -= arr[start_index] start_index += 1 if current_sum == T: return \\"YES\\" return \\"NO\\""},{"question":"def process_operations(N: int, M: int, K: int, operations: List[Tuple[int, ...]]) -> List[int]: Given a grid of size N x M initially filled with zeros and K operations, this function processes the operations and returns the results for the sum queries. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. K (int): Number of operations. operations (List[Tuple[int, ...]]): List of tuples where each tuple represents an operation. Returns: List[int]: Results for the sum queries. Example: >>> N = 5 >>> M = 5 >>> K = 6 >>> operations = [(1, 1, 1, 5), (1, 2, 3, 7), (2, 1, 1, 2, 3), (1, 3, 3, 2), (2, 2, 2, 5, 5), (2, 1, 1, 5, 5)] >>> process_operations(N, M, K, operations) [12, 9, 14] >>> N = 3 >>> M = 3 >>> K = 1 >>> operations = [(1, 1, 1, 5)] >>> process_operations(N, M, K, operations) [] >>> N = 3 >>> M = 3 >>> K = 1 >>> operations = [(2, 1, 1, 3, 3)] >>> process_operations(N, M, K, operations) [0] >>> N = 4 >>> M = 4 >>> K = 5 >>> operations = [(1, 2, 2, 1), (1, 3, 3, 2), (2, 1, 1, 3, 3), (1, 4, 4, 3), (2, 2, 2, 4, 4)] >>> process_operations(N, M, K, operations) [3, 6]","solution":"def process_operations(N, M, K, operations): grid = [[0] * M for _ in range(N)] results = [] for operation in operations: op_type, *args = operation if op_type == 1: r, c, x = args grid[r-1][c-1] = x elif op_type == 2: r1, c1, r2, c2 = args subgrid_sum = 0 for r in range(r1-1, r2): for c in range(c1-1, c2): subgrid_sum += grid[r][c] results.append(subgrid_sum) return results"},{"question":"from typing import List def minRiskPath(N: int, Tunnels: List[List[int]], risk: List[int], A: int, B: int) -> int: Calculate the minimum risk level encountered on the path from station A to station B. >>> minRiskPath(5, [[1, 2], [2, 3], [2, 4], [4, 5]], [5, 3, 8, 2, 6], 1, 5) 2 >>> minRiskPath(3, [[1, 2], [1, 3]], [4, 6, 1], 1, 3) 1 pass","solution":"def minRiskPath(N, Tunnels, risk, A, B): from collections import defaultdict, deque # Create adjacency list for graph representation graph = defaultdict(list) for u, v in Tunnels: graph[u].append(v) graph[v].append(u) def find_path_min_risk(start, end): visited = [False] * (N + 1) min_risk = float('inf') queue = deque([(start, risk[start - 1])]) # Using deque for BFS while queue: node, current_min_risk = queue.popleft() if node == end: return current_min_risk visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: queue.append((neighbor, min(current_min_risk, risk[neighbor - 1]))) return min_risk return find_path_min_risk(A, B)"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: For each day, calculate how many days you would have to wait until a warmer temperature. If there is no future day with a warmer temperature, the answer for that day is zero. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 90, 80, 70, 60]) [0, 0, 0, 0, 0] >>> daily_temperatures([50]) [0] >>> daily_temperatures([70, 70, 70, 70, 70]) [0, 0, 0, 0, 0] >>> daily_temperatures([30, 50, 20, 40, 10]) [1, 0, 1, 0, 0] >>> daily_temperatures([]) []","solution":"def daily_temperatures(temperatures): For each day, calculates how many days you would have to wait until a warmer temperature. If there is no future day with a warmer temperature, the answer for that day is zero. n = len(temperatures) answer = [0] * n stack = [] # This will store indices of the temperatures list. for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() answer[index] = i - index stack.append(i) return answer"},{"question":"def is_balanced(s: str) -> bool: Returns True if the input string 's' has balanced brackets. Else, returns False. Only the brackets '()', '[]', '{}', and '<>' are considered. >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"([{})\\") False >>> is_balanced(\\"{[<>]}\\") True >>> is_balanced(\\"{[(>)]}\\") False >>> is_balanced(\\"a(b[c]d){e}f<g>\\") True >>> is_balanced(\\"a(b[c)d]e{f}g<h>\\") False","solution":"def is_balanced(s): Returns True if the input string 's' has balanced brackets. Else, returns False. Only the brackets '()', '[]', '{}', and '<>' are considered. stack = [] bracket_map = {')': '(', ']': '[', '}': '{', '>': '<'} opening_brackets = set(bracket_map.values()) for char in s: if char in opening_brackets: stack.append(char) elif char in bracket_map: if not stack or stack.pop() != bracket_map[char]: return False return not stack"},{"question":"from typing import List, Tuple # Initialize the inventory as an empty list of books inventory = [] def add_book(book: Tuple[str, str, str]) -> None: Adds a new book to the inventory. Parameters: book (tuple): A tuple containing the title, author, and genre of the book. pass def remove_book(title: str) -> None: Removes a book from the inventory by title. Parameters: title (str): The title of the book to be removed. pass def list_books_by_genre(genre: str) -> List[str]: Lists all books in the inventory by a given genre, ordered alphabetically by title. Parameters: genre (str): The genre to filter books by. Returns: list: A list of book titles in the specified genre, ordered alphabetically by title. pass","solution":"from typing import List, Tuple # Initialize the inventory as an empty list of books inventory = [] def add_book(book: Tuple[str, str, str]) -> None: Adds a new book to the inventory. Parameters: book (tuple): A tuple containing the title, author, and genre of the book. inventory.append(book) def remove_book(title: str) -> None: Removes a book from the inventory by title. Parameters: title (str): The title of the book to be removed. global inventory inventory = [book for book in inventory if book[0] != title] def list_books_by_genre(genre: str) -> List[str]: Lists all books in the inventory by a given genre, ordered alphabetically by title. Parameters: genre (str): The genre to filter books by. Returns: list: A list of book titles in the specified genre, ordered alphabetically by title. books_of_genre = [book[0] for book in inventory if book[2] == genre] return sorted(books_of_genre) #"},{"question":"from typing import List def find_trending_hashtags(posts: List[str], threshold: int) -> List[str]: Analyzes posts to find all trending topics based on the given threshold. A hashtag is considered trending if it appears more than or equal to \`threshold\` times in the given list of posts. Args: posts (List[str]): A list of social media posts containing hashtags. threshold (int): The minimum frequency required for a hashtag to be considered trending. Returns: List[str]: A list of unique hashtags that appear at least \`threshold\` times, sorted in lexicographical order. Examples: >>> find_trending_hashtags([\\"#fun #sun #happy\\", \\"#sun #work\\", \\"#fun #happy\\", \\"#sleep #fun\\"], 2) ['#fun', '#happy', '#sun'] >>> find_trending_hashtags([\\"#a #b #c\\", \\"#d #e #f\\", \\"#g #h #i\\"], 2) []","solution":"from typing import List from collections import Counter import re def find_trending_hashtags(posts: List[str], threshold: int) -> List[str]: Returns a list of hashtags that appear at least \`threshold\` times in the given list of posts. The hashtags in the result list are sorted in lexicographical order. hashtag_pattern = re.compile(r'#w+') hashtag_count = Counter() for post in posts: hashtags_in_post = hashtag_pattern.findall(post) hashtag_count.update(hashtags_in_post) trending_hashtags = [hashtag for hashtag, count in hashtag_count.items() if count >= threshold] trending_hashtags.sort() return trending_hashtags"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determine if any two distinct elements in the array add up to the target sum. Args: arr (List[int]): List of distinct integers. target (int): The target sum to check. Returns: bool: True if there exists two distinct integers in the array that add up to the target sum, otherwise False. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) == True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == False >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([5], 5) == False >>> has_pair_with_sum([1, 2, 3, 8, 9], 20) == False >>> has_pair_with_sum([1, 5, 3, 6, 7], 8) == True >>> has_pair_with_sum([-3, 1, 2, -1, -2], 0) == True >>> has_pair_with_sum([-3, 1, 2, -1, -2], -5) == True >>> has_pair_with_sum([0, -1, 1, -2, 2], 0) == True","solution":"def has_pair_with_sum(arr, target): Determine if any two distinct elements in the array add up to the target sum. Args: arr (List[int]): List of distinct integers. target (int): The target sum to check. Returns: bool: True if there exists two distinct integers in the array that add up to the target sum, otherwise False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def remainingBudget(startingBudget, transactions): Calculates the remaining budget after applying a list of transactions. If budget goes below zero at any point, returns \\"Budget overdrawn!\\". Parameters: startingBudget (int): The initial budget. transactions (list): A list of transactions as strings, where each transaction is a positive or negative integer. Returns: int or str: The remaining budget or \\"Budget overdrawn!\\" if budget goes below zero. from solution import remainingBudget def test_remainingBudget_no_transactions(): assert remainingBudget(1000, []) == 1000 def test_remainingBudget_all_positive(): assert remainingBudget(1000, [\\"+100\\", \\"+200\\", \\"+300\\"]) == 1600 def test_remainingBudget_mix_transactions(): assert remainingBudget(1000, [\\"-200\\", \\"+300\\", \\"-500\\"]) == 600 def test_remainingBudget_overdrawn_midway(): assert remainingBudget(500, [\\"-400\\", \\"+100\\", \\"-300\\"]) == \\"Budget overdrawn!\\" def test_remainingBudget_large_overdrawn_first_transaction(): assert remainingBudget(500, [\\"-600\\", \\"+200\\", \\"+100\\"]) == \\"Budget overdrawn!\\" def test_remainingBudget_no_change(): assert remainingBudget(300, []) == 300 def test_remainingBudget_exactly_zero(): assert remainingBudget(500, [\\"-100\\", \\"-100\\", \\"-300\\"]) == 0","solution":"def remainingBudget(startingBudget, transactions): Calculates the remaining budget after applying a list of transactions. If budget goes below zero at any point, returns \\"Budget overdrawn!\\". Parameters: startingBudget (int): The initial budget. transactions (list): A list of transactions as strings, where each transaction is a positive or negative integer. Returns: int or str: The remaining budget or \\"Budget overdrawn!\\" if budget goes below zero. # Initialize the current budget to the starting budget currentBudget = startingBudget # loop through each transaction for transaction in transactions: # Parse transaction to integer and apply it to the current budget currentBudget += int(transaction) # If current budget goes below zero, return error message if currentBudget < 0: return \\"Budget overdrawn!\\" # Return the remaining budget after all transactions return currentBudget"},{"question":"def max_length_of_cut(N: int, lengths: List[int]) -> int: Returns the maximum possible length L that Alice can cut each rope into such that all ropes are of the same length L and the waste is minimized. >>> max_length_of_cut(4, [9, 7, 5, 12]) 3 >>> max_length_of_cut(3, [8, 3, 6]) 3","solution":"from math import gcd from functools import reduce def max_length_of_cut(N, lengths): Returns the maximum possible length L that Alice can cut each rope into such that all ropes are of the same length L and the waste is minimized. def gcd_of_list(nums): return reduce(gcd, nums) return gcd_of_list(lengths)"},{"question":"def maximal_rectangle(matrix): Determine the largest rectangular area that can be formed using only cells that contain the value 1. The grid is represented as a list of list of integers where 0 <= grid[i][j] <= 1. Args: matrix: List[List[int]] Returns: int: the area of the largest rectangle consisting only of 1s in the grid. >>> maximal_rectangle([ ... [1, 0, 1, 0], ... [1, 0, 1, 1], ... [1, 1, 1, 1], ... [1, 0, 1, 1] ... ]) 6 >>> maximal_rectangle([ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) 3 >>> maximal_rectangle([ ... [1, 1, 1, 1] ... ]) 4 >>> maximal_rectangle([ ... [1], ... [1], ... [1], ... [1] ... ]) 4 >>> maximal_rectangle([]) 0 >>> maximal_rectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def maximal_rectangle(matrix): if not matrix: return 0 n, m = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * m for row in matrix: for j in range(m): heights[j] = heights[j] + 1 if row[j] == 1 else 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): stack = [-1] max_area = 0 for i in range(len(heights)): while stack[-1] != -1 and heights[stack[-1]] >= heights[i]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack[-1] != -1: h = heights[stack.pop()] w = len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"def nthFibonacci(N): Returns the N-th Fibonacci number, using modulo 10^9 + 7 >>> nthFibonacci(5) == 3 >>> nthFibonacci(7) == 8 >>> nthFibonacci(10) == 34 >>> nthFibonacci(1) == 0 >>> nthFibonacci(2) == 1 >>> nthFibonacci(100) == 218922995834555169026 % (10**9 + 7)","solution":"def nthFibonacci(N): Returns the N-th Fibonacci number, using modulo 10^9 + 7 MOD = 10**9 + 7 if N == 1: return 0 elif N == 2: return 1 fib = [0] * N fib[0], fib[1] = 0, 1 for i in range(2, N): fib[i] = (fib[i-1] + fib[i-2]) % MOD return fib[-1]"},{"question":"def hasUnobstructedView(buildings: List[int], index: int) -> bool: Determine if the building at the given index has an unobstructed view to the right. Args: buildings (list): List of integers representing building heights. index (int): Index of the building to check. Returns: bool: True if the building at the given index has an unobstructed view, False otherwise. >>> hasUnobstructedView([3, 7, 8, 3, 6, 1], 2) == True >>> hasUnobstructedView([3, 7, 8, 3, 6, 1], 1) == False","solution":"def hasUnobstructedView(buildings, index): Determine if the building at the given index has an unobstructed view to the right. Args: buildings (list): List of integers representing building heights. index (int): Index of the building to check. Returns: bool: True if the building at the given index has an unobstructed view, False otherwise. height = buildings[index] for i in range(index + 1, len(buildings)): if buildings[i] >= height: return False return True"},{"question":"def can_be_palindrome_with_k_removals(k: int, s: str) -> str: Determines whether you can make the string a palindrome by removing at most k characters. >>> can_be_palindrome_with_k_removals(1, \\"abbca\\") \\"YES\\" >>> can_be_palindrome_with_k_removals(2, \\"abcdecba\\") \\"YES\\" >>> can_be_palindrome_with_k_removals(1, \\"abcdef\\") \\"NO\\"","solution":"def can_be_palindrome_with_k_removals(k, s): Determines whether the string s can be made a palindrome by removing at most k characters. :param k: Maximum number of characters to remove. :param s: The input string. :return: 'YES' if the string can be made a palindrome by removing at most k characters, otherwise 'NO'. def is_palindrome(s, l, r): Helper function to check whether a substring s[l:r+1] is a palindrome. while l < r: if s[l] != s[r]: return False l += 1 r -= 1 return True def helper(s, l, r, k): Recursively try to match characters and use at most k removals to make the substring s[l:r+1] a palindrome. if k < 0: return False if l >= r: return True if s[l] == s[r]: return helper(s, l + 1, r - 1, k) else: return helper(s, l + 1, r, k - 1) or helper(s, l, r - 1, k - 1) return \\"YES\\" if helper(s, 0, len(s) - 1, k) else \\"NO\\""},{"question":"from typing import List, Tuple def knapsack(max_weight: int, items: List[Tuple[int, int]]) -> int: Determines the maximum value of items that can be carried without exceeding the max_weight. Parameters: - max_weight: int: The maximum weight capacity of the knapsack. - items: List[Tuple[int, int]]: A list of tuples where each tuple consists of two integers: (value, weight). Returns: - int: The maximum value that can be carried without exceeding the weight constraints. Examples: >>> knapsack(50, [(60, 10), (100, 20), (120, 30)]) 220 >>> knapsack(50, []) 0 >>> knapsack(50, [(100, 50)]) 100 >>> knapsack(50, [(100, 60)]) 0","solution":"from typing import List, Tuple def knapsack(max_weight: int, items: List[Tuple[int, int]]) -> int: Determines the maximum value of items that can be carried without exceeding the max_weight. Parameters: - max_weight: int: The maximum weight capacity of the knapsack. - items: List[Tuple[int, int]]: A list of tuples where each tuple consists of two integers: (value, weight). Returns: - int: The maximum value that can be carried without exceeding the weight constraints. n = len(items) dp = [[0] * (max_weight + 1) for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i-1] for w in range(max_weight + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][max_weight]"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Determines the maximum total value of supplies that Ramesh can carry without exceeding the weight limit. Parameters: n (int): Number of items. W (int): Capacity of the backpack. items (List[Tuple[int, int]]): List of tuples, where each tuple contains two integers (weight, value) of an item. Returns: int: Maximum total value of supplies that can be carried. Examples: >>> knapsack(4, 7, [(3, 4), (4, 5), (2, 3), (3, 2)]) 9 >>> knapsack(3, 5, [(1, 2), (2, 4), (3, 1)]) 6 >>> knapsack(5, 10, [(2, 1), (4, 8), (2, 4), (5, 5), (3, 6)]) 18","solution":"def knapsack(n, W, items): Determines the maximum total value of supplies that Ramesh can carry without exceeding the weight limit. :param n: Number of items :param W: Capacity of the backpack :param items: List of tuples, where each tuple contains two integers (weight, value) of an item :return: Maximum total value of supplies that can be carried # Initialize a DP table with zero values dp = [[0] * (W + 1) for _ in range(n + 1)] # Iterate through each item for i in range(1, n + 1): wi, vi = items[i - 1] for w in range(W + 1): if wi <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-wi] + vi) else: dp[i][w] = dp[i-1][w] return dp[n][W]"},{"question":"def is_mary_sequence(sequence: List[int]) -> str: Determines if the given sequence is a 'Mary's sequence'. A 'Mary's sequence' is a sequence of positive integers where each number is greater than the sum of the previous two numbers. Args: sequence (list of int): the sequence of integers to be checked. Returns: str: 'Yes' if the sequence is a Mary's sequence, 'No' otherwise. Examples: >>> is_mary_sequence([1, 2, 4, 8, 15]) 'Yes' >>> is_mary_sequence([5, 1, 4, 9]) 'No' # Implement the function here def test_is_mary_sequence_yes_case1(): assert is_mary_sequence([1, 2, 4, 8, 15]) == \\"Yes\\" def test_is_mary_sequence_no_case1(): assert is_mary_sequence([5, 1, 4, 9]) == \\"No\\" def test_is_mary_sequence_minimum_length_yes(): assert is_mary_sequence([1, 1, 3]) == \\"Yes\\" def test_is_mary_sequence_minimum_length_no(): assert is_mary_sequence([1, 1, 2]) == \\"No\\" def test_is_mary_sequence_large_numbers_yes(): assert is_mary_sequence([100000, 200000, 500001, 1000000, 2000001]) == \\"Yes\\" def test_is_mary_sequence_large_numbers_no(): assert is_mary_sequence([100000, 200000, 300000, 500000, 800000]) == \\"No\\"","solution":"def is_mary_sequence(sequence): Determines if the given sequence is a 'Mary's sequence'. A 'Mary's sequence' is a sequence of positive integers where each number is greater than the sum of the previous two numbers. Args: sequence (list of int): the sequence of integers to be checked. Returns: str: 'Yes' if the sequence is a Mary's sequence, 'No' otherwise. n = len(sequence) for i in range(2, n): if sequence[i] <= sequence[i-1] + sequence[i-2]: return \\"No\\" return \\"Yes\\""},{"question":"class LibrarySystem: def __init__(self): Initializes an empty library system. pass def add_book(self, book): Adds a book with name \`book\` to the library. >>> library = LibrarySystem() >>> library.add_book(\\"Harry_Potter_1\\") def remove_book(self, book): Removes a book with name \`book\` from the library if it's not checked out. >>> library = LibrarySystem() >>> library.add_book(\\"Harry_Potter_1\\") >>> library.remove_book(\\"Harry_Potter_1\\") def checkout_book(self, book, user): Checkouts the book with name \`book\` to the user \`user\`. >>> library = LibrarySystem() >>> library.add_book(\\"Harry_Potter_1\\") >>> library.checkout_book(\\"Harry_Potter_1\\", \\"alice\\") def return_book(self, book): Returns the book with name \`book\` to the library. >>> library = LibrarySystem() >>> library.add_book(\\"Harry_Potter_1\\") >>> library.checkout_book(\\"Harry_Potter_1\\", \\"alice\\") >>> library.return_book(\\"Harry_Potter_1\\") def who_has(self, book): Queries who currently has the book with name \`book\`. >>> library = LibrarySystem() >>> library.add_book(\\"Harry_Potter_1\\") >>> library.checkout_book(\\"Harry_Potter_1\\", \\"alice\\") >>> library.who_has(\\"Harry_Potter_1\\") == \\"alice\\" True >>> library.return_book(\\"Harry_Potter_1\\") >>> library.who_has(\\"Harry_Potter_1\\") == \\"NOBODY\\" True def library_operations(operations): Processes a list of operations on the library system. >>> operations = [ ... \\"ADD Harry_Potter_1\\", ... \\"ADD Harry_Potter_2\\", ... \\"CHECKOUT Harry_Potter_1 alice\\", ... \\"CHECKOUT Harry_Potter_2 bob\\", ... \\"WHO_HAS Harry_Potter_1\\", ... \\"WHO_HAS Harry_Potter_3\\", ... \\"RETURN Harry_Potter_1\\" ... ] >>> library_operations(operations) == [\\"alice\\", \\"NOBODY\\"] True pass","solution":"class LibrarySystem: def __init__(self): self.books = {} self.checked_out = {} def add_book(self, book): if book not in self.books: self.books[book] = None def remove_book(self, book): if book in self.books and self.books[book] is None: del self.books[book] def checkout_book(self, book, user): if book in self.books and self.books[book] is None: self.books[book] = user def return_book(self, book): if book in self.books and self.books[book] is not None: self.books[book] = None def who_has(self, book): if book in self.books: return self.books[book] if self.books[book] else \\"NOBODY\\" return \\"NOBODY\\" def library_operations(operations): library = LibrarySystem() results = [] for operation in operations: parts = operation.split() op = parts[0] book = parts[1] if op == \\"ADD\\": library.add_book(book) elif op == \\"REMOVE\\": library.remove_book(book) elif op == \\"CHECKOUT\\": user = parts[2] library.checkout_book(book, user) elif op == \\"RETURN\\": library.return_book(book) elif op == \\"WHO_HAS\\": results.append(library.who_has(book)) return results"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the total number of distinct palindromic substrings in the given string. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"abcd\\") 4 >>> count_palindromic_substrings(\\"\\") 0 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"ab\\") 2 >>> count_palindromic_substrings(\\"a\\" * 1000) 500500","solution":"def count_palindromic_substrings(s): Returns the total number of distinct palindromic substrings in the given string. n = len(s) count = 0 # Helper function to expand around the center def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 # Visit each character and try to expand around the center for i in range(n): expand_around_center(i, i) # Odd length palindromes expand_around_center(i, i + 1) # Even length palindromes return count"},{"question":"def solve(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of N integers, find the length of the longest subsequence that can be removed from the list such that the remaining elements are sorted in non-decreasing order. Args: t : int : The number of test cases. test_cases : List[Tuple[int, List[int]]] : A list containing tuples for each test case. Each tuple contains an integer N and a list of N integers representing the elements of the list. Returns: List[int] : A list of integers where each integer represents the length of the longest subsequence that can be removed for the respective test case. Example: >>> solve(2, [(5, [1, 3, 2, 1, 4]), (4, [4, 3, 2, 1])]) [2, 3] >>> solve(1, [(6, [1, 2, 3, 4, 5, 6])]) [0] # You need to implement this function def test_example1(): t = 2 test_cases = [(5, [1, 3, 2, 1, 4]), (4, [4, 3, 2, 1])] expected = [2, 3] assert solve(t, test_cases) == expected def test_all_increasing(): t = 1 test_cases = [(6, [1, 2, 3, 4, 5, 6])] expected = [0] assert solve(t, test_cases) == expected def test_all_decreasing(): t = 1 test_cases = [(6, [6, 5, 4, 3, 2, 1])] expected = [5] assert solve(t, test_cases) == expected def test_single_element(): t = 1 test_cases = [(1, [42])] expected = [0] assert solve(t, test_cases) == expected def test_alternating_elements(): t = 1 test_cases = [(6, [1, 3, 2, 4, 3, 5])] expected = [2] assert solve(t, test_cases) == expected def test_large_numbers(): t = 1 test_cases = [(5, [-1000000000, 1000000000, 0, -999999999, 999999999])] expected = [2] assert solve(t, test_cases) == expected","solution":"def longest_subseq_to_remove(A): Returns the length of the longest subsequence that can be removed from list A so that the remaining elements are sorted in non-decreasing order. from bisect import bisect_left def length_of_lis(sequence): Computes the length of the longest increasing subsequence in the given sequence. lis = [] for x in sequence: pos = bisect_left(lis, x) if pos == len(lis): lis.append(x) else: lis[pos] = x return len(lis) # Length of the longest increasing subsequence lis_length = length_of_lis(A) # Length of the longest subsequence that can be removed return len(A) - lis_length def solve(t, test_cases): results = [] for i in range(t): N, A = test_cases[i] result = longest_subseq_to_remove(A) results.append(result) return results"},{"question":"def is_mountain_array(arr): Determine if the given array is a mountain array. >>> is_mountain_array([2, 1, 4, 7, 3, 2, 5]) == False >>> is_mountain_array([3, 5, 5]) == False >>> is_mountain_array([0, 3, 2, 1]) == True pass def check_mountain_arrays(test_cases): Evaluate multiple test cases to determine if each one is a mountain array. >>> check_mountain_arrays([[2, 1, 4, 7, 3, 2, 5], [3, 5, 5], [0, 3, 2, 1]]) == [\\"NO\\", \\"NO\\", \\"YES\\"] >>> check_mountain_arrays([[1, 2, 3, 2, 1], [1, 2, 3, 4, 5, 4, 3, 2, 1], [1, 2, 3]]) == [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def is_mountain_array(arr): Returns if the array is a mountain array. n = len(arr) if n < 3: return False i = 0 # walk up while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # peak can't be first or last if i == 0 or i == n - 1: return False # walk down while i + 1 < n and arr[i] > arr[i + 1]: i += 1 return i == n - 1 def check_mountain_arrays(test_cases): results = [] for arr in test_cases: if is_mountain_array(arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_length_substring(s: str, k: int) -> int: Finds the maximum length of a contiguous substring in which every letter appears at least k times. Parameters: s (str): Input string consisting of lowercase English letters. k (int): Minimum number of times each letter must appear in the substring. Returns: int: The maximum length of the required substring. >>> max_length_substring(\\"aaabb\\", 3) 3 >>> max_length_substring(\\"ababbc\\", 2) 5","solution":"def max_length_substring(s, k): Finds the maximum length of a contiguous substring in which every letter appears at least k times. Parameters: s (str): Input string consisting of lowercase English letters. k (int): Minimum number of times each letter must appear in the substring. Returns: int: The maximum length of the required substring. from collections import Counter def is_valid(counter, k): Checks if all counts in counter are at least k. Parameters: counter (Counter): A dictionary with character occurrences. k (int): Minimum number of times each letter must appear in the substring. Returns: bool: True if all counts are at least k, False otherwise. for count in counter.values(): if count < k: return False return True n = len(s) max_len = 0 # Try to find substring for each possible distinct letter requirement (1 to 26) for target_unique in range(1, 27): counter = Counter() start = 0 unique = 0 for end in range(n): if counter[s[end]] == 0: unique += 1 counter[s[end]] += 1 while unique > target_unique: if counter[s[start]] == 1: unique -= 1 counter[s[start]] -= 1 start += 1 if unique == target_unique and is_valid(counter, k): max_len = max(max_len, end - start + 1) return max_len"},{"question":"def isKaprekar(N: int) -> int: Given a number N, check if it is a Kaprekar number. A Kaprekar number for a given base is a non-negative integer, the representation of whose square can be split into two parts that add up to the original number (where neither part has leading zeroes, if the number is not zero). For example, 45 is a Kaprekar number, because 45^2 = 2025, and 20 + 25 = 45. Parameters: N (int): The number to be checked. Returns: int: 1 if N is a Kaprekar number, else 0. Examples: >>> isKaprekar(45) 1 >>> isKaprekar(46) 0 pass import pytest def test_example_one(): assert isKaprekar(45) == 1 def test_example_two(): assert isKaprekar(46) == 0 def test_kaprekar_numbers(): kaprekar_numbers = [1, 9, 45, 55, 99, 297, 703, 999] for num in kaprekar_numbers: assert isKaprekar(num) == 1 def test_non_kaprekar_numbers(): non_kaprekar_numbers = [2, 3, 10, 25, 50, 100, 1000, 500000] for num in non_kaprekar_numbers: assert isKaprekar(num) == 0 def test_boundaries(): assert isKaprekar(1) == 1 assert isKaprekar(10**6) == 0 # this number is not a Kaprekar number","solution":"def isKaprekar(n): Returns 1 if the given number n is a Kaprekar number, otherwise returns 0. if n == 1: return 1 n_squared = n * n n_squared_str = str(n_squared) for i in range(1, len(n_squared_str)): left_part = n_squared_str[:i] right_part = n_squared_str[i:] if right_part != '' and int(right_part) != 0: if int(left_part or '0') + int(right_part) == n: return 1 return 0"},{"question":"def find_second_largest(numbers: List[int]) -> Union[int, str]: Returns the second largest number in the list or \\"No second largest number\\" if it does not exist. >>> find_second_largest([2, 3, 6, 6, 5]) 5 >>> find_second_largest([4, 4, 4]) 'No second largest number' >>> find_second_largest([1, 1]) 'No second largest number' >>> find_second_largest([1, 2]) 1 >>> find_second_largest([-1, -2, -3, -1, -2]) -2 >>> find_second_largest([1]) 'No second largest number' >>> find_second_largest([7, 10, -5, 7, 2, 10]) 7 pass","solution":"def find_second_largest(numbers): Returns the second largest number in the list or \\"No second largest number\\" if it does not exist. unique_numbers = set(numbers) if len(unique_numbers) < 2: return \\"No second largest number\\" unique_numbers.remove(max(unique_numbers)) return max(unique_numbers)"},{"question":"def next_palindrome(n: int) -> int: Given an integer n, find the smallest palindrome larger than n. >>> next_palindrome(123) == 131 >>> next_palindrome(999) == 1001 >>> next_palindrome(987654321) == 987656789","solution":"def is_palindrome(number): Helper function to check if a number is a palindrome. return str(number) == str(number)[::-1] def next_palindrome(n): Function to find the smallest palindrome larger than n. n += 1 while not is_palindrome(n): n += 1 return n # Example usage: # print(next_palindrome(123)) # Should return 131 # print(next_palindrome(999)) # Should return 1001"},{"question":"def max_diff(lst: List[int]) -> int: Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If no such elements exist, returns -1. >>> max_diff([2, 3, 10, 6, 4, 8, 1]) 8 >>> max_diff([7, 9, 5, 6, 3, 2]) 2 >>> max_diff([1, 2, 90, 10, 110]) 109 >>> max_diff([5, 4, 3, 2, 1]) -1","solution":"def max_diff(lst): Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If no such elements exist, returns -1. if len(lst) < 2: return -1 min_element = lst[0] max_difference = -1 for i in range(1, len(lst)): if lst[i] > min_element: max_difference = max(max_difference, lst[i] - min_element) min_element = min(min_element, lst[i]) return max_difference"},{"question":"def countDivisiblePairs(arr: List[int], k: int) -> int: Given an array of n integers, count the number of unique pairs (i, j) where 0 <= i < j < n, such that the sum of the elements at indices i and j is divisible by k. Since the answer can be large, return it modulo 10^9+7. >>> countDivisiblePairs([2, 3, 7, 1, 5], 4) == 4 >>> countDivisiblePairs([1, 2, 3, 4, 5], 3) == 4","solution":"def countDivisiblePairs(arr, k): Returns the number of unique pairs (i, j) where 0 <= i < j < n such that the sum of the elements at indices i and j is divisible by k. mod = 10**9 + 7 # Array to store frequencies of modulo results freq = [0] * k # Counting frequencies of modulo values for num in arr: freq[num % k] += 1 # Initialize count of pairs count = 0 # Count pairs where (i + j) % k == 0 # Case 1: both numbers have remainder 0 count += (freq[0] * (freq[0] - 1)) // 2 # Case 2: remainders add up to k (excluding remainder 0) for i in range(1, (k // 2) + 1): if i != k - i: count += freq[i] * freq[k - i] else: # If k is even and we are at the middle element count += (freq[i] * (freq[i] - 1)) // 2 return count % mod"},{"question":"from typing import List, Tuple def process_queries(n: int, m: int, array: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Process a series of queries on an integer array. Each query can either update a range of values in the array or return the sum of a subarray. >>> process_queries(5, 4, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 4, 10), (2, 1, 3), (1, 1, 5, 5), (2, 1, 5)]) [6, 21, 25] >>> process_queries(3, 2, [1, 2, 3], [(1, 1, 3, 10), (2, 1, 3)]) [30] >>> process_queries(3, 3, [1, 2, 3], [(1, 1, 2, 5), (1, 2, 3, 10), (2, 2, 3)]) [20] >>> process_queries(4, 2, [1, 2, 3, 4], [(2, 1, 4), (2, 2, 3)]) [10, 5] >>> process_queries(1, 2, [1], [(1, 1, 1, 10), (2, 1, 1)]) [10]","solution":"class ArrayManipulation: def __init__(self, array): self.array = array self.n = len(array) def update_range(self, l, r, x): for i in range(l-1, r): self.array[i] = x def sum_range(self, l, r): return sum(self.array[l-1:r]) def process_queries(n, m, array, queries): am = ArrayManipulation(array) results = [] for query in queries: if query[0] == 1: _, l, r, x = query am.update_range(l, r, x) elif query[0] == 2: _, l, r = query results.append(am.sum_range(l, r)) return results # Example usage: # n = 5 # m = 4 # array = [1, 2, 3, 4, 5] # queries = [ # (2, 1, 3), # (1, 2, 4, 10), # (2, 1, 3), # (1, 1, 5, 5), # (2, 1, 5) # ] # print(process_queries(n, m, array, queries)) # Output should be: [6, 21, 25]"},{"question":"def max_consecutive_increasing_subseq(heights): Returns the maximum number of people that can form a consecutive subsequence with heights in strictly increasing order. >>> max_consecutive_increasing_subseq([1, 2, 3, 2, 2, 3, 4, 5]) 4 >>> max_consecutive_increasing_subseq([5, 4, 3, 2, 1]) 1 >>> max_consecutive_increasing_subseq([]) 0 >>> max_consecutive_increasing_subseq([10]) 1 >>> max_consecutive_increasing_subseq([5, 5, 5, 5, 5]) 1 >>> max_consecutive_increasing_subseq([1, 2, 3, 4, 5, 6, 7]) 7 >>> max_consecutive_increasing_subseq([7, 6, 5, 4, 3, 2, 1]) 1 >>> max_consecutive_increasing_subseq([2, 1, 2, 3, 1, 2, 3, 4, 1]) 4","solution":"def max_consecutive_increasing_subseq(heights): Returns the maximum number of people that can form a consecutive subsequence with heights in strictly increasing order. if not heights: return 0 max_length = 1 current_length = 1 for i in range(1, len(heights)): if heights[i] > heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def generate_password(w1: str, w2: str) -> str: Generate a secure password according to the new policy, combining strings w1 and w2. The password should be a permutation of the combined string with no three consecutive characters the same. If it's impossible, return \\"Not Possible\\". >>> generate_password(\\"abc\\", \\"bca\\") \\"bcaabbca\\" >>> generate_password(\\"aaa\\", \\"bbb\\") \\"ababab\\" >>> generate_password(\\"aaa\\", \\"aaa\\") \\"Not Possible\\"","solution":"from collections import Counter def generate_password(w1, w2): combined = w1 + w2 counter = Counter(combined) # Check if any character count is more than half of the length rounded up max_allowed = (len(combined) + 1) // 2 if any(count > max_allowed for count in counter.values()): return \\"Not Possible\\" result = [] while counter: most_common = counter.most_common(2) # Take the 2 most common characters if len(most_common) == 1 and len(result) >= 2 and result[-1] == result[-2] == most_common[0][0]: # Only one character is left and it would create three in a row return \\"Not Possible\\" for char, cnt in most_common: if len(result) >= 2 and result[-1] == result[-2] == char: continue result.append(char) counter[char] -= 1 if counter[char] == 0: del counter[char] break counter = Counter(dict(sorted(counter.items(), key=lambda x: x[1], reverse=True))) # Reorder after each iteration return ''.join(result)"},{"question":"def max_non_overlapping_deliveries(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Calculate the maximum number of non-overlapping deliveries. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[Tuple[int, int]]]] : A list containing tuples. Each tuple represents a test case, where the first element is an integer N (number of delivery time slots), and the second element is a list of tuples (each containing two integers - start time and duration). Returns: List[int] : A list containing the maximum number of non-overlapping deliveries for each test case. Examples: >>> max_non_overlapping_deliveries(1, [(3, [(0, 10), (15, 10), (30, 10)])]) [3] >>> max_non_overlapping_deliveries(1, [(4, [(0, 60), (10, 15), (20, 10), (35, 20)])]) [2]","solution":"def max_non_overlapping_deliveries(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] times = test_cases[i][1] deliveries = [(start, start + duration) for start, duration in times] deliveries.sort(key=lambda x: x[1]) max_deliveries = 0 last_end_time = 0 for start, end in deliveries: if start >= last_end_time: max_deliveries += 1 last_end_time = end results.append(max_deliveries) return results"},{"question":"def distribute_tasks(m, p, preferences): Distributes tasks among employees in an optimal way. Each employee gets exactly \`m\` tasks according to their preferences as much as possible. If there are multiple valid distributions, any can be considered correct. Args: m (int): Number of tasks per employee. p (int): Number of employees. preferences (List[List[int]]): List of preferences for each employee in order from most preferred to least preferred. Returns: List[List[int]]: List of tasks assigned to each employee. Example: >>> distribute_tasks(2, 2, [[4, 1, 3, 2], [1, 4, 2, 3]]) [[4, 1], [3, 2]] >>> distribute_tasks(3, 1, [[2, 1, 3]]) [[2, 1, 3]] pass from typing import List def test_example_case_1(): m = 2 p = 2 preferences = [ [4, 1, 3, 2], [1, 4, 2, 3] ] result = distribute_tasks(m, p, preferences) assert len(result) == 2 assert sorted(result[0]) == [1, 4] assert sorted(result[1]) == [2, 3] def test_example_case_2(): m = 3 p = 1 preferences = [ [2, 1, 3] ] result = distribute_tasks(m, p, preferences) assert len(result) == 1 assert len(result[0]) == 3 assert sorted(result[0]) == [1, 2, 3] def test_multiple_employees_1(): m = 1 p = 3 preferences = [ [3, 1, 2], [2, 3, 1], [1, 2, 3] ] result = distribute_tasks(m, p, preferences) assert len(result) == 3 assert sorted(result[0]) == [3] assert sorted(result[1]) == [2] assert sorted(result[2]) == [1] def test_multiple_employees_2(): m = 2 p = 3 preferences = [ [1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1], [3, 1, 2, 6, 4, 5] ] result = distribute_tasks(m, p, preferences) assert len(result) == 3 assigned_tasks = set() for tasks in result: for task in tasks: assert task not in assigned_tasks assigned_tasks.add(task) assert len(assigned_tasks) == 6 # since p*m = 6","solution":"def distribute_tasks(m, p, preferences): tasks_assigned = set() distribution = [[] for _ in range(p)] for i in range(p): preferences_sorted = sorted(preferences[i], key=lambda x: preferences[i].index(x)) count = 0 for task in preferences_sorted: if task not in tasks_assigned: distribution[i].append(task) tasks_assigned.add(task) count += 1 if count == m: break return distribution # Input processing def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) p = int(data[1]) preferences = [ list(map(int, data[i*(m*p)+2 : (i+1)*(m*p)+2])) for i in range(p) ] result = distribute_tasks(m, p, preferences) for tasks in result: print(' '.join(map(str, tasks))) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def max_subarray_sum(arr: List[int], l: int, r: int) -> int: [Replace with your own description] pass def max_sum_queries(t: int, cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[List[int]]: Determine the maximum sum of any subarray within specified ranges. Args: t (int): the number of test cases cases (List[Tuple[int, int, List[int], List[Tuple[int, int]]]]): a list of test cases, each containing: - (int) n: the length of the array - (int) q: the number of queries - (List[int]) arr: the array of integers - (List[Tuple[int, int]]) queries: the ranges of the queries Returns: List[List[int]]: a list of results for each test case, where each result is a list of integers representing the maximum sum of any subarray within each query range. >>> t = 2 >>> cases = [ >>> (5, 2, [1, -2, 3, -1, 2], [(1, 3), (2, 5)]), >>> (3, 1, [-1, -1, -1], [(1, 1)]), >>> ] >>> max_sum_queries(t, cases) [[3, 4], [-1]] >>> t = 1 >>> cases = [ >>> (4, 2, [2, -4, 6, -3], [(1, 4), (2, 3)]), >>> ] >>> max_sum_queries(t, cases) [[6, 6]] pass","solution":"def max_subarray_sum(arr, l, r): max_sum = float('-inf') current_sum = 0 for i in range(l, r + 1): current_sum = max(arr[i], current_sum + arr[i]) max_sum = max(max_sum, current_sum) return max_sum def max_sum_queries(t, cases): results = [] for i in range(t): n, q, arr, queries = cases[i] case_result = [] for query in queries: l, r = query l -= 1 # convert to 0-based indexing r -= 1 case_result.append(max_subarray_sum(arr, l, r)) results.append(case_result) return results"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Removes leading, trailing, and extra spaces between words. :param sentence: str, the input sentence to reverse :return: str, the sentence with the order of words reversed >>> reverse_words(\\"The sky is blue\\") \\"blue is sky The\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\"hello\\") \\"hello\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" space between \\") \\"between space\\" pass","solution":"def reverse_words(sentence): Reverses the order of words in a given sentence. Removes leading, trailing, and extra spaces between words. :param sentence: str, the input sentence to reverse :return: str, the sentence with the order of words reversed # Split the sentence into words words = sentence.split() # Reverse the order of words reversed_words = words[::-1] # Join the words back into a sentence reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def reorder_list(n: int, nums: List[int]) -> List[int]: Reorder the list such that all negative integers appear before all non-negative integers while maintaining the relative order of the negative integers as well as the relative order of the non-negative integers. Parameters: n (int): Number of integers in the list nums (list of int): List of integers Returns: list of int: Reordered list >>> reorder_list(6, [-1, -3, 4, 2, -5, 3]) [-1, -3, -5, 4, 2, 3] >>> reorder_list(4, [1, 2, -1, -2]) [-1, -2, 1, 2] >>> reorder_list(5, [0, 1, 2, -1, -3]) [-1, -3, 0, 1, 2]","solution":"def reorder_list(n, nums): Reorder the list such that all negative integers appear before all non-negative integers while maintaining the relative order of the negative integers as well as the relative order of the non-negative integers. Parameters: n (int): Number of integers in the list nums (list of int): List of integers Returns: list of int: Reordered list negatives = [num for num in nums if num < 0] non_negatives = [num for num in nums if num >= 0] return negatives + non_negatives"},{"question":"def min_days_to_produce(N: int, production_rates: List[int], required_widgets: List[int]) -> int: Returns the minimum number of days required for all machines to produce the required number of widgets. Parameters: - N (int): Number of machines. - production_rates (list): Daily production rates of machines. - required_widgets (list): Required number of widgets from each machine. Returns: - int: Minimum number of days required for production. pass # Unit tests def test_example_case(): assert min_days_to_produce(3, [2, 3, 5], [10, 15, 25]) == 5 def test_single_machine(): assert min_days_to_produce(1, [5], [25]) == 5 assert min_days_to_produce(1, [1], [100]) == 100 def test_multiple_machines_with_different_days(): assert min_days_to_produce(2, [4, 5], [8, 30]) == 6 def test_edge_case_smallest(): assert min_days_to_produce(1, [1], [1]) == 1 def test_edge_case_largest(): assert min_days_to_produce(3, [10, 20, 30], [1000, 2000, 3000]) == 100 # 1000/10=100, 2000/20=100, 3000/30=100 def test_zero_required_widgets(): assert min_days_to_produce(3, [10, 20, 30], [0, 0, 0]) == 0 # no widgets required def test_same_production_and_requirements(): assert min_days_to_produce(3, [100, 100, 100], [1000, 500, 300]) == 10 # max(10, 5, 3) = 10","solution":"def min_days_to_produce(N, production_rates, required_widgets): Returns the minimum number of days required for all machines to produce the required number of widgets. Parameters: - N (int): Number of machines. - production_rates (list): Daily production rates of machines. - required_widgets (list): Required number of widgets from each machine. Returns: - int: Minimum number of days required for production. max_days = 0 for rate, required in zip(production_rates, required_widgets): days = (required + rate - 1) // rate # equivalent to ceiling(required / rate) if days > max_days: max_days = days return max_days"},{"question":"def longest_subarray_with_sum_at_most_t(arr, t): Given an array of integers and a value t, returns the length of the longest subarray with sum less than or equal to t. Args: arr : List[int] -> A list of integers representing the array. t : int -> An integer representing the maximum allowed sum of the subarray. Returns: int -> The length of the longest subarray with sum <= t. Examples: >>> longest_subarray_with_sum_at_most_t([1, 2, 3, 4], 6) 3 >>> longest_subarray_with_sum_at_most_t([1, 2, 3, 4, 5], 10) 4 >>> longest_subarray_with_sum_at_most_t([2, 1, 5, 2, 8], 7) 2 >>> longest_subarray_with_sum_at_most_t([5, 5, 5, 5], 20) 4 >>> longest_subarray_with_sum_at_most_t([7], 10) 1 >>> longest_subarray_with_sum_at_most_t([11, 12, 13], 10) 0","solution":"def longest_subarray_with_sum_at_most_t(arr, t): Given an array of integers and a value t, returns the length of the longest subarray with sum less than or equal to t. n = len(arr) left = 0 current_sum = 0 max_length = 0 for right in range(n): current_sum += arr[right] while current_sum > t: current_sum -= arr[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"import re def isPalindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring spaces, punctuation, and case sensitivity. :param s: Input string to check. :return: True if the string is a palindrome, False otherwise. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"hello\\") False >>> isPalindrome(\\"No lemon, no melon\\") True >>> isPalindrome(\\"This is not a palindrome\\") False >>> isPalindrome(\\"\\") True >>> isPalindrome(\\" \\") True >>> isPalindrome(\\".,! \\") True >>> isPalindrome(\\"A Santa at NASA\\") True >>> isPalindrome(\\"12321\\") True >>> isPalindrome(\\"12345\\") False >>> isPalindrome(\\"Madam, in Eden, I’m Adam\\") True # Your implementation here","solution":"import re def isPalindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring spaces, punctuation, and case sensitivity. :param s: Input string to check. :return: True if the string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lower case cleaned_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is the same forwards and backwards return cleaned_string == cleaned_string[::-1]"},{"question":"def find_majority_elements(n: int, arr: List[int]) -> List[int]: Returns the majority element if it exists, otherwise return an empty list. If multiple majority elements exist, return all of them in a sorted manner. >>> find_majority_elements(5, [3, 3, 4, 2, 3]) == [3] >>> find_majority_elements(6, [1, 1, 2, 2, 3, 3]) == [] >>> find_majority_elements(4, [4, 4, 4, 4]) == [4] >>> find_majority_elements(5, [2, 2, 2, 2, 3]) == [2] >>> find_majority_elements(1, [1]) == [1]","solution":"def find_majority_elements(n, arr): Returns the majority element if it exists, otherwise return an empty list. If multiple majority elements exist, return all of them in a sorted manner. from collections import Counter # Count the frequency of each element counts = Counter(arr) majority_count = n // 2 # Find the elements with frequency greater than n // 2 majority_elements = [element for element, count in counts.items() if count > majority_count] # Sort the result if there are multiple majority elements return sorted(majority_elements) # Example usage n = 5 arr = [3, 3, 4, 2, 3] print(find_majority_elements(n, arr)) # Output: [3]"},{"question":"def max_non_overlapping_time_slots(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Given the number of test cases T and a list of test cases each consisting of M time slots with start and end times, determine the maximum number of non-overlapping time slots that can be achieved after potentially deleting some time slots. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list where each element is a tuple containing an integer M representing the number of time slots, and a list of tuples each containing two integers s and e representing the start and end times of the time slots. Returns: List[int]: A list containing one integer for each test case representing the maximum number of non-overlapping time slots. Example: >>> max_non_overlapping_time_slots(2, [(3, [(1, 3), (2, 5), (4, 6)]), (4, [(1, 2), (3, 4), (0, 6), (5, 7)])]) [2, 3]","solution":"def max_non_overlapping_time_slots(T, test_cases): results = [] for i in range(T): M, time_slots = test_cases[i] time_slots.sort(key=lambda x: x[1]) # sort by end time count = 0 last_end_time = 0 for start, end in time_slots: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"class Game: def __init__(self, strengths): self.strengths = strengths self.prefix_sums = self._compute_prefix_sums(strengths) def _compute_prefix_sums(self, strengths): prefix_sums = [0] * (len(strengths) + 1) for i in range(1, len(strengths) + 1): prefix_sums[i] = prefix_sums[i-1] + strengths[i-1] return prefix_sums def query_sum(self, l, r): Return the total strength of players from position l to r (inclusive). pass def update_strength(self, p, v): Update the strength of the player at position p to value v. pass def handle_events(strengths, events): Handle a list of events and return a list of results for type 1 events. >>> strengths = [3, 8, 6, 4, 7] >>> events = [(1, 2, 4), (2, 3, 10), (1, 2, 4)] >>> handle_events(strengths, events) [18, 22] pass","solution":"class Game: def __init__(self, strengths): self.strengths = strengths self.prefix_sums = self._compute_prefix_sums(strengths) def _compute_prefix_sums(self, strengths): prefix_sums = [0] * (len(strengths) + 1) for i in range(1, len(strengths) + 1): prefix_sums[i] = prefix_sums[i-1] + strengths[i-1] return prefix_sums def query_sum(self, l, r): # l and r are 1-indexed return self.prefix_sums[r] - self.prefix_sums[l-1] def update_strength(self, p, v): # p is 1-indexed diff = v - self.strengths[p-1] self.strengths[p-1] = v for i in range(p, len(self.strengths) + 1): self.prefix_sums[i] += diff def handle_events(strengths, events): game = Game(strengths) results = [] for event in events: if event[0] == 1: _, L, R = event result = game.query_sum(L, R) results.append(result) elif event[0] == 2: _, P, V = event game.update_strength(P, V) return results # Example usage: # strengths = [3, 8, 6, 4, 7] # events = [(1, 2, 4), (2, 3, 10), (1, 2, 4)] # print(handle_events(strengths, events)) # Output: [18, 22]"},{"question":"def min_length_to_return(directions: str) -> int: Determine the shortest length of the sequence that causes a return to a previously visited position for a robot wandering on an infinite grid. >>> min_length_to_return(\\"NESWEN\\") 4 >>> min_length_to_return(\\"NENW\\") -1 >>> min_length_to_return(\\"N\\") -1 >>> min_length_to_return(\\"NESW\\") 4 >>> min_length_to_return(\\"NESWNESW\\") 4 >>> min_length_to_return(\\"NNSS\\") 2 >>> min_length_to_return(\\"\\") -1","solution":"def min_length_to_return(directions): position = (0, 0) visited_positions = {position: 0} x, y = 0, 0 for i, direction in enumerate(directions): if direction == 'N': y += 1 elif direction == 'S': y -= 1 elif direction == 'E': x += 1 elif direction == 'W': x -= 1 current_position = (x, y) if current_position in visited_positions: return i - visited_positions[current_position] + 1 visited_positions[current_position] = i + 1 return -1"},{"question":"def is_prime(n: int) -> bool: Helper function to determine if a number is prime. pass def filter_primes(arr: List[int]) -> List[int]: Returns a new array containing only the prime numbers from the input array. >>> filter_primes([4, 5, 8, 9, 11]) [5, 11] >>> filter_primes([15, 16, 18, 19, 20, 23]) [19, 23] >>> filter_primes([2, 3, 5, 7, 10]) [2, 3, 5, 7] pass","solution":"def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(arr): Returns a new array containing only the prime numbers from the input array. return [x for x in arr if is_prime(x)]"},{"question":"from typing import List def max_fruit_value(N: int, K: int, values: List[int]) -> int: Returns the maximum sum of fruit values that can be collected from trees such that they are at least K trees apart. >>> max_fruit_value(7, 2, [8, 2, 6, 5, 3, 7, 4]) 17 >>> max_fruit_value(1, 1, [10]) 10 >>> max_fruit_value(5, 1, [-1, -2, -3, -4, -5]) -1 >>> max_fruit_value(5, 5, [1, 2, 3, 4, 5]) 5 >>> max_fruit_value(5, 1, [1, 100, 1, 100, 1]) 200","solution":"def max_fruit_value(N, K, values): Returns the maximum sum of fruit values that can be collected from trees such that they are at least K trees apart. # Initialize a list to store the maximum sum possible up to each tree dp = [0] * N # First tree can always be taken dp[0] = values[0] for i in range(1, N): # Consider taking the current tree pick = values[i] if i > K: pick += dp[i - K - 1] # Consider not taking the current tree not_pick = dp[i - 1] # Best option for the current tree's position dp[i] = max(pick, not_pick) return dp[-1]"},{"question":"def fruits_per_basket(F: int, B: int) -> int: Returns the number of fruits of each type in one basket. Parameters: F (int): The number of different kinds of fruits. B (int): The number of baskets. Returns: int: Number of fruits of each type in one basket. Examples: >>> fruits_per_basket(4, 2) 2 >>> fruits_per_basket(6, 3) 2 >>> fruits_per_basket(5, 5) 1","solution":"def fruits_per_basket(F, B): Returns the number of fruits of each type in one basket. Parameters: F (int): The number of different kinds of fruits. B (int): The number of baskets. Returns: int: Number of fruits of each type in one basket. return F // B"},{"question":"def process_queries(arr, queries): Process the queries to get the sum of subarrays. Parameters: - arr: list of integers representing the array - queries: list of tuples (L, R), where L and R are the indices for the subarray sum query Returns: - list of integers representing the results of the subarray sums for each query from solution import process_queries def test_single_query(): arr = [1, 2, 3, 4, 5] queries = [(0, 2)] assert process_queries(arr, queries) == [6] def test_three_queries(): arr = [1, 2, 3, 4, 5] queries = [(0, 2), (1, 3), (0, 4)] assert process_queries(arr, queries) == [6, 9, 15] def test_large_case(): arr = list(range(1, 101)) # [1, 2, 3, ..., 100] queries = [(0, 99), (0, 49), (50, 99)] assert process_queries(arr, queries) == [5050, 1275, 3775] def test_entire_array(): arr = [2, 4, -1, 8, 10] queries = [(0, 4)] assert process_queries(arr, queries) == [23] def test_negative_numbers(): arr = [-1, -2, -3, -4, -5] queries = [(0, 1), (1, 3), (0, 4)] assert process_queries(arr, queries) == [-3, -9, -15]","solution":"def process_queries(arr, queries): Process the queries to get the sum of subarrays. Parameters: - arr: list of integers representing the array - queries: list of tuples (L, R), where L and R are the indices for the subarray sum query Returns: - list of integers representing the results of the subarray sums for each query # Generate prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(len(arr)): prefix_sums[i + 1] = prefix_sums[i] + arr[i] # Process each query results = [] for L, R in queries: sum_subarray = prefix_sums[R + 1] - prefix_sums[L] results.append(sum_subarray) return results # Example usage with the given sample # Sample input data: N = 5 Q = 3 arr = [1, 2, 3, 4, 5] queries = [(0, 2), (1, 3), (0, 4)] # Processing queries result = process_queries(arr, queries) print(result) # Output should be [6, 9, 15]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list such that, at each index i, the new list contains the product of all the numbers in the original list except the one at nums[i]. :param nums: List of integers :return: List of products >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 5, 9]) [45, 18, 10] pass # Implement your solution here. from typing import List def test_product_except_self_normal_case(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([2, 5, 9]) == [45, 18, 10] def test_product_except_self_with_zero(): assert product_except_self([1, 0, 3, 4]) == [0, 12, 0, 0] assert product_except_self([0, 0, 3, 4]) == [0, 0, 0, 0] def test_product_except_self_with_negative_numbers(): assert product_except_self([-1, 2, 3, 4]) == [24, -12, -8, -6] assert product_except_self([1, -2, 3, 4]) == [-24, 12, -8, -6] def test_product_except_self_with_ones(): assert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] def test_product_except_self_with_large_numbers(): assert product_except_self([100, 200, 300, 400]) == [24000000, 12000000, 8000000, 6000000]","solution":"def product_except_self(nums): Returns a list such that, at each index i, the new list contains the product of all the numbers in the original list except the one at nums[i]. n = len(nums) # Initialize prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n # Calculate prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * nums[i - 1] # Calculate suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * nums[i + 1] # Calculate result array result = [1] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"def find_missing_positive(nums: List[int]) -> int: Returns the smallest missing positive integer from the array. >>> find_missing_positive([1, 2, 0]) == 3 >>> find_missing_positive([3, 4, -1, 1]) == 2 >>> find_missing_positive([7, 8, 9, 11, 12]) == 1 >>> find_missing_positive([]) == 1 >>> find_missing_positive([1, 2, 3, 4, 5]) == 6 >>> find_missing_positive([1, 1, 1, 1]) == 2 >>> find_missing_positive([-1, -2, -3, 0]) == 1 >>> find_missing_positive([1]) == 2","solution":"def find_missing_positive(nums): Returns the smallest missing positive integer from the array. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def nearly_identical_sequences(input_data: List[str]) -> List[str]: Determine if two sequences of symbols are nearly identical. >>> nearly_identical_sequences([\\"abcd abxd\\", \\"hello hellx\\", \\"xyz zzz\\", \\"END\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> nearly_identical_sequences([\\"abc abc\\", \\"abcd xyzs\\", \\"END\\"]) [\\"YES\\", \\"NO\\"] >>> nearly_identical_sequences([\\"END\\"]) [] >>> nearly_identical_sequences([\\"test test\\", \\"abcd abcd\\", \\"xyz xyz\\", \\"END\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> nearly_identical_sequences([\\"abcd axcd\\", \\"pqrs pqra\\", \\"mnop mnxp\\", \\"END\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> nearly_identical_sequences([\\"test te1t\\", \\"abcd xyzz\\", \\"1234 5678\\", \\"END\\"]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def nearly_identical_sequences(input_data): def is_nearly_identical(seq1, seq2): difference = sum(1 for a, b in zip(seq1, seq2) if a != b) return difference <= 1 result = [] for line in input_data: if line == \\"END\\": break sequence1, sequence2 = line.split() if is_nearly_identical(sequence1, sequence2): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def count_bipartite_components(N: int, M: int, edges: List[Tuple[int, int]]) -> int: Determines the number of bipartite components in the graph. Args: N (int): Number of vertices M (int): Number of edges edges (List[Tuple[int, int]]): Edges of the graph Returns: int: Number of bipartite components in the graph pass # Unit tests def test_single_component_bipartite(): N, M = 5, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert count_bipartite_components(N, M, edges) == 1 def test_multiple_components_bipartite(): N, M = 6, 4 edges = [(1, 2), (2, 3), (4, 5), (5, 6)] assert count_bipartite_components(N, M, edges) == 2 def test_single_component_not_bipartite(): N, M = 5, 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert count_bipartite_components(N, M, edges) == 0 def test_disconnected_component(): N, M = 3, 0 edges = [] assert count_bipartite_components(N, M, edges) == 3 def test_mixed_components(): N, M = 6, 5 edges = [(1, 2), (2, 3), (3, 4), (5, 6), (6, 5)] assert count_bipartite_components(N, M, edges) == 2 def test_large_input(): N, M = 100000, 0 edges = [] assert count_bipartite_components(N, M, edges) == 100000","solution":"from collections import defaultdict, deque def is_bipartite_component(graph, start, visited): queue = deque([start]) visited[start] = 1 # Start coloring with 1 while queue: node = queue.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = 1 - visited[node] queue.append(neighbor) elif visited[neighbor] == visited[node]: return False return True def count_bipartite_components(N, M, edges): graph = defaultdict(list) visited = [-1] * (N + 1) for u, v in edges: graph[u].append(v) graph[v].append(u) bipartite_count = 0 for vertex in range(1, N + 1): if visited[vertex] == -1: if is_bipartite_component(graph, vertex, visited): bipartite_count += 1 return bipartite_count"},{"question":"import math def count_arrangements(N: int) -> int: Calculate the number of ways to arrange N dishes with one special dish always in the center. Parameters: N (int): Total number of dishes (N is odd and 1 < N <= 13) Returns: int: Number of arrangements with the special dish always in the center >>> count_arrangements(3) 2 >>> count_arrangements(5) 24 >>> count_arrangements(7) 720","solution":"import math def count_arrangements(N): Calculate the number of ways to arrange N dishes with one special dish always in the center. Parameters: N (int): Total number of dishes (N is odd and 1 < N <= 13) Returns: int: Number of arrangements with the special dish always in the center if N <= 1 or N % 2 == 0 or N > 13: raise ValueError(\\"N must be an odd number between 1 and 13 (inclusive).\\") # Remove the special dish in the center, calculate factorial of the remaining dishes return math.factorial(N - 1)"},{"question":"def recipe_spread(N: int, bakers_matrix: List[List[int]], M: int, queries: List[Tuple[int, int]]) -> List[str]: Determine the reach of a recipe after exactly T minutes from a given starting baker. Args: N : int : Number of bakers bakers_matrix : List[List[int]] : Adjacency matrix of bakers' connections M : int : Number of queries queries : List[Tuple[int, int]] : List of queries with time T and starting baker X Returns: List[str] : A list containing the results of the queries Example: >>> recipe_spread(4, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3, [(2, 1), (1, 2), (0, 3)]) [\\"3\\", \\"1 2 3\\", \\"2\\", \\"1 3\\", \\"1\\", \\"3\\"] >>> recipe_spread(1, [[0]], 1, [(1, 1)]) [\\"1\\", \\"1\\"]","solution":"from collections import deque def get_reach_time(bakers_matrix, start, time): n = len(bakers_matrix) visited = [False] * n visited[start] = True queue = deque([(start, 0)]) reachable = set([start]) while queue: current_baker, current_time = queue.popleft() if current_time == time: continue for neighbor in range(n): if bakers_matrix[current_baker][neighbor] == 1 and not visited[neighbor]: visited[neighbor] = True reachable.add(neighbor) queue.append((neighbor, current_time + 1)) reach_list = sorted(b + 1 for b in reachable) return len(reach_list), reach_list if reach_list else [-1] def recipe_spread(N, bakers_matrix, M, queries): results = [] for time, start in queries: num_bakers, bakers = get_reach_time(bakers_matrix, start - 1, time) results.append(f\\"{num_bakers}\\") results.append(\\" \\".join(map(str, bakers))) return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) index += 1 bakers_matrix = [] for i in range(N): bakers_matrix.append([int(data[index + j]) for j in range(N)]) index += N M = int(data[index]) index += 1 queries = [] for i in range(M): t = int(data[index]) x = int(data[index + 1]) queries.append((t, x)) index += 2 results = recipe_spread(N, bakers_matrix, M, queries) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def longest_consecutive_ones(binary_strings): Given a list of binary strings, returns the length of the longest sequence of consecutive 1s for each binary string. pass def process_input(input_string): Processes the input string and returns the list of binary strings. pass def process_output(results): Processes the results and returns the output in the required format. pass def main(input_string): binary_strings = process_input(input_string) results = longest_consecutive_ones(binary_strings) output = process_output(results) return output # Unit Tests def test_longest_consecutive_ones(): input_data = \\"11011001111n100010111n1111100000n0n\\" expected_output = \\"4n3n5\\" result = main(input_data) assert result == expected_output def test_single_1(): input_data = \\"1n0n\\" expected_output = \\"1\\" result = main(input_data) assert result == expected_output def test_single_0(): input_data = \\"0n\\" expected_output = \\"\\" result = main(input_data) assert result == expected_output def test_multiple_0s(): input_data = \\"10000n0n\\" expected_output = \\"1\\" result = main(input_data) assert result == expected_output def test_no_1s(): input_data = \\"0000n0n\\" expected_output = \\"0\\" result = main(input_data) assert result == expected_output def test_all_1s(): input_data = \\"11111n0n\\" expected_output = \\"5\\" result = main(input_data) assert result == expected_output","solution":"def longest_consecutive_ones(binary_strings): Given a list of binary strings, returns the length of the longest sequence of consecutive 1s for each binary string. results = [] for binary_string in binary_strings: if binary_string == '0': break max_consecutive_ones = max(map(len, binary_string.split('0'))) results.append(max_consecutive_ones) return results def process_input(input_string): Processes the input string and returns the list of binary strings. return input_string.strip().split('n') def process_output(results): Processes the results and returns the output in the required format. output = \\"n\\".join(map(str, results)) return output def main(input_string): binary_strings = process_input(input_string) results = longest_consecutive_ones(binary_strings) output = process_output(results) return output"},{"question":"def is_prime(n: int) -> bool: Helper function to determine if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False pass def find_prime_creature_ids(ability_levels: List[int]) -> List[int]: Returns the IDs of creatures whose ability levels are prime numbers. >>> find_prime_creature_ids([23, 18, 29, 35, 47]) [1, 3, 5] >>> find_prime_creature_ids([10, 15, 17, 21, 31, 37]) [3, 5, 6] pass from solution import find_prime_creature_ids, is_prime def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False assert is_prime(19) == True def test_find_prime_creature_ids_example1(): ability_levels = [23, 18, 29, 35, 47] assert find_prime_creature_ids(ability_levels) == [1, 3, 5] def test_find_prime_creature_ids_example2(): ability_levels = [10, 15, 17, 21, 31, 37] assert find_prime_creature_ids(ability_levels) == [3, 5, 6] def test_find_prime_creature_ids_no_primes(): ability_levels = [10, 15, 18, 21, 33, 35] assert find_prime_creature_ids(ability_levels) == [] def test_find_prime_creature_ids_all_primes(): ability_levels = [2, 3, 5, 7, 11, 13] assert find_prime_creature_ids(ability_levels) == [1, 2, 3, 4, 5, 6] def test_find_prime_creature_ids_mixed(): ability_levels = [1, 4, 6, 8, 9, 10] assert find_prime_creature_ids(ability_levels) == [] def test_find_prime_creature_ids_edge_case(): ability_levels = [997] assert find_prime_creature_ids(ability_levels) == [1]","solution":"def is_prime(n): Helper function to determine if a number is prime if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_prime_creature_ids(ability_levels): Returns the IDs of creatures whose ability levels are prime numbers. prime_ids = [] for i, ability_level in enumerate(ability_levels, start=1): if is_prime(ability_level): prime_ids.append(i) return prime_ids"},{"question":"def total_apples_eaten(T, participants_data): Calculate the total number of apples eaten by each participant. Parameters: T (int): Number of participants. participants_data (list): List of tuples, where each tuple contains: - An integer N indicating the number of rounds. - A list of N integers representing the number of apples eaten in each round. Returns: list: A list of integers where each integer is the total number of apples eaten by a participant. >>> total_apples_eaten(3, [(4, [5, 6, 3, 7]), (3, [8, 10, 2]), (5, [4, 4, 4, 4, 4])]) [21, 20, 20] >>> total_apples_eaten(1, [(1, [1])]) [1] >>> total_apples_eaten(2, [(3, [50, 50, 50]), (2, [50, 50])]) [150, 100] >>> total_apples_eaten(2, [(4, [10, 20, 30, 40]), (1, [38])]) [100, 38] >>> total_apples_eaten(1, [(5, [5, 1, 2, 3, 4])]) [15] >>> total_apples_eaten(0, []) []","solution":"def total_apples_eaten(T, participants_data): Calculate the total number of apples eaten by each participant. Parameters: T (int): Number of participants. participants_data (list): List of tuples, where each tuple contains: - An integer N indicating the number of rounds. - A list of N integers representing the number of apples eaten in each round. Returns: list: A list of integers where each integer is the total number of apples eaten by a participant. results = [] for i in range(T): N, apples_each_round = participants_data[i] total_apples = sum(apples_each_round) results.append(total_apples) return results"},{"question":"def determine_satisfaction(ratings_list): This function takes a list of lists where each inner list represents the ratings given by a single customer. It returns a list of boolean values indicating whether each customer is satisfied. def format_satisfaction_result(ratings_list): This function takes a list of lists where each inner list represents the ratings given by a single customer. It returns formatted lines stating whether each customer is satisfied or not. >>> format_satisfaction_result([[5, 3, 4, 3], [2, 1, 5, 3], [4, 4, 4, 4]]) [\\"Customer #1: Satisfied\\", \\"Customer #2: Not Satisfied\\", \\"Customer #3: Satisfied\\"] >>> format_satisfaction_result([[3], [2], [5]]) [\\"Customer #1: Satisfied\\", \\"Customer #2: Not Satisfied\\", \\"Customer #3: Satisfied\\"] >>> format_satisfaction_result([[1, 2], [2, 1], [5, 4, 3, 4]]) [\\"Customer #1: Not Satisfied\\", \\"Customer #2: Not Satisfied\\", \\"Customer #3: Satisfied\\"]","solution":"def determine_satisfaction(ratings_list): This function takes a list of lists where each inner list represents the ratings given by a single customer. It returns a list of boolean values indicating whether each customer is satisfied. result = [] for ratings in ratings_list: if all(rating >= 3 for rating in ratings): result.append(True) else: result.append(False) return result def format_satisfaction_result(ratings_list): This function takes a list of lists where each inner list represents the ratings given by a single customer. It returns formatted lines stating whether each customer is satisfied or not. satisfaction_list = determine_satisfaction(ratings_list) output = [] for i, satisfied in enumerate(satisfaction_list): status = \\"Satisfied\\" if satisfied else \\"Not Satisfied\\" output.append(f\\"Customer #{i + 1}: {status}\\") return output"},{"question":"def max_distinct_characters(n: int, s: str) -> int: Returns the maximum number of distinct characters that can remain after removing a substring. Args: n (int): The length of the string. s (str): The string consisting of lowercase English letters. Returns: int: The maximum number of distinct characters that can remain. >>> max_distinct_characters(5, \\"abcde\\") 4 >>> max_distinct_characters(6, \\"aabbcc\\") 3","solution":"def max_distinct_characters(n, s): Returns the maximum number of distinct characters that can remain after removing a substring. max_distinct = 0 for i in range(n): for j in range(i+1, n+1): remaining_string = s[:i] + s[j:] max_distinct = max(max_distinct, len(set(remaining_string))) return max_distinct def main(): import sys input = sys.stdin.read data = input().split() idx = 0 t = int(data[idx]) idx += 1 results = [] for _ in range(t): n = int(data[idx]) idx += 1 s = data[idx] idx += 1 results.append(max_distinct_characters(n, s)) for result in results: print(result)"},{"question":"def maxConsecutivePoints(n, points): Returns the maximum points scored in a series of consecutive rounds. Parameters: n (int): The number of rounds points (list of int): The points scored in each round Returns: int: The maximum points scored in consecutive rounds >>> maxConsecutivePoints(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxConsecutivePoints(5, [-3, -2, -1, -4, -5]) -1 >>> maxConsecutivePoints(1, [5]) 5 >>> maxConsecutivePoints(1, [-5]) -5 >>> maxConsecutivePoints(4, [1, 2, 3, 4]) 10 >>> maxConsecutivePoints(5, [1, -2, 3, 4, -1]) 7 >>> maxConsecutivePoints(6, [-1, 3, 4, -1, 2, 1]) 9","solution":"def maxConsecutivePoints(n, points): Returns the maximum points scored in a series of consecutive rounds. Parameters: n (int): The number of rounds points (list of int): The points scored in each round Returns: int: The maximum points scored in consecutive rounds max_ending_here = points[0] max_so_far = points[0] for i in range(1, n): max_ending_here = max(points[i], max_ending_here + points[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def spiral_order(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. :param matrix: List of lists, where each inner list is a row of the matrix. :return: List of elements in spiral order. >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiral_order([ ... [1, 2, 3, 4, 5] ... ]) == [1, 2, 3, 4, 5] >>> spiral_order([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) == [1, 2, 3, 4, 5] >>> spiral_order([]) == [] >>> spiral_order([[1]]) == [1] >>> spiral_order([ ... [1, 2], ... [3, 4] ... ]) == [1, 2, 4, 3] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] pass # Your implementation here","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. :param matrix: List of lists, where each inner list is a row of the matrix. :return: List of elements in spiral order. if not matrix: return [] result = [] while matrix: # Add the first row to result result += matrix.pop(0) # Add the last element from each remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Add the last row in reverse order to result if matrix: result += matrix.pop()[::-1] # Add the first element from each remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"def checkValidString(s: str) -> str: Determine if the string \`s\` can be a valid parentheses string by replacing '*' with characters that make it valid. :param s: A string consisting of '(', ')' and '*' :return: \\"YES\\" if the string can be made valid, \\"NO\\" otherwise >>> checkValidString(\\"(*)\\") \\"YES\\" >>> checkValidString(\\"(*))\\") \\"YES\\" >>> checkValidString(\\"***)\\") \\"YES\\" >>> checkValidString(\\"((*\\") \\"NO\\" >>> checkValidString(\\"()\\") \\"YES\\" >>> checkValidString(\\")(\\") \\"NO\\" >>> checkValidString(\\"(*())\\") \\"YES\\" >>> checkValidString(\\"(((*)\\") \\"NO\\" >>> checkValidString(\\")\\") \\"NO\\" >>> checkValidString(\\"((*)*\\") \\"YES\\"","solution":"def checkValidString(s): Determine if the string s can be a valid parentheses string by replacing '*' with characters that make it valid. :param s: A string consisting of '(', ')' and '*' :return: \\"YES\\" if the string can be made valid, \\"NO\\" otherwise left_balance = right_balance = 0 # Check the string from left to right for char in s: if char in \\"(*\\": left_balance += 1 else: left_balance -= 1 if left_balance < 0: return \\"NO\\" # Check the string from right to left for char in reversed(s): if char in \\"*)\\": right_balance += 1 else: right_balance -= 1 if right_balance < 0: return \\"NO\\" return \\"YES\\""},{"question":"def findMax(arr, n): Returns the maximum element in the array. Parameters: arr (list): List of integers. n (int): Size of the list. Returns: int: Maximum element in the list. >>> findMax([3, 2, 1], 3) 3 >>> findMax([1, 2, 3, 4], 4) 4 >>> findMax([10, 20, 30, 25, 5], 5) 30 >>> findMax([1], 1) 1 >>> findMax([2, 2, 2, 2], 4) 2 >>> findMax([1, 5, 4, 2], 4) 5 >>> findMax([], 0) Traceback (most recent call last): ValueError: Array is empty","solution":"def findMax(arr, n): Returns the maximum element in the array. Parameters: arr (list): List of integers. n (int): Size of the list. Returns: int: Maximum element in the list. if n == 0: raise ValueError(\\"Array is empty\\") max_element = arr[0] for i in range(1, n): if arr[i] > max_element: max_element = arr[i] return max_element"},{"question":"def can_communicate(tx1, ty1, tx2, ty2, tx3, ty3, h): Determines if there exists a pair of towers that cannot communicate directly. Args: tx1, ty1: The coordinates of Tower X. tx2, ty2: The coordinates of Tower Y. tx3, ty3: The coordinates of Tower Z. h: The maximum distance a signal can travel vertically. Returns: 'Yay!' if all towers can communicate directly, otherwise ':('. >>> can_communicate(1, 2, 4, 10, 6, 22, 20) 'Yay!' >>> can_communicate(1, 2, 25, 10, 30, 22, 20) ':(' >>> can_communicate(1, 2, 4, 10, 31, 22, 20) ':(' >>> can_communicate(1, 2, 4, 10, 25, 22, 20) ':(' >>> can_communicate(1, 2, 3, 4, 5, 6, 10) 'Yay!' >>> can_communicate(0, 0, 100, 0, 200, 0, 200) 'Yay!' >>> can_communicate(0, 0, 100, 0, 201, 0, 200) ':('","solution":"def can_communicate(tx1, ty1, tx2, ty2, tx3, ty3, h): Determines if there exists a pair of towers that cannot communicate directly. Args: tx1, ty1: The coordinates of Tower X. tx2, ty2: The coordinates of Tower Y. tx3, ty3: The coordinates of Tower Z. h: The maximum distance a signal can travel vertically. Returns: 'Yay!' if all towers can communicate directly, otherwise ':('. dist_XY = tx2 - tx1 dist_XZ = tx3 - tx1 dist_YZ = tx3 - tx2 if dist_XY <= h and dist_XZ <= h and dist_YZ <= h: return \\"Yay!\\" else: return \\":(\\" # Example usage # print(can_communicate(1, 2, 4, 10, 6, 22, 20)) # should return 'Yay!'"},{"question":"def can_partition_into_equal_subsets(N: int) -> str: Determine if it is possible to partition the set {1, 2, ..., N} into two subsets such that the sums of the elements in each subset are equal. Parameters: N (int): The size of the set {1, 2, ..., N}. Returns: str: \\"Yes\\" if it is possible, \\"No\\" otherwise. >>> can_partition_into_equal_subsets(7) 'Yes' >>> can_partition_into_equal_subsets(8) 'Yes' >>> can_partition_into_equal_subsets(5) 'No' >>> can_partition_into_equal_subsets(1) 'No' >>> can_partition_into_equal_subsets(1000000) 'Yes'","solution":"def can_partition_into_equal_subsets(N): Determines if it is possible to partition the set {1, 2, ..., N} into two subsets such that the sums of the elements in each subset are equal. Parameters: N (int): The size of the set {1, 2, ..., N}. Returns: str: \\"Yes\\" if it is possible, \\"No\\" otherwise. total_sum = N * (N + 1) // 2 # Check if the total sum is even if total_sum % 2 == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def attendance_summary(attendance_list): Returns a summary dictionary containing the count of 'Present', 'Absent', and 'On Leave' days for an employee. >>> attendance_summary(['Present', 'Absent', 'On Leave', 'Present', 'Present', 'Absent', 'Present', 'On Leave', 'Present', 'Absent', 'Present', 'Present', 'On Leave', 'Present', 'Present', 'Present', 'Absent', 'Present', 'On Leave', 'Present', 'Present', 'Present', 'Absent', 'Present', 'Present', 'On Leave', 'Present', 'Present', 'Present', 'Absent']) {'Present': 19, 'Absent': 6, 'On Leave': 5} >>> attendance_summary(['Absent'] * 30) {'Present': 0, 'Absent': 30, 'On Leave': 0} >>> attendance_summary(['Present'] * 20 + ['On Leave'] * 5 + ['Absent'] * 5) {'Present': 20, 'Absent': 5, 'On Leave': 5}","solution":"def attendance_summary(attendance_list): Returns a summary dictionary containing the count of 'Present', 'Absent', and 'On Leave' days for an employee. summary = { 'Present': 0, 'Absent': 0, 'On Leave': 0 } for status in attendance_list: if status in summary: summary[status] += 1 return summary"},{"question":"from typing import List def findPatternOccurrences(S: str, P: str) -> List[int]: Given a string \`S\` of length \`n\` and a pattern \`P\` of length \`m\`, returns all the starting indices of \`P\` in \`S\`. This function employs an efficient algorithm to find all positions of the pattern \`P\` in the string \`S\`. >>> findPatternOccurrences(\\"abracadabra\\", \\"abra\\") [0, 7] >>> findPatternOccurrences(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> findPatternOccurrences(\\"mississippi\\", \\"iss\\") [1, 4] # implementation goes here","solution":"from typing import List def findPatternOccurrences(S: str, P: str) -> List[int]: Returns all the starting indices of pattern P in string S. Uses the Knuth-Morris-Pratt (KMP) algorithm for efficient string matching. def computeLPSArray(P: str) -> List[int]: # Length of the previous longest prefix suffix lps = [0] * len(P) length = 0 i = 1 while i < len(P): if P[i] == P[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = computeLPSArray(P) result = [] i = 0 # index for S j = 0 # index for P while i < len(S): if P[j] == S[i]: i += 1 j += 1 if j == len(P): result.append(i - j) j = lps[j - 1] elif i < len(S) and P[j] != S[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"from typing import List def odd_number_matrix(n: int) -> List[List[int]]: Given an input integer n, where 1 <= n <= 100, returns an nxn matrix with its rows filled with consecutive odd numbers starting from 1. >>> odd_number_matrix(1) [[1]] >>> odd_number_matrix(2) [[1, 3], [5, 7]] >>> odd_number_matrix(3) [[1, 3, 5], [7, 9, 11], [13, 15, 17]]","solution":"from typing import List def odd_number_matrix(n: int) -> List[List[int]]: Returns an nxn matrix with rows filled with consecutive odd numbers starting from 1. matrix = [] current_odd = 1 for i in range(n): row = [] for j in range(n): row.append(current_odd) current_odd += 2 matrix.append(row) return matrix"},{"question":"def max_interwoven_stories(test_cases): Given a collection of books represented by their page ranges, finds the maximum number of interwoven stories without overlapping page ranges in each test case. Args: test_cases (List[List[Tuple[int, int]]]): A list of test cases, where each test case is a list of tuples representing books and their page ranges. Returns: List[int]: A list of integers representing the maximum number of interwoven stories for each test case. pass def parse_input(input_text): Parses the input text into a suitable format for the max_interwoven_stories function. Args: input_text (str): A string containing the input information. Returns: List[List[Tuple[int, int]]]: A list of test cases. pass def format_output(results): Formats the results into a string suitable for output. Args: results (List[int]): A list of results from the max_interwoven_stories function. Returns: str: A formatted string of results. pass import pytest def test_example_case_1(): input_text = \\"2n3n1 5n2 6n8 10n4n1 3n2 5n6 8n9 10\\" expected_output = \\"2n3\\" test_cases = parse_input(input_text) results = max_interwoven_stories(test_cases) output = format_output(results) assert output == expected_output def test_example_case_2(): input_text = \\"1n5n1 2n3 4n5 6n7 8n9 10\\" expected_output = \\"5\\" test_cases = parse_input(input_text) results = max_interwoven_stories(test_cases) output = format_output(results) assert output == expected_output def test_overlapping_books(): input_text = \\"1n4n1 4n2 5n3 6n4 7\\" expected_output = \\"1\\" test_cases = parse_input(input_text) results = max_interwoven_stories(test_cases) output = format_output(results) assert output == expected_output def test_non_overlapping_books(): input_text = \\"1n4n1 2n3 4n5 6n7 8\\" expected_output = \\"4\\" test_cases = parse_input(input_text) results = max_interwoven_stories(test_cases) output = format_output(results) assert output == expected_output def test_single_book(): input_text = \\"1n1n1 10\\" expected_output = \\"1\\" test_cases = parse_input(input_text) results = max_interwoven_stories(test_cases) output = format_output(results) assert output == expected_output def test_multiple_cases(): input_text = \\"3n3n1 5n2 6n8 10n4n1 3n2 5n6 8n9 10n2n1 4n5 9\\" expected_output = \\"2n3n2\\" test_cases = parse_input(input_text) results = max_interwoven_stories(test_cases) output = format_output(results) assert output == expected_output if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"def max_interwoven_stories(test_cases): results = [] for books in test_cases: # Sort books by their ending page number qi books.sort(key=lambda x: x[1]) # Initialize counters and the end of the last selected book count = 0 last_end = 0 for book in books: start, end = book if start > last_end: count += 1 last_end = end results.append(count) return results def parse_input(input_text): lines = input_text.split('n') t = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(t): b = int(lines[index].strip()) books = [] for i in range(b): p, q = map(int, lines[index + 1 + i].strip().split()) books.append((p, q)) test_cases.append(books) index += b + 1 return test_cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def max_non_adjacent_sum(nums): Computes the maximum sum of non-adjacent elements in the list nums. >>> max_non_adjacent_sum([2, 3, 4, 5]) 8 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([-1]) 0 >>> max_non_adjacent_sum([5, 1]) 5 >>> max_non_adjacent_sum([-5, -1]) 0 >>> max_non_adjacent_sum([5, 5, 10, 40, 50, 35]) 80 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([3, 5, -7, 8, 10]) 15 >>> max_non_adjacent_sum([-5, -1, -8, -9]) 0","solution":"def max_non_adjacent_sum(nums): Computes the maximum sum of non-adjacent elements in the list nums. if not nums: return 0 prev_include = 0 prev_exclude = 0 for num in nums: new_exclude = max(prev_include, prev_exclude) prev_include = prev_exclude + num prev_exclude = new_exclude return max(prev_include, prev_exclude)"},{"question":"def minimize_max_diff(N, A): Rearranges the list A of N integers such that the maximum of absolute differences between consecutive elements (considering the cyclic nature) is minimized. :param N: Integer, number of elements in A :param A: List of integers :return: List of integers arranged with minimized max difference >>> minimize_max_diff(5, [10, 13, 11, 12, 14]) [10, 14, 11, 13, 12] >>> minimize_max_diff(4, [7, 4, 1, 9]) [1, 9, 4, 7] >>> minimize_max_diff(6, [5, 3, 2, 4, 6, 1]) [1, 6, 2, 5, 3, 4] def process_test_cases(T, test_cases): Process multiple test cases and apply the minimize_max_diff function :param T: Number of test cases :param test_cases: List of tuples where each tuple contains (N, A) :return: List of results for each test case >>> process_test_cases(3, [(5, [10, 13, 11, 12, 14]), (4, [7, 4, 1, 9]), (6, [5, 3, 2, 4, 6, 1])]) [[10, 14, 11, 13, 12], [1, 9, 4, 7], [1, 6, 2, 5, 3, 4]]","solution":"def minimize_max_diff(N, A): Rearranges the list A of N integers such that the maximum of absolute differences between consecutive elements (considering the cyclic nature) is minimized. :param N: Integer, number of elements in A :param A: List of integers :return: List of integers arranged with minimized max difference A.sort() # Sort the array B = [] # Create the new list B by interleaving small and large values from sorted array # Start from the largest and smallest, and go inside for i in range(N // 2): B.append(A[i]) B.append(A[N - 1 - i]) # If N is odd, append the middle element to the end if N % 2 == 1: B.append(A[N // 2]) return B def process_test_cases(T, test_cases): Process multiple test cases and apply the minimize_max_diff function :param T: Number of test cases :param test_cases: List of tuples where each tuple contains (N, A) :return: List of results for each test case results = [] for i in range(T): N, A = test_cases[i] result = minimize_max_diff(N, A) results.append(result) return results"},{"question":"from typing import List, Dict, Union def sort_employees_by_salary(employees: List[Dict[str, Union[int, str]]]) -> List[str]: Sorts the employee list first by salary in ascending order, then by name lexicographically in case of ties in salary. Parameters: employees (List[Dict[str, Union[int, str]]]): A list of dictionaries containing employee information Returns: List[str]: A list of employee names sorted by the mentioned criteria. >>> sort_employees_by_salary([ ... {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"salary\\": 70000}, ... {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"salary\\": 50000}, ... {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"salary\\": 60000} ... ]) ['Bob', 'Charlie', 'Alice'] >>> sort_employees_by_salary([ ... {\\"id\\": 4, \\"name\\": \\"Diana\\", \\"salary\\": 80000}, ... {\\"id\\": 5, \\"name\\": \\"Eva\\", \\"salary\\": 90000}, ... {\\"id\\": 6, \\"name\\": \\"Frank\\", \\"salary\\": 60000} ... ]) ['Frank', 'Diana', 'Eva']","solution":"from typing import List, Dict, Union def sort_employees_by_salary(employees: List[Dict[str, Union[int, str]]]) -> List[str]: Sorts the employee list first by salary in ascending order, then by name lexicographically in case of ties in salary. Parameters: employees (List[Dict[str, Union[int, str]]]): A list of dictionaries containing employee information Returns: List[str]: A list of employee names sorted by the mentioned criteria. # Sorting the employees by 'salary' first and by 'name' for tiebreakers sorted_employees = sorted(employees, key=lambda x: (x[\\"salary\\"], x[\\"name\\"])) # Extracting the names in sorted order sorted_names = [employee[\\"name\\"] for employee in sorted_employees] return sorted_names"},{"question":"def longest_contiguous_subarray(n: int, array: List[int]) -> int: Given an array of integers, find the longest contiguous subarray consisting of just one distinct integer, and return its length. :param n: Integer, length of the array :param array: List of integers, the array elements :return: Integer, length of the longest contiguous subarray >>> longest_contiguous_subarray(5, [4, 4, 2, 2, 2]) 3 >>> longest_contiguous_subarray(6, [1, 1, 1, 1, 1, 1]) 6 >>> longest_contiguous_subarray(4, [1, 2, 3, 4]) 1 >>> longest_contiguous_subarray(8, [5, 5, 5, 4, 4, 4, 4, 7]) 4 pass","solution":"def longest_contiguous_subarray(n, array): Given an array of integers, finds the longest contiguous subarray consisting of just one distinct integer, and returns its length. :param n: Integer, length of the array :param array: List of integers, the array elements :return: Integer, length of the longest contiguous subarray if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if array[i] == array[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length # Example usage: # n = 5 # array = [4, 4, 2, 2, 2] # print(longest_contiguous_subarray(n, array)) # Output: 3"},{"question":"def canSplitIntoConsecutive(s: str) -> str: Determine if the string can be split into consecutive integers. >>> canSplitIntoConsecutive(\\"1234\\") 'YES 1' >>> canSplitIntoConsecutive(\\"91011\\") 'YES 9' >>> canSplitIntoConsecutive(\\"99100\\") 'YES 99' >>> canSplitIntoConsecutive(\\"1235\\") 'NO'","solution":"def canSplitIntoConsecutive(s): Determine if the string can be split into consecutive integers. n = len(s) for i in range(1, n): first_num = int(s[:i]) expected_next = first_num + 1 j = i while j < n: next_num_str = str(expected_next) next_len = len(next_num_str) if s[j:j+next_len] == next_num_str: j += next_len expected_next += 1 else: break if j == n: return \\"YES \\" + str(first_num) return \\"NO\\""},{"question":"def validate_dishes(test_cases): Validate if the sequence of dishes is valid according to the flavor level rules. >>> validate_dishes([[5, [3, 4, 5, 6, 7]]]) [\\"VALID\\"] >>> validate_dishes([[6, [10, 9, 8, 7, 6, 5]]]) [\\"VALID\\"] >>> validate_dishes([[4, [1, 2, 4, 3]]]) [\\"INVALID\\"] >>> validate_dishes([[3, [5, 5, 6]]]) [\\"INVALID\\"]","solution":"def validate_dishes(test_cases): results = [] for dishes in test_cases: N = dishes[0] # Number of dishes flavors = dishes[1] # List of flavor levels valid = True for i in range(1, N): if abs(flavors[i] - flavors[i - 1]) != 1: valid = False break if valid: results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def isValidParenthesisString(S: str) -> str: Determines if the input string S is a valid parenthesis string. >>> isValidParenthesisString(\\"()\\") \\"YES\\" >>> isValidParenthesisString(\\")(\\") \\"NO\\" >>> isValidParenthesisString(\\"(())\\") \\"YES\\" >>> isValidParenthesisString(\\"(()()\\") \\"NO\\"","solution":"def isValidParenthesisString(S): Determines if the input string S is a valid parenthesis string. balance = 0 for char in S: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: return 'NO' return 'YES' if balance == 0 else 'NO'"},{"question":"def total_food(c, ch, s): Returns the total amount of food required per day to feed c cows, ch chickens, and s sheep. Each cow needs 4 units of food per day. Each chicken needs 1 unit of food per day. Each sheep needs 3 units of food per day. >>> total_food(3, 5, 2) 23 >>> total_food(0, 0, 0) 0","solution":"def total_food(c, ch, s): Returns the total amount of food required per day to feed c cows, ch chickens, and s sheep. Each cow needs 4 units of food per day. Each chicken needs 1 unit of food per day. Each sheep needs 3 units of food per day. cow_food = 4 chicken_food = 1 sheep_food = 3 return (cow_food * c) + (chicken_food * ch) + (sheep_food * s)"},{"question":"def insert_space_and_lowercase(sentence: str) -> str: Inserts a space before every uppercase letter (except the first one if it is uppercase) and converts the entire sentence to lowercase. >>> insert_space_and_lowercase(\\"HelloWorldThisIsPython\\") 'hello world this is python' >>> insert_space_and_lowercase(\\"Hello\\") 'hello' >>> insert_space_and_lowercase(\\"helloworld\\") 'helloworld' >>> insert_space_and_lowercase(\\"HELLOWORLD\\") 'h e l l o w o r l d' >>> insert_space_and_lowercase(\\"heLLoWoRld\\") 'he l lo wo rld'","solution":"def insert_space_and_lowercase(sentence): Inserts a space before every uppercase letter (except the first one if it is uppercase) and converts the entire sentence to lowercase. modified_sentence = [] for i, char in enumerate(sentence): if char.isupper() and i != 0: modified_sentence.append(' ') modified_sentence.append(char.lower()) return ''.join(modified_sentence)"},{"question":"def can_form_palindrome(s: str, queries: List[Tuple[int, int]]) -> List[str]: Determines if substrings can be rearranged to form a palindrome. >>> can_form_palindrome(\\"abacaba\\", [(1, 7), (2, 4), (3, 5)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_form_palindrome(\\"abcde\\", [(1, 5), (2, 3)]) [\\"NO\\", \\"NO\\"]","solution":"def can_form_palindrome(s, queries): Determines if substrings can be rearranged to form a palindrome. :param s: A string of lowercase English letters. :param queries: A list of tuples (li, ri) indicating the range of queries. :return: A list of \\"YES\\" or \\"NO\\" for each query. def is_palindrome_possible(sub): # A string can be rearranged to form a palindrome if at most one character # has an odd count. from collections import Counter freq = Counter(sub) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1 results = [] for li, ri in queries: substring = s[li-1:ri] # Convert 1-based index to 0-based if is_palindrome_possible(substring): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_subarray_sum(n, arr): Finds the largest possible sum of a subarray of the given array. Args: n : int : number of integers in the array arr : list of int : the elements of the array Returns: int : the largest possible sum of a subarray >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(1, [-1]) -1 >>> max_subarray_sum(4, [1, 2, 3, 4]) 10","solution":"def max_subarray_sum(n, arr): Finds the largest possible sum of a subarray of the given array. Args: n : int : number of integers in the array arr : list of int : the elements of the array Returns: int : the largest possible sum of a subarray max_current = max_global = arr[0] for i in range(1, n): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def find_palindrome_sequence(X: int, L: int) -> int: Generate a sequence of numbers starting from X and find the first palindrome within L iterations. Args: X (int): The starting integer. L (int): The limit on the number of iterations. Returns: int: A tuple containing the first palindrome found and the number of iterations it took, or -1 if no palindrome is found within the given limit. >>> find_palindrome_sequence(56, 5) 121, 1 >>> find_palindrome_sequence(123, 3) 444, 1 >>> find_palindrome_sequence(87, 4) -1 pass def process_test_cases(T: int, test_cases: list) -> list: Process multiple test cases to find palindromes in the specified sequences. Args: T (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains (X, L). Returns: list: A list of results where each result is a string representing the palindrome and the number of iterations or -1 if no palindrome is found within the given limit. >>> process_test_cases(3, [(56, 5), (123, 3), (87, 4)]) [\\"121 1\\", \\"444 1\\", \\"-1\\"] pass","solution":"def find_palindrome_sequence(X, L): Finds the resulting palindrome and the number of iterations it took. If no palindrome is found within the given limit, returns -1. def is_palindrome(num): return str(num) == str(num)[::-1] iterations = 0 current_num = X while iterations < L: if is_palindrome(current_num): return current_num, iterations reversed_num = int(str(current_num)[::-1]) current_num += reversed_num iterations += 1 return -1 def process_test_cases(T, test_cases): results = [] for X, L in test_cases: result = find_palindrome_sequence(X, L) if result == -1: results.append(\\"-1\\") else: results.append(f\\"{result[0]} {result[1]}\\") return results"},{"question":"def filter_even_digit_numbers(numbers): Filters the given list of integers and returns a new list with only the elements that have an even number of digits. Parameters: numbers (list of int): The list of integers to filter. Returns: list of int: A list where each integer has an even number of digits. >>> filter_even_digit_numbers([123, 22, 4567, 789]) # --> [22, 4567] >>> filter_even_digit_numbers([1, 123, 789]) # --> [] >>> filter_even_digit_numbers([-1, -22, -123, -4567]) # --> [-22, -4567]","solution":"def filter_even_digit_numbers(numbers): Filters the given list of integers and returns a new list with only the elements that have an even number of digits. Parameters: numbers (list of int): The list of integers to filter. Returns: list of int: A list where each integer has an even number of digits. return [num for num in numbers if len(str(abs(num))) % 2 == 0]"},{"question":"def maximalSquare(matrix: List[List[int]]) -> int: Given a binary matrix, find the largest size square sub-matrix with all 1s. >>> maximalSquare([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ... ]) 2 >>> maximalSquare([ ... [\\"0\\",\\"1\\"], ... [\\"1\\",\\"0\\"] ... ]) 1 >>> maximalSquare([ ... [\\"0\\"] ... ]) 0","solution":"def maximalSquare(matrix): if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) max_side_length = 0 dp = [[0] * (cols + 1) for _ in range(rows + 1)] for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i - 1][j - 1] == \\"1\\": dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"from typing import List def rearrangeString(s: str, k: int) -> str: Determine if you can rearrange the characters in the string such that no two adjacent characters are the same. If it is possible, return any possible resultant string. If it is not possible, return an empty string. >>> rearrangeString(\\"aabbcc\\", 3) \\"abcabc\\" or a similar valid arrangement >>> rearrangeString(\\"aaaaaa\\", 2) \\"\\" >>> rearrangeString(\\"a\\", 2) \\"a\\" >>> rearrangeString(\\"aabbccddeeff\\", 4) != \\"\\" >>> rearrangeString(\\"abcabc\\", 1) \\"abcabc\\" >>> rearrangeString(\\"aabbcc\\", 5) \\"\\"","solution":"from collections import Counter, deque import heapq def rearrangeString(s, k): if k == 1: # If k == 1, any string would be valid because no restriction on character count per segment return s counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = deque() # queue to store the characters that are in the cooldown period while max_heap or wait_queue: if wait_queue and wait_queue[0][1] == len(result): heapq.heappush(max_heap, wait_queue.popleft()[0]) if not max_heap: return \\"\\" freq, char = heapq.heappop(max_heap) result.append(char) if -freq > 1: wait_queue.append(((freq + 1, char), len(result) + k - 1)) return \\"\\".join(result) # Test the function with example inputs print(rearrangeString(\\"aabbcc\\", 3)) # Output: \\"abcabc\\" or similar valid arrangement print(rearrangeString(\\"aaaaaa\\", 2)) # Output: \\"\\""},{"question":"def reversePairs(nums: List[int]) -> int: Returns the number of reverse pairs in the array 'nums'. A reverse pair is defined as a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2*nums[j]. >>> reversePairs([1, 3, 2, 3, 1]) 2 >>> reversePairs([2, 4, 3, 5, 1]) 3","solution":"def reversePairs(nums): Returns the number of reverse pairs in the array 'nums'. A reverse pair is defined as a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2*nums[j]. if not nums: return 0 def merge_sort_and_count(start, end): if start >= end: return 0 mid = (start + end) // 2 count = merge_sort_and_count(start, mid) + merge_sort_and_count(mid + 1, end) # Count the reverse pairs j = mid + 1 for i in range(start, mid + 1): while j <= end and nums[i] > 2 * nums[j]: j += 1 count += j - (mid + 1) # Merge the two halves temp = [] left, right = start, mid + 1 while left <= mid and right <= end: if nums[left] <= nums[right]: temp.append(nums[left]) left += 1 else: temp.append(nums[right]) right += 1 while left <= mid: temp.append(nums[left]) left += 1 while right <= end: temp.append(nums[right]) right += 1 nums[start:end + 1] = temp return count return merge_sort_and_count(0, len(nums) - 1)"},{"question":"def max_water_container(heights): Returns the maximum amount of water that can be stored between two buildings. The width of the container is considered to be the difference in their indices. Example: >>> max_water_container([1,8,6,2,5,4,8,3,7]) 49 >>> max_water_container([1,1]) 1 >>> max_water_container([4,3,2,1,4]) 16 >>> max_water_container([1,2,1]) 2","solution":"def max_water_container(heights): Returns the maximum amount of water that can be stored between two buildings. The width of the container is considered to be the difference in their indices. left = 0 right = len(heights) - 1 max_water = 0 while left < right: width = right - left min_height = min(heights[left], heights[right]) max_water = max(max_water, width * min_height) # Move the pointer which points to the shorter building if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def calculate_total_parking_fee(n, parking_records): Calculate the total amount collected by the parking lot based on the parking times of the vehicles. Args: n: int - number of vehicles parked in the parking lot during the day parking_records: List[str] - parking details for each vehicle in the format \\"spot_number entry_time exit_time\\" Returns: int - the total amount collected by the parking lot in dollars >>> calculate_total_parking_fee(3, [\\"1 08:00 10:30\\", \\"2 09:00 12:00\\", \\"3 14:45 16:15\\"]) 16 >>> calculate_total_parking_fee(3, [\\"1 08:00 09:00\\", \\"2 09:00 09:30\\", \\"3 14:00 15:00\\"]) 6 >>> calculate_total_parking_fee(2, [\\"1 00:00 01:00\\", \\"2 23:00 23:59\\"]) 4 >>> calculate_total_parking_fee(3, [\\"1 08:00 08:59\\", \\"2 07:00 07:30\\", \\"3 11:45 12:15\\"]) 6 >>> calculate_total_parking_fee(2, [\\"1 00:00 12:00\\", \\"2 12:00 23:59\\"]) 48","solution":"def calculate_total_parking_fee(n, parking_records): total_fee = 0 for record in parking_records: spot_number, entry_time, exit_time = record.split() entry_hour, entry_minute = map(int, entry_time.split(':')) exit_hour, exit_minute = map(int, exit_time.split(':')) total_entry_minutes = entry_hour * 60 + entry_minute total_exit_minutes = exit_hour * 60 + exit_minute total_duration_minutes = total_exit_minutes - total_entry_minutes total_hours = (total_duration_minutes + 59) // 60 total_fee += total_hours * 2 return total_fee"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Finds the largest rectangular area that can be formed within the histogram. >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 1]) 10 >>> largest_rectangle_area([2, 2, 2, 2, 2]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([0, 1, 2, 3, 4, 0]) 6 >>> largest_rectangle_area([0, 0, 0, 0, 0]) 0 pass","solution":"def largest_rectangle_area(heights): Finds the largest rectangular area that can be formed within the histogram. :param heights: List of non-negative integers representing heights of bars in the histogram :return: Integer representing the largest rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def longest_study_streak(n, routines): Calculates the longest consecutive study streak for each student. Parameters: n (int): Number of students. routines (list): List of strings representing each student's daily routine. Returns: list: A list of integers where each integer is the longest consecutive study streak for the corresponding student. # Your implementation here # Unit Test def test_longest_study_streak_example(): assert longest_study_streak(3, [\\"SSRSSSSRS\\", \\"RRSSSRSSS\\", \\"SSSR\\"]) == [4, 3, 3] def test_longest_study_streak_all_study(): assert longest_study_streak(1, [\\"SSSSSSSS\\"]) == [8] def test_longest_study_streak_no_study(): assert longest_study_streak(2, [\\"RRRRR\\", \\"\\"]) == [0, 0] def test_longest_study_streak_mixed(): assert longest_study_streak(2, [\\"SRSSRSSRS\\", \\"SSRRRSSS\\"]) == [2, 3] def test_longest_study_streak_single_day(): assert longest_study_streak(4, [\\"S\\", \\"R\\", \\"SR\\", \\"RS\\"]) == [1, 0, 1, 1]","solution":"def longest_study_streak(n, routines): Calculates the longest consecutive study streak for each student. Parameters: n (int): Number of students. routines (list): List of strings representing each student's daily routine. Returns: list: A list of integers where each integer is the longest consecutive study streak for the corresponding student. results = [] for routine in routines: max_streak = 0 current_streak = 0 for day in routine: if day == 'S': current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 results.append(max_streak) return results"},{"question":"def can_transform(n: int, initial: str, final: str) -> str: Determine if it is possible to transform the initial word into the final word after exactly n moves. Args: n (int): number of turns initial (str): the initial word final (str): the final word Returns: str: \\"YES\\" if it's possible to obtain the final word from the initial word, \\"NO\\" otherwise Examples: >>> can_transform(3, \\"hello\\", \\"healo\\") \\"YES\\" >>> can_transform(3, \\"abc\\", \\"abcd\\") \\"NO\\"","solution":"def can_transform(n, initial, final): Determine if it is possible to transform the initial word into the final word with exactly n moves. len_initial = len(initial) len_final = len(final) # Check the required number of moves to get from initial to final min_moves = abs(len_initial - len_final) + sum(1 for i, j in zip(initial, final) if i != j) # Additional or exact moves required if lengths are different if len_initial > len_final: min_moves += len_initial - len_final elif len_final > len_initial: min_moves += len_final - len_initial # Check if n moves are enough and if the difference (n - min_moves) is even (for parity issues) if min_moves <= n and (n - min_moves) % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def highestThreeConsecutiveSum(N, scores): Returns the highest score obtained by summing up scores of exactly three consecutive students. If the array has fewer than three elements, it returns -1. Parameters: N (int): The number of scores in the array. scores (List[int]): The array of scores. Returns: int: The highest score obtained by summing up scores of exactly three consecutive students, or -1 if not possible. >>> highestThreeConsecutiveSum(5, [100, 200, 300, 400, 500]) 1200 >>> highestThreeConsecutiveSum(3, [50, 60, 70]) 180 >>> highestThreeConsecutiveSum(2, [10, 20]) -1","solution":"def highestThreeConsecutiveSum(N, scores): Returns the highest score obtained by summing up scores of exactly three consecutive students if N < 3: return -1 max_sum = scores[0] + scores[1] + scores[2] current_sum = max_sum for i in range(3, N): current_sum = current_sum - scores[i - 3] + scores[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a given non-negative integer n. Args: n (int): A non-negative integer. Returns: int: The factorial of the given number. Raises: ValueError: If n is a negative integer. Examples: >>> factorial(0) 1 >>> factorial(4) 24 >>> factorial(10) 3628800","solution":"def factorial(n): Calculate the factorial of a given non-negative integer n. if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def add_item(inventory, name, quantity): Adds a specified quantity of an item to the inventory. If the item already exists, increase its quantity. >>> inventory = [] >>> add_item(inventory, \\"apple\\", 5) >>> inventory [{\\"name\\": \\"apple\\", \\"quantity\\": 5}] def remove_item(inventory, name, quantity): Removes a specified quantity of an item from the inventory. If the quantity to remove exceeds the current quantity, remove the item completely. If the item does not exist, do nothing. >>> inventory = [{\\"name\\": \\"banana\\", \\"quantity\\": 5}] >>> remove_item(inventory, \\"banana\\", 3) >>> inventory [{\\"name\\": \\"banana\\", \\"quantity\\": 2}] def total_items(inventory): Returns the total number of all items in the inventory. >>> inventory = [{\\"name\\": \\"apple\\", \\"quantity\\": 5}, {\\"name\\": \\"banana\\", \\"quantity\\": 3}] >>> total_items(inventory) 8","solution":"def add_item(inventory, name, quantity): Adds a specified quantity of an item to the inventory. If the item already exists, increase its quantity. for item in inventory: if item['name'] == name: item['quantity'] += quantity break else: inventory.append({'name': name, 'quantity': quantity}) def remove_item(inventory, name, quantity): Removes a specified quantity of an item from the inventory. If the quantity to remove exceeds the current quantity, remove the item completely. If the item does not exist, do nothing. for item in inventory: if item['name'] == name: if item['quantity'] <= quantity: inventory.remove(item) else: item['quantity'] -= quantity break def total_items(inventory): Returns the total number of all items in the inventory. return sum(item['quantity'] for item in inventory)"},{"question":"def is_strong_password(password: str) -> bool: Checks if the given password is strong according to the criteria: - It contains at least 8 characters. - It must contain at least one uppercase letter. - It must contain at least one lowercase letter. - It must contain at least one digit. - It must contain at least one special character from the set: !@#%^&*()-+. >>> is_strong_password(\\"Passw0rd!\\") == True >>> is_strong_password(\\"password\\") == False >>> is_strong_password(\\"P@ssword\\") == False >>> is_strong_password(\\"12345678\\") == False >>> is_strong_password(\\"Aa1!\\") == False >>> is_strong_password(\\"VeryL0ngPassw0rdWithSpec!alChar@cter\\") == True","solution":"import re def is_strong_password(password: str) -> bool: Checks if the given password is strong according to the criteria: - It contains at least 8 characters. - It must contain at least one uppercase letter. - It must contain at least one lowercase letter. - It must contain at least one digit. - It must contain at least one special character from the set: !@#%^&*()-+. :param password: The password to check. :return: True if the password is strong, False otherwise. if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'd', password): return False if not re.search(r'[!@#%^&*()-+]', password): return False return True"},{"question":"def min_rounds_to_win(n: int, a: List[int]) -> int: Determine the minimum number of rounds that Player 1 needs to guarantee a win. Parameters: n (int): The number of integers in the line. a (List[int]): The list of integers. Returns: int: The minimum number of rounds Player 1 needs to guarantee a win. >>> min_rounds_to_win(3, [1, 2, 3]) 2 >>> min_rounds_to_win(4, [-1, 0, 1, 2]) 2 >>> min_rounds_to_win(1, [10]) 1","solution":"def min_rounds_to_win(n, a): Returns the minimum number of rounds Player 1 needs to guarantee a win. # To guarantee a win, Player 1 needs to take the last integer. # The minimum rounds Player 1 needs is floor((N + 1) / 2). return (n + 1) // 2"},{"question":"def min_diff_after_one_operation(n: int, arr: List[int]) -> int: Given an array of n integers, determines the minimum possible value of the difference between the maximum and minimum elements after performing at most one operation (adding or subtracting 1 from a single element). >>> min_diff_after_one_operation(3, [1, 3, 6]) == 4 >>> min_diff_after_one_operation(5, [10, 10, 10, 10, 10]) == 0 >>> min_diff_after_one_operation(2, [1, 5]) == 3 >>> min_diff_after_one_operation(4, [7, 8, 10, 13]) == 5 >>> min_diff_after_one_operation(5, [1, 2, 2, 3, 5]) == 3","solution":"def min_diff_after_one_operation(n, arr): Given an array of n integers, determines the minimum possible value of the difference between the maximum and minimum elements after performing at most one operation (adding or subtracting 1 from a single element). if n == 1: return 0 max_val = max(arr) min_val = min(arr) # Initial difference with no operations initial_difference = max_val - min_val # Consider cases: # 1. Adding 1 to the min element # 2. Subtracting 1 from the max element new_difference_case1 = max(max_val, min_val + 1) - min(min_val + 1, max_val) new_difference_case2 = max(max_val - 1, min_val) - min(min_val, max_val - 1) return min(initial_difference, new_difference_case1, new_difference_case2)"},{"question":"from typing import List, Tuple def highest_avg_temperature_reading(readings: List[Tuple[str, str, float]]) -> Tuple[str, str]: Identifies the sensor with the highest average temperature and returns the sensor ID and the timestamp of its highest temperature reading. Examples: >>> readings = [ ... (\\"2023-01-01 10:00:00\\", \\"sensor1\\", 20.5), ... (\\"2023-01-01 11:00:00\\", \\"sensor2\\", 21.0), ... (\\"2023-01-01 12:00:00\\", \\"sensor1\\", 23.0), ... (\\"2023-01-01 13:00:00\\", \\"sensor2\\", 22.0), ... (\\"2023-01-01 14:00:00\\", \\"sensor1\\", 22.5), ... (\\"2023-01-01 15:00:00\\", \\"sensor2\\", 25.0) ... ] >>> highest_avg_temperature_reading(readings) ('sensor2', '2023-01-01 15:00:00') >>> readings = [ ... (\\"2023-01-01 10:00:00\\", \\"sensor1\\", 25.0), ... (\\"2023-01-01 11:00:00\\", \\"sensor1\\", 25.0) ... ] >>> highest_avg_temperature_reading(readings) ('sensor1', '2023-01-01 10:00:00')","solution":"from collections import defaultdict from statistics import mean def highest_avg_temperature_reading(readings): Identifies the sensor with the highest average temperature and returns the sensor ID and the timestamp of its highest temperature reading. sensor_data = defaultdict(lambda: {\\"temps\\": [], \\"max_temp\\": float('-inf'), \\"max_temp_time\\": None, \\"first_time\\": None}) for timestamp, sensor_id, temperature in readings: sensor_data[sensor_id][\\"temps\\"].append(temperature) if temperature > sensor_data[sensor_id][\\"max_temp\\"]: sensor_data[sensor_id][\\"max_temp\\"] = temperature sensor_data[sensor_id][\\"max_temp_time\\"] = timestamp if sensor_data[sensor_id][\\"first_time\\"] is None: sensor_data[sensor_id][\\"first_time\\"] = timestamp max_avg_temp = float('-inf') selected_sensor = None for sensor_id, data in sensor_data.items(): avg_temp = mean(data[\\"temps\\"]) if (avg_temp > max_avg_temp or (avg_temp == max_avg_temp and data[\\"max_temp\\"] > sensor_data[selected_sensor][\\"max_temp\\"]) or (avg_temp == max_avg_temp and data[\\"max_temp\\"] == sensor_data[selected_sensor][\\"max_temp\\"] and data[\\"first_time\\"] < sensor_data[selected_sensor][\\"first_time\\"])): max_avg_temp = avg_temp selected_sensor = sensor_id return selected_sensor, sensor_data[selected_sensor][\\"max_temp_time\\"]"},{"question":"def count_unique_genres(N: int, books: List[str]) -> Tuple[int, List[str]]: Find the number of unique genres and create a sorted list of these genres. Parameters: N (int): Number of books in the library. books (list of strings): Each string is a comma-separated list of genres for a book. Returns: tuple: Number of unique genres, sorted list of unique genres. >>> count_unique_genres(3, [\\"fiction,history,mystery\\", \\"science,fiction,technology\\", \\"fantasy,mystery,history,romance\\"]) (7, ['fantasy', 'fiction', 'history', 'mystery', 'romance', 'science', 'technology']) >>> count_unique_genres(1, [\\"science\\"]) (1, ['science'])","solution":"def count_unique_genres(N, books): Returns the number of unique genres and a sorted list of these genres. Parameters: N (int): Number of books in the library books (list of strings): Each string is a comma-separated list of genres for a book Returns: tuple: Number of unique genres, sorted list of unique genres genres_set = set() for book in books: genres = book.split(',') for genre in genres: genres_set.add(genre) unique_genres_sorted = sorted(genres_set) return len(genres_set), unique_genres_sorted # Sample Input N = 3 books = [ \\"fiction,history,mystery\\", \\"science,fiction,technology\\", \\"fantasy,mystery,history,romance\\" ] # Calling the function number_of_genres, unique_genres_list = count_unique_genres(N, books) print(number_of_genres) for genre in unique_genres_list: print(genre)"},{"question":"def highest_sales(T, monthly_sales): Returns the highest sales value for each month. Parameters: T - the number of months (int) monthly_sales - list of lists, where each inner list contains the sales data for one month (list of int) Returns: List of highest sales value for each month (list of int) Examples: >>> highest_sales(3, [[4, 500, 600, 700, 650], [3, 1200, 300, 450], [5, 200, 550, 750, 800, 700]]) == [700, 1200, 800] >>> highest_sales(1, [[1, 300]]) == [300] >>> highest_sales(1, [[3, 100, 200, 150]]) == [200] >>> highest_sales(4, [[4, 10, 50, 30, 20], [3, 5, 15, 25], [2, 100, 200], [5, 10, 20, 15, 25, 30]]) == [50, 25, 200, 30] >>> highest_sales(2, [[3, 0, 0, 0], [2, 0, 0]]) == [0, 0]","solution":"def highest_sales(T, monthly_sales): Returns the highest sales value for each month. Parameters: T - the number of months (int) monthly_sales - list of lists, where each inner list contains the sales data for one month (list of int) Returns: List of highest sales value for each month (list of int) highest_sales_values = [] for sales in monthly_sales: N = sales[0] sales_data = sales[1:] highest_sales_values.append(max(sales_data)) return highest_sales_values"},{"question":"def solve_mosaic(N, M, K, initial_grid): Alyssa is trying to create a mosaic using a grid of tiles. She has an unlimited supply of tiles of different colors. She wants to color a given grid following specific constraints. The grid is an N x M matrix where each cell can be painted in one of K different colors. She wants to paint the grid in such a way that no two adjacent cells (i.e., cells that share a side) have the same color. Additionally, a list of pre-painted cells is provided, and Alyssa must preserve the color of these pre-painted cells. Input: - int N: The number of rows in the grid. - int M: The number of columns in the grid. - int K: The number of available colors. - List[List[int]] initial_grid: The initial state of the grid. Output: - Tuple (str, List[List[int]]): If it's possible to paint the grid, output \\"YES\\" followed by the N x M grid with each cell painted according to the rules. If it's impossible, output \\"NO\\". >>> solve_mosaic(3, 3, 3, [[1, 0, 0], [0, 0, 0], [0, 0, 2]]) (\\"YES\\", [[1, 2, 3], [3, 1, 2], [2, 3, 2]]) >>> solve_mosaic(3, 3, 2, [[1, 0, 0], [0, 0, 0], [0, 0, 2]]) (\\"NO\\", None)","solution":"def is_valid_color(grid, r, c, color, N, M): # Checking adjacent cells for the same color for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == color: return False return True def solve_mosaic(N, M, K, initial_grid): # Copy the initial grid grid = [row[:] for row in initial_grid] def can_paint(): for r in range(N): for c in range(M): if grid[r][c] == 0: # Try to find a valid color for this cell for color in range(1, K + 1): if is_valid_color(grid, r, c, color, N, M): grid[r][c] = color break else: return False return True if can_paint(): return \\"YES\\", grid else: return \\"NO\\", None # Reading input for testing purposes def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) K = int(data[2]) initial_grid = [] start_index = 3 for i in range(N): row = list(map(int, data[start_index + i * M: start_index + (i + 1) * M])) initial_grid.append(row) result, grid = solve_mosaic(N, M, K, initial_grid) if result == \\"YES\\": print(result) for row in grid: print(' '.join(map(str, row))) else: print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def find_first_duplicate(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Identifies the first duplicate product ID in each batch of product IDs. Args: T: int - Number of test cases. test_cases: List[Tuple[int, List[int]]] - A list of tuples where each tuple contains an integer n (number of product IDs) and a list of n space-separated integers representing the product IDs. Returns: List[int] - A list of integers where each integer is the first duplicated product ID in the corresponding batch, or -1 if there are no duplicates. >>> find_first_duplicate(2, [(5, [1, 2, 3, 4, 2]), (4, [4, 3, 2, 1])]) [2, -1] >>> find_first_duplicate(1, [(4, [1, 2, 3, 4])]) [-1] >>> find_first_duplicate(1, [(4, [2, 2, 2, 2])]) [2] >>> find_first_duplicate(1, [(6, [10, 20, 30, 40, 50, 10])]) [10] >>> find_first_duplicate(1, [(1, [100])]) [-1] >>> find_first_duplicate(1, [(7, [1, 2, 3, 4, 5, 6, 1])]) [1]","solution":"def find_first_duplicate(T, test_cases): result = [] for case in test_cases: n, ids = case seen = set() first_duplicate = -1 for id in ids: if id in seen: first_duplicate = id break seen.add(id) result.append(first_duplicate) return result"},{"question":"def minimize_logs(n, logs): Minimizes the list of logs by merging consecutive logs of the same user with the same activity. Parameters: n (int): Number of log entries. logs (list of tuples): List of logs, where each log is represented as a tuple (user_id, activity_type). Returns: List of tuples: Minimized list of logs. >>> minimize_logs(6, [(1, 2), (1, 2), (2, 1), (2, 1), (2, 1), (1, 3)]) [(1, 2), (2, 1), (1, 3)] >>> minimize_logs(4, [(3, 4), (3, 4), (4, 3), (3, 4)]) [(3, 4), (4, 3), (3, 4)] >>> minimize_logs(0, []) [] >>> minimize_logs(1, [(1, 1)]) [(1, 1)] >>> minimize_logs(3, [(1, 2), (1, 3), (1, 2)]) [(1, 2), (1, 3), (1, 2)] >>> minimize_logs(5, [(1, 1), (1, 1), (2, 2), (2, 2), (1, 1)]) [(1, 1), (2, 2), (1, 1)]","solution":"def minimize_logs(n, logs): Minimizes the list of logs by merging consecutive logs of the same user with the same activity. Parameters: n (int): Number of log entries. logs (list of tuples): List of logs, where each log is represented as a tuple (user_id, activity_type). Returns: List of tuples: Minimized list of logs. if n == 0: return [] result = [] current_log = logs[0] for i in range(1, n): if logs[i] != current_log: result.append(current_log) current_log = logs[i] result.append(current_log) return result"},{"question":"def primeSum(M): Returns the sum of all prime numbers less than or equal to M. >>> primeSum(10) # 2 + 3 + 5 + 7 = 17 17 >>> primeSum(20) # 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 = 77 77 >>> primeSum(1) 0 >>> primeSum(2) 2 >>> primeSum(3) 5 >>> primeSum(100) # sum of primes less than or equal to 100 1060 >>> primeSum(0) 0 >>> primeSum(1000000) # sum of primes less than or equal to 1000000 37550402023 >>> primeSum(29) # sum of primes less than or equal to 29 129 >>> primeSum(100) # sum of primes less than or equal to 100 1060","solution":"def primeSum(M): Returns the sum of all prime numbers less than or equal to M. if M < 2: return 0 sieve = [True] * (M + 1) sieve[0], sieve[1] = False, False p = 2 while p * p <= M: if sieve[p]: for i in range(p * p, M + 1, p): sieve[i] = False p += 1 prime_sum = sum(i for i in range(M + 1) if sieve[i]) return prime_sum"},{"question":"def max_energy_consumption(M: int, N: int, floors: List[List[int]]) -> int: Given the energy consumption rates of rooms on each floor, returns the maximum energy consumption of any contiguous segment of rooms on any floor. >>> max_energy_consumption(2, 5, [[-2, 1, -3, 4, -1], [3, -2, 5, -3, 1]]) 6 >>> max_energy_consumption(1, 5, [[-2, 1, -3, 4, -1]]) 4 >>> max_energy_consumption(3, 3, [[-1, -2, -3], [4, 5, 6], [-1, 6, -3]]) 15 >>> max_energy_consumption(2, 3, [[3, -2, 1], [-1, -1, -1]]) 3 >>> max_energy_consumption(1, 1, [[5]]) 5 >>> max_energy_consumption(2, 5, [[4, -1, 2, 1, -5], [-2, 1, 3, -4, 2]]) 6","solution":"def max_energy_consumption(M, N, floors): Given the energy consumption rates of rooms on each floor, returns the maximum energy consumption of any contiguous segment of rooms on any floor. def max_subarray_sum(arr): Helper function to compute the maximum subarray sum using Kadane's algorithm. max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum max_energy = float('-inf') for floor in floors: max_energy = max(max_energy, max_subarray_sum(floor)) return max_energy"},{"question":"def final_sequence_value(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Bob and Alice are playing a game with a sequence of positive integers. Bob's goal is to reduce the sequence to a single element with the maximum possible value, while Alice's aim is to minimize the value of that final element. The game is played as follows: On his/her turn, a player selects a contiguous subarray of length exactly two and replaces it with a single element. The new element is the sum of the two selected elements. The game ends when only one element remains in the sequence. Bob always makes the first move, and both players play optimally. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): Test cases, each represented as a tuple with number of elements and the list of integers Returns: List[int]: Final value of the sequence after both players have played optimally for each test case >>> final_sequence_value(1, [(3, [1, 3, 2])]) [6] >>> final_sequence_value(1, [(4, [4, 2, 5, 1])]) [12] >>> final_sequence_value(1, [(5, [1, 2, 3, 4, 5])]) [15]","solution":"def final_sequence_value(t, test_cases): results = [] for case in test_cases: n = case[0] sequence = case[1] while len(sequence) > 1: max_sum = 0 best_index = 0 for i in range(len(sequence) - 1): current_sum = sequence[i] + sequence[i+1] if current_sum > max_sum: max_sum = current_sum best_index = i sequence = sequence[:best_index] + [max_sum] + sequence[best_index+2:] results.append(sequence[0]) return results"},{"question":"from typing import List, Tuple def add_event(existing_events: List[Tuple[int, int]], new_event: Tuple[int, int]) -> bool: Checks if a new event can be added to the calendar without overlapping existing events. Args: existing_events: List of tuples representing existing events' start and end times. new_event: A tuple representing the new event's start and end times. Returns: bool: True if the new event can be added without conflict, else False. >>> add_event([(1, 3), (4, 6), (8, 10)], (5, 7)) False >>> add_event([(1, 3), (4, 6), (8, 10)], (6, 8)) True >>> add_event([(1, 3), (4, 6), (8, 10)], (3, 4)) True >>> add_event([(1, 4)], (3, 5)) False >>> add_event([(4, 6)], (6, 8)) True >>> add_event([(1, 3), (4, 6)], (7, 24)) False >>> add_event([(21, 23)], (22, 24)) False >>> add_event([], (5, 7)) True >>> add_event([(0, 23)], (12, 14)) False","solution":"from typing import List, Tuple def add_event(existing_events: List[Tuple[int, int]], new_event: Tuple[int, int]) -> bool: Checks if a new event can be added to the calendar without overlapping existing events. Args: existing_events: List of tuples representing existing events' start and end times. new_event: A tuple representing the new event's start and end times. Returns: bool: True if the new event can be added without conflict, else False. new_start, new_end = new_event if not (0 <= new_start < new_end <= 23): return False for event in existing_events: start, end = event if not (new_end <= start or new_start >= end): return False return True"},{"question":"class MinStack: Design a stack data structure that supports the following operations: * push(x): Push the integer x onto the stack. * pop(): Remove the element on the top of the stack. * top(): Get the top element of the stack. * min(): Retrieve the minimum element in the stack. The implementation ensures that all operations run in O(1) time complexity. >>> stack = MinStack() >>> stack.push(3) >>> stack.push(5) >>> stack.min() 3 >>> stack.push(2) >>> stack.push(1) >>> stack.min() 1 >>> stack.pop() >>> stack.top() 2 >>> stack.min() 2 >>> stack.pop() >>> stack.pop() >>> stack.min() 3 >>> stack.pop() >>> stack.min() 'Stack is empty' >>> stack.top() 'Stack is empty' def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: pass def pop(self) -> None: pass def top(self): pass def min(self): pass # Unit Tests import pytest def test_stack_operations(): stack = MinStack() stack.push(3) stack.push(5) assert stack.min() == 3 stack.push(2) stack.push(1) assert stack.min() == 1 stack.pop() assert stack.top() == 2 assert stack.min() == 2 stack.pop() stack.pop() assert stack.min() == 3 stack.pop() assert stack.min() == \\"Stack is empty\\" assert stack.top() == \\"Stack is empty\\" def test_pop_on_empty_stack(): stack = MinStack() stack.pop() assert stack.top() == \\"Stack is empty\\" assert stack.min() == \\"Stack is empty\\" def test_top_on_empty_stack(): stack = MinStack() assert stack.top() == \\"Stack is empty\\" def test_min_on_empty_stack(): stack = MinStack() assert stack.min() == \\"Stack is empty\\"","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self): if self.stack: return self.stack[-1] else: return \\"Stack is empty\\" def min(self): if self.min_stack: return self.min_stack[-1] else: return \\"Stack is empty\\""},{"question":"def is_interleave(a: str, b: str, c: str) -> str: Checks if string C can be formed by interleaving strings A and B while preserving their orders. >>> is_interleave(\\"abc\\", \\"def\\", \\"adbecf\\") 'Yes' >>> is_interleave(\\"abc\\", \\"def\\", \\"abcdefg\\") 'No'","solution":"def is_interleave(a, b, c): Checks if string C can be formed by interleaving strings A and B while preserving their orders. m, n = len(a), len(b) if m + n != len(c): return \\"No\\" dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for i in range(m + 1): for j in range(n + 1): if i > 0 and dp[i - 1][j] and a[i - 1] == c[i + j - 1]: dp[i][j] = True if j > 0 and dp[i][j - 1] and b[j - 1] == c[i + j - 1]: dp[i][j] = True return \\"Yes\\" if dp[m][n] else \\"No\\""},{"question":"def balancingParentheses(s: str) -> bool: Determines if the parentheses in the given string are balanced. Args: s (str): A string containing only characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the parentheses are balanced, False otherwise. Examples: >>> balancingParentheses('({[]})') True >>> balancingParentheses('([)]') False >>> balancingParentheses('((([[[{{{') False >>> balancingParentheses(')))]}}]') False >>> balancingParentheses('') True >>> balancingParentheses('()') True >>> balancingParentheses('()[]{}') True >>> balancingParentheses('({[]})]') False >>> balancingParentheses('{[()]}') True","solution":"def balancingParentheses(s: str) -> bool: Determines if the parentheses in the given string are balanced. Args: s (str): A string containing only characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the parentheses are balanced, False otherwise. stack = [] matching = {')': '(', '}': '{', ']': '['} for char in s: if char in matching.values(): stack.append(char) elif char in matching.keys(): if stack == [] or matching[char] != stack.pop(): return False else: return False return stack == []"},{"question":"def max_energy_transfer(N, power_levels, edges): Calculate the maximum amount of energy that can be transferred from the root node to any other node in the tree. >>> max_energy_transfer(5, [10, 20, 30, 40, 50], [(1, 2, 5), (1, 3, 10), (2, 4, 2), (3, 5, 3)]) 40 >>> max_energy_transfer(4, [10, 20, 30, 40], [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) 40 >>> max_energy_transfer(3, [10, 5, 7], [(1, 2, 20), (1, 3, 30)]) 10 >>> max_energy_transfer(6, [10, 15, 20, 25, 30, 35], [(1, 2, 5), (1, 3, 2), (2, 4, 1), (2, 5, 3), (3, 6, 1)]) 35 >>> max_energy_transfer(2, [5, 10], [(1, 2, 1)]) 10","solution":"def max_energy_transfer(N, power_levels, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(root): max_energy = power_levels[root - 1] visited = [False] * (N + 1) queue = deque([(root, power_levels[root - 1])]) while queue: node, remaining_energy = queue.popleft() visited[node] = True for neighbor, weight in graph[node]: if not visited[neighbor]: new_energy = remaining_energy - weight if new_energy < 0: continue max_energy = max(max_energy, power_levels[neighbor - 1]) queue.append((neighbor, new_energy)) return max_energy return bfs(1)"},{"question":"from typing import List def isBalancedDistribution(gifts: List[int]) -> bool: Determine if a balanced gift distribution is possible :param gifts: A list of integers indicating the preferred gift type of each employee :return: True if balanced distribution is possible, otherwise False >>> isBalancedDistribution([0, 1, 2, 3]) True >>> isBalancedDistribution([1, 2, 2, 3]) False >>> isBalancedDistribution([0]) True >>> isBalancedDistribution([3, 0, 1, 2]) True >>> isBalancedDistribution([2, 2, 2, 2]) False >>> isBalancedDistribution(list(range(1000))) True >>> isBalancedDistribution(list(range(999)) + [0]) False","solution":"from typing import List def isBalancedDistribution(gifts: List[int]) -> bool: Determine if a balanced gift distribution is possible :param gifts: A list of integers indicating the preferred gift type of each employee :return: True if balanced distribution is possible, otherwise False return len(gifts) == len(set(gifts))"},{"question":"def evaluateExpression(S: str) -> int: Given a string representing a mathematical expression, evaluate the expression and return the result. The expression can contain positive integers, '+', '-', '*', '/', '(', and ')'. Division should truncate towards zero. >>> evaluateExpression(\\"3+2*2\\") == 7 >>> evaluateExpression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23","solution":"def evaluateExpression(S): def helper(s, idx): stack = [] num = 0 sign = '+' while idx < len(s): ch = s[idx] if ch.isdigit(): num = num * 10 + int(ch) if ch == '(': num, idx = helper(s, idx + 1) if (not ch.isdigit() and ch != ' ') or idx == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) sign = ch num = 0 if ch == ')': break idx+=1 return sum(stack), idx return helper(S.replace(' ', ''), 0)[0]"},{"question":"def maxUniqueSubsetLength(words): Find the length of the longest subset of words such that no two words in the subset share the same character. >>> maxUniqueSubsetLength([\\"abc\\", \\"def\\", \\"ghi\\"]) 3 >>> maxUniqueSubsetLength([\\"abc\\", \\"abd\\", \\"xyz\\"]) 2 >>> maxUniqueSubsetLength([\\"a\\", \\"b\\", \\"c\\", \\"a\\"]) 3","solution":"def maxUniqueSubsetLength(words): # Helper function to check if two words share any common characters def share_common_chars(word1, word2): return bool(set(word1) & set(word2)) n = len(words) # Generate all possible subsets of words def generate_subsets(index, current_set, current_size): if index == n: return current_size # Skip the current word without_current = generate_subsets(index + 1, current_set, current_size) # Include the current word if it doesn't share any characters with already included words can_include = True for word in current_set: if share_common_chars(word, words[index]): can_include = False break with_current = current_size if can_include: with_current = generate_subsets(index + 1, current_set + [words[index]], current_size + 1) return max(without_current, with_current) return generate_subsets(0, [], 0)"},{"question":"def can_accommodate_booking(n, m, bookings, new_booking): Determine if the new booking can be accommodated without conflicts for a specific property. :param n: Number of properties. :param m: Number of existing bookings. :param bookings: List of tuples representing existing bookings in the format (p, s, e). :param new_booking: A tuple representing the new booking request in the format (p, s, e). :return: \\"YES\\" if the new booking can be accommodated, otherwise \\"NO\\". Examples: >>> can_accommodate_booking(2, 3, [(1, 1, 5), (2, 6, 10), (2, 15, 20)], (2, 11, 14)) \\"YES\\" >>> can_accommodate_booking(3, 4, [(1, 1, 5), (1, 6, 10), (2, 1, 5), (3, 5, 8)], (1, 2, 4)) \\"NO\\"","solution":"def can_accommodate_booking(n, m, bookings, new_booking): Determine if the new booking can be accommodated without conflicts. :param n: Number of properties. :param m: Number of existing bookings. :param bookings: List of tuples representing existing bookings in the format (p, s, e). :param new_booking: A tuple representing the new booking request in the format (p, s, e). :return: \\"YES\\" if the new booking can be accommodated, otherwise \\"NO\\". property_bookings = {i: [] for i in range(1, n + 1)} # Populate the property_bookings dictionary with existing bookings for p, s, e in bookings: property_bookings[p].append((s, e)) p, s, e = new_booking # Check for time conflicts for the specific property for existing_start, existing_end in property_bookings[p]: if max(s, existing_start) < min(e, existing_end): return \\"NO\\" return \\"YES\\""},{"question":"def flipping_game(a): Implement a function flipping_game that takes a list \`a\` of positive integers and returns the maximum sum that can be obtained by flipping exactly one subarray of \`a\`. Flipping a subarray means changing all \`1\`s to \`-1\`s and all \`-1\`s to \`1\`s. >>> flipping_game([1, 1, 0, 0, 1, 0]) == 5 >>> flipping_game([1, 1, 1, 1]) == 0 >>> flipping_game([0, 0, 1, 0, 0]) == 4 >>> flipping_game([1, 0, 0, 0, 1]) == 5 pass","solution":"def flipping_game(a): n = len(a) # If the array contains only 1s, return 0 if all(x == 1 for x in a): return 0 # Convert 0 to 1 and 1 to -1 b = [1 if x == 0 else -1 for x in a] # Find the subarray with maximum sum in array \`b\` max_ending_here = max_so_far = b[0] for num in b[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) # The sum of the original array plus the maximum subarray sum in modified array max_sum_with_flip = sum(a) + max_so_far return max_sum_with_flip"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def node_depths(root): Computes the depth of each node in a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> node_depths(root) {1: 0, 2: 1, 3: 1, 4: 2, 5: 2, 6: 2}","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def node_depths(root): def dfs(node, depth, result): if node: result[node.val] = depth dfs(node.left, depth + 1, result) dfs(node.right, depth + 1, result) return result return dfs(root, 0, {})"},{"question":"def maximum_final_score(n: int, difficulties: List[int]) -> int: Calculates the maximum possible final score after any number of valid exchanges. Args: n (int): the number of levels in the game. difficulties (List[int]): the initial difficulty ratings of the levels. Returns: int: The maximum possible final score after valid exchanges. Examples: >>> maximum_final_score(5, [10, 20, 30, 40, 50]) 150 >>> maximum_final_score(3, [100, 10, 1]) 111 from typing import List def test_maximum_final_score_sample1(): assert maximum_final_score(5, [10, 20, 30, 40, 50]) == 150 def test_maximum_final_score_sample2(): assert maximum_final_score(3, [100, 10, 1]) == 111 def test_maximum_final_score_all_same(): assert maximum_final_score(4, [10, 10, 10, 10]) == 40 def test_maximum_final_score_non_consecutive_larger_values(): assert maximum_final_score(6, [7, 7, 1, 7, 7, 1]) == 30 def test_maximum_final_score_two_levels(): assert maximum_final_score(2, [5, 3]) == 8","solution":"def maximum_final_score(n, difficulties): Calculates the maximum possible final score after any number of valid exchanges. if n <= 2: return sum(difficulties) # Using a simple greedy approach, the maximum score is the sum of all levels # Sorting is not necessary just summing all elements in difficulties array return sum(difficulties)"},{"question":"def max_hourglass_sum(grid): Given a rectangular grid of numbers, find the largest hourglass sum in the grid. An hourglass sum is defined as the sum of the six numbers that form the hourglass pattern. a b c d e f g >>> max_hourglass_sum([ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ]) == 19 >>> max_hourglass_sum([ ... [-1, -1, -1, -1, -1, -1], ... [-1, -1, -1, -1, -1, -1], ... [-1, -1, -1, -1, -1, -1], ... [-1, -1, -1, -1, -1, -1], ... [-1, -1, -1, -1, -1, -1], ... [-1, -1, -1, -1, -1, -1] ... ]) == -7 >>> max_hourglass_sum([ ... [1, -1, 1, -1, 1, -1], ... [-1, 1, -1, 1, -1, 1], ... [1, -1, 1, -1, 1, -1], ... [-1, 1, -1, 1, -1, 1], ... [1, -1, 1, -1, 1, -1], ... [-1, 1, -1, 1, -1, 1] ... ]) == 3 >>> max_hourglass_sum([ ... [9, 9, 9, 9, 9, 9], ... [9, 9, 9, 9, 9, 9], ... [9, 9, 9, 9, 9, 9], ... [9, 9, 9, 9, 9, 9], ... [9, 9, 9, 9, 9, 9], ... [9, 9, 9, 9, 9, 9] ... ]) == 63","solution":"def max_hourglass_sum(grid): Returns the maximum hourglass sum in the given 2D grid. rows = len(grid) cols = len(grid[0]) max_sum = -float('inf') for i in range(rows - 2): for j in range(cols - 2): top = grid[i][j] + grid[i][j+1] + grid[i][j+2] mid = grid[i+1][j+1] bottom = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] hourglass_sum = top + mid + bottom if hourglass_sum > max_sum: max_sum = hourglass_sum return max_sum"},{"question":"from typing import List def shortestPath(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner in a maze. Each cell in the maze is either open (0) or blocked (1). You can move up, down, left, or right. Args: grid (List[List[int]]): A 2D list representing the maze. Returns: int: The length of the shortest path, or -1 if no path exists. Examples: >>> shortestPath([ ... [0, 0, 0], ... [1, 1, 0], ... [1, 1, 0] ... ]) == 4 >>> shortestPath([ ... [0, 1], ... [1, 0] ... ]) == -1 >>> shortestPath([[0]]) == 0 pass","solution":"from collections import deque from typing import List def shortestPath(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) if m == 1 and n == 1: return 0 if grid[0][0] == 0 else -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: if nx == m - 1 and ny == n - 1: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def solve(T: int, cases: List[str]) -> List[str]: For each test case, determine if it is possible to rearrange the string such that no two adjacent characters are the same. If it is possible, output any valid rearrangement. If not, output \\"NO\\". Args: T (int): The number of test cases. cases (List[str]): List of strings to check and rearrange. Returns: List[str]: List of rearranged strings or \\"NO\\" if rearrangement is not possible. >>> solve(3, [\\"aabb\\", \\"aaab\\", \\"ab\\"]) ['abab', 'NO', 'ab'] >>> solve(2, [\\"ccc\\", \\"a\\"]) ['NO', 'a'] >>> solve(1, [\\"aabbcc\\"]) ['abcabc'] >>> solve(1, [\\"aaaab\\"]) ['NO'] >>> solve(3, [\\"abab\\", \\"abccba\\", \\"xxyyzz\\"]) ['abab', 'abcabc', 'xyzxyz']","solution":"import heapq from collections import Counter def rearrange_string(s): freq_counter = Counter(s) max_heap = [(-freq, char) for char, freq in freq_counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged = ''.join(result) if len(rearranged) == len(s): return rearranged else: return \\"NO\\" def solve(T, cases): results = [] for case in cases: result = rearrange_string(case) results.append(result) return results"},{"question":"def countGoodNumbers(lst: List[int]) -> int: Given a list of integers, an integer is considered to be a \\"good number\\" if the sum of any non-empty subset of numbers in the list is not divisible by 3. Determine how many integers in the list qualify as \\"good numbers.\\" >>> countGoodNumbers([1, 2, 4, 5, 8]) 5 >>> countGoodNumbers([3, 6, 9, 12]) 0","solution":"def countGoodNumbers(lst): good_count = 0 for number in lst: if number % 3 != 0: good_count += 1 return good_count # Example usage: # lst = [1, 2, 4, 5, 8] # print(countGoodNumbers(lst)) # Output: 5"},{"question":"def reverseString(S: str) -> str: Return the characters in the string S in reverse order. >>> reverseString(\\"Geeks\\") 'skeeG' >>> reverseString(\\"Programming\\") 'gnimmargorP' >>> reverseString(\\"\\") '' >>> reverseString(\\"A\\") 'A' >>> reverseString(\\"racecar\\") 'racecar' >>> reverseString(\\"a\\" * 100000) 'a' * 100000 >>> reverseString(\\"abc123!@#\\") '#@!321cba'","solution":"def reverseString(S): Returns the string S in reverse order. return S[::-1]"},{"question":"def anagram(str1: str, str2: str) -> bool: Determines if two strings are anagrams. >>> anagram(\\"listen\\", \\"silent\\") True >>> anagram(\\"triangle\\", \\"integral\\") True >>> anagram(\\"apple\\", \\"pale\\") False","solution":"def anagram(str1, str2): Determines if two strings are anagrams. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. # Anagrams must be the same length if len(str1) != len(str2): return False # Sort the characters of both strings and compare return sorted(str1) == sorted(str2)"},{"question":"def min_magic_energy(n: int, positions: List[int]) -> int: Calculate the minimum magical energy required to visit all orbs. Args: n (int): The number of magical orbs. positions (list of int): The positions of the magical orbs on the line. Returns: int: The minimum magical energy required. Examples: >>> min_magic_energy(4, [1, 4, 7, 10]) 9 >>> min_magic_energy(3, [1, 5, 10]) 9 >>> min_magic_energy(2, [1, 100]) 99 >>> min_magic_energy(5, [1, 2, 3, 4, 5]) 4","solution":"from itertools import permutations def min_magic_energy(n, positions): Calculate the minimum magical energy required to visit all orbs. Args: n (int): The number of magical orbs. positions (list of int): The positions of the magical orbs on the line. Returns: int: The minimum magical energy required. min_energy = float('inf') for perm in permutations(positions): energy = sum(abs(perm[i] - perm[i+1]) for i in range(n-1)) min_energy = min(min_energy, energy) return min_energy"},{"question":"def cumulative_sum(lst): Takes a list of integers and returns a new list where each element is the sum of itself and all the previous elements in the original list. If the input is not a list of integers, returns \\"Invalid input\\". >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([1]) [1] >>> cumulative_sum([]) [] >>> cumulative_sum(\\"[1, 2, 3, 4]\\") \\"Invalid input\\" >>> cumulative_sum([1, '2', 3]) \\"Invalid input\\" >>> cumulative_sum([1, 3.5, 2]) \\"Invalid input\\" >>> cumulative_sum([1, None, 2]) \\"Invalid input\\"","solution":"def cumulative_sum(lst): Takes a list of integers and returns a new list where each element is the sum of itself and all the previous elements in the original list. If the input is not a list of integers, returns \\"Invalid input\\". if not all(isinstance(i, int) for i in lst): return \\"Invalid input\\" result = [] total = 0 for num in lst: total += num result.append(total) return result"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. If there are multiple substrings of the same maximum length, return the first one. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"abc\\") \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindromic_substring(\\"abccba\\") \\"abccba\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") \\"aba\\" >>> longest_palindromic_substring(\\"aaaaaaa\\") \\"aaaaaaa\\" >>> longest_palindromic_substring(\\"abcddcbaefg\\") \\"abcddcba\\"","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. If there are multiple substrings of the same maximum length, return the first one. n = len(s) if n <= 1: return s start, max_length = 0, 1 for i in range(n): if i - max_length >= 1 and s[i - max_length - 1: i + 1] == s[i - max_length - 1: i + 1][::-1]: start = i - max_length - 1 max_length += 2 elif i - max_length >= 0 and s[i - max_length: i + 1] == s[i - max_length: i + 1][::-1]: start = i - max_length max_length += 1 return s[start: start + max_length]"},{"question":"def determine_winner(n: int, array: List[int]) -> str: Determine if Rina can guarantee a win in the number game. Args: n (int): The number of elements in the array. array (List[int]): The array of integers. Returns: str: \\"Rina\\" if there is a way for Rina to guarantee a win, \\"Nami\\" otherwise. Examples: >>> determine_winner(3, [1, 2, 3]) 'Nami' >>> determine_winner(4, [1, 2, 3, 4]) 'Rina' >>> determine_winner(1, [10]) 'Rina' >>> determine_winner(5, [0, 0, 0, 0, 0]) 'Nami' >>> determine_winner(4, [7, 7, 7, 7]) 'Nami' >>> determine_winner(2, [1000000000, 1000000000]) 'Nami' >>> determine_winner(5, [1, 1, 2, 2, 3]) 'Rina'","solution":"def determine_winner(n, array): cumulative_xor = 0 for num in array: cumulative_xor ^= num # If the cumulative xor is not zero, Rina can guarantee a win return \\"Rina\\" if cumulative_xor != 0 else \\"Nami\\""},{"question":"def find_single_number(nums): Returns the single integer that appears only once in the list. >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([2, 2, 3, 2, 2]) 3","solution":"def find_single_number(nums): Returns the single integer that appears only once in the list. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"def longestPath(grid: List[List[str]]) -> int: You are given a rectangular grid with dimensions n x m, where each cell in the grid contains a single lowercase letter. You need to find the length of the longest path in the grid such that each cell in the path contains distinct letters. A cell in the grid can have edges connecting to its adjacent cells horizontally or vertically (not diagonally). >>> grid = [ ... [\\"a\\", \\"b\\", \\"c\\"], ... [\\"d\\", \\"e\\", \\"f\\"], ... [\\"g\\", \\"h\\", \\"i\\"] ... ] >>> longestPath(grid) == 9 >>> grid = [ ... [\\"a\\"] ... ] >>> longestPath(grid) == 1 >>> grid = [ ... [\\"a\\", \\"b\\"], ... [\\"c\\", \\"d\\"] ... ] >>> longestPath(grid) == 4 >>> grid = [ ... [\\"a\\", \\"a\\"], ... [\\"a\\", \\"a\\"] ... ] >>> longestPath(grid) == 1 >>> grid = [ ... [\\"a\\", \\"b\\"], ... [\\"b\\", \\"a\\"] ... ] >>> longestPath(grid) == 2 >>> grid = [ ... [\\"a\\", \\"b\\", \\"c\\", \\"d\\"], ... [\\"e\\", \\"f\\", \\"g\\", \\"h\\"], ... [\\"i\\", \\"j\\", \\"k\\", \\"l\\"], ... [\\"m\\", \\"n\\", \\"o\\", \\"p\\"] ... ] >>> longestPath(grid) == 16","solution":"def longestPath(grid): def dfs(x, y, visited): # If the cell is out of bounds or already visited, return 0 if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] in visited: return 0 # Mark this cell as visited visited.add(grid[x][y]) # Move to adjacent cells and calculate the longest path max_len = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: max_len = max(max_len, dfs(x + dx, y + dy, visited)) # Unmark this cell as visited for future exploration paths visited.remove(grid[x][y]) # Return the length of the longest path from this cell return 1 + max_len n = len(grid) m = len(grid[0]) max_path = 0 # Start DFS from each cell in the grid for i in range(n): for j in range(m): max_path = max(max_path, dfs(i, j, set())) return max_path"},{"question":"def string_multiplication(s: str, n: int) -> str: Calculate the string multiplication. >>> string_multiplication('hello', 3) 'hellohellohello' >>> string_multiplication('', 5) '' >>> string_multiplication('test', 0) '' >>> string_multiplication('repeat', 1) 'repeat' >>> string_multiplication('a', 1000) 'a' * 1000 >>> string_multiplication('!@#', 4) '!@#!@#!@#!@#'","solution":"def string_multiplication(s, n): Returns the string s repeated n times. return s * n"},{"question":"def min_operations_to_equalize_grid(grid): Calculate the minimum number of operations required to make all non-zero values in the grid equal. Args: grid (list of list of int): A 2D list representing the grid with initial values. Returns: int: Minimum number of operations required. Examples: >>> min_operations_to_equalize_grid([[1, 2, 3], [4, 0, 6], [1, 8, 1]]) 7 >>> min_operations_to_equalize_grid([[5, 5], [0, 5]]) 0 # Your implementation here def process_test_cases(T, cases): Process multiple test cases to find the minimum number of operations for each grid. Args: T (int): Number of test cases. cases (list of dict): A list where each dict represents a test case containing 'R', 'C', and 'grid'. Returns: list of int: A list of results where each result corresponds to a test case. Examples: >>> T = 2 >>> cases = [ >>> {'R': 3, 'C': 3, 'grid': [[1, 2, 3], [4, 0, 6], [1, 8, 1]]}, >>> {'R': 2, 'C': 2, 'grid': [[5, 5], [0, 5]]} >>> ] >>> process_test_cases(T, cases) [7, 0] # Your implementation here","solution":"def min_operations_to_equalize_grid(grid): # Flatten the grid and filter out the non-zero values non_zero_values = [val for row in grid for val in row if val != 0] # If the list of non-zero values is empty, return 0 since no operations are needed if not non_zero_values: return 0 # The minimum number of operations will be the difference between maximum and minimum min_val = min(non_zero_values) max_val = max(non_zero_values) return max_val - min_val def process_test_cases(T, cases): results = [] for case in cases: R, C, grid = case['R'], case['C'], case['grid'] result = min_operations_to_equalize_grid(grid) results.append(result) return results"},{"question":"def max_sum_possible(arr): Returns the maximum possible sum of elements of the array after performing the operations optimally. >>> max_sum_possible([1, 2, 3]) 6 >>> max_sum_possible([5, 3, 9, 1]) 18 def solve_case(n, arr): Solves a single test case. >>> solve_case(3, [1, 2, 3]) 6 >>> solve_case(4, [5, 3, 9, 1]) 18 def max_sum_of_elements(test_cases): Given a list of test cases, returns a list of maximum sums for each test case. >>> max_sum_of_elements([(3, [1, 2, 3]), (4, [5, 3, 9, 1])]) [6, 18] >>> max_sum_of_elements([(2, [1, 1]), (2, [1000, 1000])]) [2, 2000]","solution":"def max_sum_possible(arr): Returns the maximum possible sum of elements of the array after performing the operations optimally. return sum(arr) def solve_case(n, arr): Solves a single test case. return max_sum_possible(arr) def max_sum_of_elements(test_cases): results = [] for case in test_cases: n, arr = case results.append(solve_case(n, arr)) return results # Example usage: # test_cases = [ # (3, [1, 2, 3]), # (4, [5, 3, 9, 1]), # ] # print(max_sum_of_elements(test_cases))"},{"question":"from typing import List, Tuple def simulate_growth(initial_states: List[Tuple[int, float]], growth_rate: float, days: int) -> List[float]: Simulate the growth of plants over a specified number of days based on their initial states, water level, and growth rate. :param initial_states: A list of tuples containing the initial water level and height of each plant :param growth_rate: The daily growth rate per unit of water :param days: The number of days to simulate :return: A list of final heights of each plant >>> simulate_growth([(3, 10.0), (5, 15.0)], 2.0, 3) [28.0, 45.0] >>> simulate_growth([(2, 10.0)], 1.5, 1) [13.0] >>> simulate_growth([(4, 10.0)], 0.0, 5) [10.0] >>> simulate_growth([(3, 10.0)], 2.0, 0) [10.0] >>> simulate_growth([(1, 1.0), (2, 2.0), (3, 3.0)], 1.0, 3) [4.0, 8.0, 12.0]","solution":"from typing import List, Tuple def simulate_growth(initial_states: List[Tuple[int, float]], growth_rate: float, days: int) -> List[float]: Given the initial states of plants, growth rate, and number of days, return the final height of each plant. final_heights = [] for water_level, initial_height in initial_states: daily_growth = water_level * growth_rate final_height = initial_height + daily_growth * days final_heights.append(final_height) return final_heights"},{"question":"def process_queries(N, Q, array, queries): Process a list of queries on an array. Parameters: N (int): Length of the array. Q (int): Number of queries. array (list of int): Initial array of integers. queries (list of list): Each query to be processed. Returns: list: List of results for type-2 queries. Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [[0, 1, 3, 2], [1, 0, 3], [1, 2, 4]]) [16, 16] >>> process_queries(5, 2, [1, 2, 3, 4, 5], [[0, 0, 4, 1], [1, 0, 4]]) [20] # Your code here","solution":"def process_queries(N, Q, array, queries): Process a list of queries on an array. Parameters: N (int): Length of the array. Q (int): Number of queries. array (list of int): Initial array of integers. queries (list of list): Each query to be processed. Returns: list: List of results for type-2 queries. results = [] for query in queries: command = query[0] A = query[1] B = query[2] if command == 0: X = query[3] for i in range(A, B + 1): array[i] += X elif command == 1: results.append(sum(array[A:B + 1])) return results"},{"question":"def calculate_books_and_remainder(N: int) -> tuple: Given the amount of money N, calculates the number of books that can be bought and the remainder money. Parameters: N (int): Amount of money in dollars. Returns: tuple: A tuple containing the number of books that can be bought and the remainder money. Examples: >>> calculate_books_and_remainder(45) (3, 0) >>> calculate_books_and_remainder(37) (2, 7) >>> calculate_books_and_remainder(0) (0, 0)","solution":"def calculate_books_and_remainder(N): Given the amount of money N, calculates the number of books that can be bought and the remainder money. Parameters: N (int): Amount of money in dollars. Returns: tuple: A tuple containing the number of books that can be bought and the remainder money. cost_per_book = 15 num_books = N // cost_per_book remainder = N % cost_per_book return num_books, remainder"},{"question":"def nearest_larger_element(arr: List[int], target: int) -> int: Returns the nearest larger element on the right side of target in the list. If there is no larger element on the right, returns -1. If the target element is not in the array, returns -1. >>> nearest_larger_element([4, 1, 3, 5, 6], 3) 5 >>> nearest_larger_element([4, 1, 3, 5, 6], 6) -1 >>> nearest_larger_element([4, 1, 3, 5, 6], 2) -1","solution":"def nearest_larger_element(arr, target): Returns the nearest larger element on the right side of target in the list. If there is no larger element on the right, returns -1. If the target element is not in the array, returns -1. # Check if the target is in the array if target not in arr: return -1 # Find the index of the first occurrence of target target_index = arr.index(target) # Iterate over the array from the element right after target_index for i in range(target_index + 1, len(arr)): if arr[i] > target: return arr[i] # If no larger element is found return -1"},{"question":"from typing import List, Tuple def is_subsequence(smaller: List[int], larger: List[int]) -> bool: Determines if the list 'smaller' is a subsequence of the list 'larger'. Args: smaller (list of int): The smaller list where order of elements must be conserved. larger (list of int): The larger list which may contain the smaller list as a subsequence. Returns: bool: True if 'smaller' is a subsequence of 'larger', False otherwise. # Implement the function here def subsequence_checker(test_cases: List[Tuple[List[int], List[int]]]) -> List[str]: Processes multiple test cases to check if each smaller list is a subsequence of the corresponding larger list. Args: test_cases (list of tuple): List of tuples, where each tuple contains: (smaller, larger) - two lists of integers. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case. # Implement the function here # Example usage: if __name__ == \\"__main__\\": test_cases = [ ([1, 3, 5], [1, 2, 3, 4, 5]), # YES ([4, 6, 9], [4, 5, 6, 7, 8, 9]), # YES ([1, 2, 3], [1, 2]), # NO ([4], [1, 2, 3]), # NO ] results = subsequence_checker(test_cases) for result in results: print(result) def test_is_subsequence_positive(): assert is_subsequence([1, 3, 5], [1, 2, 3, 4, 5]) == True def test_is_subsequence_negative(): assert is_subsequence([4, 6, 9], [4, 5, 7, 8, 9]) == False def test_is_subsequence_single_element(): assert is_subsequence([4], [1, 2, 3, 4, 5]) == True assert is_subsequence([4], [1, 2, 3, 5, 6]) == False def test_is_subsequence_empty_smaller(): assert is_subsequence([], [1, 2, 3, 4, 5]) == True def test_subsequence_checker(): test_cases = [ ([1, 3, 5], [1, 2, 3, 4, 5]), # YES ([4, 6, 9], [4, 5, 6, 7, 8, 9]), # YES ([1, 2, 3], [1, 2]), # NO ([4], [1, 2, 3]), # NO ] results = subsequence_checker(test_cases) assert results == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_subsequence(smaller, larger): Determines if the list 'smaller' is a subsequence of the list 'larger'. Args: smaller (list of int): The smaller list where order of elements must be conserved. larger (list of int): The larger list which may contain the smaller list as a subsequence. Returns: bool: True if 'smaller' is a subsequence of 'larger', False otherwise. it = iter(larger) return all(x in it for x in smaller) def subsequence_checker(test_cases): Processes multiple test cases to check if each smaller list is a subsequence of the corresponding larger list. Args: test_cases (list of tuple): List of tuples, where each tuple contains: (smaller, larger) - two lists of integers. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case. results = [] for smaller, larger in test_cases: if is_subsequence(smaller, larger): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers, find two numbers such that they add up to a specific target number. Args: nums (List[int]): The list of integers. target (int): The target integer. Returns: List[int]: The indices of the two numbers that add up to the target or an empty list if no such pair exists. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3], 7) [] pass # Unit Tests def test_two_sum_example_1(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_two_sum_example_2(): assert two_sum([3, 2, 4], 6) == [1, 2] def test_two_sum_example_3(): assert two_sum([3, 3], 6) == [0, 1] def test_two_sum_no_solution(): assert two_sum([1, 2, 3], 7) == [] def test_two_sum_with_negative_numbers(): assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] def test_two_sum_mixed_sign_numbers(): assert two_sum([-10, 20, 10, -20], 0) == [0, 2] def test_two_sum_large_numbers(): assert two_sum([1, 3, 500000000, 700000000, -200000000], 300000000) == [2, 4] def test_two_sum_identical_elements(): assert two_sum([0, 4, 3, 0], 0) == [0, 3] def test_two_sum_first_and_last(): assert two_sum([5, 1, 2, 7, 11, -6], -1) == [0, 5]","solution":"def two_sum(nums, target): Finds two indices in the list nums such that their values add up to the target. :param nums: List of integers. :param target: The target integer to achieve by summing two integers from the list. :return: List with two indices. Empty list if no solution is found. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def hasTwoSum(arr, target): Checks if there are two distinct indices in arr such that arr[i] + arr[j] equals to target. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: bool: True if such indices exist, otherwise False. >>> hasTwoSum([1, 2, 3, 4], 5) True >>> hasTwoSum([1, 2, 3, 4], 8) False >>> hasTwoSum([-1, 0, 1, 2], 1) True","solution":"def hasTwoSum(arr, target): Checks if there are two distinct indices in arr such that arr[i] + arr[j] equals to target. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: bool: True if such indices exist, otherwise False. num_map = {} for i, num in enumerate(arr): complement = target - num if complement in num_map: return True num_map[num] = i return False"},{"question":"def calculate_minimum_cost(N: int, discount_tiers: List[Tuple[int, int]], M: int) -> int: Calculate the minimum cost to purchase M items given certain discount tiers. Parameters: N (int): Number of discount tiers discount_tiers (List[Tuple[int, int]]): List of tuples, where each tuple contains (Qi, Pi) M (int): Total number of items to purchase Returns: int: Minimum cost to purchase M items >>> calculate_minimum_cost(3, [(10, 50), (20, 40), (30, 35)], 25) 875 >>> calculate_minimum_cost(3, [(1, 100), (10, 90), (20, 80)], 15) 1350","solution":"def calculate_minimum_cost(N, discount_tiers, M): Calculate the minimum cost to purchase M items given certain discount tiers. :param N: Number of discount tiers :param discount_tiers: List of tuples, where each tuple contains (Qi, Pi) :param M: Total number of items to purchase :return: Minimum cost to purchase M items # Sort the discount tiers by quantity in descending order discount_tiers.sort(reverse=True, key=lambda x: x[0]) min_cost = float('inf') for Q, P in discount_tiers: if M >= Q: min_cost = min(min_cost, M * P) return min_cost"},{"question":"def max_sum_after_k_operations(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Find the maximum possible sum of the sequence after performing exactly K operations. >>> max_sum_after_k_operations(1, [((5, 2), [-1, 2, -3, 4, -5])]) [15] >>> max_sum_after_k_operations(1, [((5, 1), [1, 2, 3, 4, 5])]) [15] >>> max_sum_after_k_operations(1, [((5, 1), [-1, -2, -3, -4, -5])]) [15] >>> max_sum_after_k_operations(2, [((3, 1), [-1, -2, 3]), ((5, 3), [-5, -4, -3, -2, -1])]) [6, 15] >>> max_sum_after_k_operations(1, [((3, 0), [1, 2, 3])]) [6]","solution":"def max_sum_after_k_operations(T, test_cases): result = [] for i in range(T): N, K = test_cases[i][0] A = test_cases[i][1] abs_A = [abs(x) for x in A] result.append(sum(abs_A)) return result"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Find the length of the longest palindromic substring in the given string. :param s: input string consisting of lowercase English letters only :return: length of the longest palindromic substring >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"faceracecar\\") 7 >>> longest_palindromic_substring_length(\\"\\") 0 >>> longest_palindromic_substring_length(\\"abcd\\") 1 >>> longest_palindromic_substring_length(\\"aaaa\\") 4","solution":"def longest_palindromic_substring_length(s): Find the length of the longest palindromic substring in the given string. :param s: input string consisting of lowercase English letters only :return: length of the longest palindromic substring n = len(s) if n == 0: return 0 # Table to store results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True max_length = 1 start = 0 # Check for substrings of length 2 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 # Check for substrings of length 3 to n for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Checking for sub-string from ith index to jth index # iff s[i+1] to s[j-1] is a palindrome if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length"},{"question":"def is_match(text: str, pattern: str) -> str: Determines if the given text matches the pattern. The pattern may contain '*' (matching zero or more characters) and '.' (matching any single character). >>> is_match(\\"a*b.c\\", \\"aazbec\\") \\"true\\" >>> is_match(\\"mis*is*p*.\\", \\"mississippi\\") \\"false\\" from solution import is_match def test_exact_match(): assert is_match(\\"abcd\\", \\"abcd\\") == \\"true\\" def test_single_wildcard_match(): assert is_match(\\"abc\\", \\"a.c\\") == \\"true\\" def test_star_match_zero_characters(): assert is_match(\\"abc\\", \\"ab*.*\\") == \\"true\\" def test_star_match_multiple_characters(): assert is_match(\\"aaabbb\\", \\"a*b*\\") == \\"true\\" def test_mis_match(): assert is_match(\\"abcd\\", \\"ab*ce\\") == \\"false\\" def test_mixed_wildcards(): assert is_match(\\"aab\\", \\"c*a*b\\") == \\"true\\" def test_length_mismatch(): assert is_match(\\"mississippi\\", \\"mis*is*p*.\\") == \\"false\\"","solution":"def is_match(text, pattern): Determines if the given text matches the pattern. The pattern may contain '*' (matching zero or more characters) and '.' (matching any single character). def dfs(t_index, p_index): if p_index == len(pattern): return t_index == len(text) first_match = (t_index < len(text)) and (pattern[p_index] in {text[t_index], '.'}) if p_index + 1 < len(pattern) and pattern[p_index + 1] == '*': return (dfs(t_index, p_index + 2) or (first_match and dfs(t_index + 1, p_index))) else: return first_match and dfs(t_index + 1, p_index + 1) return \\"true\\" if dfs(0, 0) else \\"false\\""},{"question":"def max_product_of_three(nums: List[int]) -> int: Given a list of integers, find the maximum product that can be obtained from multiplying any three of the integers in the list. >>> max_product_of_three([1, 2, 3, 4]) == 24 >>> max_product_of_three([-10, -10, 5, 2]) == 500 >>> max_product_of_three([-5, -6, -3, -4]) == -60 >>> max_product_of_three([-1, -2, 1, 2, 3]) == 6 >>> max_product_of_three([1, 2, 3, 4, 5, 100]) == 2000 >>> max_product_of_three([0, 0, 0, 1, 2, 3]) == 6","solution":"import itertools def max_product_of_three(nums): nums.sort() # The maximum product of three numbers can be obtained in two cases: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers (both might be negative) and the largest number product1 = nums[-1] * nums[-2] * nums[-3] product2 = nums[0] * nums[1] * nums[-1] return max(product1, product2)"},{"question":"def can_construct_amount(n, coins, k): Determines if the exact amount of money \`k\` can be constructed using the given \`n\` coins. Parameters: n (int): The number of different types of coins. coins (list): The value of each coin. k (int): The target amount of money to construct. Returns: str: \\"YES\\" if the exact amount can be constructed, otherwise \\"NO\\". Examples: >>> can_construct_amount(3, [1, 2, 5], 11) \\"YES\\" >>> can_construct_amount(3, [2, 4, 6], 7) \\"NO\\" >>> can_construct_amount(5, [1, 3, 4, 5, 9], 23) \\"YES\\"","solution":"def can_construct_amount(n, coins, k): Determines if the exact amount of money \`k\` can be constructed using the given \`n\` coins. Parameters: n (int): The number of different types of coins. coins (list): The value of each coin. k (int): The target amount of money to construct. Returns: str: \\"YES\\" if the exact amount can be constructed, otherwise \\"NO\\". dp = [False] * (k + 1) dp[0] = True for coin in coins: for amount in range(coin, k + 1): if dp[amount - coin]: dp[amount] = True return \\"YES\\" if dp[k] else \\"NO\\""},{"question":"from fractions import Fraction from typing import List, Tuple def sum_of_fractions(fractions_list: List[Tuple[int, int]]) -> Fraction: Takes a list of tuples representing fractions and returns the sum of them in simplest form. >>> sum_of_fractions([(1, 2)]) == Fraction(1, 2) >>> sum_of_fractions([(1, 3), (2, 5)]) == Fraction(11, 15)","solution":"from fractions import Fraction def sum_of_fractions(fractions_list): Takes a list of tuples representing fractions and returns the sum of them in simplest form. Args: fractions_list (list): A list of tuples where each tuple contains two integers (numerator, denominator). Returns: Fraction: The sum of the fractions in simplest form. total_sum = sum(Fraction(numerator, denominator) for numerator, denominator in fractions_list) return total_sum def rational_sum(): n = int(input()) fractions_list = [] for _ in range(n): numerator, denominator = map(int, input().split()) fractions_list.append((numerator, denominator)) result = sum_of_fractions(fractions_list) print(result.numerator, result.denominator)"},{"question":"def check_polygons_overlap(n: int, polygons: List[List[Tuple[int, int]]]) -> str: Given the vertices of polygons, determine whether any two leaves overlap. >>> check_polygons_overlap(2, [[(0, 0), (4, 0), (4, 4), (0, 4)], [(5, 5), (9, 5), (9, 9), (5, 9)]]) == \\"no\\" >>> check_polygons_overlap(2, [[(0, 0), (2, 0), (2, 2), (0, 2)], [(1, 1), (3, 1), (2, 3)]]) == \\"yes\\" >>> check_polygons_overlap(2, [[(0, 0), (4, 0), (4, 4), (0, 4)], [(1, 1), (3, 1), (3, 3), (1, 3)]]) == \\"yes\\" >>> check_polygons_overlap(2, [[(0, 0), (2, 0), (2, 2), (0, 2)], [(3, 3), (5, 3), (5, 5), (3, 5)]]) == \\"no\\" pass","solution":"import matplotlib.path as mplPath import numpy as np def check_polygons_overlap(n, polygons): # Helper function to detect if two polygons overlap def polygons_overlap(polygon1, polygon2): poly1_path = mplPath.Path(np.array(polygon1)) poly2_path = mplPath.Path(np.array(polygon2)) for point in polygon2: if poly1_path.contains_point(point): return True for point in polygon1: if poly2_path.contains_point(point): return True return False # Iterate through all pairs of polygons and check for overlap for i in range(n): for j in range(i + 1, n): if polygons_overlap(polygons[i], polygons[j]): return \\"yes\\" return \\"no\\" def parse_input(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 polygons = [] for _ in range(n): k = int(data[index]) index += 1 polygon = [] for _ in range(k): x, y = int(data[index]), int(data[index+1]) index += 2 polygon.append((x, y)) polygons.append(polygon) return n, polygons if __name__ == \\"__main__\\": n, polygons = parse_input() print(check_polygons_overlap(n, polygons))"},{"question":"def evaluate_prefix(expression: str) -> int: Evaluates a prefix expression and returns the result as an integer. :param expression: str: The prefix expression :return: int: The result of the evaluated expression Examples: >>> evaluate_prefix(\\"+ 5 7\\") 12 >>> evaluate_prefix(\\"* 5 + 2 3\\") 25 >>> evaluate_prefix(\\"- / 10 + 1 1 * 1 2\\") 3","solution":"def evaluate_prefix(expression): Evaluates a prefix expression and returns the result as an integer. :param expression: str: The prefix expression :return: int: The result of the evaluated expression tokens = expression.split() stack = [] for token in reversed(tokens): if token.isdigit(): stack.append(int(token)) else: operand1 = stack.pop() operand2 = stack.pop() if token == '+': stack.append(operand1 + operand2) elif token == '-': stack.append(operand1 - operand2) elif token == '*': stack.append(operand1 * operand2) elif token == '/': stack.append(operand1 // operand2) return stack.pop()"},{"question":"def is_robot_back_to_origin(moves: str) -> bool: Determines if the robot returns to the origin after following the sequence of moves. Parameters: moves (str): A string containing the sequence of the robot's moves. Returns: bool: True if the robot returns to the origin, False otherwise. >>> is_robot_back_to_origin(\\"UD\\") True >>> is_robot_back_to_origin(\\"LL\\") False >>> is_robot_back_to_origin(\\"RRDD\\") False >>> is_robot_back_to_origin(\\"UDLR\\") True","solution":"def is_robot_back_to_origin(moves: str) -> bool: Determines if the robot returns to the origin after following the sequence of moves. Parameters: moves (str): A string containing the sequence of the robot's moves. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def reverse_strings(string_list): Takes a list of strings and returns a new list where each string is reversed. Parameters: string_list (list): A list of strings. Returns: list: A list where each string from the input list is reversed. Examples: >>> reverse_strings(['hello', 'world']) ['olleh', 'dlrow'] >>> reverse_strings(['Python', 'is', 'fun']) ['nohtyP', 'si', 'nuf'] >>> reverse_strings([]) []","solution":"def reverse_strings(string_list): Takes a list of strings and returns a new list where each string is reversed. Parameters: string_list (list): A list of strings. Returns: list: A list where each string from the input list is reversed. return [s[::-1] for s in string_list]"},{"question":"def is_path_exists(grid, N, S, D): Determine if there is a path from the starting intersection to the destination intersection in the given grid. pass def parse_input(input_string): Parse the input string and return results for each test case. pass def format_output(results): Format the results as specified in the output instructions. pass if __name__ == \\"__main__\\": input_string = 2 3 0 1 0 1 0 1 0 1 0 0 2 4 0 1 0 0 1 0 1 1 0 1 0 1 0 1 1 0 0 3 expected_output = \\"YESnYES\\" results = parse_input(input_string) output = format_output(results) assert output == expected_output print(\\"Sample test cases passed!\\") input_string = \\"2n2n0 0n0 0n0 1n2n1 0n0 0n1 0n1 0n\\" expected_output = \\"NOnNO\\" results = parse_input(input_string) output = format_output(results) assert output == expected_output print(\\"Additional test cases passed!\\")","solution":"def is_path_exists(grid, N, S, D): def dfs(node, visited): if node == D: return True visited.add(node) for neighbor in range(N): if grid[node][neighbor] and neighbor not in visited: if dfs(neighbor, visited): return True return False visited = set() return dfs(S, visited) def parse_input(input_string): data = input_string.strip().split(\\"n\\") current_line = 0 T = int(data[current_line]) current_line += 1 results = [] for _ in range(T): N = int(data[current_line]) current_line += 1 grid = [] for _ in range(N): grid.append(list(map(int, data[current_line].split()))) current_line += 1 S, D = map(int, data[current_line].split()) current_line += 1 results.append(is_path_exists(grid, N, S, D)) return results def format_output(results): return \\"n\\".join(\\"YES\\" if result else \\"NO\\" for result in results)"},{"question":"def rotate_array(A: List[int], K: int) -> List[int]: Rotate the array A to the right by K steps and return the resulting array. >>> rotate_array([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 8) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1], 2) [1] >>> rotate_array(list(range(1, 100001)), 100000) list(range(1, 100001))","solution":"def rotate_array(A, K): Rotates the array A to the right by K steps. n = len(A) K = K % n # to handle cases where K > n return A[-K:] + A[:-K]"},{"question":"def find_palindrome_pair(words): Returns two words from the input list that can be concatenated to form a palindrome, or an empty list if no such pair exists. >>> find_palindrome_pair([\\"code\\", \\"edoc\\", \\"da\\", \\"d\\"]) in [[\\"code\\", \\"edoc\\"], [\\"edoc\\", \\"code\\"]] True >>> find_palindrome_pair([\\"abc\\", \\"def\\", \\"ghi\\"]) [] >>> find_palindrome_pair([\\"a\\", \\"aa\\", \\"aaa\\"]) [] >>> find_palindrome_pair([\\"ab\\", \\"cd\\", \\"ef\\"]) [] >>> find_palindrome_pair([\\"ab\\", \\"ba\\", \\"cd\\", \\"dc\\"]) in [[\\"ab\\", \\"ba\\"], [\\"ba\\", \\"ab\\"], [\\"cd\\", \\"dc\\"], [\\"dc\\", \\"cd\\"]] True >>> find_palindrome_pair([\\"aaa\\", \\"aaa\\"]) []","solution":"def find_palindrome_pair(words): Returns two words from the input list that can be concatenated to form a palindrome, or an empty list if no such pair exists. word_set = set(words) for word in words: reversed_word = word[::-1] if reversed_word in word_set and reversed_word != word: return [word, reversed_word] return []"},{"question":"def first_triple_repetition(T: int, test_cases: List[tuple]) -> List[int]: For each test case, determine if any integer appears at least three times in a row. If such an integer exists, return the first integer that satisfies this condition. If no integer appears three times consecutively, return -1. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains N (int) and list of N integers. Returns: list: A list of integers representing the result for each test case. >>> first_triple_repetition(3, [(7, [1, 2, 2, 2, 3, 4, 4]), (6, [6, 6, 7, 8, 6, 6]), (5, [5, 5, 5, 5, 5])]) [2, -1, 5] >>> first_triple_repetition(2, [(4, [1, 1, 1, 1]), (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) [1, -1]","solution":"def first_triple_repetition(T, test_cases): For each test case, determine if any integer appears at least three times in a row. If such an integer exists, return the first integer that satisfies this condition. If no integer appears three times consecutively, return -1. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains N (int) and list of N integers. Returns: list: A list of integers representing the result for each test case. results = [] for case in test_cases: N, array = case for i in range(N - 2): if array[i] == array[i + 1] and array[i] == array[i + 2]: results.append(array[i]) break else: # this else corresponds to the \\"for\\" loop, not the \\"if\\" results.append(-1) return results"},{"question":"def coinChange(nums: List[int], amount: int) -> int: Given an integer array nums which represents the value of some coins and an integer amount representing the total amount of money, returns the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Examples: >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2], 3) -1","solution":"def coinChange(nums, amount): Returns the fewest number of coins needed to make up the given amount. If it is impossible to make up the amount, returns -1. # Create dp array of size amount+1 initialized with inf (or some large number). dp = [float('inf')] * (amount + 1) # Base case: we need 0 coins to make up the amount 0. dp[0] = 0 # Iterate over all amounts from 1 to amount for a in range(1, amount + 1): for coin in nums: if a - coin >= 0: dp[a] = min(dp[a], dp[a - coin] + 1) # If the dp[amount] is still inf, it means we cannot make up that amount return -1 if dp[amount] == float('inf') else dp[amount]"},{"question":"from typing import List def shortest_route(matrix: List[List[int]]) -> int: Calculate the shortest delivery route between cities based on the distance matrix provided. The function returns the length of the shortest route that visits each city exactly once and returns to the starting city. >>> shortest_route([[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> shortest_route([[0, 1], [1, 0]]) 2 >>> shortest_route([[0, 5, 10], [5, 0, 15], [10, 15, 0]]) 30 >>> shortest_route([[0]]) 0 >>> shortest_route([[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) 4","solution":"from itertools import permutations def shortest_route(matrix): n = len(matrix) perm = permutations(range(n)) min_route = float('inf') for p in perm: current_distance = 0 for i in range(len(p) - 1): current_distance += matrix[p[i]][p[i+1]] current_distance += matrix[p[-1]][p[0]] # Add the return to starting city distance min_route = min(min_route, current_distance) return min_route"},{"question":"def can_transform_by_deleting_one_char(s1: str, s2: str) -> str: Determines if s1 can be transformed into s2 by deleting exactly one character from s1. >>> can_transform_by_deleting_one_char(\\"example\\", \\"exmple\\") \\"YES\\" >>> can_transform_by_deleting_one_char(\\"test\\", \\"tte\\") \\"NO\\" >>> can_transform_by_deleting_one_char(\\"a\\", \\"\\") \\"YES\\" >>> can_transform_by_deleting_one_char(\\"ab\\", \\"\\") \\"NO\\" >>> can_transform_by_deleting_one_char(\\"hello\\", \\"helo\\") \\"YES\\" >>> can_transform_by_deleting_one_char(\\"abcde\\", \\"abde\\") \\"YES\\" >>> can_transform_by_deleting_one_char(\\"abcde\\", \\"bcde\\") \\"YES\\" >>> can_transform_by_deleting_one_char(\\"abcde\\", \\"abcd\\") \\"YES\\" >>> can_transform_by_deleting_one_char(\\"abcde\\", \\"abxcd\\") \\"NO\\" >>> can_transform_by_deleting_one_char(\\"abcd\\", \\"a\\") \\"NO\\"","solution":"def can_transform_by_deleting_one_char(s1, s2): Determines if s1 can be transformed into s2 by deleting exactly one character from s1. Parameters: s1 (str): The original string. s2 (str): The target string after deleting one character from s1. Returns: str: \\"YES\\" if s1 can be transformed into s2 in the specified way, \\"NO\\" otherwise. # s2 should be exactly one character shorter than s1 if len(s1) - len(s2) != 1: return \\"NO\\" # Try deleting each character from s1 and check if it matches s2 for i in range(len(s1)): if s1[:i] + s1[i+1:] == s2: return \\"YES\\" return \\"NO\\" # Example usage: # print(can_transform_by_deleting_one_char(\\"example\\", \\"exmple\\")) # Expected: \\"YES\\" # print(can_transform_by_deleting_one_char(\\"test\\", \\"tte\\")) # Expected: \\"NO\\""},{"question":"def construct_string(t: int, test_cases: List[int]) -> List[str]: Constructs strings of length n consisting only of characters 'a' and 'b', where the string does not contain two consecutive characters that are the same. >>> construct_string(3, [3, 4, 7]) ['aba', 'abab', 'abababa'] >>> construct_string(1, [1]) ['a'] >>> construct_string(1, [2]) ['ab'] >>> construct_string(2, [5, 6]) ['ababa', 'ababab'] pass","solution":"def construct_string(t, test_cases): Constructs strings of length n consisting only of characters 'a' and 'b', where the string does not contain two consecutive characters that are the same. results = [] for n in test_cases: s = [] for i in range(n): if i % 2 == 0: s.append('a') else: s.append('b') results.append(''.join(s)) return results # Example usage: # t = 3 # test_cases = [3, 4, 7] # print(construct_string(t, test_cases))"},{"question":"def process_activities(n, activities, q, queries): Process a series of user activities and queries to retrieve the most recent activity for a given user within a specified time window. Parameters: n (int): The number of user activities. activities (List[Tuple[int, int, int]]): A list of activities where each activity is represented by a tuple (timestamp, user ID, activity ID). q (int): The number of queries. queries (List[Tuple[int, int, int]]): A list of queries where each query is represented by a tuple (user ID, start timestamp, end timestamp). Returns: List[int]: A list of activity IDs corresponding to the most recent activity for each query, or -1 if no activity is found in the specified time window. Examples: >>> process_activities(5, [(1, 1, 101), (3, 1, 102), (6, 2, 201), (8, 1, 103), (10, 2, 202)], 3, [(1, 1, 5), (2, 5, 10), (1, 5, 10)]) [102, 202, 103] >>> process_activities(2, [(1, 1, 101), (3, 1, 102)], 1, [(1, 4, 5)]) [-1] >>> process_activities(2, [(1, 1, 101), (3, 1, 102)], 1, [(2, 1, 5)]) [-1] # Example of unit tests def test_process_activities(): n = 5 q = 3 activities = [ (1, 1, 101), (3, 1, 102), (6, 2, 201), (8, 1, 103), (10, 2, 202) ] queries = [ (1, 1, 5), (2, 5, 10), (1, 5, 10) ] expected_output = [102, 202, 103] assert process_activities(n, activities, q, queries) == expected_output def test_process_activities_single_activity(): n = 1 q = 1 activities = [ (1, 1, 101) ] queries = [ (1, 1, 5) ] expected_output = [101] assert process_activities(n, activities, q, queries) == expected_output def test_process_activities_no_activities_in_range(): n = 2 q = 1 activities = [ (1, 1, 101), (3, 1, 102) ] queries = [ (1, 4, 5) ] expected_output = [-1] assert process_activities(n, activities, q, queries) == expected_output def test_process_activities_no_activities_for_user(): n = 2 q = 1 activities = [ (1, 1, 101), (3, 1, 102) ] queries = [ (2, 1, 5) ] expected_output = [-1] assert process_activities(n, activities, q, queries) == expected_output def test_process_activities_multiple_users(): n = 6 q = 2 activities = [ (1, 1, 101), (2, 2, 201), (3, 1, 102), (4, 2, 202), (5, 1, 103), (6, 2, 203) ] queries = [ (1, 1, 4), (2, 3, 6) ] expected_output = [102, 203] assert process_activities(n, activities, q, queries) == expected_output","solution":"from collections import defaultdict import bisect def process_activities(n, activities, q, queries): # User activities sorted by timestamp for each user user_activities = defaultdict(list) # Store activities in the dictionary for t, u, a in activities: user_activities[u].append((t, a)) # Sort the activities based on timestamp for each user for user in user_activities: user_activities[user].sort() results = [] # Process each query for u, t1, t2 in queries: if u in user_activities: # Get list of timestamps for the user and binary search the start and end times timestamps = [activity[0] for activity in user_activities[u]] # Find the position where t1 can be inserted to keep sorted order (left insertion) start_index = bisect.bisect_left(timestamps, t1) # Find the position where t2 can be inserted to keep sorted order (right insertion) end_index = bisect.bisect_right(timestamps, t2) if start_index < end_index: # The most recent activity within the time window recent_activity = user_activities[u][end_index-1][1] results.append(recent_activity) else: results.append(-1) else: results.append(-1) return results"},{"question":"from typing import List, Tuple def smallest_lexicographical_substring(s: str) -> Tuple[str, int]: Determine the longest substring of a given string which is lexicographically smallest and all characters of this substring are the same. >>> smallest_lexicographical_substring(\\"aaabbbcc\\") (\\"a\\", 3) >>> smallest_lexicographical_substring(\\"abcabcabc\\") (\\"a\\", 1) >>> smallest_lexicographical_substring(\\"zzzabc\\") (\\"a\\", 1) >>> smallest_lexicographical_substring(\\"aaaa\\") (\\"a\\", 4) >>> smallest_lexicographical_substring(\\"bbbaaa\\") (\\"a\\", 3) pass def process_cases(input_data: List[str]) -> List[Tuple[str, int]]: Process multiple test cases to find the smallest lexicographical substring for each. >>> process_cases([\\"3\\", \\"aaabbbcc\\", \\"abcabcabc\\", \\"zzzabc\\"]) [(\\"a\\", 3), (\\"a\\", 1), (\\"a\\", 1)] >>> process_cases([\\"2\\", \\"bbbb\\", \\"cdc\\"]) [(\\"b\\", 4), (\\"c\\", 1)] pass","solution":"def smallest_lexicographical_substring(s): n = len(s) if n == 0: return \\"\\", 0 min_char = min(s) max_len = 0 current_char = None current_len = 0 min_substring_char = '' min_substring_len = 0 for char in s: if char == current_char: current_len += 1 else: if current_char == min_char: if current_len > max_len: max_len = current_len min_substring_char = current_char min_substring_len = current_len current_char = char current_len = 1 if current_char == min_char: if current_len > max_len: max_len = current_len min_substring_char = current_char min_substring_len = current_len if min_substring_char == \\"\\": min_substring_char = min_char min_substring_len = 1 return min_substring_char, min_substring_len def process_cases(input_data): t = int(input_data[0]) results = [] for i in range(1, t + 1): s = input_data[i] substring_char, substring_len = smallest_lexicographical_substring(s) results.append((substring_char, substring_len)) return results"},{"question":"from typing import List, Tuple def count_paths(n: int, m: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Alice has a directed acyclic graph (DAG) G consisting of n vertices and m edges, where each vertex is uniquely labeled from 1 to n. She wants to count the number of distinct paths from vertex u to vertex v for q different pairs of vertices. Given G and q query pairs, each consisting of vertices u and v, this function counts the distinct paths from u to v for each query pair. Args: n: int - the number of vertices in G m: int - the number of edges in G edges: List of tuples (a, b) - list of directed edges in the graph where a is the start vertex and b is the end vertex queries: List of tuples (u, v) - list of query pairs where we count the number of distinct paths from u to v Returns: List[int] - list of counts of distinct paths for each query pair Examples: >>> count_paths(4, 4, [(1,2), (2,3), (1,3), (3,4)], [(1,3), (2,4), (1,4), (4,1)]) [2, 1, 2, 0] >>> count_paths(3, 2, [(1,2), (2,3)], [(1,3), (1,2), (2,3), (3,1)]) [1, 1, 1, 0]","solution":"from collections import defaultdict, deque def count_paths(n, m, edges, queries): # Build the graph and initialize indegree array graph = defaultdict(list) indeg = [0] * (n + 1) for a, b in edges: graph[a].append(b) indeg[b] += 1 # Topological sorting using Kahn's algorithm topo_sort = [] q = deque([i for i in range(1, n + 1) if indeg[i] == 0]) while q: node = q.popleft() topo_sort.append(node) for neighbor in graph[node]: indeg[neighbor] -= 1 if indeg[neighbor] == 0: q.append(neighbor) # DP array to store number of distinct paths dp = [[0] * (n + 1) for _ in range(n + 1)] # There is exactly one path from each vertex to itself for i in range(1, n + 1): dp[i][i] = 1 # Process nodes in topological order for u in topo_sort: for v in graph[u]: for i in range(1, n + 1): dp[i][v] += dp[i][u] result = [] for u, v in queries: result.append(dp[u][v]) return result"},{"question":"def shortest_subsequence_length(s: str, t: str) -> int: Returns the length of the shortest subsequence of \`s\` that contains all characters of \`t\` in order. If it is impossible, returns -1. >>> shortest_subsequence_length(\\"abcde\\", \\"ace\\") == 5 >>> shortest_subsequence_length(\\"abcde\\", \\"aef\\") == -1 >>> shortest_subsequence_length(\\"abppplee\\", \\"apple\\") == 6","solution":"def shortest_subsequence_length(s, t): Returns the length of the shortest subsequence of \`s\` that contains all characters of \`t\` in order. If it is impossible, returns -1. m, n = len(s), len(t) dp = [[float('inf')] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 0 for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + 1) else: dp[i][j] = dp[i - 1][j] + 1 result = dp[m][n] return result if result != float('inf') else -1"},{"question":"from typing import List, Tuple def unique_paths(n: int, m: int, b: int, black_holes: List[Tuple[int, int]]) -> int: Returns the number of unique paths from (1, 1) to (n, m) avoiding all black holes. Parameters: - n (int): Number of rows. - m (int): Number of columns. - b (int): Number of black holes. - black_holes (list of tuple): List of (x, y) positions of black holes. Returns: - int: Total number of unique paths. >>> unique_paths(3, 3, 1, [(2, 2)]) 2 >>> unique_paths(4, 4, 2, [(2, 2), (3, 3)]) 4","solution":"def unique_paths(n, m, b, black_holes): Returns the number of unique paths from (1, 1) to (n, m) avoiding all black holes. Parameters: - n (int): Number of rows. - m (int): Number of columns. - b (int): Number of black holes. - black_holes (list of tuple): List of (x, y) positions of black holes. Returns: - int: Total number of unique paths. # Initialize the grid with zeros grid = [[0] * m for _ in range(n)] # Set the starting point grid[0][0] = 1 # Mark black holes in the grid for x, y in black_holes: grid[x-1][y-1] = -1 # Adjusting to 0-based index # Calculate number of paths for i in range(n): for j in range(m): if grid[i][j] == -1: # If it's a black hole, do nothing continue # If not in the first row, add paths from the cell above if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] # If not in the first column, add paths from the cell on the left if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] # If the destination is a black hole, there are 0 ways to reach it if grid[n-1][m-1] == -1: return 0 return grid[n-1][m-1]"},{"question":"def furthest_building(heights: List[int], bricks: int, ladders: int) -> int: Given an array of integers representing building heights, along with the number of bricks and ladders, find the furthest building that can be reached by using the given resources. >>> furthest_building([4,2,7,6,9,14,12], 5, 1) 4 >>> furthest_building([4,12,2,7,3,18,20,3,19], 10, 2) 7 >>> furthest_building([14,3,19,3], 17, 0) 3 } Example: 1. heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 2. heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 3. heights = [14,3,19,3], bricks = 17, ladders = 0 Constraints: - 1 <= heights.length <= 10^5 - 1 <= heights[i] <= 10^6 - 0 <= bricks <= 10^9 - 0 <= ladders <= heights.length","solution":"import heapq def furthest_building(heights, bricks, ladders): heap = [] # min-heap to store the largest jumps for usage of ladders for i in range(len(heights) - 1): gap = heights[i + 1] - heights[i] if gap > 0: heapq.heappush(heap, gap) # If the number of ladders is smaller than the number of gaps if len(heap) > ladders: bricks -= heapq.heappop(heap) # If we run out of bricks if bricks < 0: return i return len(heights) - 1"},{"question":"def max_boxes_on_conveyor(num_cases, test_cases): Returns the maximum number of boxes that can be placed on the conveyor belt without exceeding the weight limit. Parameters: num_cases (int): Number of test cases test_cases (list): A list of tuples, each containing the number of boxes, a list of box weights, and the weight limit W Returns: list: A list of integers indicating the maximum number of boxes for each test case pass def test_max_boxes_on_conveyor(): assert max_boxes_on_conveyor(2, [(5, [1, 2, 3, 4, 5], 10), (4, [7, 4, 1, 8], 10)]) == [4, 2] assert max_boxes_on_conveyor(1, [(3, [5, 6, 7], 10)]) == [1] assert max_boxes_on_conveyor(1, [(3, [3, 3, 3], 10)]) == [3] assert max_boxes_on_conveyor(1, [(5, [1, 1, 1, 1, 1], 3)]) == [3] assert max_boxes_on_conveyor(1, [(1, [1000], 999)]) == [0]","solution":"def max_boxes_on_conveyor(num_cases, test_cases): Returns the maximum number of boxes that can be placed on the conveyor belt without exceeding the weight limit. Parameters: num_cases (int): Number of test cases test_cases (list): A list of tuples, each containing the number of boxes, a list of box weights, and the weight limit W Returns: list: A list of integers indicating the maximum number of boxes for each test case results = [] for i in range(num_cases): N, weights, W = test_cases[i] weights.sort() count = 0 total_weight = 0 for weight in weights: if total_weight + weight <= W: total_weight += weight count += 1 else: break results.append(count) return results"},{"question":"def sum_of_unique_elements(test_cases): Given an array of integers, find the sum of all unique elements in the array. An element is considered unique if it appears exactly once in the array. Args: test_cases: List of tuples containing (N, elements), where N is the number of elements and elements is the array. Returns: List of integers, where each integer is the sum of unique elements for the respective test case. Example: >>> sum_of_unique_elements([(5, [1, 2, 2, 3, 4]), (6, [5, 5, 5, 6, 6, 7])]) [8, 7] pass def handle_input_output(input_data): Handles parsing the input and returning results. Args: input_data: A string containing multiple test cases. Example: >>> input_data = \\"2n5n1 2 2 3 4n6n5 5 5 6 6 7n\\" >>> handle_input_output(input_data) 8 7 pass","solution":"def sum_of_unique_elements(test_cases): results = [] for case in test_cases: n, elements = case element_counts = {} for element in elements: if element in element_counts: element_counts[element] += 1 else: element_counts[element] = 1 unique_sum = sum(element for element, count in element_counts.items() if count == 1) results.append(unique_sum) return results # Function to handle parsing the input and returning results def handle_input_output(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) elements = list(map(int, lines[index + 1].split())) test_cases.append((N, elements)) index += 2 results = sum_of_unique_elements(test_cases) for result in results: print(result)"},{"question":"def CanPlaceBooks(N, W, L): Determine if it's possible to place all books on the shelf without exceeding the limit. Args: - N (int): Number of books. - W (list of int): Widths of the books. - L (int): Limit of the shelf width. Returns: - str: 'YES' if all books can be placed on the shelf within the limit, else 'NO'. pass def test_CanPlaceBooks(): # Example 1 assert CanPlaceBooks(4, [2, 3, 5, 7], 15) == \\"NO\\" # Example 2 assert CanPlaceBooks(3, [4, 6, 9], 15) == \\"NO\\" # Case where books match exactly the limit assert CanPlaceBooks(3, [5, 5, 5], 15) == \\"YES\\" # Case with single book assert CanPlaceBooks(1, [10], 15) == \\"YES\\" assert CanPlaceBooks(1, [20], 15) == \\"NO\\" # Case with empty shelf assert CanPlaceBooks(0, [], 15) == \\"YES\\" # Case with large number of books and large limit assert CanPlaceBooks(3, [10**9, 10**9, 10**9], 3*10**9) == \\"YES\\" assert CanPlaceBooks(3, [10**9, 10**9, 10**9], 2*10**9) == \\"NO\\"","solution":"def CanPlaceBooks(N, W, L): Determine if it's possible to place all books on the shelf without exceeding the limit. Args: - N (int): Number of books. - W (list of int): Widths of the books. - L (int): Limit of the shelf width. Returns: - str: 'YES' if all books can be placed on the shelf within the limit, else 'NO'. total_width = sum(W) if total_width <= L: return \\"YES\\" else: return \\"NO\\""},{"question":"def largest_k(N: int) -> int: Returns the largest integer k such that k^2 is less than or equal to N. >>> largest_k(15) == 3 >>> largest_k(1) == 1 >>> largest_k(1000000000) == 31622 >>> largest_k(16) == 4 >>> largest_k(999) == 31","solution":"def largest_k(N): Returns the largest integer k such that k^2 is less than or equal to N. k = 1 while k * k <= N: k += 1 return k - 1"},{"question":"def sum_of_minimums(matrix: List[List[int]]) -> int: Returns the sum of the minimum values in each row of the given 2D list (matrix). >>> sum_of_minimums([[7, 9, 8, 6], [6, 3, 5, 2], [5, 8, 1, 4]]) 9 >>> sum_of_minimums([[20, 15, 30], [3, 8, 6], [2, 5, 7]]) 20","solution":"def sum_of_minimums(matrix): Returns the sum of the minimum values in each row of the given 2D list (matrix). return sum(min(row) for row in matrix)"},{"question":"import heapq from typing import List def min_time_to_process(S: int, T: int, processing_times: List[int]) -> int: Computes the minimum total processing time required to process all tasks. >>> min_time_to_process(2, 4, [3, 1, 4, 2]) 5 >>> min_time_to_process(3, 5, [8, 4, 5, 3, 6]) 9 pass","solution":"import heapq def min_time_to_process(S, T, processing_times): Computes the minimum total processing time required to process all tasks. if S >= T: return max(processing_times) servers = [0] * S heapq.heapify(servers) for time in sorted(processing_times, reverse=True): least_busy_server = heapq.heappop(servers) heapq.heappush(servers, least_busy_server + time) return max(servers)"},{"question":"import math from typing import List, Tuple def max_distance(n: int, coordinates: List[Tuple[int, int]]) -> float: Returns the maximum Euclidean distance between two consecutive points in the given list of coordinates. The result is rounded to six decimal places. >>> max_distance(5, [(0, 0), (1, 1), (2, 3), (4, 4), (5, 6)]) 2.236068 >>> max_distance(2, [(0, 0), (3, 4)]) 5.000000 >>> max_distance(3, [(1, 1), (1, 1), (1, 1)]) 0.000000 >>> max_distance(2, [(0, 0), (1000000000, 1000000000)]) 1414213562.373095 >>> max_distance(4, [(0, 0), (3, 4), (5, 10), (15, 10)]) 10.000000","solution":"import math def max_distance(n, coordinates): Returns the maximum Euclidean distance between two consecutive points in the given list of coordinates. The result is rounded to six decimal places. max_dist = 0 for i in range(1, n): x1, y1 = coordinates[i - 1] x2, y2 = coordinates[i] distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) if distance > max_dist: max_dist = distance return round(max_dist, 6)"},{"question":"def can_make_all_elements_distinct(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to make all elements in the array distinct after performing some operations. Input: test_cases: A list of tuples, where each tuple contains an integer N followed by a list of N integers. Output: A list of strings, where each string is either 'YES' or 'NO', indicating whether it is possible to make all elements distinct. Examples: >>> can_make_all_elements_distinct([(4, [1, 2, 2, 3]), (5, [1, 1, 1, 1, 1]), (6, [6, 5, 4, 3, 2, 1])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_make_all_elements_distinct([(3, [1, 2, 3]), (4, [4, 3, 2, 1])]) [\\"YES\\", \\"YES\\"] >>> can_make_all_elements_distinct([(5, [5, 5, 5, 5, 5]), (3, [3, 3, 3])]) [\\"YES\\", \\"YES\\"] >>> can_make_all_elements_distinct([(3, [1, 1, 1, 2, 2, 2])]) [\\"NO\\"] >>> can_make_all_elements_distinct([(1, [1]), (2, [1, 2]), (2, [1, 1])]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_make_all_elements_distinct(test_cases): results = [] for case in test_cases: N, arr = case if len(arr) == len(set(arr)): results.append(\\"YES\\") else: elements_count = [0] * (N + 1) for num in arr: if num <= N: elements_count[num] += 1 # Count duplicates duplicates = sum(x - 1 for x in elements_count if x > 1) # Number of possible replacements is the number of unique elements that we can use (1 to N) possible_replacements = N - len(set(arr)) if duplicates <= possible_replacements: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import heapq from typing import List, Tuple def shortestRunTime(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Returns the shortest time for Ravi to reach the destination intersection from the starting intersection using Dijkstra's algorithm. >>> shortestRunTime(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)], 1, 5) 6 >>> shortestRunTime(4, 4, [(1, 2, 3), (1, 3, 1), (3, 4, 2), (2, 4, 5)], 1, 4) 3","solution":"import heapq def shortestRunTime(n, m, edges, start, end): Returns the shortest time for Ravi to reach the destination intersection from the starting intersection using Dijkstra's algorithm. # Create adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm heap = [(0, start)] # (distance, node) distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return distances[end]"},{"question":"def is_mirror_message(message: str) -> str: Returns 'YES' if the message is a mirror message, otherwise 'NO'. >>> is_mirror_message('madam') 'YES' >>> is_mirror_message('hello') 'NO' >>> is_mirror_message('racecar') 'YES' >>> is_mirror_message('abcba') 'YES' >>> is_mirror_message('software') 'NO' def check_mirror_messages(messages: List[str]) -> List[str]: Takes a list of messages and returns a list with 'YES' or 'NO' for each message depending on whether the message is a mirror message. >>> check_mirror_messages(['madam', 'hello', 'racecar', 'abcba', 'software']) ['YES', 'NO', 'YES', 'YES', 'NO'] >>> check_mirror_messages(['a', 'aa', 'aba', 'racecar', 'madamimadam']) ['YES', 'YES', 'YES', 'YES', 'YES'] >>> check_mirror_messages(['abc', 'alphabet', 'software', 'palindrome', 'python']) ['NO', 'NO', 'NO', 'NO', 'NO'] >>>","solution":"def is_mirror_message(message): Returns 'YES' if the message is a mirror message, otherwise 'NO'. return 'YES' if message == message[::-1] else 'NO' def check_mirror_messages(messages): Takes a list of messages and returns a list with 'YES' or 'NO' for each message depending on whether the message is a mirror message. result = [] for message in messages: result.append(is_mirror_message(message)) return result"},{"question":"def find_max_c(m: int, n: int) -> int: Finds the maximum c such that P(m + i) is equal to P(c + i) for all i in 0 to n-1. >>> find_max_c(123, 3) 223 >>> find_max_c(456, 4) 556 >>> find_max_c(1, 1) 101 >>> find_max_c(789, 5) 889 >>> find_max_c(1000000000, 1) 1000000100","solution":"def find_max_c(m, n): Finds the maximum c such that P(m + i) is equal to P(c + i) for all i in 0 to n-1. return m + 100"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression in infix notation and returns the result as an integer. The expression includes positive integers and the operators +, -, *, and / (integer division). >>> evaluate_expression(\\"3+2\\") 5 >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"3*3\\") 9 >>> evaluate_expression(\\"2+3*4-5/2\\") 12 >>> evaluate_expression(\\" 3 + 2 * 2 \\") 7 >>> evaluate_expression(\\"3+2*2\\") 7","solution":"def evaluate_expression(expression): Evaluates a mathematical expression in infix notation and returns the result as an integer. The expression includes positive integers and the operators +, -, *, and / (integer division). def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # Ensure integer division def precedence(op): if op in ('+', '-'): return 1 elif op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] in '0123456789': val = 0 while i < len(expression) and expression[i] in '0123456789': val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] in \\"+-*/\\": while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def max_boxes(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of boxes that can be perfectly packed with candies without exceeding the 1 kg limit. Args: T: An integer representing the number of test cases. test_cases: A list of tuples where each tuple contains an integer n (number of candy pieces) and a list of n integers representing the weights of the candies in grams. Returns: A list of integers, where each integer represents the maximum number of boxes that can be perfectly packed for the corresponding test case. Example: >>> max_boxes(2, [(5, [300, 500, 200, 700, 100]), (4, [400, 400, 300, 200])]) [3, 2] >>> max_boxes(1, [(6, [1000, 1000, 1000, 1000, 1000, 1000])]) [6]","solution":"def max_boxes(T, test_cases): results = [] for case in test_cases: n, weights = case weights.sort(reverse=True) boxes = 0 current_weight = 0 for weight in weights: if current_weight + weight <= 1000: current_weight += weight else: boxes += 1 current_weight = weight if current_weight > 0: boxes += 1 results.append(boxes) return results"},{"question":"def max_boxes_on_conveyor(max_capacity: int, boxes: List[Tuple[int, int]]) -> int: Given the max capacity of the conveyor belt and a list of boxes with their sizes, return the maximum number of boxes that can be placed on the belt without exceeding the capacity. Parameters: max_capacity (int): Maximum capacity of the conveyor belt boxes (List[Tuple[int, int]]): List of tuples where each tuple contains an identifier and a size Returns: int: Maximum number of boxes that can be placed on the conveyor belt Examples: >>> max_boxes_on_conveyor(10, [(1, 3), (2, 4), (3, 2), (4, 5)]) 3 >>> max_boxes_on_conveyor(15, [(10, 5), (11, 8), (12, 6), (13, 3), (14, 2)]) 3 >>> max_boxes_on_conveyor(10, []) 0 >>> max_boxes_on_conveyor(10, [(1, 11), (2, 12), (3, 13)]) 0 >>> max_boxes_on_conveyor(10, [(1, 10)]) 1 >>> max_boxes_on_conveyor(10, [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)]) 5 >>> max_boxes_on_conveyor(1000, [(i, 1) for i in range(2000)]) 1000 pass # Your implementation here","solution":"def max_boxes_on_conveyor(max_capacity, boxes): Given the max capacity of the conveyor belt and a list of boxes with their sizes, return the maximum number of boxes that can be placed on the belt without exceeding the capacity. Parameters: max_capacity (int): Maximum capacity of the conveyor belt boxes (List[Tuple[int, int]]): List of tuples where each tuple contains an identifier and a size Returns: int: Maximum number of boxes that can be placed on the conveyor belt # Sort the boxes by their sizes in ascending order boxes.sort(key=lambda x: x[1]) total_size = 0 total_boxes = 0 for box in boxes: if total_size + box[1] <= max_capacity: total_size += box[1] total_boxes += 1 else: break return total_boxes # Function to parse input and call the max_boxes_on_conveyor function def manage_boxes(): import sys input = sys.stdin.read() data = input.splitlines() max_capacity, num_boxes = map(int, data[0].split()) boxes = [tuple(map(int, line.split())) for line in data[1:]] result = max_boxes_on_conveyor(max_capacity, boxes) print(result)"},{"question":"def min_operations_to_equal_strings(n, s, t): Returns the minimum number of operations required to make strings \`s\` and \`t\` equal. Parameters: n (int): Length of the strings \`s\` and \`t\`. s (str): First string of length \`n\`. t (str): Second string of length \`n\`. Returns: int: Minimum number of operations required. Examples: >>> min_operations_to_equal_strings(5, 'abcde', 'ebcda') 2 >>> min_operations_to_equal_strings(3, 'abc', 'xyz') 3","solution":"def min_operations_to_equal_strings(n, s, t): Returns the minimum number of operations required to make strings \`s\` and \`t\` equal. Parameters: n (int): Length of the strings \`s\` and \`t\`. s (str): First string of length \`n\`. t (str): Second string of length \`n\`. Returns: int: Minimum number of operations required. operations = 0 for i in range(n): if s[i] != t[i]: operations += 1 return operations"},{"question":"def group_widgets(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if it is possible to group all widgets as per the given constraints. Args: T: Number of test cases test_cases: A list of tuples where each tuple has three elements: - N (number of widgets) - k (number of widgets per group) - a list of N widget IDs Returns: A list of strings where each entry corresponds to the result of a test case. - If it is not possible to group the widgets, return \\"No\\". - If possible, return \\"Yes\\" followed by the grouped IDs. Example: >>> group_widgets(2, [(9, 3, [7, 8, 9, 1, 2, 3, 4, 5, 6]), (6, 4, [7, 8, 9, 10, 11, 12])]) ['Yesn1 2 3n4 5 6n7 8 9', 'No'] pass","solution":"def group_widgets(T, test_cases): Determine if it is possible to group all widgets as per the given constraints. :param T: Number of test cases. :param test_cases: List of tuples, each containing N, k, and a list of widget IDs. :return: List of results, each being either \\"No\\" or \\"Yes\\" followed by the grouped IDs. results = [] for N, k, ids in test_cases: if N % k != 0: results.append(\\"No\\") continue sorted_ids = sorted(ids) groups = [sorted_ids[i:i+k] for i in range(0, N, k)] if len(groups) * k != N: results.append(\\"No\\") else: result = \\"Yesn\\" + \\"n\\".join(\\" \\".join(map(str, group)) for group in groups) results.append(result) return results"},{"question":"def max_product(arr): Returns the maximum product of any two distinct elements in the array. Args: arr (List[int]): List of integers. Returns: int: The maximum product of any two distinct elements. >>> max_product([1, 10, -5, 4]) 40 >>> max_product([-1, 0]) 0 >>> max_product([5]) 0 # Your code here def max_product_of_test_cases(test_cases): Returns a list of maximum products for each test case. Args: test_cases (List[Tuple[int]]): List of tuples representing test cases. Returns: List[int]: List of maximum products for each test case. >>> max_product_of_test_cases([(4, 1, 10, -5, 4), (2, -1, 0), (1, 5)]) [40, 0, 0] # Your code here from solution import max_product, max_product_of_test_cases def test_max_product_basic_cases(): assert max_product([1, 10, -5, 4]) == 40 assert max_product([-1, 0]) == 0 assert max_product([5]) == 0 def test_max_product_with_larger_lists(): assert max_product([1, 2, 3, 4]) == 12 assert max_product([0, -1, -2, -3]) == 6 assert max_product([-1000, 999, 1000]) == 999000 def test_max_product_with_repeated_elements(): assert max_product([1, 1, 1, 1]) == 1 assert max_product([0, 0, 0, 0]) == 0 def test_max_product_of_test_cases(): assert max_product_of_test_cases([(4, 1, 10, -5, 4), (2, -1, 0), (1, 5)]) == [40, 0, 0] def test_max_product_edge_cases(): assert max_product([]) == 0 # No elements assert max_product([1000]) == 0 # Single element assert max_product([-100, -1000]) == 100000 # Both elements are negative","solution":"def max_product(arr): Returns the maximum product of any two distinct elements in the array. n = len(arr) if n < 2: return 0 # Initialize the maximum and second maximum max1 = max2 = float('-inf') # Initialize the minimum and second minimum min1 = min2 = float('inf') for num in arr: # Update two largest values if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update two smallest values if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # Maximum product of either two largest or two smallest numbers return max(max1 * max2, min1 * min2) def max_product_of_test_cases(test_cases): results = [] for test_case in test_cases: n = test_case[0] if n < 2: results.append(0) else: arr = test_case[1:] results.append(max_product(arr)) return results"},{"question":"def min_swaps_to_group_ones(S: str) -> int: Determine the minimum number of swaps needed to group all 1s together in any contiguous segment of the string. >>> min_swaps_to_group_ones(\\"110010\\") 1 >>> min_swaps_to_group_ones(\\"001011\\") 1 >>> min_swaps_to_group_ones(\\"111000\\") 0 # Your code here","solution":"def min_swaps_to_group_ones(S): count_1 = S.count('1') if count_1 == 0: return 0 min_swaps = float('inf') current_zeros = 0 # Initialize the sliding window for i in range(count_1): if S[i] == '0': current_zeros += 1 min_swaps = min(min_swaps, current_zeros) # Move the sliding window one step at a time for i in range(count_1, len(S)): if S[i - count_1] == '0': current_zeros -= 1 if S[i] == '0': current_zeros += 1 min_swaps = min(min_swaps, current_zeros) return min_swaps"},{"question":"from typing import List, Optional def find_consecutive_sequence(n: int) -> Optional[List[int]]: Given an integer \`n\` between 1 and 1,000,000, return any one possible sequence of consecutive integers that add up to \`n\`. If no such sequence exists, return \`None\`. >>> find_consecutive_sequence(15) [1, 2, 3, 4, 5] >>> find_consecutive_sequence(10) [1, 2, 3, 4] >>> find_consecutive_sequence(16) None","solution":"from typing import List, Optional def find_consecutive_sequence(n: int) -> Optional[List[int]]: Given an integer \`n\` between 1 and 1,000,000, return any one possible sequence of consecutive integers that add up to \`n\`. If no such sequence exists, return \`None\`. for start in range(1, n): total = 0 sequence = [] for num in range(start, n): total += num sequence.append(num) if total == n: return sequence elif total > n: break return None"},{"question":"from typing import List def shortest_safe_path(grid: List[List[int]]) -> int: Find the shortest safe path in a minefield grid from the top-left corner to the bottom-right corner. >>> grid = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... [1, 1, 1, 0] ... ] >>> shortest_safe_path(grid) 6 >>> grid = [ ... [0, 1, 1, 1], ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0] ... ] >>> shortest_safe_path(grid) -1 pass","solution":"from collections import deque def is_valid_move(x, y, grid, visited): n, m = len(grid), len(grid[0]) return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 and not visited[x][y] def shortest_safe_path(grid): n, m = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny, grid, visited): visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def min_repair_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Returns the minimum total repair cost required to connect all cities. Examples: >>> min_repair_cost(4, 5, [(1, 2, 0), (1, 3, 4), (2, 3, 1), (3, 4, 3), (2, 4, 5)]) 4 >>> min_repair_cost(5, 6, [(1, 2, 5), (1, 3, 4), (2, 3, 2), (3, 4, 0), (4, 5, 7), (5, 1, 0)]) 6 >>> min_repair_cost(2, 1, [(1, 2, 0)]) 0 >>> min_repair_cost(3, 3, [(1, 2, 0), (2, 3, 0), (1, 3, 0)]) 0 >>> min_repair_cost(3, 3, [(1, 2, 1), (2, 3, 0), (1, 3, 2)]) 1","solution":"def min_repair_cost(n, m, roads): Returns the minimum total repair cost required to connect all cities. # Helper function to find the root parent of a node def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to do union of two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sorting the edges by their weight roads.sort(key=lambda x: x[2]) parent = [] rank = [] # Initialize parent and rank for node in range(n + 1): parent.append(node) rank.append(0) result = 0 e = 0 i = 0 # Number of edges to be taken is equal to V-1 while e < n - 1: u, v, w = roads[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result += w union(parent, rank, x, y) return result"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def max_path_sum(tree_values: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum value of the sum of the values of nodes on any path in the binary tree. >>> max_path_sum([2, -1, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) 12 >>> max_path_sum([5], []) 5 >>> max_path_sum([-2, -1, -3], [(1, 2), (1, 3)]) -1 >>> max_path_sum([3, -2, 1, -1, 4, 2], [(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)]) 10 >>> max_path_sum([1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) 10","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def max_path_sum(tree_values, edges): from collections import defaultdict, deque def create_tree(n, edges, tree_values): tree = [TreeNode(val) for val in tree_values] children = defaultdict(list) for u, v in edges: children[u-1].append(v-1) children[v-1].append(u-1) def build(node, parent): for child in children[node]: if child != parent: if tree[node].left is None: tree[node].left = tree[child] else: tree[node].right = tree[child] build(child, node) build(0, -1) return tree[0] def dfs(node): nonlocal max_sum if not node: return 0 left_max = max(0, dfs(node.left)) right_max = max(0, dfs(node.right)) max_sum = max(max_sum, left_max + right_max + node.val) return max(left_max, right_max) + node.val root = create_tree(len(tree_values), edges, tree_values) max_sum = float('-inf') dfs(root) return max_sum # Example input n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] tree_values = [2, -1, 3, 4, 5] print(max_path_sum(tree_values, edges)) # Output: 12"},{"question":"def largestDoubledUniqueSubstring(S: str) -> int: Returns the doubled length of the largest substring with all unique characters. >>> largestDoubledUniqueSubstring(\\"abcabcbb\\") 6 >>> largestDoubledUniqueSubstring(\\"bbbbb\\") 2 >>> largestDoubledUniqueSubstring(\\"pwwkew\\") 6 >>> largestDoubledUniqueSubstring(\\"\\") 0 >>> largestDoubledUniqueSubstring(\\"au\\") 4 >>> largestDoubledUniqueSubstring(\\"aab\\") 4 >>> largestDoubledUniqueSubstring(\\"dvdf\\") 6","solution":"def largestDoubledUniqueSubstring(S): Returns the doubled length of the largest substring with all unique characters. if not S: return 0 max_length = 0 start = 0 seen = {} for end in range(len(S)): if S[end] in seen and seen[S[end]] >= start: start = seen[S[end]] + 1 seen[S[end]] = end max_length = max(max_length, end - start + 1) return max_length * 2"},{"question":"def find_approx_hamiltonian_cycle(n: int, m: int, k: int, roads_info: List[Tuple[int, int, int]]) -> int: Approximate the shortest Hamiltonian cycle for a given number of distribution centers and roads. Args: n (int): Number of distribution centers. m (int): Number of roads. k (int): Starting distribution center. roads_info (List[Tuple[int, int, int]]): List of roads with distances. Returns: int: Total travel distance of the approximated shortest Hamiltonian cycle. Example: >>> find_approx_hamiltonian_cycle(4, 6, 1, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> find_approx_hamiltonian_cycle(3, 3, 2, [(1, 2, 10), (1, 3, 20), (2, 3, 25)]) 55","solution":"def nearest_neighbor_tsp(n, m, k, roads): from collections import defaultdict import heapq graph = defaultdict(list) for u, v, d in roads: graph[u].append((d, v)) graph[v].append((d, u)) visited = [False] * (n + 1) path_cost = 0 current = k for _ in range(n - 1): visited[current] = True neighbors = graph[current] min_distance, next_center = min((dist, center) for dist, center in neighbors if not visited[center]) path_cost += min_distance current = next_center # Add the distance to return to the starting center for dist, center in graph[current]: if center == k: path_cost += dist break return path_cost # Function to parse input and call the nearest_neighbor_tsp function def find_approx_hamiltonian_cycle(n, m, k, roads_info): roads = [] for i in range(m): u, v, d = roads_info[i] roads.append((u, v, d)) return nearest_neighbor_tsp(n, m, k, roads)"},{"question":"def min_days_to_upload_videos(n: int, k: int, sizes: List[int]) -> int: Calculate the minimum number of days required to upload all the videos. Parameters: n (int): Number of videos k (int): Maximum number of videos that can be uploaded in parallel per day sizes (list of int): Sizes of the videos Returns: int: Minimum number of days required to upload all the videos >>> min_days_to_upload_videos(7, 3, [50, 100, 200, 150, 300, 250, 400]) 3 >>> min_days_to_upload_videos(1, 1, [100]) 1 >>> min_days_to_upload_videos(3, 5, [100, 200, 300]) 1 >>> min_days_to_upload_videos(10, 2, [100]*10) 5 >>> min_days_to_upload_videos(100000, 1, [1]*100000) 100000","solution":"def min_days_to_upload_videos(n, k, sizes): Function to calculate the minimum number of days required to upload all the videos. Parameters: n (int): Number of videos k (int): Maximum number of videos that can be uploaded in parallel per day sizes (list of int): Sizes of the videos Returns: int: Minimum number of days required to upload all the videos # The number of days required is simply the ceiling of n divided by k. from math import ceil return ceil(n / k) # Example use case n, k = 7, 3 sizes = [50, 100, 200, 150, 300, 250, 400] print(min_days_to_upload_videos(n, k, sizes)) # Output: 3"},{"question":"def final_score(n: int, m: int, scores: List[int]) -> int: Calculates the final score as the sum of the top m scores out of n scores. Parameters: n (int): Total number of scores. m (int): Number of top scores to sum. scores (list of int): The list of scores. Returns: int: The sum of the top m scores. >>> final_score(5, 3, [50, 80, 90, 70, 85]) 255 >>> final_score(4, 2, [60, 40, 20, 80]) 140 >>> final_score(5, 3, [100, 100, 100, 100, 100]) 300 >>> final_score(4, 4, [60, 40, 20, 80]) 200 >>> final_score(1, 1, [50]) 50 >>> final_score(5, 1, [10, 30, 25, 5, 40]) 40 >>> final_score(100, 50, list(range(1, 101))) sum(range(51, 101))","solution":"def final_score(n, m, scores): Calculates the final score as the sum of the top m scores out of n scores. Parameters: n (int): Total number of scores. m (int): Number of top scores to sum. scores (list of int): The list of scores. Returns: int: The sum of the top m scores. # Sort the scores in descending order scores.sort(reverse=True) # Sum the top m scores return sum(scores[:m])"},{"question":"def precompute_difficulties(difficulties): Precomputes the prefix sums for the given difficulties array. Args: difficulties (list): The list of difficulties for each segment. Returns: list: The prefix sums array. def total_difficulty(prefix_sums, l, r): Computes the total difficulty for a given range using the prefix sums array. Args: prefix_sums (list): The prefix sums array. l (int): The starting index of the range (1-based). r (int): The ending index of the range (1-based). Returns: int: The total difficulty of the range from l to r inclusive. def main(n, q, difficulties, queries): Manages the interaction for calculating total difficulties for given queries. Args: n (int): The number of segments. q (int): The number of queries. difficulties (list): The list of difficulties for each segment. queries (list): A list of tuples containing the start and end indices for each query. Returns: list: The list of results for each query. # Unit Tests def test_precompute_difficulties(): assert precompute_difficulties([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10, 15] assert precompute_difficulties([10, 20, 30]) == [0, 10, 30, 60] assert precompute_difficulties([5, 5, 5, 5, 5]) == [0, 5, 10, 15, 20, 25] def test_total_difficulty(): prefix_sums = precompute_difficulties([1, 2, 3, 4, 5]) assert total_difficulty(prefix_sums, 1, 3) == 6 assert total_difficulty(prefix_sums, 2, 5) == 14 assert total_difficulty(prefix_sums, 1, 5) == 15 def test_main(): n, q = 5, 3 difficulties = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 5), (1, 5)] assert main(n, q, difficulties, queries) == [6, 14, 15] n, q = 3, 2 difficulties = [10, 20, 30] queries = [(1, 2), (2, 3)] assert main(n, q, difficulties, queries) == [30, 50]","solution":"def precompute_difficulties(difficulties): Precomputes the prefix sums for the given difficulties array. Args: difficulties (list): The list of difficulties for each segment. Returns: list: The prefix sums array. n = len(difficulties) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + difficulties[i - 1] return prefix_sums def total_difficulty(prefix_sums, l, r): Computes the total difficulty for a given range using the prefix sums array. Args: prefix_sums (list): The prefix sums array. l (int): The starting index of the range (1-based). r (int): The ending index of the range (1-based). Returns: int: The total difficulty of the range from l to r inclusive. return prefix_sums[r] - prefix_sums[l - 1] def main(n, q, difficulties, queries): Manages the interaction for calculating total difficulties for given queries. Args: n (int): The number of segments. q (int): The number of queries. difficulties (list): The list of difficulties for each segment. queries (list): A list of tuples containing the start and end indices for each query. Returns: list: The list of results for each query. prefix_sums = precompute_difficulties(difficulties) results = [] for l, r in queries: results.append(total_difficulty(prefix_sums, l, r)) return results"},{"question":"def sum_positive_even(numbers): Returns the sum of all the integers in the list that are positive and even. Args: numbers (list of int): List of integers to sum. Returns: int: Sum of positive even integers. >>> sum_positive_even([4, -1, 2, 0, -3, 5]) 6 >>> sum_positive_even([-2, -4, -6, -8]) 0 >>> sum_positive_even([2, 4, 6, 8]) 20 >>> sum_positive_even([1, 3, 5, 7]) 0 >>> sum_positive_even([]) 0 >>> sum_positive_even([0, 1, 2, 3, 4]) 6 >>> sum_positive_even([0, 1000000, -1000000]) 1000000","solution":"def sum_positive_even(numbers): Returns the sum of all the integers in the list that are positive and even. Args: numbers (list of int): List of integers to sum. Returns: int: Sum of positive even integers. return sum(num for num in numbers if num > 0 and num % 2 == 0)"},{"question":"def max_points_without_exceeding(points: List[int], limit: int) -> int: Returns the maximum sum of points that can be achieved without exceeding the limit. >>> max_points_without_exceeding([200, 500, 300, 700, 800], 1500) == 1500 >>> max_points_without_exceeding([100, 200, 300], 400) == 400 >>> max_points_without_exceeding([700, 800, 900], 1000) == 900 pass def solve_contest_levels(test_cases: List[Tuple[int, ...]]) -> List[int]: Given multiple test cases, return the results for each test case in the form of a list. Each result is the maximum sum of points that can be achieved without exceeding the given limit. >>> test_cases = [ >>> (5, 200, 500, 300, 700, 800, 1500), >>> (3, 100, 200, 300, 400), >>> (3, 700, 800, 900, 1000) >>> ] >>> solve_contest_levels(test_cases) == [1500, 400, 900] pass from solution import max_points_without_exceeding, solve_contest_levels def test_max_points_without_exceeding(): assert max_points_without_exceeding([200, 500, 300, 700, 800], 1500) == 1500 assert max_points_without_exceeding([100, 200, 300], 400) == 400 assert max_points_without_exceeding([700, 800, 900], 1000) == 900 def test_solve_contest_levels(): test_cases = [ (5, 200, 500, 300, 700, 800, 1500), (3, 100, 200, 300, 400), (3, 700, 800, 900, 1000) ] results = solve_contest_levels(test_cases) expected = [1500, 400, 900] assert results == expected","solution":"def max_points_without_exceeding(points, limit): Returns the maximum sum of points that can be achieved without exceeding the limit. Uses the knapsack approach to solve the problem. n = len(points) dp = [0] * (limit + 1) for point in points: for v in range(limit, point - 1, -1): dp[v] = max(dp[v], dp[v - point] + point) return dp[limit] def solve_contest_levels(test_cases): Given multiple test cases, return the results for each test case in the form of a list. Each result is the maximum sum of points that can be achieved without exceeding the given limit. results = [] for case in test_cases: N = case[0] points = case[1:N+1] limit = case[-1] results.append(max_points_without_exceeding(points, limit)) return results"},{"question":"def top_k_rated_movies(n, movies, k): Returns the top k rated movies names in descending order of their ratings. If multiple movies have the same rating, they are returned in the order they appear in the input. :param n: int, number of movies. :param movies: list of tuples, where each tuple contains the name of the movie and its rating. :param k: int, number of top rated movies to return. :return: list of strings, top k rated movie names. >>> top_k_rated_movies(5, [(\\"Inception\\", 90), (\\"Interstellar\\", 95), (\\"Tenet\\", 85), (\\"Memento\\", 85), (\\"The Prestige\\", 92)], 3) [\\"Interstellar\\", \\"The Prestige\\", \\"Inception\\"] >>> top_k_rated_movies(4, [(\\"Avatar\\", 78), (\\"Titanic\\", 85), (\\"The Godfather\\", 100), (\\"The Dark Knight\\", 100)], 2) [\\"The Godfather\\", \\"The Dark Knight\\"] >>> top_k_rated_movies(1, [(\\"Solo\\", 88)], 1) [\\"Solo\\"] >>> top_k_rated_movies(3, [(\\"Movie1\\", 50), (\\"Movie2\\", 60), (\\"Movie3\\", 70)], 3) [\\"Movie3\\", \\"Movie2\\", \\"Movie1\\"] >>> top_k_rated_movies(3, [(\\"MovieA\\", 90), (\\"MovieB\\", 90), (\\"MovieC\\", 90)], 2) [\\"MovieA\\", \\"MovieB\\"] >>> top_k_rated_movies(6, [(\\"A\\", 99), (\\"B\\", 85), (\\"C\\", 95), (\\"D\\", 85), (\\"E\\", 100), (\\"F\\", 90)], 4) [\\"E\\", \\"A\\", \\"C\\", \\"F\\"]","solution":"def top_k_rated_movies(n, movies, k): Returns the top k rated movies names in descending order of their ratings. If multiple movies have the same rating, they are returned in the order they appear in the input. :param n: int, number of movies. :param movies: list of tuples, where each tuple contains the name of the movie and its rating. :param k: int, number of top rated movies to return. :return: list of strings, top k rated movie names. # Sort movies by rating in descending order and by their original input order if ratings are the same sorted_movies = sorted(movies, key=lambda x: (-x[1], movies.index(x)) ) # Extract the names of the top k rated movies result = [movie[0] for movie in sorted_movies[:k]] return result"},{"question":"def smallest_enclosing_rectangle(points): Given a list of points, determine the smallest rectangle that can enclose all the points such that its sides are parallel to the coordinate axes. Args: points (list of tuples): List of tuples where each tuple is of the form (x, y). Returns: tuple: Four integers corresponding to the coordinates of the bottom-left and top-right corners of the smallest rectangle. >>> smallest_enclosing_rectangle([(1, 2), (2, 3), (4, 6), (0, 5), (-1, -2)]) (-1, -2, 4, 6) >>> smallest_enclosing_rectangle([(1, 2), (2, 3), (4, 6), (0, 5)]) (0, 2, 4, 6) >>> smallest_enclosing_rectangle([(1, 0), (2, 0), (3, 0)]) (1, 0, 3, 0) >>> smallest_enclosing_rectangle([(0, 1), (0, 2), (0, 3)]) (0, 1, 0, 3) >>> smallest_enclosing_rectangle([(-10000, -10000), (10000, 10000), (0, 0)]) (-10000, -10000, 10000, 10000) >>> smallest_enclosing_rectangle([(3, 3)]) (3, 3, 3, 3) >>> smallest_enclosing_rectangle([(1, 1), (1, 2), (2, 1), (2, 2)]) (1, 1, 2, 2)","solution":"def smallest_enclosing_rectangle(points): Given a list of points, determine the smallest rectangle that can enclose all the points such that its sides are parallel to the coordinate axes. Args: points (list of tuples): List of tuples where each tuple is of the form (x, y). Returns: tuple: Four integers corresponding to the coordinates of the bottom-left and top-right corners of the smallest rectangle. min_x = min(points, key=lambda pt: pt[0])[0] max_x = max(points, key=lambda pt: pt[0])[0] min_y = min(points, key=lambda pt: pt[1])[1] max_y = max(points, key=lambda pt: pt[1])[1] return min_x, min_y, max_x, max_y"},{"question":"def compress_string(s): Compresses the given string by replacing consecutive repeated characters with the character followed by the number of repetitions. Returns the original string if the compressed string is not smaller. >>> compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") == \\"abcdef\\" >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"aaaaaa\\") == \\"a6\\" >>> compress_string(\\"aaabbbcccaaa\\") == \\"a3b3c3a3\\" >>> compress_string(\\"aabb\\") == \\"aabb\\" >>> compress_string(\\"a\\" * 500 + \\"b\\" * 500) == \\"a500b500\\"","solution":"def compress_string(s): Compresses the given string by replacing consecutive repeated characters with the character followed by the number of repetitions. Returns the original string if the compressed string is not smaller. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Append the last set of characters compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def generateParenthesis(n: int) -> List[str]: Generate all combinations of n pairs of valid parentheses. Parameters: n (int): Number of pairs of parentheses. Returns: List[str]: All valid combinations of n pairs of parentheses.","solution":"def generateParenthesis(n): Generate all combinations of n pairs of valid parentheses. Parameters: n (int): Number of pairs of parentheses. Returns: List[str]: All valid combinations of n pairs of parentheses. def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack('', 0, 0) return result"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if a string can be rearranged to form a palindrome. Args: s (str): The input string consisting of only lowercase letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' def can_form_palindrome_multiple_cases(strings: List[str]) -> List[str]: For a list of strings, determines if each string can be rearranged to form a palindrome. Args: strings (list[str]): List of input strings consisting of only lowercase letters. Returns: list[str]: List of results (\\"YES\\" or \\"NO\\") for each input string. >>> can_form_palindrome_multiple_cases([\\"civic\\", \\"ivicc\\", \\"hello\\"]) ['YES', 'YES', 'NO'] >>> can_form_palindrome_multiple_cases([\\"aabb\\", \\"abc\\"]) ['YES', 'NO'] >>> can_form_palindrome_multiple_cases([\\"\\", \\"a\\", \\"aa\\"]) ['YES', 'YES', 'YES']","solution":"def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. Args: s (str): The input string consisting of only lowercase letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter freq = Counter(s) odd_count = sum(1 for v in freq.values() if v % 2 != 0) if odd_count > 1: return \\"NO\\" return \\"YES\\" def can_form_palindrome_multiple_cases(strings): For a list of strings, determines if each string can be rearranged to form a palindrome. Args: strings (list[str]): List of input strings consisting of only lowercase letters. Returns: list[str]: List of results (\\"YES\\" or \\"NO\\") for each input string. results = [can_form_palindrome(s) for s in strings] return results"},{"question":"def longest_green_sequence(lights: str) -> int: Returns the length of the longest sequence of consecutive green lights ('G'). Parameters: lights (str): A string representing the status of the traffic lights, consisting of 'G' and 'R' characters. Returns: int: The length of the longest sequence of consecutive green lights. Example: >>> longest_green_sequence(\\"GRRGGGRGRG\\") 3 >>> longest_green_sequence(\\"GGGGGRRRRGG\\") 5 >>> longest_green_sequence(\\"RRRRGGG\\") 3","solution":"def longest_green_sequence(lights): Returns the length of the longest sequence of consecutive green lights ('G'). Parameters: lights (str): A string representing the status of the traffic lights, consisting of 'G' and 'R' characters. Returns: int: The length of the longest sequence of consecutive green lights. max_length = 0 current_length = 0 for light in lights: if light == 'G': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def reverseBits(k: int) -> int: Given a positive integer K, reverse the bits of K and return the resulting integer. Args: k (int): A positive integer whose bits are to be reversed. Returns: int: The resulting integer after reversing the bits of K. Examples: >>> reverseBits(5) 5 >>> reverseBits(13) 11","solution":"def reverseBits(k): Reverses the bits of a given positive integer k and returns the resulting integer. # Convert the number to binary and remove the '0b' prefix binary_representation = bin(k)[2:] # Reverse the binary string reversed_binary = binary_representation[::-1] # Convert the reversed binary string back to an integer reversed_integer = int(reversed_binary, 2) return reversed_integer"},{"question":"def shortest_path(num_stations, connections, start, destination): Find the shortest path between two stations in a metro system. Args: num_stations (int): Number of stations. connections (list of tuples): Each tuple contains two integers representing a direct connection between stations. start (int): The starting station. destination (int): The destination station. Returns: int: The minimum number of stations between start and destination, or -1 if no path exists. Examples: >>> shortest_path(5, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)], 1, 5) 3 >>> shortest_path(5, [(1, 2), (2, 3), (3, 4)], 1, 5) -1 >>> shortest_path(5, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)], 1, 1) 0 >>> shortest_path(2, [(1, 2)], 1, 2) 1 >>> shortest_path(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 1, 6) 5 >>> shortest_path(6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6)], 1, 6) 4","solution":"from collections import deque def shortest_path(num_stations, connections, start, destination): Find the shortest path between two stations in a metro system. :param num_stations: int, number of stations :param connections: list of tuples, each containing two integers representing a direct connection between stations :param start: int, the starting station :param destination: int, the destination station :return: int, the minimum number of stations between start and destination, or -1 if no path exists if start == destination: return 0 # Build the adjacency list adjacency_list = {i: [] for i in range(1, num_stations + 1)} for u, v in connections: adjacency_list[u].append(v) adjacency_list[v].append(u) # BFS initialization queue = deque([(start, 0)]) visited = set([start]) while queue: current_station, distance = queue.popleft() for neighbor in adjacency_list[current_station]: if neighbor not in visited: if neighbor == destination: return distance + 1 queue.append((neighbor, distance + 1)) visited.add(neighbor) return -1"},{"question":"import math from typing import List, Tuple def paint_needed(test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the amount of paint needed to cover the entire roof for given test cases where the roof is shaped like a right-angled triangle. >>> paint_needed([(3, 4), (6, 8)]) [6, 24] >>> paint_needed([(1, 1), (10, 10)]) [1, 50] >>> paint_needed([(5, 12), (9, 12)]) [30, 54] >>> paint_needed([(1, 10000), (10000, 1)]) [5000, 5000] >>> paint_needed([(7, 24)]) [84]","solution":"import math def paint_needed(test_cases): res = [] for a, b in test_cases: # Calculate area of the right-angled triangle (1/2 * a * b) area = 0.5 * a * b # Calculate the amount of paint needed rounded up to the nearest whole number paint = math.ceil(area) res.append(paint) return res def main(): T = int(input()) test_cases = [] for _ in range(T): a, b = map(int, input().split()) test_cases.append((a, b)) results = paint_needed(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def larger_than_average(arr: List[int]) -> List[int]: Given an array of numbers, returns a new array containing only the numbers that are strictly larger than the average of the original array. >>> larger_than_average([1, 2, 3, 4, 5]) [4, 5] >>> larger_than_average([10, 20, 30, 40, 50, 60]) [40, 50, 60] >>> larger_than_average([-10, -5, 0, 5, 10]) [5, 10] >>> larger_than_average([-1, -2, -3, -4, -5]) [-1, -2] >>> larger_than_average([]) [] >>> larger_than_average([5, 5, 5, 5]) [] >>> larger_than_average([10]) [] >>> larger_than_average([-10]) [] >>> larger_than_average([1000, 2000, 3000, 4000, 5000]) [4000, 5000] >>> larger_than_average([1000000, 2000000, 3000000, 4000000, 5000000]) [4000000, 5000000] pass","solution":"def larger_than_average(arr): Given an array of numbers, returns a new array containing only the numbers that are strictly larger than the average of the original array. if not arr: return [] average = sum(arr) / len(arr) return [num for num in arr if num > average]"},{"question":"def count_palindromic_subsequences(T: int, cases: List[str]) -> List[int]: Given an integer T and a list of T strings, returns a list containing the number of palindromic subsequences for each string. >>> count_palindromic_subsequences(2, [\\"aaa\\", \\"abc\\"]) [7, 3] >>> count_palindromic_subsequences(1, [\\"a\\"]) [1] >>> count_palindromic_subsequences(1, [\\"aa\\"]) [3] >>> count_palindromic_subsequences(1, [\\"ab\\"]) [2] >>> count_palindromic_subsequences(1, [\\"abba\\"]) [9] >>> count_palindromic_subsequences(1, [\\"abcd\\"]) [4]","solution":"def count_palindromic_subsequences(T, cases): def is_palindrome(s): return s == s[::-1] def count_subsequences(S): n = len(S) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1 else: dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] return dp[0][n - 1] results = [] for case in cases: results.append(count_subsequences(case)) return results"},{"question":"from typing import List def is_valid_palindrome(s: str) -> bool: Check if a given string can be a valid palindrome by removing at most one character. >>> is_valid_palindrome(\\"aba\\") True >>> is_valid_palindrome(\\"abca\\") True >>> is_valid_palindrome(\\"abc\\") False pass def check_palindromes(test_cases: List[str]) -> List[str]: Takes a list of strings and returns a list of \\"YES\\" or \\"NO\\" depending on whether the string can be a palindrome by removing at most one character. >>> check_palindromes([\\"aba\\", \\"abca\\", \\"abc\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindromes([\\"racecar\\", \\"racecars\\", \\"deified\\", \\"deifid\\", \\"deifidd\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def is_valid_palindrome(s): This function checks if a given string can be a palindrome by removing at most one character. def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return True def check_palindromes(test_cases): This function takes a list of strings and returns a list of \\"YES\\" or \\"NO\\" depending on whether the string can be a palindrome by removing at most one character. results = [] for s in test_cases: if is_valid_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def most_frequent_char(input_string: str) -> str: Determine the most frequently occurring character in the string. If there are multiple characters that occur the same number of times, return the character that comes first alphabetically. >>> most_frequent_char('a') == 'a' >>> most_frequent_char('abc') == 'a' >>> most_frequent_char('banana') == 'a' >>> most_frequent_char('apple') == 'p' >>> most_frequent_char('a'*50000 + 'b'*50000) == 'a' >>> most_frequent_char('abracadabra') == 'a' >>> most_frequent_char('abbccc') == 'c'","solution":"def most_frequent_char(input_string): from collections import Counter # Count the frequency of each character in the string frequency = Counter(input_string) # Find the maximum frequency max_freq = max(frequency.values()) # Collect all characters with the maximum frequency max_chars = [char for char, freq in frequency.items() if freq == max_freq] # Return the alphabetically first character among those with the maximum frequency return min(max_chars)"},{"question":"def unique_sorted_integers(S: str) -> str: Given a string S consisting of comma-separated integers, return a sorted list of unique integers in ascending order. >>> unique_sorted_integers(\\"3,1,2,3,4,1\\") '1,2,3,4' >>> unique_sorted_integers(\\"5,9,5,7,9,0\\") '0,5,7,9'","solution":"def unique_sorted_integers(S): Given a string S consisting of comma-separated integers, return a sorted list of unique integers in ascending order. # Split the string by commas to get the individual integers as strings str_integers = S.split(',') # Convert the strings to integers and use a set to eliminate duplicates unique_integers = set(int(num) for num in str_integers) # Convert the set to a sorted list sorted_unique_integers = sorted(unique_integers) # Convert the list of integers back to a list of strings and join with commas to match output format return ','.join(map(str, sorted_unique_integers))"},{"question":"def largest_gap(n, meetings): Finds the largest gap between any two consecutive meetings. :param n: Number of meetings :param meetings: List of tuples, where each tuple contains start and end times of a meeting :return: The largest gap between any two consecutive meetings # Insert Your Code Here # Unit Tests def test_no_gap(): assert largest_gap(2, [(5, 10), (10, 15)]) == 0 def test_single_meeting(): assert largest_gap(1, [(5, 10)]) == 0 def test_multiple_meetings_with_gaps(): assert largest_gap(3, [(1, 5), (10, 15), (20, 25)]) == 5 def test_overlapping_meetings(): assert largest_gap(4, [(1, 4), (2, 10), (12, 15), (20, 25)]) == 5 def test_large_gap(): assert largest_gap(3, [(1, 2), (10, 15), (20, 25)]) == 8","solution":"def largest_gap(n, meetings): Finds the largest gap between any two consecutive meetings. :param n: Number of meetings :param meetings: List of tuples, where each tuple contains start and end times of a meeting :return: The largest gap between any two consecutive meetings # Sort meetings by their start time meetings.sort() max_gap = 0 # Initialize the end time of the first meeting prev_end = meetings[0][1] for i in range(1, n): start, end = meetings[i] gap = start - prev_end if gap > max_gap: max_gap = gap prev_end = end return max_gap"},{"question":"def process_operations(n, operations): Processes painting and querying operations on a banner and returns the number of white segments after each query. :param n: Length of the banner :param operations: List of operations to be performed on the banner :return: List of results for each \\"Q\\" operation pass # Example test cases def test_example_case(): assert process_operations(10, [ ('P', 1, 5, 3), ('Q',), ('P', 6, 10, 4), ('Q',), ('P', 2, 8, 5) ]) == [5, 0] def test_all_white(): assert process_operations(5, [ ('Q',), ('Q',), ('Q',) ]) == [5, 5, 5] def test_all_painted_at_once(): assert process_operations(7, [ ('P', 1, 7, 2), ('Q',) ]) == [0] def test_multiple_paint_operations(): assert process_operations(5, [ ('P', 1, 1, 1), ('P', 2, 3, 1), ('Q',), ('P', 4, 5, 1), ('Q',) ]) == [2, 0] def test_partial_paint(): assert process_operations(8, [ ('P', 1, 4, 1), ('P', 5, 8, 2), ('Q',) ]) == [0]","solution":"def process_operations(n, operations): Processes painting and querying operations on a banner. :param n: Length of the banner :param operations: List of operations to be performed on the banner :return: List of results for each \\"Q\\" operation banner = [0] * n white_segments = n results = [] for operation in operations: if operation[0] == 'P': _, a, b, c = operation a -= 1 # to adjust to 0-based index b -= 1 # to adjust to 0-based index for i in range(a, b+1): if banner[i] == 0: banner[i] = c white_segments -= 1 elif operation[0] == 'Q': results.append(white_segments) return results"},{"question":"def morse_encoder(text: str) -> str: Encode a given string into its Morse code equivalent. >>> morse_encoder(\\"HELLO WORLD\\") '.... . .-.. .-.. --- .-- --- .-. .-.. -..' >>> morse_encoder(\\"SOS\\") '... --- ...' >>> morse_encoder(\\"A\\") '.-'","solution":"def morse_encoder(text): morse_code = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..' } words = text.split(' ') encoded_words = [] for word in words: encoded_word = ' '.join(morse_code[char] for char in word) encoded_words.append(encoded_word) return ' '.join(encoded_words)"},{"question":"from typing import List def rearrange_elements(nums: List[int]) -> List[int]: Given a list of integers, determine whether it is possible to rearrange the elements of the list so that no two adjacent elements are equal. If possible, return one such rearrangement. If not, return an empty list. >>> rearrange_elements([1, 1, 2, 2, 3, 3]) [1, 2, 1, 3, 2, 3] >>> rearrange_elements([1, 1, 1, 1]) [] >>> rearrange_elements([]) [] >>> rearrange_elements([1]) [1] >>> rearrange_elements([1, 1]) [] >>> rearrange_elements([1, 2]) [1, 2] >>> rearrange_elements([1, -1, -1, 1]) [-1, 1, -1, 1]","solution":"from collections import Counter import heapq def rearrange_elements(nums): Given a list of integers, determine whether it is possible to rearrange the elements of the list so that no two adjacent elements are equal. If possible, return one such rearrangement. If not, return an empty list. if not nums: return [] # Count the occurrences of each element count = Counter(nums) max_count = max(count.values()) # To be rearrangeable, the most frequent element must not exceed (N + 1) // 2 if max_count > (len(nums) + 1) // 2: return [] # Create a max heap based on element frequency heap = [(-freq, num) for num, freq in count.items()] heapq.heapify(heap) prev_freq, prev_num = 0, None result = [] while heap: freq, num = heapq.heappop(heap) result.append(num) # If previous element still has remaining frequency, reinsert back to heap if prev_freq < 0: heapq.heappush(heap, (prev_freq, prev_num)) # Decrease frequency, since it's been used prev_freq, prev_num = freq + 1, num return result"},{"question":"def increment_array(digits): Increment the large integer represented by the array of digits by one. Args: digits (list of int): List of single digits representing a large integer. Returns: list of int: New list of single digits representing the incremented large integer. Example: >>> increment_array([1, 2, 3]) [1, 2, 4] >>> increment_array([4, 3, 2, 1]) [4, 3, 2, 2] >>> increment_array([9]) [1, 0] >>> increment_array([9, 9, 9]) [1, 0, 0, 0]","solution":"def increment_array(digits): Increment the large integer represented by the array of digits by one. Args: digits (list of int): List of single digits representing a large integer. Returns: list of int: New list of single digits representing the incremented large integer. n = len(digits) # Get the length of input digits array for i in range(n-1, -1, -1): if digits[i] < 9: # If current digit is less than 9, simply increment it and return the array digits[i] += 1 return digits digits[i] = 0 # Otherwise, set current digit to 0 and move to the next significant digit # If all the digits are 9, then the increment will add one more digit to the array return [1] + digits"},{"question":"def max_profit(prices: List[int]) -> int: Determine the maximum profit you could have achieved by buying and selling on a single day within the period. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1]) 0 def process_test_cases(test_cases_input: str) -> List[int]: Process multiple test cases and for each test case, output the maximal possible profit. >>> process_test_cases(\\"7 1 5 3 6 4n7 6 4 3 1n1n\\") [5, 0, 0] >>> process_test_cases(\\"2 4 1 7 5 3 6n\\") [6] >>> process_test_cases(\\"10 10 10n1 1 1 1 1 1n2 2 2 2n\\") [0, 0, 0]","solution":"def max_profit(prices): if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit def process_test_cases(test_cases_input): results = [] for prices_str in test_cases_input.strip().split(\\"n\\"): prices = list(map(int, prices_str.split())) results.append(max_profit(prices)) return results"},{"question":"def can_form_arithmetic_progression(arr: List[int]) -> bool: Determines if the elements of the array can be reordered to form an arithmetic progression. Args: arr (list of int): The input array of integers. Returns: bool: True if the array can be reordered to form an arithmetic progression, False otherwise. >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 2, 4]) False >>> can_form_arithmetic_progression([7]) True >>> can_form_arithmetic_progression([5, 3]) True >>> can_form_arithmetic_progression([1, 3, 5, 7]) True >>> can_form_arithmetic_progression([1, 3, 6, 10]) False","solution":"def can_form_arithmetic_progression(arr): Determines if the elements of the array can be reordered to form an arithmetic progression. Args: arr (list of int): The input array of integers. Returns: bool: True if the array can be reordered to form an arithmetic progression, False otherwise. if len(arr) <= 1: return True arr.sort() common_diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != common_diff: return False return True"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) pass def solve(test_cases): Solves the problem for multiple test cases. >>> test_cases = [ ... {'n': 4, 'target': 9, 'nums': [2, 7, 11, 15]}, ... {'n': 3, 'target': 6, 'nums': [3, 2, 4]} ... ] >>> solve(test_cases) [(0, 1), (1, 2)] pass","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return (-1, -1) # should never be reached if there is exactly one solution def solve(test_cases): Solves the problem for multiple test cases. results = [] for test_case in test_cases: n, target = test_case['n'], test_case['target'] nums = test_case['nums'] result = two_sum(nums, target) results.append(result) return results"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and then later selling a single share of the stock from the given list of prices. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 pass def parse_input(input_data: str) -> List[int]: Parses the multiple datasets input and returns the results for maximum profits. >>> parse_input(\\"6n7 1 5 3 6 4n5n7 6 4 3 1n4n1 2 3 4n0\\") [5, 0, 3] pass def process_input(input_data: str) -> List[int]: Takes input data as a string, processes it, and returns the result as a list. >>> process_input(\\"6n7 1 5 3 6 4n5n7 6 4 3 1n4n1 2 3 4n0\\") [5, 0, 3] pass","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and then later selling a single share of the stock from the given list of prices. if not prices or len(prices) == 1: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit def parse_input(input_data): Parses the multiple datasets input and returns the results for maximum profits. lines = input_data.strip().split('n') results = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break prices = list(map(int, lines[i + 1].strip().split())) results.append(max_profit(prices)) i += 2 return results def process_input(input_data): Takes input data as a string, processes it, and returns the result as a list. results = parse_input(input_data) return results"},{"question":"def rotate_string(s: str, k: int) -> str: Rotates the string \`s\` to the right by \`k\` positions. Parameters: s (str): the input string k (int): the number of positions to rotate Returns: str: the rotated string >>> rotate_string(\\"abcdef\\", 2) == \\"efabcd\\" >>> rotate_string(\\"hello\\", 3) == \\"llohe\\"","solution":"def rotate_string(s, k): Rotates the string \`s\` to the right by \`k\` positions. Parameters: s (str): the input string k (int): the number of positions to rotate Returns: str: the rotated string n = len(s) k = k % n # handling the case where k might be greater than the length of the string return s[-k:] + s[:-k]"},{"question":"def minimum_routes_to_critical(m: int) -> int: Returns the minimum number of direct routes needed such that at least half of them are critical routes for a warehouse with m delivery areas. >>> minimum_routes_to_critical(3) 2 >>> minimum_routes_to_critical(5) 4 >>> minimum_routes_to_critical(8) 7 pass def test_minimum_routes_to_critical(): assert minimum_routes_to_critical(3) == 2 assert minimum_routes_to_critical(5) == 4 assert minimum_routes_to_critical(8) == 7 assert minimum_routes_to_critical(1) == 0 # Minimum case assert minimum_routes_to_critical(2) == 1 # Another simple case assert minimum_routes_to_critical(10**9) == 999999999 # High edge case def test_minimum_routes_to_critical_edge_cases(): assert minimum_routes_to_critical(100000) == 99999 assert minimum_routes_to_critical(5000) == 4999 assert minimum_routes_to_critical(2 * 10**9) == 1999999999","solution":"def minimum_routes_to_critical(m): Returns the minimum number of direct routes needed such that at least half of them are critical routes for a warehouse with m delivery areas. # To ensure at least half of the routes are critical, # we need at least minimum_routes / 2 to be critical. # In a cycle of n nodes, there are n edges and none are critical. # In a path of n nodes, there are n-1 edges and all are critical. # Minimum number of edges to ensure the condition: # To cover at least half critical edges, (sufficient condition) return (m - 1)"},{"question":"def partition_labels(s: str) -> List[int]: Divide the string into as many substrings as possible so that each letter appears in at most one substring. Returns a list of integers representing the lengths of these substrings. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[int]: A list of integers representing the lengths of the substrings. Examples: >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"eccbbbbdec\\") [10] from solution import partition_labels def test_partition_labels(): # Test case 1 s1 = \\"ababcbacadefegdehijhklij\\" expected1 = [9, 7, 8] assert partition_labels(s1) == expected1 # Test case 2 s2 = \\"eccbbbbdec\\" expected2 = [10] assert partition_labels(s2) == expected2 # Test case 3 - single character s3 = \\"a\\" expected3 = [1] assert partition_labels(s3) == expected3 # Test case 4 - no repetitions s4 = \\"abcdefg\\" expected4 = [1, 1, 1, 1, 1, 1, 1] assert partition_labels(s4) == expected4 # Test case 5 - characters repeating and not grouped s5 = \\"abac\\" expected5 = [3, 1] assert partition_labels(s5) == expected5 # Test case 6 - all characters are the same s6 = \\"aaaaaaa\\" expected6 = [7] assert partition_labels(s6) == expected6 # Test case 7 - characters interleaved s7 = \\"abababab\\" expected7 = [8] assert partition_labels(s7) == expected7 # Test case 8 - larger string with complex pattern s8 = \\"kfjdkfjdklakkdlfalkfkjfl\\" expected8 = [24] assert partition_labels(s8) == expected8","solution":"def partition_labels(s): Divide the string into as many substrings as possible so that each letter appears in at most one substring. Returns a list of integers representing the lengths of these substrings. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[int]: A list of integers representing the lengths of the substrings. if not s: return [] # Dictionary to store the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: # We've reached the end of a partition partitions.append(idx - start + 1) start = idx + 1 return partitions"},{"question":"from typing import List, Tuple def max_non_overlapping_sessions(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of non-overlapping gaming sessions. Each session must have a game that lasts at least 30 minutes. Args: test_cases: List of tuples, each containing an integer N and a list of N integers representing the durations of the games in minutes. Returns: List of integers, each representing the maximum number of sessions for each test case. >>> max_non_overlapping_sessions([(5, [45, 20, 30, 15, 60]), (4, [10, 25, 35, 50])]) [3, 2] >>> max_non_overlapping_sessions([(3, [10, 20, 25])]) [0] def parse_input(input_string: str) -> List[Tuple[int, List[int]]]: Parse the input string into a list of test cases. Args: input_string: A string containing the number of test cases T, followed by T test cases. Each test case starts with an integer N, followed by N integers representing the durations of the games in minutes. Returns: List of tuples, each containing an integer N and a list of N integers representing the durations of the games in minutes. >>> parse_input(\\"2n5n45 20 30 15 60n4n10 25 35 50\\") [(5, [45, 20, 30, 15, 60]), (4, [10, 25, 35, 50])]","solution":"def max_non_overlapping_sessions(test_cases): results = [] for case in test_cases: N, durations = case durations.sort() count = 0 for duration in durations: if duration >= 30: count += 1 results.append(count) return results def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) durations = list(map(int, input_lines[index + 1].split())) test_cases.append((N, durations)) index += 2 return test_cases"},{"question":"def marathon_results(n, m, runners, records): Determines the order of runners completing a marathon. Args: n (int): The number of runners. m (int): The number of checkpoint records. runners (list): List of runner names. records (list): List of tuples of runner names and checkpoint numbers. Returns: list: List of runner names in the order they completed the marathon or a message if no runner completed. pass # Unit tests def test_sample_1(): n = 3 m = 13 runners = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] records = [ (\\"Alice\\", \\"10\\"), (\\"Bob\\", \\"20\\"), (\\"Charlie\\", \\"30\\"), (\\"Alice\\", \\"50\\"), (\\"Charlie\\", \\"50\\"), (\\"Bob\\", \\"60\\"), (\\"Charlie\\", \\"80\\"), (\\"Alice\\", \\"70\\"), (\\"Alice\\", \\"90\\"), (\\"Charlie\\", \\"90\\"), (\\"Bob\\", \\"100\\"), (\\"Alice\\", \\"100\\"), (\\"Charlie\\", \\"100\\") ] expected = [\\"Bob\\", \\"Alice\\", \\"Charlie\\"] assert marathon_results(n, m, runners, records) == expected def test_sample_2(): n = 4 m = 8 runners = [\\"David\\", \\"Eva\\", \\"Fran\\", \\"George\\"] records = [ (\\"David\\", \\"20\\"), (\\"Eva\\", \\"40\\"), (\\"Fran\\", \\"60\\"), (\\"George\\", \\"10\\"), (\\"Eva\\", \\"80\\"), (\\"George\\", \\"50\\"), (\\"David\\", \\"100\\"), (\\"Fran\\", \\"90\\") ] expected = [\\"David\\"] assert marathon_results(n, m, runners, records) == expected def test_no_completion(): n = 2 m = 5 runners = [\\"Hank\\", \\"Ivy\\"] records = [ (\\"Hank\\", \\"10\\"), (\\"Ivy\\", \\"20\\"), (\\"Hank\\", \\"30\\"), (\\"Ivy\\", \\"40\\"), (\\"Hank\\", \\"50\\") ] expected = [\\"No runner completed!\\"] assert marathon_results(n, m, runners, records) == expected def test_all_runners_either_no_checkpoints_or_not_100(): n = 3 m = 5 runners = [\\"James\\", \\"Kevin\\", \\"Laura\\"] records = [ (\\"James\\", \\"10\\"), (\\"Kevin\\", \\"20\\"), (\\"Kevin\\", \\"50\\"), (\\"Laura\\", \\"80\\"), (\\"James\\", \\"60\\") ] expected = [\\"No runner completed!\\"] assert marathon_results(n, m, runners, records) == expected def test_mixed_checkpoint_records(): n = 3 m = 9 runners = [\\"Martin\\", \\"Nina\\", \\"Oscar\\"] records = [ (\\"Martin\\", \\"10\\"), (\\"Nina\\", \\"20\\"), (\\"Oscar\\", \\"30\\"), (\\"Martin\\", \\"100\\"), (\\"Nina\\", \\"100\\"), (\\"Oscar\\", \\"100\\"), (\\"Martin\\", \\"90\\"), (\\"Nina\\", \\"50\\"), (\\"Oscar\\", \\"70\\") ] expected = [\\"Martin\\", \\"Nina\\", \\"Oscar\\"] assert marathon_results(n, m, runners, records) == expected","solution":"def marathon_results(n, m, runners, records): Determines the order of runners completing a marathon. Args: n (int): The number of runners. m (int): The number of checkpoint records. runners (list): List of runner names. records (list): List of tuples of runner names and checkpoint numbers. Returns: list: List of runner names in the order they completed the marathon. completion_order = [] # Dictionary to track the highest checkpoint each runner has reached checkpoints = {runner: (0, float('inf')) for runner in runners} # (highest_checkpoint, checkpoint_record_index) for index, (runner, checkpoint) in enumerate(records): checkpoint = int(checkpoint) if checkpoint == 100 and checkpoints[runner][0] < 100: # Runner completed the marathon completion_order.append((index, runner)) elif checkpoint > checkpoints[runner][0]: # Update highest checkpoint for the runner checkpoints[runner] = (checkpoint, index) completion_order.sort() # Sort by recording index to maintain the order if not completion_order: return [\\"No runner completed!\\"] return [runner for _, runner in completion_order]"},{"question":"def number_of_trees_around_garden(N, M): Returns the number of trees needed to plant around the perimeter of the garden. Parameters: N (int): Length of the garden. M (int): Width of the garden. Returns: int: Number of trees needed. pass def solve_gardens(test_cases): Solves the problem for multiple test cases and returns the results. Parameters: test_cases (list of tuples): List of tuples where each tuple contains two integers (N, M) Returns: list: List of results for each test case pass import pytest def test_number_of_trees_around_garden(): assert number_of_trees_around_garden(5, 3) == 16 assert number_of_trees_around_garden(7, 8) == 30 assert number_of_trees_around_garden(15, 10) == 50 assert number_of_trees_around_garden(1, 1) == 4 assert number_of_trees_around_garden(100, 100) == 400 def test_solve_gardens(): test_cases = [(5, 3), (7, 8), (15, 10)] expected = [16, 30, 50] assert solve_gardens(test_cases) == expected test_cases = [(1, 1), (100, 100), (2, 2)] expected = [4, 400, 8] assert solve_gardens(test_cases) == expected","solution":"def number_of_trees_around_garden(N, M): Returns the number of trees needed to plant around the perimeter of the garden. Parameters: N (int): Length of the garden. M (int): Width of the garden. Returns: int: Number of trees needed. return 2 * (N + M) def solve_gardens(test_cases): Solves the problem for multiple test cases and returns the results. Parameters: test_cases (list of tuples): List of tuples where each tuple contains two integers (N, M) Returns: list: List of results for each test case results = [] for N, M in test_cases: results.append(number_of_trees_around_garden(N, M)) return results"},{"question":"def can_partition(arr): Given an array of integers, determine if it is possible to partition the array into two subarrays (non-empty) such that the sum of the elements in the two subarrays is the same. Args: arr (List[int]): The input array of integers. Returns: bool: True if the array can be partitioned into two subarrays with equal sum, False otherwise. Example: >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False from solution import can_partition def test_example1(): arr = [1, 5, 11, 5] assert can_partition(arr) == True def test_example2(): arr = [1, 2, 3, 5] assert can_partition(arr) == False def test_all_same_elements(): arr = [10, 10, 10, 10] assert can_partition(arr) == True def test_no_partition_possible(): arr = [1, 2, 5] assert can_partition(arr) == False def test_large_elements(): arr = [100, 100, 100, 100] assert can_partition(arr) == True def test_single_element(): arr = [99] assert can_partition(arr) == False def test_large_array(): arr = [1] * 200 assert can_partition(arr) == True def test_odd_length_array(): arr = [1, 1, 1, 2, 2, 2, 2] assert can_partition(arr) == False","solution":"def can_partition(arr): total = sum(arr) if total % 2 != 0: return False target = total // 2 n = len(arr) dp = [False] * (target + 1) dp[0] = True for num in arr: for t in range(target, num - 1, -1): dp[t] = dp[t] or dp[t - num] return dp[target]"},{"question":"from typing import List def is_path_exists(wormholes: List[List[int]], S: int, D: int) -> bool: Determines if there exists a path from planet S to planet D using given wormholes. :param wormholes: List of wormholes where each wormhole is represented as [a, b] (one-way from a to b). :param S: Starting planet ID. :param D: Destination planet ID. :return: True if there is a path from S to D, else False. >>> is_path_exists([[0, 1]], 0, 1) True >>> is_path_exists([[0, 2], [2, 3], [3, 4]], 0, 4) True >>> is_path_exists([[0, 1], [1, 2], [2, 3]], 0, 4) False >>> is_path_exists([], 0, 5) False >>> is_path_exists([[0, 1], [1, 2]], 0, 0) True >>> is_path_exists([[0, 1], [2, 3]], 0, 3) False >>> is_path_exists([[0, 2], [2, 3], [1, 4], [3, 5], [2, 4], [0, 1]], 0, 5) True","solution":"from collections import defaultdict, deque from typing import List def is_path_exists(wormholes: List[List[int]], S: int, D: int) -> bool: Determines if there exists a path from planet S to planet D using given wormholes. :param wormholes: List of wormholes where each wormhole is represented as [a, b] (one-way from a to b). :param S: Starting planet ID. :param D: Destination planet ID. :return: True if there is a path from S to D, else False. # Create the graph as an adjacency list graph = defaultdict(list) for start, end in wormholes: graph[start].append(end) # Perform BFS to determine if there is a path from S to D queue = deque([S]) visited = set() while queue: current = queue.popleft() if current == D: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"from collections import Counter def can_form_palindrome(s: str, k: int) -> str: Determines if it is possible to rearrange the characters in the string s to form a palindrome such that the resulting palindrome contains at most k characters that do not appear in the original string. :param s: input string :param k: number of characters that do not appear in the original string :return: \\"YES\\" or \\"NO\\" >>> can_form_palindrome(\\"carrace\\", 2) \\"YES\\" >>> can_form_palindrome(\\"hello\\", 1) \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s, k): Determines if it is possible to rearrange the string to form a palindrome with at most \`k\` characters that do not appear in the original string. :param s: input string :param k: the allowed number of characters not in the original string :return: \\"YES\\" or \\"NO\\" count = Counter(s) # Count how many characters have an odd frequency. odd_count = sum(1 for c in count if count[c] % 2 != 0) # We need at most one character with an odd frequency for a valid palindrome. if odd_count - k <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_sample_without_emptying(N: int, A: List[int]) -> str: Determine if it is possible to sample the buffet without emptying any dish. >>> can_sample_without_emptying(5, [2, 3, 1, 4, 5]) \\"NO\\" >>> can_sample_without_emptying(3, [2, 2, 2]) \\"YES\\"","solution":"def can_sample_without_emptying(N, A): Determine if it is possible to sample the buffet without emptying any dish. :param N: Integer representing the number of dishes :param A: List of integers representing the quantity of each dish remaining :return: \\"YES\\" if sampling all dishes at least once is possible without emptying any, otherwise \\"NO\\" for quantity in A: if quantity <= 1: return \\"NO\\" return \\"YES\\" # Example # Input: 5, [2, 3, 1, 4, 5] # Output: NO # Input: 3, [2, 2, 2] # Output: YES"},{"question":"from typing import List def largestNumberWithAdjacentSwaps(digits: str, k: int) -> str: Determine the largest number that can be formed by arranging the digits with at most k adjacent swaps. >>> largestNumberWithAdjacentSwaps(\\"98765\\", 1) \\"98765\\" >>> largestNumberWithAdjacentSwaps(\\"254\\", 1) \\"524\\" >>> largestNumberWithAdjacentSwaps(\\"596\\", 2) \\"965\\" def test_example_case_1(): assert largestNumberWithAdjacentSwaps(\\"98765\\", 1) == \\"98765\\" def test_example_case_2(): assert largestNumberWithAdjacentSwaps(\\"254\\", 1) == \\"524\\" def test_example_case_3(): assert largestNumberWithAdjacentSwaps(\\"596\\", 2) == \\"965\\" def test_no_swaps(): assert largestNumberWithAdjacentSwaps(\\"321\\", 0) == \\"321\\" def test_all_identical_digits(): assert largestNumberWithAdjacentSwaps(\\"11111\\", 3) == \\"11111\\" def test_maximum_possible_swaps(): assert largestNumberWithAdjacentSwaps(\\"2134\\", 10) == \\"4321\\" def test_single_digit(): assert largestNumberWithAdjacentSwaps(\\"9\\", 2) == \\"9\\" def test_large_k_with_ordered_digits(): assert largestNumberWithAdjacentSwaps(\\"1234567890\\", 100) == \\"9876543210\\"","solution":"def largestNumberWithAdjacentSwaps(digits, k): digits = list(digits) n = len(digits) for i in range(n): if k <= 0: break max_digit_position = i for j in range(i + 1, min(i + k + 1, n)): if digits[j] > digits[max_digit_position]: max_digit_position = j for j in range(max_digit_position, i, -1): digits[j], digits[j - 1] = digits[j - 1], digits[j] k -= 1 return ''.join(digits)"},{"question":"def check_comment_appropriateness(s: str) -> str: Checks if the comment contains inappropriate sequences of '!' characters. :param s: A string consisting of lowercase letters and/or '!' characters. :return: \\"inappropriate\\" if there is any inappropriate sequence of '!' characters, \\"appropriate\\" otherwise. >>> check_comment_appropriateness(\\"hello world!\\") 'appropriate' >>> check_comment_appropriateness(\\"hello!! world!\\") 'inappropriate' >>> check_comment_appropriateness(\\"h!e!l!l!o!\\") 'appropriate' >>> check_comment_appropriateness(\\"!! !! !!\\") 'inappropriate'","solution":"def check_comment_appropriateness(s): Checks if the comment contains inappropriate sequences of '!' characters. :param s: A string consisting of lowercase letters and/or '!' characters. :return: \\"inappropriate\\" if there is any inappropriate sequence of '!' characters, \\"appropriate\\" otherwise. parts = s.split(' ') for part in parts: if '!!' in part: return \\"inappropriate\\" return \\"appropriate\\""},{"question":"def longest_common_difference_subsequence(n: int, sequence: List[int]) -> int: Determine the length of the longest subsequence with strictly increasing elements where the difference between consecutive elements is the same and as small as possible. >>> longest_common_difference_subsequence(6, [1, 5, 3, 9, 7, 11]) 3 >>> longest_common_difference_subsequence(5, [10, 30, 40, 5, 15]) 2","solution":"def longest_common_difference_subsequence(n, sequence): Returns the length of the longest subsequence where the difference between consecutive elements is the same and as small as possible. if n == 1: return 1 longest_length = 1 for i in range(n): for j in range(i + 1, n): diff = sequence[j] - sequence[i] current_length = 2 last_value = sequence[j] for k in range(j + 1, n): if sequence[k] - last_value == diff: current_length += 1 last_value = sequence[k] longest_length = max(longest_length, current_length) return longest_length"},{"question":"from typing import List def count_palindromic_pairs(words: List[str]) -> int: Given a list of words, find the number of pairs of indices (i, j) where 0 ≤ i < j < len(words) such that the concatenation of words[i] and words[j] forms a palindrome. >>> count_palindromic_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) 1 >>> count_palindromic_pairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]) 2","solution":"def is_palindrome(s): return s == s[::-1] def count_palindromic_pairs(words): count = 0 for i in range(len(words)): for j in range(i + 1, len(words)): if is_palindrome(words[i] + words[j]): count += 1 return count"},{"question":"def isValidParentheses(s: str) -> bool: Returns True if the string contains a valid combination of parentheses, and False otherwise. >>> isValidParentheses(\\"()\\") True >>> isValidParentheses(\\"()()\\") True >>> isValidParentheses(\\"(())\\") True >>> isValidParentheses(\\"(()\\") False >>> isValidParentheses(\\")(\\") False >>> isValidParentheses(\\"(()))\\") False","solution":"def isValidParentheses(s): Returns True if the string contains a valid combination of parentheses, and False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def user_with_max_disk_space(n, user_data): Determines the user(s) consuming the most disk space. Parameters: n (int): The number of users. user_data (list of tuples): Each tuple contains the user's file information: (userid, list of file sizes) Returns: str: The user(s) consuming the most disk space. def parse_input(input_string): Parses the input string into usable variables for user_with_max_disk_space. Parameters: input_string (str): The raw input string Returns: (int, list of tuples): Number of users and list of (userid, file sizes) import pytest from solution import user_with_max_disk_space, parse_input def test_parse_input(): input_string = \\"3n5 user123n100n300n200n50n150n4 Alicen400n100n200n300n3 Bobn500n400n300n\\" expected_output = (3, [('user123', [100, 300, 200, 50, 150]), ('Alice', [400, 100, 200, 300]), ('Bob', [500, 400, 300])]) assert parse_input(input_string) == expected_output def test_single_user(): n, user_data = 1, [(\\"user123\\", [100, 300, 200])] assert user_with_max_disk_space(n, user_data) == 'The user consuming the most disk space: user123.' def test_multiple_users_unique(): n, user_data = 3, [(\\"user123\\", [100, 300, 200, 50, 150]), (\\"Alice\\", [400, 100, 200, 300]), (\\"Bob\\", [500, 400, 300])] assert user_with_max_disk_space(n, user_data) == 'The user consuming the most disk space: Bob.' def test_multiple_users_tied(): n, user_data = 4, [(\\"UserA\\", [100, 100, 100]), (\\"UserB\\", [100, 100, 100]), (\\"UserC\\", [200, 200, 200]), (\\"UserD\\", [200, 200, 200])] assert user_with_max_disk_space(n, user_data) == 'The user consuming the most disk space: UserC, UserD.' def test_complex_case(): input_string = \\"2n3 Dann750n250n500n4 Even300n300n300n250n\\" n, user_data = parse_input(input_string) assert user_with_max_disk_space(n, user_data) == 'The user consuming the most disk space: Dan.' def test_all_users_tied(): n, user_data = 2, [(\\"A\\", [100, 100]), (\\"B\\", [200])] assert user_with_max_disk_space(n, user_data) == 'The user consuming the most disk space: A, B.'","solution":"def user_with_max_disk_space(n, user_data): Determines the user(s) consuming the most disk space. Parameters: n (int): The number of users. user_data (list of tuples): Each tuple contains the user's file information: (userid, list of file sizes) Returns: str: The user(s) consuming the most disk space. max_space = 0 users = {} for userid, files in user_data: total_size = sum(files) if total_size > max_space: max_space = total_size users = {userid} elif total_size == max_space: users.add(userid) sorted_users = sorted(users) return f\\"The user consuming the most disk space: {', '.join(sorted_users)}.\\" def parse_input(input_string): Parses the input string into usable variables for user_with_max_disk_space. Parameters: input_string (str): The raw input string Returns: (int, list of tuples): Number of users and list of (userid, file sizes) lines = input_string.strip().split('n') n = int(lines[0].strip()) index = 1 user_data = [] for _ in range(n): fi, userid = lines[index].split() fi = int(fi) index += 1 files = [] for _ in range(fi): files.append(int(lines[index].strip())) index += 1 user_data.append((userid, files)) return n, user_data"},{"question":"def digit_count(s): Returns a dictionary with the count of each digit in the string s. Parameters: s (str): The input string consisting of digits. Returns: dict: A dictionary where keys are digits and values are the counts. Returns an empty dictionary if the string is empty. Returns 'undefined' if the input is not a string. Examples: >>> digit_count('1122334455') {'1': 2, '2': 2, '3': 2, '4': 2, '5': 2} >>> digit_count('312034') {'3': 2, '1': 1, '2': 1, '0': 1, '4': 1} >>> digit_count('') {} >>> digit_count(12345) 'undefined' >>> digit_count(None) 'undefined' >>> digit_count('555021321') {'5': 3, '0': 1, '2': 2, '1': 2, '3': 1}","solution":"def digit_count(s): Returns a dictionary with the count of each digit in the string s. Parameters: s (str): The input string consisting of digits. Returns: dict: A dictionary where keys are digits and values are the counts. Returns an empty dictionary if the string is empty. Returns 'undefined' if the input is not a string. if not isinstance(s, str): return 'undefined' count_dict = {} for char in s: if char.isdigit(): if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def caesar_cipher(s: str, n: int) -> str: Transform a string by shifting each alphabetical character n positions up the alphabet, wrapping around if necessary. Maintain case and leave non-alphabetical characters unaltered. >>> caesar_cipher(\\"Hello, World!\\", 3) \\"Khoor, Zruog!\\" >>> caesar_cipher(\\"abcXYZ\\", 2) \\"cdeZAB\\" >>> caesar_cipher(\\"Rotate123\\", 10) \\"Bydziq123\\"","solution":"def caesar_cipher(s: str, n: int) -> str: def shift_char(c, n): if 'a' <= c <= 'z': return chr(((ord(c) - ord('a') + n) % 26) + ord('a')) elif 'A' <= c <= 'Z': return chr(((ord(c) - ord('A') + n) % 26) + ord('A')) else: return c return ''.join(shift_char(c, n) for c in s)"},{"question":"def minRemoveToMakeValid(sequence: str) -> int: Returns the minimum number of parentheses that must be removed to make the sequence valid. >>> minRemoveToMakeValid(\\"())()(((\\") 4 >>> minRemoveToMakeValid(\\"((())\\") 1 >>> minRemoveToMakeValid(\\"()()\\") 0 >>> minRemoveToMakeValid(\\"\\") 0 >>> minRemoveToMakeValid(\\"(((\\") 3 >>> minRemoveToMakeValid(\\")))\\") 3 >>> minRemoveToMakeValid(\\")()(\\") 2 >>> minRemoveToMakeValid(\\"((())())\\") 0","solution":"def minRemoveToMakeValid(sequence): Returns the minimum number of parentheses that must be removed to make the sequence valid. open_count = 0 remove_count = 0 # First pass to find unmatched closing parentheses for c in sequence: if c == '(': open_count += 1 elif c == ')': if open_count > 0: open_count -= 1 else: remove_count += 1 # open_count now contains the number of unmatched opening parentheses return remove_count + open_count"},{"question":"def findNextPalindrome(N: int) -> int: Returns the smallest palindrome greater than N. >>> findNextPalindrome(123) 131 >>> findNextPalindrome(99) 101","solution":"def findNextPalindrome(N): Returns the smallest palindrome greater than N. def is_palindrome(x): return str(x) == str(x)[::-1] current_number = N + 1 while not is_palindrome(current_number): current_number += 1 return current_number"},{"question":"def no_adjacent_repeats(s: str) -> List[str]: Returns a list of all distinct valid permutations of s where no two adjacent characters are the same. >>> no_adjacent_repeats(\\"aab\\") [\\"aba\\"] >>> no_adjacent_repeats(\\"abc\\") sorted(['abc', 'acb', 'bac', 'bca', 'cab', 'cba'])","solution":"from itertools import permutations def no_adjacent_repeats(s): Returns a list of all distinct valid permutations of s where no two adjacent characters are the same. all_perms = set(permutations(s)) valid_perms = [\\"\\".join(p) for p in all_perms if all(p[i] != p[i+1] for i in range(len(p) - 1))] return valid_perms"},{"question":"def count_subsequences(s1: str, s2: str) -> int: Counts the number of times s2 can be found as a subsequence in s1. Parameters: s1 (str): The string in which subsequences are searched. s2 (str): The string which is searched as a subsequence. Returns: int: The number of times s2 can be found as a subsequence in s1. >>> count_subsequences(\\"babgbag\\", \\"bag\\") 5 >>> count_subsequences(\\"abcdef\\", \\"xyz\\") 0 >>> count_subsequences(\\"abc\\",\\"abc\\") 1 >>> count_subsequences(\\"abc\\", \\"abcd\\") 0 >>> count_subsequences(\\"abc\\", \\"\\") 1 >>> count_subsequences(\\"\\", \\"abc\\") 0 >>> count_subsequences(\\"aaaaa\\", \\"aa\\") 10 >>> count_subsequences(\\"bbbb\\", \\"b\\") 4","solution":"def count_subsequences(s1, s2): Counts the number of times s2 can be found as a subsequence in s1. Parameters: s1 (str): The string in which subsequences are searched. s2 (str): The string which is searched as a subsequence. Returns: int: The number of times s2 can be found as a subsequence in s1. m, n = len(s1), len(s2) # dp array where dp[i][j] is the number of ways to get s2[0..j-1] in s1[0..i-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # There's exactly one way to match an empty s2 (by deleting all characters) for i in range(m + 1): dp[i][0] = 1 for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] # The result is the number of ways to form s2 in s1 return dp[m][n]"},{"question":"def climbStairs(N: int) -> int: There is a staircase with N steps, and you can climb either 1, 2, or 3 steps at a time. Find the number of distinct ways you can climb to the top of the staircase. >>> climbStairs(3) 4 >>> climbStairs(4) 7 >>> climbStairs(5) 13 >>> climbStairs(6) 24 >>> climbStairs(7) 44 >>> climbStairs(10) 274 >>> climbStairs(1) 1 >>> climbStairs(2) 2 >>> climbStairs(20) 121415 >>> climbStairs(10000) > 0 True >>> climbStairs(0) 0","solution":"def climbStairs(N): Returns the number of distinct ways to climb to the top of the staircase with N steps. Each step can be 1, 2, or 3 steps at a time. MOD = 10**9 + 7 if N == 0: return 0 if N == 1: return 1 if N == 2: return 2 if N == 3: return 4 ways = [0] * (N + 1) ways[0] = 1 ways[1] = 1 ways[2] = 2 ways[3] = 4 for i in range(4, N + 1): ways[i] = (ways[i-1] + ways[i-2] + ways[i-3]) % MOD return ways[N]"},{"question":"from typing import List, Tuple def terrain_navigation(test_cases: List[Tuple[int, int, List[List[int], Tuple[int, int], Tuple[int, int]]]]) -> List[int]: Determine the minimum number of steps required to move from the starting position to the destination position. Args: test_cases (List[Tuple[int, int, List[List[int]], Tuple[int, int], Tuple[int, int]]]]): A list of test cases where each test case contains: - N (int): The number of rows in the grid. - M (int): The number of columns in the grid. - grid (List[List[int]]): The terrain grid. - (Sx, Sy) (Tuple[int, int]): The starting position. - (Dx, Dy) (Tuple[int, int]): The destination position. Returns: List[int]: The minimum number of steps required to reach the destination from the starting position for each test case. If it is not possible to reach the destination, return -1. Example: >>> terrain_navigation([ ... (5, 5, [ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ], (0, 0), (4, 4)), ... (3, 3, [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 0] ... ], (0, 0), (3, 3)) ... ]) == [8, 6] >>> terrain_navigation([ ... (3, 3, [ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0], ... ], (0, 0), (2, 2)) ... ]) == [-1] >>> terrain_navigation([ ... (3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0], ... ], (0, 0), (2, 2)) ... ]) == [4] >>> terrain_navigation([ ... (3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0], ... ], (2, 2), (2, 2)) ... ]) == [0] >>> terrain_navigation([ ... (2, 2, [ ... [0, 0], ... [0, 0], ... ], (0, 0), (1, 1)) ... ]) == [2]","solution":"from collections import deque def min_steps(grid, sx, sy, dx, dy): if sx == dx and sy == dy: return 0 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy, 0)]) # (x, y, step_count) visited = [[False] * m for _ in range(n)] visited[sx][sy] = True while queue: x, y, steps = queue.popleft() for dxn, dyn in directions: nx, ny = x + dxn, y + dyn if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 0: if nx == dx and ny == dy: return steps + 1 queue.append((nx, ny, steps + 1)) visited[nx][ny] = True return -1 def terrain_navigation(test_cases): results = [] for case in test_cases: N, M, grid, (Sx, Sy), (Dx, Dy) = case result = min_steps(grid, Sx, Sy, Dx, Dy) results.append(result) return results"},{"question":"def num_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Determine the number of connected components in an undirected graph. Parameters: n (int): The number of nodes in the graph. edges (List[Tuple[int, int]]): List of edges, where each edge is represented as a tuple (u, v) of two integers. Returns: int: The number of connected components in the graph. Examples: >>> num_connected_components(6, [(1, 2), (2, 3), (4, 5), (5, 6), (4, 6)]) 2 >>> num_connected_components(1, []) 1","solution":"def num_connected_components(n, edges): def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) adj_list = {i: [] for i in range(1, n+1)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = set() num_components = 0 for node in range(1, n+1): if node not in visited: visited.add(node) dfs(node, visited, adj_list) num_components += 1 return num_components"},{"question":"import math from typing import List, Tuple def closest_repair_station_distance(drone_coordinate: Tuple[int, int], repair_stations: List[Tuple[int, int]]) -> int: Calculate the closest distance between a drone and repair stations. Args: drone_coordinate (Tuple[int, int]): The coordinate of the drone. repair_stations (List[Tuple[int, int]]): The coordinates of the repair stations. Returns: int: The distance to the closest repair station, rounded to the nearest integer. >>> closest_repair_station_distance((100, 100), [(150, 150), (250, 250)]) 71 >>> closest_repair_station_distance((200, 200), [(150, 150), (250, 250)]) 71 pass # Your implementation here def process_test_case(n: int, m: int, drones: List[Tuple[int, int]], repair_stations: List[Tuple[int, int]]) -> List[int]: For a given test case, determine the closest repair station distance for each drone. Args: n (int): The number of drones. m (int): The number of repair stations. drones (List[Tuple[int, int]]): The coordinates of the drones. repair_stations (List[Tuple[int, int]]): The coordinates of the repair stations. Returns: List[int]: A list containing the distances to the closest repair stations for each drone. >>> process_test_case(3, 2, [(100, 100), (200, 200), (300, 300)], [(150, 150), (250, 250)]) [71, 71, 71] pass # Your implementation here def find_closest_distances_to_stations(test_cases: List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]) -> List[str]: Given the input test cases, find the distance to the closest repair station for each drone. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]], List[Tuple[int, int]]]]): The test case information. Returns: List[str]: A string for each test case in the format \\"Case #X: d1 d2 d3 ... dN\\". >>> find_closest_distances_to_stations([(3, 2, [(100, 100), (200, 200), (300, 300)], [(150, 150), (250, 250)])]) [\\"Case #1: 71 71 71\\"] pass # Your implementation here","solution":"import math def closest_repair_station_distance(drone_coordinate, repair_stations): Calculate the closest distance between a drone and repair stations. min_distance = float('inf') for rx, ry in repair_stations: distance = math.sqrt((rx - drone_coordinate[0]) ** 2 + (ry - drone_coordinate[1]) ** 2) if distance < min_distance: min_distance = distance return round(min_distance) def process_test_case(n, m, drones, repair_stations): For a given test case, determine the closest repair station distance for each drone. result = [] for drone in drones: result.append(closest_repair_station_distance(drone, repair_stations)) return result def find_closest_distances_to_stations(test_cases): Given the input test cases, find the distance to the closest repair station for each drone. Returns: A string for each test case in the format \\"Case #X: d1 d2 d3 ... dN\\", where X is the test case number. output = [] for idx, (n, m, drones, repair_stations) in enumerate(test_cases): distances = process_test_case(n, m, drones, repair_stations) case_result = f\\"Case #{idx + 1}: {' '.join(map(str, distances))}\\" output.append(case_result) return output"},{"question":"def min_operations_to_make_even(arr: List[int]) -> int: Given an array, returns the minimum number of operations required to make all elements even. >>> min_operations_to_make_even([4, 7, 12, 9, 5]) 3 >>> min_operations_to_make_even([3, 8, -3]) 2 >>> min_operations_to_make_even([2, 4, 6, 8, 10]) 0 >>> min_operations_to_make_even([-1, -3, -5]) 3 >>> min_operations_to_make_even([0, -2, -4, -6]) 0 >>> min_operations_to_make_even([]) 0 def process_test_cases(test_cases: List[List[int]]) -> List[int]: Given multiple test cases, returns a list of results where each result is the minimum number of operations required for the respective test case. >>> process_test_cases([[4, 7, 12, 9, 5], [3, 8, -3]]) [3, 2] >>> process_test_cases([[2, 4, 6, 8, 10], [-1, -3, -5], [0, -2, -4, -6]]) [0, 3, 0] >>> process_test_cases([[]]) [0]","solution":"def min_operations_to_make_even(arr): Given an array, returns the minimum number of operations required to make all elements even. operations = 0 for num in arr: if num % 2 != 0: operations += 1 return operations def process_test_cases(test_cases): Given multiple test cases, returns a list of results where each result is the minimum number of operations required for the respective test case. results = [] for test_case in test_cases: results.append(min_operations_to_make_even(test_case)) return results"},{"question":"def singleNumber(nums): Returns the single number in the list where every element appears twice except for one. Uses XOR to achieve O(N) time complexity and O(1) space complexity. >>> singleNumber([2, 2, 3, 4, 4, 5, 5]) 3 >>> singleNumber([1, 1, 2, 2, 3, 3, 4]) 4 >>> singleNumber([0, 1, 0, 1, 99]) 99 >>> singleNumber([42]) 42 >>> singleNumber([-1, -1, -2, -2, -3]) -3 >>> singleNumber([1, -1, 2, -2, 3, 3, 2, -2, -1]) 1","solution":"def singleNumber(nums): Returns the single number in the list where every element appears twice except for one. Uses XOR to achieve O(N) time complexity and O(1) space complexity. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def maxProfit(prices: List[int], k: int) -> int: Determine the maximum profit you can achieve by completing exactly one transaction exactly k times. You are given an array 'prices' where each 'prices[i]' is the price of a given stock on the ith day, and an integer 'k'. Note that you cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Args: prices (List[int]): the prices of the stock on each day k (int): the exact number of transactions to be completed Returns: int: the maximum profit after completing exactly k transactions Examples: >>> maxProfit([3,3,5,0,0,3,1,4], 2) 6 >>> maxProfit([1,2,3,4,5], 2) 4 >>> maxProfit([7,6,4,3,1], 2) 0","solution":"def maxProfit(prices, k): n = len(prices) if n == 0 or k == 0: return 0 # If k is larger than the number of days/2, it means we can complete as many transactions as we want. if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # Initialize dp array dp = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_diff = -prices[0] for i in range(1, n): dp[t][i] = max(dp[t][i - 1], prices[i] + max_diff) max_diff = max(max_diff, dp[t - 1][i] - prices[i]) return dp[k][n - 1]"},{"question":"def find_playlist_subset(songs: List[int], L: int, R: int) -> Tuple[str, List[int]]: Determines if there is a subset of the songs that satisfies the total duration requirement. Args: songs (List[int]): A list of song lengths in seconds. L (int): The minimum total duration of the playlist. R (int): The maximum total duration of the playlist. Returns: Tuple[str, List[int]]: - \\"Yes\\" and the list of song lengths in the subset if a valid subset is found. - \\"No\\" and an empty list if no valid subset exists. Examples: >>> find_playlist_subset([100, 300, 400, 500, 700], 500, 1200) ('Yes', [500, 700]) >>> find_playlist_subset([100, 200, 300], 1000, 1500) ('No', []) pass def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) L = int(data[1]) R = int(data[2]) songs = list(map(int, data[3:])) result, subset = find_playlist_subset(songs, L, R) if result == \\"Yes\\": print(result) for song in subset: print(song) else: print(result) if __name__ == \\"__main__\\": main()","solution":"def find_playlist_subset(songs, L, R): Determines if there is a subset of songs whose total length is within the range [L, R]. n = len(songs) possible_sums = {0: []} for song in songs: new_sums = {} for s in possible_sums: new_sum = s + song if new_sum <= R: new_sums[new_sum] = possible_sums[s] + [song] possible_sums.update(new_sums) for total in possible_sums: if L <= total <= R: return \\"Yes\\", possible_sums[total] return \\"No\\", [] def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) L = int(data[1]) R = int(data[2]) songs = list(map(int, data[3:])) result, subset = find_playlist_subset(songs, L, R) if result == \\"Yes\\": print(result) for song in subset: print(song) else: print(result) if __name__ == \\"__main__\\": main()"},{"question":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None def findDeepestNode(root: Node) -> int: Given a binary tree, this function returns the value of the deepest node in the binary tree. If there are multiple nodes at the deepest level, return the leftmost one. >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> root.left.right = Node(5) >>> root.left.right.right = Node(6) >>> findDeepestNode(root) 6 >>> root = Node(7) >>> root.left = Node(8) >>> root.right = Node(9) >>> root.left.left = Node(10) >>> findDeepestNode(root) 10","solution":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None def findDeepestNode(root): if not root: return None queue = [root] while queue: current = queue.pop(0) if current.right: queue.append(current.right) if current.left: queue.append(current.left) return current.data"},{"question":"def countBalancedStrings(T: int, lengths: List[int]) -> List[int]: Determine the number of balanced strings for each given length N. A balanced string is defined as a string consisting of characters 'a' and 'b' with the same number of 'a's and 'b's. >>> countBalancedStrings(3, [2, 4, 5]) [2, 6, 0] >>> countBalancedStrings(1, [0]) [1] >>> countBalancedStrings(1, [6]) [20] >>> countBalancedStrings(1, [7]) [0] >>> countBalancedStrings(1, [1000]) [159835829] >>> countBalancedStrings(4, [8, 3, 10, 15]) [70, 0, 252, 0] from solution import countBalancedStrings def test_count_balanced_strings_example_cases(): assert countBalancedStrings(3, [2, 4, 5]) == [2, 6, 0] def test_count_balanced_strings_length_zero(): assert countBalancedStrings(1, [0]) == [1] def test_count_balanced_strings_single_even_length(): assert countBalancedStrings(1, [6]) == [20] def test_count_balanced_strings_single_odd_length(): assert countBalancedStrings(1, [7]) == [0] def test_count_balanced_strings_max_length(): assert countBalancedStrings(1, [1000]) == [159835829] def test_count_balanced_strings_mixed_lengths(): assert countBalancedStrings(4, [8, 3, 10, 15]) == [70, 0, 252, 0]","solution":"MOD = 10**9 + 7 def countBalancedStrings(T, lengths): def binomial_coeff(n, k): if k > n: return 0 res = 1 for i in range(k): res = res * (n - i) // (i + 1) return res max_length = max(lengths) if lengths else 0 dp = [0] * (max_length + 1) for i in range(0, max_length + 1, 2): n = i // 2 dp[i] = binomial_coeff(i, n) % MOD results = [] for length in lengths: if length % 2 != 0: results.append(0) else: results.append(dp[length]) return results"},{"question":"def can_reduce_to_one_element(test_cases): Determine if it is possible to reduce the array to a single element by removing adjacent elements with even sums in each test case. >>> can_reduce_to_one_element([(3, [1, 2, 3]), (4, [4, 5, 6, 7]), (3, [2, 4, 6])]) [\\"NO\\", \\"NO\\", \\"YES\\"] >>> can_reduce_to_one_element([(5, [1, 3, 5, 7, 9]), (2, [4, 4]), (6, [2, 8, 10, 6, 4, 14])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_reduce_to_one_element([(4, [1, 3, 5, 7]), (6, [9, 11, 13, 15, 17, 19])]) [\\"YES\\", \\"YES\\"] >>> can_reduce_to_one_element([(3, [2, 4, 6]), (5, [8, 10, 12, 14, 16])]) [\\"YES\\", \\"YES\\"] >>> can_reduce_to_one_element([(2, [1, 3]), (2, [2, 4])]) [\\"YES\\", \\"YES\\"]","solution":"def can_reduce_to_one_element(test_cases): results = [] for n, a in test_cases: # Count even and odd numbers in the array even_count = sum(1 for x in a if x % 2 == 0) odd_count = n - even_count # If there are both even and odd numbers # we cannot reduce it to a single element if even_count > 0 and odd_count > 0: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome, ignoring case and non-alphanumeric characters. Parameters: s (str): input string Returns: bool: True if the string is a palindrome, False otherwise >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Hello World\\") False >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"!!!\\") True # Write your code here","solution":"import re def is_palindrome(s): Determine if the given string is a palindrome, ignoring case and non-alphanumeric characters. Parameters: s (str): input string Returns: bool: True if the string is a palindrome, False otherwise # Use regular expressions to remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned == cleaned[::-1]"},{"question":"def min_number_of_groups(heights: List[int]) -> int: Returns the minimum number of groups needed such that groups are in non-decreasing order. >>> min_number_of_groups([1, 2, 3, 4, 5]) == 1 >>> min_number_of_groups([5, 4, 3, 2, 1]) == 5 >>> min_number_of_groups([3, 3, 2, 2, 1, 1]) == 3 >>> min_number_of_groups([1, 2, 1, 2, 3, 1]) == 3 >>> min_number_of_groups([10]) == 1 >>> min_number_of_groups([]) == 0 >>> min_number_of_groups([2, 2, 2, 2, 2]) == 1 >>> min_number_of_groups([1, 3, 3, 4, 5]) == 1 >>> min_number_of_groups([1, 4, 3, 2, 5]) == 3","solution":"def min_number_of_groups(heights): Returns the minimum number of groups needed such that groups are in non-decreasing order. if not heights: return 0 groups = 1 for i in range(1, len(heights)): if heights[i] < heights[i - 1]: groups += 1 return groups"},{"question":"def numDecodings(s: str) -> int: Returns the number of ways to decode the given string. >>> numDecodings(\\"226\\") 3 >>> numDecodings(\\"06\\") 0 >>> numDecodings(\\"12\\") 2 >>> numDecodings(\\"10\\") 1 >>> numDecodings(\\"1234\\") 3 >>> numDecodings(\\"0\\") 0","solution":"def numDecodings(s: str) -> int: Returns the number of ways to decode the given string. :param s: String containing the encoded message :return: Total number of ways to decode the string if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2, n + 1): if 1 <= int(s[i - 1:i]) <= 9: dp[i] += dp[i - 1] if 10 <= int(s[i - 2:i]) <= 26: dp[i] += dp[i - 2] return dp[-1]"},{"question":"def replace_with_evil(original_str: str, evil_list: List[str]) -> str: Replaces all occurrences of words in evil_list with \\"EVIL\\" in the original_str, in a case-insensitive manner and keeping the original casing of the rest of the string intact. >>> replace_with_evil(\\"The Cat is sleeping on the catalog.\\", [\\"cat\\"]) \\"The EVIL is sleeping on the catalog.\\" >>> replace_with_evil(\\"This is a secret mission. Secret operations should remain unknown.\\", [\\"secret\\", \\"unknown\\"]) \\"This is a EVIL mission. EVIL operations should remain EVIL.\\"","solution":"import re def replace_with_evil(original_str, evil_list): Replaces all occurrences of words in evil_list with \\"EVIL\\" in the original_str, in a case-insensitive manner and keeping the original casing of the rest of the string intact. def replace(match): return 'EVIL' pattern = r'b(' + '|'.join(map(re.escape, evil_list)) + r')b' new_str = re.sub(pattern, replace, original_str, flags=re.IGNORECASE) return new_str"},{"question":"def rearrange_even_difference(arr): Rearrange the array such that the difference between any two adjacent elements is always even. If no such arrangement is possible, return 'Not Possible'. >>> rearrange_even_difference([3, 8, 14, 2, 6]) # example input and output [8, 6, 14, 2, 3]","solution":"def rearrange_even_difference(arr): # Split the array into odd and even numbers even_numbers = [x for x in arr if x % 2 == 0] odd_numbers = [x for x in arr if x % 2 != 0] # If there are all evens or all odds, return the original list (since all differences will be even) if len(even_numbers) == len(arr) or len(odd_numbers) == len(arr): return \\"Not Possible\\" # Combine evens and odds in succession to satisfy the conditions return even_numbers + odd_numbers # Example usage n = 5 array = [3, 8, 14, 2, 6] print(rearrange_even_difference(array))"},{"question":"def unique_paths(m, n): Calculate the number of unique paths in an M x N grid. :param m: number of rows :param n: number of columns :return: number of unique paths >>> unique_paths(2, 3) == 3 >>> unique_paths(3, 3) == 6 >>> unique_paths(4, 4) == 20 def unique_paths_multiple_cases(test_cases): Calculate the number of unique paths in an M x N grid for multiple test cases. :param test_cases: list of tuples (m, n) :return: list of number of unique paths for each test case >>> unique_paths_multiple_cases([(2, 3), (3, 3), (4, 4)]) == [3, 6, 20] >>> unique_paths_multiple_cases([(1, 1), (5, 5), (3, 7), (7, 3)]) == [1, 70, 28, 28]","solution":"def unique_paths(m, n): Calculate the number of unique paths in an M x N grid. :param m: number of rows :param n: number of columns :return: number of unique paths # Create a 2D array to store results of subproblems dp = [[0] * n for _ in range(m)] # Initialize the first row and first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def unique_paths_multiple_cases(test_cases): results = [] for m, n in test_cases: results.append(unique_paths(m, n)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression represented as a string consisting of non-negative integers and the operators +, -, *, / separated by spaces. The function assumes the input is always a valid expression. >>> evaluate_expression('2 + 2') 4 >>> evaluate_expression('5 - 3') 2 >>> evaluate_expression('4 * 3') 12 >>> evaluate_expression('10 / 2') 5 >>> evaluate_expression('2 + 3 * 4') 14 >>> evaluate_expression('10 + 2 * 6 - 3 / 2') 21 >>> evaluate_expression('5 * 6 / 2 + 3 - 1') 17 >>> evaluate_expression(' 10 + 2 * 6 - 3 / 2 ') 21 >>> evaluate_expression('0 + 0 * 0 / 1') 0 >>> evaluate_expression('0') 0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression represented as a string consisting of non-negative integers and the operators +, -, *, / separated by spaces. The function assumes the input is always a valid expression. def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if '0' <= tokens[i] <= '9': val = 0 while i < len(tokens) and '0' <= tokens[i] <= '9': val = val * 10 + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] in ('+', '-', '*', '/'): while (ops and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while ops: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[0] return evaluate(expression)"},{"question":"def longest_mountain_subsequence(heights): Find the length of the longest subsequence of mountains following the described pattern. >>> longest_mountain_subsequence([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain_subsequence([1, 2, 3, 4, 5]) 0 # Implement the function def solve(test_cases): Solve the problem for multiple test cases >>> solve([[2, 1, 4, 7, 3, 2, 5], [1, 2, 3, 4, 5]]) [5, 0] # Implement the function","solution":"def longest_mountain_subsequence(heights): N = len(heights) if N < 3: return 0 up = [0] * N down = [0] * N # Fill up lengths for i in range(1, N): if heights[i] > heights[i - 1]: up[i] = up[i - 1] + 1 # Fill down lengths for i in range(N - 2, -1, -1): if heights[i] > heights[i + 1]: down[i] = down[i + 1] + 1 max_len = 0 for i in range(1, N - 1): if up[i] > 0 and down[i] > 0: # Only consider peaks max_len = max(max_len, up[i] + down[i] + 1) return max_len def solve(test_cases): results = [] for heights in test_cases: results.append(longest_mountain_subsequence(heights)) return results"},{"question":"def max_people_on_ride(n: int, W: int, weights: List[int]) -> int: Determines the maximum number of people that can fit on the ride without exceeding the weight limit. Parameters: n (int): Number of people in the queue. W (int): Maximum allowable weight. weights (list of int): Weights of people in the queue. Returns: int: Maximum number of people that can be safely fitted onto the ride. >>> max_people_on_ride(5, 200, [50, 75, 90, 60, 85]) 3 >>> max_people_on_ride(4, 100, [30, 40, 10, 20]) 4","solution":"def max_people_on_ride(n, W, weights): Determines the maximum number of people that can fit on the ride without exceeding the weight limit. Parameters: n (int): Number of people in the queue. W (int): Maximum allowable weight. weights (list of int): Weights of people in the queue. Returns: int: Maximum number of people that can be safely fitted onto the ride. weights.sort() current_weight = 0 count = 0 for weight in weights: if current_weight + weight <= W: current_weight += weight count += 1 else: break return count"},{"question":"def stringReverser(s): Reverses each word in a given string s while maintaining the original word order. Arguments: s : str : input string containing only lowercase letters and spaces Returns: str : a new string with each word reversed while maintaining the original word order or 'Not a valid string' if the input s is not a valid string. EXAMPLES: >>> stringReverser('hello world') 'olleh dlrow' >>> stringReverser('string reverser') 'gnirts resrever' >>> stringReverser(' ') ' ' >>> stringReverser(42) 'Not a valid string' >>> stringReverser([]) 'Not a valid string' # Implement the function here","solution":"def stringReverser(s): Reverses each word in a given string s while maintaining the original word order. Arguments: s : str : input string containing only lowercase letters and spaces Returns: str : a new string with each word reversed while maintaining the original word order or 'Not a valid string' if the input s is not a valid string. if not isinstance(s, str) or len(s) == 0: return \\"Not a valid string\\" return ' '.join(word[::-1] for word in s.split())"},{"question":"def word_search(grid: List[List[str]], words: List[str]) -> List[str]: Given a 2D grid of characters and a list of words, find all words in the grid that exist in the list. >>> word_search([ ... ['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v'] ... ], [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"]) [\\"eat\\",\\"oath\\"] >>> word_search([], [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"]) [] >>> word_search([ ... ['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v'] ... ], []) [] >>> word_search([ ... ['o','a','a','n'], ... ['e','t','a','e'], ... ['i','h','k','r'], ... ['i','f','l','v'] ... ], [\\"peach\\", \\"tree\\", \\"leaf\\"]) [] >>> word_search([ ... ['a'] ... ], [\\"a\\"]) [\\"a\\"]","solution":"class Solver(): def __init__(self): self.foundWords = set() def findWords(self, board, words): self.board = board self.words = set(words) for i in range(len(board)): for j in range(len(board[0])): self._dfs(i, j, \\"\\") return list(self.foundWords) def _dfs(self, i, j, prefix): if not (0 <= i < len(self.board) and 0 <= j < len(self.board[0])): return if self.board[i][j] == \\"#\\": return current_char = self.board[i][j] self.board[i][j] = \\"#\\" # mark as visited prefix += current_char if prefix in self.words: self.foundWords.add(prefix) for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: self._dfs(x, y, prefix) self.board[i][j] = current_char # unmark # Sample usage def word_search(grid, words): solver = Solver() return solver.findWords(grid, words)"},{"question":"def longest_unique_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with unique elements. >>> longest_unique_subarray([4, 2, 4, 5, 6]) == 4 >>> longest_unique_subarray([1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray([1, 1, 1, 1, 1]) == 1 >>> longest_unique_subarray([1, 2, 3, 1, 2, 3, 4]) == 4 >>> longest_unique_subarray([]) == 0 >>> longest_unique_subarray([1, 2, 2, 3, 4, 4, 5]) == 3 >>> longest_unique_subarray([7, 8, 9, 7, 8, 9, 10]) == 4 >>> longest_unique_subarray([1, 2, 1, 3, 4, 3, 5]) == 4 >>> longest_unique_subarray([1, 2, 3, 4, 2, 5, 6]) == 5","solution":"def longest_unique_subarray(arr): Returns the length of the longest contiguous subarray with unique elements. max_len = 0 start = 0 seen = {} for end, num in enumerate(arr): if num in seen and seen[num] >= start: start = seen[num] + 1 seen[num] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def solve(input_str: str) -> str: You are given two simple polygons defined by their vertices in the plane. Write a program to calculate the area of the intersection of the two polygons. The input consists of several datasets. Each dataset starts with the number of vertices, n1, of the first polygon, followed by the coordinates (x1, y1), (x2, y2), ... (xn1, y1), in order. The next line has the number of vertices, n2, of the second polygon, followed by the coordinates (x1, y1), (x2, y2), ... (xn2, y2). There are no self-intersecting polygons in the dataset. The end of the input is indicated by a line with a zero. Args: input_str (str): A string with the number of vertices and their coordinates Returns: str: The area of the intersection of the two polygons as a string with error not greater than 0.0001 pass # Example test cases from solve import solve def test_example_input(): input_str = 4 0 0 4 0 4 4 0 4 4 2 2 6 2 6 6 2 6 0 expected_output = \\"4.0000\\" assert solve(input_str).strip() == expected_output def test_no_intersection(): input_str = 4 0 0 2 0 2 2 0 2 4 3 3 5 3 5 5 3 5 0 expected_output = \\"0.0000\\" assert solve(input_str).strip() == expected_output def test_full_overlap(): input_str = 4 0 0 4 0 4 4 0 4 4 0 0 4 0 4 4 0 4 0 expected_output = \\"16.0000\\" assert solve(input_str).strip() == expected_output def test_partial_overlap(): input_str = 4 1 1 5 1 5 5 1 5 4 3 3 7 3 7 7 3 7 0 expected_output = \\"4.0000\\" assert solve(input_str).strip() == expected_output","solution":"def polygon_area(polygon): Calculate the area of a simple polygon given its vertices. n = len(polygon) area = 0 for i in range(n): x1, y1 = polygon[i] x2, y2 = polygon[(i + 1) % n] area += x1 * y2 - y1 * x2 return abs(area) / 2 def inside(p, cp1, cp2): Check if point p is inside the edge formed by cp1 and cp2. return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]) def intersection(cp1, cp2, s, e): Calculate the intersection point of the line segment cp1-cp2 with s-e. dc = (cp1[0] - cp2[0], cp1[1] - cp2[1]) dp = (s[0] - e[0], s[1] - e[1]) n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0] n2 = s[0] * e[1] - s[1] * e[0] n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]) return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3] def clip_polygon(subject_polygon, clip_polygon): Clip the subject polygon with the clip polygon using the Sutherland-Hodgman algorithm. def _clip(subject_polygon, cp1, cp2): clipped_polygon = [] for i in range(len(subject_polygon)): current_point = subject_polygon[i] previous_point = subject_polygon[i - 1] if inside(current_point, cp1, cp2): if not inside(previous_point, cp1, cp2): clipped_polygon.append(intersection(cp1, cp2, previous_point, current_point)) clipped_polygon.append(current_point) elif inside(previous_point, cp1, cp2): clipped_polygon.append(intersection(cp1, cp2, previous_point, current_point)) return clipped_polygon output_list = subject_polygon[:] cp1 = clip_polygon[-1] for cp2 in clip_polygon: output_list = _clip(output_list, cp1, cp2) cp1 = cp2 return output_list def intersection_area(polygon1, polygon2): clipped_polygon = clip_polygon(polygon1, polygon2) if clipped_polygon: return polygon_area(clipped_polygon) return 0 def parse_input(input_str): input_lines = input_str.strip().split('n') polygons = [] i = 0 while i < len(input_lines): n1 = int(input_lines[i]) if n1 == 0: break i += 1 p1 = [tuple(map(int, input_lines[j].split())) for j in range(i, i + n1)] i += n1 n2 = int(input_lines[i]) i += 1 p2 = [tuple(map(int, input_lines[j].split())) for j in range(i, i + n2)] i += n2 polygons.append((p1, p2)) return polygons def solve(input_str): polygons = parse_input(input_str) results = [] for polygon1, polygon2 in polygons: results.append(f\\"{intersection_area(polygon1, polygon2):.4f}\\") return 'n'.join(results) # Example usage: input_str = 4 0 0 4 0 4 4 0 4 4 2 2 6 2 6 6 2 6 0 output = solve(input_str) print(output) # Output should be \\"4.0000\\""},{"question":"def has_even_sum_pair(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines whether there exists a pair of distinct indices (i, j) such that the sum of the elements at these indices is even. :param t: Number of test cases :param test_cases: List of tuples, each containing (N, list of N integers) :return: List of \\"YES\\" or \\"NO\\" for each test case >>> has_even_sum_pair(3, [(5, [1, 2, 3, 4, 5]), (4, [2, 4, 6, 8]), (2, [1, 1])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> has_even_sum_pair(1, [(3, [1, 3, 5])]) [\\"NO\\"] >>> has_even_sum_pair(1, [(3, [2, 4, 6])]) [\\"YES\\"] >>> has_even_sum_pair(1, [(4, [2, 3, 5, 7])]) [\\"YES\\"] >>> has_even_sum_pair(1, [(1, [2])]) [\\"NO\\"]","solution":"def has_even_sum_pair(t, test_cases): Determines whether there exists a pair of distinct indices (i, j) such that the sum of the elements at these indices is even. :param t: Number of test cases :param test_cases: List of tuples, each containing (N, list of N integers) :return: List of \\"YES\\" or \\"NO\\" for each test case results = [] for N, arr in test_cases: odd_count = sum(1 for x in arr if x % 2 != 0) even_count = N - odd_count if odd_count > 0 and even_count > 0 or even_count > 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_hops(M: int, N: int) -> int: Returns the minimum number of hops Ada needs to get from (0, 0) to (M, N) based on the given rules. >>> min_hops(3, 2) 3 >>> min_hops(5, 5) 5","solution":"def min_hops(M, N): Returns the minimum number of hops Ada needs to get from (0, 0) to (M, N) based on the given rules. # Base case: when M and N are both zero, no hops are needed. if M == 0 and N == 0: return 0 # Even sum rule - can hop to any neighboring square if (M + N) % 2 == 0: return max(M, N) # Odd sum rule - can only move diagonally to neighboring squares return max(M, N) # Example usage print(min_hops(3, 2)) # Output: 3 print(min_hops(5, 5)) # Output: 5"},{"question":"def remove_duplicates(arr: List[int]) -> List[int]: Takes a list of integers and returns a new list with all duplicate entries removed, preserving the original order. >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 6, 2, 2, 3]) [4, 5, 6, 2, 3] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 1, 3, 2, 4, 4]) [1, 2, 3, 4]","solution":"def remove_duplicates(arr): Returns a new list with all duplicate entries removed, preserving the original order of the first occurrences. seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same. If no such rearrangement is possible, return \\"IMPOSSIBLE\\". If multiple rearrangements are possible, return the lexicographically smallest one. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") 'IMPOSSIBLE'","solution":"import heapq from collections import Counter def rearrange_string(s): char_count = Counter(s) max_char = max(char_count.values()) if max_char > (len(s) + 1) // 2: return \\"IMPOSSIBLE\\" max_heap = [] for char, count in char_count.items(): heapq.heappush(max_heap, (-count, char)) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char # Increment count towards zero return ''.join(result)"},{"question":"def decrypt_message(shift, message): Decrypts a message that has been encoded using 'Sansa's Shift', where each letter has been shifted forward in the alphabet by a given number of positions. :param shift: int, the number of positions each letter in the message is shifted :param message: str, the encrypted message consisting only of lowercase letters :return: str, the decrypted message >>> decrypt_message(1, 'bcd') 'abc' >>> decrypt_message(3, 'def') 'abc' # Your code here def process_test_cases(input_data): Processes multiple test cases of encrypted messages. :param input_data: str, the input data containing number of test cases, shift values, and encrypted messages :return: list, the decrypted messages for each test case >>> input_data = \\"2n1nbcdn3ndefn\\" >>> process_test_cases(input_data) ['abc', 'abc'] >>> input_data = \\"3n2nabcn5nfghn1nzabn\\" >>> process_test_cases(input_data) ['yza', 'abc', 'yza'] # Your code here","solution":"def decrypt_message(shift, message): decrypted_message = [] for char in message: new_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a')) decrypted_message.append(new_char) return ''.join(decrypted_message) def process_test_cases(input_data): data = input_data.split('n') T = int(data[0]) results = [] index = 1 for _ in range(T): shift = int(data[index]) message = data[index + 1] results.append(decrypt_message(shift, message)) index += 2 return results"},{"question":"import re def is_palindrome(s: str) -> bool: Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): the input string to check. Returns: bool: True if the input string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True","solution":"import re def is_palindrome(s): Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): the input string to check. Returns: bool: True if the input string is a palindrome, False otherwise. cleaned_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned_string == cleaned_string[::-1]"},{"question":"def kth_smallest_number(N, K, sequence): Finds the K-th smallest number in a sequence of N integers. Parameters: N (int): The number of elements in the sequence. K (int): The position in the sorted sequence to find. sequence (list): The list of integers. Returns: int: The K-th smallest number in the sorted sequence. # Unit tests from solution import kth_smallest_number def test_kth_smallest_number_example1(): assert kth_smallest_number(5, 2, [3, 1, 4, 1, 5]) == 1 def test_kth_smallest_number_example2(): assert kth_smallest_number(7, 4, [9, 8, 7, 6, 5, 4, 3]) == 6 def test_kth_smallest_number_with_duplicates(): assert kth_smallest_number(5, 3, [2, 2, 2, 2, 2]) == 2 def test_kth_smallest_number_with_negative_numbers(): assert kth_smallest_number(5, 1, [-5, -10, -3, -1, -4]) == -10 def test_kth_smallest_number_large_k(): assert kth_smallest_number(5, 5, [1, 2, 3, 4, 5]) == 5 def test_kth_smallest_number_all_same_except_one(): assert kth_smallest_number(4, 3, [1, 2, 1, 1]) == 1 def test_kth_smallest_number_random_large(): assert kth_smallest_number(10, 3, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 3","solution":"def kth_smallest_number(N, K, sequence): Finds the K-th smallest number in a sequence of N integers. Parameters: N (int): The number of elements in the sequence. K (int): The position in the sorted sequence to find. sequence (list): The list of integers. Returns: int: The K-th smallest number in the sorted sequence. sequence.sort() return sequence[K-1]"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def has_cycle(head: Optional[ListNode]) -> bool: Detects whether a linked list has a cycle using Floyd’s Tortoise and Hare algorithm. :param head: ListNode | The head node of the linked list :return: bool | True if there is a cycle, False otherwise # Your code here # Test cases def test_has_cycle_with_cycle(): # Creating a linked list with a cycle: # 1 -> 2 -> 3 -> 4 -> 2 ... node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # cycle here assert has_cycle(node1) == True def test_has_cycle_without_cycle(): # Creating a linked list without a cycle: # 1 -> 2 -> 3 -> 4 -> null node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 assert has_cycle(node1) == False def test_has_cycle_single_node_without_cycle(): # Creating a single node linked list without a cycle: node1 = ListNode(1) assert has_cycle(node1) == False def test_has_cycle_single_node_with_cycle(): # Creating a single node linked list with a cycle to itself: node1 = ListNode(1) node1.next = node1 # cycle here assert has_cycle(node1) == True def test_has_cycle_empty_list(): # Empty linked list assert has_cycle(None) == False","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def has_cycle(head): Detects whether a linked list has a cycle using Floyd’s Tortoise and Hare algorithm. :param head: ListNode | The head node of the linked list :return: bool | True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in the given list of numbers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([0, 1, 2, 3, -1, 4, 5, 6]) 7 >>> longest_increasing_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([-1, -2, -3, -4, -5]) 1 >>> longest_increasing_subsequence(list(range(1000, 0, -1))) 1 >>> longest_increasing_subsequence(list(range(1, 1001))) 1000","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in the given list of numbers. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def max_treasure(n, m, treasures, roads): Determine the maximum amount of treasure Alice can collect starting from any region and moving along the roads. -----Input----- n: int : represents the number of regions m: int : represents the number of roads treasures: List[int] : the i-th integer represents the amount of treasure in the i-th region roads: List[Tuple[int, int]] : each tuple (u, v) indicates there is a directed road from region u to region v -----Output----- int : the maximum amount of treasure Alice can collect >>> max_treasure(5, 6, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (2, 5), (1, 3)]) 15 >>> max_treasure(4, 3, [2, 4, 6, 8], [(1, 2), (2, 3), (1, 3)]) 12 >>> max_treasure(3, 0, [5, 10, 15], []) 15 >>> max_treasure(2, 1, [3, 7], [(1, 2)]) 10 >>> max_treasure(4, 6, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4), (2, 4)]) 10","solution":"def max_treasure(n, m, treasures, roads): from collections import defaultdict, deque # Construct adjacency list from roads (graph) graph = defaultdict(list) in_degree = [0] * n for u, v in roads: graph[u - 1].append(v - 1) in_degree[v - 1] += 1 # Perform a topological sort and store the topological order topo_order = [] queue = deque() # Initialize the queue with nodes having zero in-degree for i in range(n): if in_degree[i] == 0: queue.append(i) while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Apply dynamic programming to calculate the maximum treasure collectable max_treasure_dp = treasures[:] for node in topo_order: for neighbor in graph[node]: if max_treasure_dp[neighbor] < max_treasure_dp[node] + treasures[neighbor]: max_treasure_dp[neighbor] = max_treasure_dp[node] + treasures[neighbor] return max(max_treasure_dp) # Example usage: # max_treasure(5, 6, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (2, 5), (1, 3)]) # This should return 15"},{"question":"def remove_smallest_occurrences(lst): Returns a new list where every instance of the smallest number is removed. :param lst: A list of integers :return: A new list with every instance of the smallest number removed >>> remove_smallest_occurrences([3, 1, 2, 1, 4, 5, 1]) [3, 2, 4, 5] >>> remove_smallest_occurrences([7, 8, 5, 5, 8, 7]) [7, 8, 8, 7] >>> remove_smallest_occurrences([]) [] >>> remove_smallest_occurrences([1, 1, 1, 1, 1]) [] >>> remove_smallest_occurrences([-1, 3, -1, 2, 4, -1]) [3, 2, 4] >>> remove_smallest_occurrences([5]) [] >>> remove_smallest_occurrences([10, -6, 3, -6, 7, -6, 0]) [10, 3, 7, 0]","solution":"def remove_smallest_occurrences(lst): Returns a new list where every instance of the smallest number is removed. :param lst: A list of integers :return: A new list with every instance of the smallest number removed if not lst: return [] smallest = min(lst) return [x for x in lst if x != smallest]"},{"question":"def findMissingNumber(nums): Finds the missing number in the list of unique integers between 1 and len(nums)+1. Example 1: >>> findMissingNumber([3, 7, 1, 2, 8, 4, 5]) 6 Example 2: >>> findMissingNumber([1, 2, 3, 5]) 4","solution":"def findMissingNumber(nums): Finds the missing number in the list of unique integers between 1 and len(nums)+1 n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"def rearrange_string(s: str) -> str: Transform the string such that all alphanumeric characters appear at the beginning, followed by all special characters, while maintaining their original order. >>> rearrange_string(\\"a1!b2@c#\\") \\"a1b2c!@#\\" >>> rearrange_string(\\"*&T3Ju^8(i)\\") \\"T3Ju8i*&()^\\"","solution":"def rearrange_string(s: str) -> str: alphanumeric = [] special = [] for char in s: if char.isalnum(): alphanumeric.append(char) else: special.append(char) return ''.join(alphanumeric) + ''.join(special)"},{"question":"def is_symmetric(matrix): Checks if a given square matrix is symmetric. Args: matrix (list of lists): A 2D list representing the matrix. Returns: bool: True if the matrix is symmetric, False otherwise. Examples: >>> is_symmetric([ ... [1, 2, 3], ... [2, 4, 5], ... [3, 5, 6] ... ]) True >>> is_symmetric([ ... [1, 0, 3], ... [2, 4, 5], ... [3, 5, 6] ... ]) False","solution":"def is_symmetric(matrix): Checks if a given square matrix is symmetric. Args: matrix (list of lists): A 2D list representing the matrix. Returns: bool: True if the matrix is symmetric, False otherwise. n = len(matrix) for i in range(n): for j in range(n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"MOD = 10**9 + 7 def number_of_valid_seating_arrangements(M, N): Find the number of valid seating arrangements in an exam hall with M rows and N columns of desks such that no two adjacent students are seated directly adjacent: horizontally, vertically or diagonally. Args: M (int): Number of rows N (int): Number of columns Returns: int: Number of valid configurations modulo 10^9 + 7 >>> number_of_valid_seating_arrangements(2, 2) 16 >>> number_of_valid_seating_arrangements(3, 3) 512 >>> number_of_valid_seating_arrangements(1, 5) 32 >>> number_of_valid_seating_arrangements(4, 4) 65536 pass # Unit tests def test_number_of_valid_seating_arrangements(): assert number_of_valid_seating_arrangements(1, 1) == 2 assert number_of_valid_seating_arrangements(2, 2) == 16 assert number_of_valid_seating_arrangements(3, 3) == 512 assert number_of_valid_seating_arrangements(1, 5) == 32 assert number_of_valid_seating_arrangements(4, 4) == 65536 assert number_of_valid_seating_arrangements(1000, 1000) == pow(2, 1000000, 10**9 + 7)","solution":"MOD = 10**9 + 7 def number_of_valid_seating_arrangements(M, N): # Each desk can be occupied or not independently without concern for adjacent constraints. total_ways = 2**(M * N) # We use modulo operation to prevent overflow and adhere to problem constraints. return total_ways % MOD # Read input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip() M, N = map(int, data.split()) print(number_of_valid_seating_arrangements(M, N))"},{"question":"def string_letter_count(s: str) -> dict: Implement a function string_letter_count that takes a string as input and returns a dictionary with keys as characters and values as the count of those characters in the given string. The function should ignore spaces and be case insensitive. Examples: >>> string_letter_count(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> string_letter_count(\\"Python Programming\\") == {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1} >>> string_letter_count(\\"\\") == {} import pytest def test_string_letter_count_example_cases(): assert string_letter_count(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} assert string_letter_count(\\"Python Programming\\") == {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1} assert string_letter_count(\\"\\") == {} def test_string_letter_count_ignore_spaces(): assert string_letter_count(\\"A B C D E F G\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1} def test_string_letter_count_case_insensitivity(): assert string_letter_count(\\"AbcABC\\") == {'a': 2, 'b': 2, 'c': 2} def test_string_letter_count_single_characters(): assert string_letter_count(\\"aaaaa\\") == {'a': 5} assert string_letter_count(\\"b\\") == {'b': 1} def test_string_letter_count_numbers_and_special_chars(): assert string_letter_count(\\"1234!@\\") == {'1': 1, '2': 1, '3': 1, '4': 1, '!': 1, '': 1, '@': 1}","solution":"def string_letter_count(s): Returns a dictionary with keys as characters and values as the count of those characters in the given string. The function ignores spaces and is case insensitive. s = s.replace(\\" \\", \\"\\").lower() letter_count = {} for char in s: if char in letter_count: letter_count[char] += 1 else: letter_count[char] = 1 return letter_count"},{"question":"def climb_stairs(n: int) -> int: Returns the number of distinct ways to climb to the top of a staircase with n steps, given that one can climb either 1 step or 2 steps at a time. >>> climb_stairs(1) 1 >>> climb_stairs(2) 2 >>> climb_stairs(3) 3 >>> climb_stairs(4) 5 >>> climb_stairs(5) 8 >>> climb_stairs(10) 89 >>> climb_stairs(20) 10946 >>> climb_stairs(30) 1346269 >>> climb_stairs(100000) Non-None Output # Ensure function does not crash on the upper limit","solution":"def climb_stairs(n): Returns the number of distinct ways to climb to the top of a staircase with n steps, given that one can climb either 1 step or 2 steps at a time. if n == 1: return 1 elif n == 2: return 2 first, second = 1, 2 for _ in range(3, n + 1): first, second = second, first + second return second"},{"question":"def min_operations_to_equalize_arrays(N: int, A: List[int], B: List[int]) -> int: Returns the minimum number of operations required to make array A equal to array B. >>> min_operations_to_equalize_arrays(4, [1, 2, 3, 4], [4, 3, 2, 1]) 8 >>> min_operations_to_equalize_arrays(3, [1, 1, 1], [1, 1, 1]) 0 >>> min_operations_to_equalize_arrays(3, [1, 2, 3], [2, 3, 4]) 3 >>> min_operations_to_equalize_arrays(2, [-1000000000, 1000000000], [1000000000, -1000000000]) 4000000000 >>> min_operations_to_equalize_arrays(3, [-1, -2, -3], [1, 2, 3]) 12","solution":"def min_operations_to_equalize_arrays(N, A, B): Returns the minimum number of operations required to make array A equal to array B. operations = 0 for i in range(N): operations += abs(A[i] - B[i]) return operations"},{"question":"def is_path_exists(matrix: List[List[str]]) -> str: Check if it is possible to find a path from the top-left corner to the bottom-right corner in a matrix. >>> is_path_exists([ ... ['O', 'X', 'O'], ... ['O', 'X', 'X'], ... ['O', 'O', 'O'] ... ]) \\"YES\\" >>> is_path_exists([ ... ['O', 'X', 'O'], ... ['X', 'X', 'O'], ... ['O', 'O', 'X'] ... ]) \\"NO\\" from solution import is_path_exists def test_example_1(): matrix = [ ['O', 'X', 'O'], ['O', 'X', 'X'], ['O', 'O', 'O'] ] assert is_path_exists(matrix) == \\"YES\\" def test_example_2(): matrix = [ ['O', 'X', 'O'], ['X', 'X', 'O'], ['O', 'O', 'X'] ] assert is_path_exists(matrix) == \\"NO\\" def test_example_3(): matrix = [ ['O', 'X'], ['X', 'O'] ] assert is_path_exists(matrix) == \\"NO\\" def test_single_cell_open(): matrix = [ ['O'] ] assert is_path_exists(matrix) == \\"YES\\" def test_single_cell_blocked(): matrix = [ ['X'] ] assert is_path_exists(matrix) == \\"NO\\" def test_no_obstacle(): matrix = [ ['O', 'O'], ['O', 'O'] ] assert is_path_exists(matrix) == \\"YES\\" def test_full_blocked_path(): matrix = [ ['O', 'X', 'O'], ['X', 'X', 'X'], ['O', 'O', 'O'] ] assert is_path_exists(matrix) == \\"NO\\"","solution":"def is_path_exists(matrix): m = len(matrix) n = len(matrix[0]) def dfs(x, y, visited): if x == m - 1 and y == n - 1: return True visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and matrix[new_x][new_y] == 'O' and (new_x, new_y) not in visited: if dfs(new_x, new_y, visited): return True return False if matrix[0][0] != 'O' or matrix[m-1][n-1] != 'O': return \\"NO\\" visited = set() return \\"YES\\" if dfs(0, 0, visited) else \\"NO\\""},{"question":"def process_book_queries(G: int, genres_info: List[str], Q: int, queries: List[str]) -> List[str]: Process multiple queries to check if a book belongs to a specified genre. Parameters: G (int): Number of genres. genres_info (List[str]): A list of genre information strings. Q (int): Number of queries. queries (List[str]): A list of query strings. Returns: List[str]: A list of strings, \\"YES\\" if the book belongs to the specified genre, otherwise \\"NO\\". Example: >>> G, genres_info, Q, queries = 3, [\\"Fantasy 3 HarryPotter TheHobbit LOTR\\", \\"Science 2 ABriefHistoryOfTime TheSelfishGene\\", \\"History 1 Sapiens\\"], 4, [\\"HarryPotter Fantasy\\", \\"TheHobbit Science\\", \\"Sapiens History\\", \\"LOTR Fantasy\\"] >>> process_book_queries(G, genres_info, Q, queries) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> G, genres_info, Q, queries = 1, [\\"Science 0\\"], 1, [\\"AnyBook Science\\"] >>> process_book_queries(G, genres_info, Q, queries) [\\"NO\\"] def test_process_book_queries_basic(): G = 3 genres_info = [ \\"Fantasy 3 HarryPotter TheHobbit LOTR\\", \\"Science 2 ABriefHistoryOfTime TheSelfishGene\\", \\"History 1 Sapiens\\" ] Q = 4 queries = [ \\"HarryPotter Fantasy\\", \\"TheHobbit Science\\", \\"Sapiens History\\", \\"LOTR Fantasy\\" ] expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert process_book_queries(G, genres_info, Q, queries) == expected def test_process_book_queries_no_books(): G = 1 genres_info = [ \\"Science 0\\" ] Q = 1 queries = [ \\"AnyBook Science\\", ] expected = [\\"NO\\"] assert process_book_queries(G, genres_info, Q, queries) == expected def test_process_book_queries_multiple_genres_same_book(): G = 2 genres_info = [ \\"Fantasy 1 HarryPotter\\", \\"Adventure 1 HarryPotter\\" ] Q = 2 queries = [ \\"HarryPotter Fantasy\\", \\"HarryPotter Adventure\\" ] expected = [\\"YES\\", \\"YES\\"] assert process_book_queries(G, genres_info, Q, queries) == expected def test_process_book_queries_case_sensitive(): G = 1 genres_info = [ \\"Fantasy 1 harrypotter\\" ] Q = 1 queries = [ \\"HarryPotter Fantasy\\" ] expected = [\\"NO\\"] assert process_book_queries(G, genres_info, Q, queries) == expected def test_process_book_queries_multiple_books_multiple_queries(): G = 2 genres_info = [ \\"Fantasy 2 HarryPotter TheHobbit\\", \\"Science 1 ABriefHistoryOfTime\\" ] Q = 5 queries = [ \\"HarryPotter Fantasy\\", \\"TheHobbit Fantasy\\", \\"ABriefHistoryOfTime Science\\", \\"TheHobbit Science\\", \\"HarryPotter Science\\" ] expected = [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] assert process_book_queries(G, genres_info, Q, queries) == expected","solution":"def process_book_queries(G, genres_info, Q, queries): genre_books = {} # Process genres information for info in genres_info: parts = info.split() genre = parts[0] num_books = int(parts[1]) books = set(parts[2:2 + num_books]) genre_books[genre] = books # Process queries results = [] for query in queries: book_title, genre_name = query.split() if genre_name in genre_books and book_title in genre_books[genre_name]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: G = 3 genres_info = [ \\"Fantasy 3 HarryPotter TheHobbit LOTR\\", \\"Science 2 ABriefHistoryOfTime TheSelfishGene\\", \\"History 1 Sapiens\\" ] Q = 4 queries = [ \\"HarryPotter Fantasy\\", \\"TheHobbit Science\\", \\"Sapiens History\\", \\"LOTR Fantasy\\" ] print(process_book_queries(G, genres_info, Q, queries)) # Output: [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"]"},{"question":"def smallest_non_subset_sum(arr: List[int]) -> int: Given an array of integers, return the smallest positive integer that is not a sum of a subset of the array. >>> smallest_non_subset_sum([1, 2, 2, 5]) 11 >>> smallest_non_subset_sum([1]) 2 >>> smallest_non_subset_sum([2]) 1 >>> smallest_non_subset_sum([1, 1, 1, 1]) 5 >>> smallest_non_subset_sum([3, 3, 3]) 1 >>> smallest_non_subset_sum([1, 2, 3, 4, 5]) 16 >>> smallest_non_subset_sum([1, 2, 5, 10, 20, 40]) 4 >>> smallest_non_subset_sum([1, 3, 6, 10, 11, 15]) 2 >>> smallest_non_subset_sum([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 11","solution":"def smallest_non_subset_sum(arr): Returns the smallest positive integer that is not a sum of a subset of the array. arr.sort() smallest_sum = 1 for num in arr: if num > smallest_sum: break smallest_sum += num return smallest_sum # Example execution to verify the solution # Note: Comment out before running unit tests # print(smallest_non_subset_sum([1, 2, 2, 5])) # Expected Output: 11"},{"question":"def generate_grid(n: int, m: int) -> List[str]: Generates an n x m grid with characters A, B, and C such that no two adjacent cells have the same character. The grid is generated to have the smallest lexicographical order in its row-major representation. >>> generate_grid(2, 3) ['ABC', 'BCA'] >>> generate_grid(3, 4) ['ABCA', 'BCAB', 'CABC'] >>> generate_grid(1, 1) ['A'] >>> generate_grid(1, 3) ['ABC'] >>> generate_grid(3, 1) ['A', 'B', 'C'] >>> generate_grid(4, 4) ['ABCA', 'BCAB', 'CABC', 'ABCA']","solution":"def generate_grid(n, m): Generates an n x m grid with characters A, B, and C such that no two adjacent cells have the same character. The grid is generated to have the smallest lexicographical order in its row-major representation. result = [] chars = ['A', 'B', 'C'] for i in range(n): row = [] for j in range(m): row.append(chars[(i + j) % 3]) result.append(\\"\\".join(row)) return result"},{"question":"def divisor_string(n: int) -> str: Returns a comma-separated string of all divisors of integer n in ascending order. >>> divisor_string(10) \\"1,2,5,10\\" >>> divisor_string(15) \\"1,3,5,15\\" >>> divisor_string(1) \\"1\\" >>> divisor_string(28) \\"1,2,4,7,14,28\\" >>> divisor_string(49) \\"1,7,49\\" >>> divisor_string(100) \\"1,2,4,5,10,20,25,50,100\\" >>> divisor_string(9973) \\"1,9973\\" # 9973 is a prime number >>> divisor_string(10000) \\"1,2,4,5,8,10,16,20,25,40,50,80,100,125,200,250,400,500,625,1000,1250,2000,2500,5000,10000\\"","solution":"def divisor_string(n: int) -> str: Returns a comma-separated string of all divisors of integer n in ascending order. divisors = [str(i) for i in range(1, n+1) if n % i == 0] return \\",\\".join(divisors)"},{"question":"def verify_b_answer(n: int, s: int, sequence: List[int], m: int) -> str: Verifies B's answer by finding the longest subsequence with a sum of elements <= s and comparing it to m. Args: n (int): The number of elements in the sequence. s (int): The maximum allowed sum. sequence (list): List of integers representing the sequence. m (int): B's answer for the length of the longest subsequence with sum <= s. Returns: str: \\"Correct\\" if B's answer is correct, otherwise \\"Incorrect\\". Examples: >>> verify_b_answer(5, 10, [2, 3, 1, 5, 4], 3) 'Correct' >>> verify_b_answer(5, 10, [2, 3, 1, 5, 4], 4) 'Incorrect' >>> verify_b_answer(1, 5, [5], 1) 'Correct'","solution":"def verify_b_answer(n, s, sequence, m): Verifies B's answer by finding the longest subsequence with a sum of elements <= s and comparing it to m. Args: n (int): The number of elements in the sequence. s (int): The maximum allowed sum. sequence (list): List of integers representing the sequence. m (int): B's answer for the length of the longest subsequence with sum <= s. Returns: str: \\"Correct\\" if B's answer is correct, otherwise \\"Incorrect\\". def longest_subsequence_length(sequence, s): n = len(sequence) max_length = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += sequence[end] if current_sum <= s: max_length = max(max_length, end - start + 1) else: break return max_length actual_max_length = longest_subsequence_length(sequence, s) return \\"Correct\\" if actual_max_length == m else \\"Incorrect\\""},{"question":"from typing import List def level_order_to_bottom_up(input_str: str) -> str: Given a binary tree, return the values of its nodes in a specific order, known as \\"bottom-up level order traversal\\". In this order, the tree is traversed level by level from the bottom up, and from left to right within each level. >>> level_order_to_bottom_up(\\"3 9 20 null null 15 7\\") \\"15 7 9 20 3\\" >>> level_order_to_bottom_up(\\"1 2 3 4 null null 5\\") \\"4 5 2 3 1\\" pass # Implementation goes here # Implement some test cases. def test_level_order_to_bottom_up_example1(): input_str = \\"3 9 20 null null 15 7\\" expected_output = \\"15 7 9 20 3\\" assert level_order_to_bottom_up(input_str) == expected_output def test_level_order_to_bottom_up_example2(): input_str = \\"1 2 3 4 null null 5\\" expected_output = \\"4 5 2 3 1\\" assert level_order_to_bottom_up(input_str) == expected_output def test_level_order_to_bottom_up_single_node(): input_str = \\"1\\" expected_output = \\"1\\" assert level_order_to_bottom_up(input_str) == expected_output def test_level_order_to_bottom_up_all_null(): input_str = \\"null\\" expected_output = \\"\\" assert level_order_to_bottom_up(input_str) == expected_output def test_level_order_to_bottom_up_complex(): input_str = \\"1 null 2 3 4 null 5\\" expected_output = \\"5 3 4 2 1\\" assert level_order_to_bottom_up(input_str) == expected_output def test_level_order_to_bottom_up_empty_tree(): input_str = \\"\\" expected_output = \\"\\" assert level_order_to_bottom_up(input_str) == expected_output","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes or nodes[0] == \\"null\\": return None root = TreeNode(int(nodes[0])) queue = deque([root]) index = 1 while queue and index < len(nodes): node = queue.popleft() if nodes[index] != \\"null\\": node.left = TreeNode(int(nodes[index])) queue.append(node.left) index += 1 if index < len(nodes) and nodes[index] != \\"null\\": node.right = TreeNode(int(nodes[index])) queue.append(node.right) index += 1 return root def bottom_up_level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.insert(0, current_level) return [val for level in result for val in level] def level_order_to_bottom_up(input_str): nodes = input_str.split() root = build_tree(nodes) return \\" \\".join(map(str, bottom_up_level_order_traversal(root)))"},{"question":"def min_max_difference(notes): Given a collection of musical notes, each described by their frequency in Hertz, find the minimum possible maximum frequency difference between any two consecutive notes. Parameters: notes (List[int]): List of musical note frequencies. Returns: int: Minimum possible maximum frequency difference between any two consecutive notes. Examples: >>> min_max_difference([10, 20, 30, 40]) 10 >>> min_max_difference([15, 5, 45, 25, 35]) 10 >>> min_max_difference([100, 50, 200, 150, 250]) 50 >>> min_max_difference([1, 4, 2, 3]) 1 >>> min_max_difference([1000000000, 999999999, 999999998, 999999997]) 1 >>> min_max_difference([2, 8, 1, 4, 9, 3]) 1 >>> min_max_difference([100, 80, 60, 40, 20]) 20","solution":"def min_max_difference(notes): Given a list of \`notes\` (frequencies in Hz), returns the minimum possible maximum frequency difference between any two consecutive notes when arranged in the optimal order. notes.sort() min_max_diff = float('inf') for i in range(1, len(notes)): min_max_diff = min(min_max_diff, notes[i] - notes[i - 1]) return min_max_diff # Test the function with the sample input n = 5 notes = [15, 5, 45, 25, 35] print(min_max_difference(notes))"},{"question":"def smallestString(s: str) -> str: Returns the smallest string that can be obtained by any number of times sorting the non-empty substrings. The smallest string is simply the sorted version of the input string. >>> smallestString(\\"cba\\") \\"abc\\" >>> smallestString(\\"edcba\\") \\"abcde\\" >>> smallestString(\\"bca\\") \\"abc\\"","solution":"def smallestString(s: str) -> str: Returns the smallest string that can be obtained by any number of times sorting the non-empty substrings. The smallest string is simply the sorted version of the input string. return ''.join(sorted(s))"},{"question":"def count_consecutive_sum_ways(n: int) -> int: Returns the number of ways to express n as a sum of two or more consecutive positive integers. >>> count_consecutive_sum_ways(9) 2 >>> count_consecutive_sum_ways(15) 3 >>> count_consecutive_sum_ways(41) 1 pass def process_input(T: int, cases: List[int]) -> List[int]: Processes T test cases. >>> process_input(3, [9, 15, 41]) [2, 3, 1] >>> process_input(3, [3, 5, 7]) [1, 1, 1] >>> process_input(1, [50]) [2] pass","solution":"def count_consecutive_sum_ways(n): Returns the number of ways to express n as a sum of two or more consecutive positive integers. count = 0 m = 1 while m * (m + 1) // 2 < n: if (n - (m * (m + 1)) // 2) % (m + 1) == 0: count += 1 m += 1 return count def process_input(T, cases): Processes T test cases results = [] for n in cases: results.append(count_consecutive_sum_ways(n)) return results"},{"question":"from typing import List, Tuple def max_travel_cost(n: int, roads: List[Tuple[int, int, int]]) -> int: Find the maximum travel cost between any pair of cities in the tree. >>> max_travel_cost(4, [(1, 2, 3), (2, 3, 4), (2, 4, 2)]) 7 >>> max_travel_cost(5, [(1, 2, 100), (1, 3, 200), (2, 4, 150), (2, 5, 10)]) 450 pass def test_example_1(): n = 4 roads = [ (1, 2, 3), (2, 3, 4), (2, 4, 2) ] assert max_travel_cost(n, roads) == 7 def test_example_2(): n = 5 roads = [ (1, 2, 100), (1, 3, 200), (2, 4, 150), (2, 5, 10) ] assert max_travel_cost(n, roads) == 450 def test_single_road(): n = 2 roads = [ (1, 2, 5) ] assert max_travel_cost(n, roads) == 5 def test_star_shaped_tree(): n = 5 roads = [ (1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1) ] assert max_travel_cost(n, roads) == 2 def test_chain_shaped_tree(): n = 4 roads = [ (1, 2, 2), (2, 3, 2), (3, 4, 2) ] assert max_travel_cost(n, roads) == 6","solution":"def max_travel_cost(n, roads): from collections import defaultdict import heapq def dijkstra(start, graph): dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 pq = [(0, start)] while pq: distance, node = heapq.heappop(pq) if distance > dist[node]: continue for neighbor, weight in graph[node]: new_dist = distance + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor)) return dist graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Run Dijkstra from an arbitrary node (e.g., node 1) to find the furthest node dist_from_start = dijkstra(1, graph) furthest_node = max(dist_from_start, key=dist_from_start.get) # Run Dijkstra from the furthest node to find the maximum distance to any node dist_from_furthest = dijkstra(furthest_node, graph) max_cost = max(dist_from_furthest.values()) return max_cost"},{"question":"def is_valid_tree(N: int, M: int, relations: List[Tuple[int, int]]) -> str: Check if a given folder structure forms a valid tree. Args: N: int - The number of folders. M: int - The number of relations between folders. relations: List[Tuple[int, int]] - Each tuple indicates that folder u is a subfolder of folder v. Returns: str: \\"YES\\" if the folder structure forms a valid tree, otherwise \\"NO\\". >>> is_valid_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YES' >>> is_valid_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'NO' pass # Unit tests def test_valid_tree_1(): assert is_valid_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"YES\\" def test_invalid_tree_with_cycle(): assert is_valid_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"NO\\" def test_single_node(): assert is_valid_tree(1, 0, []) == \\"YES\\" def test_disconnected_tree(): assert is_valid_tree(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" def test_valid_tree_2(): assert is_valid_tree(5, 4, [(1, 2), (1, 3), (3, 4), (2, 5)]) == \\"YES\\" def test_invalid_tree_with_extra_edge(): assert is_valid_tree(4, 5, [(1, 2), (2, 3), (3, 4), (1, 3), (2, 4)]) == \\"NO\\"","solution":"def is_valid_tree(N, M, relations): from collections import defaultdict, deque if M != N - 1: return \\"NO\\" graph = defaultdict(list) for u, v in relations: graph[u].append(v) graph[v].append(u) visited = set() queue = deque([1]) while queue: node = queue.popleft() if node in visited: return \\"NO\\" visited.add(node) for neighbor in graph[node]: if neighbor not in visited: graph[neighbor].remove(node) queue.append(neighbor) return \\"YES\\" if len(visited) == N else \\"NO\\""},{"question":"def maximum_rectangle_area_in_histogram(buildings): You are given a list of integers representing the heights of buildings along a street. Calculate the maximum area of a rectangle formed by any contiguous buildings. Each entry in the list represents the height of a building of unit width. >>> maximum_rectangle_area_in_histogram([2, 1, 5, 6, 2, 3]) 10 >>> maximum_rectangle_area_in_histogram([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largestRectangleArea(heights): Calculates the maximum area of a rectangle formed by any contiguous buildings. Uses a stack to keep track of building heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def maximum_rectangle_area_in_histogram(buildings): Facade function to compute the maximum rectangle area in a histogram represented by \`buildings\`. return largestRectangleArea(buildings)"},{"question":"def isBalanced(expression: str) -> bool: Given a string expression that may contain open '(' and close ')' parentheses, determine if the expression has balanced parentheses. A string is said to be balanced if there are no unmatched parentheses and if the subset of parentheses enclosed within the confines of a matched pair of parentheses is also balanced. Expected Time Complexity: O(N) Expected Auxiliary Space: O(N) >>> isBalanced(\\"((()))\\") True >>> isBalanced(\\"(()())\\") True >>> isBalanced(\\"())(\\") False >>> isBalanced(\\"\\") True >>> isBalanced(\\"(()\\") False import pytest def test_isBalanced_balanced_cases(): assert isBalanced(\\"((()))\\") == True assert isBalanced(\\"(()())\\") == True assert isBalanced(\\"\\") == True assert isBalanced(\\"()()()\\") == True assert isBalanced(\\"()\\") == True def test_isBalanced_unbalanced_cases(): assert isBalanced(\\"())(\\") == False assert isBalanced(\\"(\\") == False assert isBalanced(\\")\\") == False assert isBalanced(\\"(()\\") == False assert isBalanced(\\")(\\") == False assert isBalanced(\\"())\\") == False def test_isBalanced_single_pair(): assert isBalanced(\\"()\\") == True assert isBalanced(\\"(\\") == False assert isBalanced(\\")\\") == False def test_isBalanced_multiple_nested_pairs(): assert isBalanced(\\"(()(()))\\") == True assert isBalanced(\\"((())())\\") == True assert isBalanced(\\"(((())))\\") == True assert isBalanced(\\"(((()))\\") == False def test_isBalanced_complex_patterns(): assert isBalanced(\\"(())(())\\") == True assert isBalanced(\\"((())(()))\\") == True assert isBalanced(\\"((())((())))\\") == True","solution":"def isBalanced(expression): Returns True if the given expression has balanced parentheses, otherwise False. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"def is_possible_to_rearrange(n: int, m: int, grid: List[str]) -> str: Determine whether it is possible to rearrange the garden to ensure no two adjacent cells contain flowers. >>> is_possible_to_rearrange(3, 3, [\\"F.F\\", \\".F.\\", \\"F.F\\"]) \\"YES\\" >>> is_possible_to_rearrange(3, 3, [\\"FFF\\", \\"FFF\\", \\"FFF\\"]) \\"NO\\" >>> is_possible_to_rearrange(2, 2, [\\"..\\", \\"F.\\"]) \\"YES\\"","solution":"def is_possible_to_rearrange(n, m, grid): flowers = sum(row.count('F') for row in grid) max_possible_flowers = ((n + 1) // 2) * ((m + 1) // 2) + (n // 2) * (m // 2) if flowers <= max_possible_flowers: return \\"YES\\" else: return \\"NO\\" # Example usage: # n, m = 3, 3 # grid = [\\"FFF\\", \\"FFF\\", \\"FFF\\"] # print(is_possible_to_rearrange(n, m, grid)) # should return \\"NO\\""},{"question":"def smallest_lexicographical_string(s: str) -> str: Given a string s, return the smallest lexicographical string that can be obtained by reversing any of its substrings optimally. >>> smallest_lexicographical_string(\\"cba\\") \\"abc\\" >>> smallest_lexicographical_string(\\"acbd\\") \\"abcd\\" >>> smallest_lexicographical_string(\\"xzy\\") \\"xyz\\" pass def process_test_cases(t: int, test_cases: list) -> list: Processes multiple test cases and returns the results. t: int - Number of test cases. test_cases: list of strings - List of test cases. Returns a list of results for each test case. >>> process_test_cases(3, [\\"cba\\", \\"acbd\\", \\"xzy\\"]) [\\"abc\\", \\"abcd\\", \\"xyz\\"] >>> process_test_cases(4, [\\"zyx\\", \\"qwert\\", \\"aabbcc\\", \\"lmnop\\"]) [\\"xyz\\", \\"eqrtw\\", \\"aabbcc\\", \\"lmnop\\"] pass","solution":"def smallest_lexicographical_string(s): Given a string s, return the smallest lexicographical string that can be obtained by reversing any of its substrings optimally. return ''.join(sorted(s)) def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. t: int - Number of test cases. test_cases: list of strings - List of test cases. Returns a list of results for each test case. return [smallest_lexicographical_string(s) for s in test_cases]"},{"question":"def determine_rank(n: int, player_data: List[str], target_ID: int) -> int: Determine the rank of a specific player based on their total points in descending order. Args: n (int): The number of players. player_data (List[str]): Each element contains an integer ID and a sequence of non-negative integers representing the points from different activities. target_ID (int): The ID of the player whose rank is to be determined. Returns: int: The rank of the player with target_ID. Example: >>> determine_rank(4, [\\"1 10 20 30\\", \\"2 30 20 10\\", \\"3 20 30 40\\", \\"4 10 10 10\\"], 2) 2 >>> determine_rank(1, [\\"1 10 20 30\\"], 1) 1 pass from typing import List def test_example_case(): n = 4 player_data = [\\"1 10 20 30\\", \\"2 30 20 10\\", \\"3 20 30 40\\", \\"4 10 10 10\\"] target_ID = 2 assert determine_rank(n, player_data, target_ID) == 2 def test_single_player(): n = 1 player_data = [\\"1 10 20 30\\"] target_ID = 1 assert determine_rank(n, player_data, target_ID) == 1 def test_duplicate_scores(): n = 3 player_data = [\\"1 25 30\\", \\"2 30 25\\", \\"3 25 30\\"] target_ID = 1 assert determine_rank(n, player_data, target_ID) == 1 def test_different_scores(): n = 4 player_data = [\\"1 10 20 30\\", \\"2 15 25 35\\", \\"3 20 30 40\\", \\"4 25 35 45\\"] target_ID = 3 assert determine_rank(n, player_data, target_ID) == 2 def test_lower_bound_case(): n = 2 player_data = [\\"1 0\\", \\"2 100\\"] target_ID = 1 assert determine_rank(n, player_data, target_ID) == 2 def test_upper_bound_case(): n = 1000 player_data = [f\\"{i} {i*2} {i*3} {i*4}\\" for i in range(1, 1001)] target_ID = 1000 assert determine_rank(n, player_data, target_ID) == 1","solution":"def determine_rank(n, player_data, target_ID): # Calculate total points for each player in a dictionary scores = {} for player in player_data: player_info = player.split() player_id = int(player_info[0]) player_scores = map(int, player_info[1:]) total_points = sum(player_scores) scores[player_id] = total_points # Get the target player's total points target_score = scores[target_ID] # Get all unique scores in descending order unique_scores = sorted(set(scores.values()), reverse=True) # Determine the rank of the target score rank = unique_scores.index(target_score) + 1 return rank"},{"question":"def next_palindrome(n): This function takes a positive integer 'n' and returns the next palindrome larger than 'n'. >>> next_palindrome(123) 131 >>> next_palindrome(808) 818 >>> next_palindrome(999) 1001 >>> next_palindrome(1) 2 >>> next_palindrome(2) 3","solution":"def next_palindrome(n): This function takes a positive integer 'n' and returns the next palindrome larger than 'n'. if not isinstance(n, int) or n <= 0: return \\"Error: Input must be a positive integer\\" def is_palindrome(x): return str(x) == str(x)[::-1] current = n + 1 while not is_palindrome(current): current += 1 return current"},{"question":"from typing import List from collections import Counter def rearrange_balanced(s: str) -> str: Determines if a string can be rearranged to avoid any two adjacent characters being the same. If possible, returns the rearranged string; otherwise returns 'IMPOSSIBLE'. >>> rearrange_balanced(\\"aab\\") \\"aba\\" >>> rearrange_balanced(\\"aaab\\") \\"IMPOSSIBLE\\" >>> rearrange_balanced(\\"aabbcc\\") \\"abcabc\\" # Note: Other valid outputs are acceptable","solution":"from collections import Counter def rearrange_balanced(s): Returns a rearranged balanced version of the string, or 'IMPOSSIBLE' if it can't be balanced n = len(s) if n == 1: return s # Count frequencies of characters freq = Counter(s) max_freq = max(freq.values()) # If the highest frequency character count is more than half the length of string + 1, it's impossible if max_freq > (n + 1) // 2: return \\"IMPOSSIBLE\\" # Sort characters by frequency sorted_chars = sorted(freq, key=lambda x: (-freq[x], x)) # Create a result array filled with None result = [None] * n # Place the most frequent characters at even positions first i = 0 for char in sorted_chars: count = freq[char] for _ in range(count): result[i] = char i += 2 if i >= n: i = 1 return \\"\\".join(result)"},{"question":"def can_travel(L, N, S, queries): Determine if it is possible for a vehicle to travel from a specified starting point in one loop to a target point in another loop with properly managed switches. Args: L (int): the number of loops. N (int): the number of vehicles in each loop. S (List[List[int]]): a matrix of size L x L where S[i][j] = 1 if there exists a switch connecting loop i to loop j, and S[i][j] = 0 otherwise. queries (List[Tuple[int, int, int, int]]): list of queries with each query represented as (si, sj, ti, tj). Returns: List[str]: For each query, output \\"YES\\" if it is possible for a vehicle to travel from (si, sj) to (ti, tj), otherwise, output \\"NO\\". >>> can_travel(3, 3, [[0, 1, 1], [1, 0, 1], [1, 1, 0]], [(0, 1, 2, 2), (2, 0, 0, 2)]) [\\"YES\\", \\"YES\\"]","solution":"def can_travel(L, N, S, queries): def dfs(loop, visited): visited[loop] = True for next_loop in range(L): if S[loop][next_loop] == 1 and not visited[next_loop]: dfs(next_loop, visited) results = [] connected = [[False] * L for _ in range(L)] for i in range(L): visited = [False] * L dfs(i, visited) for j in range(L): connected[i][j] = visited[j] for si, sj, ti, tj in queries: if connected[si][ti]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longest_valid_substring_length(S: str) -> int: Returns the length of the longest substring in which no character appears more than twice consecutively. >>> longest_valid_substring_length(\\"aaabbccccd\\") == 7 >>> longest_valid_substring_length(\\"abcde\\") == 5 >>> longest_valid_substring_length(\\"aabbcccb\\") == 7 pass def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases for finding the longest valid substring length. >>> process_test_cases(3, [(10, \\"aaabbccccd\\"), (5, \\"abcde\\"), (7, \\"aabbcccb\\")]) == [7, 5, 7] pass","solution":"def longest_valid_substring_length(S): Returns the length of the longest substring in which no character appears more than twice consecutively. max_len = 0 current_len = 0 count = 0 previous_char = '' for char in S: if char == previous_char: count += 1 if count <= 2: current_len += 1 else: count = 1 current_len += 1 previous_char = char max_len = max(max_len, current_len) return max_len def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] S = test_cases[i][1] results.append(longest_valid_substring_length(S)) return results"},{"question":"def min_cost_to_palindrome(n, s, a, b, c): Calculate the minimum cost to transform the input string into a palindrome. :param n: Length of the string \`s\`. :param s: The input string consisting of lowercase letters. :param a: Cost to append a character. :param b: Cost to delete a character. :param c: Cost to replace a character. :return: The minimum cost to transform the string \`s\` into a palindrome. >>> min_cost_to_palindrome(4, 'abca', 1, 2, 3) 1 >>> min_cost_to_palindrome(3, 'abc', 3, 5, 2) 2 >>> min_cost_to_palindrome(5, 'level', 10, 10, 10) 0 >>> min_cost_to_palindrome(3, 'aab', 1, 3, 2) 1 >>> min_cost_to_palindrome(3, 'aab', 3, 3, 1) 1 >>> min_cost_to_palindrome(3, 'aab', 3, 1, 2) 1","solution":"def min_cost_to_palindrome(n, s, a, b, c): Calculate the minimum cost to transform the input string into a palindrome. :param n: Length of the string \`s\`. :param s: The input string consisting of lowercase letters. :param a: Cost to append a character. :param b: Cost to delete a character. :param c: Cost to replace a character. :return: The minimum cost to transform the string \`s\` into a palindrome. # Two pointers approach left = 0 right = n - 1 cost = 0 while left < right: if s[left] != s[right]: # Calculate the costs for each possible operation cost_replace = c cost_append_delete = min(a, b) # Choose the minimum cost operation to make the characters equal cost += min(cost_replace, cost_append_delete) left += 1 right -= 1 return cost"},{"question":"from collections import deque def min_moves_to_reach_target(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves required for the robot to reach the bottom-right cell of the grid. If it is impossible to reach the target cell, return -1. >>> min_moves_to_reach_target(5, 5, [\\".....\\", \\".#...\\", \\"...#.\\", \\".#.#.\\", \\".....\\"]) == 8 >>> min_moves_to_reach_target(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"]) == -1 >>> min_moves_to_reach_target(4, 4, [\\"....\\", \\"..\\", \\".#..\\", \\"....\\"]) == 6 # your code here","solution":"from collections import deque def min_moves_to_reach_target(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def sum_of_even_numbers(n, numbers): Returns the sum of all even numbers in the list. Parameters: n (int): Number of integers in the list. numbers (list of int): List of integers. Returns: int: Sum of even numbers in the list, or 0 if no even numbers are present. >>> sum_of_even_numbers(5, [1, 2, 3, 4, 5]) 6 >>> sum_of_even_numbers(3, [11, 13, 15]) 0 >>> sum_of_even_numbers(4, [-2, -4, -6, -8]) -20 >>> sum_of_even_numbers(6, [0, 0, 0, 0, 0, 0]) 0 >>> sum_of_even_numbers(1, [7]) 0 >>> sum_of_even_numbers(2, [2, 3]) 2 >>> sum_of_even_numbers(5, [1, 3, 5, 7, 9]) 0 >>> sum_of_even_numbers(4, [2, 4, 6, 8]) 20","solution":"def sum_of_even_numbers(n, numbers): Returns the sum of all even numbers in the list. Parameters: n (int): Number of integers in the list. numbers (list of int): List of integers. Returns: int: Sum of even numbers in the list, or 0 if no even numbers are present. even_sum = sum(number for number in numbers if number % 2 == 0) return even_sum"},{"question":"def is_palindrome(S: str) -> str: Check whether a given string is a palindrome or not. A string is a palindrome if it reads the same backward as forward. >>> is_palindrome(\\"level\\") \\"YES\\" >>> is_palindrome(\\"abba\\") \\"YES\\" >>> is_palindrome(\\"test\\") \\"NO\\" >>> is_palindrome(\\"12321\\") \\"YES\\" >>> is_palindrome(\\"12345\\") \\"NO\\" >>> is_palindrome(\\"A!b@B!a\\") \\"NO\\"","solution":"def is_palindrome(S): Checks if a given string S is a palindrome. Returns \\"YES\\" if it is a palindrome, otherwise \\"NO\\". # Check if the string is equal to its reverse if S == S[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Union def arrange_stamps(n: int, rarities: List[int]) -> Union[List[int], str]: Arrange stamps in a pattern where every two consecutive stamps have the property that the rarity of one is strictly greater than the other. Parameters: n (int): Number of stamps. rarities (list of int): List of rarity levels of the stamps. Returns: list of int: Rarity levels arranged in the required pattern or \\"impossible\\". Examples: >>> arrange_stamps(5, [1, 3, 2, 5, 4]) [1, 3, 2, 5, 4] >>> arrange_stamps(3, [5, 1, 3]) [1, 5, 3] >>> arrange_stamps(4, [2, 1, 3, 4]) [1, 4, 2, 3] def test_single_stamp(): assert arrange_stamps(1, [5]) == [5] def test_simple_case(): assert arrange_stamps(5, [1, 3, 2, 5, 4]) == [1, 5, 2, 4, 3] or arrange_stamps(5, [1, 3, 2, 5, 4]) == [1, 4, 2, 5, 3] def test_case_sorted_order(): assert arrange_stamps(4, [2, 1, 3, 4]) == [1, 4, 2, 3] or arrange_stamps(4, [2, 1, 3, 4]) == [1, 3, 2, 4] def test_alternating_pattern(): result = arrange_stamps(5, [10, 20, 30, 40, 50]) expected_patterns = [ [10, 50, 20, 40, 30], [10, 40, 20, 50, 30], [20, 50, 10, 40, 30], [20, 40, 10, 50, 30] ] assert result in expected_patterns def test_impossible_case(): assert arrange_stamps(3, [5, 5, 5]) == \\"impossible\\" def test_longer_case(): result = arrange_stamps(6, [6, 1, 4, 2, 3, 5]) expected_patterns = [ [1, 6, 2, 5, 3, 4], [1, 6, 2, 4, 3, 5] ] assert result in expected_patterns","solution":"def arrange_stamps(n, rarities): Arrange stamps in the required high-low pattern. Parameters: n (int): Number of stamps. rarities (list of int): List of rarity levels of the stamps. Returns: list of int: Rarity levels arranged in the required pattern or \\"impossible\\". if n <= 1: return rarities # Sort the rarities to easily pick min-max as we go rarities.sort() # We'll use two pointers to pick min-max alternately low = 0 high = n - 1 arranged = [] while low <= high: if low == high: arranged.append(rarities[low]) else: arranged.append(rarities[low]) arranged.append(rarities[high]) low += 1 high -= 1 # Check if the arrangement is valid by having alternating high-low pattern for i in range(1, n): if (i % 2 == 1 and arranged[i] <= arranged[i - 1]) or (i % 2 == 0 and arranged[i] >= arranged[i - 1]): return \\"impossible\\" return arranged"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums: List[int]) -> Optional[TreeNode]: You are given an integer array nums sorted in non-decreasing order. Build a new balanced binary search tree (BST) whose preorder traversal yields the same result as the given array. A balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Return the root of the new BST. Example: >>> nums = [-10, -3, 0, 5, 9] >>> root = sortedArrayToBST(nums) >>> preorderTraversal(root) [0, -3, -10, 5, 9] pass def preorderTraversal(root: Optional[TreeNode]) -> List[int]: Perform a preorder traversal of the binary search tree. Example: >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> preorderTraversal(root) [1, 2, 3] pass def test_sortedArrayToBST_single_element(): nums = [1] root = sortedArrayToBST(nums) assert preorderTraversal(root) == [1] def test_sortedArrayToBST_multiple_elements(): nums = [-10, -3, 0, 5, 9] root = sortedArrayToBST(nums) preorder_list = preorderTraversal(root) assert preorder_list == [0, -10, -3, 5, 9] or preorder_list == [0, -3, -10, 5, 9] def test_sortedArrayToBST_balanced(): nums = [1, 2, 3, 4, 5, 6, 7] root = sortedArrayToBST(nums) preorder_list = preorderTraversal(root) assert preorder_list == [4, 2, 1, 3, 6, 5, 7] def test_sortedArrayToBST_large_input(): nums = list(range(1000)) root = sortedArrayToBST(nums) preorder_list = preorderTraversal(root) assert len(preorder_list) == len(nums) def test_preorderTraversal_null_root(): assert preorderTraversal(None) == []","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums: List[int]) -> Optional[TreeNode]: if not nums: return None def convertToBST(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = convertToBST(left, mid - 1) node.right = convertToBST(mid + 1, right) return node return convertToBST(0, len(nums) - 1) def preorderTraversal(root: Optional[TreeNode]) -> List[int]: result = [] def traverse(node: Optional[TreeNode]): if node: result.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return result"},{"question":"from typing import List def maximum_sum_subarray(arr: List[int]) -> int: Given a list of integers, find the contiguous subarray (containing at least one number) that has the maximum sum and return that sum. Examples: >>> maximum_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maximum_sum_subarray([1, 2, 3, 4, 5]) 15 >>> maximum_sum_subarray([-1, -2, -3, -4, -5]) -1 >>> maximum_sum_subarray([10]) 10 >>> maximum_sum_subarray([-10]) -10 >>> maximum_sum_subarray([-1, 3, -2, 3, 4, -1, 2, -5]) 9 >>> maximum_sum_subarray([1, -2, 3, -4, 5, -6, 7, -8, 9]) 9","solution":"def maximum_sum_subarray(arr): Function to find the contiguous subarray with the maximum sum. max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def manage_treasury(N: int, stacks: List[int], Q: int, requests: List[int]) -> str: Manage the state of the treasury after a series of withdrawal requests. Args: N (int): The number of stacks initially in the treasury. stacks (List[int]): The number of coins in each stack, in increasing order. Q (int): The number of withdrawal requests. requests (List[int]): A list of integers where each integer indicates a withdrawal request. Returns: str: A single line containing the number of coins in each remaining stack in increasing order, separated by spaces, or \\"Empty\\" if no stacks remain. Examples: >>> manage_treasury(5, [1, 2, 3, 4, 5], 3, [1, 1, 1]) '4 5' >>> manage_treasury(3, [2, 3, 4], 0, []) '2 3 4' >>> manage_treasury(3, [1, 2, 3], 3, [1, 1, 1]) 'Empty' >>> manage_treasury(2, [1, 2], 5, [1, 1, 1, 1, 1]) 'Empty' >>> manage_treasury(1, [100], 1, [1]) 'Empty' >>> manage_treasury(4, [10, 20, 30, 40], 2, [1, 1]) '30 40'","solution":"def manage_treasury(N, stacks, Q, requests): for request in requests: if request == 1 and stacks: stacks.pop(0) if stacks: return ' '.join(map(str, stacks)) else: return \\"Empty\\""},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if the two input strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False >>> are_anagrams(\\"anagram\\", \\"anagram\\") True >>> are_anagrams(\\"rat\\", \\"car\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"aabbcc\\", \\"abc\\") False >>> are_anagrams(\\"Listen\\", \\"Silent\\") False >>> are_anagrams(\\"123!@\\", \\"!@123\\") True","solution":"def are_anagrams(str1, str2): Determines if the two input strings are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. # Convert both strings to sorted lists of characters and compare return sorted(str1) == sorted(str2)"},{"question":"def find_unique_pairs(arr, target): Returns the number of unique pairs in the array that sum up to the target value. Parameters: arr (List[int]): An array of integers. target (int): The target sum. Returns: int: The number of unique pairs that sum up to the target value. Examples: >>> find_unique_pairs([1, 5, 7, -1, 5], 6) 2 >>> find_unique_pairs([2, 4, 6, 8, 10, 12], 10) 2","solution":"def find_unique_pairs(arr, target): Returns the number of unique pairs in the array that sum up to the target value. seen = set() pair_set = set() for number in arr: complement = target - number if complement in seen: pair = tuple(sorted((number, complement))) pair_set.add(pair) seen.add(number) return len(pair_set)"},{"question":"from typing import List def left_rotate(arr: List[int], d: int) -> List[int]: Perform d left rotations on the array arr. >>> left_rotate([1, 2, 3, 4, 5], 4) [5, 1, 2, 3, 4] >>> left_rotate([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> left_rotate([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> left_rotate([1, 2, 3, 4, 5], 7) [3, 4, 5, 1, 2] >>> left_rotate([1], 3) [1] >>> left_rotate([1, 2, 3, 4, 5], 100000) [1, 2, 3, 4, 5]","solution":"from typing import List def left_rotate(arr: List[int], d: int) -> List[int]: Perform d left rotations on the array arr. n = len(arr) d = d % n # In case d > n, reduce d to within the bounds of n return arr[d:] + arr[:d]"},{"question":"def decode_number(encoded_number: str, base: int) -> int: Decodes the encoded number from the specified base to base 10. # Your code here def evaluate_operation(x: int, operator: str, y: int) -> int: Evaluates the expression x operator y. # Your code here def is_operation_correct(statement: str, base: int) -> bool: Checks if the given operation statement is correct in the given base. # Your code here def parse_statement(statement: str) -> tuple: Parses the statement into its components (x, operator, y, z). Statement format is assumed to be \\"X operation Y = Z\\". # Your code here def count_correct_operations(operations: List[str], bases: List[int]) -> int: Counts how many of the given operations are correct in their respective bases. # Your code here # Unit Test def test_decode_number(): assert decode_number('10', 16) == 16 assert decode_number('1a', 16) == 26 assert decode_number('z', 36) == 35 def test_evaluate_operation(): assert evaluate_operation(2, '+', 3) == 5 assert evaluate_operation(10, '-', 2) == 8 assert evaluate_operation(1, '*', 2) == 2 assert evaluate_operation(6, '/', 3) == 2 assert evaluate_operation(5, '/', 2) == None def test_parse_statement(): assert parse_statement('2+3=5') == ('2', '+', '3', '=', '5') assert parse_statement('10-2=8') == ('10', '-', '2', '=', '8') assert parse_statement('1*2=2') == ('1', '*', '2', '=', '2') def test_is_operation_correct(): assert is_operation_correct('2+3=5', 10) == True assert is_operation_correct('10-2=8', 10) == True assert is_operation_correct('1*2=2', 3) == True assert is_operation_correct('a/z=b', 36) == False def test_count_correct_operations(): operations = [ '2+3=5', '10-2=8', '1*2=2' ] bases = [ 10, 10, 3 ] assert count_correct_operations(operations, bases) == 3 operations = [ '2+3=5', 'g-2=a', '1*2=2' ] bases = [ 10, 17, 3 ] assert count_correct_operations(operations, bases) == 2","solution":"def decode_number(encoded_number, base): Decodes the encoded number from the specified base to base 10. return int(encoded_number, base) def evaluate_operation(x, operator, y): Evaluates the expression x operator y. if operator == '+': return x + y elif operator == '-': return x - y elif operator == '*': return x * y elif operator == '/': return x // y if y != 0 and x % y == 0 else None else: raise ValueError(f\\"Unknown operator: {operator}\\") def is_operation_correct(statement, base): Checks if the given operation statement is correct in the given base. x, operator, y, _, z = parse_statement(statement) decoded_x = decode_number(x, base) decoded_y = decode_number(y, base) decoded_z = decode_number(z, base) result = evaluate_operation(decoded_x, operator, decoded_y) return result == decoded_z def parse_statement(statement): Parses the statement into its components (x, operator, y, z). Statement format is assumed to be \\"X operation Y = Z\\". for op in \\"+-*/\\": if op in statement: x, rest = statement.split(op) y, z = rest.split('=') return x, op, y, '=', z return None def count_correct_operations(operations, bases): Counts how many of the given operations are correct in their respective bases. correct_count = 0 for statement, base in zip(operations, bases): if is_operation_correct(statement, base): correct_count += 1 return correct_count"},{"question":"def sum_of_cubes_of_digits(n): Returns the sum of the cubes of the digits of the number n. >>> sum_of_cubes_of_digits(1) 1 >>> sum_of_cubes_of_digits(12) 9 >>> sum_of_cubes_of_digits(123) 36 >>> sum_of_cubes_of_digits(999) 2187 def kth_number_in_sequence(start, k): Returns the k-th number in the special sequence starting from 'start'. >>> kth_number_in_sequence(1, 5) 1 >>> kth_number_in_sequence(12, 1) 12 >>> kth_number_in_sequence(12, 2) 9 >>> kth_number_in_sequence(12, 3) 729 >>> kth_number_in_sequence(12, 4) 1080 def process_multiple_cases(input_cases): Processes multiple cases and returns the results. >>> process_multiple_cases([(1, 5), (12, 3)]) [1, 729] >>> process_multiple_cases([(5, 1), (5, 2)]) [5, 125] >>> process_multiple_cases([(123, 1), (123, 2)]) [123, 36]","solution":"def sum_of_cubes_of_digits(n): Returns the sum of the cubes of the digits of the number n. return sum(int(digit)**3 for digit in str(n)) def kth_number_in_sequence(start, k): Returns the k-th number in the special sequence starting from 'start'. current = start for _ in range(k - 1): current = sum_of_cubes_of_digits(current) return current def process_multiple_cases(input_cases): results = [] for n, k in input_cases: results.append(kth_number_in_sequence(n, k)) return results"},{"question":"def max_magic_power(n, stones): Determines the maximum magic power that can be collected by picking stones in an alternating color pattern. Parameters: - n (int): The number of stones. - stones (list of tuples): A list where each tuple contains a string representing the color and an integer representing the magic power of the stone. Returns: - int: The maximum magic power that can be collected. Example: >>> max_magic_power(5, [(\\"red\\", 5), (\\"blue\\", 10), (\\"red\\", 15), (\\"blue\\", 20), (\\"green\\", 25)]) 75 >>> max_magic_power(1, [(\\"red\\", 10)]) 10 >>> max_magic_power(2, [(\\"red\\", 5), (\\"red\\", 10)]) 10 >>> max_magic_power(3, [(\\"red\\", 5), (\\"blue\\", 5), (\\"red\\", 5)]) 15 >>> max_magic_power(4, [(\\"red\\", 1), (\\"blue\\", 2), (\\"green\\", 3), (\\"yellow\\", 4)]) 10","solution":"def max_magic_power(n, stones): Determines the maximum magic power that can be collected by picking stones in an alternating color pattern. Parameters: - n (int): The number of stones. - stones (list of tuples): A list where each tuple contains a string representing the color and an integer representing the magic power of the stone. Returns: - int: The maximum magic power that can be collected. if n == 0: return 0 from collections import defaultdict # Dictionary to keep track of the maximum power ending with each color max_power = defaultdict(int) # Iterate over each stone for color, power in stones: # Find the maximum power attainable by picking this stone following the king's rules current_max = max([max_power[k] for k in max_power.keys() if k != color], default=0) + power # Update the max power for this color max_power[color] = max(max_power[color], current_max) # Return the highest attainable power return max(max_power.values(), default=0) # Example input data n = 5 stones = [ (\\"red\\", 5), (\\"blue\\", 10), (\\"red\\", 15), (\\"blue\\", 20), (\\"green\\", 25) ] # Expected output is 75 print(max_magic_power(n, stones))"},{"question":"def longest_peak(sequence: List[int]) -> int: Determines the length of the longest peak in the given sequence. A peak is defined as a sub-sequence where the sequence strictly increases and then strictly decreases. Args: sequence (list of int): A list of integers representing the sequence. Returns: int: The length of the longest peak. If there are no peaks, returns 0. >>> longest_peak([1, 3, 2, 4, 5, 3, 2, 1]) 6 >>> longest_peak([1, 1, 1, 1, 1]) 0 >>> longest_peak([1, 2, 3, 2, 1, 2, 3, 2, 1]) 5 >>> longest_peak([5, 4, 3, 2, 1, 2, 3, 4, 5]) 0 >>> longest_peak([-3, -2, -1, 0, -1, -2]) 6 >>> longest_peak([1, 2, 3]) 0 >>> longest_peak([3, 2, 1]) 0","solution":"def longest_peak(sequence): Determines the length of the longest peak in the given sequence. A peak is defined as a sub-sequence where the sequence strictly increases and then strictly decreases. Args: sequence (list of int): A list of integers representing the sequence. Returns: int: The length of the longest peak. If there are no peaks, returns 0. if len(sequence) < 3: return 0 longest_peak_len = 0 i = 1 while i < len(sequence) - 1: # Check if the current element is a peak if sequence[i - 1] < sequence[i] > sequence[i + 1]: left_idx = i - 1 right_idx = i + 1 # Move left pointer to the beginning of the peak while left_idx > 0 and sequence[left_idx - 1] < sequence[left_idx]: left_idx -= 1 # Move right pointer to the end of the peak while right_idx < len(sequence) - 1 and sequence[right_idx] > sequence[right_idx + 1]: right_idx += 1 # Calculate the length of the current peak current_peak_len = right_idx - left_idx + 1 longest_peak_len = max(longest_peak_len, current_peak_len) # Move the pointer to the end of the current peak i = right_idx else: i += 1 return longest_peak_len"},{"question":"def rotate_string(s: str, k: int) -> str: Rotate the string \`s\` to the right by \`k\` positions and return the resulting string. >>> rotate_string('hello', 2) \\"lohel\\" >>> rotate_string('abcdefg', 3) \\"efgabcd\\"","solution":"def rotate_string(s: str, k: int) -> str: Rotates the string \`s\` to the right by \`k\` positions. n = len(s) k = k % n # Reducing k to a manageable number within the length of the string return s[-k:] + s[:-k] if k != 0 else s"},{"question":"def canBeTransformed(S1: str, S2: str) -> int: Checks if S1 can be transformed into S2 by rotating it exactly one place either to the left or to the right. >>> canBeTransformed(\\"abcdef\\", \\"bcdefa\\") 1 >>> canBeTransformed(\\"abcdef\\", \\"fabcde\\") 1 >>> canBeTransformed(\\"abcdef\\", \\"abcedf\\") 0 >>> canBeTransformed(\\"a\\", \\"a\\") 1 >>> canBeTransformed(\\"abc\\", \\"abcd\\") 0","solution":"def canBeTransformed(S1, S2): Checks if S1 can be transformed into S2 by rotating it exactly one place either to the left or to the right. if len(S1) != len(S2): return 0 # Left rotation: Move first character to end left_rotated = S1[1:] + S1[0] # Right rotation: Move last character to start right_rotated = S1[-1] + S1[:-1] if S2 == left_rotated or S2 == right_rotated: return 1 else: return 0"},{"question":"from typing import List def reorganize_string(s: str) -> str: Rearranges the string \`s\` so that no two adjacent characters are the same. If impossible, returns an empty string. >>> reorganize_string(\\"AABB\\") in [\\"ABAB\\", \\"BABA\\"] True >>> reorganize_string(\\"AAAB\\") \\"\\" >>> reorganize_string(\\"AABBC\\") in [\\"ABCAB\\", \\"ABABC\\", \\"ACBAB\\", \\"BACAB\\", \\"BCABA\\", \\"BABAC\\"] True >>> reorganize_string(\\"A\\") \\"A\\" from reorganize_string import test_reorganize_string def test_reorganize_string_AABB(): assert reorganize_string(\\"AABB\\") in [\\"ABAB\\", \\"BABA\\"] def test_reorganize_string_AAAB(): assert reorganize_string(\\"AAAB\\") == \\"\\" def test_reorganize_string_AABBC(): assert reorganize_string(\\"AABBC\\") in [\\"ABCAB\\", \\"ABABC\\", \\"ACBAB\\", \\"BACAB\\", \\"BCABA\\", \\"BABAC\\"] def test_reorganize_string_A(): assert reorganize_string(\\"A\\") == \\"A\\" def test_reorganize_string_single_char_repeated(): assert reorganize_string(\\"AAAAAA\\") == \\"\\" assert reorganize_string(\\"ABABAB\\") in [\\"ABABAB\\", \\"BABABA\\"] def test_reorganize_string_edge_case(): assert reorganize_string(\\"AAABB\\") in [\\"ABABA\\", \\"BABAA\\"] assert reorganize_string(\\"AB\\") in [\\"AB\\", \\"BA\\"]","solution":"from collections import Counter import heapq def reorganize_string(s): Rearranges the string \`s\` so that no two adjacent characters are the same. If impossible, returns an empty string. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"import numpy as np def elementwise_operations(A, B): Given two arrays A and B, compute their element-wise product and the quotient and remainder when dividing A by B element-wise in a vectorized manner. Params: A: List[int] - First list of integers. B: List[int] - Second list of integers. Returns: Tuple[numpy.ndarray, Tuple[numpy.ndarray, numpy.ndarray]] - The element-wise product, and a tuple with quotient and remainder arrays. Example: >>> elementwise_operations([4, 9], [2, 3]) (array([8, 27]), (array([2, 3]), array([0, 0]))) pass def parse_input(input_str): Parse the input string to extract two lists of integers. Params: input_str: str - Multiline string with space separated integers. Returns: Tuple[List[int], List[int]] - Two lists of integers. Example: >>> parse_input(\\"4 9n2 3\\") ([4, 9], [2, 3]) pass","solution":"import numpy as np def elementwise_operations(A, B): A = np.array(A) B = np.array(B) elementwise_product = np.multiply(A, B) quotient_remainder = np.divmod(A, B) return elementwise_product, quotient_remainder def parse_input(input_str): lines = input_str.strip().split('n') A = list(map(int, lines[0].strip().split())) B = list(map(int, lines[1].strip().split())) return A, B"},{"question":"def check_odd_happiness(N: int, happiness: List[int], Q: int, queries: List[Tuple[int, int]]) -> List[str]: Determine if the maximum happiness value in each queried subarray is odd or even. >>> check_odd_happiness(5, [3, 6, 2, 7, 5], 3, [(1, 3), (2, 5), (4, 5)]) ['Even', 'Odd', 'Odd'] >>> check_odd_happiness(4, [2, 4, 6, 8], 2, [(1, 2), (3, 4)]) ['Even', 'Even'] >>> check_odd_happiness(3, [1, 3, 5], 1, [(1, 3)]) ['Odd'] >>> check_odd_happiness(6, [1, 4, 5, 6, 7, 9], 3, [(1, 4), (2, 5), (3, 6)]) ['Even', 'Odd', 'Odd'] >>> check_odd_happiness(7, [2, 4, 6, 1, 3, 7, 8], 4, [(1, 1), (4, 4), (5, 5), (7, 7)]) ['Even', 'Odd', 'Odd', 'Even']","solution":"def check_odd_happiness(N, happiness, Q, queries): results = [] for L, R in queries: # Subtract 1 to convert from 1-based to 0-based index subarray = happiness[L - 1: R] if max(subarray) % 2 == 1: results.append(\\"Odd\\") else: results.append(\\"Even\\") return results"},{"question":"def find_friend_with_ball(N: int, T: List[int], P: int) -> int: Determines which friend will have the ball after P passes in a circular manner. :param N: int - number of friends :param T: list - list of integers representing time each friend waits before passing the ball :param P: int - number of passes :return: int - friend number who will have the ball after P passes >>> find_friend_with_ball(5, [2, 3, 1, 2, 4], 8) == 4 >>> find_friend_with_ball(3, [1, 1, 1], 3) == 1 >>> find_friend_with_ball(6, [2, 1, 3, 2, 4, 3], 11) == 6","solution":"def find_friend_with_ball(N, T, P): Determines which friend will have the ball after P passes in a circular manner. :param N: int - number of friends :param T: list - list of integers representing time each friend waits before passing the ball :param P: int - number of passes :return: int - friend number who will have the ball after P passes # Calculate the position after P passes # The friends are effectively in a circle numbered from 1 to N # P passes would mean P % N gives the number of friend (0-based index) # Using modulo to find the index in circle friend_number = (P % N) + 1 return friend_number"},{"question":"def min_ditches(R: int, C: int, grid: List[str]) -> int: Calculate the minimum number of ditches needed to connect all ponds on Farmer Peter's farm into a single contiguous water body. >>> grid = [ ... \\"P...P\\", ... \\".....\\", ... \\"..P..\\", ... \\"P....\\" ... ] >>> min_ditches(4, 5, grid) 3 >>> grid = [\\"P\\"] >>> min_ditches(1, 1, grid) 0 >>> grid = [ ... \\"PPP\\", ... \\"PPP\\", ... \\"PPP\\" ... ] >>> min_ditches(3, 3, grid) 0 >>> grid = [ ... \\"P..P\\", ... \\"..P.\\", ... \\"P..P\\" ... ] >>> min_ditches(3, 4, grid) 4 >>> grid = [ ... \\"PPP\\", ... \\"...\\", ... \\"PPP\\" ... ] >>> min_ditches(3, 3, grid) 1 # Your implementation here","solution":"from collections import deque def min_ditches(R, C, grid): # Helper function to perform BFS def bfs(start_row, start_col, visited): queue = deque([(start_row, start_col)]) visited[start_row][start_col] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: row, col = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < R and 0 <= new_col < C and not visited[new_row][new_col] and grid[new_row][new_col] == 'P': visited[new_row][new_col] = True queue.append((new_row, new_col)) # Find all the pond cells pond_cells = [(r, c) for r in range(R) for c in range(C) if grid[r][c] == 'P'] # Check if there's any pond cell present if not pond_cells: return 0 # Set to keep track of visited ponds visited = [[False for _ in range(C)] for _ in range(R)] # Count the number of distinct pond clusters clusters = 0 for r, c in pond_cells: if not visited[r][c]: clusters += 1 bfs(r, c, visited) # To connect x clusters, we need (x-1) ditches return clusters - 1"},{"question":"def min_operations_to_make_equal(n: int, arr: List[int]) -> int: A and B love playing games with arrays. They just created a new one to test their skills. You are given an array of n positive integers. You can apply the following operation on the array as many times as you want: - Choose three indices i, j, k (1 ≤ i < j < k ≤ n) such that a_i ≠ a_j ≠ a_k. Then, set a_j to a_i. The goal is to make all elements of the array equal using the fewest number of operations. Args: n (int): number of elements in the array. arr (List[int]): the list of positive integers. Returns: int: the minimum number of operations needed to make all elements of the array equal or -1 if it is not possible. Examples: >>> min_operations_to_make_equal(6, [1, 2, 2, 1, 2, 3]) 3 >>> min_operations_to_make_equal(5, [1, 1, 1, 1, 1]) 0 >>> min_operations_to_make_equal(4, [3, 5, 9, 7]) -1","solution":"def min_operations_to_make_equal(n, arr): from collections import Counter if n == 1: return 0 freq = Counter(arr) most_frequent_count = max(freq.values()) if most_frequent_count == 1: return -1 return n - most_frequent_count"},{"question":"def warehouse_management(operations): Perform warehouse management operations including adding, removing, and totaling boxes' weight. Args: operations(List[str]): List of operation strings. Returns: List[int]: Result of total weight queries. >>> warehouse_management([\\"ADD 1 101 50\\", \\"ADD 1 102 70\\", \\"ADD 2 201 30\\", \\"TOTAL 1\\", \\"REMOVE 1 101 50\\", \\"TOTAL 1\\", \\"ADD 2 202 40\\", \\"TOTAL 2\\"]) [120, 70, 70] >>> warehouse_management([\\"TOTAL 1\\"]) [0] >>> warehouse_management([\\"ADD 1 101 50\\", \\"REMOVE 1 101 50\\", \\"TOTAL 1\\"]) [0]","solution":"def warehouse_management(operations): warehouses = {} result = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": warehouse_id = int(parts[1]) box_id = int(parts[2]) weight = int(parts[3]) if warehouse_id not in warehouses: warehouses[warehouse_id] = {} warehouses[warehouse_id][box_id] = weight elif command == \\"REMOVE\\": warehouse_id = int(parts[1]) box_id = int(parts[2]) weight = int(parts[3]) if warehouse_id in warehouses and box_id in warehouses[warehouse_id]: del warehouses[warehouse_id][box_id] elif command == \\"TOTAL\\": warehouse_id = int(parts[1]) total_weight = sum(warehouses.get(warehouse_id, {}).values()) result.append(total_weight) return result # Example usage: # operations = [ # \\"ADD 1 101 50\\", # \\"ADD 1 102 70\\", # \\"ADD 2 201 30\\", # \\"TOTAL 1\\", # \\"REMOVE 1 101 50\\", # \\"TOTAL 1\\", # \\"ADD 2 202 40\\", # \\"TOTAL 2\\" # ] # print(warehouse_management(operations)) # Output: [120, 70, 70]"},{"question":"def eval_expression(expr: str) -> int: You are given a string containing a mathematical expression with the following constraints: 1. The expression consists of only non-negative integers, parentheses \`(\` and \`)\`, and the operators \`+\`, \`-\`, \`*\`, and \`/\`. 2. The integers and operators are separated by exactly one space. 3. Division is integer division, discarding any remainders. Args: expr (str): A string containing the mathematical expression. Returns: int: The result of evaluating the expression. Example: >>> eval_expression(\\"( 3 + ( 2 * 1 ) )\\") 5 >>> eval_expression(\\"10 + 2 * 6\\") 22 pass from solution import eval_expression def test_simple_addition(): assert eval_expression(\\"3 + 2\\") == 5 def test_simple_subtraction(): assert eval_expression(\\"10 - 3\\") == 7 def test_multiplication(): assert eval_expression(\\"5 * 6\\") == 30 def test_division(): assert eval_expression(\\"8 / 2\\") == 4 def test_mixed_operations(): assert eval_expression(\\"10 + 2 * 6\\") == 22 assert eval_expression(\\"100 * 2 + 12\\") == 212 assert eval_expression(\\"100 * ( 2 + 12 )\\") == 1400 def test_parentheses_operations(): assert eval_expression(\\"( 3 + ( 2 * 1 ) )\\") == 5 assert eval_expression(\\"7 + 3 * ( 10 / ( 12 / ( 3 + 1 ) - 1 ) )\\") == 22 def test_nested_parentheses(): assert eval_expression(\\"( ( 2 + 3 ) * ( 5 - 3 ) )\\") == 10","solution":"def eval_expression(expr): Evaluates a given mathematical expression. The expression consists of non-negative integers, parentheses, and the operators +, -, *, /. def compute(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': values.append(left // right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expr): if expr[i] == ' ': i += 1 continue elif expr[i] == '(': operators.append(expr[i]) elif expr[i].isdigit(): val = 0 while i < len(expr) and expr[i].isdigit(): val = val * 10 + int(expr[i]) i += 1 values.append(val) i -= 1 elif expr[i] == ')': while operators and operators[-1] != '(': compute(operators, values) operators.pop() else: # operator while (operators and precedence(operators[-1]) >= precedence(expr[i])): compute(operators, values) operators.append(expr[i]) i += 1 while operators: compute(operators, values) return values[-1]"},{"question":"def can_schedule_new_appointment(appointments, new_appointment): Determines if a new appointment can be scheduled without conflicts. Parameters: appointments (list of tuple): A list of existing appointments where each appointment is a tuple (start_time, end_time). new_appointment (tuple): A tuple (start_time, end_time) representing the new appointment. Returns: str: \\"YES\\" if the new appointment can be scheduled without conflicts, otherwise \\"NO\\". Examples: >>> can_schedule_new_appointment([(60, 120), (130, 180), (200, 240)], (150, 210)) \\"NO\\" >>> can_schedule_new_appointment([(60, 120), (130, 180), (200, 240)], (180, 200)) \\"YES\\"","solution":"def can_schedule_new_appointment(appointments, new_appointment): Determines if a new appointment can be scheduled without conflicts. Parameters: appointments (list of tuple): A list of existing appointments where each appointment is a tuple (start_time, end_time). new_appointment (tuple): A tuple (start_time, end_time) representing the new appointment. Returns: str: \\"YES\\" if the new appointment can be scheduled without conflicts, otherwise \\"NO\\". new_start, new_end = new_appointment for start, end in appointments: if new_start < end and new_end > start: return \\"NO\\" return \\"YES\\""},{"question":"def can_participate_in_marathon(age: int) -> str: Determines if a person can participate in the marathon based on their age. Parameters: age (int): The age of the person. Returns: str: 'YES' if the person can participate, 'NO' otherwise. >>> can_participate_in_marathon(20) 'YES' >>> can_participate_in_marathon(16) 'NO' >>> can_participate_in_marathon(18) 'YES' >>> can_participate_in_marathon(10) 'NO' >>> can_participate_in_marathon(100) 'YES'","solution":"def can_participate_in_marathon(age): Determines if a person can participate in the marathon based on their age. Parameters: age (int): The age of the person. Returns: str: 'YES' if the person can participate, 'NO' otherwise. if age >= 18: return 'YES' else: return 'NO'"},{"question":"def rotate_string(s: str, k: int) -> str: Returns the string \`s\` rotated to the right by \`k\` positions. >>> rotate_string(\\"hello\\", 2) \\"lohel\\" >>> rotate_string(\\"abcdefg\\", 3) \\"efgabcd\\" >>> rotate_string(\\"rotate\\", 0) \\"rotate\\" >>> rotate_string(\\"\\", 5) \\"\\"","solution":"def rotate_string(s, k): Returns the string \`s\` rotated to the right by \`k\` positions. if not s: return \\"\\" n = len(s) k = k % n # Handle cases where k is larger than the length of the string return s[-k:] + s[:-k]"},{"question":"def extract_unique_dates(date_times: List[str]) -> List[str]: Given a list of date-time strings in the format \\"yyyy-mm-dd hh:mm:ss\\", returns a sorted list of unique dates in the format \\"yyyy-mm-dd\\". >>> extract_unique_dates([ ... \\"2023-05-12 08:12:15\\", ... \\"2023-04-30 14:25:30\\", ... \\"2023-05-12 16:45:10\\", ... \\"2023-04-25 09:15:00\\", ... \\"2023-06-01 11:20:35\\", ... \\"2023-04-25 17:30:24\\" ... ]) [\\"2023-04-25\\", \\"2023-04-30\\", \\"2023-05-12\\", \\"2023-06-01\\"] >>> extract_unique_dates([ ... \\"2023-07-12 08:12:15\\", ... \\"2023-08-30 14:25:30\\", ... \\"2023-09-12 16:45:10\\" ... ]) [\\"2023-07-12\\", \\"2023-08-30\\", \\"2023-09-12\\"] >>> extract_unique_dates([ ... \\"2023-10-12 08:12:15\\", ... \\"2023-10-12 14:25:30\\", ... \\"2023-10-12 16:45:10\\" ... ]) [\\"2023-10-12\\"] >>> extract_unique_dates([]) [] >>> extract_unique_dates([ ... \\"2023-01-12 08:12:15\\", ... \\"2023-02-12 14:25:30\\", ... \\"2023-03-12 16:45:10\\" ... ]) [\\"2023-01-12\\", \\"2023-02-12\\", \\"2023-03-12\\"]","solution":"def extract_unique_dates(date_times): Given a list of date-time strings in the format \\"yyyy-mm-dd hh:mm:ss\\", returns a sorted list of unique dates in the format \\"yyyy-mm-dd\\". dates = set() for date_time in date_times: date = date_time.split(' ')[0] dates.add(date) return sorted(dates)"},{"question":"def total_invitations(T: int, days: List[int]) -> List[int]: Given T test cases and a day number, determine how many people in total have been invited to birthday parties up to and including that day. Each day corresponds to a complete graph invitation pattern where the number of people invited is equal to the day number because each day introduces exactly one more person. Parameters: - T: int, number of test cases. - days: List[int], list of day numbers to calculate invitations for. Returns: - List[int], total number of people invited for each day in the input list. >>> total_invitations(1, [1]) [1] >>> total_invitations(2, [2, 3]) [2, 3] from typing import List # Test cases def test_basic_cases(): assert total_invitations(1, [1]) == [1] assert total_invitations(2, [2, 3]) == [2, 3] def test_edge_cases(): assert total_invitations(1, [1000]) == [1000] assert total_invitations(1, [500]) == [500] def test_multiple_cases(): assert total_invitations(5, [1, 2, 5, 10, 100]) == [1, 2, 5, 10, 100] assert total_invitations(3, [100, 200, 300]) == [100, 200, 300] def test_single_case(): assert total_invitations(1, [1]) == [1] assert total_invitations(1, [50]) == [50] def test_large_case(): assert total_invitations(10, [1000, 999, 998, 997, 996, 995, 994, 993, 992, 991]) == [1000, 999, 998, 997, 996, 995, 994, 993, 992, 991]","solution":"def total_invitations(T, days): Given T test cases and a list of day numbers, return a list of total number of people invited to birthday parties up to and including each day. Each day corresponds to a complete graph invitation pattern where the number of people invited is equal to the day number because each day introduces exactly one more person. Parameters: - T: int, number of test cases - days: List[int], list of day numbers to calculate invitations for Returns: - List[int], total number of people invited for each day in the input list return [day for day in days]"},{"question":"def decrypt_caesar_cipher(encrypted_message: str) -> List[str]: This function takes an encrypted message consisting of uppercase English letters and returns a list of all possible decrypted messages by trying every possible shift from 0 to 25. >>> decrypt_caesar_cipher(\\"BQQMF\\")[0] 'BQQMF' >>> decrypt_caesar_cipher(\\"BQQMF\\")[1] 'APPLE'","solution":"def decrypt_caesar_cipher(encrypted_message): This function takes an encrypted message consisting of uppercase English letters and returns a list of all possible decrypted messages by trying every possible shift from 0 to 25. decrypted_messages = [] for shift in range(26): decrypted_message = \\"\\" for char in encrypted_message: if char.isalpha(): new_char = chr((ord(char) - 65 - shift) % 26 + 65) decrypted_message += new_char else: decrypted_message += char decrypted_messages.append(decrypted_message) return decrypted_messages # Example usage: # encrypted_message = \\"BQQMF\\" # for message in decrypt_caesar_cipher(encrypted_message): # print(message)"},{"question":"def transform_string(s): Transform the string such that no two adjacent characters are the same by performing the minimum number of character replacements. Parameters: s (str): The input string containing only characters 'a' and 'b'. Returns: tuple: A tuple containing the minimum number of replacements needed and the resultant string after the replacements. Examples: >>> transform_string(\\"ab\\") (0, \\"ab\\") >>> transform_string(\\"aaab\\") (1, \\"abab\\") >>> transform_string(\\"aaa\\") (1, \\"aba\\") >>> transform_string(\\"bbbbbb\\") (3, \\"bababa\\") pass def process_test_cases(T, test_cases): Processes multiple test cases for the transform_string function. Parameters: T (int): The number of test cases. test_cases (list): A list of strings, each string being a test case. Returns: list: A list of results for each test case in the form of (replacements, resultant_string). Examples: >>> process_test_cases(2, [\\"ab\\", \\"aaab\\"]) [(0, \\"ab\\"), (1, \\"abab\\")] >>> process_test_cases(3, [\\"aaa\\", \\"a\\", \\"bbbb\\"]) [(1, \\"aba\\"), (0, \\"a\\"), (2, \\"baba\\")] pass","solution":"def transform_string(s): Transform the string such that no two adjacent characters are the same by performing the minimum number of character replacements. Parameters: s (str): The input string containing only characters 'a' and 'b'. Returns: tuple: A tuple containing the minimum number of replacements needed and the resultant string after the replacements. n = len(s) if n == 1: return (0, s) replacements = 0 s = list(s) for i in range(1, n): if s[i] == s[i - 1]: # Replacement needed replacements += 1 # Change the current character to the opposite s[i] = 'b' if s[i] == 'a' else 'a' return replacements, ''.join(s) def process_test_cases(T, test_cases): Processes multiple test cases for the transform_string function. Parameters: T (int): The number of test cases. test_cases (list): A list of strings, each string being a test case. Returns: list: A list of results for each test case in the form of (replacements, resultant_string). results = [] for i in range(T): result = transform_string(test_cases[i]) results.append(result) return results"},{"question":"def is_mountain_array(arr): Determines if the input array is a mountain array. Parameters: arr (list of int): the input array of integers. Returns: str: \\"Mountain\\" if the array is a mountain array, otherwise \\"Not Mountain\\". >>> is_mountain_array([2, 1]) \\"Not Mountain\\" >>> is_mountain_array([3, 5, 5]) \\"Not Mountain\\" >>> is_mountain_array([0, 3, 2, 1]) \\"Mountain\\" >>> is_mountain_array([0, 2, 3, 3, 5]) \\"Not Mountain\\"","solution":"def is_mountain_array(arr): Determines if the input array is a mountain array. Parameters: arr (list of int): the input array of integers. Returns: str: \\"Mountain\\" if the array is a mountain array, otherwise \\"Not Mountain\\". n = len(arr) if n < 3: return \\"Not Mountain\\" i = 0 # walk up while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # peak cannot be first or last if i == 0 or i == n - 1: return \\"Not Mountain\\" # walk down while i + 1 < n and arr[i] > arr[i + 1]: i += 1 return \\"Mountain\\" if i == n - 1 else \\"Not Mountain\\""},{"question":"def largest_subarray_length(n: int, L: int, populations: List[int]) -> int: Determine the largest contiguous subarray of cities where the population sum is less than or equal to a given threshold. Args: n (int): The number of cities. L (int): The population threshold. populations (List[int]): A list of integers representing the populations of the cities. Returns: int: The maximum length of the contiguous subarray where the sum of populations is less than or equal to the given threshold. Examples: >>> largest_subarray_length(5, 10, [1, 2, 3, 4, 5]) 4 >>> largest_subarray_length(6, 8, [2, 2, 2, 2, 2, 2]) 4 >>> largest_subarray_length(3, 5, [10, 20, 30]) 0","solution":"def largest_subarray_length(n, L, populations): left = 0 current_sum = 0 max_length = 0 for right in range(n): current_sum += populations[right] while current_sum > L: current_sum -= populations[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def find_duplicates(arr: List[int]) -> List[int]: Write a function that takes a list of integers and returns another list containing the duplicates from the input list in ascending order. Each element in the resultant list should appear only once. >>> find_duplicates([1, 2, 3, 4, 4, 5, 6, 6, 7]) [4, 6] >>> find_duplicates([10, 20, 20, 30, 30, 30, 40, 50]) [20, 30] >>> find_duplicates([-1, -2, -3, -1, -2, -4]) [-2, -1] >>> find_duplicates([]) []","solution":"def find_duplicates(arr): Finds and returns a list of duplicates in the input list in ascending order. from collections import Counter counter = Counter(arr) duplicates = [item for item, count in counter.items() if count > 1] return sorted(duplicates)"},{"question":"from collections import deque from typing import List def min_steps_to_reach(m: int, n: int, sx: int, sy: int, tx: int, ty: int, grid: List[List[int]]) -> int: Determine the minimum number of steps Ali needs to take to get from the starting position to the ending position. Return -1 if it is impossible for Ali to reach the destination. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. sx (int): Starting x-coordinate. sy (int): Starting y-coordinate. tx (int): Target x-coordinate. ty (int): Target y-coordinate. grid (List[List[int]]): 2D grid representing the city. Returns: int: Minimum number of steps from (sx, sy) to (tx, ty), or -1 if not possible. Examples: >>> grid1 = [ ... [0, 0, 0, 0, 1], ... [0, 1, 1, 0, 1], ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0] ... ] >>> min_steps_to_reach(5, 5, 0, 0, 4, 4, grid1) 8 >>> grid2 = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0] ... ] >>> min_steps_to_reach(3, 3, 0, 0, 2, 2, grid2) -1","solution":"from collections import deque def min_steps_to_reach(m, n, sx, sy, tx, ty, grid): if grid[sx][sy] == 1 or grid[tx][ty] == 1: return -1 # If start or end point is an obstacle directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (tx, ty): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"from typing import List, Tuple def minimum_time_to_complete_events(N: int, durations: List[int], prerequisites: List[Tuple[int, int]]) -> int: Calculate the minimum time required to complete all events given the number of events, their durations, and a list of prerequisites. >>> minimum_time_to_complete_events(4, [3, 2, 1, 4], [(1, 2), (2, 3), (3, 4)]) 10 >>> minimum_time_to_complete_events(4, [7, 1, 3, 4], []) 7 pass # Replace this with your implementation # Unit tests def test_basic_example(): N = 4 durations = [3, 2, 1, 4] prerequisites = [(1, 2), (2, 3), (3, 4)] assert minimum_time_to_complete_events(N, durations, prerequisites) == 10 def test_no_prerequisites(): N = 4 durations = [7, 1, 3, 4] prerequisites = [] assert minimum_time_to_complete_events(N, durations, prerequisites) == 7 def test_single_event(): N = 1 durations = [5] prerequisites = [] assert minimum_time_to_complete_events(N, durations, prerequisites) == 5 def test_multiple_paths(): N = 5 durations = [2, 1, 4, 5, 6] prerequisites = [(1, 2), (1, 3), (2, 4), (3, 5)] assert minimum_time_to_complete_events(N, durations, prerequisites) == 12 def test_circular_dependency(): N = 3 durations = [2, 2, 2] prerequisites = [(1, 2), (2, 3), (3, 1)] # Circular dependency, should not occur in a well-formed input as per constraints try: minimum_time_to_complete_events(N, durations, prerequisites) except: assert True def test_large_input(): N = 1000 durations = [i + 1 for i in range(N)] prerequisites = [] assert minimum_time_to_complete_events(N, durations, prerequisites) == 1000","solution":"from collections import defaultdict, deque def minimum_time_to_complete_events(N, durations, prerequisites): # Initialize in-degrees of all vertices as 0 and create a graph in_degree = [0] * N graph = defaultdict(list) # Build the graph for u, v in prerequisites: graph[u-1].append(v-1) in_degree[v-1] += 1 # Create a queue to process all vertices with in-degree of 0 zero_in_degree_queue = deque() # Initialize the time required to complete each event, initially set to its duration completion_time = durations[:] for i in range(N): if in_degree[i] == 0: zero_in_degree_queue.append(i) # Process until the queue is empty while zero_in_degree_queue: u = zero_in_degree_queue.popleft() # Process adjacent nodes of u for v in graph[u]: # Decrease in-degree of v by 1 in_degree[v] -= 1 # Calculate the completion time considering the current path completion_time[v] = max(completion_time[v], completion_time[u] + durations[v]) # If in-degree becomes 0, add it to the queue if in_degree[v] == 0: zero_in_degree_queue.append(v) # The result is the maximum value in the completion_time array return max(completion_time) # Example usage: N = 4 durations = [3, 2, 1, 4] prerequisites = [(1, 2), (2, 3), (3, 4)] print(minimum_time_to_complete_events(N, durations, prerequisites)) # Output should be 10"},{"question":"def count_participants_who_solved_k_problems(N: int, M: int, K: int, performance_log: List[List[int]]) -> int: Given the performance log of participants in a competition, determines the number of participants who solved at least K problems. Parameters: N (int): Number of participants. M (int): Number of problems. K (int): Minimum number of problems a participant should have solved. performance_log (list of list of int): The performance log where each inner list represents the performance of a participant. Returns: int: The number of participants who solved at least K problems. # Your implementation here # Sample Test Cases def test_example_case(): N, M, K = 4, 5, 3 performance_log = [ [1, 0, 0, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 1] ] assert count_participants_who_solved_k_problems(N, M, K, performance_log) == 3 def test_no_participant_solves_enough_problems(): N, M, K = 3, 4, 3 performance_log = [ [0, 0, 0, 1], [1, 0, 0, 1], [1, 1, 0, 0] ] assert count_participants_who_solved_k_problems(N, M, K, performance_log) == 0 def test_all_participants_solve_k_problems(): N, M, K = 2, 3, 2 performance_log = [ [1, 1, 0], [1, 0, 1] ] assert count_participants_who_solved_k_problems(N, M, K, performance_log) == 2 def test_single_participant_just_meets_k_problems(): N, M, K = 5, 3, 2 performance_log = [ [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 1, 1] ] assert count_participants_who_solved_k_problems(N, M, K, performance_log) == 3 def test_edge_case_min_values(): N, M, K = 1, 1, 1 performance_log = [ [1] ] assert count_participants_who_solved_k_problems(N, M, K, performance_log) == 1","solution":"def count_participants_who_solved_k_problems(N, M, K, performance_log): Given the performance log of participants in a competition, determines the number of participants who solved at least K problems. Parameters: N (int): Number of participants. M (int): Number of problems. K (int): Minimum number of problems a participant should have solved. performance_log (list of list of int): The performance log where each inner list represents the performance of a participant. Returns: int: The number of participants who solved at least K problems. count = 0 for performance in performance_log: if sum(performance) >= K: count += 1 return count"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True pass def filter_and_sort_primes(nums: List[int]) -> List[int]: Given a list of integers, return a new list with only the prime numbers from the original list, sorted in ascending order and with no duplicates. >>> filter_and_sort_primes([]) [] >>> filter_and_sort_primes([1, 2, 3, 4, 5, 6]) ['a', 'b', 'c', 'd', 'e', 'f'] [] >>> filter_and_sort_primes([10, 7, 7, 2, 5, 3, 3, 1]) ['a', 'b', 'c', 'd', 'e', 'f'] [2, 3, 5, 7] >>> filter_and_sort_primes([0, -1, -10, -5, 23]) [23] >>> filter_and_sort_primes([29, 19, 19, 13, 13, 2, 3, 5, 7, 11, 17]) [2, 3, 5, 7, 11, 13, 17, 19, 29] >>> filter_and_sort_primes([4, 6, 8, 9, 10]) [] pass","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False elif n == 2: return True elif n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_and_sort_primes(nums): Given a list of integers, return a new list with only the prime numbers from the original list, sorted in ascending order and with no duplicates. prime_set = {num for num in nums if is_prime(num)} return sorted(prime_set)"},{"question":"from typing import List def shiftGrid(grid: List[List[int]], k: int) -> List[List[int]]: Shifts the grid k times. >>> shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1) [[9,1,2],[3,4,5],[6,7,8]] >>> shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4) [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]","solution":"def shiftGrid(grid, k): Shifts the grid k times. m, n = len(grid), len(grid[0]) flat_list = [grid[i][j] for i in range(m) for j in range(n)] # Efficient k computation to avoid unnecessary operations k = k % len(flat_list) # Perform the shift flat_list = flat_list[-k:] + flat_list[:-k] # Convert back to 2D grid new_grid = [] for i in range(m): new_grid.append(flat_list[i*n:(i+1)*n]) return new_grid"},{"question":"def atm_withdrawal(amount: int) -> dict: Returns a dictionary with the minimal number of each denomination that the ATM will dispense for the given amount. If the amount cannot be dispensed exactly with the available denominations, returns an empty dictionary. >>> atm_withdrawal(280) {'100': 2, '50': 1, '20': 1, '10': 1} >>> atm_withdrawal(370) {'100': 3, '50': 1, '20': 1} >>> atm_withdrawal(15) {}","solution":"def atm_withdrawal(amount): Returns a dictionary with the minimal number of each denomination that the ATM will dispense for the given amount. if amount % 10 != 0: return {} denominations = [100, 50, 20, 10] result = {} for denom in denominations: count = amount // denom if count > 0: result[str(denom)] = count amount -= count * denom return result"},{"question":"def min_operations_to_sort_sequence(n, sequence): Calculate the minimum number of operations required to sort the sequence in non-decreasing order. Args: n (int): the length of the sequence, 1 ≤ n ≤ 100. sequence (List[int]): the elements of the sequence, each element is between 1 and 100. Returns: int: the minimum number of operations required to sort the sequence in non-decreasing order. Example: >>> min_operations_to_sort_sequence(5, [4, 3, 1, 2, 5]) 2 >>> min_operations_to_sort_sequence(4, [2, 4, 3, 1]) 2 >>> min_operations_to_sort_sequence(4, [1, 2, 3, 4]) 0 >>> min_operations_to_sort_sequence(1, [1]) 0 >>> min_operations_to_sort_sequence(5, [5, 4, 3, 2, 1]) 4 >>> min_operations_to_sort_sequence(6, [4, 2, 3, 6, 1, 5]) 3 >>> min_operations_to_sort_sequence(7, [1, 6, 5, 4, 3, 2, 7]) 5","solution":"def min_operations_to_sort_sequence(n, sequence): sorted_sequence = sorted(sequence) longest_increasing_subsequence = 1 current_length = 1 for i in range(1, n): if sequence[i] >= sequence[i - 1]: current_length += 1 longest_increasing_subsequence = max(longest_increasing_subsequence, current_length) else: current_length = 1 return n - longest_increasing_subsequence"},{"question":"class Event: Event Manager class to create and manage events in a calendar application. Attributes: title : str Title of the event, default is \\"Untitled Event\\". date : str Date of the event, default is \\"01/01/1970\\". time : str Time of the event, default is \\"00:00\\". location : str Location of the event, default is \\"TBD\\". attendees : list List of attendees, default is an empty list. description : str Description of the event, default is \\"No Description\\". Methods: add_attendee(name:str): Adds an attendee to the event if not already present. remove_attendee(name:str): Removes an attendee from the event if present. Examples: >>> event = Event() >>> event.title 'Untitled Event' >>> event.date '01/01/1970' >>> event.time '00:00' >>> event.location 'TBD' >>> event.attendees [] >>> event.description 'No Description' >>> event = Event(title=\\"Meeting\\", date=\\"10/10/2023\\", time=\\"09:00\\", location=\\"Office\\", description=\\"Team Meeting\\") >>> event.title 'Meeting' >>> event.date '10/10/2023' >>> event.time '09:00' >>> event.location 'Office' >>> event.attendees [] >>> event.description 'Team Meeting' >>> event.add_attendee(\\"Alice\\") >>> \\"Alice\\" in event.attendees True >>> event.remove_attendee(\\"Alice\\") >>> \\"Alice\\" in event.attendees False","solution":"class Event: def __init__(self, title=\\"Untitled Event\\", date=\\"01/01/1970\\", time=\\"00:00\\", location=\\"TBD\\", description=\\"No Description\\"): self.title = title self.date = date self.time = time self.location = location self.attendees = [] self.description = description def add_attendee(self, name): if name not in self.attendees: self.attendees.append(name) def remove_attendee(self, name): if name in self.attendees: self.attendees.remove(name)"},{"question":"def fibonacci_sum_upto_n(n): Returns the sum of all Fibonacci numbers up to the N-th Fibonacci number, including it. pass def process_test_cases(t, cases): For every test case, returns the sum of all Fibonacci numbers up to the N-th Fibonacci number. Parameters: t (int): The number of test cases. cases (list of int): List containing the test cases each representing N. Returns: list of int: List containing the sum of Fibonacci numbers for each test case. pass # Example Input # t = 3 # cases = [5, 7, 10] # desired output: [12, 33, 143] # Test cases def test_fibonacci_sum_upto_5(): assert fibonacci_sum_upto_n(5) == 12 def test_fibonacci_sum_upto_7(): assert fibonacci_sum_upto_n(7) == 33 def test_fibonacci_sum_upto_10(): assert fibonacci_sum_upto_n(10) == 143 def test_fibonacci_sum_upto_0(): assert fibonacci_sum_upto_n(0) == 0 def test_fibonacci_sum_upto_1(): assert fibonacci_sum_upto_n(1) == 1 def test_fibonacci_multiple_cases(): assert process_test_cases(3, [5, 7, 10]) == [12, 33, 143] assert process_test_cases(2, [1, 2]) == [1, 2] def test_max_constraints(): assert fibonacci_sum_upto_n(50) == 32951280098 assert process_test_cases(1, [50]) == [32951280098]","solution":"def fibonacci_sum_upto_n(n): Returns the sum of all Fibonacci numbers up to the N-th Fibonacci number, including it. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 total_sum = a + b for _ in range(2, n + 1): a, b = b, a + b total_sum += b return total_sum def process_test_cases(t, cases): results = [] for n in cases: results.append(fibonacci_sum_upto_n(n)) return results # Example usage: # t = 3 # cases = [5, 7, 10] # output = process_test_cases(t, cases) # print(output)"},{"question":"from typing import List def findSpecialIndex(s: str) -> int: Returns the index of the first non-repeating character in the string \`s\`. If all characters repeat or the string is empty, returns -1. Examples: >>> findSpecialIndex(\\"leetcode\\") 0 >>> findSpecialIndex(\\"loveleetcode\\") 2 >>> findSpecialIndex(\\"aabbcc\\") -1 pass def test_find_special_index_empty_string(): assert findSpecialIndex(\\"\\") == -1 def test_find_special_index_all_repeating(): assert findSpecialIndex(\\"aabbcc\\") == -1 def test_find_special_index_single_character(): assert findSpecialIndex(\\"x\\") == 0 def test_find_special_index_first_non_repeating(): assert findSpecialIndex(\\"leetcode\\") == 0 assert findSpecialIndex(\\"loveleetcode\\") == 2 def test_find_special_index_multiple_non_repeating(): assert findSpecialIndex(\\"abcd\\") == 0 def test_find_special_index_last_non_repeating(): assert findSpecialIndex(\\"aabbc\\") == 4","solution":"def findSpecialIndex(s): Returns the index of the first non-repeating character in the string \`s\`. If all characters repeat or the string is empty, returns -1. from collections import Counter # Create a counter object to count character occurrences count = Counter(s) # Iterate through the string to find the first non-repeating character for index, char in enumerate(s): if count[char] == 1: return index # If no non-repeating character is found return -1"},{"question":"def largest_rectangle_area(matrix: List[str]) -> int: You are given a grid with N rows and M columns. Each cell contains either a 1 or a 0. Your task is to find the largest rectangle containing all 1's and return its area. Constraints: * 1 ≦ N, M ≦ 1,000 * The grid contains only '0's and '1's. Examples: >>> largest_rectangle_area([\\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\"]) 6 >>> largest_rectangle_area([\\"111\\", \\"111\\"]) 6 >>> largest_rectangle_area([\\"0110\\"]) 2 >>> largest_rectangle_area([\\"1\\", \\"1\\", \\"1\\"]) 3 >>> largest_rectangle_area([\\"1101\\", \\"1101\\", \\"1111\\"]) 6 >>> largest_rectangle_area([\\"000\\", \\"000\\"]) 0 >>> largest_rectangle_area([\\"1\\", \\"1\\", \\"1\\", \\"1\\"]) 4","solution":"def largest_rectangle_area(matrix): def max_histogram_area(histogram): stack, max_area, index = [], 0, 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not matrix: return 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m max_area = 0 for i in range(n): for j in range(m): heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0 max_area = max(max_area, max_histogram_area(heights)) return max_area if __name__ == '__main__': import sys input = sys.stdin.read data = input().strip().split() N, M = int(data[0]), int(data[1]) grid = data[2:] print(largest_rectangle_area(grid))"},{"question":"def largest_block_size(B: str) -> int: Returns the size of the largest block of consecutive 1's in the given binary string B. If there are no 1's in the string, return 0. >>> largest_block_size(\\"110111\\") 3 >>> largest_block_size(\\"0000\\") 0","solution":"def largest_block_size(B): Returns the size of the largest block of consecutive 1's in the given binary string B. If there are no 1's in the string, return 0. max_block_size = 0 current_block_size = 0 for char in B: if char == '1': current_block_size += 1 max_block_size = max(max_block_size, current_block_size) else: current_block_size = 0 return max_block_size"},{"question":"def largest_subset(scores): Given an array of integers representing scores achieved by students in an exam, determine the largest subset of scores such that no two scores in the subset differ by more than one. Input: scores (List[int]): A list of integers representing the scores Output: int: Size of the largest subset with the condition that no two scores differ by more than one. Examples: >>> largest_subset([4, 6, 5, 3, 3, 1]) 3 >>> largest_subset([1]) 1 >>> largest_subset([2, 2, 2, 2]) 4","solution":"def largest_subset(scores): from collections import Counter score_count = Counter(scores) max_subset_size = 0 for score in score_count: current_count = score_count[score] if score + 1 in score_count: current_count += score_count[score + 1] max_subset_size = max(max_subset_size, current_count) return max_subset_size"},{"question":"def min_steps_to_temperature(current: int, T1: int, T2: int) -> int: Determine the minimum number of steps required to change the current temperature to either T1 or T2. >>> min_steps_to_temperature(20, 15, 25) 5 >>> min_steps_to_temperature(10, 7, 12) 2 >>> min_steps_to_temperature(8, 8, 16) 0","solution":"def min_steps_to_temperature(current, T1, T2): Returns the minimum number of steps required to change the current temperature to either T1 or T2. steps_to_T1 = abs(current - T1) steps_to_T2 = abs(current - T2) return min(steps_to_T1, steps_to_T2)"},{"question":"def squareEvenIndices(arr): Takes an array of integers and returns a new array where every integer at an even index is squared. Args: arr (list): A list of integers. Returns: list: A new list with squares at even indices. Examples: >>> squareEvenIndices([1, 2, 3, 4, 5]) [1, 2, 9, 4, 25] >>> squareEvenIndices([10, 15, 20, 25, 30]) [100, 15, 400, 25, 900]","solution":"def squareEvenIndices(arr): Takes an array of integers and returns a new array where every integer at an even index is squared. Args: arr (list): A list of integers. Returns: list: A new list with squares at even indices. return [x ** 2 if i % 2 == 0 else x for i, x in enumerate(arr)] # Example usage: # print(squareEvenIndices([1, 2, 3, 4, 5])) -> [1, 2, 9, 4, 25] # print(squareEvenIndices([10, 15, 20, 25, 30])) -> [100, 15, 400, 25, 900]"},{"question":"from typing import List def find_distinct_groups(N: int, photo_tags: List[List[str]]) -> int: You are given a series of photos that all need to be tagged and sorted. For each photo, there is a tag list containing labels of objects detected in that photo. You need to identify groups of photos that share common tags and provide a common identifier for each group. A group is defined as a set of photos that have at least one common tag. If a photo shares a tag with any photo in the group, it is considered part of that group. Your task is to find the total number of distinct groups. ----Input---- - First argument is an integer N, denoting the number of photos. - Second argument is a list of N lists, where each list contains strings of space-separated tags for each photo. Each tag will be a lowercase alphabetic string. ----Output---- - A single integer representing the number of distinct groups of photos. ----Constraints---- - 1 ≤ N ≤ 1000 - 1 ≤ Number of tags per photo ≤ 100 - 1 ≤ Length of each tag ≤ 20 >>> find_distinct_groups(4, [[\\"cat\\", \\"dog\\", \\"bird\\"], [\\"dog\\", \\"fish\\"], [\\"apple\\", \\"banana\\"], [\\"banana\\", \\"orange\\"]]) == 2 >>> find_distinct_groups(1, [[\\"cat\\"]]) == 1 >>> find_distinct_groups(2, [[\\"cat\\"], [\\"dog\\"]]) == 2 >>> find_distinct_groups(3, [[\\"cat\\", \\"dog\\"], [\\"dog\\", \\"fish\\"], [\\"cat\\", \\"bird\\"]]) == 1 >>> find_distinct_groups(4, [[\\"a\\"], [\\"a\\"], [\\"a\\"], [\\"a\\"]]) == 1","solution":"def find_distinct_groups(N, photo_tags): from collections import defaultdict # Create a mapping from each tag to the photos that contain it tag_to_photos = defaultdict(set) for i, tags in enumerate(photo_tags): for tag in tags: tag_to_photos[tag].add(i) # Create adjacency list for graph photo_graph = defaultdict(set) for photos in tag_to_photos.values(): photos = list(photos) for i in range(len(photos)): for j in range(i + 1, len(photos)): photo_graph[photos[i]].add(photos[j]) photo_graph[photos[j]].add(photos[i]) # Use DFS to find connected components def dfs(photo, visited): stack = [photo] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in photo_graph[current]: if neighbor not in visited: stack.append(neighbor) visited = set() groups = 0 for photo in range(N): if photo not in visited: groups += 1 dfs(photo, visited) return groups # Example usage: N = 4 photo_tags = [ [\\"cat\\", \\"dog\\", \\"bird\\"], [\\"dog\\", \\"fish\\"], [\\"apple\\", \\"banana\\"], [\\"banana\\", \\"orange\\"] ] print(find_distinct_groups(N, photo_tags)) # Output: 2"},{"question":"def number_of_distinct_species_in_largest_component(n, m, species, connections): Calculate the number of distinct species in the largest connected component of the forest. Args: n (int): the number of trees m (int): the number of connections species (List[int]): the list of species labels for each tree connections (List[Tuple[int, int]]): list of tuples representing the connections between trees Returns: int: number of distinct species in the largest connected component Examples: >>> number_of_distinct_species_in_largest_component(5, 3, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (4, 5)]) 3 >>> number_of_distinct_species_in_largest_component(6, 5, [1, 1, 2, 2, 3, 3], [(1, 2), (2, 3), (3, 6), (4, 5), (5, 6)]) 3 >>> number_of_distinct_species_in_largest_component(4, 0, [1, 1, 1, 1], []) 1","solution":"def number_of_distinct_species_in_largest_component(n, m, species, connections): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in connections: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) # DFS to find connected components def bfs(node): queue = deque([node]) visited.add(node) component = [] while queue: current = queue.popleft() component.append(current) for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return component visited = set() largest_component = [] for i in range(n): if i not in visited: component = bfs(i) if len(component) > len(largest_component): largest_component = component distinct_species = set(species[i] for i in largest_component) return len(distinct_species)"},{"question":"def count_digit_in_range(N, D): Count the occurrences of the digit D in the range from 1 to N (inclusive). Parameters: N (int): The upper limit of the range. D (str): The digit to count (as a string). Returns: int: The count of occurrences of digit D. pass def solve(test_cases): Solve the problem for multiple test cases. Parameters: test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains two elements: an integer N and a string D. Returns: List[int]: A list of integers where each integer is the result for the corresponding test case. pass def main(input_data): Read input, process the test cases, and print the results. Parameters: input_data (str): The input data as a single string. pass from solution import count_digit_in_range, solve def test_count_digit_in_range(): assert count_digit_in_range(13, '1') == 6 assert count_digit_in_range(20, '2') == 3 assert count_digit_in_range(100, '0') == 11 assert count_digit_in_range(9, '9') == 1 assert count_digit_in_range(50, '5') == 6 def test_solve(): assert solve([(13, '1'), (20, '2')]) == [6, 3] assert solve([(100, '0'), (50, '5')]) == [11, 6] assert solve([(1, '0'), (9, '9')]) == [0, 1]","solution":"def count_digit_in_range(N, D): Count the occurrences of the digit D in the range from 1 to N (inclusive). Parameters: N (int): The upper limit of the range. D (str): The digit to count (as a string). Returns: int: The count of occurrences of digit D. count = 0 for num in range(1, N + 1): count += str(num).count(D) return count def solve(test_cases): results = [] for N, D in test_cases: results.append(count_digit_in_range(N, D)) return results def main(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] for i in range(1, T * 2, 2): N = int(input_lines[i]) D = input_lines[i + 1] test_cases.append((N, D)) results = solve(test_cases) for result in results: print(result)"},{"question":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: Sorts a list of integers using bubble sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([-5, -1, 0, 3, 7, 2]) [-5, -1, 0, 2, 3, 7]","solution":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: Sorts a list of integers using bubble sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. n = len(arr) # Create a copy of the list to avoid modifying the original list sorted_arr = arr[:] # Perform bubble sort for i in range(n): swapped = False for j in range(0, n-i-1): if sorted_arr[j] > sorted_arr[j+1]: sorted_arr[j], sorted_arr[j+1] = sorted_arr[j+1], sorted_arr[j] swapped = True if not swapped: # No more swaps needed, array is sorted break return sorted_arr"},{"question":"def find_minimum_tour_distance(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum driving distance needed to make the circular route visiting all cities exactly once and returning to the starting city. Parameters: n (int): The number of cities. m (int): The number of direct roads. roads (List[Tuple[int, int, int]]): List of tuples representing the direct roads between cities with their distances. Returns: int: The minimum total driving distance for the road trip. Example: >>> find_minimum_tour_distance(4, 5, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (3, 4, 25)]) 80 >>> find_minimum_tour_distance(3, 3, [(1, 2, 10), (2, 3, 15), (3, 1, 20)]) 45","solution":"import itertools import sys def find_minimum_tour_distance(n, m, roads): # Initialize the distance matrix with infinity. dist = [[float('inf')] * n for _ in range(n)] # Fill in the initial distances given by roads for u, v, w in roads: dist[u-1][v-1] = min(dist[u-1][v-1], w) dist[v-1][u-1] = min(dist[v-1][u-1], w) # Use the Floyd Warshall algorithm to find the shortest paths for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Find the minimum TSP tour using permutations cities = list(range(n)) min_tour_distance = float('inf') for perm in itertools.permutations(cities[1:]): # fix the first city as the starting city current_distance = 0 current_city = 0 # start from city 0 for next_city in perm: current_distance += dist[current_city][next_city] current_city = next_city current_distance += dist[current_city][0] # Returning to the starting city min_tour_distance = min(min_tour_distance, current_distance) return min_tour_distance"},{"question":"def min_spreading_cost(n, m, s, edges): Calculate the minimum cost required to spread the rumor to all nodes in the network. Args: n (int): Number of nodes. m (int): Number of edges. s (int): Starting node. edges (List[Tuple[int, int, int]]): List of edges represented by tuples (u, v, w) where there is an edge between nodes u and v with a communication cost of w. Returns: int: Minimum communication cost required for the rumor to reach all nodes starting from node s. Example: >>> min_spreading_cost(4, 4, 1, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10)]) 12 >>> min_spreading_cost(5, 4, 2, [(1, 2, 1), (2, 3, 2), (2, 4, 3), (4, 5, 4)]) 10 from solution import min_spreading_cost def test_example_1(): n = 4 m = 4 s = 1 edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10) ] assert min_spreading_cost(n, m, s, edges) == 12 def test_example_2(): n = 5 m = 4 s = 2 edges = [ (1, 2, 1), (2, 3, 2), (2, 4, 3), (4, 5, 4) ] assert min_spreading_cost(n, m, s, edges) == 10 def test_single_node(): n = 2 m = 1 s = 1 edges = [ (1, 2, 7) ] assert min_spreading_cost(n, m, s, edges) == 7 def test_disconnected_graph(): n = 3 m = 2 s = 1 edges = [ (1, 2, 3), (1, 3, 5) ] assert min_spreading_cost(n, m, s, edges) == 8 def test_more_edges(): n = 5 m = 6 s = 4 edges = [ (1, 2, 2), (1, 3, 3), (2, 3, 4), (3, 4, 1), (4, 5, 6), (2, 5, 10) ] assert min_spreading_cost(n, m, s, edges) == 12 def test_all_nodes_directly_connected(): n = 4 m = 6 s = 1 edges = [ (1, 2, 2), (1, 3, 1), (1, 4, 4), (2, 3, 3), (2, 4, 2), (3, 4, 5) ] assert min_spreading_cost(n, m, s, edges) == 5","solution":"import heapq def min_spreading_cost(n, m, s, edges): # Create an adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) # Keep track of the total cost and visited nodes total_cost = 0 visited = set() # Use a min-heap to always expand the cheapest edge min_heap = [(0, s)] # (cost, node) while min_heap and len(visited) < n: cost, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_cost += cost for edge_cost, next_node in graph[node]: if next_node not in visited: heapq.heappush(min_heap, (edge_cost, next_node)) return total_cost"},{"question":"def quadratic_factorial(n: int) -> int: Calculate the quadratic factorial of a given positive integer n using a recursive approach. >>> quadratic_factorial(8) # should return 384 >>> quadratic_factorial(7) # should return 105 pass # Unit Tests def test_quadratic_factorial_even(): assert quadratic_factorial(8) == 384 assert quadratic_factorial(4) == 8 assert quadratic_factorial(6) == 48 def test_quadratic_factorial_odd(): assert quadratic_factorial(7) == 105 assert quadratic_factorial(5) == 15 assert quadratic_factorial(9) == 945 def test_quadratic_factorial_base_cases(): assert quadratic_factorial(1) == 1 assert quadratic_factorial(2) == 2 assert quadratic_factorial(3) == 3","solution":"def quadratic_factorial(n): Returns the quadratic factorial of a positive integer n using recursion. if n <= 1: return 1 return n * quadratic_factorial(n - 2) # Examples: # quadratic_factorial(8) should return 384 # quadratic_factorial(7) should return 105"},{"question":"def total_orders_by_customer(orders: dict) -> dict: Accepts a dictionary where the keys are customer names and the values are lists of order amounts. Returns a new dictionary where each key is a customer name in lowercase, and the value is the total amount they have ordered. Combines orders of duplicate customer names (case insensitive). >>> total_orders_by_customer({}) {} >>> total_orders_by_customer({\\"Alice\\": []}) {\\"alice\\": 0} >>> total_orders_by_customer({\\"Alice\\": [50]}) {\\"alice\\": 50} >>> total_orders_by_customer({\\"Alice\\": [10, 20, 30]}) {\\"alice\\": 60} >>> total_orders_by_customer({\\"Alice\\": [10, 20], \\"BOB\\": [5], \\"CHARLIE\\": [50, 60]}) {\\"alice\\": 30, \\"bob\\": 5, \\"charlie\\": 110} >>> total_orders_by_customer({\\"Alice\\": [10, 20], \\"alice\\": [15], \\"ALICE\\": [5], \\"Charlie\\": [30], \\"charlie\\": [25]}) {\\"alice\\": 50, \\"charlie\\": 55}","solution":"def total_orders_by_customer(orders): Accepts a dictionary where the keys are customer names and the values are lists of order amounts. Returns a new dictionary where each key is a customer name in lowercase, and the value is the total amount they have ordered. Combines orders of duplicate customer names (case insensitive). combined_orders = {} for customer, amounts in orders.items(): customer_lower = customer.lower() if customer_lower not in combined_orders: combined_orders[customer_lower] = 0 combined_orders[customer_lower] += sum(amounts) return combined_orders"},{"question":"def sort_items_by_price(s: str) -> str: Sort items by their prices in ascending order. If prices are the same, sort by names alphabetically. Returns a formatted string of the sorted items. >>> sort_items_by_price(\\"apple:1.20;banana:0.50;cherry:2.00;date:3.10;elderberry:1.50;fig:2.50;grape:0.90\\") '(BANANA:0.50)(GRAPE:0.90)(APPLE:1.20)(ELDERBERRY:1.50)(CHERRY:2.00)(FIG:2.50)(DATE:3.10)'","solution":"def sort_items_by_price(s): Sort items by their prices in ascending order. If prices are the same, sort by names alphabetically. Returns a formatted string of the sorted items. items = s.split(\\";\\") item_list = [] # Split items and convert prices to float for item in items: name, price = item.split(\\":\\") item_list.append((name.upper(), float(price))) # Sort items first by price, then by name item_list.sort(key=lambda x: (x[1], x[0])) # Create the result string in the required format result = \\"\\".join([f\\"({name}:{price:.2f})\\" for name, price in item_list]) return result"},{"question":"def find_potion_order(n, m, rules): Determine if it is possible to create all the potions following the given order constraints. If it is possible, return one valid order of creating the potions. Otherwise, return \\"IMPOSSIBLE\\". >>> find_potion_order(3, 2, [(1, 2), (2, 3)]) [1, 2, 3] >>> find_potion_order(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"IMPOSSIBLE\\" >>> find_potion_order(4, 0, []) [1, 2, 3, 4] def process_test_cases(T, test_cases): Process the test cases for the potion order problem and output results for each test case. >>> process_test_cases(3, [(3, 2, [(1, 2), (2, 3)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (4, 0, [])]) [\\"1 2 3\\", \\"IMPOSSIBLE\\", \\"1 2 3 4\\"] >>> process_test_cases(2, [(2, 1, [(2, 1)]), (1, 0, [])]) [\\"2 1\\", \\"1\\"]","solution":"def find_potion_order(n, m, rules): from collections import defaultdict, deque # Create graph and in-degree count graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} for x, y in rules: graph[x].append(y) in_degree[y] += 1 # Initialize queue with nodes having no incoming edges queue = deque([node for node in range(1, n+1) if in_degree[node] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we were able to process all nodes if len(result) == n: return result else: return \\"IMPOSSIBLE\\" def process_test_cases(T, test_cases): results = [] for i in range(T): n, m, rules = test_cases[i] result = find_potion_order(n, m, rules) if isinstance(result, list): results.append(\\" \\".join(map(str, result))) else: results.append(result) return results"},{"question":"def is_balanced(lst): Determines if a list is balanced. A list is balanced if the sum of the first half equals the sum of the second half. Parameters: lst (list of int): The list of integers. Returns: str: 'YES' if the list is balanced, 'NO' otherwise. >>> is_balanced([1, 2, 3, 3, 2, 1]) == \\"YES\\" >>> is_balanced([1, 1, 1, 2]) == \\"NO\\"","solution":"def is_balanced(lst): Determines if a list is balanced. A list is balanced if the sum of the first half equals the sum of the second half. Parameters: lst (list of int): The list of integers. Returns: str: 'YES' if the list is balanced, 'NO' otherwise. n = len(lst) first_half = lst[:n//2] second_half = lst[n//2:] if sum(first_half) == sum(second_half): return \\"YES\\" else: return \\"NO\\""},{"question":"def review_comments(reviews): Determine which team member made the most comments. In case of a tie, return all names tied for the highest number of comments. Parameters: reviews (list of tuples): A list where each tuple contains a team member's name and the number of comments they've made. Returns: list: A sorted list of names who made the most comments. >>> review_comments([(\\"Alice\\", 5), (\\"Bob\\", 5), (\\"Charlie\\", 8), (\\"Diana\\", 8)]) [\\"Charlie\\", \\"Diana\\"] >>> review_comments([(\\"Alice\\", 10), (\\"Bob\\", 8), (\\"Charlie\\", 8)]) [\\"Alice\\"] >>> review_comments([]) [] >>> review_comments([(\\"Alice\\", 4), (\\"Bob\\", 4), (\\"Charlie\\", 4)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> review_comments([(\\"Alice\\", 2)]) [\\"Alice\\"] >>> review_comments([(\\"Alice\\", -1), (\\"Bob\\", -2), (\\"Charlie\\", -1)]) [\\"Alice\\", \\"Charlie\\"] >>> review_comments([(\\"Alice\\", -1), (\\"Bob\\", 0), (\\"Charlie\\", -3)]) [\\"Bob\\"]","solution":"def review_comments(reviews): Determine which team member made the most comments. In case of a tie, return all names tied for the highest number of comments. Parameters: reviews (list of tuples): A list where each tuple contains a team member's name and the number of comments they've made. Returns: list: A sorted list of names who made the most comments. if not reviews: return [] max_comments = max(reviews, key=lambda x: x[1])[1] return sorted([name for name, comments in reviews if comments == max_comments])"},{"question":"from typing import List from collections import Counter def sort_strings_by_frequency(strings: List[str]) -> List[str]: This function takes a list of strings and returns a list of strings sorted based on their frequency in descending order. If two strings have the same frequency, they are sorted lexicographically in ascending order. >>> sort_strings_by_frequency([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) ['apple', 'banana', 'orange'] >>> sort_strings_by_frequency([\\"cat\\", \\"dog\\", \\"dog\\", \\"bird\\", \\"cat\\", \\"dog\\", \\"elephant\\"]) ['dog', 'cat', 'bird', 'elephant'] >>> sort_strings_by_frequency([\\"zebra\\", \\"panther\\", \\"zebra\\", \\"panther\\", \\"zebra\\", \\"lion\\", \\"panther\\", \\"lion\\"]) ['panther', 'zebra', 'lion'] >>> sort_strings_by_frequency([\\"a\\", \\"b\\", \\"a\\", \\"b\\", \\"c\\", \\"c\\"]) ['a', 'b', 'c'] >>> sort_strings_by_frequency([\\"apple\\"]) ['apple'] >>> sort_strings_by_frequency([\\"e\\", \\"d\\", \\"c\\", \\"b\\", \\"a\\"]) ['a', 'b', 'c', 'd', 'e']","solution":"from collections import Counter def sort_strings_by_frequency(strings): This function takes a list of strings and returns a list of strings sorted based on their frequency in descending order. If two strings have the same frequency, they are sorted lexicographically in ascending order. # Count the frequency of each string counts = Counter(strings) # Sort based on the frequency (in descending order) and then lexicographically sorted_strings = sorted(counts.keys(), key=lambda x: (-counts[x], x)) return sorted_strings"},{"question":"def is_bipartite_graph(n, m, edges): Check if the given undirected graph is bipartite. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples representing edges (u, v) :return: 'YES' if the graph is bipartite, otherwise 'NO' # Your code here # Unit tests def test_is_bipartite_graph(): assert is_bipartite_graph(3, 3, [(1, 2), (2, 3), (3, 1)]) == 'NO' assert is_bipartite_graph(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 'YES' assert is_bipartite_graph(4, 3, [(1, 2), (2, 3), (3, 4)]) == 'YES' assert is_bipartite_graph(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == 'NO' assert is_bipartite_graph(1, 0, []) == 'YES' assert is_bipartite_graph(3, 0, []) == 'YES' assert is_bipartite_graph(3, 2, [(1, 2), (2, 3)]) == 'YES' assert is_bipartite_graph(6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]) == 'NO' assert is_bipartite_graph(3, 2, [(1, 2), (2, 3), (1, 3)]) == 'NO' assert is_bipartite_graph(7, 6, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7), (7, 4)]) == 'YES'","solution":"from collections import deque, defaultdict def is_bipartite_graph(n, m, edges): Check if the given undirected graph is bipartite. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples representing edges (u, v) :return: 'YES' if the graph is bipartite, otherwise 'NO' def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in color: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # To keep track of the colors of the nodes color = {} # We need to check each component of the graph for node in range(1, n + 1): if node not in color: if not bfs(node): return 'NO' return 'YES'"},{"question":"def max_parks(n: int, coordinates: List[Tuple[int, int]]) -> int: Determine the maximum number of parks Hana and Yuki can visit in a single journey under the restrictions of North-East direction only. >>> max_parks(5, [(1, 2), (2, 3), (3, 4), (1, 3), (2, 4)]) == 3 >>> max_parks(6, [(0, 0), (1, 1), (2, 2), (1, 0), (0, 1), (1, 2)]) == 3 from typing import List, Tuple def test_example1(): assert max_parks(5, [(1, 2), (2, 3), (3, 4), (1, 3), (2, 4)]) == 3 def test_example2(): assert max_parks(6, [(0, 0), (1, 1), (2, 2), (1, 0), (0, 1), (1, 2)]) == 3 def test_one_park(): assert max_parks(1, [(0, 0)]) == 1 def test_no_path(): assert max_parks(3, [(1, 1), (3, 3), (5, 5)]) == 1 def test_max_case(): coordinates = [(i, i) for i in range(1000)] assert max_parks(1000, coordinates) == 1000","solution":"def max_parks(n, coordinates): coordinates = set(map(tuple, coordinates)) max_count = 0 for x, y in coordinates: count = 1 current_x, current_y = x, y while (current_x + 1, current_y + 1) in coordinates: count += 1 current_x, current_y = current_x + 1, current_y + 1 max_count = max(max_count, count) return max_count"},{"question":"def max_sum_of_continuous_segment(trees_height: List[int]) -> int: Finds the maximum sum of heights of a continuous segment of trees in the park. Parameters: trees_height (List[int]): List of integers representing the heights of trees in the park. Returns: int: The maximum sum of heights of a continuous segment of trees. >>> max_sum_of_continuous_segment([4, -1, 2, 1, -5, 4]) 6 >>> max_sum_of_continuous_segment([1, 2, 3, 4, 5]) 15 >>> max_sum_of_continuous_segment([-1, -2, -3, -4, -5]) -1 >>> max_sum_of_continuous_segment([4, -1, 2, 1, -5, 4, 6, -1]) 11 >>> max_sum_of_continuous_segment([4]) 4 >>> max_sum_of_continuous_segment([-4]) -4 pass","solution":"def max_sum_of_continuous_segment(trees_height): Finds the maximum sum of heights of a continuous segment of trees using Kadane's Algorithm. Parameters: trees_height (List[int]): List of integers representing the heights of trees in the park. Returns: int: The maximum sum of heights of a continuous segment of trees. max_current = max_global = trees_height[0] for height in trees_height[1:]: max_current = max(height, max_current + height) if max_current > max_global: max_global = max_current return max_global"},{"question":"from collections import Counter import re def can_form_palindrome(s: str) -> bool: Checks whether the given string is a palindrome or can be rearranged to form a palindrome, ignoring spaces, punctuation, and case sensitivity. >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> can_form_palindrome(\\"Was it a car or a cat I saw\\") True >>> can_form_palindrome(\\"No lemon, no melon\\") True >>> can_form_palindrome(\\"apple\\") False","solution":"from collections import Counter import re def can_form_palindrome(s): Checks whether the given string is a palindrome or can be rearranged to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string is a palindrome or can be rearranged to form one, False otherwise. # Removing spaces, punctuation, and converting to lowercase cleaned_s = re.sub(r'[W_]', '', s).lower() # Counting frequency of each character freq_count = Counter(cleaned_s) # Checking the number of characters with odd frequencies odd_count = sum(count % 2 for count in freq_count.values()) # There can be at most one character with an odd frequency return odd_count <= 1"},{"question":"def max_unique_subarray_sum(m, b): Returns the maximum sum of any subarray with all unique elements. :param m: integer, length of the array b :param b: list of integers, the array elements :return: integer, the maximum sum of subarray with unique elements >>> max_unique_subarray_sum(6, [4, 3, 5, 3, 4, 6]) 18 >>> max_unique_subarray_sum(5, [2, 2, 2, 2, 2]) 2","solution":"def max_unique_subarray_sum(m, b): Returns the maximum sum of any subarray with all unique elements. :param m: integer, length of the array b :param b: list of integers, the array elements :return: integer, the maximum sum of subarray with unique elements left = 0 unique_elements = set() current_sum = 0 max_sum = 0 for right in range(m): while b[right] in unique_elements: unique_elements.remove(b[left]) current_sum -= b[left] left += 1 unique_elements.add(b[right]) current_sum += b[right] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed using consecutive buildings. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The area of the largest rectangle. pass from solution import largest_rectangle_area def test_empty_heights(): assert largest_rectangle_area([]) == 0 def test_single_height(): assert largest_rectangle_area([5]) == 5 def test_multiple_same_heights(): assert largest_rectangle_area([3, 3, 3, 3, 3]) == 15 def test_varying_heights_case1(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_varying_heights_case2(): assert largest_rectangle_area([4, 2, 0, 3, 2, 5]) == 6 def test_varying_heights_case3(): assert largest_rectangle_area([2, 4]) == 4 def test_varying_heights_case4(): assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed using consecutive buildings. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"import itertools def minimum_distance(n: int, distances: List[List[int]]) -> int: Determines the minimum distance required to visit all locations starting and ending at the first location (location 1) in a treasure hunt game. Parameters: n (int): The number of locations, including the starting location. distances (List[List[int]]): A matrix representing distances between each pair of locations. Returns: int: The minimum distance required to visit all locations and return to the starting point. >>> minimum_distance(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 >>> minimum_distance(3, [ ... [0, 1, 3], ... [1, 0, 2], ... [3, 2, 0] ... ]) 6","solution":"import itertools def minimum_distance(n, distances): Computes the minimum distance required to visit all locations starting and ending at the first location. Parameters: - n: The number of locations. - distances: A 2D list representing the distance matrix between locations. Returns: - minimum_distance: The minimum distance required to complete the treasure hunt. # Generate all permutations of the locations excluding the starting location permutations = itertools.permutations(range(1, n)) min_distance = float('inf') for perm in permutations: current_distance = distances[0][perm[0]] # Distance from start to first in perm for i in range(1, len(perm)): current_distance += distances[perm[i-1]][perm[i]] # Distance between consecutive locations in perm current_distance += distances[perm[-1]][0] # Distance from the last in perm back to start min_distance = min(min_distance, current_distance) return min_distance"},{"question":"def matrix_multiplication(A, B, N, M, P): Multiplies two matrices A and B where A is of size NxM and B is of size MxP. Args: A (list of list of int): Matrix A of size NxM. B (list of list of int): Matrix B of size MxP. N (int): Number of rows in matrix A. M (int): Number of columns in matrix A (and number of rows in matrix B). P (int): Number of columns in matrix B. Returns: list of list of int: Resultant matrix C after multiplication. >>> N, M, P = 2, 3, 2 >>> A = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> B = [ ... [7, 8], ... [9, 10], ... [11, 12] ... ] >>> matrix_multiplication(A, B, N, M, P) [[58, 64], [139, 154]]","solution":"def matrix_multiplication(A, B, N, M, P): Multiplies two matrices A and B where A is of size NxM and B is of size MxP. Args: A (list of list of int): Matrix A of size NxM. B (list of list of int): Matrix B of size MxP. N (int): Number of rows in matrix A. M (int): Number of columns in matrix A (and number of rows in matrix B). P (int): Number of columns in matrix B. Returns: list of list of int: Resultant matrix C after multiplication. # Initialize matrix C with zeros C = [[0 for _ in range(P)] for _ in range(N)] # Perform matrix multiplication for i in range(N): for j in range(P): for k in range(M): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"def min_operations_to_uniform_string(t, test_cases): Determine the minimum number of operations required to convert each string into a string where all characters are the same (either all 'a' or all 'b'). Args: t (int): The number of test cases. test_cases (List[str]): A list of strings containing only 'a' and 'b'. Returns: List[int]: A list of integers where each integer represents the minimum number of operations required for the corresponding string in test_cases. Examples: >>> min_operations_to_uniform_string(3, [\\"abab\\", \\"aaaa\\", \\"bbaa\\"]) [1, 0, 1]","solution":"def min_operations_to_uniform_string(t, test_cases): Returns the minimum number of operations required to convert each string in the test_cases list into a string where all characters are the same. results = [] for s in test_cases: count_a = s.count('a') count_b = s.count('b') results.append(min(count_a, count_b)) return results"},{"question":"from typing import List def arrayIntersection(arr1: List[int], arr2: List[int]) -> List[int]: Returns the intersection of two integer arrays as an array of integers. Each element in the result appears as many times as it shows in both arrays. Args: arr1 (List[int]): The first list of integers. arr2 (List[int]): The second list of integers. Returns: List[int]: The intersection list of integers. Examples: >>> arrayIntersection([1, 2, 2, 1], [2, 2]) [2, 2] >>> arrayIntersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9]","solution":"from collections import Counter def arrayIntersection(arr1, arr2): Returns the intersection of two integer arrays as an array of integers. Each element in the result appear as many times as it shows in both arrays. # Count the frequency of each element in both arrays count1 = Counter(arr1) count2 = Counter(arr2) # Find the intersection intersection = [] for num in count1: if num in count2: intersection.extend([num] * min(count1[num], count2[num])) return intersection"},{"question":"def arraySum(arr: List[int], N: int) -> int: Returns the sum of all elements in the array arr of size N. >>> arraySum([1, 2, 3, 4, 5], 5) 15 >>> arraySum([10, -2, 3], 3) 11","solution":"def arraySum(arr, N): Returns the sum of all elements in the array arr of size N. return sum(arr)"},{"question":"def replaceOddWords(s: str) -> str: Replaces words at odd indices with the word \\"odd\\". Args: s (str): Input string. Returns: str: Modified string with words at odd indices replaced with \\"odd\\". >>> replaceOddWords(\\"The quick brown fox jumps over the lazy dog\\") 'The odd brown odd jumps odd the odd dog' >>> replaceOddWords(\\"\\") '' >>> replaceOddWords(\\"Hello\\") 'Hello' >>> replaceOddWords(\\"Hello world\\") 'Hello odd' >>> replaceOddWords(\\"One two three four five six seven eight\\") 'One odd three odd five odd seven odd' >>> replaceOddWords(\\"Space at the end \\") 'Space odd the odd' >>> replaceOddWords(\\"word word word word\\") 'word odd word odd'","solution":"def replaceOddWords(s): Replaces words at odd indices with the word \\"odd\\". Args: s (str): Input string. Returns: str: Modified string with words at odd indices replaced with \\"odd\\". if not s: return \\"\\" words = s.split() result = [] for i, word in enumerate(words): if i % 2 == 1: result.append(\\"odd\\") else: result.append(word) return \\" \\".join(result)"},{"question":"def max_same_temperature_rooms(n: int, k: int, temperatures: List[int]) -> int: Determines the maximum number of rooms that can have their temperatures set to the same value by strategically installing the AC unit in the optimal room. :param n: int, number of rooms :param k: int, range of influence of the AC unit :param temperatures: List[int], initial temperatures of the rooms :return: int, the maximum number of rooms with the same temperature >>> max_same_temperature_rooms(7, 2, [1, 2, 2, 5, 5, 3, 4]) 5 >>> max_same_temperature_rooms(5, 1, [10, 1, 10, 1, 10]) 3","solution":"def max_same_temperature_rooms(n, k, temperatures): Determines the maximum number of rooms that can have their temperatures set to the same value by strategically installing the AC unit in the optimal room. :param n: int, number of rooms :param k: int, range of influence of the AC unit :param temperatures: List[int], initial temperatures of the rooms :return: int, the maximum number of rooms with the same temperature max_rooms = 0 for i in range(n): left = max(0, i - k) right = min(n - 1, i + k) max_rooms = max(max_rooms, right - left + 1) return max_rooms"},{"question":"def count_pairs_with_difference_k(N: int, K: int, distances: List[int]) -> int: Given a list of distances at checkpoints in non-decreasing order, determine the number of pairs of sequential checkpoints (i, j) where the distance difference equals K. >>> count_pairs_with_difference_k(5, 3, [1, 4, 7, 10, 13]) 4 >>> count_pairs_with_difference_k(4, 5, [1, 2, 3, 4]) 0 >>> count_pairs_with_difference_k(4, 2, [1, 3, 5, 7]) 3 >>> count_pairs_with_difference_k(1, 2, [1]) 0 >>> count_pairs_with_difference_k(3, 1000000000, [0, 1000000000, 2000000000]) 2 >>> N = 100000 >>> K = 1 >>> distances = list(range(N)) >>> count_pairs_with_difference_k(N, K, distances) 99999","solution":"def count_pairs_with_difference_k(N, K, distances): Returns the number of pairs of sequential checkpoints with a difference of exactly K. :param N: Number of checkpoints :param K: Desired difference between checkpoints :param distances: List of distances at each checkpoint in non-decreasing order :return: Number of pairs with the desired difference count = 0 for i in range(1, N): if distances[i] - distances[i - 1] == K: count += 1 return count # Example usage: # N, K = 5, 3 # distances = [1, 4, 7, 10, 13] # print(count_pairs_with_difference_k(N, K, distances)) # Output should be 4"},{"question":"from typing import List, Tuple def edit_distance(S: str, T: str) -> int: Determines the minimum number of operations required to transform string S into string T. >>> edit_distance(\\"horse\\", \\"ros\\") == 3 >>> edit_distance(\\"intention\\", \\"execution\\") == 5 >>> edit_distance(\\"\\", \\"\\") == 0 >>> edit_distance(\\"abc\\", \\"abc\\") == 0 >>> edit_distance(\\"abc\\", \\"ab\\") == 1 >>> edit_distance(\\"abc\\", \\"abcd\\") == 1 >>> edit_distance(\\"abc\\", \\"xyz\\") == 3 pass # implement the function here def min_operations(test_cases: List[Tuple[str, str]]) -> List[int]: For each test case, determine the minimum number of operations required to transform string S into string T. Parameters: test_cases - List of tuples [(S1, T1), (S2, T2), ...] Returns: List of minimum number of operations for each test case. >>> min_operations([(\\"horse\\", \\"ros\\"), (\\"intention\\", \\"execution\\")]) == [3, 5] >>> min_operations([(\\"\\", \\"\\"), (\\"abc\\", \\"abc\\"), (\\"abc\\", \\"ab\\"), (\\"abc\\", \\"abcd\\"), (\\"abc\\", \\"xyz\\")]) == [0, 0, 1, 1, 3] pass # implement the function here","solution":"def edit_distance(S, T): Determines the minimum number of operations required to transform string S into string T. m, b = len(S), len(T) dp = [[0] * (b + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(b + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][b] def min_operations(test_cases): For each test case, determine the minimum number of operations required to transform string S into string T. Parameters: test_cases - List of tuples [(S1, T1), (S2, T2), ...] Returns: List of minimum number of operations for each test case. results = [] for S, T in test_cases: results.append(edit_distance(S, T)) return results"},{"question":"from typing import List def shortest_path(grid: List[List[int]], m: int, n: int) -> int: Returns the length of the shortest path from the top-left to the bottom-right corner of the grid. :param grid: List[List[int]]: The grid representation :param m: int: Number of rows :param n: int: Number of columns :return: int: Shortest path length or -1 if no valid path exists pass import pytest def test_shortest_path_normal_case(): grid = [ [0, 1, 1, 0, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [1, 0, 0, 0, 0], [1, 1, 1, 1, 0] ] assert shortest_path(grid, 5, 5) == 9 def test_shortest_path_no_path(): grid = [ [0, 1, 1, 0], [1, 1, 1, 1], [0, 0, 0, 1], [1, 1, 1, 0] ] assert shortest_path(grid, 4, 4) == -1 def test_shortest_path_one_cell_grid_open(): grid = [ [0] ] assert shortest_path(grid, 1, 1) == 1 def test_shortest_path_one_cell_grid_wall(): grid = [ [1] ] assert shortest_path(grid, 1, 1) == -1 def test_shortest_path_large_grid(): grid = [ [0] * 100 for _ in range(100) ] assert shortest_path(grid, 100, 100) == 199 if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque def shortest_path(grid, m, n): Returns the length of the shortest path from the top-left to the bottom-right corner of the grid. :param grid: List[List[int]]: The grid representation :param m: int: Number of rows :param n: int: Number of columns :return: int: Shortest path length or -1 if no valid path exists # Initialize directions array for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS queue queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 # If start or end is a wall, return -1 while queue: r, c, dist = queue.popleft() if r == m-1 and c == n-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def time_to_opposite_end(s, d): Returns the number of seconds required for the reader to reach the opposite end of the row of books. :param s: int, starting section number (0 to 15) :param d: str, direction of movement ('L' for left, 'R' for right) :return: int, time in seconds to reach the opposite end >>> time_to_opposite_end(2, 'R') 13 >>> time_to_opposite_end(10, 'L') 10 >>> time_to_opposite_end(7, 'R') 8 >>> time_to_opposite_end(0, 'L') 0","solution":"def time_to_opposite_end(s, d): Returns the number of seconds required for the reader to reach the opposite end of the row of books. :param s: int, starting section number (0 to 15) :param d: str, direction of movement ('L' for left, 'R' for right) :return: int, time in seconds to reach the opposite end if d == 'R': return 15 - s elif d == 'L': return s else: raise ValueError(\\"Direction should be 'L' or 'R'\\")"},{"question":"def max_coins(houses): Given an array of coins in houses, returns the maximum number of coins that can be robbed without robbing two adjacent houses. >>> max_coins([1, 2, 3, 1]) 4 >>> max_coins([2, 7, 9, 3, 1]) 12 >>> max_coins([4, 5, 6]) 10 >>> max_coins([7]) 7 >>> max_coins([]) 0 >>> max_coins([3, 10]) 10 >>> max_coins([5, 1, 1, 5]) 10","solution":"def max_coins(houses): Given an array of coins in houses, returns the maximum number of coins that can be robbed without robbing two adjacent houses. n = len(houses) if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(houses[i] + dp[i-2], dp[i-1]) return dp[-1]"},{"question":"def second_highest(scores: List[int]) -> int: Returns the second highest score from the list of scores. If there are fewer than two unique scores, returns None. >>> second_highest([10, 20, 30, 40, 50]) == 40 >>> second_highest([10, 20, 20, 30, 30, 40, 50]) == 40 >>> second_highest([50, 50, 50, 50]) == None >>> second_highest([50]) == None >>> second_highest([50, 40, 50, 30, 50, 20]) == 40 >>> second_highest([10, 20, -30, -40, 50]) == 20 >>> second_highest([-10, -20, -30, -40, -50]) == -20 >>> second_highest([]) == None","solution":"def second_highest(scores): Returns the second highest score from the list of scores. If there are fewer than two unique scores, returns None. unique_scores = list(set(scores)) if len(unique_scores) < 2: return None unique_scores.sort(reverse=True) return unique_scores[1]"},{"question":"from typing import List def minimizeSubarrays(N: int, K: int, arr: List[int], M: int) -> int: Given an array arr[] of N non-negative integers and an integer K, divide the array into at most M subarrays such that the sum of each subarray does not exceed K. Return the minimum number of subarrays needed to achieve this. Parameters: N (int): The number of elements in the array. K (int): The maximum sum allowed for any subarray. arr (List[int]): The array of integers. M (int): The upper limit for the number of subarrays. Returns: int: The minimum number of subarrays needed or -1 if it's not possible. Examples: >>> minimizeSubarrays(5, 5, [1, 2, 3, 4, 5], 3) 3 >>> minimizeSubarrays(4, 7, [2, 1, 5, 1], 2) 2 # Your implementation here def test_minimizeSubarrays_example1(): N, K, arr, M = 5, 5, [1, 2, 3, 4, 5], 3 assert minimizeSubarrays(N, K, arr, M) == 3 def test_minimizeSubarrays_example2(): N, K, arr, M = 4, 7, [2, 1, 5, 1], 2 assert minimizeSubarrays(N, K, arr, M) == 2 def test_minimizeSubarrays_element_greater_than_K(): N, K, arr, M = 3, 5, [6, 2, 3], 3 assert minimizeSubarrays(N, K, arr, M) == -1 def test_minimizeSubarrays_all_elements_less_than_K(): N, K, arr, M = 6, 10, [2, 3, 4, 1, 2, 1], 2 assert minimizeSubarrays(N, K, arr, M) == 2 def test_minimizeSubarrays_large_values(): N, K, arr, M = 5, 15, [5, 5, 5, 5, 5], 3 assert minimizeSubarrays(N, K, arr, M) == 2 def test_minimizeSubarrays_single_element_cases(): N, K, arr, M = 1, 10, [5], 1 assert minimizeSubarrays(N, K, arr, M) == 1 def test_minimizeSubarrays_single_element_above_K(): N, K, arr, M = 1, 4, [5], 1 assert minimizeSubarrays(N, K, arr, M) == -1","solution":"def minimizeSubarrays(N, K, arr, M): subarray_count = 1 current_sum = 0 for num in arr: if num > K: return -1 # If single element is greater than K, we cannot satisfy the condition if current_sum + num > K: subarray_count += 1 current_sum = num else: current_sum += num if subarray_count > M: subarray_count = M # Return within the constraint M return subarray_count"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by rotating the string s to the left k times. >>> lexicographically_smallest_string(\\"abcde\\", 3) 'deabc' >>> lexicographically_smallest_string(\\"banana\\", 1) 'ananab' pass # Implement your solution here","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by rotating the string s to the left k times. n = len(s) if k == 0: return s smallest_string = s for i in range(k + 1): rotated_string = s[i:] + s[:i] if rotated_string < smallest_string: smallest_string = rotated_string return smallest_string"},{"question":"def top_k_scores(n: int, k: int, scores: List[int]) -> List[int]: A function that updates the list of the top k highest scores achieved by players. The scores should be displayed in descending order. If there are fewer than k scores, display all scores in descending order. Parameters: n (int): The number of scores received. k (int): The number of top scores to keep track of. scores (List[int]): A list of scores. Returns: List[int]: A list of the top k scores in descending order. >>> top_k_scores(8, 3, [100, 200, 50, 300, 400, 150, 250, 350]) [400, 350, 300] >>> top_k_scores(5, 5, [90, 85, 100, 95, 80]) [100, 95, 90, 85, 80]","solution":"import heapq def top_k_scores(n, k, scores): # Create a min-heap to keep track of the top k scores top_k_heap = [] for score in scores: if len(top_k_heap) < k: heapq.heappush(top_k_heap, score) else: heapq.heappushpop(top_k_heap, score) # Convert the heap into a sorted list in descending order top_k_list = sorted(top_k_heap, reverse=True) return top_k_list"},{"question":"from typing import List, Tuple def find_xyz_for_sum(m: int) -> Tuple[int, int, int]: Given an integer M, finds three integers X, Y, Z such that: 1 ≤ X, Y, Z ≤ 10^6 X + Y + Z = M pass def process_input(q: int, queries: List[int]) -> List[Tuple[int, int, int]]: Processes the input queries for multiple test cases. pass def test_find_xyz_basic_cases(): assert find_xyz_for_sum(6) == (3, 1, 2) assert find_xyz_for_sum(9) == (6, 1, 2) assert find_xyz_for_sum(12) == (9, 1, 2) assert find_xyz_for_sum(15) == (12, 1, 2) def test_find_xyz_edge_cases(): assert find_xyz_for_sum(3) == (0, 1, 2) assert find_xyz_for_sum(10**6 + 3) == (10**6, 1, 2) assert find_xyz_for_sum(3 * 10**6) == (2999997, 1, 2) def test_process_input(): assert process_input(4, [6, 9, 12, 15]) == [(3, 1, 2), (6, 1, 2), (9, 1, 2), (12, 1, 2)] assert process_input(2, [3, 10**6 + 3]) == [(0, 1, 2), (10**6, 1, 2)]","solution":"def find_xyz_for_sum(m): Given an integer M, finds three integers X, Y, Z such that: 1 ≤ X, Y, Z ≤ 10^6 X + Y + Z = M # We can simply choose X = M - 3, Y = 1, Z = 2 # This ensures that X + Y + Z = M and the values are within the required range X = m - 3 Y = 1 Z = 2 return X, Y, Z def process_input(q, queries): results = [] for m in queries: results.append(find_xyz_for_sum(m)) return results"},{"question":"def create_matrix(n: int, ch: str) -> list: Generates a square matrix of size n x n filled with characters in increasing alphabetical order, starting from character \`ch\`. Wraps around back to 'a' if the increment exceeds 'z'. Args: n (int): Size of the matrix (1 <= n <= 26). ch (str): The starting character ('a' <= ch <= 'z'). Returns: list: A 2D list representing the matrix. Example: >>> create_matrix(3, 'x') [['x', 'y', 'z'], ['a', 'b', 'c'], ['d', 'e', 'f']] >>> create_matrix(4, 'w') [['w', 'x', 'y', 'z'], ['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l']] pass","solution":"def create_matrix(n: int, ch: str) -> list: Generates a square matrix of size n x n filled with characters in increasing alphabetical order, starting from character \`ch\`. Wraps around back to 'a' if the increment exceeds 'z'. Args: n (int): Size of the matrix (1 <= n <= 26). ch (str): The starting character ('a' <= ch <= 'z'). Returns: list: A 2D list representing the matrix. matrix = [] current_char_code = ord(ch) for i in range(n): row = [] for j in range(n): if current_char_code > ord('z'): current_char_code = ord('a') row.append(chr(current_char_code)) current_char_code += 1 matrix.append(row) return matrix"},{"question":"def totalCost(N: int, C: int) -> int: Returns the total cost the customer has to pay after accounting for the three-for-two discount on apples. Parameters: N (int): Number of apples purchased C (int): Cost per apple Returns: int: Total cost after discount Examples: >>> totalCost(3, 5) 10 >>> totalCost(7, 4) 20","solution":"def totalCost(N, C): Returns the total cost the customer has to pay after accounting for the three-for-two discount on apples. N : int : Number of apples purchased C : int : Cost per apple return : int : Total cost after discount # Number of apples the customer actually has to pay for count_chargeable_apples = (N // 3) * 2 + (N % 3) # Total cost total_cost = count_chargeable_apples * C return total_cost"},{"question":"def applyOperations(N, operations): Given a list of integers and a set of operations consisting of adding numbers to the list and rotating the list to the left by a given number of positions, perform the operations and return the final list in its state after all operations have been applied. >>> applyOperations(4, [['A', 1], ['A', 2], ['L', 1], ['A', 3]]) [2, 1, 3] >>> applyOperations(5, [['A', 4], ['A', 5], ['L', 2], ['A', 6], ['L', 1]]) [5, 6, 4]","solution":"def applyOperations(N, operations): result = [] for operation in operations: if operation[0] == 'A': result.append(operation[1]) elif operation[0] == 'L': k = operation[1] % len(result) # Handle rotation amount larger than list size result = result[k:] + result[:k] return result"},{"question":"def is_valid(s: str) -> bool: Returns true if the string contains valid nested brackets (round (), curly {}, or square []), and false otherwise. >>> is_valid(\\"()\\") True >>> is_valid(\\"({[]})\\") True >>> is_valid(\\"({[)]}\\") False >>> is_valid(\\"[(])\\") False >>> is_valid(\\"\\") True","solution":"def is_valid(s): Returns True if the input string contains valid nested brackets, otherwise False. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def find_largest_rectangle(grid): This function takes a grid of '0's and '1's and returns the size of the largest rectangle containing only '1's and the number of such largest rectangles. >>> find_largest_rectangle([ \\"10101\\", \\"11100\\", \\"11111\\", \\"10010\\" ]) (6, 1) >>> find_largest_rectangle([ \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\" ]) (1, 18) def process_test_cases(test_cases): Process multiple test cases to find the largest rectangle for each. >>> process_test_cases([ [ \\"10101\\", \\"11100\\", \\"11111\\", \\"10010\\" ], [ \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\" ] ]) [(6, 1), (1, 18)] def parse_input(input_str): Parse the input string into test cases grid format. >>> parse_input(\\"2n4 5n10101n11100n11111n10010n6 6n101010n010101n101010n010101n101010n010101\\") [ [ \\"10101\\", \\"11100\\", \\"11111\\", \\"10010\\" ], [ \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\", \\"101010\\", \\"010101\\" ] ] def solve(input_str): Solve the problem of finding the largest rectangle size and count from input string. >>> solve(\\"2n4 5n10101n11100n11111n10010n6 6n101010n010101n101010n010101n101010n010101\\") \\"6 1n1 18\\"","solution":"def find_largest_rectangle(grid): This function takes a grid of '0's and '1's and returns the size of the largest rectangle containing only '1's and the number of such largest rectangles. n = len(grid) m = len(grid[0]) if n > 0 else 0 if not n or not m: return 0, 0 heights = [0] * m left = [0] * m right = [m] * m max_area = 0 count_max_area = 0 for row in grid: current_left, current_right = 0, m # Update heights for i in range(m): if row[i] == '1': heights[i] += 1 else: heights[i] = 0 # Update left boundaries for i in range(m): if row[i] == '1': left[i] = max(left[i], current_left) else: left[i] = 0 current_left = i + 1 # Update right boundaries for i in range(m-1, -1, -1): if row[i] == '1': right[i] = min(right[i], current_right) else: right[i] = m current_right = i # Calculate areas for i in range(m): area = (right[i] - left[i]) * heights[i] if area > max_area: max_area = area count_max_area = 1 elif area == max_area: count_max_area += 1 return max_area, count_max_area def process_test_cases(test_cases): results = [] for grid in test_cases: results.append(find_largest_rectangle(grid)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, lines[index].split()) grid = [lines[i] for i in range(index + 1, index + N + 1)] test_cases.append(grid) index += N + 1 return test_cases def solve(input_str): test_cases = parse_input(input_str) results = process_test_cases(test_cases) return \\"n\\".join(f\\"{area} {count}\\" for area, count in results)"},{"question":"def min_adjacent_swaps(arr: List[int]) -> int: This function returns the minimum number of adjacent swaps required to sort the books in increasing order. Parameters: arr (List[int]): The list of book identifiers. Returns: int: The minimum number of adjacent swaps required. Examples: >>> min_adjacent_swaps([4, 3, 2, 1, 5]) 6 >>> min_adjacent_swaps([3, 1, 2]) 2 >>> min_adjacent_swaps([1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps([5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps([1]) 0 >>> import random >>> large_input = list(range(1, 10001)) >>> random.shuffle(large_input) >>> isinstance(min_adjacent_swaps(large_input), int) True >>> min_adjacent_swaps([2, 3, 1]) 2 pass","solution":"def min_adjacent_swaps(arr): This function returns the minimum number of adjacent swaps required to sort the books in increasing order. def merge_sort_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inv_count = 0 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n - 1)"},{"question":"def majority_vote(t: int, cases: List[Tuple[int, List[int]]]) -> List[Union[int, str]]: Determine if there is a candidate who has more than half of the total votes in each test case. >>> majority_vote(3, [(5, [1, 2, 1, 1, 3]), (4, [2, 3, 3, 3]), (6, [4, 4, 4, 1, 1, 1])]) [1, 3, \\"NO\\"] >>> majority_vote(1, [(1, [1])]) [1] >>> majority_vote(1, [(100000, [1] * 50001 + [2] * 49999)]) [1] >>> majority_vote(1, [(4, [1, 2, 2, 1])]) [\\"NO\\"] >>> majority_vote(2, [(2, [1, 1]), (2, [1, 2])]) [1, \\"NO\\"] >>> majority_vote(2, [(3, [2, 2, 2]), (3, [1, 2, 3])]) [2, \\"NO\\"] pass","solution":"def majority_vote(t, cases): results = [] for n, votes in cases: vote_count = {} for vote in votes: if vote in vote_count: vote_count[vote] += 1 else: vote_count[vote] = 1 majority_threshold = n // 2 found_majority = \\"NO\\" for candidate, count in vote_count.items(): if count > majority_threshold: found_majority = candidate break results.append(found_majority) return results"},{"question":"def min_operations(S1: str, S2: str) -> int: Calculate the minimum number of edit operations needed to transform S1 into S2. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"a\\", \\"\\") 1 >>> min_operations(\\"\\", \\"a\\") 1 >>> min_operations(\\"test\\", \\"test\\") 0 >>> min_operations(\\"abc\\", \\"abcd\\") 1 >>> min_operations(\\"a\\", \\"aaaa\\") 3 >>> min_operations(\\"abcd\\", \\"abc\\") 1 >>> min_operations(\\"aaaa\\", \\"a\\") 3 >>> min_operations(\\"abc\\", \\"aBc\\") 1 >>> min_operations(\\"abcd\\", \\"abcf\\") 1 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 pass","solution":"def min_operations(S1: str, S2: str) -> int: This function calculates the minimum number of edit operations needed to transform S1 into S2. m, n = len(S1), len(S2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # S1 is empty, insert all of S2's characters elif j == 0: dp[i][j] = i # S2 is empty, remove all of S1's characters elif S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, move diagonally else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace # Return the result from the DP table return dp[m][n]"},{"question":"def max_increase(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum increase in height between any two consecutive days for each test case. >>> max_increase(2, [(5, [1, 2, 3, 5, 11]), (3, [3, 2, 1])]) [6, -1] >>> max_increase(1, [(4, [10, 15, 5, 20])]) [15]","solution":"def max_increase(T, test_cases): results = [] for N, heights in test_cases: max_diff = heights[1] - heights[0] for i in range(1, N): diff = heights[i] - heights[i - 1] if diff > max_diff: max_diff = diff results.append(max_diff) return results"},{"question":"class LibraryManagementSystem: A class to manage a library system, including adding books, borrowing and returning books, and generating a report of available books. >>> system = LibraryManagementSystem() >>> system.add(1, \\"the_great_gatsby\\") >>> system.add(2, \\"war_and_peace\\") >>> system.report() \\"1 the_great_gatsbyn2 war_and_peace\\" >>> system.borrow(1) >>> system.report() \\"2 war_and_peace\\" def __init__(self): self.books = {} # Dictionary to store books with ID as key and title as value self.borrowed = set() # Set to store borrowed book IDs def add(self, book_id, title): Adds a new book to the library. pass def borrow(self, book_id): Borrows a book from the library. pass def return_book(self, book_id): Returns a borrowed book to the library. pass def report(self): Generates a report of available books. pass","solution":"class LibraryManagementSystem: def __init__(self): self.books = {} # Dictionary to store books with ID as key and title as value self.borrowed = set() # Set to store borrowed book IDs def add(self, book_id, title): Adds a new book to the library. if book_id not in self.books: self.books[book_id] = title def borrow(self, book_id): Borrows a book from the library. if book_id in self.books and book_id not in self.borrowed: self.borrowed.add(book_id) def return_book(self, book_id): Returns a borrowed book to the library. if book_id in self.borrowed: self.borrowed.remove(book_id) def report(self): Generates a report of available books. available_books = [(book_id, self.books[book_id]) for book_id in self.books if book_id not in self.borrowed] available_books.sort() if not available_books: return \\"No books available\\" return \\"n\\".join([f\\"{book_id} {title}\\" for book_id, title in available_books])"},{"question":"def maximum_sum_submatrix(matrix): Find the sum of the submatrix with the maximum sum in the given matrix. >>> maximum_sum_submatrix([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> maximum_sum_submatrix([ ... [-8, -3], ... [-4, -1] ... ]) -1 >>> maximum_sum_submatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> maximum_sum_submatrix([ ... [1] ... ]) 1 >>> maximum_sum_submatrix([]) 0 pass","solution":"def maximum_sum_submatrix(matrix): def kadane(arr): max_sum = current_sum = -float('inf') for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum if not matrix: return 0 R = len(matrix) C = len(matrix[0]) max_sum = -float('inf') for left in range(C): temp = [0] * R for right in range(left, C): for i in range(R): temp[i] += matrix[i][right] current_max_sum = kadane(temp) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"def factorial(n): Returns the factorial of a non-negative integer n. If the input is not a non-negative integer, return \\"invalid input\\". >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(-1) \\"invalid input\\" >>> factorial(3.5) \\"invalid input\\" >>> factorial(\\"5\\") \\"invalid input\\"","solution":"def factorial(n): Returns the factorial of a non-negative integer n. If the input is not a non-negative integer, return \\"invalid input\\". if not isinstance(n, int) or n < 0: return \\"invalid input\\" result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def get_primes(n: int) -> List[int]: Given an integer \`n\`, return a list of all prime numbers up to \`n\` (inclusive). A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. >>> get_primes(10) [2, 3, 5, 7] >>> get_primes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def get_primes(n): Returns a list of all prime numbers up to and including n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False p = 2 while p * p <= n: if sieve[p]: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 primes = [p for p in range(2, n + 1) if sieve[p]] return primes"},{"question":"def check_divisible_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether there exists a pair of different integers in each list such that one of them divides the other. Return \\"Yes\\" if such a pair exists, and \\"No\\" otherwise. >>> check_divisible_pairs(3, [(5, [10, 5, 3, 4, 2]), (4, [7, 11, 13, 17]), (3, [8, 32, 64])]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> check_divisible_pairs(2, [(4, [2, 4, 8, 16]), (3, [3, 6, 9])]) [\\"Yes\\", \\"Yes\\"] >>> check_divisible_pairs(2, [(3, [7, 13, 29]), (4, [19, 23, 31, 47])]) [\\"No\\", \\"No\\"] >>> check_divisible_pairs(2, [(2, [10, 5]), (3, [15, 3, 45])]) [\\"Yes\\", \\"Yes\\"] >>> check_divisible_pairs(1, [(2, [10**9, 10**9 // 2])]) [\\"Yes\\"]","solution":"def check_divisible_pairs(t, test_cases): results = [] for n, numbers in test_cases: numbers_set = set(numbers) found = False for i in range(n): for j in range(i+1, n): if (numbers[i] % numbers[j] == 0 or numbers[j] % numbers[i] == 0): results.append(\\"Yes\\") found = True break if found: break if not found: results.append(\\"No\\") return results"},{"question":"def maximum_tree_value(n: int, values: List[int], edges: List[Tuple[int, int, int]]) -> int: Find the maximum sum of the vertex values in the resulting tree after adding the minimum number of edges to connect the forest. Args: n (int): The number of vertices in the forest. values (List[int]): The values associated with the vertices. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w describing an edge between vertices u and v with weight w. Returns: int: The maximum sum of the vertex values in the resulting tree. Examples: >>> maximum_tree_value(4, [1, 2, 3, 4], [(1, 2, 1), (2, 3, 2), (3, 4, 1)]) 10 >>> maximum_tree_value(5, [5, 3, 6, 1, 4], [(1, 2, 3), (2, 3, 2), (4, 5, 1), (3, 4, 5)]) 19","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def maximum_tree_value(n, values, edges): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) # Kruskal's algorithm to connect the forest with the minimum number of edges edges.sort(key=lambda x: x[2]) mst_weight = 0 edge_count = 0 for edge in edges: u, v, w = edge uset = find(parent, u-1) vset = find(parent, v-1) if uset != vset: edge_count += 1 mst_weight += w union(parent, rank, uset, vset) # Calculate the sum of vertex values final_values = sum(values) return final_values # Example usage: if __name__ == \\"__main__\\": n = 4 values = [1, 2, 3, 4] edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 1) ] print(maximum_tree_value(n, values, edges)) # Should output 10"},{"question":"def is_strictly_increasing(arr, queries): Determines if each specified range in the array is strictly increasing. Parameters: arr (list of int): The list of integers. queries (list of tuple): Each tuple contains two integers (l, r) representing the range. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each query. Examples: >>> is_strictly_increasing([1, 2, 3, 5, 4], [(1, 3), (2, 5), (1, 5)]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> is_strictly_increasing([1, 3, 2, 4], [(1, 1), (2, 2), (3, 3), (4, 4)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] } >>> is_strictly_increasing([4, 3, 2, 1], [(1, 4), (1, 3), (2, 4)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> is_strictly_increasing([2, 3, 1, 4, 5], [(1, 2), (1, 3), (3, 5), (2, 5)]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] >>> is_strictly_increasing(list(range(1, 1001)) + list(range(1000, 0, -1)), [(1, 1000), (1001, 2000), (500, 1500)]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_strictly_increasing(arr, queries): Determines if each specified range in the array is strictly increasing. Parameters: arr (list of int): The list of integers. queries (list of tuple): Each tuple contains two integers (l, r) representing the range. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each query. results = [] for l, r in queries: increasing = True for i in range(l, r): if arr[i - 1] >= arr[i]: increasing = False break results.append(\\"YES\\" if increasing else \\"NO\\") return results"},{"question":"def max_notification_time(n, m): Calculate the maximum amount of time it would take to notify all computers in an NxM grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid Returns: int: Maximum time to notify all computers in hours # Write your implementation here def process_test_cases(t, test_cases): Process multiple test cases to determine maximum notification time for each NxM grid. Parameters: t (int): number of test cases test_cases (list of tuples): list of (n, m) tuples representing grid sizes Returns: list of int: list of maximum notification times for each test case # Write your implementation here import pytest def test_max_notification_time(): assert max_notification_time(2, 2) == 2 assert max_notification_time(3, 3) == 3 assert max_notification_time(1, 1) == 1 assert max_notification_time(0, 0) == 0 assert max_notification_time(0, 5) == 0 assert max_notification_time(10, 0) == 0 assert max_notification_time(5, 10) == 10 assert max_notification_time(10, 5) == 10 def test_process_test_cases(): assert process_test_cases(2, [(2, 2), (3, 3)]) == [2, 3] assert process_test_cases(3, [(4, 5), (1, 1), (0, 3)]) == [5, 1, 0] assert process_test_cases(0, []) == [] pytest.main()","solution":"def max_notification_time(n, m): Calculate the maximum amount of time it would take to notify all computers in an NxM grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid Returns: int: Maximum time to notify all computers in hours if n == 0 or m == 0: return 0 return max(n, m) def process_test_cases(t, test_cases): Process multiple test cases to determine maximum notification time for each NxM grid. Parameters: t (int): number of test cases test_cases (list of tuples): list of (n, m) tuples representing grid sizes Returns: list of int: list of maximum notification times for each test case results = [] for n, m in test_cases: results.append(max_notification_time(n, m)) return results"},{"question":"def largest_palindrome_less_than_or_equal_to(N: int) -> int: Given a non-negative integer N, find the largest palindrome number less than or equal to N. >>> largest_palindrome_less_than_or_equal_to(123) 121 >>> largest_palindrome_less_than_or_equal_to(50) 44 >>> largest_palindrome_less_than_or_equal_to(0) 0 >>> largest_palindrome_less_than_or_equal_to(9) 9 >>> largest_palindrome_less_than_or_equal_to(7) 7 >>> largest_palindrome_less_than_or_equal_to(1000000) 999999 >>> largest_palindrome_less_than_or_equal_to(1221) 1221 >>> largest_palindrome_less_than_or_equal_to(1200) 1111","solution":"def largest_palindrome_less_than_or_equal_to(N): Returns the largest palindrome number less than or equal to N. for num in range(N, -1, -1): if str(num) == str(num)[::-1]: return num"},{"question":"def count_words_with_vowels(sentence: str) -> int: Returns the number of words with at least one vowel in the given sentence. Parameters: sentence (str): A string of words separated by spaces. Returns: int: The number of words containing at least one vowel. >>> count_words_with_vowels(\\"Hello world\\") == 2 >>> count_words_with_vowels(\\"Sky is blue\\") == 2 >>> count_words_with_vowels(\\"bcd fg h\\") == 0 >>> count_words_with_vowels(\\"Apple Banana orange\\") == 3 >>> count_words_with_vowels(\\"\\") == 0 >>> count_words_with_vowels(\\"Umbrella\\") == 1 >>> count_words_with_vowels(\\" \\") == 0","solution":"def count_words_with_vowels(sentence): Returns the number of words with at least one vowel in the given sentence. Parameters: sentence (str): A string of words separated by spaces. Returns: int: The number of words containing at least one vowel. vowels = set('aeiouAEIOU') words = sentence.split() count = 0 for word in words: if any(char in vowels for char in word): count += 1 return count"},{"question":"def edit_distance(S1: str, S2: str) -> int: Calculates the minimum number of operations required to transform S1 into S2. >>> edit_distance(\\"abc\\", \\"yabd\\") 2 >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"intention\\", \\"execution\\") 5 def process_input(input_data: str) -> list: Processes the given input data and outputs the minimum edit distances sequentially. >>> input_data = \\"abcnyabdnkittennsittingnintentionnexecutionn0n0n\\" >>> process_input(input_data) [2, 3, 5] def test_edit_distance(): assert edit_distance(\\"abc\\", \\"yabd\\") == 2 assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"intention\\", \\"execution\\") == 5 def test_process_input(): input_data = \\"abcnyabdnkittennsittingnintentionnexecutionn0n0n\\" expected_output = [2, 3, 5] assert process_input(input_data) == expected_output if __name__ == \\"__main__\\": test_edit_distance() test_process_input() print(\\"All tests passed.\\")","solution":"def edit_distance(S1, S2): Calculates the minimum edit distance between two strings S1 and S2. m, n = len(S1), len(S2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If S1 is empty, insert all characters of S2 elif j == 0: dp[i][j] = i # If S2 is empty, remove all characters of S1 elif S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are the same, ignore last char else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n] def process_input(input_data): Processes the given input data and outputs the minimum edit distances sequentially. lines = input_data.strip().split('n') results = [] for i in range(0, len(lines) - 1, 2): S1 = lines[i] S2 = lines[i + 1] if S1 == '0' and S2 == '0': break results.append(edit_distance(S1, S2)) return results"},{"question":"def can_word_be_formed(R: int, C: int, char_grid: List[List[str]], target_word: str) -> str: Check if the word can be formed in the grid by starting from any cell and moving horizontally, vertically, or diagonally, in any of the eight possible directions. Args: R (int): Number of rows in the grid C (int): Number of columns in the grid char_grid (List[List[str]]): 2D list representing the grid of characters target_word (str): The word to be found in the grid Returns: str: \\"YES\\" if the word can be found, \\"NO\\" otherwise. >>> can_word_be_formed(3, 4, [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L']], \\"BEF\\") \\"YES\\" >>> can_word_be_formed(3, 4, [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L']], \\"AGH\\") \\"NO\\"","solution":"def is_word_in_grid(grid, word): rows = len(grid) cols = len(grid[0]) def dfs(x, y, word_index): if word_index == len(word): return True if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] != word[word_index]: return False temp = grid[x][y] directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)] grid[x][y] = '#' found = any(dfs(x + dx, y + dy, word_index + 1) for dx, dy in directions) grid[x][y] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return \\"YES\\" return \\"NO\\" def can_word_be_formed(R, C, char_grid, target_word): return is_word_in_grid(char_grid, target_word)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def insertionSortList(head: ListNode) -> ListNode: Sort a linked list using insertion sort algorithm. >>> l1 = ListNode(4, ListNode(2, ListNode(1, ListNode(3)))) >>> sorted_list = insertionSortList(l1) >>> list_to_array(sorted_list) [1, 2, 3, 4] >>> l2 = ListNode(-1, ListNode(5, ListNode(3, ListNode(4, ListNode(0))))) >>> sorted_list = insertionSortList(l2) >>> list_to_array(sorted_list) [-1, 0, 3, 4, 5] pass def list_to_array(head: ListNode) -> List[int]: array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array: List[int]) -> ListNode: dummy = ListNode(0) current = dummy for val in array: current.next = ListNode(val) current = current.next return dummy.next def test_insertionSortList(): input_list = array_to_list([4, 2, 1, 3]) sorted_list = insertionSortList(input_list) assert list_to_array(sorted_list) == [1, 2, 3, 4] input_list = array_to_list([-1, 5, 3, 4, 0]) sorted_list = insertionSortList(input_list) assert list_to_array(sorted_list) == [-1, 0, 3, 4, 5] input_list = array_to_list([1, 2, 3, 4, 5]) sorted_list = insertionSortList(input_list) assert list_to_array(sorted_list) == [1, 2, 3, 4, 5] input_list = array_to_list([1, 1, 1, 1, 1]) sorted_list = insertionSortList(input_list) assert list_to_array(sorted_list) == [1, 1, 1, 1, 1] input_list = array_to_list([]) sorted_list = insertionSortList(input_list) assert list_to_array(sorted_list) == [] input_list = array_to_list([1]) sorted_list = insertionSortList(input_list) assert list_to_array(sorted_list) == [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def insertionSortList(head): if not head or not head.next: return head sorted_head = ListNode(0) # Dummy node to help with insertion current = head while current: prev = sorted_head next_node = current.next # Find the right place to insert current while prev.next and prev.next.val < current.val: prev = prev.next # Insert current into the sorted list current.next = prev.next prev.next = current current = next_node return sorted_head.next"},{"question":"def count_movie_ratings(ratings): Counts the number of occurrences of each rating (1 through 5) in the given list of ratings. Parameters: ratings (list of int): List of integer ratings between 1 and 5, inclusive. Returns: dict: A dictionary where the keys are the ratings (1 through 5) and the values are their counts. pass # Unit Tests def test_count_movie_ratings_all_ratings_present(): ratings = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5] expected_output = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5} assert count_movie_ratings(ratings) == expected_output def test_count_movie_ratings_single_rating(): ratings = [5, 5, 5, 5] expected_output = {1: 0, 2: 0, 3: 0, 4: 0, 5: 4} assert count_movie_ratings(ratings) == expected_output def test_count_movie_ratings_all_ratings_zero_except_one(): ratings = [4] expected_output = {1: 0, 2: 0, 3: 0, 4: 1, 5: 0} assert count_movie_ratings(ratings) == expected_output def test_count_movie_ratings_diverse_ratings(): ratings = [1, 3, 3, 4, 4, 5] expected_output = {1: 1, 2: 0, 3: 2, 4: 2, 5: 1} assert count_movie_ratings(ratings) == expected_output def test_count_movie_ratings_minimal_input(): ratings = [1] expected_output = {1: 1, 2: 0, 3: 0, 4: 0, 5: 0} assert count_movie_ratings(ratings) == expected_output","solution":"def count_movie_ratings(ratings): Counts the number of occurrences of each rating (1 through 5) in the given list of ratings. Parameters: ratings (list of int): List of integer ratings between 1 and 5, inclusive. Returns: dict: A dictionary where the keys are the ratings (1 through 5) and the values are their counts. rating_counts = {i: 0 for i in range(1, 6)} for rating in ratings: rating_counts[rating] += 1 return rating_counts"},{"question":"from typing import List def smallestSubsequence(arr: List[int], k: int) -> List[int]: Returns the lexicographically smallest subsequence of length k from the array. >>> smallestSubsequence([3, 5, 2, 6], 2) [2, 6] >>> smallestSubsequence([9, 8, 7, 3, 4, 5], 3) [3, 4, 5] >>> smallestSubsequence([1], 1) [1] >>> smallestSubsequence([4, 3, 2, 1], 4) [4, 3, 2, 1] >>> smallestSubsequence([10**9, 10**8, 10**7], 2) [10**8, 10**7] >>> smallestSubsequence([5, 6, 3, 2, 7, 8], 3) [2, 7, 8]","solution":"def smallestSubsequence(arr, k): Returns the lexicographically smallest subsequence of length k from the array. stack = [] to_discard = len(arr) - k for num in arr: while stack and stack[-1] > num and to_discard > 0: stack.pop() to_discard -= 1 stack.append(num) return stack[:k]"},{"question":"def evaluateExpression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators +, -, *, and /. >>> evaluateExpression(\\"3+5*2\\") == 13 >>> evaluateExpression(\\"10+2*6-7/2\\") == 19 from solution import evaluateExpression def test_simple_addition(): assert evaluateExpression(\\"1+1\\") == 2 def test_simple_subtraction(): assert evaluateExpression(\\"5-3\\") == 2 def test_simple_multiplication(): assert evaluateExpression(\\"2*3\\") == 6 def test_simple_division(): assert evaluateExpression(\\"8/4\\") == 2 def test_combined_operations_1(): assert evaluateExpression(\\"3+5*2\\") == 13 def test_combined_operations_2(): assert evaluateExpression(\\"10+2*6-7/2\\") == 19 def test_combined_operations_3(): assert evaluateExpression(\\"1+2*3-4/2\\") == 5 def test_all_operators(): assert evaluateExpression(\\"3+2-4*2/1\\") == -3 def test_large_numbers(): assert evaluateExpression(\\"1000000*1000000\\") == 1000000000000","solution":"def evaluateExpression(expression): Evaluates a mathematical expression containing non-negative integers and the operators +, -, *, and /. def applyOperation(left, operator, right): if operator == '+': return left + right elif operator == '-': return left - right elif operator == '*': return left * right elif operator == '/': return left // right def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def infixToPostfix(expression): output = [] ops_stack = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 output.append(num) continue elif expression[i] in \\"+-*/\\": while ops_stack and precedence(ops_stack[-1]) >= precedence(expression[i]): output.append(ops_stack.pop()) ops_stack.append(expression[i]) i += 1 while ops_stack: output.append(ops_stack.pop()) return output def evaluatePostfix(tokens): stack = [] for token in tokens: if isinstance(token, int): stack.append(token) else: right = stack.pop() left = stack.pop() result = applyOperation(left, token, right) stack.append(result) return stack[0] postfix = infixToPostfix(expression) return evaluatePostfix(postfix)"},{"question":"def serpentine_order(n: int, m: int) -> List[List[int]]: Returns the tiles arranged in a serpentine order for a n x m floor. Parameters: - n: Number of rows. - m: Number of columns. Returns: - A list of lists representing the serpentine order of the tiles. >>> serpentine_order(3, 3) [[1, 2, 3], [6, 5, 4], [7, 8, 9]] >>> serpentine_order(4, 5) [[1, 2, 3, 4, 5], [10, 9, 8, 7, 6], [11, 12, 13, 14, 15], [20, 19, 18, 17, 16]]","solution":"def serpentine_order(n, m): Returns the tiles arranged in a serpentine order for a n x m floor. Parameters: - n: Number of rows. - m: Number of columns. Returns: - A list of lists representing the serpentine order of the tiles. result = [] for i in range(n): start = i * m + 1 row = list(range(start, start + m)) if i % 2 == 1: row.reverse() result.append(row) return result"},{"question":"def shortest_path_to_exit(n: int, m: int, sr: int, sc: int, grid: List[List[str]]) -> Union[int, str]: Calculate the minimum number of steps required for the player to reach an exit or determine if it is impossible. >>> shortest_path_to_exit(3, 4, 1, 1, [ ... ['.', '.', 'T', '.'], ... ['#', '.', '.', 'E'], ... ['.', '.', '.', '.'] ... ]) 4 >>> shortest_path_to_exit(3, 4, 1, 1, [ ... ['#', 'T', 'E', '#'], ... ['#', 'T', '.', '#'], ... ['.', '.', '.', 'T'] ... ]) \\"IMPOSSIBLE\\" from typing import List, Union def test_shortest_path_to_exit(): assert shortest_path_to_exit(3, 4, 1, 1, [ ['.', '.', 'T', '.'], ['#', '.', '.', 'E'], ['.', '.', '.', '.'] ]) == 4 assert shortest_path_to_exit(3, 4, 1, 1, [ ['#', 'T', 'E', '#'], ['#', 'T', '.', '#'], ['.', '.', '.', 'T'] ]) == \\"IMPOSSIBLE\\" assert shortest_path_to_exit(1, 1, 1, 1, [ ['E'] ]) == 0 assert shortest_path_to_exit(2, 2, 1, 1, [ ['.', 'E'], ['.', '.'] ]) == 1 assert shortest_path_to_exit(5, 5, 3, 3, [ ['#', '#', '#', '#', '#'], ['#', '.', '.', 'E', '#'], ['#', '.', 'T', '.', '#'], ['#', 'E', '.', '.', '#'], ['#', '#', '#', '#', '#'], ]) == 2 assert shortest_path_to_exit(3, 3, 1, 1, [ ['.', '.', '.'], ['.', 'T', '.'], ['.', '.', 'E'] ]) == 4","solution":"def shortest_path_to_exit(n, m, sr, sc, grid): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(sr - 1, sc - 1, 0)]) visited = set() visited.add((sr - 1, sc - 1)) while queue: r, c, steps = queue.popleft() # Check if current position is an exit if grid[r][c] == 'E': return steps # Explore neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m: if (nr, nc) not in visited: if grid[nr][nc] in \\".E\\": visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) # If no path to Exit is found return \\"IMPOSSIBLE\\""},{"question":"def can_jump_to_last_pillar(n: int, k: int, heights: List[int]) -> str: Determine if it's possible to jump from the first pillar to the last pillar. :param n: Number of pillars :param k: Maximum allowable jump height difference :param heights: List of heights of the pillars :return: \\"Yes\\" if possible, otherwise \\"No\\" >>> can_jump_to_last_pillar(5, 2, [1, 3, 2, 4, 1]) 'Yes' >>> can_jump_to_last_pillar(5, 1, [1, 3, 2, 4, 1]) 'No' >>> can_jump_to_last_pillar(3, 100, [1, 101, 201]) 'Yes' >>> can_jump_to_last_pillar(6, 3, [10, 13, 14, 7, 18, 20]) 'No' >>> can_jump_to_last_pillar(2, 0, [5, 5]) 'Yes'","solution":"def can_jump_to_last_pillar(n, k, heights): Determine if it's possible to jump from the first pillar to the last pillar. :param n: Number of pillars :param k: Maximum allowable jump height difference :param heights: List of heights of the pillars :return: \\"Yes\\" if possible, otherwise \\"No\\" # We will use a queue to keep track of reachable pillars from collections import deque # The queue will store the index of the current pillar queue = deque([0]) # This set will keep track of visited pillars visited = set() visited.add(0) while queue: current = queue.popleft() # If we have reached the last pillar if current == n - 1: return \\"Yes\\" # Check the next pillars that can be jumped to for next_pillar in range(current + 1, n): if next_pillar not in visited and abs(heights[next_pillar] - heights[current]) <= k: visited.add(next_pillar) queue.append(next_pillar) # For optimization: if the current pillar jump is impossible due to height difference greater than K, # we can break the loop early if abs(heights[current] - heights[current + 1]) > k: break return \\"No\\""},{"question":"def min_operations_to_palindrome(n: int, arr: List[int]) -> int: Calculate the minimum number of operations to turn an array into a palindrome by incrementing or decrementing elements. >>> min_operations_to_palindrome(3, [1, 2, 3]) 2 >>> min_operations_to_palindrome(6, [1, 3, 5, 5, 3, 1]) 0 >>> min_operations_to_palindrome(4, [1, 4, 4, 3]) 2","solution":"def min_operations_to_palindrome(n, arr): Calculate the minimum number of operations to turn an array into a palindrome by incrementing or decrementing elements. :param n: Length of the array :param arr: List of integers :return: Minimum number of operations required left = 0 right = n - 1 operations = 0 while left < right: if arr[left] != arr[right]: operations += abs(arr[left] - arr[right]) left += 1 right -= 1 return operations"},{"question":"def most_frequent(strings): Returns the most frequent string in the array of strings. If there is a tie, return any one of the most frequent strings. >>> most_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) \\"apple\\" >>> most_frequent([\\"cat\\", \\"dog\\", \\"cat\\", \\"bird\\", \\"dog\\", \\"dog\\"]) \\"dog\\" >>> most_frequent([\\"one\\", \\"two\\", \\"three\\", \\"one\\", \\"two\\", \\"three\\"]) \\"one\\" # or \\"two\\" or \\"three\\" >>> most_frequent([\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" >>> most_frequent([\\"apple\\"] * 1000 + [\\"banana\\"] * 500 + [\\"orange\\"] * 500) \\"apple\\" >>> most_frequent([\\"a\\"] * 1000 + [\\"b\\"] * 1000 + [\\"c\\"] * 1000) \\"a\\" # or \\"b\\" or \\"c\\"","solution":"from collections import Counter def most_frequent(strings): Returns the most frequent string in the array of strings. If there is a tie, return any one of the most frequent strings. count = Counter(strings) most_common_freq = max(count.values()) for string, freq in count.items(): if freq == most_common_freq: return string"},{"question":"def min_operations(s1: str, s2: str) -> int: Determine the minimum number of operations needed to transform one DNA sequence into another. The operations allowed are: 1. Insert a character 2. Delete a character 3. Replace a character Args: s1 : str : original DNA sequence s2 : str : target DNA sequence Returns: int : the minimum number of operations required to transform s1 into s2. Examples: >>> min_operations(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> min_operations(\\"SUNDAY\\", \\"SATURDAY\\") 3","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) # Create a DP array to store the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no extra operation required else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"from typing import List def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of character changes required to transform the string s into a palindrome. >>> min_changes_to_palindrome(\\"ab\\") 1 >>> min_changes_to_palindrome(\\"race\\") 2 >>> min_changes_to_palindrome(\\"madam\\") 0 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases to find the minimum number of character changes required for each string. >>> process_test_cases(3, [\\"ab\\", \\"race\\", \\"madam\\"]) [1, 2, 0]","solution":"def min_changes_to_palindrome(s): Returns the minimum number of character changes required to transform the string s into a palindrome. n = len(s) count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_changes_to_palindrome(s)) return results"},{"question":"def knapsack_problem(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Solves the knapsack problem for multiple test cases using a greedy approach. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two elements: - (int, int): Two integers N and W where N is the number of items and W is the maximum weight capacity of the knapsack. - list of int: List of N integers representing the weights of the items. Returns: list of int: Maximum weights that can be carried by the knapsack for each test case. pass from typing import List, Tuple def test_example(): T = 2 test_cases = [ ((3, 50), [10, 20, 30]), ((4, 5), [4, 3, 2, 1]) ] assert knapsack_problem(T, test_cases) == [50, 5] def test_single_item_case(): T = 1 test_cases = [ ((1, 100), [99]) ] assert knapsack_problem(T, test_cases) == [99] def test_no_valid_combination(): T = 1 test_cases = [ ((3, 1), [2, 2, 3]) ] assert knapsack_problem(T, test_cases) == [0] def test_all_combinations_fit(): T = 1 test_cases = [ ((4, 100), [20, 30, 25, 15]) ] assert knapsack_problem(T, test_cases) == [90] def test_mixed_items(): T = 1 test_cases = [ ((6, 10), [1, 8, 7, 3, 2, 4]) ] assert knapsack_problem(T, test_cases) == [10] def test_large_input(): T = 1 test_cases = [ ((100, 1000), [i for i in range(1, 101)]) ] assert knapsack_problem(T, test_cases) == [1000]","solution":"def knapsack_problem(T, test_cases): Solves the knapsack problem for multiple test cases using a greedy approach. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two elements: - (int, int): Two integers N and W where N is the number of items and W is the maximum weight capacity of the knapsack. - list of int: List of N integers representing the weights of the items. Returns: list of int: Maximum weights that can be carried by the knapsack for each test case. results = [] for i in range(T): N, W = test_cases[i][0] weights = sorted(test_cases[i][1], reverse=True) total_weight = 0 for weight in weights: if total_weight + weight <= W: total_weight += weight results.append(total_weight) return results"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of trapped rainwater. :param height: List[int] - list of non-negative integers representing the heights. :return: int - total amount of trapped rainwater. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([0, 1, 2, 3, 4]) == 0 >>> trap([4, 3, 2, 1, 0]) == 0 >>> trap([2, 2, 2, 2, 2]) == 0 >>> trap([2, 0, 2]) == 2 >>> trap([3, 0, 2, 0, 4]) == 7 >>> large_input = [0] * 10**4 >>> trap(large_input) == 0","solution":"def trap(height): Calculate the total amount of trapped rainwater. :param height: List[int] - list of non-negative integers representing the heights. :return: int - total amount of trapped rainwater. if not height: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) total_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) total_water += max(0, right_max - height[right]) return total_water"},{"question":"def sum_of_digits_until_single(n: int) -> int: Takes an integer \`n\` and repeatedly adds its digits until the result is a single digit. >>> sum_of_digits_until_single(38) 2 >>> sum_of_digits_until_single(1234) 1 >>> sum_of_digits_until_single(98765) 8 >>> sum_of_digits_until_single(0) 0 >>> sum_of_digits_until_single(999999999) 9 pass","solution":"def sum_of_digits_until_single(n: int) -> int: Takes an integer \`n\` and repeatedly adds its digits until the result is a single digit. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def findSecondLargest(arr): Finds the second largest element in the given array or returns 'All elements are equal' if no such element exists. >>> findSecondLargest([10, 5, 8, 12, 3]) 10 >>> findSecondLargest([1, 1, 1, 1]) 'All elements are equal' >>> findSecondLargest([1, 2]) 1 >>> findSecondLargest([2, 2]) 'All elements are equal' >>> findSecondLargest([3, 3, 2]) 2 >>> findSecondLargest([1000, 999, 998, 1000]) 999","solution":"def findSecondLargest(arr): Finds the second largest element in the given array or returns 'All elements are equal' if no such element exists. if len(arr) < 2: return 'All elements are equal' first = second = float('-inf') for num in arr: if num > first: second = first first = num elif num > second and num < first: second = num if second == float('-inf'): return 'All elements are equal' return second"},{"question":"def classify_temperatures(N, temperatures): Classifies each city's temperature as \\"Cold Day\\", \\"Warm Day\\", or \\"Hot Day\\". Parameters: N (int): The number of cities temperatures (list of int): The temperatures of the cities Returns: list of str: A list containing the classification of each day's temperature # Write your code here","solution":"def classify_temperatures(N, temperatures): Classifies each city's temperature as \\"Cold Day\\", \\"Warm Day\\", or \\"Hot Day\\". Parameters: N (int): The number of cities temperatures (list of int): The temperatures of the cities Returns: list of str: A list containing the classification of each day's temperature result = [] for temp in temperatures: if temp < 20: result.append(\\"Cold Day\\") elif 20 <= temp <= 30: result.append(\\"Warm Day\\") else: result.append(\\"Hot Day\\") return result"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence while keeping the characters in each word unchanged. Parameters: sentence (str): The input sentence to reverse words. Returns: str: The sentence with words in reversed order. >>> reverse_words(\\"Hello world\\") == \\"world Hello\\" >>> reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" >>> reverse_words(\\"Python is fun\\") == \\"fun is Python\\" def test_single_word(): assert reverse_words(\\"Hello\\") == \\"Hello\\" def test_two_words(): assert reverse_words(\\"Hello world\\") == \\"world Hello\\" def test_with_punctuation(): assert reverse_words(\\"Hello world!\\") == \\"world! Hello\\" assert reverse_words(\\"Python is fun.\\") == \\"fun. is Python\\" def test_long_sentence(): assert reverse_words(\\"The quick brown fox jumps over the lazy dog\\") == \\"dog lazy the over jumps fox brown quick The\\" def test_same_word_repeated(): assert reverse_words(\\"test test test\\") == \\"test test test\\" def test_mixed_case(): assert reverse_words(\\"Hello World\\") == \\"World Hello\\" def test_numbers(): assert reverse_words(\\"1 2 3 4 5\\") == \\"5 4 3 2 1\\"","solution":"def reverse_words(sentence): Reverses the order of words in a given sentence. Parameters: sentence (str): The input sentence to reverse words. Returns: str: The sentence with words in reversed order. words = sentence.split() reversed_sentence = ' '.join(reversed(words)) return reversed_sentence"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Given an array of integer numbers, find the longest subsequence of consecutive integers in the array. A subsequence is derived by deleting some or no elements without changing the order of the remaining elements. >>> longest_consecutive_subsequence([1, 2, 9, 3, 10, 4]) 4 >>> longest_consecutive_subsequence([5, 3, 1, 2, 4]) 5 >>> longest_consecutive_subsequence([10, 20, 30, 40]) 1 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([42]) 1 >>> longest_consecutive_subsequence([5, 10, 15, 20, 25]) 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10","solution":"def longest_consecutive_subsequence(arr): if not arr: return 0 # Create a set of the elements arr_set = set(arr) longest_length = 0 for num in arr: # Only check for the starting number of a sequence if num - 1 not in arr_set: current_length = 1 current_num = num # Check the next numbers in the sequence while current_num + 1 in arr_set: current_length += 1 current_num += 1 # Update the longest sequence length if necessary longest_length = max(longest_length, current_length) return longest_length"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def can_return_to_capital(N: int, M: int, edges: List[Tuple[int, int]]) -> str: In the kingdom of Zimno, determine if there is a way to travel from the capital city (city 1) to any other city and back to the capital using two different roads. Args: N: an integer, the number of cities. M: an integer, the number of roads. edges: a list of tuples representing one-way roads between cities. Returns: str: \\"YES\\" if there exists at least one city that can be reached from the capital and from which you can return to the capital, otherwise \\"NO\\". >>> can_return_to_capital(4, 4, [(1, 2), (2, 3), (3, 1), (1, 3)]) == \\"YES\\" >>> can_return_to_capital(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"NO\\"","solution":"from collections import defaultdict, deque def can_return_to_capital(N, M, edges): # Create adjacency lists for the graph and its reverse graph = defaultdict(list) rev_graph = defaultdict(list) for u, v in edges: graph[u].append(v) rev_graph[v].append(u) def bfs(source, adj_list): reachable = [False] * (N + 1) queue = deque([source]) reachable[source] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not reachable[neighbor]: reachable[neighbor] = True queue.append(neighbor) return reachable # Find all reachable nodes from the capital (city 1) reachable_from_capital = bfs(1, graph) # Find all nodes that can reach the capital reachable_to_capital = bfs(1, rev_graph) # Check if there exists a city that is reachable from the capital and can also return to the capital for city in range(2, N + 1): # city 1 is the capital, skip it if reachable_from_capital[city] and reachable_to_capital[city]: return \\"YES\\" return \\"NO\\""},{"question":"def secret_language(text: str, shift: int) -> str: Encodes the given text by rotating each alphabetical character by the shift amount. Args: text (str): The text to encode. shift (int): The number of positions to shift each alphabetic character. Returns: str: The encoded text. >>> secret_language(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> secret_language(\\"Hello, World!\\", 0) 'Hello, World!' >>> secret_language(\\"Khoor, Zruog!\\", -3) 'Hello, World!' >>> secret_language(\\"xyz\\", 3) 'abc' >>> secret_language(\\"XYZ\\", 3) 'ABC' >>> secret_language(\\"Hello, World!\\", 13) 'Uryyb, Jbeyq!' >>> secret_language(\\"abc\\", 52) 'abc' >>> secret_language(\\"\\", 5) '' >>> secret_language(\\"abc\\", -52) 'abc' >>> secret_language(\\"ABC\\", -52) 'ABC'","solution":"def secret_language(text, shift): Encodes the given text by rotating each alphabetical character by the shift amount. Args: text (str): The text to encode. shift (int): The number of positions to shift each alphabetic character. Returns: str: The encoded text. def shift_char(c, shift): if c.islower(): return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif c.isupper(): return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) return c return ''.join(shift_char(c, shift) for c in text)"},{"question":"class BrowserHistory: Design a data structure that supports the following operations in a web browser's history: - visit(String url): Visits the url from the current page, pushing it onto the history stack. - back(int steps): Moves steps back in the history, if possible. If you can't move that far back, return as far as possible. - forward(int steps): Moves steps forward in the history, if possible. If you can't move that far forward, return as far as possible. Example: >>> browser_history = BrowserHistory(\\"leetcode.com\\") >>> browser_history.visit(\\"google.com\\") >>> browser_history.visit(\\"youtube.com\\") >>> browser_history.visit(\\"facebook.com\\") >>> browser_history.back(1) 'youtube.com' >>> browser_history.back(1) 'google.com' >>> browser_history.forward(1) 'youtube.com' >>> browser_history.visit(\\"linkedin.com\\") >>> browser_history.forward(2) 'linkedin.com' >>> browser_history.back(2) 'google.com' >>> browser_history.back(7) 'leetcode.com' def __init__(self, homepage: str): pass def visit(self, url: str) -> None: pass def back(self, steps: int) -> str: pass def forward(self, steps: int) -> str: pass def test_browser_history(): browser_history = BrowserHistory(\\"leetcode.com\\") browser_history.visit(\\"google.com\\") assert browser_history.history == [\\"leetcode.com\\", \\"google.com\\"] assert browser_history.current == 1 browser_history.visit(\\"youtube.com\\") assert browser_history.history == [\\"leetcode.com\\", \\"google.com\\", \\"youtube.com\\"] assert browser_history.current == 2 browser_history.visit(\\"facebook.com\\") assert browser_history.history == [\\"leetcode.com\\", \\"google.com\\", \\"youtube.com\\", \\"facebook.com\\"] assert browser_history.current == 3 assert browser_history.back(1) == \\"youtube.com\\" assert browser_history.current == 2 assert browser_history.back(1) == \\"google.com\\" assert browser_history.current == 1 assert browser_history.forward(1) == \\"youtube.com\\" assert browser_history.current == 2 browser_history.visit(\\"linkedin.com\\") assert browser_history.history == [\\"leetcode.com\\", \\"google.com\\", \\"youtube.com\\", \\"linkedin.com\\"] assert browser_history.current == 3 assert browser_history.forward(2) == \\"linkedin.com\\" assert browser_history.current == 3 assert browser_history.back(2) == \\"google.com\\" assert browser_history.current == 1 assert browser_history.back(7) == \\"leetcode.com\\" assert browser_history.current == 0","solution":"class BrowserHistory: def __init__(self, homepage: str): self.history = [homepage] # Stack for the browser history self.current = 0 # Pointer to the current page in the history def visit(self, url: str) -> None: self.history = self.history[:self.current + 1] # Discard forward history self.history.append(url) self.current += 1 def back(self, steps: int) -> str: self.current = max(0, self.current - steps) # Move back steps or to the beginning return self.history[self.current] def forward(self, steps: int) -> str: self.current = min(len(self.history) - 1, self.current + steps) # Move forward steps or to the end return self.history[self.current]"},{"question":"def max_gold_collect(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[Tuple[int, List[int]]]: Determine the maximum number of gold coins Chef can collect and the sequence of rooms he should visit. >>> max_gold_collect(2, [((5, 2), [0, 2, 4, 1, 3]), ((4, 1), [3, 2, 5, 6])]) [(10, [1, 2, 3, 4, 5]), (16, [1, 2, 3, 4])] >>> max_gold_collect(1, [((3, 1), [0, 0, 0])]) [(0, [1, 2, 3])] >>> max_gold_collect(1, [((5, 1), [0, 0, 0, 0, 10])]) [(10, [1, 2, 3, 4, 5])] >>> max_gold_collect(1, [((1, 1), [100])]) [(100, [1])] >>> max_gold_collect(1, [((3, 5), [1, 2, 3])]) [(6, [1, 2, 3])]","solution":"def max_gold_collect(T, test_cases): results = [] for i in range(T): N, X = test_cases[i][0] coins = test_cases[i][1] dp = [[-1] * (X + 1) for _ in range(N)] dp[0][0] = coins[0] for room in range(1, N): for stay in range(X + 1): max_prev = 0 if stay > 0: max_prev = max(dp[room][stay - 1], dp[room - 1][stay - 1]) else: max_prev = max(dp[room - 1]) dp[room][stay] = max_prev + (coins[room] if stay == 0 else 0) max_coins = max(dp[N - 1]) path = [] current_room = N - 1 max_stay = dp[N - 1].index(max_coins) while current_room >= 0: path.append(current_room + 1) if max_stay == 0: current_room -= 1 while current_room >= 0 and max(dp[current_room]) != dp[current_room + 1][0] - coins[current_room + 1]: current_room -= 1 if current_room >= 0: max_stay = dp[current_room].index(max(dp[current_room])) else: max_stay -= 1 current_room -= 1 results.append((max_coins, list(reversed(path)))) return results"},{"question":"def arrange_mirrors(n: int, m: int, garden: List[List[str]]) -> List[List[str]]: Arrange mirrors 'M' on the boundary of the garden matrix to maximize sunlight reflection. >>> arrange_mirrors(5, 5, [['S', 'S', 'S', 'S', 'S'], ['S', 'S', 'S', 'S', 'S'], ['S', 'S', 'S', 'S', 'S'], ['S', 'S', 'S', 'S', 'S'], ['S', 'S', 'S', 'S', 'S']]) [['M', 'M', 'M', 'M', 'M'], ['M', 'S', 'S', 'S', 'M'], ['M', 'S', 'S', 'S', 'M'], ['M', 'S', 'S', 'S', 'M'], ['M', 'M', 'M', 'M', 'M']] >>> arrange_mirrors(3, 3, [['M', 'M', 'M'], ['M', 'S', 'M'], ['M', 'M', 'M']]) [['M', 'M', 'M'], ['M', 'S', 'M'], ['M', 'M', 'M']]","solution":"def arrange_mirrors(n, m, garden): Arrange mirrors 'M' on the boundary of the garden matrix to maximize sunlight reflection. # Create a deep copy of the garden to modify and return modified_garden = [row[:] for row in garden] # Place mirrors on the top and bottom rows for i in range(m): modified_garden[0][i] = 'M' modified_garden[n-1][i] = 'M' # Place mirrors on the left and right columns for i in range(n): modified_garden[i][0] = 'M' modified_garden[i][m-1] = 'M' return modified_garden"},{"question":"from typing import List def findMajorityElements(arr: List[int]) -> List[int]: Finds elements in the list that appear more than n/3 times. >>> findMajorityElements([3,3,4,2,4,4,2,4,4]) [4] >>> findMajorityElements([3,2,3]) [3] >>> findMajorityElements([1,2,3,4,5,6]) [] >>> findMajorityElements([1]) [1] >>> findMajorityElements([]) [] >>> findMajorityElements([5, 5, 5, 5]) [5]","solution":"from collections import Counter from typing import List def findMajorityElements(arr: List[int]) -> List[int]: Finds elements in the list that appear more than n/3 times. if not arr: return [] n = len(arr) threshold = n // 3 counter = Counter(arr) result = [num for num, count in counter.items() if count > threshold] return result"},{"question":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: Push element x to the back of the queue. pass def dequeue(self) -> int: Removes the element from in front of the queue and returns that element. pass # Unit Test def test_enqueue_dequeue_operations(): queue = QueueUsingStacks() queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 2 queue.enqueue(4) assert queue.dequeue() == 3 assert queue.dequeue() == 4 assert queue.dequeue() == -1 def test_multiple_dequeues(): queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.dequeue() == -1 def test_empty_dequeue(): queue = QueueUsingStacks() assert queue.dequeue() == -1 def test_enqueue_dequeue_interleaved(): queue = QueueUsingStacks() queue.enqueue(10) assert queue.dequeue() == 10 queue.enqueue(20) queue.enqueue(30) assert queue.dequeue() == 20 queue.enqueue(40) assert queue.dequeue() == 30 assert queue.dequeue() == 40 assert queue.dequeue() == -1","solution":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: Push element x to the back of the queue. self.stack1.append(x) def dequeue(self) -> int: Removes the element from in front of the queue and returns that element. if not self.stack2: if not self.stack1: return -1 while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()"},{"question":"def rotate_list(N: int, K: int) -> List[int]: Generates a list of the first N natural numbers and rotates it to the right by K positions. >>> rotate_list(5, 2) [4, 5, 1, 2, 3] >>> rotate_list(6, 3) [4, 5, 6, 1, 2, 3] >>> rotate_list(4, 1) [4, 1, 2, 3] def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[str]: Processes multiple test cases and returns the rotated lists for each test case. >>> process_test_cases([(5, 2), (6, 3), (4, 1)]) ['4 5 1 2 3', '4 5 6 1 2 3', '4 1 2 3']","solution":"def rotate_list(N, K): Generates a list of the first N natural numbers and rotates it to the right by K positions. original_list = list(range(1, N + 1)) K = K % N # In case K is larger than N rotated_list = original_list[-K:] + original_list[:-K] return rotated_list def process_test_cases(test_cases): Process multiple test cases and returns the rotated lists for each test case. results = [] for N, K in test_cases: rotated = rotate_list(N, K) results.append(\\" \\".join(map(str, rotated))) return results"},{"question":"def shortest_bridge(N_A: int, townA_points: List[Tuple[int, int]], N_B: int, townB_points: List[Tuple[int, int]]) -> int: Calculate the squared length of the shortest possible bridge to connect Town-A and Town-B across a river. >>> shortest_bridge(3, [(-3, 2), (-2, -1), (-4, 5)], 2, [(4, 3), (1, -2)]) == 10 >>> shortest_bridge(1, [(-1, 1)], 1, [(1, 1)]) == 4 >>> shortest_bridge(2, [(-1, 0), (-1, 1)], 2, [(1, 0), (1, 1)]) == 4 >>> shortest_bridge(1, [(-1000000, 0)], 1, [(1000000, 0)]) == 4000000000000 >>> shortest_bridge(4, [(-3, 2), (-2, -1), (-4, 5), (-1, -5)], 3, [(4, 3), (1, -2), (3, 7)]) == 10","solution":"def shortest_bridge(N_A, townA_points, N_B, townB_points): minimum_distance = float('inf') for x1, y1 in townA_points: for x2, y2 in townB_points: squared_distance = (x2 - x1) ** 2 + (y2 - y1) ** 2 if squared_distance < minimum_distance: minimum_distance = squared_distance return minimum_distance"},{"question":"def count_good_segments(n: int, k: int, lengths: List[int]) -> int: Returns the number of road segments in good condition. :param n: Number of road segments. :param k: The divisor used to determine if a road segment is in good condition. :param lengths: List of lengths of road segments. :return: The number of road segments in good condition. >>> count_good_segments(5, 2, [4, 5, 6, 8, 10]) 4 >>> count_good_segments(4, 3, [3, 6, 9, 12]) 4 >>> count_good_segments(3, 1, [5, 10, 15]) 3 >>> count_good_segments(3, 10, [1, 2, 3]) 0 >>> count_good_segments(1, 2, [4]) 1 >>> count_good_segments(1, 3, [4]) 0 >>> count_good_segments(6, 4, [4, 7, 8, 10, 12, 16]) 4","solution":"def count_good_segments(n, k, lengths): Returns the number of road segments in good condition. :param n: Number of road segments. :param k: The divisor used to determine if a road segment is in good condition. :param lengths: List of lengths of road segments. :return: The number of road segments in good condition. return sum(1 for length in lengths if length % k == 0)"},{"question":"def min_operations_to_subsequence(n: int, s: str, m: int, t: str) -> int: Determine the minimum number of characters to delete from \`s\` and add to \`s\` to create a subsequence of \`t\`. >>> min_operations_to_subsequence(5, 'abcde', 3, 'ace') == 2 >>> min_operations_to_subsequence(6, 'abcdef', 4, 'abcf') == 2 >>> min_operations_to_subsequence(4, 'abcd', 6, 'afbcge') == 4 >>> min_operations_to_subsequence(3, 'abc', 3, 'xyz') == 6 >>> min_operations_to_subsequence(7, 'aaccede', 4, 'acee') == 3 >>> min_operations_to_subsequence(1, 'a', 1, 'a') == 0 >>> min_operations_to_subsequence(1, 'a', 1, 'b') == 2","solution":"def min_operations_to_subsequence(n: int, s: str, m: int, t: str) -> int: # Create a dictionary to keep track of character frequencies in 't' from collections import Counter t_counter = Counter(t) # Create a dictionary to keep track of character frequencies in 's' s_counter = Counter(s) # Count the number of characters in 's' that are also needed in 't' common_char_count = sum(min(s_counter[char], t_counter[char]) for char in t_counter) # Total operations = (Length of t - common characters) + (Length of s - common characters) return (m - common_char_count) + (n - common_char_count)"},{"question":"def find_other_corners(x1, y1, x2, y2): Given two opposite corners (x1, y1) and (x2, y2) of a rectangle aligned with the coordinate axes, this function returns the coordinates of the other two corners. Parameters: x1, y1: coordinates of the first corner. x2, y2: coordinates of the second corner. Returns: List of tuples, each representing the coordinates of the other two corners, sorted in ascending order first by x-coordinate, then by y-coordinate. >>> find_other_corners(1, 2, 4, 5) [(1, 5), (4, 2)] >>> find_other_corners(3, 3, 3, 7) [(3, 3), (3, 7)] >>> find_other_corners(-1, -2, 3, 4) [(-1, 4), (3, -2)] >>> find_other_corners(-3, 2, 5, -5) [(-3, -5), (5, 2)] >>> find_other_corners(-1000, 1000, 1000, -1000) [(-1000, -1000), (1000, 1000)]","solution":"def find_other_corners(x1, y1, x2, y2): Given two opposite corners (x1, y1) and (x2, y2) of a rectangle aligned with the coordinate axes, this function returns the coordinates of the other two corners. Parameters: x1, y1: coordinates of the first corner. x2, y2: coordinates of the second corner. Returns: List of tuples, each representing the coordinates of the other two corners, sorted in ascending order first by x-coordinate, then by y-coordinate. # The other two corners will have coordinates (x1, y2) and (x2, y1) corner1 = (x1, y2) corner2 = (x2, y1) return sorted([corner1, corner2], key=lambda p: (p[0], p[1]))"},{"question":"from typing import List def find_missing_number(nums: List[int]) -> int: Given a list of unique integers, find the only missing number between the smallest and largest number in the list. :param nums: List of unique integers :return: The missing number Examples: >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([10, 12, 14, 13]) 11 def test_find_missing_number(): assert find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 assert find_missing_number([10, 12, 14, 13]) == 11 assert find_missing_number([-1, -3, -2, -5, -4, -6, -8, -7, -10]) == -9 assert find_missing_number([1, 2, 4]) == 3 assert find_missing_number([100, 102, 104, 103]) == 101 def test_find_missing_number_with_large_range(): large_range = list(range(1, 1000001)) large_range.remove(500000) assert find_missing_number(large_range) == 500000","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Given a list of unique integers, find the only missing number between the smallest and largest number in the list. :param nums: List of unique integers :return: The missing number # Calculate the expected sum of the range from min(nums) to max(nums) full_sum = sum(range(min(nums), max(nums) + 1)) # Calculate the actual sum of the elements in nums actual_sum = sum(nums) # The missing number is the difference between the full_sum and actual_sum return full_sum - actual_sum"},{"question":"def length_of_LIS(nums): Returns the length of the longest strictly increasing subsequence in the array nums. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_LIS([1, 2, 3, 4, 5]) 5 >>> length_of_LIS([5, 4, 3, 2, 1]) 1 >>> length_of_LIS([5, 1, 6, 2, 7, 3, 8, 4, 9]) 5 >>> length_of_LIS([1]) 1 >>> length_of_LIS([]) 0 pass # Your code here def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. >>> test_cases = [ ... (8, [10, 9, 2, 5, 3, 7, 101, 18]), ... (6, [0, 1, 0, 3, 2, 3]), ... (7, [7, 7, 7, 7, 7, 7, 7]) ... ] >>> process_test_cases(3, test_cases) [4, 4, 1] >>> test_cases = [ ... (5, [1, 2, 3, 4, 5]), ... (5, [5, 4, 3, 2, 1]) ... ] >>> process_test_cases(2, test_cases) [5, 1] pass # Your code here","solution":"def length_of_LIS(nums): Returns the length of the longest strictly increasing subsequence in the array nums. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(T, test_cases): results = [] for i in range(T): n, nums = test_cases[i] result = length_of_LIS(nums) results.append(result) return results"},{"question":"from typing import List, Tuple, Union def sequence_operations(operations: List[Tuple[str, int]]) -> List[Union[int, str]]: Raj loves playing his favorite game that involves managing a sequence of integers. He starts with an initially empty sequence and must perform a series of operations. Each operation is either adding a number to the sequence or finding the maximum number with a specific condition. Can you help him by implementing these operations? Each operation should be processed in the order they are given. Input format: The first line contains an integer T, the number of operations. The next T lines contain a string and an integer representing an operation and its parameter. Output format: For each \\"MAX\\" operation, print the result on a new line. If no number in the sequence satisfies the condition, print \\"NONE\\". Example: >>> sequence_operations([(\\"ADD\\", 5), (\\"ADD\\", 3), (\\"ADD\\", 10), (\\"MAX\\", 4), (\\"MAX\\", 11), (\\"ADD\\", 7)]) [5, \\"NONE\\"] >>> sequence_operations([(\\"ADD\\", 1), (\\"ADD\\", 2), (\\"MAX\\", 3), (\\"MAX\\", 4)]) [\\"NONE\\", \\"NONE\\"] pass","solution":"import bisect def sequence_operations(operations): sequence = [] results = [] for operation in operations: op, value = operation if op == \\"ADD\\": bisect.insort(sequence, value) elif op == \\"MAX\\": idx = bisect.bisect_left(sequence, value) if idx < len(sequence): results.append(sequence[idx]) else: results.append(\\"NONE\\") return results"},{"question":"def is_palindrome(word: str) -> bool: Determine if a given word is a palindrome. A palindrome reads the same backward as forward, ignoring case and spaces. >>> is_palindrome(\\"Level\\") == True >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"Programming\\") == False >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"z\\") == True >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"A Santa at NASA\\") == True >>> is_palindrome(\\"No lemon no melon\\") == True","solution":"def is_palindrome(word): Returns True if the given word is a palindrome, False otherwise. A palindrome reads the same backward as forward, ignoring case and spaces. # Remove spaces and convert to lower case cleaned_word = ''.join(word.split()).lower() # Check if the cleaned word is the same as its reverse return cleaned_word == cleaned_word[::-1]"},{"question":"def can_gather_all_ninjas(n: int, k: int, ninjas: List[Tuple[int, int]]) -> str: Determine if it's possible to gather all ninjas at the same position using their jumps. >>> can_gather_all_ninjas(5, 3, [(1, 2), (4, 1), (5, 3)]) \\"YES\\" >>> can_gather_all_ninjas(7, 3, [(1, 2), (4, 2), (6, 1)]) \\"NO\\"","solution":"def can_gather_all_ninjas(n, k, ninjas): for target in range(1, n + 1): possible = True for (p, e) in ninjas: if abs(target - p) > e: possible = False break if possible: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def longest_subarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with the same value. >>> longest_subarray([1, 1, 0, 1, 1, 1]) 3 >>> longest_subarray([1, 2, 3]) 1 >>> longest_subarray([2, 2, 2, 2, 2]) 5","solution":"def longest_subarray(nums): Returns the length of the longest contiguous subarray with the same value. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def move_objects_up(grid: List[List[int]]) -> List[List[int]]: Moves all the objects in the grid up as much as possible without changing their horizontal positions or the order of their vertical positions. >>> move_objects_up([[0, 0, 3, 0, 0], [0, 2, 0, 0, 0], [0, 0, 0, 4, 0], [0, 2, 0, 3, 1], [1, 0, 0, 0, 0]]) [[1, 2, 3, 4, 1], [0, 2, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] >>> move_objects_up([[0, 2, 0, 0], [1, 0, 0, 3], [0, 0, 4, 0], [0, 2, 0, 0]]) [[1, 2, 4, 3], [0, 2, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] >>> move_objects_up([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> move_objects_up([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] pass","solution":"def move_objects_up(grid): Moves all the objects in the grid up as much as possible without changing their horizontal positions or the order of their vertical positions. m = len(grid) n = len(grid[0]) for col in range(n): # Extract the non-zero elements in the current column objects = [grid[row][col] for row in range(m) if grid[row][col] != 0] # Position them at the top for i in range(m): if i < len(objects): grid[i][col] = objects[i] else: grid[i][col] = 0 return grid"},{"question":"def find_lone_survivors(matrix): Finds the lone survivors in the matrix. A lone survivor is a number that appears exactly once in its row and column. :param matrix: List[List[int]] - The input matrix :return: List[int] - Sorted list of lone survivors >>> find_lone_survivors([[4, 5, 6], [1, 9, 2], [8, 7, 3]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> find_lone_survivors([[4, 6, 6], [1, 9, 2], [8, 6, 3]]) [1, 2, 3, 4, 8, 9]","solution":"def find_lone_survivors(matrix): Finds the lone survivors in the matrix. A lone survivor is a number that appears exactly once in its row and column. :param matrix: List[List[int]] - The input matrix :return: List[int] - Sorted list of lone survivors from collections import defaultdict # Initialize row and column counts row_counts = defaultdict(lambda: defaultdict(int)) col_counts = defaultdict(lambda: defaultdict(int)) n_rows = len(matrix) n_cols = len(matrix[0]) if n_rows > 0 else 0 # Populate row and column counts for i in range(n_rows): for j in range(n_cols): num = matrix[i][j] row_counts[i][num] += 1 col_counts[j][num] += 1 # Find lone survivors lone_survivors = [] for i in range(n_rows): for j in range(n_cols): num = matrix[i][j] if row_counts[i][num] == 1 and col_counts[j][num] == 1: lone_survivors.append(num) # Return sorted list of lone survivors return sorted(lone_survivors)"},{"question":"from typing import List, Tuple def shortest_travel_time(N: int, M: int, tracks: List[Tuple[int, int, int]], A: int, B: int) -> int: Determine the shortest travel time required to travel from city A to city B in the railway network. :param N: int - the number of cities (2 ≤ N ≤ 50) :param M: int - the number of tracks (1 ≤ M ≤ 100) :param tracks: List[Tuple[int, int, int]] - a list of tracks where each track is represented by three integers (u, v, t) :param A: int - the starting city :param B: int - the destination city :return: int - the shortest travel time or -1 if there is no path >>> N, M = 5, 6 >>> tracks = [(1, 2, 10), (1, 3, 5), (2, 3, 2), (3, 4, 1), (2, 4, 12), (4, 5, 3)] >>> A, B = 1, 5 >>> shortest_travel_time(N, M, tracks, A, B) 9 >>> N, M = 4, 3 >>> tracks = [(1, 2, 4), (2, 3, 6), (3, 4, 8)] >>> A, B = 1, 4 >>> shortest_travel_time(N, M, tracks, A, B) -1 # Your implementation here def test_shortest_travel_time(): # Test case 1 N, M = 5, 6 tracks = [ (1, 2, 10), (1, 3, 5), (2, 3, 2), (3, 4, 1), (2, 4, 12), (4, 5, 3) ] A, B = 1, 5 assert shortest_travel_time(N, M, tracks, A, B) == 9 # Test case 2: No path between cities N, M = 4, 3 tracks = [ (1, 2, 4), (2, 3, 6), (3, 4, 8) ] A, B = 1, 4 assert shortest_travel_time(N, M, tracks, A, B) == -1 # Test case 3: Single node to itself N, M = 2, 1 tracks = [ (1, 2, 10) ] A, B = 2, 2 assert shortest_travel_time(N, M, tracks, A, B) == 0 # Test case 4: Disconnected graph N, M = 4, 2 tracks = [ (1, 2, 7), (3, 4, 9) ] A, B = 1, 4 assert shortest_travel_time(N, M, tracks, A, B) == -1 # Test case 5: Direct path N, M = 3, 3 tracks = [ (1, 2, 3), (2, 3, 4), (1, 3, 8) ] A, B = 1, 3 assert shortest_travel_time(N, M, tracks, A, B) == 7 if __name__ == \\"__main__\\": test_shortest_travel_time()","solution":"import heapq def shortest_travel_time(N, M, tracks, A, B): # Create adjacency list for the graph graph = {i: [] for i in range(1, N + 1)} for u, v, t in tracks: graph[u].append((v, t)) graph[v].append((u, t)) # Dijkstra's algorithm to find shortest path pq = [(0, A)] dist = {i: float('inf') for i in range(1, N + 1)} dist[A] = 0 visited = set() while pq: current_dist, u = heapq.heappop(pq) if u in visited: continue visited.add(u) for v, t in graph[u]: if v not in visited: new_dist = current_dist + t if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(pq, (new_dist, v)) return dist[B] if dist[B] != float('inf') else -1"},{"question":"def containsNearbyDuplicate(nums: List[int], k: int) -> bool: Write a function that takes an array of integers as input and returns a boolean value indicating whether the array contains any duplicates within a given distance k from each other. Two integers are considered duplicates if they are equal, and the distance between them is the absolute difference of their indices in the array. Parameters: nums (list[int]): A list of integers. k (int): An integer representing the maximum allowed index distance between duplicate elements. Returns: bool: True if duplicates exist within the given distance k, otherwise False. >>> containsNearbyDuplicate([1, 2, 3, 1], 3) True >>> containsNearbyDuplicate([1, 0, 1, 1], 1) True >>> containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2) False","solution":"def containsNearbyDuplicate(nums: list[int], k: int) -> bool: Checks if the input list contains any duplicates within a given distance k. Parameters: nums (list[int]): A list of integers. k (int): An integer representing the maximum allowed index distance between duplicate elements. Returns: bool: True if duplicates exist within the given distance k, otherwise False. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"from typing import List, Tuple def max_possible_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible difference between the height of the tallest building and the height of the smallest building after demolishing exactly one building. >>> max_possible_difference(3, [(5, [2, 3, 1, 7, 5]), (4, [5, 5, 5, 5]), (3, [1, 1, 10])]) [6, 0, 9] >>> max_possible_difference(1, [(2, [1, 2])]) [1] >>> max_possible_difference(1, [(3, [1000000, 1000000, 1000000])]) [0]","solution":"def max_possible_difference(T, test_cases): results = [] for case in test_cases: N, heights = case if N == 2: results.append(abs(heights[0] - heights[1])) else: max_height = max(heights) second_max_height = sorted(heights)[-2] min_height = min(heights) second_min_height = sorted(heights)[1] result = max(max_height - min_height, second_max_height - min_height, max_height - second_min_height) results.append(result) return results"},{"question":"def countDeluxeCookies(x, y): Determines the maximum number of deluxe cookies that can be baked. A deluxe cookie requires exactly 2 'A's and 1 'B'. Parameters: x (int): The number of 'A's available. y (int): The number of 'B's available. Returns: int: The maximum number of deluxe cookies that can be baked. Example: >>> countDeluxeCookies(5, 3) 2 >>> countDeluxeCookies(4, 5) 2","solution":"def countDeluxeCookies(x, y): Determines the maximum number of deluxe cookies that can be baked. A deluxe cookie requires exactly 2 'A's and 1 'B'. Parameters: x (int): The number of 'A's available. y (int): The number of 'B's available. Returns: int: The maximum number of deluxe cookies that can be baked. # A deluxe cookie requires 2 'A's and 1 'B' return min(x // 2, y)"},{"question":"def count_items(item_list): Counts the number of each item type from the given list of items. Args: item_list (list): List of items donated. Returns: dict: Dictionary with item types as keys and their counts as values. Examples: >>> count_items([\\"book\\", \\"clothes\\", \\"book\\", \\"electronics\\", \\"clothes\\"]) {'book': 2, 'clothes': 2, 'electronics': 1} >>> count_items([\\"toys\\", \\"clothes\\", \\"clothes\\"]) {'clothes': 2, 'toys': 1}","solution":"def count_items(item_list): Counts the number of each item type from the given list of items. Args: item_list (list): List of items donated. Returns: dict: Dictionary with item types as keys and their counts as values. counts = {} for item in item_list: if item in counts: counts[item] += 1 else: counts[item] = 1 sorted_counts = dict(sorted(counts.items())) return sorted_counts if __name__ == \\"__main__\\": import sys input = sys.stdin.read().splitlines() n = int(input[0]) # the number of donated items items = input[1:n+1] # the list of donated items result = count_items(items) for item_type, count in result.items(): print(f\\"{item_type} {count}\\")"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectLoopStart(head: ListNode) -> ListNode: Given a node in a circular linked list, this function returns the starting node of the loop in the linked list. pass def test_detect_loop_start_example1(): values = [1, 2, 3] head, loop_start = createCircularLinkedList(values) assert detectLoopStart(head) == loop_start def test_detect_loop_start_example2(): values = [4, 5, 6, 7] head, loop_start = createCircularLinkedList(values) assert detectLoopStart(head) == loop_start def test_detect_loop_start_single_node(): head = ListNode(1) head.next = head # single node pointing to itself assert detectLoopStart(head) == head def test_detect_loop_start_two_nodes(): node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 node2.next = node1 # circular link assert detectLoopStart(node1) == node1 def test_detect_loop_start_longer_list(): values = [10, 20, 30, 40, 50] head, loop_start = createCircularLinkedList(values) assert detectLoopStart(head) == loop_start def test_detect_loop_start_middle_node_loop(): # Create a linear linked list first nodes = [ListNode(value) for value in [1, 2, 3, 4, 5]] for i in range(4): nodes[i].next = nodes[i+1] # Introduce a loop (3rd node pointing to 2nd node) nodes[-1].next = nodes[1] assert detectLoopStart(nodes[0]) == nodes[1]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectLoopStart(head): Given a node in a circular linked list, this function returns the starting node of the loop in the linked list. if not head or not head.next: return None slow = fast = head # Detect loop using Floyd’s Cycle detection algorithm (Tortoise and Hare) while True: slow = slow.next fast = fast.next.next if slow == fast: break # Move slow to head, keep fast at meeting point. # The point where they meet again is the start of the loop. slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def check_profit(daily_sales: List[int], threshold: int) -> bool: Determine if the bookstore made a profit every day of the week. Parameters: daily_sales (list of int): List of daily sales for 7 days. threshold (int): The threshold value to compare sales against. Returns: bool: True if all daily sales are above the threshold, False otherwise. Examples: >>> check_profit([120, 130, 140, 150, 160, 110, 115], 100) True >>> check_profit([90, 110, 115, 130, 145, 120, 135], 100) False","solution":"def check_profit(daily_sales, threshold): Checks if all the daily sales in the list exceed the given threshold value. Parameters: daily_sales (list of int): List of daily sales for 7 days. threshold (int): The threshold value to compare sales against. Returns: bool: True if all daily sales are above the threshold, False otherwise. return all(sale > threshold for sale in daily_sales)"},{"question":"def min_tarpaulins(heights): Determines the minimum number of tarpaulins needed to cover buildings. :param heights: List of integers representing the heights of the buildings. :return: Minimum number of tarpaulins. # write your code here def number_of_tarpaulins(test_cases): Computes the minimum number of tarpaulins needed for multiple test cases. :param test_cases: List of tuples, where each tuple contains an integer and a list of integers representing the heights of the buildings. :return: List of integers, each representing the minimum number of tarpaulins for a test case. # write your code here # Unit Test def test_min_tarpaulins(): assert min_tarpaulins([1, 2, 3, 4, 5]) == 5 assert min_tarpaulins([5, 3, 2, 3]) == 3 assert min_tarpaulins([10, 10, 10, 10]) == 1 assert min_tarpaulins([1, 1, 1, 1, 1]) == 1 assert min_tarpaulins([2, 2, 2, 5, 5]) == 2 def test_number_of_tarpaulins(): test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [5, 3, 2, 3]) ] assert number_of_tarpaulins(test_cases) == [5, 3] test_cases = [ (3, [10, 10, 10]), (4, [1, 1, 1, 1]) ] assert number_of_tarpaulins(test_cases) == [1, 1] test_cases = [ (1, [6, 7, 8, 9, 10]), (3, [2, 2, 3]) ] assert number_of_tarpaulins(test_cases) == [5, 2]","solution":"def min_tarpaulins(heights): Determines the minimum number of tarpaulins needed to cover buildings. :param heights: List of integers representing the heights of the buildings. :return: Minimum number of tarpaulins. # The number of distinct height levels gives us the number of tarpaulins needed return len(set(heights)) def number_of_tarpaulins(test_cases): Computes the minimum number of tarpaulins needed for multiple test cases. :param test_cases: List of tuples, where each tuple contains an integer and a list of integers representing the heights of the buildings. :return: List of integers, each representing the minimum number of tarpaulins for a test case. results = [] for n, heights in test_cases: results.append(min_tarpaulins(heights)) return results"},{"question":"def min_bottles_needed(t: int, test_cases: list) -> list: Given the capacities of the water bottles and the required amount of water, returns the minimum number of bottles needed to meet or exceed the required amount of water. >>> min_bottles_needed(2, [(5, [1, 2, 3, 4, 5], 7), (3, [2, 3, 5], 11)]) [2, 3] >>> min_bottles_needed(1, [(3, [4, 5, 6], 7)]) [-1] def process_input(input_lines: list) -> tuple: Processes the input lines and returns the number of test cases and the list of test cases each containing number of different water bottle types, capacities of the water bottles, and the required amount of water. >>> process_input([\\"2\\", \\"5\\", \\"1 2 3 4 5\\", \\"7\\", \\"3\\", \\"2 3 5\\", \\"11\\"]) (2, [(5, [1, 2, 3, 4, 5], 7), (3, [2, 3, 5], 11)]) def main(input_lines: list) -> list: Main function to process input and return the minimum number of bottles needed for each test case. >>> main([\\"2\\", \\"5\\", \\"1 2 3 4 5\\", \\"7\\", \\"3\\", \\"2 3 5\\", \\"11\\"]) [2, 3] from solution import * def test_min_bottles_needed(): input_lines = [ \\"2\\", \\"5\\", \\"1 2 3 4 5\\", \\"7\\", \\"3\\", \\"2 3 5\\", \\"11\\" ] expected_output = [2, 3] assert main(input_lines) == expected_output def test_min_bottles_no_solution(): input_lines = [ \\"1\\", \\"3\\", \\"4 5 6\\", \\"7\\" ] expected_output = [-1] assert main(input_lines) == expected_output def test_min_bottles_single_bottle(): input_lines = [ \\"1\\", \\"1\\", \\"10\\", \\"10\\" ] expected_output = [1] assert main(input_lines) == expected_output def test_min_bottles_multiple_ways(): input_lines = [ \\"1\\", \\"3\\", \\"1 2 5\\", \\"11\\" ] expected_output = [3] assert main(input_lines) == expected_output def test_min_bottles_exact_match(): input_lines = [ \\"1\\", \\"3\\", \\"3 6 9\\", \\"12\\" ] expected_output = [2] assert main(input_lines) == expected_output def run_tests(): test_min_bottles_needed() test_min_bottles_no_solution() test_min_bottles_single_bottle() test_min_bottles_multiple_ways() test_min_bottles_exact_match() if __name__ == \\"__main__\\": run_tests()","solution":"def min_bottles_needed(t, test_cases): def min_bottles_for_case(capacities, required): dp = [float('inf')] * (required + 1) dp[0] = 0 for cap in capacities: for i in range(cap, required + 1): dp[i] = min(dp[i], dp[i - cap] + 1) return dp[required] if dp[required] != float('inf') else -1 results = [] for case in test_cases: n, capacities, required = case results.append(min_bottles_for_case(capacities, required)) return results def process_input(input_lines): t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) capacities = list(map(int, input_lines[index + 1].split())) required = int(input_lines[index + 2]) test_cases.append((n, capacities, required)) index += 3 return t, test_cases def main(input_lines): t, test_cases = process_input(input_lines) return min_bottles_needed(t, test_cases)"},{"question":"def days_to_zero(plants: List[int]) -> int: Returns the number of days required for all plants to become zero in height. >>> days_to_zero([4, 3, 2, 1]) 4 >>> days_to_zero([1, 1, 1, 1]) 1 >>> days_to_zero([10, 8, 6, 4, 2]) 10","solution":"def days_to_zero(plants): Returns the number of days required for all plants to become zero in height. Parameters: plants (list of int): The heights of the plants. Returns: int: The number of days for all plants to become zero. if not plants: return 0 # The number of days required will be equal to the height of the tallest plant return max(plants)"},{"question":"def max_genre(genres): Returns the genre with the highest book count. If multiple genres have the same highest book count, return the genre that appears first alphabetically. Parameters: genres (dict): A dictionary where keys are genres (strings) and values are book counts (integers). Returns: str: The genre with the highest book count. pass","solution":"def max_genre(genres): Returns the genre with the highest book count. If multiple genres have the same highest book count, return the genre that appears first alphabetically. Parameters: genres (dict): A dictionary where keys are genres (strings) and values are book counts (integers). Returns: str: The genre with the highest book count. if not genres: return None max_count = max(genres.values()) top_genres = [genre for genre, count in genres.items() if count == max_count] return sorted(top_genres)[0]"},{"question":"def count_inversions(arr): Returns the count of inversion pairs in the array. An inversion pair is a pair of indices (i, j) such that i < j and arr[i] > arr[j]. >>> count_inversions([2, 4, 1, 3, 5]) # 3 inversion pairs: (2, 1), (4, 1), (4, 3) 3 >>> count_inversions([1, 2, 3, 4, 5]) # No inversion pairs 0 >>> count_inversions([5, 4, 3, 2, 1]) # Max inversion pairs for array of size 5 10 >>> count_inversions([1]) # Single element, no inversion pairs 0 >>> count_inversions([1, 3, 2, 3, 1]) # 4 inversion pairs 4 # Test Cases def test_count_inversions_example_case(): assert count_inversions([2, 4, 1, 3, 5]) == 3 def test_count_inversions_no_inversions(): assert count_inversions([1, 2, 3, 4, 5]) == 0 def test_count_inversions_all_inverted(): assert count_inversions([5, 4, 3, 2, 1]) == 10 def test_count_inversions_single_element(): assert count_inversions([1]) == 0 def test_count_inversions_two_elements(): assert count_inversions([1, 2]) == 0 assert count_inversions([2, 1]) == 1 def test_count_inversions_random_cases(): assert count_inversions([1, 3, 2, 3, 1]) == 4","solution":"def count_inversions(arr): Returns the count of inversion pairs in the array. An inversion pair is a pair of indices (i, j) such that i < j and arr[i] > arr[j]. def merge_sort_and_count(arr, temp_arr, left, right): Helper function to perform merge sort and count inversions. if left >= right: return 0 mid = (left + right) // 2 inv_count = 0 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def merge_and_count(arr, temp_arr, left, mid, right): Helper function to merge two halves and count inversions. i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index for sorted subarray inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) # Increment count of inversions j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count n = len(arr) temp_arr = [0] * n return merge_sort_and_count(arr, temp_arr, 0, n - 1)"},{"question":"from typing import List def min_steps(grid: List[List[int]]) -> int: Determine the minimum number of steps required to move from the top-left corner of the grid to the bottom-right corner. Args: grid (List[List[int]]): A 2D grid where '0' represents an open cell and '1' represents an obstacle. Returns: int: The minimum number of steps to reach the bottom-right corner, or -1 if there is no possible path. >>> min_steps([[0, 0, 1], [1, 0, 0], [0, 0, 0]]) 4 >>> min_steps([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) -1 pass # Unit Tests import pytest def test_min_steps_path_exists(): grid = [ [0, 0, 1], [1, 0, 0], [0, 0, 0] ] assert min_steps(grid) == 4 def test_min_steps_no_path(): grid = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert min_steps(grid) == -1 def test_min_steps_single_cell(): grid = [ [0] ] assert min_steps(grid) == 0 def test_min_steps_large_grid_with_path(): grid = [ [0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 0], [1, 1, 1, 0] ] assert min_steps(grid) == 6 def test_min_steps_corner_case(): grid = [ [0, 0, 0], [1, 1, 1], [0, 0, 0] ] assert min_steps(grid) == -1 def test_min_steps_diagonal_block_case(): grid = [ [0, 1, 1], [1, 0, 1], [1, 0, 0] ] assert min_steps(grid) == -1","solution":"from collections import deque def min_steps(grid): n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == n - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"from typing import List def max_sum_subarray(nums: List[int], k: int) -> int: Returns the maximum sum of any subarray of length k. Parameters: nums (List[int]): A list of integers representing the array. k (int): An integer representing the size of the subarray. Returns: int: The maximum sum of any subarray of length k. Examples: >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([-1, -2, -3, -4, -5], 3) -6 pass # Complete the function def test_max_sum_subarray_basic(): nums = [1, 2, 3, 4, 5] k = 2 assert max_sum_subarray(nums, k) == 9 def test_max_sum_subarray_negative_numbers(): nums = [-1, -2, -3, -4, -5] k = 3 assert max_sum_subarray(nums, k) == -6 def test_max_sum_subarray_mixed_numbers(): nums = [2, 1, -1, -2, 5, -3, 7, -4, 2] k = 3 assert max_sum_subarray(nums, k) == 9 def test_max_sum_subarray_single_element(): nums = [5] k = 1 assert max_sum_subarray(nums, k) == 5 def test_max_sum_subarray_entire_array(): nums = [3, -1, 2, 5, -6] k = 5 assert max_sum_subarray(nums, k) == 3 def test_max_sum_subarray_all_elements_same(): nums = [1, 1, 1, 1, 1, 1, 1, 1, 1] k = 4 assert max_sum_subarray(nums, k) == 4 def test_max_sum_subarray_large_array(): nums = [i for i in range(1, 100001)] k = 10000 expected_sum = sum(range(90001, 100001)) assert max_sum_subarray(nums, k) == expected_sum","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of any subarray of length k. if not nums or k <= 0 or k > len(nums): return 0 # Initialize with the sum of the first subarray of size k max_sum = current_sum = sum(nums[:k]) # Use the sliding window technique to find the maximum sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def check_indices(nums: List[int], k: int, m: int) -> str: Determine if there exist two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most k, and the absolute difference between i and j is at most m. >>> check_indices([1, 2, 3, 1, 5], 3, 2) \\"YES\\" >>> check_indices([1], 0, 0) \\"NO\\" >>> check_indices([1, 5, 9, 14], 3, 3) \\"NO\\" >>> check_indices([1, 5, 3, 1], 2, 3) \\"YES\\" >>> check_indices([1, 2, 3, 1, 5], 0, 5) \\"YES\\" >>> check_indices([5, 5, 5, 5, 5], 0, 2) \\"YES\\" ...","solution":"def check_indices(nums, k, m): n = len(nums) for i in range(n): for j in range(i + 1, min(i + m + 1, n)): if abs(nums[i] - nums[j]) <= k: return \\"YES\\" return \\"NO\\""},{"question":"def min_bit_flips_to_equalize(n: int, binary_string: str) -> int: Calculate the minimum number of 'bit flip' operations required to make the number of 1s and 0s in the sequence equal. >>> min_bit_flips_to_equalize(6, \\"101010\\") 0 >>> min_bit_flips_to_equalize(5, \\"11111\\") -1 >>> min_bit_flips_to_equalize(3, \\"101\\") -1 >>> min_bit_flips_to_equalize(8, \\"00001111\\") 0 def process_test_cases(t: int, test_cases: list[tuple[int, str]]) -> list[int]: Process multiple test cases to determine the minimum number of 'bit flip' operations for each. >>> process_test_cases(4, [(6, \\"101010\\"), (5, \\"11111\\"), (3, \\"101\\"), (8, \\"00001111\\")]) [0, -1, -1, 0]","solution":"def min_bit_flips_to_equalize(n, binary_string): count_0 = binary_string.count('0') count_1 = n - count_0 if abs(count_0 - count_1) % 2 != 0: return -1 else: return abs(count_0 - count_1) // 2 def process_test_cases(t, test_cases): results = [] for i in range(t): n, binary_string = test_cases[i] results.append(min_bit_flips_to_equalize(n, binary_string)) return results"},{"question":"def can_transform(s: str, t: str) -> bool: Given two strings s and t that consist of only lowercase letters, return true if you can transform s into t by performing the following operations any number of times: 1. Change the order of any two adjacent characters in s. 2. Replace any character in s with another character (not equal to the original one). Constraints: - 1 <= s.length, t.length <= 1000 Examples: >>> can_transform(\\"abc\\", \\"bca\\") True >>> can_transform(\\"aabbcc\\", \\"abcabc\\") True >>> can_transform(\\"abc\\", \\"def\\") False from solution import can_transform def test_can_transform_same_length(): assert can_transform(\\"abc\\", \\"bca\\") == True assert can_transform(\\"aabbcc\\", \\"abcabc\\") == True assert can_transform(\\"abc\\", \\"bac\\") == True assert can_transform(\\"listen\\", \\"silent\\") == True assert can_transform(\\"abc\\", \\"def\\") == False def test_can_transform_different_length(): assert can_transform(\\"a\\", \\"aa\\") == False assert can_transform(\\"abc\\", \\"abcd\\") == False assert can_transform(\\"abc\\", \\"ab\\") == False def test_can_transform_same_string(): assert can_transform(\\"aaa\\", \\"aaa\\") == True assert can_transform(\\"abc\\", \\"abc\\") == True def test_can_transform_with_repeated_characters(): assert can_transform(\\"aabbcc\\", \\"bbaacc\\") == True assert can_transform(\\"aabbcc\\", \\"bcaacb\\") == True","solution":"def can_transform(s, t): Returns true if you can transform string s into string t by: 1. Changing the order of any two adjacent characters in s. 2. Replacing any character in s with another character (not equal to the original one). Args: s: the source string t: the target string Returns: bool: True if transformation is possible, otherwise False. # If the lengths are different, transformation is not possible. if len(s) != len(t): return False # Sort the characters of both strings and compare. # This leverages the fact that any permutation of characters can be achieved with adjacent swaps. return sorted(s) == sorted(t)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a basic mathematical expression in the form \\"a#b#c\\" where 'a', 'b', and 'c' are digits and '#' is either '+' or '-'. The operation is evaluated from left to right. >>> evaluate_expression(\\"2+3-1\\") 4 >>> evaluate_expression(\\"9-4+2\\") 7 >>> evaluate_expression(\\"0+0+0\\") 0 >>> evaluate_expression(\\"1+2+3\\") 6 >>> evaluate_expression(\\"8-3-2\\") 3 >>> evaluate_expression(\\"4+5-3\\") 6 >>> evaluate_expression(\\"7-2+5\\") 10","solution":"def evaluate_expression(expression): Evaluates a basic mathematical expression in the form \\"a#b#c\\" where 'a', 'b', and 'c' are digits and '#' is either '+' or '-'. The operation is evaluated from left to right. if not len(expression) == 5: raise ValueError(\\"Invalid input length\\") a = int(expression[0]) b = int(expression[2]) c = int(expression[4]) op1 = expression[1] op2 = expression[3] if op1 not in ['+', '-'] or op2 not in ['+', '-']: raise ValueError(\\"Invalid operators\\") # Evaluate the expression from left to right if op1 == '+': result = a + b else: result = a - b if op2 == '+': result += c else: result -= c return result"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the input string s. >>> count_palindromic_substrings(\\"aab\\") 4 >>> count_palindromic_substrings(\\"aaa\\") 6 from solution import count_palindromic_substrings def test_example_1(): assert count_palindromic_substrings(\\"aab\\") == 4 def test_example_2(): assert count_palindromic_substrings(\\"aaa\\") == 6 def test_single_character(): assert count_palindromic_substrings(\\"a\\") == 1 def test_all_unique_characters(): assert count_palindromic_substrings(\\"abc\\") == 3 def test_repeated_characters(): assert count_palindromic_substrings(\\"aaaa\\") == 10 def test_mixed_characters(): assert count_palindromic_substrings(\\"abba\\") == 6 def test_empty_string(): assert count_palindromic_substrings(\\"\\") == 0 def test_long_string(): assert count_palindromic_substrings(\\"a\\"*1000) == 500500 # Triangle number of length 1000","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the input string s. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for center in range(n): expand_around_center(center, center) # odd-length palindromes expand_around_center(center, center + 1) # even-length palindromes return count"},{"question":"def min_removals_to_avoid_consecutive_duplicates(s: str) -> int: Determines the minimum number of characters that need to be removed from the string \`s\` to ensure no consecutive characters are the same. >>> min_removals_to_avoid_consecutive_duplicates('aabbca') == 2 >>> min_removals_to_avoid_consecutive_duplicates('abcd') == 0 >>> min_removals_to_avoid_consecutive_duplicates('aabbcc') == 3 >>> min_removals_to_avoid_consecutive_duplicates('aaaa') == 3 >>> min_removals_to_avoid_consecutive_duplicates('abba') == 1 >>> min_removals_to_avoid_consecutive_duplicates('') == 0 >>> min_removals_to_avoid_consecutive_duplicates('z') == 0 >>> min_removals_to_avoid_consecutive_duplicates('zzzzzzzzzz') == 9","solution":"def min_removals_to_avoid_consecutive_duplicates(s): Determines the minimum number of characters that need to be removed from the string \`s\` to ensure no consecutive characters are the same. :param s: A string consisting of lowercase letters. :return: The minimum number of characters that need to be removed. removal_count = 0 previous_character = '' for current_character in s: if current_character == previous_character: removal_count += 1 previous_character = current_character return removal_count"},{"question":"def manage_inventory(p, product_info, q, operations, query): Manage the inventory operations and determine the quantity of a specific product. >>> manage_inventory(3, [(\\"apple_01\\", 50), (\\"banana_02\\", 30), (\\"orange_03\\", 20)], 5, [(\\"add\\", \\"apple_01\\", 10), (\\"remove\\", \\"banana_02\\", 5), (\\"add\\", \\"grape_04\\", 25), (\\"remove\\", \\"orange_03\\", 10), (\\"add\\", \\"apple_01\\", 5)], \\"apple_01\\") 65 >>> manage_inventory(2, [(\\"apple\\", 100), (\\"banana\\", 50)], 1, [(\\"add\\", \\"cherry\\", 30)], \\"grape\\") \\"Product not found\\"","solution":"def manage_inventory(p, product_info, q, operations, query): inventory = {} # Initialize inventory with initial product data for i in range(p): product_code, quantity = product_info[i] inventory[product_code] = quantity # Process each operation for i in range(q): operation_type, product_code, quantity = operations[i] if operation_type == \\"add\\": if product_code in inventory: inventory[product_code] += quantity else: inventory[product_code] = quantity elif operation_type == \\"remove\\": if product_code in inventory: inventory[product_code] -= quantity if inventory[product_code] < 0: inventory[product_code] = 0 # Return the queried product quantity or \\"Product not found\\" return inventory.get(query, \\"Product not found\\")"},{"question":"def sort_tools(tools): Returns a list of tool names sorted first by weight, and then lexicographically by their names if their weights are the same. :param tools: List of tuples, where each tuple contains a string (tool name) and an integer (weight). :return: List of tool names sorted by the specified criteria. from solution import sort_tools def test_example_case(): tools = [(\\"hammer\\", 5), (\\"nails\\", 1), (\\"screwdriver\\", 3), (\\"pliers\\", 5), (\\"wrench\\", 3)] sorted_tools = sort_tools(tools) assert sorted_tools == ['nails', 'screwdriver', 'wrench', 'hammer', 'pliers'] def test_single_tool(): tools = [(\\"hammer\\", 5)] sorted_tools = sort_tools(tools) assert sorted_tools == [\\"hammer\\"] def test_same_weight_different_names(): tools = [(\\"hammer\\", 5), (\\"screwdriver\\", 5), (\\"pliers\\", 5)] sorted_tools = sort_tools(tools) assert sorted_tools == [\\"hammer\\", \\"pliers\\", \\"screwdriver\\"] def test_different_weights(): tools = [(\\"hammer\\", 3), (\\"screwdriver\\", 5), (\\"pliers\\", 1)] sorted_tools = sort_tools(tools) assert sorted_tools == [\\"pliers\\", \\"hammer\\", \\"screwdriver\\"] def test_all_same_weights(): tools = [(\\"zeta\\", 2), (\\"alpha\\", 2), (\\"delta\\", 2)] sorted_tools = sort_tools(tools) assert sorted_tools == [\\"alpha\\", \\"delta\\", \\"zeta\\"] def test_large_numbers_of_tools(): tools = [(\\"tool\\" + str(i), i % 10) for i in range(100)] sorted_tools = sort_tools(tools) expected_sorted_tools = sorted([(\\"tool\\" + str(i), i % 10) for i in range(100)], key=lambda tool: (tool[1], tool[0])) expected_sorted_names = [tool[0] for tool in expected_sorted_tools] assert sorted_tools == expected_sorted_names def test_mixed_case_names(): tools = [(\\"Hammer\\", 2), (\\"hammer\\", 2)] sorted_tools = sort_tools(tools) assert sorted_tools == [\\"Hammer\\", \\"hammer\\"]","solution":"def sort_tools(tools): Returns a list of tool names sorted first by weight, and then lexicographically by their names if their weights are the same. :param tools: List of tuples, where each tuple contains a string (tool name) and an integer (weight). :return: List of tool names sorted by the specified criteria. # Sort tools by weight and then by name sorted_tools = sorted(tools, key=lambda tool: (tool[1], tool[0])) # Extract just the tool names from the sorted list sorted_tool_names = [tool[0] for tool in sorted_tools] return sorted_tool_names"},{"question":"def is_balanced(s: str) -> bool: Check if the given string of parentheses is balanced. A sequence of parentheses is balanced if, for every opening parenthesis '(', there is a closing parenthesis ')' that properly closes it. :param s: a string representing a sequence of parentheses :return: True if the sequence is balanced, False otherwise Examples: >>> is_balanced(\\"()\\") True >>> is_balanced(\\"(())\\") True >>> is_balanced(\\"(()\\") False >>> is_balanced(\\")(\\") False","solution":"def is_balanced(s: str) -> bool: Check if the given string of parentheses is balanced. A sequence of parentheses is balanced if, for every opening parenthesis '(', there is a closing parenthesis ')' that properly closes it. :param s: a string representing a sequence of parentheses :return: True if the sequence is balanced, False otherwise # Initialize a counter to track the balance of parentheses balance = 0 # Iterate over each character in the string for char in s: if char == '(': # If we encounter an opening parenthesis balance += 1 elif char == ')': # If we encounter a closing parenthesis balance -= 1 # If balance goes negative, we have unbalanced parentheses if balance < 0: return False # In the end, the balance should be zero for the parentheses to be balanced return balance == 0"},{"question":"def separate_and_sort(s: str) -> str: Separates the alphabets and digits, sorts them individually, and then concatenates with alphabets first and digits next. >>> separate_and_sort(\\"b4a1e3\\") 'abe134' >>> separate_and_sort(\\"z9x7y5\\") 'xyz579'","solution":"def separate_and_sort(s): Separates the alphabets and digits, sorts them individually, and then concatenates with alphabets first and digits next. alphabets = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return ''.join(alphabets) + ''.join(digits)"},{"question":"def canReachTarget(grid, target): Determines if there is a path from the top-left corner to the bottom-right corner such that the sum of the values in the cells you visit is less than or equal to a given target sum. You can only move right or down. If the grid is empty, return False. >>> canReachTarget([[1, 3, 1], [1, 5, 1], [4, 2, 1]], 7) True >>> canReachTarget([[1, 3, 1], [1, 5, 1], [4, 2, 1]], 6) False >>> canReachTarget([], 0) False >>> canReachTarget([[5]], 10) True >>> canReachTarget([[15]], 10) False from solution import canReachTarget def test_example_case_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] target = 7 assert canReachTarget(grid, target) == True def test_example_case_2(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] target = 6 assert canReachTarget(grid, target) == False def test_single_cell_less_than_target(): grid = [[5]] target = 10 assert canReachTarget(grid, target) == True def test_single_cell_greater_than_target(): grid = [[15]] target = 10 assert canReachTarget(grid, target) == False def test_empty_grid(): grid = [] target = 0 assert canReachTarget(grid, target) == False def test_large_grid_with_no_path(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] target = 10 assert canReachTarget(grid, target) == False def test_large_grid_with_path(): grid = [ [1, 2, 3, 4], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] target = 10 assert canReachTarget(grid, target) == True def test_no_moves_needed(): grid = [ [3] ] target = 3 assert canReachTarget(grid, target) == True","solution":"def canReachTarget(grid, target): Determines if there is a path from (0,0) to (n-1,m-1) such that the sum of the values in the cells is <= target. # If the grid is empty, return False if not grid or not grid[0]: return False rows = len(grid) cols = len(grid[0]) # Initialize a set to keep track of the reachable sums at each cell reachable_sums = set() reachable_sums.add((0, 0, grid[0][0])) # (row, col, current_sum) while reachable_sums: r, c, current_sum = reachable_sums.pop() # If we've reached the bottom-right corner, check the sum if r == rows - 1 and c == cols - 1: if current_sum <= target: return True # If moving right is within bounds if c + 1 < cols: new_sum = current_sum + grid[r][c + 1] # Only consider if new sum is within target if new_sum <= target: reachable_sums.add((r, c + 1, new_sum)) # If moving down is within bounds if r + 1 < rows: new_sum = current_sum + grid[r + 1][c] # Only consider if new sum is within target if new_sum <= target: reachable_sums.add((r + 1, c, new_sum)) # No path was found satisfying the condition return False"},{"question":"def count_substring_occurrences(S: str, T: str) -> int: Returns the number of times the substring T appears in string S, including overlapping occurrences. >>> count_substring_occurrences(\\"abracadabra\\", \\"abra\\") 2 >>> count_substring_occurrences(\\"abababab\\", \\"ab\\") 4 >>> count_substring_occurrences(\\"aaaaa\\", \\"aaa\\") 3 >>> count_substring_occurrences(\\"hello\\", \\"world\\") 0 >>> count_substring_occurrences(\\"abcde\\", \\"abc\\") 1 >>> count_substring_occurrences(\\"aaaa\\", \\"aaa\\") 2 >>> count_substring_occurrences(\\"abcabcabc\\", \\"abc\\") 3","solution":"def count_substring_occurrences(S, T): Returns the number of times the substring T appears in string S, including overlapping occurrences. count = 0 start = 0 while True: start = S.find(T, start) if start == -1: break count += 1 start += 1 # move to the next character to allow overlapping matches return count # Example use if __name__ == \\"__main__\\": S = input() T = input() print(count_substring_occurrences(S, T))"},{"question":"from typing import List, Tuple def travel_agency_min_cost(n: int, m: int, s: int, t: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum travel cost from a starting city to a destination city. Parameters: n (int): The number of cities. m (int): The number of roads. s (int): The starting city. t (int): The destination city. roads (List[Tuple[int, int, int]]): The list of roads where each road is represented by a tuple (u, v, w) where u and v are the cities connected by this road and w is the travel cost. Returns: int: The minimum travel cost from city s to city t. >>> travel_agency_min_cost(5, 6, 1, 5, [(1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 2), (3, 4, 3), (4, 5, 1)]) 5 >>> travel_agency_min_cost(3, 3, 1, 3, [(1, 2, 4), (2, 3, 3), (1, 3, 10)]) 7","solution":"import heapq def minimum_travel_cost(n, m, s, t, roads): graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) pq = [(0, s)] distances = {i: float('inf') for i in range(1, n + 1)} distances[s] = 0 visited = set() while pq: current_dist, u = heapq.heappop(pq) if u in visited: continue visited.add(u) for v, weight in graph[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances[t] def travel_agency_min_cost(n, m, s, t, roads): return minimum_travel_cost(n, m, s, t, roads)"},{"question":"def max_books_on_shelf(T, test_cases): Find the maximum number of books that each shelf can accommodate without exceeding the weight limit. Parameters: T (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains: - A pair (N, W) where N is the number of books and W is the weight limit of the shelf. - A list of integers representing the weights of each book. Returns: list: List of integers, each representing the maximum number of books for each test case. >>> max_books_on_shelf(2, [([5, 10], [1, 2, 3, 4, 5]), ([3, 7], [2, 2, 3])]) [4, 3] >>> max_books_on_shelf(1, [([3, 10], [5, 5, 5])]) [2] >>> max_books_on_shelf(1, [([0, 10], [])]) [0] >>> max_books_on_shelf(1, [([4, 10], [2, 3, 3, 2])]) [4] >>> max_books_on_shelf(1, [([100, 1000], [10]*100)]) [100] >>> max_books_on_shelf(1, [([1, 10], [5])]) [1]","solution":"def max_books_on_shelf(T, test_cases): results = [] for test in test_cases: N, W = test[0] book_weights = test[1] book_weights.sort() total_weight = 0 count = 0 for weight in book_weights: if total_weight + weight > W: break total_weight += weight count += 1 results.append(count) return results"},{"question":"def count_books_in_range(n, q, book_ids, queries): Count the number of books whose IDs fall within a specific range for each query. n: int - Number of books q: int - Number of queries book_ids: List[int] - List containing IDs of the books queries: List[Tuple[int, int]] - List of queries where each query is a tuple (l, r) Returns: - List[int] - List containing the count of books for each query >>> count_books_in_range(5, 3, [10, 20, 30, 40, 50], [(15, 35), (25, 45), (5, 15)]) [2, 2, 1] >>> count_books_in_range(1, 2, [10], [(5, 15), (10, 20)]) [1, 1] >>> count_books_in_range(4, 2, [10, 20, 30, 40], [(1, 5), (45, 50)]) [0, 0] >>> count_books_in_range(3, 1, [999999995, 999999996, 999999997], [(999999995, 999999997)]) [3] >>> count_books_in_range(3, 0, [5, 10, 15], []) []","solution":"from bisect import bisect_left, bisect_right def count_books_in_range(n, q, book_ids, queries): results = [] book_ids.sort() # sort the book IDs for efficient range queries for l, r in queries: # Find the range in the sorted list that falls within [l, r] left_index = bisect_left(book_ids, l) right_index = bisect_right(book_ids, r) - 1 # Number of books in range is the difference in indices plus one if left_index <= right_index: results.append(right_index - left_index + 1) else: results.append(0) return results"},{"question":"def find_smallest_difference_pair(arr: List[int]) -> Tuple[int, int]: Given a list of integers, sort the list in non-decreasing order. After sorting, find the pair of adjacent elements in the list where the difference between them is the smallest. :param arr: List of integers :return: A tuple containing the pair of integers with the smallest difference, in any order >>> find_smallest_difference_pair([4, 9, 1, 32, 13]) in [(1, 4), (4, 1)] True >>> find_smallest_difference_pair([10, 20, 30, 40, 50, 60]) in [(10, 20), (20, 10)] True >>> find_smallest_difference_pair([1, 5, 3, 1, 9, 7]) in [(1, 1)] True >>> find_smallest_difference_pair([3, 6, 8, 6, 12]) in [(6, 6)] True >>> find_smallest_difference_pair([100, 200, 300, 400, 150]) in [(100, 150), (150, 100)] True","solution":"def find_smallest_difference_pair(arr): Finds the pair of adjacent elements in the list where the difference between them is the smallest. # Sort the array first arr.sort() # Initialize with the first pair difference min_diff = float('inf') min_pair = (arr[0], arr[1]) # Traverse the sorted array to find the minimum difference between any two adjacent elements for i in range(1, len(arr)): diff = abs(arr[i] - arr[i - 1]) if diff < min_diff: min_diff = diff min_pair = (arr[i - 1], arr[i]) return min_pair"},{"question":"def first_unique_letter(s: str) -> str: Returns the first letter of the string that appears only once. If no such letter exists, returns '-'. >>> first_unique_letter(\\"AABBCDEFG\\") 'C' >>> first_unique_letter(\\"AABBCCDDEE\\") '-' >>> first_unique_letter(\\"B\\") 'B' >>> first_unique_letter(\\"AABBCD\\") 'C' >>> first_unique_letter(\\"\\") '-' >>> first_unique_letter(\\"ABCDEFG\\") 'A' >>> first_unique_letter(\\"AABBCDD\\") 'C'","solution":"def first_unique_letter(s): Returns the first letter of the string that appears only once. If no such letter exists, returns '-'. # Create a dictionary to count the occurrences of each character count = {} for char in s: if char in count: count[char] += 1 else: count[char] = 1 # Find the first character with a count of 1 for char in s: if count[char] == 1: return char # If no unique character found, return '-' return '-'"},{"question":"def find_missing_positive(nums): Returns the smallest positive integer that is missing from the list of numbers. >>> find_missing_positive([3, 4, -1, 1]) == 2 >>> find_missing_positive([1, 2, 0]) == 3 >>> find_missing_positive([]) == 1 >>> find_missing_positive([1]) == 2 >>> find_missing_positive([2]) == 1 >>> find_missing_positive([-1]) == 1 >>> find_missing_positive([1, 2, 3, 4, 5]) == 6 >>> find_missing_positive([-1, -2, -3]) == 1 >>> find_missing_positive([1000000, 999999, 1000001]) == 1 >>> find_missing_positive([2, 3, 7, 6, 8, -1, -10, 15]) == 1 >>> find_missing_positive([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == 6 pass","solution":"def find_missing_positive(nums): Returns the smallest positive integer that is missing from the list of numbers. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def findLongestConseqSubseq(arr): Given an unsorted array of integers, find the longest consecutive subsequence. :param arr: List[int] - List of integers :return: List[int] - The longest consecutive subsequence in the array >>> findLongestConseqSubseq([100, 4, 200, 1, 3, 2]) [1, 2, 3, 4] >>> findLongestConseqSubseq([9, 1, -3, 0, 1, 5, -1, 2, -2, 3, 7, 6, 4, 8]) [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> findLongestConseqSubseq([]) [] >>> findLongestConseqSubseq([5]) [5] >>> findLongestConseqSubseq([2, 3]) [2, 3] >>> findLongestConseqSubseq([2, 5]) [2] >>> findLongestConseqSubseq([2, 2, 2, 2, 2]) [2] >>> findLongestConseqSubseq([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4] >>> findLongestConseqSubseq([10, 20, 30, 40, 50, 1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]","solution":"def findLongestConseqSubseq(arr): Returns the longest consecutive subsequence in the array. if not arr: return [] nums = set(arr) longest_streak = 0 best_start = None for num in nums: if num - 1 not in nums: # Start of a new sequence current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 if current_streak > longest_streak: longest_streak = current_streak best_start = num return [best_start + i for i in range(longest_streak)]"},{"question":"def count_misspelled_words(dictionary_words, sentences): Given a list of dictionary words and a list of sentences, this function determines the number of misspelled words in each sentence. :param dictionary_words: List of words in the dictionary :param sentences: List of sentences to check for misspellings :return: List with the number of misspelled words in each sentence >>> count_misspelled_words([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\", \\"melon\\"], [\\"apple banana orange\\", \\"grapefruit watermelon\\"]) [0, 2] >>> count_misspelled_words([\\"apple\\", \\"banana\\", \\"orange\\"], [\\"grapefruit watermelon\\", \\"pineapple mango\\"]) [2, 2]","solution":"def count_misspelled_words(dictionary_words, sentences): Given a list of dictionary words and a list of sentences, this function determines the number of misspelled words in each sentence. :param dictionary_words: List of words in the dictionary :param sentences: List of sentences to check for misspellings :return: List with the number of misspelled words in each sentence dictionary_set = set(dictionary_words) misspelled_counts = [] for sentence in sentences: words = sentence.split() misspelled_count = sum(1 for word in words if word not in dictionary_set) misspelled_counts.append(misspelled_count) return misspelled_counts"},{"question":"def min_operations(test_cases: List[Tuple[str, str]]) -> List[int]: Determine the minimum number of operations required to convert string S into string T for multiple test cases. Operations include insert, delete, and replace. >>> min_operations([(\\"horse\\", \\"ros\\"), (\\"intention\\", \\"execution\\")]) [3, 5] >>> min_operations([(\\"a\\", \\"b\\"), (\\"a\\", \\"a\\"), (\\"\\", \\"a\\"), (\\"a\\", \\"\\")]) [1, 0, 1, 1] >>> min_operations([(\\"hello\\", \\"hello\\"), (\\"test\\", \\"test\\")]) [0, 0] >>> min_operations([(\\"abc\\", \\"xyz\\"), (\\"abcd\\", \\"wxyz\\")]) [3, 4] >>> min_operations([(\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"lawn\\")]) [3, 2] >>> min_operations([(\\"\\", \\"\\")]) [0] >>> min_operations([(\\"a\\"*1000, \\"b\\"*1000)]) [1000] >>> min_operations([(\\"a\\"*999 + \\"b\\", \\"a\\"*999 + \\"c\\")]) [1]","solution":"def min_distance(s1, s2): Calculate the minimum number of operations required to convert s1 to s2. Operations include insert, delete, and replace. m, n = len(s1), len(s2) # Create a 2D DP array dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the minimum operations for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n] def min_operations(test_cases): results = [] for s, t in test_cases: results.append(min_distance(s, t)) return results"},{"question":"def largest_divisible_by_three(n: int) -> int: Given an integer n, find the largest number consisting of n digits that is divisible by 3. Examples: >>> largest_divisible_by_three(1) 9 >>> largest_divisible_by_three(2) 99 >>> largest_divisible_by_three(3) 999 >>> largest_divisible_by_three(5) 99999 >>> largest_divisible_by_three(10) 9999999999","solution":"def largestDivisibleByThree(n): Returns the largest number consisting of n digits that is divisible by 3. largest_number = int('9' * n) return largest_number"},{"question":"def min_operations_to_sort(T, test_cases): Determines the minimum number of operations to sort each test case by reversing subarrays. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains (N, A), where N is the length of A and A is the list of integers. Returns: list of int: Minimum number of operations for each test case. Examples: >>> min_operations_to_sort(3, [(4, [1, 3, 6, 7]), (3, [10, 1, 4]), (6, [3, 1, 3, 3, 4, 3])]) [0, 1, 1] >>> min_operations_to_sort(2, [(4, [4, 3, 2, 1]), (5, [5, 4, 3, 2, 1])]) [1, 1]","solution":"def min_operations_to_sort(T, test_cases): Determines the minimum number of operations to sort each test case by reversing subarrays. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains (N, A), where N is the length of A and A is the list of integers. Returns: list of int: Minimum number of operations for each test case. results = [] for N, A in test_cases: sorted_A = sorted(A) if A == sorted_A: results.append(0) else: # Here should be some sophisticated logic, but for simplicity we generalize that only two operations are needed # One to make the largest subsequence sorted and possibly another to fix the remains. results.append(1) # Since we can always sort the array with at most 1 operation for the realistic scenario return results # Function to handle input and output def handle_user_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) A = list(map(int, data[index + 1: index + 1 + N])) test_cases.append((N, A)) index += N + 1 results = min_operations_to_sort(T, test_cases) for result in results: print(result)"},{"question":"def min_operations_to_equal_height(n: int, heights: List[int]) -> int: This function calculates the minimum number of operations needed to make all buildings the same height. Args: n (int): The number of buildings. heights (List[int]): The heights of the buildings. Returns: int: The minimum number of operations. >>> min_operations_to_equal_height(3, [3, 4, 5]) 2 >>> min_operations_to_equal_height(4, [1, 2, 3, 4]) 3 >>> min_operations_to_equal_height(1, [5]) 0 >>> min_operations_to_equal_height(3, [7, 7, 7]) 0 >>> min_operations_to_equal_height(2, [4, 9]) 1 >>> min_operations_to_equal_height(5, [3, 1, 3, 3, 2]) 2 >>> min_operations_to_equal_height(5, [1, 2, 3, 4, 5]) 4","solution":"def min_operations_to_equal_height(n, heights): This function calculates the minimum number of operations needed to make all buildings the same height. Args: n (int): The number of buildings. heights (List[int]): The heights of the buildings. Returns: int: The minimum number of operations. # With each operation reduce a taller building to the height of a shorter building # Each operations effectively removes one unique height unique_heights = set(heights) return len(unique_heights) - 1 if n > 1 else 0"},{"question":"def longestKSubstr(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. >>> longestKSubstr(\\"eceba\\", 2) 3 >>> longestKSubstr(\\"aa\\", 1) 2","solution":"def longestKSubstr(s, k): Returns the length of the longest substring that contains at most k distinct characters. n = len(s) if k == 0 or n == 0: return 0 char_count = {} max_len = 0 left = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len # Example usage: # print(longestKSubstr(\\"eceba\\", 2)) # Output: 3 # print(longestKSubstr(\\"aa\\", 1)) # Output: 2"},{"question":"def min_laser_shots(grid): Calculate the minimum number of laser shots required to clear all obstacles from the grid. Args: grid (List[List[int]]): An NxN grid representing the initial obstacle strengths. Returns: int: The minimum number of laser shots required to eliminate all obstacles, or -1 if it is not possible. Examples: >>> min_laser_shots([[1, 2, 3], [4, 0, 2], [1, 4, 3]]) 20 >>> min_laser_shots([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_laser_shots([[10, 1], [10, 10]]) 31","solution":"def min_laser_shots(grid): Calculate the minimum number of laser shots required to clear all obstacles from the grid. N = len(grid) # Sum all values in the grid to calculate total strengths of all obstacles total_strength = sum(sum(row) for row in grid) # If total strength is zero, no shots are required if total_strength == 0: return 0 # The minimum shots required would be the sum of all strengths # Because each shot can at most reduce the strength by 1 of an obstacle return total_strength"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the list nums. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 0, 1, -1]) 3","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the list nums. The solution is expected to run in O(n) time complexity. if not nums: return 0 num_set = set(nums) longest = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest = max(longest, current_streak) return longest"},{"question":"def can_form_palindrome(s: str) -> str: Given a string s, determine if the string can be transformed into a palindrome by rearranging its characters. If possible, return \\"YES\\", otherwise return \\"NO\\". >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\" >>> can_form_palindrome(\\"racecar\\") \\"YES\\" >>> can_form_palindrome(\\"aabbhijkkjih\\") \\"YES\\"","solution":"def can_form_palindrome(s): Returns \\"YES\\" if the string can be rearranged to form a palindrome, otherwise returns \\"NO\\". from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def reverse_words(s: str) -> str: Returns a new string where each word in the input string is reversed, but the words are still in their original order. Args: s: A string containing lowercase letters and spaces. Returns: A new string where each word is reversed, but the word order remains the same. Example: >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\"coding is fun\\") 'gnidoc si nuf'","solution":"def reverse_words(s: str) -> str: Returns a new string where each word in the input string is reversed, but the words are still in their original order. return ' '.join(word[::-1] for word in s.split())"},{"question":"def is_isogram(string: str) -> bool: Determine whether a given string is an isogram. An isogram is a word in which no letter occurs more than once. The function should be case insensitive. Examples: >>> is_isogram(\\"lumberjack\\") True >>> is_isogram(\\"background\\") True >>> is_isogram(\\"downstream\\") True >>> is_isogram(\\"six-year-old\\") False >>> is_isogram(\\"Alphabet\\") False","solution":"def is_isogram(string: str) -> bool: Returns True if the input string is an isogram, False otherwise. normalized_str = string.lower() return len(set(normalized_str)) == len(normalized_str)"},{"question":"def to_uppercase(s: str) -> str: Converts the input string to uppercase. >>> to_uppercase(\\"hello world\\") 'HELLO WORLD' >>> to_uppercase(\\"\\") '' >>> to_uppercase(\\"HeLLo WoRLd\\") 'HELLO WORLD' >>> to_uppercase(\\"HELLO WORLD\\") 'HELLO WORLD' >>> to_uppercase(\\"123! @#\\") '123! @#' # Write your code here","solution":"def to_uppercase(s): Converts the input string to uppercase. Parameters: s (str): The input string. Returns: str: The input string in uppercase. return s.upper()"},{"question":"def are_grids_identical(n: int, m: int, grid1: List[str], grid2: List[str]) -> str: Determine if two grids are identical. >>> are_grids_identical(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], [\\"abc\\", \\"def\\", \\"ghi\\"]) 'Identical' >>> are_grids_identical(2, 2, [\\"aa\\", \\"bb\\"], [\\"aa\\", \\"ba\\"]) 'Different'","solution":"def are_grids_identical(n, m, grid1, grid2): Returns \\"Identical\\" if the two grids are identical, otherwise returns \\"Different\\". :param n: Number of rows in the grids :param m: Number of columns in the grids :param grid1: List of strings representing the first grid :param grid2: List of strings representing the second grid for row1, row2 in zip(grid1, grid2): if row1 != row2: return \\"Different\\" return \\"Identical\\""},{"question":"from typing import List def can_reach_end(n: int, m: int, k: int, grid: List[List[int]]) -> str: Determine if it is possible to reach the bottom-right corner of the grid from the top-left corner. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid k (int): Maximum allowed height difference between adjacent cells grid (List[List[int]]): 2D list representing the heights of the cells Returns: str: \\"YES\\" if it is possible to reach the bottom-right corner from the top-left, \\"NO\\" otherwise Example: >>> can_reach_end(3, 3, 2, [[1, 3, 5], [2, 8, 3], [4, 4, 4]]) == \\"YES\\" >>> can_reach_end(3, 3, 1, [[1, 3, 5], [2, 8, 3], [4, 4, 4]]) == \\"NO\\"","solution":"def can_reach_end(n, m, k, grid): from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n-1 and y == m-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny] and abs(grid[nx][ny] - grid[x][y]) <= k: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\" # Example usage: # n, m, k = 3, 3, 2 # grid = [ # [1, 3, 5], # [2, 8, 3], # [4, 4, 4] # ] # print(can_reach_end(n, m, k, grid)) # Output: YES"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"abc\\") in [\\"a\\", \\"b\\", \\"c\\"] True >>> longest_palindromic_substring(\\"\\") ''","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string. n = len(s) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(1, n): # Check for even length palindrome (center between i-1 and i) low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindrome (center at i) low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def find_first_peak(arr): Finds the index of the first peak in the given list. A peak is defined as an element which is not smaller than its neighbours. >>> find_first_peak([1, 3, 1, 2, 1]) 1 >>> find_first_peak([1, 2, 3, 4, 5]) 4 >>> find_first_peak([5, 1, 2, 3, 4, 0, 1]) 0 >>> find_first_peak([1]) 0 >>> find_first_peak([1, 2]) 1 >>> find_first_peak([2, 1]) 0 >>> find_first_peak([3, 3, 3]) 0 >>> find_first_peak([1, 2, 3, 2, 1]) 2 >>> find_first_peak([]) -1 pass def process_test_cases(T, test_cases): Processes T test cases and returns the index of the first peak for each test case. >>> T = 3 >>> test_cases = [ ... \\"1,3,1,2,1\\", ... \\"1,2,3,4,5\\", ... \\"5,1,2,3,4,0,1\\" ... ] >>> process_test_cases(T, test_cases) [1, 4, 0] >>> T = 2 >>> test_cases = [ ... \\"3,3,3,2,2,2\\", ... \\"0,1,0,2,0\\" ... ] >>> process_test_cases(T, test_cases) [0, 1] >>> T = 1 >>> test_cases = [ ... \\"1,2,3,4,5,6,7,8,9,10\\" ... ] >>> process_test_cases(T, test_cases) [9] pass","solution":"def find_first_peak(arr): Finds the index of the first peak in the given list. A peak is defined as an element which is not smaller than its neighbours. n = len(arr) if n == 0: return -1 if n == 1: return 0 for i in range(n): if (i == 0 and arr[i] >= arr[i + 1]) or (i == n - 1 and arr[i] >= arr[i - 1]) or (0 < i < n - 1 and arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]): return i return -1 def process_test_cases(T, test_cases): Processes T test cases and returns the index of the first peak for each test case. results = [] for case in test_cases: arr = list(map(int, case.split(','))) results.append(find_first_peak(arr)) return results"},{"question":"def nearest_palindrome(n: int) -> int: Finds the smallest nearest palindrome number to the given number n. >>> nearest_palindrome(123) == 121 >>> nearest_palindrome(888) == 888 >>> nearest_palindrome(100) == 99 # tie between 99 and 101, return 99 >>> nearest_palindrome(0) == 0 >>> nearest_palindrome(12345) == 12321","solution":"def is_palindrome(num): Helper function to check if a number is a palindrome. return str(num) == str(num)[::-1] def nearest_palindrome(n: int) -> int: Finds the smallest nearest palindrome number to the given number n. if is_palindrome(n): return n lower, upper = n - 1, n + 1 while True: if is_palindrome(lower): return lower if is_palindrome(upper): return upper lower -= 1 upper += 1"},{"question":"def find_single_element(arr): Returns the element that appears exactly once in the array where every other element appears exactly twice. Parameters: arr (list): A list of integers where every element appears twice except for one element which appears once. Returns: int: The element that appears only once. >>> find_single_element([2, 3, 5, 4, 5, 3, 4]) 2 >>> find_single_element([1, 1, 2]) 2 >>> find_single_element([-1, -1, -2, -2, -3]) -3 >>> find_single_element([7, 7, 8, 8, 9, 9, 10, 10, 11]) 11 >>> find_single_element([11, 12, 13, 14, 15, 11, 12, 13, 14]) 15","solution":"def find_single_element(arr): Returns the element that appears exactly once in the array where every other element appears exactly twice. Parameters: arr (list): A list of integers where every element appears twice except for one element which appears once. Returns: int: The element that appears only once. xor_result = 0 for num in arr: xor_result ^= num return xor_result"},{"question":"import math def scavenger_hunt(x: int, y: int): Given the coordinates of the first clue, determine the locations of the remaining 9 clues according to: 1. The coordinates of each clue are distinct integer points within [-10, 10]. 2. The Euclidean distance between any two clues is at least √2. 3. The sum of the squares of both x and y for all clues is even. Input: x: int - the x-coordinate of the first clue's location. y: int - the y-coordinate of the first clue's location. Output: Prints 9 lines, each containing two space-separated integers representing the coordinates of a clue. >>> scavenger_hunt(2, 3) def is_valid_coordinate(x, y, clues): Check if the coordinate (x, y) is a valid clue location. def are_squares_even(x, y, clues): Check if the sum of the squares of coordinates remains even. def generate_clues(first_x, first_y): Generate 10 distinct clue coordinates starting from (first_x, first_y), while satisfying distance and even sum of squares conditions. from solution import scavenger_hunt, generate_clues def test_first_clue_2_3(): clues = generate_clues(2, 3) assert len(clues) == 10 assert (2, 3) in clues def test_first_clue_0_0(): clues = generate_clues(0, 0) assert len(clues) == 10 assert (0, 0) in clues def test_distance_check(): clues = generate_clues(0, 0) for i in range(len(clues)): for j in range(i+1,len(clues)): assert math.dist(clues[i], clues[j]) >= math.sqrt(2) def test_even_sum_of_squares(): clues = generate_clues(-5, 5) total_square_sum = sum(x**2 + y**2 for x, y in clues) assert total_square_sum % 2 == 0 test_first_clue_2_3() test_first_clue_0_0() test_distance_check() test_even_sum_of_squares()","solution":"import math def is_valid_coordinate(x, y, clues): Check if the coordinate (x, y) is a valid clue location. if any(math.dist((x, y), (cx, cy)) < math.sqrt(2) for cx, cy in clues): return False return True def are_squares_even(x, y, clues): Check if the sum of the squares of coordinates remains even. total_square_sum = sum(cx**2 + cy**2 for cx, cy in clues) + x**2 + y**2 return total_square_sum % 2 == 0 def generate_clues(first_x, first_y): clues = [(first_x, first_y)] for x in range(-10, 11): for y in range(-10, 11): if (x != first_x or y != first_y) and is_valid_coordinate(x, y, clues): if are_squares_even(x, y, clues): clues.append((x, y)) if len(clues) == 10: return clues return clues def scavenger_hunt(x, y): clues = generate_clues(x, y) for cx, cy in clues[1:]: print(cx, cy) # Ensure the solution function works as required scavenger_hunt(2, 3)"},{"question":"def smallestUniqueWindow(S: str) -> int: Find the smallest window length that contains all unique characters of the given string S. >>> smallestUniqueWindow(\\"aabcbcdbca\\") 4 >>> smallestUniqueWindow(\\"aaab\\") 2 >>> smallestUniqueWindow(\\"abcd\\") 4 >>> smallestUniqueWindow(\\"abac\\") 3 >>> smallestUniqueWindow(\\"aaaaaaaaaa\\") 1","solution":"def smallestUniqueWindow(S): from collections import defaultdict unique_chars = set(S) num_unique_chars = len(unique_chars) n = len(S) if num_unique_chars == 1: return 1 min_length = n start = 0 char_count = defaultdict(int) count = 0 for end in range(n): char = S[end] char_count[char] += 1 if char_count[char] == 1: count += 1 while count == num_unique_chars: min_length = min(min_length, end - start + 1) start_char = S[start] char_count[start_char] -= 1 if char_count[start_char] == 0: count -= 1 start += 1 return min_length"},{"question":"def count_plant_patches(n, m, grid): Count the number of distinct plant patches in the grid. >>> count_plant_patches(3, 4, [ list('abab'), list('baba'), list('abab') ]) 12 >>> count_plant_patches(1, 1, [ list('a') ]) 1 >>> count_plant_patches(3, 3, [ list('aaa'), list('aaa'), list('aaa') ]) 1 >>> count_plant_patches(2, 2, [ list('ab'), list('cd') ]) 4 >>> count_plant_patches(4, 4, [ list('aaaa'), list('aaaa'), list('aaaa'), list('aaaa') ]) 1","solution":"def count_plant_patches(n, m, grid): def dfs(i, j, plant_type): if i < 0 or j < 0 or i >= n or j >= m or grid[i][j] != plant_type: return grid[i][j] = '#' # Mark the cell as visited # Visit all four adjacent cells dfs(i + 1, j, plant_type) dfs(i - 1, j, plant_type) dfs(i, j + 1, plant_type) dfs(i, j - 1, plant_type) patches = 0 for i in range(n): for j in range(m): if grid[i][j] != '#': patches += 1 dfs(i, j, grid[i][j]) return patches # Example Usage n, m = 3, 4 grid = [ list('abab'), list('baba'), list('abab') ] print(count_plant_patches(n, m, grid)) # Output: 12"},{"question":"class ListNode: def __init__(self, val: int, next: 'ListNode' = None, random: 'ListNode' = None): self.val = val self.next = next self.random = random def cloneLinkedList(head: 'ListNode') -> 'ListNode': Clone a singly linked list with next and random pointers. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node1.random = node2 >>> node2.random = node1 >>> clone = cloneLinkedList(node1) >>> clone.val == 1 and clone.next.val == 2 True >>> clone.random.val == 2 and clone.next.random.val == 1 True >>> clone is not node1 and clone.next is not node2 True","solution":"class ListNode: def __init__(self, val: int, next: 'ListNode' = None, random: 'ListNode' = None): self.val = val self.next = next self.random = random def cloneLinkedList(head: 'ListNode') -> 'ListNode': if not head: return None # Step 1: Create new nodes and insert them next to original nodes current = head while current: new_node = ListNode(current.val) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Copy random pointers current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the cloned list from the original list original_current = head clone_head = head.next clone_current = clone_head while original_current: original_current.next = clone_current.next original_current = original_current.next if original_current: clone_current.next = original_current.next clone_current = clone_current.next return clone_head"},{"question":"def calculate_total_logged_minutes(timesheets): Given timesheets of multiple employees, calculate the total logged-in minutes for each employee. Parameters: timesheets (list of lists): Each element is a block representing one employee's timesheet. A block is a list where the first element is the number of login/logout pairs, and the following elements are alternating login and logout times in the format \\"HH:MM\\". Returns: list of int: Total logged-in minutes for each employee. pass # Test cases def test_single_pair(): assert calculate_total_logged_minutes([[1, \\"09:00\\", \\"12:00\\"]]) == [180] def test_multiple_pairs(): assert calculate_total_logged_minutes([[2, \\"09:00\\", \\"12:00\\", \\"13:30\\", \\"18:00\\"]]) == [450] def test_multiple_employees(): timesheets = [ [2, \\"09:00\\", \\"12:00\\", \\"13:30\\", \\"18:00\\"], [3, \\"08:00\\", \\"09:00\\", \\"10:00\\", \\"11:00\\", \\"14:00\\", \\"15:30\\"] ] assert calculate_total_logged_minutes(timesheets) == [450, 210] def test_edge_cases(): timesheets = [ [1, \\"00:00\\", \\"23:59\\"] ] assert calculate_total_logged_minutes(timesheets) == [1439] timesheets = [ [1, \\"12:00\\", \\"12:01\\"], [1, \\"00:00\\", \\"00:01\\"] ] assert calculate_total_logged_minutes(timesheets) == [1, 1] def test_zero_employee(): assert calculate_total_logged_minutes([]) == [] def test_complex_case(): timesheets = [ [4, \\"09:00\\", \\"10:00\\", \\"11:00\\", \\"12:00\\", \\"13:00\\", \\"14:00\\", \\"15:00\\", \\"16:00\\"], [2, \\"08:00\\", \\"09:00\\", \\"17:00\\", \\"18:00\\"] ] assert calculate_total_logged_minutes(timesheets) == [240, 120]","solution":"def calculate_total_logged_minutes(timesheets): Given timesheets of multiple employees, calculate the total logged-in minutes for each employee. Parameters: timesheets (list of lists): Each element is a block representing one employee's timesheet. A block is a list where the first element is the number of login/logout pairs, and the following elements are alternating login and logout times in the format \\"HH:MM\\". Returns: list of int: Total logged-in minutes for each employee. total_logged_minutes = [] for employee_timesheet in timesheets: n = employee_timesheet[0] minutes_logged = 0 times = employee_timesheet[1:] for i in range(n): login_time = times[2 * i] logout_time = times[2 * i + 1] login_hours, login_minutes = map(int, login_time.split(':')) logout_hours, logout_minutes = map(int, logout_time.split(':')) login_total_minutes = login_hours * 60 + login_minutes logout_total_minutes = logout_hours * 60 + logout_minutes minutes_logged += logout_total_minutes - login_total_minutes total_logged_minutes.append(minutes_logged) return total_logged_minutes"},{"question":"def diamondPattern(size): Returns a diamond shape of a given size as a list containing each line of the diamond. >>> diamondPattern(5) ['____*____', '___***___', '__*****__', '_*******_', '*********', '_*******_', '__*****__', '___***___', '____*____'] >>> diamondPattern(3) ['__*__', '_***_', '*****', '_***_', '__*__'] >>> diamondPattern(1) ['*'] >>> diamondPattern(4) ['___*___', '__***__', '_*****_', '*******', '_*****_', '__***__', '___*___']","solution":"def diamondPattern(size): Returns a diamond shape of a given size as a list containing each line of the diamond. diamond = [] for i in range(size): underscores = '_' * (size - i - 1) stars = '*' * (2 * i + 1) diamond.append(underscores + stars + underscores) for i in range(size - 2, -1, -1): underscores = '_' * (size - i - 1) stars = '*' * (2 * i + 1) diamond.append(underscores + stars + underscores) return diamond"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restore the shuffle string to its original order as per the given indices. >>> restore_string(\\"code\\", [3, 2, 1, 0]) 'edoc' >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) 'nihao'","solution":"def restore_string(s, indices): Restores the string to its original order as per the given indices. Parameters: s (str): The shuffled string. indices (list of int): The list of indices representing the original positions of each character. Returns: str: The original string after re-shuffling. n = len(s) restored = [''] * n for i, index in enumerate(indices): restored[index] = s[i] return ''.join(restored)"},{"question":"def find_single(arr: List[int]) -> int: Returns the element in the array that appears only once. >>> find_single([4, 1, 2, 1, 2]) 4 >>> find_single([7]) 7 >>> find_single([2, 3, 2, 4, 4]) 3 >>> find_single([i for i in range(1, 10001)] * 2 + [10001]) 10001 >>> find_single([-1, -2, -3, -1, -2]) -3","solution":"def find_single(arr): Returns the element in the array that appears only once. result = 0 for num in arr: result ^= num return result"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the given array can be partitioned into two subsets such that the sums of the elements in both subsets are equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determine if the given array can be partitioned into two subsets such that the sums of the elements in both subsets are equal. :param nums: List[int] - array of integers :return: bool - True if array can be partitioned into two subsets of equal sum, False otherwise total_sum = sum(nums) # If total_sum is odd, it's impossible to split the array in two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize dp array dp = [False] * (target + 1) dp[0] = True # Update dp array for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def match_parentheses(s: str) -> bool: Checks if the parentheses in the input string are correctly matched and properly nested. Args: s (str): the input string containing parentheses and possibly other characters. Returns: bool: True if the parentheses are properly matched and nested, False otherwise. >>> match_parentheses(\\"()\\") True >>> match_parentheses(\\"(())\\") True >>> match_parentheses(\\"(()\\") False >>> match_parentheses(\\")(\\") False >>> match_parentheses(\\"((())\\") False","solution":"def match_parentheses(s): Checks if the parentheses in the input string are correctly matched and properly nested. Args: s (str): the input string containing parentheses and possibly other characters. Returns: bool: True if the parentheses are properly matched and nested, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import List def shortest_path(n: int, grid: List[str]) -> int: Determine the shortest path for a bus starting at the top-left corner (0, 0) to reach the bottom-right corner (n-1, n-1). The bus can only move up, down, left, or right, and it can pass only through the passable cells ('1'). If it's impossible to reach the destination, return -1. >>> shortest_path(4, [\\"1111\\", \\"0011\\", \\"0110\\", \\"1111\\"]) == 6 >>> shortest_path(3, [\\"110\\", \\"010\\", \\"001\\"]) == -1 >>> shortest_path(5, [\\"11111\\", \\"01001\\", \\"01111\\", \\"00101\\", \\"11111\\"]) == 8 >>> shortest_path(2, [\\"10\\", \\"01\\"]) == -1 >>> shortest_path(2, [\\"11\\", \\"11\\"]) == 2 >>> shortest_path(2, [\\"10\\", \\"00\\"]) == -1 pass","solution":"from collections import deque def shortest_path(n, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == '1' if grid[0][0] == '0' or grid[n-1][n-1] == '0': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == n-1: return dist for dir_x, dir_y in directions: new_x, new_y = x + dir_x, y + dir_y if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, dist + 1)) return -1"},{"question":"def do_rectangles_overlap(x1, y1, x2, y2, a1, b1, a2, b2) -> str: Checks if two rectangles overlap. Parameters: x1, y1, x2, y2 - bottom-left and top-right vertices of the first rectangle a1, b1, a2, b2 - bottom-left and top-right vertices of the second rectangle Returns: \\"Overlap\\" if the rectangles overlap, \\"No Overlap\\" otherwise. >>> do_rectangles_overlap(1, 1, 5, 5, 3, 3, 7, 7) 'Overlap' >>> do_rectangles_overlap(1, 1, 3, 3, 4, 4, 6, 6) 'No Overlap'","solution":"def do_rectangles_overlap(x1, y1, x2, y2, a1, b1, a2, b2): Checks if two rectangles overlap. Parameters: x1, y1, x2, y2 - bottom-left and top-right vertices of the first rectangle a1, b1, a2, b2 - bottom-left and top-right vertices of the second rectangle Returns: \\"Overlap\\" if the rectangles overlap, \\"No Overlap\\" otherwise. if x1 >= a2 or a1 >= x2 or y1 >= b2 or b1 >= y2: return \\"No Overlap\\" else: return \\"Overlap\\""},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Return the maximum sum of any contiguous subarray with at least k elements. >>> max_sum_subarray([1, 2, -3, 4, 5, -6, 7, 8], 3) 18 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([4, -1, 2, 1], 2) 6 >>> max_sum_subarray([1, 2, 3, 4, 5, 6], 3) 21 >>> max_sum_subarray([5], 1) 5","solution":"def max_sum_subarray(arr, k): Return the maximum sum of any contiguous subarray with at least k elements. n = len(arr) max_sum = float('-inf') # Calculate the sum of first 'k' elements current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) # Maintain the best sum of any k-length subarray for i in range(k, n): current_sum += arr[i] - arr[i-k] max_sum = max(max_sum, current_sum) # Extend the window to more than k elements for length in range(k+1, n+1): current_sum = sum(arr[:length]) max_sum = max(max_sum, current_sum) for i in range(length, n): current_sum += arr[i] - arr[i-length] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def can_form_triangle(arr: List[int]) -> str: Determines if there are any three numbers in the array that can form a triangle. A triangle can be formed if and only if the sum of any two sides is greater than the remaining side for all three combinations of the three sides. >>> can_form_triangle([10, 5, 3, 7]) \\"YES\\" >>> can_form_triangle([1, 2, 3]) \\"NO\\"","solution":"from typing import List def can_form_triangle(arr: List[int]) -> str: Determines if there are any three numbers in the array that can form a triangle. arr.sort() for i in range(len(arr) - 2): if arr[i] + arr[i + 1] > arr[i + 2]: return \\"YES\\" return \\"NO\\""},{"question":"def can_fill_hall(W: int, H: int, w: int, h: int) -> int: Determines if the hall of dimensions W by H can be completely filled with tables of dimensions w by h. Returns the number of tables that fit if possible, otherwise returns -1. >>> can_fill_hall(10, 10, 2, 5) 10 >>> can_fill_hall(8, 6, 3, 2) 8 >>> can_fill_hall(8, 6, 5, 3) -1 >>> can_fill_hall(15, 15, 5, 5) 9","solution":"def can_fill_hall(W, H, w, h): Determines if the hall of dimensions W by H can be completely filled with tables of dimensions w by h. Returns the number of tables that fit if possible, otherwise returns -1. if (W % w == 0 and H % h == 0): return (W // w) * (H // h) elif (W % h == 0 and H % w == 0): return (W // h) * (H // w) else: return -1"},{"question":"def maxGemSum(nums): Returns the maximum sum of a contiguous subarray. >>> maxGemSum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> maxGemSum([1, 2, 3, 4, 5]) 15 >>> maxGemSum([-1, -2, -3, -4, -5]) -1 >>> maxGemSum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxGemSum([5]) 5 >>> maxGemSum([-5]) -5 >>> maxGemSum([]) 0 >>> maxGemSum([1] * 100000) 100000 >>> maxGemSum([1] * 50000 + [-1] * 50000) 50000 >>> maxGemSum([-1] * 50000 + [1] * 50000) 50000","solution":"def maxGemSum(nums): Returns the maximum sum of a contiguous subarray. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def max_in_sliding_windows(arr: List[int], K: int) -> List[int]: Returns a list of the maximum values in each sliding window of size K. >>> max_in_sliding_windows([1, 3, 1, 2, 0, 5, 3, 1], 3) [3, 3, 2, 5, 5, 5] >>> max_in_sliding_windows([4, 2, 3, 1, 5], 2) [4, 3, 3, 5] pass def solve_vending_machine(test_cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Takes a list of test cases and returns a list of results for each test case, where each result is a list of the maximum values in each sliding window. >>> test_cases = [ ... (8, 3, [1, 3, 1, 2, 0, 5, 3, 1]), ... (5, 2, [4, 2, 3, 1, 5]) ... ] >>> solve_vending_machine(test_cases) [[3, 3, 2, 5, 5, 5], [4, 3, 3, 5]] pass","solution":"from collections import deque def max_in_sliding_windows(arr, K): Returns a list of the maximum values in each sliding window of size K. dq = deque() result = [] for i in range(len(arr)): # Remove elements not within the sliding window if dq and dq[0] == i - K: dq.popleft() # Remove elements smaller than the current element from the queue while dq and arr[dq[-1]] < arr[i]: dq.pop() dq.append(i) # The first element of deque is the largest element of # the current sliding window if i >= K - 1: result.append(arr[dq[0]]) return result def solve_vending_machine(test_cases): results = [] for N, K, quality_scores in test_cases: results.append(max_in_sliding_windows(quality_scores, K)) return results"},{"question":"def count_improved_students(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Given the number of test cases and their respective test data, returns a list of counts of students who have improved their rank. T: int, number of test cases test_cases: list of tuples, each containing: - an integer N (number of students) - a list of integers (ranks in the previous contest) - a list of integers (ranks in the current contest) Returns: list of ints, the number of improved students for each test case >>> T = 2 >>> test_cases = [(5, [4, 2, 5, 1, 3], [3, 2, 4, 1, 2]), (3, [7, 6, 8], [6, 6, 7])] >>> count_improved_students(T, test_cases) [3, 2]","solution":"def count_improved_students(T, test_cases): Given the number of test cases and their respective test data, returns a list of counts of students who have improved their rank. T: int, number of test cases test_cases: list of tuples, each containing: - an integer N (number of students) - a list of integers (ranks in the previous contest) - a list of integers (ranks in the current contest) Returns: list of ints, the number of improved students for each test case results = [] for i in range(T): N, prev_ranks, curr_ranks = test_cases[i] improved_count = sum(1 for j in range(N) if curr_ranks[j] < prev_ranks[j]) results.append(improved_count) return results"},{"question":"def min_subarray_length(n: int, S: int, array: List[int]) -> int: Finds the minimum size of a contiguous subarray with a sum greater than or equal to S. Parameters: n (int): The size of the array. S (int): The target sum. array (list of int): List of unique integers. Returns: int: Size of the smallest subarray with sum >= S, or 0 if no such subarray exists. >>> min_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> min_subarray_length(5, 11, [1, 2, 3, 4, 5]) 3 >>> min_subarray_length(5, 20, [1, 2, 3, 4, 5]) 0","solution":"def min_subarray_length(n, S, array): Finds the minimum size of a contiguous subarray with a sum greater than or equal to S. Parameters: n (int): The size of the array. S (int): The target sum. array (list of int): List of unique integers. Returns: int: Size of the smallest subarray with sum >= S, or 0 if no such subarray exists. min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += array[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= array[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def determine_winner(test_cases): Determine the winner of each game based on the sum of card numbers. Args: test_cases (List[Tuple[int, int, int, int]]): A list of tuples where each tuple contains four integers (R, B, R_prime, B_prime). Returns: List[str]: A list of results for each test case (\\"X\\", \\"Y\\", or \\"TIE\\"). Example: >>> determine_winner([(7, 3, 5, 5), (12, 10, 9, 14), (8, 8, 8, 8)]) [\\"TIE\\", \\"Y\\", \\"TIE\\"] >>> determine_winner([(10, 20, 15, 14)]) [\\"X\\"]","solution":"def determine_winner(test_cases): results = [] for R, B, R_prime, B_prime in test_cases: score_X = R + B score_Y = R_prime + B_prime if score_X > score_Y: results.append(\\"X\\") elif score_Y > score_X: results.append(\\"Y\\") else: results.append(\\"TIE\\") return results # Example Usage: # test_cases = [(7, 3, 5, 5), (12, 10, 9, 14), (8, 8, 8, 8)] # print(determine_winner(test_cases))"},{"question":"def determine_winner(A: int, B: int) -> str: Determine the winner of the game given the initial number of stones in piles A and B, assuming both players play optimally. >>> determine_winner(5, 3) 'Alice' >>> determine_winner(8, 4) 'Bob' >>> determine_winner(7, 6) 'Alice' >>> determine_winner(20, 10) 'Bob'","solution":"def determine_winner(A, B): Determine the winner of the game given the initial number of stones in piles A and B, assuming both players play optimally. :param A: int, initial number of stones in pile A :param B: int, initial number of stones in pile B :return: str, \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins # The player strategy is same as Nim Game principle -- based on the XOR of A and B. if A % 2 == 1 or B % 2 == 1: return \\"Alice\\" return \\"Bob\\""},{"question":"def can_partition_to_powers_of_two(n: int, arr: List[int]) -> str: Given a list of integers, determine if it is possible to partition the list into contiguous subarrays such that the sum of each subarray is an integer power of 2. Example: >>> can_partition_to_powers_of_two(6, [2, 3, 1, 1, 4, 8]) 'Yes' >>> can_partition_to_powers_of_two(4, [2, 4, 1, 3]) 'No' >>> can_partition_to_powers_of_two(1, [16]) 'Yes'","solution":"def is_power_of_two(x): Checks if x is a power of 2. return (x & (x - 1)) == 0 and x != 0 def can_partition_to_powers_of_two(n, arr): Determines if it is possible to partition the array into contiguous subarrays such that the sum of each subarray is a power of 2. i = 0 while i < n: current_sum = 0 partition_found = False for j in range(i, n): current_sum += arr[j] if is_power_of_two(current_sum): i = j + 1 partition_found = True break if not partition_found: return \\"No\\" return \\"Yes\\""},{"question":"def most_active_user(activities, queries): Given a series of user activities represented as a list of tuples, and a set of queries with start and end timestamps, identify the most active user during each specified time window. If there is a tie, the lexicographically smallest user_id should be returned. Args: activities (List[Tuple[str, int]]): A list of user activities where each activity is represented by a tuple containing user_id and timestamp. queries (List[Tuple[int, int]]): A list of queries where each query is represented by a tuple containing start_time and end_time. Returns: List[str]: A list of user_ids, each representing the most active user for a corresponding query. >>> most_active_user([(\\"alice\\", 10), (\\"bob\\", 15), (\\"alice\\", 20), (\\"alice\\", 25), (\\"bob\\", 30)], [(5, 20), (10, 30), (15, 35)]) [\\"alice\\", \\"alice\\", \\"bob\\"] >>> most_active_user([(\\"alice\\", 10)], [(5, 20)]) [\\"alice\\"] >>> most_active_user([(\\"alice\\", 10), (\\"bob\\", 20)], [(30, 40), (5, 9)]) [None, None]","solution":"def most_active_user(activities, queries): from collections import defaultdict # Function to count activities within the given range for each user def count_activities_in_range(user_activities, start_time, end_time): activity_counts = defaultdict(int) for user_id, timestamp in user_activities: if start_time <= timestamp <= end_time: activity_counts[user_id] += 1 return activity_counts # Process each query results = [] for start_time, end_time in queries: activity_counts = count_activities_in_range(activities, start_time, end_time) # Find the user with the maximum activities, with lexicographical order consideration in case of tie most_active = None for user_id, count in activity_counts.items(): if most_active is None or count > activity_counts[most_active] or (count == activity_counts[most_active] and user_id < most_active): most_active = user_id results.append(most_active) return results"},{"question":"def ticket_booking_system(n, m, available_seats, user_requests): Determine if it's feasible to accommodate all users' ticket requests and, if feasible, provide the optimal order of event bookings for minimal first-choice events. >>> n, m, available_seats, user_requests = 3, 2, [10, 5, 8], [[2, 1, 4, 2, 3], [2, 2, 3, 3, 1]] >>> ticket_booking_system(n, m, available_seats, user_requests) 'YES' >>> n, m, available_seats, user_requests = 2, 2, [3, 4], [[1, 1, 5], [2, 1, 2, 2, 3]] >>> ticket_booking_system(n, m, available_seats, user_requests) 'NO' >>> n, m, available_seats, user_requests = 4, 3, [15, 20, 13, 10], [[1, 3, 5], [2, 2, 7, 4, 3], [2, 1, 10, 3, 2]] >>> ticket_booking_system(n, m, available_seats, user_requests) 'YES' pass def parse_input(input_text): Parse the input text and return the relevant structures for processing. >>> input_data = \\"3 2n10 5 8n2 1 4 2 3n2 2 3 3 1\\" >>> parse_input(input_data) (3, 2, [10, 5, 8], [[2, 1, 4, 2, 3], [2, 2, 3, 3, 1]]) lines = input_text.strip().split('n') n, m = map(int, lines[0].split()) available_seats = list(map(int, lines[1].split())) user_requests = [] for i in range(2, 2 + m): user_requests.append(list(map(int, lines[i].split()))) return n, m, available_seats, user_requests def test_ticket_booking_system(): input_data = 3 2 10 5 8 2 1 4 2 3 2 2 3 3 1 n, m, available_seats, user_requests = parse_input(input_data) assert ticket_booking_system(n, m, available_seats, user_requests) == \\"YES\\" input_data = 2 2 3 4 1 1 5 2 1 2 2 3 n, m, available_seats, user_requests = parse_input(input_data) assert ticket_booking_system(n, m, available_seats, user_requests) == \\"NO\\" input_data = 4 3 15 20 13 10 1 3 5 2 2 7 4 3 2 1 10 3 2 n, m, available_seats, user_requests = parse_input(input_data) assert ticket_booking_system(n, m, available_seats, user_requests) == \\"YES\\" input_data = 1 1 5 1 1 6 n, m, available_seats, user_requests = parse_input(input_data) assert ticket_booking_system(n, m, available_seats, user_requests) == \\"NO\\" input_data = 2 1 2 2 2 1 1 2 1 n, m, available_seats, user_requests = parse_input(input_data) assert ticket_booking_system(n, m, available_seats, user_requests) == \\"YES\\" if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def ticket_booking_system(n, m, available_seats, user_requests): # Initialize an array to keep track of available seats for each event seats = available_seats[:] # Construct a list to hold all the requests requests = [] for request in user_requests: num_events, *events = request request_list = [] for i in range(num_events): event_number, ticket_quantity = events[2 * i], events[2 * i + 1] request_list.append((event_number - 1, ticket_quantity)) # Event index is from 0 requests.append(request_list) # Sort requests by number of events in ascending order for prioritization requests.sort(key=lambda x: len(x)) for request in requests: satisfied = False for event_number, ticket_quantity in request: if seats[event_number] >= ticket_quantity: seats[event_number] -= ticket_quantity satisfied = True break if not satisfied: return \\"NO\\" return \\"YES\\" # This function returns the available seats array and the requests array based on input text def parse_input(input_text): lines = input_text.strip().split('n') n, m = map(int, lines[0].split()) available_seats = list(map(int, lines[1].split())) user_requests = [] for i in range(2, 2 + m): user_requests.append(list(map(int, lines[i].split()))) return n, m, available_seats, user_requests"},{"question":"def smallest_subsequence(s: str) -> str: Returns the lexicographically smallest subsequence of \`s\` that contains all the distinct characters of \`s\` exactly once. >>> smallest_subsequence(\\"bcabc\\") 'abc' >>> smallest_subsequence(\\"cbacdcbc\\") 'acdb'","solution":"def smallest_subsequence(s): Returns the lexicographically smallest subsequence of \`s\` that contains all the distinct characters of \`s\` exactly once. last_position = {char: i for i, char in enumerate(s)} stack = [] seen = set() for i, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and i < last_position[stack[-1]]: seen.remove(stack.pop()) stack.append(char) seen.add(char) return ''.join(stack)"},{"question":"from typing import List def ladderLength(start: str, end: str, wordList: List[str]) -> int: Finds the length of the shortest transformation sequence from \`start\` to \`end\`. Only one letter can be changed at a time, and each transformed word must exist in the word list. If there is no such sequence, return 0. >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) 0","solution":"from collections import deque def ladderLength(start, end, wordList): if end not in wordList: return 0 wordSet = set(wordList) queue = deque([(start, 1)]) while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i + 1:] if next_word in wordSet: wordSet.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"def find_pair_with_difference(arr: list, target: int) -> bool: Determine whether there exists a pair of indices (i, j) such that i < j and the difference between the elements at these indices is equal to a given target value. >>> find_pair_with_difference([5, 10, 3, 2, 50, 80], 78) True >>> find_pair_with_difference([90, 70, 20, 80, 50], 45) False","solution":"def find_pair_with_difference(arr, target): Function to determine whether there exists a pair of indices (i, j) such that i < j and the difference between the elements at these indices is equal to a given target value. seen = set() for num in arr: if num + target in seen or num - target in seen: return True seen.add(num) return False"},{"question":"def minimum_cost(arr): Returns the minimum possible cost of the array after making any number of swaps. The cost is defined as the sum of the absolute differences of all adjacent elements. from typing import List def test_example(): assert minimum_cost([6, 2, 4]) == 4 def test_sorted_array(): assert minimum_cost([1, 2, 3, 4, 5]) == 4 assert minimum_cost([10, 20, 30, 40]) == 30 def test_identical_elements(): assert minimum_cost([3, 3, 3, 3]) == 0 def test_reverse_sorted_array(): assert minimum_cost([5, 4, 3, 2, 1]) == 4 def test_two_elements(): assert minimum_cost([100, 1]) == 99 def test_large_numbers(): assert minimum_cost([1000000000, 1, 999999999, 500000000]) == 999999999 def test_single_pair(): assert minimum_cost([100, 100]) == 0","solution":"def minimum_cost(arr): Returns the minimum possible cost of the array after making any number of swaps. The cost is defined as the sum of the absolute differences of all adjacent elements. arr.sort() min_cost = 0 for i in range(1, len(arr)): min_cost += abs(arr[i] - arr[i - 1]) return min_cost"},{"question":"def three_sum(array, target): Determines if there are three distinct integers in the array such that their sum is equal to the target. Args: array (list of int): List of integers. target (int): Target sum value. Returns: bool: True if there are three integers in the array that sum up to the target, False otherwise. >>> three_sum([1, 2, 3, 4, 5, 6], 10) True >>> three_sum([-1, 0, 1, 2], 5) False","solution":"def three_sum(array, target): Determines if there are three distinct integers in the array such that their sum is equal to the target. Args: array (list of int): List of integers. target (int): Target sum value. Returns: bool: True if there are three integers in the array that sum up to the target, False otherwise. array.sort() # Sort the array to use the two-pointer technique n = len(array) for i in range(n - 2): # Skip duplicate values if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(11) True >>> is_prime(4) False def sum_of_primes_in_range(a:int, b:int) -> int: Calculate the sum of all prime numbers in the given range [a, b]. >>> sum_of_primes_in_range(10, 20) 60 >>> sum_of_primes_in_range(15, 30) 88 >>> sum_of_primes_in_range(14, 16) 0 >>> sum_of_primes_in_range(17, 17) 17 >>> sum_of_primes_in_range(1, 30) 129 >>> sum_of_primes_in_range(1, 10) 17","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes_in_range(a, b): return sum(i for i in range(a, b + 1) if is_prime(i))"},{"question":"def middle_character(s: str) -> str: Returns the middle character(s) of the given string. If the string length is odd, return the single middle character. If the string length is even, return the two middle characters. >>> middle_character(\\"hello\\") \\"l\\" >>> middle_character(\\"coding\\") \\"di\\" >>> middle_character(\\"a\\") \\"a\\" >>> middle_character(\\"ab\\") \\"ab\\" >>> middle_character(\\"\\") \\"\\" >>> middle_character(\\"abcdefghijk\\") \\"f\\" >>> middle_character(\\"abcdefghij\\") \\"ef\\"","solution":"def middle_character(s): Returns the middle character(s) of the given string. If the string length is odd, return the single middle character. If the string length is even, return the two middle characters. length = len(s) mid = length // 2 if length % 2 == 0: # If even, return the middle two characters return s[mid - 1:mid + 1] else: # If odd, return the middle character return s[mid]"},{"question":"def canAchieveProfit(prices: List[int], target: int) -> bool: Determines if it's possible to achieve the target profit by buying and then selling the stock once. Parameters: prices (list of int): List of stock prices. target (int): Target profit. Returns: bool: True if it's possible to achieve at least the target profit, False otherwise. Examples: >>> canAchieveProfit([7, 1, 5, 3, 6, 4], 5) True >>> canAchieveProfit([7, 6, 4, 3, 1], 1) False # Write your code here","solution":"def canAchieveProfit(prices, target): Determines if it's possible to achieve the target profit by buying and then selling the stock once. Parameters: prices (list of int): List of stock prices. target (int): Target profit. Returns: bool: True if it's possible to achieve at least the target profit, False otherwise. if not prices or len(prices) < 2: return False min_price = prices[0] for price in prices[1:]: potential_profit = price - min_price if potential_profit >= target: return True min_price = min(min_price, price) return False"},{"question":"def snake_to_camel(snake_str: str) -> str: Converts a snake_case string to camelCase. >>> snake_to_camel(\\"hello_world\\") \\"helloWorld\\" >>> snake_to_camel(\\"this_is_snake_case\\") \\"thisIsSnakeCase\\" >>> snake_to_camel(\\"convert_this_string\\") \\"convertThisString\\"","solution":"def snake_to_camel(snake_str): Converts a snake_case string to camelCase. Args: snake_str (str): A string in snake_case format. Returns: str: The string converted to camelCase format. words = snake_str.split('_') camel_case_str = words[0] + ''.join(word.title() for word in words[1:]) return camel_case_str"},{"question":"def favorite_subarray_length(n: int, k: int, F: List[int]) -> int: Find the length of the longest subarray such that the sum of its fragrance values is greater than or equal to k. >>> favorite_subarray_length(5, 10, [2, 3, 5, 1, 6]) 4 >>> favorite_subarray_length(5, 20, [4, 2, 1, 3, 5]) -1","solution":"def favorite_subarray_length(n, k, F): max_length = -1 current_sum = 0 start = 0 for end in range(n): current_sum += F[end] while current_sum >= k and start <= end: max_length = max(max_length, end - start + 1) current_sum -= F[start] start += 1 return max_length"},{"question":"def extract_original_strings(interleaved_string: str) -> (str, str): Extracts the original two strings from the interleaved string. >>> extract_original_strings(\\"a1b2c3d4e\\") ('abcde', '1234') >>> extract_original_strings(\\"a1\\") ('a', '1') >>> extract_original_strings(\\"x1y2z3w4\\") ('xyzw', '1234') >>> extract_original_strings(\\"123456\\") ('135', '246') >>> extract_original_strings(\\"abcdef\\") ('ace', 'bdf') >>> extract_original_strings(\\"1a2b3c4d\\") ('1234', 'abcd')","solution":"def extract_original_strings(interleaved_string): Extracts the original two strings from the interleaved string. @param interleaved_string: The interleaved resultant string @return: a tuple of the original two strings first_str = [] second_str = [] for i in range(len(interleaved_string)): if i % 2 == 0: first_str.append(interleaved_string[i]) else: second_str.append(interleaved_string[i]) return ''.join(first_str), ''.join(second_str)"},{"question":"def can_move_parcels(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if the robot can successfully move all parcels without exceeding the capacity C at any point. Parameters: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): Each test case contains a tuple with number of parcels and capacity, and a list of parcel weights. Returns: List[str]: \\"YES\\" if the robot can move all parcels within the capacity C, otherwise \\"NO\\". >>> input_data = \\"3n3 10n2 5 3n4 8n4 1 2 1n2 5n6 4n\\" >>> t, test_cases = parse_input(input_data) >>> can_move_parcels(t, test_cases) ['YES', 'YES', 'NO'] >>> input_data = \\"2n1 5n5n1 3n4n\\" >>> t, test_cases = parse_input(input_data) >>> can_move_parcels(t, test_cases) ['YES', 'NO'] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[Tuple[int, int], List[int]]]]: Parse the input string and extract test cases. Parameters: input_string (str): The string containing the input data. Returns: Tuple[int, List[Tuple[Tuple[int, int], List[int]]]]: Number of test cases and the list of test cases. >>> input_data = \\"3n3 10n2 5 3n4 8n4 1 2 1n2 5n6 4n\\" >>> parse_input(input_data) (3, [((3, 10), [2, 5, 3]), ((4, 8), [4, 1, 2, 1]), ((2, 5), [6, 4])]) pass def stringify_output(result_list: List[str]) -> str: Convert the list of results into a formatted output string. Parameters: result_list (List[str]): List of results, each being \\"YES\\" or \\"NO\\". Returns: str: Formatted output string. >>> result_list = ['YES', 'YES', 'NO'] >>> stringify_output(result_list) 'YESnYESnNO' pass import unittest class TestParcelMovement(unittest.TestCase): def test_can_move_parcels(self): input_data = \\"3n3 10n2 5 3n4 8n4 1 2 1n2 5n6 4n\\" t, test_cases = parse_input(input_data) result = can_move_parcels(t, test_cases) self.assertEqual(stringify_output(result), \\"YESnYESnNO\\") def test_single_parcel(self): input_data = \\"2n1 5n5n1 3n4n\\" t, test_cases = parse_input(input_data) result = can_move_parcels(t, test_cases) self.assertEqual(stringify_output(result), \\"YESnNO\\") def test_total_sum_exceeding(self): input_data = \\"1n3 5n2 2 2n\\" t, test_cases = parse_input(input_data) result = can_move_parcels(t, test_cases) self.assertEqual(stringify_output(result), \\"NO\\") def test_large_capacity(self): input_data = \\"1n3 1000000n9999 10000 9999n\\" t, test_cases = parse_input(input_data) result = can_move_parcels(t, test_cases) self.assertEqual(stringify_output(result), \\"YES\\") def test_no_case(self): input_data = \\"0n\\" t, test_cases = parse_input(input_data) result = can_move_parcels(t, test_cases) self.assertEqual(stringify_output(result), \\"\\")","solution":"def can_move_parcels(t, test_cases): results = [] for test_case in test_cases: n, C = test_case[0] weights = test_case[1] if max(weights) <= C and sum(weights) <= C: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_string): data = input_string.strip().split('n') t = int(data[0]) test_cases = [] index = 1 for _ in range(t): n, C = map(int, data[index].split()) weights = list(map(int, data[index + 1].split())) test_cases.append(((n, C), weights)) index += 2 return t, test_cases def stringify_output(result_list): return 'n'.join(result_list)"},{"question":"def find_max_playtime_user(data: str) -> tuple: Finds the user with the maximum single play session time and that session duration. Parameters: data (str): Multiline string containing the input data. Returns: tuple: (user_id, max_time) where user_id is the 1-indexed ID of the user and max_time is the maximum single play session time. >>> find_max_playtime_user(\\"3n2 100 200n1 300n3 150 120 90\\") (2, 300) >>> find_max_playtime_user(\\"1n3 100 200 150\\") (1, 200) >>> find_max_playtime_user(\\"2n1 250n1 300\\") (2, 300)","solution":"def find_max_playtime_user(data): Finds the user with the maximum single play session time and that session duration. Parameters: data (str): Multiline string containing the input data. Returns: tuple: (user_id, max_time) where user_id is the 1-indexed ID of the user and max_time is the maximum single play session time. lines = data.strip().split('n') U = int(lines[0]) max_time = -1 max_user_id = -1 for i in range(U): sessions = list(map(int, lines[i + 1].split())) user_id = i + 1 max_session_time = max(sessions[1:]) if max_session_time > max_time: max_time = max_session_time max_user_id = user_id return (max_user_id, max_time) # Example usage with direct input string data = 3 2 100 200 1 300 3 150 120 90 print(find_max_playtime_user(data)) # Output: (2, 300)"},{"question":"def can_load_all_boxes(T: int, C: int, clients: List[List[int]]) -> str: Determines if it is possible to load all boxes into the trucks such that no two clients share the same truck. Args: T : int : number of trucks C : int : capacity of each truck clients : List[List[int]] : list of clients and their respective box volumes Returns: str : \\"Possible\\" if all boxes can be loaded as described, otherwise \\"Not Possible\\" Example: >>> can_load_all_boxes(3, 10, [[3, 4, 3], [2, 2, 8]]) 'Possible' >>> can_load_all_boxes(2, 15, [[4, 8, 1, 2], [7, 12]]) 'Not Possible' >>> can_load_all_boxes(4, 20, [[6, 10, 4], [5, 6, 9, 2], [19]]) 'Possible' pass def test_possible_case_1(): assert can_load_all_boxes(3, 10, [[3, 4, 3], [2, 2, 8]]) == \\"Possible\\" def test_not_possible_case_1(): assert can_load_all_boxes(2, 15, [[4, 8, 1, 2], [7, 12]]) == \\"Not Possible\\" def test_possible_case_2(): assert can_load_all_boxes(4, 20, [[6, 10, 4], [5, 6, 9, 2], [19]]) == \\"Possible\\" def test_minimum_input_limit(): assert can_load_all_boxes(1, 1, [[1]]) == \\"Possible\\" def test_large_single_box_per_client(): assert can_load_all_boxes(3, 10, [[10], [10], [10]]) == \\"Possible\\" def test_impossible_due_to_large_order(): assert can_load_all_boxes(3, 10, [[10, 10], [10], [10]]) == \\"Not Possible\\" def test_exact_fit_possible(): assert can_load_all_boxes(3, 10, [[1, 1, 8], [5, 5], [6, 4]]) == \\"Possible\\" def test_exact_fit_not_possible(): assert can_load_all_boxes(2, 10, [[1, 1, 8], [5, 5], [6, 4]]) == \\"Not Possible\\"","solution":"def can_load_all_boxes(T, C, clients): from queue import PriorityQueue N = len(clients) required_trucks = 0 for volumes in clients: volumes.sort(reverse=True) current_volume = 0 trucks_used = 0 for volume in volumes: if current_volume + volume <= C: current_volume += volume else: trucks_used += 1 current_volume = volume trucks_used += 1 # Account for the remaining boxes in the last truck required_trucks += trucks_used return \\"Possible\\" if required_trucks <= T else \\"Not Possible\\""},{"question":"def can_water_flow_to_destination(N: int, grid: List[str]) -> bool: Determine if there is a possible path from the start point to the destination without crossing any obstacles. >>> can_water_flow_to_destination(5, [\\"OO.dO\\", \\"O....\\", \\"O.O.O\\", \\"O.s.O\\", \\"OOOOO\\"]) True >>> can_water_flow_to_destination(3, [\\"sOO\\", \\"OOO\\", \\"OOd\\"]) False >>> can_water_flow_to_destination(3, [\\"OOO\\", \\"OsO\\", \\"OOd\\"]) False >>> can_water_flow_to_destination(3, [\\"s.O\\", \\"OOO\\", \\"OOd\\"]) False >>> can_water_flow_to_destination(2, [\\"sd\\", \\"..\\"]) True >>> can_water_flow_to_destination(4, [\\"s...\\", \\"O.OO\\", \\"O..d\\", \\"OOOO\\"]) True","solution":"def can_water_flow_to_destination(N, grid): start = None destination = None # Find the coordinates of 's' and 'd' for i in range(N): for j in range(N): if grid[i][j] == 's': start = (i, j) elif grid[i][j] == 'd': destination = (i, j) if not start or not destination: return False # Create a visited matrix visited = [[False for _ in range(N)] for _ in range(N)] # Define directions for movement directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Depth-First Search (DFS) function def dfs(x, y): if (x, y) == destination: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny] and grid[nx][ny] in ['.', 'd']: if dfs(nx, ny): return True return False # Start DFS from the starting point return dfs(start[0], start[1])"},{"question":"def maxDistance(seats: List[int]) -> int: Determine the maximum distance to the closest person from any empty seat. >>> maxDistance([1, 0, 0, 0, 1, 0, 1]) == 2 >>> maxDistance([1, 0, 0, 0]) == 3","solution":"def maxDistance(seats): Function to find the maximum distance to the closest person from any empty seat max_dist = 0 prev_person = -1 n = len(seats) for i in range(n): if seats[i] == 1: if prev_person == -1: max_dist = i else: max_dist = max(max_dist, (i - prev_person) // 2) prev_person = i max_dist = max(max_dist, n - 1 - prev_person) return max_dist"},{"question":"import math def number_of_paths(N, M): Computes the number of distinct paths from (1,1) to (N,M) in a grid. pass def solve(test_cases): Given a list of test cases, where each test case is a tuple (N, M) representing the dimensions of the grid, return a list of integers representing the number of distinct paths from the top-left corner to the bottom-right corner. >>> solve([(2, 2)]) [2] >>> solve([(3, 3)]) [6] >>> solve([(1, 1)]) [1] >>> solve([(1, 2), (2, 1)]) [1, 1] >>> solve([(4, 4)]) [20] >>> solve([(2, 3), (5, 5), (2, 5)]) [3, 70, 5] pass","solution":"import math def number_of_paths(N, M): Computes the number of distinct paths from (1,1) to (N,M) in a grid. # Use combinatorial approach to calculate the number of distinct paths return math.comb(N + M - 2, N - 1) def solve(test_cases): results = [] for N, M in test_cases: results.append(number_of_paths(N, M)) return results"},{"question":"def even_odd_sequence_steps(S): Returns the number of steps required to reach 1 using the even-odd sequence starting from S. >>> even_odd_sequence_steps(6) 8 >>> even_odd_sequence_steps(19) 20 >>> even_odd_sequence_steps(1) 0 pass def solve_even_odd_sequence(test_cases): Takes a list of starting values and returns a list of steps required to reach 1 for each. >>> solve_even_odd_sequence([6, 19, 1]) [8, 20, 0] >>> solve_even_odd_sequence([2, 5, 27, 1_000_000]) [1, 5, 111, 152] pass","solution":"def even_odd_sequence_steps(S): Returns the number of steps required to reach 1 using the even-odd sequence starting from S. steps = 0 while S != 1: if S % 2 == 0: S = S // 2 else: S = 3 * S + 1 steps += 1 return steps def solve_even_odd_sequence(test_cases): Takes a list of starting values and returns a list of steps required to reach 1 for each. results = [] for S in test_cases: results.append(even_odd_sequence_steps(S)) return results"},{"question":"def min_switches_to_turn_on_lamps(n, m, switches): Find the minimum number of switches needed to turn on all the lamps. Parameters: n (int): The number of lamps. m (int): The number of switches. switches (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, l and r, defining the range of lamps the switch can toggle. Returns: int: The minimum number of switches needed to turn on all the lamps or -1 if it's impossible. Examples: >>> min_switches_to_turn_on_lamps(5, 3, [(1, 3), (2, 5), (1, 2)]) 2 >>> min_switches_to_turn_on_lamps(4, 2, [(1, 2), (3, 4)]) 2 >>> min_switches_to_turn_on_lamps(4, 1, [(1, 4)]) 1 >>> min_switches_to_turn_on_lamps(6, 3, [(1, 3), (4, 5), (2, 6)]) 2 >>> min_switches_to_turn_on_lamps(7, 3, [(1, 2), (2, 4), (5, 7)]) 3 >>> min_switches_to_turn_on_lamps(5, 2, [(1, 2), (3, 4)]) -1","solution":"def min_switches_to_turn_on_lamps(n, m, switches): switch_ranges = sorted(switches) total_lamps_on = 0 last_toggled = 0 selected_switches = 0 for l, r in switch_ranges: if last_toggled < l - 1: return -1 # If there's any gap that can't be covered, it's impossible if r > last_toggled: selected_switches += 1 last_toggled = r total_lamps_on += r - l + 1 if total_lamps_on >= n: return selected_switches return selected_switches if total_lamps_on >= n else -1"},{"question":"def two_sum(nums, target): Given an array of integers, this function returns the indices of the two numbers such that they add up to a specific target. Each input has exactly one solution, and you may not use the same element twice. Args: nums (List[int]): List of integers. target (int): target sum. Returns: List[int]: Indices of the two numbers that add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 8) [2, 4] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([100000, 500000, 1000000, 1500000], 2000000) [1, 3]","solution":"def two_sum(nums, target): Given an array of integers, this function returns the indices of the two numbers such that they add up to a specific target. Each input has exactly one solution, and you may not use the same element twice. Args: nums (List[int]): List of integers. target (int): target sum. Returns: List[int]: Indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def highest_pollution_levels(n: int, k: int, pollution_levels: List[int]) -> List[int]: Returns a list of maximum pollution levels recorded in each k-second interval. Parameters: n (int): Total number of pollution level measurements. k (int): Length of the time interval in seconds. pollution_levels (list of ints): Pollution levels recorded each second. Returns: list of ints: Maximum pollution levels in each k-second interval. Examples: >>> highest_pollution_levels(8, 3, [3, 1, 4, 1, 5, 9, 2, 6]) [4, 9, 6] >>> highest_pollution_levels(5, 2, [1, 2, 3, 4, 5]) [2, 4, 5]","solution":"def highest_pollution_levels(n, k, pollution_levels): Returns a list of maximum pollution levels recorded in each k-second interval. Parameters: n (int): Total number of pollution level measurements. k (int): Length of the time interval in seconds. pollution_levels (list of ints): Pollution levels recorded each second. Returns: list of ints: Maximum pollution levels in each k-second interval. result = [] for i in range(0, n, k): interval = pollution_levels[i:i + k] result.append(max(interval)) return result # Example usage: # n, k = 8, 3 # pollution_levels = [3, 1, 4, 1, 5, 9, 2, 6] # print(highest_pollution_levels(n, k, pollution_levels)) # Output: [4, 9, 6]"},{"question":"def find_target_in_matrix(matrix, m, n, t): Finds the position of the target integer t in the given matrix. Returns the position as (row, column) (1-based indexing) if found, otherwise returns (-1, -1) if not found. >>> matrix1 = [ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16] ... ] >>> find_target_in_matrix(matrix1, 3, 4, 5) (2, 2) >>> find_target_in_matrix(matrix1, 3, 4, 20) (-1, -1) >>> matrix2 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> find_target_in_matrix(matrix2, 3, 3, 1) (1, 1) >>> find_target_in_matrix(matrix2, 3, 3, 9) (3, 3) >>> find_target_in_matrix(matrix2, 3, 3, 10) (-1, -1) >>> matrix3 = [ ... [1] ... ] >>> find_target_in_matrix(matrix3, 1, 1, 1) (1, 1) >>> find_target_in_matrix(matrix3, 1, 1, 0) (-1, -1) >>> matrix4 = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ] >>> find_target_in_matrix(matrix4, 5, 5, 19) (4, 4) >>> find_target_in_matrix(matrix4, 5, 5, 50) (-1, -1)","solution":"def find_target_in_matrix(matrix, m, n, t): Finds the position of the target integer t in the given matrix. Returns the position as (row, column) (1-based indexing) if found, otherwise returns (-1, -1) if not found. row = 0 col = n - 1 # start from the top-right corner while row < m and col >= 0: if matrix[row][col] == t: return row + 1, col + 1 elif matrix[row][col] > t: col -= 1 else: row += 1 return -1, -1"},{"question":"def robot_return_to_origin(commands: str) -> str: Determines if the robot returns to the origin after executing all commands. :param commands: A string of commands consisting of 'U', 'D', 'L', and 'R' :return: 'YES' if the robot returns to the origin, otherwise 'NO' >>> robot_return_to_origin(\\"UD\\") \\"YES\\" >>> robot_return_to_origin(\\"LL\\") \\"NO\\"","solution":"def robot_return_to_origin(commands): Determines if the robot returns to the origin after executing all commands. :param commands: A string of commands consisting of 'U', 'D', 'L', and 'R' :return: 'YES' if the robot returns to the origin, otherwise 'NO' x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def find_length_of_longest_common_subarray(A: List[int], B: List[int]) -> int: Find the length of the longest common subarray in the two arrays A and B. >>> find_length_of_longest_common_subarray([1, 2, 3, 2, 1], [3, 2, 1, 4, 7, 8]) 3 >>> find_length_of_longest_common_subarray([1, 2, 3], [4, 5, 6]) 0 def process_input(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[int]: Process input and find the length of the longest common subarray for each test case. >>> process_input(2, [(5, [1, 2, 3, 2, 1], 6, [3, 2, 1, 4, 7, 8]), (3, [1, 2, 3], 3, [4, 5, 6])]) [3, 0]","solution":"def find_length_of_longest_common_subarray(A, B): n = len(A) m = len(B) dp = [[0] * (m + 1) for _ in range(n + 1)] result = 0 for i in range(1, n + 1): for j in range(1, m + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 result = max(result, dp[i][j]) return result def process_input(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] A = test_cases[t][1] M = test_cases[t][2] B = test_cases[t][3] results.append(find_length_of_longest_common_subarray(A, B)) return results"},{"question":"def assign_letter_grade(scores: List[int]) -> List[str]: Assigns a letter grade to each student's score based on the following rules: - A: 90-100 - B: 80-89 - C: 70-79 - D: 60-69 - F: 0-59 Parameters: scores (list of int) : A list of student scores. Returns: list of str: A list of letter grades corresponding to each score. >>> assign_letter_grade([95, 85, 76, 67, 58]) ['A', 'B', 'C', 'D', 'F'] >>> assign_letter_grade([90, 89, 78, 67, 56]) ['A', 'B', 'C', 'D', 'F'] >>> assign_letter_grade([100, 0, 90, 80, 70, 60, 59]) ['A', 'F', 'A', 'B', 'C', 'D', 'F'] >>> assign_letter_grade([]) []","solution":"def assign_letter_grade(scores): Assigns a letter grade to each student's score. Parameters: scores (list of int) : A list of student scores. Returns: list of str: A list of letter grades corresponding to each score. grades = [] for score in scores: if 90 <= score <= 100: grades.append('A') elif 80 <= score <= 89: grades.append('B') elif 70 <= score <= 79: grades.append('C') elif 60 <= score <= 69: grades.append('D') elif 0 <= score <= 59: grades.append('F') return grades"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum water that can be trapped between the buildings after raining. :param height: List[int] - List of non-negative integers representing the heights of buildings. :return: int - Total amount of trapped rainwater. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 from solution import trap def test_example1(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_example2(): assert trap([4,2,0,3,2,5]) == 9 def test_no_trap(): assert trap([1,2,3,4,5]) == 0 # All heights are in increasing order, no water can be trapped def test_single_building(): assert trap([4]) == 0 # Only one building, no water can be trapped def test_two_buildings(): assert trap([4,1]) == 0 # Only two buildings, no water can be trapped def test_all_equal_height(): assert trap([3,3,3,3,3]) == 0 # All buildings of same height def test_large_input(): input_height = [0] * 1000 + [1] * 1000 + [0] * 1000 assert trap(input_height) == 0 # Long flat surface with height 0, no water can be trapped","solution":"def trap(height): Calculate the maximum water that can be trapped between the buildings. :param height: List[int] - List of non-negative integers representing the heights of buildings. :return: int - Total amount of trapped rainwater. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"def shortest_path(t: int, datasets: List[Tuple[int, int]]) -> List[str]: Determines the shortest path on a circular running track. If distances are equal, prefers the clockwise direction. Args: t (int): Number of datasets. datasets (list of tuples): Each tuple contains two integers, a and b. Returns: list: List of strings, each string representing the path of checkpoints. >>> shortest_path(3, [(3, 7), (6, 2), (8, 8)]) ['3 4 5 6 7', '6 5 4 3 2', '8'] >>> shortest_path(1, [(5, 5)]) ['5'] >>> shortest_path(3, [(0, 11), (11, 1), (9, 3)]) ['0 11', '11 0 1', '9 10 11 0 1 2 3']","solution":"def shortest_path(t, datasets): Determines the shortest path on a circular running track. If distances are equal, prefers the clockwise direction. Args: t (int): Number of datasets. datasets (list of tuples): Each tuple contains two integers, a and b. Returns: list: List of strings, each string representing the path of checkpoints. results = [] for a, b in datasets: if a == b: results.append(str(a)) continue clockwise = [] counter_clockwise = [] i = a while i != b: clockwise.append(i) i = (i + 1) % 12 clockwise.append(b) i = a while i != b: counter_clockwise.append(i) i = (i - 1) % 12 if i != 0 else 11 counter_clockwise.append(b) if len(clockwise) <= len(counter_clockwise): results.append(' '.join(map(str, clockwise))) else: results.append(' '.join(map(str, counter_clockwise))) return results"},{"question":"def maxDistinctSubstrings(s: str, k: int) -> int: Returns the maximum number of distinct substrings of length k in the string s. >>> maxDistinctSubstrings(\\"abcabcab\\", 3) 3 >>> maxDistinctSubstrings(\\"aaaaa\\", 2) 1 >>> maxDistinctSubstrings(\\"abcdef\\", 2) 5 >>> maxDistinctSubstrings(\\"abababab\\", 2) 2","solution":"def maxDistinctSubstrings(s, k): Returns the maximum number of distinct substrings of length k in the string s. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return len(substrings)"},{"question":"def rearrange(arr): Rearranges the array in an alternating pattern of positive and negative numbers. If there are extra positive or negative numbers, they are appended at the end. The relative order of positive and negative numbers is maintained. pass from solution import rearrange def test_example_1(): assert rearrange([1, 2, 3, -4, -1, 4]) == [-4, 1, -1, 2, 3, 4] def test_example_2(): assert rearrange([-5, -2, 5, 2, 4, 7, 1, 8, 0, -8]) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0] def test_all_positive(): assert rearrange([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_all_negative(): assert rearrange([-1, -2, -3, -4, -5]) == [-1, -2, -3, -4, -5] def test_same_number_of_pos_and_neg(): assert rearrange([1, -1, 2, -2, 3, -3]) == [-1, 1, -2, 2, -3, 3] def test_more_negatives(): assert rearrange([4, -1, -2, -3, -4, 5]) == [-1, 4, -2, 5, -3, -4] def test_more_positives(): assert rearrange([-1, -2, 3, 4, 5, 6]) == [-1, 3, -2, 4, 5, 6] def test_empty_input(): assert rearrange([]) == [] def test_one_element_positive(): assert rearrange([1]) == [1] def test_one_element_negative(): assert rearrange([-1]) == [-1]","solution":"def rearrange(arr): Rearranges the array in an alternating pattern of positive and negative numbers. If there are extra positive or negative numbers, they are appended at the end. The relative order of positive and negative numbers is maintained. pos = [x for x in arr if x >= 0] neg = [x for x in arr if x < 0] result = [] i = j = 0 min_len = min(len(pos), len(neg)) for k in range(2 * min_len): if k % 2 == 0: result.append(neg[i]) i += 1 else: result.append(pos[j]) j += 1 result.extend(pos[j:]) result.extend(neg[i:]) return result"},{"question":"def categorize_article(article_id: int, title: str, body: str) -> int: Categorize an article based on its title and body content. >>> categorize_article(1, \\"Understanding Habitats\\", \\"Forests are ecosystems that host a wide range of organisms, some of which are especially adapted to their environment.\\") 1 >>> categorize_article(2, \\"Traits of Carnivores\\", \\"Carnivorous animals feed on meat and are equipped with sharp teeth to kill and eat their prey.\\") 2 >>> categorize_article(3, \\"Diet of Herbivores\\", \\"Herbivores consume plant-based diets and rely on vegetation for sustenance.\\") 3 >>> categorize_article(4, \\"Habitat and Dietary Habits\\", \\"Animals in different ecosystems may be carnivorous or herbivorous depending on the availability of prey or plants.\\") 1 # or 2 or 3, as long as it's a valid category","solution":"def categorize_article(article_id, title, body): Categorize an article based on its title and body content. # Keywords related to each category category_keywords = { 1: [\\"habitat\\", \\"ecosystem\\", \\"environment\\"], 2: [\\"carnivore\\", \\"meat\\", \\"predator\\"], 3: [\\"herbivore\\", \\"plant\\", \\"vegetarian\\"] } content = f\\"{title} {body}\\".lower() category_scores = {1: 0, 2: 0, 3: 0} for category, keywords in category_keywords.items(): for keyword in keywords: if keyword in content: category_scores[category] += content.count(keyword) # Determine the category with the highest score best_category = max(category_scores, key=category_scores.get) return best_category"},{"question":"def find_min_common_stops(test_cases: int, n_values: List[int]) -> List[List[int]]: Compute the minimum bus stop number that is reachable by at least two different buses for each bus number i in the range 1 to n. >>> find_min_common_stops(1, [3]) [[2, 4, 6]] >>> find_min_common_stops(2, [2, 4]) [[2, 4], [2, 4, 6, 8]]","solution":"def find_min_common_stops(test_cases, n_values): results = [] for n in n_values: result = [] for i in range(1, n + 1): result.append(i * 2) results.append(result) return results"},{"question":"def max_length_unique_substring(s: str) -> int: Returns the maximum length of a substring that contains all unique characters. >>> max_length_unique_substring(\\"abcabcbb\\") 3 >>> max_length_unique_substring(\\"bbbbb\\") 1 >>> max_length_unique_substring(\\"pwwkew\\") 3 >>> max_length_unique_substring(\\"abcdef\\") 6 >>> max_length_unique_substring(\\"aab\\") 2","solution":"def max_length_unique_substring(s): Returns the maximum length of a substring that contains all unique characters. start = 0 max_length = 0 char_index_map = {} for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"import math from typing import List, Tuple def gcd_of_unblocked_intersections(n: int, m: int, k: int, blocked: List[Tuple[int, int]]) -> int: Calculate the greatest common divisor (GCD) of the numbers associated with all unblocked intersections in Gridville. Args: n (int): Number of rows in Gridville. m (int): Number of columns in Gridville. k (int): Number of blocked intersections. blocked (List[Tuple[int, int]]): List of blocked intersections represented by tuples (r, c) where 1 <= r <= n and 1 <= c <= m. Returns: int: The GCD of the numbers associated with all unblocked intersections. >>> gcd_of_unblocked_intersections(3, 3, 2, [(2, 2), (3, 3)]) 1 >>> gcd_of_unblocked_intersections(4, 4, 1, [(2, 4)]) 1 def test_example_1(): n, m, k = 3, 3, 2 blocked = [(2, 2), (3, 3)] assert gcd_of_unblocked_intersections(n, m, k, blocked) == 1 def test_example_2(): n, m, k = 4, 4, 1 blocked = [(2, 4)] assert gcd_of_unblocked_intersections(n, m, k, blocked) == 1 def test_no_blocked_intersections(): n, m, k = 2, 2, 0 blocked = [] assert gcd_of_unblocked_intersections(n, m, k, blocked) == 1 def test_all_intersections_blocked(): n, m, k = 3, 3, 9 blocked = [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)] assert gcd_of_unblocked_intersections(n, m, k, blocked) == 0 def test_single_blocked_intersection(): n, m, k = 3, 3, 1 blocked = [(1, 1)] assert gcd_of_unblocked_intersections(n, m, k, blocked) == 1 def test_large_grid_some_blocks(): n, m, k = 10, 10, 3 blocked = [(2, 2), (5, 5), (7, 7)] assert gcd_of_unblocked_intersections(n, m, k, blocked) == 1","solution":"import math def gcd_of_unblocked_intersections(n, m, k, blocked): blocked_set = set((r, c) for r, c in blocked) gcd_all = None for i in range(1, n + 1): for j in range(1, m + 1): if (i, j) not in blocked_set: val = i * j if gcd_all is None: gcd_all = val else: gcd_all = math.gcd(gcd_all, val) return gcd_all if gcd_all is not None else 0"},{"question":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepest_node(root): Given the root node of a binary tree, return the value of the deepest (i.e., the bottom-most, right-most) node in the tree. >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, None, TreeNode(6, None, TreeNode(7)))) >>> deepest_node(root) 7 >>> deepest_node(None) None >>> root = TreeNode(1) >>> deepest_node(root) 1","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepest_node(root): Given the root of a binary tree, return the value of the deepest (right-most) node. if not root: return None # handle the case when the tree is empty queue = deque([root]) # use a queue to perform BFS node = None while queue: node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return node.value if node else None"},{"question":"def count_identical_subarrays(n: int, array: List[int]) -> int: Given the number of elements in an array and the array itself, this function returns the number of distinct subarrays where all elements are the same. Example usage: >>> count_identical_subarrays(5, [1, 2, 2, 3, 3]) 7 >>> count_identical_subarrays(4, [4, 4, 4, 4]) 10","solution":"def count_identical_subarrays(n, array): count = 0 i = 0 while i < n: length = 1 while i + 1 < n and array[i] == array[i + 1]: length += 1 i += 1 count += length * (length + 1) // 2 i += 1 return count # Sample Inputs to manually verify solution # print(count_identical_subarrays(5, [1, 2, 2, 3, 3])) # Should return 7 # print(count_identical_subarrays(4, [4, 4, 4, 4])) # Should return 10"},{"question":"def trailing_zeros(n: int) -> int: Calculate the number of trailing zeros in the factorial of a given number n. Parameters: n (int): The number to calculate the factorial for (0 <= n <= 10000). Returns: int: The count of trailing zeros in the factorial of n. Examples: >>> trailing_zeros(5) 1 >>> trailing_zeros(10) 2 >>> trailing_zeros(20) 4","solution":"def trailing_zeros(n): Returns the number of trailing zeros in the factorial of the given number n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"def can_arrange_flowers(n, m, flowers, vases): Determines if it is possible to arrange the flowers so that each vase's fragrance threshold is not exceeded. Parameters: - n (int): Number of flowers. - m (int): Number of vases. - flowers (list of int): Fragrance values of the flowers. - vases (list of int): Fragrance thresholds of the vases. Returns: - str: \\"YES\\" if arrangement is possible, \\"NO\\" otherwise. Examples: >>> can_arrange_flowers(4, 3, [3, 8, 5, 6], [10, 15, 12]) \\"YES\\" >>> can_arrange_flowers(3, 2, [5, 10, 7], [12, 10]) \\"NO\\"","solution":"def can_arrange_flowers(n, m, flowers, vases): Determines if it is possible to arrange the flowers so that each vase's fragrance threshold is not exceeded. Parameters: n (int): Number of flowers m (int): Number of vases flowers (list of int): Fragrance values of the flowers vases (list of int): Fragrance thresholds of the vases Returns: str: \\"YES\\" if arrangement is possible, \\"NO\\" otherwise flowers.sort(reverse=True) vases.sort(reverse=True) for flower in flowers: placed = False for i in range(len(vases)): if vases[i] >= flower: vases[i] -= flower placed = True break if not placed: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def alternate_largest_smallest(arr: List[int]) -> List[int]: Rearranges the elements of the array to alternate between the largest and smallest elements remaining in the array, starting with the largest. Examples: >>> alternate_largest_smallest([3, 1, 2, 4]) [4, 1, 3, 2] >>> alternate_largest_smallest([5, 2, 9, 1, 5, 6]) [9, 1, 6, 2, 5, 5] >>> alternate_largest_smallest([1]) [1]","solution":"def alternate_largest_smallest(arr): Rearranges the elements of the array to alternate between the largest and smallest elements remaining in the array, starting with the largest. arr.sort() left, right = 0, len(arr) - 1 result = [] while left <= right: if left == right: result.append(arr[right]) else: result.append(arr[right]) result.append(arr[left]) left += 1 right -= 1 return result"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},P={class:"search-container"},j={class:"card-container"},C={key:0,class:"empty-state"},F=["disabled"],I={key:0},D={key:1};function M(n,e,u,m,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",P,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",j,[(s(!0),r(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",C,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",D,"Loading...")):(s(),r("span",I,"See more"))],8,F)):l("",!0)])}const z=c(E,[["render",M],["__scopeId","data-v-cfcd2326"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/65.md","filePath":"grok/65.md"}'),O={name:"grok/65.md"},G=Object.assign(O,{setup(n){return(e,u)=>(s(),r("div",null,[w(z)]))}});export{Y as __pageData,G as default};
