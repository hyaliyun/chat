import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},A={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const O=c(k,[["render",E],["__scopeId","data-v-5fb4ee7d"]]),N=JSON.parse('[{"question":"You are tasked with writing a function called `enhanced_bubble_sort` which sorts a list of integers using a modified version of the bubble sort algorithm. This enhanced version should include: 1. Early termination if the array becomes sorted before completing all passes. 2. A simulation mode that prints out the array after every pass, showing the progress of the sorting algorithm. Function Signature: ```python def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input * `arr`: A list of integers (1 ≤ len(arr) ≤ 1000, -1000 ≤ arr[i] ≤ 1000). * `simulation`: A boolean flag indicating whether to print the array after each pass. # Output * The function should return the sorted list of integers in ascending order. # Constraints * Optimize to terminate early if no swaps are needed in a pass. * Ensure the function can handle edge cases such as an empty list or a list already in sorted order efficiently. # Example ```python assert enhanced_bubble_sort([64, 34, 25, 12, 22, 11, 90], True) == [11, 12, 22, 25, 34, 64, 90] ``` Expected output with `simulation=True`: ``` Pass 0: [34, 25, 12, 22, 11, 64, 90] Pass 1: [25, 12, 22, 11, 34, 64, 90] Pass 2: [12, 22, 11, 25, 34, 64, 90] Pass 3: [12, 11, 22, 25, 34, 64, 90] Pass 4: [11, 12, 22, 25, 34, 64, 90] ``` # Notes * If `simulation` is `True`, print the array with format `Pass X: <array>` after each pass where `X` is the pass number starting from 0. * Ensure the function works for all edge cases and optimizes performance by terminating early if the array becomes sorted.","solution":"from typing import List def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for pass_num in range(n): swapped = False for i in range(n - 1 - pass_num): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if simulation: print(f\\"Pass {pass_num}: {arr}\\") if not swapped: break return arr"},{"question":"# Problem: You\'re given two integers, `low` and `high`, which define a range `[low, high]` (inclusive). Write a function `sum_dig_pow(low: int, high: int) -> List[int]` to find all numbers in this range such that the number is equal to the sum of its digits raised to consecutive powers from left to right. # Input: * `low` (an integer where 1 <= low <= high <= 10000) - Start of the range (inclusive). * `high` (an integer where low <= high <= 10000) - End of the range (inclusive). # Output: * A list of integers that meet the specified property within the range. # Constraints: * The function should return a list of such numbers or an empty list if there are no such numbers. * Ensure the solution is optimized to handle the maximum constraint efficiently. # Example 1: ```plaintext Input: low = 1, high = 10 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Example 2: ```plaintext Input: low = 50, high = 150 Output: [89, 135] ``` # Example 3: ```plaintext Input: low = 90, high = 100 Output: [] ``` # Explanation: 1. For the number 89: - 8^1 + 9^2 = 8 + 81 = 89, hence valid. 2. For the number 135: - 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135, hence valid. Your task is to implement the `sum_dig_pow` function to achieve the desired functionality.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: Finds all numbers in the range [low, high] such that the number is equal to the sum of its digits raised to consecutive powers from left to right. def is_valid_number(num: int) -> bool: str_num = str(num) sum_dig_pow = sum(int(str_num[i]) ** (i + 1) for i in range(len(str_num))) return sum_dig_pow == num return [num for num in range(low, high + 1) if is_valid_number(num)]"},{"question":"# Graph Traversal Challenge You are tasked with implementing two fundamental graph traversal algorithms: Depth-First Search (DFS) and Breadth-First Search (BFS). Given a graph represented as an adjacency list and a starting node, your task is to implement both traversals and return the list of nodes in the order they were visited. # Input - A graph represented as a dictionary where keys are nodes, and values are lists of connected nodes. - A starting node which is guaranteed to be a key in the graph. # Output - Two lists: One containing the order of nodes visited by DFS, and the other containing the order visited by BFS. # Constraints - The graph does not contain self-loops or multiple edges between the same nodes. - All node values are unique integers. - The graph may be disconnected. - The graph contains at most 1000 nodes and 10000 edges. # Performance Requirements - Must handle the upper limits of the constraints efficiently. - DFS iteration and recursion should both handle deep graph structures without performance degradation. # Example ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } start_node = 2 dfs_order = dfs_traverse(graph, start_node) bfs_order = bfs_traverse(graph, start_node) print(\\"DFS Order:\\", dfs_order) print(\\"BFS Order:\\", bfs_order) ``` # Expected Output ``` DFS Order: [2, 0, 1, 3] BFS Order: [2, 0, 3, 1] ``` # Task Implement the following functions: ```python def dfs_traverse(graph, start): Return the list of nodes in the order they are visited by depth-first search. pass def bfs_traverse(graph, start): Return the list of nodes in the order they are visited by breadth-first search. pass ```","solution":"def dfs_traverse(graph, start): Return the list of nodes in the order they are visited by depth-first search. visited = [] def dfs(node): if node not in visited: visited.append(node) for neighbor in graph.get(node, []): dfs(neighbor) dfs(start) return visited def bfs_traverse(graph, start): Return the list of nodes in the order they are visited by breadth-first search. visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(neighbor for neighbor in graph.get(node, []) if neighbor not in visited) return visited"},{"question":"# Coding Challenge You are tasked with implementing a function to match strings against given patterns with support for special characters. This function should adopt a dynamic programming approach to ensure efficient and comprehensive matching. Function Signature ```python def is_match(s: str, p: str) -> bool: Determine if the given input string matches the pattern string with special characters \'.\' and \'*\'. Args: s : str : Input string. p : str : Pattern string containing \'.\' and \'*\'. Returns: bool : True if \'s\' matches pattern \'p\', otherwise False. ``` Input - `s` (string): The input string, containing only lowercase alphabets. - `p` (string): The pattern string, which may contain lowercase alphabets, \'.\' and/or \'*\'. Output - Returns `True` if the input string `s` matches the full pattern `p`, otherwise returns `False`. Examples ```python print(is_match(\\"aa\\", \\"a\\")) # Expected Output: False print(is_match(\\"aa\\", \\"aa\\")) # Expected Output: True print(is_match(\\"aaa\\", \\"aa\\")) # Expected Output: False print(is_match(\\"aa\\", \\"a*\\")) # Expected Output: True print(is_match(\\"aa\\", \\".*\\")) # Expected Output: True print(is_match(\\"ab\\", \\".*\\")) # Expected Output: True print(is_match(\\"aab\\", \\"c*a*b\\")) # Expected Output: True ``` Constraints - Both `s` and `p` will contain at most 1000 characters. - Characters in both strings will be lowercase letters or special characters (in `p` only). Evaluation Criteria - Correctness and completeness of the implementation. - Efficient handling of edge cases and performance concerns. - Clarity and readability of the code. Develop an efficient and accurate solution that demonstrates your understanding of dynamic programming and its application in regular expression matching.","solution":"def is_match(s: str, p: str) -> bool: Determine if the given input string matches the pattern string with special characters \'.\' and \'*\'. Args: s : str : Input string. p : str : Pattern string containing \'.\' and \'*\'. Returns: bool : True if \'s\' matches pattern \'p\', otherwise False. # dp[i][j] will be True if the first i characters in s match the first j characters in p dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: both s and p are empty dp[0][0] = True # Handle patterns with \'*\' at the beginning for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Populate the dp table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \'.\')) return dp[len(s)][len(p)]"},{"question":"# Plus-One Algorithm Implementation You are provided with an array of non-negative integers representing a non-negative number in big-endian format. Each element in the array corresponds to a digit, with the most significant digit at the head of the array. Your task is to implement a function that takes this array and returns a new array that represents the number after adding one. Assume there are no leading zeros except the number 0 itself. Input - A list of integers (0 <= digits[i] <= 9) representing a non-negative integer. - The length of this list is between 1 and 1000. Output - A list of integers representing the input number incremented by one. Constraints - Do not use built-in functions that directly convert the array to an integer and back to an array. - Performance: Aim for efficient O(n) time complexity and O(1) extra space complexity. Example Scenarios 1. **Example 1:** - **Input:** [1, 2, 3] - **Output:** [1, 2, 4] 2. **Example 2:** - **Input:** [4, 3, 2, 1] - **Output:** [4, 3, 2, 2] 3. **Example 3:** - **Input:** [9] - **Output:** [1, 0] 4. **Example 4:** - **Input:** [9, 9, 9] - **Output:** [1, 0, 0, 0] Implement the function: ```python def plus_one(digits): :type digits: List[int] :rtype: List[int] # Write your function implementation here ``` Ensure your implementation accurately considers the carry-over mechanism and handles number overflow by adding a new digit at the start when necessary.","solution":"def plus_one(digits): Increments the number represented by the list of digits by one. n = len(digits) # Traverse the list from the end to the beginning for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we are here, it means all the digits were 9 return [1] + [0] * n"},{"question":"# Question: Advanced Caesar Cipher Implementation You are provided with a function to encrypt a given string using a Caesar Cipher. While it correctly encrypts text, it does not handle the scenario of decrypting the text. Your task is to extend the functionality by implementing a function `caesar_cipher_advanced` that not only encrypts text with a given shift but can also decrypt it. Additionally, ensure that it preserves case sensitivity and ignores non-alphabetic characters, leaving them unchanged. Function Signature ```python def caesar_cipher_advanced(s: str, k: int, mode: str) -> str: pass ``` Input - `s` (str): The input string to encrypt or decrypt. - `k` (int): The shift key. It can be any integer (positive, negative, or zero). - `mode` (str): A string that can either be `\\"encrypt\\"` or `\\"decrypt\\"` to indicate the operation. Output - (str): The resulting string after either encryption or decryption. Constraints - The input string `s` can contain uppercase and lowercase English letters as well as non-alphabetic characters. - The shift key `k` can be any integer. - The `mode` can be either `\\"encrypt\\"` or `\\"decrypt\\"`. Performance Requirements - The function should have linear time complexity relative to the length of the string. - The function should operate with constant additional space. Examples 1. For input `s=\\"Hello, World!\\"`, `k=3`, and `mode=\\"encrypt\\"`, the output should be `\\"Khoor, Zruog!\\"`. 2. For input `s=\\"Khoor, Zruog!\\"`, `k=3`, and `mode=\\"decrypt\\"`, the output should be `\\"Hello, World!\\"`. Explanation - In the first example, each letter of \\"Hello, World!\\" is shifted by 3 positions in the alphabet. - In the second example, \\"Khoor, Zruog!\\" is shifted backward by 3 positions to restore the original text \\"Hello, World!\\". Implement the function considering the analysis above regarding the nuances of the Caesar Cipher.","solution":"def caesar_cipher_advanced(s: str, k: int, mode: str) -> str: def shift_char(c, shift): if c.isalpha(): start = ord(\'A\') if c.isupper() else ord(\'a\') return chr((ord(c) - start + shift) % 26 + start) return c if mode == \\"decrypt\\": k = -k return \'\'.join(shift_char(c, k) for c in s)"},{"question":"Scenario: Suppose you are tasked with designing a function to manipulate stock price data stored in a stack. This stack reflects real-time incoming stock prices, with the most recent price on the top. Your job is to create a function that will periodically remove the lowest stock price from the stack to help in quickly analyzing peak stock values. Task: Implement a function `remove_min(stack: list) -> list` that accepts a stack of integers representing stock prices and removes the smallest value, preserving the order of the remaining elements. Function Signature: ```python def remove_min(stack: list) -> list: ``` Input: * `stack`: A list of integers where the end of the list represents the top of the stack. Example: `[2, 8, 3, -6, 7, 3]`. Output: * The function should return a list (the modified stack) after removing the smallest value. Constraints: * If the stack is empty, it should return an empty list. * Ensure that only one occurrence of the minimum value is removed. * Do not use built-in functions for finding min value or directly manipulating stack behaviors. Performance Requirements: * The implemented algorithm must run in O(n) time complexity and use O(n) additional space. Example: ```python stack = [2, 8, 3, -6, 7, 3] output = remove_min(stack) print(output) # Output: [2, 8, 3, 7, 3] ``` You may assume all input values for the stock prices in the stack are integers.","solution":"def remove_min(stack: list) -> list: if not stack: return stack min_value = stack[0] for value in stack: if value < min_value: min_value = value new_stack = [] min_removed = False for value in stack: if value == min_value and not min_removed: min_removed = True else: new_stack.append(value) return new_stack"},{"question":"# Red-Black Tree Insert Validation As a part of maintaining a large dataset, you need to ensure that the Red-Black Tree properties are never violated when inserting new elements. You are tasked with implementing a function that inserts a new value into a Red-Black tree and ensures all the Red-Black properties are upheld. **Function Signature**: ```python def red_black_insert(root, value): pass ``` **Input & Output**: * **Input**: - `root`: root node of the Red-Black Tree (of type RBNode). - `value`: integer value to be inserted. * **Output**: - The root of the modified Red-Black Tree after insertion. **Constraints**: * Each node in the tree has a unique value. * The tree may initially be empty (`root` can be `None`). * The `value` to be inserted is an integer that doesn\'t already exist in the tree. **Performance Requirements**: * Ensure insert operation maintains O(log n) complexity. # Example: **Scenario**: You have the following Red-Black tree: ``` 11(B) / 2(R) 14(B) / 1(B) 7(B) 15(R) / 5(R) 8(R) ``` Inserting value `4` should result in: ``` 11(B) / 2(R) 14(B) / 1(B) 7(B) 15(R) / 5(R) 8(R) / 4(R) ``` Then necessary rotations and color adjustments will maintain the Red-Black properties. **Execution**: ```python tree_root = RBNode(11, 0, None, RBNode(2, 1), RBNode(14, 0, None, None, RBNode(15, 1))) red_black_insert(tree_root, 4) # Validate via in-order traversal and color properties check ``` Implement `red_black_insert` to handle node insertions respecting Red-Black Tree properties.","solution":"class RBNode: def __init__(self, value, color, parent=None, left=None, right=None): self.value = value self.color = color # 0 for black and 1 for red self.parent = parent self.left = left self.right = right def left_rotate(root, x): y = x.right x.right = y.left if y.left is not None: y.left.parent = x y.parent = x.parent if x.parent is None: root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y return root def right_rotate(root, y): x = y.left y.left = x.right if x.right is not None: x.right.parent = y x.parent = y.parent if y.parent is None: root = x elif y == y.parent.right: y.parent.right = x else: y.parent.left = x x.right = y y.parent = x return root def insert_fixup(root, z): while z.parent is not None and z.parent.color == 1: if z.parent == z.parent.parent.left: y = z.parent.parent.right if y is not None and y.color == 1: z.parent.color = 0 y.color = 0 z.parent.parent.color = 1 z = z.parent.parent else: if z == z.parent.right: z = z.parent root = left_rotate(root, z) z.parent.color = 0 z.parent.parent.color = 1 root = right_rotate(root, z.parent.parent) else: y = z.parent.parent.left if y is not None and y.color == 1: z.parent.color = 0 y.color = 0 z.parent.parent.color = 1 z = z.parent.parent else: if z == z.parent.left: z = z.parent root = right_rotate(root, z) z.parent.color = 0 z.parent.parent.color = 1 root = left_rotate(root, z.parent.parent) root.color = 0 return root def red_black_insert(root, value): new_node = RBNode(value, 1) # New node will be red y = None x = root while x is not None: y = x if new_node.value < x.value: x = x.left else: x = x.right new_node.parent = y if y is None: root = new_node elif new_node.value < y.value: y.left = new_node else: y.right = new_node return insert_fixup(root, new_node)"},{"question":"# Incrementing a Number Represented as an Array of Digits Objective You are provided with a scenario where you need to manage large numbers represented as arrays of digits. Your task is to increment the given number by one, handling carry-over and possible resizing of the list efficiently. Problem Write a function `increment_digits` that accepts a list of digits representing a non-negative integer, increments the integer by one, and returns the resulting list of digits. Input * `digits`: A list of integers where each element is a digit (0-9) of the number. The most significant digit is at the head of the list. Output * Return a list of integers representing the original number incremented by one. Constraints * The input list will be non-empty and contain only non-negative digits (0-9). Example ```python def increment_digits(digits): # Your code here # Example 1: # Input: [1, 2, 3] # Output: [1, 2, 4] # Example 2: # Input: [4, 3, 2, 1] # Output: [4, 3, 2, 2] # Example 3: # Input: [9, 9, 9] # Output: [1, 0, 0, 0] ``` Performance Requirements * Expected time complexity: O(n), where n is the number of digits in the input list. * Expected space complexity: O(1), ignoring the space required to store the input and output lists. Notes * Make sure to handle edge cases like lists containing all 9s ([9, 9, 9]) effectively. * Focus on clear, efficient carry-over logic to manage digit overflow.","solution":"def increment_digits(digits): Increments the number represented by the list of digits by one. Args: digits (list of int): List of digits representing the number. Returns: list of int: List of digits representing the incremented number. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + [0] * n"},{"question":"**Question**: You are given an array of integers and need to determine the mode(s) of this array. In probability and statistics, the mode is the value that appears most frequently in a data set. If there are multiple values that have the same highest frequency, return all of them in a list. **Function Signature**: ```python def find_modes(arr: List[int]) -> List[int]: ``` **Input**: - `arr` (List[int]): A list of integers representing the dataset. You may assume that the list has a maximum length of 10^5 elements. **Output**: - The function should return a list of integers that includes all mode(s). If the input array is empty, return an empty list. **Constraints**: - Example arrays and their modes: - `find_modes([1, 1, 2, 2, 3, 4])` should return `[1, 2]`. - `find_modes([4, 5, 6, 6, 7, 7, 7, 8, 8, 8])` should return `[7, 8]`. - `find_modes([])` should return `[]`. **Example**: ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([4, 5, 6, 6, 7, 7, 7, 8, 8, 8]) == [7, 8] assert find_modes([]) == [] ``` **Scenario**: You are developing a survey analysis tool that requires identifying the most popular options among respondents. To achieve this, you need to implement a function that can accurately and efficiently find the mode(s) of any given list of survey responses.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: Finds the mode(s) of a given list of integers. Args: arr: List[int]: A list of integers Returns: List[int]: A list of integers representing the mode(s) if not arr: return [] count = Counter(arr) max_frequency = max(count.values()) modes = [k for k, v in count.items() if v == max_frequency] return modes"},{"question":"You are provided with an array of integers. Write a Python function `optimized_exchange_sort` that sorts the array using an optimization over the traditional Exchange Sort. The optimization involves terminating early if the array is already sorted at any point during the iterations. Function Signature ```python def optimized_exchange_sort(arr: list[int]) -> list[int]: pass ``` Input - `arr`: A list of integers that needs to be sorted. Output - A list of integers, sorted in non-decreasing order. Constraints - The input list can have up to 10,000 elements. - Each integer in the list is between -10^6 and 10^6. Performance Requirements - Optimize the Exchange Sort to handle the best-case scenario of O(n) when the array is already sorted. # Example ```python assert optimized_exchange_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_exchange_sort([1, 2, 3, 4, 5, 6, 7]) == [1, 2, 3, 4, 5, 6, 7] assert optimized_exchange_sort([]) == [] assert optimized_exchange_sort([4]) == [4] assert optimized_exchange_sort([3, 3, 3]) == [3, 3, 3] ``` # Scenario Consider that you are building a low-resource embedded system where simplicity and low memory usage are critical, but dataset sizes can sometimes be relatively small.","solution":"def optimized_exchange_sort(arr: list[int]) -> list[int]: Sorts the array of integers using an optimized Exchange Sort. The optimization terminates the sorting early if the array is detected to be already sorted. n = len(arr) for i in range(n): swapped = False for j in range(n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# String Encoding and Decoding You are tasked with building a pair of functions to encode a list of strings into a single string, and then decode that string back into the original list of strings. This is often used in scenarios where a list of strings needs to be sent over a network, stored, or retrieved while maintaining the order and integrity of the original data. Function Specifications * **encode(strs: List[str]) -> str**: This function encodes a list of strings into a single string. * **decode(s: str) -> List[str]**: This function decodes a single string back into a list of original strings. Input and Output 1. **encode Function**: - **Input**: `strs` (List[str]) - A list of strings to be encoded. - **Output**: A single string that represents the encoded version of the list of strings. 2. **decode Function**: - **Input**: `s` (str) - A single string that has been encoded from a list of strings. - **Output**: A list of strings that represents the decoded version of the input string. Constraints - The list of strings may contain empty strings. - Assume the input list `strs` contains ASCII characters. Examples ```python # Example 1 strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) print(encoded_str) # Output might be \\"5:hello5:world\\" decoded_strs = decode(encoded_str) print(decoded_strs) # Output should be [\\"hello\\", \\"world\\"] # Example 2 strs = [\\"\\", \\"test\\", \\" \\"] encoded_str = encode(strs) print(encoded_str) # Output might be \\"0:4:test1: \\" decoded_strs = decode(encoded_str) print(decoded_strs) # Output should be [\\"\\", \\"test\\", \\" \\"] ``` Your task is to implement both **encode** and **decode** functions adhering to the above specifications and constraints. This will demonstrate understanding of string manipulation and handling edge cases effectively.","solution":"def encode(strs): Encodes a list of strings into a single string. Parameters: strs (List[str]): A list of strings to be encoded. Returns: str: A single string representing the encoded version of the list of strings. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string back into a list of original strings. Parameters: s (str): A single string that has been encoded from a list of strings. Returns: List[str]: A list of strings that represents the decoded version of the input string. strs = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) strs.append(s[j+1:j+1+length]) i = j + 1 + length return strs"},{"question":"# Question: Implement Optimized Median Heap Sort You are tasked with implementing a modified version of the Heap Sort algorithm. Instead of using only a max heap or min heap, you will use a combination of both to efficiently find the median value during the sorting process. Scenario: Given an array of integers, you need to: * Partition the array such that elements are divided into two heaps—a max heap for the first half and a min heap for the second half. * Repeatedly balance the heaps to find the median value. * Sort the entire array in ascending order using these median heap structures. Details: 1. **Input**: * An array of `n` integers, `arr` (`1 ≤ n ≤ 10^5`). 2. **Output**: * A list of integers representing the sorted order of the input array. * Print the median value after every insertion (for educational purposes, you will see the feedback on how the elements are balanced around the median). Constraints: * You must implement the solution using max heap and min heap, balancing them to maintain the median. * Example: * Input: [7, 1, 5, 3, 9, 2] * Output (Median values): [7, 4, 5, 4, 5, 4] * Output (Sorted Array): [1, 2, 3, 5, 7, 9] # Function Signature ```python def median_heap_sort(arr: List[int]) -> List[int]: pass def insert_to_heaps(max_heap: List[int], min_heap: List[int], value: int) -> float: pass ``` # Task: 1. **median_heap_sort(arr)**: Implement this function to perform the median heap sort using the provided `insert_to_heaps` helper function. 2. **insert_to_heaps(max_heap, min_heap, value)**: Implement this helper function to manage the insertion and balancing of elements in the heaps, ensuring the median is efficiently maintained. Expected Performance: * Time Complexity: O(n log n) * Space Complexity: O(n)","solution":"import heapq from typing import List def insert_to_heaps(max_heap: List[int], min_heap: List[int], value: int) -> float: if not max_heap or value <= -max_heap[0]: heapq.heappush(max_heap, -value) else: heapq.heappush(min_heap, value) if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) if len(max_heap) == len(min_heap): median = (-max_heap[0] + min_heap[0]) / 2 else: median = -max_heap[0] return median def median_heap_sort(arr: List[int]) -> List[int]: max_heap, min_heap = [], [] medians = [] sorted_arr = [] for value in arr: median = insert_to_heaps(max_heap, min_heap, value) medians.append(median) while max_heap: sorted_arr.append(-heapq.heappop(max_heap)) while min_heap: sorted_arr.append(heapq.heappop(min_heap)) sorted_arr.sort() print(\\"Medians:\\", medians) # Educational purpose print statement return sorted_arr"},{"question":"# Base Conversion Coding Challenge As part of a software engineering project, you are required to implement two functions to handle integer base conversions. Specifically, you need to write one function that converts an integer to a different base, and another function that converts a string representation in a given base back to an integer. Input Specifications: 1. **Function `int_to_base(num: int, base: int) -> str`:** - `num` (type: int): The integer to be converted. - `base` (type: int): The base to convert the integer to. - Output: A string representing the number in the given base. 2. **Function: `base_to_int(str_to_convert: str, base: int) -> int`:** - `str_to_convert` (type: str): The string representation of the number in the given base. - `base` (type: int): The base of the number representation. - Output: An integer which is the decimal equivalent of the string representation. Constraints: - The base will be a value between 2 and 36 inclusive. - The string `str_to_convert` will contain only valid characters for the given base. - Negative numbers must be correctly formatted with a leading \'-\' (for `int_to_base`). Example: ```plaintext int_to_base(5, 2) -> \'101\' int_to_base(-5, 2) -> \'-101\' base_to_int(\'101\', 2) -> 5 base_to_int(\'-101\', 2) -> -5 base_to_int(\'F\', 16) -> 15 ``` Notes: 1. You are not allowed to use built-in helper functions such as `int()` for conversions in `base_to_int`, implement the conversion manually. 2. You can assume that the input for `base_to_int` is valid according to the given base. Implement the functions `int_to_base` and `base_to_int` following the described specifications, taking care of edge cases and adhering to performance requirements.","solution":"def int_to_base(num: int, base: int) -> str: Convert an integer to a given base and return it as a string. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = \\"\\" while num > 0: remainder = num % base result = digits[remainder] + result num //= base if negative: result = \\"-\\" + result return result def base_to_int(str_to_convert: str, base: int) -> int: Convert a string representation of a number in a given base to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = str_to_convert.startswith(\'-\') if negative: str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: value = digits.index(char) result = result * base + value if negative: result = -result return result"},{"question":"**Question**: You are required to implement a function that determines the length of a digit sequence for a given integer. This is important for understanding how many characters a number would occupy on a digital display. Implement the function `num_digits(n)` which: * Takes in an integer `n` (which can be positive, negative, or zero). * Returns the number of digits in the integer. # Input - An integer `n` where: -10^12 ≤ n ≤ 10^12 # Output - An integer representing the count of digits in the input number. # Examples ```python print(num_digits(1234)) # Output: 4 print(num_digits(-567)) # Output: 3 print(num_digits(0)) # Output: 1 print(num_digits(1000000)) # Output: 7 ``` # Constraints * The input number will be confined within the range, ensuring no overflow issues. * Floating-point numbers or non-numeric inputs will not be tested, so handle only whole integers. * The solution should execute in constant time, O(1). # Context This function can be used in scenarios such as digital clocks, counters, or any display mechanisms where understanding the magnitude of a number in terms of its digits is crucial.","solution":"def num_digits(n): Returns the number of digits in the integer n. return len(str(abs(n)))"},{"question":"# Question Implement the Cocktail Shaker Sort algorithm explained below, and then use this implemention to sort the provided list of numbers. # Instructions 1. Implement the function `cocktail_shaker_sort(arr)` which sorts an array of integers in ascending order using the Cocktail Shaker Sort algorithm. 2. The input will be a list of integers. Ensure that the list is not altered outside the function call. 3. Return the sorted list of integers. # Constraints * The list can contain positive, negative, and zero values. * The length of the list (n) will be such that `1 ≤ n ≤ 10^4`. # Example ```python cocktail_shaker_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) # Expected output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] cocktail_shaker_sort([]) # Expected output: [] cocktail_shaker_sort([1]) # Expected output: [1] cocktail_shaker_sort([-2, 45, 0, 11, -9]) # Expected output: [-9, -2, 0, 11, 45] ``` # Performance Guidance - Ensure your implementation handles the constraints efficiently though the worst-case time complexity is O(n^2). - Handle edge cases such as an empty list or a single-element list gracefully.","solution":"def cocktail_shaker_sort(arr): Sorts an array using the Cocktail Shaker Sort algorithm. Parameters: arr (list of int): The list of integers to be sorted. Returns: list of int: The sorted list of integers. n = len(arr) swapped = True start = 0 end = n - 1 while swapped: # Reset swapped to false swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, then array is sorted if not swapped: break # Otherwise, reset the swapped flag so that it can be used in the next stage swapped = False # Move the end point back by one, because the item at the end is in correct position end = end - 1 # Backward pass for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Move the start point forward by one, because the item at the start is in correct position start = start + 1 return arr"},{"question":"# Missing Ranges Coding Assessment Question Context You have been tasked with developing a feature for identifying missing elements in sequences within specified bounds. Given an array of sorted integers, you need to identify the ranges of missing values between a given lower bound and an upper bound. Task Write a function `missing_ranges(arr, lo, hi)` that finds and returns the missing ranges between the lower bound `lo` and the upper bound `hi` in the given sorted array `arr`. Input - `arr` (List[int]): A sorted list of distinct integers. - `lo` (int): The lower bound (inclusive). - `hi` (int): The upper bound (inclusive). Output - Returns a list of tuples. Each tuple represents a range (inclusive) of missing numbers. If there are no missing numbers, return an empty list. Constraints - The elements in `arr` are distinct. - `lo` <= `hi` - Elements of `arr` lie within the range `[lo, hi]`. Performance Requirements - Your solution should have linear time complexity, O(n) where n is the length of the input array. Example ```python # Input arr = [3, 5, 9] lo = 1 hi = 10 # Output missing_ranges(arr, lo, hi) => [(1, 2), (4, 4), (6, 8), (10, 10)] ``` Edge Cases - If the input array is empty, the result should be a single range from `lo` to `hi`. For example: ```python missing_ranges([], 1, 10) => [(1, 10)] ``` - If there are no missing ranges because the array covers every number within the bounds, return an empty list. For example: ```python missing_ranges([1, 2, 3, 4], 1, 4) => [] ``` Implement the `missing_ranges` function in Python.","solution":"def missing_ranges(arr, lo, hi): Finds the missing ranges between lo and hi in the sorted array arr. Parameters: arr (List[int]): A sorted list of distinct integers. lo (int): The lower bound (inclusive). hi (int): The upper bound (inclusive). Returns: List[Tuple[int, int]]: A list of tuples representing the missing ranges. result = [] prev = lo - 1 # Initialize previous to one less than the lower bound for num in arr: if num - prev > 1: result.append((prev + 1, num - 1)) prev = num # Check the range between the last element of the array and the upper bound if hi - prev > 0: result.append((prev + 1, hi)) return result"},{"question":"# Problem: Implement an Autocomplete System using a Trie You are tasked with implementing an autocomplete system for a search engine. The system should be able to insert words, search for exact word matches, and return all possible completions given a prefix. # Requirements * Implement a class `AutocompleteSystem` with the following methods: * `insert(word: str) -> None`: Inserts a word into the system. * `search(word: str) -> bool`: Searches for the exact word in the system and returns `True` if found, otherwise `False`. * `autocomplete(prefix: str) -> List[str]`: Returns a list of all words in the system that start with the given prefix. If no words are found, return an empty list. # Input and Output Formats * `insert(word: str) -> None`: Inserts a word consisting of lowercase letters `a-z`. * `search(word: str) -> bool`: Returns `True` if the word exists in the system, otherwise `False`. * `autocomplete(prefix: str) -> List[str]`: Given a prefix, return a list of all words in the system that start with the prefix. # Constraints * Assume all inputs consist of lowercase letters from `a` to `z`. * The length of each word and prefix does not exceed 100. * The total number of words inserted will not exceed 10^5. # Performance Requirements * The implementation should be efficient in terms of both time and space complexity. # Example Scenario ```python # Instantiating the AutocompleteSystem system = AutocompleteSystem() # Inserting words into the system system.insert(\\"hello\\") system.insert(\\"hi\\") system.insert(\\"hey\\") system.insert(\\"hero\\") system.insert(\\"happy\\") # Searching words print(system.search(\\"hello\\")) # Output: True print(system.search(\\"hel\\")) # Output: False # Autocompleting prefixes print(system.autocomplete(\\"he\\")) # Output: [\\"hello\\", \\"hey\\", \\"hero\\"] print(system.autocomplete(\\"ha\\")) # Output: [\\"happy\\"] print(system.autocomplete(\\"ho\\")) # Output: [] ``` # Implementation ```python import collections from typing import List class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word: str) -> bool: current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def autocomplete(self, prefix: str) -> List[str]: current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return [] result = [] self.dfs(current, prefix, result) return result def dfs(self, node, prefix, result): if node.is_word: result.append(prefix) for letter, child_node in node.children.items(): self.dfs(child_node, prefix + letter, result) ```","solution":"import collections from typing import List class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word: str) -> bool: current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def autocomplete(self, prefix: str) -> List[str]: current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return [] result = [] self.dfs(current, prefix, result) return result def dfs(self, node, prefix, result): if node.is_word: result.append(prefix) for letter, child_node in node.children.items(): self.dfs(child_node, prefix + letter, result)"},{"question":"# Linked List: Finding the k-th to Last Element Scenario You are given a singly linked list and tasked with finding the k-th to last element. Your colleague has shared three different methods, each with its strengths and weaknesses. Your task is to improve the approach to finding the k-th to last element reliably and efficiently. # Problem Improve upon the `kth_to_last_eval` method. Specifically: 1. Ensure the solution is safe. 2. Make sure it is efficient in terms of both time and space complexity. 3. Handle edge cases such as k out of bounds, and empty list scenarios. # Input & Output - **Input**: The head of a single linked list and an integer k (non-negative). - **Output**: Return the value of the k-th to last element, or `None` if k is out of range. # Function Signature ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def improved_kth_to_last(head: Node, k: int) -> Node: # Implement function pass ``` # Constraints 1. The methods should raise an IndexError if `k` is greater than the length of the list. 2. The methods should be efficient, `O(n)` in terms of time and `O(1)` in terms of space complexity. 3. You should take care of edge case scenarios (i.e., empty list or a `k` greater than the length of the list). # Example ```python # Example: # Consider the linked list: A -> B -> C -> D -> E # and let\'s find k=2 element from the end (which means we need to find 2nd to last element) a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e # should return Node with value \\"D\\" [4th element] assert improved_kth_to_last(a, 2).val == \\"D\\" # Testing k out of range try: improved_kth_to_last(a, 10) except IndexError: print(\\"Index error as expected\\") ```","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def improved_kth_to_last(head: Node, k: int) -> Node: if head is None: raise IndexError(\\"List is empty\\") slow = fast = head # Move fast pointer k steps ahead for _ in range(k): if not fast: raise IndexError(\\"k is greater than the length of the list\\") fast = fast.next # Move both pointers until fast is at the end of the list while fast: slow = slow.next fast = fast.next if not slow: raise IndexError(\\"k is greater than the length of the list\\") return slow"},{"question":"Scenario: As part of a new feature in your text editor, you intend to implement an auto-complete functionality for parentheses. The goal is to provide a list of all valid combinations of balanced parentheses given a number n. This will help users see all possible ways they can complete their currently opened parentheses. Task: Write a function named `generate_balanced_parentheses(n)` that generates all possible combinations of well-formed parentheses. Input: - An integer `n` where `1 <= n <= 8`, representing the number of pairs of parentheses. Output: - A list of strings, where each string represents a unique combination of well-formed parentheses. Constraints: 1. The total number of valid combinations follows Catalan numbers. 2. You are expected to implement an efficient solution both in terms of time and space. Performance Requirements: - The solution should handle the maximum input size effectively, without significant delays or memory issues. Examples: ```python assert generate_balanced_parentheses(1) == [\\"()\\"] assert generate_balanced_parentheses(2) == [\\"(())\\", \\"()()\\"] assert generate_balanced_parentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] ``` Notes: - Make sure you deeply test edge cases. - Consider and address performance bottlenecks and optimization methods during implementation.","solution":"def generate_balanced_parentheses(n): Returns a list of all possible combinations of well-formed parentheses. :param n: int - the number of pairs of parentheses :return: List[str] - list of strings representing well-formed parentheses combinations result = [] def backtrack(S=\'\', left=0, right=0): if len(S) == 2 * n: result.append(S) return if left < n: backtrack(S+\'(\', left+1, right) if right < left: backtrack(S+\')\', left, right+1) backtrack() return result"},{"question":"# Problem Description Implement a function `optimized_comb_sort` that improves on the Comb Sort algorithm provided by introducing dynamic gap adjustment based on the current array\'s state. # Function Signature ```python def optimized_comb_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` (0 ≤ len(arr) ≤ 10^5) where each integer is in the range [-10^6, 10^6]. # Output * A list of integers sorted in non-decreasing order. # Constraints * Focus on optimizing the average performance, potentially making use of dynamic gap calculations or integrating another sorting algorithm when a low gap is reached. # Examples ```python assert optimized_comb_sort([5, 3, 4, 8, 7, 2]) == [2, 3, 4, 5, 7, 8] assert optimized_comb_sort([1]) == [1] assert optimized_comb_sort([]) == [] assert optimized_comb_sort([10, -5, 0, -1, 20]) == [-5, -1, 0, 10, 20] ``` # Guidelines * Ensure the function handles edge cases such as empty arrays or arrays of length one gracefully. * Aim to keep the average time complexity as low as possible. * The solution should be self-contained and not depend on external libraries for sorting.","solution":"def optimized_comb_sort(arr): Sorts a list of integers using an optimized Comb Sort algorithm. if len(arr) <= 1: return arr gap = len(arr) shrink = 1.3 # Common shrink factor for Comb Sort sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True for i in range(len(arr) - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"You are given a 2D matrix represented as a list of lists in Python. Your task is to implement functions to transform this matrix as follows: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix with respect to the top-left corner. 4. Invert the matrix with respect to the bottom-left corner. # Function Specifications These are the functions you need to implement: 1. **rotate_clockwise(matrix)** * **Input**: A 2D list `matrix` where each element is a list of integers representing a row. * **Output**: A new 2D list representing the matrix rotated 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)** * **Input**: A 2D list `matrix` where each element is a list of integers representing a row. * **Output**: A new 2D list representing the matrix rotated 90 degrees counterclockwise. 3. **top_left_invert(matrix)** * **Input**: A 2D list `matrix` where each element is a list of integers representing a row. * **Output**: A new 2D list representing the matrix inverted with respect to the top-left corner. 4. **bottom_left_invert(matrix)** * **Input**: A 2D list `matrix` where each element is a list of integers representing a row. * **Output**: A new 2D list representing the matrix inverted with respect to the bottom-left corner. # Constraints * The input matrix will be non-empty and all rows will have the same length. * The size of the matrix will not exceed 1000x1000. # Example Given the input matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` 1. `rotate_clockwise(matrix)` should return: ```python [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] ``` 2. `rotate_counterclockwise(matrix)` should return: ```python [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` 3. `top_left_invert(matrix)` should return: ```python [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` 4. `bottom_left_invert(matrix)` should return: ```python [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` # Notes - Consider edge cases where the matrix could be a single row, single column, or a 1x1 matrix. - Make sure to handle cases where the matrix can contain negative integers and zero. Good luck!","solution":"def rotate_clockwise(matrix): Rotate the matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotate the matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Invert the matrix with respect to the top-left corner. return [row[::-1] for row in matrix[::-1]] def bottom_left_invert(matrix): Invert the matrix with respect to the bottom-left corner. return matrix[::-1]"},{"question":"# Context Network flow problems are fundamental in optimization and have various applications like network routing, resource allocation, and bipartite matching. The following question will test your understanding of maximum flow algorithms. # Problem Statement You are given a network graph represented by an NxN capacity matrix `capacity`, where `capacity[i][j]` holds the capacity of the edge from node `i` to node `j`. If there is no edge between nodes `i` and `j`, `capacity[i][j]` is zero. You need to compute the maximum possible flow from a source node `source` to a sink node `sink`. Write a function `max_flow(capacity: List[List[int]], source: int, sink: int) -> int` that implements the Dinic algorithm to compute the maximum flow from the given `source` to the given `sink`. # Input - `capacity`: A 2D list of integers, where `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. - `source`: An integer representing the source node. - `sink`: An integer representing the sink node. # Output - An integer representing the maximum flow from the source to the sink. # Constraints - 1 ≤ N ≤ 1000 (where N is the number of vertices in the graph). - 0 ≤ capacity[i][j] ≤ 10^9. - source and sink are valid indices for the graph. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(max_flow(capacity, source, sink)) # Output: 23 ``` # Notes - You are not allowed to use any in-built libraries for max-flow computations. - You should handle edge cases including no possible flow from source to sink, very large capacities, and graphs with many vertices and edges.","solution":"from collections import deque def bfs(level, capacity, source, sink): queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] < 0 and capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[sink] >= 0 def dfs(flow, capacity, current_node, sink, level, start): if current_node == sink: return flow while start[current_node] < len(capacity): v = start[current_node] if level[v] == level[current_node] + 1 and capacity[current_node][v] > 0: min_flow = min(flow, capacity[current_node][v]) pushed_flow = dfs(min_flow, capacity, v, sink, level, start) if pushed_flow > 0: capacity[current_node][v] -= pushed_flow capacity[v][current_node] += pushed_flow return pushed_flow start[current_node] += 1 return 0 def max_flow(capacity, source, sink): n = len(capacity) total_flow = 0 while True: level = [-1] * n if not bfs(level, capacity, source, sink): break start = [0] * n while True: flow = dfs(float(\'Inf\'), capacity, source, sink, level, start) if flow == 0: break total_flow += flow return total_flow"},{"question":"Context: You are working on a navigation system that needs to find the most profitable path through a network of connected hubs. Each hub has a profit associated with it, which can be negative or positive. Your task is to write a function that finds the maximum profit path in this network, represented as a binary tree. Function Definition: Write a Python function **max_profit_path_sum(root)** that takes as input the **root** of a binary tree where each node has an integer value representing the profit. The function should return the maximum sum of the profits obtainable by traveling along any path in the tree. Input: - `root`: A TreeNode object representing the root of a binary tree. TreeNode is a class defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - An integer representing the maximum sum of any path in the tree. Constraints: - The number of nodes in the tree is in the range [0, 10^4]. - `-1000 <= Node.val <= 1000` Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) print(max_profit_path_sum(root)) # Output: 6 root = TreeNode(-10) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(max_profit_path_sum(root)) # Output: 42 ``` Notes: - The input tree could be empty (i.e., root is None), in which case your function should return 0. - A path in the tree is defined as any sequence of nodes starting from and ending at any node in the tree following parent-child connections. - The path must contain at least one node, and does not need to go through the root.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_profit_path_sum(root): max_sum = float(\'-inf\') def max_gain(node): nonlocal max_sum if not node: return 0 # Recursively get the maximum gain from the left and right subtrees left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Price of the current path is the value of the current node plus the # maximum gain from each child price_newpath = node.val + left_gain + right_gain # Update the global maximum sum if the price of the new path is higher max_sum = max(max_sum, price_newpath) # For recursion, return the maximum gain including the current node. return node.val + max(left_gain, right_gain) max_gain(root) return max_sum if root else 0"},{"question":"# Coding Assessment: Implement a Modified Primality Test You are tasked with implementing a variation of the Rabin-Miller Primality Test algorithm. This variation requires you to consider a list of prime candidates and return a list of results indicating whether each candidate is probably prime or guaranteed composite. Function Details: * **Function Name**: `prime_candidates` * **Input**: * `candidates` (List[int]): A list of integers which we need to test for primality. * `k` (int): Number of iterations for the Rabin-Miller test, indicating the accuracy level. * **Output**: * (List[bool]): A list of boolean values where `True` implies the number is probably prime, and `False` implies the number is guaranteed composite. Constraints: * ( 2 leq k leq 100 ) * ( 2 leq text{candidates}[i] leq 10^{18} ) * Length of candidates list (leq 10^5) Performance Requirements: * The solution should handle each prime test in ( O(k cdot log^3 n) ) time complexity. * The solution should efficiently manage memory usage within the acceptable limits. Example: ```python # Expected: [True, True, False, True] print(prime_candidates([5, 7, 8, 23], 40)) # Expected: [False, True, False] print(prime_candidates([25, 17, 35], 50)) ``` # Instructions: 1. Implement the `prime_candidates` function. 2. Thoroughly test it with various cases to ensure accuracy and performance. 3. Consider edge cases, such as minimal and maximal values in `candidates`. 4. Prioritize clear, readable, and efficient code.","solution":"import random def is_probably_prime(n, k): Rabin-Miller Primality Test to check if a number is probably prime. # Base cases if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0: return False # Decompose n-1 as d * 2^r r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Witness loop for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def prime_candidates(candidates, k): Determine the primality of each number in the list of candidates using the Rabin-Miller Primality Test. results = [] for candidate in candidates: results.append(is_probably_prime(candidate, k)) return results"},{"question":"Finding Strongly Connected Components Using Kosaraju\'s Algorithm Problem Statement You are tasked with finding the strongly connected components (SCCs) of a directed graph using Kosaraju\'s algorithm. A strongly connected component is a maximal subgraph of a directed graph where there is a directed path from any node to every other node within the subgraph. Input - An integer V, representing the number of vertices (0-indexed). - An integer E, representing the number of edges. - A list of E pairs of integers (u, v), where u -> v denotes a directed edge from vertex u to vertex v. Output - An integer representing the number of strongly connected components in the graph. Constraints - 1 <= V <= 1000 - 0 <= E <= 2000 - 0 <= u, v < V Example **Input:** ``` 6 7 0 2 1 0 2 3 3 1 3 4 4 5 5 4 ``` **Output:** ``` 2 ``` Explanation The input graph has 2 strongly connected components: - The first SCC includes the nodes: 0, 1, 2, 3. - The second SCC includes the nodes: 4, 5. Instructions - Implement the function `def kosaraju(V: int, edge_list: List[Tuple[int, int]]) -> int:`. - You should use Kosaraju\'s algorithm to calculate the number of strongly connected components. - Ensure you handle edge cases such as isolated nodes and disconnected components effectively.","solution":"from typing import List, Tuple def kosaraju(V: int, edge_list: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque def dfs(v, visited, stack): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor, visited, stack) stack.append(v) def reverse_dfs(v, visited, transpose_graph): visited[v] = True for neighbor in transpose_graph[v]: if not visited[neighbor]: reverse_dfs(neighbor, visited, transpose_graph) # Step 1: Create the graph graph = defaultdict(list) for u, v in edge_list: graph[u].append(v) # Step 2: Order all vertices in the stack according to their finishing times visited = [False] * V stack = [] for i in range(V): if not visited[i]: dfs(i, visited, stack) # Step 3: Create the transposed graph transpose_graph = defaultdict(list) for u, v in edge_list: transpose_graph[v].append(u) # Step 4: Process all vertices in the order defined by the stack visited = [False] * V scc_count = 0 while stack: node = stack.pop() if not visited[node]: reverse_dfs(node, visited, transpose_graph) scc_count += 1 return scc_count"},{"question":"# Segment Tree Implementation and Queries # Context You are given the task to implement a segment tree to handle range queries efficiently. This segment tree should support various range queries such as sum, maximum, or minimum over a specified interval of indices in an array. # Objective Your objective is to implement the Segment Tree data structure to efficiently handle interval queries. # Instructions 1. Implement the `SegmentTree` class in Python with the following methods: - `__init__(self, arr, function)`: Initialize the segment tree with the given array and the function determining the type of query (sum, max, min). - `make_tree(self, i, l, r)`: Construct the tree given the array. - `__query(self, i, L, R, l, r)`: Internal method for querying the segment tree. - `query(self, L, R)`: Public method to query the range [L, R] using the segment tree. # Function Signatures: ```python class SegmentTree: def __init__(self, arr, function): pass def make_tree(self, i, l, r): pass def __query(self, i, L, R, l, r): pass def query(self, L, R): pass ``` # Example Scenario Given the array `[4, 5, 2, 3, 4, 43, 3]` and the function `sum`, initialize the segment tree and perform the following queries: - `query(1, 5)` should return `57` (5 + 2 + 3 + 4 + 43 = 57) - `query(0, 3)` should return `14` (4 + 5 + 2 + 3 = 14) # Constraints 1. The length of the array does not exceed 10^5. 2. The values in the array and the results of the function are integers. # Performance Requirements - Ensure that the `query` method operates in O(log N) time complexity. - Assume the segment tree only needs to support basic interval queries without dynamic updates. Implement the `SegmentTree` class and ensure it passes the provided example and adheres to the performance requirements.","solution":"class SegmentTree: def __init__(self, arr, function): Initialize the segment tree with the given array and the function for the query type. self.arr = arr self.function = function self.n = len(arr) self.tree = [0] * (4 * self.n) self.make_tree(0, 0, self.n - 1) def make_tree(self, i, l, r): Construct the segment tree given the array. if l == r: self.tree[i] = self.arr[l] else: mid = (l + r) // 2 self.make_tree(2 * i + 1, l, mid) self.make_tree(2 * i + 2, mid + 1, r) self.tree[i] = self.function(self.tree[2 * i + 1], self.tree[2 * i + 2]) def __query(self, i, L, R, l, r): Internal method for querying the segment tree. if L <= l and r <= R: return self.tree[i] if r < L or l > R: return None mid = (l + r) // 2 left_result = self.__query(2 * i + 1, L, R, l, mid) right_result = self.__query(2 * i + 2, L, R, mid + 1, r) if left_result is None: return right_result if right_result is None: return left_result return self.function(left_result, right_result) def query(self, L, R): Public method to query the range [L, R] using the segment tree. return self.__query(0, L, R, 0, self.n - 1)"},{"question":"# Priority Queue: Task Scheduling Simulation As a software engineer at a company building a task scheduling system, you are tasked with implementing a priority queue to manage tasks based on their priorities. Each task has a priority, and tasks with higher priorities should be executed before those with lower priorities. You need to implement the `PriorityQueue` class as described below: Class: PriorityQueue * **Methods**: 1. `__init__(self, items=None, priorities=None)`: Initializes the priority queue with given items and their respective priorities. 2. `size(self)`: Returns the size of the priority queue. 3. `push(self, item, priority=None)`: Pushes an item into the priority queue. If no priority is provided, the item itself is used as the priority. 4. `pop(self)`: Removes and returns the item with the highest priority. Implementation Constraints * The priority queue must use a linear array to store items. * Insertion complexity should be O(n). * Extraction complexity should be O(1). Example ```python # Initialize the priority queue with tasks and their priorities pq = PriorityQueue(items=[\\"task1\\", \\"task2\\", \\"task3\\"], priorities=[3, 2, 1]) # Push a new task into the priority queue pq.push(\\"task4\\", priority=4) # Get the size of the queue print(pq.size()) # Output: 4 # Pop the task with the highest priority print(pq.pop()) # Output: task4 ``` Note: 1. If `pop` is called on an empty queue, an exception should be raised. 2. Utilize classes `PriorityQueueNode` and `PriorityQueue`. Implement the `PriorityQueue` class with the methods described above.","solution":"class PriorityQueueNode: def __init__(self, item, priority): self.item = item self.priority = priority class PriorityQueue: def __init__(self, items=None, priorities=None): self.queue = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.queue) def push(self, item, priority=None): if priority is None: priority = item node = PriorityQueueNode(item, priority) i = len(self.queue) - 1 while i >= 0 and self.queue[i].priority < node.priority: i -= 1 self.queue.insert(i + 1, node) def pop(self): if not self.queue: raise IndexError(\\"Pop from an empty priority queue\\") return self.queue.pop(0).item"},{"question":"# Hailstone Sequence Analysis and Longest Sequence Finder Implement a function `find_longest_hailstone_sequence` that finds the integer within a given range `[low, high]` that generates the longest Hailstone sequence, and returns the starting integer, the length of the sequence, and the sequence itself. # Input: * Two integers, `low` and `high` such that `1 <= low <= high`. # Output: * A tuple containing three elements: 1. The integer within the range `[low, high]` that generates the longest Hailstone sequence. 2. The length of the longest Hailstone sequence. 3. The Hailstone sequence itself generated by the above integer. # Constraints: * The function must handle inputs where `1 <= low <= high <= 10^6`. * Performance should be reasonable within these constraints. # Example: ```python find_longest_hailstone_sequence(1, 10) ``` **Expected Output**: The integer `9`, which generates the longest Hailstone sequence of length `20` within the range `[1, 10]`, along with the sequence: `(9, 20, [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1])`. # Additional Notes: * You can utilize the provided `hailstone` function to generate individual sequences as required. * Consider edge cases where `low` equals `high` and handle large ranges efficiently.","solution":"def hailstone(n): Generate the Hailstone sequence starting from n. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 sequence.append(1) return sequence def find_longest_hailstone_sequence(low, high): Finds the integer within the range [low, high] that generates the longest Hailstone sequence. Parameters: - low (int): The lower bound of the range. - high (int): The upper bound of the range. Returns: A tuple containing: - The integer that generates the longest Hailstone sequence. - The length of the longest Hailstone sequence. - The Hailstone sequence itself. max_length = 0 number_with_max_length = low longest_sequence = [] for number in range(low, high + 1): sequence = hailstone(number) length = len(sequence) if length > max_length: max_length = length number_with_max_length = number longest_sequence = sequence return number_with_max_length, max_length, longest_sequence"},{"question":"# Context In data processing, it is sometimes necessary to rearrange lists to move specific placeholders (like zeros) to the end while preserving the order of the other elements. This is a common preprocessing step for subsequent analysis. # Task Implement a function `move_zeros` that rearranges the elements of an array such that all zeros are moved to the end. The order of non-zero elements must be maintained. Numeric zeros (`0`) and boolean `False` should be treated distinctly. # Function ```python def move_zeros(array: list) -> list: Rearrange the elements of `array` such that all zeros are moved to the end, while preserving the order of non-zero elements. Parameters: array (list): The input list that may contain various data types alongside numeric zeros. Returns: list: A new list with all zeros moved to the end. pass ``` # Input and Output * **Input**: A list `array` that can contain various types of elements. * **Output**: A new list with zeros moved to the end. # Constraints * Ensure numeric zeros (`0`) and boolean `False` are treated as distinct. * The input list can contain integers, floats, strings, booleans, and other objects. * The solution should handle lists up to size 10^6 within reasonable time and space limits. # Examples ```python move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # returns [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] move_zeros([0, 0, 0]) # returns [0, 0, 0] move_zeros([1, 2, 3]) # returns [1, 2, 3] move_zeros([False, \\"\\", 0, [], 1, 0.0, {}, 0, 0.0, 0]) # returns [False, \\"\\", [], 1, 0.0, {}, 0.0, 0, 0, 0] move_zeros([]) # returns [] ``` # Additional Notes Consider edge cases such as lists with no zeros, all zeros, and lists containing various types of elements. Ensure your solution handles large lists efficiently.","solution":"def move_zeros(array: list) -> list: Rearrange the elements of `array` such that all zeros are moved to the end, while preserving the order of non-zero elements. Parameters: array (list): The input list that may contain various data types alongside numeric zeros. Returns: list: A new list with all zeros moved to the end. non_zeros = [item for item in array if item is not 0 or type(item) == bool] zeros = [item for item in array if item is 0 and type(item) != bool] return non_zeros + zeros"},{"question":"You have been given an array of integers that you need to sort. Normally, you would use efficient algorithms like quicksort, mergesort, or heapsort. However, as a part of an educational exercise, you are required to implement Bogo Sort. Your task is to demonstrate your understanding of algorithmic efficiency by implementing Bogo Sort and comparing its performance in different scenarios. # Function Signature ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers to be sorted (1 ≤ len(arr) ≤ 10). The function should handle cases with both positive and negative integers. * `simulation` (bool): An optional flag. If set to `True`, the function prints the array at each iteration of shuffling. # Output * `result` (List[int]): The sorted list of integers. # Constraints * The length of the array will not exceed 10 elements to ensure the completion of the task in a reasonable time during testing. * The function must continue shuffling and checking until the array is sorted. # Performance Requirements * Given its inherent inefficiency, the Bogo Sort should be used with the understanding that it will be slow for arrays longer than those in the problem constraints. # Example ```python >>> arr = [3, 2, 4, 1] >>> bogo_sort(arr) [1, 2, 3, 4] >>> arr = [5, 1, 4, 2, 8] >>> bogo_sort(arr, True) iteration 0 : 5 1 4 2 8 iteration 1 : 8 1 5 4 2 iteration 2 : 8 5 1 2 4 ... iteration 12 : 1 2 4 5 8 [1, 2, 4, 5, 8] ``` # Notes * You should make sure to consider edge cases where the array is already sorted, contains duplicate values, or contains negative values. * Avoid using any pre-built sorting functions and focus on the implementation of Bogo Sort.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sort the array using the highly inefficient Bogo Sort algorithm. Optionally, print the array at each iteration of shuffling if simulation is set to True. Parameters: arr (List[int]): A list of integers to be sorted. simulation (bool): Optional flag to print the array at each iteration. Returns: List[int]: The sorted list of integers. iterations = 0 while not is_sorted(arr): if simulation: print(f\'iteration {iterations} : {\\" \\".join(map(str, arr))}\') random.shuffle(arr) iterations += 1 if simulation: print(f\'iteration {iterations} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Coding Challenge: Unique Character String Scenario You have been tasked with creating a utility for processing user inputs by removing reoccurring characters. Your solution should ensure that each character appears only once in the resultant string and in the order of their first appearance. Objective Write a function `remove_duplicates` that takes a single string as input and returns a new string with all reoccurring characters removed. Function Signature ```python def remove_duplicates(string: str) -> str: ``` Input - `string` (str): The input string which may contain any characters, including spaces. Output - Returns a string where each character appears only once in the order of their first appearance in the input string. Constraints - The length of the input string `string` is constrained to 1 <= len(string) <= 10^5. - The input string consists of printable ASCII characters. Example ```python assert remove_duplicates(\\"programming\\") == \\"progamin\\" assert remove_duplicates(\\"aabbcc\\") == \\"abc\\" assert remove_duplicates(\\"abcabcabc\\") == \\"abc\\" assert remove_duplicates(\\"\\") == \\"\\" ``` Notes - Focus on optimizing both time and space complexity considering the input constraints. - Consider edge cases where the input is an empty string or contains only unique characters.","solution":"def remove_duplicates(string: str) -> str: Removes reoccurring characters from the input string, ensuring each character appears only once and in the order of their first appearance. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You have been tasked with developing a more space-efficient version of the Sieve of Eratosthenes to generate all prime numbers less than a given integer `n`. The optimized sieve already excludes even numbers to save space and improve performance. You need to implement this sieve based on the given criteria. # Function Specification You need to implement the following function: ```python def get_primes(n): Return list of all primes less than n using the Sieve of Eratosthenes algorithm. Exclude even numbers to optimize the sieve. Args: n (int): A positive integer indicating the upper limit (exclusive). Returns: list: A list of all prime numbers less than n. ``` # Input - A single integer `n` (1 ≤ n ≤ 10^6). # Output - A list of prime numbers less than `n`. # Constraints - The function should raise a ValueError if `n` is less than 1. - The function should be optimized in terms of space and time, particularly aiming at `O(n log log n)` time complexity. # Example ```python >> get_primes(10) [2, 3, 5, 7] >> get_primes(1) [] >> get_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] ``` # Notes - Focus on reducing the space usage by excluding even numbers from the sieve. - Ensure your implementation handles edge cases such as `n = 1` or negative values appropriately. Good luck!","solution":"def get_primes(n): Return list of all primes less than n using the Sieve of Eratosthenes algorithm. Exclude even numbers to optimize the sieve. Args: n (int): A positive integer indicating the upper limit (exclusive). Returns: list: A list of all prime numbers less than n. if n <= 0: raise ValueError(\\"Input should be a positive integer greater than 0.\\") if n <= 2: return [] sieve = [True] * (n // 2) sieve[0] = False for i in range(1, int((n**0.5 + 1) // 2)): if sieve[i]: for j in range(2*i*(i+1), len(sieve), 2*i+1): sieve[j] = False primes = [2] + [2*i + 1 for i in range(1, len(sieve)) if sieve[i]] return primes"},{"question":"You are given a 2D grid initially filled with water (represented by 0). You receive a list of positions where land (represented by 1) will be added sequentially. An island is formed by connecting adjacent lands horizontally or vertically. Your task is to implement a function `num_islands(positions: List[List[int]]) -> List[int]` that returns the number of islands after each position is added. # Example Input: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] ``` Output: ```python [1, 1, 2, 3] ``` # Explanation Given a 3x3 grid initially filled with water: 1. After adding land at (0,0), there is 1 island. 2. After adding land at (0,1), there is still 1 island as (0,0) and (0,1) are connected. 3. After adding land at (1,2), there are 2 islands, separate from each other. 4. After adding land at (2,1), there are 3 islands. # Function Signature Your function should have the following signature: ```python def num_islands(positions: List[List[int]]) -> List[int]: ``` # Constraints * The grid size will not exceed 10^4. * The number of positions will not exceed 10^4. # Performance Requirements Your solution should efficiently handle the operations within the constraints. # Implementation Implement the Union-Find (or Disjoint Set) data structure within your solution to manage the dynamic connectivity of land positions.","solution":"from typing import List def num_islands(positions: List[List[int]]) -> List[int]: parent = {} rank = {} count = 0 def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for pos in positions: x, y = pos if (x, y) in parent: results.append(count) continue parent[(x, y)] = (x, y) rank[(x, y)] = 0 count += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) in parent: if union((x, y), (nx, ny)): count -= 1 results.append(count) return results"},{"question":"# Hailstone Sequence Analysis and Generation In the field of computer science and mathematics, there exists a fascinating unsolved problem known as the Collatz Conjecture related to sequences of numbers. The sequence starts with any positive integer n and follows these rules: * If n is 1, stop the sequence. * If n is even, the next number is n divided by 2. * If n is odd, the next number is 3n plus 1. The conjecture posits that no matter what value of n you start with, the sequence will always eventually reach 1. # Objective Write a function `analyze_hailstone_sequence` that takes a single integer and returns critical information about its Collatz sequence. Function Signature ```python def analyze_hailstone_sequence(n: int) -> dict: ``` Input * `n` : A positive integer (1 <= n <= 1000000). Output The function should return a dictionary containing the following keys: - `sequence`: List of integers representing the Collatz sequence starting from `n` and ending at `1`. - `length`: Integer representing the number of steps in the sequence (including the starting number). - `max_value`: The maximum value encountered in this Collatz sequence. Constraints: - Ensure that the function handles large values efficiently. Example ```python result = analyze_hailstone_sequence(7) print(result) # Expected output: # { # \\"sequence\\": [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], # \\"length\\": 17, # \\"max_value\\": 52 # } ``` # Notes - Consider that the behavior of the sequence will be tested with various inputs, and optimize accordingly. - Edge cases such as starting with n=1 should result in the minimal sequence `[1]` with a length of 1.","solution":"def analyze_hailstone_sequence(n: int) -> dict: sequence = [] max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 if n > max_value: max_value = n sequence.append(1) return { \\"sequence\\": sequence, \\"length\\": len(sequence), \\"max_value\\": max_value }"},{"question":"You are given a sorted list of integers. Your task is to implement a function `find_element` that takes in a sorted list and a target value and returns the index of the target value using the ternary search method. If the target value is not present in the list, the function should return -1. Function Signature ```python def find_element(arr: List[int], key: int) -> int: ``` Input - `arr` (List[int]): A sorted list of integers. - `key` (int): The target integer to search for. Output - Returns the index (int) of the target value `key` if present in the list. - Returns -1 if the target value is not found. Constraints - The input list will have a length of at most 10^5. - The elements of the input list will be in the range [-10^9, 10^9]. Example ```python find_element([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) # returns 4 find_element([10, 20, 30, 40, 50], 25) # returns -1 find_element([2, 4, 6, 8, 10], 10) # returns 4 find_element([1, 3, 5, 7, 9], 1) # returns 0 ``` Note Ensure your solution has a time complexity of O(log3(N)) and space complexity of O(1). Handle edge cases such as an empty array or an array with one element effectively.","solution":"from typing import List def find_element(arr: List[int], key: int) -> int: Uses ternary search to find the index of the key in the sorted list arr. Returns -1 if the key is not found. def ternary_search(left, right, key): if left > right: return -1 third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(left, mid1 - 1, key) elif key > arr[mid2]: return ternary_search(mid2 + 1, right, key) else: return ternary_search(mid1 + 1, mid2 - 1, key) return ternary_search(0, len(arr) - 1, key)"},{"question":"# Scenario As a developer working on secure messaging applications, you need to implement an efficient algorithm that quickly checks if a number is prime. This is crucial for generating large prime numbers used in encryption keys. # Challenge Write a function `enhanced_prime_check` that extends the provided `prime_check` function by adding more constraints: * It should return \\"Input must be a non-negative integer\\" for any input that is not a non-negative integer. * It should handle inputs efficiently for values up to one billion. # Function Signature ```python def enhanced_prime_check(n: int) -> str: Return \'Prime\' if n is a prime number Else return \'Not Prime\' Return \'Input must be a non-negative integer\' for invalid inputs. ``` # Input * An integer `n`, which you need to test for primality. # Constraints * 0 <= n <= 10^9 # Output * \'Prime\' if `n` is a prime number. * \'Not Prime\' if `n` is not a prime number. * \'Input must be a non-negative integer\' for invalid inputs. # Examples ```python print(enhanced_prime_check(3)) # Output: \\"Prime\\" print(enhanced_prime_check(4)) # Output: \\"Not Prime\\" print(enhanced_prime_check(-1)) # Output: \\"Input must be a non-negative integer\\" print(enhanced_prime_check(1000000007)) # Output: \\"Prime\\" ``` # Performance Considerations * Ensure that your solution is optimized for handling large numbers efficiently. * Consider edge cases and error handling thoroughly to avoid incorrect results.","solution":"def enhanced_prime_check(n): Return \'Prime\' if n is a prime number Else return \'Not Prime\' Return \'Input must be a non-negative integer\' for invalid inputs. if not isinstance(n, int) or n < 0: return \'Input must be a non-negative integer\' if n in (0, 1): return \'Not Prime\' if n == 2: return \'Prime\' if n % 2 == 0: return \'Not Prime\' sq_root = int(n ** 0.5) + 1 for div in range(3, sq_root, 2): if n % div == 0: return \'Not Prime\' return \'Prime\'"},{"question":"Implementing Custom Gap Sequence Shell Sort Problem Description Write a function to implement Shell Sort with a custom gap sequence. Instead of using the standard sequence (n/2, n/4, ..., 1), you will use an alternative predefined gap sequence to potentially increase the sorting efficiency for varied datasets. Input and Output Format - **Input**: A list of integers `arr` and a list of integers `gaps` for the gap sequence. - **Output**: The sorted list. Function Signature ```python def custom_gap_shell_sort(arr: List[int], gaps: List[int]) -> List[int]: pass ``` # Constraints - `1 <= len(arr) <= 10^4` - `1 <= len(gaps) <= len(arr)` # Performance Requirements The performance should be comparable to the traditional Shell Sort with the standard gap sequence, aiming for an average and worst-case time complexity of O(n^2). # Example ```python # Example 1 arr = [64, 34, 25, 12, 22, 11, 90] gaps = [5, 3, 1] print(custom_gap_shell_sort(arr, gaps)) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 arr = [7, 1, 3, 6, 9, 5, 8, 4] gaps = [4, 2, 1] print(custom_gap_shell_sort(arr, gaps)) # Output: [1, 3, 4, 5, 6, 7, 8, 9] ``` Notes 1. The gap sequence provided will ensure a decreasing order and will always end with 1. 2. Handle edge cases such as already sorted arrays, reverse order arrays, and arrays with identical elements.","solution":"def custom_gap_shell_sort(arr, gaps): Implements Shell Sort using a custom gap sequence. n = len(arr) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i # Shift earlier gap-sorted elements until the correct location for arr[i] is found while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Imagine you are working as a software developer at a logistics company. One of your tasks is to sort a list of package weights before they are loaded onto a sorting machine for further processing. Due to the nature of the weights arriving almost in an ordered fashion from the manufacturers, you decide to use Insertion Sort, which is efficient for nearly sorted data. Your task is to implement the `insertion_sort` algorithm. However, you need to make the following enhancements: 1. Detect if the array is already sorted and terminate early in such cases to improve efficiency. 2. Handle arrays that contain both integers and floating-point numbers. **Function Signature:** ```python def enhanced_insertion_sort(arr: List[Union[int, float]]) -> List[Union[int, float]]: ... ``` **Input:** - A list `arr` containing `n` integers and/or floating-point numbers, where `0 ≤ n ≤ 10^4`. **Output:** - Return the sorted list of integers and floating-point numbers. **Constraints:** - Assume all numbers are real and within the range of -10^6 to 10^6. - The solution should handle large lists efficiently. **Performance Requirements:** - The function must handle the average case scenario efficiently for n up to 10^4. **Scenario:** To verify your implementation, consider the following test cases: 1. An already sorted list. 2. A list sorted in reverse order. 3. A list with all elements being the same. 4. An empty list. 5. A list with mixed integers and floating-point numbers. Implement the `enhanced_insertion_sort` function to sort the weights array efficiently. **Examples:** ```python print(enhanced_insertion_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(enhanced_insertion_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] print(enhanced_insertion_sort([3, 1, 2, 1, 3])) # Output: [1, 1, 2, 3, 3] print(enhanced_insertion_sort([])) # Output: [] print(enhanced_insertion_sort([1.1, 2.2, 0.5, 3.3])) # Output: [0.5, 1.1, 2.2, 3.3] ```","solution":"from typing import List, Union def enhanced_insertion_sort(arr: List[Union[int, float]]) -> List[Union[int, float]]: if not arr: return arr # Check if array is already sorted is_sorted = all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) if is_sorted: return arr for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Bucket Sort Enhancement Challenge Background Bucket sort is excellent for sorting datasets that are uniformly distributed over a range. The basic bucket sort implementation provided uses insertion sort for sorting individual buckets, which can be inefficient in some scenarios, especially with large datasets. Task Enhance the existing bucket sort algorithm to improve its performance by using a more efficient sorting algorithm (e.g., merge sort or quick sort) for sorting individual buckets. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: # Your implementation here ``` # Input - `arr`: A list of integers to be sorted. Assume integers are non-negative. # Output - A sorted list of integers. # Constraints - The input list can have 0 to 10^5 integers. - All integers are in the range [0, 10^6]. # Performance Requirements 1. The average-case time complexity of the sorting algorithm for individual buckets should be better than insertion sort. 2. The solution should handle edge cases effectively (e.g., empty list, single-element list, non-uniform distributions). 3. The space complexity should remain manageable within O(n + k). # Example ```python assert bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) == [3, 9, 21, 25, 29, 37, 43, 49] assert bucket_sort([]) == [] assert bucket_sort([1]) == [1] assert bucket_sort([4, 1]) == [1, 4] ``` # Notes 1. You can assume a helper function `efficient_sort(arr: List[int]) -> List[int]` is available if necessary. 2. Ensure proper handling of edge cases and invalid scenarios.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] bucket_count = 10 max_value = max(arr) buckets = [[] for _ in range(bucket_count)] for num in arr: index = num * bucket_count // (max_value + 1) buckets[index].append(num) sorted_array = [] for bucket in buckets: sorted_array.extend(quick_sort(bucket)) return sorted_array"},{"question":"# Question: Implement In-Place Merge Sort Merge Sort is an efficient, stable, comparison-based, divide and conquer sorting algorithm. Your task is to implement an in-place version of the Merge Sort algorithm which sorts an array of integers without using additional space for merging. Function Signature ```python def in_place_merge_sort(arr: list) -> list: ``` Input - `arr`: A list of integers `arr` (0 <= len(arr) <= 10^6). Output - The function should return the sorted list in non-descending order. The sorting should be done in place. Constraints 1. You are not allowed to use additional arrays or other data structures for the merging process; you must perform the merge in place. 2. The function should handle edge cases such as empty lists and lists with a single element correctly. 3. The algorithm should have a time complexity of O(n log n). Example ```python assert in_place_merge_sort([3, 1, 2, 4, 5]) == [1, 2, 3, 4, 5] assert in_place_merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert in_place_merge_sort([1]) == [1] assert in_place_merge_sort([]) == [] ``` Explanation 1. **Array Split**: Recursively split the array into halves until you have subarrays of size 1. 2. **In-Place Merge**: Merge the subarrays in place such that the auxiliary space remains constant. This will involve managing indices carefully to avoid using extra space. Use this skeleton to start your implementation: ```python def in_place_merge_sort(arr): if len(arr) <= 1: return arr # Main in-place merge sort process def merge_sort_in_place(arr, l, r): if l < r: mid = (l + r) // 2 merge_sort_in_place(arr, l, mid) merge_sort_in_place(arr, mid + 1, r) merge_in_place(arr, l, mid, r) def merge_in_place(arr, l, mid, r): start2 = mid + 1 if arr[mid] <= arr[start2]: return while l <= mid and start2 <= r: if arr[l] <= arr[start2]: l += 1 else: value = arr[start2] index = start2 while index != l: arr[index] = arr[index - 1] index -= 1 arr[l] = value l += 1 mid += 1 start2 += 1 merge_sort_in_place(arr, 0, len(arr) - 1) return arr ``` Provide the complete function implementation for the in-place merge sort.","solution":"def in_place_merge_sort(arr): if len(arr) <= 1: return arr def merge_sort_in_place(arr, l, r): if l < r: mid = (l + r) // 2 merge_sort_in_place(arr, l, mid) merge_sort_in_place(arr, mid + 1, r) merge_in_place(arr, l, mid, r) def merge_in_place(arr, l, mid, r): start2 = mid + 1 if arr[mid] <= arr[start2]: return while l <= mid and start2 <= r: if arr[l] <= arr[start2]: l += 1 else: value = arr[start2] index = start2 while index != l: arr[index] = arr[index - 1] index -= 1 arr[l] = value l += 1 mid += 1 start2 += 1 merge_sort_in_place(arr, 0, len(arr) - 1) return arr"},{"question":"Nearest Neighbor Classification You are given a training dataset where each data point is represented as a key in a dictionary, and the corresponding label is the value. Implement a function that, given a new data point, returns the label of the nearest data point in the training set using the Euclidean distance metric. Function Signature ```python def classify_nearest_neighbor(x: tuple, tSet: dict) -> any: pass ``` Input - `x` (tuple): A tuple representing the input vector which needs to be classified. All elements are integers or floats. - `tSet` (dict): A dictionary representing the training set, where keys are tuples (same type as `x`), and values are arbitrary labels. Output - The function should return the label of the closest point in the training set to the input vector `x`. Constraints - Length of `x` equals the length of any key in `tSet` and is between 1 and 100 inclusive. - `tSet` dictionary is non-empty and has at most 1000 entries. - All numerical values in the tuples are between -10^6 and 10^6 inclusive. - Labels can be any hashable type (e.g., int, str). Example Usage ```python x = (1, 2) tSet = { (0, 0): \'A\', (1, 1): \'B\', (2, 2): \'C\' } print(classify_nearest_neighbor(x, tSet)) # Output: \'B\' ``` # Requirements 1. Ensure the implementation correctly calculates Euclidean distance. 2. Handle empty or invalid inputs with appropriate error messages or handling mechanisms. 3. Optimize the computation to run efficiently within constraints.","solution":"import math def euclidean_distance(pt1, pt2): Calculate the Euclidean distance between two points. return math.sqrt(sum((a - b) ** 2 for a, b in zip(pt1, pt2))) def classify_nearest_neighbor(x: tuple, tSet: dict) -> any: Classifies the given point x by finding the nearest neighbor in the training set tSet. Parameters: x (tuple): The input vector to classify. tSet (dict): The training set where keys are tuple points and values are labels. Returns: The label of the nearest neighbor in the tSet. nearest_label = None min_distance = float(\'inf\') for point, label in tSet.items(): distance = euclidean_distance(x, point) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Comb Sort Implementation Assessment Context: You have been provided with an unsorted array of integers. Your task is to implement the Comb Sort algorithm to sort this array in ascending order. Comb sort is a variation of bubble sort that improves performance by comparing elements that are further apart initially, and then progressively narrowing the gap between compared elements. Function Signature: ``` def comb_sort(arr: List[int]) -> List[int]: ``` - **Input**: * A list of integers, `arr`, where 0 ≤ len(arr) ≤ 10^5 and each element is within the range -10^6 to 10^6. - **Output**: * The same list sorted in ascending order. Constraints: 1. You cannot use any built-in sort functions. 2. You should aim to implement the Comb Sort as efficiently as possible while adhering to its principles. 3. You need to handle edge cases, including an empty list or a list with duplicates. Example: ```python >>> comb_sort([45, 32, 10, -4, 22, 78]) [-4, 10, 22, 32, 45, 78] >>> comb_sort([3, 0, 10, 30, -1]) [-1, 0, 3, 10, 30] >>> comb_sort([]) [] ``` Performance Requirements: Ensure that your implementation works efficiently within the provided constraints and handles large inputs within a reasonable time frame.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts an array using the Comb Sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The same list sorted in ascending order. n = len(arr) gap = n shrink = 1.3 # Typically shrink factor is 1.3 for comb sort. sorted = False while not sorted: # Update the gap for the next comb gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True # Assumes this is the last pass over the array # Compare elements with the current gap distance i = 0 while i + gap < n: if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 return arr"},{"question":"Problem Statement: You are given a list `lst` and a number `N`. Your task is to write a function `limit_occurances(lst, N)` that returns a new list, retaining the order of elements, but limiting the occurrences of each element to at most `N` times. The solution should be efficient even for large lists. Input: - A list of integers `lst`. - An integer `N` (0 <= N <= len(lst)). Output: - A list of integers with each number appearing at most `N` times. Constraints: - List size can be up to 10^6. - Each element in the list is a 32-bit signed integer. Performance Requirements: - The solution must run in O(n) time complexity where n is the length of the list. - Memory usage should be optimized, ideally using only O(n) additional space. Example: - `limit_occurances([1,2,3,1,2,1,2,3], 2)` should return `[1,2,3,1,2,3]` - `limit_occurances([1,1,1,1], 2)` should return `[1,1]` - `limit_occurances([], 1)` should return `[]` # Implementation: ```python import collections def limit_occurances(lst, N): result = [] counts = collections.defaultdict(int) for item in lst: if counts[item] < N: result.append(item) counts[item] += 1 return result # Example Test print(limit_occurances([1,2,3,1,2,1,2,3], 2)) # Output: [1,2,3,1,2,3] ```","solution":"import collections def limit_occurances(lst, N): Return a new list retaining the order of elements but limiting the occurrences of each element to at most N times. result = [] counts = collections.defaultdict(int) for item in lst: if counts[item] < N: result.append(item) counts[item] += 1 return result"},{"question":"# Linked List Reversal with Constraints and Edge Cases Context: Given a singly linked list, your task is to reverse the linked list both iteratively and recursively. To confirm your understanding, you need to manage an enhancement where some additional constraints are provided related to the node\'s values. Task Description: Implement both iterative and recursive versions of a function `reverse_list` that can reverse a singly linked list. This should also account for cases where: - The linked list has fewer than 2 nodes, nothing should be altered. - Nodes with duplicate values are significant and should be preserved in the reversed order, as they appear originally. Input and Output Formats: - **Input**: A singly linked list defined by its head node. - **Output**: The head of the reversed singly linked list. - **Node Class**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Constraints: - Values in nodes are integers. - The length of the linked list does not exceed (10^4). Performance Requirements: - The solutions should be efficient with linear runtime complexity. - The iterative version should have a constant space complexity. - The recursive version should handle deep recursion efficiently. # Functions to Implement: 1. **Iterative Version**: ```python def reverse_list(head: ListNode) -> ListNode: # Implement iterative version here pass ``` 2. **Recursive Version**: ```python def reverse_list_recursive(head: ListNode) -> ListNode: # Implement recursive version here pass ``` Example: ```python # Input: 1 -> 2 -> 3 -> 4 -> None head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) # Output after reverse (Iterative or Recursive): 4 -> 3 -> 2 -> 1 -> None ``` Include edge case handling and ensure the solution is robust for different input cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Iteratively reverses the given singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: Recursively reverses the given singly linked list. def _reverse_recursive(node, prev=None): if not node: return prev next_node = node.next node.next = prev return _reverse_recursive(next_node, node) return _reverse_recursive(head)"},{"question":"You are given a stream of data represented as a list of tuples `(val, sign)`, where `val` is a non-negative integer and `sign` indicates whether the value should be added (\'+\') or subtracted (\'-\') from the running total. Write a function `find_unique_in_stream(data_stream: List[Tuple[int, str]]) -> int` in Python to determine if the stream is 1-sparse. A stream is 1-sparse if, after processing all the tuples, exactly one unique value remains that is not canceled out by any other value. The function should return the unique value if the stream is 1-sparse. Otherwise, it should return `None`. Input - `data_stream`: A list of tuples, where each tuple contains an integer `val` and a string `sign`. Output - An integer representing the unique number in the stream if it is 1-sparse. - `None` if the stream does not fulfill the 1-sparse condition. Example ```python # Example 1: data_stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] assert find_unique_in_stream(data_stream) == 4 # Example 2: data_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] assert find_unique_in_stream(data_stream) == 2 # Example 3: data_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] assert find_unique_in_stream(data_stream) == None # Example 4: data_stream = [(5, \'+\'), (5, \'-\')] assert find_unique_in_stream(data_stream) == None ``` Constraints - All values in the stream are non-negative integers. - The stream can contain multiple values and signs but will fit in memory. - Performance requirement: The solution should run in O(n) time complexity. Function Signature ```python def find_unique_in_stream(data_stream: List[Tuple[int, str]]) -> int: pass ```","solution":"from collections import defaultdict from typing import List, Tuple, Optional def find_unique_in_stream(data_stream: List[Tuple[int, str]]) -> Optional[int]: value_count = defaultdict(int) # Process each entry in the data stream for val, sign in data_stream: if sign == \'+\': value_count[val] += 1 elif sign == \'-\': value_count[val] -= 1 # Filter out all zero balances non_zero_values = [val for val, count in value_count.items() if count != 0] # If exactly one unique non-canceled value is left, return it if len(non_zero_values) == 1: return non_zero_values[0] # Otherwise, return None return None"},{"question":"# String Matching with Rabin-Karp Algorithm Alice is developing a text editor where she needs to implement a fast search feature to find specific words (patterns) within a larger body of text. She has decided to use the **Rabin-Karp algorithm** to accomplish this task efficiently. This algorithm will compute hash values to reduce the time complexity of searching for the pattern. Implement a function `rabin_karp` that uses the Rabin-Karp algorithm to return the starting index of the first occurrence of a given word (pattern) in a given body of text. If the word is not found, the function should return `None`. # Function Signature: ```python def rabin_karp(word: str, text: str) -> int: Find the starting index of the first occurrence of `word` in `text` using Rabin-Karp algorithm. Returns the index if found, otherwise returns `None`. Parameters: word (str): The pattern to be searched in the text. text (str): The text in which the pattern needs to be searched. Returns: int: The starting index of the first occurrence of `word` in `text` if found, otherwise `None`. ``` # Inputs: * `word`: a non-empty string, `1 ≤ len(word) ≤ 10000` * `text`: a non-empty string, `1 ≤ len(text) ≤ 100000` # Outputs: * Returns the starting index (0-based) of the first occurrence of `word` in `text` if found. * Returns `None` if the `word` is not in `text`. # Constraints: * The function should handle edge cases efficiently, including: * Word and/or text being empty. * Word being longer than the text. # Example: ```python rabin_karp(\\"test\\", \\"this is a test text\\") # returns 10 rabin_karp(\\"abc\\", \\"defghijkl\\") # returns None ``` Ensure your implementation of the Rabin-Karp algorithm efficiently handles the input sizes and avoids false positives due to hash collisions.","solution":"def rabin_karp(word: str, text: str) -> int: Find the starting index of the first occurrence of `word` in `text` using Rabin-Karp algorithm. Returns the index if found, otherwise returns `None`. Parameters: word (str): The pattern to be searched in the text. text (str): The text in which the pattern needs to be searched. Returns: int: The starting index of the first occurrence of `word` in `text` if found, otherwise `None`. if not word or not text or len(word) > len(text): return None base = 256 prime = 101 word_len = len(word) text_len = len(text) word_hash = 0 text_hash = 0 h = 1 for i in range(word_len - 1): h = (h * base) % prime for i in range(word_len): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(text_len - word_len + 1): if word_hash == text_hash: if text[i:i+word_len] == word: return i if i < text_len - word_len: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + word_len])) % prime if text_hash < 0: text_hash += prime return None"},{"question":"Compute Minimum Spanning Tree Weight Given an undirected, connected weighted graph, implement a function to compute the sum of the weights of its Minimum Spanning Tree (MST) using Kruskal\'s algorithm. Function Signature ```python def compute_mst_weight(n: int, edges: List[Tuple[int, int, int]]) -> int: ``` Input * `n` (int): Number of vertices in the graph (1 <= n <= 1000). * `edges` (List[Tuple[int, int, int]]): List of edges where each tuple (u, v, w) represents an edge: - `u` (int): Index of one vertex (1 <= u <= n). - `v` (int): Index of another vertex (1 <= v <= n). - `w` (int): Weight of the edge (1 <= w <= 1000). Output * `int`: The sum of weights of the Minimum Spanning Tree. Constraints * The graph is guaranteed to be connected with no self-loops. * The graph may contain parallel edges. Example ```python assert compute_mst_weight(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)]) == 14 assert compute_mst_weight(3, [(2, 1, 20), (3, 1, 20), (2, 3, 100)]) == 40 ``` Notes - Treat the edge indices as 1-indexed. - You need to handle and convert the input to 0-indexed within your implementation if necessary. # Implementation Guide 1. **Sorting Edges**: First, sort the edges by their weights. 2. **Union-Find Data Structure**: Initialize Union-Find structures to manage sets of vertices. 3. **Kruskal’s Algorithm**: - Iterate through the sorted edges. - Use Union-Find to check if an edge forms a cycle. - If no cycle, include the edge in the MST and perform a union operation. 4. **Summing Weights**: Accumulate the weights of the chosen edges to compute the MST weight.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 def compute_mst_weight(n: int, edges: List[Tuple[int, int, int]]) -> int: # Initialize Union-Find uf = UnionFind(n) # Sort edges by weight edges.sort(key=lambda x: x[2]) mst_weight = 0 for u, v, w in edges: # Convert 1-indexed to 0-indexed u -= 1 v -= 1 # Check if u and v are in different components if uf.find(u) != uf.find(v): uf.union(u, v) mst_weight += w return mst_weight"},{"question":"You are working as a software engineer to develop a project management tool. One feature required is to determine if there exists a path between two tasks where tasks and dependencies are modeled as a directed graph. The graph is represented by nodes (tasks) and directed edges (dependencies). Given the provided `DirectedGraph` class, implement the function **find_path(graph, start, end)** that determines if a path exists from the node `start` to node `end`. # Function Signature ```python def find_path(graph: DirectedGraph, start: str, end: str) -> bool: pass ``` # Input * `graph`: An instance of the `DirectedGraph` class. * `start`: The name of the starting node, a string. * `end`: The name of the ending node, a string. # Output * Returns `True` if there is a path from `start` to `end`, otherwise `False`. # Constraints * Both `start` and `end` nodes will be valid and exist in the graph. * There can be multiple paths between two nodes, finding at least one path is sufficient. # Examples ```python # Example 1 graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } graph = DirectedGraph(graph_data) result = find_path(graph, \'A\', \'D\') # Output: True # Example 2 graph_data = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [\'E\'], \'E\': [\'F\'], \'F\': [] } graph = DirectedGraph(graph_data) result = find_path(graph, \'A\', \'F\') # Output: False ``` # Note - You cannot modify or alter the `DirectedGraph` class. Work within the provided structure.","solution":"from collections import deque class DirectedGraph: def __init__(self, graph_data): self.graph = graph_data def find_path(graph: DirectedGraph, start: str, end: str) -> bool: Determines if there is a path from \'start\' to \'end\' in the given directed graph. if start == end: return True visited = set() queue = deque([start]) while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph.graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return False"},{"question":"# Interval Merging and Query System **Objective**: You are required to implement an interval merging and querying system. This system should be able to: 1. Merge a list of provided intervals. 2. Quickly check if a number falls within any of the merged intervals. **Requirements**: 1. Implement a function `merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that merges overlapping intervals. 2. Implement an `Interval` class with the following methods: - `__init__(self, start: int, end: int) -> None`: Initializes an interval. - `__repr__(self) -> str`: Provides a string representation of the interval. - `contains(self, number: int) -> bool`: Checks if a given number is within the interval. - `as_list(self) -> List[int]`: Returns the interval as a list of numbers. **Constraints**: - The intervals are provided as a list of tuples, each containing two integers `(start, end)`. - You can assume that the end value of each interval is greater than or equal to the start value. - Performance is crucial: aim for an efficient solution that handles large input sizes. **Example**: ```python from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Your implementation here class Interval: def __init__(self, start: int, end: int) -> None: # Your implementation here def __repr__(self) -> str: # Your implementation here def contains(self, number: int) -> bool: # Your implementation here def as_list(self) -> List[int]: # Your implementation here # Example usage intervals = [(1, 5), (3, 7), (8, 10), (9, 12)] merged_intervals = merge_intervals(intervals) print(merged_intervals) # Output: [(1, 7), (8, 12)] interval_obj = Interval(1, 7) print(interval_obj.contains(6)) # Output: True print(interval_obj.contains(8)) # Output: False print(interval_obj.as_list()) # Output: [1, 2, 3, 4, 5, 6, 7] print(interval_obj) # Output: Interval (1, 7) ``` Please make sure your implementation adheres to the constraints and is efficient for large inputs.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # Sort the intervals by their starting points intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] # If the current interval overlaps with the last merged one, merge them if current[0] <= last_merged[1]: merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged.append(current) return merged class Interval: def __init__(self, start: int, end: int) -> None: self.start = start self.end = end def __repr__(self) -> str: return f\\"Interval({self.start}, {self.end})\\" def contains(self, number: int) -> bool: return self.start <= number <= self.end def as_list(self) -> List[int]: return list(range(self.start, self.end + 1))"},{"question":"# Question: Next Greater Character in Cyclic Sorted List You are given a list of sorted characters `letters` containing only lowercase letters, and a target letter `target`. Your task is to implement a function that finds the smallest element in the list that is larger than the given target. The letters wrap around circularly, meaning that if the target is \'z\' and letters contain \'a\', the answer should be \'a\'. # Function Signature ```python def find_next_greatest_letter(letters: List[str], target: str) -> str: pass ``` # Input * `letters` (List[str]): A list of sorted lowercase letters. The list has a length between 2 and 104. * `target` (str): A single lowercase letter. # Output * Returns a single character (str) which is the smallest element in `letters` that is larger than `target`. # Constraints * The list will always be non-empty and sorted. * The letters wrap around, meaning if the target is at the end of the alphabet (like \'z\') and the list contains letters at the beginning (like \'a\'), you should return \'a\'. # Examples Example 1 * Input: * `letters = [\\"c\\", \\"f\\", \\"j\\"]` * `target = \\"a\\"` * Output: `\\"c\\"` Example 2 * Input: * `letters = [\\"c\\", \\"f\\", \\"j\\"]` * `target = \\"c\\"` * Output: `\\"f\\"` Example 3 * Input: * `letters = [\\"c\\", \\"f\\", \\"j\\"]` * `target = \\"d\\"` * Output: `\\"f\\"` # Performance Requirements * The solution should ideally operate within O(log N) time complexity given that the list is sorted. # Guidelines 1. Consider edge cases where the target is near or at the boundaries of the letters. 2. Ensure that your solution effectively handles the circular nature of the list. 3. Optimize your solution using binary search or the `bisect` library for better performance.","solution":"from typing import List def find_next_greatest_letter(letters: List[str], target: str) -> str: lo, hi = 0, len(letters) while lo < hi: mid = (lo + hi) // 2 if letters[mid] <= target: lo = mid + 1 else: hi = mid return letters[lo % len(letters)]"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Longest Common Prefix Problem * **Type**: String Manipulation Algorithm * **Main Purpose**: To find the longest common prefix string among a list of strings. Complexity * **Horizontal Scanning**: * **Time Complexity**: O(S), where S is the sum of all characters in all strings. * **Space Complexity**: O(1), auxiliary space is minimal. * **Vertical Scanning**: * **Time Complexity**: O(S), where S is the sum of all characters in all strings. * **Space Complexity**: O(1), auxiliary space is minimal. * **Divide and Conquer**: * **Time Complexity**: O(S), where S is the sum of all characters in all strings. * **Space Complexity**: O(m log n), where n is the number of strings and m is the length of the longest string. Principles * **Horizontal Scanning**: Compares strings pairwise to determine the longest common prefix. * **Vertical Scanning**: Checks each character position across all strings simultaneously. * **Divide and Conquer**: Recursively divides the list into halves and merges their prefixes. Characteristics & Applications * **Properties**: * These methods are capable of identifying the maximum common prefix string by different approaches. * Efficiently handles edge cases like empty arrays or where no common prefix is present. * **Common Use Cases**: * Useful in bioinformatics for DNA sequence analysis. * Auto-completion features in text editors. * Prefix-based search optimization. * **Strengths/Limitations**: * Horizontal and Vertical scanning techniques are straightforward and easy to implement, but might be less efficient for large datasets. * Divide and Conquer method might be more efficient in certain contexts but requires more stack memory due to recursion. * All methods are best used when dealing with a manageable number of strings and string lengths. Implementation Challenges * **Edge Cases**: * Empty input list. * List containing an empty string. * The list where no common prefix exists. * **Performance Bottlenecks**: * Large input size leading to lengthy operations. * Handling excessively long strings. * **Error Scenarios**: * Unhandled empty strings or null inputs could crash the algorithm. * **Optimization Points**: * Improved comparison operations. * Efficient memory management in the case of large datasets. <|Analysis End|> <|Question Begin|> # Longest Common Prefix Challenge Objective You are to write an algorithm that finds the longest common prefix string amongst an array of strings. If there is no common prefix, the function should return an empty string (\\"\\"). Requirements Your task is to implement the function `find_longest_common_prefix` which should handle the below complexities effectively: * Horizontal Scanning * Vertical Scanning * Divide and Conquer Input * An array of strings, `strs` (1 <= strs.length <= 200, 0 <= strs[i].length <= 200) Output * A string, the longest common prefix. Constraints * The input list should contain at least one string. * The function should efficiently determine an empty prefix if no commonality is found. Example ```python # Example 1: Input: [\\"flower\\", \\"flow\\", \\"flight\\"] Output: \\"fl\\" # Example 2: Input: [\\"dog\\", \\"racecar\\", \\"car\\"] Output: \\"\\" ``` Implementation Implement the function as below: ```python def find_longest_common_prefix(strs): :param strs: List of strings :return: Longest common prefix among the strings # Add your logic here return common_prefix_string # You may choose to implement additional helper functions as required. ``` Ensure that your solution is optimized and capable of handling the constraints and edge cases effectively.","solution":"def find_longest_common_prefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. :param strs: List of strings :return: Longest common prefix among the strings if not strs: return \\"\\" # The initial prefix is the first string in the list prefix = strs[0] # Compare the prefix with each string in the list for s in strs[1:]: while s.find(prefix) != 0: # Reduce the prefix by one character at a time prefix = prefix[:len(prefix)-1] if not prefix: return \\"\\" return prefix"},{"question":"Design and implement a class `RandomizedCollection` that allows insertion, removal, and retrieval of random elements with equal probability for each element, in average O(1) time. # Requirements 1. **insert(val)**: - Inserts the value `val` to the set if it is not already present. - If `val` is already present, the count of `val` should be incremented. - Returns a boolean indicating whether `val` was not already present. 2. **remove(val)**: - Removes one instance of the value `val` from the set if it is present. - Returns a boolean indicating whether `val` was present. 3. **random_element()**: - Returns a random element from the current set of elements. - Each element must have the same probability of being returned. # Constraints - The set can contain duplicate elements. # Input and Output - **insert(val)**: - Input: An integer `val`. - Output: Boolean (True if the `val` was not already present, False otherwise). - **remove(val)**: - Input: An integer `val`. - Output: Boolean (True if `val` was present and removed, False otherwise). - **random_element()**: - Output: An integer. # Example ```python rset = RandomizedCollection() print(rset.insert(1)) # True print(rset.insert(1)) # False print(rset.insert(2)) # True print(rset.remove(1)) # True print(rset.random_element()) # 1 or 2 print(rset.remove(1)) # True print(rset.remove(1)) # False print(rset.remove(2)) # True ``` # Notes 1. `insert` and `remove` should both be average O(1) time complexity. 2. The `random_element` method should also be average O(1) time complexity. 3. Assume all input values are valid integers.","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): Initialize your data structure here. self.values = [] self.val_indices = defaultdict(set) def insert(self, val): Inserts an item into the collection. Returns true if the collection did not already contain the specified element. is_new_element = len(self.val_indices[val]) == 0 self.values.append(val) self.val_indices[val].add(len(self.values) - 1) return is_new_element def remove(self, val): Removes an item from the collection. Returns true if the collection contained the specified element. if len(self.val_indices[val]) == 0: return False # Get arbitrary index of the element to remove remove_index = self.val_indices[val].pop() # Move the last element to the place of the element to remove last_val = self.values[-1] self.values[remove_index] = last_val self.val_indices[last_val].add(remove_index) self.val_indices[last_val].discard(len(self.values) - 1) # Remove the last element self.values.pop() if len(self.val_indices[val]) == 0: del self.val_indices[val] return True def random_element(self): Get a random element from the collection. return random.choice(self.values)"},{"question":"# Scenario: You have been hired to optimize an online bookstore\'s backend system. One of your tasks is to enhance their dictionary implementation to handle frequent lookups, insertions, and deletions of book records efficiently. The current implementation relies heavily on basic HashMap functionalities, but with their growing database, performance issues have started to appear, particularly with high collision rates and resizing operations. # Task: Implement a custom HashTable that efficiently manages book records. Your implementation should extend from the given HashTable and add optimizations for: 1. Handling high load factors with minimal performance drop. 2. Efficient collision resolution. 3. Quick resizing operations. # Function Details: Implement a class `EnhancedHashTable` that inherits from `ResizableHashTable`: * **Methods to Implement**: * `def _rehash(self, old_hash):` – Modify this to implement quadratic probing instead of linear probing. * `def __resize(self):` – Optimize the resizing strategy to avoid frequent rehashing by considering future growth nodes dynamically (i.e., grow by 1.5x instead of 2x). # Input/Output Requirements: * **put(key, value)**: * Adds a key-value pair or updates an existing key. * Should handle hash collisions effectively and use quadratic probing. * **get(key)**: * Retrieves the value for a given key or returns `None` if the key is not found. * **del_(key)**: * Deletes the key if it exists in the hashtable. * **__resize()**: * Adjusts the size of the table when necessary as per the new growth strategy. # Constraints: * Keys are non-negative integers. * Values are strings or numbers representing book information. * Use quadratic probing for collision resolution. * Implement dynamic resizing without frequently impacting performance. # Example: ```python # Create an instance of EnhancedHashTable hashtable = EnhancedHashTable() # Insert key-value pairs hashtable.put(10, \\"Book A\\") hashtable.put(20, \\"Book B\\") hashtable.put(15, \\"Book C\\") # Retrieve values print(hashtable.get(10)) # Output: \\"Book A\\" print(hashtable.get(15)) # Output: \\"Book C\\" # Delete a key hashtable.del_(10) print(hashtable.get(10)) # Output: None ```","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.count = 0 self.table = [None] * self.size def _hash(self, key): return key % self.size def put(self, key, value): if self.count / self.size > 0.7: self.__resize() index = self._hash(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.size if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return True index = (index + 1) % self.size return False def __resize(self): old_table = self.table self.size *= 2 self.count = 0 self.table = [None] * self.size for item in old_table: if item is not None: self.put(item[0], item[1]) class EnhancedHashTable(ResizableHashTable): def _rehash(self, old_hash, i): return (old_hash + i ** 2) % self.size def __resize(self): old_table = self.table self.size = int(self.size * 1.5) self.count = 0 self.table = [None] * self.size for item in old_table: if item is not None: self.put(item[0], item[1]) def put(self, key, value): hash_val = self._hash(key) i = 0 new_hash_val = hash_val while self.table[new_hash_val] is not None and self.table[new_hash_val][0] != key: i += 1 new_hash_val = self._rehash(hash_val, i) if self.table[new_hash_val] is None: self.count += 1 self.table[new_hash_val] = (key, value) if self.count / self.size > 0.7: self.__resize() def get(self, key): hash_val = self._hash(key) i = 0 new_hash_val = hash_val while self.table[new_hash_val] is not None: if self.table[new_hash_val][0] == key: return self.table[new_hash_val][1] i += 1 new_hash_val = self._rehash(hash_val, i) return None def del_(self, key): hash_val = self._hash(key) i = 0 new_hash_val = hash_val while self.table[new_hash_val] is not None: if self.table[new_hash_val][0] == key: self.table[new_hash_val] = None self.count -= 1 return True i += 1 new_hash_val = self._rehash(hash_val, i) return False"},{"question":"# Atbash Cipher Implementation **Objective**: Implement the Atbash cipher to encode a given string where each alphabetic character is substituted by its reverse counterpart in the alphabet, while leaving all non-alphabetic characters unchanged. **Problem Description**: You are given a string `s` that may contain uppercase letters, lowercase letters, digits, punctuation, and spaces. Your task is to encode this string using the Atbash cipher. **Function Signature**: ```python def atbash_cipher(s: str) -> str: ``` **Input**: - `s` (1 <= len(s) <= 10^4): A string containing any printable ASCII characters. **Output**: - A string representing the encoded text using the Atbash cipher. **Constraints**: - All alphabetic characters must be encoded to their \\"reversed\\" counterpart in the respective alphabet (uppercase and lowercase handled separately). - Non-alphabetic characters must remain unchanged. - The length of the input string will not exceed 10,000 characters. **Examples**: ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"Secret Message 123\\") == \\"Hvxivg Nvhhztv 123\\" ``` **Scenario**: Imagine you are a cryptographer working on a historical encryption project. You need to implement the Atbash cipher to encode historical texts. Your function must accurately transform these texts while preserving the case and leaving non-alphabetic characters unaffected.","solution":"def atbash_cipher(s: str) -> str: Encode the input string using the Atbash cipher. Parameters: s (str): The string to be encoded. Returns: str: The encoded string. encoded_string = [] for char in s: if \'A\' <= char <= \'Z\': encoded_char = chr(ord(\'Z\') - (ord(char) - ord(\'A\'))) elif \'a\' <= char <= \'z\': encoded_char = chr(ord(\'z\') - (ord(char) - ord(\'a\'))) else: encoded_char = char encoded_string.append(encoded_char) return \'\'.join(encoded_string)"},{"question":"# Question: **String Encoding and Decoding** You are given the task of implementing serialization and deserialization procedures for a list of strings. Your functions should encode a list of strings into a single string suitable for network transmission or storage, and decode it back into the original list of strings. Implement the following two functions: ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - a list of strings to encode :return: str - the encoded single string pass def decode(s): Decodes a single string to a list of strings. :param s: str - the encoded string :return: List[str] - the decoded list of strings pass ``` Requirements: 1. The `encode` function should concatenate the lengths of the strings followed by the strings themselves, separated by a colon `:`. 2. The `decode` function should reverse this operation, extracting each string based on its length specified. 3. Handle cases where strings might contain colons by ensuring your method is robust enough to delimit lengths correctly. 4. Consider edge cases such as empty strings and ensure your code efficiently uses time and memory. Example: ```python # Example usage strs = [\\"hello\\", \\"world\\", \\":\\", \\"test:123\\"] encoded = encode(strs) print(encoded) # Expected format might be something like \\"5:hello5:world1::8:test:123\\" decoded = decode(encoded) print(decoded) # Expected output: [\\"hello\\", \\"world\\", \\":\\", \\"test:123\\"] ``` **Constraints**: - Strings in the input list will have lengths within reasonable bounds typical for a networked application. Bonus: - Ensure your solution has a linear time complexity relative to the total number of characters in all strings. - Handle potential issues where strings themselves might contain the delimiter character.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - a list of strings to encode :return: str - the encoded single string return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: str - the encoded string :return: List[str] - the decoded list of strings i, n, result = 0, len(s), [] while i < n: j = i while j < n and s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j + 1: j + 1 + length]) i = j + 1 + length return result"},{"question":"# Problem Scenario Alice is working on storing and managing a collection of numbers dynamically. She needs a data structure that allows for efficient insertion, deletion, and search operations. Alice decides to use a binary search tree (BST) for this purpose. # Task Description Implement a `BinarySearchTree` class with the following methods: 1. **insert(val)** - Insert the number `val` into the BST. - If the number already exists in the BST, do not insert it again. 2. **search(val)** - Return `True` if the number `val` is found in the BST, otherwise, return `False`. 3. **delete(val)** - Remove the number `val` from the BST. If `val` does not exist, do nothing. # Input/Output Formats - **insert(val)**: - Input: An integer `val` - Output: None - **search(val)**: - Input: An integer `val` - Output: Boolean `True` or `False` - **delete(val)**: - Input: An integer `val` - Output: None # Constraints - Values of each node are unique. - Assume all values are integers. - `1 <= val <= 10000` # Performance Requirements - Ensure that each operation (insert, search, delete) takes O(h) time, where h is the height of the tree. # Implementation You must implement your solution using the given `TreeNode` class. ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): # Implement the insert method pass def search(self, val): # Implement the search method pass def delete(self, val): # Implement the delete method pass ``` # Example ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True bst.delete(3) print(bst.search(3)) # Output: False ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val): return self._search(self.root, val) def _search(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self._min_value_node(node.right) node.val = temp_val.val node.right = self._delete(node.right, temp_val.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Scenario You have two lists of integer numbers. You need to integrate these lists into a single sequence, following the zigzag pattern—taking an element from the first list, followed by an element from the second, and so on. If one list is longer than the other, just continue with the remaining elements of the longer list after there are no elements left in the shorter list. # Task Write a Python class `ZigZagIterator` which simulates this behavior. You need to implement the following methods: * `__init__(self, v1, v2)`: Initializes the iterator with the two lists `v1` and `v2`. * `next(self)`: Returns the next element in the zigzag order. * `has_next(self)`: Returns `True` if there are more elements to return, otherwise `False`. # Input - Two lists of integers `v1` and `v2`. # Output - The class with the specified methods. # Constraints - The input lists can be empty, but they are not simultaneously empty. # Performance Requirements - Each method call should be efficient in terms of time complexity. # Example ```python v1 = [1, 2] v2 = [3, 4, 5, 6] it = ZigZagIterator(v1, v2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` # Note - Implement your own solution from scratch, considering the performance and edge cases discussed.","solution":"class ZigZagIterator: def __init__(self, v1, v2): self.v1 = v1 self.v2 = v2 self.index1 = 0 self.index2 = 0 self.turn = 0 # 0 for v1, 1 for v2 def next(self): if self.turn == 0: if self.index1 < len(self.v1): result = self.v1[self.index1] self.index1 += 1 else: result = self.v2[self.index2] self.index2 += 1 self.turn = 1 else: if self.index2 < len(self.v2): result = self.v2[self.index2] self.index2 += 1 else: result = self.v1[self.index1] self.index1 += 1 self.turn = 0 return result def has_next(self): return self.index1 < len(self.v1) or self.index2 < len(self.v2)"},{"question":"**Question**: Write a function `is_isomorphic_advanced(s, t)` that determines whether two given strings `s` and `t` are isomorphic under a predefined set of constraints. Your function should return `True` if the strings are isomorphic and `False` otherwise. # Function Signature ```python def is_isomorphic_advanced(s: str, t: str) -> bool: pass ``` # Input * Two strings `s` and `t`, both of which have a length between `1` and `10000` inclusive. * The strings consist of any printable ASCII characters. # Output * A boolean value `True` if the strings `s` and `t` are isomorphic, `False` otherwise. # Constraints * The strings should be evaluated case-sensitively. * No two characters from `s` should map to the same character from `t`. # Example Example 1: Input: ```python s = \\"egg\\" t = \\"add\\" ``` Output: ```python True ``` Example 2: Input: ```python s = \\"foo\\" t = \\"bar\\" ``` Output: ```python False ``` Example 3: Input: ```python s = \\"paper\\" t = \\"title\\" ``` Output: ```python True ``` # Scenario Imagine you are working on a feature in a text editor where you need to check if two given patterns can be interchanged under certain character reassignments. This function will help ensure that the structure of the text remains consistent after such transformations. # Note Consider edge cases such as: * Strings with special characters. * Uneven lengths should return `False`. * Ensure efficient mapping and unmapping. Implement your function below: ```python def is_isomorphic_advanced(s, t): if len(s) != len(t): return False dict_s_t = {} dict_t_s = {} for char_s, char_t in zip(s, t): if (char_s in dict_s_t and dict_s_t[char_s] != char_t) or (char_t in dict_t_s and dict_t_s[char_t] != char_s): return False dict_s_t[char_s] = char_t dict_t_s[char_t] = char_s return True ```","solution":"def is_isomorphic_advanced(s: str, t: str) -> bool: if len(s) != len(t): return False dict_s_t = {} dict_t_s = {} for char_s, char_t in zip(s, t): if (char_s in dict_s_t and dict_s_t[char_s] != char_t) or (char_t in dict_t_s and dict_t_s[char_t] != char_s): return False dict_s_t[char_s] = char_t dict_t_s[char_t] = char_s return True"},{"question":"# Matrix Operations and Exponentiation **Scenario**: You are working on a project that involves a lot of matrix operations, particularly matrix exponentiation. You are given a task to optimize the calculation of matrix powers. **Problem Statement**: Implement the function `matrix_exponentiation(mat: list, n: int) -> list`, which returns the matrix `mat` raised to the power `n` using the repeated squaring method discussed above. Additionally, implement `multiply(matA: list, matB: list) -> list` and `identity(n: int) -> list` if not provided. # Requirements: 1. **matrix_exponentiation(mat, n)**: - **Input**: - `mat`: A list of lists (square matrix) containing integers of dimension `d x d`. - `n`: Non-negative integer representing the exponent. - **Output**: - A list of lists representing the matrix `mat` raised to the power `n`. 2. **multiply(matA, matB)**: - **Input**: Two lists of lists representing square matrices `matA` and `matB` of dimension `d x d`. - **Output**: A list of lists representing the product matrix `matC` of dimension `d x d`. 3. **identity(n)**: - **Input**: Integer `n` representing the dimension of the identity matrix. - **Output**: A list of lists representing the identity matrix of size `n x n`. # Constraints: * 1 <= d <= 100 * 0 <= n <= 10^9 * The matrix elements will be integers in the range [-10^3, 10^3] # Example: ```python mat = [ [2, 0], [0, 2] ] n = 3 # Identity matrix of size 2 # [ # [1, 0], # [0, 1] # ] # Expected output: # [ # [8, 0], # [0, 8] # ] result = matrix_exponentiation(mat, n) print(result) # Output should be [[8, 0], [0, 8]] ``` # Notes: - Ensure that your code handles edge cases (e.g., power of zero, non-square matrices). - Avoid using any built-in libraries for matrix operations. - Optimize for performance and readability.","solution":"def multiply(matA, matB): Multiplies two square matrices matA and matB. d = len(matA) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += matA[i][k] * matB[k][j] return result def identity(n): Returns the identity matrix of dimension n x n. return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_exponentiation(mat, n): Raises the matrix mat to the power n using repeated squaring. if n == 0: return identity(len(mat)) elif n == 1: return mat half_power = matrix_exponentiation(mat, n // 2) half_power_squared = multiply(half_power, half_power) if n % 2 == 0: return half_power_squared else: return multiply(half_power_squared, mat)"},{"question":"You are hired to work on a file management tool that relies heavily on manipulating file paths. One of your tasks is to ensure that all file paths are correctly converted to their absolute forms. To accomplish this, you\'ll implement a utility function that processes relative paths and user paths (with `~`) to return the absolute path. # Function Description Implement a function `get_absolute_path` that takes one parameter: * `file (str)`: The relative file path, which may include user-directory notation (`~`). The function should return the absolute path to the file. # Input - A string `file` representing the file path to be resolved. # Output - The function should return a string representing the full absolute path of the input file. # Example ```python print(get_absolute_path(\\"~/Documents/report.txt\\")) # Output: \\"/home/user/Documents/report.txt\\" (assuming \\"/home/user\\" is the home directory) print(get_absolute_path(\\"projects/code/main.py\\")) # Output: \\"/current/working/directory/projects/code/main.py\\" (assuming the current working directory is \\"/current/working/directory\\") ``` # Constraints - The input `file` string will be non-empty but may contain spaces. - Only standard filesystem characters will be used. # Edge Cases - Handle user home directory notation (`~`). - Handle paths that are already absolute. - Consider the input being just `~` or `/`. Your implementation should use the `os` module functions to resolve the paths.","solution":"import os def get_absolute_path(file): Converts a relative file path or one containing user-directory notation (`~`) to an absolute path. Args: file (str): The relative file path. Returns: str: The absolute path of the file. # Expand user directory notation and convert to absolute path return os.path.abspath(os.path.expanduser(file))"},{"question":"You are given an array containing n integers where each integer is 0, 1, or 2. Write a function, `sort_colors`, that sorts the array in a single pass such that all 0s come first, followed by all 1s, and then all 2s. The function should not use any built-in sorting functions. # Function Signature ```python def sort_colors(nums: List[int]) -> None: Sorts the input list \'nums\' which only contains 0s, 1s, and 2s. Args: nums (List[int]): The list of integers to be sorted in-place. Returns: None: The list is sorted in-place, no value is returned. ``` # Constraints - (1 leq text{len(nums)} leq 10^5) - Each element in `nums` is either 0, 1, or 2. # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] nums = [1, 0, 1, 2, 2, 0, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 0, 1, 1, 1, 2, 2] ``` # Explanation The Dutch National Flag problem solution provided will help you sort the array optimally. You should use the three-way partitioning technique described, manipulating the array in-place to achieve the desired sorting in ( O(n) ) time. # Edge Cases to Consider: 1. If the array contains only one type of element (e.g., [0, 0, 0]), the function should still work correctly. 2. Arrays with combination but not including all types (e.g., [1, 1, 2, 2]). 3. The function should handle the smallest arrays correctly (e.g., single element arrays [0], [1], or [2]). # Task Implement the `sort_colors` function by following the specified requirements and ensure it passes the edge cases and examples provided.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the input list \'nums\' which only contains 0s, 1s, and 2s. Args: nums (List[int]): The list of integers to be sorted in-place. Returns: None: The list is sorted in-place, no value is returned. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"# Context You are working on a project that involves manipulating stacks for a particular application. One of the tasks requires you to switch successive pairs of elements in such a way that for an even number of elements, all elements are paired and swapped, whereas for an odd number of elements, the top element remains in place. # Problem Statement Implement a function `switch_stack_pairs` that switches successive pairs of elements in a stack. You are encouraged to use an auxiliary queue for this operation. The function should take a list representing a stack, where the last element of the list represents the top of the stack. # Function Signature ```python def switch_stack_pairs(stack: List[int]) -> List[int]: ``` # Input - A list of integers `stack`, where each integer represents an element in a stack, and the last integer is the top of the stack. - Constraints: The elements in the stack range from -10^6 to 10^6. The length of the stack is at most 10^4. # Output - A list of integers representing the stack after switching successive pairs of elements. # Example ```python stack = [3, 8, 17, 9, 1, 10] print(switch_stack_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] print(switch_stack_pairs(stack)) # Output: [8, 3, 9, 17, 1] stack = [] print(switch_stack_pairs(stack)) # Output: [] stack = [1] print(switch_stack_pairs(stack)) # Output: [1] ``` # Constraints - Implement the function with O(n) time complexity and try to use O(n) space complexity. # Hints 1. Consider using an auxiliary queue for temporary storage and to facilitate the switching process. 2. Pay attention to the edge cases where the number of elements in the stack is odd or the stack is empty.","solution":"from typing import List def switch_stack_pairs(stack: List[int]) -> List[int]: if len(stack) < 2: # If the stack has less than 2 elements, return it as is return stack # Make a copy of the stack to avoid modifying the input directly result_stack = stack[:] # Initialize an auxiliary queue (in practice, just use a list) queue = [] # We process elements in pairs, so we need to count them i = 0 while i < len(result_stack): if i + 1 < len(result_stack): # Swap the pair of elements queue.append(result_stack[i + 1]) queue.append(result_stack[i]) i += 2 else: # In case of an odd number of elements, just add the last one queue.append(result_stack[i]) i += 1 return queue"},{"question":"# Question: Given an array of integers where every element appears exactly three times except for one element which appears exactly once, write a function `find_unique_number(nums: List[int]) -> int` that returns the single unique element. Your solution should run in linear time and use constant extra space. Explanation: Your algorithm should use bitwise operations and bit manipulation to find the unique number. You are not allowed to use any extra data structures or additional memory for this task; use variable bit masking. Input: * `nums` (List[int]): A list of integers where every element appears exactly three times except for one which appears exactly once. It is guaranteed that the list length is at least four. Output: * Returns the single unique element that appears exactly once in the list. Constraints: * Length of `nums` >= 4 * The integers can be both positive and negative. * The solution should run in O(n) time and use O(1) space. Example: ```python assert find_unique_number([2, 2, 3, 2]) == 3 assert find_unique_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique_number([-2, -2, -2, -6]) == -6 ``` Implement the function: ```python def find_unique_number(nums: List[int]) -> int: # Your code here pass ```","solution":"def find_unique_number(nums): Function to find the unique number in a list where every element appears exactly three times except for one element which appears exactly once. Args: nums (List[int]): The list of integers. Returns: int: The unique number. # Initialize variables to hold the bits we encounter ones, twos = 0, 0 for num in nums: # Appearances of num bits in ones and twos twos |= ones & num ones ^= num # Mask to keep bits that are exactly three times common_bit_mask = ~(ones & twos) # Apply mask to reset bits that have appeared three times ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"You are given a non-negative number represented as a list of digits. Each digit is an element of the list where the most significant digit is at the head of the list, and the least significant digit is at the end of the list. You need to add one to this number and return the resulting list of digits. Write a function `increment_digits(digits: List[int]) -> List[int]` that accepts a list of integers representing a non-negative number and returns a list of integers representing the number after incrementing by one. # Function Signature ```python from typing import List def increment_digits(digits: List[int]) -> List[int]: # Your implementation here ``` # Input - `digits`: A list of integers with each element in the range [0, 9]. # Output - A list of integers representing the incremented number. # Example ```python # Example 1 input_digits = [1, 2, 3] output_digits = increment_digits(input_digits) print(output_digits) # Output: [1, 2, 4] # Example 2 input_digits = [9, 9, 9] output_digits = increment_digits(input_digits) print(output_digits) # Output: [1, 0, 0, 0] ``` # Constraints - The input list will not be empty. - The elements of the list will always be between 0 and 9 (inclusive). # Requirements 1. The function should handle carry operations effectively. 2. The solution should maintain linear time complexity, `O(n)`. 3. The solution should handle edge cases, such as when all digits are `9`. # Additional Notes - Consider the performance implications and aim to write an optimized solution. - Avoid using direct conversion of the array to an integer for operations, focus on the digit-by-digit manipulation.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: This function takes a list of digits representing a non-negative integer and returns a list of digits representing the integer after incrementing by one. # Start from the last digit for i in range(len(digits) - 1, -1, -1): if digits[i] < 9: # If the current digit is less than 9 digits[i] += 1 # Simply increment it by 1 return digits # Return the result as no further carry is needed digits[i] = 0 # If the current digit is 9, it becomes 0 and carries over # If all digits were 9, we would have exited the loop without returning # thus we need to add a leading 1 return [1] + digits"},{"question":"# Context You are given an array of integers representing stock prices where each element in the array represents the stock price on a given day. Your task is to write a function to find the maximum sum of a contiguous subsequence of stock prices. # Task Implement the function `max_contiguous_subsequence_sum(expenses: List[int]) -> int` that computes the maximum sum of any contiguous subsequence within the input array. # Input * `expenses`: list of integers `expenses` where each integer represents the stock price on a given day. # Output * Return an integer representing the maximum sum of any contiguous subsequence within the array. # Constraints * The length of the array `expenses` will be from `0` to `10^5`. * Each element of the array `expenses` will be between `-10^4` and `10^4`. # Example ```python # Example 1 input_arr = [-2, 3, 8, -1, 4] # Output: 14 # Explanation: The contiguous subsequence [3, 8, -1, 4] has the maximum sum of 14. # Example 2 input_arr = [-1, 1, 0] # Output: 1 # Explanation: The contiguous subsequence [1] has the maximum sum of 1. # Example 3 input_arr = [-1, -3, -4] # Output: -1 # Explanation: The contiguous subsequence [-1] has the highest sum of -1. # Example 4 input_arr = [-2, 3, 8, -12, 8, 4] # Output: 12 # Explanation: The contiguous subsequence [8, 4] has the maximum sum of 12. ``` # Notes Make sure you handle edge cases such as arrays with all negative numbers and arrays of size zero. ```python def max_contiguous_subsequence_sum(expenses: List[int]) -> int: arr_size = len(expenses) if arr_size == 0: return 0 max_till_now = expenses[0] curr_sub_sum = 0 for i in range(0, arr_size): if curr_sub_sum + expenses[i] < expenses[i]: curr_sub_sum = expenses[i] else: curr_sub_sum += expenses[i] max_till_now = max(max_till_now, curr_sub_sum) return max_till_now ```","solution":"from typing import List def max_contiguous_subsequence_sum(expenses: List[int]) -> int: if not expenses: return 0 max_sum = current_sum = expenses[0] for price in expenses[1:]: current_sum = max(price, current_sum + price) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Background You are given the task of processing binary trees, where you need to traverse and extract values in a specific order. In this challenge, you are required to implement preorder traversal both iteratively and recursively for a given binary tree. Task Implement a function `preorder_recursive` and `preorder_iterative` that performs a preorder traversal of a binary tree and returns the values of the nodes in a list. Input and Output Format 1. **Function Signature**: ```python def preorder_recursive(root: Node) -> List[int]: pass def preorder_iterative(root: Node) -> List[int]: pass ``` 2. **Input**: - A binary tree node defined by the class `Node` provided below: ```python class Node: def __init__(self, val: int, left=None, right=None): self.val = val self.left = left self.right = right ``` - The root node of the tree is provided as an input to both functions. 3. **Output**: - The functions return a list of integers representing the node values in preorder. Constraints - The number of nodes in the binary tree will not exceed 10^4. - Tree node values are integers and can include negative values. Example Input: ```plaintext root = Node(1, Node(2, Node(4), Node(5)), Node(3)) preorder_recursive(root) => [1, 2, 4, 5, 3] preorder_iterative(root) => [1, 2, 4, 5, 3] ``` Explanation: - For both recursive and iterative preorder traversals, the list of visited nodes is the same: [1, 2, 4, 5, 3]. Notes - Ensure proper handling of edge cases like an empty tree. - Aim for optimal time and space complexity, leveraging in-depth understanding of binary trees.","solution":"from typing import List class Node: def __init__(self, val: int, left=None, right=None): self.val = val self.left = left self.right = right def preorder_recursive(root: Node) -> List[int]: def traverse(node: Node, result: List[int]) -> None: if not node: return result.append(node.val) traverse(node.left, result) traverse(node.right, result) result = [] traverse(root, result) return result def preorder_iterative(root: Node) -> List[int]: if not root: return [] stack = [root] result = [] while stack: node = stack.pop() if node: result.append(node.val) # Push right first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"**Problem Statement:** Given a list of words, design an algorithm that returns the words that can be typed using only one row of the standard American QWERTY keyboard. Assume that the rows are as follows: 1. Top row: `[\'q\', \'w\', \'e\', \'r\', \'t\', \'y\', \'u\', \'i\', \'o\', \'p\']` 2. Middle row: `[\'a\', \'s\', \'d\', \'f\', \'g\', \'h\', \'j\', \'k\', \'l\']` 3. Bottom row: `[\'z\', \'x\', \'c\', \'v\', \'b\', \'n\', \'m\']` # Input: - A list of words (List[str]). # Output: - A list of words (List[str]) that can be typed using one row on the keyboard. # Constraints: - The words list can contain up to 1000 words. - Each word can have up to 100 characters. - Words consist of letters from the English alphabet. # Example: ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` # Requirements: 1. Implement a function `find_keyboard_row(words)` which takes a list of words and returns the words that can be typed using only one row of the keyboard. 2. Ensure the function is case insensitive. # Note: - Consider edge cases such as empty list input and words with mixed capitalization. - The function should be efficient in terms of both time and space complexity.","solution":"def find_keyboard_row(words): Returns words that can be typed using only one row of the standard American QWERTY keyboard. top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") def can_be_typed_on_one_row(word): lower_word = set(word.lower()) return lower_word <= top_row or lower_word <= middle_row or lower_word <= bottom_row return [word for word in words if can_be_typed_on_one_row(word)]"},{"question":"You are tasked with implementing two encoding schemes, Elias γ and Elias δ, which are universal coding algorithms for positive integers. These encodings are useful for compressing numbers without requiring knowledge of their upper bounds. Implement the following functions: 1. `elias_gamma_encode(x: int) -> str`: This function computes the Elias γ encoding of a given positive integer `x`. 2. `elias_delta_encode(x: int) -> str`: This function computes the Elias δ encoding of a given positive integer `x`. # Function Signatures ```python def elias_gamma_encode(x: int) -> str: pass def elias_delta_encode(x: int) -> str: pass ``` # Input - Both functions take a single integer `x` (1 <= x <= 10^6), representing the number to encode. # Output - The functions return a string representing the encoded form of `x`. # Example **Input:** ```python x = 5 print(elias_gamma_encode(x)) print(elias_delta_encode(x)) ``` **Output:** ```python elias_gamma_encode(5): \\"00101\\" elias_delta_encode(5): \\"00010101\\" ``` # Constraints - Ensure your implementation handles values up to 10^6 efficiently. - Consider edge cases such as minimal input values carefully. - The implementations should not use pre-existing encoding libraries but should be crafted from standard Python capabilities. # Scenario Imagine you\'re working on a data compression module for a system where the upper bound of incoming positive integers is not known in advance. Implement these universal coding techniques to allow efficient storage and transmission of the data.","solution":"def elias_gamma_encode(x: int) -> str: Computes the Elias Gamma encoding of a given positive integer x. if x <= 0: raise ValueError(\\"Input must be a positive integer.\\") # Find the binary representation of x binary_representation = bin(x)[2:] # Compute the length of the binary representation n = len(binary_representation) # Construct the Elias Gamma code: (n-1) zero bits followed by the binary_representation elias_gamma_code = \'0\' * (n - 1) + binary_representation return elias_gamma_code def elias_delta_encode(x: int) -> str: Computes the Elias Delta encoding of a given positive integer x. if x <= 0: raise ValueError(\\"Input must be a positive integer.\\") # Find the binary representation of x binary_representation = bin(x)[2:] # Compute the length of the binary representation n = len(binary_representation) # Compute the Elias Gamma encoding of n gamma_encoded_n = elias_gamma_encode(n) # Construct the Elias Delta code: gamma_encoded_n without the first bit of binary_representation followed by remaining bits elias_delta_code = gamma_encoded_n + binary_representation[1:] return elias_delta_code"},{"question":"You are given two strings, `haystack` and `needle`. Write a function `find_substring_index(haystack: str, needle: str) -> int` that returns the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not a part of `haystack`. Additionally, optimize your solution to handle large inputs efficiently. # Input * `haystack`: A non-empty string of length n (1 ≤ n ≤ 10^5). * `needle`: A string of length m (0 ≤ m ≤ n). `needle` can be an empty string. # Output * Integer representing the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not found. # Constraints * You must aim for an efficient solution, ideally with a time complexity better than O((n-m+1)*m). # Example ```python assert find_substring_index(\\"hello\\", \\"ll\\") == 2 assert find_substring_index(\\"aaaaa\\", \\"bba\\") == -1 assert find_substring_index(\\"hello\\", \\"\\") == 0 assert find_substring_index(\\"hello\\", \\"hello world\\") == -1 ``` # Explanation 1. In the first example, \\"ll\\" is a part of \\"hello\\", and its first occurrence starts at index 2. 2. In the second example, \\"bba\\" is not a part of \\"aaaaa\\", so the function returns -1. 3. In the third example, the needle is empty, following the convention, the function returns 0. 4. In the fourth example, \\"hello world\\" is longer than \\"hello\\" and therefore cannot be a part of it. # Considerations for Optimization * Implementing a more efficient string searching algorithm like Knuth-Morris-Pratt (KMP) or Boyer-Moore can be helpful. * Avoiding unnecessary comparisons and redundant loops can significantly enhance performance.","solution":"def find_substring_index(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not a part of haystack. if not needle: return 0 n, m = len(haystack), len(needle) if m > n: return -1 # Partial match table for KMP algorithm lps = [0] * m j = 0 # Preprocess the pattern (needle) to get the lps array i = 1 while i < m: if needle[i] == needle[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j-1] else: lps[i] = 0 i += 1 i = j = 0 # index for haystack, needle while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j-1] else: i += 1 return -1 # Example cases print(find_substring_index(\\"hello\\", \\"ll\\")) # Expected Output: 2 print(find_substring_index(\\"aaaaa\\", \\"bba\\")) # Expected Output: -1 print(find_substring_index(\\"hello\\", \\"\\")) # Expected Output: 0 print(find_substring_index(\\"hello\\", \\"hello world\\")) # Expected Output: -1"},{"question":"Write a function `count_flips_to_convert(a: int, b: int) -> int` that determines the minimal number of bits you would need to flip to convert integer `A` to integer `B`. Input: * An integer `A` where 1 <= A <= 10^9. * An integer `B` where 1 <= B <= 10^9. Output: * An integer representing the minimal number of bit flips needed to convert `A` to `B`. # Example: ```python # Example 1 input: A = 29, B = 15 output: 2 # Example 2 input: A = 10, B = 20 output: 4 ``` # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: pass ``` # Notes: * The XOR (^) operation can be used to find differing bits. * Counting the number of 1s in the resultant difference will give the number of flips required. Your task is to implement the `count_flips_to_convert` function that performs the above-described process efficiently.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Determines the minimal number of bits needed to flip to convert integer A to integer B. :param a: Integer A :param b: Integer B :return: Number of bit flips xor_result = a ^ b return bin(xor_result).count(\'1\')"},{"question":"# Inorder Traversal of a Binary Tree **Context**: You are to implement the inorder traversal of a binary tree. You need to ensure your solution works correctly for various binary trees, including balanced, unbalanced, and edge cases such as empty trees. **Problem Statement**: Write a function `inorder_traversal` that takes the root of a binary tree and returns a list of values in inorder sequence. # Function Signature ```python def inorder_traversal(root: \'Node\') -> List[int]: ``` # Input * `root` - The root node of the binary tree (of type `Node`). # Output * `List[int]` - A list of integers representing the node values in inorder sequence. # Constraints * The number of nodes in the tree will be in the range [0, 1000]. * -1000 <= Node.val <= 1000 You must provide two separate implementations: one using an iterative approach and the other using a recursive approach. **Example**: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree # 1 # # 2 # / # 3 root = Node(1) root.right = Node(2) root.right.left = Node(3) assert inorder_traversal(root) == [1, 3, 2] ``` **Requirements**: 1. Implement the function `inorder_traversal_iterative(root: \'Node\') -> List[int]` using an iterative approach. 2. Implement the function `inorder_traversal_recursive(root: \'Node\') -> List[int]` using a recursive approach. 3. Ensure both implementations pass the provided example. # Implementation - Use the existing Node class provided in the examples. - Assume that your final implementation will be tested with various tree configurations to ensure correctness and efficiency.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def inorder_traversal_iterative(root: Optional[Node]) -> List[int]: Iterative approach for inorder traversal. result, stack = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_traversal_recursive(root: Optional[Node]) -> List[int]: Recursive approach for inorder traversal. result = [] def dfs(node: Optional[Node]): if node: dfs(node.left) result.append(node.val) dfs(node.right) dfs(root) return result"},{"question":"You are given a non-empty list of integers where every element appears exactly three times, except for one element which appears exactly once. Implement a function `find_single_number(nums: List[int]) -> int` to find and return the single number. Your implementation should run in linear time (O(n)) and should not use extra memory. # Input - `nums`: a list of integers `[n1, n2, ..., nk]` where (n geq 1). # Output - The single integer that appears exactly once in the list. # Constraints 1. The length of the list will be in the range [1, (10^5)]. 2. The integers in the list will be in the range [-(2^{31}), (2^{31} - 1)]. # Example ```python # Example 1: nums = [2, 2, 3, 2] # The element \'3\' appears only once, while other elements appear thrice. find_single_number(nums) -> 3 # Example 2: nums = [0, 1, 0, 1, 0, 1, 99] # The element \'99\' appears only once, while other elements appear thrice. find_single_number(nums) -> 99 ``` # Problem Constraints - Your algorithm should have linear runtime complexity, (O(n)). - Your algorithm should not use extra memory. # Note Avoid using Python’s in-built hash tables (dictionaries) as extra memory.","solution":"def find_single_number(nums): Finds the single number in a list where every other number appears exactly three times. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# 2-SAT Solver Implementation Challenge You are tasked with implementing a function to determine the satisfiability of a 2-CNF formula. A 2-CNF formula is composed of clauses, each containing at most two literals. Your function should return a satisfying assignment of variables if it exists, or indicate that no such assignment exists. Input * A 2-CNF formula represented as a list of clauses. * Each clause is a tuple of two literals, where a literal is represented as a tuple `(name, is_neg)`. * `name` - An arbitrary identifier for the variable. * `is_neg` - A boolean indicating if the literal is negated (True if negated, False otherwise). Output * A dictionary where keys are variable names and values are boolean True/False representing their assignment. * If the formula is unsatisfiable, return `None`. Constraints * All variable names are unique. * The number of variables `N` can be up to 100. * The number of clauses `M` can be up to 200. Example ```python formula = [ ((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True)) ] result = solve_sat(formula) # Expected Output: # One possible output could be: {\'x\': True, \'y\': False, \'a\': True, \'b\': False, \'c\': False} ``` Detailed Requirements * Define the function `solve_sat(formula)`. * You may define helper functions as necessary. Notes * Your code will be tested against various 2-CNF formulas for validation. * Pay special attention to edge cases as mentioned in the analysis.","solution":"from collections import defaultdict, deque def solve_sat(formula): def var_index(name, is_neg): if is_neg: return 2 * name + 1 else: return 2 * name def strongly_connected_components(graph, n): index = 0 stack = [] indices = [-1] * n lowlink = [-1] * n on_stack = [False] * n SCCs = [] def strongconnect(v): nonlocal index indices[v] = index lowlink[v] = index index += 1 stack.append(v) on_stack[v] = True for w in graph[v]: if indices[w] == -1: strongconnect(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif on_stack[w]: lowlink[v] = min(lowlink[v], indices[w]) if lowlink[v] == indices[v]: current_SCC = [] while True: w = stack.pop() on_stack[w] = False current_SCC.append(w) if w == v: break SCCs.append(current_SCC) for v in range(n): if indices[v] == -1: strongconnect(v) return SCCs vars_set = set() for clause in formula: for lit in clause: vars_set.add(lit[0]) n = len(vars_set) m = 2 * n graph = defaultdict(list) variables = sorted(list(vars_set)) var_to_index = {var: idx for idx, var in enumerate(variables)} for clause in formula: (name1, is_neg1), (name2, is_neg2) = clause u = var_index(var_to_index[name1], not is_neg1) v = var_index(var_to_index[name2], not is_neg2) graph[u].append(var_index(var_to_index[name2], is_neg2)) graph[v].append(var_index(var_to_index[name1], is_neg1)) SCCs = strongly_connected_components(graph, m) component = [-1] * m for i, scc in enumerate(SCCs): for node in scc: component[node] = i assignment = {} for var in variables: if component[var_index(var_to_index[var], False)] == component[var_index(var_to_index[var], True)]: return None assignment[var] = component[var_index(var_to_index[var], False)] < component[var_index(var_to_index[var], True)] return assignment"},{"question":"You are working on a cyclic buffer and need to implement a function to rotate a singly linked list to the right by `k` places, where `k` is a non-negative integer. A singly linked list is a sequence of nodes where each node points to the next node. Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: ``` Input - `head`: The head node of a singly linked list. - `k`: A non-negative integer representing the number of places to rotate the list to the right. The singly linked list is defined as: ```python class ListNode: def __init__(self, x: int): self.val = x self.next = None ``` Output - Return the head of the rotated list. Constraints - The number of nodes in the list is between 0 and 500. - The value of each node is between -1000 and 1000. - `0 <= k <= 10^9` Example ```python Given 1 -> 2 -> 3 -> 4 -> 5 -> NULL and k = 2, return 4 -> 5 -> 1 -> 2 -> 3 -> NULL. ``` # Special Notes: - Ensure to handle edge cases such as empty list, single-element list, and `k` being 0 or a multiple of the length of the list. - Aim for a solution that performs efficiently for long lists. Implement the function `rotate_right` to complete the task.","solution":"class ListNode: def __init__(self, x: int): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Compute the length of the linked list length = 1 last_node = head while last_node.next: last_node = last_node.next length += 1 # If k is greater than the length, take modulo k %= length if k == 0: return head # Find the new tail, which is (length - k - 1)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # The new head is the next node of the new tail new_head = new_tail.next new_tail.next = None last_node.next = head return new_head"},{"question":"You are given two singly linked lists that might intersect at some point in the list. Your task is to write a function that finds and returns the node at which the two lists intersect. If the lists do not intersect, return `None`. # Scenario Imagine you have two sets of friends who journey separately and you want to find out at which point they meet so you can plan to join them. Each friend’s journey is represented as a singly linked list, and the point where they meet corresponds to the intersection node. # Function Signature ```python def intersection(h1: Node, h2: Node) -> Node: ``` # Input * `h1`: The head node of the first singly linked list. * `h2`: The head node of the second singly linked list. # Output * The first common node `Node` at which the two lists intersect, or `None` if the lists do not intersect. # Constraints * The two linked lists must retain their orders; you cannot rearrange the nodes. * The node returned (if any) should be exactly the node object referenced in both lists. # Example Given the linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` The function should return the node containing the value `7`. Notes * This problem can assume each node has an attribute `val` for its value and `next` for the next node in the list. * Ensure to consider cases where one or both lists might be empty. # Unit Test You should use the provided unit test for verification. Your solution should pass the following test cases: ```python import unittest class TestSuite(unittest.TestCase): def test_intersection(self): # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f self.assertEqual(7, intersection(a1, a2).val) if __name__ == \'__main__\': unittest.main() ``` **Note**: Use this test case to verify the functionality of your code, ensuring robustness against the scenarios described.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def get_length_and_tail(node): length = 0 while node: length += 1 if node.next is None: return length, node node = node.next return length, None def intersection(h1: Node, h2: Node) -> Node: len1, tail1 = get_length_and_tail(h1) len2, tail2 = get_length_and_tail(h2) if tail1 != tail2: return None if len1 > len2: for _ in range(len1 - len2): h1 = h1.next else: for _ in range(len2 - len1): h2 = h2.next while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"You are given the implementation of a `BSTIterator` class above. Your task is to extend the functionality of the `BSTIterator` class to support a `prev` method, which will allow the user to iterate over the BST in reverse in-order sequence (right, root, left). # Requirements: 1. Implement the `prev` method which should: - Return the previous element in the BST. - Assume `prev` is going to be called only when there are previous elements available. 2. Implement the `has_prev` method which should: - Return `True` if there are previous elements available in the traversal sequence, otherwise `False`. # Function Definitions: ```python def prev(self) -> int: Returns the previous element in the BST. Returns: int: The value of the previous node. pass def has_prev(self) -> bool: Checks if there are previous elements in the BST. Returns: bool: True if there are previous elements, False otherwise. pass ``` # Constraints: * The methods from the `BSTIterator` class should maintain an average O(1) time complexity. * The additional space complexity due to `prev` should also be within O(h). # Example: Given the following BST: ``` 7 / 3 15 / 9 20 ``` ```python root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) print(iterator.next()) # return 3 print(iterator.next()) # return 7 print(iterator.next()) # return 9 print(iterator.has_prev()) # return True print(iterator.prev()) # return 9 print(iterator.has_next()) # return True print(iterator.next()) # return 9 print(iterator.has_next()) # return True print(iterator.next()) # return 15 ``` # Note: - The iterator should maintain its integrity and not interfere with the current `next` and `has_next` methods.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._push_left(root) self.prev_stack = [] def _push_left(self, node): while node: self.stack.append(node) node = node.left def _push_right(self, node): while node: self.prev_stack.append(node) node = node.right def next(self) -> int: node = self.stack.pop() self.prev_stack.append(node) self._push_left(node.right) return node.val def has_next(self) -> bool: return bool(self.stack) def prev(self) -> int: node = self.prev_stack.pop() self.stack.append(node) return node.val def has_prev(self) -> bool: return bool(self.prev_stack)"},{"question":"**Question**: # Scenario You are working on a new feature for a spell checker that suggests the closest valid word for a given misspelled word. To achieve this, you need to calculate the minimum number of operations required to transform a misspelled word into a valid dictionary word. You need to implement an algorithm that calculates the edit distance between two words. # Task Write a function `calculate_edit_distance(word_a, word_b)` that takes in two words, `word_a` and `word_b`, and returns the minimum number of operations required to transform `word_a` into `word_b`. # Function Signature ```python def calculate_edit_distance(word_a: str, word_b: str) -> int: pass ``` # Input * `word_a` (1 <= len(word_a) <= 1000): A string representing the first word. * `word_b` (1 <= len(word_b) <= 1000): A string representing the second word. # Output * Returns an integer representing the minimum number of operations required to transform `word_a` into `word_b`. # Constraints * You must use dynamic programming to solve the problem. * Do not use any external libraries that directly perform this operation. * Consider edge cases such as empty strings and long strings. # Examples ```python assert calculate_edit_distance(\\"food\\", \\"money\\") == 4 assert calculate_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert calculate_edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert calculate_edit_distance(\\"intention\\", \\"execution\\") == 5 assert calculate_edit_distance(\\"\\", \\"abc\\") == 3 ``` # Notes - The function should handle both small and large input sizes efficiently. - Pay attention to optimize the space complexity if possible.","solution":"def calculate_edit_distance(word_a: str, word_b: str) -> int: Calculate the edit distance between two words using dynamic programming. The edit distance is the minimum number of operations (insertions, deletions, substitutions) required to transform word_a into word_b. m, n = len(word_a), len(word_b) # Create a table to store the edit distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the base cases for i in range(m + 1): dp[i][0] = i # Cost of deleting all characters from word_a is i for j in range(n + 1): dp[0][j] = j # Cost of inserting all characters of word_b is j # Compute the edit distance using bottom-up dynamic programming for i in range(1, m + 1): for j in range(1, n + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: dp[i][j] = min( dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Substitution ) + 1 return dp[m][n]"},{"question":"You have been tasked with implementing a function that computes the greatest common divisor (GCD) of two integers using an optimized algorithm. Besides returning the GCD, the function should also return the least common multiple (LCM) to facilitate various applications in number theory and computational mathematics. # Function Signature ```python def optimized_gcd_and_lcm(a: int, b: int) -> (int, int): Computes the greatest common divisor and the least common multiple of integers a and b. Parameters: a (int): The first integer. b (int): The second integer. Returns: (int, int): A tuple containing the GCD and LCM of a and b respectively. ``` # Input - Two integers `a` and `b` where `a`, `b` can be positive, negative or zero. # Output - A tuple `(gcd, lcm)`: - `gcd`: The greatest common divisor of `a` and `b`. - `lcm`: The least common multiple of `a` and `b`. # Constraints - The integers `a` and `b` will be within the range of `[-10^9, 10^9]`. - Either `a` or `b` should be non-zero. # Requirements - Your function must handle negative values and convert them to positive as necessary. - You must use an optimized algorithm, preferably using bitwise operations. # Example ```python assert optimized_gcd_and_lcm(24, 36) == (12, 72) assert optimized_gcd_and_lcm(-24, 36) == (12, 72) assert optimized_gcd_and_lcm(0, -36) == (36, 0) assert optimized_gcd_and_lcm(-24, 0) == (24, 0) ``` # Performance - Your solution should aim to be efficient in terms of both time and space complexity, targeting O(log(min(a, b))) for time complexity. # Edge Cases 1. Input values are zeros or negative. 2. Very large integers.","solution":"def optimized_gcd_and_lcm(a: int, b: int) -> (int, int): Computes the greatest common divisor and the least common multiple of integers a and b. Parameters: a (int): The first integer. b (int): The second integer. Returns: (int, int): A tuple containing the GCD and LCM of a and b respectively. import math # Make both numbers positive a, b = abs(a), abs(b) # GCD computation using Euclid\'s algorithm def gcd(x, y): while y: x, y = y, x % y return x if a == 0 or b == 0: gcd_value = max(a, b) return gcd_value, 0 gcd_value = gcd(a, b) lcm_value = abs(a * b) // gcd_value return gcd_value, lcm_value"},{"question":"# Interval Merging & Operations Problem Statement You are given a set of intervals representing ranges on the real number line. Your task is to implement an existing interval class and extend it with additional functionality to handle interval operations effectively. Class Definition You need to implement a class `EnhancedInterval` that will include methods to: 1. Initialize with start and end points. 2. Determine if a number is included in the interval. 3. Merge overlapping intervals. 4. Find intersections of intervals. 5. Print intervals in a readable form. Method Descriptions 1. **`__init__(self, start, end)`**: Initialize the interval `[start, end)`. 2. **`__contains__(self, item)`**: Return True if item is within the interval, False otherwise. 3. **`merge_intervals(intervals)`**: Given a list of intervals, merge all overlapping intervals and return the merged intervals as a list. 4. **`intersect(self, other)`**: Given another interval, return the intersection of self and other, or an empty interval if they do not intersect. 5. **`__repr__(self)`**: Return a string representation of the interval as `\\"Interval(start, end)\\"`. Input and Output * **Input**: * List of intervals represented as tuples [(start1, end1), ..., (startN, endN)] for merging. * Individual intervals for intersection. * **Output**: * Merged list of intervals. * Intersection interval, or an empty interval if they do not intersect. Implementation Constraints 1. Intervals are provided as tuples of integers for simplicity. 2. Ensure start <= end for all intervals during initialization. 3. Your implementation should have a time complexity of O(n log n) for merging. Example ```python # Initialize intervals i1 = EnhancedInterval(1, 5) i2 = EnhancedInterval(6, 9) i3 = EnhancedInterval(2, 6) # Checking if a number is in interval print(4 in i1) # True print(5 in i1) # False # Merging intervals intervals = [EnhancedInterval(1, 3), EnhancedInterval(2, 4), EnhancedInterval(5, 7)] merged = EnhancedInterval.merge_intervals(intervals) print(merged) # [EnhancedInterval(1, 4), EnhancedInterval(5, 7)] # Intersecting intervals intersection = i1.intersect(i3) print(intersection) # EnhancedInterval(2, 5) intersection = i1.intersect(i2) print(intersection) # EnhancedInterval(0, 0) # No intersection ``` Implement the `EnhancedInterval` class and its methods.","solution":"class EnhancedInterval: def __init__(self, start, end): # Ensure that start is less than or equal to end if start > end: raise ValueError(\\"Start of interval must be less than or equal to end\\") self.start = start self.end = end def __contains__(self, item): return self.start <= item < self.end @classmethod def merge_intervals(cls, intervals): if not intervals: return [] # Sort intervals by the start time intervals.sort(key=lambda interval: interval.start) merged = [] current_start, current_end = intervals[0].start, intervals[0].end for interval in intervals[1:]: if interval.start <= current_end: # There is an overlap, extend the current interval current_end = max(current_end, interval.end) else: # No overlap, add the current interval and reset merged.append(cls(current_start, current_end)) current_start, current_end = interval.start, interval.end # Add the last merged interval merged.append(cls(current_start, current_end)) return merged def intersect(self, other): # Calculate the intersection of two intervals new_start = max(self.start, other.start) new_end = min(self.end, other.end) if new_start < new_end: return EnhancedInterval(new_start, new_end) return EnhancedInterval(0, 0) # Represents no intersection def __repr__(self): return f\\"EnhancedInterval({self.start}, {self.end})\\""},{"question":"# Problem Description You are given a directed graph representing a flow network with nodes representing junctions and edges representing pipes with specific capacities. Your task is to determine the maximum amount of flow that can be sent from the source node (the first node) to the sink node (the last node) using the Edmonds-Karp implementation of the Ford-Fulkerson method (using BFS for path searching). # Function Signature Implement the function `maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int` that will take an `adjacency_matrix` representing the capacities of the pipes in the network and return the maximum flow value. # Input - `adjacency_matrix`: A n x n 2D list where `adjacency_matrix[i][j]` represents the capacity of the edge from node i to node j. Value 0 means no direct path. # Output - Return an integer representing the maximum flow from the source node to the sink node. # Constraints 1. `1 <= n <= 100`, where n is the number of nodes. 2. `0 <= adjacency_matrix[i][j] <= 10^6`, capacities are non-negative integers. 3. Source node is `0` and sink node is `n-1`. # Example **Example 1** Input: ```python adjacency_matrix = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] ``` Output: ```python 23 ``` **Example 2** Input: ```python adjacency_matrix = [ [0, 10, 10, 0], [0, 0, 1, 10], [0, 0, 0, 10], [0, 0, 0, 0] ] ``` Output: ```python 20 ``` # Notes - Circular paths and multiple paths between nodes are allowed. - The function should handle cases where no flow is possible. # Implementation Your implementation should follow the principles of the Ford-Fulkerson algorithm using a BFS approach for finding augmenting paths and updating the residual capacities.","solution":"from collections import deque def bfs(residual_graph, source, sink, parent): visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix): n = len(adjacency_matrix) source, sink = 0, n-1 residual_graph = [row[:] for row in adjacency_matrix] parent = [-1] * n max_flow = 0 while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question: Graph Pathfinder Given an undirected graph represented as an adjacency list and two nodes, `start` and `end`, write a function that determines if there is a path between the `start` and `end` nodes. If a path exists, your function should return `True`; otherwise, it should return `False`. Your function should perform a breadth-first search (BFS) to ensure optimal path checking in unweighted graphs. Function Signature ```python def is_path_exists(graph: Dict[int, List[int]], start: int, end: int) -> bool: pass ``` # Input * `graph`: A dictionary where keys are node identifiers (integers) and values are lists of neighboring node identifiers. * `start` and `end`: Integers representing the start and end nodes. # Output * Returns `True` if there is a path from `start` to `end`, otherwise returns `False`. # Constraints * The graph can have up to (10^4) nodes and (10^5) edges. * Node identifiers are non-negative integers. * The graph is undirected and may be disconnected. # Performance Requirements * The solution should not exceed (O(|V| + |E|)) time and (O(|V|)) space complexity. # Examples ```python # Example 1 graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } print(is_path_exists(graph, 0, 3)) # Output: True # Example 2 graph = { 0: [1], 1: [0], 2: [3], 3: [2] } print(is_path_exists(graph, 0, 3)) # Output: False ``` # Notes * Ensure to handle cases where the start or end node might not exist in the graph. * Utilize BFS to ensure the solution leverages the shortest path checking characteristic of BFS.","solution":"from collections import deque from typing import Dict, List def is_path_exists(graph: Dict[int, List[int]], start: int, end: int) -> bool: if start not in graph or end not in graph: return False visited = set() queue = deque([start]) while queue: current = queue.popleft() if current == end: return True visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"# Scenario You are tasked with developing a feature for a software application that tracks operations within an undo/redo framework. To achieve this, you need to implement a stack that supports typical operations efficiently. # Problem Statement Write a Python class `UndoRedoStack` that builds upon the `ArrayStack` data structure. This stack should support additional operations necessary for an undo/redo system. Your implementation should handle up to 10,000 operations (push, pop, peek, or is_empty) and be optimized for performance. # Class Definition ```python class UndoRedoStack(ArrayStack): def __init__(self, size=10): pass def push(self, value): Add an item to the top of the undo stack. pass def pop(self): Remove and return the item from the top of the undo stack. pass def peek(self): Return the top item from the undo stack without removing it. pass def is_empty(self): Check if the undo stack is empty. pass def redo(self): Redo the last undone operation by moving it from the redo stack to the undo stack. pass def undo(self): Undo the last operation by moving it from the undo stack to the redo stack. pass ``` # Functionality Requirements 1. **Undo Operation**: * Moves the element from the top of the `undo stack` to the `redo stack`. * Should maintain `redo stack` elements for potential redoing. 2. **Redo Operation**: * Moves the element from the top of the `redo stack` back to the `undo stack`. * Should ensure actions can be re-performed. # Expected Input and Output * **Input**: Sequence of operations consisting of `push`, `pop`, `peek`, `is_empty`, `undo`, and `redo`. * **Output**: Observe and manage the stack state post-operations. # Constraints * `Stack` should handle up to 10,000 operations efficiently. * Each `undo` operation adds an element to the `redo` stack and vice versa. * Operations should respect the order and undo/redo should maintain operational integrity. # Example Usage ```python stack = UndoRedoStack() stack.push(1) stack.push(2) stack.undo() # Undo last push (2), redo stack should have 2 assert stack.peek() == 1 stack.redo() # Redo last undo (push 2), top should now be 2 again assert stack.peek() == 2 ```","solution":"class UndoRedoStack: def __init__(self, size=10): self.stack = [] self.redo_stack = [] self.max_size = size def push(self, value): if len(self.stack) == self.max_size: raise OverflowError(\\"Stack is full\\") self.stack.append(value) self.redo_stack.clear() # Clear redo stack on new action def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def redo(self): if not self.redo_stack: raise IndexError(\\"Redo stack is empty\\") self.stack.append(self.redo_stack.pop()) def undo(self): if self.is_empty(): raise IndexError(\\"Undo stack is empty\\") self.redo_stack.append(self.stack.pop())"},{"question":"# Coding Challenge: Find the k-th to Last Element in a Linked List Context You work for a company that analyzes sequences of events recorded in a log, represented as a singly linked list. Sometimes, you need to quickly find the k-th to last event in these logs for debugging or analytical purposes. Task Write an efficient function `kth_to_last` that returns the k-th to last node in a singly-linked list. You should use an iterative approach with a two-pointer technique to achieve an optimal time and space complexity. Input and Output - **Input:** * `head` (Node): The head node of the singly linked list. * `k` (int): The position from the end (0-based). - **Output:** * The k-th to last node in the list. If `k` is out of bounds (i.e., greater than or equal to the length of the list), raise an appropriate exception (e.g., `IndexError`) or return False. Function Signature ```python def kth_to_last(head, k): pass ``` Example Consider the following linked list: `A -> A -> B -> C -> D -> C -> F -> G` If you call `kth_to_last(a1, 4)`, where `a1` is the head of this list, the function should return the node with value `\\"D\\"`. Constraints - Do not use the `eval` built-in function. - Aim for O(n) time and O(1) space complexity. - Assume that the list contains at least one element and that `k` is a non-negative integer. Notes - Remember to handle edge cases where `k` is greater than or equal to the length of the list, or the list is empty. Use the following node class for your implementation: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` You can utilize the following test case to validate your solution: ```python def test(): # create the linked list a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # validate `kth_to_last` function implementation kth = kth_to_last(a1, 4) assert kth.val == \\"D\\", f\\"Expected \'D\', got {kth.val}\\" print(\\"All test cases passed\\") if __name__ == \\"__main__\\": test() ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head, k): Returns the k-th to last node of a singly linked list. :param head: Node, the head of the singly linked list. :param k: int, the position from the end (0-based). :return: Node, the k-th to last node. if not head: raise IndexError(\\"The linked list is empty\\") p1 = head p2 = head # Move p2 forward k steps for _ in range(k): if not p2.next: raise IndexError(\\"k is out of bounds (greater than or equal to the length of the list)\\") p2 = p2.next # Move both p1 and p2 until p2 reaches the end of the list while p2.next: p1 = p1.next p2 = p2.next return p1"},{"question":"Write a function that takes a directed graph as input and computes its transitive closure. The graph is represented using an adjacency list. The function should return a matrix indicating the reachability between vertices. # Input Format - An integer `n` representing the number of vertices, where vertices are indexed from 0 to n-1. - A list of tuples `edges` where each tuple (u, v) indicates a directed edge from vertex u to vertex v. # Output Format - A 2D list (matrix) `closure` of size n x n where `closure[i][j]` is 1 if there is a path from vertex i to vertex j, and 0 otherwise. # Constraints - 1 ≤ n ≤ 100 (you can assume a dense graph) - 0 ≤ number of edges ≤ n * (n-1) # Function Signature ```python def transitive_closure(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` # Example ```python # Example 1 n = 4 edges = [(0, 1), (1, 2), (2, 3)] transitive_closure(n, edges) # Output: [[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]] # Example 2 n = 3 edges = [(0, 1), (1, 2), (2, 0)] transitive_closure(n, edges) # Output: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] ``` # Notes - Provide a clear and efficient implementation. - Pay attention to edge cases such as graphs with no edges or self-loops. - Ensure your algorithm is efficient in terms of both time and space complexity.","solution":"def transitive_closure(n: int, edges: list[tuple[int, int]]) -> list[list[int]]: Computes the transitive closure of a directed graph represented by an adjacency list. # Create an n x n matrix initialized to 0 closure = [[0] * n for _ in range(n)] # Initialize the matrix such that closure[i][i] = 1 for i in range(n): closure[i][i] = 1 # Populate the adjacency matrix from the edge list for u, v in edges: closure[u][v] = 1 # Compute the transitive closure using Floyd-Warshall Algorithm for k in range(n): for i in range(n): for j in range(n): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"Problem Statement Given an array of integers, implement the Selection Sort algorithm to sort the array in ascending order. Additionally, implement a simulation mode to visually indicate the sorting process step-by-step. Function Signature ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array in ascending order using the Selection Sort algorithm. :param arr: List[int] - A list of integers to be sorted. :param simulation: bool - If set to True, the function should print the array after each iteration. :return: List[int] - The sorted list of integers. ``` Input * `arr`: A list of integers. Example: `[64, 25, 12, 22, 11]` * `simulation`: A boolean flag. If `True`, print the state of the array after each pass. Output * The function should return a new list that is sorted in ascending order. * If `simulation` is `True`, print the state of the array after each pass. Constraints * 1 <= len(arr) <= 50 * -10^3 <= arr[i] <= 10^3 Example ```python selection_sort([64, 25, 12, 22, 11], simulation=True) # Should print: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # Returns: [11, 12, 22, 25, 64] ``` Evaluation Criteria * Correct implementation of the Selection Sort algorithm. * Proper handling of edge cases (e.g., empty array or array with one element). * Correct state printing for simulation mode if `simulation` is `True`. * Code readability and adherence to Python coding standards.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array in ascending order using the Selection Sort algorithm. :param arr: List[int] - A list of integers to be sorted. :param simulation: bool - If set to True, the function should print the array after each iteration. :return: List[int] - The sorted list of integers. n = len(arr) for i in range(n): # Assume the minimum is the first element min_idx = i for j in range(i + 1, n): # Update min_idx if the element at j is less than the current minimum if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element of the unsorted part arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Question: Advanced Arithmetic Operations with Constraints You are tasked with implementing several arithmetic operations on integers for a numerical library. Your implementation should not only be correct but optimized for large numbers and edge cases. Task Implement the following functions: 1. **Greatest Common Divisor (GCD) - Euclid\'s Algorithm**: - `gcd(a: int, b: int) -> int` - Inputs: Two non-zero integers (a, b). - Output: The greatest common divisor of `a` and `b`. - Constraints: Handle negative inputs by absolute value. 2. **Least Common Multiple (LCM)**: - `lcm(a: int, b: int) -> int` - Inputs: Two non-zero integers (a, b). - Output: The least common multiple of `a` and `b`. 3. **Trailing Zero Count**: - `trailing_zero(x: int) -> int` - Inputs: A positive integer `x`. - Output: The number of trailing zeros in the binary representation of `x`. - Constraints: Ensure that the function handles all valid positive integers. 4. **Greatest Common Divisor using Bitwise operations**: - `gcd_bit(a: int, b: int) -> int` - Inputs: Two non-negative integers (a, b). - Output: The greatest common divisor using bitwise operations. - Constraints: Ensure no unnecessary operations and handle zero efficiently. Example ```python assert gcd(34, 17) == 17 assert lcm(21, 6) == 42 assert trailing_zero(40) == 3 assert gcd_bit(34, 17) == 17 ``` # Constraints - Input integers for `gcd` and `lcm` are non-zero. - Input integers for `gcd_bit` are non-negative. - Inputs for `trailing_zero` are positive. - Performance should be optimized for up to 10^9 integer inputs. # Notes - Return a positive integer for all functions. - Raise a `ValueError` for invalid inputs as per the constraints.","solution":"def gcd(a, b): Returns the greatest common divisor of a and b using Euclid\'s Algorithm. a, b = abs(a), abs(b) while b: a, b = b, a % b return a def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // gcd(a, b) def trailing_zero(x): Returns the number of trailing zeros in the binary representation of x. if x <= 0: raise ValueError(\\"Input must be a positive integer.\\") count = 0 while x & 1 == 0: x >>= 1 count += 1 return count def gcd_bit(a, b): Returns the greatest common divisor of a and b using bitwise operations. a, b = abs(a), abs(b) if a == 0 or b == 0: return a | b shift = 0 while (((a | b) & 1) == 0): a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift"},{"question":"# Integer to Bytes and Bytes to Integer Conversion Challenge Given an integer, write two functions: 1. `int_to_bytes(num: int) -> bytes` that converts the integer to its byte representation in both little-endian and big-endian formats. 2. `bytes_to_int(bytestr: bytes, endian: str) -> int` that converts a byte array back to an integer, based on the provided endianness. Function Specifications: 1. **Function**: `int_to_bytes` - **Input**: An integer `num` (0 <= num <= 2^64) - **Output**: A tuple of two byte arrays `(big_endian_bytes, little_endian_bytes)` - **Example**: ```python int_to_bytes(305) -> (b\'x01x31\', b\'x31x01\') ``` 2. **Function**: `bytes_to_int` - **Input**: A byte array `bytestr`, and a string `endian` which is either `\'big\'` or `\'little\'` - **Output**: Integer equivalent of the byte array in the specified endianness - **Example**: ```python bytes_to_int(b\'x01x31\', \'big\') -> 305 bytes_to_int(b\'x31x01\', \'little\') -> 305 ``` Constraints - Assume all integers are non-negative and within the 64-bit range (0 <= num <= 2^64). - The byte arrays will be non-empty and will not exceed 8 bytes in length according to 64-bit limits. - Endianness string will only be `\'big\'` or `\'little\'`. Considerations - Handle edge cases such as zero and empty byte arrays correctly. - Ensure performance efficiency for large numbers within the 64-bit limit. - Validate the input appropriately to avoid errors.","solution":"def int_to_bytes(num: int): Convert an integer to its byte representation in both big-endian and little-endian formats. :param num: The integer to be converted. :return: A tuple containing the big-endian and little-endian byte representations. big_endian_bytes = num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'big\') little_endian_bytes = num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'little\') return big_endian_bytes, little_endian_bytes def bytes_to_int(bytestr: bytes, endian: str) -> int: Convert a byte array back to an integer, based on the provided endianness. :param bytestr: The byte array to be converted. :param endian: The endianness of the byte array, \\"big\\" or \\"little\\". :return: The integer equivalent of the byte array. return int.from_bytes(bytestr, byteorder=endian)"},{"question":"# Scenario You are developing a simple user management application that allows adding and searching users based on their IDs. Each user\'s data is stored in a binary search tree, where each node represents a user\'s ID. # Task Implement a Binary Search Tree (BST) with functionalities to insert a user ID and search for a user ID. # Requirements * Implement two functions: * `insert(root, val)` to insert a new node with value `val` into the BST. * `search(root, val)` to search for a node with value `val` in the BST and return `True` if found, otherwise `False`. # Input and Output Formats `insert(root, val)` * **Input**: * `root`: The root node of the BST (`TreeNode` type). * `val`: Integer value to be inserted. * **Output**: * `TreeNode`: Return the root of the BST after insertion. `search(root, val)` * **Input**: * `root`: The root node of the BST (`TreeNode` type). * `val`: Integer value to search. * **Output**: * `bool`: `True` if the value exists in the BST, otherwise `False`. # Constraints * Nodes\' values are unique integers. * Values are within the range of -10^4 to 10^4. # Example ```python # Example usage: root = TreeNode(5) root = insert(root, 3) root = insert(root, 7) root = insert(root, 4) print(search(root, 3)) # Output: True print(search(root, 6)) # Output: False ``` # Notes * You may assume the initial call to `insert` will receive `None` as the root (for an empty tree). * Your implementation should handle edge cases such as inserting into an empty tree and searching for non-existent values.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert(root, val): Insert a new node with value val into the BST. if root is None: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) else: root.right = insert(root.right, val) return root def search(root, val): Search for a node with value val in the BST. Return True if found, otherwise False. if root is None: return False if root.val == val: return True elif val < root.val: return search(root.left, val) else: return search(root.right, val)"},{"question":"Context: In project management and task scheduling, detecting cycles in dependency graphs is critical to preventing circular dependencies that can cause tasks to wait indefinitely. This problem can be generalized to checking for cycles in directed graphs. The overall goal is to implement a function that can detect whether any cycle exists within a given directed graph. Problem Statement: Write a function `detect_cycle(graph: Dict[str, List[str]]) -> bool` that determines whether there is a cycle in the graph. The graph is represented as a dictionary where each key is a node, and the associated value is a list of nodes that the key node has edges towards. Input and Output: - **Input**: A dictionary representing the directed graph. - Each key in the dictionary represents a node. - The value is a list of nodes indicating directed edges from the key node to the nodes in the list. - **Output**: A boolean value. - Return `True` if there is a cycle in the graph. - Return `False` if there is no cycle in the graph. Constraints: - Each node can have zero or more edges. - Nodes will be represented by unique strings. - No self-loops are allowed (a node cannot have an edge to itself). Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert detect_cycle(graph) == True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } assert detect_cycle(graph2) == False ``` Requirements: - Performance should be optimal and handle cases efficiently, including the provided example and similar graphs in terms of complexity and size. - Consider edge cases such as empty graphs or graphs with single nodes with no edges. Note: Your solution should leverage depth-first search and the color marking scheme as indicated in the provided implementation to ensure correctness and efficiency.","solution":"def detect_cycle(graph): Function to detect a cycle in a directed graph using DFS. :param graph: Dict[str, List[str]] - The directed graph represented as an adjacency list :return: bool - True if there is a cycle, False otherwise visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"**Problem Statement**: Given an integer `N`, identify all numbers between 1 and `N` (inclusive) such that the sum of their digits raised to consecutive powers equals the number itself. Write a function `find_special_numbers(N)` which returns a list of such numbers. **Function Signature**: ```python def find_special_numbers(N: int) -> List[int]: ``` **Input**: - `N`: An integer (1 ≤ N ≤ 10^6). The upper bound of the range within which to find the special numbers. **Output**: - A list of integers which have the property that the sum of their digits raised to consecutive powers equals the number itself. **Examples**: ```python assert find_special_numbers(100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_special_numbers(150) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] assert find_special_numbers(9) == [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` **Constraints**: - Ensure your function executes efficiently within the given input constraints. - Do not use any built-in functions explicitly handling digit manipulations like `map`, `list` as the main processing methods. **Scenario**: You are developing a software application that helps students understand mathematical properties of numbers. One feature of this application is to identify numbers that have interesting properties, such as the numbers where each digit raised to consecutive powers sums to the number itself. Implementing this feature will require identifying such numbers within a given range efficiently.","solution":"def find_special_numbers(N: int): def sum_of_digits_raised_to_consecutive_powers(num): str_num = str(num) return sum(int(str_num[i]) ** (i + 1) for i in range(len(str_num))) special_numbers = [] for i in range(1, N + 1): if i == sum_of_digits_raised_to_consecutive_powers(i): special_numbers.append(i) return special_numbers"},{"question":"**Gnome Sort Re-implementation with Error Handling and Swaps Count** **Objective**: Gnome Sort is a simple sorting algorithm based on the concept of a \\"garden gnome\\" sorting his flowers. However, it performs poorly on large datasets and can fail to handle edge cases properly. Your task is to re-implement the Gnome Sort algorithm, ensuring it handles edge cases correctly and also tracks the number of swaps performed. **Task**: Write a function `gnome_sort_with_tracking(arr)` that: 1. Takes a list of integers `arr` as input. 2. Sorts the list in ascending order using the Gnome Sort algorithm. 3. Returns a tuple containing: * The sorted list. * The count of swaps performed during the sort. **Constraints**: - Input list length: 0 ≤ len(arr) ≤ 1000. - Input list elements: -10^6 ≤ arr[i] ≤ 10^6. **Function Signature**: ```python def gnome_sort_with_tracking(arr: list) -> tuple: pass ``` **Example**: ```python # Example 1 input_arr = [34, 2, 78, 12, 45, 23] result = gnome_sort_with_tracking(input_arr) # Expected output: ([2, 12, 23, 34, 45, 78], <number_of_swaps>) # Example 2 input_arr = [5, 3, 2, 4, 1] result = gnome_sort_with_tracking(input_arr) # Expected output: ([1, 2, 3, 4, 5], <number_of_swaps>) ``` **Explanation**: - Your function should handle the edge cases such as empty arrays and already sorted arrays. - Ensure your implementation tracks and returns the number of swaps made to sort the list.","solution":"def gnome_sort_with_tracking(arr): Sorts a list using the Gnome Sort algorithm and returns a tuple containing the sorted list and the number of swaps performed. :param arr: List of integers to be sorted. :return: Tuple with the sorted list and the count of swaps performed. if not arr: return (arr, 0) index = 0 swaps = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] swaps += 1 index -= 1 return (arr, swaps)"},{"question":"# Question: Maximum Depth of a Binary Tree You are given a binary tree and your task is to write a function to compute its maximum depth. The maximum depth of the tree is the number of nodes along the longest path from the root node down to the farthest leaf node. Function Signature ```python def max_height(root: TreeNode) -> int: pass ``` Input - `root`: `TreeNode` object, the root of the binary tree. Output - An integer representing the maximum depth of the binary tree. Constraints - The length of the binary tree will be between 0 and 10^4 nodes. - The values in the nodes will be unique integers. - The depth of the tree will not exceed 10^4. Example Consider the binary tree represented as: ``` 10 / 12 15 / / 25 30 36 100 ``` For this tree, the maximum depth is 4. ```python # Example usage: if \'__main__\' == __name__: tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) print(max_height(tree)) # Output: 4 ``` Instructions 1. Implement the function `max_height`. 2. Consider edge cases, such as when the tree is empty. 3. Optimize for both time and space complexity due to the high constraint on the number of nodes.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_height(root: TreeNode) -> int: if root is None: return 0 return 1 + max(max_height(root.left), max_height(root.right))"},{"question":"# Question: Custom Integer Base Conversion You are required to implement a custom integer base conversion in Python. This involves converting an integer to its string representation in a specific base and vice versa. Function 1: `int_to_base` **Input**: - An integer `num` which could be positive or negative. - An integer `base` where 2 ≤ base ≤ 36. **Output**: - A string representation of the integer `num` in the specified base. Function 2: `base_to_int` **Input**: - A string `str_to_convert` representing the number in a specific base. - An integer `base` where 2 ≤ base ≤ 36. **Output**: - An integer value converted from the base representation string `str_to_convert`. # Requirements: 1. Implement `int_to_base(num, base)`: - Handle the number zero properly. - Handle negative integer input. - Utilize characters 0-9 and A-Z for digit representations in bases greater than 10. 2. Implement `base_to_int(str_to_convert, base)`: - Validate the string to ensure it contains valid characters for given base. - Support converting string representations of negative numbers. # Constraints: - The input base will always be in the range [2, 36]. - The input string for `base_to_int` will represent a valid number in the provided base. # Examples: ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-31, 16) == \'-1F\' assert int_to_base(0, 8) == \'0\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'-1F\', 16) == -31 assert base_to_int(\'0\', 10) == 0 ``` # Notes: - Do not use built-in functions for base conversions (e.g., `int(str, base)`).","solution":"def int_to_base(num, base): Converts an integer to a string in a specified base. if num == 0: return \\"0\\" neg = num < 0 if neg: num = -num digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" while num > 0: result = digits[num % base] + result num //= base if neg: result = \\"-\\" + result return result def base_to_int(str_to_convert, base): Converts a string in a specified base to an integer. if str_to_convert[0] == \'-\': neg = True str_to_convert = str_to_convert[1:] else: neg = False digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {c: i for i, c in enumerate(digits)} num = 0 for char in str_to_convert: num = num * base + digit_map[char.upper()] if neg: num = -num return num"},{"question":"Scenario You are given a collection of student scores as an array of integers. Your task is to write a function that sorts these scores in non-decreasing order using an algorithm that is simple to understand and implement, specifically, the Exchange Sort algorithm. Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers, `arr`, where each integer represents a student\'s score. The length of the list can be up to 10^3. Output * A list of integers representing the sorted scores in non-decreasing order. Constraints * `1 <= len(arr) <= 10^3` * `-10^5 <= arr[i] <= 10^5` for each `arr[i]`. Requirements * Implement the function `exchange_sort` such that it uses the Exchange Sort algorithm. * Ensure the function handles edge cases such as empty arrays or arrays with all elements being the same value. Example ```python assert exchange_sort([]) == [] assert exchange_sort([45]) == [45] assert exchange_sort([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] assert exchange_sort([9, -3, -3, 8, 1]) == [-3, -3, 1, 8, 9] ```","solution":"from typing import List def exchange_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Exchange Sort algorithm. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Context You are tasked with developing a system for sorting a series of numeric grades. The system is required to follow insertion sort due to its simplicity and efficient handling of nearly sorted lists. Your job is to extend the given insertion sort algorithm to handle more complex scenarios. # Problem Statement You are given an array of integers `arr` which represents the grades of students. Write a function `advanced_insertion_sort(arr)` to sort this array using the insertion sort algorithm. However, the sorting should be done in such a way that: 1. Any grades that are greater than or equal to 50 should be increased by 10% (round down to nearest integer) before placing them in their final position. 2. If the array contains any grade below 0 or above 100, raise a `ValueError` with the message \\"Grade out of bounds\\". 3. Return the sorted array. # Function Signature ```python def advanced_insertion_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: List of integers, where each integer is between -10 and 110 (inclusive). # Output * Returns the sorted list of integers with adjusted grades as per the problem statement. # Constraints * Length of `arr` is between 1 to 1000. * No element should be less than 0 or greater than 100; if it is, raise a `ValueError`. # Examples ```python print(advanced_insertion_sort([55, 20, 60, 49, 85])) # Output: [20, 49, 60, 66, 93] print(advanced_insertion_sort([52, 48, 102])) # Raises ValueError: \\"Grade out of bounds\\" print(advanced_insertion_sort([-2, 40, 66])) # Raises ValueError: \\"Grade out of bounds\\" ``` # Notes - Implement the insertion sort algorithm as described. - Ensure to handle invalid grades by raising the appropriate error.","solution":"from typing import List def advanced_insertion_sort(arr: List[int]) -> List[int]: Sorts the list `arr` using insertion sort. Before sorting, any grades that are greater than or equal to 50 are increased by 10% (rounded down to the nearest integer). Raises a ValueError if any grades are below 0 or above 100. for grade in arr: if grade < 0 or grade > 100: raise ValueError(\\"Grade out of bounds\\") # Adjust grades >= 50 by increasing them by 10% adjusted_grades = [grade + (grade // 10) if grade >= 50 else grade for grade in arr] # Perform insertion sort for i in range(1, len(adjusted_grades)): key = adjusted_grades[i] j = i - 1 while j >= 0 and key < adjusted_grades[j]: adjusted_grades[j + 1] = adjusted_grades[j] j -= 1 adjusted_grades[j + 1] = key return adjusted_grades"},{"question":"**Task**: Write a function that assesses the validity of an N x N Sudoku board. **Background**: Sudoku is a number puzzle where a partially filled N x N grid must be validated. The rules are: 1. Each row must have the numbers 1 to N, without repetition. 2. Each column must have the numbers 1 to N, without repetition. 3. Each corresponding N^0.5 x N^0.5 sub-grid must have the numbers 1 to N, without repetition. **Function Signature**: `def is_valid_sudoku(board: List[List[str]], N: int) -> bool:` **Input**: - `board`: A list of lists of strings, representing the Sudoku grid (N x N). Each cell is filled with a number (1 to N as strings) or \'.\' for empty cells. - `N`: An integer representing the size of the grid. **Output**: - Return `True` if the board meets the Sudoku criteria, else `False`. **Constraints**: - The length and width of the board will always be an exact square number (1, 4, 9, 16, ...). - Each element in board is either a number between \'1\' and \'N\' or \'.\'. - Empty spaces are represented by \'.\'. **Performance**: The solution should have a time complexity of O(N^2). **Examples**: Example 1: ``` Input: board = [ [\'5\', \'3\', \'.\', \'.\', \'7\', \'.\', \'.\', \'.\', \'.\'], [\'6\', \'.\', \'.\', \'1\', \'9\', \'5\', \'.\', \'.\', \'.\'], [\'.\', \'9\', \'8\', \'.\', \'.\', \'.\', \'.\', \'6\', \'.\'], [\'8\', \'.\', \'.\', \'.\', \'6\', \'.\', \'.\', \'.\', \'3\'], [\'4\', \'.\', \'.\', \'8\', \'.\', \'3\', \'.\', \'.\', \'1\'], [\'7\', \'.\', \'.\', \'.\', \'2\', \'.\', \'.\', \'.\', \'6\'], [\'.\', \'6\', \'.\', \'.\', \'.\', \'.\', \'2\', \'8\', \'.\'], [\'.\', \'.\', \'.\', \'4\', \'1\', \'9\', \'.\', \'.\', \'5\'], [\'.\', \'.\', \'.\', \'.\', \'8\', \'.\', \'.\', \'7\', \'9\'] ] N = 9 Output: True ``` Example 2: ``` Input: board = [ [\'8\', \'3\', \'.\', \'.\', \'7\', \'.\', \'.\', \'.\', \'.\'], [\'6\', \'.\', \'.\', \'1\', \'9\', \'5\', \'.\', \'.\', \'.\'], [\'.\', \'9\', \'8\', \'.\', \'.\', \'.\', \'.\', \'6\', \'.\'], [\'8\', \'.\', \'.\', \'.\', \'6\', \'.\', \'.\', \'.\', \'3\'], [\'4\', \'.\', \'.\', \'8\', \'.\', \'3\', \'.\', \'.\', \'1\'], [\'7\', \'.\', \'.\', \'.\', \'2\', \'.\', \'.\', \'.\', \'6\'], [\'.\', \'6\', \'.\', \'.\', \'.\', \'.\', \'2\', \'8\', \'.\'], [\'.\', \'.\', \'.\', \'4\', \'1\', \'9\', \'.\', \'.\', \'5\'], [\'.\', \'.\', \'.\', \'.\', \'8\', \'.\', \'.\', \'7\', \'9\'] ] N = 9 Output: False Explanation: \'8\' is repeated in the first column. ``` **Note**: Pay special attention to ensuring each sub-grid of size N^0.5 x N^0.5 meets the criteria.","solution":"from typing import List def is_valid_sudoku(board: List[List[str]], N: int) -> bool: sub_grid_size = int(N ** 0.5) def is_valid_group(group): seen = set() for value in group: if value != \'.\': if value in seen: return False seen.add(value) return True for row in board: if not is_valid_group(row): return False for col in range(N): column = [board[row][col] for row in range(N)] if not is_valid_group(column): return False for box_row in range(0, N, sub_grid_size): for box_col in range(0, N, sub_grid_size): box = [board[r][c] for r in range(box_row, box_row + sub_grid_size) for c in range(box_col, box_col + sub_grid_size)] if not is_valid_group(box): return False return True"},{"question":"# Roman to Integer Conversion Objective Write a function that converts a Roman numeral string to its corresponding integer value. This function will test your ability to understand and implement conversion algorithms, emphasizing correct value mappings and order-based evaluations. Input * A single string `s` which is a valid Roman numeral representing a number between 1 and 3999. Output * An integer that represents the Roman numeral value. Constraints * The input string `s` will be a valid Roman numeral within the range from 1 to 3999. Performance Requirements * The solution should have a time complexity of O(n) and space complexity of O(1), where n is the length of the Roman numeral string. Function Signature ```python def roman_to_int(s: str) -> int: pass ``` Example Input: ```python \\"DCXXI\\" ``` Output: ```python 621 ``` Instructions 1. Define a dictionary `roman` to map Roman numerals to integer values. 2. Traverse each character in the input string `s`. 3. Compare each character with the next to decide addition or subtraction. 4. Sum the values based on the defined rules. 5. Return the calculated integer as the result. Scenario Roman numerals have been widely used in history and are still of interest in various educational and data processing contexts. This algorithm is a practical tool for converting historical data into modern formats or for teaching purposes. This implementation focuses on correct and efficient conversion adhering to the standard Roman numeral rules.","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to an integer. roman = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"Context Consider a scenario where you have to merge two educational content sources into a single instructional document. You need to verify if a particular merged result is feasible given the order constraints of the original content sources. Problem Statement Implement a function `is_valid_interleaving(s: str, part1: str, part2: str) -> bool` that determines whether the string `s` is a valid interleaving of strings `part1` and `part2`. **Criteria**: - All characters in `part1` and `part2` must appear in `s` while retaining their respective order. - Alternating characters from `part1` and `part2` are allowed, but their linear order must be strictly followed. Function Signature ```python def is_valid_interleaving(s: str, part1: str, part2: str) -> bool: pass ``` Input * `s` (`str`): A non-empty string representing the merged document. * `part1` (`str`): A string representing the first content source. * `part2` (`str`): A string representing the second content source. Output * Returns `True` if `s` is a valid interleaving of `part1` and `part2`, otherwise `False`. Constraints * 0 <= len(s), len(part1), len(part2) <= 100. * `s`, `part1`, and `part2` consist of lowercase English letters only. Performance Requirements * Aim for an optimized solution that manages both time and space efficiently, potentially through a dynamic programming approach. Example ```python assert is_valid_interleaving(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_valid_interleaving(\\"abcdef\\", \\"abc\\", \\"def\\") == True assert is_valid_interleaving(\\"aabcc\\", \\"abc\\", \\"abc\\") == False assert is_valid_interleaving(\\"ab\\", \\"abc\\", \\"def\\") == False assert is_valid_interleaving(\\"\\", \\"\\", \\"\\") == True assert is_valid_interleaving(\\"ab\\", \\"a\\", \\"b\\") == True assert is_valid_interleaving(\\"abc\\", \\"a\\", \\"bc\\") == True assert is_valid_interleaving(\\"abc\\", \\"ab\\", \\"c\\") == True ``` Additional Information * You should consider edge cases like empty strings and disjoint interleaving from `part1` and `part2`.","solution":"def is_valid_interleaving(s: str, part1: str, part2: str) -> bool: # Length check if len(s) != len(part1) + len(part2): return False # Create a DP table dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] # Iterate over the table for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i == 0 and j == 0: dp[i][j] = True elif i == 0: dp[i][j] = dp[i][j-1] and part2[j-1] == s[i+j-1] elif j == 0: dp[i][j] = dp[i-1][j] and part1[i-1] == s[i+j-1] else: dp[i][j] = (dp[i-1][j] and part1[i-1] == s[i+j-1]) or (dp[i][j-1] and part2[j-1] == s[i+j-1]) return dp[len(part1)][len(part2)]"},{"question":"You are developing a performance-critical application that requires manipulation of specific bits in 32-bit integers. Write a class `BitManipulator` that implements the following methods using bitwise operations: 1. **get_bit(self, num: int, i: int) -> int**: Returns the bit (0 or 1) at position `i` in the integer `num`. 2. **set_bit(self, num: int, i: int) -> int**: Sets the bit at position `i` in the integer `num` to 1. 3. **clear_bit(self, num: int, i: int) -> int**: Clears the bit at position `i` in the integer `num` (sets it to 0). 4. **update_bit(self, num: int, i: int, bit: int) -> int**: Updates the bit at position `i` in the integer `num` to the value of `bit` (either 0 or 1). Input/Output * **get_bit(num: int, i: int) -> int** * **Input**: integer `num`, integer `i` where 0 <= i < 32 * **Output**: integer (0 or 1), the bit at position `i` * **set_bit(num: int, i: int) -> int** * **Input**: integer `num`, integer `i` where 0 <= i < 32 * **Output**: integer, `num` with the bit at position `i` set to 1 * **clear_bit(num: int, i: int) -> int** * **Input**: integer `num`, integer `i` where 0 <= i < 32 * **Output**: integer, `num` with the bit at position `i` cleared to 0 * **update_bit(num: int, i: int, bit: int) -> int** * **Input**: integer `num`, integer `i` where 0 <= i < 32, integer `bit` (0 or 1) * **Output**: integer, `num` with the bit at position `i` updated to `bit`. # Constraints * The integer `i` will always be between 0 and 31 (inclusive). * The value of `bit` for the `update_bit` function will always be either 0 or 1. * Input integers will be within the 32-bit signed integer range. # Example ```python bm = BitManipulator() print(bm.get_bit(5, 2)) # Output: 1 (binary 101, the bit at index 2 is 1) print(bm.set_bit(5, 1)) # Output: 7 (binary 111, setting bit at index 1: 101 -> 111) print(bm.clear_bit(5, 2)) # Output: 1 (binary 001, clearing bit at index 2: 101 -> 001) print(bm.update_bit(5, 1, 0)) # Output: 4 (binary 100, updating bit at index 1 to 0: 101 -> 100) ``` Write the implementation of the `BitManipulator` class based on the descriptions and examples provided.","solution":"class BitManipulator: def get_bit(self, num: int, i: int) -> int: Returns the bit (0 or 1) at position `i` in the integer `num`. return (num >> i) & 1 def set_bit(self, num: int, i: int) -> int: Sets the bit at position `i` in the integer `num` to 1. return num | (1 << i) def clear_bit(self, num: int, i: int) -> int: Clears the bit at position `i` in the integer `num` (sets it to 0). return num & ~(1 << i) def update_bit(self, num: int, i: int, bit: int) -> int: Updates the bit at position `i` in the integer `num` to the value of `bit` (either 0 or 1). return (num & ~(1 << i)) | (bit << i)"},{"question":"# Context You\'re tasked with implementing a search functionality in a large e-commerce website that allows users to search for product prices quickly. Given the array of prices is always sorted in ascending order, a binary search implementation is ideal due to its efficiency. # Problem Statement Write a function `find_price_index` that takes two arguments: 1. A list of integers `price_list` representing the sorted product prices. 2. An integer `target_price` representing the price to search for. Your function should return the index of `target_price` in `price_list` if it exists. If `target_price` is not in the list, return -1. Use binary search to solve this problem efficiently. # Constraints - The `price_list` will always be sorted in ascending order. - 1 ≤ len(price_list) ≤ 10^5 - -10^6 ≤ price_list[i], target_price ≤ 10^6 # Performance Requirements - Time complexity: O(log(n)) - Space complexity: O(1) for the iterative solution or O(log(n)) for the recursive solution. # Function Signature ```python def find_price_index(price_list: list[int], target_price: int) -> int: pass ``` # Examples ```python assert find_price_index([1, 3, 5, 7, 9], 7) == 3 assert find_price_index([1, 2, 3, 4, 5], 6) == -1 assert find_price_index([], 3) == -1 assert find_price_index([1], 1) == 0 ``` Please make sure your solution passes the provided example cases and handle edge cases appropriately.","solution":"def find_price_index(price_list, target_price): Performs a binary search to find the index of target_price in price_list. Returns the index if target_price is found, otherwise returns -1. left, right = 0, len(price_list) - 1 while left <= right: mid = (left + right) // 2 if price_list[mid] == target_price: return mid elif price_list[mid] < target_price: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Implement `contains_key` Method for Separate Chaining Hash Table **Context**: You are enhancing the functionality of the `SeparateChainingHashTable` class provided. Currently, it supports basic operations such as insertion, deletion, and retrieval of key-value pairs. **Task**: Implement a method `contains_key` within the `SeparateChainingHashTable` class that checks if a given key exists in the hash table. **Function Signature**: ```python def contains_key(self, key: Any) -> bool: Returns True if the key exists in the hash table, otherwise False. ``` **Constraints**: - You may assume the keys are hashable types. - The method should have a time complexity of `O(1)` on average and `O(n)` in the worst case. **Input/Output**: - **Input**: A single key to be checked for existence. - **Output**: A boolean indicating if the key is present or not. **Example**: ```python table = SeparateChainingHashTable() table.put(\\"apple\\", \\"fruit\\") table.put(\\"carrot\\", \\"vegetable\\") print(table.contains_key(\\"apple\\")) # Output: True print(table.contains_key(\\"banana\\")) # Output: False ``` **Implementation**: - Implement the `contains_key` method within the `SeparateChainingHashTable` class.","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=10): self.table = [[] for _ in range(initial_capacity)] self.size = 0 def _hash(self, key): return hash(key) % len(self.table) def put(self, key, value): index = self._hash(key) for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.size += 1 def get(self, key): index = self._hash(key) for k, v in self.table[index]: if k == key: return v return None def remove(self, key): index = self._hash(key) for i, (k, v) in enumerate(self.table[index]): if k == key: del self.table[index][i] self.size -= 1 return v return None def contains_key(self, key): index = self._hash(key) for k, v in self.table[index]: if k == key: return True return False"},{"question":"# Scenario You are a network engineer tasked with optimizing the cable layout for a new citywide internet service. The city comprises several potential junctions (nodes) that can be connected via underground cables (edges). The goal is to ensure that all junctions are connected with the least possible total cable length. # Problem Statement Write a Python function `minimum_spanning_tree(vertex_count, edges)` that utilizes Kruskal\'s algorithm to compute the Minimum Spanning Tree (MST) for a given undirected, connected graph. The function should use the `DisjointSet` class (Union-Find data structure) to help manage the different sets of nodes during the merging process. # Function Signature ```python def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: Compute the sum of weights of the MST for a given graph using Kruskal\'s algorithm. Args: vertex_count (int): The number of vertices in the graph. edges (List[Tuple[int, int, int]]): A list of tuples representing the edges of the graph, where each tuple is of the form (source, target, weight). Returns: int: The sum of the weights of the MST. pass ``` # Input Format - `vertex_count`: An integer `V` (2 ≤ V ≤ 1000), representing the number of vertices. - `edges`: A list of tuples `(source, target, weight)`, where each tuple represents an edge with a source node, target node, and the weight of the edge (1 ≤ weight ≤ 1000). The nodes are indexed from 0 to `V-1`. # Output Format - An integer representing the total weight of the MST. # Constraints - The graph is guaranteed to be connected (i.e., there is a path between any two vertices). - The graph does not contain self-loops. - There are no negative weights. # Examples ```python assert minimum_spanning_tree(5, [(0, 1, 3), (0, 2, 8), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 6)]) == 14 assert minimum_spanning_tree(3, [(1, 0, 20), (2, 0, 20), (1, 2, 100)]) == 40 ``` # Detailed Explanation 1. Parse the input and initialize the `DisjointSet` for vertex management. 2. Sort the edges based on their weights. 3. Iterate through the edges, using the `DisjointSet` to ensure no cycles form. Only add edges from different sets to the MST. 4. Terminate once there are (V-1) edges in the MST and return the total weight.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: edges.sort(key=lambda e: e[2]) disjoint_set = DisjointSet(vertex_count) mst_weight = 0 edges_used = 0 for u, v, weight in edges: if disjoint_set.find(u) != disjoint_set.find(v): disjoint_set.union(u, v) mst_weight += weight edges_used += 1 if edges_used == vertex_count - 1: break return mst_weight"},{"question":"Problem Statement You are working on a system that communicates with devices using both big-endian and little-endian integer representations. To ensure correct data handling, you need to write a function to correctly convert integers to bytes and vice versa for both endianness formats. Implement the following functions: 1. **int_to_bytes(num: int, byteorder: str) -> bytes** - **Input**: A non-negative integer `num` and a string `byteorder` which is either `\\"big\\"` or `\\"little\\"`. - **Output**: A bytes object representing the integer in the specified byte order. - **Constraints**: The integer will be non-negative and fit within 64 bits. 2. **bytes_to_int(bytestr: bytes, byteorder: str) -> int** - **Input**: A bytes object `bytestr` and a string `byteorder` which is either `\\"big\\"` or `\\"little\\"`. - **Output**: An integer representing the bytes interpreted in the specified byte order. Here are some example calls and their expected outputs: ```python # Example 1 assert int_to_bytes(1024, \\"big\\") == b\'x00x04x00\' assert bytes_to_int(b\'x00x04x00\', \\"big\\") == 1024 # Example 2 assert int_to_bytes(1024, \\"little\\") == b\'x00x04\' assert bytes_to_int(b\'x00x04\', \\"little\\") == 1024 # Example 3 assert int_to_bytes(255, \\"big\\") == b\'xff\' assert bytes_to_int(b\'xff\', \\"big\\") == 255 # Example 4 assert int_to_bytes(255, \\"little\\") == b\'xff\' assert bytes_to_int(b\'xff\', \\"little\\") == 255 ```","solution":"def int_to_bytes(num: int, byteorder: str) -> bytes: Converts an integer to bytes in the specified byte order. :param num: A non-negative integer to convert. :param byteorder: \'big\' for big-endian, \'little\' for little-endian. :return: Bytes representation of the integer. # Ensure the byteorder is either \'big\' or \'little\' if byteorder not in (\\"big\\", \\"little\\"): raise ValueError(\\"byteorder must be either \'big\' or \'little\'\\") # Convert the integer to bytes return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder) def bytes_to_int(bytestr: bytes, byteorder: str) -> int: Converts bytes to an integer in the specified byte order. :param bytestr: Bytes object to convert. :param byteorder: \'big\' for big-endian, \'little\' for little-endian. :return: Integer representation of the bytes. # Ensure the byteorder is either \'big\' or \'little\' if byteorder not in (\\"big\\", \\"little\\"): raise ValueError(\\"byteorder must be either \'big\' or \'little\'\\") # Convert the bytes to an integer return int.from_bytes(bytestr, byteorder)"},{"question":"Context You have been hired by a company to develop a fast sorting function for a large dataset of numbers. The dataset contains both positive and negative integers. Due to operational constraints, the range of the numbers in the dataset is relatively small compared to the number of elements. Problem Statement Write a Python function `advanced_counting_sort(arr: List[int]) -> List[int]` that sorts an array of integers using an optimized version of the counting sort algorithm. Your implementation should handle both positive and negative numbers without converting the whole array to positive values. Input * `arr`: a list of integers (both positive and negative). Output * The function should return a new list of integers sorted in non-decreasing order. Constraints * The array can contain duplicate elements. * It\'s guaranteed that the range of numbers (difference between the largest and smallest values) will not exceed 10^6. Performance Requirements * The solution should have a time complexity of O(n + k), where `n` is the number of elements in the input array and `k` is the range of the input. * Space complexity should be optimized to O(k). Example ```python from typing import List def advanced_counting_sort(arr: List[int]) -> List[int]: # TODO: Implement this method pass # Example: input_arr = [-5, -10, -3, -1, 0, 2, 3, 5, 5, -1] output_arr = advanced_counting_sort(input_arr) print(output_arr) # Output: [-10, -5, -3, -1, -1, 0, 2, 3, 5, 5] ``` You are required to handle negative numbers appropriately in your optimized counting sort to ensure the method works correctly and efficiently.","solution":"from typing import List def advanced_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Create a count array to store counts of individual elements range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements # Store the count of each element for num in arr: count[num - min_val] += 1 # Reconstruct the sorted array index = 0 sorted_arr = [0] * len(arr) for i, cnt in enumerate(count): while cnt > 0: sorted_arr[index] = i + min_val index += 1 cnt -= 1 return sorted_arr"},{"question":"**Scenario**: Imagine you are working on an e-commerce website where you need to filter product prices within a certain range before displaying them to the user. Given an array of product prices, your task is to implement a function that filters these prices based on minimum and/or maximum boundaries. # Problem Statement: Write a Python function `filter_prices(prices, min_price=None, max_price=None)` that filters a list of `prices` within a given `min_price` and `max_price`. If `min_price` or `max_price` is not provided, they should be considered as unbounded on that side. # Input and Output Formats: - **Input**: - `prices`: List of integers or floating-point numbers representing prices. - `min_price`: Integer or floating-point number representing the minimum price (inclusive). Default is `None`. - `max_price`: Integer or floating-point number representing the maximum price (inclusive). Default is `None`. - **Output**: - List of prices that are within the specified range [min_price, max_price]. # Constraints: - If `prices` is empty, the function should return an empty list. - If no `min_price` is provided, filter based on only the `max_price`. - If no `max_price` is provided, filter based on only the `min_price`. - If both are not provided, return the original list. # Examples: ```python assert filter_prices([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert filter_prices([5, 3, 7, 1, 9, 11], 5) == [5, 7, 9, 11] assert filter_prices([100, 200, 300, 400], None, 250) == [100, 200] assert filter_prices([], 10, 20) == [] assert filter_prices([50, 60, 70], None, None) == [50, 60, 70] ``` # Performance Requirements: The solution should have a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the `prices` list. # Implementation: Implement the `filter_prices` function in Python as described above.","solution":"def filter_prices(prices, min_price=None, max_price=None): Filters the list of prices based on the given min_price and max_price. :param prices: List of integers or floating-point numbers representing prices. :param min_price: Integer or floating-point number representing the minimum price (inclusive). Default is None. :param max_price: Integer or floating-point number representing the maximum price (inclusive). Default is None. :return: List of prices that are within the specified range [min_price, max_price]. filtered_prices = [] for price in prices: if (min_price is None or price >= min_price) and (max_price is None or price <= max_price): filtered_prices.append(price) return filtered_prices"},{"question":"# Question Scenario You work for a company that processes large datasets of integers. Your task is to design an efficient algorithm that finds the unique integer in these datasets, where every integer appears exactly three times except for one. Problem Statement Given an array of integers, where every element appears exactly three times except for one element which appears exactly once, write a function to find that single element. Your solution should have a linear runtime complexity (mathcal{O}(n)) and should not use additional memory (i.e., constant space complexity (mathcal{O}(1))). # Function Signature ```python def find_unique(nums: List[int]) -> int: ``` # Input * `nums`: A list of integers where: - len(nums) >= 4 - Each integer appears three times except one. # Output * Return the integer that appears exactly once. # Constraints * Your solution must have a linear runtime complexity. * You must not use extra memory, i.e., constant space usage is required. # Example ```python # Example 1 nums = [2, 2, 3, 2] Output: 3 # Example 2 nums = [0, 1, 0, 1, 0, 1, 99] Output: 99 ``` Note: Make sure to handle potential edge cases and test your solution against arrays of different sizes and patterns. # Hints 1. You can solve this problem by keeping track of counts of bits. 2. Use bitwise operators to maintain counts of each bit position.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Finds the unique element in the list where every other element appears exactly three times. Args: nums : List[int] : List of integers. Returns: int : The unique integer that appears exactly once. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Task **Context**: You are given an implementation of an AVL Tree, a self-balancing binary search tree. The tree automatically maintains its balance factor via rotations during insertions. **Objective**: Implement additional functionality to the AVL Tree class that ensures correct in-order traversal and removal of a specified node, maintaining the tree\'s balance property. # Requirements: 1. **Function to perform In-Order Traversal**: Return a sorted list of all keys in the AVL Tree. - **Function Signature**: `def in_order_traverse(self) -> list:` - **Output**: A list of keys in sorted order. 1. **Function to Remove a Key**: Remove a specified node such that the AVL Tree properties are maintained. - **Function Signature**: `def remove(self, key) -> None:` - **Input**: `key` (integer) – The key to be removed from the AVL Tree. - **Constraints**: - The key exists in the tree. - The tree should remain balanced after removal. # Example: Given the following sequence of operations: ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.insert(25) print(avl.in_order_traverse()) # Expected Output: [10, 20, 25, 30, 40, 50] avl.remove(25) print(avl.in_order_traverse()) # Expected Output: [10, 20, 30, 40, 50] ``` # Constraints: - Each insertion or removal must take O(log n) time complexity in the average case. - The AVL Tree should handle at most 10^4 operations within acceptable time limits. **Hints**: 1. Use the rotation functions `rotate_left` and `rotate_right` to maintain balance. 2. Ensure to correctly update heights and balance factors during operations.","solution":"class AvlNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = AvlNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AvlNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._rotate_right(node) if balance < -1 and key > node.right.key: return self._rotate_left(node) if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def remove(self, key): if not self.root: return None self.root = self._remove(self.root, key) def _remove(self, node, key): if not node: return node if key < node.key: node.left = self._remove(node.left, key) elif key > node.key: node.right = self._remove(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._remove(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._rotate_right(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._rotate_left(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"# Randomized Data Structure Implementation You are tasked with designing a data structure named `RandomizedCollection` that supports the following operations in *average* O(1) time: 1. **insert(val)**: Inserts an item `val` to the set if it is not already present. 2. **remove(val)**: Removes an item `val` from the set if it is present. 3. **get_random**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Implement the `RandomizedCollection` class with the following methods: Method Definitions: ```python class RandomizedCollection: def __init__(self): # Initialize your data structure here. def insert(self, val): Inserts an item val to the set if not present. Returns True if the item was not present, False otherwise. def remove(self, val): Removes an item val from the set if present. Returns True if the item was present, False otherwise. def get_random(self): Returns a random element from the current set of elements. Each element must have the same probability of being returned. ``` # Input and Output: * `insert(val)`: * **Inputs**: `val` (Any integer). * **Outputs**: `True` if insertion is successful, `False` otherwise. * `remove(val)`: * **Inputs**: `val` (Any integer). * **Outputs**: `True` if removal is successful, `False` otherwise. * `get_random()`: * **Outputs**: Returns a random element from the set anytime the method is called. # Example: ```python rc = RandomizedCollection() print(rc.insert(1)) # Returns True print(rc.insert(2)) # Returns True print(rc.insert(1)) # Returns False print(rc.remove(1)) # Returns True print(rc.remove(3)) # Returns False print(rc.get_random()) # Returns either 1 or 2 randomly print(rc.get_random()) # Returns either 1 or 2 randomly ``` # Constraints: * You may assume at most 10^5 calls will be made to `insert`, `remove`, and `get_random` methods. # Notes: * Handle edge cases where the collection might be empty when `get_random` is called. * Ensure that the data structure functions efficiently even with a large number of operations or elements.","solution":"import random class RandomizedCollection: def __init__(self): self.items = [] self.val_to_index = {} def insert(self, val): Inserts an item val to the collection. Returns True if the item was not present, False otherwise. if val not in self.val_to_index: self.val_to_index[val] = set() self.val_to_index[val].add(len(self.items)) self.items.append(val) return len(self.val_to_index[val]) == 1 def remove(self, val): Removes an item val from the collection. Returns True if the item was present, False otherwise. if val not in self.val_to_index or not self.val_to_index[val]: return False # Get an index of the element to delete index_to_remove = self.val_to_index[val].pop() last_element = self.items[-1] # Replace the element to remove with the last element self.items[index_to_remove] = last_element self.val_to_index[last_element].add(index_to_remove) self.val_to_index[last_element].remove(len(self.items) - 1) # Remove the last element self.items.pop() # If after removal the set is empty, delete the key from the dictionary if not self.val_to_index[val]: del self.val_to_index[val] return True def get_random(self): Returns a random element from the current collection of elements. Each element must have the same probability of being returned. if not self.items: return None return random.choice(self.items)"},{"question":"The company \\"SortItOut\\" is working on a new feature for their product, and they need your help to develop an optimized sorting algorithm. While they already have an implementation of the Insertion Sort, they are interested in a potentially more efficient variation called **Binary Insertion Sort**. # Binary Insertion Sort Binary Insertion Sort is a variant of the Insertion Sort algorithm. It improves the performance by using binary search to find the correct location to insert each element, thereby reducing the number of comparisons. # Task Implement the `binary_insertion_sort` function that sorts an array using the Binary Insertion Sort algorithm. # Function Signature ```python def binary_insertion_sort(arr: List[int]) -> List[int]: ``` # Input * An array `arr` of integers where `1 <= len(arr) <= 1000`. # Output * Return the sorted array `arr`. # Constraints * Implement the function to run within O(n^2) time complexity and O(1) space complexity (excluding input and output). # Example ```python assert binary_insertion_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert binary_insertion_sort([]) == [] assert binary_insertion_sort([1]) == [1] assert binary_insertion_sort([5, -2, 4, -1, 0, -3, 9]) == [-3, -2, -1, 0, 4, 5, 9] ``` # Note * Use binary search technique to find positions to insert elements within the sorted subset of the array during sorting.","solution":"from typing import List def binary_insertion_sort(arr: List[int]) -> List[int]: Sorts an array using the Binary Insertion Sort algorithm. def binary_search(sub_arr, val, start, end): Performs binary search to find the position to insert the value. while start < end: mid = (start + end) // 2 if sub_arr[mid] < val: start = mid + 1 else: end = mid return start for i in range(1, len(arr)): val = arr[i] pos = binary_search(arr, val, 0, i) # Shift elements to make room for the inserted element arr = arr[:pos] + [val] + arr[pos:i] + arr[i+1:] return arr"},{"question":"# Scenario You are part of a development team working on a real-time data processing system where maintaining a sorted list of elements is crucial. One of the core functionalities you need to implement involves efficiently finding the correct position to insert new elements to keep the list sorted. # Task Write a function named `find_insertion_point` that takes two arguments: 1. A sorted list of integers, `sorted_array`. 2. A target integer value, `target`. Your goal is to determine the index at which `target` should be inserted to maintain the sorted order of `sorted_array`. # Function Signature ```python def find_insertion_point(sorted_array: List[int], target: int) -> int: # Your implementation here ``` # Input - `sorted_array`: A list of integers sorted in non-decreasing order. List length ranges from 0 to (10^5). - `target`: An integer value to be inserted. # Output - Return an integer index where `target` should be inserted. # Constraints - The algorithm should run with a time complexity of (O(log n)), where (n) is the length of `sorted_array`. # Example ```python assert find_insertion_point([1, 3, 5, 6], 5) == 2 assert find_insertion_point([1, 3, 5, 6], 2) == 1 assert find_insertion_point([1, 3, 5, 6], 7) == 4 assert find_insertion_point([1, 3, 5, 6], 0) == 0 ``` # Notes - Consider all edge cases, such as empty arrays and values not between existing elements. - Optimize your code for performance and correctness.","solution":"from typing import List def find_insertion_point(sorted_array: List[int], target: int) -> int: Returns the index at which `target` should be inserted to maintain the sorted order of `sorted_array`. Uses binary search for efficient O(log n) time complexity. left, right = 0, len(sorted_array) while left < right: mid = (left + right) // 2 if sorted_array[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"**Scenario**: You are given a task to analyze the structure of a binary search tree used in a company\'s internal tool for managing hierarchical data. One of the key metrics to calculate is the number of empty branches (or empty child references) in the tree. Each node can have up to two children, and an empty branch is defined as a `None` reference in the left or right child positions. **Task**: Write a function `num_empty(root)` that returns the number of empty branches in a given binary search tree. # Function Signature ```python def num_empty(root) -> int: ``` # Input - `root`: The root node of the Binary Search Tree. If the tree is empty, `root` is `None`. # Output - Return an integer representing the number of empty branches in the tree. # Constraints 1. The tree can have up to `10^4` nodes. 2. Node values are unique integers. # Example ```python # Define the structure of the BST node class Node: def __init__(self, key): self.left = None self.right = None self.val = key # Example tree: # 9 # / # 6 12 # / / # 3 8 10 15 # # 7 18 # Create the nodes root = Node(9) root.left = Node(6) root.right = Node(12) root.left.left = Node(3) root.left.right = Node(8) root.right.left = Node(10) root.right.right = Node(15) root.left.right.right = Node(7) root.right.right.right = Node(18) print(num_empty(root)) # Output should be 10 ``` # Notes - An empty tree (where `root` is `None`) is considered to have 1 empty branch. - Nodes with no children contribute 2 empty branches (one for each absent child).","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def num_empty(root) -> int: if root is None: return 1 # An empty tree is considered to have 1 empty branch. empty_count = 0 # Use a stack to perform a depth-first traversal of the tree. stack = [root] while stack: current = stack.pop() # Check left child. if current.left is None: empty_count += 1 else: stack.append(current.left) # Check right child. if current.right is None: empty_count += 1 else: stack.append(current.right) return empty_count"},{"question":"You are required to implement a function to calculate the unknown side length of a right-angled triangle given the lengths of the other two sides. The function will receive the known lengths of either the opposite, adjacent, or hypotenuse side, and return the length of the third side. The \'unknown\' side will be indicated by the wildcard string \\"?\\". # Function Signature ```python def find_unknown_side(opposite: Union[str, float], adjacent: Union[str, float], hypotenuse: Union[str, float]) -> str: pass ``` # Input Parameters - `opposite` - Length of the opposite side (type `float` or `str` \\"?\\" indicating unknown). - `adjacent` - Length of the adjacent side (type `float` or `str` \\"?\\" indicating unknown). - `hypotenuse` - Length of the hypotenuse side (type `float` or `str` \\"?\\" indicating unknown). # Output - It should return a string in the format \\"Side = value\\" where \'Side\' is \'Opposite\', \'Adjacent\', or \'Hypotenuse\', and \'value\' is the calculated length of the unknown side (rounded to 2 decimal places). # Constraints - Only one side can be unknown at a time. - The known side lengths will be valid floating-point numbers. - The hypotenuse will always be the longest side. - Consider numerical precision up to two decimal points for the result. # Example ```python # Example 1 find_unknown_side(\\"?\\", 4.0, 5.0) # Expected output: \\"Opposite = 3.0\\" # Example 2 find_unknown_side(3.0, \\"?\\", 5.0) # Expected output: \\"Adjacent = 4.0\\" # Example 3 find_unknown_side(3.0, 4.0, \\"?\\") # Expected output: \\"Hypotenuse = 5.0\\" ``` # Notes - Make sure to handle any invalid arguments gracefully by raising an appropriate exception.","solution":"import math from typing import Union def find_unknown_side(opposite: Union[str, float], adjacent: Union[str, float], hypotenuse: Union[str, float]) -> str: if opposite == \\"?\\": if isinstance(adjacent, (float, int)) and isinstance(hypotenuse, (float, int)): opposite_value = math.sqrt(hypotenuse ** 2 - adjacent ** 2) return f\\"Opposite = {round(opposite_value, 2)}\\" elif adjacent == \\"?\\": if isinstance(opposite, (float, int)) and isinstance(hypotenuse, (float, int)): adjacent_value = math.sqrt(hypotenuse ** 2 - opposite ** 2) return f\\"Adjacent = {round(adjacent_value, 2)}\\" elif hypotenuse == \\"?\\": if isinstance(opposite, (float, int)) and isinstance(adjacent, (float, int)): hypotenuse_value = math.sqrt(opposite ** 2 + adjacent ** 2) return f\\"Hypotenuse = {round(hypotenuse_value, 2)}\\" else: raise ValueError(\\"One side must be unknown represented by \'?\'\\") raise ValueError(\\"Invalid input values provided\\")"},{"question":"# Question: Depth-First Search Path Verification You are tasked with determining if there is a path between two nodes in a directed graph. The graph is represented by a class `Graph` which will allow you to add directed edges and check if a path exists between two nodes using Depth-First Search (DFS) traversal. Description Create an implementation of the `Graph` class and complete the `is_reachable` method to determine if there\'s a path from a given source node to a given target node. Detailed Requirements - Class Definition: ```python class Graph: def __init__(self, vertex_count): Initialize the graph with the given number of vertices. def add_edge(self, source, target): Add a directed edge from source node to target node. def is_reachable(self, source, target): Return True if there is a path from source to target, else return False. ``` - `__init__(self, vertex_count)`: * Initializes the graph with the given number of vertices. - `add_edge(self, source, target)`: * Adds a directed edge from the `source` node to the `target` node. - `is_reachable(self, source, target)`: * Determines if there is a path from the `source` node to the `target` node using DFS or another appropriate algorithm. Input and Output - **Input**: - `vertex_count`: Integer, the number of vertices in the graph. - `edges`: List of tuples providing the directed edges (source, target). - `source`: Integer, the node from which the search starts. - `target`: Integer, the node at which the search ends. - **Output**: - Returns a boolean indicating whether a path exists from `source` to `target`. Constraints - All inputs will be valid and vertices are 0-indexed. - The graph can have up to 10,000 vertices and 50,000 edges. Example ```python # Initialize the graph g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(3, 2) # Check if there is a path from node 0 to node 2 print(g.is_reachable(0, 2)) # Output: True # Check if there is a path from node 3 to node 1 print(g.is_reachable(3, 1)) # Output: False ```","solution":"class Graph: def __init__(self, vertex_count): Initialize the graph with the given number of vertices. self.vertex_count = vertex_count self.graph = {i: [] for i in range(vertex_count)} def add_edge(self, source, target): Add a directed edge from source node to target node. self.graph[source].append(target) def is_reachable(self, source, target): Return True if there is a path from source to target, else return False. visited = [False] * self.vertex_count return self._dfs(source, target, visited) def _dfs(self, source, target, visited): Depth First Search to check path between source and target. if source == target: return True visited[source] = True for neighbor in self.graph[source]: if not visited[neighbor]: if self._dfs(neighbor, target, visited): return True return False"},{"question":"# Scenario You\'re working on a text processing tool that needs to check if two provided strings are anagrams. To make this tool more versatile, we want to expand beyond just lowercase English letters to include all alphanumeric characters. # Task You need to write a function that checks if two given strings are anagrams, considering all alphanumeric characters (letters and digits). # Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: ``` # Input - `s1`: A string containing alphanumeric characters (0-9, a-z, A-Z). - `s2`: Another string containing alphanumeric characters (0-9, a-z, A-Z). # Output - Returns `True` if `s1` and `s2` are anagrams. - Returns `False` otherwise. # Constraints - The strings will contain only alphanumeric characters. - The comparison should be case-insensitive. - Maximum length of each string is 100,000 characters. # Examples ```python are_anagrams(\\"apple\\", \\"pleap\\") # True are_anagrams(\\"apple\\", \\"cherry\\") # False are_anagrams(\\"Listen\\", \\"Silent\\") # True are_anagrams(\\"123\\", \\"321\\") # True are_anagrams(\\"123a\\", \\"321A\\") # True are_anagrams(\\"abcd1\\", \\"dcba2\\") # False ``` # Notes - Pay special attention to case insensitivity when comparing letters. - Both strings should be considered as potential inputs, so ensure your solution can handle larger strings efficiently.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Checks if two strings are anagrams, considering all alphanumeric characters (0-9, a-z, A-Z) with case insensitivity. :param s1: First string containing alphanumeric characters. :param s2: Second string containing alphanumeric characters. :return: True if s1 and s2 are anagrams, else False. from collections import Counter # Normalize the strings to lowercase s1 = s1.lower() s2 = s2.lower() # Compare the count of characters in both strings return Counter(s1) == Counter(s2)"},{"question":"**Question**: You work as a software developer, and you are assigned the task of improving file handling operations in a legacy system. One of the first tasks is to develop a function that splits a given file path into its directory and the filename components. Implement a function `split_path(path: str) -> List[str]` that splits the input `path` into two parts: 1. The directory path (all characters before the last \'/\'). 2. The filename (all characters after the last \'/\'). Your function should handle both Unix-style file paths and typical URLs. **Input**: - `path` (str): A string representing the file path or URL. **Output**: - `parts` (List[str]): A list containing two elements: 1. The directory path. 2. The filename. **Constraints**: - The input string will not be null. - The path will contain at least one non-slash character. **Example**: ```python assert split_path(\\"https://algorithms/unix/test.py\\") == [\\"https://algorithms/unix\\", \\"test.py\\"] assert split_path(\\"algorithms/unix/test.py\\") == [\\"algorithms/unix\\", \\"test.py\\"] assert split_path(\\"/unix/test.py\\") == [\\"/unix\\", \\"test.py\\"] assert split_path(\\"unix/test.py/\\") == [\\"unix/test.py\\", \\"\\"] assert split_path(\\"file.txt\\") == [\\"\\", \\"file.txt\\"] ```","solution":"from typing import List def split_path(path: str) -> List[str]: Splits the input path into directory and filename components. Args: path (str): A string representing the file path or URL. Returns: List[str]: A list containing two elements: the directory path and the filename. if \'/\' in path: dir_path, filename = path.rsplit(\'/\', 1) else: dir_path, filename = \'\', path return [dir_path, filename]"},{"question":"Modular Cryptography Context You are tasked with implementing a module for a cryptographic system that involves computations of multiplicative inverses under a given modulus. A critical part of RSA encryption/decryption algorithms uses the modular inverse for various operations. Given your expertise in number theory algorithms, you are to complete the function implementations to ensure robust and efficient computations. Task Implement two functions, `extended_gcd(a: int, b: int)` and `modular_inverse(a: int, m: int)`, leveraging your understanding from the provided algorithm analysis. Function Definitions 1. `extended_gcd(a: int, b: int) -> (int, int, int)`: - **Input**: Two integers `a` and `b`. - **Output**: A tuple `(s, t, g)` where: - `s`: Coefficient for `a`. - `t`: Coefficient for `b`. - `g`: GCD of `a` and `b`. - **Constraints**: `a` and `b` are non-negative integers. 2. `modular_inverse(a: int, m: int) -> int`: - **Input**: Two integers `a` and `m`. - **Output**: An integer `x` such that `(a * x) % m = 1`. - **Constraints**: `a` and `m` must be coprime. Example ```python # Example usages: s, t, g = extended_gcd(30, 20) print(s, t, g) # Output might be (1, -1, 10) inverse = modular_inverse(3, 11) print(inverse) # Output should be 4 because (3 * 4) % 11 = 1 ``` Notes * The functions should handle edge cases gracefully. For instance, the `modular_inverse` function should raise appropriate errors when the inputs are invalid (i.e., `a` and `m` are not coprime). * Ensure your implementations are efficient and avoid unnecessary computations or memory usage. * Document any assumptions made and any additional helper functions used. Good luck!","solution":"def extended_gcd(a, b): Implements the Extended Euclidean Algorithm. Returns a tuple (s, t, g) such that s * a + t * b = g where g is the gcd of a and b. :param a: Integer :param b: Integer :return: Tuple of integers (s, t, g) old_s, s = 1, 0 old_t, t = 0, 1 old_r, r = a, b while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t return old_s, old_t, old_r def modular_inverse(a, m): Finds the modular inverse of a under modulo m using the Extended Euclidean Algorithm. :param a: Integer :param m: Integer, the modulo :return: Integer, the modular inverse of a under modulo m s, t, gcd = extended_gcd(a, m) if gcd != 1: raise ValueError(f\\"No modular inverse exists for a = {a} and m = {m} because they are not coprime.\\") return s % m"},{"question":"# Matrix Key Search You are given a matrix where every row and column is sorted in non-decreasing order. Write a function `find_key_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]` that searches for a given key in this matrix. The function should return a tuple of two integers `(row, col)` representing the position of the key in the matrix (0-based indexing). If the key is not found, return `None`. Input * `matrix`: A list of lists of integers where each row and column is sorted in non-decreasing order. * `key`: An integer that needs to be searched in the matrix. Output * A tuple `(row, col)` representing the position of the key in the matrix if found. Otherwise, return `None`. Constraints * Assume `matrix` has at least one element and at most 1000 rows and 1000 columns. * Elements in the matrix are integers in the range `-10^9` to `10^9`. * The function should run in O(m + n) time complexity and use O(1) extra space. Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 # Function call: find_key_in_sorted_matrix(matrix, key) # Output: (1, 2) because 13 is at the second row and third column (0-based index) ``` Tips * Start from the bottom-left corner of the matrix. * Carefully handle movement within the matrix bounds. Implement the `find_key_in_sorted_matrix` function.","solution":"from typing import List, Tuple, Optional def find_key_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: Searches for a given key in a matrix where every row and column is sorted in non-decreasing order. Returns the position of the key in the matrix (row, col) or None if not found. if not matrix: return None # Start from the bottom-left corner of the matrix n = len(matrix) m = len(matrix[0]) row = n - 1 col = 0 while row >= 0 and col < m: current = matrix[row][col] if current == key: return (row, col) elif current < key: col += 1 else: row -= 1 return None"},{"question":"You are given a Hermitian positive-definite matrix ( A ). Implement the Cholesky Decomposition algorithm to factorize ( A ) into a lower triangular matrix ( V ) such that ( V cdot V^T = A ). # Function Signature ```python def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: ``` # Input - A: A square matrix of dimensions ( n times n ) of type List[List[float]] where ( A ) is Hermitian and positive-definite. # Output - Return a lower triangular matrix ( V ) of dimension ( n times n ) if ( A ) can be decomposed, otherwise return `None`. # Constraints - ( 1 leq n leq 100 ) - Elements of ( A ) are real numbers between (-10^6) and (10^6). - Matrix ( A ) is guaranteed to be square. # Example ```python A = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] Output: [ [2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0] ] ``` # Details - The algorithm should validate the matrix\'s dimensions before processing. - Return `None` if the matrix is not positive-definite. # Notes - Ensure to handle edge cases such as non-square matrices and invalid positive-definite conditions. - Aim to construct an efficient and robust implementation.","solution":"import math from typing import List, Optional def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: Performs the Cholesky Decomposition of a Hermitian positive-definite matrix A. Returns the lower triangular matrix V such that V * V^T = A. If A cannot be decomposed, returns None. n = len(A) # Initialize the lower triangular matrix with zeros V = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i + 1): if i == j: # Diagonal elements sum_diagonal = sum(V[i][k]**2 for k in range(i)) try: V[i][i] = math.sqrt(A[i][i] - sum_diagonal) except ValueError: # Handle non-positive-definite matrix return None else: # Off-diagonal elements sum_off_diagonal = sum(V[i][k] * V[j][k] for k in range(j)) if V[j][j] == 0: return None # To avoid division by zero in poorly conditioned matrices V[i][j] = (A[i][j] - sum_off_diagonal) / V[j][j] return V"},{"question":"**Priority Queue Implementation Optimization** # Context You need to improve the current implementation of the Priority Queue using a more efficient data structure. The existing implementation uses a linear array, leading to an O(n) complexity for the insertion of elements which is not scalable for larger data sets. # Task You are required to implement a Priority Queue using a binary heap (min-heap), which will improve the insertion operation complexity from O(n) to O(log n), while still ensuring that extracting the element with the minimum priority (pop) remains efficient (O(1)). # Requirements Implement the following methods: 1. **__init__(self, items=None, priorities=None)**: Initialize the priority queue with given items and priorities (optional). 2. **size(self)**: Return the size of the priority queue. 3. **push(self, item, priority=None)**: Insert an element into the priority queue. 4. **pop(self)**: Remove and return the element with the minimum priority. # Input and Output Formats * **__init__**: - Inputs: - `items`: list of items (optional). - `priorities`: list of corresponding priorities (optional). * **size**: - Output: integer representing the current size of the queue. * **push**: - Inputs: - `item`: the element to be added. - `priority`: the associated priority (optional; default is item\'s value). - Output: None. * **pop**: - Output: the element with the smallest priority in the queue. # Constraints 1. Priorities of the elements are integers. 2. Duplicate priorities are allowed. 3. There should be efficient handling of the underlying data structure to maintain the properties of the priority queue. # Example ```python pq = PriorityQueue(items=[3, 1, 4], priorities=[10, 5, 15]) print(pq.size()) # Output: 3 pq.push(2, 6) print(pq.pop()) # Output: 1 (since it has the smallest priority 5) print(pq.size()) # Output: 3 ``` **Notes**: - You should not use any in-built heap/priority queue library functions. - Consider handling the edge cases like pushing an element into an empty queue and popping from an empty queue gracefully. - Aim to write clean and efficient code following best practice guidelines.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.heap) def push(self, item, priority=None): if priority is None: priority = item self.heap.append((priority, item)) self._sift_up(len(self.heap) - 1) def pop(self): if self.size() == 0: return None self._swap(0, len(self.heap) - 1) min_item = self.heap.pop() self._sift_down(0) return min_item[1] def _sift_up(self, index): parent_index = (index - 1) // 2 if parent_index >= 0 and self.heap[index][0] < self.heap[parent_index][0]: self._swap(index, parent_index) self._sift_up(parent_index) def _sift_down(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < self.size() and self.heap[left_child_index][0] < self.heap[smallest][0]: smallest = left_child_index if right_child_index < self.size() and self.heap[right_child_index][0] < self.heap[smallest][0]: smallest = right_child_index if smallest != index: self._swap(index, smallest) self._sift_down(smallest) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"# Linked List Operations Background You are developing a text editor with an undo/redo feature. To implement this feature efficiently, you decide to use a doubly linked list. Each operation to insert or delete a character can be undone or redone, making navigation an essential part of your implementation. Task Implement a class `EditorHistory` that supports the following operations using a doubly linked list: 1. **Insert**: Insert a character at a specific position. 2. **Delete**: Delete a character from a specific position. 3. **Undo**: Undo the most recent insert or delete operation. 4. **Redo**: Redo the most recently undone insert or delete operation, if any. Implementation Details 1. **insert(position: int, character: str)**: Inserts a character at the given position in the text. 2. **delete(position: int)**: Deletes the character at the given position. 3. **undo()**: Undoes the last insert or delete operation. 4. **redo()**: Redoes the last undone operation, if any. Constraints - For simplicity, assume all positions are valid. - Multiple consecutive undos followed by redos should result in the correct final text. Example ```python editor = EditorHistory() editor.insert(0, \'a\') # \\"a\\" editor.insert(1, \'b\') # \\"ab\\" editor.delete(1) # \\"a\\" editor.undo() # \\"ab\\" editor.redo() # \\"a\\" ``` Note - Pay attention to edge cases like undoing without any operations to undo, or redoing when there\'s nothing to redo. - Ensure efficient memory usage and performance.","solution":"class Node: def __init__(self, data=None): self.data = data self.prev = None self.next = None class EditorHistory: def __init__(self): self.head = Node() self.tail = Node() self.head.next = self.tail self.tail.prev = self.head self.history = [] self.redo_stack = [] def _get_node_at_position(self, position): current = self.head.next for _ in range(position): current = current.next return current def insert(self, position, character): self.redo_stack.clear() new_node = Node(character) current = self._get_node_at_position(position) prev_node = current.prev prev_node.next = new_node new_node.prev = prev_node new_node.next = current current.prev = new_node self.history.append((\'insert\', position, character)) def delete(self, position): self.redo_stack.clear() current = self._get_node_at_position(position) prev_node = current.prev next_node = current.next prev_node.next = next_node next_node.prev = prev_node self.history.append((\'delete\', position, current.data)) def undo(self): if not self.history: return action, position, character = self.history.pop() if action == \'insert\': self.delete(position) self.redo_stack.append((\'insert\', position, character)) elif action == \'delete\': self.insert(position, character) self.redo_stack.append((\'delete\', position, character)) def redo(self): if not self.redo_stack: return action, position, character = self.redo_stack.pop() if action == \'insert\': self.insert(position, character) elif action == \'delete\': self.delete(position) def get_text(self): current = self.head.next text = [] while current != self.tail: text.append(current.data) current = current.next return \'\'.join(text)"},{"question":"Scenario You are tasked with sorting a list of student scores to prepare a leaderboard for a class. However, the list can sometimes consist of duplicated scores. You need to ensure the list is sorted in ascending order using the given sorting algorithm. Your implementation should handle all edge cases and ensure the original list is sorted in place. Task Implement the `sorted_exchange_sort` function that sorts a list of integers using the Exchange Sort algorithm. Function Signature ```python def sorted_exchange_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list `arr` of integers, with 0 ≤ len(arr) ≤ 10^3 and -10^6 ≤ arr[i] ≤ 10^6. # Output * A list of integers sorted in ascending order. # Constraints 1. The function should modify and return the original list. 2. The algorithm must follow the principle of Exchange Sort. # Performance Requirements 1. The implemented function should operate within `O(n^2)` time complexity due to the nature of Exchange Sort. 2. The function should use `O(1)` space complexity. # Example ```python assert sorted_exchange_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert sorted_exchange_sort([]) == [] assert sorted_exchange_sort([10]) == [10] assert sorted_exchange_sort([2, 3, 1]) == [1, 2, 3] ``` Edge Cases 1. Empty list input should return an empty list. 2. A list with a single element should return the same list. 3. A list with multiple identical elements should handle duplicates correctly.","solution":"from typing import List def sorted_exchange_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using Exchange Sort. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Question: Preorder Traversal of Binary Tree Problem Statement You are tasked with implementing both iterative and recursive methods for the preorder traversal of a binary tree. In preorder traversal, you process the root node first, then recursively do a preorder traversal of the left subtree, followed by a recursive preorder traversal of the right subtree. Requirements 1. Implement a recursive function: ```python def preorder_rec(root: Optional[Node]) -> List[int]: ``` 2. Implement an iterative function: ```python def preorder_iter(root: Optional[Node]) -> List[int]: ``` Input * The input parameter `root` is the root node of the binary tree, which may be `None` for an empty tree. Output * Both functions should return a list of integers representing the preorder traversal of the tree. Constraints * Each node in the binary tree contains at most one integer value and two child nodes. * The number of nodes in the binary tree does not exceed 100,000. Examples Example 1: ```python # Given the tree: # 1 # / # 2 3 # / #4 root = Node(1, Node(2, Node(4)), Node(3)) print(preorder_rec(root)) # Output: [1, 2, 4, 3] print(preorder_iter(root)) # Output: [1, 2, 4, 3] ``` Example 2: ```python # Given the tree: # 5 # / # 6 # / #7 8 root = Node(5, Node(6, Node(7), Node(8))) print(preorder_rec(root)) # Output: [5, 6, 7, 8] print(preorder_iter(root)) # Output: [5, 6, 7, 8] ``` Notes * Ensure your solution is optimized for both time and space complexities. * Handle all edge cases such as an empty tree, single-node tree, and trees where all nodes are either on the left or right.","solution":"from typing import Optional, List class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def preorder_rec(root: Optional[Node]) -> List[int]: Recursive preorder traversal of binary tree. if root is None: return [] return [root.val] + preorder_rec(root.left) + preorder_rec(root.right) def preorder_iter(root: Optional[Node]) -> List[int]: Iterative preorder traversal of binary tree. if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"# Prime Number Sequence Checker **Objective:** Implement a function that checks whether every number in a given list is a prime number. The function should return a list of Boolean values correspondingly. **Function Signature:** ```python def check_prime_sequence(lst: List[int]) -> List[bool]: pass ``` **Input:** - `lst` (List[int]): A list of integers for primality check. **Output:** - List[bool]: A list of boolean values, each indicating whether the corresponding integer in `lst` is a prime number (`True`) or not (`False`). **Constraints:** - 1 <= len(lst) <= 10^5 - -10^9 <= lst[i] <= 10^9 for all i in `lst` **Requirements:** - Optimize the function to handle up to 100,000 integers efficiently. - Consider edge cases such as very small or large negative numbers. **Examples:** ```python check_prime_sequence([1, 2, 3, 4, 5, 6, 23, -17, 0, 19]) # Output: [False, True, True, False, True, False, True, False, False, True] check_prime_sequence([33, 34, 35, 36, 37, 38, 39]) # Output: [False, False, False, False, True, False, False] ``` **Explanation:** - The output list contains `True` for prime numbers, `False` otherwise.","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def check_prime_sequence(lst: List[int]) -> List[bool]: return [is_prime(num) for num in lst]"},{"question":"# Scenario You have been hired by a text processing company to develop a function that detects if a string is a rotation of another string. Such functionality could be useful, for example, in validating cyclic patterns in text data. # Task Write a function `detect_rotation(original, query)` that determines if `query` is a rotation of `original`. # Function Signature ```python def detect_rotation(original: str, query: str) -> bool: ``` # Input - `original` (string) : The original string to be checked. - `query` (string) : The string to check if it is a rotation of `original`. # Output - Returns `True` if `query` is a rotation of `original`, `False` otherwise. # Constraints - Both `original` and `query` are non-null strings. - The length of each string will not exceed ( 10^6 ). # Example ```python assert detect_rotation(\\"waterbottle\\", \\"erbottlewat\\") == True assert detect_rotation(\\"abcde\\", \\"abced\\") == False assert detect_rotation(\\"a\\", \\"a\\") == True assert detect_rotation(\\"a\\", \\"b\\") == False ``` # Notes - Consider edge cases like empty strings or strings of different lengths. - Aim for optimal performance to handle large strings within the provided constraints.","solution":"def detect_rotation(original: str, query: str) -> bool: Determines if `query` is a rotation of `original`. Args: original (str): The original string to be checked. query (str): The string to check if it is a rotation of `original`. Returns: bool: True if `query` is a rotation of `original`, False otherwise. # If lengths are not equal, query can\'t be a rotation of original if len(original) != len(query): return False # Concatenate original with itself and check if query is a substring return query in (original + original)"},{"question":"# Factor Combination Problem **Objective**: Write a function that generates all unique combinations of integer factors (excluding 1) that multiply together to give the number `n`. **Function Signature**: ```python def generate_factor_combinations(n: int) -> List[List[int]]: pass ``` **Input**: - An integer `n` (`1 <= n <= 10^6`). **Output**: - A list of lists, where each inner list contains unique combinations of factors of `n`. **Examples**: 1. **Input**: `generate_factor_combinations(1)` - **Output**: `[]` 2. **Input**: `generate_factor_combinations(37)` - **Output**: `[]` 3. **Input**: `generate_factor_combinations(12)` - **Output**: ```python [ [2, 6], [2, 2, 3], [3, 4] ] ``` 4. **Input**: `generate_factor_combinations(32)` - **Output**: ```python [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` **Constraints**: - Factor combinations should only include factors greater than 1 and less than `n`. - Each combination should appear once. - The order of combinations in the output list does not matter. **Scenario**: Consider you are developing a tool for number theory analysis, where one of the features is to decompose given numbers into their factor combinations. This tool aims to assist in mathematical research, cryptographic analysis, and educational purposes. **Instructions**: 1. Implement the `generate_factor_combinations` function to solve the problem as described above. 2. Ensure the solution adheres to the input and output formats. 3. Consider edge cases and optimize for performance where possible.","solution":"def generate_factor_combinations(n: int): def backtrack(start, target, path, res): if target == 1: if len(path) > 1: res.append(path[:]) return for i in range(start, target + 1): if target % i == 0: path.append(i) backtrack(i, target // i, path, res) path.pop() result = [] backtrack(2, n, [], result) return result"},{"question":"# Priority Queue Using Linear Array We have implemented a basic Priority Queue using a linear array. The current implementation has time complexities of O(n) for insertion and O(1) for extracting the element with the lowest priority. Task: Your job is to implement further functionalities to test the efficiency and robustness of this priority queue. You are also supposed to handle edge cases and ensure that the code does not break for any input. Requirements: 1. **Function 1: Total priorities** - Implement a method `total_priorities` that calculates the sum of all priorities in the queue. - **Input**: No input parameters. - **Output**: An integer representing the sum of all priorities in the queue. 2. **Function 2: Update priority** - Implement a method `update_priority` that updates the priority of a specific item in the queue. - **Input**: - item (str): Item whose priority needs to be updated. - new_priority (int): New priority of the item. - **Output**: None. 3. **Function 3: Validate priority queue** - Implement a method `validate_priority_queue` that validates if the queue maintains the heap property based on priorities. - This means that for any node `i` with children `2i+1` and `2i+2`, `priority[i] >= priority[2i+1]` and `priority[i] >= priority[2i+2]`. - **Input**: No input parameters. - **Output**: A boolean representing whether the priority queue maintains the required property. Example: ```python pq = PriorityQueue(items=[\\"task1\\", \\"task2\\", \\"task3\\"], priorities=[1, 3, 5]) pq.push(\\"task4\\", 2) print(pq.total_priorities()) # Output: 11 pq.update_priority(\\"task3\\", 6) print(pq.validate_priority_queue()) # Output: True print(pq.pop()) # Output: \\"task1\\" ``` Constraints: * All priorities will be non-negative integers. * Operations concerning an empty queue should raise an appropriate error. * Update operation should not violate the heap property – you may need to re-adjust the queue to maintain it. Ensure your implementation is clean and robust. You are expected to follow best coding practices and handle edge cases appropriately.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): if items is None: items = [] if priorities is None: priorities = [] self.queue = list(zip(priorities, items)) # [(priority, item)] self.queue.sort() # Sort items by priorities def push(self, item, priority): self.queue.append((priority, item)) self.queue.sort() # Maintain order after insertion def pop(self): if not self.queue: raise IndexError(\\"Pop from empty priority queue\\") return self.queue.pop(0)[1] # Return item with lowest priority def total_priorities(self): return sum(priority for priority, item in self.queue) def update_priority(self, item, new_priority): found = False for i in range(len(self.queue)): if self.queue[i][1] == item: self.queue[i] = (new_priority, item) found = True break if not found: raise ValueError(\\"Item not found in queue\\") self.queue.sort() # Re-sort the queue after priority update def validate_priority_queue(self): for i in range(len(self.queue)): left = 2 * i + 1 right = 2 * i + 2 if left < len(self.queue) and self.queue[i][0] > self.queue[left][0]: return False if right < len(self.queue) and self.queue[i][0] > self.queue[right][0]: return False return True"},{"question":"Your task is to implement a similar priority queue, but this time using an array-based implementation where the highest priority is associated with the smallest numeric value. Your implementation should maintain the elements in such a way that the lowest value priorities come first. Specifically, you will be implementing two main functionalities - `push` and `pop` - for this priority queue. Function Definitions 1. **push(item, priority)**: Insert an item with an associated priority into the priority queue. - *Input*: - `item` (any data type): The item to be inserted. - `priority` (int): An integer representing the item\'s priority. - *Output*: None Maintain the ordering of elements in such a way that they are in ascending order of priority, i.e., the lowest priority value comes first. 2. **pop()**: Remove and return the item with the lowest priority. - *Input*: None - *Output*: Item with the lowest priority. If the queue is empty, raise an appropriate exception. Example ```python pq = PriorityQueue() pq.push(10, 5) pq.push(20, 1) pq.push(30, 3) print(pq.pop()) # Output: 20 print(pq.pop()) # Output: 30 print(pq.pop()) # Output: 10 ``` Constraints - Priorities are integers and can be negative. - Items can be any data type, including duplicates. Ensure your implementation is efficient and handles edge cases, such as popping from an empty queue.","solution":"import heapq class PriorityQueue: def __init__(self): self.queue = [] heapq.heapify(self.queue) def push(self, item, priority): Insert an item with an associated priority into the priority queue. heapq.heappush(self.queue, (priority, item)) def pop(self): Remove and return the item with the lowest priority. If the queue is empty, raise an IndexError. if not self.queue: raise IndexError(\\"pop from empty priority queue\\") return heapq.heappop(self.queue)[1]"},{"question":"# Matrix Path Sum Problem Scenario You are working as a software engineer in a robotics company. One of the company\'s robots needs to find the optimal path through a grid where each cell has a given cost. The robot is allowed to move either right or down, and it starts from the top-left corner (0, 0) and needs to reach the bottom-right corner (n-1, m-1). The goal is to calculate the minimum cost path from the top-left to the bottom-right cell of the grid. Task Write a function `min_cost_path(grid: list) -> int` that computes the minimum cost of the path. Input: * `grid`: A 2D list where `grid[i][j]` represents the cost at cell (i, j). * The grid dimensions are `n x m` (1 <= n, m <= 100). Output: * Return an integer representing the minimum cost to travel from the top-left to the bottom-right of the grid. Constraints: * The grid consists of non-negative integers. * The solution should handle the edge case when either `n` or `m` is 1. Example: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_cost_path(grid)) # Output: 7 (1→3→1→1→1) grid2 = [ [1, 2, 5], [3, 2, 1] ] print(min_cost_path(grid2)) # Output: 6 (1→2→2→1) ``` Hints: * Consider using a dynamic programming approach to solve this problem efficiently.","solution":"def min_cost_path(grid: list) -> int: Returns the minimum cost to travel from the top-left to the bottom-right of the grid. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) # Initialize the DP table with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the result return dp[n - 1][m - 1]"},{"question":"Question: Bit Manipulation Utilities # Context You are developing a library for precise bit-level control of integers, which is crucial for performance-critical applications such as system programming and data compression. Your task is to implement a set of utility functions to manipulate individual bits within an integer. # Task Implement the following functions that perform various bit manipulations: `get_bit`, `set_bit`, `clear_bit`, and `update_bit`. # Function Signatures ```python def get_bit(num: int, i: int) -> bool: Get the bit at index i from the integer num. Parameters: num (int): The integer from which to get the bit. i (int): The index of the bit to get. Returns: bool: The bit value at index i (True if 1, False if 0). pass def set_bit(num: int, i: int) -> int: Set the bit at index i to 1 in the integer num. Parameters: num (int): The integer in which to set the bit. i (int): The index of the bit to set. Returns: int: The integer with the bit at index i set to 1. pass def clear_bit(num: int, i: int) -> int: Clear the bit at index i (set to 0) in the integer num. Parameters: num (int): The integer in which to clear the bit. i (int): The index of the bit to clear. Returns: int: The integer with the bit at index i cleared to 0. pass def update_bit(num: int, i: int, bit: bool) -> int: Update the bit at index i to the provided bit value (0 or 1). Parameters: num (int): The integer in which to update the bit. i (int): The index of the bit to update. bit (bool): The new bit value to set (True for 1, False for 0). Returns: int: The integer with the bit at index i updated to the new value. pass ``` # Examples *Example 1*: ```python num = 5 # binary: 0101 i = 1 result = get_bit(num, i) # Expected output: True (the bit at index 1 is 1) ``` *Example 2*: ```python num = 12 # binary: 1100 i = 2 result = set_bit(num, i) # Expected output: 12 (the bit at index 2 is already 1, so no change) ``` *Example 3*: ```python num = 15 # binary: 1111 i = 1 result = clear_bit(num, i) # Expected output: 13 (binary: 1101, the bit at index 1 is cleared to 0) ``` *Example 4*: ```python num = 8 # binary: 1000 i = 3 bit = False result = update_bit(num, i, bit) # Expected output: 0 (binary: 0000, the bit at index 3 is updated to 0) ``` # Constraints * The functions should handle bit indices `i` ranging from 0 (least significant bit) to 31 (if assuming a 32-bit integer). * The integer `num` can be any valid integer (positive or negative). # Performance Requirements * All functions must operate in constant time O(1). * Minimize the use of additional space.","solution":"def get_bit(num: int, i: int) -> bool: Get the bit at index i from the integer num. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Set the bit at index i to 1 in the integer num. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clear the bit at index i (set to 0) in the integer num. return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Update the bit at index i to the provided bit value (0 or 1). return (num & ~(1 << i)) | ((1 if bit else 0) << i)"},{"question":"Hailstone Sequence Analysis You are tasked with implementing a function to generate and analyze the \\"hailstone sequence\\" for a given starting integer `n`. The sequence is defined as follows: - Start with integer `n` - If `n == 1`, stop. - If `n` is even, the next term is `n / 2`. - If `n` is odd, the next term is `3 * n + 1`. - Repeat the process until `n` reaches 1. Additionally, you need to analyze the sequence for the following metrics: 1. The length of the sequence. 2. The peak value (maximum value) in the sequence. # Function Signature ```python def analyze_hailstone(n: int) -> Tuple[List[int], int, int]: Computes the hailstone sequence starting from integer n and returns: - The sequence itself as a list - The length of the sequence - The peak value (maximum value) in the sequence Parameters: n (int): The starting integer (1 <= n <= 10^6) Returns: Tuple containing: - List[int]: The hailstone sequence from n to 1 - int: The length of the sequence - int: The peak value in the sequence pass ``` # Input - An integer `n`, where ( 1 leq n leq 10^6 ). # Output A tuple containing: - The `\'hailstone sequence\'` from `n` to 1 as a list of integers. - The length of the sequence as an integer. - The peak value (maximum value) in the sequence as an integer. # Constraints - The starting integer `n` will be within the range ( 1 leq n leq 10^6 ). # Example ```python assert analyze_hailstone(7) == ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 17, 52) assert analyze_hailstone(1) == ([1], 1, 1) ``` # Explanation - For the input `7`, the hailstone sequence is `[7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]` which has a length of 17 and the peak value is `52`. - For the input `1`, the hailstone sequence is `[1]` which has a length of 1 and the peak value is `1`.","solution":"from typing import List, Tuple def analyze_hailstone(n: int) -> Tuple[List[int], int, int]: Computes the hailstone sequence starting from integer n and returns: - The sequence itself as a list - The length of the sequence - The peak value (maximum value) in the sequence Parameters: n (int): The starting integer (1 <= n <= 10^6) Returns: Tuple containing: - List[int]: The hailstone sequence from n to 1 - int: The length of the sequence - int: The peak value in the sequence sequence = [] peak = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 if n > peak: peak = n sequence.append(1) return sequence, len(sequence), peak"},{"question":"In this question, you will be implementing bit manipulation functions for performance-critical applications. Evaluate each bit based on the functions provided and implement necessary operations to solve a practical problem. # Context You are working on a system that controls binary switches in an industrial automation setup. Each switch’s state (on/off) is represented by a single bit in an integer. # Problem Statement Implement the following function: ```python def toggle_switches(switches, operations): Args: switches (int): A positive integer representing the state of N binary switches, where the least significant bit (LSB) represents switch 0, the next bit represents switch 1, and so on. operations (List[Tuple[int, str]]): A list of operations to perform on the switches. Each tuple contains an index of the switch and an operation (\'on\', \'off\', or \'toggle\'). Returns: int: The updated switches after performing all operations. ``` # Requirements 1. **Switch Operations**: - `\'on\'`: Ensure the bit at the specified index is set to 1. - `\'off\'`: Ensure the bit at the specified index is set to 0. - `\'toggle\'`: Change the bit at the specified index from 0 to 1 or 1 to 0 depending on the current state. 2. **Input Constraints**: - `switches`: A 32-bit unsigned integer. - `operations`: A list of tuples where each tuple contains: - An integer `i` (0 ≤ i < 32), indicating the bit position. - A string `\'on\'`, `\'off\'`, or `\'toggle\'`. 3. **Output**: Return the updated integer value of `switches` after performing all operations. # Example Usage ```python # Initial switches state (binary 00000000 00000000 00000000 00000000) switches = 0 # Operations to perform operations = [(1, \'on\'), (1, \'toggle\'), (2, \'on\'), (2, \'off\'), (3, \'toggle\')] # switches binary 00000000 00000000 00000000 00001010 updated_switches = toggle_switches(switches, operations) print(updated_switches) # Output should be 10 ``` # Notes - You may use the helper functions (`get_bit`, `set_bit`, `clear_bit`, `update_bit`) provided above to implement `toggle_switches`.","solution":"def toggle_switches(switches, operations): Toggles the switches based on the operations provided. Args: switches (int): A positive integer representing the state of N binary switches. operations (List[Tuple[int, str]]): A list of operations to perform on the switches. Each tuple contains an index of the switch and an operation (\'on\', \'off\', or \'toggle\'). Returns: int: The updated switches after performing all operations. for index, operation in operations: if operation == \'on\': switches |= (1 << index) elif operation == \'off\': switches &= ~(1 << index) elif operation == \'toggle\': switches ^= (1 << index) return switches"},{"question":"# Context You are working on a software system where binary arithmetic is fundamental. One common task is to add two binary numbers provided as strings and return the result, also as a binary string. # Problem Statement Write a function `add_binary(a, b)` that takes two binary strings `a` and `b`, adds them, and returns their sum as a binary string. # Input * `a`: A non-empty string containing only \'0\' and \'1\'. * `b`: A non-empty string containing only \'0\' and \'1\'. # Output * A string representing the sum of the two binary inputs. # Constraints 1. The input strings will not be empty and will contain only the characters \'0\' and \'1\'. 2. The length of each binary string can go up to (10^4). # Example ```plaintext Input: a = \\"11\\", b = \\"1\\" Output: \\"100\\" ``` # Edge Cases to Consider 1. Both strings of different lengths. 2. One or both strings being \\"0\\". 3. Strings containing leading zeros, such as \\"0001\\". # Requirements - The function should handle the largest possible binary string within the given constraints efficiently. - Your solution should handle edge cases effectively. Implement the `add_binary` function to achieve the above specifications.","solution":"def add_binary(a, b): Adds two binary strings and returns their sum as a binary string. # Convert binary strings to integers int_a = int(a, 2) int_b = int(b, 2) # Sum the integers int_sum = int_a + int_b # Convert the sum back to a binary string return bin(int_sum)[2:]"},{"question":"You have been given an integer, and your task is to write a function `swap_pair(num)` that swaps the odd and even bits in the integer with as few instructions as possible. For example, for the integer 22 which has a binary representation of `010110`, the swapped value should be `101001`, which is 41 in decimal form. # Function Signature ```python def swap_pair(num: int) -> int: ``` # Input - An integer `num`, where `0 <= num <= 2^32 - 1`. # Output - An integer where all the odd and even bits are swapped. # Examples - Input: `22` - Output: `41` - Input: `10` - Output: `5` # Constraints - The solution should focus on using bitwise operations to achieve the result. - Performance-wise, you\'d expect an O(1) complexity solution in terms of both time and space. # Notes - The odd bits mask is `0xAAAAAAAA` in hexadecimal (binary `10101010101010101010101010101010`), which isolates bits at odd positions. - The even bits mask is `0x55555555` in hexadecimal (binary `01010101010101010101010101010101`), which isolates bits at even positions. Use the provided example to validate your implementation: ```python print(swap_pair(22)) # Expected output: 41 print(swap_pair(10)) # Expected output: 5 ``` # Scenario Imagine you need to implement a protocol where specific bits of a status code need to be interpreted differently based on their positions. This swapping mechanism will help you efficiently re-map how you read these status codes without changing the hardware level instructions.","solution":"def swap_pair(num: int) -> int: Swaps the odd and even bits in the integer `num`. Args: num (int): The input integer Returns: int: The integer after swapping odd and even bits # Masks to isolate even and odd indexed bits even_mask = 0x55555555 # 01010101010101010101010101010101 (binary) odd_mask = 0xAAAAAAAA # 10101010101010101010101010101010 (binary) # Isolate even and odd bits even_bits = num & even_mask odd_bits = num & odd_mask # Shift even bits left and odd bits right even_bits_shifted = even_bits << 1 odd_bits_shifted = odd_bits >> 1 # Combine the shifted bits result = even_bits_shifted | odd_bits_shifted return result"},{"question":"**Question:** You are tasked with sorting an array of objects colored red, white, or blue using the integers 0, 1, and 2 to represent the colors respectively. Your goal is to sort the array so that objects of the same color are adjacent, with the colors order being red (0), white (1), and blue (2). Write a function `sort_colors(nums)` that achieves this sorting efficiently in-place without using any library sorting function. Your implementation should satisfy the following criteria: # Input: - An integer array `nums` where each element is either 0, 1, or 2. # Output: - The function should modify the input array `nums` in place so that it is sorted according to the order 0, 1, 2. # Constraints: - The length of `nums` is in the range [0, 100]. - Each element in `nums` is one of 0, 1, or 2. # Performance Requirements: - Time Complexity: O(n) - Space Complexity: O(1) # Scenarios: 1. If the array `nums` is empty, no changes are needed. 2. If the array `nums` contains elements but all are of one type (e.g., all 0s), it should remain unchanged. 3. If the array `nums` contains a random mix of 0s, 1s, and 2s, it must be arranged such that all 0s come first, followed by all 1s, and all 2s come last. # Example: ```python # Example 1: nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 2: nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` Write your function implementation below: ```python def sort_colors(nums): # Your code here ```","solution":"def sort_colors(nums): Sorts the array in-place so that all 0s come first, followed by all 1s, and all 2s come last. Implements the Dutch National Flag problem solution. # Pointers for low, mid and high low, mid, high = 0, 0, len(nums) - 1 # Iterate through the list while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Scenario You’re developing a system that validates strings based on a given set of state transitions. This system uses a deterministic finite automaton (DFA) to determine if a string is acceptable according to a predefined set of rules. # Question Write a function `is_string_accepted(transitions, start, final, string)` that determines if a given `string` is accepted by a DFA. The DFA is defined by: * A transition table `transitions` (a dictionary of dictionaries). * A `start` state. * A list of `final` states. Input * `transitions`: A dictionary where keys are states and values are dictionaries that map input characters to subsequent states. If no transition exists for a given state and character, it will be represented by `None`. * `start`: An integer representing the start state. * `final`: A list of integers representing the final (accepting) states. * `string`: A string consisting of characters to be processed by the DFA. Output * Return `True` if the string is accepted by the DFA (i.e., the DFA terminates in one of the final states). Return `False` otherwise. Constraints * The input string can be empty, in which case the DFA should return whether the start state itself is an accepting state or not. * Characters in the input string are guaranteed to be valid symbols in the transition table. * State ids and symbols are assumed to be integers and strings, respectively. You must ensure the function handles the above constraints, including edge cases where the `transitions` table might have incomplete data. Example ```python transitions = { 0: {\'a\': 1, \'b\': None}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': 1, \'b\': None} } start = 0 final = [2] string = \\"aab\\" ``` * The function call `is_string_accepted(transitions, start, final, string)` should return `True`. ```python transitions = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 1}, } start = 0 final = [0] string = \\"ab\\" ``` * The function call `is_string_accepted(transitions, start, final, string)` should return `True`. ```python transitions = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 1} } start = 0 final = [1] string = \\"ab\\" ``` * The function call `is_string_accepted(transitions, start, final, string)` should return `False`. Develop the function `is_string_accepted(transitions, start, final, string)` to validate strings based on the DFA rules.","solution":"def is_string_accepted(transitions, start, final, string): Determines if a given string is accepted by the DFA. :param transitions: Dictionary where keys are states and values are dictionaries mapping input characters to subsequent states. :param start: Integer representing the start state. :param final: List of integers representing the final (accepting) states. :param string: String consisting of characters to be processed by the DFA. :return: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: next_state = transitions[current_state][char] if next_state is None: return False current_state = next_state else: return False return current_state in final"},{"question":"# Question: Given a string `enc_mes` containing digits, implement two functions `num_decodings` and `num_decodings2` which determine the total number of possible ways to decode the message. Each number can map to a letter (1 -> A, 2 -> B, ..., 26 -> Z). **Function Signatures:** ```python def num_decodings(enc_mes: str) -> int: pass def num_decodings2(enc_mes: str) -> int: pass ``` **Input:** - `enc_mes` (str): A string containing only digits. **Output:** - An integer representing the total number of ways the input string can be decoded. **Constraints:** - 1 ≤ len(enc_mes) ≤ 100 - `enc_mes` contains numerical digits only. **Examples:** ```python assert num_decodings(\\"12\\") == 2 # \\"AB\\" (1,2) or \\"L\\" (12) assert num_decodings(\\"226\\") == 3 # \\"BZ\\" (2,26), \\"VF\\" (22,6), \\"BBF\\" (2,2,6) assert num_decodings(\\"0\\") == 0 # Invalid String, returns 0 assert num_decodings2(\\"12\\") == 2 # \\"AB\\" (1,2) or \\"L\\" (12) assert num_decodings2(\\"226\\") == 3 # \\"BZ\\" (2,26), \\"VF\\" (22,6), \\"BBF\\" (2,2,6) assert num_decodings2(\\"0\\") == 0 # Invalid String, returns 0 ``` --- **Detailed Explanation**: 1. **Handling Leading Zeros**: Both functions should return 0 if the string starts with \'0\'. 2. **Single Character String**: Return 1 if the string has one valid character (non-\'0\'). 3. **Traversing the String**: Use dynamic programming to calculate the number of ways to decode the string. 4. **Updating State**: Maintain variables to store results of the previous iteration (for `num_decodings`) or use a stack (for `num_decodings2`) to store intermediate decodings. Write these implementations and validate using the provided examples. Your solution should handle all cases effectively while maintaining optimal time and space complexities.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 dp = [0] * (len(enc_mes) + 1) dp[0] = 1 dp[1] = 1 for i in range(2, len(enc_mes) + 1): if enc_mes[i - 1] != \'0\': dp[i] += dp[i - 1] if 10 <= int(enc_mes[i - 2:i]) <= 26: dp[i] += dp[i - 2] return dp[-1] def num_decodings2(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 prev = curr = 1 for i in range(1, len(enc_mes)): temp = 0 if enc_mes[i] != \'0\': temp += curr if 10 <= int(enc_mes[i - 1:i + 1]) <= 26: temp += prev prev, curr = curr, temp return curr"},{"question":"# Anagram Checker for Extended Character Set You are given two strings consisting of uppercase, lowercase, and non-alphabetic characters. Write a function to determine if you can make the two strings identical by reordering the characters. **Function Signature**: ```python def extended_anagram_checker(s1: str, s2: str) -> bool: ``` # Input * `s1` (string): The first input string. Consists of printable ASCII characters. * `s2` (string): The second input string. Also consists of printable ASCII characters. # Output * `bool`: Return `True` if the strings are anagrams after reordering, otherwise return `False`. # Constraints * The function should be case-sensitive (`\\"a\\"` is not the same as `\\"A\\"`). * The order of non-alpha characters matters in terms of frequency but not positions. # Examples ```python assert extended_anagram_checker(\\"A man, a plan, a canal, Panama!\\", \\"AmanaplanacanalPanam! a \\") == True assert extended_anagram_checker(\\"Hello, World!\\", \\"World, Hello!\\") == True assert extended_anagram_checker(\\"apple@\\", \\"paple\\") == False assert extended_anagram_checker(\\"123abc\\", \\"cba321\\") == True ``` # Notes * The function should handle mixed alphanumeric and punctuation inputs gracefully. * Consider only the frequency of characters and case sensitivity when implementing the comparison.","solution":"from collections import Counter def extended_anagram_checker(s1: str, s2: str) -> bool: Check if two strings consisting of uppercase, lowercase, and non-alphabetic characters can be made identical by reordering their characters. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: bool: True if the strings are anagrams after reordering, otherwise False. return Counter(s1) == Counter(s2)"},{"question":"# Separate Chaining Hash Table: Enhanced Functionality You are given an implementation of a hash table using separate chaining, which efficiently handles collisions using linked lists for each bucket. Your task is to enhance this hash table with two additional functionalities: 1. **Resize the Hash Table**: Implement a `resize` method to double the size of the hash table when it reaches a certain load factor (threshold). Rehash all existing keys to ensure optimal distribution. 2. **Keys Method**: Implement a method that returns a list of all the keys currently stored in the hash table. Specifications: 1. **Resize Method**: * This method should be called internally when the number of key-value pairs exceeds the threshold (e.g., load factor > 0.75). * Double the size of the hash table and rehash all existing keys. * **Performance Requirement**: The resizing operation should have a complexity of O(n), where n is the number of key-value pairs. 2. **Keys Method**: * Should return a list of all keys in the hash table. * **Performance Requirement**: Should have a complexity of O(n), where n is the number of key-value pairs. **Input and Output:** - **Input**: There is no direct input function; you will modify the existing hash table implementation. - **Output**: Implement the `resize` method to be called when resizing is necessary. Implement a `keys` method to return all keys. Here is the initial class definition with placeholders for the methods to implement: ```python class SeparateChainingHashTable(object): ... def resize(self): raise NotImplementedError(\\"Resize method is not implemented\\") def keys(self): raise NotImplementedError(\\"Keys method is not implemented\\") ``` # Example: ```python # Example usage: table = SeparateChainingHashTable(size=4) table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) table.put(\'d\', 4) # Assuming a load factor threshold of 0.75, `resize` must be triggered here assert table.size > 4 # After resize, size should be doubled to 8 # Retrieve all keys keys = table.keys() assert set(keys) == {\'a\', \'b\', \'c\', \'d\'} ``` A correct implementation should ensure that the hash table handles resizing automatically and provides a way to list all keys efficiently.","solution":"class SeparateChainingHashTable: def __init__(self, size=8, load_factor=0.75): self.size = size self.table = [[] for _ in range(size)] self.count = 0 self.load_factor = load_factor def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) for i, kv in enumerate(self.table[index]): k, v = kv if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.count += 1 if self.count / self.size > self.load_factor: self.resize() def get(self, key): index = self.hash(key) for k, v in self.table[index]: if k == key: return v return None def remove(self, key): index = self.hash(key) for i, kv in enumerate(self.table[index]): k, _ = kv if k == key: del self.table[index][i] self.count -= 1 return True return False def resize(self): new_size = self.size * 2 new_table = [[] for _ in range(new_size)] for bucket in self.table: for key, value in bucket: index = hash(key) % new_size new_table[index].append((key, value)) self.size = new_size self.table = new_table def keys(self): keys_list = [] for bucket in self.table: for key, _ in bucket: keys_list.append(key) return keys_list"},{"question":"**Objective:** Implement a `ResizableHashTable` similar to the provided implementation but with improvements and extensions in functionality. You should: 1. Optimize the hash function to handle a wider range of key types beyond just integers. 2. Implement a quadratic probing method instead of linear probing to handle collisions. 3. Support deletion with proper marking and re-insertion during resize to maintain integrity. 4. Include unit tests to validate your implementation. **Requirements:** 1. Implement a generic hash function that can handle various types of keys (e.g., strings, integers). 2. Use quadratic probing for collision resolution. 3. Ensure that the table resizes and rehashes correctly when it reaches the load factor threshold. 4. Provide proper handling of deleted elements and revalidate during resizing. 5. Include at least 5 unit tests to verify functionality: testing insertion, deletion, collision handling, resizing, and edge cases with special keys. **Function Signatures:** - `put(key: Any, value: Any) -> None` - `get(key: Any) -> Optional[Any]` - `del_(key: Any) -> None` - `__resize() -> None` **Input and Output Formats:** - Input: Various key-value pairs of types (e.g., integers, strings). - Output: Retrieved values for keys or notifications of absence (None). **Constraints:** - Assume initial size of the table is 8. - Ensure proper resizing when load factor > 2/3. - Keys can be integers or strings. Example Scenario: 1. Insert key-value pairs: `put(\'a\', 1)`, `put(\'b\', 2)` 2. Retrieve values: `get(\'a\')` should return `1` 3. Handle collisions using quadratic probing. 4. Resize when necessary and ensure all elements are rehashed correctly.","solution":"class ResizableHashTable: def __init__(self): self.initial_capacity = 8 self.size = 0 self.capacity = self.initial_capacity self.table = [None] * self.capacity self.deleted_flag = object() def _hash(self, key): # Improved hash function for different key types return hash(key) % self.capacity def __resize(self): old_table = self.table self.capacity *= 2 self.size = 0 self.table = [None] * self.capacity for item in old_table: if item and item != self.deleted_flag: self.put(item[0], item[1]) def put(self, key, value): if self.size / self.capacity > 2 / 3: self.__resize() idx = self._hash(key) i = 0 while self.table[idx] is not None and self.table[idx] != self.deleted_flag: if self.table[idx][0] == key: self.table[idx] = (key, value) return i += 1 idx = (idx + i ** 2) % self.capacity self.table[idx] = (key, value) self.size += 1 def get(self, key): idx = self._hash(key) i = 0 while self.table[idx] is not None: if self.table[idx] != self.deleted_flag and self.table[idx][0] == key: return self.table[idx][1] i += 1 idx = (idx + i ** 2) % self.capacity return None def del_(self, key): idx = self._hash(key) i = 0 while self.table[idx] is not None: if self.table[idx] != self.deleted_flag and self.table[idx][0] == key: self.table[idx] = self.deleted_flag self.size -= 1 return i += 1 idx = (idx + i ** 2) % self.capacity"},{"question":"# Sparse Vector Operations Given the task of efficiently storing and calculating the dot product of large sparse vectors, we use an index-value list representation. Each vector is translated into a list of tuples where each tuple contains an index and the corresponding non-zero value from the original vector. This helps in reducing storage requirements and computational overhead. # Problem Statement You are given two functions for handling sparse vectors: 1. `vector_to_index_value_list(vector)`: Converts a dense vector into an index-value list. 2. `dot_product(iv_list1, iv_list2)`: Computes the dot product of two sparse vectors represented as index-value lists. Implement a function to: 1. Merge two sparse vectors while maintaining the sparse representation. 2. Subtract one sparse vector from another and return the result in sparse representation. # Function Signature ```python def merge_sparse_vectors(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> List[Tuple[int, float]]: pass def subtract_sparse_vectors(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> List[Tuple[int, float]]: pass ``` # Input - `iv_list1, iv_list2`: Lists of tuples representing sparse vectors where each tuple `(index, value)` has: - `index (int)`: Position in the original dense vector. - `value (float)`: Non-zero value at that position. # Output - `merge_sparse_vectors`: Returns a list of tuples representing the merged sparse vector. - `subtract_sparse_vectors`: Returns a list of tuples representing the resultant sparse vector after subtraction. # Constraints - The index-value lists are sorted in ascending order by index. - The sizes of the index-value lists can be up to (10^6). # Example ```python iv_list1 = [(0, 1.0), (3, 2.0), (5, 3.0)] iv_list2 = [(1, 4.0), (3, 6.0), (5, -2.0)] merge_result = merge_sparse_vectors(iv_list1, iv_list2) # Expected: [(0, 1.0), (1, 4.0), (3, 8.0), (5, 1.0)] subtract_result = subtract_sparse_vectors(iv_list1, iv_list2) # Expected: [(0, 1.0), (1, -4.0), (3, -4.0), (5, 5.0)] ``` # Note - Carefully handle edge cases such as empty vectors or vectors with all zero values. - Ensure that the output index-value lists are sorted by index.","solution":"def merge_sparse_vectors(iv_list1, iv_list2): Merges two sparse vectors represented as index-value lists. result = [] i, j = 0, 0 while i < len(iv_list1) and j < len(iv_list2): if iv_list1[i][0] < iv_list2[j][0]: result.append(iv_list1[i]) i += 1 elif iv_list1[i][0] > iv_list2[j][0]: result.append(iv_list2[j]) j += 1 else: # iv_list1[i][0] == iv_list2[j][0] merged_value = iv_list1[i][1] + iv_list2[j][1] if merged_value != 0: result.append((iv_list1[i][0], merged_value)) i += 1 j += 1 result.extend(iv_list1[i:]) result.extend(iv_list2[j:]) return result def subtract_sparse_vectors(iv_list1, iv_list2): Subtracts one sparse vector from another and returns the result in sparse representation. result = [] i, j = 0, 0 while i < len(iv_list1) and j < len(iv_list2): if iv_list1[i][0] < iv_list2[j][0]: result.append(iv_list1[i]) i += 1 elif iv_list1[i][0] > iv_list2[j][0]: result.append((iv_list2[j][0], -iv_list2[j][1])) j += 1 else: # iv_list1[i][0] == iv_list2[j][0] subtracted_value = iv_list1[i][1] - iv_list2[j][1] if subtracted_value != 0: result.append((iv_list1[i][0], subtracted_value)) i += 1 j += 1 result.extend(iv_list1[i:]) result.extend((index, -value) for index, value in iv_list2[j:]) return result"},{"question":"A city\'s skyline is represented by the outer contour of the silhouette formed by all its buildings when viewed from a distance. Suppose you are given the locations and heights of all the buildings forming the skyline. Each building is represented by a triplet of integers ([Li, Ri, Hi]): where (Li) and (Ri) are the x-coordinates of the left and right edges, respectively, and (Hi) is the height of the building. For example, given the following buildings: [ begin{array}{cc} text{Buildings} & text{Formatted List} hline (2, 9, 10) & quad [[2, 9, 10]] (3, 7, 15) & quad [[3, 7, 15]] (5, 12, 12) & quad [[5, 12, 12]] (15, 20, 10) & quad [[15, 20, 10]] (19, 24, 8) & quad [[19, 24, 8]] end{array} ] The output should be a list of points ((xi, yi)) forming the skyline: [ begin{array}{c} text{Skyline Points} hline [2, 10] [3, 15] [7, 12] [12, 0] [15, 10] [20, 8] [24, 0] end{array} ] Input Format: - A list of triplets (text{List[List[int]]}) representing the buildings. Output Format: - A list of points (text{List[List[int]]}) representing the skyline. Constraints: - The number of buildings is in the range ([0, 10000]). - (0 leq Li, Ri leq INT_MAX). - (0 < Hi leq INT_MAX). - (Ri - Li > 0). # Function Signature: ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` # Performance Requirements: - The algorithm should run in ( O(N log N) ) time. - Ensure optimal use of memory and efficiently handle edge cases. # Example: ```python print(get_skyline([[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]])) # Expected output: [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` Notes: 1. The generated skyline must not have consecutive horizontal lines of the same height. 2. Make sure to handle all edge cases, such as overlaps and shared edges appropriately.","solution":"from typing import List import heapq def get_skyline(buildings: List[List[int]]) -> List[List[int]]: # Convert each building to events of building start and end. events = [(L, -H, R) for L, R, H in buildings] events += [(R, 0, 0) for _, R, _ in buildings] events.sort() # Resultant list of skyline points. result = [] # Priority queue to store live buildings. live_buildings = [(0, float(\\"inf\\"))] # (-height, right_end) for position, neg_height, right_end in events: # Remove buildings from the heap that are to the left of the current position. while live_buildings[0][1] <= position: heapq.heappop(live_buildings) # If it\'s a building start event, add the building to the heap. if neg_height != 0: heapq.heappush(live_buildings, (neg_height, right_end)) # Current highest building height. current_height = -live_buildings[0][0] # If the current height differs from the last added height, add the point to result. if not result or result[-1][1] != current_height: result.append([position, current_height]) return result"},{"question":"# Strong Connectivity in Directed Graph **Scenario:** You are working on network stability for a distributed system. The system\'s nodes are represented as vertices in a directed graph, and the connections between nodes are directed edges. To ensure reliability, you need to ascertain whether the network is strongly connected — that is, every node can reach every other node directly or indirectly. **Task:** Your task is to implement a function that determines whether a directed graph is strongly connected. **Function Signature:** ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` **Input:** - `vertex_count` (int): The number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. **Output:** - Return a boolean value `True` if the graph is strongly connected, otherwise return `False`. **Constraints:** - 0 <= `vertex_count` <= 10^4 - 0 <= number of edges <= 2 * 10^4 **Examples:** ```python # Example 1: vertex_count = 5 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 3)] print(is_strongly_connected(vertex_count, edges)) # Output: False # Example 2: vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] print(is_strongly_connected(vertex_count, edges)) # Output: True ``` **Explanation:** - In Example 1, some nodes are not reachable from others and vice versa, i.e., there is no complete path between all pairs of nodes. - In Example 2, every node can reach every other node either directly or indirectly, hence the graph is strongly connected.","solution":"from typing import List, Tuple from collections import defaultdict, deque def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: if vertex_count == 0: return True def bfs(start_node, graph): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Create the adjacency list graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check from any node if all nodes are reachable all_nodes = bfs(0, graph) if len(all_nodes) != vertex_count: return False # Check from any node in the reverse graph if all nodes are reachable all_nodes_reverse = bfs(0, reverse_graph) if len(all_nodes_reverse) != vertex_count: return False return True"},{"question":"# Keyboard Row Filter Problem You are required to implement a function `find_keyboard_row(words)` that takes in a list of strings (words) and returns a list of words that can be typed using letters from only one row of an American QWERTY keyboard. The function should consider case insensitivity in letter comparison. Example: * **Input**: `[\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]` * **Output**: `[\\"Alaska\\", \\"Dad\\"]` # Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` # Input: * `words`: A list of strings. Each string can be considered as a word composed of alphabetical characters. # Output: * Returns a list of strings which can be typed entirely using letters on only one row of a QWERTY keyboard. # Constraints: 1. Each word will be composed of alphabet characters only. 2. The function should be case insensitive. 3. The function should have a time complexity of O(n * k), where n is the length of the list and k is the length of the longest word. # Notes: - Make sure to handle an empty list input edge case. - Assure all words are strictly lowercase when performing checks. # Scenario: Consider you\'re developing an educational tool that helps children learn to type by practicing with words that are easy to type with one row of the keyboard. You need to filter such words to enhance the learning experience.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: Returns a list of words that can be typed using letters from only one row of a QWERTY keyboard. # Define each row on the QWERTY keyboard row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: # Convert the word to lowercase for case insensitive comparison lower_word = set(word.lower()) # Check if the word letters are entirely in one of the rows if lower_word <= row1 or lower_word <= row2 or lower_word <= row3: result.append(word) return result"},{"question":"# Scenario You have been hired by a startup specializing in secure communications. One task involves efficiently encrypting messages using large numbers, and the team has decided to use the RSA encryption algorithm, which requires frequent and efficient computation of large powers under a modulo. # Problem Statement Write a function that efficiently calculates the power of a given base, potentially with a modulo. Implement two versions: an iterative version and a recursive version. Both functions should handle large numbers and apply the modulo operation correctly when specified. # Function Signatures ```python def power_iterative(a: int, n: int, mod: int = None) -> int: # Your code here def power_recursive(a: int, n: int, mod: int = None) -> int: # Your code here ``` # Input * **a** (int): The base, an integer. * **n** (int): The exponent, a non-negative integer. * **mod** (int, optional): The modulo value, a non-negative integer if provided. # Output * Return the result of a raised to the power of n. If mod is specified, return the result modulo mod. # Constraints * 0 ≤ a ≤ 10^9 * 0 ≤ n ≤ 10^9 * 1 ≤ mod ≤ 10^9 (if provided) # Requirements 1. Ensure both functions run with time complexity O(log(n)). 2. The recursive function should maintain a stack depth of O(log(n)). 3. Handle typical edge cases like n being 0 or 1, and consider overflow issues. # Example ```python print(power_iterative(2, 10)) # Output: 1024 print(power_iterative(2, 10, 1000)) # Output: 24 print(power_recursive(2, 10)) # Output: 1024 print(power_recursive(2, 10, 1000)) # Output: 24 print(power_recursive(7, 3, 13)) # Output: 5 ```","solution":"def power_iterative(a: int, n: int, mod: int = None) -> int: result = 1 base = a while n > 0: if n % 2 == 1: # If n is odd, include base in result result = result * base if mod: result = result % mod base = base * base if mod: base = base % mod n = n // 2 # Reduce n by half return result % mod if mod else result def power_recursive(a: int, n: int, mod: int = None) -> int: if n == 0: return 1 if mod is None else 1 % mod half_power = power_recursive(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod else half_power * half_power if n % 2 != 0: half_power = (half_power * a) % mod if mod else half_power * a return half_power % mod if mod else half_power"},{"question":"Context: You\'ve been hired as a software engineer and given an internal tool that sorts lists of integers using the Selection Sort algorithm. While the current version of `selection_sort` allows for an optional detailed simulation of each sorting iteration, your task is to expand its functionality. The lead engineer wants you to incorporate a new feature: Allow the `selection_sort` function to sort the array in descending order based on an additional parameter. Requirements: Modify the provided `selection_sort` function to include a parameter `order` which determines whether the list should be sorted in ascending order (default) or descending order. Your function should maintain the ability to print each iteration when the `simulation` parameter is `True`. - **Function Signature**: `def selection_sort(arr, order=\'asc\', simulation=False):` - **Parameters**: - `arr`: A list of integers. - `order`: A string (\'asc\' or \'desc\') indicating the desired order of sorting. Default is \'asc\' (ascending). - `simulation`: A boolean indicating whether to print each iteration. Default is `False`. - **Output**: A sorted list of integers in the specified order. Constraints: - All elements in `arr` are integers and the list length is between 0 and 1000. - The `order` parameter will only be \'asc\' or \'desc\'. - When `simulation` is `True`, print each iteration in the format specified in the original code. Example: ```python # Example 1 input_arr = [64, 25, 12, 22, 11] sorted_arr_asc = selection_sort(input_arr, order=\'asc\', simulation=False) print(sorted_arr_asc) # Output should be [11, 12, 22, 25, 64] # Example 2 input_arr = [64, 25, 12, 22, 11] sorted_arr_desc = selection_sort(input_arr, order=\'desc\', simulation=False) print(sorted_arr_desc) # Output should be [64, 25, 22, 12, 11] # Example 3: Simulation input_arr = [64, 25, 12, 22, 11] selection_sort(input_arr, order=\'asc\', simulation=True) # Expected printed output: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 ```","solution":"def selection_sort(arr, order=\'asc\', simulation=False): n = len(arr) for i in range(n): if simulation: print(f\\"iteration {i} :\\", \' \'.join(map(str, arr))) min_max_index = i for j in range(i + 1, n): if (order == \'asc\' and arr[j] < arr[min_max_index]) or (order == \'desc\' and arr[j] > arr[min_max_index]): min_max_index = j arr[i], arr[min_max_index] = arr[min_max_index], arr[i] return arr"},{"question":"# Scenario You are working on a navigation system that helps drivers find the shortest paths between various locations in a city. Each location is a vertex in a graph, and the roads connecting them have various travel times as edge weights. The city government ensures that all travel times are non-negative. # Objective Implement a function that applies Dijkstra\'s algorithm to find the shortest paths from a given starting location to all other locations in the city. # Task Write a function `shortest_paths(vertex_count, edges, src)` that computes the shortest path from the source vertex to all other vertices in the graph. # Requirements * **Input**: * `vertex_count` (int): The number of vertices in the graph. * `edges` (List[Tuple[int, int, int]]): A list of tuples representing the edges of the graph. Each tuple contains three integers `(u, v, w)`, where `u` and `v` are the vertices, and `w` is the weight of the edge connecting `u` to `v`. * `src` (int): The source vertex. * **Output**: * List[int]: A list of distances from the source vertex to each other vertex. If a vertex is unreachable, the distance should be `float(\'inf\')`. # Constraints: * `1 <= vertex_count <= 1000` * `0 <= weight <= 10^5` * Assumes all weights are non-negative. # Performance: The implementation should be efficient enough to handle the upper constraints smoothly. # Example ```python def shortest_paths(vertex_count, edges, src): # function implementation goes here # Example graph vertex_count = 5 edges = [ (0, 1, 10), (0, 4, 5), (1, 2, 1), (2, 3, 4), (4, 1, 3), (4, 2, 9), (4, 3, 2) ] src = 0 print(shortest_paths(vertex_count, edges, src)) # Output: [0, 8, 9, 7, 5] ``` # Notes * Ensure to handle edge cases such as isolated vertices and vertices with no edges properly. * Your implementation should handle performance optimizations effectively, considering edge and vertex constraints.","solution":"import heapq def shortest_paths(vertex_count, edges, src): Finds the shortest paths from a source vertex to all other vertices in a graph using Dijkstra\'s algorithm. :param vertex_count: Number of vertices in the graph. :param edges: List of tuples representing the edges of the graph. Each tuple contains three integers (u, v, w), where u and v are vertices, and w is the weight of the edge connecting u to v. :param src: The source vertex. :return: List of distances from the source vertex to each other vertex. If a vertex is unreachable, the distance should be float(\'inf\'). # Initialize adjacency list adj = [[] for _ in range(vertex_count)] for u, v, w in edges: adj[u].append((v, w)) # Initialize distances and priority queue distances = [float(\'inf\')] * vertex_count distances[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the distance is outdated, skip if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in adj[current_vertex]: distance = current_distance + weight # If a shorter path to neighbor is found if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Strobogrammatic Number Checker Objective: Write a function that determines if a given number is strobogrammatic. The number will be represented as a string. Function Signature: ```python def is_strobogrammatic(num: str) -> bool: pass ``` Input: - `num` (str): The input number as a string. The string length will be between 0 and 100 inclusive, and it will contain only numeric digits. Output: - `bool`: Return `True` if the number is strobogrammatic, `False` otherwise. Constraints: - The function should correctly identify all strobogrammatic numbers. - The function should handle an empty string correctly by returning `True` (an empty string can be considered strobogrammatic). Performance Requirements: - The solution should have a time complexity of O(n) and a space complexity of O(1) where n is the length of the input string. Context/Scenario: You are working on a digital e-reader display that might rotate its content when the device orientation changes. To ensure the numbers displayed maintain their readability when turned upside down, you need to write a function that checks if a number remains valid when rotated by 180 degrees. This function will be crucial in ensuring the readability of numeric codes displayed on the device in various orientations. Example: ```python assert is_strobogrammatic(\\"69\\") == True assert is_strobogrammatic(\\"88\\") == True assert is_strobogrammatic(\\"962\\") == False assert is_strobogrammatic(\\"1\\") == True assert is_strobogrammatic(\\"\\") == True ``` Use the example provided to test your implementation. Consider additional tests to check edge cases and ensure robustness of your solution.","solution":"def is_strobogrammatic(num: str) -> bool: Determines if a given number is strobogrammatic. Args: - num (str): The input number as a string. Returns: - bool: True if the number is strobogrammatic, False otherwise. strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: left_char = num[left] right_char = num[right] if left_char not in strobogrammatic_pairs or strobogrammatic_pairs[left_char] != right_char: return False left += 1 right -= 1 return True"},{"question":"Your task is to implement a data structure that allows the addition of words and supports both exact and wildcard searches efficiently. The data structure should support the operations described below: 1. **add_word(word)**: Adds the given word to the data structure. 2. **search(word)**: Returns `True` if there exists any word in the data structure that matches the given `word` (where \\".\\" can represent any letter), and `False` otherwise. # Requirements 1. Implement a `WordDatabase` class with the described methods. 2. Ensure your implementation takes edge cases into account, such as empty input words. 3. Optimize your solution to handle an extensive set of words and multiple wildcard searches efficiently. # Input and Output Formats **Input**: - All words αdded using `add_word` will have a length greater than 0 and consist only of lowercase English letters. - The `search` method\'s input may contain lowercase English letters and \\".\\" characters. **Output**: - The `search` method should return a boolean value (`True` or `False`). # Constraints - You may assume that all inputs are valid as per the specifications. - Ensure your `search` method performs efficiently even when large sets of words and numerous wildcard searches are involved. # Example ```python wd = WordDatabase() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # False print(wd.search(\\"bad\\")) # True print(wd.search(\\".ad\\")) # True print(wd.search(\\"b..\\")) # True ``` Implement the class `WordDatabase` and its methods to pass the above example test cases.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDatabase: def __init__(self): self.root = TrieNode() def add_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): return self._search_in_node(word, self.root) def _search_in_node(self, word, node): for i, char in enumerate(word): if char == \\".\\": for x in node.children: if self._search_in_node(word[i+1:], node.children[x]): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"You are given a binary tree and your goal is to identify the deepest node that is the left child of its parent node. Each node of the binary tree has an integer value, and we consider any node that is not the root or its immediate right child as a candidate. Implement a function `deepest_left_node(root: TreeNode) -> Optional[int]` where: - `root`: The root of the binary tree. - `TreeNode`: A class representing a node in the binary tree. The function should return the value of the deepest left node. If there is no such node, return `None`. # Input Format - The root of the binary tree (node class TreeNode defined). # Output Format - Return an integer which is the value of the deepest left node or `None` if there is no such node. # Constraints - The number of nodes in the tree will be in the range `[1, 1000]`. - The value of each node will be a unique integer within the range `[-10^6, 10^6]`. # Examples 1. Given the tree: ``` 1 / 2 3 / 4 5 6 7 ``` - Expected output: `4` 2. Given the tree: ``` 1 / 2 5 ``` - Expected output: `None` 3. Given the tree: ``` 1 3 6 ``` - Expected output: `None` # Notes - You should handle cases where the binary tree might be imbalanced. - Consider edge cases with minimal or no left children.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_left_node(root: TreeNode) -> Optional[int]: if not root: return None queue = [(root, False, 0)] # (node, is_left, depth) deepest_left_value = None max_depth = -1 while queue: node, is_left, depth = queue.pop(0) if is_left and not node.left and not node.right: if depth > max_depth: max_depth = depth deepest_left_value = node.val if node.left: queue.append((node.left, True, depth + 1)) if node.right: queue.append((node.right, False, depth + 1)) return deepest_left_value"},{"question":"# Stutter Algorithm Coding Exercise You need to stutter the elements of a stack. That means, given a stack of `n` elements, you must write a function that replaces every value in the stack with two occurrences of that value. You can implement this based on one of the two provided methods using either an auxiliary stack or an auxiliary queue. Input - A list `stack` representing the elements of the stack, where the end of the list is considered the top of the stack. Output - A list representing the modified stack with each element duplicated. Constraints - Maximum size of the stack, `n`, is 1000. - Values in the stack will be integers and can include negative values. Requirements 1. Implement the `stutter_with_stack` function using an auxiliary stack. 2. Implement the `stutter_with_queue` function using an auxiliary queue (deque). # Examples **Example 1**: ```python stack = [3, 7, 1, 14, 9] print(stutter_with_stack(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [3, 7, 1, 14, 9] print(stutter_with_queue(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ```","solution":"from collections import deque def stutter_with_stack(stack): Stutter the elements in the stack using an auxiliary stack. auxiliary_stack = [] while stack: element = stack.pop() auxiliary_stack.append(element) auxiliary_stack.append(element) # Reverse back to preserve the order result_stack = [] while auxiliary_stack: result_stack.append(auxiliary_stack.pop()) return result_stack def stutter_with_queue(stack): Stutter the elements in the stack using an auxiliary queue. auxiliary_queue = deque() while stack: element = stack.pop() auxiliary_queue.appendleft(element) auxiliary_queue.appendleft(element) # Move elements back to stack to preserve the order result_stack = list(auxiliary_queue) return result_stack"},{"question":"Problem Statement: You are required to implement a specialized stack data structure that supports regular stack operations (`push`, `pop`, `peek`, `is_empty`) and an additional operation `get_min` that retrieves the minimum element in the stack in constant time. This task will test your understanding of stack fundamentals and your ability to extend its functionality. Requirements: 1. Implement a class `SpecialStack` that uses either the `ArrayStack` or `LinkedListStack` as its underlying stack implementation. 2. Add a method `get_min()` which returns the minimum element in the stack in O(1) time. 3. Assume all stack operations will only deal with integers. Function Signatures: ```python class SpecialStack: def __init__(self): # initialize your data structures here pass def push(self, value: int): # implements pushing an element onto the stack pass def pop(self) -> int: # implements popping the top element from the stack pass def peek(self) -> int: # returns the top element without removing it pass def is_empty(self) -> bool: # returns if the stack is empty pass def get_min(self) -> int: # returns the minimum element in the stack in O(1) time pass ``` Constraints: * All elements are integers. * You may assume no duplicate elements. * You may assume `get_min()` will only be called when the stack is not empty. Performance Requirements: - All stack operations should be O(1) time complexity except for dynamic array expansion in `ArrayStack` where applicable. Example: ```python stack = SpecialStack() stack.push(3) stack.push(5) print(stack.get_min()) # Output: 3 stack.push(2) stack.push(1) print(stack.get_min()) # Output: 1 print(stack.pop()) # Output: 1 print(stack.get_min()) # Output: 2 print(stack.pop()) # Output: 2 print(stack.peek()) # Output: 5 ``` Notes: - You are free to use an additional stack or any other auxiliary data structures to achieve the required time complexities.","solution":"class SpecialStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value: int): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") popped_value = self.stack.pop() if popped_value == self.min_stack[-1]: self.min_stack.pop() return popped_value def peek(self) -> int: if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self) -> bool: return len(self.stack) == 0 def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"min from empty stack\\") return self.min_stack[-1]"},{"question":"# Problem Description You are given an array of non-negative numerical values, and you need to implement a sorting algorithm based on the bucket sort principle. Your implementation should handle large arrays efficiently and take into account the possible variations in the distribution of the input data. Implement the function `optimized_bucket_sort` that sorts the input array using the bucket sort technique enhanced with efficient sub-bucket sorting and dynamic bucket allocation based on the given data range. # Function Signature ```python def optimized_bucket_sort(arr: list) -> list: ``` # Input * `arr` (list of integers/floats): The array of non-negative numerical values that need to be sorted. # Output * `list`: The sorted array in ascending order. # Constraints * The input array can have up to 10^6 elements. * All elements are non-negative and within the range of [0, 10^6]. # Requirements * The implementation should not use more than O(n) auxiliary space. * The algorithm should run efficiently for varied distributions of data. # Example ```python print(optimized_bucket_sort([0.78, 0.55, 0.45, 0.98, 0.12, 0.20])) # Output: [0.12, 0.20, 0.45, 0.55, 0.78, 0.98] print(optimized_bucket_sort([3, 6, 2, 7, 5, 9, 1, 8, 4])) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Notes * Consider using a more efficient sorting algorithm within the buckets if necessary. * Ensure the bucket allocation is dynamic and scales with the data characteristics to optimize the sorting process. * Make sure to handle edge cases such as empty arrays and arrays with identical elements appropriately.","solution":"def optimized_bucket_sort(arr): if len(arr) == 0: return [] # Determine the maximum value in the array to determine bucket ranges max_value = max(arr) bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute elements into appropriate buckets for num in arr: index = int(num * bucket_count / (max_value + 1)) buckets[index].append(num) # Sort each bucket using an efficient sorting algorithm (e.g., Python\'s Timsort) sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"# Coding Task Scenario You are working on a project where you need to sort data for analysis. The data set involves strings representing names of items that need to be sorted alphabetically. Although there are more efficient sorting algorithms, you have chosen to practice implementing Selection Sort for better understanding its mechanics and limitations. Problem Statement Implement the `selection_sort_strings` function that sorts a list of strings in alphabetical order using the Selection Sort algorithm. Function Signature ```python def selection_sort_strings(arr: List[str], simulation: bool = False) -> List[str]: ``` Input * `arr`: A list of strings (`List[str]`) that need to be sorted. * `simulation`: An optional boolean parameter (`bool`) to print the array at each iteration step for visualization purposes. Default is `False`. Output * Returns a list of strings (`List[str]`) sorted in alphabetical order. Constraints * The array can contain duplicates. * The array can have varying lengths up to 1000 elements. Performance Requirements * Time Complexity: O(n^2) * Space Complexity: O(1) Example ```python input_array = [\\"banana\\", \\"apple\\", \\"orange\\", \\"mango\\"] result = selection_sort_strings(input_array) print(result) # Output should be: [\\"apple\\", \\"banana\\", \\"mango\\", \\"orange\\"] ``` Notes 1. You must not use Python’s built-in sort functions. 2. Ensure the function handles empty lists and lists with a single element correctly.","solution":"from typing import List def selection_sort_strings(arr: List[str], simulation: bool = False) -> List[str]: n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"Step {i+1}: {arr}\\") return arr"},{"question":"You are given two strings, `s1` and `s2`, where `s2` contains all distinct characters. Your task is to write a function to find and return the longest common substring between `s1` and `s2`. Function Signature ```python def longest_common_substring(s1: str, s2: str) -> str ``` Input - `s1` (string): A string of length n (1 ≤ n ≤ 1000). - `s2` (string): A string of length m (1 ≤ m ≤ 1000), containing all unique characters. Output - Returns a string which is the longest common substring between `s1` and `s2`. - If there are multiple longest common substrings of the same length, return any of them. Constraints - Expected time complexity is O(n log n). - `s2` contains all unique characters. Examples ```python assert longest_common_substring(\\"ABABC\\", \\"BABCA\\") == \\"BABC\\" assert longest_common_substring(\\"XYXZ\\", \\"XYZ\\") == \\"XYZ\\" assert longest_common_substring(\\"ABC\\", \\"DEF\\") == \\"\\" ``` Brief Scenario Consider that you are developing a software to detect similarities between two documents, `s1` and `s2`. Given the constraint that `s2` is a reference document containing unique terms, your software needs to find the longest segment of continuous similarity between the documents. Implement the function to accomplish this task efficiently.","solution":"def longest_common_substring(s1, s2): def get_suffix_array(s): suffixes = sorted((s[i:], i) for i in range(len(s))) return [suffix[1] for suffix in suffixes] def get_lcp_array(s, suffix_array): n = len(s) rank = [0] * n lcp = [0] * n for i, suffix in enumerate(suffix_array): rank[suffix] = i h = 0 for i in range(n): if rank[i] > 0: j = suffix_array[rank[i] - 1] while i + h < n and j + h < n and s[i + h] == s[j + h]: h += 1 lcp[rank[i]] = h if h > 0: h -= 1 return lcp combined_string = s1 + \'#\' + s2 + \'\' suffix_array = get_suffix_array(combined_string) lcp_array = get_lcp_array(combined_string, suffix_array) max_len = 0 start_index = 0 for i in range(1, len(lcp_array)): if lcp_array[i] > max_len: suffix1_in_s1 = suffix_array[i - 1] < len(s1) suffix2_in_s1 = suffix_array[i] < len(s1) if suffix1_in_s1 != suffix2_in_s1: max_len = lcp_array[i] start_index = suffix_array[i] return combined_string[start_index:start_index + max_len] # Example usage: print(longest_common_substring(\\"ABABC\\", \\"BABCA\\")) # Output: \\"BABC\\" print(longest_common_substring(\\"XYXZ\\", \\"XYZ\\")) # Output: \\"XYZ\\" print(longest_common_substring(\\"ABC\\", \\"DEF\\")) # Output: \\"\\""},{"question":"# Sparse Matrix Multiplication Assessment **Context**: You are working on a large-scale machine learning project involving document-term matrices, which are typically sparse. Efficient matrix multiplications are crucial for your project\'s performance. Your task is to implement a function that multiplies two sparse matrices and returns the result. **Task**: Write a function `sparse_matrix_multiply(A, B)` that takes two sparse matrices, `A` and `B`, and returns the product of these two matrices. **Input**: - `A`: List of lists representing the sparse matrix A, where `A[i][j]` is the element at row `i` and column `j`. - `B`: List of lists representing the sparse matrix B, where `B[i][j]` is the element at row `i` and column `j`. **Output**: - A list of lists representing the product matrix C, where `C[i][j]` is the sum of the products of the elements in the `i`-th row of `A` and the `j`-th column of `B`. **Constraints**: - The number of columns in A must equal the number of rows in B. - Elements in both matrices can be integers. - Matrices can be empty (i.e., `A` or `B` can be an empty list). **Example**: ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] # Expected Output: # [ # [7, 0, 0], # [-7, 0, 3] # ] print(sparse_matrix_multiply(A, B)) ``` **Edge Cases to Consider**: - If either matrix is empty, return an empty matrix. - Matrices with rows or columns of all zeros. - Handle dimension mismatches by raising an appropriate exception. **Performance Requirement**: - The solution should efficiently handle sparse matrices by leveraging the sparsity and avoiding unnecessary computations. **Function Signature**: ```python def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ```","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B: return [] m, n, p = len(A), len(A[0]), len(B[0]) # Initialize result matrix with zeros C = [[0] * p for _ in range(m)] # Transform B for easier access of columns B_cols = [[B[row][col] for row in range(len(B))] for col in range(p)] for i in range(m): for j in range(p): C[i][j] = sum(A[i][k] * B_cols[j][k] for k in range(n)) return C"},{"question":"# Nearest Neighbor Classification Algorithm Objective: Implement an advanced version of the nearest neighbor algorithm. You are provided with a training set of labeled vectors and a target vector. Your task is to classify the target vector by finding the label of its nearest neighbor from the training set. Requirements: 1. **Function Name**: `classify_nearest_neighbor` 2. **Input**: * `target`: A tuple representing the target vector. * `training_set`: A dictionary where the key is a tuple (vector) and the value is the label associated with that vector. 3. **Output**: * A label (type can be string, int, etc.) corresponding to the nearest neighbor\'s label. Constraints: 1. All vectors (target and training set) have the same dimension. 2. The training set has at least one vector. 3. The function should handle high-dimensional vectors efficiently. 4. Ensure that the function considers possible numerical and floating-point inaccuracies in distance comparison. Specifications: 1. Handle edge cases where multiple vectors are equidistant. 2. Optimize the distance computation using any efficient method or library. Example: ```python # Example training set training_set = { (1.0, 2.0, 3.0): \'A\', (4.0, 5.0, 6.0): \'B\', (7.0, 8.0, 9.0): \'C\' } # Example target vector target = (2.0, 3.0, 4.0) # Expected Output: \'A\' (since the first vector is the closest) print(classify_nearest_neighbor(target, training_set)) ``` Additional Notes: 1. Use Euclidean distance as the metric for comparing vectors. 2. Ensure the function is robust and handles large, high-dimensional data within reasonable time. ```python # Implementation def classify_nearest_neighbor(target, training_set): Classify the target vector based on the nearest neighbor algorithm. import math def distance(x, y): Calculate the Euclidean distance between vectors x and y. assert len(x) == len(y), \\"Vectors must be of the same length\\" return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) closest_key = min(training_set, key=lambda k: distance(target, k)) return training_set[closest_key] ```","solution":"def classify_nearest_neighbor(target, training_set): Classify the target vector based on the nearest neighbor algorithm. import math def distance(x, y): Calculate the Euclidean distance between vectors x and y. assert len(x) == len(y), \\"Vectors must be of the same length\\" return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) closest_key = min(training_set, key=lambda k: distance(target, k)) return training_set[closest_key]"},{"question":"# Path/URL Joining Function Python function `join_with_slash` takes two string inputs: a `base` part and a `suffix` part, and joins them to form a path or URL ensuring that there are no redundant slashes. You are required to extend this function to handle edge cases and improve its robustness. Task: 1. Modify the function `join_with_slash`: - Ensure it handles empty strings appropriately. - Throw an `InvalidPathError` if both `base` and `suffix` are empty. - Handle cases where both parts are valid. - Maintain correct format for final path/URL. Implementation Details: * **Function Signature**: `def join_with_slash(base: str, suffix: str) -> str:` * **Input Parameters**: - `base` (str): The base path part, may be empty. - `suffix` (str): The suffix path part, may be empty. * **Outputs**: - Returns a correctly combined path/URL as a string. * **Error Handling**: - Raise `ValueError(\\"Both base and suffix cannot be empty.\\")` if both inputs are empty. Constraints: - The `base` can be a full URL or file directory path. - The `suffix` is a relative path or further part of the URL. - Both paths should be properly formatted, and joined without redundant slashes. Example: ```python assert join_with_slash(\\"http://example.com\\", \\"path/to/resource\\") == \\"http://example.com/path/to/resource\\" assert join_with_slash(\\"http://example.com/\\", \\"/path/to/resource/\\") == \\"http://example.com/path/to/resource\\" assert join_with_slash(\\"\\", \\"file.txt\\") == \\"file.txt\\" assert join_with_slash(\\"/base/path/\\", \\"/file\\") == \\"/base/path/file\\" assert join_with_slash(\\"\\", \\"\\") raises ValueError # Expecting the function to throw an error ``` ```python class InvalidPathError(Exception): pass def join_with_slash(base: str, suffix: str) -> str: # Check if both are empty and raise ValueError if not base and not suffix: raise ValueError(\\"Both base and suffix cannot be empty.\\") # Remove / trailing in base path base = base.rstrip(\'/\') # Remove / leading and trailing in suffix path suffix = suffix.lstrip(\'/\').rstrip() # If one of the inputs is empty, return the other if not base: return suffix elif not suffix: return base # Combine paths full_path = \\"{}/{}\\".format(base, suffix) return full_path assert join_with_slash(\\"http://example.com\\", \\"path/to/resource\\") == \\"http://example.com/path/to/resource\\" assert join_with_slash(\\"http://example.com/\\", \\"/path/to/resource/\\") == \\"http://example.com/path/to/resource\\" assert join_with_slash(\\"\\", \\"file.txt\\") == \\"file.txt\\" assert join_with_slash(\\"/base/path/\\", \\"/file\\") == \\"/base/path/file\\" assert join_with_slash(\\"\\", \\"\\") raises ValueError # Expecting the function to throw an error ```","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins base and suffix paths ensuring no redundant slashes. Raises ValueError if both base and suffix are empty. # Check if both are empty and raise ValueError if not base and not suffix: raise ValueError(\\"Both base and suffix cannot be empty.\\") # Remove / trailing in base path base = base.rstrip(\'/\') # Remove / leading and trailing in suffix path suffix = suffix.lstrip(\'/\').rstrip(\'/\') # If one of the inputs is empty, return the other if not base: return suffix elif not suffix: return base # Combine paths full_path = f\\"{base}/{suffix}\\" return full_path"},{"question":"# Stutter Stack Transformation # Objective Design a function that demonstrates your understanding of stack and queue manipulations by doubling each element in a stack using different auxiliary data structures. # Problem Statement You are given a stack `stack` where you need to replace every value in the stack with two occurrences of that value. Implement two functions, `first_stutter` and `second_stutter`, that achieve this using different auxiliary data structures. # Function 1: first_stutter * **Input**: A stack represented by a list of integers. * **Output**: The transformed stack with each element doubled using an auxiliary stack. * **Example**: ```python stack = [3, 7, 1, 14, 9] first_stutter(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Function 2: second_stutter * **Input**: A stack represented by a list of integers. * **Output**: The transformed stack with each element doubled using an auxiliary queue. * **Example**: ```python stack = [3, 7, 1, 14, 9] second_stutter(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Constraints 1. The stack should be implemented using a list. 2. The functions should handle an empty stack gracefully. 3. You are only allowed to use a single auxiliary data structure (either a stack for `first_stutter` or a queue for `second_stutter`). # Performance Requirements * Both functions should run in O(n) time complexity, where `n` is the number of elements in the original stack. * The space complexity for auxiliary storage should not exceed O(n). Write your implementation for `first_stutter` and `second_stutter` below:","solution":"from collections import deque def first_stutter(stack): This function takes a stack and doubles each element using an auxiliary stack. auxiliary_stack = [] # Use the auxiliary stack to hold double the elements while stack: value = stack.pop() auxiliary_stack.append(value) auxiliary_stack.append(value) # Transfer elements back to the original stack to maintain order while auxiliary_stack: stack.append(auxiliary_stack.pop()) return stack def second_stutter(stack): This function takes a stack and doubles each element using an auxiliary queue. auxiliary_queue = deque() # Use the auxiliary queue to hold double the elements while stack: value = stack.pop() auxiliary_queue.appendleft(value) auxiliary_queue.appendleft(value) # Transfer elements back to the original stack to maintain order while auxiliary_queue: stack.append(auxiliary_queue.popleft()) return stack"},{"question":"Coding Assessment Question # Problem Statement You are given a positive integer `n`. Write a function that calculates the number of possible ways to partition this integer into sums of smaller integers (including 1). Your solution should use dynamic programming to ensure efficient computation. # Function Signature ```python def number_of_partitions(n: int) -> int: pass ``` # Input * An integer `n` where ( 1 leq n leq 50 ). # Output * Return an integer representing the number of distinct partitions of `n`. # Example ```python number_of_partitions(4) # Returns: 5 number_of_partitions(7) # Returns: 15 ``` # Explanation For `number_of_partitions(4)`, the partitions are: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Total = 5 For `number_of_partitions(7)`, the partitions are: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 Total = 15 # Constraints * The function should handle integer inputs as per the range specified. * Optimize for both time and space, ensuring the complexity does not exceed O(n^2).","solution":"def number_of_partitions(n: int) -> int: Returns the number of ways to partition integer n using dynamic programming. # Initialize dp array with base case dp = [1] + [0] * n # Update dp array for each number <= n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: License Key Formatting Algorithm * **Type**: String manipulation * **Main Purpose**: Format a string representing a license key by grouping characters into specific segment lengths separated by dashes. Complexity * **Time Complexity**: O(n) - where n is the length of the input string. The algorithm processes each character of the string a few times (initially to filter out dashes, then to insert new dashes). * **Space Complexity**: O(n) - to store the characters and the result. Principles 1. **Step 1**: Remove all dashes from the input string and collect alphanumeric characters. 2. **Step 2**: Reverse the alphanumeric string and iterate through it, inserting dashes after every k characters. 3. **Step 3**: Reverse the resulting string again to get the final formatted license key. Characteristics & Applications * **Properties**: The rearrangement of characters and insertion of dashes is done in a reverse sequence to ensure the final grouping is correct. * **Common Use Cases**: This algorithm is often used to format product keys, license numbers, or other strings requiring specific groupings and separations for readability. * **Strengths/Limitations**: - **Strengths**: Simple implementation, ensures grouping is correct by working backward. - **Limitations**: Requires string reversal which might not be ideal for extremely long strings. Implementation Challenges * **Edge Cases**: - Input string with no dashes. - Input string with only dashes. - Group size larger than the number of characters after removing dashes. * **Performance Bottlenecks**: For very large strings, multiple reversals could be inefficient. * **Error Scenarios**: Incorrect handling of characters if the assumption of alphanumeric characters is violated. * **Optimization Points**: Instead of reversing strings, maintaining a count and directly inserting characters into the result could be more efficient. <|Analysis End|> <|Question Begin|> # License Key Formatter Context: A software company generates license keys for their software which include alphanumeric characters separated by dashes for readability. A single mishap in the grouping can cause issues in the key validation process. To ensure keys are correctly formatted before use, your task is to write a function that formats given license keys into consistent segments. Objective: Write a function `license_number(key: str, k: int) -> str` that reformats a given license key string such that each segment contains exactly `k` characters, except for the first segment which may be shorter to accommodate the remaining characters. Input: * `key`: A string `key` of length `n` consisting of alphanumeric characters and dashes. * `k`: An integer `k` representing the desired length of each segment. Output: * The function should return a string of reformatted license key with segments of length `k`, separated by dashes. Constraints: * The input string `key` will only contain alphanumeric characters and dashes. * `k` will be a positive integer. Example Usage: ```python print(license_number(\\"2-4A0r7-4k\\", 4)) # Output: \\"24A0-R74K\\" print(license_number(\\"2-4A0r7-4k\\", 3)) # Output: \\"24-A0R-74K\\" ``` Notes: * The newly formed string should have segments of maximum length `k` separated by dashes. * The function should be case insensitive, but the final result should be in all uppercase letters. * Any leading or trailing dashes in the input string should be handled. |Question End| Your Task: Implement the function `license_number` to solve the problem as described.","solution":"def license_number(key: str, k: int) -> str: Reformats the given license key string so that each segment contains exactly `k` characters, except for the first segment which may be shorter. Parameters: key (str): The input license key string consisting of alphanumeric characters and dashes. k (int): The desired length of each segment. Returns: str: The reformatted license key string with segments of length `k`, separated by dashes. # Remove all dashes from the input string and convert to uppercase cleaned_key = key.replace(\\"-\\", \\"\\").upper() # Determine the length of the first group first_group_length = len(cleaned_key) % k or k # Initialize result with the first group result = cleaned_key[:first_group_length] # Iterate over the rest of the string in chunks of size k for i in range(first_group_length, len(cleaned_key), k): result += \'-\' + cleaned_key[i:i + k] return result"},{"question":"# Your Task You are required to implement an efficient method to compute the number of combinations (nCr), i.e., the number of ways to choose `r` items from `n` items without regard to the order of selection. Use the memoization technique to optimize your solution. Function Signature ```python def combination_memo(n: int, r: int) -> int: ``` Input - Two integers, `n` and `r`. (`0 ≤ r ≤ n ≤ 500`) Output - Return an integer representing the number of ways to choose `r` items from `n` items. Constraints - Your function should efficiently handle the upper limits (n, r ≤ 500) within reasonable time and space complexity. - Assume that all inputs are valid integers where `0 ≤ r ≤ n`. Example ```python assert combination_memo(5, 3) == 10 assert combination_memo(10, 5) == 252 assert combination_memo(20, 10) == 184756 ``` Detailed Requirements 1. **Efficiency Requirement**: Utilize memoization to ensure the solution is efficient. 2. **Handling Edge Cases**: Make sure to handle cases such as `n = r = 0`. 3. **Correctness**: Ensure that your solution is mathematically correct and optimally computes `nCr`. Scenario Consider a scenario where you need to compute how many ways you can form a committee of `r` members from a pool of `n` candidates. Such calculations are common in combinatorial problems in various fields such as statistics, biology, and computer science. Therefore it is crucial to have an efficient algorithm for large inputs. Implement the function and validate your implementation with the provided examples to ensure correctness.","solution":"def combination_memo(n: int, r: int) -> int: Returns the number of ways to choose r items from n items without regard to order. Uses memoization for efficiency. memo = {} def comb(n, r): if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = comb(n-1, r-1) + comb(n-1, r) return memo[(n, r)] return comb(n, r)"},{"question":"**Objective**: Write a function that determines the number of possible combinations that add up to a given target sum using integers from a provided array. Different sequences are treated as different combinations. Function Signature ```python def combination_sum(nums: List[int], target: int) -> int: pass ``` # Input and Output - **Input**: - `nums`: A list of positive integers without duplicates (`1 <= nums[i] <= 100`, `1 <= len(nums) <= 20`). - `target`: A positive integer (`1 <= target <= 1000`). - **Output**: - Returns an integer representing the number of possible combinations. # Constraints - Each number in the array can be used multiple times to form the target sum. - The input array `nums` will contain only unique positive integers. # Example ```python nums = [1, 2, 3] target = 4 combination_sum(nums, target) ``` **Expected Output**: `7` # Instructions 1. Implement the function using iterative Dynamic Programming (bottom-up approach). 2. Ensure the solution runs efficiently for the given input constraints. 3. Handle any edge cases and invalid input scenarios gracefully. Detailed Steps 1. Initialize a list `combinations` of size `target + 1` filled with zeroes. 2. Set `combinations[0]` to 1 since there\'s one way to make zero, which is by using zero elements. 3. Loop over each value from 1 to `target`. 4. For each value, iterate through the numbers in `nums`. 5. If a number can be used to reach the current value, update the `combinations` list. 6. Return the total number of ways to form the `target` sum stored in `combinations[target]`. Follow-up Question What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: Returns the number of possible combinations that add up to the given target sum using the integers from the provided list. Each number in the list can be used multiple times. Different sequences are treated as different combinations. # Initialize a list to store the number of combinations for each sum up to target. dp = [0] * (target + 1) # There is one way to make the sum 0, by using no elements. dp[0] = 1 # Calculate the number of combinations for each sum from 1 to target. for current_sum in range(1, target + 1): for num in nums: if current_sum >= num: dp[current_sum] += dp[current_sum - num] # The desired result is the number of combinations that add up to target. return dp[target]"},{"question":"# Scenario A social media network uses graphs to represent users and their connections (friendships). Anomalous activities are represented by cycles in the graph, which can suggest bots or malicious users spamming friend requests to create loops. Your task is to identify the starting point of these cycles for further investigation. # Question You are given a directed linked list that may contain a cycle. Implement a function `find_cycle_start_node(head)` that will help the social media network identify and report the starting node of the first detected cycle. # Constraints * The list can contain up to 10^6 nodes. * Node values are unique identifiers represented as strings. * There may or may not be a cycle in the list. * The function should return `None` if no cycle exists. # Input and Output * **Input**: `head` - The head node of a linked list. * **Output**: The node representing the start of the cycle if a cycle exists, otherwise `None`. # Function Signature ```python def find_cycle_start_node(head: Node) -> Node: pass ``` # Example ```python # create linked list => 1 -> 2 -> 3 -> 4 -> 5 -> 3 head = Node(\'1\') head.next = Node(\'2\') curr = head.next cyclic_node = Node(\'3\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'4\') curr = curr.next curr.next = Node(\'5\') curr = curr.next curr.next = cyclic_node # If the function runs successfully, it should return the node with the value \'3\' assert find_cycle_start_node(head).val == \'3\' ```","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def find_cycle_start_node(head: Node) -> Node: Returns the starting node of the cycle if it exists in the linked list, otherwise None. slow = fast = head # Step 1: Detect if a cycle exists using two-pointer technique while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle exists, return None if not fast or not fast.next: return None # Step 2: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are tasked with creating a function to find all possible combinations of factors of a given positive integer n that are greater than 1 and less than n using the iterative approach. This problem helps in understanding recursive and iterative approaches to solving combinatorial problems. Function Signature ```python def get_factor_combinations(n: int) -> List[List[int]]: ``` Input * An integer `n` (1 <= n <= 10000). Output * Returns a list of lists where each list is a combination of factors of `n`. Constraints * Factors should be greater than 1 and less than `n`. * The result should not include duplicate combinations. Example Input 1: ```python n = 12 ``` Output 1: ```python [ [2, 6], [2, 2, 3], [3, 4] ] ``` Input 2: ```python n = 32 ``` Output 2: ```python [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` # Implementation Requirements * Implement the solution using an iterative approach. * Ensure the function is optimized for performance concerning both time and space complexity. * Handle edge cases correctly (e.g., input number is 1 or a prime number). # Context Consider you are working on a mathematical library where you need to provide utilities for factorization. This function is part of the utilities to generate factor combinations of a given integer.","solution":"from typing import List def get_factor_combinations(n: int) -> List[List[int]]: def factors(num): for i in range(2, int(num**0.5) + 1): if num % i == 0: yield i, num // i result = [] stack = [(n, 2, [])] while stack: current, start, path = stack.pop() for i, factor in factors(current): if i >= start: result.append(path + [i, factor]) stack.append((factor, i, path + [i])) return result"},{"question":"# Coding Challenge Description You are given a list of sorted characters `letters` containing only lowercase letters, and a target letter `target`. Write a function `find_smallest_letter_greater_than_target` to find the smallest element in the list that is larger than the given target. The letters wrap around, meaning if the target is \'z\' and the list contains \'a\', the answer should be \'a\'. Input - A list of lowercase characters `letters`, sorted in non-decreasing order. - A lowercase character `target`. Constraint: - The length of `letters` is positive and up to 10^4. - `letters` contains at least two different characters. Output - A single lowercase character that represents the smallest character in the list that is larger than the given target. Examples ```python # Example 1 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" # Expected Output: \\"c\\" # Example 2 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" # Expected Output: \\"f\\" # Example 3 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" # Expected Output: \\"f\\" ``` Requirements - **Efficiency**: Your function should use an efficient approach, with a time complexity better than O(N). - **Correctness**: Your function should handle edge cases and cyclic wrapping properly. Function Signature ```python def find_smallest_letter_greater_than_target(letters: List[str], target: str) -> str: pass ``` Hints - Consider using binary search to efficiently find the smallest letter greater than the target. - Don’t forget to handle the cyclic wrap-around condition.","solution":"from typing import List def find_smallest_letter_greater_than_target(letters: List[str], target: str) -> str: left, right = 0, len(letters) - 1 while left <= right: mid = (left + right) // 2 if letters[mid] <= target: left = mid + 1 else: right = mid - 1 return letters[left % len(letters)]"},{"question":"Implement a Balanced Binary Tree Checker **Objective**: Your task is to implement a function that checks whether a given binary tree is balanced. A balanced binary tree is defined as one in which the left and right subtrees of every node differ in height by no more than 1. **Function Signature**: ```python def is_balanced(root) -> bool: Determines if the binary tree rooted at `root` is balanced. Parameters: - root (TreeNode): The root node of the binary tree. Returns: - bool: True if the tree is balanced, False otherwise. ``` **Input**: - `root`: A `TreeNode` object representing the root of the binary tree. A `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` **Output**: - Return `True` if the tree is balanced, `False` otherwise. **Constraints**: - The number of nodes in the tree is in the range [0, 10^4]. - The value of each node is a unique integer within the range of [-10^4, 10^4]. **Performance Requirements**: - The function should run in linear time `O(N)` where `N` is the number of nodes in the binary tree. - The function should use `O(H)` space where `H` is the height of the binary tree. # Example: ```python # Example of a balanced binary tree # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(is_balanced(root)) # Output: True # Example of an unbalanced binary tree # 1 # / # 2 # / # 3 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) print(is_balanced(root)) # Output: False ``` **Hint**: Use a helper function to recursively determine both the depth of each subtree and whether it is balanced.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root) -> bool: Determines if the binary tree rooted at `root` is balanced. Parameters: - root (TreeNode): The root node of the binary tree. Returns: - bool: True if the tree is balanced, False otherwise. def check_balanced_and_height(node): if not node: return 0, True left_height, left_balanced = check_balanced_and_height(node.left) right_height, right_balanced = check_balanced_and_height(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return height, balanced _, balanced = check_balanced_and_height(root) return balanced"},{"question":"You are a developer tasked with solving resource allocation problems for an e-commerce platform. Given a list of items with specified values and weights, and a knapsack with a fixed weight capacity, you need to determine the maximum total value of items that can be put into the knapsack without exceeding the capacity. Task: Write a function `maximize_knapsack_value` that takes a list of tuples `(value, weight)` and an integer `capacity` representing the knapsack\'s capacity as input, and returns the maximum value that can be put into the knapsack. Function Signature: ```python def maximize_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: pass ``` Input: - `items`: A list of tuples, where each tuple consists of two integers `(value, weight)`, with 1 ≤ value, weight ≤ 1000. - `capacity`: An integer representing the knapsack\'s capacity, with 0 ≤ capacity ≤ 1000. Output: - Returns an integer representing the maximum value that can be achieved within the given capacity. Example: ```python >>> items = [(60, 5), (50, 3), (70, 4), (30, 2)] >>> capacity = 5 >>> maximize_knapsack_value(items, capacity) 80 >>> items = [(100, 3), (120, 2), (150, 4), (200, 5)] >>> capacity = 5 >>> maximize_knapsack_value(items, capacity) 220 ``` Constraints: - The function should run with a reasonable time complexity. - Handle edge cases where the knapsack capacity is zero or where no items are given. Please implement the function by focusing on efficiency and correctness.","solution":"from typing import List, Tuple def maximize_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): value, weight = items[i-1] if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"# Pattern and String Bijection Matching Objective Write a function that determines if a given string follows a given pattern, meaning there is a bijection between each distinct character in the pattern and a non-empty substring of the string. Use a backtracking algorithm to explore all possible mappings. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` Input - `pattern` (str): A string containing the pattern to be matched. Only contains lowercase letters. - `string` (str): A string to be validated against the pattern. Only contains lowercase letters. Output - `bool`: Returns `True` if the string follows the pattern, `False` otherwise. Constraints - You may assume both `pattern` and `string` contain only lowercase letters. - The function should handle cases where: - The length of the pattern is less than or equal to the length of the string. - Each character in the pattern maps to a non-empty substring of the string. Example ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False ``` Context Imagine you are building a parser for a lightweight templating language. Your goal is to verify if the input follows a predefined structure where specific placeholders (defined by a pattern) are replaced by actual data (substrings). This function helps ensure that the input text aligns to expected patterns before processing it further. Additional Notes Consider various edge cases such as: - Patterns that cannot possibly map due to length differences. - Substrings that should not overlap. - Potential performance issues on longer inputs.","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(p_idx: int, s_idx: int, mapping: dict, used: set) -> bool: # If both pattern and string are fully matched if p_idx == len(pattern) and s_idx == len(string): return True # If either of them is exhausted if p_idx == len(pattern) or s_idx == len(string): return False char = pattern[p_idx] if char in mapping: substr = mapping[char] if not string.startswith(substr, s_idx): return False return is_match(p_idx + 1, s_idx + len(substr), mapping, used) for end in range(s_idx + 1, len(string) + 1): substr = string[s_idx:end] if substr in used: continue mapping[char] = substr used.add(substr) if is_match(p_idx + 1, s_idx + len(substr), mapping, used): return True del mapping[char] used.remove(substr) return False return is_match(0, 0, {}, set())"},{"question":"You are tasked with implementing a function to rotate a singly linked list to the right by a specified number of positions. Given a singly linked list format and an integer `k`, the function should return a new list that represents the input list rotated to the right by `k` positions. If `k` is greater than the length of the list, handle it efficiently using the modulus operator. # Function Signature ```python # Class definition for a singly-linked list node. class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: ``` # Input * `head`: A ListNode, representing the head of the singly linked list. * `k`: A non-negative integer, representing the number of positions to rotate the list. # Output * The function should return a ListNode, which is the new head of the rotated list. # Constraints * The number of nodes in the list is in the range [0, 500]. * -100 <= ListNode.val <= 100 * 0 <= k <= 2*10^9 # Example ```python Given: 1 -> 2 -> 3 -> 4 -> 5 -> NULL, and k = 2, Returns: 4 -> 5 -> 1 -> 2 -> 3 -> NULL. Given: 0 -> 1 -> 2 -> NULL, and k = 4, Returns: 2 -> 0 -> 1 -> NULL. ``` # Additional Context Consider and appropriately handle the following scenarios: 1. The list is empty or contains only one node. 2. The rotation count `k` is zero or a multiple of the list length (leading to no actual change). # Hints * Think about converting the list into a cyclic structure temporarily to ease the rotation process. * Ensure you handle the original list structure correctly to avoid infinite loops.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head: return None # Find the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Adjust k to be within bounds of the list length k = k % length if k == 0: return head # Find the new tail: (length - k - 1)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # Find the new head: (length - k)th node new_head = new_tail.next # Break the list at the new tail and adjust the connections new_tail.next = None tail.next = head return new_head"},{"question":"Implement a function to remove duplicates from an array. Your function should be optimized to handle larger datasets efficiently. Use a data structure like a set to keep track of encountered elements and ensure the resulting list maintains the original order of first occurrences. # Function Signature `def remove_duplicates(array: list) -> list:` # Input * `array` (List[Any]): A list of elements which could be numbers, strings, or other hashable types. # Output * (List[Any]): A list with duplicate items removed, preserving the order of first appearances from the original list. # Constraints * The elements of the list are hashable. * The list can have up to 10^6 elements. # Example ```python >>> remove_duplicates([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]) [1, 2, 3, 4, \'hey\', \'hello\', True] >>> remove_duplicates([]) [] >>> remove_duplicates([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"] ``` # Performance Requirements * The algorithm should run in O(n) time complexity.","solution":"def remove_duplicates(array: list) -> list: Removes duplicates from the provided array while maintaining the order of first occurrences. Parameters: - array: List[Any], a list of hashable elements Returns: - List[Any]: A list with duplicates removed, maintaining the order of first occurrences. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Question: Implement and Optimize Comb Sort Given an unsorted list of numbers, implement the Comb Sort algorithm to sort the list in ascending order. Ensure your implementation addresses potential edge cases and optimize the function for both performance and readability. Additionally, compare the performance with Bubble Sort under similar conditions, and analyze when Comb Sort provides a significant advantage. Input * An unsorted list of integers `arr`. Output * Return the sorted list. Constraints * The input list can have up to `10^5` elements. * Each element in the list will be an integer within the range `[-10^9, 10^9]`. Performance Requirements * Aim for average-case time complexity close to O(N log N). * Ensure the implementation is in-place with space complexity O(1). Context Comb Sort is utilized in sorting large datasets where in-place sort is crucial, and auxiliary memory is limited. However, balancing the performance across varying distributions of the data is a challenge. Your task is to implement Comb Sort considering these constraints and test the performance difference compared to Bubble Sort. Instructions * Implement the function `comb_sort(arr)`. * Optimize the function for best performance and handle edge cases effectively. * Briefly, explain any optimizations or enhancements in comments. Example ```python def comb_sort(arr): # Your optimized comb sort implementation here pass # Sample Input arr = [5, 3, 1, 4, 2] # Sample Output print(comb_sort(arr)) # Should print: [1, 2, 3, 4, 5] ```","solution":"def comb_sort(arr): Function to sort an array using Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by Shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are given an integer ( n ). Your task is to write a more efficient version of the Fibonacci sequence generator. # Requirements: - Implement a function `fib_optimized(n: int) -> int` that returns the ( n )th Fibonacci number. - The function should have a time complexity of ( O(n) ) and a space complexity of ( O(1) ). # Constraints: - ( 0 leq n leq 10^5 ) - You should ensure that your implementation can handle the upper limit of ( n ) without running into performance issues or memory constraints. # Example: ```python assert fib_optimized(0) == 0 assert fib_optimized(1) == 1 assert fib_optimized(2) == 1 assert fib_optimized(10) == 55 assert fib_optimized(100) == 354224848179261915075 ``` # Hint: Think about using an iterative approach and optimize the space by utilizing a constant amount of variable storage. Avoid unnecessary data structures like arrays or lists for storing intermediate Fibonacci numbers.","solution":"def fib_optimized(n: int) -> int: Returns the nth Fibonacci number using a space-optimized iterative approach. Time Complexity: O(n) Space Complexity: O(1) if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# FizzBuzz Problem with Additional Constraints Design a function that returns a list containing the numbers from 1 to `n` (inclusive), where `n` is the parameter value, replacing certain values under specific conditions: 1. If the value is a multiple of 3, replace it with \\"Fizz\\". 2. If the value is a multiple of 5, replace it with \\"Buzz\\". 3. If the value is a multiple of both 3 and 5, replace it with \\"FizzBuzz\\". However, there are additional constraints to handle edge cases effectively: - If `n` is less than 1, raise a `ValueError` with the message \\"n cannot be less than one\\". - If `n` is `None`, raise a `TypeError` with the message \\"n cannot be None\\". Function Signature ```python def custom_fizzbuzz(n: int) -> List[Union[int, str]]: pass ``` Input - `n` (int): the number up to which to generate the sequence. `1 <= n <= 10^4`. Output - List containing numbers from 1 to `n` with specific values replaced as described. Example ```python custom_fizzbuzz(15) ``` # Expected Output: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` Constraints - The function should handle invalid inputs as specified. - Aim for an efficient solution in terms of both time and space.","solution":"from typing import List, Union def custom_fizzbuzz(n: int) -> List[Union[int, str]]: Generates a list of numbers from 1 to n with multiples of 3 replaced by \'Fizz\', multiples of 5 replaced by \'Buzz\', and multiples of both replaced by \'FizzBuzz\'. if n is None: raise TypeError(\\"n cannot be None\\") if n < 1: raise ValueError(\\"n cannot be less than one\\") result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Segment Tree Implementation and Application You have been tasked to implement a Segment Tree that supports efficient range query and update operations. The Segment Tree should be flexible to work with any commutative function. # Objective Your goal is to: 1. Implement the Segment Tree class with the following methods: - `__init__(self, arr, function)`: Initialize the segment tree with the given array and function. - `build_tree(self)`: Construct the segment tree. - `update(self, p, v)`: Update the element at index `p` to value `v`. - `query(self, l, r)`: Query the segment tree for the range [l, r]. 2. Ensure the implementation handles typical edge cases and performs efficiently within the given constraints. # Constraints - The elements in the array can be integers, floats, or tuples of numbers. - The array size `N` will be at most `10^5`. - The segment tree should handle both `update` and `query` operations in log(N) time. # Input and Output Formats - The `query(l, r)` method should return the result of applying the given function to the range [l, r]. - The `update(p, v)` method should ensure the element at index `p` is updated to `v` and all relevant parts of the tree are recalculated. # Example ```python # Example usage of SegmentTree mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Expected output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Expected output: 6 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Expected output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Expected output: 52 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Expected output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Expected output: (4, 10) ``` **Deliverable**: Implement the `SegmentTree` class in Python as described above.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr[:] self.function = function self.tree = [None] * (2 * self.n) self.build_tree() def build_tree(self): # Build the tree from the original array for i in range(self.n): self.tree[self.n + i] = self.arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, p, v): # Update the value at index p to v pos = self.n + p self.tree[pos] = v while pos > 1: pos >>= 1 self.tree[pos] = self.function(self.tree[pos << 1], self.tree[pos << 1 | 1]) def query(self, l, r): # Query from index l to r (inclusive) res = None l += self.n r += self.n + 1 while l < r: if l & 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l >>= 1 r >>= 1 return res"},{"question":"# Question: Implement and Enhance Selection Sort Context Selection sort is a simple comparison-based sorting algorithm that divides the input list into two parts: a sorted sublist of items built up from left to right and a sublist of the remaining unsorted items. The algorithm works by repeatedly selecting the smallest (or largest, depending on the sorting order) element from the unsorted sublist, exchanging (swapping) it with the first unsorted element, and moving the sublist boundaries one element to the right. You are tasked with implementing the selection sort algorithm. Moreover, your implementation should include certain optimizations and additional functionalities. Task Description 1. Implement the selection sort algorithm for sorting a list of integers in ascending order. 2. Optimize your code to minimize the number of swaps performed. 3. Integrate a simulation option that prints the state of the list after every iteration, similar to the provided code snippet. 4. Add validation to handle and return appropriate responses for edge cases such as empty arrays or arrays with a single element. Function Signature You need to implement the following function: ```python def enhanced_selection_sort(arr, simulation=False): Enhanced Selection Sort with minimised swaps and simulation option. Args: arr (List[int]): List of integers to be sorted. simulation (bool): If set to True, prints the list after each iteration. Returns: List[int]: The sorted list. pass ``` Input - `arr`: A list of integers (0 <= len(arr) <= 10^5, -10^6 <= arr[i] <= 10^6). - `simulation`: A boolean flag, if set to `True`, the internal state of the list should be printed after each outer loop iteration. Output - A list of integers sorted in ascending order. Constraints - Optimize the algorithm to minimize the total number of swaps performed. - Ensure the function can handle large lists efficiently (within the given constraints). Example ```python >>> enhanced_selection_sort([64, 25, 12, 22, 11], simulation=True) iteration 0 : 11 25 12 22 64 iteration 1 : 11 12 25 22 64 iteration 2 : 11 12 22 25 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 [11, 12, 22, 25, 64] ``` Note: In the example, `iteration 3` and `iteration 4` result in the same list since it is already sorted.","solution":"def enhanced_selection_sort(arr, simulation=False): Enhanced Selection Sort with minimised swaps and simulation option. Args: arr (list of int): List of integers to be sorted. simulation (bool): If set to True, prints the list after each iteration. Returns: list of int: The sorted list. n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Problem Description Write a function `reverse_string(s: str) -> str` that reverses a given string using an efficient algorithm. Your implementation should be efficient in terms of both time and space complexity. # Input Format * A single string `s` where `1 <= len(s) <= 10^4`. # Output Format * A single string which is the reversed version of the input string `s`. # Constraints * The function should handle strings of length up to 10^4 efficiently. * Do not use any built-in string manipulation functions like `reversed()` or slicing. # Example Input: ``` \\"hello\\" ``` Output: ``` \\"olleh\\" ``` # Notes * Consider edge cases such as an empty string or single-character strings. * Your implementation should be both clear and maintainable.","solution":"def reverse_string(s: str) -> str: Reverses the given string using an efficient algorithm. :param s: Input string to be reversed. :return: Reversed string. string_list = list(s) start = 0 end = len(string_list) - 1 while start < end: string_list[start], string_list[end] = string_list[end], string_list[start] start += 1 end -= 1 return \'\'.join(string_list)"},{"question":"You are tasked with writing a function to compute the binomial coefficient using dynamic programming rather than recursion to avoid potential stack overflow issues when handling large values of `n` and `k`. This coefficient represents the number of ways to choose `k` elements from a set of `n` elements without caring about the order. # Function Signature ```python def dynamic_binomial_coefficient(n, k): Calculates the binomial coefficient C(n, k) using dynamic programming. Parameters: n (int): Number of elements in the set (n >= 0) k (int): Number of elements to choose (0 <= k <= n) Returns: int: The binomial coefficient C(n, k) Raises: ValueError: If the inputs do not satisfy the constraints 0 <= k <= n. pass ``` # Input and Output - **Input**: - `n` (int): A non-negative integer representing the total number of elements. - `k` (int): A non-negative integer representing the number of elements to choose, where (0 leq k leq n). - **Output**: - An integer representing the binomial coefficient C(n, k). # Constraints - ( 0 leq k leq n ) - ( n ), ( k ) are non-negative integers. # Example ```python print(dynamic_binomial_coefficient(5, 0)) # Output: 1 print(dynamic_binomial_coefficient(8, 2)) # Output: 28 print(dynamic_binomial_coefficient(500, 300)) # Output: Very large integer ``` # Performance Requirements - The solution should handle large inputs up to n=500 and k=300 efficiently. # Scenario Given the need to frequently compute combinations in various combinatorial problems, your task is to optimize the computation performance through the use of dynamic programming to ensure that the solution is both efficient and scalable, even for large inputs. # Instructions 1. Implement the function `dynamic_binomial_coefficient` as specified. 2. Ensure that your solution leverages dynamic programming to minimize repetitive calculations. 3. Handle any edge cases appropriately.","solution":"def dynamic_binomial_coefficient(n, k): Calculates the binomial coefficient C(n, k) using dynamic programming. Parameters: n (int): Number of elements in the set (n >= 0) k (int): Number of elements to choose (0 <= k <= n) Returns: int: The binomial coefficient C(n, k) Raises: ValueError: If the inputs do not satisfy the constraints 0 <= k <= n. if k < 0 or k > n: raise ValueError(\\"Invalid values for n and k. Ensure that 0 <= k <= n.\\") # Create a 2D array to store the value of binomial coefficients C = [[0 for _ in range(k+1)] for _ in range(n+1)] # Calculate value of Binomial Coefficient in bottom up manner for i in range(n+1): for j in range(min(i, k)+1): # Base Cases if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k]"},{"question":"Bit Manipulation Mastery Context: Imagine you are working on a security module that deals with encryption keys. To optimize the storage and processing of these keys, it is crucial to manipulate individual bits effectively. You will be implementing a utility that performs a series of bit-level operations on given integers. Task: Implement a class `BitManipulator` that provides the following functionalities: 1. **get_bit(num, i)**: Returns the value of the bit at index `i` in the binary representation of `num`. 2. **set_bit(num, i)**: Sets the bit at index `i` in the binary representation of `num` to 1. 3. **clear_bit(num, i)**: Clears the bit at index `i` in the binary representation of `num` (sets it to 0). 4. **update_bit(num, i, bit)**: Sets the bit at index `i` in the binary representation of `num` to the given `bit` value (either 0 or 1). Input/Output Specifications: - **get_bit(num, i)** - **Input**: - `num` (integer): The number whose bit is to be gotten. - `i` (integer): The index of the bit. - **Output**: - Returns 1 or 0 depending on the bit value at index `i`. - **set_bit(num, i)** - **Input**: - `num` (integer): The number whose bit is to be set. - `i` (integer): The index of the bit to set. - **Output**: - Returns the new number with the bit at index `i` set to 1. - **clear_bit(num, i)** - **Input**: - `num` (integer): The number whose bit is to be cleared. - `i` (integer): The index of the bit to clear. - **Output**: - Returns the new number with the bit at index `i` cleared (set to 0). - **update_bit(num, i, bit)** - **Input**: - `num` (integer): The number whose bit is to be updated. - `i` (integer): The index of the bit to update. - `bit` (integer): The new bit value (either 0 or 1). - **Output**: - Returns the new number with the bit at index `i` updated to the given bit value. Constraints: - The bit index `i` is zero-based and should be a non-negative integer. - Assume `num` fits within the range of standard integer representation in Python. Example: ```python bm = BitManipulator() print(bm.get_bit(10, 1)) # Output: 1 (binary 1010, second bit from the right is 1) print(bm.set_bit(10, 1)) # Output: 10 (binary 1010, setting second bit to 1 does not change it) print(bm.clear_bit(10, 1)) # Output: 8 (binary 1000, clearing the second bit sets it to 0) print(bm.update_bit(10, 1, 0)) # Output: 8 (binary 1000, updating the second bit to 0) ``` Implement the `BitManipulator` class in Python using the specified methods.","solution":"class BitManipulator: @staticmethod def get_bit(num, i): Returns the value of the bit at index \'i\' in the binary representation of \'num\'. return (num >> i) & 1 @staticmethod def set_bit(num, i): Sets the bit at index \'i\' in the binary representation of \'num\' to 1. return num | (1 << i) @staticmethod def clear_bit(num, i): Clears the bit at index \'i\' in the binary representation of \'num\' (sets it to 0). return num & ~(1 << i) @staticmethod def update_bit(num, i, bit): Sets the bit at index \'i\' in the binary representation of \'num\' to the given \'bit\' value (either 0 or 1). mask = ~(1 << i) return (num & mask) | ((bit & 1) << i)"},{"question":"A robot starts at the origin (0, 0) on a plane and can move up, down, left, or right. You are given a sequence of its moves represented by a string. The moves are \'U\' for up, \'D\' for down, \'L\' for left, and \'R\' for right. Write a function `does_robot_return(moves: str) -> bool` that determines whether the robot returns to the origin after executing all its moves. # Input: - A string `moves` which represents the sequence of moves (1 <= len(moves) <= 10^4). # Output: - Return `True` if the robot returns to the origin after all moves, otherwise return `False`. # Constraints: - Only valid characters \'U\', \'D\', \'L\', \'R\' will be present in the input string. # Examples: ```python example_1 = \\"UD\\" print(does_robot_return(example_1)) # Expected output: True example_2 = \\"LL\\" print(does_robot_return(example_2)) # Expected output: False example_3 = \\"UDLR\\" print(does_robot_return(example_3)) # Expected output: True example_4 = \\"\\" print(does_robot_return(example_4)) # Expected output: True example_5 = \\"UUDDLLRR\\" print(does_robot_return(example_5)) # Expected output: True ``` # Explanation: 1. The robot\'s moves are counted and balanced directionally. For example, if moves up (\'U\') are equal to moves down (\'D\') and moves left (\'L\') are equal to moves right (\'R\'), the robot returns to the starting point, else it does not. 2. For example, after move sequence \\"UDLR\\" robot returns back to (0,0).","solution":"def does_robot_return(moves: str) -> bool: Determines whether the robot returns to the origin after executing all its moves. Parameters: moves (str): A string representing the sequence of moves. Returns: bool: True if the robot returns to the origin, otherwise False. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Longest Common Subsequence Problem # Scenario You are working in a bioinformatics team, and you are tasked with comparing DNA sequences to find common ancestries. Given two DNA sequences, you need to find the length of the longest subsequence that is common to both sequences. # Problem Statement Write a Python function `longest_common_subsequence(dna_1: str, dna_2: str) -> int` that accepts two strings `dna_1` and `dna_2`, representing two DNA sequences containing lowercase alpha characters only, and returns the length of their longest common subsequence. # Input * `dna_1` (1 <= len(dna_1) <= 1000): A string containing lowercase English alphabets. * `dna_2` (1 <= len(dna_2) <= 1000): A string containing lowercase English alphabets. # Output * An integer representing the length of the longest common subsequence. # Constraints * Time Complexity: Solution should run in O(M * N) time where M and N are the lengths of `dna_1` and `dna_2` respectively. * Space Complexity: Solution should use at most O(M * N) auxiliary space. # Example Example 1 ```python Input: dna_1 = \'abcdgh\' dna_2 = \'aedfhr\' Output: 3 Explanation: The longest subsequence common to both strings is \\"adh\\". ``` Example 2 ```python Input: dna_1 = \'abc\' dna_2 = \'abc\' Output: 3 Explanation: The longest subsequence common to both strings is \\"abc\\". ``` Example 3 ```python Input: dna_1 = \'abc\' dna_2 = \'def\' Output: 0 Explanation: There is no common subsequence between the two strings. ``` # Implementation Skeleton ```python def longest_common_subsequence(dna_1: str, dna_2: str) -> int: # Your implementation here pass # Do not forget to test your function with the provided examples and additional test cases. ```","solution":"def longest_common_subsequence(dna_1: str, dna_2: str) -> int: Returns the length of the longest common subsequence of two DNA sequences. m = len(dna_1) n = len(dna_2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array in bottom-up manner. for i in range(1, m + 1): for j in range(1, n + 1): if dna_1[i - 1] == dna_2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a stack that stores integer values. Your task is to write a function `enhanced_stutter` that takes a stack as a parameter and replaces every value in the stack with three occurrences of that value. You need to provide two implementations of this function: 1. `first_enhanced_stutter`: Use an auxiliary stack to help achieve the goal. 2. `second_enhanced_stutter`: Use an auxiliary queue to help achieve the goal. # Input: - A stack of integers represented as a list, where the last element of the list is considered the top of the stack. # Output: - The modified stack where each element appears three times consecutively. # Example: If the stack is: `[3, 7, 1, 14, 9]` After calling the function, the stack should be: `[3, 3, 3, 7, 7, 7, 1, 1, 1, 14, 14, 14, 9, 9, 9]` # Constraints: - Do not use any built-in functions or libraries that provide direct functionalities like doubling or repeating elements, except for basic stack and queue operations. - Assume the stack only contains integers and has at most 10^3 elements. # Function Signatures: ```python def first_enhanced_stutter(stack: list) -> list: pass def second_enhanced_stutter(stack: list) -> list: pass ``` # Additional Requirements: - Ensure your function handles edge cases properly. - Aim for efficient memory usage within the constraints provided. - Write clean, readable, and well-documented code.","solution":"def first_enhanced_stutter(stack: list) -> list: Uses an auxiliary stack to replace every value in the stack with three occurrences of that value. auxiliary_stack = [] while stack: value = stack.pop() # Push the value three times onto the auxiliary stack for _ in range(3): auxiliary_stack.append(value) while auxiliary_stack: # Return values back to the original stack stack.append(auxiliary_stack.pop()) return stack def second_enhanced_stutter(stack: list) -> list: Uses an auxiliary queue to replace every value in the stack with three occurrences of that value. from collections import deque queue = deque() while stack: value = stack.pop() # Enqueue the value three times for _ in range(3): queue.appendleft(value) while queue: # Return values back to the original stack stack.append(queue.popleft()) return stack"},{"question":"**Problem Statement:** You have been provided with two variations of the Heap Sort algorithm: one using a Max Heap and one using a Min Heap. Each variation sorts an array in ascending order. Your task is to implement a function that merges these two sorted arrays into a single sorted array. # Function Signature ```python def merge_sorted_arrays(max_heap_sorted: List[int], min_heap_sorted: List[int]) -> List[int]: pass ``` # Input - `max_heap_sorted`: A list of integers sorted in ascending order using Max Heap Sort. - `min_heap_sorted`: A list of integers sorted in ascending order using Min Heap Sort. # Output - Returns a list of integers which is a merged and sorted array of the input arrays. # Constraints - Both input lists, `max_heap_sorted` and `min_heap_sorted`, contain at least one integer. - The integers in both input lists are within the range of -10^9 to 10^9. - The combined length of both input lists does not exceed 10^5. # Performance Requirements - The function should run in O(n) where n is the combined length of both input arrays. # Context Maria is working on a project that involves sorting large datasets. She leverages different algorithms for different parts of her datasets to optimize performance. She\'s already used Max Heap Sort and Min Heap Sort for two sub-arrays. Now she seeks your help to efficiently merge these sorted arrays to form a single sorted array in linear time. # Example ```python # Example 1 max_heap_sorted = [1, 3, 5, 7] min_heap_sorted = [2, 4, 6, 8] print(merge_sorted_arrays(max_heap_sorted, min_heap_sorted)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 max_heap_sorted = [-10, -3, 0, 9] min_heap_sorted = [-8, 2, 4, 7, 11] print(merge_sorted_arrays(max_heap_sorted, min_heap_sorted)) # Output: [-10, -8, -3, 0, 2, 4, 7, 9, 11] ``` # Solution The solution to this problem involves an approach similar to the merge step in the Merge Sort algorithm, which ensures that the merging process is performed in linear time.","solution":"from typing import List def merge_sorted_arrays(max_heap_sorted: List[int], min_heap_sorted: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. :param max_heap_sorted: A list of integers sorted in ascending order using Max Heap Sort. :param min_heap_sorted: A list of integers sorted in ascending order using Min Heap Sort. :return: A merged and sorted list of integers. merged_array = [] i, j = 0, 0 while i < len(max_heap_sorted) and j < len(min_heap_sorted): if max_heap_sorted[i] <= min_heap_sorted[j]: merged_array.append(max_heap_sorted[i]) i += 1 else: merged_array.append(min_heap_sorted[j]) j += 1 # Append any remaining elements from either array while i < len(max_heap_sorted): merged_array.append(max_heap_sorted[i]) i += 1 while j < len(min_heap_sorted): merged_array.append(min_heap_sorted[j]) j += 1 return merged_array"},{"question":"Scenario You are working with repetitive patterns in genetic sequences and need to determine how many times to repeat a base genetic sequence so that it could potentially contain a target subsequence. This problem will help determine how effective a rebuilding strategy is by checking minimal recurrence requirements. Problem Statement You need to implement a function called `min_repetitions(base, target)` that, given two strings `base` and `target`, returns the minimum number of times the string `base` must be repeated so that `target` is a substring of it. If it\'s not possible, return -1. Function Signature: ```python def min_repetitions(base: str, target: str) -> int: pass ``` Input: * `base` (string): The base string to be repeated. (1 <= len(base) <= 10000) * `target` (string): The target string which should be a substring in the repeated base string. (1 <= len(target) <= 10000) Output: * Returns an integer representing the minimal number of repetitions. If `target` cannot be a substring in any number of repetitions of `base`, return -1. Example: ```python print(min_repetitions(\\"abcd\\", \\"cdabcdab\\")) # Output: 3 print(min_repetitions(\\"abcd\\", \\"xyz\\")) # Output: -1 ``` Constraints: * The length of both `base` and `target` will be between 1 and 10000 inclusive. * You must consider and handle edge cases such as large input sizes optimally. Performance Requirements: * Optimize the implementation to avoid excessive computations. * Ensure the solution handles maximal constraints within a reasonable time frame.","solution":"def min_repetitions(base: str, target: str) -> int: Returns the minimum number of times the string `base` must be repeated so that `target` is a substring of it. If it\'s not possible, return -1. m, n = len(base), len(target) # The maximum times we need to repeat base is (n // m) + 2 # This handles cases where target starts at the end of base and continues into the next repetition. max_repeats = (n // m) + 2 # Create the repeated string and check if target is in the formed string. repeated_base = base * max_repeats # Check minimum repetitions required for i in range(1, max_repeats + 1): if target in repeated_base[:m * i]: return i return -1"},{"question":"Climbing Stairs Problem with Extensions You are climbing a staircase that takes `steps` number of steps to reach to the top. Each time you can either climb 1 or 2 steps. You\'ll return the number of distinct ways you can climb to the top. Additionally, we want to extend the problem: What if you can also climb 3 steps at a time? Write a function `climb_stairs_extended` to accommodate this case. Function Signature ```python def climb_stairs_extended(steps: int) -> int: Calculate the number of distinct ways to reach the top of a staircase with \'steps\' steps where you can take 1, 2, or 3 steps at a time. :param steps: The number of steps to reach the top (positive integer) :return: The number of distinct ways to reach the top ``` Input and Output * **Input**: An integer `steps`, where `steps` is a positive integer. * **Output**: An integer representing the total number of distinct ways to climb the staircase. Constraints * The input integer `steps` will be a positive integer (1 ≤ steps ≤ 10^6). Example Example 1: ```plaintext Input: steps = 3 Output: 4 Explanation: There are four distinct ways to climb to the top (1+1+1, 1+2, 2+1, 3). ``` Example 2: ```plaintext Input: steps = 5 Output: 13 Explanation: There are thirteen distinct ways to climb to the top. ``` Ensure your implementation handles large values of `steps` efficiently in terms of both time and space complexity. You may assume the input is valid, as described in the constraints.","solution":"def climb_stairs_extended(steps: int) -> int: Calculate the number of distinct ways to reach the top of a staircase with \'steps\' steps where you can take 1, 2, or 3 steps at a time. :param steps: The number of steps to reach the top (positive integer) :return: The number of distinct ways to reach the top if steps == 1: return 1 elif steps == 2: return 2 elif steps == 3: return 4 # Initialize the base cases dp = [0] * (steps + 1) dp[1], dp[2], dp[3] = 1, 2, 4 # Fill the dp array for all steps from 4 to \'steps\' for i in range(4, steps + 1): dp[i] = dp[i-1] + dp[i-2] + dp[i-3] return dp[steps]"},{"question":"# Context You are working on developing a library that will help manage a large collection of numbers efficiently. The core data structure you\'ll use is a Binary Search Tree (BST), which allows for fast lookups, insertions, and deletions. # Question Implement a function `delete(self, data)` in the given BST class to remove a node with a specified value from the tree. Additionally, modify the traversal methods to store and return a list of node values instead of printing them. # Input and Output * **delete(self, data)**: This method should remove the node with the given value if it exists in the tree. * **traversal methods (preorder, inorder, postorder)**: Modify these methods to return a list of values obtained from the traversal. You can use the provided BST implementation as a base and focus on adding the `delete()` method and modifying traversal methods. # Constraints * Assume all input values are integers and unique. * The tree can have a maximum of 100,000 nodes. * The number ‘data’ passed to delete function exists in the tree. # Requirements 1. Implement the `delete` method to remove a node from the BST. 2. Modify the `preorder`, `inorder`, and `postorder` traversal methods to return results instead of printing them. ```python class BST(object): # Previous methods: __init__, insert, search, recur_insert, recur_search remain as given def delete(self, data): # Implement node deletion logic def preorder(self, root): # Implement modified preorder traversal def inorder(self, root): # Implement modified inorder traversal def postorder(self, root): # Implement modified postorder traversal ``` # Example ```python # Example to test the functionality tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) print(tree.inorder(tree.get_root())) # [4, 6, 9, 10, 12, 15, 24] tree.delete(10) print(tree.inorder(tree.get_root())) # [4, 6, 9, 12, 15, 24] ``` Ensure your implementation is efficient and can handle the constraints specified.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def get_root(self): return self.root def insert(self, key): if self.root is None: self.root = Node(key) else: self._recur_insert(self.root, key) def _recur_insert(self, root, key): if root is None: return Node(key) elif key < root.val: root.left = self._recur_insert(root.left, key) else: root.right = self._recur_insert(root.right, key) return root def delete(self, root, key): if root is None: return root if key < root.val: root.left = self.delete(root.left, key) elif key > root.val: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left root.val = self.min_value(root.right) root.right = self.delete(root.right, root.val) return root def min_value(self, node): current = node while current.left is not None: current = current.left return current.val def preorder(self, root): result = [] self._preorder_helper(root, result) return result def _preorder_helper(self, root, result): if root: result.append(root.val) self._preorder_helper(root.left, result) self._preorder_helper(root.right, result) def inorder(self, root): result = [] self._inorder_helper(root, result) return result def _inorder_helper(self, root, result): if root: self._inorder_helper(root.left, result) result.append(root.val) self._inorder_helper(root.right, result) def postorder(self, root): result = [] self._postorder_helper(root, result) return result def _postorder_helper(self, root, result): if root: self._postorder_helper(root.left, result) self._postorder_helper(root.right, result) result.append(root.val)"},{"question":"You are required to implement a function that takes a list of integers and a number `N`. The objective of the function is to return a new list such that each number in the original list appears at most `N` times while preserving the original order of elements. Your implementation should ensure an efficient performance for larger lists by optimizing the counting mechanism. # Function Signature ```python def limited_frequency_list(lst: List[int], n: int) -> List[int]: pass ``` # Input - `lst`: A list of integers (1 ≤ len(lst) ≤ 10^5). - `n`: An integer (1 ≤ n ≤ len(lst)) representing the maximum allowed occurrences of each number in the returned list. # Output - A list of integers meeting the described constraints. # Constraints - Order of elements in the list must be preserved. - Each element in the output list should not exceed `N` occurrences. - Time complexity should be O(n) and space complexity should be O(n). # Example ```python limited_frequency_list([1, 2, 3, 1, 2, 1, 2, 3], 2) # Returns: [1, 2, 3, 1, 2, 3] limited_frequency_list([20, 37, 20, 21], 1) # Returns: [20, 37, 21] limited_frequency_list([], 2) # Returns: [] ``` # Requirements - Implement the function using an efficient method, preferably using hash tables/dictionaries for counting. - Avoid nested loops that result in O(n^2) time complexity. - Ensure the function handles various edge cases such as an empty list or a list with all unique elements appropriately.","solution":"from typing import List def limited_frequency_list(lst: List[int], n: int) -> List[int]: Returns a new list such that each number in the original list appears at most `N` times while preserving the original order of elements. count = {} result = [] for number in lst: if number not in count: count[number] = 0 if count[number] < n: result.append(number) count[number] += 1 return result"},{"question":"You are working on a string manipulation task and need to determine if two strings are rotations of each other. More specifically, you need to write a function that verifies if one string can be formed by rotating another string any number of times. Function Signature ```python def is_rotated_string(s1: str, s2: str) -> bool: ``` Input Parameters - `s1`: A string representing the original string that we are checking against. - `s2`: A string representing the potential rotated version of `s1`. Output - A boolean value: `True` if `s2` is a rotated version of `s1`, otherwise `False`. Constraints - All characters are lowercase English letters (a-z). - Both strings will have a length ranging from 0 to 1000. Scenarios and Context Imagine an automated surveillance camera system where a camera records entry and exit logs as single strings. To check if the sequence of logs at the start of the day can explain the sequence of logs at the end of the day, you have to verify if one is just a rotated version of the other. Examples 1. `is_rotated_string(\\"hello\\", \\"ohell\\")` should return `True`. Explanation: The string \\"ohell\\" is a rotation of \\"hello\\" rotated right by 1 position. 2. `is_rotated_string(\\"abc\\", \\"bca\\")` should return `True`. Explanation: The string \\"bca\\" is a rotation of \\"abc\\" rotated right by 2 positions. 3. `is_rotated_string(\\"abc\\", \\"cab\\")` should return `True`. Explanation: The string \\"cab\\" is a rotation of \\"abc\\" rotated right by 1 position. 4. `is_rotated_string(\\"hello\\", \\"lohel\\")` should return `True`. Explanation: The string \\"lohel\\" is a rotation of \\"hello\\" rotated left by 3 positions. 5. `is_rotated_string(\\"hello\\", \\"helo\\")` should return `False`. Explanation: The string lengths are different, hence cannot be rotations. Implement the function to verify string rotations effectively.","solution":"def is_rotated_string(s1: str, s2: str) -> bool: Determines if one string is a rotation of another string. if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"Maximize Job Scheduling Profit **Scenario**: You\'ve been hired to optimize the profit for a media company that needs to schedule a series of non-conflicting advertisements within a given period. Each advertisement slot has a start time, end time, and an associated profit. Your task is to determine the maximum profit that can be obtained by scheduling these advertisements optimally. **Function Specification**: Implement a function `maximize_profit(jobs)` that takes a list of jobs. Each job is represented as a tuple `(start, finish, profit)`. The function should return the maximum profit achievable. **Input**: * `jobs`: A list of tuples where each tuple contains three integers `start`, `finish`, and `profit` representing the start time, end time, and profit of a job, respectively. **Output**: * An integer representing the maximum profit achievable. **Example**: ```python jobs = [(1, 2, 50), (3, 5, 20), (6, 19, 100), (2, 100, 200)] print(maximize_profit(jobs)) # Output: 250 ``` **Constraints**: * `1 <= len(jobs) <= 10^5` * `1 <= start < finish <= 10^9` * `1 <= profit <= 10^4` # Guidelines: * First, sort the jobs based on the finish time. * Use binary search to find the latest non-conflicting job for each job. * Employ dynamic programming to build up the solution for maximum profit by considering both including and excluding each job. **Notes**: * Pay attention to edge cases such as jobs with overlapping periods and ensure the solution efficiently handles large inputs. Good luck!","solution":"from bisect import bisect_right def maximize_profit(jobs): Returns the maximum profit that can be obtained by scheduling non-conflicting jobs. # Sort jobs by their finish times jobs.sort(key=lambda x: x[1]) # Extract the finish times for binary search usage finish_times = [job[1] for job in jobs] # Initialize dp array where dp[i] represents the maximum profit obtainable by the first i jobs n = len(jobs) dp = [0] * (n + 1) for i in range(1, n + 1): # Get current job\'s details start, finish, profit = jobs[i - 1] # Find the latest job that doesn\'t conflict with the current job # Use binary search for efficiency index = bisect_right(finish_times, start) - 1 # Calculate current profit including current job current_profit = profit + (dp[index + 1] if index != -1 else 0) # Update dp array with the maximum of including or excluding the current job dp[i] = max(dp[i - 1], current_profit) return dp[n]"},{"question":"Implement a Custom Exchange Sort **Context**: You are developing a small module for an educational tool that demonstrates various sorting algorithms. One of the algorithms to be included is the Exchange Sort. You are tasked with writing an optimized and robust version that efficiently handles various edge cases. **Task**: Implement the `custom_exchange_sort` function which sorts an input list of integers in non-decreasing order. The function should prioritize simplicity and handle edge cases effectively. **Function Signature**: ```python def custom_exchange_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr` (List[int]): A list of integers. **Output**: * Returns a new list of integers sorted in non-decreasing order. **Constraints**: * The input list can be empty. * Elements are all integers. * The function must handle an array of any size up to 10,000 elements, but it\'s expected to perform well on small to medium-sized datasets. **Performance Requirements**: Although the Exchange Sort algorithm has a time complexity of O(n^2), aim for efficient performance within this constraint. Optimize the function to handle small arrays quickly and address the mentioned edge cases intelligently. **Example**: ```python assert custom_exchange_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert custom_exchange_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert custom_exchange_sort([]) == [] assert custom_exchange_sort([1]) == [1] assert custom_exchange_sort([-1, 2, -5, 0]) == [-5, -1, 0, 2] ``` **Note**: Focus on code readability and correctness. Consider error checking, especially with edge cases. Document your code effectively for future learners who might study it.","solution":"from typing import List def custom_exchange_sort(arr: List[int]) -> List[int]: Sorts the input list of integers in non-decreasing order using the Exchange Sort algorithm. :param arr: List[int] - A list of integers to be sorted :return: List[int] - The sorted list of integers in non-decreasing order if not arr: return [] n = len(arr) sorted_arr = arr.copy() # Create a copy to avoid mutating the input list for i in range(n): for j in range(i + 1, n): if sorted_arr[i] > sorted_arr[j]: # Swap the elements sorted_arr[i], sorted_arr[j] = sorted_arr[j], sorted_arr[i] return sorted_arr"},{"question":"# Task: Remove Duplicates from a Linked List Given a singly linked list, write a function to remove all duplicate elements from the list. You are required to provide two solutions: 1. **Using Additional Space (Hash Set)**: - Implement the function `remove_dups(head: Node) -> None` that removes duplicates using a hash set. - **Constraints**: Optimize for time complexity. 2. **Without Using Additional Space**: - Implement the function `remove_dups_without_set(head: Node) -> None` that removes duplicates without using any additional data structures. - **Constraints**: Optimize for space complexity. Input: - A reference to the head of a singly linked list where each node contains an alphanumeric character as its value. Output: - Both functions should modify the list in place and not return anything. Constraints: - Consider edge cases such as an empty list or a list with only one element. - The list can contain up to 10^4 nodes. Example: ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head: string += head.val + \\" -> \\" head = head.next string = string.strip(\\" -> \\") print(string) # Constructing the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates using the hash set method remove_dups(a1) print_linked_list(a1) # Expected Output: A -> B -> C -> D -> F -> G # Remove duplicates without additional space remove_dups_without_set(a1) print_linked_list(a1) # Expected Output: A -> B -> C -> D -> F -> G ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): Removes duplicates from a linked list using a hash set. if not head: return node_values = set() current = head node_values.add(current.val) while current.next: if current.next.val in node_values: current.next = current.next.next else: node_values.add(current.next.val) current = current.next def remove_dups_without_set(head): Removes duplicates from a linked list without using extra space. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head): result = [] while head: result.append(head.val) head = head.next return \\" -> \\".join(result)"},{"question":"# Problem: Compute the Skyline A city\'s skyline is the outer contour of the silhouette formed by a collection of buildings when viewed from a distance. You are provided with the locations and heights of various buildings in a cityscape and asked to compute the skyline formed by these buildings collectively. Input: The input is a list of buildings, where each building is represented by a triplet of integers ([L_i, R_i, H_i]): - (L_i): the x-coordinate of the left edge of the (i^{th}) building. - (R_i): the x-coordinate of the right edge of the (i^{th}) building. - (H_i): the height of the (i^{th}) building. Constraints: - (0 leq L_i, R_i leq 2^{31}-1) - (0 < H_i leq 2^{31}-1) - (R_i - L_i > 0) - The number of buildings is between (0) and (10,000). Output: The output should be a list of key points that collectively form the skyline. Each key point is represented as `[x, y]` where `x` is the x-coordinate of the start of the horizontal line segment, and `y` is its height. The key points in the output should describe the skyline, structured as follows: - Sorted by the x-coordinate. - No consecutive horizontal lines of equal height allowed; they must be merged. Constraints: - The output list must be sorted by the x position. - Buildings are perfect rectangles grounded at height `0`. Example: ```python Input: [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] Output: [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` Function Signature: ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` Develop the `get_skyline` function to compute the skyline for given buildings.","solution":"from typing import List import heapq def get_skyline(buildings: List[List[int]]) -> List[List[int]]: # Pair the locations with the corresponding start and end points events = [] for L, R, H in buildings: events.append((L, -H, R)) events.append((R, 0, 0)) # Sort the events by x coordinate events.sort() result = [[0, 0]] # Initialize the result with a dummy live_buildings = [(0, float(\'inf\'))] # Initialize a live buildings heap with a dummy for x, negH, R in events: while live_buildings[0][1] <= x: heapq.heappop(live_buildings) if negH: heapq.heappush(live_buildings, (negH, R)) max_height = -live_buildings[0][0] if result[-1][1] != max_height: result.append([x, max_height]) return result[1:]"},{"question":"Objective: Given an understanding of the Interpolation Search algorithm, you are required to implement a modified version of Interpolation Search that deals with potential performance issues when the array is not uniformly distributed. Problem Statement: Implement a function `optimized_interpolation_search` that searches for a given key in a sorted list of integers where elements may not be uniformly distributed. The function should employ the Interpolation Search algorithm, but use an adaptive mechanism to handle non-uniform distributions efficiently. Function Signature: ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. Examples: >>> optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 pass # implement your code here ``` Constraints: 1. `array` will be a non-empty list of integers sorted in increasing order. 2. `search_key` will be an integer. 3. Optimize for both the best case and worst-case time complexity, ensuring the solution performs well on non-uniform distributions too. Requirements: 1. Your function must handle edge cases efficiently. 2. Ensure the function does not run into any out-of-bound errors. 3. Use adaptive mechanisms to facilitate early exit if the array is not uniformly distributed. Examples: ```python >>> optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> optimized_interpolation_search([1, 2, 3, 4, 100, 200, 300, 400], 4) 3 ``` Note: Consider using additional data or flags to detect and handle non-uniform elements during the search, optimizing your interpolation strategy accordingly.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: Implements an optimized interpolation search that adapts to non-uniform distributions in the sorted array. Returns the index of search_key in the array if found, else returns -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Handle uniform distribution based case if array[high] == array[low]: if array[low] == search_key: return low else: return -1 # Calculate the position using the interpolation formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Ensure pos is within the array bounds pos = max(low, min(pos, high)) # Check if the found position is the search key if array[pos] == search_key: return pos # Adjust the range based on the comparison if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Longest Increasing Subsequence Assignment **Scenario**: You work as a software engineer at a biotech company where you frequently need to analyze sequences of data representing DNA strands. One of the common tasks is to identify the longest increasing subsequence of genome markers. To achieve this, you need to implement an efficient algorithm that can handle large datasets. **Task**: Implement a function `longest_increasing_subsequence(sequence: List[int]) -> int` that computes the length of the longest increasing subsequence in a given list of integers. # Requirements 1. **Function Signature**: ```python def longest_increasing_subsequence(sequence: List[int]) -> int: ``` 2. **Input**: A list of integers, `sequence` (0 ≤ len(sequence) ≤ 10^5, -10^5 ≤ sequence[i] ≤ 10^5). 3. **Output**: An integer representing the length of the longest increasing subsequence. 4. **Constraints**: - You must implement the optimized version using advanced data structures to achieve a time complexity better than O(n^2). - Handle edge cases, such as empty lists and lists containing repeated elements. # Example ```python assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence([]) == 0 assert longest_increasing_subsequence([3, 3, 3, 3, 3]) == 1 assert longest_increasing_subsequence([-1, -3, 4, 1, 2, 3, 7]) == 5 ``` # Performance Your solution should efficiently manage large sequences up to the maximum constraints while maintaining optimal performance. Specifically, your implementation should aim for O(n log(n)) time complexity, or as close as feasible. **Note**: Avoid using the brute force solution with O(n^2) complexity directly.","solution":"from typing import List import bisect def longest_increasing_subsequence(sequence: List[int]) -> int: Computes the length of the longest increasing subsequence in a given list of integers. if not sequence: return 0 # The tail array will store the end elements of the increasing subsequences tail = [] for num in sequence: # Use binary search to find the insertion position index = bisect.bisect_left(tail, num) # If the element is larger than all elements in tail, append it if index == len(tail): tail.append(num) else: # Otherwise, replace the element at the found index tail[index] = num return len(tail)"},{"question":"# Square Root Calculation Using Newton\'s Method Problem Statement Given a positive integer **N** and a precision factor **P**, you need to write a function that computes and returns the square root of **N** such that the maximum absolute error of your result from the actual square root of **N** is less than or equal to **P**. Your implementation should be based on Newton\'s method (Heron\'s method) of approximation. Function Signature ```python def square_root(n: int, p: float = 0.001) -> float: Calculate the square root of n with precision p. :param n: The number to find the square root of (0 <= n <= 10^9) :param p: The precision factor (0 < p <= 0.1) :return: The square root of n with an error less than or equal to p ``` Input * **n**: An integer, the number whose square root is to be computed, where 0 <= n <= 10^9. * **p**: A floating-point number, the precision factor for computing the square root, where 0 < p <= 0.1. Defaults to 0.001. Output * Returns the square root of **n** with the maximum absolute error from the actual value less than or equal to **p**. Constraints * The computation must handle numbers as large as 10^9. * Ensure that the precision constraint (p) is respected in the iteration. Example * Input: **n = 5**, **p = 0.001** * Output: Approximate value (x) such that (2.235 leq x leq 2.237) (since the actual square root of 5 is approximately 2.236) Notes * Do not use built-in functions like `math.sqrt()`. * Handle edge cases explicitly such as **n = 0** or **n = 1** where the square roots are 0 and 1 respectively.","solution":"def square_root(n: int, p: float = 0.001) -> float: Calculate the square root of n with precision p using Newton\'s method. :param n: The number to find the square root of (0 <= n <= 10^9) :param p: The precision factor (0 < p <= 0.1) :return: The square root of n with an error less than or equal to p if n == 0: return 0 elif n == 1: return 1 # Initial guess x = n # Iteratively improve the guess using Newton\'s method while True: root = 0.5 * (x + n / x) if abs(root - x) < p: return root x = root"},{"question":"Given an array of integers, implement the Gnome Sort algorithm to sort the array in non-decreasing order. Your implementation should be in-place, meaning it should not use extra space outside of the given array and a few variables. # Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers where `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6`. # Output * A list of integers sorted in non-decreasing order. # Constraints * The function must sort the list without making a copy of it. * Consider the edge cases such as an empty list or a list with all elements being the same. # Example ```python assert gnome_sort([3, 2, 5, 1, 7]) == [1, 2, 3, 5, 7] assert gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert gnome_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` Write your solution in Python and ensure it meets the constraints and example outputs provided.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sort the array using the Gnome Sort algorithm. i = 0 n = len(arr) while i < n: if i == 0 or arr[i] >= arr[i - 1]: i += 1 else: arr[i], arr[i - 1] = arr[i - 1], arr[i] i -= 1 return arr"},{"question":"Context: Given two strings `word1` and `word2`, you are required to find the minimum number of steps to make `word1` and `word2` the same. The only operation allowed is to delete one character in either of the strings. Task: Write a function `min_distance(word1: str, word2: str) -> int` that calculates the minimum number of steps required to make the two strings equal by only deleting characters. Input: - `word1`: A string with length in the range `[0, 1000]`. - `word2`: A string with length in the range `[0, 1000]`. Output: - An integer representing the minimum number of steps required. Constraints: 1. The function should handle edge cases such as one or both strings being empty. 2. The expected time complexity should be optimal, aiming for `O(length1 * length2)` where length1 and length2 are the lengths of the input strings. Examples: 1. **Example 1**: ```plaintext Input: word1 = \\"sea\\", word2 = \\"eat\\" Output: 2 Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". ``` 2. **Example 2**: ```plaintext Input: word1 = \\"leetcode\\", word2 = \\"etco\\" Output: 4 Explanation: You need to delete \\"lee\\" from \\"leetcode\\" and \\"o\\" from \\"etco\\" to get the common subsequence \\"etco\\". ``` Implementation: Implement the function `min_distance` utilizing dynamic programming techniques. You are free to optimize the space complexity as long as it does not compromise the functionality of the function.","solution":"def min_distance(word1: str, word2: str) -> int: Returns the minimum number of steps required to make word1 and word2 the same by only deleting characters. len1, len2 = len(word1), len(word2) dp = [[0]*(len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[len1][len2] return (len1 + len2) - 2 * lcs_length"},{"question":"# Question: Flatten Array and Manage Special Cases Context: You are developing a utility for data preprocessing. One of its functionalities is to transform nested arrays into a flat structure. However, you are aware that strings should not be split into characters, and deeply nested structures can sometimes lead to errors. Task: Implement a function `special_flatten` that flattens a nested list but includes additional checks to handle special cases: - Filter out any `None` values from the result. - Handle deeply nested structures without causing stack overflow using an iterative approach. - Ensure strings remain as whole elements, not split into individual characters. Function Signature: ```python def special_flatten(input_arr: list) -> list: pass ``` Input: * `input_arr (list)`: A nested list containing various elements including other lists, integers, floating-point numbers, strings, and potential `None` values. Output: * A single flat list with all elements from the nested lists, excluding `None` elements. Constraints: * Do not use any external libraries apart from the standard ones allowed in the task. * Assume the maximum depth of nesting does not exceed typical recursion limits of 1000. Example: ```python assert special_flatten([1, [2, [3, None, [4, \'hello\']], 5], None]) == [1, 2, 3, 4, \'hello\', 5] assert special_flatten([\'a\', [\'b\', [\'c\', [None, [None]]]], \'d\']) == [\'a\', \'b\', \'c\', \'d\'] ``` Notes: - You are expected to manage the depth of recursion by opting for an iterative solution or modifying the recursion limits where necessary. - Ensure the performance is adequate for typical input sizes.","solution":"def special_flatten(input_arr: list) -> list: Flattens a nested list, while handling special cases: - Strings are kept whole. - None values are filtered out. - Uses an iterative approach to avoid recursion limit issues. result = [] stack = [input_arr] while stack: current = stack.pop() if isinstance(current, list): for item in reversed(current): stack.append(item) elif current is not None: result.append(current) return result"},{"question":"**Union-Find Data Structure with Enhanced Functionality** **Objective**: Create a Union-Find data structure with additional functionality to support a more complex set of operations. # Problem Statement You need to implement a Union-Find data structure that supports the following additional operations: 1. **`connected(element1, element2)`**: Return True if the elements `element1` and `element2` are in the same set, False otherwise. 2. **`find(element)`**: Return the root or representative of the set containing `element`. 3. **`count_sets()`**: Return the current number of distinct sets. # Input/Output Requirements Function Signatures ```python class EnhancedUnionFind: def __init__(self): # initializes the data structure pass def add(self, element): # adds a new element pass def unite(self, element1, element2): # unites the sets containing element1 and element2 pass def connected(self, element1, element2): # checks if two elements are connected pass def find(self, element): # finds the root of the element pass def count_sets(self): # returns the count of distinct sets pass ``` Constraints 1. Assume elements are unique and hashable. 2. Operations will be called in any order. 3. Handle edge cases such as querying on non-existent elements gracefully. Example ```python uf = EnhancedUnionFind() uf.add(1) uf.add(2) uf.add(3) uf.unite(1, 2) assert uf.connected(1, 2) == True assert uf.connected(1, 3) == False assert uf.find(1) == uf.find(2) assert uf.count_sets() == 2 ``` Performance Requirements * Ensure all operations (`add`, `unite`, `connected`, `find`, `count_sets`) are optimized to handle up to 10^6 elements efficiently. # Additional Context The Union-Find data structure is widely used to manage and query dynamic connectivity in problems like network topology, image processing, and more. Understanding its implementation helps in solving diverse algorithmic challenges effectively.","solution":"class EnhancedUnionFind: def __init__(self): self.parent = {} self.rank = {} self.num_sets = 0 def add(self, element): if element not in self.parent: self.parent[element] = element self.rank[element] = 0 self.num_sets += 1 def find(self, element): if element not in self.parent: return None if self.parent[element] != element: self.parent[element] = self.find(self.parent[element]) # Path compression return self.parent[element] def unite(self, element1, element2): root1 = self.find(element1) root2 = self.find(element2) if root1 is None or root2 is None: return if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 self.num_sets -= 1 def connected(self, element1, element2): root1 = self.find(element1) root2 = self.find(element2) return root1 == root2 def count_sets(self): return self.num_sets"},{"question":"# Question: Repeated String Matcher Given two strings `A` and `B`, you need to determine the minimum number of times string `A` has to be repeated such that string `B` becomes a substring of the repeated string `A`. If it is not possible, return `-1`. **Function Signature**: ```python def repeat_string(A: str, B: str) -> int: pass ``` **Input**: - `A`: A string of length between 1 and 10000. - `B`: A string of length between 1 and 10000. **Output**: - An integer representing the minimum number of repeats of `A` required for `B` to be a substring of the repeated `A`. If not possible, return `-1`. **Constraints**: - The length of both strings, A and B, will be between 1 and 10000. **Examples**: ```python assert repeat_string(\\"abcd\\", \\"cdabcdab\\") == 3 assert repeat_string(\\"a\\", \\"aa\\") == 2 assert repeat_string(\\"abc\\", \\"xyz\\") == -1 assert repeat_string(\\"abc\\", \\"abcabc\\") == 2 ``` **Explanation**: 1. The first example returns 3 because repeating \\"abcd\\" three times (\\"abcdabcdabcd\\") contains \\"cdabcdab\\" as a substring, while twice repetition \\"abcdabcd\\" does not. 2. The second example returns 2 because repeating \\"a\\" twice (\\"aa\\") makes \\"aa\\" a substring. 3. The third example returns -1 because no amount of repetition of \\"abc\\" can ever contain \\"xyz\\" as a substring. 4. The fourth example returns 2 because \\"abcabc\\" contains \\"abcabc\\".","solution":"def repeat_string(A: str, B: str) -> int: Returns the minimum number of times A needs to be repeated for B to be a substring. If it\'s impossible, returns -1. max_repeats = (len(B) // len(A)) + 2 repeated_A = A for i in range(1, max_repeats + 1): if B in repeated_A: return i repeated_A += A return -1"},{"question":"# Maximum Subarray Sum You are given an array of integers, which may contain both positive and negative numbers. Your task is to implement a function that returns the sum of the maximum subarray. A subarray is a contiguous part of the array. **Function Signature:** ```python def max_subarray(array: List[int]) -> int: ``` **Input:** - `array`: A list of integers `array` (1 ≤ len(array) ≤ 10^5, -10^4 ≤ array[i] ≤ 10^4) **Output:** - Returns an integer representing the maximum sum of a contiguous subarray. **Constraints:** - You must achieve a linear time complexity O(n) and constant space complexity O(1). - Handle arrays that may contain both positive and negative values, as well as arrays containing a single element. **Example:** ```python assert max_subarray([1, 2, -3, 4, 5, -7, 23]) == 25 # The subarray [4, 5, -7, 23] gives the sum 25. assert max_subarray([-2, -3, -1, -4]) == -1 # The subarray [-1] gives the sum -1. assert max_subarray([5]) == 5 # The subarray [5] gives the sum 5. ``` **Scenario:** You are a software engineer at a company that analyzes financial data. You receive time series data representing daily profit/loss values of a stock. Your task is to identify the best period (subarray) during which the stock makes the maximum profit. Develop a function that processes the daily profit/loss data efficiently and returns the maximum sum of any contiguous subarray to assist your team in making investment decisions.","solution":"from typing import List def max_subarray(array: List[int]) -> int: Returns the sum of the maximum subarray. if not array: return 0 max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Bitwise Addition Challenge Context In certain low-level programming environments, or in the development of embedded systems, you may not have access to standard arithmetic operations. This scenario requires you to perform necessary calculations using bitwise operations. Task Write a function `add_without_plus(a: int, b: int) -> int` that adds two positive integers `a` and `b` without using the \'+\' operator. Instead, use the provided algorithm that utilizes bitwise operations to compute the sum. Input * Two non-negative integers `a` and `b`. Output * A single integer which is the sum of `a` and `b`. Example ```python add_without_plus(2, 3) ``` * Expected Output: `5` Constraints * The function should add the numbers without using the \'+\' operator. * The input numbers are guaranteed to be within the range of typical 32-bit signed integers. * You can assume that `a` and `b` are non-negative. Function Signature ```python def add_without_plus(a: int, b: int) -> int: pass ``` **Note**: Ensure your code handles edge cases such as one or both of the numbers being zero.","solution":"def add_without_plus(a: int, b: int) -> int: Adds two non-negative integers a and b using bitwise operations. # Repeat till there\'s no carry while b != 0: # carry contains common set bits of a and b carry = a & b # sum of bits of a and b where at least one of the bits is not set a = a ^ b # Carry is shifted by one so that adding it to a gives the required sum b = carry << 1 return a"},{"question":"You are tasked with implementing an efficient factorial calculator for a competitive programming platform. Your function should calculate the factorial of a non-negative integer `n` and return the result. Additionally, you should support an optional modulus operation to prevent overflow, returning the factorial result modulo `mod`. # Function Signature ```python def factorial_efficient(n: int, mod: int = None) -> int: Calculates the factorial of n. Params: n (int): A non-negative integer whose factorial is to be calculated. mod (int, optional): If provided, the result will be (factorial % mod). Returns: int: The factorial of n, or (factorial % mod) if mod is provided. ``` # Input and Output Formats - **Input**: - An integer `n` where `0 <= n <= 10^5`. - An optional integer `mod` where `1 <= mod <= 10^9` (if provided). - **Output**: - An integer representing `n!` or `(n! % mod)` if `mod` is provided. # Constraints - The function should handle large values of `n` efficiently. - The implementation should be able to execute efficiently within the time limits for `n` up to `100000`. # Performance Requirements - **Time Complexity**: O(n) - **Space Complexity**: O(1) # Example ```python assert factorial_efficient(5) == 120 assert factorial_efficient(5, 3) == 0 assert factorial_efficient(10, 1000) == 800 ``` # Edge Cases to Consider - The smallest non-negative integer input (`n=0`). - Inputs where `mod` is greater than the resulting factorial. - Large values of `n` near the upper constraint. Implement the function considering the outlined requirements and edge cases.","solution":"def factorial_efficient(n: int, mod: int = None) -> int: Calculates the factorial of n. Params: n (int): A non-negative integer whose factorial is to be calculated. mod (int, optional): If provided, the result will be (factorial % mod). Returns: int: The factorial of n, or (factorial % mod) if mod is provided. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result"},{"question":"# Question: Implement Enhanced Merge Sort Merge Sort is a classical sorting algorithm that guarantees O(n log(n)) time complexity. We have provided an inefficient implementation due to its extra space usage for merging. Your task is to improve the efficiency of this Merge Sort by making it an in-place sorting algorithm without using additional temporary lists inside the merge function. Requirements: 1. **Function Signature**: Your function should adhere to the following signature: ```python def merge_sort(arr: List[int]) -> None: In-place merge sort. ``` 2. **Input**: - `arr`: A list of integers (0 <= len(arr) <= 10^5). The integers are within the range [-10^9, 10^9]. 3. **Output**: - The function should sort the input list `arr` in-place in ascending order. It should not return anything. 4. **Constraints**: - The function must accomplish the sorting in-place with O(1) additional space complexity beyond the input array. 5. **Edge Cases**: - Lists with a single element or empty lists. - Lists that are already sorted or sorted in reverse order. - Lists with duplicate values. Example: ```python # Example 1: arr = [38, 27, 43, 3, 9, 82, 10] merge_sort(arr) print(arr) # Output: [3, 9, 10, 27, 38, 43, 82] # Example 2: arr = [1] merge_sort(arr) print(arr) # Output: [1] # Example 3: arr = [] merge_sort(arr) print(arr) # Output: [] # Example 4: arr = [4, 4, 4, 4] merge_sort(arr) print(arr) # Output: [4, 4, 4, 4] ``` Utilize the provided Merge Sort code as a starting point and modify it to work in-place for better space efficiency.","solution":"from typing import List def merge_sort(arr: List[int]) -> None: In-place merge sort. def merge(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] def merge_sort_recursive(arr, temp_arr, left, right): if left < right: mid = (left + right) // 2 merge_sort_recursive(arr, temp_arr, left, mid) merge_sort_recursive(arr, temp_arr, mid + 1, right) merge(arr, temp_arr, left, mid, right) n = len(arr) temp_arr = [0] * n merge_sort_recursive(arr, temp_arr, 0, n - 1)"},{"question":"# Problem Description You are responsible for developing an advanced health-tracking app that calculates ways for users to reach their daily step goals efficiently. One of the features involves calculating the number of distinct ways users can reach a given step count if they can take either 1-step or 2-steps at a time. *You have been tasked to implement a function that returns the number of distinct ways to reach the top of the staircase*. # Function Signature Implement the function `calculate_ways(steps: int) -> int`. # Input - `steps` (1 <= `steps` <= 10^4): A positive integer representing the number of steps to reach the top. # Output - Returns an integer representing the number of distinct ways to reach the top of the staircase. # Constraints - The solution should be efficient, with a time complexity of O(n) and space complexity of O(1). - Ensure that the function handles edge cases such as minimal steps (1 step). # Example ```python assert calculate_ways(2) == 2 # [1-step + 1-step, 2-steps] assert calculate_ways(3) == 3 # [1-step + 1-step + 1-step, 1-step + 2-steps, 2-steps + 1-step] assert calculate_ways(4) == 5 # [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2] ```","solution":"def calculate_ways(steps: int) -> int: Returns the number of distinct ways to reach the top of the staircase if the user can take either 1-step or 2-steps at a time. if steps == 1: return 1 elif steps == 2: return 2 prev2, prev1 = 1, 2 for _ in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Objective Write a function to find the next higher number with the same set of digits. This requires understanding permutations and efficient manipulation of digits. Input Format - A single integer `num` (1 ≤ num ≤ 10^9). Output Format - Return the next higher permutation of the number as an integer. - If no such permutation exists, return -1. # Example Scenarios Example 1 - Input: `38276` - Output: `38627` Example 2 - Input: `99999` - Output: `-1` Example 3 - Input: `12345` - Output: `12354` # Constraints - You may not use built-in functions that directly generate permutations of the number. - Your solution must run in linear time, i.e., O(n) where n is the number of digits. # Function Signature ```python def next_bigger(num: int) -> int: ``` # Scenario Suppose you\'re developing software for a secure bank vault with a combination lock. It would help if the lock could generate the next permutation of the combination if you wanted to check for specific sequence patterns or require changes in a sequence of code. Implementing this algorithm efficiently ensures its reliability and speed. # Implementation Instructions Implement the function `next_bigger(num: int) -> int` following the provided example code structure. Ensure your function handles edge cases properly, including very large inputs.","solution":"def next_bigger(num: int) -> int: Returns the next higher permutation of the same digits of the given number. If no such permutation exists, returns -1. digits = list(str(num)) n = len(digits) # Step 1: Find the largest index k such that digits[k] < digits[k + 1] k = -1 for i in range(n - 1): if digits[i] < digits[i + 1]: k = i if k == -1: return -1 # The digits are in descending order # Step 2: Find the largest index l greater than k such that digits[k] < digits[l] l = -1 for i in range(k + 1, n): if digits[k] < digits[i]: l = i # Step 3: Swap the value of digits[k] with that of digits[l] digits[k], digits[l] = digits[l], digits[k] # Step 4: Reverse the sequence from digits[k + 1] to the end digits = digits[:k + 1] + digits[k + 1:][::-1] # Convert back to an integer next_permutation = int(\\"\\".join(digits)) return next_permutation"},{"question":"**Context** Imagine you are working on a text compression tool that requires generating all potential abbreviations for given input strings. This is helpful in applications where shorthand notations can save space and improve readability. **Task** Write a function `generate_abbreviations` that generates all possible abbreviations for a given input string. **Function Signature** ```python def generate_abbreviations(word: str) -> List[str]: ``` **Input** - A single string `word` of length `n` (`0 <= n <= 20`), consisting of lowercase English letters. **Output** - A list of strings representing all possible abbreviations of the input word. **Constraints** - The function should handle edge cases gracefully, including empty input strings. - You should aim for an efficient solution, but exact performance requirements are relaxed due to the inherent combinatorial nature. **Examples** ```python assert generate_abbreviations(\\"word\\") == [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] assert generate_abbreviations(\\"\\") == [\\"\\"] assert generate_abbreviations(\\"a\\") == [\\"a\\", \\"1\\"] ``` **Explanation** For the input word \\"word\\": - \\"word\\" (no abbreviation). - Replace one character at a time by 1: \\"wor1\\", \\"wo1d\\", \\"w1rd\\", \\"1ord\\". - Replace two characters: \\"wo2\\", \\"w2d\\", \\"2rd\\". - Replace three characters: \\"w3\\", \\"1o2\\", \\"1o1d\\", \\"1or1\\". - Replace four characters: \\"4\\". Your function will be tested against multiple test cases, including edge cases. Make sure to test your function exhaustively to ensure correctness.","solution":"def generate_abbreviations(word): Generates all possible abbreviations of the input word. Parameters: word (str): A string for which abbreviations are to be generated. Returns: List[str]: A list of all possible abbreviations. def backtrack(pos, cur, count): if pos == len(word): if count > 0: cur += str(count) abbreviations.append(cur) else: # Abbreviate current position backtrack(pos + 1, cur, count + 1) # Keep current position character backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) abbreviations = [] backtrack(0, \'\', 0) return abbreviations"},{"question":"**Graph Connectivity Check** Given the definition of the graph above, write a function `is_connected_directed_graph` to check if the provided directed graph is strongly connected. A directed graph is strongly connected if there is a path from any node to every other node. # Function Signature ```python def is_connected_directed_graph(d_graph: DirectedGraph) -> bool: ``` # Input: - `d_graph`: An instance of `DirectedGraph`. # Output: - Return `True` if the graph is strongly connected, otherwise `False`. # Constraints: * Graph can have up to 1000 nodes. * Node names are unique and non-empty strings. * The function should run within a reasonable time for the input size limit (preferably O(V+E), where V is the number of nodes and E is the number of edges). # Example: ```python graph_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } graph = DirectedGraph(graph_dict) print(is_connected_directed_graph(graph)) # Output: True graph_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"A\\"], \\"B\\": [\\"D\\"], } graph = DirectedGraph(graph_dict) print(is_connected_directed_graph(graph)) # Output: True graph_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [] } graph = DirectedGraph(graph_dict) print(is_connected_directed_graph(graph)) # Output: False ``` # Hints: 1. You may need to perform a depth-first search (DFS) or breadth-first search (BFS) from every node to check reachability. 2. Consider using Tarjan\'s or Kosaraju\'s algorithm for efficiency.","solution":"from collections import defaultdict class DirectedGraph: def __init__(self, graph_dict=None): self.graph_dict = graph_dict or {} def is_connected_directed_graph(d_graph: DirectedGraph) -> bool: def dfs(graph, node, visited): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: dfs(graph, neighbor, visited) def get_transpose(graph): t_graph = defaultdict(list) for node in graph: for neighbor in graph[node]: t_graph[neighbor].append(node) return t_graph graph = d_graph.graph_dict if not graph: return True # Pick the first node to start DFS. start_node = list(graph.keys())[0] # Step 1: Check if all nodes are reachable from the start node. visited = set() dfs(graph, start_node, visited) if len(visited) != len(graph): return False # Step 2: Get the transpose of the graph. t_graph = get_transpose(graph) # Step 3: Check if all nodes are reachable from the start node in the transposed graph. visited = set() dfs(t_graph, start_node, visited) if len(visited) != len(graph): return False return True"},{"question":"# Question: Extended Linear Search In this task, you will implement an enhanced form of linear search to assess your understanding of array manipulation and search algorithms. Specifically, you need to handle advanced requirements beyond a basic linear search. **Enhanced Requirements**: * You need to find the index of the first and last occurrence of the given element (`query`) in the array. * If the element is not present, return a tuple (-1, -1). * Your implementation should handle both small and very large datasets efficiently. Implement the function: ```python def extended_linear_search(array, query): Find the first and last occurrence index of the given element in the array. Parameters: * array (List[int]): List of integers (can be empty). * query (int): The element to search for. Returns: * Tuple[int, int]: A tuple with the first and last occurrence indices of the element. If the element is not found, return (-1, -1). pass ``` Example: ```python # Example 1 array = [3, 5, 2, 1, 5, 7, 5] query = 5 # First occurrence is at index 1 # Last occurrence is at index 6 print(extended_linear_search(array, query)) # Output: (1, 6) # Example 2 array = [1, 2, 3] query = 4 # Element not found print(extended_linear_search(array, query)) # Output: (-1, -1) ``` Constraints: * The array length `n` can be in the range [0, 10^6]. * Each element of the array is an integer in the range [-10^9, 10^9]. * Aim for an O(n) time complexity and O(1) auxiliary space complexity. In your solution, pay attention to handling various edge cases such as: * Empty arrays. * Arrays where the query element appears multiple times. * Arrays where the query element does not appear at all.","solution":"def extended_linear_search(array, query): Find the first and last occurrence index of the given element in the array. Parameters: * array (List[int]): List of integers (can be empty). * query (int): The element to search for. Returns: * Tuple[int, int]: A tuple with the first and last occurrence indices of the element. If the element is not found, return (-1, -1). first_occurrence = -1 last_occurrence = -1 for index, value in enumerate(array): if value == query: if first_occurrence == -1: first_occurrence = index last_occurrence = index return (first_occurrence, last_occurrence)"},{"question":"**Trimming the Mean** Given an array of integers and a percentage to trim, write a function `trimmean(arr, per)` that calculates the trimmed mean of the array. This function should remove the highest and lowest values based on the given percentage and then compute the mean of the remaining values. # Input - `arr`: a list of integers (1 <= len(arr) <= 10^5) - `per`: a float representing the percentage of values to trim from both ends of the list. (0 <= per <= 100) # Output - A float representing the trimmed mean of the array. # Constraints - The list will contain at least one element after trimming. # Performance Requirements - The function should run in O(n log n) time complexity or better. - The solution should require O(n) additional space at most. # Example: ```python assert trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) == 5.5 assert trimmean([10, 20, 30, 40, 50, 60, 70], 40) == 40.0 assert trimmean([5, 5, 5, 5, 5], 0) == 5.0 assert trimmean([1, 1, 1, 100, 100, 100], 10) == 50.5 ``` # Scenario: In competitive sports, when calculating an athlete\'s score, outlier scores (either extremely high or extremely low) can skew the average. To get a more reliable assessment of the athlete’s performance, the highest and lowest scores are trimmed before computing the average score. This helps to ensure that the trimmed mean provides a fairer representation of the athlete\'s performance. Write a function that helps compute this trimmed mean to aid sports analysts and judges.","solution":"def trimmean(arr, per): Calculate the trimmed mean of the array based on the percentage. Parameters: arr (list): List of integers. per (float): Percentage of values to trim from both ends of the list. Returns: float: Trimmed mean of the array. arr.sort() n = len(arr) k = int((per / 100) * n / 2) if k == 0: return sum(arr) / n trimmed_arr = arr[k:-k] trimmed_mean = sum(trimmed_arr) / len(trimmed_arr) return trimmed_mean"},{"question":"You are tasked with implementing an optimized version of the Insertion Sort algorithm. Your task is to write a function that enhances the insertion sort by utilizing a binary search to determine the correct position of the current element. This improvement aims to reduce the number of comparisons within the inner while loop, thereby improving overall efficiency. # Function Signature ```python def optimized_insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers to be sorted. # Output - Returns the sorted list of integers. # Constraints - The input list will have no more than (10^4) elements. - Each element in the list will be an integer in the range (-10^9) to (10^9). # Example Input ```python arr = [29, 10, 14, 37, 13] ``` Output ```python [10, 13, 14, 29, 37] ``` # Notes 1. Make sure to handle edge cases: empty array, single-element array, already sorted array, and reverse order array. 2. The function should maintain the stability of the original insertion sort – meaning equal elements should maintain their relative order from the input list. # Performance Given the constraint on list size (i.e., up to (10^4)), your implementation should exhibit the efficiency benefits brought by the binary search within the insertion sort algorithm.","solution":"from typing import List def binary_search(arr: List[int], val: int, start: int, end: int) -> int: A helper function to perform binary search on the array. It returns the position where the value should be inserted. if start == end: if arr[start] > val: return start else: return start + 1 if start > end: return start mid = (start + end) // 2 if arr[mid] < val: return binary_search(arr, val, mid + 1, end) elif arr[mid] > val: return binary_search(arr, val, start, mid - 1) else: return mid def optimized_insertion_sort(arr: List[int]) -> List[int]: An optimized version of insertion sort that uses binary search to find the correct insertion position, reducing the number of comparisons. for i in range(1, len(arr)): val = arr[i] j = binary_search(arr, val, 0, i - 1) # Shifting elements to the right to make space for insertion arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] return arr"},{"question":"# Exam Question: Finding the Added Character Context You are given two strings `s` and `t`, where `s` consists of lowercase letters and `t` is generated by random shuffling `s` and adding one additional lowercase letter. Your task is to find the extra letter that was added to `t`. Problem Statement Write a function named `find_added_letter` that identifies the one additional letter in string `t` compared to string `s`. Function Signature ```python def find_added_letter(s: str, t: str) -> str: ``` Input * `s`: A string consisting of lowercase English letters. Length of s is n (1 ≤ n ≤ 10^5). * `t`: A string consisting of lowercase English letters. Length of t is n + 1 and it is guaranteed that t is generated by shuffling s and adding one extra letter. Output * A single character which is the added letter in `t`. Constraints * The input strings contain only lowercase English letters. * The length of `t` is exactly one more than the length of `s`. Example ```python # Example 1: s = \\"abcd\\" t = \\"abcde\\" Output: \'e\' # Example 2: s = \\"xyz\\" t = \\"yxzz\\" Output: \'z\' # Example 3: s = \\"\\" t = \\"a\\" Output: \'a\' ``` Instructions Your solution should implement the function `find_added_letter` using an efficient algorithm for character comparison and determining the additional character. Consider edge cases and strive for optimal space and time complexity.","solution":"def find_added_letter(s: str, t: str) -> str: Finds the added letter in t compared to s. s_sum = sum(ord(char) for char in s) t_sum = sum(ord(char) for char in t) return chr(t_sum - s_sum)"},{"question":"# Question: Given two strings `A` and `B`, your task is to determine the minimum number of times you need to repeat string `A` such that `B` becomes a substring of the repeated string. If `B` cannot be a substring of any number of repetitions of `A`, return -1. Input Format: * Two strings `A` and `B` Output Format: * An integer representing the minimum number of times `A` has to be repeated so that `B` is a substring of it, or `-1` if no such repetition exists. Constraints: * The length of `A` and `B` will be between 1 and 10000. Example: ```text Input: A = \\"abcd\\" B = \\"cdabcdab\\" Output: 3 Input: A = \\"abc\\" B = \\"cabcabca\\" Output: 4 Input: A = \\"abcd\\" B = \\"abcdbcd\\" Output: -1 ``` Requirements: * Optimized approach with adequate performance for the given constraints. * Careful manipulation of string to avoid unnecessary concatenation.","solution":"def min_repeats_to_get_substring(A, B): Determines the minimum number of times string A needs to be repeated so that B becomes a substring of the repeated string. If B cannot be a substring, returns -1. len_A = len(A) len_B = len(B) max_repeats = (len_B // len_A) + 2 repeated_A = A for i in range(1, max_repeats + 1): if B in repeated_A: return i repeated_A += A return -1"},{"question":"Interpolation Search with Variations and Edge Cases You are tasked with implementing an improved version of the Interpolation Search algorithm. The standard interpolation search works effectively on uniformly distributed values but struggles with highly skewed distributions. Your objective is to handle edge cases and improve robustness. Requirements: * Implement the `enhanced_interpolation_search` function. * Enhance robustness against division-by-zero scenarios. * Correctly handle edge cases where the search key is smaller or larger than any element in the array. * Add functionality to handle repetitive elements. Specifications: * **Function Signature**: `def enhanced_interpolation_search(array: List[int], search_key: int) -> int:` * **Input**: * `array` - A sorted list of integers (sorted in non-decreasing order). * `search_key` - An integer value that you need to find in the array. * **Output**: * Return the index of the `search_key` if found. * Return `-1` if the `search_key` is not in the array. Constraints: * You must handle cases where all elements in the array are identical. * Ensure that the algorithm does not fail for arrays containing up to (10^6) elements. * Use integer division where necessary to avoid precision errors. Example: ```python >>> enhanced_interpolation_search([10, 20, 20, 20, 30, 40, 50], 20) 1 >>> enhanced_interpolation_search([5, 10, 12, 17, 20, 21], 22) -1 >>> enhanced_interpolation_search([5, 10, 12, 17, 20, 21], 5) 0 >>> enhanced_interpolation_search([5, 10, 12, 17, 20, 21], -5) -1 >>> enhanced_interpolation_search([10, 10, 10, 10, 10], 10) 0 ``` Additional Considerations: * Ensure the function runs efficiently for large arrays. * Document how the function handles different edge cases within the code. Implement your function in the code block below.","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: Perform an enhanced interpolation search on the given sorted array. Args: - array (List[int]): A sorted list of integers. - search_key (int): The value to search for. Returns: - int: The index of the search_key if found, otherwise -1. if not array: return -1 low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Avoid division by zero and handle repetitive elements if array[high] == array[low]: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Ensure the calculated position stays within bounds pos = max(min(pos, high), low) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Missing Number Finder You are given a sequence of unique integers in the range [0, n] where exactly one number is missing. Develop a function to find and return the missing number. If there are no missing numbers, return the next integer (i.e., n+1). Your task is to implement two functions, `find_missing_number` and `find_missing_number2`, each detecting the missing number using a different approach. # Function 1: find_missing_number This function should use the XOR approach. **Function Signature**: ```python def find_missing_number(nums: List[int]) -> int: ``` # Function 2: find_missing_number2 This function should use the sum formula approach. **Function Signature**: ```python def find_missing_number2(nums: List[int]) -> int: ``` # Input - `nums`: List of unique integers from the range [0, n], with one missing number. # Output - An integer representing the missing number. If no number is missing, return `n+1`. # Constraints - All integers in `nums` are unique. - The length of `nums` will be in the range [0, 10^6]. # Examples **Example 1** ```python Input: nums = [4, 1, 3, 0, 6, 5, 2] Output: find_missing_number(nums) -> 7 find_missing_number2(nums) -> 7 ``` **Example 2** ```python Input: nums = [0, 1, 2, 3, 4] Output: find_missing_number(nums) -> 5 find_missing_number2(nums) -> 5 ``` # Requirements - Ensure both implementations perform efficiently with respect to time and space. - Handle edge cases such as empty lists and already complete sequences.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in the array using the XOR approach. n = len(nums) xor_all = 0 xor_nums = 0 # XOR all numbers from 0 to n for i in range(n + 1): xor_all ^= i # XOR all numbers in the list for num in nums: xor_nums ^= num # The missing number is the XOR of these two results return xor_all ^ xor_nums def find_missing_number2(nums: List[int]) -> int: Finds the missing number in the array using the sum formula approach. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Problem: Next Higher Number Using Same Digits You are given an integer `num`, and you need to find the next higher number that contains exactly the same set of digits as the original number. If no such number exists (i.e., the input is the highest possible permutation of its digits), return `-1`. # Function Signature: ```python def next_bigger(num: int) -> int: pass ``` # Input: * A single integer `num` where (1 leq num leq 10^6). # Output: * An integer representing the next higher number with the same digits or `-1` if no such number exists. # Constraints: * The number `num` will not have leading zeros. * The function should complete efficiently for the input constraint. # Examples: ```python next_bigger(38276) -> 38627 next_bigger(99999) -> -1 next_bigger(12345) -> 12354 next_bigger(54321) -> -1 next_bigger(1528452) -> 1528524 ``` # Scenario: You\'re implementing a feature in a combinatorial task manager that needs to efficiently find the next permutation of a task identifier (which is a number). Your function will help in sorting out task sequences in increasing order quickly by generating the next possible identifier using the same digits. # Notes: 1. Make sure to handle all edge cases, such as when the given number is the largest permutation or when it contains duplicate digits. 2. Optimize the implementation to minimise space usage whenever possible. 3. Ensure your solution passes all the provided test cases.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) length = len(digits) # Step 1: Find the rightmost digit which is smaller than its next digit. i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: return -1 # No higher permutation possible # Step 2: Find the smallest digit on the right of \'i\' and greater than digits[i] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence after the i-th position digits[i + 1:] = reversed(digits[i + 1:]) return int(\'\'.join(digits))"},{"question":"You are required to implement a function that uses Euler\'s Totient Function to determine the number of integers between 1 and `n` that are relatively prime to `n`. This function is useful for many applications in number theory, cryptography, and modular arithmetic. Your implementation should handle large values of n efficiently. # Function Signature ```python def calculate_phi(n: int) -> int: This function takes a single integer n (1 <= n <= 10^6) as input and returns the count of integers between 1 and n inclusive that are coprime with n. pass ``` # Input * An integer `n` (1 <= n <= 10^6). # Output * An integer representing the count of numbers from 1 to `n` inclusive that are coprime with `n`. # Constraints * You must utilize efficient algorithms, as brute force techniques will not run within acceptable time limits for large `n`. * You must not use any external libraries for GCD or prime factorization. # Example ```python calculate_phi(1) -> 1 calculate_phi(6) -> 2 calculate_phi(10) -> 4 calculate_phi(15) -> 8 ``` # Explanation * For `n = 1`, the only number coprime with 1 is 1 itself. * For `n = 6`, the numbers that are coprime with 6 are 1 and 5. * For `n = 10`, the coprime numbers are 1, 3, 7, and 9. * For `n = 15`, the coprime numbers are 1, 2, 4, 7, 8, 11, 13, and 14. Given the constraints and requirements, make sure your code is optimal and handles large inputs gracefully.","solution":"def calculate_phi(n: int) -> int: This function takes a single integer n (1 <= n <= 10^6) as input and returns the count of integers between 1 and n inclusive that are coprime with n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: # If p is a divisor of n, then count the divisor while n % p == 0: n //= p result -= result // p p += 1 # If n is still greater than 1, it means n is prime if n > 1: result -= result // n return result"},{"question":"Scenario You are responsible for developing an application that processes ancient documents and requires the conversion of integers to Roman numerals for publication. Your task is to implement this functionality efficiently within the given constraints. Task Write a Python function to convert an integer to a Roman numeral. The input integer is guaranteed to be within the range from 1 to 3999. ```python def int_to_roman(num): Convert an integer to a Roman numeral. :param num: int - An integer within the range 1 to 3999 :return: str - The corresponding Roman numeral # Your implementation here ``` # Input * `num` - An integer within the range 1 to 3999. # Output * A string representing the Roman numeral corresponding to the input integer. Example ```python print(int_to_roman(58)) # Expected output: \\"LVIII\\" print(int_to_roman(1994)) # Expected output: \\"MCMXCIV\\" ``` # Constraints * The input integer will be within the range of 1 to 3999. * The output should always be a valid Roman numeral for the given input. # Notes * Pay attention to the special cases in Roman numeral system, such as 4 (IV) and 9 (IX). * Optimize the function to handle the conversion in constant time, as the maximum input value constraints allow such optimization.","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: int - An integer within the range 1 to 3999 :return: str - The corresponding Roman numeral val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"# Question: Absolute File Path Retrieval Scenario You are developing a file system utility tool that frequently needs to resolve file paths to their absolute values for consistent file handling. As part of this utility, it\'s essential to ensure that any file path passed through is correctly translated into an absolute path. This includes expanding user directory symbols (`~`) and converting relative paths to their absolute counterparts. Task Write a function `absolute_file_path(file_path: str) -> str` that takes a single string argument representing a file path and returns its absolute path. Requirements * If the file path starts with `~`, it should be expanded to the user\'s home directory. * If the file path is relative, convert it to an absolute path. * Ensure the function handles and returns a valid string for the absolute path even if the path does not exist. Input and Output * **Input**: A single string `file_path` representing the file path. ```python file_path: str ``` * **Output**: A single string representing the absolute path of the file. ```python return: str ``` Performance * The function should handle paths up to 4096 characters efficiently. * Aim for time complexity: O(n). * Space complexity should not exceed O(n). Constraints * The input file path will not be larger than 4096 characters. * Assume a valid file path string is provided. Example ```python file_path = \\"~/Documents/myfile.txt\\" # When the home directory is /home/username output = \\"/home/username/Documents/myfile.txt\\" file_path = \\"projects/assignment.py\\" # When the current working directory is /home/username output = \\"/home/username/projects/assignment.py\\" ``` Implementation Implement the function `absolute_file_path` in Python. ```python def absolute_file_path(file_path): Converts a given file path to its absolute path. Parameters: file_path (str): The file path to be converted. Returns: str: The absolute path of the file. import os return os.path.abspath(os.path.expanduser(file_path)) ```","solution":"def absolute_file_path(file_path): Converts a given file path to its absolute path. Parameters: file_path (str): The file path to be converted. Returns: str: The absolute path of the file. import os return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# Scenario You are a software engineer tasked with optimizing data processing in an e-commerce application. One of the critical operations is sorting the product IDs before performing batch updates. You plan to use Quick Sort due to its efficient average-case performance. # Problem Statement Implement the Quick Sort algorithm to sort an array of integers. Your function should not only sort the array but also keep track of and return the number of swaps made during the sorting process. This will help in analyzing the performance of Quick Sort on different datasets. # Function Signature ```python def quick_sort_with_swaps(arr: List[int]) -> Tuple[List[int], int]: Sorts the array using Quick Sort and keeps track of the number of swaps. Parameters: arr (List[int]): A list of integers to sort. Returns: Tuple[List[int], int]: A sorted list of integers and the count of swaps done during sorting. ``` # Constraints * The length of the array will be between 1 and 10^4. * Each element in the array will be between -10^6 and 10^6. # Example ```python # Example 1 arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr, swap_count = quick_sort_with_swaps(arr) print(sorted_arr) # Expected: [1, 1, 2, 3, 6, 8, 10] print(swap_count) # Output: depends on the implementation # Example 2 arr = [1, 4, 3, 9, 7] sorted_arr, swap_count = quick_sort_with_swaps(arr) print(sorted_arr) # Expected: [1, 3, 4, 7, 9] print(swap_count) # Output: depends on the implementation ``` # Requirements * Your implementation must be efficient with an average time complexity of O(n log n). * Ensure your solution handles edge cases, including arrays with repeated elements, already sorted arrays, and arrays sorted in reverse order.","solution":"from typing import List, Tuple def quick_sort_with_swaps(arr: List[int]) -> Tuple[List[int], int]: def partition(low, high): pivot = arr[high] i = low - 1 swap_count = 0 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] swap_count += 1 arr[i + 1], arr[high] = arr[high], arr[i + 1] swap_count += 1 return i + 1, swap_count def quick_sort_recursive(low, high): swap_count = 0 if low < high: pi, current_swaps = partition(low, high) swap_count += current_swaps swap_count += quick_sort_recursive(low, pi - 1) swap_count += quick_sort_recursive(pi + 1, high) return swap_count swap_count = quick_sort_recursive(0, len(arr) - 1) return arr, swap_count"},{"question":"# Question: Implement and Analyze Stooge Sort Scenario John is a computer science student who has just learned about various sorting algorithms in his algorithms class. He encounters a peculiar recursive sorting algorithm called Stooge Sort, which he finds interesting but highly inefficient compared to other classic sorting algorithms. John decides to implement Stooge Sort to better understand its working principle by sorting a given list of integers. Task You are required to implement the Stooge Sort algorithm in Python and explain its inefficiencies through analysis. Additionally, you should handle the edge cases effectively. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your implementation goes here ``` Input - **arr**: A list of integers [1, 3, 64, 5, 7, 8] (0 ≤ arr.length ≤ 10^5) - **l**: Integer representing the starting index, initially 0. - **h**: Integer representing the ending index, initially len(arr) - 1. Output - The function modifies the array in place to be sorted in non-decreasing order. - You should print the array elements to display the sorted order. Constraints - Ensure efficient use of recursion to prevent stack overflow for large arrays. - Consider edge cases such as arrays of length 0 or 1 and arrays with all identical elements. - You must not use any built-in sorting functions like sort() or sorted(). Example ```python # Example 1: arr = [1, 3, 64, 5, 7, 8] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 3, 5, 7, 8, 64] # Example 2: arr = [9, 8, 7, 6, 5, 4, 3, 2, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ```","solution":"def stoogesort(arr, l, h): Recursive Stooge Sort algorithm which sorts the array in-place. :param arr: List of integers to be sorted. :param l: Left index of the subarray to be sorted. :param h: Right index of the subarray to be sorted. if l >= h: return # Base case: single element or invalid range # If the element at the left index is greater than the element at the right index, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the subarray if (h - l + 1) > 2: t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort the last 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort the first 2/3 of the array again to ensure the whole array is sorted stoogesort(arr, l, h - t)"},{"question":"# Question: Subset Generation with Constraints You are tasked with developing a function to generate all possible subsets of a given list of distinct integers. However, you must ensure that subsets meet specific criteria. **Objective**: Write a Python function `filtered_subsets(nums, min_elements, max_elements)` that returns a list of all subsets where the size of each subset is between `min_elements` and `max_elements` inclusive. Input - `nums` (List[int]): A list of distinct integers. - `min_elements` (int): Minimum number of elements in each subset. - `max_elements` (int): Maximum number of elements in each subset. Output - List[List[int]]: All subsets of `nums` containing between `min_elements` and `max_elements` elements. Constraints - 1 ≤ len(nums) ≤ 10 - min_elements ≥ 0 - max_elements ≤ len(nums) - min_elements ≤ max_elements Example ```python # Example 1 nums = [1, 2, 3] min_elements = 1 max_elements = 2 filtered_subsets(nums, min_elements, max_elements) # Output: [[1], [2], [3], [1,2], [1,3], [2,3]] # Example 2 nums = [4, 5, 6] min_elements = 2 max_elements = 2 filtered_subsets(nums, min_elements, max_elements) # Output: [[4, 5], [4, 6], [5, 6]] ``` Guidelines Your implementation should: - Utilize either backtracking or iterative approach to generate subsets. - Filter the subsets based on their length. - Handle edge cases where `min_elements` is 0 (in which case empty set should be considered) or `max_elements` equals the length of `nums` (in which case a full set should be considered). Performance Requirements - Optimize the implementation to handle the worst-case scenario efficiently within the given constraints.","solution":"from itertools import combinations def filtered_subsets(nums, min_elements, max_elements): Generates all subsets of nums containing between min_elements and max_elements. Args: nums (List[int]): A list of distinct integers. min_elements (int): Minimum number of elements in each subset. max_elements (int): Maximum number of elements in each subset. Returns: List[List[int]]: A list of all subsets satisfying the constraints. result = [] for i in range(min_elements, max_elements+1): result.extend(combinations(nums, i)) return [list(subset) for subset in result]"},{"question":"Question Given an encoded string, decode it following the encoding rules and return the decoded string. **Encoding Rule**: 1. The encoded string uses the format k[encoded_string], where the encoded string inside the square brackets is repeated exactly k times. 2. \'k\' is always a positive integer. **Assumptions**: 1. The input string is always valid and well-formed. 2. Digits in the input string are solely representing repeat numbers, and there are no digits in the original encoded strings (no input like `3a` or `2[4]`). # Function Signature ```python def decode_string(s: str) -> str: pass ``` # Input - `s` (str): An encoded string. # Output - `str`: The decoded string. # Constraints - 1 ≤ len(s) ≤ 30,000. - All encoding structures are properly nested and well-formed. # Example ```python # Input: s = \\"3[a]2[bc]\\" # Output: \\"aaabcbc\\" # Input: s = \\"3[a2[c]]\\" # Output: \\"accaccacc\\" # Input: s = \\"2[abc]3[cd]ef\\" # Output: \\"abcabccdcdcdef\\" ``` # Explanation 1. In the first example, \\"3[a]2[bc]\\" decodes to three \'a\'s followed by two \'bc\'s, resulting in \\"aaabcbc\\". 2. In the second example, \\"3[a2[c]]\\" decodes to three \'a\' followed by two \'c\'s, forming \\"accaccacc\\". 3. In the third example, \\"2[abc]3[cd]ef\\" decodes to two \'abc\'s and three \'cd\'s followed by \'ef\', producing \\"abcabccdcdcdef\\". Implement the function `decode_string` to meet the above specifications.","solution":"def decode_string(s: str) -> str: Decodes the encoded string according to the specified encoding rules. stack = [] current_string = \'\' current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Scenario You are working on a software project that needs to sort a list of numerical values. While your team typically uses efficient sorting algorithms like Quick Sort or Merge Sort, for educational purposes, you have decided to explore simpler algorithms and their implementations. # Task Write a function `optimized_cocktail_shaker_sort` to sort a list of integers using the Cocktail Shaker Sort algorithm, but with an added feature to skip over sections of the list that are already sorted to potentially improve performance. # Specifications * Implement `optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]` in Python. * Input: A list of integers `arr` of size N (1 ≤ N ≤ 1000). * Output: A sorted list of integers in ascending order. # Constraints * Try to minimize the number of comparisons and swaps as much as possible. * Consider scenarios where the list might already be partially sorted or fully sorted. # Example ```python >>> optimized_cocktail_shaker_sort([5, 1, 4, 2, 8, 0, 2]) [0, 1, 2, 2, 4, 5, 8] >>> optimized_cocktail_shaker_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> optimized_cocktail_shaker_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] ``` # Hints 1. Use a flag to track if any swapping occurred during a pass. 2. Consider marking the bounds where sorting needs to be checked in each iteration to avoid redundant comparisons.","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers using an optimized version of Cocktail Shaker Sort. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Backward pass for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Question You are tasked with implementing a function that verifies and corrects the transformation functions of a given matrix. Specifically, your function should accept a transformation type (e.g., rotate clockwise, rotate counterclockwise) and return the correctly transformed matrix based on the provided matrix. # Function Signature ```python def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: pass ``` # Input 1. `matrix`: A 2D list of integers representing the matrix to be transformed. 2. `transformation`: A string indicating the type of transformation to be applied. Possible values are `\'rotate_clockwise\'`, `\'rotate_counterclockwise\'`, `\'top_left_invert\'`, and `\'bottom_left_invert\'`. # Output The function should return a 2D list representing the transformed matrix. # Constraints - The matrix can have dimensions `m x n` where `1 ≤ m, n ≤ 100`. - The values in the matrix will be integers between `0` and `1,000`. # Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert transform_matrix(matrix, \'rotate_clockwise\') == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] assert transform_matrix(matrix, \'rotate_counterclockwise\') == [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] assert transform_matrix(matrix, \'top_left_invert\') == [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert transform_matrix(matrix, \'bottom_left_invert\') == [ [9, 8, 7], [6, 5, 4], [3, 2, 1], ] ``` # Note - The \'top_left_invert\' in the example coincidentally remains the same as the original. Make sure the implementation handles the logic as discussed in the algorithm analysis section.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: if transformation == \'rotate_clockwise\': # Transpose and then reverse each row return [list(row) for row in zip(*matrix[::-1])] elif transformation == \'rotate_counterclockwise\': # Transpose each row of reversed matrix return [list(row) for row in zip(*matrix)][::-1] elif transformation == \'top_left_invert\': m = len(matrix) n = len(matrix[0]) for i in range(m): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix elif transformation == \'bottom_left_invert\': # Rotate 180 degrees return [row[::-1] for row in matrix[::-1]] else: raise ValueError(f\\"Unknown transformation: {transformation}\\")"},{"question":"Flatten Nested Arrays Context: You work with data that frequently includes nested lists (arrays) with variable depths. To standardize processing, you need a function that flattens these nested structures into a single list. # Objective: Implement two functions: one to produce a flat list from a nested array, and another to do the same but as an iterator for memory efficiency. # Function Specifications: 1. **flatten(input_arr, output_arr=None):** - **Input:** A potentially nested list `[1, [2, [3, [4, 5]]]]`. - **Output:** A flat list `[1, 2, 3, 4, 5]`. - **Constraints:** Input may include integers, floats, strings, and lists at any depth. 2. **flatten_iter(iterable):** - **Input:** A potentially nested list `[1, [2, [3, [4, 5]]]]`. - **Output:** An iterator over flat elements `1, 2, 3, 4, 5`. - **Constraints:** Generator should yield elements in a single flat sequence. # Example Case: For input `[1, [\'a\', [2, [3, \'b\']], 4], 5]`: 1. `flatten([1, [\'a\', [2, [3, \'b\']], 4], 5])` should return `[1, \'a\', 2, 3, \'b\', 4, 5]`. 2. `list(flatten_iter([1, [\'a\', [2, [3, \'b\']], 4], 5]))` should produce `[1, \'a\', 2, 3, \'b\', 4, 5]`. # Edge Cases: 1. **Empty Arrays:** `[[[[]]]]` should return `[]`. 2. **Flat Array:** `[1, 2, 3]` should return `[1, 2, 3]`. 3. **Mixed Types:** `[1, [\'string\', [2.5]]]` should return `[1, \'string\', 2.5]`. # Guidelines: - Refrain from using built-in flatten functions or libraries. - Ensure your solution handles arbitrary levels of nesting within the constraints of Python\'s recursion. - Provide test cases demonstrating edge cases and typical usage. # Input and Output Format: ```plaintext Input: A nested array e.g., [1, [2, [3, [4, 5]]]] Output: A flat array e.g., [1, 2, 3, 4, 5] OR Output: An iterator that yields flat elements in sequence. ```","solution":"def flatten(input_arr, output_arr=None): Flattens a nested list into a single list. Args: - input_arr: A potentially nested list. - output_arr: A list to accumulate the flattened elements (used for recursive calls). Returns: - A flat list with all elements from the nested structure. if output_arr is None: output_arr = [] for item in input_arr: if isinstance(item, list): flatten(item, output_arr) else: output_arr.append(item) return output_arr def flatten_iter(iterable): Flattens a nested list into a single iterator. Args: - iterable: A potentially nested list. Yields: - The next element in a flattened sequence. for item in iterable: if isinstance(item, list): yield from flatten_iter(item) else: yield item"},{"question":"# Question: Advanced GCD and LCM Calculations In this task, you\'ll work on optimizing and applying fundamental arithmetic algorithms, specifically the greatest common divisor (GCD) and the lowest common multiple (LCM). Task 1: Enhanced Euclidean GCD Function Write a function `enhanced_gcd(a: int, b: int) -> int` that calculates the GCD of two integers using the Euclidean Algorithm. Your function should handle negative inputs gracefully. If either of the inputs is zero, return the other number (since gcd(a, 0) = |a|). Task 2: Robust LCM Function Using the gcd function from Task 1, write a function `robust_lcm(a: int, b: int) -> int` that computes the LCM of two integers. Ensure your function can handle cases where one or both inputs are zero by returning an appropriate value (since lcm(a, 0) = 0). Task 3: GCD with Bitwise Operations Implement the function `bitwise_gcd(a: int, b: int) -> int`, which computes the GCD of two non-negative integers using bitwise operations. Integrate error handling to deal with cases like a = 0 or b = 0 by returning the appropriate value. Input and Output Formats * Function `enhanced_gcd(a: int, b: int) -> int`: * **Input**: Two integers, a and b. * **Output**: An integer which is the GCD of a and b. * Function `robust_lcm(a: int, b: int) -> int`: * **Input**: Two integers, a and b. * **Output**: An integer which is the LCM of a and b. * Function `bitwise_gcd(a: int, b: int) -> int`: * **Input**: Two non-negative integers, a and b. * **Output**: An integer which is the GCD of a and b. Constraints * -10^9 ≤ a, b ≤ 10^9 * For `bitwise_gcd`, both a and b are non-negative. Example ```python # Task 1 assert enhanced_gcd(48, 18) == 6 assert enhanced_gcd(-48, 18) == 6 assert enhanced_gcd(0, 18) == 18 # Task 2 assert robust_lcm(4, 5) == 20 assert robust_lcm(0, 5) == 0 assert robust_lcm(0, 0) == 0 # Task 3 assert bitwise_gcd(48, 18) == 6 assert bitwise_gcd(0, 18) == 18 assert bitwise_gcd(48, 0) == 48 ``` You should carefully consider edge cases and incorporate appropriate error handling in your solution.","solution":"def enhanced_gcd(a, b): Calculate the GCD of two integers using the Euclidean Algorithm. Return the other number if either input is zero. while b: a, b = b, a % b return abs(a) def robust_lcm(a, b): Compute the LCM of two integers using the GCD function. Return zero if either input is zero. if a == 0 or b == 0: return 0 return abs(a * b) // enhanced_gcd(a, b) def bitwise_gcd(a, b): Compute the GCD of two non-negative integers using bitwise operations. if a == 0: return abs(b) if b == 0: return abs(a) # Make both numbers positive a, b = abs(a), abs(b) shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift"},{"question":"# Question: Maximize Continuous Ones by Flipping a Zero Implement a function `max_ones_index` which finds the index of a zero in a given binary array, so that by replacing that zero with one, we can maximize the length of continuous ones in the array. Function Signature ```python def max_ones_index(arr: list) -> int: ``` Input * `arr`: A list of integers which can only be `0` or `1` (binary array). Output * Returns an integer index of the zero in the binary array `arr` which may be replaced with a one to maximize the length of continuous ones. * If there\'s no zero in the array, the function should return `-1`. Constraints * The function should handle arrays of size up to (10^6) efficiently. * The binary array contains at least one element. Example ```python # Example 1 arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] print(max_ones_index(arr)) # Output should be 3 # Example 2 arr = [1, 1, 1, 1] print(max_ones_index(arr)) # Output should be -1 # Example 3 arr = [0] print(max_ones_index(arr)) # Output should be 0 # Example 4 arr = [1, 0, 1, 1, 0] print(max_ones_index(arr)) # Output should be 1 ``` Explanation * In Example 1, replacing the 0 at index 3 with 1 gives the longest sequence of continuous ones in the array. * In Example 2, since there are no zeros, the function should return -1. * In Example 3, as it only consists of a zero, flipping it to one results in a sequence of length 1. * In Example 4, flipping the zero at index 1 to one gives two sequences of length 3 (both are valid results).","solution":"def max_ones_index(arr): Finds the index of a zero in the binary array `arr` which, if replaced by one, maximizes the length of continuous ones. max_length = 0 max_index = -1 current_length = 0 zero_index = -1 for i in range(len(arr)): if arr[i] == 1: current_length += 1 else: current_length = i - zero_index zero_index = i if current_length > max_length: max_length = current_length max_index = zero_index return max_index"},{"question":"# Scenario You have been hired as a software developer for a small company. Your manager assigned you the task of implementing a sorting feature for an array of integers in the company\'s application. The manager provided you with a simple bubble sort algorithm but mentioned that its time complexity could be a drawback for larger arrays. # Task Your task is to optimize the given bubble sort algorithm. Specifically, make sure it works efficiently for both small and large datasets. Additionally, you are asked to implement a function that verifies if an array is already sorted before performing the sort, which can significantly enhance the performance for nearly sorted arrays. # Problem Statement Complete the function `optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]`. This function should sort the given list `arr` using an optimized version of bubble sort and include the following improvements: 1. Check if the array is already sorted before starting the sorting process to avoid unnecessary passes. 2. Print the array at each iteration step if `simulation` is set to `True`. Input - A list of integers, `arr`, where `1 <= len(arr) <= 5000` and `-10^6 <= arr[i] <= 10^6`. - A boolean, `simulation`, default is `False`. Output - A sorted list of integers. Constraints 1. Time complexity should preferably remain O(N) for already sorted arrays. 2. The function should handle large lists efficiently (up to 5000 elements). 3. Space complexity should remain O(1). # Example ```python optimized_bubble_sort([5, 2, 9, 1, 5, 6], simulation=False) # Output: [1, 2, 5, 5, 6, 9] optimized_bubble_sort([1, 2, 3, 4, 5], simulation=False) # Output: [1, 2, 3, 4, 5], no swaps should occur. ``` # Notes - You need to use the provided bubble sort template and improvements should be added on that. - Ensure that your algorithm prints the array state at each iteration step correctly when `simulation` is `True`.","solution":"from typing import List def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array using an optimized bubble sort algorithm and prints the array at each iteration step if simulation is True. :param arr: List of integers to sort. :param simulation: If True, print array at each iteration. :return: Sorted list of integers. n = len(arr) # Step 1: Check if already sorted already_sorted = True for i in range(n - 1): if arr[i] > arr[i + 1]: already_sorted = False break if already_sorted: return arr # Step 2: Optimized bubble sort for i in range(n): swapped = False for j in range(n - 1 - i): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: print(arr) if not swapped: break return arr"},{"question":"# Context You are given a stochastic simulator that models random state transitions based on given probabilities. The transition map of the Markov chain is provided as a nested dictionary with states as keys and their corresponding transition probabilities to other states. # Task Implement a function `predict_next_state(chain, state, steps)` that takes a Markov chain, an initial state, and the number of steps to simulate, and returns the state after simulating the given number of transitions. Ensure your implementation handles edge cases, such as invalid probabilities and states with no outgoing transitions. # Input 1. `chain` (dict): The Markov transition map. 2. `state` (str): The initial state. 3. `steps` (int): The number of state transitions to simulate. # Output 1. `final_state` (str): The state after the given number of transitions. # Constraints 1. The provided chain will have at least one state. 2. Transition probabilities for each state will sum to 1 within a tolerance due to floating-point arithmetic. 3. You may assume that the initial state provided exists in the chain. 4. 1 ≤ steps ≤ 10^5 # Performance Requirements - Ensure your solution efficiently handles up to 10^5 steps. # Example ```python # Example chain chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } # Given initial state \'A\' and 10 transitions # One possible output could be \'A\' assert predict_next_state(chain, \'A\', 10) == \'A\' # Depending on randomness in transitions ```","solution":"import random def predict_next_state(chain, state, steps): Simulate the number of state transitions on a given Markov chain to predict the state after a given number of steps. Parameters: - chain (dict): The Markov transition map. - state (str): The initial state. - steps (int): The number of state transitions to simulate. Returns: - final_state (str): The state after the given number of transitions. for _ in range(steps): if state not in chain or not chain[state]: break transitions = chain[state] states, probabilities = zip(*transitions.items()) state = random.choices(states, probabilities)[0] return state"},{"question":"**Title**: Implement an Optimized and Flexible Palindrome Checker # Objective Write a function `is_flexible_palindrome(s, method)` that determines if the input string `s` is a palindrome based on the specified `method`. Your function should handle different techniques as specified and be able to choose the most space and time-efficient variation applicable. # Requirements * Function Signature: `def is_flexible_palindrome(s: str, method: str) -> bool` * Input: - `s` (str): The input string to check. - `method` (str): The method to use for checking, one of `\\"original\\"`, `\\"reverse\\"`, `\\"two-pointer\\"`, `\\"stack\\"`, `\\"deque\\"`. * Output: - Return `True` if the input string `s` is a palindrome based on the specified `method`, otherwise `False`. # Constraints * The input string `s` can contain any printable ASCII characters. * A valid method must be one of the provided strings. # Implementation Guidelines 1. **Original Method**: Use the base method with two pointers iterating from the edges inward. 2. **Reverse Method**: Check palindrome by comparing the cleaned string with its reversed version. 3. **Two-pointer Method**: Use a two-pointer technique to compare characters from the start and the end. 4. **Stack Method**: Use a stack to help with character comparison. 5. **Deque Method**: Use a deque to facilitate character comparison from both ends. # Example Usage ```python assert is_flexible_palindrome(\\"A man, a plan, a canal: Panama\\", \\"original\\") == True assert is_flexible_palindrome(\\"race a car\\", \\"reverse\\") == False assert is_flexible_palindrome(\\"abba\\", \\"two-pointer\\") == True ``` # Edge Cases to Consider 1. An empty string should return `True`. 2. Strings with only non-alphanumeric characters should return `True`. 3. Mixed case strings should be treated case insensitively. # Notes - Include helper functions if needed. - Ensure that your implementation is efficient, and document any assumptions.","solution":"def is_flexible_palindrome(s: str, method: str) -> bool: def clean_string(s): return \'\'.join(c.lower() for c in s if c.isalnum()) def original_method(s): cleaned = clean_string(s) return cleaned == cleaned[::-1] def reverse_method(s): cleaned = clean_string(s) reversed_s = \'\'.join(reversed(cleaned)) return cleaned == reversed_s def two_pointer_method(s): cleaned = clean_string(s) left, right = 0, len(cleaned) - 1 while left < right: if cleaned[left] != cleaned[right]: return False left += 1 right -= 1 return True def stack_method(s): from collections import deque cleaned = clean_string(s) stack = deque(cleaned) while len(stack) > 1: if stack.popleft() != stack.pop(): return False return True def deque_method(s): from collections import deque cleaned = clean_string(s) dq = deque(cleaned) while len(dq) > 1: if dq.popleft() != dq.pop(): return False return True if method == \\"original\\": return original_method(s) elif method == \\"reverse\\": return reverse_method(s) elif method == \\"two-pointer\\": return two_pointer_method(s) elif method == \\"stack\\": return stack_method(s) elif method == \\"deque\\": return deque_method(s) else: raise ValueError(f\\"Invalid method: {method}\\")"},{"question":"Abbreviation Generation Objective You are required to implement a function that generates all possible abbreviations of a given word. Function Signature ```python def generate_abbreviations(word: str) -> List[str]: ``` Input - `word`: a non-empty string (1 ≤ |word| ≤ 15), containing only lowercase English letters. Output - Return a list of all possible abbreviations of the given word. Example ```python assert generate_abbreviations(\\"word\\") == [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] ``` Constraints - All characters in the word are lowercase English letters. - The length of the word will not exceed 15. Requirements - Consider all possible abbreviations, including those that skip multiple letters or no letters. - Ensure that the generated abbreviations are in lexicographically sorted order. - Maintain efficiency given the constraints on input size. Hints - Utilize a backtracking approach to explore both choices of including the character in the abbreviation and skipping it in favor of a count. Scenario Imagine you are designing a URL shortening service where you need to generate short forms of given words. Each word can be represented in multiple abbreviated forms, and you need to efficiently generate all possible options.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(position: int, current: str, count: int): if position == len(word): abbreviation = current + (str(count) if count > 0 else \\"\\") result.append(abbreviation) else: # Skip the current character backtrack(position + 1, current, count + 1) # Include the current character backtrack(position + 1, current + (str(count) if count > 0 else \\"\\") + word[position], 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"Generate All Subsets Objective Given a set of distinct integers, you need to generate all possible subsets of the given set. The solution must include all subsets, including the empty one, without any duplicates. Task Write a function `generate_subsets(nums)` that takes a list of distinct integers `nums` and returns a list of lists, each representing a unique subset of `nums`. Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` Input: * A list of distinct integers `nums` where ( 0 leq text{len}(nums) leq 16 ) and ( -100 leq text{nums[i]} leq 100 ). Output: * A list of lists, where each inner list is a subset of `nums`. Example: ```python assert set(map(frozenset, generate_subsets([1, 2, 3]))) == { frozenset([]), frozenset([1]), frozenset([2]), frozenset([3]), frozenset([1, 2]), frozenset([1, 3]), frozenset([2, 3]), frozenset([1, 2, 3]) } ``` Constraints: * The solution set must not contain duplicate subsets. * The subsets within the solution set can be in any order. Additional Notes: * Ensure that your solution is optimized for both time and space as per the given constraints. * Consider boundary cases such as empty input list and single-element lists.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of a list of distinct integers. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"The challenge is to implement an encoding and decoding mechanism using the integer base conversion algorithms discussed above. Scenario You are designing a URL shortening service like bit.ly. Your task is to encode an integer ID to a shortened string using a higher base (e.g., base 62), which includes digits, lowercase, and uppercase letters. Similarly, you need to decode the shortened string back to the integer ID. Function Definitions 1. **Encoding Function** - **Input**: An integer `id` and base value `base` (integer, between 2 and 62). - **Output**: A shortened string representing the `id`. - **Signature**: `def encode_id(id: int, base: int) -> str:` 2. **Decoding Function** - **Input**: A shortened string `shortened` and base value `base` (integer, between 2 and 62). - **Output**: The original integer `id`. - **Signature**: `def decode_id(shortened: str, base: int) -> int:` Hint Utilize the `int_to_base` and `base_to_int` functions provided above to implement these functionalities. Examples ```python assert encode_id(125, 62) == \'21\' assert decode_id(\'21\', 62) == 125 assert encode_id(99999, 62) == \'q0T\' assert decode_id(\'q0T\', 62) == 99999 ``` Constraints & Performance - The `id` will be a non-negative integer. - The base will be an integer between 2 and 62, inclusive. - Your solution should handle up to 10^12 as the maximum `id` efficiently. Implement the two functions, ensuring to handle edge cases and adhering to the constraints given.","solution":"import string # Characters used for encoding ALPHABET = string.digits + string.ascii_letters def encode_id(id: int, base: int) -> str: Encodes an integer ID to a shortened string using the given base. if id == 0: return ALPHABET[0] result = [] while id > 0: result.append(ALPHABET[id % base]) id //= base result.reverse() return \'\'.join(result) def decode_id(shortened: str, base: int) -> int: Decodes a shortened string back to the integer ID using the given base. id = 0 for char in shortened: id = id * base + ALPHABET.index(char) return id"},{"question":"# Path/URL Joiner You are given a utility function that combines a base path or URL with a suffix, ensuring that the resulting path does not contain redundant slashes where the base and suffix meet. Write a function `join_with_slash` that accepts two parameters: 1. `base` (str): A base path or URL. 2. `suffix` (str): A suffix path or URL part. Your function should: 1. Strip any trailing slashes from the base. 2. Strip any leading and trailing slashes from the suffix. 3. Combine the base and suffix with a single slash between them. 4. Return the correctly combined path or URL. Input - `base`: a string representing the base path or URL. - `suffix`: a string representing the suffix path or URL part. Output - A string representing the correctly combined path or URL. Constraints - The base can be an empty string. - The suffix can be an empty string. - Assume the inputs will not contain any space characters. - Uniform Resource Identifiers (URIs) follow typical structure rules (e.g., no special characters unless defined by the URI specs). # Examples 1. `join_with_slash(\\"path/to/dir\\", \\"file\\")` should return `\\"path/to/dir/file\\"` 2. `join_with_slash(\\"http://algorithms.com\\", \\"part\\")` should return `\\"http://algorithms.com/part\\"` 3. `join_with_slash(\\"path/to/dir/\\", \\"/file\\")` should return `\\"path/to/dir/file\\"` 4. `join_with_slash(\\"\\", \\"file\\")` should return `\\"file\\"` 5. `join_with_slash(\\"path/to/dir\\", \\"\\")` should return `\\"path/to/dir\\"` 6. `join_with_slash(\\"\\", \\"\\")` should return `\\"\\"` Function Signature ```python def join_with_slash(base: str, suffix: str) -> str: # Your code here ```","solution":"def join_with_slash(base: str, suffix: str) -> str: Combines a base path or URL with a suffix, ensuring no redundant slashes exist. base = base.rstrip(\'/\') suffix = suffix.strip(\'/\') if base and suffix: return f\\"{base}/{suffix}\\" elif base: return base else: return suffix"},{"question":"# FizzBuzz Customization Problem Statement Write a function `custom_fizzbuzz(n, x, y)` that generates a list of numbers from 1 to N with the following modifications: 1. Replace numbers that are multiples of `x` with \'Fizz\'. 2. Replace numbers that are multiples of `y` with \'Buzz\'. 3. Replace numbers that are multiples of both `x` and `y` with \'FizzBuzz\'. Requirements * **Function Signature**: `def custom_fizzbuzz(n: int, x: int, y: int) -> list:` * **Parameters**: - `n` (int): The upper bound of the range. Must be greater than or equal to 1. - `x` (int): The divisor for \'Fizz\'. Must be greater than or equal to 1. - `y` (int): The divisor for \'Buzz\'. Must be greater than or equal to 1. * **Returns**: List of integers and strings, where integers from 1 to N are replaced accordingly by the rules. Constraints * 1 ≤ N ≤ 10^4 * 1 ≤ x, y ≤ 100 Expected Output * A list of size N filled with integers and strings according to their divisibility by `x` and `y`. Example Scenario If called with arguments `n=15`, `x=3`, and `y=5`: * **Input**: `custom_fizzbuzz(15, 3, 5)` * **Output**: `[1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\']` Edge Cases to Consider * The smallest value of N (`n=1`). * Divisors that are equal (`x=y`). * Large values approaching upper constraint.","solution":"def custom_fizzbuzz(n, x, y): Generates a list from 1 to n with modifications: - Replace multiples of x with \'Fizz\' - Replace multiples of y with \'Buzz\' - Replace multiples of both x and y with \'FizzBuzz\' Parameters: n (int): The upper bound of the range. x (int): The divisor for \'Fizz\'. y (int): The divisor for \'Buzz\'. Returns: list: Modified list according to the rules. result = [] for i in range(1, n + 1): if i % x == 0 and i % y == 0: result.append(\'FizzBuzz\') elif i % x == 0: result.append(\'Fizz\') elif i % y == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Question: Stutter Stack Elements You are tasked with implementing a function that takes a stack (represented as a Python list) and stutters its elements, such that each element is duplicated in place. You need to provide two implementations: 1. Using a single auxiliary stack (list). 2. Using a single auxiliary queue (collections.deque). # Constraints - Input stack will contain integers. - You are not allowed to use any other external libraries or data structures except for basic ones. - Solutions must maintain the order of elements as seen from the bottom to the top of the stack. - You should handle edge cases like an empty stack. # Performance Requirements - Ensure your solution works efficiently for stacks containing up to 10^5 elements. # Function Signature ```python def first_stutter(stack: list) -> list: # your code here def second_stutter(stack: list) -> list: # your code here ``` # Examples **Input**: ```python stack = [3, 7, 1, 14, 9] ``` **Output**: ```python # Both functions should return: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` **Input**: ```python stack = [] ``` **Output**: ```python # Both functions should return an empty list: [] ``` # Explanation - For a stack [3, 7, 1, 14, 9], after the stutter operations are applied, the elements should be duplicated maintaining their original order, resulting in [3, 3, 7, 7, 1, 1, 14, 14, 9, 9]. - For an empty input stack, the resulting stack should also be empty. Implement and test both of your functions to ensure correctness and efficiency.","solution":"def first_stutter(stack: list) -> list: This function duplicates each element in the stack using an auxiliary stack. if not stack: return [] aux_stack = [] original_size = len(stack) # Reverse the original stack onto the auxiliary stack while stack: aux_stack.append(stack.pop()) # Stutter elements back onto the original stack while aux_stack: element = aux_stack.pop() stack.append(element) stack.append(element) return stack from collections import deque def second_stutter(stack: list) -> list: This function duplicates each element in the stack using an auxiliary queue. if not stack: return [] queue = deque() # Transfer elements to the queue to keep the original order while stack: queue.appendleft(stack.pop()) # Stutter elements back onto the stack using the queue while queue: element = queue.popleft() stack.append(element) stack.append(element) return stack"},{"question":"# Postorder Traversal of a Binary Tree Problem Statement Given the root of a binary tree, implement a function that performs a postorder traversal of the tree and returns a list of node values in postorder sequence. Specifications: 1. **Function Signature**: ```python def postorder_traversal(root: Node) -> List[int]: ``` 2. **Input**: - `root`: The root node of a binary tree (or `None` if the tree is empty). 3. **Output**: - A list of integers representing the node values in postorder sequence. 4. **Constraints**: - The number of nodes in the tree is in the range `[0, 10^4]`. - The value of each node is an integer in the range `[-10^5, 10^5]`. Examples: 1. Example 1: - Input: ```plaintext 1 2 / 3 ``` - Output: `[3, 2, 1]` 2. Example 2: - Input: ```plaintext None ``` - Output: `[]` 3. Example 3: - Input: ```plaintext 4 / 5 6 ``` - Output: `[5, 6, 4]` Key Considerations: - Ensure that both implementations (iterative and recursive) handle all possible edge cases like an empty tree, a single node tree, and differently structured trees without ambiguity. - Optimize for both time and space where possible. - Do not use any external libraries.","solution":"class Node: def __init__(self, val: int): self.val = val self.left = None self.right = None def postorder_traversal(root: Node) -> list[int]: Function to perform a postorder traversal of a binary tree. if root is None: return [] result = [] def dfs(node: Node): if not node: return dfs(node.left) dfs(node.right) result.append(node.val) dfs(root) return result"},{"question":"# Objective Write a function that identifies the index of a 0 in a given binary array that, if replaced with a 1, will produce the longest continuous sequence of 1s. Your solution should demonstrate understanding of sliding window techniques for efficient subarray calculations. # Function Signature ```python def find_optimal_index(binary_array: List[int]) -> int: Finds the index of a 0 to replace with a 1 that results in the longest continuous sequence of 1s in the binary array. Parameters: binary_array (List[int]): A list of integers containing only 0s and 1s. Returns: int: The index of the 0 that should be replaced. If no such index exists, return -1. pass ``` # Input - **binary_array**: A list of integers `[0, 1]` representing a binary array. Length (1 leq text{len(binary_array)} leq 10^6). # Output - An integer representing the index of the 0 to be replaced to achieve the longest continuous sequence of 1s. If no index is suitable or the all elements are 1, return -1. # Constraints - You may only iterate through the array once. - Your solution must run in O(n) time complexity and use O(1) additional space. # Examples 1. Input: `[1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]` Output: `3` 2. Input: `[1, 1, 1, 1]` Output: `-1` 3. Input: `[0, 0, 0, 0]` Output: `0` 4. Input: `[]` Output: `-1` # Description Implement the function `find_optimal_index` to solve the given problem by deploying a sliding window approach. Ensure your function correctly handles edge cases and is efficient in terms of both time and space complexity.","solution":"from typing import List def find_optimal_index(binary_array: List[int]) -> int: max_len = 0 max_index = -1 current_len = 0 prev_zero_index = -1 prev_len = 0 for i, num in enumerate(binary_array): if num == 1: current_len += 1 else: if prev_zero_index != -1: if (current_len + prev_len + 1) > max_len: max_len = current_len + prev_len + 1 max_index = prev_zero_index prev_len = current_len current_len = 0 prev_zero_index = i if prev_zero_index != -1: if (current_len + prev_len + 1) > max_len: max_len = current_len + prev_len + 1 max_index = prev_zero_index if max_index == -1 and 0 in binary_array: return binary_array.index(0) return max_index"},{"question":"Given a number `n`, write a program to compute the nth Fibonacci number using an iterative approach. The function should be efficient in terms of both time and space. # Function Signature ```python def fibonacci(n: int) -> int: # Your implementation here ``` # Input - An integer `n` where `0 <= n <= 10^5` # Output - An integer representing the nth Fibonacci number. # Constraints - Ensure your solution runs efficiently within the limits. - Handle edge cases, such as `n = 0` and `n = 1` properly. # Example 1. Input: `n=10` - Output: `55` 2. Input: `n=0` - Output: `0` # Notes - The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 # Hints - Think about how you can iteratively compute the Fibonacci number using a loop.","solution":"def fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Scenario: You are working on a messaging system where you need to send a list of messages over a network and then reconstruct them on the receiving end. To ensure that you can accurately reconstruct the original list of messages, you create a custom encoding and decoding mechanism. # Task: Implement the functions `encode` and `decode`: 1. **encode**: This function receives a list of strings and encodes it into a single string. 2. **decode**: This function receives a single encoded string and decodes it back into a list of strings. # Implementation Details: * Each string in the encoded format will be prefixed by its length and a colon. * The format of the encoded string will be: `\\"len1:string1len2:string2...\\"`. # Function Signature: ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. # Your implementation here def decode(s: str) -> List[str]: Decodes a single string to a list of strings. # Your implementation here ``` # Constraints: * The input list for encoding will contain at most `10^5` strings. * Each individual string can have a length ranging from `0` to `10^4` characters. * The total length of all strings combined will not exceed `10^6` characters. # Examples: ```python # Example Usage encoded = encode([\\"hello\\", \\"world\\"]) print(encoded) # Output: \\"5:hello5:world\\" decoded = decode(encoded) print(decoded) # Output: [\\"hello\\", \\"world\\"] # Edge Case encoded = encode([\\"\\"]) print(encoded) # Output: \\"0:\\" decoded = decode(encoded) print(decoded) # Output: [\\"\\"] ``` # Performance Requirements: * The implementation should efficiently handle the constraints and edge cases as specified.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_str = \'\' for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. decoded_strs = [] i = 0 while i < len(s): colon_idx = s.find(\':\', i) length = int(s[i:colon_idx]) i = colon_idx + 1 decoded_strs.append(s[i:i + length]) i += length return decoded_strs"},{"question":"Fast Insert Position in Sorted Array **Context**: In many applications, elements need to be inserted into a sorted array while maintaining the sorted order. A typical approach involves linear searching for the correct position, but this can be inefficient. A more efficient approach is to use binary search to find the correct insertion point. **Task**: Write a function `find_insert_position(sorted_array, target)` that takes a sorted list of integers `sorted_array` and an integer `target`. The function should return the index at which `target` should be inserted in order to keep `sorted_array` sorted. **Input**: - `sorted_array`: A list of integers, sorted in ascending order. - `target`: An integer value to be inserted. **Output**: - An integer representing the index at which `target` should be inserted in `sorted_array`. **Constraints**: - All integers in `sorted_array` and the `target` are between -10^5 and 10^5. - The length of `sorted_array` is between 0 and 10^5. **Examples**: ``` find_insert_position([1, 3, 5, 6], 5) -> 2 find_insert_position([1, 3, 5, 6], 2) -> 1 find_insert_position([1, 3, 5, 6], 7) -> 4 find_insert_position([1, 3, 5, 6], 0) -> 0 find_insert_position([], 4) -> 0 ``` **Implementation Notes**: - Handle edge cases such as an empty `sorted_array`. - Think about time complexity and aim for an O(log n) solution using binary search. **Function Signature**: ```python def find_insert_position(sorted_array: List[int], target: int) -> int: # Your code here ```","solution":"from typing import List def find_insert_position(sorted_array: List[int], target: int) -> int: Returns the index at which the target should be inserted in sorted_array to maintain the sorted order. left, right = 0, len(sorted_array) while left < right: mid = (left + right) // 2 if sorted_array[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"# Problem: Optimized Bubble Sort You are given the Bubble Sort algorithm, which has a high time complexity of O(n^2) in its average and worst case. Your objective is to enhance this Bubble Sort algorithm with optimizations that address its inefficiencies. # Task Implement an optimized version of Bubble Sort with the following improvements: 1. **Early Exit Optimization**: Implement logic to detect if the array is already sorted and exit early to avoid unnecessary passes. 2. **Bidirectional Bubble Sort (Cocktail Shaker Sort)**: Modify the bubble_sort function to perform bi-directional passes to limit the number of comparisons and swaps. This modification can help in efficiently sorting arrays with a large number of elements closer to their correct positions. # Function Signature ```python def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input * `arr`: A list of integers that needs to be sorted. `1 <= len(arr) <= 10^5` * `simulation`: Boolean flag indicating whether to print the status of the array after each pass for the sake of visualization (default is `False`). # Output * Return the sorted list of integers. # Constraints * Ensure the code handles edge cases like already sorted arrays, arrays in reverse order, all elements being the same, and empty arrays. * The solution should handle large datasets efficiently in reasonable time. # Performance Requirements * The optimized solution should perform better than the naive bubble sort on nearly sorted arrays. * Ensure the space complexity remains O(1). # Example ```python In: optimized_bubble_sort([5, 1, 4, 2, 8], True) Out: iteration 0 : 1 4 2 5 8 iteration 1 : 1 2 4 5 8 iteration 2 : 1 2 4 5 8 In: optimized_bubble_sort([5, 1, 4, 2, 8], False) Out: [1, 2, 4, 5, 8] In: optimized_bubble_sort([1, 2, 3, 4, 5], False) Out: [1, 2, 3, 4, 5] In: optimized_bubble_sort([ ], False) Out: [ ] ``` Write your implementation of the optimized bubble sort in the function `optimized_bubble_sort`.","solution":"from typing import List def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Performs an optimized bubble sort with early exit and bidirectional passes. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 iteration = 0 while start < end: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") iteration += 1 # If no two elements were swapped by inner loop, then the array is sorted if not swapped: break end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i - 1] > arr[i]: arr[i - 1], arr[i] = arr[i], arr[i - 1] swapped = True if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") iteration += 1 if not swapped: break start += 1 return arr"},{"question":"Anagram Checker with One Pass Hash Table Optimization # Scenario You\'re working on a text analysis application where one of the features allows users to check if two given strings are anagrams. An anagram is defined as a word or phrase formed by rearranging the letters of another, typically using all original letters exactly once. # Task Write a function `is_optimized_anagram(s: str, t: str) -> bool` that determines if two strings `s` and `t` are anagrams of each other. # Requirements * The function should use a single hash table for frequency counting. * Only lowercase English letters are allowed. * The function should optimize space usage and be performant in terms of time complexity. # Inputs and Outputs * **Input**: * `s` (str): The first string. * `t` (str): The second string. * **Output**: * `bool`: True if `t` is an anagram of `s`, otherwise False. # Constraints * The length of both strings will be in the range [0, 10^5]. # Examples 1. `is_optimized_anagram(\\"anagram\\", \\"nagaram\\")` should return `True`. 2. `is_optimized_anagram(\\"rat\\", \\"car\\")` should return `False`. 3. `is_optimized_anagram(\\"\\", \\"\\")` should return `True`. # Notes * Pay attention to edge cases such as differing lengths and empty strings. * Ensure the implementation is efficient and handles large input sizes within the given constraints. # Function Signature ```python def is_optimized_anagram(s: str, t: str) -> bool: pass ```","solution":"def is_optimized_anagram(s: str, t: str) -> bool: Determines if two strings s and t are anagrams of each other using a single hash table. if len(s) != len(t): return False # Create a frequency dictionary freq = {} # Count frequency of each character in s and decrement for each character in t for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 for char in t: if char in freq: freq[char] -= 1 else: return False # Check the frequency dictionary for any non-zero values for count in freq.values(): if count != 0: return False return True"},{"question":"# Bogo sort deluxe Bogo Sort is an entertaining but impractically inefficient sorting algorithm that shuffles the elements randomly until they are sorted. Your task is to implement a modified version of Bogo Sort -- `bogo_sort_deluxe`, that adds a counter and stops after a predetermined number of shuffles to provide a graceful exit in case of excessive shuffles. # Your task: 1. **Function Name**: `bogo_sort_deluxe` 2. **Input**: - `arr`: A list of integers to sort. - `max_shuffles`: An integer that provides a limit for the number of shuffles before the function terminates. 3. **Output**: - If the array is sorted within `max_shuffles`, return the sorted array. - If the array cannot be sorted within `max_shuffles`, return `None`. 4. **Constraints**: - The list `arr` can have up to `1000` elements. - All elements of `arr` are integers within the range `-10^6` to `10^6`. - The integer `max_shuffles` is positive and greater than zero. 5. **Performance**: The solution must handle the constraints effectively, keeping in mind the extremely inefficient nature of Bogo Sort. # Example: ```python arr = [3, 2, 1] max_shuffles = 1000 # Possible returns # [1, 2, 3] (if sorted within 1000 shuffles) # None (if not sorted within 1000 shuffles) ``` **Note**: 1. Use the helper function to check if the array is sorted. 2. If the array gets sorted before the shuffle limit, return the sorted array. 3. If the shuffle limit is reached before the array sorts, terminate the function and return `None`. # Implementation: Implement the function `bogo_sort_deluxe`.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted in ascending order return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def bogo_sort_deluxe(arr, max_shuffles): Bogo Sort Deluxe which shuffles the array randomly until it is sorted or the number of shuffles exceeds max_shuffles. shuffle_count = 0 while shuffle_count < max_shuffles: if is_sorted(arr): return arr random.shuffle(arr) shuffle_count += 1 return None"},{"question":"Objective: You are provided with a stack and need to replace every value in the stack with two occurrences of that value using an auxiliary data structure. Implement a function to achieve the desired transformation. Function Signature: ```python def duplicate_stack_elements(stack: List[int]) -> List[int]: pass ``` Input: - `stack`: A list of integers representing the stack with the bottom at index 0. Output: - A list of integers with each element in the original stack duplicated. Constraints: - The stack will have at most 1000 elements. - Each element in the stack will be an integer between -1000 and 1000. Example: ```python # Given the stack original_stack = [3, 7, 1, 14, 9] # After processing, it should be result_stack = duplicate_stack_elements(original_stack) # with the result being # [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Requirements: - Ensure the final stack maintains the original order but with duplicated elements. - Aim for an implementation that efficiently handles the stack operations. - Use either an auxiliary stack or a queue as intermediate storage. Edge Cases to Handle: - An empty stack should result in an empty stack. - A stack with a single element should duplicate that element.","solution":"from typing import List def duplicate_stack_elements(stack: List[int]) -> List[int]: This function takes a stack represented as a list of integers and replaces every value in the stack with two occurrences of that value. :param stack: List[int] - A list representing the stack, where the bottom of the stack is at index 0. :return: List[int] - A list representing the transformed stack with each element duplicated aux_stack = [] while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) result_stack = [] while aux_stack: result_stack.append(aux_stack.pop()) return result_stack"},{"question":"Scenario Given a binary search tree (BST), transform it into a sorted Doubly Linked List (DLL) where each tree node\'s `left` pointer indicates the previous node and `right` pointer indicates the next node. You are required to implement this transformation maintaining in-order traversal order of the BST. Task Write a function `bin_tree_to_sorted_dll(root: TreeNode) -> TreeNode` to achieve the described functionality. Additionally, write a utility function `print_dll(head: TreeNode)` that prints the values of the doubly linked list starting from the head node. Input and Output Formats - **Input**: - `root` (TreeNode): The root node of a binary search tree. Each node contains an integer value, a `left` pointer, and a `right` pointer. - **Output**: - Returns the head node of a doubly linked list. Constraints - Valid binary search tree properties are guaranteed. - The values in the binary search tree nodes are unique. - The number of nodes will be in the range [0, 10^5]. Performance Requirements - The solution must run in O(N) time complexity. - The solution must use O(H) auxiliary space, where H is the height of the tree due to recursion, or equivalent iterative constraint. Example ``` Input: 4 / 2 5 / 1 3 Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Note that the values should be printed in ascending order for the doubly linked list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_sorted_dll(root: TreeNode) -> TreeNode: Convert a Binary Search Tree to a doubly linked list. if not root: return None # Helper function to perform the conversion. def convert(node): nonlocal last, first if node: # Recursively convert the left subtree convert(node.left) # Now deal with the current node if last: # Link the previous node (last) # with the current one (node) last.right = node node.left = last else: # This is the leftmost node first = node last = node # Recursively convert the right subtree convert(node.right) first, last = None, None convert(root) return first def print_dll(head: TreeNode): Print the values of the doubly linked list starting from the head node. while head: print(head.val, end=\\" <-> \\" if head.right else \\"\\") head = head.right print() # for newline at the end"},{"question":"You have been given an array of non-negative integers. Your task is to implement the `comb_sort` function to sort the array in non-decreasing order using the Comb Sort algorithm. Write a function `comb_sort(arr: List[int]) -> List[int]` that takes a list of integers as input and returns the sorted list. # Function Signature ```python from typing import List def comb_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of non-negative integers to be sorted. - The list can have up to 10^5 elements. - Each element in the list will be an integer in the range [0, 10^6]. # Output * (List[int]): A list of non-negative integers sorted in ascending order. # Constraints * The function should sort the array in place with a space complexity of O(1). * The function must handle large inputs efficiently within practical run-time limits. # Example ```python input_list = [5, 3, 8, 4, 2] print(comb_sort(input_list)) ``` Expected Output: ``` [2, 3, 4, 5, 8] ``` # Performance Requirements * Best-case complexity: O(n log n) * Average complexity: O(n^2/2^p) * Worst-case complexity: O(n^2) # Instructions 1. Implement the `comb_sort` function using the Comb Sort algorithm. 2. Ensure the function sorts the array in place for optimization. 3. Consider edge cases such as empty arrays or arrays with a single element.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Binary Search Tree Deletion A common operation missing in the provided Binary Search Tree (BST) implementation is the deletion of nodes. In a BST, when you delete a node, several scenarios must be handled: 1. The node to be deleted is a leaf (no children). 2. The node to be deleted has only one child. 3. The node to be deleted has two children. Task Implement the `delete` method for the provided `BST` class. Your implementation should maintain the properties of the BST, ensuring it remains valid after the deletion operation. Function Signature ```python def delete(self, data: int) -> bool: Delete a node with the given data in the BST. Returns True if the deletion was successful, and False if the node with the given data was not found. ``` Input * `data` (int): The value of the node to be deleted from the BST. Output * `bool`: Return `True` if the deletion was successful, `False` if the node to be deleted is not found in the tree. Constraints * The BST should be modified in place. * Nodes to be deleted are guaranteed to exist in the tree. Example ```python # Assuming the same BST structure created in TestSuite: tree.delete(9) # Deleting node with single child (7) # Tree after deletion: # 10 # / # 6 15 # / / # 4 7 12 24 # / # 20 30 # / # 18 tree.delete(15) # Deleting node with two children (12, 24) # Tree after deletion: # 10 # / # 6 18 # / / # 4 7 12 24 # / # 20 30 ``` Notes * Ensure your solution considers all edge cases, such as deleting the root node or nodes with various configurations of children. * Maintain the structural properties of the BST after deletion.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def delete(self, data): self.root, deleted = self._delete_recursive(self.root, data) return deleted def _delete_recursive(self, node, key): if not node: return node, False if key < node.val: node.left, deleted = self._delete_recursive(node.left, key) elif key > node.val: node.right, deleted = self._delete_recursive(node.right, key) else: # Node to be deleted found if not node.left: return node.right, True elif not node.right: return node.left, True # Node with two children, get the inorder successor (smallest in the right subtree) temp_val = self._find_min(node.right).val node.val = temp_val node.right, _ = self._delete_recursive(node.right, temp_val) return node, True return node, deleted def _find_min(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"You are working on a performance-critical system where determining the number of digits of a given integer is a frequent operation. To optimize this, you decide to implement a function that computes the number of digits in constant time. Task Implement a function `count_digits(n)` that returns the number of digits in the integer `n`. # Function Signature ```python def count_digits(n: int) -> int: ``` # Input * The function receives a single integer `n` such that -10^18 <= n <= 10^18. # Output * The function should return an integer representing the number of digits in the input integer `n`. # Constraints 1. You must implement the function using logarithmic properties. 2. You should handle both positive and negative numbers as well as zero. 3. Ensure the function runs in constant O(1) time. # Examples 1. `count_digits(12345)` should return `5`. 2. `count_digits(-12345)` should return `5`. 3. `count_digits(0)` should return `1`. # Scenario You are writing code for a financial application. In this application, you need to determine the digit count of transaction IDs quickly to perform various normalization operations. The transaction IDs can range widely, and performance is critical, so you must ensure the operation completes in constant time.","solution":"import math def count_digits(n: int) -> int: Returns the number of digits in the integer n. Handles both positive and negative numbers as well as zero. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Question: Verify Palindrome Using Two Pointers **Context**: You are working on a text analysis tool that requires you to frequently verify if certain user inputs are palindromes. Given the need for efficient verification, you decide to implement a palindrome checking function using the two-pointers technique, which is both time and space efficient. **Objective**: Write a function `is_palindrome_two_pointer` which checks if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. **Function Signature**: ```python def is_palindrome_two_pointer(s: str) -> bool: ``` **Input Format**: - A single string `s` (0 <= len(s) <= 10000). **Output Format**: - Returns a boolean value: `True` if the string is a palindrome, and `False` otherwise. **Constraints**: - The function should be case-insensitive. - Non-alphanumeric characters should be ignored while determining if the string is a palindrome. **Example**: ```python # Example 1: input_str = \\"A man, a plan, a canal: Panama\\" print(is_palindrome_two_pointer(input_str)) # Output: True # Example 2: input_str = \\"race a car\\" print(is_palindrome_two_pointer(input_str)) # Output: False ``` **Edge Cases to Consider**: - An empty string should return `True`. - Strings with only non-alphanumeric characters should return `True`. - Strings with a mixture of cases should be correctly identified as palindromes or not.","solution":"def is_palindrome_two_pointer(s: str) -> bool: Checks if the given string is a palindrome considering only alphanumeric characters and ignoring case. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Initialize two pointers left, right = 0, len(s) - 1 while left < right: # Move left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Compare the characters at the left and right pointers if s[left].lower() != s[right].lower(): return False # Move both pointers towards the center left += 1 right -= 1 return True"},{"question":"**Problem Statement**: Given an integer array `nums`, implement a function `max_subarray_sum(nums)` that finds the contiguous subarray (containing at least one number) which has the largest sum and returns its sum. # Input: * An integer array `nums` of length `n` (1 ≤ n ≤ 10^5). * Each element in array `nums` is an integer (-10^4 ≤ nums[i] ≤ 10^4). # Output: * A single integer representing the maximum sum of the contiguous subarray. # Constraints: * Your implementation should run in linear time with respect to the array size. * The array will always have at least one element. # Examples: 1. `max_subarray_sum([1, 2, -3, 4, 5, -7, 23])` should return `25`. 2. `max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])` should return `6`. 3. `max_subarray_sum([5, 4, -1, 7, 8])` should return `23`. # Additional Context: Kadane\'s Algorithm will be a suitable approach for solving this problem due to its linear time complexity, making it efficient for large input sizes. Be sure to handle edge cases such as arrays composed entirely of negative numbers or arrays with only one element.","solution":"def max_subarray_sum(nums): Find the contiguous subarray within an array which has the largest sum and return its sum. :param nums: List[int] - List of integers representing the array. :return: int - The maximum sum of the contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are required to implement an optimized version of the Cooley-Tukey Fast Fourier Transform (FFT) algorithm. This algorithm efficiently computes the discrete Fourier transform (DFT) of an input array of complex numbers, which is widely used in signal and image processing. # Implementation Details * **Function Signature**: `def optimized_fft(x: List[complex]) -> List[complex]:` * **Input**: A list `x` of complex numbers of length `N`, where `N` is a power of 2. * **Output**: A list of complex numbers representing the discrete Fourier transform of the input. # Requirements 1. Implement an iterative (non-recursive) version of the Cooley-Tukey FFT algorithm to avoid potential recursion depth issues. 2. The implementation should minimize memory usage by performing in-place transformations where possible. 3. Ensure that the algorithm runs in O(N log N) time complexity and uses O(N) extra space. # Constraints - The length of the input list, `N`, will always be a power of 2 and between 1 and 1024, inclusive. - Input values are floating-point numbers with a precision up to 5 decimal places. # Example ```python from cmath import exp, pi def optimized_fft(x): Iterative implementation of the Cooley-Tukey N = len(x) if N <= 1: return x # Bit-reversal permutation y = [0]*N j = 0 for i in range(N): y[j] = x[i] bit = N >> 1 while j >= bit: j -= bit bit >>= 1 j += bit # Iterative FFT m = 2 while m <= N: angle = -2j * pi / m w_m = exp(angle) for k in range(0, N, m): w = 1 for j in range(m//2): t = w * y[k + j + m//2] u = y[k + j] y[k + j] = u + t y[k + j + m//2] = u - t w *= w_m m *= 2 return y ```","solution":"from typing import List from cmath import exp, pi def optimized_fft(x: List[complex]) -> List[complex]: Iterative implementation of the Cooley-Tukey FFT algorithm. :param x: List of complex numbers of length N (power of 2) :return: Discrete Fourier Transform of the input list N = len(x) if N <= 1: return x # Bit-reversal permutation y = [0] * N j = 0 for i in range(N): y[j] = x[i] bit = N >> 1 while j >= bit and bit >= 1: j -= bit bit >>= 1 j += bit # Iterative FFT m = 2 while m <= N: angle = -2j * pi / m wm = exp(angle) for k in range(0, N, m): w = 1 for j in range(m // 2): t = w * y[k + j + m // 2] u = y[k + j] y[k + j] = u + t y[k + j + m // 2] = u - t w *= wm m *= 2 return y"},{"question":"# Coding Challenge: Pattern Matching with Bijection Context: Given a pattern and a string, determine if the string follows the same pattern. To do so, there must be a one-to-one and onto mapping (bijection) between characters in the pattern and non-empty substrings of the string. This challenge involves recursive backtracking to explore all possible mappings. Objective: Write a function `pattern_match(pattern, string)` that returns `True` if the string follows the pattern, and `False` otherwise. Input Format: - `pattern`: a string containing lowercase letters (1 ≤ len(pattern) ≤ 20) - `string`: a string containing lowercase letters (1 ≤ len(string) ≤ 50) Output Format: - A boolean value `True` if the string follows the pattern, `False` otherwise. Constraints: - Both `pattern` and `string` will only contain lowercase letters. Performance Requirements: - Aim for a solution that efficiently prunes impossible mappings, but understand that worst-case performance might be exponential. Examples: 1. `pattern = \\"abab\\"`, `string = \\"redblueredblue\\"` → `True` 2. `pattern = \\"aaaa\\"`, `string = \\"asdasdasdasd\\"` → `True` 3. `pattern = \\"aabb\\"`, `string = \\"xyzabcxzyabc\\"` → `False` Function Signature: ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` Notes: - Think about possible mappings and how to systematically try all options. - Consider edge cases such as single-character patterns or strings. - Make sure your solution backtracks properly if a mapping turns out to be invalid. Good luck and think carefully about mapping and recursion efficiency.","solution":"def pattern_match(pattern, string): Function to check if a string follows the given pattern. Parameters: pattern (str): A pattern containing lowercase letters (1 ≤ len(pattern) ≤ 20) string (str): A string containing lowercase letters (1 ≤ len(string) ≤ 50) Returns: bool: True if the string follows the pattern, False otherwise. def is_match(pattern, string, p_idx, s_idx, mapping, used): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] if pattern_char in mapping: mapped_string = mapping[pattern_char] if not string.startswith(mapped_string, s_idx): return False return is_match(pattern, string, p_idx + 1, s_idx + len(mapped_string), mapping, used) for end in range(s_idx + 1, len(string) + 1): candidate = string[s_idx:end] if candidate in used: continue mapping[pattern_char] = candidate used.add(candidate) if is_match(pattern, string, p_idx + 1, s_idx + len(candidate), mapping, used): return True del mapping[pattern_char] used.remove(candidate) return False return is_match(pattern, string, 0, 0, {}, set())"},{"question":"# Scenario You are developing a real-time monitoring system that needs to provide continuous updates on the maximum pressure levels recorded in sliding windows of a fixed duration within a stream of sensor data. To facilitate this, you need to implement a function that efficiently calculates the maximum values for each sliding window segment of the data. # Task Implement a function `max_sliding_window(arr, k)` that takes a list of integers `arr` representing the pressure values recorded at equal intervals and an integer `k` representing the window size. Your function should return a list of integers representing the maximum pressure values for each sliding window. # Input - `arr`: A list of integers of length n (0 ≤ n ≤ 10^5), representing the pressure values. - `k`: An integer (1 ≤ k ≤ n), representing the size of the sliding window. # Output - A list of integers, where each element is the maximum value in each sliding window of the given size k. # Constraints - If `k` is larger than the length of `arr`, return an empty list. - Ensure that your solution is efficient and adheres to the given time and space complexities. # Example ```python # Example 1 arr = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 Output: [3, 3, 5, 5, 6, 7] # Example 2 arr = [] k = 3 Output: [] # Example 3 arr = [9, 11] k = 2 Output: [11] # Example 4 arr = [4, -2] k = 1 Output: [4, -2] ```","solution":"from collections import deque def max_sliding_window(arr, k): Returns a list of integers representing the maximum pressure values for each sliding window. :param arr: List of integers representing the pressure values recorded at equal intervals. :param k: Integer representing the size of the sliding window. :return: List of integers representing the maximum values in each sliding window of size k. if not arr or k > len(arr): return [] deq = deque() result = [] for i in range(len(arr)): # Remove elements out of the current window if deq and deq[0] == i - k: deq.popleft() # Remove elements not needed in deque while deq and arr[deq[-1]] <= arr[i]: deq.pop() deq.append(i) # Start recording results when we have a valid window if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"# Question: Implement a Robust Square Root Computation You have been given a function `square_root(n, epsilon=0.001)` that computes the square root of a positive integer (N) with a maximum error margin of ( epsilon ). This function uses the Babylonian method (a.k.a. Newton’s method for square roots) to compute its result. Your task is to: * Implement a robust version of this function considering all possible edge cases and optimizing the computation as needed. # Function Signature ```python def square_root(n: float, epsilon: float) -> float: pass ``` # Input * **n** (float): The number for which the square root is to be found; ( n geq 0 ) * **epsilon** (float): The allowed error margin between the actual and computed value, ( epsilon > 0 ) # Output * Returns a float: The computed square root of ( n ) within the precision ( epsilon ) # Constraints * ( 0 leq n leq 10^9 ) * ( 0 < epsilon leq 1 ) # Examples ```python print(square_root(5, 0.001)) # Possible output: 2.236... print(square_root(25, 0.0001)) # Possible output: 5.0 print(square_root(10, 0.01)) # Possible output: 3.162... print(square_root(0, 0.001)) # Output: 0.0 ``` # Requirements * Manage edge cases where (n) is zero or very large. * Improve the initial guess dynamically for large values. * Ensure the function terminates efficiently without unnecessary iterations. * Handle the situation gracefully where a very small or very large precision value might affect the performance. # Hint Consider starting the guess dynamically based on the range of ( n ), for example: * If ( n ) is very small (( < 1 )), the initial guess should be 1. * If ( n ) is very large (( geq 1 )), the initial guess might be something larger (( approx n/2 )).","solution":"def square_root(n: float, epsilon: float) -> float: if n == 0: return 0.0 guess = n / 2.0 if n >= 1 else 1.0 while abs(guess * guess - n) > epsilon: guess = (guess + n / guess) / 2.0 return guess"},{"question":"# Question You are given a list of integers and your task is to sort this list using the merge sort algorithm. Write a function `merge_sort(input_list)` that takes a list of integers `input_list` as a parameter and returns a new list with the elements sorted in non-decreasing order. Function Signature ```python def merge_sort(input_list: List[int]) -> List[int]: pass ``` Input * A single list of integers, `input_list` where `1 <= len(input_list) <= 10^5` and `-10^9 <= input_list[i] <= 10^9`. Output * Return a new list of integers where the elements are sorted in non-decreasing order. Constraints * You cannot use Python\'s built-in sort() function or any other library-specific sorting functions. * The solution should have a time complexity of O(n log(n)) and a space complexity of O(n). Examples ```python assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert merge_sort([10, -1, 2, 5, 0, 6, 4, -5]) == [-5, -1, 0, 2, 4, 5, 6, 10] assert merge_sort([1]) == [1] assert merge_sort([]) == [] ```","solution":"from typing import List def merge_sort(input_list: List[int]) -> List[int]: if len(input_list) <= 1: return input_list def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 # Merge the two lists together until one is exhausted while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append the remaining elements from the non-exhausted list merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged # Divide the list into two halves middle = len(input_list) // 2 left_half = merge_sort(input_list[:middle]) right_half = merge_sort(input_list[middle:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"# Magic Number Function Implementation **Scenario**: You are developing a feature that utilizes the concept of magic numbers in a puzzle game. Players can enter any non-negative integer to check if it is classified as a magic number based on the summation of its digits. Write a function `is_magic_number(n: int) -> bool` that determines whether a given non-negative integer is a magic number. The function should follow these rules: 1. Continuously sum the digits of the number until you get a single-digit number. 2. If the single-digit number is 1, then the input number is considered a magic number. **Input**: * `n`: A non-negative integer (`0 ≤ n ≤ 10^9`). **Output**: * Returns `True` if `n` is a magic number, `False` otherwise. **Constraints**: * You may assume the input is always a valid non-negative integer within the provided range. **Examples**: ```python assert is_magic_number(50113) == True assert is_magic_number(1234) == True assert is_magic_number(199) == True assert is_magic_number(111) == False ``` **Solution Requirements**: * Efficiency in time and space complexity, reflecting the analysis provided. * Handle edge cases, including small values of `n`.","solution":"def digit_sum(n): Calculates the sum of the digits of a non-negative integer n. return sum(int(digit) for digit in str(n)) def is_magic_number(n: int) -> bool: Determines if a given non-negative integer is a magic number. A magic number is defined as a number that reduces to 1 after repeatedly summing its digits. while n >= 10: n = digit_sum(n) return n == 1"},{"question":"Given a sequence of natural numbers written in a concatenated form as \'123456789101112...\', your task is to write a function `find_nth_digit(n)` that returns the nth digit in this sequence. Consider 1-based indexing for the sequence. # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input * `n` (1 <= n <= 2 * 10^9): Integer representing the position of the digit in the concatenated sequence. # Output * An integer representing the nth digit in the sequence. # Constraints * The function should have time complexity O(log10(n)). * Handle all edge cases and ensure the result is derived accurately even for very large values of n. # Example ```python assert find_nth_digit(1) == 1 assert find_nth_digit(9) == 9 assert find_nth_digit(10) == 1 assert find_nth_digit(11) == 0 assert find_nth_digit(189) == 9 assert find_nth_digit(190) == 1 assert find_nth_digit(191) == 0 ``` # Context This problem is typical in competitive programming contests and coding interviews, where you need to derive specific elements from a conceptual infinite series. Its efficient solving strategy involves understanding numerical patterns and logarithmic intervals, which is crucial in optimizing performance for very large indices.","solution":"def find_nth_digit(n: int) -> int: digit_length = 1 count = 9 start = 1 # First, find the range where the nth digit falls. while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Find the exact number that contains the nth digit. num = start + (n - 1) // digit_length # Find the exact digit within that number. digit_index = (n - 1) % digit_length return int(str(num)[digit_index])"},{"question":"You are given a sorted list of integers arranged in increasing order. You need to implement an improved search function which utilizes the Interpolation Search algorithm to locate a given integer efficiently in the list. However, your task also involves upgrading the basic interpolation search to handle more complex scenarios: 1. The array might not always be uniformly distributed, and you have to switch to binary search-like steps whenever necessary. 2. The function needs to account for the edge cases where the element might not be present or the array being empty. Function Signature Implement the function `enhanced_interpolation_search(array: List[int], search_key: int) -> int`. Input - `array`: A sorted list of integers (e.g., [1, 4, 7, 10]). - `search_key`: An integer value to search in the array. Output - An integer representing the index of the search_key in the array if found, otherwise -1. Constraints - The input array is sorted. - The array can contain up to (10^6) elements. - The search_key can be any integer within the array\'s range. Performance Requirements - Aim for a sub-linear time complexity in average cases. Example Usage ```python >>> enhanced_interpolation_search([1, 2, 3, 4, 5], 3) 2 >>> enhanced_interpolation_search([10, 20, 30, 40], 35) -1 >>> enhanced_interpolation_search([], 1) -1 >>> enhanced_interpolation_search([1, 1, 1, 1, 1], 1) 0 ``` **Note**: Avoid referencing the provided code directly; instead, focus on the improvements according to the stated requirements.","solution":"def enhanced_interpolation_search(array, search_key): def interpolation_search(arr, low, high, x): while low <= high and x >= arr[low] and x <= arr[high]: if low == high: if arr[low] == x: return low return -1 pos = low + ((high - low) // (arr[high] - arr[low] + 1) * (x - arr[low])) if pos < low or pos > high: return -1 if arr[pos] == x: return pos if arr[pos] < x: low = pos + 1 else: high = pos - 1 return -1 def binary_search(arr, low, high, x): while low <= high: mid = (low + high) // 2 if arr[mid] == x: return mid elif arr[mid] < x: low = mid + 1 else: high = mid - 1 return -1 if not array: return -1 lo, hi = 0, len(array) - 1 while lo <= hi: if array[lo] <= search_key <= array[hi]: pos = lo + ((hi - lo) // (array[hi] - array[lo] + 1) * (search_key - array[lo])) if pos < lo or pos > hi: return binary_search(array, lo, hi, search_key) if array[pos] == search_key: return pos if array[pos] < search_key: lo = pos + 1 else: hi = pos - 1 else: return binary_search(array, lo, hi, search_key) return -1"},{"question":"# Exchange Sort Implementation and Analysis Context You are working on sorting algorithms for educational purposes and want to explore the performance and characteristics of simpler but inefficient sorting algorithms. Specifically, you want to implement the Exchange Sort algorithm and analyze its behavior on various datasets. Objective Write a function `exchange_sort(arr)` that sorts an array `arr` of integers using the Exchange Sort algorithm. The function should return a sorted array. Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers which can be empty, have one element, or have multiple elements (positive and/or negative). Output * A sorted list of integers in ascending order. Constraints * The length of the array, `n`, can be up to 10^3. * The integers in the array can be positive or negative. Performance Requirements * Time Complexity: O(n^2) * Space Complexity: O(1) Example 1. Input: `exchange_sort([5, 3, 8, 4, 2])` Output: `[2, 3, 4, 5, 8]` 2. Input: `exchange_sort([1])` Output: `[1]` 3. Input: `exchange_sort([])` Output: `[]` 4. Input: `exchange_sort([-1, -3, -2, 0, 2])` Output: `[-3, -2, -1, 0, 2]` Tasks 1. Implement the `exchange_sort` function. 2. Test the function with various inputs to ensure it handles edge cases properly. 3. Analyze its performance on different types and sizes of input data and document any significant observations.","solution":"from typing import List def exchange_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Exchange Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers in ascending order. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Scenario You are tasked with developing a simple machine learning model to classify data points on a 2D plane. The nearest neighbor classification algorithm should be used based on the previously implemented code snippets. # Task Write a function `classify_point` that, given a new point and a training set of classified points, uses the nearest neighbor algorithm to determine the class of the new point. # Function Signature ```python def classify_point(point: tuple, training_set: dict) -> any: Classifies a given point based on the nearest neighbor in the training set. Args: point (tuple): A tuple representing the coordinates of the point to classify. training_set (dict): A dictionary where keys are tuples representing coordinates of known points and values are their corresponding classes. Returns: any: The class of the nearest neighbor. ``` # Input * `point`: A tuple of two integers/floats representing the point to classify. * `training_set`: A dictionary where keys are tuples of two integers/floats representing coordinates of known points, and values are their corresponding classes. # Output * The class of the nearest neighbor to the input point from the training set. # Constraints * All points in the `training_set` and the `point` itself will have integer or float coordinates. * There will be at least one point in the `training_set`. # Example ```python training_set = { (1, 2): \'A\', (3, 4): \'B\', (5, 1): \'C\' } classify_point((2, 3), training_set) == \'A\' ``` # Notes 1. The distance calculation uses the Euclidean distance formula. 2. The function should handle the case where multiple points have the same minimum distance. It should return the class of the first found nearest neighbor.","solution":"import math def classify_point(point, training_set): Classifies a given point based on the nearest neighbor in the training set. Args: point (tuple): A tuple representing the coordinates of the point to classify. training_set (dict): A dictionary where keys are tuples representing coordinates of known points and values are their corresponding classes. Returns: any: The class of the nearest neighbor. nearest_neighbor = None min_distance = float(\'inf\') for training_point, class_name in training_set.items(): distance = math.sqrt((training_point[0] - point[0]) ** 2 + (training_point[1] - point[1]) ** 2) if distance < min_distance: min_distance = distance nearest_neighbor = class_name return nearest_neighbor"},{"question":"# Problem: Enhanced Gnome Sort with Early Termination You are tasked with enhancing the given Gnome Sort algorithm. The goal is to improve it by adding a mechanism to detect if the array is already sorted during the sorting process. If a complete pass through the array is made without any swaps, the algorithm should terminate early. This check can potentially reduce the time complexity when the input array is already sorted or nearly sorted. Function Signature: `def enhanced_gnome_sort(arr: List[int]) -> List[int]:` Input: * `arr` (List[int]): An array of integers to be sorted. Output: * Return the sorted list in non-decreasing order. Constraints: * The input list will contain at most `10^5` elements. * Each element of the list will be in the range [-10^6, 10^6]. Performance Requirements: * The solution should aim to handle nearly sorted arrays efficiently. * It should preserve the in-place sorting nature unless there\'s a strong justification to use additional space. Example: ```python assert enhanced_gnome_sort([3, 2, 5, 4, 1]) == [1, 2, 3, 4, 5] assert enhanced_gnome_sort([7, 8, 5, 4, 3]) == [3, 4, 5, 7, 8] assert enhanced_gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_gnome_sort([]) == [] assert enhanced_gnome_sort([10]) == [10] ``` # Note: Ensure that your solution retains the simplicity of the original Gnome Sort while attempting to optimize for nearly sorted inputs.","solution":"from typing import List def enhanced_gnome_sort(arr: List[int]) -> List[int]: n = len(arr) index = 0 last_sorted_position = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: if index == last_sorted_position: last_sorted_position += 1 index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 if index < last_sorted_position: last_sorted_position = index + 1 return arr"},{"question":"You\'ve recently been hired by a company to optimize their search functionality for sorted membership ID databases. The current challenge is to efficiently locate specific membership IDs from their extensive sorted list of IDs. **Task**: Write a function `optimized_search` that employs the Jump Search algorithm to find a given target membership ID in a sorted array of IDs. Your function should return the index of the target if found, otherwise -1. # Input - A sorted list of integers `ids` where 1 ≤ len(ids) ≤ 10^5. - An integer `target` representing the membership ID to search for. # Output - An integer representing the index of the target if found; otherwise -1. # Constraints - The list `ids` will be sorted in ascending order. - The elements in `ids` are unique and fall in the range 1 ≤ ids[i] ≤ 10^9. - Your solution must maintain a time complexity of O(√n). # Example ```python def optimized_search(ids, target): # Implementation here pass # Example 1 print(optimized_search([1, 3, 5, 7, 9], 7)) # Output: 3 # Example 2 print(optimized_search([10, 20, 30, 40, 50], 25)) # Output: -1 ``` # Explanation - Example 1: The function should return 3 because the number 7 appears at index 3. - Example 2: The function should return -1 because the number 25 is not in the list.","solution":"import math def optimized_search(ids, target): Uses Jump Search algorithm to find the target membership ID in a sorted list of IDs. Returns the index of the target if found, otherwise -1. n = len(ids) step = int(math.sqrt(n)) # Calculate the jump step size prev = 0 # Finding the block where the element is present (if it is present) while ids[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in the block beginning with prev. for i in range(prev, min(step, n)): if ids[i] == target: return i return -1"},{"question":"Given the analysis above, you need to implement a function `find_cycle_start` that not only detects if a cycle exists in a linked list but also returns the starting node of the cycle if it exists. If there is no cycle, the function should return `None`. Follow the constraints and performance requirements outlined below. ```python class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head): :type head: Node :rtype: Node or None # Implementation here ``` # Function Implementation Input Format - `head`: The head node of the singly linked list. Output Format - Return the node where the cycle begins if a cycle is present; otherwise, return `None`. Constraints - Do not use any extra space apart from the variables you need (`O(1)` space complexity). - The solution should run in linear time (`O(N)`). Example Usage ```python # Example 1: # Input: head = [3, 2, 0, -4], position = 1 (cycle starts at node with value 2) # Output: Node at position 1 # Example 2: # Input: head = [1, 2], position = 0 (cycle starts at node with value 1) # Output: Node at position 0 # Example 3: # Input: head = [1], position = -1 (no cycle) # Output: None ``` # Hints 1. Use Floyd’s Cycle-Finding Algorithm to detect a cycle. 2. Once a cycle is detected, initialize one pointer to the head and the other to the meeting point. Move both pointers one step at a time; the point where they meet is the start of the cycle.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head): Detects if there is a cycle in the linked list and returns the start node of the cycle if it exists. If there is no cycle, returns None. :type head: Node :rtype: Node or None if not head or not head.next: return None slow = head fast = head # Step 1: Determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None # No cycle # Step 2: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# AVL Tree Coding Assessment You are tasked with implementing specific functionalities of an AVL tree (a self-balancing binary search tree). Given a partially implemented AVL Tree class, your job is to complete the insertion function and ensure the tree remains balanced after each insertion. Function Signature ```python def insert(self, key: int) -> None: ``` * `key`: The integer value to add to the AVL tree. Constraints 1. Keys are unique within the tree. 2. The tree can support integer values within the range of a 32-bit signed integer. Requirements * Complete the `insert` method within the AVL Tree class. * Ensure that the AVL tree properties are maintained after each insertion, with necessary rotations to balance the tree. * Update the heights and balance factors correctly for each node. * Implement proper rotations (left and right) when imbalances are detected. * Your implementation should follow the provided tree structure and methods. Example Assume the AVL tree initially contains the following values inserted in this order: `[10, 20, 30, 40, 50, 25]`. The tree should first insert 10, becoming: ``` 10 ``` Then, insert 20: ``` 10 20 ``` Continue with 30: ``` 20 / 10 30 ``` Following insertions of 40, 50, and finally 25 should result in a balanced AVL Tree: ``` 30 / 20 40 / 10 25 50 ``` Write the `insert` function and any additional helper methods required to ensure the AVL property is maintained. Test the following scenarios: 1. Inserting a single element in an empty tree. 2. Inserting multiple elements and ensuring tree balance. 3. Conducting in-order traversal to verify the sorted order of elements.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): # Perform normal BST insertion if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) # Update the node\'s height node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) # Get the balance factor balance = self._get_balance(node) # Rotate if unbalanced # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) # Return the new root return y def _right_rotate(self, y): x = y.left T2 = x.right # Perform rotation x.right = y y.left = T2 # Update heights y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) # Return the new root return x def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def inorder_traversal(self): res = [] self._inorder(self.root, res) return res def _inorder(self, node, res): if not node: return self._inorder(node.left, res) res.append(node.key) self._inorder(node.right, res)"},{"question":"# Problem Description You are given a group of people sitting in a circular arrangement. Your task is to write a function that prints every third member, removes them from the circle, and continues this process until all members are exhausted. This problem is analogous to the Josephus problem. # Function Signature ```python def circular_elimination(int_list: List[int], skip: int) -> List[int]: pass ``` # Input * `int_list`: A list of integers representing members sitting in a circle. * `skip`: An integer `3` that indicates you need to remove every 3rd member. # Output * A list of integers representing the order in which members were removed. # Constraints * The list length will be at least 1 and not more than 1000. * `skip` will always be a positive integer no greater than the length of the list. # Example ```python assert circular_elimination([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [3, 6, 9, 4, 8, 5, 2, 7, 1] assert circular_elimination([1, 2, 3, 4, 5], 3) == [3, 1, 5, 2, 4] ``` # Notes 1. Members should be removed in a circular manner. After reaching the end of the list, counting should continue from the start. 2. Ensure that your solution handles edge cases like an empty list or a very short list correctly.","solution":"from typing import List def circular_elimination(int_list: List[int], skip: int) -> List[int]: if len(int_list) == 0: return [] result = [] index = 0 while len(int_list) > 0: index = (index + skip - 1) % len(int_list) result.append(int_list.pop(index)) return result"},{"question":"# Scenario You have been hired by a company that processes age demographic data. Ages recorded in the survey vary from -5 years (erroneous entries now corrected in new inputs) to 120 years. You need to write an efficient sorting function to clean and sort the ages. # Objective Write a function `efficient_age_sort` that uses the Counting Sort algorithm to sort an array of ages. Ensure your implementation can handle negative ages by shifting values appropriately. # Function Signature ```python def efficient_age_sort(ages: List[int]) -> List[int]: Sorts a list of ages using the Counting Sort algorithm. ``` # Input * `ages`: A list of integers representing ages (can include negative values). # Output * A list of integers sorted in ascending order. # Constraints * The length of `ages` is not greater than 10^6. * Age values are between -5 and 120 inclusive. # Examples ```python assert efficient_age_sort([23, -2, 35, 0, -3, 120, 5]) == [-3, -2, 0, 5, 23, 35, 120] assert efficient_age_sort([]) == [] assert efficient_age_sort([55, 55, 55]) == [55, 55, 55] assert efficient_age_sort([-5, -5, -5]) == [-5, -5, -5] ``` # Notes * Make sure to address the edge cases such as empty list, all negative ages, and arrays with identical elements. * Your solution should be efficient in both time and space, respecting the O(n + k) complexity.","solution":"from typing import List def efficient_age_sort(ages: List[int]) -> List[int]: Sorts a list of ages using the Counting Sort algorithm. Ages range from -5 to 120 inclusive. if not ages: return [] # Define the range based on the given constraints min_age = -5 max_age = 120 range_ages = max_age - min_age + 1 # Initialize count array count = [0] * range_ages # Count the occurrences of each age for age in ages: count[age - min_age] += 1 # Generate the sorted ages list sorted_ages = [] for i in range(range_ages): sorted_ages.extend([i + min_age] * count[i]) return sorted_ages"},{"question":"# Radix Sort Implementation Challenge You are given an integer array `arr` that needs to be sorted in non-decreasing order. Implement the Radix Sort algorithm to sort the array. Function Signature ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input * `arr`: A list of non-negative integers. Constraints: 0 <= len(arr) <= 10^5, 0 <= arr[i] <= 10^9. * `simulation`: A boolean flag (default is False). If set to True, print the array\'s state after each iteration of sorting by each digit position, starting from the least significant digit. Output * Return the sorted list. Constraints - Do not use Python\'s built-in sort function. - Handle large arrays efficiently in terms of both time and space complexity. - Pay attention to edge cases, such as empty arrays. Example ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(arr)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] empty_arr = [] print(radix_sort(empty_arr)) # Output: [] ``` Context In computer systems, sorting is a fundamental operation that optimizes the performance of searching and data manipulation processes. Radix Sort is particularly useful when working with large datasets of integer keys, where comparison-based sorting methods might underperform. Given its unique processing mechanism, understanding and implementing Radix Sort enhances your grasp of various sorting strategies and their application contexts.","solution":"from typing import List def counting_sort_for_radix(arr: List[int], exp: int, base: int = 10) -> List[int]: n = len(arr) output = [0] * n count = [0] * base for i in range(n): index = (arr[i] // exp) % base count[index] += 1 for i in range(1, base): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % base output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return arr max_element = max(arr) exp = 1 while max_element // exp > 0: arr = counting_sort_for_radix(arr, exp) if simulation: print(f\\"After sorting with exp={exp}: {arr}\\") exp *= 10 return arr"},{"question":"You are asked to write a function `longest_1s_sequence(num: int) -> int` that finds the length of the longest sequence of 1s a given integer\'s binary representation can have if you flip exactly one bit from 0 to 1. Input * **num**: An integer `num (>= 0)` representing the number. Output * **An integer**: The length of the longest sequence of consecutive 1s after flipping exactly one bit from 0 to 1. # Constraints * The integer provided is non-negative. # Example 1. Input: `num = 1775` (Binary representation: `11011101111`) Output: `8` 2. Input: `num = 15` (Binary representation: `1111`) Output: `5` 3. Input: `num = 0` (Binary representation: `0`) Output: `1` # Explanation For the first example with input `1775`: * The binary representation `11011101111` has the longest sequence of 1s that can be achieved by flipping one bit to be `111111111`, which has a length of `8` 1s. # Function Signature ```python def longest_1s_sequence(num: int) -> int: # Your code here ```","solution":"def longest_1s_sequence(num: int) -> int: Finds the length of the longest sequence of consecutive 1s after flipping exactly one bit from 0 to 1 in the binary representation of \'num\'. if num == 0: return 1 bin_str = bin(num)[2:] # Get the binary representation without \'0b\' prefix. max_len = 0 current_len = 0 prev_len = 0 for bit in bin_str: if bit == \'1\': current_len += 1 else: prev_len = current_len if current_len > 0 else 0 current_len = 0 max_len = max(max_len, prev_len + current_len + 1) return max_len"},{"question":"# Question You are given two functions that perform encoding and decoding of a list of strings into a single string for transmission or storage. Your task is to implement these functions as described below: **Function 1: encode** ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str ``` * **Input**: A list of strings `strs`. * **Output**: A single encoded string representing the list of strings. **Function 2: decode** ```python def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] ``` * **Input**: A single encoded string `s` that represents a list of strings. * **Output**: The original list of strings. Constraints 1. The list `strs` can be empty. 2. The strings in the list can be empty. 3. Assume that the strings do not contain the delimiter `:`, which is used in the encoding process. # Examples ```python # Example 1 encoded = encode([\\"hello\\", \\"world\\"]) print(encoded) # Output should be \\"5:hello5:world\\" decoded = decode(encoded) print(decoded) # Output should be [\\"hello\\", \\"world\\"] # Example 2 encoded = encode([\\"a\\", \\"\\", \\"ab\\", \\"\\"]) print(encoded) # Output should be \\"1:a0:2:ab0:\\" decoded = decode(encoded) print(decoded) # Output should be [\\"a\\", \\"\\", \\"ab\\", \\"\\"] # Example 3 encoded = encode([]) print(encoded) # Output should be \\"\\" decoded = decode(encoded) print(decoded) # Output should be [] ``` Make sure your implementation handles all edge cases as specified in the analysis. Your solution should be efficient in both time and space complexity.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_strs = [] i = 0 while i < len(s): # Find the \':\' which separates the length and the string j = i while s[j] != \':\': j += 1 length = int(s[i:j]) i = j + 1 + length decoded_strs.append(s[j+1:i]) return decoded_strs"},{"question":"# Integer Partition Problem Given a positive integer `n`, write a function to determine the number of different ways `n` can be expressed as a sum of positive integers, ignoring the order of addends. This problem is equivalent to counting the number of partitions of `n`. The function signature is: ```python def integer_partitions(n: int) -> int: pass ``` # Input - `n` (1 ≤ n ≤ 100): a positive integer to be partitioned. # Output - An integer denoting the number of ways to partition `n`. # Example **Example 1**: ```python integer_partitions(4) ``` **Output**: ``` 5 ``` **Explanation**: ``` 4 can be partitioned as: 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` **Example 2**: ```python integer_partitions(7) ``` **Output**: ``` 15 ``` **Explanation**: ``` 7 can be partitioned as: 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Constraints - Implement an efficient solution with time complexity not worse than O(n^2). - Ensure that your function adheres to the given input and output format constraints.","solution":"def integer_partitions(n: int) -> int: Returns the number of different ways n can be expressed as a sum of positive integers, ignoring the order of addends. # Create a list to store the number of partitions for each number up to n partitions = [0] * (n + 1) partitions[0] = 1 # Base case: there is one way to partition zero (using no numbers) # For each number from 1 to n, update the partition counts for i in range(1, n + 1): for j in range(i, n + 1): partitions[j] += partitions[j - i] return partitions[n]"},{"question":"You have been hired by a financial analysis firm to analyze the stock prices of a company. Your task is to write a function that finds the maximum sum of a contiguous subarray from a given list of daily stock price changes. Implement a function `max_contiguous_subsequence_sum(stock_changes: List[int]) -> int` that takes a list of integers representing daily stock price changes and returns the maximum sum of a contiguous subarray. # Input - `stock_changes`: A list of integers (both positive and negative). # Output - An integer which is the maximum sum of a contiguous subarray. # Constraints - The input list can have at most 10^6 elements. - The input list can have negative numbers and positive numbers. - The list can be empty, in which case the function should return 0. # Example Example 1: ```python stock_changes = [-2, 3, 8, -1, 4] print(max_contiguous_subsequence_sum(stock_changes)) ``` Output: `14` Explanation: The maximum sum of a contiguous subarray is from the elements `[3, 8, -1, 4]`, which sums to `14`. Example 2: ```python stock_changes = [-1, 1, 0] print(max_contiguous_subsequence_sum(stock_changes)) ``` Output: `1` Explanation: The maximum sum of a contiguous subarray is from the element `[1]`, which sums to `1`. Example 3: ```python stock_changes = [-1, -3, -4] print(max_contiguous_subsequence_sum(stock_changes)) ``` Output: `-1` Explanation: The maximum sum of a contiguous subarray is from the element `[-1]`, which sums to `-1`. # Notes 1. Ensure your implementation handles edge cases such as an empty list or lists with all negative numbers. 2. Optimize for performance, considering the constraints.","solution":"from typing import List def max_contiguous_subsequence_sum(stock_changes: List[int]) -> int: if not stock_changes: return 0 max_sum = float(\'-inf\') current_sum = 0 for change in stock_changes: current_sum = max(change, current_sum + change) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Context You are asked to improve the functionality of a weather prediction application using Markov chains. The application models weather transitions between sunny, cloudy, and rainy days. By using a predefined transition dictionary, your task is to implement a function that predicts the weather sequence over a specific number of days, starting from an initial state. Task 1. Implement a function called `predict_weather` that takes in a Markov chain representing weather transitions, an initial state, and the number of days to predict. 2. The function should return a list of states representing the predicted sequence of weather for the given number of days. Input * `weather_chain` (dict): A dictionary representing the Markov chain for weather transitions with states as keys and dictionaries as values. Each dictionary specifies the probability of transitioning to other states. * `initial_state` (str): The starting state (e.g., \'Sunny\'). * `days` (int): The number of days to predict. Output * A list of strings representing the sequence of predicted weather states. Example ```python # Example Chain weather_chain = { \'Sunny\': {\'Sunny\': 0.5, \'Cloudy\': 0.3, \'Rainy\': 0.2}, \'Cloudy\': {\'Sunny\': 0.2, \'Cloudy\': 0.6, \'Rainy\': 0.2}, \'Rainy\': {\'Sunny\': 0.1, \'Cloudy\': 0.4, \'Rainy\': 0.5} } initial_state = \'Sunny\' days = 5 assert predict_weather(weather_chain, initial_state, days) == [\'Sunny\', \'Cloudy\', \'Rainy\', \'Cloudy\', \'Sunny\'] ``` Constraints * The sum of probabilities for each state in the chain will be guaranteed to be approximately 1.0. * The initial state will be one of the keys in the weather_chain. * 1 ≤ days ≤ 100. Additional Notes * Consider edge cases such as transitions leading to the same state across multiple days. * Focus on the accuracy and correctness of the predicted sequence.","solution":"import random def predict_weather(weather_chain, initial_state, days): Predicts the weather sequence over a specified number of days starting from an initial state using a Markov chain. :param weather_chain: A dictionary representing the Markov chain for weather transitions. :param initial_state: The starting state. :param days: The number of days to predict. :return: A list of strings representing the sequence of predicted weather states. current_state = initial_state weather_sequence = [current_state] for _ in range(days - 1): current_transitions = weather_chain[current_state] next_state = random.choices(list(current_transitions.keys()), weights=list(current_transitions.values()))[0] weather_sequence.append(next_state) current_state = next_state return weather_sequence"},{"question":"# Question: As a programming assessment task, you are asked to implement a new feature in the provided Polynomial and Monomial class definitions. Problem Statement: Implement a method `differentiate` in both the `Monomial` and `Polynomial` classes to find the derivative of a monomial or polynomial with respect to a specific variable. # Function Signature: ```python class Monomial: def differentiate(self, variable: int) -> Monomial: pass class Polynomial: def differentiate(self, variable: int) -> Polynomial: pass ``` # Input: 1. **Monomial.differentiate(variable: int)**: - `variable`: an integer representing the variable with respect to which the derivative is taken. 2. **Polynomial.differentiate(variable: int)**: - `variable`: an integer representing the variable with respect to which the derivative is taken. # Output: 1. **Monomial.differentiate**: - Returns a new Monomial which is the derivative of the current Monomial relative to the specified variable. 2. **Polynomial.differentiate**: - Returns a new Polynomial which is the derivative of the current Polynomial relative to the specified variable. # Constraints: - `Polynomial` and `Monomial` objects only contain non-negative integer exponents. - If the variable to differentiate does not exist in the Monomial/Polynomial, the derivative should be zero monomial/polynomial. # Example: ```python # For Monomial differentiation mono1 = Monomial({1: 3}, 2) # 2*(a_1)^3 print(mono1.differentiate(1)) # Expected: 6*(a_1)^2 # For Polynomial differentiation poly1 = Polynomial([ Monomial({1: 3}, 2), # 2*(a_1)^3 Monomial({2: 1}, 5), # 5*(a_2) ]) print(poly1.differentiate(1)) # Expected: 6*(a_1)^2 (since d/d(a_2) 5*(a_2) is 0) print(poly1.differentiate(2)) # Expected: 5 (since d/d(a_1) 2*(a_1)^3 is 0) ``` # Notes: 1. The derivative of a monomial ( c cdot x^{n} ) with respect to ( x ) is ( c cdot n cdot x^{n-1} ) if ( n > 0 ); otherwise it is zero. 2. The derivative of a polynomial is obtained by differentiating each monomial and summing the results. # Implement the methods in Python below: ```python class Monomial: def differentiate(self, variable: int) -> Monomial: # Your implementation here pass class Polynomial: def differentiate(self, variable: int) -> Polynomial: # Your implementation here pass ```","solution":"class Monomial: def __init__(self, exponents, coefficient): Initialize the Monomial with a dictionary of exponents and a coefficient. :param exponents: dict, where keys are variable indices and values are their exponents. :param coefficient: float, the coefficient of the monomial. self.exponents = exponents self.coefficient = coefficient def differentiate(self, variable: int): Differentiate the monomial with respect to the given variable. :param variable: int, the variable to take the derivative with respect to. :return: Monomial, the resulting derivative monomial. if variable not in self.exponents or self.exponents[variable] == 0: return Monomial({}, 0) new_exponents = self.exponents.copy() new_exponent = new_exponents[variable] new_coefficient = self.coefficient * new_exponent new_exponents[variable] -= 1 if new_exponents[variable] == 0: del new_exponents[variable] return Monomial(new_exponents, new_coefficient) def __repr__(self): return f\\"Monomial(exponents={self.exponents}, coefficient={self.coefficient})\\" class Polynomial: def __init__(self, monomials): Initialize the Polynomial with a list of Monomials. :param monomials: list of Monomials. self.monomials = monomials def differentiate(self, variable: int): Differentiate the polynomial with respect to the given variable. :param variable: int, the variable to take the derivative with respect to. :return: Polynomial, the resulting derivative polynomial. differentiated_monomials = [monomial.differentiate(variable) for monomial in self.monomials] # Filter out zero monomials (i.e., those with coefficient zero) differentiated_monomials = [mono for mono in differentiated_monomials if mono.coefficient != 0] return Polynomial(differentiated_monomials) def __repr__(self): return f\\"Polynomial(monomials={self.monomials})\\""},{"question":"You have been provided with a task to \\"stutter\\" a stack. The objective is to design a function that takes a stack and duplicates each element before returning the stack. In this assessment, you are required to implement this stuttering algorithm using an auxiliary data structure efficiently. Function Signature ```python def stutter_stack(stack: list) -> list: # Your implementation here pass ``` Input * A stack represented as a list `[val1, val2, ..., valn]` with the top of the stack at the last index. Output * A stack represented as a list where each value is duplicated while preserving the original order. Examples ```python assert stutter_stack([3, 7, 1, 14, 9]) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] assert stutter_stack([]) == [] assert stutter_stack([1]) == [1, 1] assert stutter_stack([2, 4]) == [2, 2, 4, 4] ``` Constraints * Ensure the solution handles an edge case of an empty stack without errors. * Performance should be efficient and aim for linear time complexity O(n). * You are allowed to use either a stack or a queue (collections.deque) as auxiliary storage, but avoid using other complex data structures. Scenario Imagine you are working on a system that needs to log every user action twice for redundancy. Each action is stored in a LIFO stack and needs to be duplicated exactly in the same order without losing the LIFO nature of the stack. This function will help in enabling that logging duplication feature.","solution":"def stutter_stack(stack: list) -> list: Duplicates each element in the stack while preserving the original stack\'s order. :param stack: list representing a stack with the top element at the last index. :return: list with each element duplicated. new_stack = [] for elem in stack: new_stack.append(elem) new_stack.append(elem) return new_stack"},{"question":"# Context: Matrix multiplication is a fundamental operation in various fields including computer graphics, machine learning, and scientific simulations. The purpose of this question is to assess your understanding and implementation of the matrix multiplication algorithm. # Task: Write a function `matrix_multiply` that takes two 2D lists (representing matrices) and returns their product. Ensure to handle edge cases and optimize the solution where possible. # Function Signature: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: pass ``` # Input: * `multiplicand`: List[List[int]] - a two-dimensional list representing the first matrix with dimensions (m times p). * `multiplier`: List[List[int]] - a two-dimensional list representing the second matrix with dimensions (p times n). # Output: * Returns a two-dimensional list representing the resultant matrix with dimensions (m times n). # Constraints: 1. The number of columns in `multiplicand` must equal the number of rows in `multiplier`. 2. Each input matrix will contain only integer values. 3. Handle cases where matrices are empty or not compatible for multiplication. # Example: ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] assert matrix_multiply(multiplicand, multiplier) == [ [4, 4], [10, 8] ] ``` # Notes: * Do not use any external libraries for matrix multiplication. * Think about potential optimizations for larger matrices. * Ensure the function is robust and can handle edge cases gracefully.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: if not multiplicand or not multiplier or not multiplicand[0] or not multiplier[0]: raise ValueError(\\"Input matrices should not be empty.\\") if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Number of columns in the first matrix must equal the number of rows in the second matrix.\\") m = len(multiplicand) p = len(multiplicand[0]) n = len(multiplier[0]) # Initialize the result matrix with zeroes result = [[0] * n for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(n): for k in range(p): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You are given an input string representing a sequence of moves made by a robot starting at the position (0, 0) on a 2D grid. The valid moves are: * \'R\' (Right) * \'L\' (Left) * \'U\' (Up) * \'D\' (Down) You need to determine whether the robot returns to its original position after performing all the moves in the sequence. # Implementation Requirements 1. Implement a function `is_robot_back_to_origin(moves: str) -> bool` that takes a string `moves` as input and returns a boolean indicating whether the robot returns to the origin. 2. Ensure your function correctly handles edge cases, including empty input and strings with invalid characters. # Input * A string `moves` (0 <= len(moves) <= 10000), consisting of only the characters \'R\', \'L\', \'U\', \'D\'. # Output * A boolean value: * `True` if the robot returns to the origin after the moves. * `False` otherwise. # Constraints * All move characters in the string will be one of \'R\', \'L\', \'U\', \'D\'. * The function must run in O(n) time, where n is the length of the input string. # Example 1. **Input**: \\"UD\\" **Output**: `True` 2. **Input**: \\"LL\\" **Output**: `False` 3. **Input**: \\"\\" **Output**: `True` # Function Signature ```python def is_robot_back_to_origin(moves: str) -> bool: pass ```","solution":"def is_robot_back_to_origin(moves: str) -> bool: This function checks if the robot returns to the origin after making the moves. x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"You are given two strings `source` and `target`. Your task is to implement a function `min_edit_distance` that computes the minimum number of operations required to convert `source` into `target`. You are allowed to use the operations: insert a character, delete a character, or substitute a character. # Function Signature: ```python def min_edit_distance(source: str, target: str) -> int: pass ``` # Input * `source` (string): The initial string you want to transform. * `target` (string): The final string after transformation. # Output * Returns an integer representing the minimum number of operations required to transform `source` into `target`. # Constraints * The length of `source` and `target` will be in the range `[0, 1000]`. * The function must run in `O(n * m)` time complexity where `n` and `m` are the lengths of `source` and `target` respectively. * The space complexity should not exceed `O(n * m)`. # Example ```python assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"ab\\", \\"cd\\") == 2 assert min_edit_distance(\\"\\", \\"abc\\") == 3 assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 ``` # Explanation 1. In the first example, \\"kitten\\" can be transformed into \\"sitting\\" with 3 operations: - Substituting \'k\' with \'s\' (kitten -> sitten) - Substituting \'e\' with \'i\' (sitten -> sittin) - Adding \'g\' at the end (sittin -> sitting) 2. In the second example, transforming \\"ab\\" to \\"cd\\" requires substituting both characters.","solution":"def min_edit_distance(source: str, target: str) -> int: Calculates the minimum number of operations required to transform source string into target string. Allowed operations: insert, delete, substitute a character. n, m = len(source), len(target) # Initialize a DP table with (n+1)x(m+1) dimensions dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the base cases: transforming empty source to target for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the table with the recursion rules for i in range(1, n + 1): for j in range(1, m + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: insert_op = dp[i][j - 1] + 1 delete_op = dp[i - 1][j] + 1 substitute_op = dp[i - 1][j - 1] + 1 dp[i][j] = min(insert_op, delete_op, substitute_op) return dp[n][m]"},{"question":"Scenario: You are developing a software to manage binary data for an embedded system that requires high precision in data manipulation. To facilitate this, you need to implement a bit manipulation functionality that allows insertion of one or multiple bits into an integer at specific positions. You are tasked with writing two functions to achieve this. # Task: Implement two functions: `insert_one_bit` and `insert_mult_bits`. 1. Function `insert_one_bit` * **Input**: * `num` (int): The integer into which the bit should be inserted. * `bit` (int): The bit to be inserted (0 or 1). * `i` (int): The position at which the bit should be inserted (0-based index from the right). * **Output**: * (int): The resulting integer after inserting the bit. * **Function Signature**: ```python def insert_one_bit(num: int, bit: int, i: int) -> int: ``` * **Constraints**: * `bit` must be either 0 or 1. * `i` must be a non-negative integer. * Avoid using any libraries that provide direct bit manipulation functions. 2. Function `insert_mult_bits` * **Input**: * `num` (int): The integer into which bits should be inserted. * `bits` (int): The bits to be inserted represented as an integer. * `length` (int): The number of bits in the `bits` integer. * `i` (int): The position at which the bits should be inserted. * **Output**: * (int): The resulting integer after inserting the bits. * **Function Signature**: ```python def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: ``` * **Constraints**: * `length` must be non-negative and should not exceed the number of bits in `num`. * `i` must be a non-negative integer. * Avoid using any libraries that provide direct bit manipulation functions. Ensure to handle all edge cases and ensure that your solution is optimized for performance. # Example: ```python # Example usage: num = 21 # (binary: 10101) bit = 1 i = 2 print(insert_one_bit(num, bit, i)) # Output: 45 (binary: 101101) num = 5 # (binary: 101) bits = 7 # (binary: 111) length = 3 i = 1 print(insert_mult_bits(num, bits, length, i)) # Output: 47 (binary: 101111) ``` Prompt students to focus on maximizing efficiency while ensuring the correctness of bit manipulation.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit into num at position i. if bit not in {0, 1}: raise ValueError(\\"bit must be 0 or 1\\") if i < 0: raise ValueError(\\"i must be a non-negative integer\\") # Shift the part after i to the left by 1, add the bit at i, and then combine with the rest left_part = num >> i right_part = num & ( (1 << i) - 1 ) return (left_part << 1 | bit) << i | right_part def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits into num at position i. if length < 0: raise ValueError(\\"length must be a non-negative integer\\") if i < 0: raise ValueError(\\"i must be a non-negative integer\\") # Shift the part after i to the left by length, add the bits at i, and then combine with the rest left_part = num >> i right_part = num & ( (1 << i) - 1 ) return (left_part << length | bits) << i | right_part"},{"question":"# Topological Sort with Cycle Detection Context Your task is to implement a topological sorting function for a directed acyclic graph (DAG). However, if the input graph contains cycles, your function should raise an error. This is crucial for several applications, including task scheduling, where dependencies must be resolved in a specific order but cycles in dependencies make it impossible. Task Implement a function `topological_sort(graph)` that takes a dictionary representing a directed graph and returns a list of vertices in topological order. If the graph contains a cycle, raise a `ValueError`. Input - A dictionary `graph` where each key is a node, and its value is a list of nodes it points to. Output - A list of nodes in topological order. Constraints 1. The graph will have at most `10^3` nodes. 2. Node identifiers are strings and are unique. # Example ```python graph = { \'5\': [\'11\'], \'7\': [\'11\', \'8\'], \'3\': [\'8\', \'10\'], \'11\': [\'2\', \'9\', \'10\'], \'8\': [\'9\'], \'2\': [], \'9\': [], \'10\': [] } print(topological_sort(graph)) # Output: [\'3\', \'7\', \'8\', \'5\', \'11\', \'2\', \'10\', \'9\'] or any valid topological sort ``` # Notes 1. Graphs can be visually represented as nodes pointing to dependent nodes. For instance, node \'5\' depends on node \'11\', thus, \'11\' must occur after \'5\' in the topological ordering. 2. If the graph contains a cycle, e.g., {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\']}, the function must raise a `ValueError`. Implement this function: ```python def topological_sort(graph): GRAY, BLACK = 0, 1 order, enter, state = [], set(graph), {} def dfs(node): state[node] = GRAY for k in graph.get(node, ()): sk = state.get(k, None) if sk == GRAY: raise ValueError(\\"cycle\\") if sk == BLACK: continue enter.discard(k) dfs(k) order.append(node) state[node] = BLACK while enter: dfs(enter.pop()) return order[::-1] ``` # Additional Requirements - Implement cycle detection as part of the function using Depth-First Search (DFS). - Ensure the solution is efficient and handles edge cases effectively.","solution":"def topological_sort(graph): GRAY, BLACK = 0, 1 order, enter, state = [], set(graph), {} def dfs(node): state[node] = GRAY for neighbor in graph.get(node, ()): neighbor_state = state.get(neighbor, None) if neighbor_state == GRAY: raise ValueError(\\"Graph contains a cycle\\") if neighbor_state == BLACK: continue enter.discard(neighbor) dfs(neighbor) order.append(node) state[node] = BLACK while enter: dfs(enter.pop()) return order[::-1]"},{"question":"# Question: Sorting RGB Values (Dutch National Flag Problem) Context: You are working on a project that processes images stored as arrays where each pixel can be red, white, or blue. For a particular task, you need to sort the pixel color values in such a way that all red pixels come first, followed by all white pixels, and finally all blue pixels. Task: Write a function `sort_colors` that takes a list of integers representing colors (0 for red, 1 for white, and 2 for blue) and sorts them in-place so that all occurrences of 0 come before 1, which come before 2. Input: - A list `nums` of length `n` where each element is either 0, 1, or 2. Output: - The input list `nums` sorted in-place such that all 0s come first, followed by all 1s, and then all 2s. Constraints: - Do not use the library\'s sorting function or any built-in sorting functions. - The solution should have a time complexity of O(n) and a space complexity of O(1). Example: ```python def sort_colors(nums): # Your implementation here if __name__ == \\"__main__\\": nums = [0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 2] sort_colors(nums) assert nums == [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2] ``` Additional Notes: - Think about the most efficient way to traverse and update the list using minimal extra space. - Pay special attention to the order and values of the indices to maintain the appropriate partitions.","solution":"def sort_colors(nums): Sorts the input list nums in-place such that all 0s come first, followed by all 1s, then all 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Remove Duplicates from Linked List You are given a singly linked list where each node contains a character value. Your task is to write a function that removes all duplicate values in the linked list. There are two methods provided, one with additional space and one without. Your goal is to implement and optimize both approaches. Input * A singly linked list, `head`, where each node contains a character. Output * The linked list with all duplicates removed. Constraints * Characters in the linked list can be any letter (A-Z), with possible repetitions. * The length of the linked list is at most 10^5. Requirements 1. `remove_dups(head)`: Remove duplicates using additional space (a set). 2. `remove_dups_without_set(head)`: Remove duplicates without using additional space. Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): hashset = set() prev = Node() while head: if head.val in hashset: prev.next = head.next else: hashset.add(head.val) prev = head head = head.next def remove_dups_without_set(head): current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) # Example usage: # Create a linked list A->A->B->C->D->C->F->G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates and print the list remove_dups(a1) print_linked_list(a1) remove_dups_without_set(a1) print_linked_list(a1) ``` * Implement the functions: `remove_dups` and `remove_dups_without_set`. * Ensure your function handles edge cases mentioned in the analysis. * Provide proper test cases to validate your solution.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): if head is None: return head hashset = set() current = head prev = None while current: if current.val in hashset: prev.next = current.next else: hashset.add(current.val) prev = current current = current.next return head def remove_dups_without_set(head): current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head def print_linked_list(head): result = [] while head: result.append(head.val) head = head.next print(\\" -> \\".join(result)) # Example usage: # Create a linked list A->A->B->C->D->C->F->G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates and print the list head = remove_dups(a1) print_linked_list(head) head = remove_dups_without_set(head) print_linked_list(head)"},{"question":"# Insertion Sort Implementation with Additional Requirements **Context**: You have been hired to optimize the sorting operations of a software dealing with customer orders. One of the tasks involves ensuring that a list of order values is sorted efficiently given different types of input scenarios. **Task**: Write a function named `optimized_insertion_sort` that will take as input a list of integers. Your function should sort the list using an enhanced version of the insertion sort algorithm where: 1. For a given sublist, if the size is above a certain threshold `k`, use the standard insertion sort. 2. If the size of the sublist is below or equal to `k`, use binary search to find the position for insertion (making it a binary insertion sort) to reduce the comparisons. **Requirements**: - Your function should switch between standard and binary insertion methods based on the threshold `k`. - The threshold `k` should be passed as an argument to your function. - Ensure you handle edge cases such as empty arrays or arrays with a single element. - The function should operate efficiently for both small and large lists. **Function Signature**: ```python def optimized_insertion_sort(arr: List[int], k: int) -> List[int]: pass ``` **Input**: 1. `arr` - a list of integers to be sorted. 2. `k` - an integer threshold that determines whether to use standard or binary insertion sort. **Output**: - A list of integers sorted in ascending order. **Constraints**: - 0 <= len(arr) <= 1000 - -10^6 <= `arr[i]` <= 10^6 for all valid `i` - 1 <= `k` <= 1000 **Example**: ```python input_arr = [5, 2, 9, 1, 5, 6] threshold_k = 3 print(optimized_insertion_sort(input_arr, threshold_k)) # Output: [1, 2, 5, 5, 6, 9] ``` **Note**: `optimized_insertion_sort` should be efficiently implement whether using standard or binary insertion sort by dynamically adjusting based on the threshold `k`.","solution":"from typing import List def binary_search(arr: List[int], val: int, start: int, end: int) -> int: Helper function to perform binary search to find the index to insert `val` while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def optimized_insertion_sort(arr: List[int], k: int) -> List[int]: Function to perform optimized insertion sort where it uses standard insertion sort if the sublist size is above threshold k, otherwise it uses binary insertion sort. if not arr: return arr for i in range(1, len(arr)): key = arr[i] # Perform standard insertion sort for large sublists if i > k: j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key else: # Perform binary insertion sort for small sublists j = i - 1 loc = binary_search(arr, key, 0, j + 1) while j >= loc: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: The algorithm is a Breadth-First Search (BFS) algorithm used to solve the \\"counting islands\\" problem. **Complexity**: - **Time complexity**: O(M × N) where M is the number of rows and N is the number of columns in the grid. Each cell is added and processed once in the queue. - **Space complexity**: O(M × N) for the `visited` array and potentially O(min(M, N)) for the BFS queue. **Principles**: The BFS approach systematically explores nodes level by level, ensuring all neighbors at the present depth level are explored before moving on to nodes at the next depth level. It is achieved using a queue data structure. **Properties**: - Traversal Order: BFS explores nodes in a layer-wise manner. - BFS is useful in finding the shortest path in unweighted graphs, connected components, etc. **Common Use Cases**: - Finding shortest paths in unweighted graphs. - Solving connectivity issues like determining connected components. - Level order traversal in trees. **Strengths/Limitations**: - **Strengths**: Ensures all nodes at a given distance are explored before deeper nodes, making it ideal for shortest path problems in unweighted graphs. - **Limitations**: Consumes more memory compared to Depth-First Search (DFS) due to its queue-based nature. **Implementation Challenges**: - **Edge Cases**: - Grids with all water or all land. - Irregular grid sizes (e.g., very large or small number of rows/columns). - Non-rectangular grids are not handled by this solution (each row must have the same number of columns). - **Performance Bottlenecks**: - Repeatedly checking each cell and its neighbors, leading to potentially high time complexity. - **Error Scenarios**: - Mismanagement of the queue could lead to infinite loops. - Incorrect boundary checks might lead to out-of-bound errors. - **Optimization Points**: - Efficiently managing the `visited` array. - Reducing repeated access to the grid cells by optimizing data structures used. <|Analysis End|> <|Question Begin|> # Counting Islands Using BFS You are given a 2D grid map where \'1\' represents land and \'0\' represents water. Your task is to count the number of distinct islands. An island is surrounded by water and is formed by horizontally or vertically connected lands. Function Signature ```python def count_islands(grid: List[List[int]]) -> int: ``` **Input**: - `grid`: A 2D list of integers where: - `grid[i][j]` is `1` if that cell is land and `0` if it is water. - Grid dimensions are M x N (1 <= M, N <= 100). **Output**: - Returns an integer representing the number of distinct islands. Constraints: 1. You can assume all four edges of the grid are surrounded by water. 2. Ensure your solution efficiently handles grids of the maximum possible size. Examples: 1. Example 1: ```plaintext Input: [[1,1,1,1,0], [1,1,0,1,0], [1,1,0,0,0], [0,0,0,0,0]] Output: 1 ``` 2. Example 2: ```plaintext Input: [[1,1,0,0,0], [1,1,0,0,0], [0,0,1,0,0], [0,0,0,1,1]] Output: 3 ``` 3. Example 3: ```plaintext Input: [[1,1,1,0,0,0], [1,1,0,0,0,0], [1,0,0,0,1,1], [0,0,1,1,0,0], [0,1,1,0,0,0]] Output: 3 ``` 4. Example 4: ```plaintext Input: [[1,1,0,0,1,1], [0,0,1,1,0,0], [0,0,0,0,0,1], [1,1,1,1,0,0]] Output: 5 ``` # Solution Requirements * The solution should correctly identify all connected components of land cells and count each uniquely connected component. * Use the BFS approach to explore connected components. * Ensure the solution handles edge cases, such as empty grids, entirely water grids, and varying grid sizes, gracefully.","solution":"from typing import List from collections import deque def count_islands(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def bfs(r, c): queue = deque([(r, c)]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: cr, cc = queue.popleft() for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 1: visited[nr][nc] = True queue.append((nr, nc)) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: visited[r][c] = True bfs(r, c) island_count += 1 return island_count"},{"question":"# Coding Challenge: Enhanced Diffie-Hellman Key Exchange with Error Handling Context Diffie-Hellman key exchange is a method that empowers two parties to establish a shared secret over an unsecured channel. However, for enhanced security and efficient operation, we must ensure that the inputs provided (large prime \'p\' and its primitive root \'a\') are valid. Task Write a function `secure_diffie_hellman(a, p, option=None)` that: 1. Validates that `p` is a large prime number. 2. Ensures that `a` is a primitive root of `p`. 3. Implements the Diffie-Hellman key exchange to generate a shared secret key securely. The function should handle edge cases and provide informative error messages if invalid inputs are provided. Function Signature ```python def secure_diffie_hellman(a: int, p: int, option: bool = None) -> bool: pass ``` Input * `a` and `p`: Two integers where: - `p` must be a large prime number. - `a` should be a primitive root of `p`. * `option`: (Optional) Boolean; if `True`, print steps of key exchange. Output * Returns `True` if the shared key computed by both parties matches. * Prints informative error messages in case of invalid inputs. Constraints * `1 < a < p` * 10^5 < p < 10^8 Example ```python secure_diffie_hellman(5, 23, True) ``` This should perform a secure Diffie-Hellman key exchange between Alice and Bob, printing intermediate keys if `option=True`, and return `True` if shared keys match. Notes - Ensure comprehensive validation for prime number and primitive root. - Optimize for performance given large constraints. - Consider edge cases and print clear error messages for invalid conditions.","solution":"def is_prime(n): Check if n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find the primitive root of p. if p == 2: return 1 # Find all prime factors of p-1 phi = p - 1 prime_factors = set() n = phi i = 2 while i * i <= n: if n % i == 0: prime_factors.add(i) while n % i == 0: n //= i i += 1 if n > 1: prime_factors.add(n) def is_primitive_root(a, p): # Check if a^phi/k != 1 (mod p) for all prime factors k of phi for factor in prime_factors: if pow(a, phi // factor, p) == 1: return False return True for a in range(2, p): if is_primitive_root(a, p): return a return None def secure_diffie_hellman(a, p, option=None): Securely perform the Diffie-Hellman key exchange. # Validate if p is a prime number if not is_prime(p): if option: print(f\'Error: {p} is not a prime number.\') return False # Validate if a is a primitive root of p if a != find_primitive_root(p): if option: print(f\'Error: {a} is not a primitive root of {p}.\') return False # Assuming Alice and Bob select random private keys private_key_Alice = 6 # just for the example, typically it should be a large random number private_key_Bob = 15 # just for the example, typically it should be a large random number # Alice computes her public key public_key_Alice = pow(a, private_key_Alice, p) # Bob computes his public key public_key_Bob = pow(a, private_key_Bob, p) if option: print(f\'Alice public key: {public_key_Alice}\') print(f\'Bob public key: {public_key_Bob}\') # Alice computes shared key shared_key_Alice = pow(public_key_Bob, private_key_Alice, p) # Bob computes shared key shared_key_Bob = pow(public_key_Alice, private_key_Bob, p) if option: print(f\'Alice shared key: {shared_key_Alice}\') print(f\'Bob shared key: {shared_key_Bob}\') # If both shared keys are the same, keys match and we return True return shared_key_Alice == shared_key_Bob"},{"question":"**Context**: A forensic linguist is analyzing various documents to check for occurrences of a specific phrase. Given a set of documents, the linguist is interested in identifying the starting index of the first occurrence of this phrase within each document using the Rabin-Karp pattern searching algorithm. **Task**: Write a function `find_first_occurrence(phrase: str, documents: List[str]) -> List[int]` that implements the Rabin-Karp algorithm to find the starting index of the first occurrence of the phrase in each document. If the phrase is not found in a document, the function should return -1 for that document. **Input**: - `phrase`: A string representing the phrase to search for. - `documents`: A list of strings where each string represents a document to be searched. **Output**: - A list of integers where each integer represents the starting index of the first occurrence of the phrase in the corresponding document, or -1 if the phrase is not found. **Constraints**: - The phrase and documents will only contain lowercase letters (\'a\' to \'z\'). - Phrase length will be between 1 and 10^5. - Each document length will be between 1 and 10^6. - The total length of all documents combined will not exceed 10^7. **Performance Requirements**: - The solution should be efficient in terms of time complexity, ideally leveraging the average-case O(n + m) complexity of the Rabin-Karp algorithm. **Example**: ```python def find_first_occurrence(phrase: str, documents: List[str]) -> List[int]: # Your implementation here # Example usage: phrase = \\"needle\\" documents = [\\"haystack needle haystack\\", \\"foo bar baz\\"] print(find_first_occurrence(phrase, documents)) # Output should be [9, -1] ```","solution":"from typing import List def find_first_occurrence(phrase: str, documents: List[str]) -> List[int]: Implements the Rabin-Karp algorithm to find the starting index of the first occurrence of the phrase in each document. Returns -1 for documents where the phrase is not found. def hash_function(s: str) -> int: return sum(ord(c) for c in s) phrase_len = len(phrase) phrase_hash = hash_function(phrase) results = [] for doc in documents: if len(doc) < phrase_len: results.append(-1) continue current_hash = hash_function(doc[:phrase_len]) if current_hash == phrase_hash and doc[:phrase_len] == phrase: results.append(0) continue found = False for i in range(1, len(doc) - phrase_len + 1): current_hash = current_hash - ord(doc[i - 1]) + ord(doc[i + phrase_len - 1]) if current_hash == phrase_hash and doc[i:i + phrase_len] == phrase: results.append(i) found = True break if not found: results.append(-1) return results"},{"question":"You\'re provided with a list of sorted lowercase characters `letters` and a target character `target`. Your task is to determine the smallest character in the list that is larger than the given `target`. If no such character exists, the list is considered to be circular and you should return the smallest character in the list. # Input: - `letters`: list of lowercase characters sorted in ascending order. - `target`: a single lowercase character. # Output: - A single character representing the smallest character that is larger than `target`. # Constraints: - All characters in `letters` are distinct. - `1 <= len(letters) <= 10^4` - `letters` contains only lowercase alphabet characters. - `target` is a lowercase alphabet character. # Performance Requirements: - The solution must handle up to 10,000 elements efficiently. # Examples: Example 1: ```plaintext Input: letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" Output: \\"c\\" ``` Example 2: ```plaintext Input: letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" Output: \\"f\\" ``` Example 3: ```plaintext Input: letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" Output: \\"f\\" ``` # Instructions: Implement the function `find_next_greatest_letter(letters: List[str], target: str) -> str` in Python that solves the problem. Optimize your solution both for time and space complexity. # Additional Requirement: Your implementation should handle the wrap-around condition efficiently using any of the provided methods or an optimized approach if you can think of a better solution.","solution":"def find_next_greatest_letter(letters, target): Find the smallest letter in the sorted list that is larger than the target letter. If no such letter exists, return the first letter in the list (wrap around). left, right = 0, len(letters) - 1 while left <= right: mid = (left + right) // 2 if letters[mid] > target: right = mid - 1 else: left = mid + 1 return letters[left % len(letters)]"},{"question":"# Assessment Question Context You\'re tasked with writing a function that finds the longest common subsequence between two strings. Notably, the second string is guaranteed to contain all distinct characters. This is a typical problem in comparing DNA sequences where one sequence has unique bases or finding common patterns in logs with distinct keys. Problem Statement You are provided with two strings `s1` and `s2`. The string `s2` contains all unique characters. Your task is to implement a function `longest_common_subsequence(s1, s2)` that finds the longest contiguous common subsequence present in both `s1` and `s2`. Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> str: ``` Input - `s1` (str) - First input string. - `s2` (str) - Second input string with all unique characters. Output - Returns the longest contiguous common subsequence present in both strings. Constraints - The function should run in O(n log n) time complexity, where `n` is the length of `s1`. - Extra space complexity should be kept minimal, ideally within O(m), where `m` is the length of `s2`. Edge Cases - Both strings are empty. - One of the strings is empty. - No common subsequence exists. Example ```python s1 = \\"abcde\\" s2 = \\"ac\\" Output: \\"a\\" s1 = \\"abcdef\\" s2 = \\"azced\\" Output: \\"a\\" s1 = \\"abcdez\\" s2 = \\"z\\" Output: \\"z\\" ``` Considerations - Make sure to handle edge cases where no subsequence is found correctly. - Take advantage of the property that `s2` has all unique characters to optimize your solution. Good luck, and remember to test thoroughly!","solution":"def longest_common_subsequence(s1: str, s2: str) -> str: Finds the longest contiguous common subsequence present in both s1 and s2. This function assumes that the characters in s2 are all unique. m, n = len(s1), len(s2) max_len = 0 end_idx_s1 = 0 # Dynamic programming table to store lengths of longest common suffixes dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] end_idx_s1 = i else: dp[i][j] = 0 longest_subsequence = s1[end_idx_s1 - max_len:end_idx_s1] if max_len > 0 else \\"\\" return longest_subsequence"},{"question":"# Flattening Nested Arrays You are given a potentially deeply nested list which might include multiple layers of nested sub-lists. Your task is to implement a function to flatten this nested list into a single, flat list which includes all the elements of the original nested list. **Objective**: Implement this flattening operation both in a recursive manner and using an iterative (generator) approach while considering Python\'s characteristics and constraints. Requirements 1. **Recursive Function**: Implement a recursive function `flatten` which receives a nested list and returns a flat list containing all elements. 2. **Iterator Function**: Implement a function `flatten_iter` which uses an iterator to lazily flatten the nested list, yielding elements one-by-one. Function Signatures ```python def flatten(input_arr): pass def flatten_iter(input_arr): pass ``` Input * **input_arr**: A list which could include multiple layers of nested sub-lists. Example: `[1, [2, [3, [4]]]]`. Output * **flatten** should return a single flat list including all elements. Example: `[1, 2, 3, 4]`. * **flatten_iter** should return an iterator that yields elements one-by-one. Constraints * Nested list depth will not exceed 1000. * List can contain multiple data types including integers, strings, lists, etc. * Iterators should handle arbitrary-length iterables without consuming too much memory. Example ```python # Example usage of flatten function print(flatten([1, [2, [3, [4]]]])) # Output: [1, 2, 3, 4] # Example usage of flatten_iter function print(list(flatten_iter([1, [2, [3, [4]]]]))) # Output: [1, 2, 3, 4] ``` Notes 1. Avoid treating strings as iterables of characters. 2. Ensure the recursive function does not exceed Python\'s recursion limit for very deep nested structures.","solution":"from collections.abc import Iterable def flatten(input_arr): Recursively flatten a nested list. flat_list = [] for item in input_arr: if isinstance(item, list): flat_list.extend(flatten(item)) else: flat_list.append(item) return flat_list def flatten_iter(input_arr): Iteratively flatten a nested list using a generator. for item in input_arr: if isinstance(item, list): yield from flatten_iter(item) else: yield item"},{"question":"# Interval Merging Challenge **Context**: You are given a class `Interval` that represents a set of real numbers between a given start and end. This class supports several operations, such as checking if a number is contained within the interval, merging intervals, and converting intervals to a list. Additionally, you\'ll merge intervals directly using a helper function. **Requirements**: Your task is to implement an additional function `find_overlap_intervals(intervals)` that takes a list of `Interval` objects and returns overlapping intervals in the list. # Function Signature ```python def find_overlap_intervals(intervals: List[Interval]) -> List[Tuple[Interval, Interval]]: pass ``` # Input * `intervals`: A list of `Interval` objects. # Output * A list of tuples where each tuple contains two overlapping `Interval` objects. # Constraints * Each interval in the list is a valid `Interval` object. * Do not modify the original list and maintain the interval properties. * Optimize for performance, ideally ( O(n log n) ). # Example ```python i1 = Interval(1, 3) i2 = Interval(2, 4) i3 = Interval(5, 7) intervals = [i1, i2, i3] # Calling your function print(find_overlap_intervals(intervals)) # Expected output: [(Interval(1, 3), Interval(2, 4))] ``` # Additional Notes * Intervals (1, 3) and (2, 4) overlap, so they should be included in the result. * Use the functionalities of the `Interval` class where appropriate, especially for comparing and merging intervals. # Implement and Test Make sure to test your function with various cases including typical, edge, and performance-critical scenarios to ensure correctness and efficiency.","solution":"from typing import List, Tuple class Interval: def __init__(self, start: int, end: int): self.start = start self.end = end def __repr__(self): return f\'Interval({self.start}, {self.end})\' def overlaps(self, other: \'Interval\') -> bool: return self.start <= other.end and other.start <= self.end def find_overlap_intervals(intervals: List[Interval]) -> List[Tuple[Interval, Interval]]: Finds overlapping intervals in a list of Interval objects. # Sort intervals by start time intervals.sort(key=lambda x: x.start) overlap_pairs = [] for i in range(len(intervals) - 1): for j in range(i + 1, len(intervals)): if intervals[i].overlaps(intervals[j]): overlap_pairs.append((intervals[i], intervals[j])) else: # Since the intervals are sorted, if the current interval does not overlap with the next, # it won\'t overlap with the subsequent intervals either break return overlap_pairs"},{"question":"# Question: Implement Modified Kruskal\'s Algorithm You are provided with a weighted, undirected graph. Your task is to implement a function `calculate_mst_weight` using a modified version of Kruskal’s algorithm. This modified version additionally returns the edges included in the MST. Function Signature ```python def calculate_mst_weight(vertices: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[Tuple[int, int]]]: ``` Input * `vertices`: An integer `V` denoting the number of vertices in the graph. * `edges`: A list of tuples, where each tuple `(u, v, w)` represents an edge in the graph. `u` and `v` are the nodes connected by the edge, and `w` is the weight of the edge. Output * The function should return a tuple containing: - An integer representing the total weight of the MST. - A list of tuples representing the edges in the MST. Each tuple `(u, v)` denotes an edge between vertices `u` and `v`. Constraints * 1 <= `vertices` <= 1000 * 0 <= `edges` <= (vertices * (vertices - 1)) / 2 * Edge weights are positive integers. Note Vertices are 1-indexed, ranging from 1 to `vertices`. Example ```python vertices = 5 edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] print(calculate_mst_weight(vertices, edges)) # Output: (14, [(1, 2), (3, 4), (3, 5), (2, 4)]) ``` Explanation For the provided graph, the function calculates the minimum spanning tree with a total weight of 14 and includes the edges `(1, 2)`, `(3, 4)`, `(3, 5)`, and `(2, 4)`.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.root = [i for i in range(size)] self.rank = [1] * size def find(self, u): if self.root[u] != u: self.root[u] = self.find(self.root[u]) return self.root[u] def union(self, u, v): rootU = self.find(u) rootV = self.find(v) if rootU != rootV: if self.rank[rootU] > self.rank[rootV]: self.root[rootV] = rootU elif self.rank[rootU] < self.rank[rootV]: self.root[rootU] = rootV else: self.root[rootV] = rootU self.rank[rootU] += 1 return True return False def calculate_mst_weight(vertices: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[Tuple[int, int]]]: edges.sort(key=lambda x: x[2]) # Sort edges by weight uf = UnionFind(vertices + 1) mst_weight = 0 mst_edges = [] for u, v, weight in edges: if uf.union(u, v): mst_weight += weight mst_edges.append((u, v)) return mst_weight, mst_edges"},{"question":"RSA Encryption/Decryption System Context You have been tasked to design a secure communication module that uses the RSA encryption algorithm to protect data being transmitted between clients and a server. To achieve this, you need to implement functions to generate RSA keys, encrypt data, and decrypt data. Task Implement the following functions in Python: 1. `generate_key(k: int, seed: int = None) -> Tuple[int, int, int]`: - Generates and returns RSA keys. - **Input**: - `k` (int): The number of bits in `n`. `k` will be a positive integer, typically 1024 or 2048. - `seed` (int or None): Optional seed for random number generation to ensure repeatability in tests. - **Output**: - A tuple `(n, e, d)` where: - `n` is the modulus. - `e` is the public exponent. - `d` is the private exponent. 2. `encrypt(data: int, e: int, n: int) -> int`: - Encrypts the given data using the RSA algorithm. - **Input**: - `data` (int): The integer data to be encrypted. - `e` (int): The public exponent from the RSA key. - `n` (int): The modulus from the RSA key. - **Output**: - The encrypted integer. 3. `decrypt(data: int, d: int, n: int) -> int`: - Decrypts the given encrypted data using the RSA algorithm. - **Input**: - `data` (int): The encrypted integer. - `d` (int): The private exponent from the RSA key. - `n` (int): The modulus from the RSA key. - **Output**: - The decrypted integer. Constraints 1. The number of bits `k` for key generation will be a positive integer between 16 and 4096. 2. The data to encypt/decrypt will be a non-negative integer. 3. Ensure that `p` and `q` are at least `k/2` bits each, and both should not be the same. Example You can test your implementation using the following: ```python # Example usage: # Key Generation n, e, d = generate_key(16) # Data Encryption data = 20 encrypted_data = encrypt(data, e, n) # Data Decryption decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data ``` This confirms that the RSA encryption and decryption processes are functioning correctly. Test your implementation rigorously to ensure all edge cases are handled, especially for different values of `k`.","solution":"import random from typing import Tuple from sympy import isprime, mod_inverse def generate_prime(bits: int, seed = None) -> int: if seed is not None: random.seed(seed) while True: num = random.getrandbits(bits) if isprime(num): return num def generate_key(k: int, seed: int = None) -> Tuple[int, int, int]: half_bits = k // 2 p = generate_prime(half_bits, seed) q = generate_prime(half_bits, seed + 1 if seed else None) while p == q: q = generate_prime(half_bits, seed + 1 if seed else None) n = p * q phi = (p-1) * (q-1) e = 65537 while True: try: d = mod_inverse(e, phi) break except ValueError: e += 2 # Try next odd number return n, e, d def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Question **Objective**: Implement a function to identify the unique element in an array where each element appears twice except for one. **Scenario**: Consider you are given an array of integers where every element appears twice except for one unique element. We need to identify this unique element efficiently. **Function Signature**: ```python def find_unique_element(arr: List[int]) -> int: This function takes a list of integers where every element appears twice except for one. It returns the element which appears only once. Args: arr (List[int]): The input list of integers. Returns: int: The single integer that appears only once in the list. ``` **Input**: * `arr`: A list of integers where every element appears exactly twice, except for one. **Output**: * An integer which appears only once in the input list. **Constraints**: * The function should run in linear time, O(n). * The function should use constant extra space, O(1). * The length of the list will be at least 1 and elements can be negative. **Example**: ```python assert find_unique_element([2, 2, 3, 3, 4, 4, 5]) == 5 assert find_unique_element([1]) == 1 assert find_unique_element([4, 1, 2, 1, 2]) == 4 ``` You are required to implement the function `find_unique_element` that meets the above requirements.","solution":"def find_unique_element(arr): This function takes a list of integers where every element appears twice except for one. It returns the element which appears only once. Args: arr (List[int]): The input list of integers. Returns: int: The single integer that appears only once in the list. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"Task Write a function `get_unique_permutations(nums)` that takes a list of integers `nums` (which may contain duplicates) and returns a list of all unique permutations in any order. Input - `nums`: A list of integers, where 1 <= len(nums) <= 8. Output - A list of lists, where each inner list is a unique permutation of the input list. Constraints - All elements in `nums` are integers. - Duplicates in `nums` should not produce duplicate permutations in the output. Performance Requirements - Your solution should aim for a time complexity of O(N * N!), where N is the length of the input list. Example ```python # Example Input nums = [1, 1, 2] # Example Output # The order of permutations does not matter. # [ # [1, 1, 2], # [1, 2, 1], # [2, 1, 1] # ] result = get_unique_permutations(nums) print(result) # Should output the unique permutations. ``` Guidelines 1. Ensure your function handles edge cases such as empty lists or lists with all identical elements. 2. Avoid generating duplicate permutations by implementing checks within your logic. 3. Submit a function definition without additional print statements or input calls.","solution":"from itertools import permutations def get_unique_permutations(nums): Returns a list of all unique permutations of the input list nums. return list(map(list, set(permutations(nums))))"},{"question":"# Coding Challenge: Enhancing the Linear Search Algorithm Context You are part of a software development team working on a data management system. As part of the project, you are required to enhance the search functionality to allow flexible element lookup. The current implementation is a simple linear search. Objective Extend the functionality of the provided `linear_search` function to handle a broader set of requirements. Specifically, you will enhance the search function to support searching multiple elements and provide functionality to start searching from a specified index. Function Signature ```python def enhanced_linear_search(array: list, queries: list, start_index: int = 0): Finds the index of the given elements in the array starting from a specified index. Parameters: - array (list): List of elements to search within. - queries (list): List of elements to search for. - start_index (int): The index from which to start the search. Returns: - dict: A dictionary where keys are the query elements, and values are their respective index in the array. If an element is not found, its index should be -1. ``` Input Format 1. `array`: A list of integers or strings. 2. `queries`: A list of integers or strings that need to be searched within `array`. 3. `start_index`: An integer specifying the index from which the search should start. Output Format - The function should return a dictionary where each query element maps to its index found within the `array`. If a query element is not found, the dictionary should map it to -1. Constraints - Elements in `array` need not be unique. - Elements in `queries` may not be present in `array`. - 0 <= start_index < len(array) - Edge cases such as an empty array, empty queries list, and start_index being out of range should be considered. Examples ```python # Example 1: array = [10, 20, 30, 40, 50] queries = [30, 50, 70] start_index = 1 # Output: {30: 2, 50: 4, 70: -1} # Example 2: array = [\'apple\', \'banana\', \'cherry\', \'date\'] queries = [\'date\', \'cherry\'] start_index = 2 # Output: {\'date\': 3, \'cherry\': 2} ```","solution":"def enhanced_linear_search(array, queries, start_index=0): Finds the index of the given elements in the array starting from a specified index. Parameters: - array (list): List of elements to search within. - queries (list): List of elements to search for. - start_index (int): The index from which to start the search. Returns: - dict: A dictionary where keys are the query elements, and values are their respective index in the array. If an element is not found, its index should be -1. result = {} for query in queries: result[query] = -1 # Default to -1 if not found. for i in range(start_index, len(array)): if array[i] == query: result[query] = i break return result"},{"question":"You are working on a project that involves data filtering. Your task is to limit the number of occurrences of each element in a list `lst` to at most `N` times while preserving the order of elements. Given a list and an integer `n`, write a Python function `delete_nth(lst, n)` that performs this operation efficiently. # Input * A list of integers `lst` where 1 ≤ len(lst) ≤ 10^6. * An integer `n` where n ≥ 0. # Output * A list of integers with each element appearing at most `n` times in the same order as they appear in the input list. # Constraints * Elements in the list range from -10^9 to 10^9. * The function should operate with time complexity O(n). # Examples ```python # Example 1 input_list = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 print(delete_nth(input_list, n)) # Output: [1, 2, 3, 1, 2, 3] # Example 2 input_list = [1, 1, 1, 1] n = 1 print(delete_nth(input_list, n)) # Output: [1] # Example 3 input_list = [] n = 2 print(delete_nth(input_list, n)) # Output: [] ``` # Requirements * Your function should handle edge cases efficiently. * Consider performance and memory usage when implementing the solution.","solution":"def delete_nth(lst, n): Returns a list with each element appearing at most n times while preserving the order of elements. from collections import defaultdict result = [] counts = defaultdict(int) for item in lst: if counts[item] < n: result.append(item) counts[item] += 1 return result"},{"question":"# Problem Description You have been provided with the algorithm for inverting an n x n matrix. Your task is to extend this functionality by implementing a function that can handle special cases more efficiently and handle larger matrices with an optimized determinant calculation. # Requirements 1. **Optimize Determination Calculation**: - Implement LU decomposition to calculate the determinant more efficiently for matrices larger than 3x3. - Your determinant function should dynamically choose between direct calculation and LU decomposition based on the matrix size. 2. **Function Signature** ```python def advanced_invert_matrix(matrix: List[List[float]]) -> List[List[float]]: This function inverts a given n x n matrix if it is invertible. :param matrix: A list of lists where each inner list represents a row of the matrix. :return: A list of lists representing the inverse of the input matrix, or an appropriate error code matrix. ``` 3. **Input/Output Formats**: - **Input**: A square matrix (list of lists), where each inner list represents a row. - **Output**: - Inverted matrix as a list of lists. - Return [[-1]] if matrix is not square. - Return [[-2]] if the matrix is singular. - Additional meaningful error codes can be added if necessary. 4. **Constraints**: - Matrix sizes will be between 2x2 and 10x10. - Elements in the matrix are floating-point numbers. # Example ```python example_matrix = [ [4, 7], [2, 6] ] output_matrix = advanced_invert_matrix(example_matrix) # Expected output: # [ # [0.6, -0.7], # [-0.2, 0.4] # ] ``` # Hint - For LU decomposition, consider using a helper function or external libraries, but ensure you understand the underlying principle. Implement the function `advanced_invert_matrix` by taking into consideration all edge cases and required efficiency improvements.","solution":"from typing import List import numpy as np def is_square_matrix(matrix: List[List[float]]) -> bool: return all(len(row) == len(matrix) for row in matrix) def lu_decomposition(matrix: List[List[float]]) -> (List[List[float]], List[List[float]], List[int]): n = len(matrix) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] P = list(range(n)) for i in range(n): max_index = i max_value = abs(matrix[i][i]) for j in range(i + 1, n): if abs(matrix[j][i]) > max_value: max_value = abs(matrix[j][i]) max_index = j if max_index != i: matrix[i], matrix[max_index] = matrix[max_index], matrix[i] P[i], P[max_index] = P[max_index], P[i] for j in range(i, n): U[i][j] = matrix[i][j] for k in range(i): U[i][j] -= L[i][k] * U[k][j] for j in range(i + 1, n): L[j][i] = matrix[j][i] / U[i][i] for k in range(i): L[j][i] -= L[j][k] * U[k][i] / U[i][i] for i in range(n): L[i][i] = 1.0 return L, U, P def determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] elif n == 3: return (matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0])) else: if not is_square_matrix(matrix): return 0.0 _, U, P = lu_decomposition(matrix) det = 1.0 for i in range(n): det *= U[i][i] if len(set(P)) != len(P): # if permutation is an odd number, apply sign change det *= -1 return det def advanced_invert_matrix(matrix: List[List[float]]) -> List[List[float]]: if not is_square_matrix(matrix): return [[-1]] n = len(matrix) det = determinant(matrix) if det == 0: return [[-2]] try: matrix_np = np.array(matrix) matrix_inv_np = np.linalg.inv(matrix_np) return matrix_inv_np.tolist() except np.linalg.LinAlgError: return [[-2]]"},{"question":"# Array Filtering Challenge Background You are working on a data preprocessing module that requires filtering numerical data based on specified lower and upper bounds. This is particularly useful in scenarios like data analysis, where only values within a certain range are significant for further analysis. Problem Statement Write a function `filter_range(arr, min_lim=None, max_lim=None)` that filters the given list of integers, `arr`, and returns a new list containing only the elements that fall within `(min_lim, max_lim)` inclusive. If `min_lim` is `None`, treat it as negative infinity (i.e., no lower bound). If `max_lim` is `None`, treat it as positive infinity (i.e., no upper bound). Function Signature ```python def filter_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` Input - `arr`: List of integers. (`1 <= len(arr) <= 10^6`, `-10^9 <= arr[i] <= 10^9`) - `min_lim`: Optional integer representing the lower bound. - `max_lim`: Optional integer representing the upper bound. Output - Returns a new list of integers filtered within the given `min_lim` and `max_lim`. Constraints - If `arr` is empty, return an empty list. - If both `min_lim` and `max_lim` are `None`, return the original list as all values are considered to be within the range. Examples Example 1: ```python arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 filter_range(arr, min_lim, max_lim) ``` Output: ```python [1, 2, 3] ``` Example 2: ```python arr = [10, 20, 30, 40, 50] min_lim = 25 max_lim = None filter_range(arr, min_lim, max_lim) ``` Output: ```python [30, 40, 50] ``` Example 3: ```python arr = [] min_lim = 5 max_lim = 15 filter_range(arr, min_lim, max_lim) ``` Output: ```python [] ``` Example 4: ```python arr = [5, -10, 15, 20, 25] min_lim = 0 max_lim = 20 filter_range(arr, min_lim, max_lim) ``` Output: ```python [5, 15, 20] ``` Additional Notes - Ensure the solution runs efficiently within the provided constraints. - Consider potential edge cases and handle them appropriately.","solution":"from typing import List, Optional def filter_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the list of integers to include only those within the (min_lim, max_lim) inclusive range. Parameters: arr (List[int]): The list of integers to filter. min_lim (Optional[int]): The minimum limit (inclusive). If None, there\'s no lower bound. max_lim (Optional[int]): The maximum limit (inclusive). If None, there\'s no upper bound. Returns: List[int]: A new list with elements filtered within the specified range. if min_lim is None and max_lim is None: return arr if min_lim is None: return [x for x in arr if x <= max_lim] if max_lim is None: return [x for x in arr if x >= min_lim] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Matrix Inversion Problem You are tasked to implement a function called `invert_matrix` that inverts an invertible n x n matrix. Given an input matrix A, your function should return a matrix B such that the product of A and B yields the identity matrix of size n x n. # Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: Inverts the given n x n matrix and returns the resulting inverted matrix. ``` # Input - `matrix`: A list of lists where each inner list represents a row of an n x n matrix. - Will always be of dimension n x n where 2 ≤ n ≤ 10. - Entries of the matrix are floating-point numbers. # Output - Returns an n x n matrix which is the inverse of the input matrix. # Constraints - The matrix will be a square matrix of size n x n. - The matrix is guaranteed to be invertible. - The size of the matrix is reasonably small to allow for direct computation without excessive performance issues. # Example ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] ``` # Notes 1. Your solution should check for basic validity of the matrix, and you may assume that matrices provided will be invertible. 2. Utilize the steps outlined in the core algorithm: compute the matrix of minors, adjust for cofactors, transpose, and finally, scale by the determinant\'s reciprocal. 3. Be mindful of computational efficiency and handling of floating point arithmetic accurately.","solution":"from typing import List def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: import numpy as np np_matrix = np.array(matrix) inverse_np_matrix = np.linalg.inv(np_matrix) return inverse_np_matrix.tolist()"},{"question":"You are given a **singly linked list** implemented using the provided `Node` class. Write a function `count_cycle_length(head: Node) -> int` that returns the length of the cycle in the linked list. If there is no cycle, the function should return `-1`. # Input: * `head`: The head node of the singly linked list (node type `Node`). # Output: * An integer representing the length of the cycle. Return \'-1\' if no cycle is present. # Function Signature: ```python def count_cycle_length(head: Node) -> int: # Your code here ``` # Constraints: * You should aim for a solution with `O(n)` time complexity and `O(1)` space complexity. * The linked list could be empty (i.e., head is None) or have no cycle. * Do not mutate the linked list. # Example: ```python class Node: def __init__(self, x): self.val = x self.next = None # Example Linked List with cycle # 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle) head = Node(1) second = Node(2) third = Node(3) fourth = Node(4) fifth = Node(5) head.next = second second.next = third third.next = fourth fourth.next = fifth fifth.next = second assert count_cycle_length(head) == 4 # There is a cycle of length 4 # Example Linked List without cycle # 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) second = Node(2) third = Node(3) fourth = Node(4) fifth = Node(5) head.next = second second.next = third third.next = fourth fourth.next = fifth assert count_cycle_length(head) == -1 # No cycle present ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def count_cycle_length(head: Node) -> int: Detects if there is a cycle in the linked list and returns its length. If there is no cycle, returns -1. if not head or not head.next: return -1 slow, fast = head, head # Step 1: Determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: # No cycle detected return -1 # Step 2: Determine the length of the cycle current = slow cycle_length = 0 while True: current = current.next cycle_length += 1 if current == slow: break return cycle_length"},{"question":"# Question: FizzBuzz Extended You are to implement a function to generate a sequence from 1 to N, following specific rules for replacements. Extend the traditional FizzBuzz problem with an additional condition. Function Signature ```python def extended_fizzbuzz(n: int) -> list: pass ``` Input - An integer `n` where ( 1 leq n leq 10^4 ). Output - A list of length `n` containing integers and strings based on the conditions. Conditions - If the value is a multiple of 3, use the value \\"Fizz\\". - If the value is a multiple of 5, use the value \\"Buzz\\". - If the value is a multiple of 3 and 5, use the value \\"FizzBuzz\\". - If the value is a multiple of 7, use the value \\"Bazz\\". - If the value meets multiple conditions, concatenate the strings in the order of \\"FizzBuzzBazz\\". Example ```python extended_fizzbuzz(15) # Expected Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Bazz\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Bazz\', \'FizzBuzz\'] ``` Constraints - You must handle invalid inputs gracefully by raising appropriate exceptions. - `ValueError` for `n < 1`. - `TypeError` for non-integer inputs. Context This problem helps to test the understanding of looping, conditionals, modular arithmetic, and string operations.","solution":"def extended_fizzbuzz(n: int) -> list: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 1: raise ValueError(\\"Input must be a positive integer greater than zero\\") result = [] for i in range(1, n + 1): value = \\"\\" if i % 3 == 0: value += \\"Fizz\\" if i % 5 == 0: value += \\"Buzz\\" if i % 7 == 0: value += \\"Bazz\\" result.append(value if value != \\"\\" else i) return result"},{"question":"# Repeated String Match Problem Scenario Company X has a system for processing textual documents that often requires ensuring certain phrases are present within certain headers or sections. While performing these checks, you are tasked with ensuring a phrase is repeated sufficiently within a given header. This requires you to find the minimal repetition of strings. Task Given two strings, A and B, write a function `repeat_string(A: str, B: str) -> int` that determines the minimum number of times A should be repeated so that B is a substring of the repeated A. If it is not possible for B to be a substring of any number of repetitions of A, return -1. Input and Output - **Input**: - `A`: A string of length between 1 and 10,000. - `B`: Another string of length between 1 and 10,000. - **Output**: - Returns an integer representing the minimum number of repetitions required, or -1 if B cannot be a substring of the repeated A. - **Constraints**: - You should ensure that your solution handles the constraints efficiently in terms of both time and space. Example Example 1: - Input: `A = \\"abcd\\"`, `B = \\"cdabcdab\\"` - Output: `3` - Explanation: Repeating A three times (abcdabcdabcd) makes B a substring. Example 2: - Input: `A = \\"a\\"`, `B = \\"aa\\"` - Output: `2` - Explanation: Repeating A two times (aa) makes B a substring. Function Signature ```python def repeat_string(A: str, B: str) -> int: count = 1 tmp = A max_count = (len(B) / len(A)) + 1 while not (B in tmp): tmp = tmp + A if count > max_count: count = -1 break count += 1 return count ``` Implement the function accordingly.","solution":"def repeat_string(A: str, B: str) -> int: Determines the minimum number of times A should be repeated so that B is a substring of the repeated A. Returns -1 if B cannot be a substring of any number of repetitions of A. count = 1 repeated_A = A max_length = len(A) * (len(B) // len(A) + 2) while len(repeated_A) <= max_length: if B in repeated_A: return count repeated_A += A count += 1 return -1"},{"question":"# Queue Data Structure Assessment Context: Joan is developing a new game application where various tasks are queued up for execution. To manage these tasks, she needs a reliable queue implementation. For performance reasons, she decides to implement a queue using a circular buffer. This queue must efficiently handle extensive operations and avoid the frequent resizing problem present in a simple dynamic array-based queue. Task: Implement a `CircularQueue` class that follows the `AbstractQueue` interface as provided below. The class should support dynamic sizing with efficient use of the array to avoid frequent resizing. Requirements: 1. **enqueue(item)**: Adds a new item to the rear of the queue. 2. **dequeue()**: Removes the front item from the queue. 3. **peek()**: Returns the front element of the queue. 4. **isEmpty()**: Returns a boolean indicating whether the queue is empty. 5. **__iter__()**: Iterates over the queue from front to rear. # Input/Output Specifications * The queue should initialize with a default capacity of 10 items. * Resize the queue dynamically when it is full. * The iterator should provide a means to access the elements of the queue in FIFO order. Constraints: * Do not use built-in queue data structures. * Consider edge cases such as dequeuing from an empty queue. * Ensure that the CircularQueue provides O(1) time complexity for `enqueue`, `dequeue`, and `peek`. # Example: ```python cq = CircularQueue() cq.enqueue(1) cq.enqueue(2) print(cq.dequeue()) # Output: 1 print(cq.peek()) # Output: 2 print(cq.is_empty())# Output: False for item in cq: print(item) # Output: 2 ``` Implementation Template: ```python class CircularQueue(AbstractQueue): def __init__(self, capacity=10): super().__init__() # Initialize circular buffer with the given capacity self._array = [None] * capacity self._front = 0 self._rear = 0 def __iter__(self): # Implement the iterator to traverse the queue pass def enqueue(self, value): # Implement enqueue method pass def dequeue(self): # Implement dequeue method pass def peek(self): # Implement peek method pass def _expand(self): # Implement dynamic expansion of the circular buffer pass # Define the necessary methods following the AbstractQueue interface principles ```","solution":"class CircularQueue: def __init__(self, capacity=10): self._array = [None] * capacity self._front = 0 self._rear = 0 self._size = 0 self._capacity = capacity def __iter__(self): index = self._front num_elements_yielded = 0 while num_elements_yielded < self._size: yield self._array[index] index = (index + 1) % self._capacity num_elements_yielded += 1 def enqueue(self, value): if self._size == self._capacity: self._expand() self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self._array[self._front] def is_empty(self): return self._size == 0 def _expand(self): new_capacity = self._capacity * 2 new_array = [None] * new_capacity for i in range(self._size): new_array[i] = self._array[(self._front + i) % self._capacity] self._array = new_array self._front = 0 self._rear = self._size self._capacity = new_capacity"},{"question":"# Question: Frequency Distribution of Elements You are tasked with designing a function `frequency_distribution` that calculates the frequency distribution of elements in a given list. This function will help analyze how often each distinct element appears in the list. **Function Signature:** ```python def frequency_distribution(input_list: list) -> dict: Calculate the frequency distribution of elements in the given list. :param input_list: A list of elements (can be integers, strings, etc.) :return: A dictionary with elements of the list as keys and their frequencies as values. ``` # Input: * `input_list`: A list of elements. The elements can be integers, strings, or a mix of hashable data types. (1 <= len(input_list) <= 10**5) # Output: * The function should return a dictionary where keys are the unique elements from the input list, and the values are the counts of these elements. # Constraints: * All elements in the list must be hashable (able to be used as dictionary keys). # Scenario: Imagine you\'re working with a large dataset of user activities, and you\'d like to understand how frequently each type of activity occurs. This information could be pivotal in evaluating user behavior and optimizing user experience. # Example: ```python input_list_1 = [3, 3, 2, 1] # Output: {1: 1, 2: 1, 3: 2} input_list_2 = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"] # Output: {\\"apple\\": 2, \\"banana\\": 3, \\"orange\\": 1} input_list_3 = [] # Output: {} ``` Implement the `frequency_distribution` function to solve this problem. Make sure your solution is efficient and handles all edge cases appropriately.","solution":"def frequency_distribution(input_list): Calculate the frequency distribution of elements in the given list. :param input_list: A list of elements (can be integers, strings, etc.) :return: A dictionary with elements of the list as keys and their frequencies as values. frequency_dict = {} for item in input_list: if item in frequency_dict: frequency_dict[item] += 1 else: frequency_dict[item] = 1 return frequency_dict"},{"question":"# Bogo Sort Re-Implementation Challenge Imagine you\'ve been hired as a software engineer at a startup that enjoys creating quirky and fun educational tools. One of your tasks is to impress upon learners the importance of choosing the right algorithms by implementing a deliberately inefficient one. To this end, you are asked to write the Bogo Sort algorithm from scratch and run a simulation to illustrate its inefficiency. Task Write a function `bogo_sort(arr)` that implements the Bogo Sort algorithm without using any pre-existing sort functions. Your function should include a simulation mode that visually demonstrates each shuffle until the array is sorted. Function Signature ```python def bogo_sort(arr: list[int], simulation: bool = False) -> list[int]: pass ``` Input and Output * **Input**: * `arr` (list of integers): The list of integers to sort. * `simulation` (boolean, optional): If set to `True`, the function should print each shuffle iteration. Default is `False`. * **Output**: * A list of integers sorted in non-decreasing order. Constraints * The length of `arr` will not exceed 10 to keep the simulation tractable. * The integers within the list are comprehensive, including negative and positive values. Requirements * Randomly shuffle the list until it is sorted. * Print each shuffle iteration and the current state of the list if `simulation` is set to `True`. Example ```python # Example 1: bogo_sort([3, 1, 2], simulation=True) # Outputs (example simulation printout): # iteration 0 : 3 1 2 # iteration 1 : 1 3 2 # iteration 2 : 2 1 3 # iteration 3 : 3 2 1 # iteration 4 : 1 2 3 # Example 2: bogo_sort([5, 4, 3, 2, 1], simulation=True) # Outputs a series of shuffled arrangements until correctly sorted to: # iteration N : 1 2 3 4 5 ```","solution":"import random def bogo_sort(arr: list[int], simulation: bool = False) -> list[int]: The Bogo Sort algorithm shuffles the array until it is sorted. Parameters: arr (list[int]): The list of integers to sort. simulation (bool): If True, prints each shuffle until the array is sorted. Returns: list[int]: The sorted list. def is_sorted(lst): Helper function to check if the list is sorted. return all(lst[i] <= lst[i+1] for i in range(len(lst) - 1)) iterations = 0 while not is_sorted(arr): if simulation: print(f\\"iteration {iterations} : {arr}\\") random.shuffle(arr) iterations += 1 if simulation: print(f\\"iteration {iterations} : {arr}\\") return arr"},{"question":"# Binary Search Tree Extension with Deletion Context You have a basic Binary Search Tree (BST) implementation with functionalities for insertion, search, size calculation, and tree traversal. However, it lacks a crucial function — the ability to delete a node. Objective Implement the deletion operation for the Binary Search Tree. Functions to Implement ```python def delete(self, data): ``` * **Input**: * `data` (int): The data value to be deleted from the tree. * **Output**: * None. But the tree structure should be modified accordingly. The delete function should handle three cases: 1. **Node with no children** (a leaf node). It can simply be removed. 2. **Node with one child**. The node can be replaced by its subtree. 3. **Node with two children**. Replace the node\'s value with its in-order successor (smallest value in the right subtree) and then delete the in-order successor. Example You are given the following tree: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` * Deleting `4` should leave the tree as: ``` 10 / 6 15 / 9 12 24 / / 7 20 30 / 18 ``` * Deleting `9` should leave the tree as: ``` 10 / 6 15 / / 4 12 24 / 7 20 30 / 18 ``` * Deleting `10` should leave the tree as: ``` 12 / 6 15 / 4 9 24 / / 7 20 30 / 18 ``` Constraints * **Performance**: Your function should have an average time complexity of O(log N), but it is acceptable for the worst-case scenario to be O(N). * You must handle edge cases such as deleting from an empty tree, attempting to delete a non-existent element, and correctly managing the root node if it is being deleted. Bonus: Write unit tests to validate the correctness of your `delete` function using the `unittest` module.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_min(self, node): while node.left is not None: node = node.left return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self.find_min(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return node def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node is not None: self._inorder(node.left, result) result.append(node.key) self._inorder(node.right, result)"},{"question":"**Question**: Write a function `maximum_flow_bfs` that computes the maximum flow from a source node (node 0) to a sink node (last node, n-1) in a directed graph represented by a n x n adjacency matrix. Your function should use the Breadth-First Search (BFS) approach to find augmenting paths. You should also consider edge cases like graphs with zero-capacity edges or disconnected segments. **Input**: - An n x n adjacency matrix `graph` where `graph[i][j]` represents the capacity of the edge from node `i` to node `j`. **Output**: - An integer representing the maximum flow from the source to the sink. **Constraints**: - The adjacency matrix will always be square (n x n). - Graph capacities are non-negative integers. **Example**: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow_bfs(graph) == 23 ``` **Function Signature**: ```python def maximum_flow_bfs(graph: List[List[int]]) -> int: pass ``` **Notes**: - Make sure to handle residual graph updates correctly. - Ensure your algorithm terminates properly when no further augmenting paths can be found. - Optimize for readability and efficiency.","solution":"from collections import deque def bfs(graph, source, sink, parent): visited = [False] * len(graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(graph): source = 0 sink = len(graph) - 1 parent = [-1] * len(graph) max_flow = 0 while bfs(graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Coding Assessment Scenario: You are tasked with implementing an efficient search function for an application that queries sorted datasets of uniformly distributed numerical values. The function should leverage the interpolation search algorithm to find the index of a given search key, if it exists, within the sorted list. Task: Implement the function `interpolation_search_custom` that takes a sorted list of integers and an integer search key as input, and returns the index of the search key if it is found, otherwise it returns -1. Function Signature: ```python from typing import List def interpolation_search_custom(array: List[int], search_key: int) -> int: ``` Input: 1. `array` (List[int]): A sorted list of integers (increasing order). 2. `search_key` (int): The integer value to search for in the array. Output: - **int**: The index of the search key in the array if present, otherwise -1. Constraints: - The length of the array will be between 1 and 10^6. - The values in the array will be between -10^9 and 10^9. Performance Requirements: - The solution should aim for an average time complexity of O(log2(log2 n)). - The solution should handle edge cases efficiently without unnecessary calculations. Example Usage: ```python >>> interpolation_search_custom([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> interpolation_search_custom([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> interpolation_search_custom([5, 10, 12, 14, 17, 20, 21], -5) -1 ``` Additional Notes: - Ensure to handle the edge cases where the search key is outside the range of the array values. - Provide meaningful comments explaining the code sections. - Optimize your code to avoid performance pitfalls mentioned in the analysis.","solution":"from typing import List def interpolation_search_custom(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Palindrome Permutation Given a string, write a function to determine if a permutation of the string could form a palindrome. **Function Signature**: ```python def can_form_palindrome(s: str) -> bool: pass ``` # Input: - **s** (string): A string consisting of alphanumeric characters and whitespaces. # Output: - **Returns** (boolean): `True` if any permutation of the input string can form a palindrome, and `False` otherwise. # Constraints: - The string `s` is at most 1000 characters long. - The function should handle both uppercase and lowercase letters, spaces, and digits. # Performance Requirements: - The function should run in O(n) time complexity where n is the length of the string. - The function should use O(1) additional space, not considering input space. # Example Scenarios 1. **Example 1**: - Input: \\"Tact Coa\\" - Output: `True` - Explanation: Permutations \\"taco cat\\", \\"atco cta\\", etc., have a palindrome form. 2. **Example 2**: - Input: \\"A man, a plan, a canal: Panama\\" - Output: `True` - Explanation: Permutations \\"a man a plan a canal panama\\" can be rearranged to form a palindrome. 3. **Example 3**: - Input: \\"race a car\\" - Output: `False` - Explanation: No permutation of \\"race a car\\" can form a palindrome. # Hint: - A permutation of a palindrome has at most one character with an odd count.","solution":"def can_form_palindrome(s: str) -> bool: Determine if a permutation of the string could form a palindrome. from collections import Counter s = \'\'.join(filter(str.isalnum, s)).lower() char_counter = Counter(s) odd_count = 0 for count in char_counter.values(): if count % 2 == 1: odd_count += 1 return odd_count <= 1"},{"question":"Implement a class `AdvancedTrie` that extends the basic Trie data structure capabilities. In addition to the provided methods (`insert`, `search`, `startsWith`), add the following methods: 1. **delete(word)**: Removes a word from the Trie. If the word does not exist, do nothing. Ensure the Trie structure remains valid after deletion. 2. **suggest(prefix)**: Returns a list of all words in the Trie that start with the given prefix. # Constraints - All inputs are composed of lowercase letters a-z. - The length of each word and prefix will be in the range [1, 1000]. - The number of words inserted into the Trie will be in the range [1, 10000]. # Input and Output Formats **delete(word)**: * Input: word (string) * Output: Modify the Trie in place (no output) **suggest(prefix)**: * Input: prefix (string) * Output: List of strings, all words in the Trie that start with the given prefix. # Example ```python trie = AdvancedTrie() trie.insert(\\"apple\\") trie.insert(\\"application\\") trie.insert(\\"appetite\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True trie.delete(\\"apple\\") print(trie.search(\\"apple\\")) # Output: False print(trie.suggest(\\"app\\")) # Output: [\\"application\\", \\"appetite\\"] ```","solution":"class Node: def __init__(self): self.children = {} self.is_end_of_word = False class AdvancedTrie: def __init__(self): self.root = Node() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = Node() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def delete(self, word): self._delete(self.root, word, 0) def _delete(self, node, word, index): if index == len(word): if not node.is_end_of_word: return False node.is_end_of_word = False return len(node.children) == 0 char = word[index] if char not in node.children: return False should_delete_child = self._delete(node.children[char], word, index + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False def suggest(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._find_all_words(node, prefix) def _find_all_words(self, node, prefix): results = [] if node.is_end_of_word: results.append(prefix) for char, next_node in node.children.items(): results.extend(self._find_all_words(next_node, prefix + char)) return results"},{"question":"# Coding Task: Implement a String Reversal Function Objective Design and implement a function `reverse_string` that reverses a given input string. You should demonstrate an understanding of different algorithms and select an approach that balances simplicity, performance, and readability. Function Signature ```python def reverse_string(s: str) -> str: pass ``` Input * A single input string `s` with length `n` where `0 <= n <= 10^6`. Output * A string that is the reverse of the input string `s`. Constraints * The function should efficiently handle strings of length up to 1 million characters. * Consider time complexity and ensure the solution is optimized for larger inputs. Performance Requirements * The function should have a time complexity of O(n) and a space complexity of O(n). # Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"abcd\\") == \\"dcba\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" ``` # Additional Scenario Imagine you are creating a feature in a messaging application that reverses incoming messages for a specific transformation. Your function must be robust and efficient enough to handle real-time data processing with frequent calls.","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string s. :param s: The string to reverse. :return: The reversed string. return s[::-1]"},{"question":"# Problem Description You are working with a representation of a graph as an adjacency list. Your task is to enhance the provided graph traversal functions to handle large graphs more efficiently and to guarantee correct path discovery even in the presence of cycles. # Requirements - Implement an iterative version of `find_path` using a stack to avoid recursion depth issues. - Optimize the `find_all_path` function to handle cyclic graphs correctly. - Modify `find_shortest_path` to include memoization to reduce redundant path calculations. # Input and Output Format - **Input**: - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - `start`: The starting node. - `end`: The end node. - **Output**: - `find_path`: A list representing a path from start to end, or `None` if no path exists. - `find_all_path`: A list of lists, where each inner list represents a unique path from start to end. - `find_shortest_path`: A list representing the shortest path from start to end, or `None` if no path exists. # Constraints 1. You may assume the graph does not have negative weights. 2. `start` and `end` nodes are guaranteed to be within the graph. 3. Graph nodes and edges fit within memory for efficient traversal. # Functions Signature: ```python def optimized_find_path(graph, start, end): pass def optimized_find_all_path(graph, start, end): pass def optimized_find_shortest_path(graph, start, end): pass ``` # Example Usage ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example Calls print(optimized_find_path(graph, \'A\', \'F\')) # Output: [\'A\', \'B\', \'E\', \'F\'] print(optimized_find_all_path(graph, \'A\', \'F\')) # Output: [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] print(optimized_find_shortest_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] ``` # Notes - Focus on ensuring that the solution is efficient and correct. - Consider edge cases like graphs with cycles and nodes with no outbound edges.","solution":"def optimized_find_path(graph, start, end): Iterative DFS to find one path from start to end. stack = [(start, [start])] while stack: (vertex, path) = stack.pop() for next in set(graph.get(vertex, [])) - set(path): if next == end: return path + [next] else: stack.append((next, path + [next])) return None def optimized_find_all_path(graph, start, end): Recursive DFS to find all paths from start to end. def dfs(node, end, path): path = path + [node] if node == end: paths.append(path) else: for neighbor in graph.get(node, []): if neighbor not in path: dfs(neighbor, end, path) paths = [] dfs(start, end, []) return paths def optimized_find_shortest_path(graph, start, end): BFS to find the shortest path from start to end. queue = [(start, [start])] visited = set() while queue: (vertex, path) = queue.pop(0) if vertex in visited: continue if vertex == end: return path visited.add(vertex) for next in graph.get(vertex, []): if next not in visited: queue.append((next, path + [next])) return None"},{"question":"# Regular Expression Matching Problem Statement Write a function `is_match(s: str, p: str) -> bool` that implements a regular expression matching with support for \'.\' and \'*\'. The matching function should match the entire input string `s` against the pattern `p`. Specifications 1. `\'.\'` matches any single character. 2. `\'*\'` matches zero or more of the preceding element. 3. The matching should cover the entire input string (not partial). Input * `s` - input string (1 ≤ len(s) ≤ 1000) * `p` - pattern string where 1 ≤ len(p) ≤ 1000 and only includes lowercase letters, \'.\' and \'*\'. Output * Return `True` if `s` matches the pattern `p`, otherwise return `False`. Constraints * Assume that `p` is a well-formed regular expression as per the rules given. * Performance requirement: The algorithm should be efficient with a time complexity of O(m * n). Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Task Implement the `is_match` function as described.","solution":"def is_match(s: str, p: str) -> bool: Returns True if input string s matches the pattern p following the rules of regular expression matching with \'.\' and \'*\'. # Create a DP table to store the results dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: empty string matches empty pattern dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc. for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # Match empty sequence or match preceding element dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (p[j - 2] == s[i - 1] or p[j - 2] == \'.\')) return dp[len(s)][len(p)]"},{"question":"You are given an array that may contain nested arrays. Your task is to write a Python function that flattens this nested array structure into a single resultant flat array. # Function Signature: ```python def flatten_array(input_array: list) -> list: ``` # Input: * `input_array`: A list which may contain nested lists or other iterable elements (excluding strings). # Output: * Returns a single list that contains all elements from the nested structure in a flat format, with the original order preserved. # Constraints: * The function should handle up to 1,000,000 total elements across all nested levels. * The depth of nesting can go arbitrarily deep. # Example: ```python assert flatten_array([1, [2, 3, [4, 5]], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_array([]) == [] assert flatten_array([1, [2], [3, [4, [5, [6]]]]]) == [1, 2, 3, 4, 5, 6] assert flatten_array([\'a\', [\'b\', \'c\', [\'d\']]]) == [\'a\', \'b\', \'c\', \'d\'] ``` # Requirements: 1. Do not use any external libraries except for the built-in collections.abc.Iterable to check for iterable elements. 2. Your implementation should account for edge cases such as empty arrays or deeply nested empty arrays. 3. You should consider performance implications of deep recursion and prefer an iterative solution where practicable.","solution":"from collections.abc import Iterable def flatten_array(input_array: list) -> list: Flattens a nested array into a single flat list. Args: input_array (list): A list possibly containing nested lists. Returns: list: A flat list containing all elements from the nested structure. result = [] def flatten(item): if isinstance(item, Iterable) and not isinstance(item, str): for sub_item in item: flatten(sub_item) else: result.append(item) flatten(input_array) return result"},{"question":"# Question: Validate Parentheses with a Stack Objective Write a function `validate_parentheses(s: str) -> bool` to check whether a given string containing only the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'` is a valid string of parentheses. The function should return `True` if the input string is valid and `False` otherwise. Context You are building a mini syntax checker for a custom programming language that uses parentheses for delimiting expressions. Your goal is to ensure that every expression is correctly nested and balanced. Input and Output Format - **Input**: - A string `s` (0 ≤ length of s ≤ 10^4), consisting solely of characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. - **Output**: - `True` if the input string `s` is a valid string of parentheses. - `False` otherwise. Constraints and Requirements - The input string can be empty, in which case the function should return `True`. - The solution should operate within O(n) time complexity and O(n) space complexity. - You must use a stack data structure to implement this algorithm. Examples 1. `validate_parentheses(\\"()\\")` should return `True`. 2. `validate_parentheses(\\"()[]{}\\")` should return `True`. 3. `validate_parentheses(\\"(]\\")` should return `False`. 4. `validate_parentheses(\\"([)]\\")` should return `False`. 5. `validate_parentheses(\\"{[]}\\")` should return `True`.","solution":"def validate_parentheses(s: str) -> bool: Check if the given string s containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is a valid parentheses string. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_bracket.values(): # If it\'s an opening bracket, push to stack stack.append(char) elif char in matching_bracket.keys(): # If it\'s a closing bracket if stack == [] or matching_bracket[char] != stack.pop(): return False return stack == []"},{"question":"# Atbash Cipher Implementation Context You\'ve been hired by a cybersecurity firm to write a module that uses the Atbash cipher to encode and decode textual messages as part of their suite of historical ciphers. Your implementation should handle mixed-case inputs and leave non-alphabetic characters unchanged. Task Implement a function `atbash(s)` that takes a string `s` and returns its Atbash cipher transformation. Input and Output Formats * **Input**: A single string `s` containing English alphabetic and non-alphabetic characters. The length of the string `s` can be up to 10^4 characters. * **Output**: A string transformed using the Atbash cipher. Constraints * The function should maintain the casing of alphabetic characters. * Non-alphabetic characters should remain unchanged. Performance Requirements * Ensure your implementation runs with a time complexity of O(n), where n is the length of the input string. Example ```python assert atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash(\\"123 ABC abc\\") == \\"123 ZYX zyx\\" ``` Write your solution in Python.","solution":"def atbash(s): Applies the Atbash cipher to the given string by reversing the alphabet. Uppercase and lowercase letters are transformed separately. Non-alphabetic characters remain unchanged. Parameters: s (str): The input string to be transformed. Returns: str: The transformed string using the Atbash cipher. def transform_char(c): if \'A\' <= c <= \'Z\': return chr(25 - (ord(c) - ord(\'A\')) + ord(\'A\')) elif \'a\' <= c <= \'z\': return chr(25 - (ord(c) - ord(\'a\')) + ord(\'a\')) return c return \'\'.join(transform_char(c) for c in s)"},{"question":"Optimized Primality Test Scenario You have been hired by a cybersecurity firm to implement an optimized version of a primality test. The firm uses large prime numbers extensively, and thus, performance is critical. Your task is to write a function that determines whether a number is prime. Your function should handle a large range of values efficiently. Task Write a function `is_prime_optimized(n: int) -> bool` that returns `True` if `n` is a prime number, otherwise returns `False`. Input * An integer `n` where `1 <= n <= 10^6`. Output * Return `True` if the given number `n` is prime, otherwise, return `False`. # Constraints * You may not use built-in functions that directly solve the problem (e.g., direct primality check utilities). * Your solution should be optimized and scalable within the input limits. * Consider edge cases like 1, 2, and large prime/non-prime numbers. # Example ```python print(is_prime_optimized(1)) # False print(is_prime_optimized(2)) # True print(is_prime_optimized(17)) # True print(is_prime_optimized(18)) # False print(is_prime_optimized(19)) # True ``` # Requirements * Perform an initial check for obvious non-prime numbers. * Use an efficient method to minimize redundant calculations, similar to the given code snippet. * Ensure that your code runs within reasonable time limits for the maximum input size. Good luck with your implementation!","solution":"def is_prime_optimized(n: int) -> bool: Determines if the given number n is a prime number. Args: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n > 1 else False if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Swapping Adjacent Nodes in a Linked List Context: You are given a singly linked list where each node contains an integer value. Your task is to swap every two adjacent nodes and return the head of the modified list. Requirements: - The algorithm should use only constant space. - You may not modify the values of the nodes; only the nodes themselves can be changed. - The function should handle edge cases effectively, such as an empty list or a list with only one node. Input Format: - A singly linked list provided as the head of the list. Output Format: - The head node of the modified linked list after performing the swaps. Constraints: - The list may have `0` to `1000` nodes. - Each node\'s value is an integer. Performance: - The implementation must run in O(n) time complexity where n is the number of nodes. - It must use O(1) additional space. # Function Signature: ```python class Node: def __init__(self, x: int): self.val = x self.next = None def swap_pairs(head: Node) -> Node: pass ``` # Example: Input: - Linked List: 1 -> 2 -> 3 -> 4 Output: - Linked List: 2 -> 1 -> 4 -> 3 Scenario: Consider you have a linked list representing sequence orders in a queue. You need to swap every two adjacent orders for operational efficiency, ensuring that each step uses minimal extra resources. Your task is to implement the `swap_pairs` function by filling in the logic to achieve the desired node swapping.","solution":"class Node: def __init__(self, x: int): self.val = x self.next = None def swap_pairs(head: Node) -> Node: # Create a dummy node to simplify edge cases dummy = Node(0) dummy.next = head current = dummy while current.next and current.next.next: first = current.next second = current.next.next # Swap nodes first.next = second.next second.next = first current.next = second # Move to the next pair current = first return dummy.next"},{"question":"# String Decoding with Nested Encodings Objective You are to implement a function that decodes a given encoded string, following specific decoding rules. This exercise is designed to assess your understanding of stack data structures and string manipulation techniques. Problem Statement You are given an encoded string where the encoding rule is defined as: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly `k` times. `k` is guaranteed to be a positive integer. Write a function `decode_string(s)` that takes in a single parameter: * `s` (string): The encoded string. The function should return a decoded string following the given rules. For simplicity, you may assume: 1. The input string is always valid; no extra white spaces, and square brackets are well-formed. 2. Digits in the string only represent repeat numbers `k`. For example, there won\'t be any input like \\"3a\\" or \\"2[4]\\". Input * A single string `s` with lengths between `1` to `30`. Output * A single decoded string. # Example ```plaintext decode_string(\\"3[a]2[bc]\\") # Output: \\"aaabcbc\\" decode_string(\\"3[a2[c]]\\") # Output: \\"accaccacc\\" decode_string(\\"2[abc]3[cd]ef\\") # Output: \\"abcabccdcdcdef\\" ``` Constraints * The digits are only used to specify the number of repetitions of the enclosed string. The implementation should handle nested encodings correctly. Implementation Requirements * Your solution should ideally run in O(n) time complexity. * Managed using stack data structures. Edge Cases * Consider test cases like \\"3[x2[y]z]\\" to ensure that nested encodings are correctly processed.","solution":"def decode_string(s): Decodes the given encoded string following the specified rules. Parameters: s (str): The encoded string. Returns: str: The decoded string. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \\"\\" current_num = 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"# Scenario You are developing a financial web application that helps users quickly find outlier transactions from their bank statements. Users frequently need to identify two transactions that together round off to a suspicious total. Implement a function that efficiently returns the indices of these two transactions. # Function Description Write a function `find_suspicious_trans` to find the indices of two elements in a given list of integers that add up to a specified target sum. You have to ensure that you do not reuse the same element twice. Input - `transactions`: List of integers representing the transaction amounts. - `target_sum`: Integer representing the sum you need to find. Output - A tuple of two integers representing the indices of the two elements in the list that add up to `target_sum`, or `None` if no such pair exists. # Requirements - The function should run in O(n) time complexity. - You can assume each input has exactly one solution and may not use the same element twice. # Function Signature ```python def find_suspicious_trans(transactions: List[int], target_sum: int) -> Optional[Tuple[int, int]]: ``` # Example ```python transactions = [13, 7, 2, 15] target_sum = 9 # Output: (1, 2) # Explanation: transactions[1] + transactions[2] = 7 + 2 = 9 print(find_suspicious_trans(transactions, target_sum)) ```","solution":"from typing import List, Optional, Tuple def find_suspicious_trans(transactions: List[int], target_sum: int) -> Optional[Tuple[int, int]]: Returns the indices of two elements in transactions that add up to target_sum. seen = {} for i, value in enumerate(transactions): complement = target_sum - value if complement in seen: return (seen[complement], i) seen[value] = i return None"},{"question":"# Comb Sort Function Implementation **Context**: Imagine you have a collection of items stored as an array, and you need to sort these items in ascending order efficiently. You\'ve learned about Comb Sort, an enhancement over the traditional Bubble Sort, which helps to reduce the total number of elements compared by introducing gaps. Your task is to implement this sorting algorithm. **Task**: Write a function `comb_sort` that takes an array of integers and sorts it in ascending order using the Comb Sort algorithm. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers `arr` where `1 <= len(arr) <= 10^5` and each integer is `-10^9 <= arr[i] <= 10^9`. **Output**: * A list of integers sorted in ascending order. **Constraints**: * The solution should handle edge cases such as empty arrays, arrays with one element, and arrays with duplicate elements. * Aim to maintain a time complexity close to O(N log N) in average scenarios. * Minimize any excessive space usage with an in-place sorting mechanism. **Examples**: 1. Input: `[3, 1, 2, 4, 5]` Output: `[1, 2, 3, 4, 5]` 2. Input: `[10, -1, 2, 5, 0]` Output: `[-1, 0, 2, 5, 10]` 3. Input: `[1, 2, 2, 2, 1]` Output: `[1, 1, 2, 2, 2]` **Requirements**: 1. Implement the gap reduction accurately using a shrink factor of 1.3. 2. Ensure that swapping and comparisons respect the correct order. 3. Manage the sorted flag to exit the loop efficiently when the array is sorted. **Notes**: - Consider edge cases, such as arrays with zero or one element. - Think about optimization techniques to improve real-world performance without dramatically increasing complexity.","solution":"def comb_sort(arr): Sorts a list of integers in ascending order using the Comb Sort algorithm. def get_next_gap(gap): gap = int(gap / 1.3) return max(1, gap) n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question Suppose you are handling an online platform selling limited-edition products. You are tasked with developing a sorting module to arrange the product IDs (which are integers) in ascending order. Given the memory constraints of the platform\'s hardware, you must minimize the number of writes to the memory. Write a function `cycle_sort(arr: List[int]) -> List[int]` that sorts the given list `arr` of product IDs using the Cycle Sort algorithm. # Input: * A list of integers `arr`, where each integer represents a product ID. * `1 <= len(arr) <= 10^4` * `-10^6 <= arr[i] <= 10^6` for each `arr[i]` # Output: * A list of integers sorted in non-decreasing order. # Constraints: * Array length can be between 1 and 10,000. * Product IDs can range from -1,000,000 to 1,000,000. # Example: ```python assert cycle_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert cycle_sort([1, 2, 3, 4]) == [1, 2, 3, 4] assert cycle_sort([4, 1, 3, 2]) == [1, 2, 3, 4] ``` # Notes: Remember to handle edge cases such as already sorted arrays, arrays with duplicate elements, and arrays with negative and positive integers. Aim to stay within the mentioned time and space complexity constraints to ensure your code performs efficiently even with large inputs.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts the array using Cycle Sort algorithm. This method minimizes the number of writes to the memory. n = len(arr) # Traverse the array to find cycles to rotate. for cycle_start in range(n - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Imagine you are creating a program that processes a sequence of numbers from 1 to N and replaces certain numbers based on specified conditions. This is a common problem referred to as \\"FizzBuzz\\". **Function Specification**: You need to implement a function called `fizzbuzz`. ```python def fizzbuzz(n): # your code here ``` **Input**: - An integer `n` (1 ≤ n ≤ 10^6), where `n` is the upper bound of the sequence. **Output**: - A list of integers and strings based on the following rules: - For multiples of 3, the list should contain \\"Fizz\\" instead of the number. - For multiples of 5, the list should contain \\"Buzz\\" instead of the number. - For multiples of both 3 and 5, the list should contain \\"FizzBuzz\\". - For all other numbers, the list should contain the number itself. **Constraints and Requirements**: - Your function should raise a `ValueError` if `n` is less than 1. - Your function should raise a `TypeError` if `n` is not an integer. - The solution should be efficient with a time complexity of O(n) and a space complexity of O(n). **Example**: ```python assert fizzbuzz(15) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] assert fizzbuzz(5) == [1, 2, \'Fizz\', 4, \'Buzz\'] assert fizzbuzz(1) == [1] ``` **Scenarios**: 1. Basic check: `fizzbuzz(5)` should return `[1, 2, \'Fizz\', 4, \'Buzz\']`. 2. Edge case test: `fizzbuzz(1)` should return `[1]`. 3. Error case: `fizzbuzz(0)` should raise `ValueError`. 4. Non-integer and None inputs should raise `TypeError`. Your task is to implement the `fizzbuzz` function meeting the above requirements and passing all the example scenarios.","solution":"def fizzbuzz(n): Returns a list of integers and strings based on the FizzBuzz rules: - \\"Fizz\\" for multiples of 3 - \\"Buzz\\" for multiples of 5 - \\"FizzBuzz\\" for multiples of both 3 and 5 - The number itself for all other cases if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 1: raise ValueError(\\"Input must be at least 1\\") result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Objective: Implement and validate the AVL Tree data structure\'s capability to handle dynamic data sets by consistently maintaining balance through appropriate rotations. # Task: You are required to implement a method to delete a node from an AVL Tree and ensure the tree remains balanced after deletion. # Function Signature: ```python def delete(self, key: int) -> None: ``` # Input: - **key (int)**: The key of the node to delete from the AVL tree. # Expected Output: - The AVL tree should be updated with the node deleted, while maintaining its balanced property. - You should ensure the tree remains balanced after the deletion operation, with all nodes correctly rebalanced and no violations of AVL properties. # Constraints: 1. Assume there are no duplicate nodes in the tree. 2. You must implement the rebalancing operations if needed after the deletion. # Performance Requirements: Ensure that the deletion and rebalancing operations maintain an O(log n) time complexity. # Example: ```python # Creating an AVL Tree and inserting values avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) avl_tree.insert(40) avl_tree.insert(50) avl_tree.insert(25) # In-order traversal before deletion print(avl_tree.in_order_traverse()) # Output: [10, 20, 25, 30, 40, 50] # Deleting a node avl_tree.delete(30) # In-order traversal after deletion print(avl_tree.in_order_traverse()) # Expected Output: [10, 20, 25, 40, 50] ``` # Note: Ensure to handle all edge cases such as deleting a leaf node, deleting a node with one child, and deleting a node with two children.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def insert(self, root, key): if not root: return Node(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def delete(self, root, key): if not root: return root elif key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.get_min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_min_value_node(self, root): if root is None or root.left is None: return root return self.get_min_value_node(root.left) def in_order_traverse(self, root, res=[]): if root: self.in_order_traverse(root.left, res) res.append(root.key) self.in_order_traverse(root.right, res) return res # Usage avl_tree = AvlTree() root = None keys = [10, 20, 30, 40, 50, 25] for key in keys: root = avl_tree.insert(root, key) print(avl_tree.in_order_traverse(root, [])) root = avl_tree.delete(root, 30) print(avl_tree.in_order_traverse(root, []))"},{"question":"# Question: Validating Binary Tree Path Sum Given a binary tree and a target sum, write a function `validate_path_sum` to determine if the tree has a root-to-leaf path such that the sum of the node values in the path equals the target sum. You need to implement this function using three different traversal techniques: Recursive Depth-First Search (DFS), Iterative Depth-First Search (DFS) with a stack, and Breadth-First Search (BFS) with a queue. Function Signature ```python def validate_path_sum(root, target_sum): :param root: TreeNode :param target_sum: int :return: dict Dictionary with format: { \\"recursive_dfs\\": bool, \\"iterative_dfs\\": bool, \\"bfs\\": bool } Each key\'s value denotes whether a root-to-leaf path with the given sum exists for the corresponding method. ``` Input * `root`: The root of the binary tree, which is an instance of `TreeNode`. * `target_sum`: An integer representing the target path sum. Output * A dictionary indicating the presence of such a path for each traversal method. Constraints * The number of nodes in the tree will be in the range [0, 1000]. * Node values will be in the range [-1000, 1000]. Example ```python # Example definition of TreeNode for clarity class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example case root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) target_sum = 22 expected_output = { \\"recursive_dfs\\": True, \\"iterative_dfs\\": True, \\"bfs\\": True } assert validate_path_sum(root, target_sum) == expected_output ``` Notes * Ensure to handle edge cases such as empty trees or trees with a single node. * Each traversal method should be implemented within the `validate_path_sum` function and properly integrated to produce the final result.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def validate_path_sum(root, target_sum): def recursive_dfs(node, remaining_sum): if not node: return False remaining_sum -= node.val if not node.left and not node.right: # If it\'s a leaf return remaining_sum == 0 return recursive_dfs(node.left, remaining_sum) or recursive_dfs(node.right, remaining_sum) def iterative_dfs(root, target_sum): if not root: return False stack = [(root, target_sum - root.val)] while stack: node, current_sum = stack.pop() if not node.left and not node.right and current_sum == 0: return True if node.right: stack.append((node.right, current_sum - node.right.val)) if node.left: stack.append((node.left, current_sum - node.left.val)) return False def bfs(root, target_sum): if not root: return False from collections import deque queue = deque([(root, target_sum - root.val)]) while queue: node, current_sum = queue.popleft() if not node.left and not node.right and current_sum == 0: return True if node.left: queue.append((node.left, current_sum - node.left.val)) if node.right: queue.append((node.right, current_sum - node.right.val)) return False return { \\"recursive_dfs\\": recursive_dfs(root, target_sum), \\"iterative_dfs\\": iterative_dfs(root, target_sum), \\"bfs\\": bfs(root, target_sum) }"},{"question":"# Missing Number Finder Scenario You are working on an application where you need to ensure data integrity for sequences of IDs assigned from `0` to `n`. Occasionally, IDs might be lost or not assigned. You need a utility function to detect these missing IDs in linear time and constant space. Task Implement a function `find_missing_number3` that takes a list `nums` of unique integers in the range `[0..n]` (inclusive) and returns the missing number. If the list is already complete with integers from `0` to `n-1`, it should return `n` as the missing number. Input - `nums` (list of integers): A list of unique integers in the range `[0..n]` where exactly one number is missing. Output - An integer representing the missing number. Constraints - The length of `nums` will be `n` where `n` is a non-negative integer. - Each element in `nums` is unique and lies in `[0..n]`. Performance Requirements The solution should run in O(n) time and use O(1) extra space. Example ```python nums = [4, 1, 3, 0, 6, 5, 2] print(find_missing_number3(nums)) # Output: 7 ```","solution":"def find_missing_number3(nums): Find the missing number in the given list of unique integers from 0 to n. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"As part of a low-level data handling system, you are required to implement functions that convert integers to their byte representations and vice versa. These conversions need to cater to both big-endian and little-endian formats. # Task Implement the following functions: 1. `int_to_bytes_big_endian(num)`: Converts an integer to its big-endian byte representation. 2. `int_to_bytes_little_endian(num)`: Converts an integer to its little-endian byte representation. 3. `bytes_big_endian_to_int(bytestr)`: Converts a big-endian byte representation back to an integer. 4. `bytes_little_endian_to_int(bytestr)`: Converts a little-endian byte representation back to an integer. # Function Signatures ```python def int_to_bytes_big_endian(num: int) -> bytes: # Implement this function def int_to_bytes_little_endian(num: int) -> bytes: # Implement this function def bytes_big_endian_to_int(bytestr: bytes) -> int: # Implement this function def bytes_little_endian_to_int(bytestr: bytes) -> int: # Implement this function ``` # Input and Output Formats int_to_bytes_big_endian(num) - **Input**: A positive integer `num`. - **Output**: A `bytes` object representing the integer in big-endian format. int_to_bytes_little_endian(num) - **Input**: A positive integer `num`. - **Output**: A `bytes` object representing the integer in little-endian format. bytes_big_endian_to_int(bytestr) - **Input**: A `bytes` object `bytestr` representing an integer in big-endian format. - **Output**: An integer converted from the byte representation. bytes_little_endian_to_int(bytestr) - **Input**: A `bytes` object `bytestr` representing an integer in little-endian format. - **Output**: An integer converted from the byte representation. # Constraints - You can assume input integers are non-negative. - The byte conversions should handle integers up to the size that can fit into Python’s `int` data type. # Performance Requirements - The solution should efficiently handle the conversion for large integers (≥ 2^32). # Scenario Consider a scenario where you are implementing a data serialization library for a networking service that needs to handle data interchange between different types of systems (big-endian and little-endian). Your task is to ensure the correct conversion of integers to and from their byte representations in both endian formats. # Example - `int_to_bytes_big_endian(305419896)` should return `b\'x12x34x56x78\'`. - `int_to_bytes_little_endian(305419896)` should return `b\'x78x56x34x12\'`. - `bytes_big_endian_to_int(b\'x12x34x56x78\')` should return `305419896`. - `bytes_little_endian_to_int(b\'x78x56x34x12\')` should return `305419896`.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to its big-endian byte representation. return num.to_bytes((num.bit_length() + 7) // 8, \'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to its little-endian byte representation. return num.to_bytes((num.bit_length() + 7) // 8, \'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte representation back to an integer. return int.from_bytes(bytestr, \'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte representation back to an integer. return int.from_bytes(bytestr, \'little\')"},{"question":"Write a function `add_positive_integers_without_plus_operator(a: int, b: int) -> int` that adds two non-negative integers a and b without using the \'+\' operator or any other arithmetic operators such as \'-\', \'*\', or \'/\'. # Input * `a` and `b`: non-negative integers (0 <= a, b <= 10^9) # Output * Return an integer which is the sum of `a` and `b`. # Example ```python assert add_positive_integers_without_plus_operator(2, 3) == 5 assert add_positive_integers_without_plus_operator(0, 0) == 0 assert add_positive_integers_without_plus_operator(1000, 456) == 1456 assert add_positive_integers_without_plus_operator(123456, 654321) == 777777 ``` # Constraints * You must not use any arithmetic operators like `+`, `-`, `*`, or `/`. * You can only use bitwise operators and control structures like loops and conditionals. * Aim for clarity and correctness first, but consider performance if you have time. # Additional Notes Remember to handle edge cases such as when either of the inputs is zero.","solution":"def add_positive_integers_without_plus_operator(a: int, b: int) -> int: Add two non-negative integers without using the \'+\' operator or any other arithmetic operators. while b != 0: carry = a & b # carry now contains common set bits of a and b a = a ^ b # sum of bits of a and b where at least one of the bits is not set b = carry << 1 # carry is shifted by one so that adding it to a gives the required sum return a"},{"question":"Minimum Spanning Tree Finder # Objective Implement the Kruskal’s Algorithm to find the Minimum Spanning Tree (MST) of a given undirected, connected graph. You\'ll utilize a Disjoint Set (Union-Find) data structure to manage and merge sets efficiently. # Instructions Complete the function `kruskals_mst` which accepts the number of vertices and an edge list, and returns the sum of weights of the MST. # Function Signature ```python def kruskals_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: ``` # Input - `vertex_count` (int): The number of vertices in the graph. - `edges` (List[Tuple[int, int, int]]): A list where each tuple represents an edge in the form `(source, target, weight)`. # Output - `int`: The sum of weights of the minimum spanning tree. # Example Input ```python vertex_count = 5 edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] ``` Output ```python 14 ``` # Constraints - 1 ≤ vertex_count ≤ 10^4 - 1 ≤ number of edges ≤ 10^6 - 1 ≤ weight ≤ 10^4 # Notes - Assure to handle edge cases, such as a disconnected graph (return 0 or appropriate error indication). - Use path compression and rank for optimizing union-find operations. # Requirements - Implement core operations to build a minimum spanning tree using Kruskal\'s algorithm. - Utilize a Disjoint Set data structure to handle merging and finding sets efficiently.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskals_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: # Initialize the Disjoint Set ds = DisjointSet(vertex_count) # Sort edges by weight edges.sort(key=lambda x: x[2]) mst_weight = 0 for u, v, weight in edges: if ds.find(u - 1) != ds.find(v - 1): # adjusting for 0-indexed internally ds.union(u - 1, v - 1) mst_weight += weight return mst_weight"},{"question":"You are tasked to find out the number of valid strings of specific length that contain a given number of \\"abba\\" substrings. To achieve this, you need to implement a dynamic programming solution that efficiently computes the result without using brute force. Function Signature ```python def find_k_factor(length: int, k_factor: int) -> int: ``` Input - `length`: An integer `length` (1 <= length <= 1000) representing the length of the strings. - `k_factor`: An integer `k_factor` (0 <= k_factor <= 1000) representing the targeted number of \\"abba\\" substrings in the strings. Output - Returns an integer representing the number of valid strings of the given length with exactly `k_factor` appearances of the substring \\"abba\\". Constraints - The characters in the strings are limited to lowercase English letters only. - The solution must be efficient enough to handle the given constraints without exceeding memory limits. Example ```python assert find_k_factor(4, 1) == 1 assert find_k_factor(7, 1) == 70302 assert find_k_factor(10, 2) == 74357 ``` # Instructions 1. Define the dynamic programming state representation and initialize it properly. 2. Iterate through possible string lengths and K factors, updating the DP state based on the rules provided. 3. Sum up the results as required and return the final count.","solution":"def find_k_factor(length: int, k_factor: int) -> int: MOD = 10**9 + 7 def count_abba_in_string(s): count = 0 for i in range(len(s) - 3): if s[i:i+4] == \'abba\': count += 1 return count def dfs(position, k, current): if position == length: return 1 if k == 0 else 0 if k < 0: return 0 if (position, k, current) in memo: return memo[(position, k, current)] total_count = 0 for char in \'abcdefghijklmnopqrstuvwxyz\': next_str = current + char new_k = k - (1 if next_str[-4:] == \'abba\' else 0) total_count += dfs(position + 1, new_k, next_str[-3:]) memo[(position, k, current)] = total_count return total_count if k_factor == 0: return (26 ** length) % MOD memo = {} return dfs(0, k_factor, \'\')"},{"question":"Optimized Sorting Algorithm **Context:** You are given an array of integers that requires sorting. The provided code uses the Exchange Sort algorithm, which is simple but not efficient for large datasets. To improve the performance, you have to implement an optimized sorting algorithm that sorts the array in-place and works efficiently for large datasets. **Task:** Write a function `optimized_sort` that takes an array of integers and sorts it in ascending order. Your algorithm should be more efficient than Exchange Sort in terms of time complexity. ```python def optimized_sort(arr): Function to sort an array in-place in ascending order. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. # Your implementation here ``` **Input:** - An array of integers (e.g., `arr = [5, 3, 8, 4, 2]`). **Output:** - Sorted array in ascending order (e.g., `[2, 3, 4, 5, 8]`). **Constraints:** - The array can contain up to 10^5 elements. - Elements in the array can be negative or positive integers. **Performance Requirements:** - Your algorithm should have an average-case time complexity better than O(n^2). **Edge Cases to Consider:** 1. The array is empty. 2. The array has only one element. 3. The array contains multiple identical elements. 4. The array is already sorted. # Example ```python print(optimized_sort([5, 3, 8, 4, 2])) # Output: [2, 3, 4, 5, 8] print(optimized_sort([-1, -3, 0, 2, 2])) # Output: [-3, -1, 0, 2, 2] print(optimized_sort([1])) # Output: [1] print(optimized_sort([])) # Output: [] print(optimized_sort([2, 3, 4, 5, 8])) # Output: [2, 3, 4, 5, 8] ```","solution":"def optimized_sort(arr): Function to sort an array in-place in ascending order using Timsort. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. arr.sort() return arr"},{"question":"# Prime Number Detector for Large Inputs **Context**: A large-scale finance application needs to identify prime numbers rapidly to support encryption algorithms that rely on large prime numbers. Your task is to implement a function that efficiently determines if a number is prime. Given the approach in the provided prime_check function, ensure the solution is correct and optimized for performance. **Task**: Implement the function `enhanced_prime_check(n)` that determines whether a positive integer ( n ) is a prime number. **Function Signature**: ```python def enhanced_prime_check(n: int) -> bool: ``` # Input: * A single integer ( n ) ( ( 1 leq n leq 10^{9} )) # Output: * Return `True` if ( n ) is a prime number, otherwise return `False`. # Constraints: * Minimize the number of operations for checking primality to handle larger values efficiently. * Ensure the function handles edge cases and performs optimally within the provided constraints. * Performance should be as efficient as possible for the given input range. # Example: ```python print(enhanced_prime_check(5)) # Output: True print(enhanced_prime_check(10)) # Output: False print(enhanced_prime_check(97)) # Output: True print(enhanced_prime_check(1000000000)) # Output: False ``` # Considerations: * Very large numbers (close to ( 10^9 )). * Edge cases like 1, very small primes, large composites. # Note: You should also consider readability and maintainability of your code. Include comments where necessary.","solution":"import math def enhanced_prime_check(n: int) -> bool: Determines if a number is prime. :param n: positive integer to be checked. :return: True if n is a prime number, False otherwise. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"Objective Implement the functions `insert`, `search`, and `startsWith` for a Trie (prefix tree) data structure. This implementation involves creating a class to represent the Trie and enabling efficient prefix-based search operations. Problem Statement Design a class `Trie` that supports the following three methods: 1. **insert(word)**: Inserts the word into the Trie. 2. **search(word)**: Returns `True` if the word is in the Trie, `False` otherwise. 3. **startsWith(prefix)**: Returns `True` if there is any word in the Trie that starts with the given prefix, `False` otherwise. Input and Output Format * `insert(word: str) -> None`: Inserts `word` into the Trie. No return value. * `search(word: str) -> bool`: Returns `True` if `word` is in the Trie, `False` otherwise. * `startsWith(prefix: str) -> bool`: Returns `True` if there is any word in the Trie that starts with `prefix`, `False` otherwise. Constraints * All inputs are consist of lowercase letters a-z. * The number of operations (insert, search, startsWith) will be in the range [1, 10^4]. Example ``` Input: Trie trie = new Trie(); trie.insert(\\"apple\\"); trie.search(\\"apple\\"); // returns true trie.search(\\"app\\"); // returns false trie.startsWith(\\"app\\"); // returns true trie.insert(\\"app\\"); trie.search(\\"app\\"); // returns true ``` Performance Requirements Ensure that both the time complexity for the `insert`, `search`, and `startsWith` operations are O(L), where L is the length of the input string or prefix.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts the word into the Trie. current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def search(self, word: str) -> bool: Returns True if the word is in the Trie, False otherwise. current = self.root for char in word: if char not in current.children: return False current = current.children[char] return current.is_end_of_word def startsWith(self, prefix: str) -> bool: Returns True if there is any word in the Trie that starts with the given prefix, False otherwise. current = self.root for char in prefix: if char not in current.children: return False current = current.children[char] return True"},{"question":"You are given a list of integers `lst` and a number `N`. You need to implement a function that returns a new list containing each number from the given list at most `N` times without reordering the list. # Function Signature ```python def limit_occurrences(lst: List[int], N: int) -> List[int]: pass ``` # Input - `lst`: A list of integers `[a1, a2, ..., an]` where (1 leq n leq 10^5) and (-10^6 leq ai leq 10^6) - `N`: An integer ( N geq 0 ) # Output - Returns a list of integers, which contains each integer from `lst` at most `N` times while maintaining the order from `lst`. # Constraints - If `N` equals 0, the returned list should be empty as no element can appear even once. - You must implement the function in O(n) time complexity using efficient data structures. # Example ```python limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 2) # Returns: [1, 2, 3, 1, 2, 3] limit_occurrences([20, 37, 20, 21], 1) # Returns: [20, 37, 21] ``` # Additional Notes - You may assume that the input list `lst` will always be a valid list of integers and `N` will be a non-negative integer. - Aim for a solution with O(n) time complexity.","solution":"def limit_occurrences(lst, N): Returns a new list containing each number from the given list at most N times. from collections import defaultdict if N == 0: return [] occurrence_count = defaultdict(int) result = [] for num in lst: if occurrence_count[num] < N: result.append(num) occurrence_count[num] += 1 return result"},{"question":"# Problem: Implement an Ordered Priority Stack Context You are tasked with implementing a priority stack that maintains its order with every insertion. This data structure should always keep the highest value at the top and the lowest at the bottom. It is crucial for you to maintain this property while supporting standard stack operations. Task Implement a class named `OrderedPriorityStack` that maintains this order with methods to `push`, `pop`, `peek`, and check if the stack is `is_empty`. Class Signature ```python class OrderedPriorityStack: def __init__(self): pass def is_empty(self): pass def push(self, item): pass def pop(self): pass def peek(self): pass def size(self): pass ``` Method Descriptions 1. `__init__(self)`: Initializes an empty stack. 2. `is_empty(self)`: Returns `True` if the stack is empty, otherwise `False`. 3. `push(self, item)`: Adds a new item into the stack, ensuring the stack is always in sorted order. 4. `pop(self)`: Removes and returns the item from the top of the stack. If stack is empty, it raises an `IndexError` with the message \\"Stack is empty.\\" 5. `peek(self)`: Returns the item at the top of the stack without removing it. 6. `size(self)`: Returns the number of items in the stack. Constraints * You can assume input items are integers. * Stack operations (push, pop, peek, size) should function within these constraints. * Consider edge cases such as popping from or peeking into an empty stack. Performance Requirements * `push` should operate with a complexity of O(n) where n is the number of elements in the stack. * Other operations (`pop`, `peek`, `is_empty`, `size`) should operate with a complexity of O(1). Example ```python stack = OrderedPriorityStack() stack.push(3) stack.push(1) stack.push(2) print(stack.pop()) # Should print 3 print(stack.peek()) # Should print 2 print(stack.size()) # Should return 2 ```","solution":"class OrderedPriorityStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): idx = 0 while idx < len(self.stack) and self.stack[idx] >= item: idx += 1 self.stack.insert(idx, item) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty.\\") return self.stack.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty.\\") return self.stack[0] def size(self): return len(self.stack)"},{"question":"Scenario You are tasked with developing a recommendation search feature for a large dataset of sorted integers representing user preferences. To ensure fast results, you\'ve decided to implement Interpolation Search due to its efficiency with uniformly distributed data commonly present in your use case. Task Write a Python function `enhanced_interpolation_search(array: List[int], search_key: int) -> int` that: 1. Uses the interpolation search algorithm to locate the `search_key` in a given sorted list `array`. 2. Handles edge cases including out-of-bound indexes and non-uniform distributions gracefully. 3. Returns the index of `search_key` if found, otherwise -1. 4. Optimizes for performance, ensuring the most efficient search runtime within practical constraints. Function Signature ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: pass ``` Input & Output Format - **Input**: - `array`: A list of integers sorted in ascending order. - `search_key`: An integer value to search for within `array`. - **Output**: - Returns an integer index of `search_key` if it exists in `array`. - Returns -1 if `search_key` is not found. Constraints - Array size `1 <= len(array) <= 10^5` - Element values in `array`: `-10^9 <= value <= 10^9` - Search key values: `-10^9 <= search_key <= 10^9` Performance Requirement Ensure the function operates efficiently with an average runtime complexity close to O(log log n). Example ```python >>> enhanced_interpolation_search([10, 22, 35, 40, 45, 50, 60, 75, 80, 90], 75) 7 >>> enhanced_interpolation_search([10, 22, 35, 40, 45, 50, 60, 75, 80, 90], 100) -1 >>> enhanced_interpolation_search([5, 15, 25, 35, 40, 50], 5) 0 >>> enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -26) -1 ```","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: Uses the interpolation search algorithm to locate the search_key in the given sorted list array. Returns the index of search_key if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low else: return -1 # Probing the position with the search formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Check if the probe position is within the bounds of the array if pos < low or pos > high: return -1 # Condition of target found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"**Scenario**: You are tasked with implementing a sorting algorithm for a large dataset in a constrained environment where memory usage needs to be minimized. You need to use in-place sorting, and the dataset consists of integers. The requirement also includes that detailed simulation logs must be produced during the algorithm\'s execution to track the state of the array. **Problem Statement**: Implement a function `descending_heap_sort(arr, simulation=False)` that sorts an array of integers in descending order using a heap sort algorithm. Unlike the given snippets which sort in ascending order using either a max heap or min heap, this function should be optimized and simulate the sorting process in each step execution if the `simulation` flag is set to `True`. Additionally, determine the performance in terms of the total number of iterations the algorithm underwent to sort the array completely. Function Signature ```python def descending_heap_sort(arr: List[int], simulation: bool=False) -> (List[int], int): pass ``` Input Format - `arr`: A list of integers to be sorted. - `simulation`: A boolean flag to indicate whether to print each iteration for simulation purposes. Output Format - A tuple containing: - The sorted list of integers in descending order. - An integer indicating the total number of iterations/simulations. Constraints - The function should be able to handle arrays with lengths up to 10^6. - Do not use additional data structures that increase space complexity beyond O(1). Example ```python result, iterations = descending_heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], simulation=True) # Expected Output: ([9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1], Total Iterations: X) ``` Performance Note - Ensure that the implemented algorithm maintains an overall time complexity of O(n log(n)). - Optimize the implementation to minimize the total number of iterations/simulations.","solution":"from typing import List, Tuple def heapify(arr: List[int], n: int, i: int, simulation: bool=False) -> int: iterations = 1 largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # Swap if simulation: print(f\\"Heapify swap: {arr}\\") sub_iterations = heapify(arr, n, largest, simulation) iterations += sub_iterations return iterations def descending_heap_sort(arr: List[int], simulation: bool=False) -> Tuple[List[int], int]: n = len(arr) total_iterations = 0 # Build a maxheap for i in range(n // 2 - 1, -1, -1): iterations = heapify(arr, n, i, simulation) total_iterations += iterations # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # Swap if simulation: print(f\\"Extract swap: {arr}\\") iterations = heapify(arr, i, 0, simulation) total_iterations += iterations # Reverse the array to get it in descending order arr.reverse() if simulation: print(f\\"Final sorted array: {arr}\\") return arr, total_iterations"},{"question":"# Question: Optimized Least Common Multiple Calculation Problem Statement Implement an optimized function to calculate the Least Common Multiple (LCM) of two integers. Your implementation should leverage an efficient algorithm to compute the Greatest Common Divisor (GCD) as a part of the process. You are expected to handle edge cases and ensure that the function operates within the constraints provided. Requirements 1. Implement the function `optimized_lcm(a: int, b: int) -> int` which returns the Least Common Multiple (LCM) of `a` and `b`. 2. Ensure that the function correctly handles negative integers by treating their absolute values. 3. Account for edge cases where either `a` or `b` is zero, and return 0 since the LCM of any number with zero is defined as zero. 4. Optimize the function for performance by using bitwise operations where possible. Input and Output Format * **Input**: Two integers `a` and `b` such that -10^6 ≤ a, b ≤ 10^6. * **Output**: A single integer representing the Least Common Multiple of `a` and `b`. Example *Input*: ```python a = 21 b = 14 ``` *Output*: ```python LCM(21, 14) = 42 ``` *Input*: ```python a = 0 b = 15 ``` *Output*: ```python LCM(0, 15) = 0 ``` **Constraints**: - Use only integer operations. - Your implementation should have a time complexity of O(log(min(a, b))).","solution":"def gcd(a, b): Computes the Greatest Common Divisor (GCD) of two integers using the Euclidean algorithm. a, b = abs(a), abs(b) while b: a, b = b, a % b return a def optimized_lcm(a, b): Computes the Least Common Multiple (LCM) of two integers a and b. Handles negative integers by treating their absolute values. If either a or b is zero, returns 0. if a == 0 or b == 0: return 0 gcd_value = gcd(a, b) return abs(a // gcd_value * b)"},{"question":"# Scenario You are tasked with implementing a Binary Search Tree (BST) that will help store student grades in a school. Each student grade is represented as an integer. # Task Implement the `insert` and `find` methods for the BST, ensuring that all BST properties are maintained. # Function Signatures ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: # Insert the value into the BST pass def find(self, val: int) -> bool: # Return True if the value is found in the BST, else False pass ``` # Input and Output Formats - **insert(val: int)**: This method takes an integer `val`, inserts it into the BST while maintaining its properties. - **find(val: int)**: This method takes an integer `val`, returns True if the value is present in the BST, otherwise returns False. # Constraints - The input integers are within the range `[-10^5, 10^5]`. - Methods will be called multiple times in any order. # Example ```python # Initialize BST bst = BST() # Insert values bst.insert(5) bst.insert(3) bst.insert(7) # Find values print(bst.find(3)) # Output: True print(bst.find(4)) # Output: False # Insert more values bst.insert(4) # Find updated values print(bst.find(4)) # Output: True ``` # Notes - Ensure your implementation considers edge cases like inserting into an empty tree or finding a value in an initially empty tree. - Maintain efficient performance for both insertion and finding operations.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node: TreeNode, val: int) -> None: if val < node.val: if node.left: self._insert_recursive(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert_recursive(node.right, val) else: node.right = TreeNode(val) def find(self, val: int) -> bool: return self._find_recursive(self.root, val) def _find_recursive(self, node: TreeNode, val: int) -> bool: if not node: return False if node.val == val: return True elif val < node.val: return self._find_recursive(node.left, val) else: return self._find_recursive(node.right, val)"},{"question":"You are working on a system that processes data in different endian formats. Your task is to write functions that can convert integers to bytes and vice versa, handling both big-endian and little-endian formats. You need to ensure that your implementation is efficient and handles edge cases correctly. # Function Specifications 1. **Function**: `convert_to_bytes(num: int, endian: str) -> bytes` - **Input**: - `num` (int): The integer to convert. - `endian` (str): The endian format, either \'big\' or \'little\'. - **Output**: - Returns the byte array corresponding to the integer in the specified endian format. 2. **Function**: `convert_to_int(bytestr: bytes, endian: str) -> int` - **Input**: - `bytestr` (bytes): The byte array to convert back to an integer. - `endian` (str): The endian format, either \'big\' or \'little\'. - **Output**: - Returns the integer corresponding to the byte array in the specified endian format. # Constraints * You can assume that the input integer is non-negative. * The byte array can be empty or contain up to 64 bytes. * You must efficiently handle conversion without using third-party libraries. # Example Cases 1. **Example 1**: * Input: `convert_to_bytes(305419896, \'big\')` * Output: `b\'x12x34x56x78\'` 2. **Example 2**: * Input: `convert_to_bytes(305419896, \'little\')` * Output: `b\'x78x56x34x12\'` 3. **Example 3**: * Input: `convert_to_int(b\'x12x34x56x78\', \'big\')` * Output: `305419896` 4. **Example 4**: * Input: `convert_to_int(b\'x78x56x34x12\', \'little\')` * Output: `305419896` # Implementation Details Ensure your solutions pass the provided test cases and consider additional edge cases, such as converting the number 0, very large numbers, and empty byte arrays.","solution":"def convert_to_bytes(num: int, endian: str) -> bytes: Converts an integer to a byte array in the specified endian format. :param num: The integer to convert. :param endian: The endian format, either \'big\' or \'little\'. :return: Byte array representing the integer in the specified endian format. length = (num.bit_length() + 7) // 8 or 1 return num.to_bytes(length, endian) def convert_to_int(bytestr: bytes, endian: str) -> int: Converts a byte array to an integer in the specified endian format. :param bytestr: The byte array to convert. :param endian: The endian format, either \'big\' or \'little\'. :return: Integer representing the byte array in the specified endian format. return int.from_bytes(bytestr, endian)"},{"question":"You need to write a function that finds the next higher number which has the exact same set of digits as the original number. If no such number exists, return `-1`. Function Signature ```python def next_bigger(num: int) -> int: pass ``` Input * The function `next_bigger` takes a single argument: - `num` (int): A non-negative integer which we will find the next permutation for. Output * The function returns: - An integer which is the next higher number with the same digit set, or `-1` if no such number exists. Constraints 1. `0 <= num <= 10**18` (The number can have up to 18 digits) Example Case 1 **Input**: ```python next_bigger(38276) ``` **Output**: ```python 38627 ``` Example Case 2 **Input**: ```python next_bigger(99999) ``` **Output**: ```python -1 ``` Explanation In the first case, the next permutation after 38276 within the same set of digits is 38627. In the second case, all digits are the same so no bigger permutation exists, hence we return `-1`. Additional Notes * Consider edge cases such as `num` being a single digit, sequential digits in descending order, or containing repeated digits.","solution":"def next_bigger(num: int) -> int: # Convert the number to a list of digits digits = list(str(num)) n = len(digits) # Find the first digit from the end that is smaller than the digit next to it i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, return -1 if i == -1: return -1 # Find the smallest digit on the right side of the found digit that is larger than the found digit j = n - 1 while digits[j] <= digits[i]: j -= 1 # Swap the found digits digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after the found digit digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert the list of digits back to a number next_bigger_num = int(\\"\\".join(digits)) return next_bigger_num"},{"question":"You are given an encoded message containing only digits and need to determine the total number of ways to decode it using the following mapping: - \'A\' -> 1 - \'B\' -> 2 - ... - \'Z\' -> 26 The encoded message will contain at most 1000 characters. Implement a function `decode_ways(encoded_message: str) -> int` which computes the number of ways to decode the given message. # Input * A string `encoded_message` containing up to 1000 characters, i.e., `1 <= len(encoded_message) <= 1000`. # Output * An integer representing the total number of ways to decode the given message. # Constraints * The input string will only contain digits and will not be empty. * If the message starts with \'0\' or contains invalid decoding patterns (like \'30\'), the function should return 0. # Examples 1. `decode_ways(\\"12\\")` should return `2` (decoded as \\"AB\\" (1 2) or \\"L\\" (12)). 2. `decode_ways(\\"226\\")` should return `3` (decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6)). 3. `decode_ways(\\"0\\")` should return `0` (invalid message). 4. `decode_ways(\\"10\\")` should return `1` (decoded as \\"J\\" (10)). # Note - You can assume that the input string always consists of digits and is non-empty.","solution":"def decode_ways(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): one_digit = int(encoded_message[i - 1:i]) two_digits = int(encoded_message[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"Context You are required to manage the structure and height of a Binary Search Tree (BST). The height of the tree is defined as the number of levels in the tree. It is crucial due to its influence on the efficiency of tree operations. Problem Statement Write a Python function `height` that takes the root node of a BST and returns its height. Additionally, write a function `insert` that inserts new values into the BST while maintaining its properties. Input and Output * The `height` function accepts a `Node` object which represents the root of the BST. * The `insert` function accepts a `Node` object (root of the BST) and an integer value to insert. * The output of the `height` function is an integer representing the height of the tree. Constraints 1. The tree can be empty (in that case, the height should be 0). 2. A single node tree has a height of 1. 3. Nodes contain unique integer values. 4. Maximum number of nodes, `n`, is `10^3`. Example ```plaintext Input Tree: 9 / 6 12 / / 3 8 10 15 / 7 18 Expected Output: 4 ``` Unit Test Create a unit test suite to thoroughly test the following: * Tree height calculation. * Node insertion correctness. ```python class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if not node.left: node.left = Node(value) else: self._insert_recursive(node.left, value) else: if not node.right: node.right = Node(value) else: self._insert_recursive(node.right, value) def height(root): if not root: return 0 return 1 + max(height(root.left), height(root.right)) import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = BST() for value in [9, 6, 12, 3, 8, 10, 15, 7, 18]: self.tree.insert(value) def test_height(self): self.assertEqual(4, height(self.tree.root)) def test_insert(self): self.tree.insert(11) # should add 11 under node with value 12 self.assertTrue(self.tree.root.right.left.right is not None) self.assertEqual(11, self.tree.root.right.left.right.value) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if not node.left: node.left = Node(value) else: self._insert_recursive(node.left, value) else: if not node.right: node.right = Node(value) else: self._insert_recursive(node.right, value) def height(root): if not root: return 0 return 1 + max(height(root.left), height(root.right))"},{"question":"Implement Enhanced Cocktail Shaker Sort Cocktail Shaker Sort is an efficient variation of Bubble Sort that sorts a given array of integers. However, it has limitations when handling large arrays or arrays that are nearly sorted. Enhancing the algorithm can significantly improve its performance. Task Implement an enhanced version of the Cocktail Shaker Sort that: 1. Reduces the range of the subsequent passes based on the last swapped positions. 2. Handles early exit efficiently when no swaps are needed during a pass. Function Signature ```python def enhanced_cocktail_shaker_sort(arr: list[int]) -> list[int]: Sorts an array of integers in ascending order using the enhanced Cocktail Shaker Sort. Args: arr (list[int]): Input list of integers to be sorted. Returns: list[int]: The sorted list of integers. ``` Input * A list of integers `arr` with length `1 <= len(arr) <= 1000`. Output * A list of integers sorted in ascending order. Constraints * The function should handle arrays with negative numbers, zeros, and duplicates. * Use a time complexity of O(N^2) in the worst case and space complexity of O(1). Examples ```python assert enhanced_cocktail_shaker_sort([3, 0, -1, 8, -10, 1, 2]) == [-10, -1, 0, 1, 2, 3, 8] assert enhanced_cocktail_shaker_sort([5, 3, 2, 8, 1]) == [1, 2, 3, 5, 8] assert enhanced_cocktail_shaker_sort([10, -10, 0, 10, -10, 10, -10]) == [-10, -10, -10, 0, 10, 10, 10] assert enhanced_cocktail_shaker_sort([]) == [] assert enhanced_cocktail_shaker_sort([1]) == [1] ``` Notes * Consider implementing a more efficient range reduction by tracking the last swap position and using it to determine the bounds of subsequent passes. * Ensure that your function exits early if the list becomes sorted before completing all passes.","solution":"def enhanced_cocktail_shaker_sort(arr: list[int]) -> list[int]: Sorts an array of integers in ascending order using the enhanced Cocktail Shaker Sort. Args: arr (list[int]): Input list of integers to be sorted. Returns: list[int]: The sorted list of integers. if not arr: return [] n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass new_end = 0 for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True new_end = i end = new_end if not swapped: break # Backward pass swapped = False new_start = 0 for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True new_start = i start = new_start + 1 return arr"},{"question":"**Scenario**: You are tasked with developing a feature for a text-processing software which involves reversing strings. Your main goal is to ensure that this feature is implemented efficiently. As part of the evaluation, you should demonstrate your understanding of both recursive and iterative approaches, as well as any built-in Python functionalities. **Objective**: Implement a function named `reverse_string` that accepts a string `s` and an additional parameter `method` with possible values \'recursive\', \'iterative\', \'pythonic\', or \'ultra_pythonic\'. The function should reverse the given string based on the specified method and return the reversed string. **Function Signature**: ```python def reverse_string(s: str, method: str) -> str: pass ``` # Input and Output Format **Input**: * `s` (string) – the string to be reversed. * `method` (string) – the method to be used for reversing the string. **Output**: * Reversed string based on the selected method. # Constraints * The length of `s` will be in the range [0, 10^6]. * The function should handle empty strings appropriately. * Assume the `method` parameter will always be a valid string among [\'recursive\', \'iterative\', \'pythonic\', \'ultra_pythonic\']. # Examples 1. `reverse_string(\\"hello\\", \\"recursive\\")` -> \\"olleh\\" 2. `reverse_string(\\"world\\", \\"iterative\\")` -> \\"dlrow\\" 3. `reverse_string(\\"python\\", \\"pythonic\\")` -> \\"nohtyp\\" 4. `reverse_string(\\"example\\", \\"ultra_pythonic\\")` -> \\"elpmaxe\\" # Performance Requirements * The function should run within acceptable time limits for input strings as large as 10^6 characters. # Additional Notes * Pay special attention to edge cases, such as empty strings and single-character strings. * Ensure compliance with specified time and space complexity constraints.","solution":"def reverse_string(s: str, method: str) -> str: Reverse a string using the specified method. Args: s (str): The string to be reversed. method (str): The method to use for reversing the string, one of \'recursive\', \'iterative\', \'pythonic\', \'ultra_pythonic\'. Returns: str: The reversed string. if method == \'recursive\': return _recursive_reverse(s) elif method == \'iterative\': return _iterative_reverse(s) elif method == \'pythonic\': return s[::-1] elif method == \'ultra_pythonic\': return \'\'.join(reversed(s)) else: raise ValueError(\\"Invalid method specified\\") def _recursive_reverse(s: str) -> str: if len(s) == 0: return s else: return s[-1] + _recursive_reverse(s[:-1]) def _iterative_reverse(s: str) -> str: reversed_string = \\"\\" for character in s: reversed_string = character + reversed_string return reversed_string"},{"question":"# Advanced Heap Sorting Challenge As a software developer at a tech company dealing with high volumes of data, you are required to implement an efficient sorting algorithm using the principles of heap data structures. Your goal is to develop a function that sorts an array in ascending order by simulating either a max heap or a min heap sorting process based on provided parameters. # Requirements Implement the function `heap_sort` which takes the following parameters: - `arr`: The list of integers to be sorted. - `heap_type`: A string that can either be `\'max\'` or `\'min\'`, specifying the type of heap to be used for sorting. - `simulate`: A boolean flag. If `True`, the function should print each iteration\'s array state. Function Signature ```python def heap_sort(arr: List[int], heap_type: str, simulate: bool) -> List[int]: ``` Parameters - `arr` (List[int]): The input list of integers. - `heap_type` (str): Determines whether to use a `\'max\'` heap or `\'min\'` heap for sorting. - `simulate` (bool): If `True`, prints each iteration of the sorting process. Returns - `List[int]`: The sorted list of integers. # Constraints: - The array will have a length in the range `[0, 10^3]`. - Elements of the array will be integers in the range `[-10^4, 10^4]`. - You are encouraged to optimize for both time and space complexities. # Example ```python # Example usage assert heap_sort([3, 5, 1, 2, 4], \'max\', True) == [1, 2, 3, 4, 5] assert heap_sort([3, 5, 1, 2, 4], \'min\', False) == [1, 2, 3, 4, 5] ``` # Guidelines: - Consider the edge cases like empty array, single-element array, arrays with duplicate elements, etc. - Pay attention to space complexity; the sorting must be done in place. - Print each iteration state if the `simulate` flag is `True`. This assessment will test your comprehension of heap structures, sorting algorithms, and in-depth implementation skills. Good luck!","solution":"from typing import List def heap_sort(arr: List[int], heap_type: str, simulate: bool) -> List[int]: n = len(arr) def simulate_and_print(): if simulate: print(arr) def heapify(arr, n, i, max_heap): largest_smallest = i l = 2 * i + 1 r = 2 * i + 2 if max_heap: if l < n and arr[i] < arr[l]: largest_smallest = l if r < n and arr[largest_smallest] < arr[r]: largest_smallest = r else: if l < n and arr[i] > arr[l]: largest_smallest = l if r < n and arr[largest_smallest] > arr[r]: largest_smallest = r if largest_smallest != i: arr[i], arr[largest_smallest] = arr[largest_smallest], arr[i] simulate_and_print() heapify(arr, n, largest_smallest, max_heap) if heap_type == \'max\': max_heap = True elif heap_type == \'min\': max_heap = False else: return arr for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, max_heap) simulate_and_print() for i in range(n - 1, 0, -1): arr[0], arr[i] = arr[i], arr[0] simulate_and_print() heapify(arr, i, 0, max_heap) simulate_and_print() return arr if max_heap else arr[::-1]"},{"question":"# Question You are tasked with writing a function that checks if a given integer is a power of two. A power of two is any positive integer that can be expressed as 2^k where k is a non-negative integer. # Function Definition ```python def is_power_of_two(n: int) -> bool: Determine if the given integer is a power of two. :param n: Integer to be checked :return: True if n is a power of two, else False ``` # Input * An integer `n`. # Output * A boolean value: `True` if `n` is a power of two, `False` otherwise. # Constraints * The function should handle negative values and zero appropriately by returning `False`. # Performance Requirements * The function should run in constant time O(1) and space O(1). # Examples Example 1: * Input: `n = 1` * Output: `True` * Explanation: 1 is 2^0. Example 2: * Input: `n = 16` * Output: `True` * Explanation: 16 is 2^4. Example 3: * Input: `n = 18` * Output: `False` * Explanation: 18 is not a power of two. Example 4: * Input: `n = 0` * Output: `False` * Explanation: 0 is not a power of two. Example 5: * Input: `n = -8` * Output: `False` * Explanation: Negative numbers are not powers of two. # Scenarios * Determining if a number of elements can be evenly divided by repeatedly halving. * Validation in systems that operate on powers of two, such as memory allocation and binary protocols.","solution":"def is_power_of_two(n: int) -> bool: Determine if the given integer is a power of two. :param n: Integer to be checked :return: True if n is a power of two, else False # For n to be a power of two, it must be greater than 0 and its binary representation # must contain exactly one \'1\'. return n > 0 and (n & (n - 1)) == 0"},{"question":"# Question: Implement Enhanced Nearest Neighbor Algorithm Scenario You are working on a machine learning project for classifying objects based on their features in a multidimensional space. The classification is performed using a Nearest Neighbor algorithm. Given new data points, you must classify these using a trained model (training set). Task Implement a more robust version of the `nearest_neighbor` function, ensuring it handles various edge cases, optimizes performance for larger datasets, and maintains clear and accurate results. Requirements 1. **Distance Calculation**: - Implement a function `enhanced_distance(x: Tuple[float, ...], y: Tuple[float, ...]) -> float` that calculates the Euclidean distance between two vectors. 2. **Nearest Neighbor Classification**: - Implement a function `enhanced_nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any], method: str = \\"sequential\\") -> Any` that: - Accepts an input vector `x`. - Uses a training set `tSet` (a dictionary of vectors mapped to their classes/values). - Includes an optional parameter `method` to change the method of finding nearest neighbors (default is sequential search). - Returns the class/value of the nearest neighbor. Constraints * Vectors will have real-number components only. * Training sets will contain at least one vector. Input and Output Formats * `enhanced_distance`: - **Input**: Two tuples of float numbers, e.g., `(1.0, 2.0)` and `(2.0, 3.0)`. - **Output**: A single float number representing the Euclidean distance. * `enhanced_nearest_neighbor`: - **Input**: - A tuple of float numbers, e.g., `(1.0, 2.0)`. - A dictionary with keys as tuples of float numbers and values as their classification labels. - An optional string specifying the search method. - **Output**: The classification label of the nearest neighbor. Example ```python # Example Training Set training_set = { (1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (4.0, 6.0): \'A\' } # Finding Nearest Neighbor result = enhanced_nearest_neighbor((1.5, 2.5), training_set) print(result) # Output should be \'A\' # Finding Nearest Neighbor with optimized method result = enhanced_nearest_neighbor((1.5, 2.5), training_set, method=\\"kd-tree\\") print(result) # Output should be \'A\' assuming KD-Tree implementation ``` Ensure your implementation is efficient, robust against edge cases, and handles incorrect input gracefully.","solution":"from typing import Tuple, Dict, Any, Optional import numpy as np from scipy.spatial import KDTree def enhanced_distance(x: Tuple[float, ...], y: Tuple[float, ...]) -> float: Calculates the Euclidean distance between two vectors x and y. return np.linalg.norm(np.array(x) - np.array(y)) def enhanced_nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any], method: str = \\"sequential\\") -> Any: Returns the class/value of the nearest neighbor for the input vector x using the training set tSet. Parameters: - x: Input vector. - tSet: Training set (dictionary of vectors mapped to their classes/values). - method: Method of finding nearest neighbors (default is sequential). Returns: - The class/value of the nearest neighbor. if method == \\"sequential\\": nearest = min(tSet.keys(), key=lambda point: enhanced_distance(x, point)) return tSet[nearest] elif method == \\"kd-tree\\": points = list(tSet.keys()) kd_tree = KDTree(points) _, idx = kd_tree.query(x) return tSet[points[idx]] else: raise ValueError(f\\"Unsupported method \'{method}\'. Use \'sequential\' or \'kd-tree\'.\\") # Example usage training_set = { (1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (4.0, 6.0): \'A\' } result = enhanced_nearest_neighbor((1.5, 2.5), training_set) print(result) # Output should be \'A\' result = enhanced_nearest_neighbor((1.5, 2.5), training_set, method=\\"kd-tree\\") print(result) # Output should be \'A\' assuming KD-Tree implementation"},{"question":"**Context**: A large digital library maintains vast collections of e-books and articles. For efficient content retrieval and plagiarism detection, the library needs an optimized text search feature that can quickly locate instances of specific phrases within large bodies of text. **Task**: You are provided with the Knuth-Morris-Pratt (KMP) pattern matching algorithm, which efficiently locates a pattern within a given text. To further assess your understanding of the algorithm, you need to implement a function that leverages the KMP algorithm to solve the following problem: **Problem Statement**: Implement the function `find_phrases` that takes a list of phrases and a single text input and returns a dictionary where the keys are the phrases and the values are lists of start indices in the text where each phrase is found. # Function Signature: ```python from typing import List, Dict def find_phrases(text: str, phrases: List[str]) -> Dict[str, List[int]]: pass ``` # Input: * `text` : A single string representing the text to search within. (`1 <= len(text) <= 10^6`) * `phrases`: A list of strings representing the phrases to search for. (`1 <= len(phrases) <= 1000`, and `1 <= len(phrases[i]) <= 1000` for each phrase) # Output: * A dictionary where each key is a phrase from the `phrases` list and the value is a list of integers representing the start indices in the text where the phrase is found. If a phrase is not found, it should map to an empty list. # Constraints: * Performance requirement: The solution should efficiently handle large texts and numerous phrases, leveraging the linear time complexity of the KMP algorithm. * Ensure that edge cases such as empty text or phrases are handled gracefully. # Example: ```python text = \\"abracadabra\\" phrases = [\\"abra\\", \\"cad\\"] output = find_phrases(text, phrases) # Expected output: # { # \\"abra\\": [0, 7], # \\"cad\\": [4] # } ``` **Additional Notes**: * Utilize the `knuth_morris_pratt` function provided for individual pattern searches within the `find_phrases` function. * Ensure proper test coverage to validate your implementation against different edge cases and performance requirements.","solution":"from typing import List, Dict def knuth_morris_pratt(text: str, pattern: str) -> List[int]: KMP algorithm to find all occurrences of the pattern in the text. n, m = len(text), len(pattern) lps = [0] * m j = 0 # index for pattern occurrences = [] # Preprocess the pattern - create lps[] that will hold the longest prefix suffix values for pattern def compute_lps_array(): length = 0 # length of the previous longest prefix suffix i = 1 while i < m: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 compute_lps_array() i = 0 # index for text while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: occurrences.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return occurrences def find_phrases(text: str, phrases: List[str]) -> Dict[str, List[int]]: Find occurrences of each phrase in the text using the KMP algorithm. results = {} for phrase in phrases: results[phrase] = knuth_morris_pratt(text, phrase) return results"},{"question":"# Problem Description You are given a collection of numbers that might contain duplicates. Write a function,`permute_unique`, that returns all possible unique permutations of the list. # Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` # Input - `nums`: a list of integers, which may contain duplicates. - Example: `[1, 1, 2]` # Output - A list of lists where each inner list is a unique permutation of `nums`. - Example: ```python [ [1,1,2], [1,2,1], [2,1,1] ] ``` # Constraints - The length of `nums` will be in the range [1, 8]. - `nums` elements are in the range -10 to 10. # Performance Requirements - Function should efficiently handle up to the maximum constraints with acceptable time and space complexity. # Scenario You are designing a new digital card game, where you need to arrange cards in all possible unique orders to determine all potential outcomes. The cards may have duplicates. For instance, if you have three cards `[1, 1, 2]`, the unique arrangements of these cards are important to determine the order of player actions based on their distinct arrangements. # Example ```python print(permute_unique([1, 1, 2])) # Expected Output: # [ # [1,1,2], # [1,2,1], # [2,1,1] # ] ``` # Additional Notes - Consider the handling of duplicates carefully to avoid redundant permutations. - Ensure the function deals with edge cases efficiently without exceeding time and space limits.","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(path, counter): if len(path) == len(nums): result.append(path[:]) # Make a deep copy since path is reused return for num in counter: if counter[num] > 0: # choose the number path.append(num) counter[num] -= 1 # explore further backtrack(path, counter) # unchoose the number path.pop() counter[num] += 1 result = [] counter = {} for num in nums: counter[num] = counter.get(num, 0) + 1 backtrack([], counter) return result"},{"question":"# Question: Sort Colors using Dutch National Flag Algorithm You are tasked with writing a function that sorts an array containing integers 0, 1, and 2 in the order (0s, then 1s, and then 2s). Scenario You are implementing a simplified sorting system for a warehouse that sorts products by color represented by integers (0 for red, 1 for white, and 2 for blue). Implement a function to sort the array of products such that the products are ordered by their color codes. Function Signature ```python def sort_colors(nums): # Your implementation here ``` # Input * `nums` (List[int]): An array of integers where each integer is 0, 1, or 2, representing a color. # Output The function should modify the input array in-place and sort the integers such that they appear in the order: 0s first, followed by 1s, and then 2s. # Constraints * The array length `n` will be in the range [1, 10^5]. * The array will only contain integers 0, 1, or 2. # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] nums = [2, 1, 0] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` # Notes * You are not supposed to use the built-in `sort` function. * Optimize for both time and space complexity as described in the algorithm analysis. Additional Notes Submit your implementation of the `sort_colors` function. Make sure your solution is efficient and handles all edge cases appropriately.","solution":"def sort_colors(nums): Sorts an array containing integers 0, 1, and 2 in the order of 0s, then 1s, and then 2s. Uses the Dutch National Flag algorithm. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: # Swap the elements at indices \'low\' and \'mid\', and increment both pointers nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: # If the element is 1, just move the \'mid\' pointer mid += 1 else: # If the element is 2, swap the elements at indices \'mid\' and \'high\', and decrease the \'high\' pointer nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"You are tasked with implementing a function to multiply two non-negative integers without using the \'*\' operator. Your solution should leverage bitwise operations to achieve this. # Function Signature: ```python def multiply_bitwise_operator(x: int, y: int) -> int: ``` # Input: * `x`: A non-negative integer. * `y`: A non-negative integer. # Output: * Returns an integer which is the product of `x` and `y`. # Constraints: * Do not use \'*\', \'/\', or any other direct arithmetic multiplication operator. * You may use addition, subtraction, bitwise operators, and loops. * The input values `x` and `y` will be such that their product fits within a standard integer range. # Example: ```python assert multiply_bitwise_operator(2, 3) == 6 assert multiply_bitwise_operator(0, 4) == 0 assert multiply_bitwise_operator(5, 5) == 25 ``` # Notes: To solve this problem, consider using the bitwise shift operations to represent the multiplication process. You will use steps similar to the bitwise addition shown in the provided function, coupled with shifts and repeated additions to simulate multiplication.","solution":"def multiply_bitwise_operator(x: int, y: int) -> int: Multiplies two non-negative integers using bitwise operations. result = 0 while y > 0: # If the least significant bit is set, add x to the result if y & 1: result += x # Shift x left (equivalent to multiplying x by 2) x <<= 1 # Shift y right (equivalent to dividing y by 2) y >>= 1 return result"},{"question":"# Integer-Byte Conversion Challenge You are required to implement a more versatile and efficient integer-to-byte and byte-to-integer conversion system that handles both positive and negative integers, as well as addresses the inefficiency in the current implementation. Your task is to write the following functions: 1. `int_to_bytes(num, endianness)` - Converts an integer to a byte array with a specified endianness. 2. `bytes_to_int(bytestr, endianness)` - Converts a byte array back to an integer with a specified endianness. # Function Specifications 1. `int_to_bytes(num, endianness)` * **Input**: - `num`: An integer (either positive or negative). - `endianness`: A string \'big\' or \'little\' representing the byte order. * **Output**: A `bytearray` representing the integer in the specified byte order. * **Constraints**: - Use efficient methods to handle both endianness. - Ensure the method handles zero correctly. 2. `bytes_to_int(bytestr, endianness)` * **Input**: - `bytestr`: A `bytearray` which represents the byte order. - `endianness`: A string \'big\' or \'little\' representing the byte order. * **Output**: An integer reconstructed from the byte array in the specified byte order. * **Constraints**: - Ensure correct reconstruction of both positive and negative integers. # Performance requirements * Your solution should have a time complexity of O(n) for both conversions, where n is the number of bytes. * The space complexity should stay within O(n). # Example For the implementation of `int_to_bytes` and `bytes_to_int`: ```python def int_to_bytes(num, endianness): # Your implementation here def bytes_to_int(bytestr, endianness): # Your implementation here # Expected usage: print(int_to_bytes(305419896, \'big\')) # Output: bytearray(b\'x12x34x56x78\') print(bytes_to_int(bytearray(b\'x12x34x56x78\'), \'big\')) # Output: 305419896 print(int_to_bytes(305419896, \'little\')) # Output: bytearray(b\'xV4x12\') print(bytes_to_int(bytearray(b\'xV4x12\'), \'little\')) # Output: 305419896 ``` Ensure your solution is robust enough to handle edge cases like zero and negative values.","solution":"def int_to_bytes(num, endianness): Converts an integer to a byte array with a specified endianness. Args: num (int): The integer to convert. endianness (str): The byte order (\'big\' or \'little\'). Returns: bytearray: The byte array representing the integer. if endianness not in (\'big\', \'little\'): raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") if num == 0: return bytearray([0]) num_bytes = (num.bit_length() + 7) // 8 # Determine the minimum number of bytes needed if num < 0: # Calculate the minimum bytes needed for negative number with sign extension num_bytes = (num.bit_length() + 8) // 8 return num.to_bytes(num_bytes, byteorder=endianness, signed=True) def bytes_to_int(bytestr, endianness): Converts a byte array back to an integer with a specified endianness. Args: bytestr (bytearray): The byte array to convert. endianness (str): The byte order (\'big\' or \'little\'). Returns: int: The integer reconstructed from the byte array. if endianness not in (\'big\', \'little\'): raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") return int.from_bytes(bytestr, byteorder=endianness, signed=True)"},{"question":"# Question You are given an implementation of a `SeparateChainingHashTable` which is a type of hash table that resolves collisions using linked lists. Your task is to enhance this hash table by implementing resizing functionality to dynamically adjust the size of the underlying array based on the load factor. # Task 1. Implement a `resize` method that: - Doubles the size of the hash table if the load factor exceeds 0.75. - Rehashes all existing keys into the new larger table. 2. Integrate `resize` into `put` if necessary. # Input and Output Formats - You will only modify the `SeparateChainingHashTable` class to add the `resize` method and integrate it into the `put` method. - The `resize` method should take no arguments and should update the internal `_table` and `size`. # Constraints - The initial size of the hash table remains at 11. - Ensure the `resize` method correctly rehashes all elements without losing any data. - Performance should remain efficient even after multiple resizings. # Example ```python table = SeparateChainingHashTable(size=4) # Add initial elements table.put(\'apple\', 10) table.put(\'banana\', 20) table.put(\'grape\', 30) # This insertion should trigger a resize, size more than 75% full table.put(\'orange\', 40) # Table should maintain resized state # Check values assert table.get(\'apple\') == 10 assert table.get(\'banana\') == 20 assert table.get(\'grape\') == 30 assert table.get(\'orange\') == 40 # Check deletion after resize table.del_(\'banana\') assert table.get(\'banana\') is None ``` # Additional Information Ensure all standard operations (`put`, `get`, `del_`, `__len__`, etc.) work correctly even after resizing takes place.","solution":"class ListNode: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, size=11): self._table = [None] * size self.size = 0 def _hash(self, key): return hash(key) % len(self._table) def put(self, key, value): index = self._hash(key) node = self._table[index] if node is None: self._table[index] = ListNode(key, value) self.size += 1 else: while node: if node.key == key: node.value = value return if node.next is None: node.next = ListNode(key, value) self.size += 1 break node = node.next # Trigger a resize if load factor exceeds 0.75 if self.size / len(self._table) > 0.75: self._resize() def get(self, key): index = self._hash(key) node = self._table[index] while node: if node.key == key: return node.value node = node.next return None def del_(self, key): index = self._hash(key) node = self._table[index] prev = None while node: if node.key == key: if prev: prev.next = node.next else: self._table[index] = node.next self.size -= 1 return prev = node node = node.next def __len__(self): return self.size def _resize(self): old_table = self._table new_size = 2 * len(old_table) self._table = [None] * new_size old_size = self.size self.size = 0 for node in old_table: while node: self.put(node.key, node.value) node = node.next self.size = old_size"},{"question":"# Perfect Square Sequence Checker Context: You are tasked with enhancing an algorithm for a mathematical analysis tool. The tool processes a sequence of numbers and verifies if each number is a perfect square. When it is, the tool computes the next perfect square in the sequence. Your job is to implement this functionality efficiently. Problem Statement: Write a function `perfect_square_sequence(nums: List[int]) -> List[int]` that takes a list of integers and returns a new list where each value is the next perfect square if the original number was a perfect square, or -1 if it was not. Input and Output Formats: - **Input**: A list of integers `nums` where `1 <= len(nums) <= 10^4` and `0 <= nums[i] <= 10^9`. - **Output**: A list of integers where each value corresponds to the next perfect square of the respective input if the input was a perfect square or -1 if it was not. Constraints: - Your function should handle large inputs within a reasonable time frame. - Ensure that edge cases, such as 0 and 1, are handled correctly. - The result should handle cases without causing overflow errors. Example: ```python perfect_square_sequence([0, 1, 2, 121, 144]) # Output: [1, 4, -1, 144, 169] ``` Definition: ```python def perfect_square_sequence(nums: List[int]) -> List[int]: pass ``` Good luck! Focus on ensuring your implementation is both correct and efficient.","solution":"from typing import List import math def perfect_square_sequence(nums: List[int]) -> List[int]: def is_perfect_square(n): root = int(math.isqrt(n)) return root * root == n result = [] for num in nums: if is_perfect_square(num): next_root = int(math.isqrt(num)) + 1 result.append(next_root * next_root) else: result.append(-1) return result"},{"question":"# Question: Path Existence in a Directed Graph using DFS You are given a directed graph and two nodes (source and target). Your task is to determine if there exists a path from the source node to the target node using Depth First Search (DFS). Graph Class Definition Implement the following methods: 1. `add_edge(source: int, target: int) -> None`: Adds a directed edge from the `source` node to the `target` node. 2. `is_reachable(source: int, target: int) -> bool`: Returns `True` if there is a path from `source` to `target`, `False` otherwise. Input Format - The first line contains an integer `n`, the number of edges in the graph. - The following `n` lines each contain two space-separated integers `u` and `v` representing a directed edge from `u` to `v`. - The last line contains two space-separated integers `source` and `target`, representing the nodes between which to check for a path. Output Format - Output `True` if there is a path from `source` to `target`, otherwise `False`. Constraints - (1 leq n leq 10^4) (number of edges) - (0 leq u, v, source, target leq 10^3) (node values) - The graph may contain cycles. Example ```plaintext Input: 4 0 1 0 2 1 2 2 0 0 2 Output: True ``` Notes - You should handle edge cases where the graph has no edges or consists of a single node. - The graph is represented as an adjacency list. Implement the Graph class as described and demonstrate its usage with the provided example. ```python class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def is_reachable(self, source, target): visited = [False] * self.vertex_count return self.dfsutil(visited, source, target) def dfsutil(self, visited, source, target): if source == target: return True visited[source] = True for neighbor in self.graph[source]: if not visited[neighbor]: if self.dfsutil(visited, neighbor, target): return True return False # Example usage: graph = Graph(4) edges = [(0, 1), (0, 2), (1, 2), (2, 0)] for u, v in edges: graph.add_edge(u, v) source, target = 0, 2 print(graph.is_reachable(source, target)) # Output: True ```","solution":"from collections import defaultdict class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def is_reachable(self, source, target): visited = set() return self.dfs(source, target, visited) def dfs(self, current, target, visited): if current == target: return True visited.add(current) for neighbor in self.graph[current]: if neighbor not in visited: if self.dfs(neighbor, target, visited): return True return False # Example usage: graph = Graph() edges = [(0, 1), (0, 2), (1, 2), (2, 0)] for u, v in edges: graph.add_edge(u, v) source, target = 0, 2 print(graph.is_reachable(source, target)) # Output: True"},{"question":"Your task is to implement a class `Polynomial` and associated class `Monomial` to perform various arithmetic operations on polynomials. Your implementation should follow the principles laid out in the provided code snippets and ensure accuracy by using rational numbers wherever possible. # Objective - Implement the following methods for the `Monomial` class: - `__add__` - `__sub__` - `__mul__` - `inverse` - `__truediv__` - Implement the following methods for the `Polynomial` class: - `__add__` - `__sub__` - `__mul__` - `__truediv__` - `all_monomials` - `subs` # Input/Output Formats Monomial Class - __init__(variables: Dict[int, int], coeff: Union[int, float, Fraction, None]) -> None: Initializes a monomial with given variables and coefficient. - __add__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial: Adds two monomials or a monomial with a number. - __sub__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial: Subtracts a number or another monomial from this monomial. - __mul__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial: Multiplies two monomials or a monomial with a number. - inverse(self) -> Monomial: Returns the inverse of the current monomial. - __truediv__(self, other: Union[int, float, Fraction, Monomial]) -> Monomial: Divides this monomial by another monomial or a number. Polynomial Class - __init__(monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None: Initializes a polynomial with a collection of monomials. - __add__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial: Adds another polynomial, monomial, or number to this polynomial. - __sub__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial: Subtracts another polynomial, monomial, or number from this polynomial. - __mul__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial: Multiplies another polynomial, monomial, or number with this polynomial. - __truediv__(self, other: Union[int, float, Fraction, Monomial]) -> Polynomial: Divides this polynomial by a monomial or number. - all_monomials(self) -> Iterable[Monomial]: Returns the set of all monomials in the polynomial. - subs(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Union[int, float, Fraction]: Substitutes variables in the polynomial given a dictionary of values. # Constraints - Handle up to 10 variables per monomial. - Supports arithmetic operations only for monomials with non-zero coefficients. - Uses Fraction for all coefficients to maintain precision. - Monomial terms with a resulting coefficient of zero should be removed from the polynomial. Example Scenarios 1. Creating and adding two monomials: ```python m1 = Monomial({1:1}, 2) m2 = Monomial({1:1}, 3) result = m1 + m2 print(result) # Output : 5(a_1) ``` 2. Multiplying a polynomial by a monomial: ```python p = Polynomial([Monomial({1:1}, 2), Monomial({2:1}, 3)]) m = Monomial({1:1}, 4) result = p * m print(result) # Output: 8(a_1)**2 + 12(a_1)(a_2) ```","solution":"from fractions import Fraction from typing import Dict, Union, Iterable class Monomial: def __init__(self, variables: Dict[int, int], coeff: Union[int, float, Fraction, None]) -> None: self.variables = variables self.coeff = Fraction(coeff) if coeff is not None else Fraction(0) def __add__(self, other: \'Monomial\') -> \'Monomial\': if self.variables == other.variables: return Monomial(self.variables, self.coeff + other.coeff) raise ValueError(\\"Cannot add monomials with different variables\\") def __sub__(self, other: \'Monomial\') -> \'Monomial\': if self.variables == other.variables: return Monomial(self.variables, self.coeff - other.coeff) raise ValueError(\\"Cannot subtract monomials with different variables\\") def __mul__(self, other: Union[int, float, Fraction, \'Monomial\']) -> \'Monomial\': if isinstance(other, Monomial): new_vars = self.variables.copy() for var, exp in other.variables.items(): new_vars[var] = new_vars.get(var, 0) + exp return Monomial(new_vars, self.coeff * other.coeff) else: return Monomial(self.variables, self.coeff * Fraction(other)) def inverse(self) -> \'Monomial\': return Monomial(self.variables, 1 / self.coeff) def __truediv__(self, other: Union[int, float, Fraction, \'Monomial\']) -> \'Monomial\': if isinstance(other, Monomial): new_vars = self.variables.copy() for var, exp in other.variables.items(): new_vars[var] = new_vars.get(var, 0) - exp return Monomial(new_vars, self.coeff / other.coeff) else: return Monomial(self.variables, self.coeff / Fraction(other)) def __repr__(self) -> str: var_str = \'\'.join(f\\"a_{k}^{v}\\" if v > 1 else f\\"a_{k}\\" for k, v in sorted(self.variables.items())) return f\\"{self.coeff}({var_str})\\" class Polynomial: def __init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None: self.monomials = [] for monomial in monomials: if isinstance(monomial, Monomial): self.monomials.append(monomial) else: self.monomials.append(Monomial({}, monomial)) def __add__(self, other: Union[int, float, Fraction, Monomial, \'Polynomial\']) -> \'Polynomial\': if isinstance(other, Polynomial): return Polynomial(self.monomials + other.monomials) else: return Polynomial(self.monomials + [other]) def __sub__(self, other: Union[int, float, Fraction, Monomial, \'Polynomial\']) -> \'Polynomial\': if isinstance(other, Polynomial): inverted_monomials = [monomial.inverse() for monomial in other.monomials] return Polynomial(self.monomials + inverted_monomials) else: return Polynomial(self.monomials + [other.inverse()]) def __mul__(self, other: Union[int, float, Fraction, Monomial, \'Polynomial\']) -> \'Polynomial\': if isinstance(other, Polynomial): result_monomials = [] for m1 in self.monomials: for m2 in other.monomials: result_monomials.append(m1 * m2) return Polynomial(result_monomials) else: return Polynomial([m * other for m in self.monomials]) def __truediv__(self, other: Union[int, float, Fraction, Monomial]) -> \'Polynomial\': return Polynomial([m / other for m in self.monomials]) def all_monomials(self) -> Iterable[Monomial]: return self.monomials def subs(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: result = 0 for monomial in self.monomials: monomial_value = monomial.coeff for var, exp in monomial.variables.items(): monomial_value *= substitutions.get(var, 1) ** exp result += monomial_value return result def __repr__(self) -> str: return \\" + \\".join(map(str, self.monomials))"},{"question":"# Unique Subsets Generation You are provided with a list of integers that might contain duplicates. Your task is to write a function that returns all possible unique subsets of the given list. Write a function `generate_unique_subsets(nums)` which takes a list of integers `nums` as input and returns a list of lists, where each list is a unique subset of the input list. **Input:** - A list of integers `nums` (0 <= len(nums) <= 16, -10 <= nums[i] <= 10) **Output:** - A list of lists, where each list represents a unique subset of `nums`. **Example:** ``` Input: nums = [1, 2, 2] Output: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] ``` # Constraints: - Subsets must not contain duplicate sets. - Order of subsets or elements within subsets does not matter, but all unique subsets must be present. # Performance Requirement: - Your solution should be efficient in terms of memory usage and should avoid generating multiple duplicates through the algorithm. # Scenario/Context: Consider a situation where you need to find all possible combinations of ingredients for a recipe, but without repeating possibilities. This problem is analogous to that, where each possibility is akin to a unique subset in our context.","solution":"def generate_unique_subsets(nums): Returns all possible unique subsets of the given list `nums`. Args: nums (List[int]): A list of integers that may contain duplicates. Returns: List[List[int]]: A list of lists where each list is a unique subset of `nums`. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() result = [] nums.sort() # Sort to handle duplicates backtrack(0, []) return result"},{"question":"# Unique Element Finder Given an array of integers where every element appears exactly three times except for one unique element, implement a function `find_unique` that identifies and returns the unique element. Your algorithm must run in linear time and should not use any extra memory apart from a few integer variables. **Input**: - An array of integers `nums` where the array is non-empty, and every element appears three times except for one which appears once. **Output**: - An integer representing the unique element in the array. **Constraints**: - The input array will have elements which are 32-bit signed integers. - The array length is at least 4 elements and at most (10^4). - The array will contain exactly one unique element. **Example**: ```python assert find_unique([2, 2, 3, 2]) == 3 assert find_unique([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique([-2, -2, -3, -2]) == -3 ``` Provide a clear and efficient implementation of this function `find_unique(nums)`.","solution":"def find_unique(nums): This function finds the unique element in the array where every other element appears exactly three times. ones, twos = 0, 0 for num in nums: # `ones` contains the bits that have appeared 1st time in the array # `twos` contains the bits that have appeared 2nd time in the array ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Question You are tasked with implementing a function to determine the count of \'1\' bits in the binary representation of a given unsigned integer using Brian Kernighan\'s Algorithm. This will test your understanding of bit manipulation techniques. Function Signature ```python def count_one_bits(n: int) -> int: Calculate the number of \'1\' bits in the binary representation of the given unsigned integer. Parameters: n (int): An unsigned integer whose \'1\' bits need to be counted. Returns: int: The count of \'1\' bits in the binary representation of n. pass ``` # Input Format * `n` is a single unsigned integer (0 ≤ n ≤ 2^31 - 1). # Output Format * Return the count of \'1\' bits in the binary representation of `n`. # Constraints * The function must process input in a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of `n`. # Example ```python # Input: n = 11 # Binary Representation: 00000000000000000000000000001011 # Expected Output: 3 assert count_one_bits(11) == 3 # Input: n = 128 # Binary Representation: 00000000000000000000000010000000 # Expected Output: 1 assert count_one_bits(128) == 1 # Input: n = 0 # Binary Representation: 00000000000000000000000000000000 # Expected Output: 0 assert count_one_bits(0) == 0 ``` Additional Notes * Zero should return `0` as there are no bits set. * The function should efficiently handle large integers within the 32-bit limit. * Aim for clarity in your bit manipulation steps to avoid any logical errors.","solution":"def count_one_bits(n: int) -> int: Calculate the number of \'1\' bits in the binary representation of the given unsigned integer. Parameters: n (int): An unsigned integer whose \'1\' bits need to be counted. Returns: int: The count of \'1\' bits in the binary representation of n. count = 0 while n: n = n & (n - 1) # This operation reduces the number of 1s by one each time count += 1 return count"},{"question":"# Gnome Sort with Enhancements You are given a sorting algorithm known as Gnome Sort. While simple to implement, it suffers from inefficient time complexity in most cases. Our task is to implement a function that sorts an array using the Gnome Sort algorithm, but also includes: 1. Handling edge cases explicitly. 2. Optimizing the algorithm to avoid unnecessary comparisons and swaps. Problem Statement Implement the function `optimized_gnome_sort(arr)` that sorts the elements of a list `arr` using an enhanced version of the Gnome Sort algorithm. This enhanced version should minimize the number of comparisons and swaps where possible. Input * A list of integers, `arr`. Output * A sorted list of integers. Constraints * The length of `arr` will be between 0 and 10^5. * Each element of `arr` is an integer that can be negative or positive. Instructions 1. Optimize the given Gnome Sort algorithm to make fewer comparisons and swaps. 2. Handle edge cases like empty lists or lists with a single element gracefully. 3. Your implementation should maintain the properties of Gnome Sort while trying to be more efficient on average. Example ```python >>> optimized_gnome_sort([34, 2, 10, -9]) [-9, 2, 10, 34] >>> optimized_gnome_sort([]) [] >>> optimized_gnome_sort([1]) [1] >>> optimized_gnome_sort([4, 3, 2, 1]) [1, 2, 3, 4] ```","solution":"def optimized_gnome_sort(arr): Function to sort a list using an optimized version of Gnome Sort. n = len(arr) if n <= 1: # Early exit for empty or single-element lists return arr index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] # Swap elements index -= 1 return arr"},{"question":"Write a function, `multiply_two_numbers(left: Node, right: Node) -> Node`, that takes two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Multiply the two numbers and return the result as a linked list. The function should handle potential carry between digits and ensure proper multiplication of numbers. # Input * `left`: `Node` - First linked list representing a non-negative integer. * `right`: `Node` - Second linked list representing a non-negative integer. # Output * `Node` - A linked list representing the product of the two numbers, stored in reverse order. # Example ```plaintext Input: (2 -> 4 -> 3) * (5 -> 6 -> 4) Output: 0 -> 8 -> 1 -> 9 -> 3 -> 2 Explanation: 342 * 465 = 159030 ``` # Constraints * The input linked lists contain only non-negative digits (0-9). * The input lists do not contain any leading zero, except the number 0 itself. * The lengths of both linked lists are in the range [1, 100]. # Performance Requirements * The solution should handle the worst-case scenario within reasonable limits of time and space complexity. # Scenario You are given two numbers represented as linked lists. You need to multiply these numbers. The objective is to simulate the multiplication process digit-by-digit, keeping proper account of the positional values and any carried-over product.","solution":"class Node: def __init__(self, x=0, next=None): self.val = x self.next = next def multiply_two_numbers(left: Node, right: Node) -> Node: def linked_list_to_number(node: Node) -> int: num, place = 0, 1 while node: num += node.val * place place *= 10 node = node.next return num def number_to_linked_list(num: int) -> Node: if num == 0: return Node(0) head = None current = None while num > 0: digit = num % 10 if head is None: head = Node(digit) current = head else: current.next = Node(digit) current = current.next num //= 10 return head num1 = linked_list_to_number(left) num2 = linked_list_to_number(right) product = num1 * num2 return number_to_linked_list(product)"},{"question":"# Context: You are working on a financial transaction system that needs to verify if a sequence of operations results in a single unique balance adjustment after considering all deposits and withdrawals. The system utilizes an existing algorithm designed to handle non-negative number streams to detect such scenarios. # Task: Implement a function `one_sparse` that takes a list of tuples, where each tuple contains a non-negative integer and a sign (\'+\' for deposit,\'-\' for withdrawal). The function should determine if the sequence results in exactly one unique non-negative integer after all operations are applied. # Function Signature: ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: ``` # Input: - `array`: A list of tuples `[(int, str)]`, where each tuple contains: - A non-negative integer. - A sign \'+\' or \'-\'. # Output: - Return the unique integer if the sequence is 1-sparse. - Return `None` if the sequence is not 1-sparse. # Constraints: - Each integer in the tuples is non-negative. - The array can be of length 0 to 10^6. # Performance Requirements: - The solution should operate within O(n) time complexity. - Space complexity should remain within O(1) (except the input array). # Examples: 1. ```python one_sparse([(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')]) # Output: 4 ``` 2. ```python one_sparse([(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')]) # Output: 2 ``` 3. ```python one_sparse([(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')]) # Output: None ``` # Notes: - Consider edge cases where all numbers might cancel each other out to 0. - Ensure to handle scenarios where the sum of signs does not result in a perfect division.","solution":"from typing import List, Tuple, Optional def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: balance = 0 unique_counts = {} for amount, sign in array: if sign == \'+\': balance += amount if amount not in unique_counts: unique_counts[amount] = 0 unique_counts[amount] += 1 elif sign == \'-\': balance -= amount if amount not in unique_counts: unique_counts[amount] = 0 unique_counts[amount] -= 1 # Find the unique non-zero count element unique_non_zero_count = None for amount, count in unique_counts.items(): if count != 0: if unique_non_zero_count is not None: return None unique_non_zero_count = amount return unique_non_zero_count"},{"question":"Context: You are tasked with processing a list of words. You need to identify parts of each word that match any symbol from a given list of symbols. Once found, replace that part of the word with the symbol surrounded by square brackets. If the word matches more than one symbol, select the one with the longest length. Task: Implement a function called `process_words_with_symbols` that takes in two lists: 1. `words` - a list of strings representing words. 2. `symbols` - a list of strings representing symbols. The function should return a new list of strings, where each word has the longest matching part replaced by the corresponding symbol surrounded by square brackets. If no match is found for a word, leave the word unchanged. Input: * A list `words` of n strings (1 <= n <= 10^5), where each string is of length at most 100. * A list `symbols` of m strings (1 <= m <= 1000), where each string is of length at most 10. Output: * A list of n strings, with the transformations applied as specified. Constraints: * You must perform the transformation in an efficient manner. * Symbols should be matched and applied in a case-sensitive manner. Example: ```python def process_words_with_symbols(words, symbols): # Your code here # Example Usage words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(process_words_with_symbols(words, symbols)) ``` Expected Output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Note: 1. The symbols should be used in their longest length order to replace the parts of words. 2. If a word matches multiple symbols of the same length, choose any one of them.","solution":"def process_words_with_symbols(words, symbols): Processes each word by replacing the longest matching part with the symbol surrounded by square brackets. :param words: List of words to process :param symbols: List of symbols :return: List of words with the transformations applied # Sort symbols by length in descending order symbols_sorted = sorted(symbols, key=len, reverse=True) def replace_longest_match(word): for symbol in symbols_sorted: if symbol in word: return word.replace(symbol, f\'[{symbol}]\', 1) return word return [replace_longest_match(word) for word in words]"},{"question":"# Scenario: You are tasked with developing a software module that processes large customer request logs. Each request is represented by an identifier in a list, and for performance reasons, you wish to maintain the order of processing while ensuring that no request is processed more than a specified number of times. # Task: Implement a function, `process_requests`, that takes a list of integers representing request IDs and an integer N. The function should return a new list where each request ID appears at most N times, maintaining the original order of first encounters. # Function Signature: ```python def process_requests(request_ids: list, n: int) -> list: ``` # Input: - `request_ids`: a list of integers where each integer represents a request ID. - `n`: an integer representing the maximum number of times a request ID can appear in the output list. # Output: - A list of integers containing the request IDs with each ID appearing no more than N times. # Constraints: - 0 <= len(request_ids) <= 10^6 - 1 <= n <= 10^6 # Examples: ```python assert process_requests([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert process_requests([1,1,1,1], 2) == [1, 1] assert process_requests([], 3) == [] assert process_requests([4, 5, 6], 0) == [] ``` # Notes: - Aim for an efficient implementation with a time complexity of O(n). - Consider edge cases where the request list is empty or contains elements appearing in succession.","solution":"def process_requests(request_ids: list, n: int) -> list: Returns a list where each request ID appears at most n times, maintaining the original order. # Dictionary to keep track of the count of each request ID request_counts = {} result = [] for request_id in request_ids: if request_id not in request_counts: request_counts[request_id] = 0 if request_counts[request_id] < n: result.append(request_id) request_counts[request_id] += 1 return result"},{"question":"**Question**: You are given a string `s`. Your task is to implement a function `is_palindrome_advanced(s: str) -> bool` that will determine if the string `s` is a palindrome considering only alphanumeric characters and ignoring cases. Empty strings are considered valid palindromes. **Input**: - A single string `s` where `0 <= len(s) <= 2 * 10^5`. **Output**: - Return `True` if `s` is a palindrome, otherwise return `False`. **Function Signature**: ```python def is_palindrome_advanced(s: str) -> bool: pass ``` # Expected Functionality: Your function should: 1. Convert the string to lowercase. 2. Ignore non-alphanumeric characters. 3. Implement one of the provided variations to check for palindrome (Two-pointer technique is highly recommended). # Constraints: - The input string can contain printable ASCII characters. - The check should be done in O(n) time complexity where n is the length of the string. - The space complexity should be minimized, O(1) auxiliary space is ideal if using the two-pointer technique. # Example: ```python assert is_palindrome_advanced(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_advanced(\\"race a car\\") == False assert is_palindrome_advanced(\\"\\") == True assert is_palindrome_advanced(\\" \\") == True ``` # Explanation: 1. **Example 1**: After removing non-alphanumeric characters and converting to lowercase, the string becomes \\"amanaplanacanalpanama\\" which is a palindrome. 2. **Example 2**: After processing, the string becomes \\"raceacar\\" which is not a palindrome. 3. **Example 3 & 4**: Empty string and string with only spaces are considered valid palindromes. Implement the function: ```python def is_palindrome_advanced(s: str) -> bool: i, j = 0, len(s) - 1 while i < j: while i < j and not s[i].isalnum(): i += 1 while i < j and not s[j].isalnum(): j -= 1 if s[i].lower() != s[j].lower(): return False i += 1 j -= 1 return True ```","solution":"def is_palindrome_advanced(s: str) -> bool: Determines if the string `s` is a palindrome considering only alphanumeric characters and ignoring cases. i, j = 0, len(s) - 1 while i < j: # Move the left pointer to the right until an alphanumeric character is found while i < j and not s[i].isalnum(): i += 1 # Move the right pointer to the left until an alphanumeric character is found while i < j and not s[j].isalnum(): j -= 1 # Compare the characters, if they are not the same then it\'s not a palindrome if s[i].lower() != s[j].lower(): return False # Move pointers for the next comparison i += 1 j -= 1 return True"},{"question":"You are tasked with extending the functionality of the `WordDictionary` to support deleting words from the dictionary. Implement a new method `delete_word` which removes a word from the trie. The trie should correctly handle the edge cases where: 1. The word to be deleted doesn’t exist. 2. Partial deletions should not affect other existing words that share common prefixes with the word to be deleted. 3. After deletion, if any node becomes useless (i.e., it doesn’t lead to any word), it should be removed to optimize space usage. Function Signatures ```python def add_word(self, word: str) -> None: Adds a word into the data structure. def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. def delete_word(self, word: str) -> None: Removes a word from the data structure. ``` # Constraints * The trie only contains lowercase alphabets a-z. * Words are non-empty and have a length of at most 100. # Example ```python # Initialization of the WordDictionary word_dict = WordDictionary() # Adding words word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") # Searching words assert word_dict.search(\\"pad\\") == False assert word_dict.search(\\"bad\\") == True assert word_dict.search(\\".ad\\") == True assert word_dict.search(\\"b..\\") == True # Deleting a word word_dict.delete_word(\\"bad\\") assert word_dict.search(\\"bad\\") == False assert word_dict.search(\\".ad\\") == True # still True because \\"dad\\" is present ``` Write your solution implementing the `delete_word` method. Ensure that your solution efficiently handles all edge cases and optimizes space usage in the trie.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def _search_recursive(self, node, word, index): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(child, word, index + 1): return True else: if char in node.children: if self._search_recursive(node.children[char], word, index + 1): return True return False def search(self, word: str) -> bool: return self._search_recursive(self.root, word, 0) def delete_word(self, word: str) -> None: def _delete(current, word, index): if index == len(word): if not current.is_end_of_word: return False current.is_end_of_word = False return len(current.children) == 0 char = word[index] if char not in current.children: return False should_delete_child = _delete(current.children[char], word, index + 1) if should_delete_child: del current.children[char] return len(current.children) == 0 return False _delete(self.root, word, 0)"},{"question":"# Question Given a list of integers and two optional limits (`min_lim` and `max_lim`), write a function that filters and returns the list of integers that lie within the given limits. If `min_lim` or `max_lim` is not specified, those bounds are considered \\"unlimited\\". Ensure that the function handles edge cases such as empty arrays and `None` values for the limits appropriately. # Input 1. `arr` (List[int]): A list of integers, e.g., [1, 2, 3, 4, 5]. 2. `min_lim` (Optional[int]): Optional minimum limit. If not provided, consider it as no lower bound. 3. `max_lim` (Optional[int]): Optional maximum limit. If not provided, consider it as no upper bound. # Output * The function should return a list (List[int]) of integers that are greater than or equal to `min_lim` and less than or equal to `max_lim`. # Constraints * Time complexity should be O(n), where n is the length of the input list. * Space complexity should be O(n) due to the need to store the resulting list. * Array elements can be positive or negative numbers, and `None` can be provided for `min_lim` or `max_lim`. # Function Signature ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` # Examples 1. Input: `arr = [1, 2, 3, 4, 5]`, `min_lim = None`, `max_lim = 3` Output: `[1, 2, 3]` 2. Input: `arr = [10, 20, 30, 40, 50]`, `min_lim = 15`, `max_lim = None` Output: `[20, 30, 40, 50]` 3. Input: `arr = [5, -10, 15, -20, 25, 0]`, `min_lim = -10`, `max_lim = 10` Output: `[5, -10, 0]` 4. Input: `arr = []`, `min_lim = 1`, `max_lim = 3` Output: `[]`","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: result = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): result.append(num) return result"},{"question":"<|Analysis Begin|> # Algorithm Analysis **Algorithm/Data Structure**: - **Name**: Merge k Sorted Lists - **Type**: Merging Algorithm using Min Heap (or Priority Queue) - **Main Purpose**: To merge multiple sorted linked lists into one sorted linked list. **Complexity**: - **Time Complexity**: O(N log k) - **N**: Total number of elements across all linked lists. - **k**: Number of linked lists. - **Space Complexity**: O(k) - Space required to store elements in the heap (or priority queue). **Principles**: - Utilizes a min-heap (or priority queue) to efficiently select the smallest element from the front of each of the k lists. - Repeatedly extracts the minimum element, adding it to the resulting merged list and pushing the next element from the list the minimum came from into the heap. # Characteristics & Applications **Properties**: - Ensures the merged list is sorted due to the property of the min-heap, which always gives the smallest element. - Effectively handles merge operations where the input lists are sorted. **Common Use Cases**: - Common in external sorting and streaming large data. - Useful in parallel processing when combining results from multiple sources. **Strengths/Limitations**: **Strengths**: - Handles merging multiple lists efficiently. - Optimal in terms of time complexity when compared to a naive merging approach. **Limitations**: - Additional space required for the heap or priority queue. **Implementation Challenges**: **Edge Cases**: - Input lists can be empty. - Varying lengths of input lists. - Lists with duplicate values. **Performance Bottlenecks**: - If the number of lists (k) is large, the heap operations might still constitute a significant overhead. **Error Scenarios**: - Improper handling of edge cases or null values might lead to runtime errors. - Care must be taken to ensure all input lists are handled correctly. **Optimization Points**: - Effective heap management can further optimize the performance slightly, but the primary complexity bounds remain determined by the fundamental nature of the algorithm. <|Analysis End|> <|Question Begin|> # Merging k Sorted Linked Lists You are given an array of k linked lists, where each linked list is sorted in ascending order. Your task is to write a function `merge_k_lists` that merges all the linked lists into one sorted linked list and returns its head. Function Signature ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ``` Input - `lists` (List[Optional[ListNode]]): An array of k linked lists. Output - Returns the head of the merged sorted linked list. Constraints - The total number of elements across all linked lists will be in the range `[0, 10^4]`. - The value of k will be in the range `[0, 100]`, where k is the number of linked lists. Example ```python # Example 1 Input: lists = [ ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6)) ] Output: [1,1,2,3,4,4,5,6] # Example 2 Input: lists = [] Output: [] # Example 3 Input: lists = [ListNode(1)] Output: [1] ``` Guidelines - Consider edge cases such as an empty array of lists or lists containing null nodes. - Ensure your solution performs efficiently for the given constraints.","solution":"import heapq from typing import List, Optional, Tuple class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap: List[Tuple[int, int, ListNode]] = [] # Initialize the heap with the head of each list for index, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, index, node)) dummy = ListNode() current = dummy while min_heap: val, index, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next node = node.next if node: heapq.heappush(min_heap, (node.val, index, node)) return dummy.next"},{"question":"# Maximum Flow with Residual Graph and BFS **Scenario**: You are tasked with optimizing a city\'s water distribution network. The city\'s water network can be represented as a flow network with nodes representing junctions and directed edges representing pipes with specific capacities. You need to determine the maximum amount of water that can flow from the main reservoir (source) to the city tank (sink) using a more efficient algorithm. **Task**: Implement a function `maximum_flow_bfs(adjacency_matrix)` that calculates the maximum flow using the **Edmonds-Karp algorithm**, which uses Breadth-First Search (BFS) for finding augmenting paths. **Function Signature**: ```python def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: ``` **Input**: * `adjacency_matrix`: A 2D list of integers `n*n` representing the capacities of the pipes between junctions in the flow network. `adjacency_matrix[i][j]` is the capacity of the pipe from junction i to junction j. Assume that the first junction (index 0) is the source and the last junction (index n-1) is the sink. **Output**: * An integer representing the maximum amount of water flow from the source to the sink. **Constraints**: * The number of junctions `n` will be between `2` and `100`. * The capacity of the pipes will be between `0` and `10^3`. **Requirements**: * Your solution should efficiently handle up to `100` junctions. * Ensure the solution uses BFS for finding augmenting paths and accurately manages the residual graph. **Example**: ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] assert maximum_flow_bfs(graph) == 23 ``` **Hint**: 1. Use BFS to find the shortest augmenting path and update the residual capacities along this path. 2. Continue to search for augmenting paths until no more can be found.","solution":"from typing import List from collections import deque def bfs_capacity_path(graph: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: visited = [False] * len(graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: source = 0 sink = len(adjacency_matrix) - 1 parent = [-1] * len(adjacency_matrix) max_flow = 0 while bfs_capacity_path(adjacency_matrix, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, adjacency_matrix[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] adjacency_matrix[u][v] -= path_flow adjacency_matrix[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are given an encoded string, and you need to decode it and return its decoded string. The encoding rule is: k[encoded_string], where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer. # Input: * The input string `s` is a valid encoded string containing only digits, letters, and square brackets. * There are no extraneous spaces, and the square brackets are well-formed. # Output: * Return the decoded string. # Constraints: * The input string does not contain any digits other than those that denote the repeat counts. * The function should be efficient in both time and space. # Examples: 1. **Example 1**: * Input: `s = \\"3[a]2[bc]\\"` * Output: `\\"aaabcbc\\"` 2. **Example 2**: * Input: `s = \\"3[a2[c]]\\"` * Output: `\\"accaccacc\\"` 3. **Example 3**: * Input: `s = \\"2[abc]3[cd]ef\\"` * Output: `\\"abcabccdcdcdef\\"` 4. **Example 4**: * Input: `s = \\"10[a]\\"` * Output: `\\"aaaaaaaaaa\\"` # Function Signature: ```python def decode_string(s: str) -> str: pass ``` # Test Your Solution: Include several test cases to validate your solution, especially focusing on: * Nested encoding. * Large repeat counts. * Edge cases with minimal input or no encodings.","solution":"def decode_string(s: str) -> str: Decodes an encoded string where the encoding rule is specified as k[encoded_string], and returns the decoded string. stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_num = 0 current_str = \'\' elif char == \']\': last_str, num = stack.pop() current_str = last_str + num * current_str else: current_str += char return current_str"},{"question":"# Run-Length Encoding Compression and Decompression You are given a simple data compression algorithm called Run-Length Encoding (RLE). Your task is to demonstrate your understanding of this algorithm by overriding the existing function `encode_rle` to enhance its functionality and writing a new function `compress_rle`. # Function Descriptions encode_rle(input: str) -> str This function compresses the input string using RLE. **Parameters:** - `input` (str): The string to be encoded. **Returns:** - `str`: The encoded string in RLE format. decode_rle(input: str) -> str This function decompresses an RLE encoded string back to its original form. **Parameters:** - `input` (str): The encoded string. **Returns:** - `str`: The decoded (original) string. compress_rle(input: str) -> str New function that compresses the input string by first applying RLE encoding and then replacing repeated counts with optimized shorter forms (if applicable). **Parameters:** - `input` (str): The string to be encoded. **Returns:** - `str`: The compressed string, optimized beyond basic RLE encoding. # Constraints - All characters in the input string are alphanumeric (a-z, A-Z, 0-9). - Maximum length of the input string: 10^6. # Requirements 1. Modify the `encode_rle` function to improve performance on strings with few repeating characters. 2. Implement the `compress_rle` function to perform additional optimizations beyond the basic RLE. # Example ```python assert encode_rle(\\"aaabb\\") == \\"3a2b\\" assert decode_rle(\\"3a2b\\") == \\"aaabb\\" assert compress_rle(\\"aaabb\\") == \\"3a2b\\" assert encode_rle(\\"abcdef\\") == \\"1a1b1c1d1e1f\\" assert decode_rle(\\"1a1b1c1d1e1f\\") == \\"abcdef\\" assert compress_rle(\\"abcdef\\") == \\"abcdef\\" # Example: Improved compression on strings without repeats ``` Please ensure your implementations are efficient given the constraints.","solution":"def encode_rle(input: str) -> str: Compresses the input string using Run-Length Encoding (RLE). if not input: return \'\' encoded_str = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_str.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded_str.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: Decompresses an RLE encoded string back to its original form. if not input: return \'\' decompressed_str = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decompressed_str.append(char * int(count)) count = \\"\\" return \'\'.join(decompressed_str) def compress_rle(input: str) -> str: Compresses the input string by first applying RLE encoding and then replacing repeated counts with optimized shorter forms if applicable. encoded_str = encode_rle(input) # Optimization check: If all encoded blocks have \\"1\\" counts, keep original string. if all(encoded_str[i].isdigit() and encoded_str[i] == \'1\' for i in range(0, len(encoded_str), 2)): return input return encoded_str"},{"question":"Implement the `OrderedStack` data structure that maintains a stack of integers in descending order, with the highest value always on top. The stack should allow pushing and popping elements efficiently while preserving order. # Requirements 1. **Class Methods**: - `__init__(self)`: Initializes an empty stack. - `is_empty(self)`: Returns `True` if the stack is empty, else `False`. - `push(self, item)`: Pushes an item maintaining the stack order. - `pop(self)`: Removes and returns the top item; raises `IndexError` if the stack is empty. - `peek(self)`: Returns the top item without removing it. - `size(self)`: Returns the number of items in the stack. # Input and Output Format - **Input**: Sequence of method calls to be performed on an instance of `OrderedStack`. - **Output**: Appropriate output for each method call, as described below: - For `push(item)`: return `None`. - For `pop()`: return the popped item. - For `peek()`: return the top item. - For `is_empty()`: return True/False. - For `size()`: return the size of the stack. # Constraints - All integers used in the inputs are within the range of [-10^5, 10^5]. - The maximum size of the stack is 10^5 operations. # Example ```python # Example usage of OrderedStack stack = OrderedStack() stack.push(5) stack.push(2) stack.push(8) print(stack.pop()) # Expected output: 8 print(stack.peek()) # Expected output: 5 print(stack.size()) # Expected output: 2 print(stack.is_empty()) # Expected output: False ``` Implement the `OrderedStack` class as per the requirements given.","solution":"class OrderedStack: def __init__(self): Initializes an empty ordered stack. self.stack = [] def is_empty(self): Returns True if the stack is empty, else False. return len(self.stack) == 0 def push(self, item): Pushes an item onto the stack maintaining descending order. index = 0 # Find the appropriate position according to the descending order while index < len(self.stack) and self.stack[index] > item: index += 1 self.stack.insert(index, item) def pop(self): Removes and returns the top item; raises IndexError if the stack is empty. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop(0) def peek(self): Returns the top item without removing it. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[0] def size(self): Returns the number of items in the stack. return len(self.stack)"},{"question":"# Question Context: You are given a list of unique numbers representing the order of participants in a marathon. The list needs to be sorted in ascending order based on their finish times. Since this is a theoretical study on sorting algorithms, you are required to implement the Stooge Sort algorithm to perform the sorting. Task: Implement a function `stooge_sort(arr: list, l: int, h: int) -> None:` that sorts the elements of `arr` between indices `l` and `h` (both inclusive) using Stooge Sort. Function Signature: ```python def stooge_sort(arr: list, l: int, h: int) -> None: ``` Input: - `arr`: A list of integers (0 ≤ len(arr) ≤ 1000) where each integer is unique and represents the finish times of participants. - `l`: The starting index of the sublist to be sorted. - `h`: The ending index of the sublist to be sorted. Output: - The function should modify the input list `arr` in place, sorting the elements in ascending order from index `l` to index `h`. Example: ```python if __name__ == \\"__main__\\": arr = [34, 23, 5, 12, 4, 76] n = len(arr) stooge_sort(arr, 0, n-1) print(arr) # Output: [4, 5, 12, 23, 34, 76] ``` Constraints: - You are not allowed to use built-in sorting functions or external libraries. - Ensure to handle edge cases such as an empty list or a list with one element.","solution":"def stooge_sort(arr: list, l: int, h: int) -> None: Sorts the elements of arr between indices l and h (both inclusive) using Stooge Sort. if l >= h: return # Swap if the element at l is greater than the element at h if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array part we are considering if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t)"},{"question":"You are given a list of integers that need to be sorted in non-decreasing order. Your task is to implement the insertion sort algorithm from scratch. Your implementation must handle typical edge cases and ensure that the sorting is stable. You should also provide an option to simulate the sorting process showing the list\'s state at each step. **Function Signature**: ```python def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` **Input**: * `arr` (List[int]): A list of integers that need to be sorted. * `simulation` (bool): A boolean flag to indicate whether intermediate steps should be printed (default is False). **Output**: * A sorted list of integers in non-decreasing order. **Constraints**: * The length of `arr` (denoted as n) is 0 ≤ n ≤ 10^3. * Each integer in `arr` will be in the range -10^6 to 10^6. **Performance Requirements**: * The algorithm should handle the upper limit of the input size efficiently enough for practical purposes. **Example**: ```python # Input arr = [5, 3, 4, 1, 2] simulation = True # Function Call sorted_arr = insertion_sort(arr, simulation) # Expected Output iteration 0 : 5 3 4 1 2 iteration 1 : 3 5 4 1 2 iteration 2 : 3 4 5 1 2 iteration 3 : 1 3 4 5 2 iteration 4 : 1 2 3 4 5 ``` **Note**: Ensure your implementation correctly handles edge cases like an empty array or an array with only one element. Document any assumptions and ensure that your solution\'s intermediate outputs match the expected format when `simulation` is enabled.","solution":"from typing import List def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: if simulation: print(f\\"iteration 0 : {\' \'.join(map(str, arr))}\\") for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"You are given a sorted array of numbers and a specific value to search for within this array. Implement the function `ternary_search` to find the position of this value in the array using the ternary search algorithm. Function Signature ```python def ternary_search(arr: List[int], key: int) -> int: ``` Input * `arr` (List[int]): A list of `n` integers, sorted in ascending order where `1 <= n <= 10^6`, `-10^9 <= arr[i] <= 10^9`. * `key` (int): The integer value to be searched within the array, `-10^9 <= key <= 10^9`. Output * Returns the index (0-based) of `key` in the array `arr` if the key is found. Otherwise, returns `-1`. Example ```python arr = [-10, 0, 3, 5, 9, 12] key = 9 ternary_search(arr, key) # Output: 4 arr = [2, 3, 5, 9, 14, 21] key = 6 ternary_search(arr, key) # Output: -1 ``` Constraints * The algorithm must run efficiently in ( O(log_3{N}) ) time complexity. * You should handle the edge cases of small arrays appropriately. Implementation Requirements * The ternary search algorithm should be implemented as described in the provided snippet with correct edge case handling. * Do not use Python’s built-in search functions (`list.index()`).","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: def search(left: int, right: int) -> int: if left > right: return -1 # Divide the range into three parts third = (right - left) // 3 mid1 = left + third mid2 = right - third # Check if the key is at any midpoints if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 # Determine which segment to continue searching if key < arr[mid1]: return search(left, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, right) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"Implement an optimized version of the binomial coefficient calculation that overcomes the limitations of the recursive approach by using dynamic programming. The function should be able to handle large values of ( n ) and ( k ) efficiently without running into recursion depth issues. # Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` # Input - `n` (integer): A non-negative integer representing the total number of elements in the set (0 ≤ n ≤ 1000) - `k` (integer): A non-negative integer representing the number of chosen elements (0 ≤ k ≤ n) # Output - Returns an integer representing the binomial coefficient ( C(n, k) ) # Constraints - The function should be optimized to handle large inputs up to ( n = 1000 ) efficiently. - Use dynamic programming or an iterative approach to avoid recursion depth limitations. # Example ```python # Examples: print(binomial_coefficient(5, 0)) # Output: 1 print(binomial_coefficient(8, 2)) # Output: 28 print(binomial_coefficient(500, 300)) # Output: a large integer value ``` # Notes - You may use loops and additional storage (e.g., arrays) to keep track of intermediate results. - Your solution should handle edge cases such as ( k = 0 ), ( k = n ), and ( k > n ) appropriately.","solution":"def binomial_coefficient(n: int, k: int) -> int: if k > n: return 0 if k == 0 or k == n: return 1 k = min(k, n - k) # Take advantage of the symmetry C = [0] * (k + 1) C[0] = 1 for i in range(1, n + 1): for j in range(min(i, k), 0, -1): C[j] = C[j] + C[j - 1] return C[k]"},{"question":"Context In computer science, tree traversal algorithms are fundamental for accessing and manipulating tree data structures. One common traversal method is the inorder traversal, which visits the nodes of a tree in a specific order: left subtree, root node, and then right subtree. Task You are given a binary tree and you need to implement two different methods to perform inorder traversal. The first method should use an iterative approach, while the second method should use recursion. Requirements 1. Implement an iterative inorder traversal method in the function `inorder_iterative(root: Node) -> List[int]`. 2. Implement a recursive inorder traversal method in the function `inorder_recursive(root: Node) -> List[int]`. The `Node` class is defined as follows: ```python class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right ``` Input Both methods receive: * `root`: the root node of a binary tree. Output Each method should return a list of integers representing the inorder traversal of the tree. Constraints * Node values are unique integers. * There can be up to 10^4 nodes in the tree. * Assume the input tree is valid. Example Given the binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` * Calling `inorder_iterative(root)` and `inorder_recursive(root)` should both return `[25, 50, 75, 100, 125, 150, 175]`. Edge Cases to Consider * An empty tree (where `root` is None). * A tree with only one node. * A skewed tree (all nodes are either on the left or right subtree).","solution":"class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list: result, stack = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> list: def dfs(node): if node: dfs(node.left) result.append(node.val) dfs(node.right) result = [] dfs(root) return result"},{"question":"You are asked to implement a function `bucket_sort_optimized(arr)`, which sorts an array of floating-point numbers in the range [0, 1). The function should use an optimized approach for sorting within each bucket to ensure a more efficient performance. **Input**: * An array `arr` of n floating-point numbers where each element is within the range [0, 1). **Output**: * A sorted array of the same elements. **Constraints**: * 1 ≤ n ≤ 10^6 * Each element in the array is a floating-point number in the range [0, 1). **Performance Requirement**: * Your solution should be highly optimized for average-case performance. Aim for O(n log n) or better. # Implementation Details - Implement the bucket sort algorithm. - Use a more efficient sorting algorithm (e.g., merge sort or quicksort) within each bucket. - Ensure your code can handle edge cases, such as all elements being the same or elements being clustered. # Example ```python def bucket_sort_optimized(arr): # Your implementation here pass # Example arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] print(bucket_sort_optimized(arr)) # Expected: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` Design and implement the `bucket_sort_optimized(arr)` function to meet the above specifications.","solution":"def bucket_sort_optimized(arr): Sorts an array of floating-point numbers in the range [0, 1) using an optimized bucket sort. if not arr: return arr n = len(arr) buckets = [[] for _ in range(n)] # Divide elements into buckets for x in arr: index = int(n * x) buckets[index].append(x) # Utilize the sorted built-in function (which uses Timsort) for sorting individual buckets sorted_arr = [] for bucket in buckets: sorted_bucket = sorted(bucket) sorted_arr.extend(sorted_bucket) return sorted_arr"},{"question":"Coding Assessment Question # Problem Statement You are given a set of distinct integers represented as a list `nums`. Your task is to write a function that generates all possible subsets of the given set. # Function Signature ```python def generate_subsets(nums: List[int]) -> Set[tuple]: ``` # Input * `nums`: A list of distinct integers. * Constraints: `1 <= len(nums) <= 15`, `-100 <= nums[i] <= 100` # Output * Return a set of tuples, where each tuple represents a subset of the input set `nums`. # Examples ```python assert generate_subsets([1, 2, 3]) == {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} assert generate_subsets([0]) == {(), (0,)} assert generate_subsets([]) == {()} assert generate_subsets([-1, 2]) == {(), (-1,), (2,), (-1, 2)} ``` # Explanation * For `[1, 2, 3]`, the output contains all possible subsets. * For `[0]`, the output should have an empty subset and a subset containing 0. * For an empty list, the function must return a set containing an empty tuple. * The function should handle negative and positive integers as well. # Constraints * The input list will have up to 15 elements to ensure the solution can generate subsets efficiently without hitting performance bottlenecks. * The solution must ensure all subsets are unique, and no duplicated subsets appear in the output set. **Note**: Pay careful attention to edge cases like when the input is an empty list. # Hints 1. Consider using bit manipulation to handle the generation of subsets efficiently. 2. Each element\'s inclusion or exclusion in a subset can be represented by a bit in a binary number. Use this property to iterate through all possible subsets.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int, ...]]: Generates all possible subsets of the given list of distinct integers. Args: nums (List[int]): A list of distinct integers. Returns: Set[Tuple[int, ...]]: A set of tuples, each representing a subset of nums. from itertools import chain, combinations # Function to generate all subsets using combinations subsets = set(chain.from_iterable(combinations(nums, r) for r in range(len(nums)+1))) return subsets"},{"question":"# Matrix Chain Multiplication Problem You are designing an efficient system for computing powers of matrices. Given a square matrix, you need to implement a function to compute the power of this matrix using the technique of matrix exponentiation by repeated squaring. Function Signature ```python def matrix_power(matrix: List[List[int]], exponent: int) -> List[List[int]]: ``` Input - `matrix` (List of List of int): a square matrix (n x n) where each element is a non-negative integer. - `exponent` (int): a non-negative integer, representing the power to which the matrix should be raised. Output - The (matrix) raised to the power of (exponent) (an n x n square matrix). Constraints - The size of the matrix (n) will be between 1 and 100. - Each element of the matrix will be between (0) and (10^9). - The value of (exponent) will be between 0 and (10^9). Example ```python matrix = [ [1, 2], [3, 4] ] exponent = 2 Output: [ [7, 10], [15, 22] ] ``` Explanation - Input matrix: (begin{pmatrix} 1 & 2 3 & 4 end{pmatrix}) - When raised to power 2, the result should be: (begin{pmatrix} 7 & 10 15 & 22 end{pmatrix}) Implement the function `matrix_power` which efficiently computes the power of a matrix using the concepts and principles of matrix exponentiation by repeated squaring.","solution":"from typing import List def matrix_multiply(a: List[List[int]], b: List[List[int]]) -> List[List[int]]: Multiplies two square matrices a and b. n = len(a) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += a[i][k] * b[k][j] return result def matrix_power(matrix: List[List[int]], exponent: int) -> List[List[int]]: Computes the power of a matrix using exponentiation by squaring. n = len(matrix) result = [[1 if i == j else 0 for j in range(n)] for i in range(n)] base = matrix while exponent > 0: if exponent % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) exponent //= 2 return result"},{"question":"# Unique Binary Search Trees Problem Statement Given an integer `n`, write a function to compute the number of structurally unique Binary Search Trees (BSTs) that store values from `1` to `n`. Binary Search Tree (BST) is a binary tree in which for each node, all the elements in the left subtree are less than the node, and all the elements in the right subtree are greater than the node. Function Signature ```python def num_trees(n: int) -> int: ``` Input * An integer `n` (0 ≤ n ≤ 20). Output * An integer representing the number of structurally unique BSTs. Constraints * Consider the base cases where `n` is `0` or `1`, the function should return `1`. * The solution should have a time complexity of O(n^2). Example ```python assert num_trees(3) == 5 ``` For `n = 3`, there are a total of `5` unique BSTs: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` Description * The solution should use dynamic programming to efficiently calculate the number of unique BSTs. * Initialize a dp array of size `n+1` with zeros and set `dp[0] = 1` and `dp[1] = 1`. * Use nested loops to fill the dp array by considering each integer from `1` to `n` as the root, and compute the number of BSTs based on the previously computed subproblems. * Return the last element of the dp array which represents the solution for `n`. You are expected to implement the function `num_trees` that meets the above requirements.","solution":"def num_trees(n: int) -> int: Calculate the number of structurally unique BSTs that store values from 1 to n. if n == 0 or n == 1: return 1 # Initialize a list to store the number of unique BSTs for each number of nodes dp = [0] * (n + 1) # Base cases dp[0] = 1 dp[1] = 1 # Fill the dp array using dynamic programming for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"Scenario As a web developer, you\'re tasked with building a web application that frequently needs to concatenate different parts of URLs. Writing out the logic for joining URLs every time can lead to errors with too many or too few slashes, making the URLs invalid. To streamline this, you decide to create a utility function to handle this automatically. Problem Statement Write a function `join_url_paths` that can join two URL parts into a single well-formatted URL. It should ensure there is exactly one slash between the URLs and handle leading and trailing slashes appropriately. Function Signature ```python def join_url_paths(base: str, suffix: str) -> str: pass ``` Input - `base`: a string representing the base URL (can be empty). - `suffix`: a string representing the relative URL part to be appended to the base (can be empty). Output - Returns a single string representing the concatenated URL. Constraints - URL parts can be empty strings. - URLs will only contain valid URL characters (letters, digits, and the characters `/-._~:?#[]@!&\'()*+,;=`). - Ensure the URL is standardized with exactly one slash between parts. Example ```python assert join_url_paths(\\"http://algorithms.com\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_url_paths(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_url_paths(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert join_url_paths(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert join_url_paths(\\"\\", \\"file\\") == \\"file\\" assert join_url_paths(\\"path/to/dir\\", \\"\\") == \\"path/to/dir\\" ``` Additional Information Ensure that your solution handles edge cases such as empty strings, leading, and trailing slashes effectively.","solution":"def join_url_paths(base: str, suffix: str) -> str: Joins two parts of a URL into a single well-formatted URL. if base.endswith(\'/\'): base = base.rstrip(\'/\') if suffix.startswith(\'/\'): suffix = suffix.lstrip(\'/\') if base == \'\': return suffix if suffix == \'\': return base return f\\"{base}/{suffix}\\""},{"question":"As a part of a system that processes hierarchical data, you need to implement a function that converts a binary tree into a doubly linked list in-place. Each node should be linked in an in-order sequence (i.e., left-to-right). # Function Signature: ```python def bin_tree_to_list(root: TreeNode) -> TreeNode: pass ``` # Input: - `root`: The root node of a binary search tree. Each node contains an integer value (`val`), a left child, and a right child. # Output: - Return the head of the resulting doubly linked list. # Constraints: - The tree will not have duplicate values. - The number of nodes in the tree will not exceed 10^4. - The values of the nodes are in the range `[-10^5, 10^5]`. # Performance Requirements: - The solution should have a time complexity of O(n). - The solution should not use extra space proportional to the number of nodes (no auxiliary data structures). # Example: ```python # Input # 4 # / # 2 5 # / # 1 3 node = TreeNode(4) node.left = TreeNode(2) node.left.left = TreeNode(1) node.left.right = TreeNode(3) node.right = TreeNode(5) # Output: Output should be a doubly linked list in-order: 1 <-> 2 <-> 3 <-> 4 <-> 5 head = bin_tree_to_list(node) ``` # Implementation: Write code to perform the transformation in an efficient manner, ensuring the solution adheres to the specified constraints and performance requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None # Helper function to convert the binary tree to doubly linked list in place. def inorder_traversal(node): nonlocal last, head if not node: return inorder_traversal(node.left) if last: # Link the previous node (last) with the current one (node) last.right = node node.left = last else: # If last is None, then we are at the head head = node last = node inorder_traversal(node.right) last, head = None, None inorder_traversal(root) return head"},{"question":"# Insert Position in Sorted Array You are given a sorted array and a target value. Write a function `insert_position` that returns the index where the target should be inserted to maintain the sorted order. If the target already exists in the array, return the index of the target. Function Signature ```python def insert_position(array: List[int], target: int) -> int: Determines the index where the target should be inserted in the sorted array. Parameters: array (List[int]): A list of integers in non-decreasing order. target (int): The integer to be inserted. Returns: int: The index at which the target should be inserted. ``` Input * `array`: A list of integers in sorted order (0 <= len(array) <= 10^5). * `target`: An integer to be inserted (no constraint on the value of target). Output * Return an integer representing the index at which the target should be inserted. Constraints * The array is guaranteed to be sorted in non-decreasing order. * Efficient implementation with time complexity (O(log n)) is expected. Example ```python assert insert_position([1, 3, 5, 6], 5) == 2 assert insert_position([1, 3, 5, 6], 2) == 1 assert insert_position([1, 3, 5, 6], 7) == 4 assert insert_position([1, 3, 5, 6], 0) == 0 assert insert_position([], 1) == 0 ``` Provide a solution that efficiently finds the insert position while ensuring correctness and addressing any potential edge cases.","solution":"from typing import List def insert_position(array: List[int], target: int) -> int: Determines the index where the target should be inserted in the sorted array. Parameters: array (List[int]): A list of integers in non-decreasing order. target (int): The integer to be inserted. Returns: int: The index at which the target should be inserted. low, high = 0, len(array) while low < high: mid = (low + high) // 2 if array[mid] < target: low = mid + 1 else: high = mid return low"},{"question":"Given two strings, `string1` and `string2`, your task is to write a Python function to compute the minimum number of steps required to make the two strings identical. A step is defined as deleting one character from either of the two strings. You must use dynamic programming to solve this problem. # Constraints: * The lengths of the strings will be at most 1000. * Strings will only contain lower-case English characters. # Input: * `string1`: A string. * `string2`: A string. # Output: * An integer representing the minimum number of deletion steps required for the two strings to become identical. # Function Signature: ```python def min_deletion_steps(string1: str, string2: str) -> int: pass ``` # Examples: 1. **Input**: `string1 = \\"sea\\"`, `string2 = \\"eat\\"` **Output**: `2` **Explanation**: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". 2. **Input**: `string1 = \\"abc\\"`, `string2 = \\"abc\\"` **Output**: `0` **Explanation**: Both strings are already the same. 3. **Input**: `string1 = \\"a\\"`, `string2 = \\"b\\"` **Output**: `2` **Explanation**: Both strings need to be emptied, requiring exactly 2 deletions. In your function implementation, ensure to: 1. Create a DP table to store lengths of LCS. 2. Initialize the table properly considering the constraints. 3. Fill the DP table according to the rules of forming and expanding the LCS. 4. Finally, calculate the minimum removal steps using the formula: `len(string1) + len(string2) - 2 * length of LCS`.","solution":"def min_deletion_steps(string1: str, string2: str) -> int: Computes the minimum number of deletion steps required to make the two strings identical. m, n = len(string1), len(string2) # Create DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill DP table for i in range(1, m + 1): for j in range(1, n + 1): if string1[i - 1] == string2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] # Minimum deletions to make the two strings identical return (m - lcs_length) + (n - lcs_length)"},{"question":"Problem: Implement and Optimize a Stooge Sort Stooge Sort is an interesting but inefficient sorting algorithm. Given its educational value, you are tasked with implementing this algorithm and then also implementing an optimized version of Merge Sort to compare performance. # Steps: 1. Implement the `stooge_sort` function. 2. Implement the `merge_sort` function. 3. Write a function `compare_sorting_algorithms` which: - Accepts an array of integers. - Sorts a copy of the array using Stooge Sort. - Sorts another copy using Merge Sort. - Measures and prints the time taken for both sorting algorithms. # Input: A list of integers `arr` of length `n`. # Output: A tuple with two elements: 1. The sorted list using Stooge Sort. 2. The sorted list using Merge Sort. # Example: ```python Input: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] Output: ([1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9], [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]) ``` # Constraints: - Array length `0 <= n <= 10^3` - Elements of the array `-10^3 <= arr[i] <= 10^3` # Performance Requirements: - Aim to optimize recursive calls where possible. - Highlight any observed performance differences. # Python Implementation: ```python import time def stooge_sort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t) def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 def compare_sorting_algorithms(arr): stooge_sort_array = arr.copy() merge_sort_array = arr.copy() start_time = time.time() stooge_sort(stooge_sort_array, 0, len(stooge_sort_array) - 1) stooge_sort_time = time.time() - start_time start_time = time.time() merge_sort(merge_sort_array) merge_sort_time = time.time() - start_time print(f\\"Stooge Sort Time: {stooge_sort_time}\\") print(f\\"Merge Sort Time: {merge_sort_time}\\") return stooge_sort_array, merge_sort_array if __name__ == \\"__main__\\": arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(compare_sorting_algorithms(arr)) ```","solution":"import time def stooge_sort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t) def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 def compare_sorting_algorithms(arr): stooge_sort_array = arr.copy() merge_sort_array = arr.copy() start_time = time.time() stooge_sort(stooge_sort_array, 0, len(stooge_sort_array) - 1) stooge_sort_time = time.time() - start_time start_time = time.time() merge_sort(merge_sort_array) merge_sort_time = time.time() - start_time print(f\\"Stooge Sort Time: {stooge_sort_time}\\") print(f\\"Merge Sort Time: {merge_sort_time}\\") return stooge_sort_array, merge_sort_array"},{"question":"# Reverse Words in a Sentence Context In the realm of text processing, a common task might be to reverse the words in a given sentence while keeping the words themselves untouched (i.e., not reversing the characters within each word). This can be particularly useful, for instance, in reversing phrases within a sentence or rearranging text data retrieved from various sources. Problem Description Write a function `reverse_sentence_words(sentence: str) -> str` that takes a string `sentence` and returns a new string with the words in the reversed order. Your function should handle edge cases such as empty strings, strings with only whitespace, and strings with single words. Function Signature ```python def reverse_sentence_words(sentence: str) -> str: pass ``` Input * A single string `sentence` (0 ≤ length of sentence ≤ 10^5). The string consists of words and possibly spaces. Output * A string with words in the reversed order. Constraints * Leading or trailing spaces in the input sentence should be discarded. * Multiple spaces between words should be reduced to a single space in the output string. Examples Example 1: ``` Input: \\" programming in Python \\" Output: \\"Python in programming\\" ``` Example 2: ``` Input: \\"data structures \\" Output: \\"structures data\\" ``` Example 3: ``` Input: \\"leetcode contest \\" Output: \\"contest leetcode\\" ``` Performance Requirements * Time Complexity: O(n), where n is the length of the input string. * Space Complexity: O(n), where n is the length of the input string. Note This problem tests your ability to handle basic string manipulation efficiently and correctly considering edge cases.","solution":"def reverse_sentence_words(sentence: str) -> str: Reverses the order of words in a given sentence while maintaining single spacing between words and discarding leading/trailing spaces. Args: sentence (str): The input sentence. Returns: str: The sentence with words in reversed order. # Split sentence on spaces to get the words, filtering out empty strings words = sentence.split() # Join words in reverse order while ensuring single space between words reversed_sentence = \' \'.join(words[::-1]) return reversed_sentence"},{"question":"# Question Statement: You are given an undirected, unweighted graph represented as an adjacency list (dictionary) and a start node. Implement a function that returns all connected components of the graph. Each connected component should be represented as a list of nodes belonging to that component. Use Depth-First Search (DFS) for this assignment. Your function should have this signature: ```python def find_connected_components(graph: dict) -> List[List[int]]: pass ``` # Input: * `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. # Output: * A list of connected components, where each connected component is a list of nodes. # Example: ```python graph = { 1: [2, 3], 2: [1], 3: [1, 4], 4: [3], 5: [], 6: [7], 7: [6] } print(find_connected_components(graph)) ``` Output: ``` [[1, 2, 3, 4], [5], [6, 7]] ``` # Requirements: * Ensure your implementation handles graphs with isolated nodes. * The function should handle cycles correctly. * Your solution must use Depth-First Search iteratively. # Constraints: * The graph can have up to `1000` nodes. * Node identifiers are unique integers. # Assessment Criteria: * Correctness: Does the solution correctly find all connected components? * Efficiency: Does the solution operate within acceptable time and space complexities? * Edge Case Handling: Does the solution account for isolated nodes, cycles, and disconnected graphs?","solution":"def find_connected_components(graph): Returns all connected components of the graph. Each component is represented as a list of nodes. def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.append(current) stack.extend(graph[current]) visited = set() components = [] for node in graph: if node not in visited: component = [] dfs(node, visited, component) components.append(component) return components"},{"question":"# Flatten Arrays Given an array that may contain nested arrays, the task is to produce a single resultant array from it. The input can contain integers, strings (which should not be expanded into individual characters), and other lists (potentially nested arbitrarily deep). Your implementation should convert this multi-dimensional array into a one-dimensional array maintaining the order of elements as they appear. You should implement a function `flatten_array` which takes a nested list and returns a flattened list. **Function Signature:** ```python def flatten_array(input_arr: list) -> list: pass ``` # Input: - `input_arr`: A list which can contain integers, strings, and other lists (nested to any depth). # Output: - A one-dimensional list containing all the elements from the nested lists in the same order. # Constraints: - Iterators or other non-list collections should be treated as atomic elements (not expanded). - Strings should not be expanded to individual characters. - The maximum depth of nested arrays will not exceed 1000. - The total number of elements across all arrays will not exceed 10^5. # Performance Requirements: - The implementation should handle the specified constraints efficiently, considering recursion limits or using iterative techniques if necessary. # Example: ```python assert flatten_array([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_array([[], [1, [2, [3]]]]) == [1, 2, 3] assert flatten_array([1, \\"hello\\", [3, [\\"world\\"]], [5]]) == [1, \\"hello\\", 3, \\"world\\", 5] assert flatten_array([1, [\\"a\\", [3, [\\"b\\"]]], [[5]]]) == [1, \\"a\\", 3, \\"b\\", 5] ``` **Note**: It\'s important that your function can handle very deep recursions efficiently and avoid problems like stack overflow.","solution":"def flatten_array(input_arr: list) -> list: This function takes a nested list and returns a flattened version of it. result = [] def flatten(sublist): for item in sublist: if isinstance(item, list): flatten(item) else: result.append(item) flatten(input_arr) return result"},{"question":"# Question 1: Intersection of Two Linked Lists You are provided with the structure of a linked list and your task is to determine if two singly-linked lists intersect, and if so, return the node at which they intersect. # Constraints * The two linked lists must retain their original structure after the function execution. * You should not modify the lists. * No assumption about whether the length of the linked lists are equal. # Input and Output **Function Signature** ```python def find_intersection(head1: Node, head2: Node) -> Node: # Write your code here ``` * `head1`: The head node of the first singly linked list. * `head2`: The head node of the second singly linked list. **Output**: * Return the intersecting node. * If there is no intersection, return `None`. # Example Consider the following linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` If we pass the head nodes of these two linked lists to your function: ```python a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f ``` ```python find_intersection(a1, a2) ``` The function should return the node `7`. # Evaluation It is expected that your implementation: * Efficiently finds the intersection node. * Correctly handles edge cases. * Maintains O(1) space complexity.","solution":"class Node: def __init__(self, data): self.data = data self.next = None def get_length(node): length = 0 while node: length += 1 node = node.next return length def find_intersection(head1, head2): if not head1 or not head2: return None # Get the lengths of both linked lists length1 = get_length(head1) length2 = get_length(head2) # Determine the difference in lengths diff = abs(length1 - length2) # Advance the pointer of the longer list by the difference if length1 > length2: for _ in range(diff): head1 = head1.next else: for _ in range(diff): head2 = head2.next # Traverse both lists together until they intersect while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"Find the In-Order Predecessor in a Binary Search Tree Scenario: You are tasked with implementing a feature in a software system that involves finding the in-order predecessor of a given node in a Binary Search Tree (BST). The in-order predecessor of a node in a BST is defined as the node with the largest value less than the target node\'s value. Task Write a function `inorder_predecessor(root, node)` that takes two arguments: 1. `root`: the root node of a BST, and 2. `node`: the target node for which the in-order predecessor must be found. Your function should return the in-order predecessor node of the given target node. If the target node has no in-order predecessor, return `None`. Input and Output Formats: * The input `root` and `node` are in the form of instances of a BST Node class, where each node contains attributes `val`, `left`, and `right`. * You may assume that all node values are unique. * The function should return the predecessor node instance or `None` if there is no predecessor. Constraints: * The BST can contain up to `10^4` nodes. * The values of the nodes are integers within the range `[-10^4, 10^4]`. Example: Given the below BST: ``` 20 / 10 30 15 ``` * `inorder_predecessor(root, Node(15))` should return the node with the value `10`. * `inorder_predecessor(root, Node(10))` should return `None`. Notes: To validate your implementation, consider additional test cases covering various edge cases such as: * Node is the leftmost node. * Node is the root node with no left subtree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def inorder_predecessor(root, node): This function returns the in-order predecessor of the given node in a BST. :param root: TreeNode, the root of the BST. :param node: TreeNode, the target node for which the predecessor needs to be found. :return: TreeNode or None, the in-order predecessor node or None if it does not exist. predecessor = None current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: if current.left: predecessor = current.left while predecessor.right: predecessor = predecessor.right break return predecessor"},{"question":"# Markov Chain Sequence Context: You are required to simulate a pattern generator that models a simple probabilistic text generator using Markov Chains. Given an initial state and a chain definition, the generator will output a sequence of states according to the specified transition probabilities for a fixed number of steps. Task: Implement a function `generate_sequence(chain: dict, initial_state: str, steps: int) -> list` that generates a sequence of states from the Markov chain starting from the `initial_state`. Input: * `chain`: A dictionary representing the Markov chain, where each key is a state that maps to another dictionary. This nested dictionary maps possible next states to their transition probabilities. * `initial_state`: A string representing the initial state in the chain. * `steps`: An integer representing the number of states to generate in the sequence. Output: * A list of strings representing the sequence of states starting from the `initial_state`. Constraints: * All transition probabilities in a given state must sum up to 1. * The number of steps is a positive integer and less than 10000. * The chain has at least one state and each state\'s transition probabilities map is non-empty. Example: ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' steps = 5 print(generate_sequence(chain, initial_state, steps)) # Possible output: [\'A\', \'A\', \'E\', \'A\', \'E\'] ``` Additional Notes: * Ensure robustness in handling cases where states have only one transition. * Validate that all state probability maps sum to 1. * Consider implementing error handling for unexpected input formats or out-of-bounds probabilities.","solution":"import random def generate_sequence(chain, initial_state, steps): Generates a sequence of states from the Markov chain starting from the initial_state. Parameters: chain (dict): The Markov chain transition probabilities. initial_state (str): The initial state of the chain. steps (int): The number of steps to generate. Returns: list: A list representing the generated sequence of states. current_state = initial_state sequence = [current_state] for _ in range(steps - 1): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) next_state = random.choices(next_states, probabilities)[0] sequence.append(next_state) current_state = next_state return sequence"},{"question":"# Question: Linear Search with Constraints You are provided with an array of integers and a query integer. Your task is to implement a function `constrained_linear_search` that finds the first occurrence of the query integer in the array under the following constraints: 1. You can only access the first half of the array directly. For the second half, you need to perform a more costly operation which is simulated by a provided function `get_element(index)`. 2. The initial half size can be specified by an integer parameter `initial_size`. **Function Signature**: ```python def constrained_linear_search(array, query, initial_size): Find the index of the given element in the array within the constraints. If the element couldn\'t be found, returns -1. Parameters: array (list of int): The array to search in. query (int): The element to search for. initial_size (int): The size of the initial accessible segment of the array. Returns: int: The index of the query element or -1 if not found. ``` **Input**: * `array`: A list of integers. * `query`: An integer to search for in the array. * `initial_size`: An integer representing the number of elements in the array that can be accessed directly. **Output**: * Return the index of the first occurrence of the query integer within the array, or -1 if the element is not found. **Constraints**: * You need to simulate the costly access for the second half of the array elements by calling the provided function `get_element(index)` for indices beyond `initial_size-1`. * Assume that `initial_size` will always be less than or equal to half the size of the array. **Example**: ```python array = [7, 2, 9, 1, 5, 3, 4, 8] query = 5 initial_size = 4 def get_element(index): Mock function to represent costly access to the array elements. if index >= len(array) or index < initial_size: raise ValueError(\\"This function should only be called for indices beyond initial_size-1.\\") return array[index] print(constrained_linear_search(array, query, initial_size)) # Expected output: 4 ``` Provide a working implementation of `constrained_linear_search` and ensure to handle edge cases as described.","solution":"def constrained_linear_search(array, query, initial_size): Find the index of the given element in the array within the constraints. If the element couldn\'t be found, returns -1. Parameters: array (list of int): The array to search in. query (int): The element to search for. initial_size (int): The size of the initial accessible segment of the array. Returns: int: The index of the query element or -1 if not found. def get_element(index): Mock function to represent costly access to the array elements. if index >= len(array) or index < initial_size: raise ValueError(\\"This function should only be called for indices beyond initial_size-1.\\") return array[index] # Search in the directly accessible segment for i in range(initial_size): if array[i] == query: return i # Search in the costly access segment for i in range(initial_size, len(array)): if get_element(i) == query: return i return -1"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Depth-First Search (DFS) to count connected components in a grid. * **Type**: Graph traversal algorithm applied on a 2D grid. * **Main Purpose**: To count the number of islands (connected components) in a grid, where each island is formed by connecting adjacent land cells horizontally or vertically. Complexity * **Time Complexity**: (O(M times N)), where (M) is the number of rows and (N) is the number of columns in the grid. Every cell is visited once. * **Space Complexity**: (O(M times N)) in the worst case due to the depth of the recursion stack when all cells are land. Principles 1. Traverse the grid cell by cell. 2. When a cell containing \'1\' (land) is found, use DFS to visit all connected \'1\'s, marking them as visited by setting them to \'0\' (water). 3. Increment the island count for each DFS initiation. # Characteristics & Applications Properties * The algorithm marks visited nodes to avoid counting the same island multiple times. * Uses recursive stack to traverse connected cells. Common Use Cases * Finding the number of connected components in a matrix. * Detecting clusters of related elements in 2D grids. * Image processing applications like segmenting connected regions. Strengths/Limitations * **Strengths**: * Simple to implement. * Works effectively with small to moderately sized grids. * **Limitations**: * Recursive approach may lead to stack overflow on very large grids. * Not optimal for dynamic or frequently updated grids. # Implementation Challenges Edge Cases * Empty grid or grid having no \'1\'s returns zero islands. * Grids with land cells only should return 1. * Grids with complex shapes of islands need proper traversal handling. Performance Bottlenecks * Large recursion depth can lead to stack overflow. * Significant memory usage in the worst case due to recursion stack. Error Scenarios * Incorrect handling of grid bounds can lead to index out of range errors. * Failing to mark all connected cells can lead to incorrect island count. Optimization Points * Convert to an iterative approach using an explicit stack to handle large grids better. * Optimize by early stopping if the rest of the row/column has been processed. <|Analysis End|> <|Question Begin|> **Question**: You are given a 2-dimensional grid of size (M times N) where each cell contains either a \'1\' (representing land) or a \'0\' (representing water). An island is a group of \'1\'s connected horizontally or vertically (but not diagonally). The grid is entirely surrounded by \'0\'s (water). Your task is to count the number of distinct islands in the grid using an iterative approach (avoiding recursion to prevent potential stack overflow). **Function Signature**: ```python def count_islands(grid: List[List[int]]) -> int: pass ``` # Input: * `grid`: A list of lists of integers representing the 2D grid of size (M times N). # Output: * An integer representing the number of distinct islands. # Constraints: * (1 leq M, N leq 1000) * Each cell in the grid is either `0` or `1`. * The grid is surrounded by water. # Example: ```python grid1 = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] assert count_islands(grid1) == 1 grid2 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert count_islands(grid2) == 3 ``` # Instructions: * Implement the function `count_islands` to solve the problem. * Avoid using recursion; instead, use an iterative approach with an explicit stack or queue. * Ensure to handle edge cases and validate correctness via assertions or tests. # Hint: Use Breadth-First Search (BFS) for the iterative approach, starting from each unvisited land cell and marking all connected land cells visited.","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def bfs(start_row, start_col): queue = [(start_row, start_col)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: row, col = queue.pop(0) for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and not visited[new_row][new_col] and grid[new_row][new_col] == 1: visited[new_row][new_col] = True queue.append((new_row, new_col)) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: # Start a BFS to mark all connected land cells visited[i][j] = True bfs(i, j) island_count += 1 return island_count"},{"question":"Counting Sort Scenario You have been given a large set of integers where every integer lies within a known range, and you need to sort the set efficiently. The Counting Sort algorithm is a good fit for this task because of its linear time complexity under these constraints. Problem Write a Python function named `counting_sort` that sorts an array of integers using the Counting Sort algorithm. Your function should handle both positive and negative integers. Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers that needs to be sorted. The list may contain both positive and negative integers. Output * Return a new sorted list of integers. Constraints 1. The number of integers in the list `arr` is in the range [0, 1000000]. 2. Each integer in the list `arr` is in the range [-1000000, 1000000]. Example ```python # Input arr = [4, -1, -3, 2, 0, 3, 1, -2] # Output sorted_arr = [-3, -2, -1, 0, 1, 2, 3, 4] ``` # Guidelines * Handle both positive and negative integers appropriately. * Consider all edge cases including empty list, all identical elements, etc. * Your solution should be efficient and run in linear time with respect to the input size and range.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Initialize the count array with zeros range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements # Store the count of each element in the count array for num in arr: count[num - min_val] += 1 # Build the sorted array sorted_arr = [] for i in range(range_of_elements): sorted_arr.extend([i + min_val] * count[i]) return sorted_arr"},{"question":"# Repeated String Match Problem Context Given two strings `A` and `B`, you need to determine the minimum number of times you must repeat string `A` such that string `B` becomes a substring of this repeated string. If it\'s not possible for `B` to be a substring of repeated `A`, return `-1`. Input * Two strings, `A` and `B`. * `1 <= len(A), len(B) <= 10000` Output * An integer representing the minimum number of times A must be repeated for B to be a substring, or -1 if no such repetition count exists. Constraints * The function should be efficient and handle cases where the length of A and B can be up to 10000. * Aim to optimize the solution beyond the basic implementation. Example * Example 1: - Input: `A = \\"abcd\\"`, `B = \\"cdabcdab\\"` - Output: `3` - Explanation: By repeating the string A three times (\\"abcdabcdabcd\\"), B becomes a substring of the repeated string. * Example 2: - Input: `A = \\"a\\"`, `B = \\"aa\\"` - Output: `2` - Explanation: By repeating the string A two times (\\"aa\\"), B becomes a substring of the repeated string. * Example 3: - Input: `A = \\"abc\\"`, `B = \\"xyz\\"` - Output: `-1` - Explanation: No matter how many times we repeat A, B will never be a substring. Function Signature ```python def repeat_string(A: str, B: str) -> int: # Your implementation here. ``` Task Implement the function `repeat_string(A: str, B: str) -> int` to solve the described problem.","solution":"def repeat_string(A: str, B: str) -> int: Returns the minimum number of times A must be repeated so that B is a substring, or -1 if this is not possible. # The maximum required repetitions will be len(B) // len(A) + 2 max_repeats = (len(B) // len(A)) + 2 repeated_A = A for count in range(1, max_repeats + 1): if B in repeated_A: return count repeated_A += A return -1"},{"question":"# Matrix Chain Multiplication As a part of a system optimization task, you\'ve been given the responsibility to determine the most efficient way to multiply a sequence of matrices. The objective is to minimize the total number of scalar multiplications needed to multiply the sequence of matrices. # Problem Statement Given the dimensions of n matrices, where the dimensions of the ith matrix are given by `array[i-1] x array[i]`, your task is to determine the order of matrix multiplication that results in the minimum number of scalar multiplications. # Specifications 1. **Function Signature**: `def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]:` * **Parameters**: - `array`: A list of integers where the ith matrix has dimensions `(array[i-1] x array[i])`. * **Returns**: - A tuple of two 2D lists: 1. `matrix`: The minimum cost of multiplying matrices from index i to j. 2. `optimal_solution`: The index at which the optimal split occurs for matrices i to j. 2. **Function Signature**: `def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None:` * **Parameters**: - `optimal_solution`: A list of lists containing the optimal splits. - `i`: The starting matrix index. - `j`: The ending matrix index. 3. **Function Signature**: `def main() -> None:` # Constraints * `2 <= len(array) <= 100` * Values in `array` are positive integers representing the dimensions of matrices and are in the range [1, 1000]. # Example Input ```python array = [30, 35, 15, 5, 10, 20, 25] ``` Output ``` Minimum number of multiplications is 15125 Optimal parenthesization is: ((A1 (A2 A3)) ((A4 A5) A6)) ``` # Notes 1. Leverage dynamic programming concepts to store intermediate results and build up the solutions. 2. Implement helper routines for printing the optimal parenthesization based on the computed splits. 3. Ensure efficient handling of edge cases as per constraints.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) - 1 matrix = [[0] * (n+1) for _ in range(n+1)] optimal_solution = [[0] * (n+1) for _ in range(n+1)] for length in range(2, n+1): # length is the chain length for i in range(1, n-length+2): j = i + length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = matrix[i][k] + matrix[k+1][j] + array[i-1] * array[k] * array[j] if q < matrix[i][j]: matrix[i][j] = q optimal_solution[i][j] = k return matrix, optimal_solution def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(optimal_solution, i, optimal_solution[i][j]) print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j) print(\\")\\", end=\\"\\") def main() -> None: array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(f\\"Minimum number of multiplications is {matrix[1][len(array) - 1]}\\") print(\\"Optimal parenthesization is: \\", end=\\"\\") print_optimal_solution(optimal_solution, 1, len(array) - 1) print() if __name__ == \\"__main__\\": main()"},{"question":"You are given an unsorted list of integers and a target integer. Your task is to write a function that implements linear search to find the position of the target integer in the list. If the target integer is present multiple times, return the index of its first occurrence. If the target integer is not found, return -1. # Function signature: ```python def linear_search(array: List[int], target: int) -> int: pass ``` # Input: - `array` (List[int]): A list of integers with a length of n (0 ≤ n ≤ 10^6). - `target` (int): An integer to search for within the list. # Output: - (int): The index of the first occurrence of the target integer in the list, or -1 if the target is not found. # Constraints: - The elements in the array and the target integer are within the range of -10^9 to 10^9. # Example: ```python # Example 1 array = [3, 5, 1, 2, 4] target = 2 # The target 2 appears first at index 3 # Output: 3 # Example 2 array = [10, 20, 10, 20, 10] target = 20 # The target 20 appears first at index 1 # Output: 1 # Example 3 array = [] target = 10 # The array is empty, so the target cannot be found # Output: -1 ``` # Notes: You need to handle edge cases such as an empty list and ensure your function runs efficiently within the given constraints. Your implementation should not exceed O(n) time complexity and O(1) auxiliary space complexity.","solution":"from typing import List def linear_search(array: List[int], target: int) -> int: Implements linear search to find the index of the target\'s first occurrence in the array. Returns -1 if the target is not found. for index, value in enumerate(array): if value == target: return index return -1"},{"question":"# Fibonacci Number Calculation Challenge You are tasked with implementing an efficient function to compute the n-th Fibonacci number. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, starting from 0 and 1. That is, ``` F0 = 0, F1 = 1 Fn = F(n-1) + F(n-2) for n > 1 ``` Given a non-negative integer `n`, your task is to return the n-th Fibonacci number using an efficient algorithm that operates in O(n) time complexity and O(1) space complexity. # Input - A non-negative integer `n` (0 ≤ n ≤ 10^18). # Output - A single integer representing the n-th Fibonacci number. # Constraints - You must ensure that your implementation handles very large inputs efficiently within the given constraints. - You should only use constant space (O(1)) to store intermediate results. # Example ```python >>> fib(10) 55 >>> fib(20) 6765 >>> fib(0) 0 >>> fib(1) 1 ``` # Tips - Think about how you can compute the Fibonacci sequence iteratively without storing all intermediate results.","solution":"def fib(n): Returns the n-th Fibonacci number using an efficient algorithm that operates in O(n) time complexity and O(1) space complexity. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Implement a Simple Diffie-Hellman Key Exchange Process Context Alice and Bob want to securely communicate with each other over an insecure network. To do this, they decide to use the Diffie-Hellman key exchange method to establish a shared secret key. However, they need your help to ensure the correctness and security of their implementation. Task Your task is to implement a function `secure_diffie_hellman(a, p)` that performs the Diffie-Hellman key exchange. The function should take a primitive root `a` and a prime number `p`, check their validity, and simulate the key exchange process by generating both private and public keys for Alice and Bob. The function should return the shared secret key if the exchange is successful. Input * `a` (integer): A primitive root of the prime number `p`. * `p` (integer): A large prime number. Output * `int`: The shared secret key if the exchange is successful, or an appropriate error message if the input constraints are not satisfied. Constraints * `p` must be a prime number. * `a` must be a valid primitive root of `p`. Performance Requirements * The solution should have a time complexity of ( O(log p) ) for the modular exponentiation processes. Example ```python secure_diffie_hellman(5, 23) ``` Explanation 1. Verify if `p` is a prime number. 2. Verify if `a` is a primitive root of `p`. 3. Generate private keys for Alice and Bob in the range [1, p-1]. 4. Compute the public keys using the formula (a^{text{private key}} mod p). 5. Exchange public keys and compute the shared secret key using the received public key and own private key. 6. Return the shared secret key if both computed keys match. Implementation ```python import math from random import randint def prime_check(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False j = 5 while j * j <= num: if num % j == 0 or num % (j + 2) == 0: return False j += 6 return True def find_order(a, n): if (a == 1) & (n == 1): return 1 if math.gcd(a, n) != 1: return -1 for i in range(1, n): if pow(a, i) % n == 1: return i return -1 def euler_totient(n): result = n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: while n % i == 0: n //= i result -= result // i if n > 1: result -= result // n return result def find_primitive_root(n): if n == 1: return [0] phi = euler_totient(n) p_root_list = [] for i in range (1, n): if math.gcd(i, n) != 1: continue order = find_order(i, n) if order == phi: p_root_list.append(i) return p_root_list def alice_private_key(p): return randint(1, p-1) def alice_public_key(a_pr_k, a, p): return pow(a, a_pr_k) % p def bob_private_key(p): return randint(1, p-1) def bob_public_key(b_pr_k, a, p): return pow(a, b_pr_k) % p def alice_shared_key(b_pu_k, a_pr_k, p): return pow(b_pu_k, a_pr_k) % p def bob_shared_key(a_pu_k, b_pr_k, p): return pow(a_pu_k, b_pr_k) % p def secure_diffie_hellman(a, p): if not prime_check(p): return f\\"{p} is not a prime number\\" p_root_list = find_primitive_root(p) if a not in p_root_list: return f\\"{a} is not a primitive root of {p}\\" a_pr_k = alice_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pr_k = bob_private_key(p) b_pu_k = bob_public_key(b_pr_k, a, p) a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p) b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p) if a_sh_k != b_sh_k: return \\"Shared keys do not match\\" return a_sh_k ```","solution":"import math from random import randint def prime_check(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_order(a, n): if math.gcd(a, n) != 1: return -1 for i in range(1, n): if pow(a, i, n) == 1: return i return -1 def euler_totient(n): result = n for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0: while n % i == 0: n //= i result -= result // i if n > 1: result -= result // n return result def find_primitive_root(n): if n == 1: return [0] phi = euler_totient(n) primitive_roots = [] for i in range(1, n): if math.gcd(i, n) == 1 and find_order(i, n) == phi: primitive_roots.append(i) return primitive_roots def secure_diffie_hellman(a, p): if not prime_check(p): return f\\"{p} is not a prime number\\" primitive_roots = find_primitive_root(p) if a not in primitive_roots: return f\\"{a} is not a primitive root of {p}\\" alice_private = randint(1, p - 1) alice_public = pow(a, alice_private, p) bob_private = randint(1, p - 1) bob_public = pow(a, bob_private, p) alice_shared = pow(bob_public, alice_private, p) bob_shared = pow(alice_public, bob_private, p) if alice_shared != bob_shared: return \\"Shared keys do not match\\" return alice_shared"},{"question":"# Strongly Connected Components Verification **Scenario**: You\'re part of a team developing software to manage a complex network of servers. Each server can send requests to any number of other servers. To ensure network resilience, you need to verify that the network is strongly connected—that is, each server must be able to communicate directly or indirectly with every other server. **Task**: Implement a function to determine if the network represented by a directed graph is strongly connected. Utilize Depth First Search (DFS) and graph reversal techniques as needed. **Function Signature**: ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` **Input**: * `vertex_count` (int): The number of vertices (servers) in the graph. * `edges` (List[Tuple[int, int]]): A list of tuples representing directed edges between vertices. Each tuple (u, v) indicates an edge from vertex `u` to vertex `v`. **Output**: * Return a boolean value `True` if the graph is strongly connected, and `False` otherwise. **Constraints**: * The graph may have up to 10,000 vertices and 50,000 edges. * Vertices are labeled from 0 to vertex_count - 1. **Example**: ```python # Example 1: vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] assert is_strongly_connected(vertex_count, edges) == True # Example 2: vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] assert is_strongly_connected(vertex_count, edges) == False ``` **Notes**: * Consider edge cases such as graphs with no edges, single-node graphs, and graphs with bidirectional edges. * Ensure your implementation handles large inputs efficiently.","solution":"from typing import List, Tuple def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: if vertex_count == 0: return True from collections import defaultdict, deque # Create the adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) # Function to perform DFS def dfs(start, graph): stack, visited = [start], [False] * vertex_count while stack: node = stack.pop() if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: stack.append(neighbor) return visited # Perform DFS from the first vertex visited = dfs(0, adj_list) if not all(visited): return False # Create the reversed graph rev_adj_list = defaultdict(list) for u, v in edges: rev_adj_list[v].append(u) # Perform DFS from the first vertex on the reversed graph rev_visited = dfs(0, rev_adj_list) if not all(rev_visited): return False return True"},{"question":"The task is to write a function that removes a specified range of elements from a linked list. The linked list consists of nodes, each containing a value and a reference to the next node. The function should modify the list in place without allocating new nodes for the list elements. Function Signature: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: ``` Input: - `head` (ListNode): The head node of a singly linked list. - `start` (int): The starting index of the range (inclusive). - `end` (int): The ending index of the range (inclusive). Output: - `ListNode`: The head node of the modified linked list. Constraints: - The list is non-empty. - 0 ≤ start ≤ end < (size of the list). - The nodes are indexed starting from 0. Example: ```plaintext List: 8 -> 13 -> 17 -> 4 -> 9 -> 12 -> 98 -> 41 -> 7 -> 23 -> 0 -> 92 remove_range(head, 3, 8) Updated List: 8 -> 13 -> 17 -> 23 -> 0 -> 92 ``` Requirements: - You may assume the linked list node definition is provided. - Consider all edge cases, such as removing elements involving the head or tail. - Achieve an O(n) time complexity solution.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: if head is None or start > end: return head dummy = ListNode(0) dummy.next = head prev = dummy for _ in range(start): prev = prev.next current = prev.next for _ in range(end - start + 1): current = current.next prev.next = current return dummy.next"},{"question":"You are tasked with implementing a sorting function that utilizes the Bucket Sort algorithm but optimized for floating-point numbers ranging from 0 to 1. The algorithm should distribute the numbers into buckets and then use a more efficient sorting algorithm for each bucket. # Function Signature ```python def optimized_bucket_sort(arr: List[float]) -> List[float]: pass ``` # Input * A list of float numbers `arr` where `0 <= arr[i] < 1` for all `i` in the list. * The number of elements in `arr` is `n` with `1 <= n <= 10^6`. # Output * A list of float numbers sorted in ascending order. # Constraints * Optimize the bucket sorting algorithm to handle up to 1 million elements efficiently. * Use a more efficient sorting algorithm like Merge Sort or Quick Sort for sorting each bucket. # Requirements 1. Distribute floating-point numbers into appropriate buckets. 2. Use a more efficient sorting algorithm for each bucket. 3. Concatenate all sorted buckets to return the final sorted list. # Example ```python assert optimized_bucket_sort([0.22, 0.29, 0.35, 0.100, 0.300]) == [0.100, 0.22, 0.29, 0.30, 0.35] assert optimized_bucket_sort([0.83, 0.24, 0.94, 0.11, 0.43, 0.19]) == [0.11, 0.19, 0.24, 0.43, 0.83, 0.94] assert optimized_bucket_sort([0.1, 0.1, 0.1, 0.1, 0.1]) == [0.1, 0.1, 0.1, 0.1, 0.1] ``` **Note**: Ensure that your solution is efficient and scales well with the input size.","solution":"from typing import List def optimized_bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] n = len(arr) buckets = [[] for _ in range(n)] # Distribute input numbers to the appropriate buckets for num in arr: index = int(n * num) buckets[index].append(num) # Sort each bucket using a faster sorting algorithm sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) # Using Python\'s Timsort which is based on MergeSort return sorted_arr"},{"question":"# Context Consider an algebraic computer system that needs to perform various operations involving monomials and polynomials. A monomial consists of a coefficient and a set of variables with corresponding powers. A polynomial is a sum of such monomials. # Task Implement a class Polynomial with the following capabilities: * Initialize from a list of monomials or numeric types. * Addition, Subtraction, Multiplication of Polynomials and Monomials. * Simplification of polynomial expressions by combining like terms. # Requirements 1. **Class Definition**: ```python class Polynomial: def __init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None: pass def __add__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial: pass def __sub__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial: pass def __mul__(self, other: Union[int, float, Fraction, Monomial, Polynomial]) -> Polynomial: pass def simplify(self) -> Polynomial: pass ``` 2. **Function Specifications**: * `__init__`: Initialize a Polynomial object from an iterable of Monomials or numeric types. * `__add__`: Overload the addition operator to add a monomial or polynomial to the existing polynomial. * `__sub__`: Overload the subtraction operator to subtract a monomial or polynomial from the existing polynomial. * `__mul__`: Overload the multiplication operator to multiply a monomial or polynomial with the existing polynomial. * `simplify`: Combine like terms in the polynomial and return the simplified Polynomial. 3. **Constraints**: * Only Monomial objects or numeric types may be added, subtracted, or multiplied. * Polynomial objects must maintain unique monomials where coefficients of like terms are combined. * Mono and Polynomials should use rational fraction where needed to avoid floating-point imprecision. # Example Usage ```python # Represent polynomial 2a_1 + 3a_2^2 - a_1a_2 + 5 poly = Polynomial([Monomial({1: 1}, 2), Monomial({2: 2}, 3), Monomial({1: 1, 2: 1}, -1), 5]) # Addition example: Add another monomial 4a_1 poly2 = poly + Monomial({1: 1}, 4) # Subtraction example: Subtract polynomial a_1 - a_2^2 poly3 = poly2 - Polynomial([Monomial({1: 1}, 1), Monomial({2: 2}, -1)]) # Multiplication example: Multiply with monomial 2a_2 poly4 = poly3 * Monomial({2: 1}, 2) # Simplify poly_simplified = poly4.simplify() print(str(poly_simplified)) ``` # Output The output will display a string representation of the simplified polynomial expression.","solution":"from typing import Union, Iterable, Dict from fractions import Fraction class Monomial: def __init__(self, powers: Dict[int, int], coefficient: Union[int, float, Fraction]) -> None: self.powers = powers self.coefficient = Fraction(coefficient) def __eq__(self, other: \'Monomial\') -> bool: return self.powers == other.powers and self.coefficient == other.coefficient def __add__(self, other: \'Monomial\') -> \'Monomial\': if self.powers == other.powers: return Monomial(self.powers, self.coefficient + other.coefficient) raise ValueError(\\"Monomials must have the same powers to be added\\") def __mul__(self, other: Union[\'Monomial\', int, float, Fraction]) -> \'Monomial\': if isinstance(other, Monomial): new_powers = self.powers.copy() for variable, power in other.powers.items(): if variable in new_powers: new_powers[variable] += power else: new_powers[variable] = power return Monomial(new_powers, self.coefficient * other.coefficient) else: return Monomial(self.powers, self.coefficient * other) def __str__(self) -> str: terms = [] for var, exp in sorted(self.powers.items()): if exp == 1: terms.append(f\'a_{var}\') else: terms.append(f\'a_{var}^{exp}\') if not terms: # Constant term case return str(self.coefficient) return f\\"{self.coefficient}*{\'*\'.join(terms)}\\" def __repr__(self) -> str: return self.__str__() class Polynomial: def __init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None: self.monomials = [] for item in monomials: if isinstance(item, Monomial): self.monomials.append(item) else: self.monomials.append(Monomial({}, item)) self.simplify() def __add__(self, other: Union[int, float, Fraction, Monomial, \'Polynomial\']) -> \'Polynomial\': if isinstance(other, Polynomial): return Polynomial(self.monomials + other.monomials) else: return Polynomial(self.monomials + [other]) def __sub__(self, other: Union[int, float, Fraction, Monomial, \'Polynomial\']) -> \'Polynomial\': if isinstance(other, Polynomial): return Polynomial(self.monomials + [Monomial(m.powers, -m.coefficient) for m in other.monomials]) else: return Polynomial(self.monomials + [Monomial(other.powers, -other.coefficient)]) def __mul__(self, other: Union[int, float, Fraction, Monomial, \'Polynomial\']) -> \'Polynomial\': if isinstance(other, Polynomial): result = [] for m1 in self.monomials: for m2 in other.monomials: result.append(m1 * m2) return Polynomial(result) else: return Polynomial([m * other for m in self.monomials]) def simplify(self) -> \'Polynomial\': combined = {} for m in self.monomials: key = tuple(sorted(m.powers.items())) if key in combined: combined[key] = combined[key] + m else: combined[key] = m self.monomials = [m for m in combined.values() if m.coefficient != 0] return self def __str__(self) -> str: if not self.monomials: return \'0\' return \' + \'.join(str(m) for m in self.monomials) def __repr__(self) -> str: return self.__str__()"},{"question":"# Segment Tree: Minimum Range Query Context You\'re working on a system that needs to process multiple range queries on a large dataset. Specifically, you need to find the minimum value within specific subarrays of the dataset very efficiently. To achieve this, you\'ll implement a data structure known as a Segment Tree, which is well-suited for this kind of operation. Problem Statement Design and implement a Segment Tree that supports efficient range minimum queries. Function Signature ```python class SegmentTree: def __init__(self, arr): Initializes the segment tree with a given array. Parameters: arr (List[int]): The initial array of integers. pass def query(self, L, R): Returns the minimum value within the range [L, R]. Parameters: L (int): Starting index (inclusive) of the range. R (int): Ending index (inclusive) of the range. Returns: int: The minimum value within the specified range. pass def update(self, idx, value): Updates the value of the element at index \'idx\' to \'value\'. Parameters: idx (int): The index of the element to be updated. value (int): The new value of the element. pass ``` Constraints and Assumptions - You can assume that the array will contain up to 10^5 elements. - You can assume the range for both queries and updates will be within valid index limits of the array. - The array may contain negative integers. - The given indices for queries are always valid. - The update operations can be interleaved with query operations. Example Usage ```python # Example usage of the SegmentTree class # Initializing the segment tree arr = [2, 4, 5, 3, 4] seg_tree = SegmentTree(arr) # Querying the minimum value in the range [1, 3] print(seg_tree.query(1, 3)) # Output: 3 # Updating value at index 2 to 1 seg_tree.update(2, 1) # Querying the minimum value in the range [1, 3] again print(seg_tree.query(1, 3)) # Output: 1 # Querying the minimum value in the range [0, 4] print(seg_tree.query(0, 4)) # Output: 1 ``` Your task is to implement the `SegmentTree` class with the above methods `__init__`, `query`, and `update`, ensuring efficient construction, querying, and updating of the segment tree.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L, R): L += self.n R += self.n minimum = float(\'inf\') while L <= R: if L % 2 == 1: minimum = min(minimum, self.tree[L]) L += 1 if R % 2 == 0: minimum = min(minimum, self.tree[R]) R -= 1 L //= 2 R //= 2 return minimum def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = min(self.tree[2 * idx], self.tree[2 * idx + 1])"},{"question":"# Scenario You are working on a real-time recommendation system for an e-commerce platform. One of the key components of your recommendation algorithm is to measure similarity between user preferences. You decide to use cosine similarity between preference vectors representing user tastes in various product categories. # Task Write a Python function `cosine_similarity_with_checks(vec1, vec2)` that calculates the cosine similarity between two vectors. Your function should handle edge cases effectively and provide meaningful error messages. Additionally, ensure the solution is optimized for performance. # Requirements: 1. The two input vectors `vec1` and `vec2` must be of the same length. 2. Deal with zero vectors by returning a similarity of 0 (if either vector is a zero vector). 3. Handle exceptions gracefully, with appropriate error messages. # Input: * `vec1`: List of integers or floats, e.g., [1, 1, 1]. * `vec2`: List of integers or floats, e.g., [1, 2, -1]. # Output: A single float value representing the cosine similarity between the two vectors. # Constraints: * The length of `vec1` and `vec2` will be between 1 and 10^6. * Elements of `vec1` and `vec2` will be in the range of [-10^4, 10^4]. # Examples: 1. `cosine_similarity_with_checks([1, 1, 1], [1, 2, -1])` should return `0.47140452079103173`. 2. `cosine_similarity_with_checks([0, 0, 0], [1, 2, 3])` should return `0.0`. # Implementation Notes * Use the Euclidean norm to handle vector normalization. * Ensure that division by zero is handled when vectors contain only zeros. * Focus on performance by minimizing repeated calculations.","solution":"import math def cosine_similarity_with_checks(vec1, vec2): Calculates the cosine similarity between two vectors with checks for edge cases. Parameters: vec1 (list of float or int): The first vector. vec2 (list of float or int): The second vector. Returns: float: The cosine similarity between the two vectors. if len(vec1) != len(vec2): raise ValueError(\\"Input vectors must have the same length\\") dot_product = sum(x * y for x, y in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(x * x for x in vec1)) norm_vec2 = math.sqrt(sum(y * y for y in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: return 0.0 return dot_product / (norm_vec1 * norm_vec2)"},{"question":"# Scenario You are writing a music playlist application that needs to efficiently handle frequent additions and removals of tracks. Each track in the playlist should also be easily naviagable both forwards and backwards. # Task Implement a **DoublyLinkedList** class to manage the playlist. Your implementation should include the following functionalities: 1. **Initialization**: Initialize an empty list. 2. **AddTrack**: - Add a new track to the end of the playlist (`O(1)` time complexity). 3. **RemoveTrack**: - Remove a specific track given its title (assume titles are unique) (`O(n)` time complexity). 4. **DisplayPlaylist**: - Print all tracks from the current playlist starting from the head to the tail (`O(n)` time complexity). # Function Signatures ```python class DoublyLinkedList: def __init__(self): # Initialize your data structure here. def AddTrack(self, title: str): # Adds a new track with the given title to the end of the list. def RemoveTrack(self, title: str) -> bool: # Removes the track with the given title and returns True if removed successfully, otherwise False. def DisplayPlaylist(self): # Prints the entire playlist from head to tail. ``` # Input/Output Format - `AddTrack`: Should insert a track at the end of the playlist with its title as a string. - `RemoveTrack`: Should remove the track with the specified title. Return `True` if the track is found and removed, else return `False`. - `DisplayPlaylist`: Should print the titles of all the tracks in the playlist from head to tail. # Constraints - Assume the track titles are unique. - Expected to handle up to 1000 operations efficiently. - Assume track titles are always valid non-empty strings. # Example ```python playlist = DoublyLinkedList() playlist.AddTrack(\\"Track 1\\") playlist.AddTrack(\\"Track 2\\") playlist.AddTrack(\\"Track 3\\") playlist.DisplayPlaylist() # Output: \\"Track 1 Track 2 Track 3\\" playlist.RemoveTrack(\\"Track 2\\") playlist.DisplayPlaylist() # Output: \\"Track 1 Track 3\\" ``` # Additional Notes Be sure to handle edge cases such as: - Trying to remove an element from an empty playlist. - Displaying an empty playlist. - Ensuring the list remains consistent after each operation.","solution":"class DoublyLinkedList: class Node: def __init__(self, title): self.title = title self.prev = None self.next = None def __init__(self): self.head = None self.tail = None def AddTrack(self, title): new_node = self.Node(title) if self.tail is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def RemoveTrack(self, title): current = self.head while current: if current.title == title: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False def DisplayPlaylist(self): current = self.head while current: print(current.title, end=\' \') current = current.next print()"},{"question":"# Task Implement a function to compute the GCD and LCM of a list of positive integers using the given principles. Your solution should validate input constraints and handle exceptional conditions. # Requirements 1. **Function**: Implement `compute_gcd_lcm(numbers)`. 2. **Input**: A list of positive integers (e.g., `[12, 15, 25]`). Constraints: 1 <= length(numbers) <= 1000, 1 <= numbers[i] <= 10000. 3. **Output**: A tuple containing two values: the GCD and LCM of the list (e.g., `(1, 300) for input [12, 15, 25]`). # Example ```python assert compute_gcd_lcm([12, 15, 25]) == (1, 300) assert compute_gcd_lcm([10, 20, 30, 40]) == (10, 120) assert compute_gcd_lcm([3]) == (3, 3) ``` # Note - Use the Euclidean algorithm to find the GCD for the list. - Use the relationship `lcm(a, b) = abs(a * b) / gcd(a, b)` to compute pairwise LCMs iteratively to find the LCM of multiple numbers. # Edge Cases - Handle the case where the list has only one number (GCD and LCM of a single number is the number itself). - Ensure the function raises appropriate errors for invalid inputs, such as negative numbers or non-integers.","solution":"import math from functools import reduce def compute_gcd_lcm(numbers): Computes the GCD and LCM of a list of positive integers. Parameters: numbers (list): List of positive integers. Returns: tuple: A tuple containing the GCD and LCM of the list. if not all(isinstance(i, int) and i > 0 for i in numbers): raise ValueError(\\"All elements in the list must be positive integers\\") # Compute GCD of the list def gcd(a, b): while b: a, b = b, a % b return a overall_gcd = reduce(gcd, numbers) # Compute LCM of the list def lcm(a, b): return abs(a * b) // gcd(a, b) overall_lcm = reduce(lcm, numbers) return (overall_gcd, overall_lcm)"},{"question":"# Flatten Nested Arrays Given an array that may include deeply nested arrays, write a function to produce a single-level (flattened) array containing all elements in their original order. Implement the following function: ```python def flatten_array(input_arr): Flattens a deeply nested array into a single-level array. Args: input_arr (list): A multi-dimensional array possibly containing nested arrays. Returns: list: A single-level flattened array. Example: >>> flatten_array([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] pass ``` **Constraints and Notes:** 1. The input array may contain various types: integers, floats, strings, and sub-arrays. 2. Strings in the nested arrays should be considered atomic (i.e., should not be split). 3. Your function should support arrays nested to any depth. 4. Do not use any libraries or pre-built functions specifically for flattening arrays (e.g., `itertools.chain`, `numpy.flatten`). **Performance Requirements**: 1. The function should run in O(n) time where n is the total number of elements in the nested array. 2. Memory usage should be O(n) for both call stack and resultant array. **Scenario**: Imagine you are working on an application that processes deeply nested JSON-like data. Flattening such structures is essential for many operations, such as database storage or flat file generation. # Examples: 1. `flatten_array([1, [2, [3, 4], 5], 6])` should return `[1, 2, 3, 4, 5, 6]`. 2. `flatten_array([1, [2, \\"a\\", [3, [\\"b\\", 4]], 5], 6])` should return `[1, 2, \\"a\\", 3, \\"b\\", 4, 5, 6]`. Given this specification, implement the `flatten_array` function to handle the requirements accurately.","solution":"def flatten_array(input_arr): Flattens a deeply nested array into a single-level array. Args: input_arr (list): A multi-dimensional array possibly containing nested arrays. Returns: list: A single-level flattened array. Example: >>> flatten_array([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] flat_list = [] def flatten(arr): for item in arr: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(input_arr) return flat_list"},{"question":"# Question: You are given a scenario where you need to handle large sparse vectors efficiently and compute their dot product. A large sparse vector is one that contains mostly zeros with a few non-zero elements scattered throughout. Implement the following functions: 1. **`vector_to_index_value_dict(vector: List[float]) -> Dict[int, float]`**: * Converts the input vector into a dictionary where keys are the indices of non-zero elements, and values are the corresponding non-zero values. * **Input**: * `vector`: A list of floating-point numbers representing the vector. * **Output**: * A dictionary with index-value pairs representing non-zero elements of the vector. 2. **`dot_product(iv_dict1: Dict[int, float], iv_dict2: Dict[int, float]) -> float`**: * Computes the dot product of two vectors represented as dictionaries of index-value pairs. * **Input**: * `iv_dict1`: Dictionary of index-value pairs representing the first sparse vector. * `iv_dict2`: Dictionary of index-value pairs representing the second sparse vector. * **Output**: * A floating-point number representing the dot product of the two vectors. Constraints: * The vectors may contain up to 10^6 elements. * The number of non-zero elements in a vector won\'t exceed 10^5. Example: ```python vector1 = [0.0, 3.0, 0.0, 4.0, 0.0] vector2 = [0.0, 2.0, 0.0, 0.0, 5.0] # Convert vectors to index-value dictionaries iv_dict1 = vector_to_index_value_dict(vector1) # {1: 3.0, 3: 4.0} iv_dict2 = vector_to_index_value_dict(vector2) # {1: 2.0, 4: 5.0} # Calculate dot product result = dot_product(iv_dict1, iv_dict2) # 6.0 ```","solution":"from typing import List, Dict def vector_to_index_value_dict(vector: List[float]) -> Dict[int, float]: Converts the input vector into a dictionary where keys are the indices of non-zero elements, and values are the corresponding non-zero values. iv_dict = {i: value for i, value in enumerate(vector) if value != 0.0} return iv_dict def dot_product(iv_dict1: Dict[int, float], iv_dict2: Dict[int, float]) -> float: Computes the dot product of two vectors represented as dictionaries of index-value pairs. result = 0.0 for index, value in iv_dict1.items(): if index in iv_dict2: result += value * iv_dict2[index] return result"},{"question":"**Context:** A group of software developers is working on implementing a stack-based command-line utility that allows for efficient command storage and retrieval. They need the stack to handle a dynamic number of commands since the utility\'s usage can vary significantly. **Task:** Implement two variations of the stack: one using arrays and one using linked lists. Your implementation will demonstrate your understanding of these different stack approaches, including edge cases and performance characteristics. **Function Specification:** # ArrayStack Implementation * `class ArrayStack` should implement the following methods: - `__init__(self, size=10)`: Initialize the stack with an optional initial size. - `push(self, value)`: Push a value onto the stack. - `pop(self)`: Remove and return the top value from the stack. - `peek(self)`: Return the top value without removing it. - `is_empty(self)`: Check if the stack is empty. - `_expand(self)`: Double the size of the array when the stack is full. # LinkedListStack Implementation * `class LinkedListStack` should implement the following methods: - `__init__(self)`: Initialize the stack. - `push(self, value)`: Push a value onto the stack. - `pop(self)`: Remove and return the top value from the stack. - `peek(self)`: Return the top value without removing it. - `is_empty(self)`: Check if the stack is empty. # Input - No direct input for these classes, as they will be tested through method calls. # Output - Each method should behave as defined above. - Ensure proper error handling for edge cases such as popping or peeking from an empty stack. # Constraints - You may assume the initial stack size for the array implementation will not exceed 1000. - For the linked list implementation, a node should be defined with `value` and `next` attributes. **Example Usage:** ```python # ArrayStack Example array_stack = ArrayStack(size=5) array_stack.push(1) array_stack.push(2) print(array_stack.pop()) # Output: 2 print(array_stack.peek()) # Output: 1 print(array_stack.is_empty()) # Output: False # LinkedListStack Example linked_list_stack = LinkedListStack() linked_list_stack.push(\\"a\\") linked_list_stack.push(\\"b\\") print(linked_list_stack.pop()) # Output: b print(linked_list_stack.peek()) # Output: a print(linked_list_stack.is_empty()) # Output: False ``` Ensure your implementation passes various edge cases, such as operations on empty stacks. Provide appropriate exception handling where needed.","solution":"class ArrayStack: def __init__(self, size=10): self.stack = [None] * size self.capacity = size self.top = -1 def push(self, value): if self.top + 1 == self.capacity: self._expand() self.top += 1 self.stack[self.top] = value def pop(self): if self.is_empty(): raise IndexError(\'pop from empty stack\') value = self.stack[self.top] self.stack[self.top] = None self.top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\'peek from empty stack\') return self.stack[self.top] def is_empty(self): return self.top == -1 def _expand(self): self.capacity *= 2 new_stack = [None] * self.capacity for i in range(self.top + 1): new_stack[i] = self.stack[i] self.stack = new_stack class Node: def __init__(self, value): self.value = value self.next = None class LinkedListStack: def __init__(self): self.head = None def push(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\'pop from empty stack\') value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): raise IndexError(\'peek from empty stack\') return self.head.value def is_empty(self): return self.head is None"},{"question":"Objective Write a function to implement a sorting algorithm similar to Exchange Sort, but with enhanced efficiency. Your function should sort an array of integers in ascending order. Function Signature ```python def optimized_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers, `arr`, where `0 <= len(arr) <= 10^5` and each integer in the list is between `-10^9` and `10^9`. Output * The sorted array of integers in ascending order. Constraints * Your implementation should be efficient enough to handle an array of up to `10^5` elements within a reasonable time frame. * Do not use Python\'s built-in sorting functions (`sorted`, `.sort()`). Performance Requirements * The algorithm must have an average-time complexity better than O(n^2). Example ```python print(optimized_sort([5, 2, 9, 1, 5, 6])) # Output: [1, 2, 5, 5, 6, 9] print(optimized_sort([-3, 0, 3, -2, 2, 1, 0])) # Output: [-3, -2, 0, 0, 1, 2, 3] print(optimized_sort([])) # Output: [] ``` Additional Information * Consider using more advanced algorithms like Merge Sort or Quick Sort to meet the performance requirements. * If using recursion, ensure your solution does not exceed the maximum recursion depth for Python (default 1000).","solution":"def optimized_sort(arr): Implementing a Quick Sort algorithm to sort the array in ascending order. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return optimized_sort(left) + middle + optimized_sort(right)"},{"question":"Context: Factorials of numbers are used extensively in combinatorial computations such as permutations and combinations. However, computing the factorial of even moderately sized numbers quickly leads to extremely large values, making it difficult to handle due to overflow issues. To mitigate this, we often compute factorials under a modulo operation, particularly in problems involving large numbers. Task: Implement a function to compute the factorial of a given integer `n` using both iterative and recursive methods. Your functions should support optional modulo computation to prevent overflow. Function Signatures: ```python def factorial_iterative(n: int, mod: int = None) -> int: pass def factorial_recursive(n: int, mod: int = None) -> int: pass ``` Input: * **n**: A non-negative integer where 0 ≤ n ≤ 10^6. * **mod**: An optional positive integer, defaults to `None`. Output: * An integer representing n! modulo mod if mod is provided. If mod is not provided, return n!. Constraints: * Your solutions should handle edge cases effectively. * Your implementation should be optimized to handle large values of n. Examples: 1. `factorial_iterative(5)` should return `120`. 2. `factorial_recursive(5)` should return `120`. 3. `factorial_iterative(5, 3)` should return `0` because 120 % 3 is 0. 4. `factorial_recursive(5, 3)` should return `0`. Ensure your implementation correctly handles large integers efficiently, especially when the modulo value is provided.","solution":"def factorial_iterative(n: int, mod: int = None) -> int: Computes the factorial of a given integer n using an iterative method. If mod is provided, returns n! % mod. factorial = 1 for i in range(2, n+1): factorial *= i if mod: factorial %= mod return factorial def factorial_recursive(n: int, mod: int = None, computed: int = 1) -> int: Computes the factorial of a given integer n using a recursive method. If mod is provided, returns n! % mod. if n == 0 or n == 1: return computed if not mod else computed % mod next_computed = computed * n return factorial_recursive(n - 1, mod, next_computed % mod if mod else next_computed)"},{"question":"You are given a function with the following signature: ```python def limit_frequency(array: list, n: int) -> list: pass ``` Implement the function `limit_frequency` that takes in a list of integers, `array`, and an integer `n`. The function should return a new list that contains each number in the original list at most `n` times without reordering. Input * `array`: A list of integers where 1 ≤ len(array) ≤ 10^5. * `n`: An integer where 1 ≤ n ≤ 10^3. Output * A list of integers meeting the criteria described. Example ```python print(limit_frequency([1, 2, 3, 1, 2, 1, 2, 3], 2)) # Output: [1, 2, 3, 1, 2, 3] print(limit_frequency([1, 1, 1, 1], 2)) # Output: [1, 1] print(limit_frequency([], 3)) # Output: [] print(limit_frequency([1, 2, 3], 3)) # Output: [1, 2, 3] ``` Constraints * You must implement the function such that its time complexity is O(n). * You may assume all integers in the list are within the range of 32-bit signed integers.","solution":"def limit_frequency(array: list, n: int) -> list: Return a new list that contains each integer from the original list at most n times without reordering. from collections import defaultdict frequency = defaultdict(int) result = [] for num in array: if frequency[num] < n: result.append(num) frequency[num] += 1 return result"},{"question":"Implement a function `linear_search_with_multi_target` that performs a linear search on an array. In addition to finding the index of a single target value, this function should be able to search for multiple target values within the array and return all their indices. If a target value is not present, return -1 for that value. # Requirements * **Input**: * A list `array` of integers, where `1 <= len(array) <= 10^5`. * A list `targets` of integers, where `1 <= len(targets) <= 10^5`. * **Output**: * A list of integers where each element is the index of the corresponding target from the `targets` list. * If a target does not exist in the `array`, the resultant list should contain -1 for that target. # Constraints * The input array may contain duplicate elements. * The order of targets in the output should match the order in the `targets` list. * The output list must have the same length as the `targets` list. # Example ```python # Example Input array = [5, 1, 4, 7, 3, 2] targets = [7, 4, 8] # Example Output result = [3, 2, -1] # Explanation # The target 7 is found at index 3 in the array. # The target 4 is found at index 2 in the array. # The target 8 is not found in the array, so return -1 for 8. ``` # Function Signature ```python def linear_search_with_multi_target(array, targets): # Your code here pass ```","solution":"def linear_search_with_multi_target(array, targets): Perform a linear search on the given array for multiple target values. Parameters: array (list of int): The list in which to search for targets. targets (list of int): The list of target values to search for in the array. Returns: list of int: A list containing the index of each target value in the array or -1 if not found. result = [] for target in targets: if target in array: result.append(array.index(target)) else: result.append(-1) return result"},{"question":"You are tasked with enhancing and verifying the integer base conversion algorithms. You need to implement two functions: `improved_int_to_base` and `improved_base_to_int`. # Function Specifications 1. **improved_int_to_base** Convert a given integer to a specified base and return the resulting string. **Input**: - `num` (int): The integer to be converted. It can be positive, negative, or zero. - `base` (int): The base to convert the number to, ranging from 2 to 36 inclusive. **Output**: - (str): The string representation of the number in the specified base. **Constraints**: - You must handle cases where `base` is less than 2 or greater than 36 by returning an appropriate error message or raising an exception. - Consider edge cases such as zero and negative numbers appropriately. 2. **improved_base_to_int** Convert a given string representing a number in a specified base to an integer. **Input**: - `str_to_convert` (str): The string representation of the number to be converted. It should only contain valid characters for the specified base. - `base` (int): The base of the given number, ranging from 2 to 36 inclusive. **Output**: - (int): The integer representation of the number. **Constraints**: - You must handle cases where `base` is less than 2 or greater than 36 by returning an appropriate error message or raising an exception. - Handle invalid characters in `str_to_convert` by returning an appropriate error message or raising an exception. # Example Example 1: ```python assert improved_int_to_base(5, 2) == \\"101\\" assert improved_base_to_int(\\"101\\", 2) == 5 ``` Example 2: ```python assert improved_int_to_base(-15, 16) == \\"-F\\" assert improved_base_to_int(\\"-F\\", 16) == -15 ``` Example 3: ```python try: improved_int_to_base(10, 37) except ValueError as e: assert str(e) == \\"Base must be between 2 and 36\\" try: improved_base_to_int(\\"1G\\", 16) except ValueError as e: assert str(e) == \\"Invalid character found for the specified base\\" ``` # Notes 1. Ensure your solutions handle the constraints and edge cases efficiently. 2. Aim for clean, readable code with meaningful error messages for invalid input.","solution":"def improved_int_to_base(num, base): Converts a given integer to a specified base and returns the resulting string. Args: - num (int): The integer to be converted. It can be positive, negative, or zero. - base (int): The base to convert the number to, ranging from 2 to 36 inclusive. Returns: - str: The string representation of the number in the specified base. Raises: - ValueError: If the base is less than 2 or greater than 36. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\\"-\\") return \'\'.join(reversed(result)) def improved_base_to_int(str_to_convert, base): Converts a given string representing a number in a specified base to an integer. Args: - str_to_convert (str): The string representation of the number to be converted. - base (int): The base of the given number, ranging from 2 to 36 inclusive. Returns: - int: The integer representation of the number. Raises: - ValueError: If the base is less than 2 or greater than 36, or if the string contains invalid characters for the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" valid_chars = digits[:base] negative = str_to_convert[0] == \\"-\\" if negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: if char.upper() not in valid_chars: raise ValueError(\\"Invalid character found for the specified base\\") num = num * base + digits.index(char.upper()) return -num if negative else num"},{"question":"# Plus One Problem Given a non-negative number represented as an array of digits, write a function that increments the number by one and returns the resulting array of digits. The most significant digit is stored at the beginning of the array. Input - A list of non-negative integers `digits` representing the non-negative number. - Size of the input list `1 <= len(digits) <= 10^6`. - Each element in `digits` is a single digit (0-9). Output - A list of integers representing the incremented number. Constraints - Do not use in-built number conversion methods. - Implement the solution using O(1) extra space (in-place modification of the list is allowed). # Example ```python plus_one([1,2,3]) # returns [1,2,4] plus_one([9,9,9]) # returns [1,0,0,0] ``` # Requirements 1. Implement an efficient solution handling carries without extra list allocations where possible. 2. Handle an edge case where the number consists entirely of 9s efficiently. 3. The solution should handle the performance requirements for lists up to 10^6 elements efficiently. # Function Signature ```python def plus_one(digits: List[int]) -> List[int]: pass ``` Use the above-provided function signature for your implementation.","solution":"def plus_one(digits): Increments the given non-negative number represented as an array of digits by one. n = len(digits) for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If all digits are 9, we need to add an additional digit at the start return [1] + digits"},{"question":"Implementing a Word Dictionary with Trie Objective Implement an efficient data structure that supports adding and searching for words including support for wildcard searches where the \'.\' character can represent any letter. Description You are required to implement a class `WordDictionary` which supports the following methods: 1. `add_word(word: str)`: Adds a word to the data structure. 2. `search(word: str)`: Returns `True` if there is any string in the data structure that matches the word (including period `.` as a wildcard), otherwise returns `False`. You are expected to use a Trie (prefix tree) for this implementation due to its efficient prefix search properties. Constraints - All input strings consist of lowercase letters `a-z`. - The input strings have a maximum length of 100 characters. - The total number of `add_word` and `search` operations will not exceed 10^4. - The words added to / searched in the dictionary will contain only lowercase alphabetical characters. Example ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` Implementation To solve this, you need to: 1. Create a TrieNode class representing each node in the Trie. 2. Implement the WordDictionary class using TrieNodes. 3. Ensure that `add_word` constructs the Trie properly. 4. Implement `search` to handle both exact matches and wildcard matches. Starter Code ```python class TrieNode: def __init__(self, letter=\\"\\", is_terminal=False): self.letter = letter self.is_terminal = is_terminal self.children = {} class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: pass def search(self, word: str, node=None) -> bool: pass # Example usage: # wd = WordDictionary() # wd.add_word(\\"example\\") # print(wd.search(\\"e.a..le\\")) ``` Write your implementation for `add_word` and `search` methods in the `WordDictionary` class. Make sure to handle edge cases and optimize your search for performance.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_terminal = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_terminal = True def search(self, word: str, node=None) -> bool: if node is None: node = self.root for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self.search(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_terminal"},{"question":"**Question: Find Two Unique Numbers in an Array** Given an array of integers `nums`, where exactly two elements appear only once and all the other elements appear exactly twice, write a function `find_two_unique_numbers(nums)` that identifies and returns the two elements that appear only once. The function should operate with a time complexity of O(N) and a space complexity of O(1). **Constraints**: * The array will have a minimum length of 2. * There will always be exactly two unique numbers. **Input Format**: * An array of integers `nums` where `2 <= len(nums) <= 10^6` and `-10^9 <= nums[i] <= 10^9`. **Output Format**: * A list of two integers representing the unique numbers. The order of the output does not matter. **Example**: Given the input array: `[1, 2, 1, 3, 2, 5]` Expected output: `[3, 5]` or `[5, 3]` **Scenario**: Assume that you are working on a system where you need to identify erroneous entries in a list of data entries that should have occurred in pairs. Your system should efficiently detect these outliers without using additional memory as the computations need to handle large datasets. **Function Signature**: ```python def find_two_unique_numbers(nums: List[int]) -> List[int]: pass ``` **Hints**: * Utilize bitwise operations to identify the two unique elements. * Make sure your solution operates in linear time and constant space.","solution":"def find_two_unique_numbers(nums): Identifies and returns the two elements that appear only once in the array. Parameters: nums (List[int]): An array of integers where exactly two elements appear only once and all other elements appear exactly twice. Returns: List[int]: A list containing the two unique elements. # XOR all the numbers. The result will be the XOR of the two unique numbers. xor_result = 0 for num in nums: xor_result ^= num # Get the rightmost set bit in xor_result. This will be one of the bits where the two numbers differ. rightmost_set_bit = xor_result & -xor_result # Split the numbers into two groups based on the rightmost set bit and XOR them separately. num1, num2 = 0, 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"You are provided with two two-dimensional matrices. Write a function to compute their product. If the matrices are not compatible for multiplication, the function should raise an exception. # Function Signature: ```python def matrix_multiply(A: list, B: list) -> list: pass ``` # Input * `A`: A List of Lists representing the first matrix (multiplicand). * `B`: A List of Lists representing the second matrix (multiplier). # Output * A List of Lists representing their product if matrices are compatible. * Raise an exception if matrices are not compatible. # Constraints * Each matrix can have at most 100 x 100 dimensions. * Matrix elements will be integers between -1000 and 1000. # Example ```python A = [ [1, 2], [3, 4] ] B = [ [2, 0], [1, 2] ] matrix_multiply(A, B) # Output: # [ # [4, 4], # [10, 8] # ] ``` # Notes * Ensure your implementation handles edge cases such as: * Empty matrices. * Matrices with incompatible dimensions. * Uniform subarray lengths within each matrix. * Aim to write clean and efficient code and ensure that the function is tested with various edge cases. # Evaluation Your solution will be evaluated on the correctness and efficiency of the implementation. Consider the constraints and input size when optimizing your solution.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. Args: A (list of list of int): First matrix. B (list of list of int): Second matrix. Returns: list of list of int: Resultant matrix after multiplication. Raises: ValueError: If the matrices cannot be multiplied. # Check if A and B are not empty if not A or not A[0] or not B or not B[0]: raise ValueError(\\"Matrices cannot be empty\\") rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) # Check if matrices A and B can be multiplied if cols_A != rows_B: raise ValueError(\\"Matrices have incompatible dimensions for multiplication\\") # Initialize the resulting matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Exchange Sort Optimization Challenge **Scenario**: You are working on optimizing a sorting routine in a legacy system where algorithms are chosen based on specific dataset characteristics. The system currently employs the Exchange Sort algorithm, which is efficient on small arrays due to its simplicity but not suitable for larger datasets. To maintain compatibility and improve performance, a decision has been made to only switch to more advanced sorting algorithms when the array size exceeds a certain threshold. **Task**: Implement a function `optimized_sort(arr)` in Python that incorporates the following: * For arrays of size less than or equal to 10, use the given Exchange Sort algorithm. * For arrays of size greater than 10, implement a more efficient sorting algorithm (like Quick Sort or Merge Sort). **Function Signature**: ```python def optimized_sort(arr: list) -> list: Sorts the given list using a strategy optimized for small and large datasets. :param arr: A list of integers that need to be sorted. :return: A sorted list of integers in non-decreasing order. ``` **Input**: - A list of integers `arr` where 0 ≤ len(arr) ≤ 1000. **Output**: - A sorted list of integers in non-decreasing order. **Constraints**: - Use the provided `exchange_sort` function for arrays of size ≤ 10. - Implement and use Quick Sort or Merge Sort for arrays of size > 10. - Do not use the built-in sorting functions. **Performance Requirements**: - The function should run efficiently within the given input constraints. **Examples**: ```python >>> optimized_sort([5, 2, 9, 1, 5, 6]) >>> [1, 2, 5, 5, 6, 9] >>> optimized_sort([3]) >>> [3] >>> optimized_sort([10, -1, 2, 8, 0, 5, 4]) >>> [-1, 0, 2, 4, 5, 8, 10] >>> optimized_sort([]) >>> [] ``` **Note**: You should submit the complete implementation of the `optimized_sort` function.","solution":"def exchange_sort(arr): Implements the Exchange Sort algorithm. :param arr: A list of integers that need to be sorted. :return: A sorted list of integers in non-decreasing order. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr def merge_sort(arr): Implements the Merge Sort algorithm. :param arr: A list of integers that need to be sorted. :return: A sorted list of integers in non-decreasing order. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. :param left: A sorted list of integers. :param right: A sorted list of integers. :return: A merged sorted list of integers from both input lists. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged def optimized_sort(arr): Sorts the given list using a strategy optimized for small and large datasets. :param arr: A list of integers that need to be sorted. :return: A sorted list of integers in non-decreasing order. if len(arr) <= 10: return exchange_sort(arr) else: return merge_sort(arr)"},{"question":"**Problem Statement:** You are given a string `s` which may contain repeated characters. Your task is to write a Python function `delete_reoccurring_characters(s)` that removes all recurring characters and returns the resulting string while maintaining the order of their first occurrences. # Input: - A string `s` (1 ≤ |s| ≤ 100,000), where |s| is the length of the string. The string can contain any printable ASCII characters. # Output: - A string that includes only the first occurrence of each character from the input string `s` in the order they appear in `s`. # Constraints: - Do not use any built-in Python functions for string deduplication (like `fromkeys` in `OrderedDict`). # Examples: 1. `delete_reoccurring_characters(\\"abracadabra\\")` should return `\\"abrcd\\"`. 2. `delete_reoccurring_characters(\\"google\\")` should return `\\"gole\\"`. 3. `delete_reoccurring_characters(\\"aabaa\\")` should return `\\"ab\\"`. # Requirements: 1. The function should handle edge cases like empty strings, strings with all identical characters, and strings with all unique characters. 2. The performance should be optimized for large input sizes. Therefore, time complexity should be O(n) and space complexity should be effectively managed. # Additional Scenario: Consider a scenario where this function is part of a data preprocessing pipeline for cleaning text before further analysis or storage, ensuring the uniqueness of characters while preserving their order. ```python def delete_reoccurring_characters(s): # your code goes here # Example test cases print(delete_reoccurring_characters(\\"abracadabra\\")) # Output: \\"abrcd\\" print(delete_reoccurring_characters(\\"google\\")) # Output: \\"gole\\" print(delete_reoccurring_characters(\\"aabaa\\")) # Output: \\"ab\\" ```","solution":"def delete_reoccurring_characters(s): Removes all recurring characters from the string s while maintaining the order of their first occurrences. Parameters: s (str): The input string. Returns: str: The string with non-recurring characters. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a singly linked list and need to determine if there is a cycle. If a cycle exists, return the node where the cycle begins. Otherwise, return `None`. Your task is to implement Floyd\'s Cycle-Finding Algorithm to achieve this efficiently. # Function Signature ```python def first_cyclic_node(head: Node) -> Optional[Node]: pass ``` # Input * `head` (Node): The head of a singly linked list. This value may be `None` if the linked list is empty. # Output * Return the node (Node) where the cycle begins. If there is no cycle, return `None`. # Constraints 1. The number of nodes in the list is in the range [0, 10^4]. 2. Each node\'s value is unique up to the first cycle point. # Example ```python # Example 1 # Nodes: A(65) -> B(66) -> C(67) -> D(68) -> E(69) -> C(67) # Return Node: C(67) head = Node(\'A\') head.next = Node(\'B\') cycle_node = Node(\'C\') head.next.next = cycle_node cycle_node.next = Node(\'D\') cycle_node.next.next = Node(\'E\') cycle_node.next.next.next = cycle_node print(first_cyclic_node(head).val) # Output: \'C\' ``` # Note 1. You must accomplish this in O(n) time complexity. 2. You must use O(1) extra space. 3. Assume `Node` class is already defined as: ```python class Node: def __init__(self, x): self.val = x self.next = None ```","solution":"from typing import Optional class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Optional[Node]) -> Optional[Node]: if not head or not head.next: return None slow = head fast = head # Step 1: Determine whether there is a cycle in the list. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # If no cycle is found return None # Step 2: Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Coding Challenge: Validate Partial Sudoku Board **Context**: A popular puzzle game, Sudoku, requires players to fill a 9x9 grid so that each row, column, and each of the nine 3x3 sub-grids contain all of the digits from 1 to 9 exactly once. Your task is to write a function that can validate a partially filled Sudoku board. **Objective**: Implement a function `is_valid_partial_sudoku(board: List[List[int]]) -> bool` that checks whether the provided partially filled 9x9 Sudoku board is valid. A valid Sudoku board means: - Each number (1-9) must appear only once per row. - Each number (1-9) must appear only once per column. - Each number (1-9) must appear only once in each of the nine 3x3 sub-grids. - Zeros (`0`) in the board are considered placeholders and can ignore the unique number constraint. **Input**: - `board`: a 2D list of integers representing the partially filled Sudoku board (9x9 grid). **Output**: - Return `True` if the board is a valid partial solution according to the rules above; otherwise, return `False`. **Constraints**: - The board is always a 9x9 grid. - Elements of the board are integers from 0 to 9. **Example**: ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] assert is_valid_partial_sudoku(board) == True ``` # Fulfillment: - Iterate through rows and columns ensuring uniqueness of non-zero numbers. - Verify 3x3 sub-grids contain unique non-zero numbers. - Return the solution as `True` or `False`.","solution":"from typing import List def is_valid_partial_sudoku(board: List[List[int]]) -> bool: def is_unique(nums): nums = [num for num in nums if num != 0] return len(nums) == len(set(nums)) # Check rows and columns for i in range(9): if not is_unique(board[i]): # Check row return False if not is_unique([board[x][i] for x in range(9)]): # Check column return False # Check 3x3 sub-grids for i in range(0, 9, 3): for j in range(0, 9, 3): grid = [] for x in range(3): for y in range(3): grid.append(board[i + x][j + y]) if not is_unique(grid): return False return True"},{"question":"# Elias Gamma and Delta Encoding Algorithms Problem Statement You are tasked with implementing two encoding algorithms for compressing positive integers: Elias Gamma encoding and Elias Delta encoding. Each encoded value must follow specific rules: 1. **Elias Gamma Encoding**: - Calculate the unary representation of `1 + floor(log2(x))`. - Calculate the binary representation of `x - 2^floor(log2(x))`. - Concatenate the unary and binary parts to form the final encoded string. 2. **Elias Delta Encoding**: - Calculate the Elias Gamma encoding of `1 + floor(log2(x))`. - Calculate the binary representation of `x - 2^floor(log2(x))`. - Concatenate the Elias Gamma and binary parts to form the final encoded string. Input Format - **Function Signature**: ```python def elias_gamma(x: int) -> str: def elias_delta(x: int) -> str: ``` - `x` is a positive integer in the range `1 ≤ x ≤ 10^9`. Output Format - `elias_gamma(x)` and `elias_delta(x)` should return the respective encoded string of `x`. Constraints - You must handle edge cases, such as the smallest positive integers. - Make sure that your code efficiently handles the upper-bound constraint to avoid performance issues. Sample Input and Output - **Sample Input 1**: ```python elias_gamma(5) ``` **Sample Output 1**: ```python \\"11001\\" ``` - **Sample Input 2**: ```python elias_delta(10) ``` **Sample Output 2**: ```python \\"11010010\\" ``` Notes - Elias Gamma Encoding for `x = 5`: - `log2(5) = 2`, Unary of `3` (2+1) is \\"110\\". - Binary of `5 - 2^2` is \\"01\\". - Concatenated, the encoded string is \\"11001\\". - Elias Delta Encoding for `x = 10`: - `log2(10) = 3`, Elias Gamma of `4` (3+1): Unary of `3` \\"110\\" + Binary of `4-2^2` \\"00\\" gives \\"11000\\". - Binary of `10 - 2^3` is \\"010\\". - Concatenated, the encoded string is \\"11010010\\". Implement the two encoding functions `elias_gamma` and `elias_delta` as described above.","solution":"import math def elias_gamma(x: int) -> str: if x <= 0: raise ValueError(\\"Input must be a positive integer.\\") if x == 1: # Special case for 1 return \\"1\\" N = int(math.log2(x)) # Unary part (1 + floor(log2(x))) unary_part = \'0\' * N + \'1\' # Binary part (x - 2^floor(log2(x))) binary_part = f\\"{x - (1 << N):0{N}b}\\" return unary_part + binary_part def elias_delta(x: int) -> str: if x <= 0: raise ValueError(\\"Input must be a positive integer.\\") if x == 1: # Special case for 1 return \\"1\\" N = int(math.log2(x)) L = N + 1 # Elias Gamma encoding of (1 + floor(log2(x))) elias_gamma_result = elias_gamma(L) # Binary part (x - 2^floor(log2(x))) binary_part = f\\"{x - (1 << N):0{N}b}\\" return elias_gamma_result + binary_part"},{"question":"# Question: Cholesky Decomposition Implementation Context You are a software engineer in a company that requires an efficient method to solve systems of linear equations. During your implementation of various numerical methods, you realize that using Cholesky decomposition can largely benefit your computations when dealing with Hermitian positive-definite matrices. You decide to implement this algorithm, but you also need to ensure that your code handles edge cases effectively. Problem Statement Write a Python function `cholesky_decomposition(A)` that takes a Hermitian positive-definite matrix `A` (represented as a list of lists) and returns its Cholesky decomposition as a lower triangular matrix. The function should return `None` if the matrix `A` is not Hermitian, not positive-definite, or not square. Function Signature ```python def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: ``` Input - `A`: a list of lists representing a Hermitian positive-definite matrix of size (n times n). Output - Returns the lower triangular matrix resulting from the Cholesky decomposition of `A`. If `A` cannot be decomposed, return `None`. Constraints - `2 <= n <= 1000` - Elements of `A` are floating-point numbers. Examples 1. Example input and output: ```python A = [[4, 12, -16], [12, 37, -43], [-16, -43, 98]] output = [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]] ``` 2. Edge Case: ```python A = [[1, 2], [3, 4]] output = None # because the matrix is not positive-definite ``` Requirements - Ensure the input matrix `A` is first checked for being Hermitian and positive-definite. - Handle floating point precision issues where necessary. - Your solution should aim to have a time complexity of (O(n^3)) and space complexity of (O(n^2)), suitable for typical (n) values up to 1000.","solution":"from typing import List, Optional import math def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: Performs the Cholesky decomposition of a given Hermitian positive-definite matrix A. Parameters: A (List[List[float]]): A Hermitian positive-definite matrix of size n x n. Returns: Optional[List[List[float]]]: The lower triangular matrix resulting from the Cholesky decomposition of A, or None if the matrix cannot be decomposed. n = len(A) # Initial check if the matrix is square for row in A: if len(row) != n: return None # Initialize L with zeros L = [[0.0] * n for _ in range(n)] # Cholesky decomposition algorithm for i in range(n): for j in range(i + 1): sum = 0.0 if j == i: # Diagonal elements for k in range(j): sum += L[j][k] * L[j][k] if A[j][j] - sum <= 0: return None # Not positive-definite L[j][j] = math.sqrt(A[j][j] - sum) else: for k in range(j): sum += L[i][k] * L[j][k] if L[j][j] == 0: return None # Division by zero L[i][j] = (A[i][j] - sum) / L[j][j] return L"},{"question":"**Objective**: Write a function that determines if a given binary tree is symmetric. Implement both a recursive and an iterative approach to solve this problem. Your solution should handle edge cases effectively and optimize performance where possible. **Scenario**: You are working with a visualizer for trees, and part of your task is to check if the visualized binary trees exhibit symmetrical properties. Your visualizer will call the provided functions to validate the symmetry. **Function Signature**: ```python def is_symmetric(root) -> bool: # Recursive approach def is_symmetric_iterative(root) -> bool: # Iterative approach ``` # Input Format - `root`: A TreeNode representing the root of the binary tree. TreeNode is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output Format - Return `True` if the tree is symmetric, otherwise return `False`. # Constraints - The number of nodes in the tree is in the range [0, 1000]. - The value of each node is an integer in the range [-100, 100]. # Performance Requirements - Solutions should run in O(n) time complexity. - Space complexity should be optimized for both recursive and iterative solutions. # Example ```python # Given the binary tree: # 1 # / # 2 2 # / / # 3 4 4 3 # Construct the tree: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(4) root.right.right = TreeNode(3) # Expected Output: print(is_symmetric(root)) # Output: True print(is_symmetric_iterative(root)) # Output: True ``` Complete the implementations for both approaches.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root) -> bool: def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right) if root else True from collections import deque def is_symmetric_iterative(root) -> bool: if not root: return True queue = deque([(root.left, root.right)]) while queue: left, right = queue.popleft() if not left and not right: continue if not left or not right or left.val != right.val: return False queue.append((left.left, right.right)) queue.append((left.right, right.left)) return True"},{"question":"# Problem Context Imagine you are working on a problem related to combinatorial generation of numbers. One of the common tasks includes generating the next higher permutation of numbers. # Problem Statement Write a function `next_higher_permutation(n: int) -> int` that takes a positive integer `n` and returns the next higher number using the exact same set of digits as `n`. If no such permutation exists, return `-1`. # Input and Output * **Input**: A single integer `n` where `1 <= n <= 10^9`. * **Output**: A single integer representing the next higher permutation, or `-1` if no such permutation exists. # Constraints * The input number will always be a positive integer. * The solution must handle numbers up to 1 billion efficiently. # Examples 1. `next_higher_permutation(38276) -> 38627` 2. `next_higher_permutation(12345) -> 12354` 3. `next_higher_permutation(99999) -> -1` 4. `next_higher_permutation(5) -> -1` 5. `next_higher_permutation(1528452) -> 1528524` # Implementation Notes * Carefully handle edge cases like single-digit numbers, numbers composed of identical digits, and numbers already in descending order. * Consider starting with converting the number to its digit list for easier manipulation.","solution":"def next_higher_permutation(n: int) -> int: digits = list(str(n)) length = len(digits) # Step 1: Find the first digit from the right that is smaller than its subsequent digit i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, return -1 if i == -1: return -1 # Step 2: Find the smallest digit on the right side of (i) that is larger than digits[i] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence from i+1 to the end of the list digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(digits))"},{"question":"# Zigzag Iterator Implementation Given two lists, implement a `ZigzagIterator` that provides an iterator to traverse the elements of the given lists in a zigzag manner. The ZigzagIterator should support the following methods: - **`__init__(self, v1: List[int], v2: List[int])`**: Initializes the object with two lists. - **`next(self) -> int`**: Returns the next element in the zigzag traversal. - **`has_next(self) -> bool`**: Returns `True` if there are remaining elements to iterate; otherwise `False`. Example: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` Constraints: - The number of elements in both lists: `0 <= len(v1) + len(v2) <= 1000` - Each list element\'s value: `-1000 <= v1[i], v2[i] <= 1000` # Your Task Implement the `ZigzagIterator` class as described above. Ensure it correctly handles edge cases and performs efficiently with the given constraints.","solution":"from collections import deque class ZigzagIterator: def __init__(self, v1, v2): Initializes the object with two lists. self.queue = deque() if v1: self.queue.append((v1, 0)) if v2: self.queue.append((v2, 0)) def next(self): Returns the next element in the zigzag traversal. if self.has_next(): v, index = self.queue.popleft() if index + 1 < len(v): self.queue.append((v, index + 1)) return v[index] else: raise StopIteration def has_next(self): Returns True if there are remaining elements to iterate; otherwise False. return len(self.queue) > 0"},{"question":"**Problem Statement**: You are provided with a list of positive integers, and your task is to implement the `radix_sort` function to sort this list in ascending order. The `radix_sort` should be implemented as described in the provided algorithm analysis. **Function Signature**: ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr` (List[int]): A list of positive integers. **Output**: * Returns a list of integers sorted in ascending order. **Constraints**: * The length of `arr` will not exceed 10^6. * All numbers in `arr` are non-negative and will have no more than 10 digits. **Example**: ```python # Example 1 Input: [170, 45, 75, 90, 802, 24, 2, 66] Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 Input: [3, 1, 4, 1, 5] Output: [1, 1, 3, 4, 5] ``` **Notes**: * Focus on clear, efficient, and correct implementation of the Radix Sort algorithm. * Ensure the function handles edge cases gracefully, such as an empty list or list with elements having different digit lengths.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n # output array to store sorted numbers count = [0] * 10 # count array to store count of occurrences of digits # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] now contains the actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 return output def radix_sort(arr: List[int]) -> List[int]: # Find the maximum number to know number of digits max_num = max(arr, default=0) # Do counting sort for every digit. # The exponent (exp) corresponds to the digit place (1, 10, 100, ...) exp = 1 while max_num // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"**Next Higher Permutation of Digits** In this task, you are given a positive integer. Your goal is to find the next higher number that can be formed by rearranging its digits. If no such higher number exists, return -1. # Requirements: - Write a function `next_higher_permutation(num: int) -> int` that takes an integer `num` and returns the next higher permutation of its digits as an integer. - If no such permutation exists, the function should return -1. # Input: - A single integer `num` where 1 <= `num` <= 10^18. # Output: - The next higher permutation of the digits of `num`, or -1 if no such permutation exists. # Constraints: - You should not use in-built permutation generation functions. - Your solution must handle edge cases such as single digits, repeated digits, and already maximized permutations. # Examples: ```python next_higher_permutation(38276) # returns: 38627 next_higher_permutation(54321) # returns: -1 next_higher_permutation(99999) # returns: -1 next_higher_permutation(12345) # returns: 12354 next_higher_permutation(1528452) # returns: 1528524 ``` # Considerations: - Ensure that your solution is efficient with respect to time and space complexities. - Handle both small and large inputs gracefully. # Notes: Study and utilize the properties of digit permutations efficiently to achieve the solution. Consider leveraging lists for digit manipulation and think about edge cases for optimal performance.","solution":"def next_higher_permutation(num): Find the next higher permutation of digits of a given number. If none exists, return -1. num_str = list(str(num)) length = len(num_str) # Step 1: Identify the first downward trend from the right i = length - 2 while i >= 0 and num_str[i] >= num_str[i + 1]: i -= 1 if i == -1: # no larger permutation is possible return -1 # Step 2: Find the smallest digit on the right side of (i-th digit) # which is larger than num_str[i] j = length - 1 while num_str[j] <= num_str[i]: j -= 1 # Step 3: Swap the found digits num_str[i], num_str[j] = num_str[j], num_str[i] # Step 4: Reverse the digits after the i-th position num_str = num_str[:i+1] + num_str[i+1:][::-1] return int(\'\'.join(num_str))"},{"question":"# Question: You are tasked with verifying the completeness of a transcription system by checking if a given string is a pangram. A pangram is a string that contains every letter of the alphabet at least once. Function Signature ```python def is_pangram(input_string: str) -> bool: # your code here ``` Input * A single string `input_string` containing between `1` and `10^6` characters, which include alphabetical letters, spaces, and punctuation marks. Output * Return `True` if the input string is a pangram. * Return `False` otherwise. Constraints * The function should be case-insensitive. * Non-alphabetic characters should be ignored. Performance Requirements * Your algorithm should run efficiently on large inputs, aiming for a time complexity of O(n). Scenario Imagine you are developing a text editor that flags incomplete data entries. As part of its features, the editor must warn users if their input doesn\'t use the full alphabet. Implement the `is_pangram` function to support this feature effectively. Example ```python assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True assert is_pangram(\\"Hello, World!\\") == False assert is_pangram(\\"Pack my box with five dozen liquor jugs\\") == True ``` Write your code in the provided function signature, ensuring it handles edge cases and performs optimally for the constraints given.","solution":"def is_pangram(input_string: str) -> bool: Checks if the input string is a pangram. A pangram is a string that contains every letter of the alphabet at least once. This function ignores case and non-alphabetical characters. # Create a set of all the letters of the alphabet alphabet = set(\\"abcdefghijklmnopqrstuvwxyz\\") # Create a set to keep track of the letters found in the input string letters_found = set() # Traverse the input string and add each letter to the set for char in input_string.lower(): if char in alphabet: letters_found.add(char) # Check if we have found all the letters in the alphabet return letters_found == alphabet"},{"question":"# Strong Password Checker You need to implement a function `strong_password(n, password)` that determines the minimum number of characters Louise must add to a given password to make it strong. Criteria for Password Strength: 1. It must be at least 6 characters long. 2. It must contain at least one digit (0-9). 3. It must contain at least one lowercase English character (a-z). 4. It must contain at least one uppercase English character (A-Z). 5. It must contain at least one special character from the set: `!@#%^&*()-+`. Your function should take two parameters: - `n` (int): the length of the given password. - `password` (string): the actual password string. The function should return an integer representing the minimum number of characters to add to make the password strong. Input/Output Format: * **Input**: - An integer `n` denoting the length of the string. - A string `password` of length `n`, representing the initial password. * **Output**: - An integer representing the minimum number of characters needed to make the password strong. Constraints: * The length of the string `n` will be between 1 and 100 (inclusive). Example: 1. **Input**: strong_password(3, \\"Ab1\\") - **Output**: 3 - **Explanation**: Adding characters such as \\"hk\\" can make the password strong (\\"Ab1hk\\"). 2. **Input**: strong_password(11, \\"#Algorithms\\") - **Output**: 1 - **Explanation**: Adding one digit can make the password strong. Edge Cases to Consider: * An empty password. * A password that meets certain conditions but lacks overall length. * A password that already satisfies all conditions except the minimum length. You are expected to: - Validate the presence of each required character type. - Calculate how many characters need to be added to meet the length requirement. - Return the greater of the character type issues or length deficiency. Write your function in Python: ```python def strong_password(n, password): count_error = 0 # Return the minimum number of characters to make the password strong if not any(i.isdigit() for i in password): count_error += 1 if not any(i.islower() for i in password): count_error += 1 if not any(i.isupper() for i in password): count_error += 1 if not any(i in \'!@#%^&*()-+\' for i in password): count_error += 1 return max(count_error, 6 - n) ```","solution":"def strong_password(n, password): Determine the minimum number of characters to add to make the password strong. Password is considered strong if: 1. It has at least 6 characters. 2. It contains at least one digit. 3. It contains at least one lowercase English letter. 4. It contains at least one uppercase English letter. 5. It contains at least one special character from !@#%^&*()-+. Parameters: n (int): Length of the password. password (str): The given password. Returns: int: Minimum number of characters needed to add to make the password strong. missing_types = 0 if not any(char.isdigit() for char in password): missing_types += 1 if not any(char.islower() for char in password): missing_types += 1 if not any(char.isupper() for char in password): missing_types += 1 if not any(char in \\"!@#%^&*()-+\\" for char in password): missing_types += 1 return max(missing_types, 6 - n)"},{"question":"# Word Transformation Path Finder You are given two words (`begin_word` and `end_word`), and a dictionary (`word_list`). Write a function `ladder_length` to find the length of the shortest transformation sequence from `begin_word` to `end_word`, such that: 1. Only one letter can be changed at a time. 2. Each intermediate word must exist in the word list. **Example:** Given: ```plaintext begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] ``` As one of the shortest transformations could be `\\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\"`, return its length: `5`. **Notes:** - Return `-1` if there is no such transformation sequence. - All words have the same length. - All words contain only lowercase alphabetic characters. ```python def ladder_length(begin_word, end_word, word_list): # Your code here pass # Example usage: begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] print(ladder_length(begin_word, end_word, word_list)) # Output should be 5 ``` # Constraints: - The length of `begin_word` is equal to the length of `end_word`. - `word_list` contains no duplicates. - Use bidirectional BFS to implement your solution for optimized performance. - Consider edge cases such as when no transformation is possible or when `begin_word` matches `end_word`.","solution":"from collections import deque def ladder_length(begin_word, end_word, word_list): if end_word not in word_list: return -1 word_set = set(word_list) begin_set = set([begin_word]) end_set = set([end_word]) visited = set() transformed = set() length = 1 while begin_set and end_set: # Always expand the smaller set for better performance if len(begin_set) > len(end_set): begin_set, end_set = end_set, begin_set next_level_set = set() for word in begin_set: for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': transformed = word[:i] + c + word[i+1:] if transformed in end_set: return length + 1 if transformed in word_set and transformed not in visited: next_level_set.add(transformed) visited.add(transformed) begin_set = next_level_set length += 1 return -1"},{"question":"# Anagram Validation Enhancement Context You are given two strings and need to determine if one string can be rearranged to form the other, considering case sensitivity and a full Unicode character set. Problem Statement Write a function `check_anagram(s1: str, s2: str) -> bool` that returns `True` if `s1` is an anagram of `s2`, and `False` otherwise. Your solution should optimize for performance while ensuring it works for any Unicode characters, not just lowercase English letters. Input/Output Format - **Input**: - `s1` (string): The first string. - `s2` (string): The second string. - **Output**: - Returns a boolean `True` if `s1` is an anagram of `s2`, otherwise `False`. Constraints - Length of `s1` and `s2`: 0 <= len(s1), len(s2) <= 10^5 - Supports full Unicode character set including special characters. - Case-sensitive (i.e., \'a\' is different from \'A\'). Example ```python assert check_anagram(\\"a\\", \\"a\\") == True assert check_anagram(\\"a\\", \\"A\\") == False assert check_anagram(\\"apple\\", \\"pleap\\") == True assert check_anagram(\\"apple\\", \\"pleap \\") == False ``` Performance Requirements - Aim for O(n) time complexity, where n is the length of the strings. - Space complexity should remain efficient despite accommodating for a larger character set.","solution":"from collections import Counter def check_anagram(s1: str, s2: str) -> bool: Returns True if s1 is an anagram of s2, otherwise False. if len(s1) != len(s2): return False return Counter(s1) == Counter(s2)"},{"question":"# Context Imagine you are working on a low-level system optimization, and you need to manipulate the binary representation of an integer to maximize sequences of contiguous 1s. This kind of operation is crucial in memory management, error detection/correction, or system performance enhancements. # Problem Given an integer, you can flip exactly one bit from 0 to 1. Write a function to determine the length of the longest sequence of 1s you could create by flipping one bit from 0 to 1 in the binary representation of the given integer. # Function Signature ```python def flip_bit_longest_seq(num: int) -> int: ``` # Input * An integer `num` (1 ≤ num ≤ 2^31 - 1). # Output * An integer, representing the maximum number of consecutive 1s that can be achieved by flipping exactly one bit from 0 to 1. # Constraints * The integer is a standard 32-bit signed integer. # Examples ```python assert flip_bit_longest_seq(1775) == 8 # Binary: 11011101111 -> Flip one bit -> 11011111111 (8 consecutive 1s) assert flip_bit_longest_seq(7) == 4 # Binary: 111 -> Flip one bit -> 1111 (4 consecutive 1s) ``` # Requirements * Your solution should be optimal in terms of both time and space complexity considering the constraints.","solution":"def flip_bit_longest_seq(num: int) -> int: Function that returns the length of the longest sequence of 1s that can be achieved by flipping exactly one bit from 0 to 1 in the binary representation of num. # Case when all bits are already set if ~num == 0: return 32 current_length = 0 previous_length = 0 max_length = 1 # We can always have at least one 1 by flipping a bit while num != 0: if (num & 1) == 1: # Current bit is 1 current_length += 1 else: # Current bit is 0 # Update the previous_length to current_length if the next bit is 1 previous_length = current_length if (num & 2) != 0 else 0 current_length = 0 # Max length of sequence with possible flip max_length = max(previous_length + current_length + 1, max_length) # Shift num to the right by 1 bit num >>= 1 return max_length"},{"question":"Binary Tree Inorder Traversal # Scenario You are implementing a system that processes various data stored in a binary tree structure. As part of the preparation, you need to retrieve and process these data in a specific order. The order required for processing is an inorder traversal of the binary tree, which ensures that nodes are retrieved in non-decreasing order for Binary Search Trees (BST). # Task Write a function `inorder_traversal` that takes the root node of a binary tree and returns a list of node values in an inorder sequence. # Input - `root`: The root node of the binary tree (of type `Node`), or `None` if the tree is empty. # Output - A list of integers representing the node values in inorder sequence. # Constraints - Assume all node values are integers. - The tree can have up to 10,000 nodes. - The depth of the tree will not exceed 1,000. # Requirements 1. You must implement both an iterative and a recursive version of the inorder traversal. 2. Both versions should be part of the final solution, and the results from both should match. 3. Use the given `Node` class for tree nodes. # Function Skeleton ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): def inorder_iterative(root): Iterative inorder traversal implementation # Your code here def inorder_recursive(root): Recursive inorder traversal implementation # Your code here # Ensure both approaches produce the same result iterative_result = inorder_iterative(root) recursive_result = inorder_recursive(root) assert iterative_result == recursive_result, \\"Iterative and Recursive outputs do not match\\" return iterative_result # Example Usage if __name__ == \\"__main__\\": n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(inorder_traversal(n1)) # Output: [25, 50, 75, 100, 125, 150, 175] ``` # Notes - Your solutions should be able to handle the maximum constraints efficiently. - Make sure to include edge cases such as an empty tree or tree with single nodes in your tests.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): def inorder_iterative(root): Iterative inorder traversal implementation stack, result = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root): Recursive inorder traversal implementation result = [] def helper(node): if node: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result # Ensure both approaches produce the same result iterative_result = inorder_iterative(root) recursive_result = inorder_recursive(root) assert iterative_result == recursive_result, \\"Iterative and Recursive outputs do not match\\" return iterative_result"},{"question":"# Problem Description: You need to redesign a Priority Queue class that supports efficient push and pop operations for large datasets. The current approach uses a linear array for storage and has inefficient insertion operations. # Requirements: 1. Refactor the existing `PriorityQueue` class to optimize the insertion operation. 2. The new implementation should ensure a time complexity of (O(log n)) for insertion and extraction operations. 3. Use a binary heap (min-heap) structure for better performance. # Input and Output Format: * **Input**: - Method: `__init__`: initializes an empty priority queue. - Method: `push(item, priority)`: adds `item` to the queue with specified `priority`. - Method: `pop()`: removes and returns the item with the smallest priority. - Method: `size()`: returns the current size of the queue. * **Output**: - `__repr__()` method should provide a string representation of the priority queue. # Constraints: 1. `push` and `pop` methods should both run in (O(log n)) time complexity. 2. Handle the situations where pop is called on an empty queue by raising an appropriate error. # Scenario: Consider a task scheduling system where tasks have different priorities. You want to efficiently handle the addition and execution of tasks using the new improved `PriorityQueue` class to optimize performance and ensure timely processing of high-priority tasks. # Implementation Challenge: Refactor the given PriorityQueue class to meet the above requirements. Implement the necessary changes for the methods to utilize a binary heap while maintaining the priority order properly. # Example: ```python pq = PriorityQueue() pq.push(\\"Task1\\", 1) pq.push(\\"Task2\\", 3) pq.push(\\"Task3\\", 2) assert pq.pop() == \\"Task1\\" # Task1 has the smallest priority assert pq.size() == 2 assert pq.pop() == \\"Task3\\" # Now Task3 has the smallest priority after Task1 is removed assert pq.pop() == \\"Task2\\" ``` Implement your solution for the improved PriorityQueue class.","solution":"import heapq class PriorityQueue: def __init__(self): Initializes an empty priority queue. self._heap = [] self._count = 0 def push(self, item, priority): Adds `item` to the queue with specified `priority`. heapq.heappush(self._heap, (priority, self._count, item)) self._count += 1 def pop(self): Removes and returns the item with the smallest priority. if self.is_empty(): raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self._heap)[2] def size(self): Returns the current size of the queue. return len(self._heap) def is_empty(self): Checks if the priority queue is empty. return len(self._heap) == 0 def __repr__(self): return f\\"PriorityQueue({self._heap})\\""},{"question":"Scenario Suppose you are managing a software that frequently needs to modify stacks by switching successive pairs of elements. The stack could represent a wide range of ordered structures such as jobs to be processed, historical data, or even memory addresses. Task Implement a function `switch_pairs` that takes a single stack as input and switches successive pairs starting from the bottom. If there\'s an odd number of elements, the top element should remain in its original position. Specifications - **Function Signature**: `def switch_pairs(stack: list) -> list` - **Input**: - `stack` (list of integers): The stack representation where the last element is the top of the stack. - **Output**: - (list of integers): The stack after switching successive pairs of elements. - **Constraints**: - You may only use one auxiliary stack or one auxiliary queue. - You must not use external libraries for stack or queue implementation apart from Python\'s `collections.deque`. Performance Requirements - Your implementation should have O(n) time complexity, where n is the number of elements in the stack. - The space complexity should be O(n). Example ```python # Example 1: stack = [3, 8, 17, 9, 1, 10] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] # Example 2: stack = [3, 8, 17, 9, 1] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 1] # Example 3: stack = [] print(switch_pairs(stack)) # Output: [] # Example 4: stack = [10] print(switch_pairs(stack)) # Output: [10] ``` Use the above analysis and examples to guide your solution, taking special note of edge cases, performance constraints, and the clear specification of inputs/outputs.","solution":"def switch_pairs(stack): Switches successive pairs of elements in the given stack. If there\'s an odd number of elements, the top element stays in its original position. Args: stack (list): The input stack where the end element is the top of the stack. Returns: list: A stack with successive pairs of elements swapped. aux_stack = [] n = len(stack) for i in range(0, n - 1, 2): aux_stack.append(stack[i + 1]) aux_stack.append(stack[i]) if n % 2 != 0: aux_stack.append(stack[-1]) return aux_stack"},{"question":"# Binary Search - Range Query Objective Implement a function that performs a binary search on a sorted array but with a slight twist – instead of looking for a single value, return all the indices of elements that are within a specified range `[low, high]`. The implementation should be efficient and leverage the characteristics of binary search. Task Write a function `range_query(array, low_val, high_val)` that takes in a sorted array of integers, a lower bound, and an upper bound. The function should return a list of all indices where the array elements are within the range `[low_val, high_val]`. Requirements * **Input**: * `array` (List[int]): A non-decreasing sorted list of integers. * `low_val` (int): The lower bound of the range. * `high_val` (int): The upper bound of the range. * **Output**: * List[int]: A list containing indices of elements within the range `[low_val, high_val]`. Constraints * All elements in the array are unique. * The array length will be at most `10^6`. * `-10^9 <= low_val, high_val <= 10^9` Example ```python # Example 1 array = [1, 3, 5, 7, 9, 11, 13, 15] low_val = 4 high_val = 10 # Output: [2, 3, 4] # Explanation: The indices of the elements within the range [4, 10] are 2->5, 3->7, 4->9 # Example 2 array = [1, 2, 3, 4, 5] low_val = 6 high_val = 8 # Output: [] # Explanation: No elements fall within the range [6, 8] ``` Guidelines * Implement the function efficiently to handle large arrays, leveraging binary search principles. * Consider edge cases such as empty arrays, non-overlapping ranges, and values outside the array bounds.","solution":"from typing import List def range_query(array: List[int], low_val: int, high_val: int) -> List[int]: Returns a list of indices where the array elements are within the range [low_val, high_val]. def find_first_gte(array: List[int], val: int) -> int: left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left def find_last_lte(array: List[int], val: int) -> int: left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] > val: right = mid else: left = mid + 1 return left - 1 start = find_first_gte(array, low_val) end = find_last_lte(array, high_val) if start <= end: return list(range(start, end + 1)) return []"},{"question":"# Question: Single Number Identification Using Bitwise Operations You are given an array of integers where every element appears exactly three times, except for one element which appears exactly once. Write a function to find and return the single element that appears only once. Your algorithm should have a linear runtime complexity and should not use extra memory beyond a constant amount. **Input**: - an array of integers `nums` where 1 <= len(nums) <= 3 * 10^4 and each integer appears exactly three times except for one which appears once. **Output**: - an integer representing the element that appears only once. **Function Signature**: ```python def single_number(nums: list[int]) -> int: pass ``` **Example**: ```python assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` **Constraints**: - The input array will always have a valid single element that appears once. - The algorithm should run in O(N) time and use O(1) extra space. Use the provided algorithm principles to craft your solution, ensuring to handle common edge cases and perform bitwise operations for efficiency.","solution":"def single_number(nums: list[int]) -> int: This function finds and returns the single element that appears only once in the list where every other element appears exactly three times. # Initialize variables to store bits one = 0 # Stores bits which have appeared `1 + 2k` times two = 0 # Stores bits which have appeared `2 + 3k` times # Iterate over each number in the array for num in nums: # Update `two` with bits which are in `one` and also in the current `num` two |= one & num # Update `one` with XOR of the current `num` one ^= num # Get the common bits which have appeared three times common_bit_mask = ~(one & two) # Remove the common bits from `one` and `two` one &= common_bit_mask two &= common_bit_mask # The remaining bits in `one` represent the single number return one"},{"question":"# Description Given an array of integers, implement a `Fenwick Tree (Binary Indexed Tree)` data structure that supports the following operations: 1. **Update**: Update the value of a specified element in the array. 2. **Range Sum Query**: Compute the sum of the elements in a given range. # Function Signatures * `def range_sum(self, start: int, end: int) -> int`: - **Input**: Two integers `start` and `end` indicating the start and end of the range (inclusive). - **Output**: Integer sum of the elements in the specified range. * `def update(self, index: int, value: int)`: - **Input**: An integer `index` indicating the position of the element to update and an integer `value` representing the new value. # Example ```python # Example usage: freq = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] bit = Fenwick_Tree(freq) # Original Range Sum from 1 to 6 (0-indexed array) assert bit.range_sum(1, 6) == 13 # Update element at index 3 from 6 to 1 bit.update(3, 1) # Range Sum from 1 to 6 after update assert bit.range_sum(1, 6) == 8 ``` # Constraints * The input array will have at least one element and at most (10^5) elements. * The values in the array and the updated values are in the range of -(10^4) to (10^4). * The `start` and `end` indices will always be valid and `start <= end`. # Implementation Complete the missing methods `range_sum` and `update` in the `Fenwick_Tree` class provided. ```python class Fenwick_Tree(object): def __init__(self, freq): self.arr = freq self.n = len(freq) self.bit_tree = self.construct() def get_sum(self, bit_tree, i): s = 0 i = i+1 while i > 0: s += bit_tree[i] i -= i & (-i) return s def update_bit(self, bit_tree, i, v): i += 1 while i <= self.n: bit_tree[i] += v i += i & (-i) def construct(self): bit_tree = [0] * (self.n + 1) for i in range(self.n): self.update_bit(bit_tree, i, self.arr[i]) return bit_tree def range_sum(self, start: int, end: int) -> int: Implement the range sum query method here pass def update(self, index: int, value: int): Implement the update method here pass ```","solution":"class Fenwick_Tree(object): def __init__(self, freq): self.arr = freq self.n = len(freq) self.bit_tree = self.construct() def get_sum(self, bit_tree, i): s = 0 i = i+1 while i > 0: s += bit_tree[i] i -= i & (-i) return s def update_bit(self, bit_tree, i, v): i += 1 while i <= self.n: bit_tree[i] += v i += i & (-i) def construct(self): bit_tree = [0] * (self.n + 1) for i in range(self.n): self.update_bit(bit_tree, i, self.arr[i]) return bit_tree def range_sum(self, start: int, end: int) -> int: Compute the sum of the elements in the given range [start, end]. if start == 0: return self.get_sum(self.bit_tree, end) return self.get_sum(self.bit_tree, end) - self.get_sum(self.bit_tree, start - 1) def update(self, index: int, value: int): Update the value at the specified index to the given value. delta = value - self.arr[index] self.arr[index] = value self.update_bit(self.bit_tree, index, delta)"},{"question":"You are given an (n times n) adjacency matrix `adjacency_matrix` where `adjacency_matrix[i][j]` represents the weight of the edge from node (i) to node (j). If there is no direct edge between nodes (i) and (j), the cell `adjacency_matrix[i][j]` is set to infinity. Write a function `all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]` that takes this adjacency matrix as input and returns a new matrix where `result[i][j]` represents the shortest path from node (i) to node (j). # Input - `adjacency_matrix`: A list of lists of floats where (n) is the number of nodes in the graph ( (1 leq n leq 100) ). # Output - Returns a list of lists of floats with the same dimensions as the input `adjacency_matrix` where each cell contains the shortest path distance. # Constraints - The graph may contain negative edges but no negative weight cycles. - If there is no path between two nodes, the corresponding cell in the output matrix should remain infinity. # Example ```python adjacency_matrix = [ [0, 0.1, 0.101, 0.142, 0.277], [0.465, 0, 0.191, 0.192, 0.587], [0.245, 0.554, 0, 0.333, 0.931], [1.032, 0.668, 0.656, 0, 0.151], [0.867, 0.119, 0.352, 0.398, 0] ] assert all_pairs_shortest_path(adjacency_matrix) == [ [0, 0.1, 0.101, 0.142, 0.277], [0.436, 0, 0.191, 0.192, 0.343], [0.245, 0.345, 0, 0.333, 0.484], [0.706, 0.27, 0.461, 0, 0.151], [0.555, 0.119, 0.31, 0.311, 0] ] ``` # Notes - You should use deep copy to make sure the original adjacency matrix is not modified. - Your solution should have a time complexity of (O(n^3)) and a space complexity of (O(n^2)).","solution":"from typing import List import copy def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: # Number of nodes n = len(adjacency_matrix) # Initialize the result matrix with a deep copy of the adjacency matrix result = copy.deepcopy(adjacency_matrix) # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): # Update the shortest path from i to j through k if result[i][k] + result[k][j] < result[i][j]: result[i][j] = result[i][k] + result[k][j] return result"},{"question":"You are given a sorted list of integers. Your task is to write a function `find_keywords_positions(keywords: List[int], search_list: List[int]) -> List[int]` that uses the Interpolation Search algorithm to determine the positions of multiple search keys in the list. The function should return a list of indices corresponding to the positions of the search keys. If a search key is not found, the function should return -1 for that key. # Details * **Input**: * `keywords`: A list of integers representing the search keys. * `search_list`: A list of sorted integers in ascending order where the search is performed. * **Output**: * A list of integers indicating the positions of the search keys in `search_list`. For keys not present, return -1. # Constraints: * The length of `search_list` will not exceed 10^5. * The length of `keywords` will not exceed 10^3. * Each key in `keywords` and each integer in `search_list` will be between -10^6 and 10^6. # Performance: * Ensure the function is efficient with a time complexity close to O(log2(log2 n)) for average cases. # Examples: 1. `find_keywords_positions([10, 20, 30], [1, 5, 10, 20, 25, 30, 40])` should return `[2, 3, 5]`. 2. `find_keywords_positions([5, 15, 25], [1, 10, 20, 30, 40])` should return `[-1, -1, -1]`. 3. `find_keywords_positions([7, 20, 35], [5, 10, 12, 20, 25, 35, 40])` should return `[-1, 3, 5]`. # Implementation Implement the function with the provided inputs and constraints. Optimize the search process by leveraging the properties of the Interpolation Search algorithm. ```python def find_keywords_positions(keywords: List[int], search_list: List[int]) -> List[int]: def interpolation_search(array, search_key): high = len(array) - 1 low = 0 while (low <= high) and (array[low] <= search_key <= array[high]): pos = low + int(((search_key - array[low]) * (high - low) / (array[high] - array[low]))) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1 return [interpolation_search(search_list, key) for key in keywords] # You can run the following tests print(find_keywords_positions([10, 20, 30], [1, 5, 10, 20, 25, 30, 40])) # Should output [2, 3, 5] print(find_keywords_positions([5, 15, 25], [1, 10, 20, 30, 40])) # Should output [-1, -1, -1] print(find_keywords_positions([7, 20, 35], [5, 10, 12, 20, 25, 35, 40])) # Should output [-1, 3, 5] ```","solution":"from typing import List def find_keywords_positions(keywords: List[int], search_list: List[int]) -> List[int]: def interpolation_search(array, search_key): high = len(array) - 1 low = 0 while (low <= high) and (array[low] <= search_key <= array[high]): if array[low] == array[high]: if array[low] == search_key: return low return -1 pos = low + int(((search_key - array[low]) * (high - low) / (array[high] - array[low]))) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1 return [interpolation_search(search_list, key) for key in keywords]"},{"question":"# Regular Expression Matching with Dynamic Programming You are given a string `s` and a pattern `p` where: - `\'.\'` matches any single character. - `\'*\'` matches zero or more of the preceding element. Write a function `is_match(s: str, p: str) -> bool` that returns whether `s` matches the pattern `p` entirely. # Input - `s` (1 <= len(s) <= 1000): A string consisting of lowercase English letters. - `p` (1 <= len(p) <= 1000): A pattern string consisting of lowercase English letters, `\'.\'`, and `\'*\'`. # Output - Return `True` if `s` matches the pattern `p` entirely, otherwise, return `False`. # Constraints - The match should cover the entire input string (not partial). - Ensure the solution runs efficiently even for the maximum input sizes. # Example ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Explanation of Example: 1. `is_match(\\"aa\\", \\"a\\")` returns `False` because \\"a\\" does not match the entire string \\"aa\\". 2. `is_match(\\"aa\\", \\"aa\\")` returns `True` because \\"aa\\" matches the entire string. 3. `is_match(\\"aaa\\", \\"aa\\")` returns `False` because \\"aa\\" does not match the entire string \\"aaa\\". 4. `is_match(\\"aa\\", \\"a*\\")` returns `True` because \\"*\\" matches zero or more of the preceding element \\"a\\". 5. `is_match(\\"aa\\", \\".*\\")` returns `True` because \\".\\" matches any single character and \\"*\\" matches zero or more of the previous character. 6. `is_match(\\"ab\\", \\".*\\")` returns `True` because \\".\\" matches \'a\' and \'*\' matches \'b\'. 7. `is_match(\\"aab\\", \\"c*a*b\\")` returns `True` due to zero or more of preceding `c`, followed by zero or more `a`, and one `b`. Write a function based on given instructions.","solution":"def is_match(s, p): m, n = len(s), len(p) # Create a DP table where dp[i][j] denotes if s[:i] matches p[:j] dp = [[False] * (n + 1) for _ in range(m + 1)] # Base case: empty string matches empty pattern dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* that can match empty string for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Exclude the char and \'*\' (two steps back) for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: # Direct match or match any single char with \'.\' dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # Zero occurrence of the char before \'*\' || one or more occurrence dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1] else False) return dp[m][n]"},{"question":"# Scenario You have been tasked to find an element in an array without using any built-in functions like `index()` for searching. The dataset is small and thus, you decide to use a linear search method, but this time you also need to handle some additional constraints. # Problem Statement Write a function `find_element` that takes three arguments: an integer array `nums`, an integer `query`, and a boolean `multiple_occurrences`. The function should return the index of the query element. If `multiple_occurrences` is `True` and the element occurs more than once, it should return a list of all indices. If the element is not found, return `-1`. # Expected Function Signature ```python def find_element(nums: List[int], query: int, multiple_occurrences: bool) -> Union[int, List[int]]: ``` # Input * `nums`: a list of integers (e.g., `[4, 2, 3, 4]`) * `query`: an integer to search for in the list (e.g., `4`) * `multiple_occurrences`: a boolean flag that indicates whether to consider multiple occurrences or just the first occurrence (e.g., `True`) # Output * If `multiple_occurrences` is `False`, return the index of the first occurrence of `query` (e.g., `0` for the above data and query). * If `multiple_occurrences` is `True`, return a list of all indices where the query element appears (e.g., `[0, 3]`). * Return `-1` if the element is not found. # Constraints * The length of `nums` will always be between `0` and `1000`. * Each element in `nums` will be an integer between `-10^6` and `10^6`. # Example ```python assert find_element([4, 2, 3, 4], 4, False) == 0 assert find_element([4, 2, 3, 4], 4, True) == [0, 3] assert find_element([1, 2, 3], 4, True) == -1 assert find_element([], 4, False) == -1 ```","solution":"from typing import List, Union def find_element(nums: List[int], query: int, multiple_occurrences: bool) -> Union[int, List[int]]: indices = [] for idx, num in enumerate(nums): if num == query: if not multiple_occurrences: return idx indices.append(idx) if not indices: return -1 return indices"},{"question":"You are given a directed graph where each node represents a task, and edges indicate that one task must be completed before another (i.e., if there is a directed edge from node `u` to node `v`, then `u` must be completed before `v`). Implement a function `find_task_order(graph: Dict[int, List[int]]) -> List[int]` that returns a valid order in which to complete the tasks, ensuring that all dependencies are respected. # Function Signature ```python def find_task_order(graph: Dict[int, List[int]]) -> List[int]: pass ``` # Input * `graph`: A dictionary where keys are task identifiers (integers) and values are lists of integers representing tasks that depend on the key task. Example: ```python { 1: [2, 3], 2: [4], 3: [4], 4: [] } ``` # Output * A list of integers representing a valid task order. If no valid order exists (due to a cycle in the graph), the function should raise a `ValueError`. # Constraints * The input graph can have up to 10^5 vertices and 2×10^5 edges. * Each task identifier is a unique integer. # Requirements * Implement an efficient solution with both time complexity O(V + E) and space complexity O(V). * Properly handle cycles in the graph by raising a `ValueError`. # Example Input: ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [] } ``` Output: ```python [1, 2, 3, 4] ``` # Explanation In this example, task `1` must be completed before tasks `2` and `3`, and both `2` and `3` must be completed before task `4`. The valid task order could be `[1, 2, 3, 4]`.","solution":"def find_task_order(graph): Returns a valid order to complete the tasks. This function uses Kahn\'s algorithm for topological sorting. If a cycle is detected, a ValueError is raised. from collections import deque, defaultdict # Calculate in-degree of each node in_degree = defaultdict(int) for node in graph: # Ensure all nodes are in the in-degree dictionary in_degree[node] for neighbor in graph[node]: in_degree[neighbor] += 1 # Initialize queue with nodes that have an in-degree of 0 queue = deque([node for node in in_degree if in_degree[node] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topological_order) == len(graph): return topological_order else: raise ValueError(\\"The graph contains a cycle, no valid task order exists.\\")"},{"question":"# Coding Problem: Enhanced Prim\'s Algorithm **Scenario:** Imagine you are a network engineer tasked with designing a communication network for a new corporate campus. Each building in the campus must be connected to form a network with the minimal total cable length (cost). You have been given the possible connections between buildings and the associated costs. Implement an algorithm to find the minimum cost to connect all the buildings. **Task:** Write a function `prims_minimum_spanning(graph: Dict[str, List[List[int, str]]]) -> int` that calculates the total minimum cost for the network. **Input Format:** * A dictionary `graph` where: - The keys are nodes represented by strings (i.e., building names). - Each value is a list of lists. Each inner list contains two elements: an integer representing the cost to an adjacent building and the adjacent building\'s name. **Output Format:** * An integer representing the total minimum cost to connect all buildings. **Constraints:** * The graph is assumed to be connected, undirected, and have no negative weights. * Each node (building) will be uniquely named. **Example:** ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } assert prims_minimum_spanning(graph) == 14 ``` **Evaluation Criteria:** * Correctness: The function should produce the correct minimum cost. * Efficiency: The solution must be optimized for larger graphs. * Edge Cases: Should handle graphs where every node has at least one edge, and no disconnected nodes.","solution":"import heapq def prims_minimum_spanning(graph): Implement Prim\'s algorithm to find the minimum spanning tree (MST) for the given graph and return the total minimum cost. Parameters: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of lists containing cost and adjacent node. Returns: int: Total minimum cost to connect all buildings. if not graph: return 0 # Initializing the min-heap to choose the edge with the minimum cost pq = [] # Assume the graph is connected, so we can start with any node. Here we start with node \'a\' start_node = list(graph.keys())[0] visited = set([start_node]) # Add initial edges from the start_node to the priority queue for cost, neighbor in graph[start_node]: heapq.heappush(pq, (cost, neighbor)) total_cost = 0 while pq: cost, node = heapq.heappop(pq) if node not in visited: visited.add(node) total_cost += cost # Add all edges from the newly added node to the heap for edge_cost, neighbor in graph[node]: if neighbor not in visited: heapq.heappush(pq, (edge_cost, neighbor)) return total_cost"},{"question":"You are given the root of a binary tree. Implement a function to perform a preorder traversal of the tree and return a list of values in the order they were visited. # Function Signature ```python def preorder_traversal(root: Node) -> List[int]: Returns preorder traversal of the binary tree ``` # Input - A binary tree represented by the root node of type `Node`. - `Node` class is defined as: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` - The binary tree may be empty. # Output - A list of integers representing the preorder traversal of the tree. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes are not unique and range between [-10^5, 10^5]. # Performance Requirements - Ensure that your solution has a time complexity of O(n) and space complexity of O(h) where h is the height of the tree. # Example ```python # Constructing a binary tree: # 1 # / # 2 3 # / # 4 5 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) assert preorder_traversal(root) == [1, 2, 4, 5, 3] ``` # Notes - Be mindful of handling edge cases, such as an empty tree (should return an empty list) or a single-node tree. - Do not use any built-in functions that directly solve the problem.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def preorder_traversal(root: Optional[Node]) -> List[int]: Returns preorder traversal of the binary tree. result = [] def helper(node: Optional[Node]): if node: result.append(node.val) helper(node.left) helper(node.right) helper(root) return result"},{"question":"You are given an array of integers. Implement the Bitonic Sort algorithm to sort the array in non-parallel fashion, either in ascending or descending order based on the arguments provided. # Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input * `arr`: A list of integers which has a length that is a power of two (2, 4, 8, ...). * `reverse`: A boolean indicating whether to sort in descending order (default is ascending order if `False`). # Output * Returns a list of integers sorted in the specified order. # Constraints * The length of the array (len(arr)) will be a power of two and at least 1. * The function should handle arrays of size up to 2**14 (16384). * Should raise a `ValueError` if the length of the array is not a power of two. # Example ```python # Example 1: Ascending Order arr = [3, 7, 4, 8, 6, 2, 1, 5] print(bitonic_sort(arr)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2: Descending Order arr = [3, 7, 4, 8, 6, 2, 1, 5] print(bitonic_sort(arr, reverse=True)) # Output: [8, 7, 6, 5, 4, 3, 2, 1] # Example 3: Invalid Array Size try: arr = [3, 7, 4] print(bitonic_sort(arr)) # Should raise a ValueError except ValueError as e: print(e) # Output: the size of input should be power of two ``` # Performance Requirements * Ensure that the function works efficiently for the given constraints. * Strive for clarity and conciseness in your implementation. # Note You do not need to implement the parallel version of Bitonic Sort. Focus on understanding the sorting mechanism and ensuring that the input size is a power of two.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Sorts an array of integers using the Bitonic Sort algorithm. Parameters: arr (List[int]): A list of integers which has a length that is a power of two. reverse (bool): A boolean indicating whether to sort in descending order (default is ascending order if False). Returns: List[int]: The sorted list of integers. def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (arr[i] > arr[i + k]) == direction: arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) # sort in ascending order bitonic_sort_recursive(arr, low + k, k, False) # sort in descending order bitonic_merge(arr, low, cnt, direction) def is_power_of_two(x): return x and (x & (x - 1)) == 0 if not is_power_of_two(len(arr)): raise ValueError(\\"the size of input should be power of two\\") bitonic_sort_recursive(arr, 0, len(arr), not reverse) return arr"},{"question":"# Factor Combinations Problem Context You are given a positive integer `n`. You need to find all possible combinations of its factors, where each combination\'s product is equal to `n`. Factors must be greater than 1 and less than `n`. Function Signature ```python def get_factor_combinations(n: int) -> List[List[int]]: pass ``` Input - An integer `n` such that `1 <= n <= 2^31 - 1`. You may assume that `n` is always positive. Output - A list of lists, where each sublist contains factors that, when multiplied together, equal `n`. Constraints - Factors should be greater than 1 and less than `n`. - The output list should not contain duplicate sublists. Examples ```python get_factor_combinations(1) # Output: [] get_factor_combinations(37) # Output: [] get_factor_combinations(12) # Output: [ # [2, 6], # [2, 2, 3], # [3, 4] # ] get_factor_combinations(32) # Output: [ # [2, 16], # [2, 2, 8], # [2, 2, 2, 4], # [2, 2, 2, 2, 2], # [2, 4, 4], # [4, 8] # ] ``` Performance Requirements - The algorithm should handle the input constraints efficiently. - Consider edge cases and optimize the recursive or iterative approach to handle large numbers and reduce time complexity as much as possible.","solution":"from typing import List def get_factor_combinations(n: int) -> List[List[int]]: def backtrack(remain, start, path, results): if remain == 1: if len(path) > 1: results.append(path[:]) return for i in range(start, remain + 1): if remain % i == 0: path.append(i) backtrack(remain // i, i, path, results) path.pop() results = [] backtrack(n, 2, [], results) return results"},{"question":"# Context In social networks, identifying clusters of closely connected users can be valuable for community detection, recommendation systems, and more. These clusters can be represented as strongly connected components in a graph where users are nodes and relationships are directed edges. # Problem Statement You are given a directed graph representing a social network. Your task is to implement Tarjan\'s algorithm to find all strongly connected components (SCCs) of the graph. Each user can be part of only one SCC, but there may be multiple SCCs in the graph. # Input * A dictionary `dict_graph` where each key is a node representing a user, and the value is a list of nodes representing users to whom the key user is connected by a directed edge. # Output * A list of lists, where each inner list represents a strongly connected component containing the users in that SCC. # Function Signature ```python def find_sccs(dict_graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` # Constraints * The nodes are represented by unique integers. * Each list of nodes (values in the dictionary) is sorted in ascending order. * The graph may contain up to 10,000 nodes and 50,000 edges. * Self-loops and multiple edges between the same nodes are possible. # Example ```python dict_graph = { 1: [2], 2: [3], 3: [1], 4: [2, 3, 5], 5: [4, 6], 6: [5], 7: [6, 7] } print(find_sccs(dict_graph)) # Expected Output: [[1, 2, 3], [4, 5, 6], [7]] ``` # Notes * Ensure to handle graphs with no connections gracefully. * The strongly connected components should be sorted within each component and the components themselves should be sorted. * Prepare for the case where there may be a large number of nodes and edges.","solution":"from typing import List, Dict def find_sccs(dict_graph: Dict[int, List[int]]) -> List[List[int]]: index = 0 stack = [] indices = {} lowlink = {} on_stack = set() sccs = [] def tarjan(v): nonlocal index indices[v] = index lowlink[v] = index index += 1 stack.append(v) on_stack.add(v) for w in dict_graph.get(v, []): if w not in indices: tarjan(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif w in on_stack: lowlink[v] = min(lowlink[v], indices[w]) if lowlink[v] == indices[v]: scc = [] while True: w = stack.pop() on_stack.remove(w) scc.append(w) if w == v: break scc.sort() sccs.append(scc) for v in dict_graph: if v not in indices: tarjan(v) sccs.sort() return sccs"},{"question":"Scenario You are asked to implement a data structure that allows efficient range queries on a dynamically changing array. For example, you might want to query the sum of elements in a specific range of the array or the maximum value in a different range. Implementing such a data structure efficiently is crucial in many applications, including financial analysis, sensor data processing, and real-time gaming. Task Implement a class `SegmentTree` that supports the following operations: 1. **Construction**: Initializes the segment tree with an array and a function. 2. **Query**: Returns the result of querying a specific range in the array. 3. **Update**: Updates the value at a specific position in the array and propagates the change throughout the segment tree. # Function Descriptions `__init__(self, arr, function)` - **Input**: - `arr`: List of integers (non-empty). - `function`: A binary function (e.g., sum, min, or max) that takes two integers and returns an integer. - **Output**: None `query(self, L, R)` - **Input**: - `L`: Starting index of the range (inclusive). - `R`: Ending index of the range (inclusive). - **Output**: The result of the function applied to the specified range. `update(self, idx, value)` - **Input**: - `idx`: Index of the element to update. - `value`: New value to be placed at index `idx`. - **Output**: None Example Usage ```python # Initialize segment tree with sum function st = SegmentTree([2, 4, 5, 3, 4], sum) # Query sum from index 2 to 4 result = st.query(2, 4) # Expected output: 12 # Update value at index 3 to 10 st.update(3, 10) # Query sum from index 2 to 4 again result = st.query(2, 4) # Expected output: 19 ``` # Constraints - The array will have at least 1 and at most 10^5 elements. - Update and query operations will be called at most 10^5 times. > **Note**: You are expected to handle edge cases where the array might have very large elements or the range queries span almost the entire array. Implementation Tips - Ensure your segment tree is dynamically updating correctly. - Address edge cases in both query and update operations. - Focus on efficient implementation to meet the performance requirements.","solution":"class SegmentTree: def __init__(self, arr, function): Initialize the Segment Tree. :param arr: List of integers. :param function: Binary function (e.g., sum, min, max). self.n = len(arr) self.tree = [0] * (2 * self.n) self.function = function # Build the tree by inserting leaf nodes in tree array for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L, R): Query the function result on the interval [L, R]. :param L: Starting index of the range (inclusive). :param R: Ending index of the range (inclusive). :return: Result of the function applied to the specified range L += self.n R += self.n result = None while L <= R: if L % 2 == 1: # If L is a right child if result is None: result = self.tree[L] else: result = self.function(result, self.tree[L]) L += 1 if R % 2 == 0: # If R is a left child if result is None: result = self.tree[R] else: result = self.function(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result def update(self, idx, value): Update the value at index `idx` in the original array. :param idx: Index of the element to update. :param value: New value to be placed at index `idx`. idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = self.function(self.tree[2 * idx], self.tree[2 * idx + 1])"},{"question":"# Diagonal Sorting of a Matrix Objective You are given an m x n matrix `mat` of integers. Your task is to write a function that sorts each diagonal of the matrix in ascending order from top-left to bottom-right and returns the sorted matrix. Input * A 2D list `mat` of integers, where `mat[i][j]` represents the element in the ith row and jth column. * Constraints: - 1 ≤ m, n ≤ 100 - -10^5 ≤ mat[i][j] ≤ 10^5 Output * Return a 2D list of integers, representing the diagonally sorted matrix. Function Signature ```python def sort_diagonally(mat: List[List[int]]) -> List[List[int]]: ``` Scenario You are working on a grid-based image processing algorithm that requires processing pixel values along diagonals before applying further transformations. Given the matrix of pixel intensities, you need to sort each diagonal to normalize the pixel values along those paths, ensuring smooth transitions in the subsequent processing steps. Example Given the matrix `mat`: ``` mat = [ [3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2] ] ``` Your function should return: ```python [ [1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3] ] ``` Explanation * The diagonal starting from mat[2][0] (1) is already sorted. * The diagonal starting from mat[1][0] (2, 1) is sorted to [1, 2]. * The diagonal starting from mat[0][0] (3, 2, 1) is sorted to [1, 2, 3]. * Other diagonals including those starting from mat[0][1] and onwards are similarly sorted. Note: Ensure you handle edge cases such as very small matrices and perfectly sorted diagonal matrices.","solution":"from typing import List def sort_diagonally(mat: List[List[int]]) -> List[List[int]]: import collections m, n = len(mat), len(mat[0]) diagonals = collections.defaultdict(list) # Collect all values from each diagonal for i in range(m): for j in range(n): diagonals[i - j].append(mat[i][j]) # Sort each diagonal for key in diagonals: diagonals[key].sort() # Write back the sorted values to the matrix for i in range(m): for j in range(n): mat[i][j] = diagonals[i - j].pop(0) return mat"},{"question":"# Question Description You are given a number, and your task is to find the next higher number that has the same set of digits as the original number. If no such number exists (i.e., the given number is the highest possible permutation of its digits), return -1. # Input and Output Format * **Input**: An integer `num`, where `1 <= num <= 10^9`. * **Output**: An integer representing the next permutation or -1 if it does not exist. # Constraints and Performance * Handle up to 9 digits efficiently within linear time complexity. * Solve the problem using in-place digit manipulation where possible. # Scenario Your task will be assessed through various test cases, including edge cases where the number provided has all digits in descending order (e.g., 54321), has repeated digits (e.g., 1223), or is a single digit (e.g., 5). # Example ```python def next_bigger(num): digits = [int(i) for i in str(num)] idx = len(digits) - 1 while idx >= 1 and digits[idx-1] >= digits[idx]: idx -= 1 if idx == 0: return -1 # no such number exists pivot = digits[idx-1] swap_idx = len(digits) - 1 while pivot >= digits[swap_idx]: swap_idx -= 1 digits[swap_idx], digits[idx-1] = digits[idx-1], digits[swap_idx] digits[idx:] = digits[:idx-1:-1] # prefer slicing instead of reversed(digits[idx:]) return int(\'\'.join(str(x) for x in digits)) # Test Cases print(next_bigger(38276)) # Output: 38627 print(next_bigger(54321)) # Output: -1 print(next_bigger(12345)) # Output: 12354 print(next_bigger(999)) # Output: -1 print(next_bigger(5)) # Output: -1 ``` Note: Implement the function `next_bigger(num)` following the provided guidelines and ensure it passes the sample test cases.","solution":"def next_bigger(num): digits = [int(i) for i in str(num)] idx = len(digits) - 1 while idx >= 1 and digits[idx-1] >= digits[idx]: idx -= 1 if idx == 0: return -1 # no such number exists pivot = digits[idx-1] swap_idx = len(digits) - 1 while swap_idx >= 0 and pivot >= digits[swap_idx]: swap_idx -= 1 digits[swap_idx], digits[idx-1] = digits[idx-1], digits[swap_idx] digits[idx:] = digits[idx:][::-1] return int(\'\'.join(str(x) for x in digits))"},{"question":"# Question **Context**: You are given a singly linked list where each node contains a value. In certain contexts, you may need to quickly delete a given node from the list, given direct access to that node. This is a common operation in various applications, such as memory management, custom data structures, and real-time list modifications. **Task**: Write a function `delete_node(node: Node) -> None` that deletes the given node (except the tail) from the singly linked list. **Function Signature**: ```python def delete_node(node: Node) -> None: ``` **Input**: - `node`: An instance of `Node` (part of a singly linked list), which should be deleted. You can assume the node is not the tail. **Output**: - None. The linked list should be directly modified to reflect the deletion. **Constraints**: - The input node will never be `None` and will always be a node in the middle of the list (i.e., it will not be the first or last node). **Example**: Consider a linked list: ```plaintext 1 -> 2 -> 3 -> 4 -> 5 ``` You are given node with value `3`. After calling `delete_node(node)`, the linked list should look like: ```plaintext 1 -> 2 -> 4 -> 5 ``` **Edge Conditions**: - Ensure to raise a `ValueError` if the deletion logic is not possible (provided node is the tail). > **Note**: The list should be modified in place. This means you do not need to return a new list or any value.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def delete_node(node: Node) -> None: Deletes the given node (except the tail) from the singly linked list. if node is None or node.next is None: raise ValueError(\\"Cannot delete the given node or the node is the tail.\\") # Copy the next node\'s data to this node next_node = node.next node.value = next_node.value node.next = next_node.next # Optional: Clear the references of the deleted node next_node.next = None"},{"question":"# Context You have been hired by a tech company to work on data storage and transmission systems. One key task is to ensure that binary tree structures can be efficiently serialized (converted to a string) and deserialized (reconstructed from a string). This capability is crucial for tasks such as saving tree-based data structures to disk or sending them over a network. # Task Implement functions `serialize` and `deserialize` for a binary tree. The `serialize` function should convert the tree into a string representation, and the `deserialize` function should transform the string back into the original tree structure. # Function Signatures ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: # Implement this function pass def deserialize(data: str) -> TreeNode: # Implement this function pass ``` # Input and Output Formats * **serialize:** * **Input**: The root node of a binary tree. * **Output**: A string that represents the pre-order traversal of the tree with null pointers marked by `\\"#\\"`. * **deserialize:** * **Input**: A serialized string representation of a binary tree. * **Output**: The root node of the reconstructed binary tree. **Example:** ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) # Expected output: \'1 2 # # 3 4 # # 5 # #\' deserialized = deserialize(serialized) # Expected output: the root node of the tree reconstructed from the string \'1 2 # # 3 4 # # 5 # #\' ``` # Constraints 1. The number of nodes in the tree will be in the range `[0, 10^4]`. 2. The values of the nodes are integers in the range `[-1000, 1000]`. # Performance Requirements The functions should be optimized to handle large trees efficiently with regard to both time and space.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def rserialize(node): A recursive helper function for the serialize() function. if node is None: return \\"#\\" return str(node.val) + \\" \\" + rserialize(node.left) + \\" \\" + rserialize(node.right) return rserialize(root) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def rdeserialize(l): A recursive helper function for the deserialize() function. if l[0] == \\"#\\": l.pop(0) return None root = TreeNode(int(l[0])) l.pop(0) root.left = rdeserialize(l) root.right = rdeserialize(l) return root data_list = data.split() root = rdeserialize(data_list) return root"},{"question":"# Question: Integer Decomposition Context: You are tasked with finding the number of ways a given positive integer can be decomposed into summands of smaller or equal positive integers. This problem finds applications in combinatorics and resource distribution. Problem Statement: Write a function `integer_decomposition(n: int) -> int` that takes an integer `n` and returns the number of ways to decompose it into summands of smaller or equal positive integers. Input and Output Format: * **Input**: A single integer `n` (1 ≤ n ≤ 100) * **Output**: A single integer, the number of possible decompositions. Constraints: * The function should handle values where `1 ≤ n ≤ 100`. * The solution should use dynamic programming to ensure optimal performance. Example: 1. **Input**: `n = 4` **Output**: `5` **Explanation**: ``` 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` 2. **Input**: `n = 7` **Output**: `15` **Explanation**: ``` 7 = 7 7 = 6 + 1 7 = 5 + 2 ... 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Implementation: Implement the function as specified, keeping in mind dynamic programming principles to optimize performance. ```python def integer_decomposition(n: int) -> int: arr = [[0 for _ in range(n + 1)] for _ in range(n + 1)] arr[1][1] = 1 for i in range(1, n + 1): for j in range(1, n + 1): if i < j: arr[i][j] = arr[i][i] elif i == j: arr[i][j] = 1 + arr[i][j - 1] else: arr[i][j] = arr[i][j - 1] + arr[i - j][j] return arr[n][n] ``` Note: The provided code snippet is a starting point. Ensure that your implementation addresses edge cases and performs efficiently for the upper constraint limits.","solution":"def integer_decomposition(n: int) -> int: This function calculates the number of ways to decompose the integer n into summands of smaller or equal positive integers using dynamic programming. # Initialize a 2D array with all zeros dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # There is one way to partition the number 0: using no parts dp[0][0] = 1 # Build the table dp[] in bottom-up manner for i in range(1, n + 1): for j in range(n + 1): if j >= i: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: dp[i][j] = dp[i - 1][j] return dp[n][n]"},{"question":"# Question: Two Sum Problem You are given an array of integers and a target integer. Your task is to write a function `two_sum` to find two distinct indices in the array whose values sum up to the target value and return those indices in the form of a tuple. # Function Specification **Function Name**: `two_sum` **Input Parameters**: - `array` (List[int]): A list of integers where each element is unique. - `target` (int): The target sum integer. **Output**: - Returns a tuple of two integers (i, j) where `0 <= i, j < len(array)` and `array[i] + array[j] = target`. # Example ```python # Example 1 nums = [2, 7, 11, 15] target = 9 # Explanation: Because nums[0] + nums[1] = 2 + 7 = 9, # the function should return (0, 1). print(two_sum(nums, target)) # Output: (0, 1) ``` # Constraints 1. Each input will have exactly one solution. 2. You may not use the same element twice. 3. You can return the indices in any order. 4. The list length is in the range [2, (10^4)] and values are in the range [-(10^9), (10^9)]. # Notes - Consider edge cases like minimal sized lists, including negatives and zero. - Ensure your solution is optimal in terms of both time and space complexity. - Handle situations where no solution exists appropriately.","solution":"def two_sum(array, target): Finds two distinct indices such that their values sum up to the target. Parameters: - array: List[int] : List of unique integers - target: int : Target sum Returns: - Tuple[int, int] : Tuple of two indices value_to_index = {} for i, num in enumerate(array): complement = target - num if complement in value_to_index: return (value_to_index[complement], i) value_to_index[num] = i"},{"question":"# Anagram Detection under Constraints Given two strings `s1` and `s2`, determine if they are anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequencies, regardless of their order. The strings consist only of lowercase Latin letters. Function Signature: ```python def anagram(s1: str, s2: str) -> bool: ``` Input: - `s1` (1 ≤ |s1| ≤ 10^5): a string consisting of lowercase Latin letters. - `s2` (1 ≤ |s2| ≤ 10^5): another string consisting of lowercase Latin letters. Output: - Return `True` if `s1` and `s2` are anagrams, otherwise return `False`. Constraints: 1. The function should operate in linear time relative to the input size. 2. You are not allowed to use any library functions that directly determine if the strings are anagrams. 3. Consider edge cases such as: - Different lengths of strings. - Strings with the same characters in different frequencies. Example Scenarios: Example 1: ```python s1 = \\"listen\\" s2 = \\"silent\\" anagram(s1, s2) ``` Output: ```python True ``` Example 2: ```python s1 = \\"hello\\" s2 = \\"billion\\" anagram(s1, s2) ``` Output: ```python False ``` Example 3: ```python s1 = \\"aabbcc\\" s2 = \\"abcabc\\" anagram(s1, s2) ``` Output: ```python True ``` Use the given code snippet as a reference for your solution method, and be sure to handle any identified edge cases.","solution":"def anagram(s1: str, s2: str) -> bool: Determines if two strings s1 and s2 are anagrams. # If the lengths are different, they cannot be anagrams. if len(s1) != len(s2): return False # Create frequency counts for each character in both strings. count1 = [0] * 26 count2 = [0] * 26 # Count the frequency of characters in both strings. for char in s1: count1[ord(char) - ord(\'a\')] += 1 for char in s2: count2[ord(char) - ord(\'a\')] += 1 # Compare the frequency counts. return count1 == count2"},{"question":"Matrix decomposition is a useful tool in numerical analysis and linear algebra. One such decomposition is Crout\'s matrix decomposition, which factors an input matrix ( A ) into a lower triangular matrix ( L ) and an upper triangular matrix ( U ), where ( L times U = A ). Implement the function `crout_matrix_decomposition(A)` that takes a square matrix ( A ) as input and returns two matrices ( L ) and ( U ) such that: 1. ( L ) is a lower triangular matrix (non-zero elements on and below the diagonal). 2. ( U ) is an upper triangular matrix (non-zero elements on and above the diagonal) with all diagonal elements equal to 1. Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: pass ``` Input - `A`: a List of Lists of floats, representing an ( n times n ) matrix ( (2 leq n leq 100) ). Output - Returns a tuple of two matrices ( L ) and ( U ), as described above. Constraints - The matrix ( A ) will be non-singular (invertible) and will not have zero values on the diagonal in valid cases. - Avoid using external libraries like NumPy or SciPy for this decomposition. Example ```python A = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_matrix_decomposition(A) print(\\"L =\\", L) print(\\"U =\\", U) ``` Expected Output: ``` L = [[1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0]] U = [[1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0]] ``` # Implementation Notes - Pay attention to numerical stability, and handle near-zero values gracefully. - Document assumptions and edge cases clearly within your code solution.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): U[i][i] = 1.0 for j in range(n): for i in range(j, n): sum_L = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum_L for i in range(j + 1, n): sum_U = sum(L[j][k] * U[k][i] for k in range(j)) if L[j][j] == 0: raise ZeroDivisionError(\\"Matrix is singular!\\") U[j][i] = (A[j][i] - sum_U) / L[j][j] return L, U"},{"question":"# Stack Operations Objective Your task is to implement a custom stack class that supports additional operations, such as reversing the stack in-place and finding the maximum element efficiently. You will demonstrate your understanding of the stack by using your implementation to solve a problem involving stack manipulation. Requirements 1. Implement a class, `AdvancedArrayStack`, that inherits from the provided `ArrayStack` class. 2. Implement the following additional methods: - `reverse()`: Reverses the elements in the stack in-place. - `get_max()`: Returns the maximum element in the stack efficiently. Expected Input and Output Formats The class should follow all the methods from `ArrayStack` and provide additional functionalities as specified. # Method Signatures: - `def reverse(self) -> None` - `def get_max(self) -> int` # Constraints: - **reverse()** must run in O(n) time. - **get_max()** operations must run in O(1) time after possible precomputation. - You may use additional data structures within the class to maintain the time complexity constraints. # Example Usage: ```python # Creating an instance of AdvancedArrayStack with initial capacity of 10 stack = AdvancedArrayStack() # Push elements to the stack stack.push(3) stack.push(5) stack.push(2) stack.push(8) # Retrieve maximum element print(stack.get_max()) # Output: 8 # Reverse the stack stack.reverse() # Check the order after reversing print(stack.pop()) # Output: 3 print(stack.pop()) # Output: 5 print(stack.get_max()) # Output: 2 ``` Provide a thoroughly tested implementation of the `AdvancedArrayStack` with considerations for edge cases, performance bottlenecks, and optimized time complexity.","solution":"class ArrayStack: def __init__(self): self._data = [] def is_empty(self): return len(self._data) == 0 def push(self, item): self._data.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self._data.pop() def top(self): if self.is_empty(): raise IndexError(\\"top from empty stack\\") return self._data[-1] def size(self): return len(self._data) class AdvancedArrayStack(ArrayStack): def __init__(self): super().__init__() self._max_stack = [] def push(self, item): super().push(item) if not self._max_stack or item >= self._max_stack[-1]: self._max_stack.append(item) def pop(self): item = super().pop() if item == self._max_stack[-1]: self._max_stack.pop() return item def reverse(self): self._data.reverse() def get_max(self): if not self._max_stack: raise IndexError(\\"get_max from empty stack\\") return self._max_stack[-1]"},{"question":"# Question You are tasked with implementing a function that correctly joins URL parts or file paths, ensuring that the result does not have redundant slashes or anomalous spaces. Given the base path/URL and a suffix, the function should strip any leading slash from the suffix, any trailing slash from the base path, and concatenate them with exactly one forward slash (`/`) in between. Write a function `join_with_slash(base, suffix)` that adheres to the following specifications: Input * `base` (string): the base path or URL. * `suffix` (string): the suffix path or URL part to be appended to the base. Output * (string): The correctly joined path or URL without redundant slashes or extraneous whitespace. Constraints * The base and suffix will not be empty simultaneously. * Each string can contain up to 1000 characters. * You should consider leading/trailing spaces as irrelevant and remove them before processing. Example 1. `join_with_slash(\'path/to/dir\', \'file\')` -> \'path/to/dir/file\' 2. `join_with_slash(\'path/to/dir/\', \'file\')` -> \'path/to/dir/file\' 3. `join_with_slash(\'path/to/dir/\', \'/file\')` -> \'path/to/dir/file\' 4. `join_with_slash(\'http://algorithms.com/\', \'part\')` -> \'http://algorithms.com/part\' 5. `join_with_slash(\'http://algorithms.com\', \'part\')` -> \'http://algorithms.com/part\' **Requirements:** * The function must use a forward slash (`/`) to join the base and suffix. * Implement the function without using any specialized path joining libraries. **Note**: Pay special attention to trimming unnecessary leading/trailing slashes and spaces.","solution":"def join_with_slash(base, suffix): Joins the base path/URL and suffix, ensuring no redundant slashes or spaces. base = base.rstrip().rstrip(\'/\') suffix = suffix.lstrip().lstrip(\'/\') return f\\"{base}/{suffix}\\""},{"question":"# **Scenario** You have been hired to develop an application that processes sequences of events. One critical part of the application involves reversing sequences efficiently using a stack. You will implement two types of stacks (ArrayStack and LinkedListStack) and then use one of them to reverse a given sequence of events. # **Task** 1. Implement an `ArrayStack` and `LinkedListStack` with push, pop, peek, and is_empty methods. 2. Write a function `reverse_sequence` that uses either of your stack implementations to reverse a given list of events. # **Function Signatures** ```python class ArrayStack(AbstractStack): def __init__(self, size=10): pass def __iter__(self): pass def push(self, value): pass def pop(self): pass def peek(self): pass class LinkedListStack(AbstractStack): def __init__(self): pass def __iter__(self): pass def push(self, value): pass def pop(self): pass def peek(self): pass def reverse_sequence(sequence, stack_class): pass ``` # **Input and Output** - The `reverse_sequence` function: - **Input**: * `sequence`: A list of elements to be reversed. * `stack_class`: Either `ArrayStack` or `LinkedListStack` class indicating the stack type to use. - **Output**: Returns a new list with the sequence reversed. # **Constraints** - You can assume the sequence has a reasonable length (up to 1000 elements). - The stack should handle exceptions gracefully (throwing appropriate exceptions for operations on an empty stack). # **Example** ```python events = [1, 2, 3, 4, 5] print(reverse_sequence(events, ArrayStack)) # Output: [5, 4, 3, 2, 1] print(reverse_sequence(events, LinkedListStack)) # Output: [5, 4, 3, 2, 1] ``` # **Performance Requirements** - Both implementations should maintain O(1) time complexity for push and pop operations. - Ensure that your implementation is robust and handles all edge cases, such as empty lists.","solution":"class ArrayStack: def __init__(self, size=10): self._stack = [] def __iter__(self): return iter(self._stack) def push(self, value): self._stack.append(value) def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") return self._stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self._stack[-1] def is_empty(self): return len(self._stack) == 0 class LinkedListStack: class Node: def __init__(self, value, next=None): self.value = value self.next = next def __init__(self): self.head = None def __iter__(self): current = self.head while current: yield current.value current = current.next def push(self, value): self.head = self.Node(value, self.head) def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None def reverse_sequence(sequence, stack_class): stack = stack_class() for item in sequence: stack.push(item) reversed_sequence = [] while not stack.is_empty(): reversed_sequence.append(stack.pop()) return reversed_sequence"},{"question":"Context You work for a company developing an online drawing application. Users can transform images by rotating and flipping them. You\'ve been given the responsibility of implementing these transformation features efficiently and correctly. Task Write a function that can perform four different transformations on a 2D matrix representing an image: rotate it clockwise, rotate it counterclockwise, invert it from the top left, and invert it from the bottom left. Your function should take as input the matrix and a string indicating the transformation to be performed. You should then return the transformed matrix. Function Signature ```python def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: # your implementation here ``` Inputs 1. `matrix`: A list of lists representing the original 2D matrix. It is guaranteed that the matrix is non-empty, but it may not be square. 2. `operation`: A string indicating the operation to be performed. It can be one of the following: - \'rotate_clockwise\' - \'rotate_counterclockwise\' - \'top_left_invert\' - \'bottom_left_invert\' Output A new 2D matrix that is the result of performing the specified transformation on the input matrix. Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transformed = transform_matrix(matrix, \'rotate_clockwise\') # Expected Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] transformed = transform_matrix(matrix, \'rotate_counterclockwise\') # Expected Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] transformed = transform_matrix(matrix, \'top_left_invert\') # Expected Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] transformed = transform_matrix(matrix, \'bottom_left_invert\') # Expected Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Constraints 1. All elements of the matrix are integers. 2. Performance expectation is within reasonable limits for matrix dimensions up to (1000 times 1000).","solution":"from typing import List def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: n, m = len(matrix), len(matrix[0]) if operation == \'rotate_clockwise\': return [[matrix[n-1-j][i] for j in range(n)] for i in range(m)] if operation == \'rotate_counterclockwise\': return [[matrix[j][m-1-i] for j in range(n)] for i in range(m)] if operation == \'top_left_invert\': return [[matrix[j][i] for j in range(n)] for i in range(m)] if operation == \'bottom_left_invert\': return [[matrix[n-1-j][m-1-i] for j in range(n)] for i in range(m)] # Return the original matrix if the operation is undefined return matrix"},{"question":"In this coding challenge, you are required to write a function that reverses a given string using an iterative approach. Your implementation should be efficient and handle edge cases properly. Problem Statement Write a function named `reverse_string` that reverses the input string `s` and returns the reversed string. You should use an iterative approach, not recursive, and avoid using built-in Python functions like `reversed()` or slicing techniques like `[::-1]`. # Function Signature ```python def reverse_string(s: str) -> str: ``` # Input * **s** (str): A string of length `n` with 0 <= n <= 10^6. The string may include spaces, punctuation marks, and various characters. # Output * **return** (str): The reversed string. # Constraints * Your solution should have a time complexity of O(n) and space complexity of O(n). * Avoid using Python built-in functions like `reversed()` or slicing techniques like `[::-1]`. # Examples 1. Given **input**: `\\"hello\\"` - **Output**: `\\"olleh\\"` 2. Given **input**: `\\"world!\\"` - **Output**: `\\"!dlrow\\"` 3. Given **input**: `\\"a\\"` - **Output**: `\\"a\\"` 4. Given **input**: `\\"\\"` - **Output**: `\\"\\"` Additional Context Your function should handle empty strings gracefully and be efficient for long strings up to one million characters. Ensure that your code is robust and optimized for performance, considering potential edge cases.","solution":"def reverse_string(s: str) -> str: Reverses the input string s using an iterative approach. # Initialize an empty list to store the reversed characters reversed_chars = [] # Iterate over the string in reverse order for i in range(len(s) - 1, -1, -1): reversed_chars.append(s[i]) # Join the list into a single string and return it return \'\'.join(reversed_chars)"},{"question":"# Question You are a developer tasked with implementing a function that finds the single unique number in an array where every other element appears exactly twice. This problem frequently arises in error detection and data validation scenarios where anomalies need to be detected efficiently. **Function Signature**: ```python def single_number(nums: List[int]) -> int: ``` # Input * `nums`: A list of integers where every element appears exactly twice, except for one, which appears only once. * Constraints: * (1 leq |nums| leq 3 times 10^4) * All elements will be within the range ([-3 times 10^4, 3 times 10^4]). * The input list is guaranteed to contain exactly one element that appears once. # Output * Return the single integer that appears exactly once in the list. # Example ```python single_number([4, 1, 2, 1, 2]) ``` *Expected Output:* ```python 4 ``` # Additional Details * Your solution should run in linear time, (O(n)). * You should not use any extra memory). # Edge Cases to Consider 1. If the input list has only one element, return that element. 2. If the input list length approaches the upper constraint, ensure performance remains within acceptable limits. Implement the function `single_number` that meets these requirements.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single unique number in an array where every other element appears exactly twice. # Using XOR as it cancels out the numbers appearing twice. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"Scenario You have been given a binary tree and your task is to implement a function to perform a preorder traversal on this tree. This traversal should visit all nodes and return the values in the correct order. Function Signature ```python def preorder_traversal(root: Node) -> List[int]: pass ``` Requirements 1. The function should take the root of the binary tree as input and return a list of integers. 2. The binary tree\'s node class is defined as follows: ```python class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right ``` 3. Your function should handle the following edge cases: - The root is None. - The tree contains only a single node. Constraints - The number of nodes in the tree is in the range [0, 10^4]. - Node values are integers and could be negative or zero. - Try to optimize for both time and space complexity. Example ```python # Example Tree: # 1 # / # 2 3 # /| | # 4 5 6 7 root = Node(1, left=Node(2, left=Node(4), right=Node(5)), right=Node(3, left=Node(6), right=Node(7))) assert preorder_traversal(root) == [1, 2, 4, 5, 3, 6, 7] ``` # Note Ensure the solution is robust and can handle large trees within the given constraints without running into performance issues or stack overflows.","solution":"from typing import List class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def preorder_traversal(root: Node) -> List[int]: Perform a preorder traversal of the binary tree. :param root: A Node representing the root of the binary tree. :return: A list containing the values of nodes in preorder traversal order. if not root: return [] result = [] def traverse(node): if not node: return result.append(node.val) # Visit the root traverse(node.left) # Traverse left subtree traverse(node.right) # Traverse right subtree traverse(root) return result"},{"question":"Given two non-negative integers `a` and `b`, write a function `count_flips_to_convert(a: int, b: int) -> int` that determines the minimal number of bits you need to flip to convert integer `a` to integer `b`. # Input/Output Formats * **Input**: * `a`: A non-negative integer, where 0 ≤ `a` ≤ 2^31 - 1 * `b`: A non-negative integer, where 0 ≤ `b` ≤ 2^31 - 1 * **Output**: * An integer denoting the number of bit flips required to convert `a` to `b`. # Constraints * Both `a` and `b` can range from 0 to the largest 32-bit integer, inclusive. * The integers are represented in a 32-bit signed or unsigned integer range. # Example ```python # Example 1 Input: a = 29, b = 15 Output: 2 Explanation: 29 in binary is 11101, and 15 in binary is 01111. The number of bits that differ is 2 (change 3rd and 4th bits). # Example 2 Input: a = 0, b = 0 Output: 0 Explanation: No bits need to be flipped as both numbers are identical. # Example 3 Input: a = 255, b = 0 Output: 8 Explanation: 255 in binary is 11111111, and 0 in binary is 00000000. All 8 bits need to be flipped. ``` # Requirements * Achieve a linear time complexity relative to the number of bits. * Use constant space.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Determines the minimal number of bits that need to be flipped to convert integer a to integer b. # XOR of a and b will have bits set to 1 wherever a and b differ xor_result = a ^ b # Count the number of set bits (1s) in the xor_result count = 0 while xor_result: # Increment count for each bit set to 1 count += xor_result & 1 # Shift right by 1 to check the next bit xor_result >>= 1 return count"},{"question":"Hailstone Sequence Analysis and Implementation # Context: The hailstone sequence (or Collatz sequence) is a sequence of numbers defined as follows for a given integer `n`: - If `n == 1`, the sequence stops. - If `n` is even, the next number is `n / 2`. - If `n` is odd, the next number is `3n + 1`. The sequence continues until it reaches 1. The length of the sequence starting from `n` is variable and unpredictable. Analyzing this sequence provides insights into number theory and iterative processes. # Task: Write a Python function named `analyze_hailstone` that computes the hailstone sequence for a given `n` and returns a tuple containing the sequence and its length. Additionally, implement input validation to ensure `n` is a positive integer. # Function Signature: ```python def analyze_hailstone(n: int) -> Tuple[List[int], int]: pass ``` # Input: - An integer `n` (1 ≤ n ≤ 10^6) # Output: - A tuple containing: 1. A list of integers representing the hailstone sequence starting from `n` and ending at 1. 2. An integer representing the length of this sequence. # Constraints: - The function should return an error message if `n` is not a positive integer. - Ensure the function handles large input values efficiently within reasonable time limits. # Examples: ```python assert analyze_hailstone(1) == ([1], 1) assert analyze_hailstone(6) == ([6, 3, 10, 5, 16, 8, 4, 2, 1], 9) assert analyze_hailstone(19) == ([19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 21) ``` # Constraints: * Ensure your code is clean and well-documented. * Consider edge cases such as very large values of `n`. * Performance optimization might not be straightforward, so empirical testing is recommended.","solution":"from typing import List, Tuple def analyze_hailstone(n: int) -> Tuple[List[int], int]: if not isinstance(n, int) or n <= 0: return \\"Error: Input must be a positive integer\\" sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) return sequence, len(sequence)"},{"question":"# Problem Description You are given a class representation of a binary search tree (BST) node. Your task is to implement a function that inserts values into the BST while maintaining its properties and a function that checks if a given value exists in the BST. The skeleton implementation is already present. # Function Signature ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: pass def search_bst(root: TreeNode, value: int) -> bool: pass ``` # Input 1. **Insert Function**: * **root (TreeNode or None)**: The root node of the BST, which may be `None` initially. * **value (int)**: An integer value to be inserted into the BST. 2. **Search Function**: * **root (TreeNode or None)**: The root node of the BST. * **value (int)**: An integer value to be searched within the BST. # Output 1. **Insert Function**: * Returns the root of the BST with the new value inserted. 2. **Search Function**: * Returns `True` if the value is found in the BST, otherwise returns `False`. # Constraints * All values to be inserted will be unique. * Values are integers within the range [-10^5, 10^5]. * The input tree can be empty (None). # Performance Requirements Both functions should operate with a time complexity of O(h), where h is the height of the BST. A balanced BST would have h = log(n), where n is the number of elements in the tree. # Example ```python # Example usage: root = None root = insert_into_bst(root, 10) root = insert_into_bst(root, 5) root = insert_into_bst(root, 15) root = insert_into_bst(root, 3) root = insert_into_bst(root, 7) print(search_bst(root, 5)) # Output: True print(search_bst(root, 20)) # Output: False ``` # Requirements 1. Implement `insert_into_bst` function that inserts values into the BST. 2. Implement `search_bst` function that searches for a value in the BST.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: if root is None: return TreeNode(val=value) if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def search_bst(root: TreeNode, value: int) -> bool: if root is None: return False if root.val == value: return True elif value < root.val: return search_bst(root.left, value) else: return search_bst(root.right, value)"},{"question":"# Binary Tree Paths Given a binary tree, write a function `binary_tree_paths(root)` that returns all root-to-leaf paths as a list of strings. Each path should be presented as a string with node values separated by \\"->\\". # Input * A binary tree represented by its root node `root`. # Output * A list of strings where each string represents a root-to-leaf path. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * Each node\'s value is a unique integer. # Performance Requirements * The time complexity of the solution should be O(N) where N is the number of nodes. * The space complexity should be optimized, with efficient use of memory. # Edge Cases to Consider 1. An empty tree (root is `None`). 2. A tree where every node only has left children or only has right children. 3. A balanced binary tree. # Example ```python Input: 1 / 2 3 | 5 Output: [\\"1->2->5\\", \\"1->3\\"] ``` # Function Signature ```python def binary_tree_paths(root): # Your code here ``` # Hints 1. Use a helper method to perform DFS. 2. Keep track of the current path as you traverse. 3. Append the path to the result list when you reach a leaf node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given a binary tree, returns all root-to-leaf paths as a list of strings. Each path is represented as a string with node values separated by \\"->\\". :param root: TreeNode, the root of the binary tree :return: List[str], all root-to-leaf paths def dfs(node, current_path, paths): if node: current_path += str(node.val) # Check if it\'s a leaf node if not node.left and not node.right: paths.append(current_path) else: current_path += \\"->\\" # Continue the path dfs(node.left, current_path, paths) dfs(node.right, current_path, paths) paths = [] dfs(root, \'\', paths) return paths"},{"question":"Given an array of unique integers `nums` in the range `[0, n]` (inclusive), where `n` is the length of the array, your task is to write a function `find_missing_number(nums)` that returns the missing number from the sequence. If the sequence already includes all numbers from `0` to `n`, your function should return `n+1`, the next integer in the sequence. # Function Signature ```python def find_missing_number(nums): # Your implementation here pass ``` # Input * `nums`: A list of `n` unique integers in the range `[0..n]`. # Output * An integer representing the missing number, or `n+1` if the sequence is complete. # Constraints * The length of the array `n` will be in the range `[0, 10000]`. # Examples 1. `find_missing_number([4, 1, 3, 0, 6, 5, 2])` -> `7` 2. `find_missing_number([0, 1, 2, 3, 4, 5, 6, 7])` -> `8` 3. `find_missing_number([2, 3, 0])` -> `1` 4. `find_missing_number([])` -> `0` # Notes * Consider edge cases such as an empty array or a fully populated sequence. * You can assume that the input array will not contain duplicates or numbers out of the expected range.","solution":"def find_missing_number(nums): Given a list of unique integers nums in the range [0, n], return the missing number from the sequence. If the sequence is complete, return n+1. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum if missing_number > n: return n + 1 else: return missing_number"},{"question":"# Maximum Flow Problem You\'re given a directed graph represented by a capacity matrix, a source node, and a sink node. Your task is to implement three different algorithms to find the maximum flow from the source to the sink node: Ford-Fulkerson (DFS-based), Edmonds-Karp (BFS-based), and Dinic\'s Algorithm. Input * `capacity` (List[List[int]]): An `n x n` matrix where `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. * `source` (int): The source node. * `sink` (int): The sink node. Output * Return an integer representing the maximum flow from `source` to `sink` for each of the three algorithms. Constraints * `1 <= n <= 1000` * `0 <= capacity[i][j] <= 10^9` * `0 <= source, sink < n` * The graph is connected, and there exists at least one path from the source to the sink. # Task 1. Implement `ford_fulkerson(capacity, source, sink)`. 2. Implement `edmonds_karp(capacity, source, sink)`. 3. Implement `dinic(capacity, source, sink)`. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(ford_fulkerson(capacity, source, sink)) # Expected output: 23 print(edmonds_karp(capacity, source, sink)) # Expected output: 23 print(dinic(capacity, source, sink)) # Expected output: 23 ```","solution":"from collections import deque # Ford-Fulkerson Algorithm using DFS def dfs_find_path(capacity, residual_capacity, source, sink, parent): visited = [False] * len(capacity) stack = [source] while stack: node = stack.pop() if node == sink: return True for next_node in range(len(capacity)): if not visited[next_node] and residual_capacity[node][next_node] > 0: stack.append(next_node) visited[next_node] = True parent[next_node] = node if next_node == sink: return True return False def ford_fulkerson(capacity, source, sink): n = len(capacity) residual_capacity = [row[:] for row in capacity] parent = [-1] * n max_flow = 0 while dfs_find_path(capacity, residual_capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink # Find the maximum flow through the path found by DFS while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] # Update the residual capacities of the edges and reverse edges v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow # Edmonds-Karp Algorithm using BFS def bfs_find_path(capacity, residual_capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: node = queue.popleft() for next_node in range(len(capacity)): if not visited[next_node] and residual_capacity[node][next_node] > 0: queue.append(next_node) visited[next_node] = True parent[next_node] = node if next_node == sink: return True return False def edmonds_karp(capacity, source, sink): return ford_fulkerson(capacity, source, sink) # Using the same ford_fulkerson method as it\'s BFS based # Dinic\'s Algorithm def bfs_level_graph(capacity, residual_capacity, source, sink, level): queue = deque([source]) level[source] = 0 while queue: node = queue.popleft() for next_node in range(len(capacity)): if level[next_node] < 0 and residual_capacity[node][next_node] > 0: level[next_node] = level[node] + 1 queue.append(next_node) return level[sink] >= 0 def dfs_flow(source, sink, flow, capacity, residual_capacity, level, start): if source == sink: return flow while start[source] < len(capacity): next_node = start[source] if level[next_node] == level[source] + 1 and residual_capacity[source][next_node] > 0: curr_flow = min(flow, residual_capacity[source][next_node]) temp_flow = dfs_flow(next_node, sink, curr_flow, capacity, residual_capacity, level, start) if temp_flow > 0: residual_capacity[source][next_node] -= temp_flow residual_capacity[next_node][source] += temp_flow return temp_flow start[source] += 1 return 0 def dinic(capacity, source, sink): n = len(capacity) residual_capacity = [row[:] for row in capacity] level = [-1] * n max_flow = 0 while bfs_level_graph(capacity, residual_capacity, source, sink, level): start = [0] * n while (flow := dfs_flow(source, sink, float(\'Inf\'), capacity, residual_capacity, level, start)) > 0: max_flow += flow level = [-1] * n return max_flow"},{"question":"Write a function `rabin_miller_primality_test(n: int, k: int) -> bool` to determine whether a given number (n) is probably prime. Your function should leverage the Rabin-Miller primality test as described. # Function Signature The function should have the following signature: ```python def rabin_miller_primality_test(n: int, k: int) -> bool: pass ``` # Input * An integer (n) (1 ≤ (n) ≤ 10^{18}): the number to test for primality. * An integer (k) (1 ≤ (k) ≤ 10): the number of iterations to increase the confidence level. # Output * Returns `True` if (n) is probably prime, `False` if (n) is definitely composite. # Constraints * If (n < 5), the test directly returns the result based on small primes. # Performance Requirements * The function should operate within reasonable time and space limits for values of (n) up to (10^{18}). # Example ```python assert rabin_miller_primality_test(17, 5) == True assert rabin_miller_primality_test(18, 5) == False assert rabin_miller_primality_test(37, 5) == True assert rabin_miller_primality_test(40, 5) == False ``` # Notes * It is important to pay attention to both time complexity while handling large integers and the correctness of results, especially with edge values. * Your implementation should efficiently handle multiple iterations to increase result confidence.","solution":"import random def rabin_miller_primality_test(n: int, k: int) -> bool: Perform the Rabin-Miller primality test to determine if `n` is a probable prime. Args: - n: The number to test for primality. - k: The number of iterations to increase the confidence level. Returns: - True if `n` is probably prime, False if `n` is definitely composite. if n < 2: return False if n in (2, 3): return True if n % 2 == 0: return False # Write n as d*2^r + 1 with d odd by factoring powers of 2 from n-1 r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Helper function to perform modular exponentiation def power_mod(base, exponent, mod): result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result # Perform k tests for _ in range(k): a = random.randint(2, n - 2) x = power_mod(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = power_mod(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"You are provided with an unsorted list of integers. Your task is to implement a function `custom_pigeonhole_sort` which sorts the list using the pigeonhole sorting algorithm. This algorithm works especially well when the range of integer values in the list is few. Additionally, you must handle empty lists and lists with negative as well as positive integers default values. # Function Signature ```python def custom_pigeonhole_sort(arr: list[int]) -> list[int]: pass ``` # Input - `arr`: A list of integers that might include negative, zero, and positive integer values. The list can be empty. # Output - A new list of integers, sorted in ascending order. # Constraints - The length of the list, `n`, can be from `0` to `10^5`. - The integer values in the list will be in the range of `[-10^5, 10^5]`. # Example ```python assert custom_pigeonhole_sort([4, 6, 7, -3, 2, 0]) == [-3, 0, 2, 4, 6, 7] assert custom_pigeonhole_sort([]) == [] assert custom_pigeonhole_sort([5, 5, 5, 5]) == [5, 5, 5, 5] assert custom_pigeonhole_sort([5]) == [5] ``` # Notes 1. Consider and handle edge cases properly: - Empty list. - List with identical values. - Large range differences (within constraints). 2. Optimize for performance: - Efficiently use memory. - Avoid unnecessary computations.","solution":"def custom_pigeonhole_sort(arr: list[int]) -> list[int]: if not arr: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for number in arr: holes[number - min_value] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_value) holes[i] -= 1 return sorted_arr"},{"question":"Scenario You are building a search feature for an application that quickly locates the first occurrence of a given number in a large dataset. Since the dataset is sorted, you decide to use a binary search algorithm for efficiency. Objective Write a function `first_occurrence(array, query)` that finds the index of the first occurrence of a given number in a sorted array using binary search. Input * `array`: A list of integers sorted in increasing order. * `query`: An integer to find in the array. Output * Returns the index of the first occurrence of `query` in `array`. * If `query` is not found, return -1. Constraints 1. The array can have a maximum length of (10^5). 2. The elements of the array are integers within the range of ([-10^9, 10^9]). 3. The query integer is within the same range. Examples 1. **Input**: `array = [1, 2, 2, 2, 3, 4, 5]`, `query = 2` **Output**: `1` 2. **Input**: `array = [1, 1, 1, 1, 1]`, `query = 1` **Output**: `0` 3. **Input**: `array = [1, 3, 5, 7, 9]`, `query = 4` **Output**: `-1` 4. **Input**: `array = [10, 20, 20, 20, 30, 40, 50]`, `query = 20` **Output**: `1` Notes * Be sure to handle edge cases such as an empty array and the query not being present in the array. * Ensure efficient implementation to adhere to the logarithmic time complexity.","solution":"def first_occurrence(array, query): Finds the index of the first occurrence of query in a sorted array using binary search. :param array: List[int] - a list of integers sorted in increasing order. :param query: int - the integer to find in the array. :return: int - the index of the first occurrence of query in array, or -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # look on left side (lower indices) elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question: Create a Histogram Function with Enhanced Analysis Capability **Description:** Your task is to extend the histogram function to not only return the frequency count of each element in a list but also provide additional statistical insights. These insights include the most frequent element, the least frequent element, and the spread of frequencies. **Function Signature:** ```python def enhanced_histogram(input_list: list) -> dict: :param input_list: List[int] - A list containing integer elements. :return: Dict - A dictionary containing: - \'histogram\': The histogram dictionary with element frequencies. - \'most_frequent\': The element with the highest frequency. - \'least_frequent\': The element with the lowest frequency. - \'frequency_spread\': The difference between the highest and lowest frequencies. ``` **Input:** - A list of integers which can be empty or have positive/negative numbers. **Output:** - A dictionary with the following structure: - \'histogram\': A dictionary of element frequencies. - \'most_frequent\': The element with the highest frequency. - \'least_frequent\': The element with the lowest frequency. - \'frequency_spread\': The difference between the highest and lowest frequencies. **Constraints:** - The input list can have a maximum size of (10^5) elements. - Each integer in the list is in the range (-10^6) to (10^6). **Performance Requirements:** - The solution should be efficient with a time complexity of O(n) and space complexity of O(d), where n is the number of elements, and d is the number of distinct elements. **Example:** ```python input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] Expected Output: { \'histogram\': {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}, \'most_frequent\': 5, \'least_frequent\': 2, \'frequency_spread\': 2 } ``` Create the function `enhanced_histogram` that fulfills these requirements.","solution":"def enhanced_histogram(input_list: list) -> dict: Analyzes the input list and provide histogram along with additional insights. :param input_list: List[int] - A list containing integer elements. :return: Dict - A dictionary containing: - \'histogram\': The histogram dictionary with element frequencies. - \'most_frequent\': The element with the highest frequency. - \'least_frequent\': The element with the lowest frequency. - \'frequency_spread\': The difference between the highest and lowest frequencies. # Create a histogram dictionary histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 if not histogram: return { \'histogram\': {}, \'most_frequent\': None, \'least_frequent\': None, \'frequency_spread\': 0 } # Determine most frequent and least frequent elements most_frequent = max(histogram, key=histogram.get) least_frequent = min(histogram, key=histogram.get) # Determine frequency spread frequency_spread = histogram[most_frequent] - histogram[least_frequent] return { \'histogram\': histogram, \'most_frequent\': most_frequent, \'least_frequent\': least_frequent, \'frequency_spread\': frequency_spread }"},{"question":"Implement a Resizable Hash Table with Advanced Operations Background A hash table is a data structure that implements an associative array abstract data type, a structure that can map keys to values. Hash tables are highly efficient in retrieving and storing data using a hashing mechanism. However, a key aspect of a hash table’s efficiency is how well it handles collisions and the strategy it uses to resize when the table becomes too full. Task Create the `AdvancedResizableHashTable` class extending the given `ResizableHashTable`: 1. **Add Method - `update`**: This method should update an existing key with a new value or add the key if it does not exist. 2. **Add Method - `keys`**: Return a list of active keys in the hash table. 3. **Add Method - `values`**: Return a list of active values in the hash table. 4. **Improve Resize Mechanism**: Enhance the `__resize` method to resize only when the load factor exceeds 70%. Requirements and Constraints * The `update` method should operate in O(1) average time. * The `keys` and `values` methods should return lists containing the active keys and values respectively, excluding deleted or unassigned slots. * The `__resize` method should ensure that resizing maintains an average load factor of 70%. * Ensure all code is properly documented and handle edge cases appropriately. Class Definition ```python class AdvancedResizableHashTable(ResizableHashTable): def update(self, key, value): Update the value of the key if it exists, otherwise add the key-value pair to the table. pass def keys(self): Return a list of all active keys in the hash table. pass def values(self): Return a list of all active values in the hash table. pass def __resize(self): Resize the hash table when the load factor exceeds 70%. pass ``` Example Usage ```python hash_table = AdvancedResizableHashTable() hash_table.update(1, \'one\') hash_table.update(2, \'two\') print(hash_table.keys()) # Output: [1, 2] print(hash_table.values()) # Output: [\'one\', \'two\'] hash_table.update(1, \'uno\') print(hash_table.get(1)) # Output: \'uno\' ``` Ensure that your implementation passes various edge cases like handling duplicate keys, deleting keys, and resizing the table correctly.","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.count = 0 self.table = [None] * self.size def _hash(self, key): return hash(key) % self.size def insert(self, key, value): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: break idx = (idx + 1) % self.size else: self.count += 1 self.table[idx] = (key, value) if self.count / self.size > 0.7: self.__resize() def get(self, key): idx = self._hash(key) for _ in range(self.size): if self.table[idx] is None: return None if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size return None def delete(self, key): idx = self._hash(key) for _ in range(self.size): if self.table[idx] is None: return if self.table[idx][0] == key: self.table[idx] = None self.count -= 1 break idx = (idx + 1) % self.size def __resize(self): old_table = self.table self.size *= 2 self.count = 0 self.table = [None] * self.size for item in old_table: if item is not None: self.insert(*item) class AdvancedResizableHashTable(ResizableHashTable): def update(self, key, value): Update the value of the key if it exists, otherwise add the key-value pair to the table. idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.size self.insert(key, value) def keys(self): Return a list of all active keys in the hash table. return [item[0] for item in self.table if item is not None] def values(self): Return a list of all active values in the hash table. return [item[1] for item in self.table if item is not None] def __resize(self): if self.count / self.size <= 0.7: return old_table = self.table self.size *= 2 self.count = 0 self.table = [None] * self.size for item in old_table: if item is not None: self.insert(*item)"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure: - **Algorithm/Data Structure**: Trimmed Mean Calculation Algorithm - **Type**: Statistical Calculation - **Main Purpose**: To compute a mean that is resistant to extreme values by removing a specified percentage of the largest and smallest values before calculating the mean. # Complexity: - **Time Complexity**: O(n log n) primarily due to the sorting step. - **Space Complexity**: O(1) extra space apart from the input list, as sorting can be done in place and only a few additional variables are used. # Principles: 1. **Sorting**: The input array is sorted to identify and eliminate the extreme values. 2. **Trimming**: A specified percentage of the smallest and largest values are removed. 3. **Mean Calculation**: The mean of the remaining values is computed. # Characteristics & Applications: - **Properties**: The algorithm trims outliers before calculating the mean, thus making it more representative of the central tendency for skewed data. - **Common Use Cases**: Useful in scenarios where data may have outliers, such as sports scores, economic indicators, sensor readings, etc. - **Strengths/Limitations**: - **Strengths**: Provides a more robust mean by reducing the impact of extreme values; easy to understand and implement. - **Limitations**: Requires sorting, which may be computationally expensive for very large datasets; not suitable when outlier information itself is crucial. # Implementation Challenges: - **Edge Cases**: - Very small arrays where the trimmed portion can result in an empty or nearly empty array. - Even distribution trimming leading to a non-integer number of values to trim. - **Performance Bottlenecks**: The sorting step dominates the time complexity. - **Error Scenarios**: Incorrect handling of the trimming percentage that may lead to index errors. - **Optimization Points**: Possible use of more advanced algorithms like Quickselect for partial sorting to enhance performance in some scenarios. <|Analysis End|> <|Question Begin|> # Problem Statement You are required to implement a function `trimmean` that calculates the trimmed mean of a list of integers. The trimmed mean is defined as the mean (average) after removing a specified percentage of the smallest and largest values from the list. # Function Signature ```python def trimmean(arr: List[int], per: float) -> float: ``` # Input Format - `arr`: A list of `n` integers, where (1 leq n leq 10^5). - `per`: A float value representing the percentage of values to be trimmed from both ends of the sorted list, where (0 leq per < 100). # Output Format - A float representing the trimmed mean of the list. # Constraints - The trimmed portion must be calculated symmetrically from both ends. - If the trimmed indices do not form an integer, perform integer truncation. # Example - Input: `arr = [6, 2, 3, 8, 5, 7]`, `per = 33.3333` - Output: `5.0` - Explanation: - After sorting: `[2, 3, 5, 6, 7, 8]` - 33.3333% trimming means removing the smallest and largest 1 value each (since 33.3333% of 6 is approximately 2, and truncating to get indices as 1). - Removed values: `[2, 3, 5, 6, 7, 8] -> [3, 5, 6, 7]` - Mean of remaining values: `(3 + 5 + 6 + 7) / 4 = 21 / 4 = 5.25` Your task is to ensure the function is efficient and robust against different edge cases while adhering to the above constraints and examples.","solution":"from typing import List def trimmean(arr: List[int], per: float) -> float: Returns the trimmed mean of the list after removing the specified percentage of smallest and largest values. :param arr: List of integers. :param per: Percentage as a float representing the proportion of values to trim from both ends. :return: Trimmed mean as a float. n = len(arr) trim_count = int(n * per // 100) if n == 0 or per == 0: return sum(arr) / n if n > 0 else 0.0 sorted_arr = sorted(arr) trimmed_arr = sorted_arr[trim_count:n - trim_count] return sum(trimmed_arr) / len(trimmed_arr) if trimmed_arr else 0.0"},{"question":"Implement Optimized Interpolation Search **Objective**: You are required to implement an optimized interpolation search function for a list of integers. This function should handle edge cases, avoid performance bottlenecks, and protect against common error scenarios. **Function Signature**: ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: ``` # Function Description * **Parameters**: - `array`: A list of integers in sorted order. - `search_key`: The integer value to be searched within the `array`. * **Returns**: - The index (0-based) of the `search_key` if found, otherwise -1. # Example *Example 1*: ```python array = [-25, -12, -1, 10, 12, 15, 20, 41, 55] search_key = -1 assert optimized_interpolation_search(array, search_key) == 2 ``` *Example 2*: ```python array = [5, 10, 12, 14, 17, 20, 21] search_key = 55 assert optimized_interpolation_search(array, search_key) == -1 ``` *Example 3*: ```python array = [5, 10, 12, 14, 17, 20, 21] search_key = -5 assert optimized_interpolation_search(array, search_key) == -1 ``` # Requirements: 1. Ensure your function gracefully handles edge cases: - Empty lists. - Lists where the search key lies outside the list bounds. - Lists with uniform values. 2. Optimize for uniformly distributed datasets. 3. Avoid common pitfalls such as division by zero.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: Returns the index of search_key in array using an optimized interpolation search. Returns -1 if the search_key is not present in the array. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Estimate the position of search_key using the interpolation formula pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # If the estimated position goes out of bounds if pos < low or pos > high: return -1 if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Context: You are given the task of designing a file synchronization tool. This tool must determine if two directories (represented as binary trees) have identical contents and structure. Often, directories are deep, and deviations might arise in either file contents or directory structure. # Task: Write a function `is_same_tree(tree_p, tree_q)` to determine if two binary trees are identical. Two binary trees are considered identical if they are structurally identical and the nodes have the same value. # Details: 1. **Input**: The input consists of two binary tree nodes, `tree_p` and `tree_q`, representing the roots of the binary trees to be compared. The binary tree node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 2. **Output**: Return `True` if the binary trees are identical, otherwise return `False`. # Constraints: - Each tree node\'s value is an integer. - Both tree nodes are either `None` or valid `TreeNode` instances. - The height of the trees can be large, so consider potential recursion depth issues for deeper trees. # Examples: 1. Example 1: ```python tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(3)) print(is_same_tree(tree_p, tree_q)) # Output: True ``` 2. Example 2: ```python tree_p = TreeNode(1, TreeNode(2), TreeNode(1)) tree_q = TreeNode(1, TreeNode(1), TreeNode(2)) print(is_same_tree(tree_p, tree_q)) # Output: False ``` Provide a robust implementation that efficiently handles various tree heights and data values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p, tree_q): Determines if two binary trees are identical in structure and value. :param tree_p: TreeNode, root of the first binary tree :param tree_q: TreeNode, root of the second binary tree :return: bool, True if the trees are identical, False otherwise if not tree_p and not tree_q: return True # Both are None if not tree_p or not tree_q: return False # One is None, the other is not if tree_p.val != tree_q.val: return False # Values do not match return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"**Permutation Queue**: Implement a function in Python, `next_permutation`, that takes a list of distinct numbers and generates the next permutation in lexicographical order. The function should follow these specifications: # Function Signature ```python def next_permutation(nums: List[int]) -> List[int]: ``` # Input * `nums`: A list of distinct integers where 1 <= len(nums) <= 20. # Output * A list of integers which is the next permutation in lexicographical order. # Constraints * The input list is always non-empty and consists of distinct integers. * You should modify the input list in place, and also return it. * The solution should have a time complexity of O(n) where n is the length of the input list. # Example ```python # Example 1 nums = [1, 2, 3] print(next_permutation(nums)) # Output: [1, 3, 2] # Example 2 nums = [3, 2, 1] print(next_permutation(nums)) # Output: [1, 2, 3] ``` # Performance Requirements - **Time Complexity**: O(n), where n is the number of elements in the `nums` list. - **Space Complexity**: O(1), i.e., in-place solution without utilizing extra space. # Scenario/Context In many applications, such as generating permutations for heuristic search algorithms or simulations, it\'s often necessary to efficiently generate the next permutation in the lexicographical order. This means that given a sequence like [1, 2, 3], the next sequence should be the smallest that is lexicographically larger than the current sequence, in this case, [1, 3, 2]. Implement this permutation function optimally adhering to the provided constraints.","solution":"from typing import List def next_permutation(nums: List[int]) -> List[int]: Modifies the list `nums` in place to represent the next permutation in lexicographical order. # Find the first element (pivot) that is smaller than the one after it from right to left. i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # If we found a pivot # Find the smallest element on the right of the pivot that is greater than the pivot j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap the pivot with this element nums[i], nums[j] = nums[j], nums[i] # Reverse the elements to the right of the pivot nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"# OrderedStack Challenge Scenario You are tasked with implementing an ordered stack data structure where each push operation maintains the elements in a sorted order. The stack should ensure that the highest value is always at the top and the lowest at the bottom, adapting the traditional Last In First Out (LIFO) behavior to maintain ordering. Task Implement the `OrderedStack` class with the following methods: - `__init__(self)`: Initializes an empty stack. - `is_empty(self)`: Returns `True` if the stack is empty, else `False`. - `push(self, item)`: Inserts `item` into the stack while maintaining its sorted order. - `pop(self)`: Removes and returns the topmost item from the stack. Raises `IndexError` if the stack is empty. - `peek(self)`: Returns the topmost item without removing it. - `size(self)`: Returns the number of elements in the stack. Input and Output formats - `push(item)`: Receives an integer `item` and does not return any value. - `pop()`: Returns an integer which is the topmost element of the stack. - `peek()`: Returns an integer which is the topmost element of the stack. - `is_empty()`: Returns a boolean value indicating if the stack is empty. - `size()`: Returns an integer indicating the number of elements in the stack. Constraints - All elements in the stack will be integers. - Ensure that the order is maintained during the `push` operation and adheres to `pop` and `peek` behaviors typical to stacks. - Avoid use of built-in sorting functions. Example Usage ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) print(stack.pop()) # prints: 3 print(stack.peek()) # prints: 2 print(stack.size()) # prints: 2 print(stack.is_empty()) # prints: False stack.pop() stack.pop() print(stack.is_empty()) # prints: True ``` Ensure to handle edge cases like popping or peeking from an empty stack properly.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): # Find the correct position for the new item position = len(self.stack) for i in range(len(self.stack)): if self.stack[i] > item: position = i break self.stack.insert(position, item) def pop(self): if self.is_empty(): raise IndexError(\\"Pop from an empty stack\\") return self.stack.pop(-1) def peek(self): if self.is_empty(): raise IndexError(\\"Peek from an empty stack\\") return self.stack[-1] def size(self): return len(self.stack)"},{"question":"# Coding Task Scenario: In your work as a software developer, you often encounter systems of simultaneous congruences while dealing with various cryptographic protocols. To ensure the security and efficiency of your system, you must implement a reliable function that finds solutions to these systems using the Chinese Remainder Theorem efficiently. Task: Implement the function `solve_chinese_remainder(nums: List[int], rems: List[int]) -> int` to solve the following problem: Given two lists `nums` and `rems` of equal length N where `nums` contains pairwise coprime integers greater than 1 and `rems` contains the respective remainders, compute and return the smallest non-negative integer `x` such that: ``` x % nums[i] == rems[i] for all i in range(N) ``` Input Format: - `nums`: List of N integers (2 <= N <= 10^4), each > 1, all pairwise coprime. - `rems`: List of N integers (0 <= rems[i] < nums[i]). Output Format: - An integer `x`, the smallest non-negative integer that satisfies the given system of congruences. Constraints: - Ensure the function throws a meaningful exception if the inputs are invalid (e.g., mismatched lengths, non-pairwise coprime numbers, nums contains numbers <= 1). Example: ```python nums = [3, 5, 7] rems = [2, 3, 2] print(solve_chinese_remainder(nums, rems)) # Output should be 23 ``` **Function Signature**: ```python def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: # your code here ``` **Note**: It is critical to handle potential edge cases, validate inputs effectively, and consider performance optimization for large datasets.","solution":"from typing import List def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def mod_inverse(a, m): gcd, x, _ = extended_gcd(a, m) if gcd != 1: raise ValueError(f\\"No modular inverse for {a} and {m} as they are not coprime.\\") else: return x % m def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: if len(nums) != len(rems): raise ValueError(\\"The lists nums and rems must have the same length.\\") N = len(nums) # Validate that nums are pairwise coprime and greater than 1 for i in range(N): if nums[i] <= 1: raise ValueError(f\\"All numbers in nums must be greater than 1. Invalid number found: {nums[i]}\\") for j in range(i+1, N): gcd, _, _ = extended_gcd(nums[i], nums[j]) if gcd != 1: raise ValueError(f\\"Numbers {nums[i]} and {nums[j]} are not coprime.\\") product = 1 for num in nums: product *= num result = 0 for i in range(N): partial_product = product // nums[i] # Compute modular inverse of partial_product mod nums[i] inverse = mod_inverse(partial_product, nums[i]) result += rems[i] * partial_product * inverse return result % product"},{"question":"# Linked List Length Calculation You are given a singly linked list. Your task is to implement a function that calculates the length of the list. The function should be efficient in terms of time complexity. **Function Signature**: ```python def calculate_length(head: ListNode) -> int: ``` **Input**: * `head` (ListNode): The head node of a singly linked list, where each node has the attributes `val` (an integer) and `next` (a reference to the next node in the linked list or `None` if it is the end of the list). **Output**: * An integer representing the length of the linked list. **Constraints**: * The number of nodes in the linked list is at most 10^4. **Performance Requirements**: The implementation should be efficient, with a linear time complexity O(n), where n is the number of nodes in the linked list. **Example**: ```python # Example ListNode Class class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example usage: # Creating a linked list: 1 -> 2 -> 3 head = ListNode(1, ListNode(2, ListNode(3))) # Calling calculate_length function print(calculate_length(head)) # Output should be 3 ``` Make sure your implementation handles edge cases such as an empty list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def calculate_length(head: ListNode) -> int: Returns the length of a singly linked list. Parameters: head (ListNode): The head node of a singly linked list. Returns: int: The length of the linked list. length = 0 current = head while current: length += 1 current = current.next return length"},{"question":"# Question: Counting Set Bits using Brian Kernighan’s Algorithm Implement a function that takes an unsigned integer and returns the number of \'1\' bits it has (also known as the Hamming weight). Your implementation should use Brian Kernighan’s algorithm and should have the following function signature: Function Signature ```python def count_ones_recur(n: int) -> int: pass def count_ones_iter(n: int) -> int: pass ``` Input - An unsigned integer `n` (0 ≤ n ≤ (2^{31} - 1)) Output - An integer representing the number of \'1\' bits in the binary representation of `n`. Performance Constraints - Your solution should have a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of `n`. - Space complexity should be O(1). Example ```python assert count_ones_recur(11) == 3 # 00000000000000000000000000001011 assert count_ones_iter(11) == 3 # 00000000000000000000000000001011 assert count_ones_recur(32) == 1 # 00000000000000000000000000100000 assert count_ones_iter(32) == 1 # 00000000000000000000000000100000 ``` Constraints - You must consider the efficiency in terms of time and space complexity even with large input sizes. - Your code should be clear and handle edge cases such as `n` being zero.","solution":"def count_ones_recur(n: int) -> int: Recursively counts the number of \'1\' bits in the binary representation of the given integer n using Brian Kernighan’s algorithm. if n == 0: return 0 else: return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Iteratively counts the number of \'1\' bits in the binary representation of the given integer n using Brian Kernighan’s algorithm. count = 0 while n: n = n & (n - 1) count += 1 return count"},{"question":"Clone an Undirected Graph Objective: Implement a function to clone an undirected graph. Your implementation should demonstrate a deep understanding of graph traversal and cloning algorithms using BFS and DFS, both iteratively and recursively. Problem Context: An undirected graph node is represented by the `UndirectedGraphNode` class that contains a label and a list of neighboring nodes. Write a function to perform a deep clone of the graph provided through such a node. Function Signature: ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': pass ``` Input: * A reference to a node in an undirected graph (or `None` for an empty graph). Output: * A deep clone of the graph that is represented by the input node. Constraints: 1. Nodes are uniquely labeled. 2. If the input graph is empty, return `None`. Example: For the graph serialized as `{0,1,2#1,2#2,2}`: ``` 1 / / 0 --- 2 / _/ ``` * Suppose `node` points to the node labeled `0` in this graph. * Your function should return the deep clone of the entire graph starting from this node. Performance Expectations: * Your function should be efficient in both time and space, handling graphs with multiple nodes and connections appropriately. * Aim for O(N + E) time complexity and O(N) space complexity. # Additional Notes: * You may use any form of graph traversal (BFS or DFS) you are comfortable with. * Ensure your solution handles cycles and self-loops correctly. * Consider providing tests for various edge cases like isolated nodes, empty graphs, and highly interconnected nodes. Hints: 1. Utilize a dictionary to map original nodes to their respective clones. 2. Ensure each node is visited and cloned exactly once.","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph(node): if node is None: return None def dfs(node, cloned_nodes): if node in cloned_nodes: return cloned_nodes[node] clone = UndirectedGraphNode(node.label) cloned_nodes[node] = clone for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor, cloned_nodes)) return clone return dfs(node, {})"},{"question":"Context: In mathematics, an integer partition of a positive integer is a way of writing it as a sum of positive integers. Two sums that differ only in the order of their addends are considered the same partition. Task: You are required to implement a function `int_divide` that computes the number of ways to partition a positive integer into a sum of positive integers. The function should use dynamic programming to ensure efficiency. Function Signature: ```python def int_divide(decompose: int) -> int: pass ``` Input: - `decompose` (int): A positive integer `n` (1 ≤ n ≤ 1000). Output: - Returns an integer representing the number of ways the input integer can be partitioned. Example: ```python assert int_divide(4) == 5 # Explanation: 4=4, 4=3+1, 4=2+2, 4=2+1+1, 4=1+1+1+1 assert int_divide(7) == 15 # Explanation as described earlier ``` Constraints: - The function should have a time complexity of O(n^2). - The function should have a space complexity of O(n^2). Guidelines: 1. Create a 2D array `arr` where `arr[i][j]` will store the number of partitions of `i` using numbers up to `j`. 2. Initialize the array and set up base cases. 3. Use nested loops to fill the array based on partition properties. 4. Return the value in `arr[decompose][decompose]` which contains the final answer. Notes: 1. Handle edge cases where `decompose` is 1, as the only partition is `1` itself. 2. Ensure to address any performance issues to stay within the expected constraints.","solution":"def int_divide(decompose: int) -> int: if decompose <= 0: return 0 # Initialize a 2D array with zeroes arr = [[0] * (decompose + 1) for _ in range(decompose + 1)] # Base case: There is one way to partition 0 (using no parts at all) for i in range(decompose + 1): arr[0][i] = 1 # Fill the array for i in range(1, decompose + 1): for j in range(1, decompose + 1): if j > i: arr[i][j] = arr[i][i] else: arr[i][j] = arr[i][j-1] + arr[i-j][j] return arr[decompose][decompose]"},{"question":"# Find the Missing Number in the Sequence **Problem Statement**: Given an array of unique integers `nums` where each integer is in the range `[0, n]` inclusive and exactly one integer is missing from the range, write a function to find the missing integer. If the sequence is already complete, return the next integer in the sequence. **Function Signature**: ```python def find_missing_number(nums: List[int]) -> int: # Your implementation here ``` **Input**: - `nums` (List[int]): A list of unique integers in the range `[0, n]` with exactly one integer missing. **Output**: - (int): The missing integer from the sequence or the next integer if the sequence is complete. **Examples**: 1. Input: `nums = [4, 1, 3, 0, 6, 5, 2]` Output: `7` 2. Input: `nums = [0, 1, 3]` Output: `2` 3. Input: `nums = [0, 1, 2, 3]` Output: `4` **Constraints**: - The length of `nums` is `n`, where `n` is in the range `[0, 10^5]`. - All values in `nums` are unique and in the range `[0, n]`. **Performance Requirements**: - The solution should have O(n) time complexity. - The solution should have O(1) space complexity. # Example Scenario: Consider a list representing attendance of students marked with their ID numbers in a class where IDs are sequentially labeled. If one student did not mark attendance, use the provided function to identify which student missed signing in. ```python # Example usage: nums = [0, 1, 2, 4, 5] missing_number = find_missing_number(nums) # Should return 3, as student with ID 3 is missing. print(missing_number) ```","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number in the sequence of unique integers. If no number is missing, returns the next number in the sequence. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"You are given a square matrix representing a digital image. Write functions to perform the following matrix transformations: rotating the matrix 90 degrees clockwise, rotating it 90 degrees counterclockwise, inverting it from the top left corner, and inverting it from the bottom left corner. Each transformation should be implemented as a separate function. # Functional Requirements 1. `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A square matrix, `matrix`, where `matrix[i][j]` is an integer representing the pixel at row `i` and column `j`. - **Output**: A new matrix, rotated 90 degrees to the right (clockwise). 2. `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A square matrix, `matrix`. - **Output**: A new matrix, rotated 90 degrees to the left (counterclockwise). 3. `top_left_invert(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A square matrix, `matrix`. - **Output**: A new matrix, where the order of rows is reversed, and then elements are pushed into columns. 4. `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A square matrix, `matrix`. - **Output**: A new matrix, where the order of rows is reversed, and elements within each row are also reversed. # Constraints - Each function should handle a matrix with dimensions between 1x1 and 100x100. - The input matrix will always be a valid square matrix containing integers. # Performance Requirements - Ensure that each function operates within O(n^2) time complexity and uses O(n^2) additional space. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(top_left_invert(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(bottom_left_invert(matrix)) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Edge Cases - Single element matrix. - Empty matrix (should return another empty matrix). - Non-square matrices (although constrained to square matrices in this problem). # Notes - Ensure proper handling of IndexError exceptions. - Optimize the matrix creation by pre-allocating lists where possible to avoid multiple insertions and enhancements.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the input square matrix 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the input square matrix 90 degrees counterclockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[n - 1 - j][i] = matrix[i][j] return rotated def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the matrix from the top left corner to the bottom right corner. n = len(matrix) inverted = [[matrix[i][j] for i in range(n)] for j in range(n)] return inverted def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the matrix from the bottom left corner to the top right corner. n = len(matrix) inverted = [[matrix[n - 1 - i][j] for j in range(n)] for i in range(n)] return inverted"},{"question":"You are given an array of integers. Your task is to implement the sorting algorithm \'Cycle Sort\' to sort the array in non-decreasing order. Note that the input array can have duplicate elements and can have negative numbers as well. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input * **arr**: A list of integers, where 1 leq len(arr) leq 10^4 and each integer -10^9 leq arr[i] leq 10^9. # Output * Return the sorted list. # Constraints * This implementation should sort the array in-place with a focus on space efficiency. * Avoid additional data structures proportional to the input size. * Handle edge cases such as an array with a single element or already sorted arrays. # Example ```python # Example 1 arr = [4, 5, 3, 2, 4, 1] output = cycle_sort(arr) # Expected output: [1, 2, 3, 4, 4, 5] # Example 2 arr = [-1, -2, 0, 1, 2] output = cycle_sort(arr) # Expected output: [-2, -1, 0, 1, 2] # Example 3 arr = [5] output = cycle_sort(arr) # Expected output: [5] ``` **Explanation**: 1. Cycle sort the given arrays considering edge cases and constraints. 2. Ensure the algorithm operates efficiently within the expected complexity boundaries.","solution":"def cycle_sort(arr): Applies Cycle Sort on the given array to sort it in non-decreasing order. The array is sorted in place. n = len(arr) for start in range(n - 1): item = arr[start] # Find position where we put the element pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the element is already in correct position if pos == start: continue # Otherwise, put the item there or right after any duplicates while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Recursive Stooge Sort Implementation You are tasked with implementing the Stooge Sort algorithm. Given an array of integers, write a function to sort the array in ascending order using the Stooge Sort algorithm. # Requirements * **Input**: An array of integers `arr` where `1 <= arr.length <= 1000` and `-1000 <= arr[i] <= 1000`. * **Output**: A sorted array in ascending order. # Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # your code here ``` # Constraints 1. Your function should modify the input array in-place. 2. Performance constraints: Although Stooge Sort is inherently slow, ensure your implementation correctly follows the Stooge Sort logic. # Example ```python arr = [5, 3, 2, 8, 1, 4] stoogesort(arr, 0, len(arr)-1) print(arr) # Output: [1, 2, 3, 4, 5, 8] ``` # Notes - Implement the Stooge Sort algorithm recursively as discussed. - Ensure your function adheres to the given signature and modifies the array in-place.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return # If the element at the start is greater than the element at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort last 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort first 2/3 of the array again stoogesort(arr, l, h - t)"},{"question":"You are tasked with implementing a function to compute the square root of a given positive integer ( N ) with a maximum absolute error ( P ). Assume the Newton-Raphson method for iterative improvement of guesses. Function Signature ```python def square_root(n: int, epsilon: float = 0.001) -> float: pass ``` Input - **n** (int): A positive integer whose square root is to be calculated. ( 1 leq N leq 10^9 ). - **epsilon** (float): A precision factor specifying the maximum absolute error allowed. ( 1e-14 leq P leq 1e-1 ). Output - **Square Root** (float): The square root of ( N ), such that the absolute error of the result is within ( P ). Constraints - Your solution should handle edge cases such as ( N = 1 ) and ( N = 0 ). - Ensure that your algorithm converges efficiently and watch out for possible sources of numerical instability. Example ```python # Example 1 result = square_root(5, 0.001) print(result) # Expected: ~2.236 within the bounds of precision 0.001 # Example 2 result = square_root(2, 1e-6) print(result) # Expected: ~1.414213 within the bounds of precision 1e-6 # Example 3 result = square_root(1, 0.0001) print(result) # Expected: 1.0 (since square root of 1 is 1 with any precision) ``` Implement the function `square_root` in the optimal way, adhering to the constraints and ensuring efficiency.","solution":"def square_root(n: int, epsilon: float = 0.001) -> float: Computes the square root of a given positive integer N using the Newton-Raphson method, such that the result is within the maximum absolute error P. Parameters: n (int): The positive integer number to find square root of. epsilon (float): The precision factor specifying the maximum absolute error allowed. Returns: float: The square root of N within the specified precision. if n == 0 or n == 1: return float(n) guess = n / 2.0 while True: new_guess = (guess + n / guess) / 2.0 if abs(new_guess - guess) < epsilon: return new_guess guess = new_guess"},{"question":"# Repeat String Match Algorithm Implementation Problem Description You are given two strings `A` and `B`. Your task is to write a function `repeat_string(A: str, B: str) -> int` that finds the minimum number of times `A` has to be repeated such that `B` is a substring of the repeated version of `A`. If no such solution exists, return -1. Input and Output Formats - **Input**: - `A`: A string with a length between 1 and 10,000 characters. - `B`: A string with a length between 1 and 10,000 characters. - **Output**: - An integer representing the number of times `A` needs to be repeated such that `B` becomes a substring. If it is not possible, return -1. Constraints - The input strings will only contain lowercase English alphabet characters. - The length of A and B will be between 1 and 10,000. Example ```python assert repeat_string(\\"abcd\\", \\"cdabcdab\\") == 3 assert repeat_string(\\"a\\", \\"aaaaa\\") == 5 assert repeat_string(\\"abc\\", \\"cabcabcab\\") == 4 ``` Scenario Imagine you are developing a text processing tool that needs to check if a pattern can be found within repetitive sequences of a shorter string. This function will be a core component of that tool.","solution":"def repeat_string(A: str, B: str) -> int: Finds the minimum number of times A has to be repeated such that B is a substring. If no such solution exists, returns -1. # The minimum number of repeats is dictated by the ceil division of len(B) by len(A) min_repeats = -(-len(B) // len(A)) # Create the potential repeated strings to check for i in range(2): if B in A * (min_repeats + i): return min_repeats + i return -1"},{"question":"Palindrome Product Context A palindrome is a string that reads the same forwards and backwards, ignoring non-alphanumeric characters and case. Beyond checking for single palindromes, your task is to find the largest palindrome formed by the product of two n-digit numbers. Task Write a function to find and return the largest palindrome that can be formed by the product of two n-digit numbers. You are required to implement the function using an efficient approach to identify the palindrome. Function Signature ```python def largest_palindrome_product(n: int) -> int: pass ``` Input - `n` (integer): Number of digits for the multiplicands (1 <= n <= 4). Output - Returns an integer which is the largest palindromic product of two n-digit numbers. Example ```python # Example 1 print(largest_palindrome_product(2)) # Output: 9009 (since 91 * 99 = 9009 which is the largest palindrome under 2-digit multiplicands) # Example 2 print(largest_palindrome_product(3)) # Output: 906609 (since 913 * 993 = 906609 which is the largest palindrome under 3-digit multiplicands) ``` Constraints - This problem involves generating n-digit products and checking for the largest palindromic number. Ensure your solution is both time and space efficient to handle the range of multiplicands where `n` can be up to 4. Notes - Consider edge cases where the largest palindrome might involve multiplicands at the boundaries of the n-digit range. - Single digit numbers should yield the largest possible single-pair palindrome (9 in the case of n=1). Testing - Ensure to test with various values of `n` to validate the correctness and performance of your code.","solution":"def largest_palindrome_product(n: int) -> int: def is_palindrome(x: int) -> bool: s = str(x) return s == s[::-1] max_num = 10**n - 1 min_num = 10**(n-1) largest_palindrome = 0 for i in range(max_num, min_num - 1, -1): for j in range(i, min_num - 1, -1): product = i * j if product <= largest_palindrome: break if is_palindrome(product): largest_palindrome = product return largest_palindrome"},{"question":"# Prime Number Sequence Check Given a list of integers, implement a function that returns a new list containing only the prime numbers from the original list. Function Signature ```python def filter_primes(numbers: List[int]) -> List[int]: pass ``` # Input - A list of integers (`numbers`) where each element `n` satisfies `0 <= n <= 10^6`. # Output - A list of integers containing only the prime numbers from the input list, in the same order as they appeared. # Example ```python numbers = [10, 15, 3, 7, 23, 30] filter_primes(numbers) -> [3, 7, 23] ``` # Constraints - If the input list is empty, return an empty list. - Ensure minimal time complexity in the context of list length and integer size constraints. # Notes - Optimize for time and space. - Reuse the `prime_check` function provided above to create an efficient solution.","solution":"from typing import List def is_prime(n: int) -> bool: Determines if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers: List[int]) -> List[int]: Filters out the prime numbers from the list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"Scenario Run-length encoding (RLE) is a simple and efficient algorithm for compressing data with many repeated characters. As a software engineer at a data storage company, you\'ve been tasked with implementing a variation of RLE with an additional feature that groups consecutive sequences separately. This advanced version should be capable of correctly handling sequences within sequences, such as nested runs of characters. Task Implement two main functions, `advanced_encode_rle` and `advanced_decode_rle`, for this advanced run-length encoding algorithm. Function Itinerary 1. **advanced_encode_rle(input: str) -> str** - **Input**: A string of data to be encoded. - **Output**: The encoded string with nested sequence recognition. - **Construction**: Generate a run-length encoded string considering sequences within sequences. 2. **advanced_decode_rle(input: str) -> str** - **Input**: A string of encoded data as per advanced RLE specification. - **Output**: The original string data by decoding the run-length encoded string. - **Construction**: Correctly decompress the encoded string to reveal the original sequence, even with nested sequences. Constraints * Each sequence within the input is guaranteed to be valid and correctly formatted. * The encoded data will not contain invalid characters or formats. * Handle strings length up to (10^6). Example ```python # Example of usage: input_str = \'aaabccccccaa\' encoded = advanced_encode_rle(input_str) # Encoded should be: \'3a1b6c2a\' print(encoded) decoded = advanced_decode_rle(encoded) # Decoded should be: \'aaabccccccaa\' print(decoded) ```","solution":"def advanced_encode_rle(data): Encodes a given string using advanced run-length encoding. Parameters: data (str): The input string to encode. Returns: str: The run-length encoded string. if not data: return \\"\\" encoded_string = \\"\\" i = 0 while i < len(data): count = 1 while i + 1 < len(data) and data[i] == data[i + 1]: i += 1 count += 1 encoded_string += str(count) + data[i] i += 1 return encoded_string def advanced_decode_rle(encoded_data): Decodes a run-length encoded string. Parameters: encoded_data (str): The encoded string to decode. Returns: str: The decoded original string. if not encoded_data: return \\"\\" decoded_string = \\"\\" i = 0 while i < len(encoded_data): count_str = \\"\\" while encoded_data[i].isdigit(): count_str += encoded_data[i] i += 1 count = int(count_str) decoded_string += encoded_data[i] * count i += 1 return decoded_string"},{"question":"# Problem Description You are given a stack of integers, where the bottom of the stack represents the first added element and the top represents the most recently added element. Your task is to write a function that doubles each element in the stack, such that every element is immediately followed by a duplicate of itself. # Function Signature ```python def stutter(stack: list[int]) -> list[int]: ``` # Input - A list of integers `stack` which behaves like a stack, where: - `stack[-1]` is the top of the stack. - `stack[0]` is the bottom of the stack. # Output - The modified stack after replacing each value with two occurrences of that value. # Constraints - The input list will have at most 10^5 elements. - Each element will be an integer within the range of [-10^9, 10^9]. # Example 1. Input: `[3, 7, 1, 14, 9]` - Output: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` 2. Input: `[5]` - Output: `[5, 5]` 3. Input: `[]` - Output: `[]` # Context Imagine you are processing a sequence of tasks, each represented by an integer in a stack. For auditing purposes, each task must be logged twice consecutively. Your function should modify the stack in-place (i.e., without creating a new list), if possible, to satisfy this requirement. You may assume you have access to a secondary stack or queue for temporary storage. # Requirements - The code should handle all edge cases efficiently. - Minimize memory usage while keeping the code readable and maintainable.","solution":"def stutter(stack: list[int]) -> list[int]: Doubles each element in the stack such that each element is immediately followed by a duplicate of itself. result = [] for element in stack: result.append(element) result.append(element) return result"},{"question":"# Pigeonhole Sort Implementation Challenge **Background**: Pigeonhole Sort is a sorting algorithm that is efficient when the number of elements and the range of key values are approximately the same. The algorithm works by placing each element in its appropriate \\"hole\\" based on its value and then assembling the sorted elements from these \\"holes\\". **Problem**: Write a function `pigeonhole_sort(arr)` that sorts an array of integers using the pigeonhole sorting algorithm. # Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr`: A list of integers `arr` where `-10^6 ≤ arr[i] ≤ 10^6`. The length of the list will be between 1 and 10^6. # Output: - The function should return a new list of integers that contains all the elements from `arr` in sorted order. # Constraints: - The function should handle negative numbers correctly. - The function should handle large ranges efficiently. - Avoid excessive memory usage. # Examples: 1. **Example 1**: ```python pigeonhole_sort([8, 3, 2, 7, 4]) ``` Output: ```python [2, 3, 4, 7, 8] ``` 2. **Example 2**: ```python pigeonhole_sort([-4, -1, -3, -2, 0, 2, 1]) ``` Output: ```python [-4, -3, -2, -1, 0, 1, 2] ``` 3. **Example 3**: ```python pigeonhole_sort([5, 5, -5, -5, 0]) ``` Output: ```python [-5, -5, 0, 5, 5] ``` # Performance Requirements: - The function should run in O(n + Range) time where `n` is the number of elements and `Range` is the difference between the maximum and minimum values in `arr`. - Minimize additional space usage beyond the \\"holes\\" array. # Note: Consider edge cases such as: - Already sorted arrays. - Arrays with all identical elements.","solution":"def pigeonhole_sort(arr): if not arr: return arr min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 holes = [0] * range_of_elements for num in arr: holes[num - min_val] += 1 sorted_arr = [] for i in range(range_of_elements): count = holes[i] while count > 0: sorted_arr.append(i + min_val) count -= 1 return sorted_arr"},{"question":"You have been hired to develop a simple text validation system. The system needs to detect slight differences between two strings to provide suggestions or corrections to users. Specifically, you need to write a function to determine if two strings are one edit distance apart. Two strings are considered to be one edit distance apart if you can: - Insert a single character into one string to make the strings equal. - Delete a single character from one string to make the strings equal. - Replace a single character in one string to make the strings equal. Write a function `is_one_edit_distance(s: str, t: str) -> bool`: # Input: - Two strings `s` and `t`, where `0 <= len(s), len(t) <= 1000`. # Output: - A boolean value indicating whether the two strings are one edit distance apart. # Constraints: - You must handle all edge cases, such as both strings being empty, identical strings, or lengths differing by more than one. - Optimize for both time (O(n)) and space (O(1)) complexities. # Examples: ```python assert is_one_edit_distance(\\"abc\\", \\"ab\\") == True # one deletion assert is_one_edit_distance(\\"ab\\", \\"abc\\") == True # one insertion assert is_one_edit_distance(\\"abc\\", \\"adc\\") == True # one replacement assert is_one_edit_distance(\\"abc\\", \\"def\\") == False # more than one edit assert is_one_edit_distance(\\"\\", \\"\\") == False # both strings are empty, no edits possible assert is_one_edit_distance(\\"a\\", \\"\\") == True # one deletion assert is_one_edit_distance(\\"\\", \\"a\\") == True # one insertion assert is_one_edit_distance(\\"a\\", \\"a\\") == False # strings are already equal ``` # Implementation: ```python def is_one_edit_distance(s: str, t: str) -> bool: l1, l2 = len(s), len(t) if abs(l1 - l2) > 1: return False for i in range(min(l1, l2)): if s[i] != t[i]: # If lengths are equal, it should be a replacement if l1 == l2: return s[i + 1:] == t[i + 1:] # If l1 < l2, it should be an insertion in s or deletion in t if l1 < l2: return s[i:] == t[i + 1:] # If l1 > l2, it should be a deletion in s or insertion in t return s[i + 1:] == t[i:] # Edge case for strings like \\"a\\", \\"ab\\" or \\"abc\\",\'abcx\' where no mismatch has been found return abs(l1 - l2) == 1 # Test your function with provided examples ```","solution":"def is_one_edit_distance(s: str, t: str) -> bool: l1, l2 = len(s), len(t) if abs(l1 - l2) > 1: return False for i in range(min(l1, l2)): if s[i] != t[i]: # If lengths are equal, it should be a replacement if l1 == l2: return s[i + 1:] == t[i + 1:] # If l1 < l2, it should be an insertion in s or deletion in t if l1 < l2: return s[i:] == t[i + 1:] # If l1 > l2, it should be a deletion in s or insertion in t return s[i + 1:] == t[i:] # Edge case for strings like \\"a\\", \\"ab\\" or \\"abc\\",\'abcx\' where no mismatch has been found return abs(l1 - l2) == 1"},{"question":"# Question: Implement Custom Hash Map with Optimized Dynamic Resizing You are asked to implement a hash table similar to the above `ResizableHashTable` that supports the operations `put`, `get`, and `delete` with optimized resizing strategy. 1. **Functionality**: - `put(key, value)`: Add a key-value pair to the hash table. Resize dynamically when the table reaches 75% of its capacity. - `get(key)`: Retrieve the value for a given key. - `del_(key)`: Remove the key-value pair for a given key. - `len()`: Return the number of key-value pairs currently stored. 2. **Behavior**: - Manage collisions with linear probing. - Ensure that operations (put, get, delete) maintain an average O(1) complexity. Resize the table dynamically by doubling the size when it reaches 75% of its capacity to keep operations efficient. 3. **Edge Cases**: - Inserting duplicate keys should update the value without adding a new entry. - Deleting a key that doesn’t exist should not affect the hash table. - Ensure the resizing operation transfers all existing keys correctly. Implement the `CustomHashTable` class with the above constraints. You are provided with an initial code structure to begin with. ```python class CustomHashTable: _empty = object() _deleted = object() def __init__(self, initial_size=8): self.size = initial_size self._len = 0 self._keys = [self._empty] * initial_size # keys self._values = [self._empty] * initial_size # values def put(self, key, value): # Implement the put method along with dynamic resizing. pass def get(self, key): # Implement the get method pass def del_(self, key): # Implement the delete method pass def __len__(self): return self._len def _resize(self): # Implement the resizing mechanism pass def _hash(self, key): return key % self.size def _rehash(self, old_hash): # Perform linear probing return (old_hash + 1) % self.size # Example Usage: # h = CustomHashTable() # h.put(1, \'a\') # h.put(2, \'b\') # print(h.get(1)) # Should output \'a\' # h.del_(1) # print(h.get(1)) # Should output None # h.put(3, \'c\') # assert len(h) == 2 ``` **Constraints**: * Key is guaranteed to be a non-negative integer. * Value can be any object. * The initial size of the hash table is 8. * Table should dynamically resize when 75% full.","solution":"class CustomHashTable: _empty = object() _deleted = object() def __init__(self, initial_size=8): self.size = initial_size self._len = 0 self._keys = [self._empty] * initial_size # keys self._values = [self._empty] * initial_size # values def put(self, key, value): if self._len >= self.size * 0.75: self._resize() index = self._hash(key) original_index = index while self._keys[index] not in {self._empty, self._deleted, key}: index = self._rehash(index) if index == original_index: raise Exception(\\"HashTable is full\\") if self._keys[index] in {self._empty, self._deleted}: self._len += 1 self._keys[index] = key self._values[index] = value def get(self, key): index = self._hash(key) original_index = index while self._keys[index] is not self._empty: if self._keys[index] == key: return self._values[index] index = self._rehash(index) if index == original_index: break return None def del_(self, key): index = self._hash(key) original_index = index while self._keys[index] is not self._empty: if self._keys[index] == key: self._keys[index] = self._deleted self._values[index] = self._deleted self._len -= 1 return index = self._rehash(index) if index == original_index: break def __len__(self): return self._len def _resize(self): old_keys = self._keys old_values = self._values self.size *= 2 self._keys = [self._empty] * self.size self._values = [self._empty] * self.size self._len = 0 for key, value in zip(old_keys, old_values): if key not in {self._empty, self._deleted}: self.put(key, value) def _hash(self, key): return key % self.size def _rehash(self, old_hash): return (old_hash + 1) % self.size"},{"question":"Scenario You are working on a library for financial applications where extremely large numbers are frequently used in computations. These numbers are represented as linked lists where each node contains a digit of the number in reverse order. Problem Statement Write a function `add_two_numbers(left: Node, right: Node) -> Node` that adds two non-negative integers represented by linked lists. Each digit is stored in reverse order, with the least significant digit at the head of the list. Function Signature ```python def add_two_numbers(left: Node, right: Node) -> Node: # implementation ``` Input * `left` and `right`: Heads of two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order. Output * Returns the head of a linked list representing the sum of the two numbers, also in reverse order. Constraints * Both numbers do not contain any leading zeros, except the number 0 itself. * Each node contains a single digit (0-9). Example For the linked lists `(2 -> 4 -> 3) + (5 -> 6 -> 4)`: * **Input**: - left: 2 -> 4 -> 3 - right: 5 -> 6 -> 4 * **Output**: - Result: 7 -> 0 -> 8 Additional Details Provide implementations for the helper functions if necessary. The provided `Node` class you should use is: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` Performance Requirements * Ensure the function operates efficiently with a time complexity of O(max(m, n)) and handles edge cases appropriately. Testing Additionally, define test cases to validate your implementation: * Linked lists of different lengths * Crossing digits where the sum exceeds 9 * Cases where final result has additional leading digit due to carry over","solution":"class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(left: Node, right: Node) -> Node: dummy_head = Node(0) current = dummy_head carry = 0 while left is not None or right is not None: left_val = left.val if left is not None else 0 right_val = right.val if right is not None else 0 total = carry + left_val + right_val carry = total // 10 current.next = Node(total % 10) current = current.next if left is not None: left = left.next if right is not None: right = right.next if carry > 0: current.next = Node(carry) return dummy_head.next"},{"question":"Problem Statement You are given the root of a binary tree, and your task is to implement a function `reverse_level_order` that performs a reverse level order traversal of its nodes. In reverse level order traversal, we process nodes level by level from the bottom up, and within each level, we process nodes from left to right. # Function Signature ```python def reverse_level_order(root: TreeNode) -> List[List[int]]: # Your code here ``` # Input * `root`: A `TreeNode` representing the root of the binary tree. Nodes will have values from `-1000` to `1000`. * The binary tree is at most 1000 nodes in size. # Output * A list of lists, where each sublist contains the values of nodes at each level, starting from the bottommost level moving up to the root. # Constraints * You must use O(N) space for the solution. * You must traverse each node of the tree exactly once. # Example ```python # Tree structure: # 3 # / # 9 20 # / # 15 7 tree = TreeNode(3) tree.left = TreeNode(9) tree.right = TreeNode(20) tree.right.left = TreeNode(15) tree.right.right = TreeNode(7) assert reverse_level_order(tree) == [ [15, 7], [9, 20], [3] ] ``` # Explanation: - The bottom level has nodes [15, 7] - The next level has nodes [9, 20] - The top level has the root node [3] # Notes: - Ensure to handle the edge case where the tree is empty.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reverse_level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) # Instead of inserting at the end of result, we insert at the beginning result.insert(0, current_level) return result"},{"question":"# Coding Challenge **Scenario:** Your friend is implementing a text editor that supports various string manipulations. One feature is the ability to recognize if a given string can be derived by rotating another string. You decide to help by writing an efficient function to check for this condition. **Task:** Write a function `is_rotated` that determines if one string is a rotated version of another. Ensure your function is efficient in both time and space. Input: * Two strings, `s1` and `s2`. Output: * A boolean value: `True` if `s2` is a rotated version of `s1`, `False` otherwise. Constraints: * Both `s1` and `s2` consist of lowercase English letters. * The lengths of `s1` and `s2` do not exceed 1000. Requirements: 1. **Performance**: Your solution should be linear in time complexity. 2. **Edge Cases**: Consider cases where strings are empty, one character long, of different lengths, and identical. Examples: ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True assert is_rotated(\\"hello\\", \\"helol\\") == False assert is_rotated(\\"abcd\\", \\"dabc\\") == True assert is_rotated(\\"abcd\\", \\"abcd\\") == True assert is_rotated(\\"abcd\\", \\"\\") == False assert is_rotated(\\"\\", \\"\\") == True ``` **Function Signature**: ```python def is_rotated(s1: str, s2: str) -> bool: # your code here ```","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotated version of s1. Args: s1 (str): The first string. s2 (str): The second string to check if it is a rotated version of s1. Returns: bool: True if s2 is a rotated version of s1, False otherwise. if len(s1) != len(s2): return False if s1 == s2 == \\"\\": return True return s2 in (s1 + s1)"},{"question":"Given an array of integers `arr` and a number `k`, your task is to implement a function `max_sliding_window(arr, k)` that returns an array of the maximums for each sub-array (or window) of length `k` in `arr`. # Input - `arr`: A list of integers representing the array. - `k`: An integer representing the size of the sliding window. # Output - A list of integers representing the maximum for each sub-array of length `k`. # Constraints - The length of `arr` (n): 1 <= n <= 10^5 - The value of elements in `arr`: -10^4 <= arr[i] <= 10^4 - The length of the window `k`: 1 <= k <= n # Example Example 1 ```plaintext Input: arr = [1, 3, -1, -3, 5, 3, 6, 7], k = 3 Output: [3, 3, 5, 5, 6, 7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 ``` Example 2 ```plaintext Input: arr = [9, 11], k = 1 Output: [9, 11] Explanation: Each window contains only one element, so each element is the maximum of its window. ``` # Notes 1. If the array is empty or `k` is 0, return an empty list. 2. Ensure your solution is efficient with a time complexity of O(n). Any inefficiency may lead to timeouts on large inputs.","solution":"from collections import deque def max_sliding_window(arr, k): Returns a list of the maximum for each sub-array of length k in arr. Args: arr: List of integers representing the array. k: An integer representing the size of the sliding window. Returns: A list of integers representing the maximum for each sub-array of length k. if not arr or k == 0: return [] if k == 1: # If window size is 1, all elements are max by themselves. return arr result = [] dq = deque() for i in range(len(arr)): # Remove elements not within the sliding window (i.e., that are out of the window range) if dq and dq[0] < i - k + 1: dq.popleft() # Remove elements from the deque from the end that are smaller than the current element while dq and arr[dq[-1]] < arr[i]: dq.pop() # Add current element index to the deque dq.append(i) # Start adding maximums to the result after the first k-1 elements if i >= k - 1: result.append(arr[dq[0]]) return result"},{"question":"# Question You are tasked with implementing a feature for a mathematical simulation that involves frequent calculations with matrices. Specifically, you need to create a function to take a matrix and raise it to a specified power efficiently. Implement the function `matrix_exponentiation(matrix: list, power: int) -> list`. Input - `matrix`: A list of lists representing a square matrix of integers (eg: `[[1, 2], [3, 4]]`). - `power`: An integer `n` where `n >= 0`. Output A list of lists representing the matrix raised to the power `n`. Constraints - All matrices will be square (i.e., they have the same number of rows and columns). - Matrix elements are integers. - The size of the matrix (n x n) will not exceed 30x30. Function Signature ```python def matrix_exponentiation(matrix: list, power: int) -> list: pass ``` # Example ```python matrix = [ [2, 3], [4, 5] ] power = 2 output = matrix_exponentiation(matrix, power) # Output will be [ # [16, 21], # [28, 37] # ] ``` # Explanation The matrix exponentiation should be done using efficient repeated squaring to ensure the solution meets the performance requirements.","solution":"def matrix_multiply(A, B): n = len(A) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result def matrix_exponentiation(matrix, power): if power == 0: size = len(matrix) return [[1 if i == j else 0 for j in range(size)] for i in range(size)] result = matrix power -= 1 while power: if power % 2 == 1: result = matrix_multiply(result, matrix) matrix = matrix_multiply(matrix, matrix) power //= 2 return result"},{"question":"# Question: Minimum Distance from Buildings You are given a grid of dimensions ( N times M ) where each cell can contain one of the following values: * `0` - Represents an empty land, * `1` - Represents a building, * `2` - Represents an obstacle that cannot be crossed. Your goal is to find the smallest distance from a building to an empty land in the grid such that the distance is measured as the shortest path using only `0`s and avoiding `2`s. Use a breadth-first search (BFS) approach to find this distance from multiple buildings. Function Signature ```python def shortest_distance(grid: List[List[int]]) -> int: pass ``` Input * `grid`: A list of lists with dimensions ( N times M ). Each element is `0`, `1`, or `2`. Output * Return an integer representing the shortest distance from a building to an empty land. If there is no such path, return `-1`. Constraints * ( 1 leq N, M leq 100 ) * At least one building (1) in the grid. Example ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_distance(grid) == 7 ``` __Explanation:__ The shortest distance from any building to an empty land is `7`. Suitable selection of empty land maximizes joint proximity. Hints: * Use BFS to expand from buildings and track distances. * Ensure each cell is visited multiple times, and update distances accordingly.","solution":"from collections import deque def shortest_distance(grid): def bfs(starting_points, distances, reach): queue = deque(starting_points) visited = set(starting_points) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] distance = 0 while queue: distance += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) distances[nx][ny] += distance reach[nx][ny] += 1 queue.append((nx, ny)) if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) distances = [[0] * m for _ in range(n)] reach = [[0] * m for _ in range(n)] building_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: building_count += 1 bfs([(i, j)], distances, reach) min_distance = float(\'inf\') for i in range(n): for j in range(m): if grid[i][j] == 0 and reach[i][j] == building_count: min_distance = min(min_distance, distances[i][j]) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"You are given an array of integers where each integer represents the size of matrices such that the ith matrix\'s dimension is array[i-1] x array[i]. Your task is to implement a function that calculates the minimum number of multiplications needed to multiply the chain of matrices optimally. Additionally, you need to provide the optimal multiplication order. # Function Signature ```python def matrix_chain_order(array): :param array: List[int] - An array where each element represents the dimension of matrices. :return: Tuple(List[List[int]], List[List[int]]) - A tuple containing two matrices: cost matrix and solution matrix. ``` # Inputs * `array` (List[int]): An array where the length of the list is `n` and array contains the dimensions of the matrices such that ith matrix has dimensions `array[i-1] x array[i]`. # Outputs * Returns a tuple with two matrices: * **cost matrix** (List[List[int]]): DP table storing the minimum cost of multiplications. * **solution matrix** (List[List[int]]): Table storing the split positions to reconstruct the parenthesization. # Constraints * 1 <= len(array) <= 100 # Example ```python array = [30, 35, 15, 5, 10, 20, 25] matrix_chain_order(array) ``` Expected output should include: * Minimum number of multiplications required: 15125 * Optimal multiplication order: `( ( ( A1 A2 ) ( A3 A4 ) ) ( A5 A6 ) )` Implement the function `matrix_chain_order` considering the above constraints and requirements.","solution":"def matrix_chain_order(array): n = len(array) - 1 # Number of matrices # Initialize the cost matrix cost = [[float(\'inf\')] * n for _ in range(n)] # Initialize the solution matrix for optimal split positions solution = [[0] * n for _ in range(n)] # A single matrix multiplication cost is zero for i in range(n): cost[i][i] = 0 # l is chain length for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 cost[i][j] = float(\'inf\') for k in range(i, j): q = cost[i][k] + cost[k+1][j] + array[i] * array[k+1] * array[j+1] if q < cost[i][j]: cost[i][j] = q solution[i][j] = k return cost, solution def print_optimal_parenthesization(solution, i, j): if i == j: return f\\"A{i+1}\\" else: return f\\"({print_optimal_parenthesization(solution, i, solution[i][j])} {print_optimal_parenthesization(solution, solution[i][j] + 1, j)})\\" def get_optimal_order(array): cost, solution = matrix_chain_order(array) optimal_order = print_optimal_parenthesization(solution, 0, len(array) - 2) return cost, optimal_order"},{"question":"# Inorder Traversal Implementation and Analysis Scenario You are given a binary tree, and you need to traverse its nodes in inorder fashion. Your task is to implement both iterative and recursive methods for inorder traversal of the binary tree. The tree nodes store integer values, and you need to return a list of these values as they appear in inorder traversal. Task 1. **Implement the iterative inorder traversal** using a stack. 2. **Implement the recursive inorder traversal**. Requirements: * **Function Signatures**: * `def inorder_iterative(root: \'Node\') -> List[int]:` * `def inorder_recursive(root: \'Node\') -> List[int]:` * **Input**: The function receives the root node of the binary tree. * **Output**: The function should return a list of integers representing the inorder traversal of the tree. * **Constraints**: * The number of nodes in the tree is in the range [0, 1000]. * Node values are unique integers. Example Given the binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` Both functions (`inorder_iterative` and `inorder_recursive`) should return: ``` [25, 50, 75, 100, 125, 150, 175] ``` Implementation The iterative version utilizes a stack to track the nodes, whereas the recursive version directly operates through function calls. Consider efficient handling of edge cases such as empty trees and skewed trees.","solution":"from typing import List, Optional class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None def inorder_iterative(root: Optional[Node]) -> List[int]: result = [] stack = [] current = root while stack or current: # Reach the left most Node of the current Node while current: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() result.append(current.value) # We have visited the node and its left subtree. # Now, it\'s right subtree\'s turn current = current.right return result def inorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], acc: List[int]): if node: helper(node.left, acc) acc.append(node.value) helper(node.right, acc) result = [] helper(root, result) return result"},{"question":"# Polynomial Arithmetic Context: You have been given a representation of monomials and polynomials that supports various arithmetic operations, including addition, subtraction, multiplication, and division. You are tasked with implementing a function that simplifies a given polynomial by merging like terms and reducing the polynomial to its simplest form. Goal: Write a function `simplify_polynomial` that takes a list of Monomial objects as input, constructs a Polynomial object, and returns the simplified Polynomial object in its simplest form. Function Signature: ```python def simplify_polynomial(monomials: Iterable[Monomial]) -> Polynomial: pass ``` Input: - `monomials`: An iterable of `Monomial` objects. Output: - Returns the simplified `Polynomial` object. Constraints: 1. Each monomial in the polynomial may contain multiple variables and a coefficient. 2. The input list may contain monomials with similar variables but different coefficients. 3. Your function should reduce the polynomial by combining like terms and reducing fractions where possible. Example: Given the following Monomials: ```python monomials = [ Monomial({1: 2}, 3), # Represents 3(a_1)^2 Monomial({1: 2}, 4), # Represents 4(a_1)^2 Monomial({2: 3}, -1) # Represents -(a_2)^3 ] ``` The resulting simplified polynomial should be: ```python Polynomial([ Monomial({1: 2}, 7), # Combined 3(a_1)^2 and 4(a_1)^2 to get 7(a_1)^2 Monomial({2: 3}, -1) # Remains unchanged ]) ``` Evaluation Criteria: - **Correctness**: The function should accurately simplify the polynomial by combining like terms. - **Efficiency**: The function should handle large polynomials efficiently. - **Edge Cases**: Consider cases with empty monomials, zero coefficients, and non-matching monomials.","solution":"from collections import defaultdict from typing import Dict, List, Iterable class Monomial: def __init__(self, variables: Dict[int, int], coefficient: int): self.variables = variables self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): return hash(tuple(sorted(self.variables.items()))) class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def __eq__(self, other): if len(self.monomials) != len(other.monomials): return False return all(m in other.monomials for m in self.monomials) def simplify_polynomial(monomials: Iterable[Monomial]) -> Polynomial: monomial_dict = defaultdict(int) for monomial in monomials: variables_tuple = tuple(sorted(monomial.variables.items())) monomial_dict[variables_tuple] += monomial.coefficient simplified_monomials = [] for variables_tuple, coefficient in monomial_dict.items(): if coefficient != 0: variables = dict(variables_tuple) simplified_monomials.append(Monomial(variables, coefficient)) return Polynomial(simplified_monomials)"},{"question":"# Scenario You have become a cybersecurity expert, tasked with developing an efficient strategy that maximizes the value of data securement in a linear network of servers. Each server has a secured amount of data, but securing two directly connected servers will trigger a security alert. # Task Write a function `data_securement` that, given a list of non-negative integers representing the security value of each server, calculates the maximum security value without triggering the alert by securing two adjacent servers. # Function Signature ```python def data_securement(servers: List[int]) -> int: ``` # Input * List of integers `servers` where each integer represents security data value of a server. * `0 <= len(servers) <= 10^4` * `0 <= servers[i] <= 10^4` # Output * Return a single integer representing the maximum security value obtainable without triggering the alert. # Constraints * You cannot secure two directly connected servers. * The function should be optimized for both time and space complexity. # Example Input ```python [2, 7, 9, 3, 1] ``` Output ```python 12 ``` Explanation Secure servers with security values `2`, `9`, and `1` to get a total security value of 12, while not triggering the alert by securing adjacent servers. # Additional Notes * Handle edge cases where the list might be empty or contain only one server.","solution":"from typing import List def data_securement(servers: List[int]) -> int: if not servers: return 0 n = len(servers) if n == 1: return servers[0] # Initialize dp array to store the maximum security value for each index. dp = [0] * n dp[0] = servers[0] dp[1] = max(servers[0], servers[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + servers[i]) return dp[-1]"},{"question":"# **Efficient Power Computation** Context: In many computations, especially in cryptographic algorithms and competitive programming, calculating powers with large exponents is required. The naive method of multiplying the base repeatedly is inefficient and impractical. Instead, binary exponentiation provides an efficient way to compute power, even when dealing with very high exponents. Problem Statement: Implement an iterative function `power()` and a recursive function `power_recur()` to compute the power of a base number raised to an exponent, provided with an optional modulus to handle large results. Function Signatures: - Iterative: `def power(a: int, n: int, mod: int = None) -> int:` - Recursive: `def power_recur(a: int, n: int, mod: int = None) -> int:` Input: - `a` (int): The base number (1 ≤ a ≤ 10^9). - `n` (int): The exponent (0 ≤ n ≤ 10^12). - `mod` (Optional[int]): A modulus for large result reduction (2 ≤ mod ≤ 10^9), if provided. Output: An integer representing the result of `a` raised to the power `n`, optionally modulo `mod`. Example: ```python # Iterative power(2, 10) # Output: 1024 power(2, 10, 1000) # Output: 24 # Recursive power_recur(5, 3) # Output: 125 power_recur(5, 3, 100) # Output: 25 ``` # Constraints: - The functions must handle large values efficiently with an O(log(n)) time complexity. - If the exponent `n` is 0, both functions should return 1 irrespective of the base `a`. - Ensure correct modulo operations to avoid overflow. # Requirements: - Implement both `power()` and `power_recur()` as described. - Consider all edge cases and performance bottlenecks discussed in the analysis.","solution":"def power(a: int, n: int, mod: int = None) -> int: Iterative function to compute a raised to the power n with an optional modulus. result = 1 base = a % mod if mod else a while n > 0: if n % 2 == 1: # If n is odd, multiply the current base with the result result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: Recursive function to compute a raised to the power n with an optional modulus. if n == 0: return 1 half_power = power_recur(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod else half_power * half_power if n % 2 != 0: # If n is odd, multiply with base half_power = (half_power * a) % mod if mod else half_power * a return half_power"},{"question":"**Problem Statement**: You are building a system that requires preprocessing of user input strings by removing any reoccurring characters. Given a string `input_str`, write a function `remove_reoccurring_characters(input_str)` that removes any reoccurring characters and returns the new string maintaining the original order of characters. # Function Signature: ```python def remove_reoccurring_characters(input_str: str) -> str: ``` # Input: - `input_str`: A string (1 ≤ |input_str| ≤ 10^5) containing alphanumeric characters and possibly spaces. # Output: - A string with reoccurring characters removed while keeping the first occurrence of each character. # Constraints: - The string consists of printable ASCII characters. - The operations should be optimized for performance since the input size can be large. # Examples: 1. **Input**: \\"abcabcbb\\" **Output**: \\"abc\\" 2. **Input**: \\"hello world\\" **Output**: \\"helo wrd\\" 3. **Input**: \\"xyz\\" **Output**: \\"xyz\\" # Scenario: Consider the scenario where you have a system designed to log unique terms from user input for indexing purposes. To ensure no duplicates are indexed, you\'ve decided to preprocess the user input by removing reoccurring characters and logging only the first occurrence of each character. # Implementation Notes: - Ensure that the function performs efficiently even for large input strings. - Handle cases where the input string might be empty. - Maintain the order of characters as they first appear in the input string.","solution":"def remove_reoccurring_characters(input_str: str) -> str: Removes reoccurring characters from the input string while maintaining the order of first occurrence. seen = set() result = [] for char in input_str: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Pathfinder Robot on a Grid Scenario: A small robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. Problem: Write a function `unique_paths(m, n)` that takes two integers `m` and `n` as input and returns the number of possible unique paths that the robot can take to reach the bottom-right corner of the grid. Expected Input and Output Formats: - **Input**: Two integers, `m` (number of rows) and `n` (number of columns), with constraints: 1 ≤ m, n ≤ 100. - **Output**: An integer representing the number of unique paths. Example: ```python assert unique_paths(3, 7) == 28 print(unique_paths(3, 2)) # Expected output: 3 ``` Constraints: Ensure your solution handles larger values of `m` and `n` efficiently. # Requirements: 1. Your solution should be efficient with a time complexity of O(m * n). 2. Optimize the space complexity to O(min(m, n)). 3. Consider edge cases such as the smallest possible grid (1x1) and grids with only one row or one column. Brief Explanation: - The robot\'s movement can be visualized as a combinatorial problem involving paths through a grid. - The number of unique paths to reach each cell (i, j) is the sum of the unique paths to reach cells (i-1, j) and (i, j-1).","solution":"def unique_paths(m, n): Returns the number of unique paths from top-left to bottom-right in an m x n grid. # Use a single array to save space dp = [1] * n for i in range(1, m): for j in range(1, n): dp[j] += dp[j - 1] return dp[-1]"},{"question":"Tree Traversal and Printing You are given a hierarchical tree data structure representing different categories and their corresponding objects. Each object in the tree can have sub-objects denoted either by strings or further nested dictionaries. Your task is to implement a function `enhanced_tree_print(tree: dict) -> None` that prints the tree structure in a readable format, maintaining a clear indentation for nested elements. # Requirements: 1. **Input**: A dictionary representing a tree structure as input, similar to the format provided in the example. 2. **Output**: Print the tree structure to console in a readable nested format, ensuring one level of indentation for each level in the hierarchy. 3. **Constraints**: * Handle edge cases such as empty trees or trees with varied depths. * Ensure efficient handling with minimum lookups and proper formatting for mixed datatypes. 4. **Performance**: * Must run recursively with O(n) time complexity. # Example Tree Input: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', {\'Computer\': 7}] } ``` # Expected Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Hint: - Use recursion to handle nested dictionaries/scripts and ensure appropriate indentation is maintained. - Remember to cache dictionary look-ups to enhance performance. Write the function `enhanced_tree_print(tree: dict) -> None` to accomplish the task.","solution":"def enhanced_tree_print(tree, indent=0): Recursively print the tree structure in a readable nested format. Args: tree (dict): The tree structure to print. indent (int): The current indentation level (used for recursive calls). for key, value in tree.items(): print(\\" \\" * indent + str(key) + \\" ->\\", end=\' \') # Print the key with the appropriate indentation if isinstance(value, list): print_list(value, indent + 4) else: print(value) def print_list(elements, indent): Helper function to print elements of a list in a hierarchical structure. Args: elements (list): The list of elements to print. indent (int): The current indentation level. for i, elem in enumerate(elements): if isinstance(elem, dict): for k, v in elem.items(): print(\\"n\\" + \\" \\" * indent + str(k) + \\" ->\\", end=\' \') if isinstance(v, list): print_list(v, indent + 4) else: print(v) else: if i != 0: # Don\'t indent the first element of the list print(\\"n\\" + \\" \\" * indent + str(elem) + \\" ->\\", end=\' \') else: print(str(elem), end=\' \') # Given tree structure for testing tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', {\'Computer\': 7}] } # Testing the enhanced_tree_print function enhanced_tree_print(tree)"},{"question":"# Filtering Elements in an Array within a Range Objective Given an array `arr` of numerical values and optional `min_lim` and `max_lim` values, write a function `filter_within_range` that returns a new array consisting of elements from `arr` that lie between `min_lim` and `max_lim`, inclusive. If `min_lim` is not provided, consider it as the minimum value in `arr`. If `max_lim` is not provided, consider it as the maximum value in `arr`. Function Signature ```python def filter_within_range(arr: list, min_lim: int = None, max_lim: int = None) -> list: ``` Input - `arr` (list): A list of integers. - `min_lim` (int, optional): The minimum threshold (inclusive). - `max_lim` (int, optional): The maximum threshold (inclusive). Output - A list of integers containing elements from `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. Constraints - The function should run with a time complexity of O(n). - The input array `arr` can have up to (10^5) elements. - The elements in `arr` can range from (-10^9) to (10^9). Examples ```python # Example 1 assert filter_within_range([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] # Example 2 assert filter_within_range([10, 20, 30, 40, 50], 20, None) == [20, 30, 40, 50] # Example 3 assert filter_within_range([5, 15, 25, 35], 10, 30) == [15, 25] # Example 4 assert filter_within_range([], 1, 10) == [] ``` Instructions 1. Implement the function `filter_within_range`. 2. Ensure your solution handles all edge cases, including empty arrays and default minimum/maximum constraints. 3. Test your function against multiple scenarios to validate its correctness and performance.","solution":"def filter_within_range(arr, min_lim=None, max_lim=None): Filters elements within a specified range [min_lim, max_lim] from the list arr. If min_lim is not given, it is considered as the minimum value in arr. If max_lim is not given, it is considered as the maximum value in arr. Args: arr (list): List of integers. min_lim (int, optional): Minimum threshold (inclusive). max_lim (int, optional): Maximum threshold (inclusive). Returns: list: A list of elements within the specified range. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are given a software package management system represented as a directed graph where each vertex represents a software package, and an edge from vertex A to vertex B implies that package A depends on package B. Your task is to implement a function to check if there are any cyclic dependencies within the given graph. These cycles can lead to issues in the installation process where certain packages would require each other to be installed first, resulting in a deadlock. # Function Signature ```python def has_cyclic_dependencies(dependency_graph: Dict[str, List[str]]) -> bool: :param dependency_graph: A dictionary representing a directed graph with package dependencies. Keys are package names (strings), and values are lists of package names that the key package depends on. e.g. {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], ...} :return: True if there are cyclic dependencies, otherwise False. ``` # Input * `dependency_graph`: A dictionary where each key-value pair represents a package and its dependencies. * Key: String representing the package name. * Value: List of strings representing the packages it depends on. # Output * `bool`: Return `True` if there is at least one cycle in the graph, otherwise return `False`. # Constraints * The input graph may be disconnected, i.e., there could be multiple independent subgraphs. * Package names are unique strings with no specific format constraints. * The list of dependencies for each package can be empty, indicating no dependencies. * The graph will be given as a dictionary. # Example ```python # Example 1: dependency_graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert has_cyclic_dependencies(dependency_graph) == True # Example 2: dependency_graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } assert has_cyclic_dependencies(dependency_graph) == False ``` # Explanation In Example 1, there is a cycle: B -> D -> E -> B. In Example 2, there are no cycles. Implement the function `has_cyclic_dependencies` using the cycle detection algorithm by graph traversal as explained in the prompt.","solution":"def has_cyclic_dependencies(dependency_graph): Check if a directed graph has any cyclic dependencies :param dependency_graph: A dictionary representing a directed graph with package dependencies. Keys are package names (strings), and values are lists of package names that the key package depends on. :return: True if there are cyclic dependencies, otherwise False. def dfs(node, visited, stack): visited[node] = True stack[node] = True for neighbor in dependency_graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[node] = False return False visited = {node: False for node in dependency_graph} stack = {node: False for node in dependency_graph} for node in dependency_graph: if not visited[node]: if dfs(node, visited, stack): return True return False"},{"question":"# Question: **Context**: In many file systems, paths are used to locate files or directories. A common task is to split these paths into their directory and file components so that the components can be processed individually. Given the code snippet that uses Python\'s built-in `os` functionality, you are to rewrite and improve the path splitting function to handle more edge cases and ensure robustness. **Problem Statement**: Write a function called `split_path` which takes a single string input representing a path (either URL or file path) and returns a tuple containing the directory part and the file part. Your function should be able to handle the following scenarios effectively: - Paths with no \'/\' (e.g., \'test.py\'). - Paths ending with \'/\' (e.g., \'algorithms/unix/\'). - Empty strings. - Relative paths and edge cases (e.g., \'./file\', \'../file\'). **Input**: - A single string, `path` (1 ≤ len(path) ≤ 10^5), representing the file or URL path. **Output**: - A tuple `(dir_part, file_part)`, where: - `dir_part` is a string representing the directory path. - `file_part` is a string representing the file name. **Example**: ```python split_path(\\"https://algorithms/unix/test.py\\") # Output: (\'https://algorithms/unix\', \'test.py\') split_path(\\"algorithms/unix/\\") # Output: (\'algorithms/unix\', \'\') split_path(\\"test.py\\") # Output: (\'\', \'test.py\') ``` **Constraints**: - Avoid using the `os` library for path manipulation to practice your understanding of string operations. - Handle paths with different errors or unusual formats effectively. # Function Signature ```python def split_path(path: str) -> tuple: # Your code here ``` **Additional Requirements**: - Ensure the function runs efficiently for large input sizes. - Consider the provided edge cases and any additional realistic scenarios. - Write clear and concise code with appropriate comments if necessary.","solution":"def split_path(path: str) -> tuple: Splits the given path into directory and file components. Parameters: path (str): The path to be split. Returns: tuple: A tuple containing the directory part and the file part. if path == \'\': return (\'\', \'\') # Find the last occurrence of \'/\' index = path.rfind(\'/\') if index == -1: # No \'/\' in the path return (\'\', path) elif index == len(path) - 1: # The path ends with a \'/\' return (path.rstrip(\'/\'), \'\') else: return (path[:index], path[index + 1:])"},{"question":"# Pattern Matching Challenge with Backtracking You are given a string pattern and another string str. Your task is to check if str follows the same pattern as specified by pattern. Here, following the pattern implies there exists a bijection between each character in the pattern and a non-empty substring in str. Implement the function `pattern_match(pattern: str, string: str) -> bool` that returns `True` if str matches the pattern, otherwise returns `False`. Parameters - `pattern` (str): A string containing only lowercase letters, which represents the pattern. - `string` (str): A string containing only lowercase letters, which needs to be checked against the pattern. Returns - `bool`: True if the string matches the pattern, False if it does not. Constraints - Both pattern and string only contain lowercase letters. - The length of pattern and string can be up to 20. Example ```python pattern = \\"abab\\" string = \\"redblueredblue\\" # Returns: True ``` ```python pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" # Returns: True ``` ```python pattern = \\"aabb\\" string = \\"xyzabcxzyabc\\" # Returns: False ``` Notes - You may assume both pattern and string contain only lowercase letters. - Follow a recursive backtracking approach considering the above-specified analysis.","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(p, s, p_to_s, s_to_p): if not p and not s: return True if not p or not s: return False char = p[0] for end in range(1, len(s) - len(p) + 2): word = s[:end] if char in p_to_s and p_to_s[char] == word: if is_match(p[1:], s[end:], p_to_s, s_to_p): return True elif char not in p_to_s and word not in s_to_p: p_to_s[char] = word s_to_p[word] = char if is_match(p[1:], s[end:], p_to_s, s_to_p): return True del p_to_s[char] del s_to_p[word] return False return is_match(pattern, string, {}, {})"},{"question":"You are given an array of integers and tasked to implement a function that sorts the array using the Shell Sort algorithm. Your implementation should adhere to the following specifications: - Function name: `shell_sort` - Input: A list of integers, `arr`, where (1 leq text{len(arr)} leq 10^5) and (-10^6 leq text{arr[i]} leq 10^6). - Output: A list of integers sorted in non-decreasing order. # Requirements: - **Efficiency**: Aim for the best possible performance, especially considering the worst-case time complexity of (O(n^2)). - **In-Place**: Your implementation must sort the list in-place (do not use additional data structures for sorting). # Constraints: - Do not use any built-in sort functions. - Ensure the solution is generalized and works effectively within given constraints. # Example: ```python >>> shell_sort([3, -2, 5, 1, 0]) [-2, 0, 1, 3, 5] >>> shell_sort([10, 7, 8, 9, 1, 5]) [1, 5, 7, 8, 9, 10] >>> shell_sort([20]) [20] >>> shell_sort([]) [] ``` # Guidelines: - Consider common edge cases such as empty arrays, single-element arrays, and already sorted arrays. - Test plenty of scenarios to ensure the robustness of the implementation.","solution":"def shell_sort(arr): Sorts an array using the Shell Sort algorithm. Parameters: arr (list of int): The list of integers to be sorted. Returns: list of int: The sorted list of integers in non-decreasing order. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Question Context In a software application that uses stacks frequently, you need to ensure that the stack contents are sorted in non-decreasing order before performing some operations. You are tasked to write a function that checks if a given stack is sorted in increasing order from bottom to top. Specifications Implement a function `is_sorted(stack)` that verifies whether the given stack has its elements sorted in non-decreasing order from bottom to top. - Input: A list `stack`, representing the elements in the stack where `stack[0]` is the bottom-most element. - Output: A boolean value `True` if the stack is sorted in non-decreasing order, otherwise `False`. Your implementation must adhere to the following constraints: - You must use only stack operations: `push` (append) and `pop`. - You can use an additional stack for temporary storage, but the original stack must be restored to its initial state after performing the checks. - Consider edge cases such as an empty stack and a stack with a single element. Requirements - Time Complexity: O(n) - Space Complexity: O(n) **Function signature:** ```python def is_sorted(stack: list) -> bool: pass ``` Example ```python # Example 1 stack = [1, 2, 3, 4, 5, 6] print(is_sorted(stack)) # Output: True # Example 2 stack = [6, 3, 5, 1, 2, 4] print(is_sorted(stack)) # Output: False # Example 3 stack = [] print(is_sorted(stack)) # Output: True # Example 4 stack = [7] print(is_sorted(stack)) # Output: True ``` **Note**: Make sure your function does not modify the contents of the input stack persistently and restores it to the original state after the function execution.","solution":"def is_sorted(stack: list) -> bool: Returns True if the stack is sorted in non-decreasing order from bottom to top, otherwise False. The input stack should not be modified after the function execution. if not stack or len(stack) == 1: return True # An empty stack or a single-element stack is trivially sorted # Use a secondary stack to help check order and restore original stack later temp_stack = [] sorted_flag = True # Transfer elements to the temp_stack to check order while stack: temp_stack.append(stack.pop()) # Check if the elements in temp_stack are in non-decreasing order, # which is in reverse order of the original stack prev_elem = temp_stack[-1] for elem in reversed(temp_stack): if elem < prev_elem: sorted_flag = False break prev_elem = elem # Restore the original stack by transferring elements back from temp_stack while temp_stack: stack.append(temp_stack.pop()) return sorted_flag"},{"question":"# Scenario You are developing a new feature for a custom keyboard app that helps users learn which words can be typed using letters from only one row of the American layout keyboard. To implement this feature, you need to write a function that efficiently identifies and returns such words. # Task Write a function `get_single_row_words` that takes a list of words and returns a list containing only the words that can be typed using letters from a single row of an American keyboard layout. # Details * A standard American keyboard has the following rows: * Top row: QWERTYUIOP * Middle row: ASDFGHJKL * Bottom row: ZXCVBNM * Your function should be case insensitive, meaning the words \\"Hello\\" and \\"hello\\" should be treated the same way. * If a word contains even a single character that is not in the same row as the others, it should be excluded from the result. # Input and Output * **Input**: A list of strings `words` where each string is a word. ```python words: List[str] ``` * **Output**: A list of strings containing only the words that can be typed using one row. ```python result: List[str] ``` # Constraints * The number of words in the input list will not exceed 100. * Each word will contain only letters (upper and lowercase) and be between 1 and 50 characters long. # Example ```python # Example scenario input_words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] # Expected output # Only \\"Alaska\\" and \\"Dad\\" can be entirely typed by the middle and top rows respectively. output = [\\"Alaska\\", \\"Dad\\"] # Call your function result = get_single_row_words(input_words) print(result) # Output should be [\\"Alaska\\", \\"Dad\\"] ``` # Implementation Write your function below: ```python def get_single_row_words(words): # Your implementation here pass ```","solution":"def get_single_row_words(words): Filters words that can be typed using letters from only one row of a standard American keyboard. :param words: List of words to filter :type words: list of str :return: List of words that can be typed using one row :rtype: list of str top_row = set(\\"QWERTYUIOPqwertyuiop\\") middle_row = set(\\"ASDFGHJKLasdfghjkl\\") bottom_row = set(\\"ZXCVBNMzxcvbnm\\") def is_single_row(word): word_set = set(word) return word_set <= top_row or word_set <= middle_row or word_set <= bottom_row return [word for word in words if is_single_row(word)]"},{"question":"# Scenario You are working in a company that specializes in firmware updates for IoT devices. During data transfer between devices, minimal bit-flips are crucial for optimizing transmission efficiency and energy consumption. You have been asked to implement a function to compute the minimal number of bit flips needed to convert one integer representation of the device state to another. # Task Write a function `count_flips_to_convert(a: int, b: int) -> int` that determines the minimal number of bits that you need to flip to convert integer `a` to integer `b`. # Input * Two integers `a` and `b` (0 ≤ a, b ≤ 2^31 - 1). # Output * Return a single integer representing the number of flipped bits. # Example ```plaintext Input: a = 29, b = 15 Output: 2 Explanation: Binary representation of 29 is 11101 Binary representation of 15 is 01111 The bits that are different are at positions 2 and 4. Therefore, 2 bits need to be flipped. ``` # Constraints * Ensure your function runs efficiently with a time complexity of O(n) where n is the number of bits in the integers. * Maintain constant space complexity O(1).","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bits that need to be flipped to convert integer a to integer b. # XOR the two integers, since XOR will give us a bit pattern where bits are 1 if they differ xor = a ^ b # Count the number of 1s in the XOR result, which is the number of differing bits count = 0 while xor > 0: count += xor & 1 # Check the least significant bit xor >>= 1 # Shift right to check the next bit return count"},{"question":"# One Edit Distance Strings Context You are working on a text editor and need to implement a function that checks if two strings are at most one single edit apart. An edit can be an insertion, deletion, or replacement of a character. This capability is foundational in implementing features like autocorrect, where suggested corrections should only be a single edit away from the mistyped word. Your Task Write a function `is_one_edit_away(s: str, t: str) -> bool` that determines if two given strings are one edit away from each other. Input - `s`: A string consisting of lowercase alphabets. - `t`: A string consisting of lowercase alphabets. Output - Return `True` if the strings `s` and `t` are one edit away from each other. - Return `False` otherwise. Constraints - `0 <= len(s), len(t) <= 10^4` - All characters in strings `s` and `t` are lowercase English letters. Examples ```python assert is_one_edit_away(\\"abc\\", \\"ab\\") == True # One deletion away assert is_one_edit_away(\\"ab\\", \\"acb\\") == True # One insertion away assert is_one_edit_away(\\"abc\\", \\"adc\\") == True # One replacement away assert is_one_edit_away(\\"abc\\", \\"def\\") == False # More than one edit away assert is_one_edit_away(\\"\\", \\"a\\") == True # One insertion away (empty string case) ``` Additional Notes - Be cautious of edge cases where one string could be empty. - Optimize for performance given that the length of the strings can be up to 10^4.","solution":"def is_one_edit_away(s: str, t: str) -> bool: len_s, len_t = len(s), len(t) if abs(len_s - len_t) > 1: return False if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s i = j = 0 found_difference = False while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return False found_difference = True if len_s == len_t: i += 1 else: i += 1 j += 1 return True"},{"question":"# Binary Tree Path Sum Serialization Context: Serialization of a binary tree allows it to be stored and transmitted in a linear format which can later be deserialized to reconstruct the original tree. One use of such serialization is when working with applications that need to store or transmit structured data like JSON and XML where maintaining the tree structure is crucial. Task: Implement the function `find_paths_serialize` that takes in a binary tree root node and an integer target sum. The function should return a serialized string representing paths from the root to the leaves in the binary tree where the sum of node values in the path equals the target sum. Paths should be returned in a pre-order traversal serialized format, as implemented in the provided serialization example. Input: - `root`: The root node of a binary tree (instance of `TreeNode`). - `target_sum`: An integer representing the target path sum. Output: - A serialized string representing paths where the path sum equals the target sum. Use \\"#\\" to indicate the end of a path. If there are no paths meeting the criteria, return an empty string. Constraints: - The tree contains at most 1000 nodes. - Node values are integers. Example: Given the binary tree and target sum: ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` Target Sum = 22 Paths valid for this sum: ``` 5->4->11->2 5->8->4->5 ``` So, the serialized string would be: ``` \\"5 4 11 2 # 5 8 4 5 #\\" ``` Function Signature: ```python def find_paths_serialize(root: TreeNode, target_sum: int) -> str: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths_serialize(root: TreeNode, target_sum: int) -> str: def find_paths(node, target_sum, current_path, all_paths): if not node: return current_path.append(node.val) if not node.left and not node.right and sum(current_path) == target_sum: all_paths.append(current_path[:]) find_paths(node.left, target_sum, current_path, all_paths) find_paths(node.right, target_sum, current_path, all_paths) current_path.pop() all_paths = [] find_paths(root, target_sum, [], all_paths) serialized_paths = \\" \\".join(\\" \\".join(map(str, path)) + \\" #\\" for path in all_paths).strip() return serialized_paths"},{"question":"# Matrix Inversion Coding Challenge Objective Implement a function `invert_matrix(m)` that inverts a given n x n matrix. Description Given an n x n matrix represented by a list of lists, write a Python function `invert_matrix(m)` that returns the inverted matrix. The matrix inversion must follow these steps: 1. **Calculate the Matrix of Minors**. 2. **Create the Matrix of Cofactors** by applying a checkerboard pattern of signs. 3. **Adjugate the Matrix** by transposing it. 4. **Multiply by the Reciprocal of the Determinant** of the original matrix. The function should handle various edge cases and return appropriate error messages when the inversion is not possible. Constraints - `m` is a list of lists where each inner list has equal length. - `m` is guaranteed to be a non-empty matrix. - You must use the recursive approach for calculating the determinant. Expected Inputs and Outputs - **Input**: A 2D list `m`, where `m[i][j]` is an integer. - **Output**: A 2D list representing the inverted matrix if inversion is possible. Return special 2D lists for error cases. - `[[−1]]` if `m` is not a matrix. - `[[−2]]` if `m` is not square. - `[[−3]]` if `m` has fewer than 2 rows/columns. - `[[−4]]` if `m` is singular (determinant = 0). Examples 1. **Input:** `[[4, 7], [2, 6]]` **Output:** `[[0.6, -0.7], [-0.2, 0.4]]` 2. **Input:** `[[1, 2, 3], [0, 1, 4], [5, 6, 0]]` **Output:** `[[−24, 18, 5], [20, −15, −4], [ −5, 4, 1]]` 3. **Input:** `[[1, 2], [2, 4]]` (Singular Matrix) **Output:** `[[−4]]` Function Signature ```python def invert_matrix(m): # your implementation here ```","solution":"def determinant(matrix): Recursively calculates the determinant of a square matrix if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): minor = get_minor(matrix, 0, c) det += ((-1) ** c) * matrix[0][c] * determinant(minor) return det def get_minor(matrix, i, j): return [row[:j] + row[j + 1:] for row in (matrix[:i] + matrix[i + 1:])] def matrix_of_minors(matrix): return [[determinant(get_minor(matrix, i, j)) for j in range(len(matrix))] for i in range(len(matrix))] def matrix_of_cofactors(matrix): minors = matrix_of_minors(matrix) for i in range(len(minors)): for j in range(len(minors)): minors[i][j] *= (-1) ** (i + j) return minors def transpose(matrix): return list(map(list, zip(*matrix))) def invert_matrix(m): if not isinstance(m, list) or not all(isinstance(row, list) for row in m): return [[-1]] if not m or len(m) != len(m[0]): return [[-2]] if len(m) < 2 or len(m[0]) < 2: return [[-3]] det = determinant(m) if det == 0: return [[-4]] cofactors = matrix_of_cofactors(m) adjugate = transpose(cofactors) inverse = [[adjugate[i][j] / det for j in range(len(m))] for i in range(len(m))] return inverse"},{"question":"# Coding Challenge: URL and Path Joiner Context In many applications, you often need to construct URLs or file paths from two separate components, such as a base directory and a file name, or a base URL and a specific endpoint. Ensuring these components are correctly joined with a single slash is crucial to avoid broken URLs or incorrect file paths. Task Write a function `smart_join(base, suffix)` that joins the base and suffix ensuring that there is exactly one slash between them. Your function should also handle some additional features beyond the basic version provided in the analysis. Features to Implement 1. **Handling Query Parameters**: If the suffix contains a query parameter (starts with `?`), append it directly without modifying. 2. **Handling Trailing Slashes in URLs**: If the base is an URL and ends with a slash, ensure no double slash occurs unless it’s a protocol. 3. **Validation**: Ensure both inputs are valid strings, otherwise, raise a `ValueError`. Input Format - `base`: A string representing the base of the path or URL. - `suffix`: A string representing the suffix to be added to the base. Output Format - A string which is the correctly joined path or URL. Example ```python assert smart_join(\\"http://example.com/\\", \\"path\\") == \\"http://example.com/path\\" assert smart_join(\\"path/to/dir/\\", \\"/file\\") == \\"path/to/dir/file\\" assert smart_join(\\"http://example.com\\", \\"part\\") == \\"http://example.com/part\\" assert smart_join(\\"http://example.com\\", \\"?key=value\\") == \\"http://example.com?key=value\\" ``` Constraints - You should not use any external libraries for handling URLs. - Focus on string manipulation techniques. - Base and suffix strings are non-empty and contain only valid path or URL characters.","solution":"def smart_join(base, suffix): Joins the base and suffix ensuring there is exactly one slash between them. if not isinstance(base, str) or not isinstance(suffix, str): raise ValueError(\\"Both base and suffix must be strings.\\") # If the suffix starts with a query parameter, append it directly if suffix.startswith(\'?\'): return base + suffix if base.endswith(\'/\') and suffix.startswith(\'/\'): return base.rstrip(\'/\') + \'/\' + suffix.lstrip(\'/\') if not base.endswith(\'/\') and not suffix.startswith(\'/\'): return base + \'/\' + suffix return base + suffix"},{"question":"Context: Imagine you are working on a system where you need to process a series of queries and updates on numeric data. The data changes frequently, and you need to answer range aggregation queries efficiently. You decide to implement a segment tree to help you with this task. Objective: Write a function that builds a segment tree from a list using a provided commutative function. Implement methods to update elements and query the range in the segment tree. Requirements: - Implement the `SegmentTree` class with the following methods: - `__init__(self, arr: List[int], function: Callable[[int, int], int])`: Initializes the segment tree. - `update(self, index: int, value: int)`: Updates the element at the specified index. - `query(self, left: int, right: int) -> int`: Returns the result of the commutative function applied over the range. - The segment tree should handle both integers and tuples of integers. Input and Output Formats: 1. **Initialization**: - Input: `SegmentTree(arr: List[Union[int, Tuple[int, ...]]], function: Callable[[Union[int, Tuple[int, ...]], Union[int, Tuple[int, ...]]], Union[int, Tuple[int, ...]]])` - The array (`arr`) and a commutative function (`function`). 2. **Updating**: - Input: `update(index: int, value: Union[int, Tuple[int, ...]])` - Index `index` should be updated with value `value`. 3. **Querying**: - Input: `query(left: int, right: int) -> Union[int, Tuple[int, ...]]` - Returns the result of the commutative function applied from `left` to `right` (inclusive). Constraints: - `1 <= len(arr) <= 10^5` - Array elements and query/update values are either integers or tuples of integers. - The commutative function is guaranteed to be valid and associative. Example: ```python # Sum segment tree arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr, lambda a, b: a + b) print(segment_tree.query(2, 4)) # Output: 12 segment_tree.update(3, 6) print(segment_tree.query(0, 3)) # Output: 17 # Max segment tree arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr, max) print(segment_tree.query(2, 4)) # Output: 5 segment_tree.update(3, 6) print(segment_tree.query(0, 3)) # Output: 6 # Tuple sum segment tree arr = [(1, 2), (4, 6), (4, 5)] segment_tree = SegmentTree(arr, lambda a, b: (a[0] + b[0], a[1] + b[1])) print(segment_tree.query(0, 2)) # Output: (9, 13) segment_tree.update(2, (-1, 2)) print(segment_tree.query(0, 2)) # Output: (4, 10) ```","solution":"from typing import List, Callable, Union, Tuple class SegmentTree: def __init__(self, arr: List[Union[int, Tuple[int, ...]]], function: Callable[[Union[int, Tuple[int, ...]], Union[int, Tuple[int, ...]]], Union[int, Tuple[int, ...]]]): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) # Initialize the leaf nodes for i in range(self.n): self.tree[i + self.n] = arr[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index: int, value: Union[int, Tuple[int, ...]]): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.function(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left: int, right: int) -> Union[int, Tuple[int, ...]]: left += self.n right += self.n + 1 # make range inclusive res = None while left < right: if left % 2: res = self.tree[left] if res is None else self.function(res, self.tree[left]) left += 1 if right % 2: right -= 1 res = self.tree[right] if res is None else self.function(res, self.tree[right]) left //= 2 right //= 2 return res"},{"question":"You have been given a task to implement a function that calculates the shortest path between every pair of nodes in a given weighted directed graph. The graph is represented by an (n times n) adjacency matrix where (n) is the number of vertices. The value at cell ([i][j]) in the matrix represents the weight of the edge from node (i) to node (j). If there is no edge between (i) and (j), the cell contains a large value like (float(\'inf\')). **Function Signature** ```python def floyd_warshall(adjacency_matrix: List[List[float]]) -> List[List[float]]: pass ``` **Input** - `adjacency_matrix`: A 2D list of floats representing the weighted adjacency matrix of the graph. **Output** - Returns a 2D list of floats representing the matrix of shortest path distances between every pair of nodes. **Constraints** - (1 leq n leq 100) where (n) is the number of vertices. - The weights of the edges can be any real number but will be limited to floating-point precision. - The graph might contain negative weights but will not contain any negative weight cycles. **Example** ```python adjacency_matrix = [ [0, 3, float(\'inf\'), 7], [8, 0, 2, float(\'inf\')], [5, float(\'inf\'), 0, 1], [2, float(\'inf\'), float(\'inf\'), 0] ] # Resulting shortest path matrix result = [ [0, 3, 5, 6], [5, 0, 2, 3], [3, 6, 0, 1], [2, 5, 7, 0] ] ``` In this problem, your task is to write the `floyd_warshall` function to compute the all-pairs shortest path matrix based on the above input format and example. **Scenario**: You are working on network optimization and need to determine the quickest paths for data packets to travel between any two points in a network. Using the weighted adjacency matrix of your network, implement your function to help with this task efficiently.","solution":"from typing import List def floyd_warshall(adjacency_matrix: List[List[float]]) -> List[List[float]]: Computes the shortest paths between every pair of nodes in a given weighted directed graph using the Floyd-Warshall algorithm. Parameters: adjacency_matrix (List[List[float]]): A 2D list representing the weighted adjacency matrix of the graph. Returns: List[List[float]]: A 2D list representing the shortest path distances between every pair of nodes. # Number of vertices in the graph n = len(adjacency_matrix) # Initialize distance matrix with the input adjacency matrix dist = [[adjacency_matrix[i][j] for j in range(n)] for i in range(n)] # Apply the Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"Problem Statement Design and implement a `MinStack`, a special type of stack that, in addition to supporting the usual stack operations, also supports a `get_min` operation. `get_min` should return the minimum element in the stack in constant time. You must implement the `MinStack` class using either an `ArrayStack` or `LinkedListStack`. Class Definition: ```python class MinStack(AbstractStack): def push(self, value): Pushes an element onto the stack. Args: value: The value to be pushed. raise NotImplementedError def pop(self): Pops the top element off the stack and returns it. Returns: The value of the popped element. raise NotImplementedError def peek(self): Returns the value of the top element without popping it. Returns: The value of the top element. raise NotImplementedError def get_min(self): Returns the minimum value in the stack. Returns: The minimum value. raise NotImplementedError ``` Requirements - You can use the provided `ArrayStack` or `LinkedListStack` templates. - Implement all methods correctly as per the specification above. - Ensure that `get_min` operates in constant time, O(1). Input and Output - **Input**: None directly. Your implementation will be tested through method calls. - **Output**: Return values for `pop`, `peek`, and `get_min`. Constraints - Stack size will fit in memory. - Only integer values will be used. Example ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.get_min()) # Output: 3 stack.push(2) stack.push(1) print(stack.get_min()) # Output: 1 stack.pop() print(stack.get_min()) # Output: 2 stack.pop() print(stack.peek()) # Output: 5 ``` Tips - Consider maintaining another stack to track the minimum values. - Ensure all operations maintain stack integrity.","solution":"class MinStack: def __init__(self): self.stack = [] # Main stack to hold all elements self.min_stack = [] # Stack to hold minimum elements def push(self, value): Pushes an element onto the stack. Args: value: The value to be pushed. self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): Pops the top element off the stack and returns it. Returns: The value of the popped element. if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self): Returns the value of the top element without popping it. Returns: The value of the top element. if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def get_min(self): Returns the minimum value in the stack. Returns: The minimum value. if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"# Coding Challenge: Efficient Priority Queue Implementation Context: You are tasked with managing a scheduling system where tasks have varying priorities. The system should efficiently manage adding new tasks and retrieving the highest priority task to execute next. Implement a priority queue that supports: 1. Insertion of new tasks with their associated priorities. 2. Extraction of the task with the highest priority in the queue. The priority queue should be implemented using a binary heap to optimize performance. Requirements: 1. **Function Signature**: ```python class PriorityQueue: def __init__(self): pass def insert(self, task: str, priority: int) -> None: pass def extract_max(self) -> str: pass ``` 2. **Methods**: - `insert(task: str, priority: int) -> None`: Inserts a new task with its associated priority into the queue. - `extract_max() -> str`: Extracts and returns the task with the highest priority in the queue. 3. **Input/Output**: - `insert`: Takes a task (string) and its priority (integer) as inputs. - `extract_max`: Returns the task (string) with the highest priority. 4. **Constraints**: - Task names will be unique. - Priorities are integers (higher number indicates higher priority). 5. **Performance Requirements**: - Insertion should be O(log n). - Extraction of the highest priority task should be O(log n). Example: ```python pq = PriorityQueue() pq.insert(\\"Task1\\", 3) pq.insert(\\"Task2\\", 5) pq.insert(\\"Task3\\", 1) print(pq.extract_max()) # Output: \\"Task2\\" print(pq.extract_max()) # Output: \\"Task1\\" print(pq.extract_max()) # Output: \\"Task3\\" ``` Implementation Hint: - Utilize a binary heap (max-heap) to ensure that both insertions and extractions are performed efficiently.","solution":"import heapq class PriorityQueue: def __init__(self): self.pq = [] self.entry_finder = {} self.REMOVED = \'<removed-task>\' # Placeholder for a removed task self.counter = 0 def insert(self, task: str, priority: int) -> None: if task in self.entry_finder: self.remove_task(task) count = self.counter entry = [-priority, count, task] self.entry_finder[task] = entry heapq.heappush(self.pq, entry) self.counter += 1 def remove_task(self, task: str) -> None: entry = self.entry_finder.pop(task) entry[-1] = self.REMOVED def extract_max(self) -> str: while self.pq: priority, count, task = heapq.heappop(self.pq) if task is not self.REMOVED: del self.entry_finder[task] return task raise KeyError(\'pop from an empty priority queue\')"},{"question":"# Crout\'s Matrix Decomposition Algorithm Context Crout\'s matrix decomposition is often used in numerical analysis to simplify the process of solving large systems of linear equations. By decomposing the matrix into a lower triangular matrix ( L ) and an upper triangular matrix ( U ), one can solve ( L times U times x = b ) in two steps: one with forward substitution and the other with backward substitution. Task You are required to implement Crout\'s matrix decomposition for a given ( n times n ) matrix ( A ). Your goal is to write a function that outputs the lower triangular matrix ( L ) and the upper triangular matrix ( U ) such that ( L times U = A ). Each diagonal element of ( U ) should be 1. Input - An ( n times n ) matrix ( A ) represented as a list of lists, where ( 2 leq n leq 100 ). Output - The decomposed matrices ( L ) and ( U ), where each is represented as a list of lists. Constraints - The matrix ( A ) is guaranteed to be invertible. - Values in the matrix ( A ) are floating-point numbers and can be positive or negative. Performance Requirements - The function should operate in ( O(n^3) ) time complexity. Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: ``` Example ```python A = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_matrix_decomposition(A) print(\\"L:\\", L) print(\\"U:\\", U) # Expected output: # L = [ # [1.0, 0.0, 0.0], # [3.0, -2.0, 0.0], # [6.0, -5.0, 0.0] # ] # U = [ # [1.0, 2.0, 3.0], # [0.0, 1.0, 2.0], # [0.0, 0.0, 1.0] # ] ``` Implement the function `crout_matrix_decomposition` as described above.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): U[i][i] = 1.0 for j in range(n): for i in range(j, n): L[i][j] = A[i][j] - sum(L[i][k] * U[k][j] for k in range(j)) for i in range(j + 1, n): U[j][i] = (A[j][i] - sum(L[j][k] * U[k][i] for k in range(j))) / L[j][j] return L, U"},{"question":"# Problem Description You are given an array `nums` consisting of integer elements, where exactly two elements appear only once and all other elements appear exactly twice. Write a function `find_single_numbers` that figures out the two unique numbers. # Function Signature ```python def find_single_numbers(nums: List[int]) -> List[int]: pass ``` # Constraints * The length of the array is at least 2. * It is guaranteed that there are exactly two elements that appear only once, and all other elements appear exactly twice. * The order of the result does not matter. For example, if the unique numbers are `[5, 3]` or `[3, 5]`, both are acceptable outputs. # Input * `nums`: List[int] - A list of integers where exactly two elements appear only once, all other elements appear exactly twice. # Output * `List[int]` - A list containing the two unique elements. # Example Example 1: ```python find_single_numbers([1, 2, 1, 3, 2, 5]) ``` Output: ```python [3, 5] ``` or ```python [5, 3] ``` Example 2: ```python find_single_numbers([4, 6, 4, 7, 8, 8]) ``` Output: ```python [6, 7] ``` or ```python [7, 6] ``` # Hints 1. Use XOR to cancel out elements that appear twice. 2. Isolate a differentiating bit to separate unique elements.","solution":"from typing import List def find_single_numbers(nums: List[int]) -> List[int]: # Step 1: XOR all numbers to get xor_of_two (which is the XOR of the two unique elements) xor_of_two = 0 for num in nums: xor_of_two ^= num # Step 2: Find any set bit (we use the rightmost set bit) in xor_of_two # This set bit will help us differentiate between the two unique numbers rightmost_set_bit = xor_of_two & -xor_of_two # Step 3: Partition the numbers into two groups based on the set bit and XOR again within each group first_unique = 0 second_unique = 0 for num in nums: if num & rightmost_set_bit: first_unique ^= num else: second_unique ^= num return [first_unique, second_unique]"},{"question":"# Question: String Reversal for Palindrome Checker Alice, a hobbyist coder, is working on a palindrome checker for strings. A string is considered a palindrome if it reads the same backward as forward, ignoring spaces, capitalization, and punctuation. To solve this problem, Alice must first reverse the string. Given a string `s`, implement a function `reverse_string(s)` that returns the reversed string. You must implement this by choosing an iterative approach and ensuring that it works within O(n) time and O(1) additional space complexity. # Function Signature ```python def reverse_string(s: str) -> str: ``` # Input - `s`: A string of length `n` where `0 ≤ n ≤ 10^5` # Output - A string which is the reverse of `s` # Constraints - The string consists of printable ASCII characters. # Example ```python # Example 1 s = \\"hello\\" print(reverse_string(s)) # Output: \\"olleh\\" # Example 2 s = \\"A man, a plan, a canal: Panama\\" print(reverse_string(s)) # Output: \\"amanaP :lanac a ,nalp a ,nam A\\" ``` # Notes - Focus on the iterative approach to achieve the required complexity. - Pay attention to edge cases like empty strings or strings with single characters.","solution":"def reverse_string(s: str) -> str: Returns the reversed string of the input `s` using an iterative approach. # Initialize an empty list to store the characters in reverse order reversed_str = [] # Iterate over the string in reverse order for char in reversed(s): reversed_str.append(char) # Join the characters in the list to form the reversed string return \'\'.join(reversed_str)"},{"question":"# Coding Challenge: Custom Sorting Function In this challenge, you are required to implement a sorting function using Stooge Sort. However, the typical Stooge Sort is extremely inefficient due to its high time complexity. You must identify potential optimizations within the recursive logic to enhance its performance. Problem Statement Implement the function `optimized_stoogesort(arr, l, h)` that utilizes Stooge Sort but employs a heuristic to avoid unnecessary recursion when portions of the array are already sorted. Function Signature ```python def optimized_stoogesort(arr: list[int], l: int, h: int) -> None: ``` Expected Input and Output - **Input**: * `arr` - list of integers to be sorted * `l` - starting index of the list (0) * `h` - ending index of the list (length of the list - 1) - **Output**: * The function should sort the list `arr` in place. No return is necessary. Constraints * The array will contain at most (10^2) elements. * Elements in the array can be both positive and negative integers. Performance Requirements * Attempt to reduce the time complexity compared to the initial O(n^2.709) where possible using optimized checks before recursing. Example ```python arr = [2, 4, 5, 3, 1] optimized_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5] ``` Hints 1. Check if the section to be sorted is already sorted to avoid unnecessary recursive calls. 2. Consider optimizing the division based on observed characteristics of smaller subproblems.","solution":"def optimized_stoogesort(arr, l, h): Function to sort the array using an optimized version of Stooge Sort. # Base case: if the current portion of the array is of size 1 or already sorted if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 optimized_stoogesort(arr, l, h - t) optimized_stoogesort(arr, l + t, h) optimized_stoogesort(arr, l, h - t) # Test case arr = [2, 4, 5, 3, 1] optimized_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5]"},{"question":"In a directed graph, a strongly connected component (SCC) is a maximal subgraph where every pair of vertices is mutually reachable. Your task is to determine if a given directed graph is strongly connected. Implement the `is_strongly_connected` method for the `Graph` class. The method should determine whether the entire graph is a single strongly connected component. # Function Signature ```python class Graph: def __init__(self, vertex_count: int): def add_edge(self, source: int, target: int): def is_strongly_connected(self) -> bool: ``` # Example ```python # Example 1 g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(1, 3) g.add_edge(3, 4) g.add_edge(4, 1) print(g.is_strongly_connected()) # Output: True # Example 2 g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) print(g.is_strongly_connected()) # Output: False ``` # Constraints * The graph contains no cycles or self-loops. * The number of vertices (V) is between 1 and 10^3. * The number of edges (E) is between 0 and 10^4. # Notes 1. You need to ensure that your implementation handles graphs with isolated nodes and no edges efficiently. 2. You need to reverse the graph’s edges without modifying the original graph. # Performance Requirements * Your solution should run in O(V + E) time complexity, where V is the number of vertices and E is the number of edges. * Space complexity should be O(V). Good luck!","solution":"class Graph: def __init__(self, vertex_count: int): self.vertex_count = vertex_count self.graph = [[] for _ in range(vertex_count)] def add_edge(self, source: int, target: int): self.graph[source].append(target) def _dfs(self, v, visited, graph): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: self._dfs(neighbor, visited, graph) def _get_transpose(self): transpose_graph = [[] for _ in range(self.vertex_count)] for v in range(self.vertex_count): for neighbor in self.graph[v]: transpose_graph[neighbor].append(v) return transpose_graph def is_strongly_connected(self) -> bool: visited = [False] * self.vertex_count # Step 1: Perform DFS from the first vertex self._dfs(0, visited, self.graph) # If any vertex is not visited, return False if any(not flag for flag in visited): return False # Step 2: Create the transpose of the graph transpose_graph = self._get_transpose() # Reset visited array visited = [False] * self.vertex_count # Step 3: Perform DFS from the same vertex on the transpose graph self._dfs(0, visited, transpose_graph) # If any vertex is not visited again, return False if any(not flag for flag in visited): return False return True"},{"question":"# Maximum Sum of Contiguous Subarray **Context**: You are given a one-dimensional array representing a time series of stock prices or any sequence of integer values. Your task is to compute the maximum sum of a contiguous subarray which can provide insights into the period of profitability or other analyses. **Problem**: Implement the function `max_contiguous_subsequence_sum` which takes an array of integers and returns the maximum sum of any contiguous subarray. **Function Signature**: ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` # Input: - `arr` (List[int]): A list of integers which could include both positive and negative numbers. # Output: - Returns a single integer, the maximum sum of a contiguous subarray. # Constraints: - The list `arr` can have at most 10^5 elements. - Elements of the array are constrained to the value range of -10^4 to 10^4. - The list `arr` can be empty, in which case the return value should be 0. # Examples: 1. `max_contiguous_subsequence_sum([-2, 3, 8, -1, 4])` should return `14` 2. `max_contiguous_subsequence_sum([-1, 1, 0])` should return `1` 3. `max_contiguous_subsequence_sum([-1, -3, -4])` should return `-1` 4. `max_contiguous_subsequence_sum([])` should return `0` 5. `max_contiguous_subsequence_sum([-2, 3, 8, -12, 8, 4])` should return `12` # Performance Requirements: - Your implementation should run in O(n) time complexity where \'n\' is the number of elements in the array. - Your implementation should use O(1) additional space. **Additional Notes**: Consider all edge cases including empty arrays and arrays with all negative numbers. Ensure to handle these cases correctly to avoid errors.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: Function to find the maximum sum of a contiguous subarray using Kadane\'s algorithm. if not arr: return 0 max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Question You are given a set of two positive integers and need to determine both their Greatest Common Divisor (GCD) and their Least Common Multiple (LCM). The catch is to implement the GCD using bitwise operations, as it can be faster for large integers. For this task: Function Signature ```python def gcd_bit(a: int, b: int) -> int: pass def lcm_using_gcd_bit(a: int, b: int) -> int: pass ``` # Requirements 1. Implement `gcd_bit(a, b)` to find the greatest common divisor of two positive integers using bitwise operations. 2. Implement `lcm_using_gcd_bit(a, b)` which computes the least common multiple by utilizing the `gcd_bit(a, b)` function. # Input * Two positive integers `a` and `b`, both within the range of [1, 10^9]. # Output * `gcd_bit(a, b)` should return the GCD of `a` and `b`. * `lcm_using_gcd_bit(a, b)` should return the LCM of `a` and `b`. # Constraints * Both functions should be optimized to handle the largest possible input values within a reasonable time frame. * You can assume the input will always be valid integers. # Example ```python print(gcd_bit(8, 12)) # Output: 4 print(lcm_using_gcd_bit(8, 12)) # Output: 24 ``` # Additional Information * **Edge cases**: - Minimal values of `a` and `b` (i.e., both 1). - Large values close to the upper limit. * **Performance**: Consider the efficiency of your algorithm, especially on the provided constraints. Good luck, and may your bitwise operations be efficient and your divisions precise!","solution":"def gcd_bit(a: int, b: int) -> int: Compute the greatest common divisor (GCD) of a and b using bitwise operations. if a == b: return a if a == 0: return b if b == 0: return a # Both a and b are even if (~a & 1) and (~b & 1): return gcd_bit(a >> 1, b >> 1) << 1 # a is even, b is odd elif (~a & 1): return gcd_bit(a >> 1, b) # a is odd, b is even elif (~b & 1): return gcd_bit(a, b >> 1) # Both a and b are odd, a >= b elif a >= b: return gcd_bit((a - b) >> 1, b) # Both a and b are odd, a < b else: return gcd_bit((b - a) >> 1, a) def lcm_using_gcd_bit(a: int, b: int) -> int: Compute the least common multiple (LCM) of a and b using their GCD. return a * (b // gcd_bit(a, b))"},{"question":"# Question: Implement an Enhanced Bucket Sort You are tasked with implementing an optimized version of Bucket Sort. The initial implementation uses Insertion Sort to sort elements within each bucket, leading to potential performance degradation for large input arrays. Your implementation should use a more efficient sorting algorithm for sorting the buckets and account for some common edge cases. # Function Signature ```python def enhanced_bucket_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of non-negative integers to be sorted. # Output * Returns a list of integers sorted in ascending order. # Constraints * The elements in `arr` will be non-negative integers. * Length of `arr` (`n`) can be between 0 and 10^6. * Values in `arr` will be between 0 and 10^6. # Requirements 1. Use a more efficient sorting algorithm (e.g., Python\'s built-in `sort()`) for sorting elements within each bucket. 2. Properly handle edge cases such as empty arrays and arrays with one element. 3. Ensure the buckets are distributed evenly. # Performance Requirements * Your implementation should aim to have a linearithmic time complexity, i.e., O(n log n) where possible. * Ensure efficient space utilization to handle large input sizes. # Example ```python >>> enhanced_bucket_sort([3, 6, 2, 8, 4, 10, 1]) [1, 2, 3, 4, 6, 8, 10] >>> enhanced_bucket_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> enhanced_bucket_sort([]) [] ``` # Implementation Notes * Think about optimizing the number of buckets. * Python\'s built-in sorting should be used for sorting within buckets. * Ensure that your code handles all typical edge cases like an empty input array and all elements being the same.","solution":"from typing import List def enhanced_bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max_value = max(arr) bucket_size = len(arr) # Initialize buckets buckets = [[] for _ in range(bucket_size)] # Distribute array elements into each bucket for num in arr: index = num * bucket_size // (max_value + 1) buckets[index].append(num) # Sort each bucket and collect the results sorted_arr = [] for bucket in buckets: sorted_bucket = sorted(bucket) sorted_arr.extend(sorted_bucket) return sorted_arr"},{"question":"Problem Statement: Priority Queue Implementation A priority queue is an extension of the regular queue that instead of FIFO order, dequeues elements based on priority. Specifically, elements with higher priority are dequeued before those with lower priority, and among elements with the same priority, they follow a FIFO order. # Task Design and implement a `PriorityQueue` class using a heap (binary min-heap or max-heap based on priority) to achieve efficient enqueue and dequeue operations. # Requirements 1. **enqueue**: Adds an item to the queue with an associated priority. 2. **dequeue**: Removes and returns the item with the highest priority. 3. **peek**: Returns the item with the highest priority without removing it. 4. **is_empty**: Checks if the queue is empty. 5. **size**: Returns the number of items in the queue. # Input and Output * The `PriorityQueue` should support the following methods: - `enqueue(item, priority)` - adds an `item` with a given `priority`. - `dequeue()` - returns the item with the highest priority. - `peek()` - returns the item with the highest priority without removing it. - `is_empty()` - returns `True` if the queue is empty, else `False`. - `size()` - returns the number of items in the queue. # Constraints 1. Assume that priorities are integers where a lower number represents a higher priority. 2. Duplicate priorities are allowed, and FIFO order is maintained among elements with the same priority. 3. Optimize `enqueue` and `dequeue` operations for performance. 4. Handle all edge cases, such as dequeuing from an empty queue. # Example ```python pq = PriorityQueue() pq.enqueue(10, 2) pq.enqueue(14, 1) pq.enqueue(9, 3) print(pq.peek()) # Output: 14 print(pq.dequeue()) # Output: 14 print(pq.size()) # Output: 2 print(pq.is_empty()) # Output: False ``` # Implementation Guidelines * Implement the `PriorityQueue` with the help of a binary heap. You can use Python\'s built-in `heapq` module or write your own heap implementation. * Make sure to maintain the priority order while enqueuing and dequeuing elements. * Ensure that the code is well-documented and includes error handling for edge cases. * Test your implementation with various scenarios to ensure correctness and efficiency.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.count = 0 # This counter helps maintain FIFO order def enqueue(self, item, priority): Adds an item to the queue with a given priority. heapq.heappush(self.heap, (priority, self.count, item)) self.count += 1 def dequeue(self): Removes and returns the item with the highest priority. If the queue is empty, raises an IndexError. if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self.heap)[2] def peek(self): Returns the item with the highest priority without removing it. If the queue is empty, raises an IndexError. if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0][2] def is_empty(self): Returns True if the queue is empty, else False. return len(self.heap) == 0 def size(self): Returns the number of items in the queue. return len(self.heap)"},{"question":"You are a software developer tasked with helping a delivery drone system. The drones need to calculate the k closest delivery drop-off points to their current position (origin). Given a list of points where each point represents an (x, y) coordinate on a 2D plane, your task is to implement a function `k_closest(points, k, origin)` which returns the list of k closest points to the origin (0, 0). Function Signature ```python def k_closest(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: ``` Input * `points`: A list of tuples where each tuple represents the coordinates (x, y) of a point on a 2D plane. E.g., `[(1, 2), (2, 3), (3, 4)]` * `k`: An integer representing the number of closest points to find. * `origin`: An optional tuple representing the origin point from which distances are calculated. Defaults to (0, 0). Output * A list of tuples representing the k points closest to the origin. Constraints * All coordinates and distances are accurate within the range of integer values. * 0 ≤ k ≤ len(points). Performance Requirement * The implementation should efficiently handle lists of up to 10^5 points. # Example ```python points = [(1, 3), (3, 4), (2, -1)] k = 2 result = k_closest(points, k) print(result) # Output: [(1, 3), (2, -1)] (or any other valid order of the two closest points) ``` Notes * You may assume that there are no duplicate points in the input list. * The output does not need to be in any particular order. # Detailed Constraints and Edge Cases 1. **Empty Points List**: If `points` is empty, the output should be an empty list. 2. **K Greater Than Number of Points**: If `k` is greater than the number of points, return all the points. 3. **Single Point**: If there is only one point, and k >= 1, return that point. 4. **Zero K**: If `k` is zero, the output should be an empty list. 5. **Negative Coordinates**: Ensure the distance calculation correctly handles negative coordinates.","solution":"from typing import List, Tuple import heapq def k_closest(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: Returns the k closest points to the origin (0,0) or a given origin. def euclidean_distance(point): return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2 # Use a heap to keep the closest k points heap = [] for point in points: distance = euclidean_distance(point) if len(heap) < k: heapq.heappush(heap, (-distance, point)) else: heapq.heappushpop(heap, (-distance, point)) return [point for _, point in heap]"},{"question":"# Scenario: You are a software engineer working for a large e-commerce company. The company needs to sort massive datasets of product information efficiently for various analytics and recommendation engines. This task is critical for maintaining user satisfaction and ensuring timely processing. # Task: Implement the `merge_sort` function which sorts a list of integers in non-decreasing order using the Merge Sort algorithm. The function should return a sorted list and must handle edge cases such as empty lists and lists with duplicate values. # Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input: - A list of integers, `arr`. # Output: - A list of integers sorted in non-decreasing order. # Example: ```python assert merge_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert merge_sort([]) == [] assert merge_sort([1]) == [1] assert merge_sort([3, 3, 3]) == [3, 3, 3] assert merge_sort([5, -1, 0, 3, 2]) == [-1, 0, 2, 3, 5] ``` # Constraints: - The length of the list, n, will be such that 0 ≤ n ≤ 10^5. - The integer values in the list will be in the range -10^9 to 10^9. # Performance Requirements: - The sorting should be performed in O(n log n) time complexity. - Space complexity should not exceed O(n). Note that your implementation should not modify the input list. # Follow-up: After completing the function, analyze and suggest any possible improvements or scenarios where switching to a different algorithm might be beneficial.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"Minimum Height of Binary Tree Background In binary trees, the minimum height is the shortest distance from the root node to any leaf node. This is an important concept in many applications like pathfinding and routing, as the shortest path to a leaf can often represent critical shortest-path problems in networks. Task Implement a function `min_height_binary_tree(tree)` that computes the minimum height of a given BinaryTree. Consider both recursive and iterative solutions. Requirements 1. **Recursive Approach** - Function `min_height_binary_tree_recursive(root: TreeNode) -> int`. - Must use depth-first search (DFS). 2. **Iterative Approach** - Function `min_height_binary_tree_iterative(root: TreeNode) -> int`. - Must use breadth-first search (BFS). Input - `root` (TreeNode): The root node of a binary tree. Output - Return an integer representing the minimum height. Constraints - The number of nodes in the binary tree is between 0 and 10^4. - Node values will be integers. Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_height_binary_tree_recursive(root): # Implement your recursive solution here def min_height_binary_tree_iterative(root): # Implement your iterative solution here # Example usage if __name__ == \\"__main__\\": tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) assert min_height_binary_tree_recursive(tree) == 3 assert min_height_binary_tree_iterative(tree) == 3 ``` Notes - A leaf node is a node with no children. - An empty tree has a height of 0.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_height_binary_tree_recursive(root): if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return 1 + min_height_binary_tree_recursive(root.right) if not root.right: return 1 + min_height_binary_tree_recursive(root.left) return 1 + min(min_height_binary_tree_recursive(root.left), min_height_binary_tree_recursive(root.right)) from collections import deque def min_height_binary_tree_iterative(root): if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"Coding Assessment Question # Problem Description You are tasked with designing a function `reverse_string` that reverses a given input string. You are required to implement this function in three different ways: recursively, iteratively, and using a Python built-in method. Each implementation should be within the same function but distinguished by a parameter that indicates the method to use. # Function Signature ```python def reverse_string(s: str, method: str) -> str: Reverse the given string `s` based on the specified `method`. Parameters: s (str): The string to be reversed. method (str): The method to use for reversal (\'recursive\', \'iterative\', or \'pythonic\'). Returns: str: The reversed string. pass ``` # Input * `s` is a non-null string. (0 <= len(s) <= 10000) * `method` is one of three strings: \'recursive\', \'iterative\', \'pythonic\'. # Output * A string that is the reversed version of input string `s`. # Constraints * Implement all three methods. * Optimize for readability and performance where possible. # Example ```python # Example 1 print(reverse_string(\\"hello\\", \\"recursive\\")) # Output: \\"olleh\\" # Example 2 print(reverse_string(\\"world\\", \\"iterative\\")) # Output: \\"dlrow\\" # Example 3 print(reverse_string(\\"python\\", \\"pythonic\\")) # Output: \\"nohtyp\\" ``` # Note You should handle edge cases such as an empty string and single character strings efficiently. # Requirements 1. Test for an even-length string. 2. Test for an odd-length string. 3. Consider efficiency for long strings.","solution":"def reverse_string(s: str, method: str) -> str: Reverse the given string `s` based on the specified `method`. Parameters: s (str): The string to be reversed. method (str): The method to use for reversal (\'recursive\', \'iterative\', or \'pythonic\'). Returns: str: The reversed string. if method == \'recursive\': # Recursive method to reverse a string if len(s) == 0: return s else: return reverse_string(s[1:], \'recursive\') + s[0] elif method == \'iterative\': # Iterative method to reverse a string result = \\"\\" for char in s: result = char + result return result elif method == \'pythonic\': # Pythonic method to reverse a string return s[::-1] else: raise ValueError(\\"Invalid method. Choose from \'recursive\', \'iterative\', or \'pythonic\'\\")"},{"question":"# Linear Search Enhancement You are given an array of integers and a query integer. Your task is to implement an enhanced version of the `linear_search` algorithm to achieve the following: 1. Return the index of the first occurrence of the query integer in the array. 2. If the query integer is not found, return -1. 3. Additionally, implement functionality to count the total number of comparisons made before finding the query integer or concluding that it is not in the array. 4. If the query appears multiple times, still return the index of its first occurrence. The count of comparisons should reflect all comparisons made until the first occurrence is found. Function Signature ```python def enhanced_linear_search(array: list[int], query: int) -> tuple[int, int]: ``` Input * `array` (list of integers): The array in which to search. * `query` (integer): The integer to find in the array. Output * A tuple `(index, comparisons)` where: - `index` is the index of the first occurrence of the query integer in the array or -1 if not found. - `comparisons` is the total number of comparisons made during the search. Constraints * The array can contain up to 10,000 elements. * The elements in the array can be any integer (positive, negative, or zero). * The query can be any integer. Performance Requirements * Aim for a solution with O(n) time complexity where n is the number of elements in the array. * Space complexity should remain O(1). Example ```python array = [10, 5, 2, 3, 2, 9, 8] query = 2 Result: (2, 3) Explanation: The element 2 is first found at index 2, after 3 comparisons (10, 5, 2). ```","solution":"def enhanced_linear_search(array: list[int], query: int) -> tuple[int, int]: Enhanced linear search algorithm to find the index of the query integer in the array and count comparisons. Args: array (list of int): The array in which to search. query (int): The integer to find in the array. Returns: tuple: A tuple (index, comparisons) where: - index (int): Index of the first occurrence of the query integer or -1 if not found. - comparisons (int): Total number of comparisons made during the search. comparisons = 0 for index, value in enumerate(array): comparisons += 1 if value == query: return (index, comparisons) return (-1, comparisons)"},{"question":"Objective Write a function `max_height` in Python that computes the maximum depth of a binary tree. Context Imagine you are tasked to determine the structural complexity of a genealogy tree for a research paper. Each individual\'s relationships are structured as a binary tree, and one of the measures needed is the depth of such a tree. Requirements 1. **Function Signature**: ```python def max_height(root: TreeNode) -> int: ``` 2. **Input**: - `root`: The root node of the binary tree. Can be `None`, indicating an empty tree. 3. **Output**: - An integer representing the maximum depth of the tree. 4. **TreeNode Class**: - Ensure your solution works with the pre-defined `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 5. **Constraints**: - The number of nodes in the tree is in the range `[0, 10^4]`. - The value of each node is `-10^5 <= Node.val <= 10^5`. Example ```python # Example 1 tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) assert max_height(tree) == 3 # Example 2 assert max_height(None) == 0 ``` Note In your implementation, focus on handling edge cases such as: - Empty tree (root is `None`). - Tree with only one node. - Unbalanced trees with nodes missing at various levels.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_height(root: TreeNode) -> int: if root is None: return 0 left_depth = max_height(root.left) right_depth = max_height(root.right) return max(left_depth, right_depth) + 1"},{"question":"A robot starts at position `(0, 0)` on a two-dimensional plane. Given a string `moves` that represents a sequence of its moves, determine if this robot returns to the original starting point after completing all the movements. The moves string may contain characters `R` (Right), `L` (Left), `U` (Up), and `D` (Down). Develop a function `does_circle_exist(moves: str) -> bool` that returns `True` if the robot returns to the origin after all moves, else returns `False`. # Input * A single string `moves` which contains only the characters: `R`, `L`, `U`, and/or `D`. * `1 <= len(moves) <= 10000` # Output * A single boolean value: `True` if the robot returns to the origin, otherwise `False`. # Constraints * All input strings are guaranteed to contain only the characters `R`, `L`, `U`, and `D`. * Consider the input to be case-sensitive (\'R\' is not the same as \'r\'). # Examples Example 1: ``` Input: moves = \\"UD\\" Output: True ``` Example 2: ``` Input: moves = \\"LL\\" Output: False ``` # Additional Information Ensure your code handles edge cases, such as the robot receiving an empty string, single-direction sequences, large move sequences, and valid input constraints appropriately.","solution":"def does_circle_exist(moves: str) -> bool: x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"Implement a CircularBufferQueue Background A Circular Buffer Queue is a type of Queue that uses a fixed-size array in a circular fashion, enabling efficient reuse of empty space in the buffer. The advantage of using a circular buffer over a dynamic array queue is its fixed memory size, and unlike a linked list queue, it utilizes a contiguous block of memory leading to better cache performance. Task You are required to implement a CircularBufferQueue class that behaves similarly to the already provided Queue classes but using a fixed-size array in a circular manner. Requirements 1. Implement a `CircularBufferQueue` class with the following methods: * `enqueue(item)`: Adds `item` to the end of the queue. * `dequeue()`: Removes and returns the front item from the queue. * `peek()`: Returns the front item without removing it. * `is_empty()`: Returns `True` if the queue is empty, `False` otherwise. * `size()`: Returns the number of items in the queue. 2. You should handle the following edge cases: * Attempting to `dequeue` or `peek` from an empty queue should raise an `IndexError` with the message \\"Queue is empty\\". * Enqueue operation should raise an `OverflowError` with the message \\"Queue is full\\" if the queue is at full capacity. 3. The buffer size should remain fixed after initialization. Resizing is not allowed. Function Signature ```python class CircularBufferQueue: def __init__(self, capacity: int): # Initializes the queue with a fixed capacity def enqueue(self, item): # Add an item to the queue def dequeue(self): # Remove and return the front item def peek(self): # Return the front item without removing it def is_empty(self): # Check if the queue is empty def size(self): # Return the number of items in the queue ``` Example ```python >>> cbq = CircularBufferQueue(3) >>> cbq.enqueue(1) >>> cbq.enqueue(2) >>> cbq.enqueue(3) >>> cbq.size() 3 >>> cbq.dequeue() 1 >>> cbq.peek() 2 >>> cbq.enqueue(4) >>> cbq.dequeue() 2 >>> cbq.dequeue() 3 >>> cbq.dequeue() 4 >>> cbq.is_empty() True >>> cbq.enqueue(5) >>> cbq.enqueue(6) >>> cbq.enqueue(7) >>> cbq.enqueue(8) # should raise OverflowError: Queue is full ``` Constraints * `0 <= capacity <= 10^5` (assuming a non-negative integer capacity) * Performance: * Enqueue, Dequeue, Peek operations must be performed in O(1) time. Implement your solution in Python.","solution":"class CircularBufferQueue: def __init__(self, capacity: int): self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, item): if self.count == self.capacity: raise OverflowError(\\"Queue is full\\") self.buffer[self.tail] = item self.tail = (self.tail + 1) % self.capacity self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity self.count -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.buffer[self.head] def is_empty(self): return self.count == 0 def size(self): return self.count"},{"question":"Rotate Linked List You are given the head of a singly linked list and an integer k. Rotate the list to the right by k places. # Detailed Specification 1. **Input Format**: - `head`: The head node of a singly linked list where the node is defined as: ```python class SinglyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None ``` - `k`: An integer representing the number of places to rotate the list. 2. **Output Format**: - The head node of the rotated singly linked list. # Constraints - The number of nodes in the list is in the range [0, 500]. - `-500 <= k <= 500` (Negative values of `k` indicate rotating to the left). # Performance Requirements - The solution should be efficient with a time complexity of O(n) where n is the number of nodes in the list. # Example ```python # List: 1 -> 2 -> 3 -> 4 -> 5, k = 2 # Output: 4 -> 5 -> 1 -> 2 -> 3 # List: 0 -> 1 -> 2, k = 4 # Output: 2 -> 0 -> 1 ``` # Implementation Tip 1. Calculate the effective number of rotations needed by taking modulo of k with the length of the list. 2. Adjust for negative values of k. 3. Traverse the list to find the new head and adjust next pointers accordingly.","solution":"class SinglyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None def rotate_list(head, k): if not head or not head.next or k == 0: return head # Find the length of the list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Adjust k to be within the list length k = k % length if k == 0: return head # Find the new tail (length - k - 1) and new head (length - k) new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None old_tail.next = head return new_head"},{"question":"**Finding Minimum in Rotated Sorted Array** # Context: You are working for a company that deals with time series data. Often, this data is cyclic, meaning it wraps around at a certain point. To effectively analyze the data, you need to find the minimum value in these rotated time series arrays. # Task: Given an array that is sorted in ascending order and then rotated at some pivot unknown to you beforehand, write a function `find_min_rotate` to find the minimum element. Your solution must demonstrate an understanding of binary search and must complete in O(log N) time complexity. Assume no duplicate elements exist in the array. # Function Signature: ```python def find_min_rotate(array: List[int]) -> int: ``` # Input: - `array` (List[int]): A non-empty list of integers sorted in ascending order, then rotated. # Output: - Returns the integer value of the minimum element in the array. # Constraints: - The array has no duplicate elements. - The array contains at least one element. # Requirements: 1. The solution must have a time complexity of O(log N). 2. The output should be the minimum integer in the given rotated sorted array. # Examples: 1. Input: `[4, 5, 6, 7, 0, 1, 2]` Output: `0` 2. Input: `[3, 4, 5, 1, 2]` Output: `1` 3. Input: `[1, 2, 3, 4, 5, 6, 7]` Output: `1` 4. Input: `[2, 3, 4, 5, 6, 7, 1]` Output: `1` # Hints: - Think of a strategy that divides the problem in half each iteration (binary search). - Pay attention to the properties of subarrays formed to determine where the minimum might lie.","solution":"from typing import List def find_min_rotate(array: List[int]) -> int: Find the minimum value in a rotated sorted array. left, right = 0, len(array) - 1 while left < right: mid = (left + right) // 2 # if middle element is greater than the rightmost element, # the minimum is in the right half if array[mid] > array[right]: left = mid + 1 else: right = mid return array[left]"},{"question":"# Question: Dynamic Connectivity Checker Suppose you are operating a network of computers which are connected dynamically. Each computer is initially isolated. We can connect two computers using a connection operation. After any number of such operations, we need to quickly check if there’s a direct or indirect (through intermediate computers) connection between any two given computers. Your task is to implement a class `Network` that supports the following operations efficiently: 1. **add_computer(computer)**: Adds a new computer to the network. 2. **connect(computer1, computer2)**: Connects two computers in the network. 3. **is_connected(computer1, computer2)**: Returns `True` if there\'s a direct or indirect connection between `computer1` and `computer2`. Otherwise, returns `False`. # Constraints - The number of operations, `Q`, can be up to 10^5. - The number of distinct computers in all operations is also up to 10^5. - Computers are identified by integer IDs ranging from 0 to 10^5. # Example ```python network = Network() # Adding computers network.add_computer(1) network.add_computer(2) network.add_computer(3) network.add_computer(4) # Connecting computers network.connect(1, 2) network.connect(2, 3) # Checking connections print(network.is_connected(1, 3)) # Output: True print(network.is_connected(1, 4)) # Output: False # Adding another connection network.connect(3, 4) # Checking new connection print(network.is_connected(1, 4)) # Output: True ``` # Implementation Requirements * **Input Format**: You should implement methods with the described signatures. * **Output Format**: Implement the `is_connected` method to return `True` or `False`. * **Performance**: Ensure that all operations are nearly constant time, i.e., O(α(n)). # Notes * Make sure to utilize Union-Find (Disjoint Set) aptly to handle the operations efficiently. * Consider edge cases mentioned in the analysis, such as connecting the same computer or querying connectivity for non-existent computers.","solution":"class Network: def __init__(self): self.parent = {} self.rank = {} def add_computer(self, computer): if computer not in self.parent: self.parent[computer] = computer self.rank[computer] = 0 def find(self, computer): if self.parent[computer] != computer: self.parent[computer] = self.find(self.parent[computer]) return self.parent[computer] def union(self, computer1, computer2): root1 = self.find(computer1) root2 = self.find(computer2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def connect(self, computer1, computer2): self.add_computer(computer1) self.add_computer(computer2) self.union(computer1, computer2) def is_connected(self, computer1, computer2): if computer1 not in self.parent or computer2 not in self.parent: return False return self.find(computer1) == self.find(computer2)"},{"question":"# Question: String Encoding and Decoding You are given a task to design an encoding and decoding mechanism for a list of strings. The goal is to encode a list of strings into a single string such that it can be sent over the network, and then decode it back to the original list of strings upon reception. # Requirements: 1. **Encode Method** - Input: A list of strings `List[str]`. - Output: A single string `str`. 2. **Decode Method** - Input: A single string `str`. - Output: A list of strings `List[str]`. # Expected Input and Output Formats: - **Encoding** - Input: `[\\"hello\\", \\"world\\"]` - Output: `\\"5:hello5:world\\"` - **Decoding** - Input: `\\"5:hello5:world\\"` - Output: `[\\"hello\\", \\"world\\"]` # Constraints: - Strings only contain graphical characters (no newlines). - The list of strings can be empty, but the individual strings are non-negative in length. - Assume the encoded string is properly formed based on the encode method. # Performance Requirements: - Your solution should be efficient with a linear time complexity O(n), where n is the total number of characters across all strings for both encoding and decoding. # Implementation: - Implement both `encode` and `decode` methods. # Example: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs # Test the implementation encoded_string = encode([\\"hello\\", \\"world\\"]) print(encoded_string) # Output: \\"5:hello5:world\\" decoded_list = decode(encoded_string) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` - Make sure your solution handles edge cases, such as empty strings or an empty list.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs"},{"question":"You are tasked with implementing an efficient way to verify if a directed graph is strongly connected. A graph is considered strongly connected if there is a directed path between any pairs of vertices. To determine this, your function will perform graph traversals and leverage graph structure properties. # Problem Statement Implement a function `is_strongly_connected` within the `Graph` class that checks if the graph instance is strongly connected. # Function Signature ```python def is_strongly_connected(self) -> bool: ``` # Input - The input consists of a `Graph` object which will have edges added via the `add_edge` method. - The `Graph` object has a `vertex_count` attribute indicating the total number of vertices in the graph. # Output - Return `True` if the graph is strongly connected, otherwise return `False`. # Examples ```python # Example 1: Strongly connected graph g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(1, 3) g.add_edge(3, 4) g.add_edge(4, 1) print(g.is_strongly_connected()) # Output: True # Example 2: Not strongly connected graph g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) print(g.is_strongly_connected()) # Output: False ``` # Constraints 1. The number of vertices in the graph (V) lies in the range [0, 1000]. 2. The number of edges (E) lies in the range [0, 10000]. # Assumptions - There can be no edges initially, leading to a trivially true or false decision based on whether there is exactly one vertex or none respectively. Write your solution within the `Graph` class provided in the code snippets.","solution":"class Graph: def __init__(self, vertex_count): Initializes a graph with a given number of vertices. self.vertex_count = vertex_count self.adj_list = [[] for _ in range(vertex_count)] def add_edge(self, u, v): Adds a directed edge from vertex u to vertex v. self.adj_list[u].append(v) def _dfs(self, v, visited): Helper function to perform DFS starting from vertex v. stack = [v] while stack: node = stack.pop() if not visited[node]: visited[node] = True stack.extend(self.adj_list[node]) def _get_transpose(self): Helper function to get the transpose of the graph. transpose = Graph(self.vertex_count) for u in range(self.vertex_count): for v in self.adj_list[u]: transpose.add_edge(v, u) return transpose def is_strongly_connected(self): Checks if the graph is strongly connected i.e., there is a path between any pair of vertices. if self.vertex_count == 0: return True # Step 1: Perform DFS from any vertex visited = [False] * self.vertex_count self._dfs(0, visited) # If DFS traversal doesn\'t visit all vertices, the graph is not strongly connected if any(not v for v in visited): return False # Step 2: Get the transpose of the graph transpose = self._get_transpose() # Step 3: Perform DFS on the transpose graph visited = [False] * self.vertex_count transpose._dfs(0, visited) # If DFS on the transpose graph doesn\'t visit all vertices, it\'s not strongly connected return all(visited)"},{"question":"You are a software engineer tasked with optimizing data processing for a rate-limited API where certain data entries marked as `0` need to be processed last while keeping the original order of other data unchanged. More formally, given an array of mixed data types, move all numeric zeros to the end of the array while preserving the order of other elements. Note that non-numeric zeros like `False` must not be considered as zeros for this problem. # Function Signature ```python def move_zeros(array: list) -> list: Moves all numeric zeros in the array to the end while preserving the order of non-zero elements. Parameters: array (list): input list containing various data types Returns: list: list where all numeric zeros have been moved to the end ``` # Input Format - A list of mixed data types. # Output Format - A list where all numeric zeros have been moved to the end. # Constraints 1. The length of the array will be between 1 and 10^5. 2. The array can contain various data types including integers, floats, strings, and booleans. # Examples ```python assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] assert move_zeros([0, False, 0.0, \\"\\"]) == [False, 0.0, \\"\\", 0, 0] assert move_zeros([1, 2, 3]) == [1, 2, 3] assert move_zeros([0, 0, 0]) == [0, 0, 0] assert move_zeros([\\"zero\\", 0, \\"another\\", 0]) == [\\"zero\\", \\"another\\", 0, 0] ``` # Complexity Requirements - Aim for O(n) time complexity and O(n) space complexity. Optimize to O(1) space complexity if possible by modifying the array in place. # Potential Pitfalls - Make sure not to consider boolean `False`, empty strings, or other non-numeric zero-equivalents as zeros in this context. - Handle large arrays efficiently within given constraints.","solution":"def move_zeros(array: list) -> list: Moves all numeric zeros in the array to the end while preserving the order of non-zero elements. Parameters: array (list): input list containing various data types Returns: list: list where all numeric zeros have been moved to the end # Two pointers approach, one for adding non-zero elements # and another to count the number of zeros. non_zero_index = 0 num_zeros = 0 # First pass: filter out numeric zeros and count them. for element in array: if element == 0 and (type(element) == int or type(element) == float): num_zeros += 1 else: array[non_zero_index] = element non_zero_index += 1 # Second pass: append the zeros to the end of the array. for i in range(len(array) - num_zeros, len(array)): array[i] = 0 return array"},{"question":"# Segment Tree Range Sum Query and Update You work as a software engineer at a gaming company where high-performance data structures are essential for managing in-game statistics. Your team has decided to use a segment tree data structure to efficiently calculate and update aggregated statistics over segments of an array of player scores. **Problem Statement**: You are required to implement a segment tree that supports range queries and point updates. The segment tree should be able to handle the following operations: - **Build**: Initialize the segment tree with an array of integers. - **Query**: Find the sum of elements within a specified range. - **Update**: Update the value of a single element in the array. **Input and Output Format**: - **Initialization**: - `SegmentTree(arr, function)`: Create a segment tree with an input array `arr` and a commutative function `function`. - **Operations**: - `query(l, r)`: Compute and return the sum of elements from index `l` to `r` (inclusive) in the array. - `update(index, value)`: Update the element at index `index` to `value`. # Example ```python mytree = SegmentTree([2, 4, 5, 3, 4], lambda a, b: a + b) print(mytree.query(1, 3)) # Output: 12 mytree.update(2, 10) print(mytree.query(1, 3)) # Output: 17 ``` # Constraints - The input array length will not exceed `10^5`. - The values in the array are integers within the range `-10^9` to `10^9`. - Queries and updates will be executed multiple times, as many as `10^5` operations in a worst-case scenario. You should implement the `SegmentTree` class with the methods described above and ensure it meets the performance requirements for both initialization and operations.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Insert leaf nodes in tree for i in range(self.n): self.tree[i + self.n] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): # Update the value at the leaf node index += self.n self.tree[index] = value # update the rest of the tree while index > 1: index //= 2 self.tree[index] = self.function(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, l, r): result = 0 # Assuming the function is sum l += self.n r += self.n + 1 while l < r: if l % 2: result = self.function(result, self.tree[l]) l += 1 if r % 2: r -= 1 result = self.function(result, self.tree[r]) l //= 2 r //= 2 return result"},{"question":"# Problem: Detecting Cycles in a Directed Graph Given the provided `DirectedGraph` class that represents a directed graph using an adjacency list, your task is to implement a function to detect if there are any cycles present in the graph. # Requirements Implement the function `has_cycle(graph: DirectedGraph) -> bool` that takes a `DirectedGraph` object and returns `True` if there is at least one cycle in the graph, otherwise `False`. # Input/Output Format - **Input:** - A `DirectedGraph` object. - **Output:** - A boolean value (`True` or `False`). # Constraints - The graph can have up to 10^3 nodes and 10^4 edges. - Node names are unique and represented as strings. # Example ```python # Example graph with a cycle: A -> B -> C -> A graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } graph = DirectedGraph(graph_data) assert(has_cycle(graph) == True) # Should return True because the graph has a cycle # Example graph without a cycle: A -> B -> C graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [] } graph = DirectedGraph(graph_data) assert(has_cycle(graph) == False) # Should return False because the graph has no cycle ``` # Implementation Notes To solve this problem, you can use Depth-First Search (DFS) to detect cycles. During the DFS traversal, you\'ll need to keep track of nodes currently in the traversal stack to identify back edges, which indicate a cycle. # Steps: 1. Use a set to track nodes currently in the path for cycle detection. 2. Implement DFS traversal, marking nodes as visited and backtracking properly. 3. If a back edge is detected (a node is revisited within the same path), a cycle is present. Write your solution below: ```python def has_cycle(graph: DirectedGraph) -> bool: # define your DFS visit function and cycle detection logic pass ```","solution":"class DirectedGraph: def __init__(self, adjacency_list): Initializes the directed graph with an adjacency list. :param adjacency_list: dict, where keys are nodes and values are lists of adjacent nodes self.adjacency_list = adjacency_list def get_adjacent_nodes(self, node): Returns the list of nodes adjacent to the given node. :param node: The node for which to find adjacent nodes. :return: List of nodes adjacent to the given node. return self.adjacency_list.get(node, []) def has_cycle(graph: DirectedGraph) -> bool: def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get_adjacent_nodes(node): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph.adjacency_list: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Problem Description You are required to implement a class `ResizableHashTableWithLoadFactor` that extends the provided `ResizableHashTable` class to include a load factor threshold for triggering the resize operation. In this implementation, you need to ensure that the table resizes itself only when the load factor (defined as the number of entries divided by the table size) exceeds a specified threshold. # Implementation Details 1. **Class**: `ResizableHashTableWithLoadFactor` 2. **Constructor**: This should initialize the hash table with a given size (default is 8) and accept an optional `load_factor` parameter, which should default to 0.67 (2/3). If the load factor provided is greater than 0.9, it should be set to 0.9. 3. **Methods**: - `put(key, value)`: Override to include the logic for resizing based on the load factor threshold. - `__resize()`: Perform the resizing operation. - Inherit other methods from `ResizableHashTable`. # Input and Output - **Input**: Key-value pairs to be inserted into the hash table. - **Output**: The hash table should properly resize itself according to the specified load factor. # Constraints and Performance Requirements - Keys are non-negative integers. - The load factor must be a float between 0.1 and 0.9 (inclusive). - Your solution should maintain an average-case time complexity of O(1) per operation. # Example ```python # Instantiate the hash table with load factor of 0.75 htable = ResizableHashTableWithLoadFactor(load_factor=0.75) # Insert some key-value pairs htable.put(1, \'one\') htable.put(2, \'two\') htable.put(3, \'three\') # The table should resize based on the specified load factor for i in range(4, 20): htable.put(i, str(i)) # Validate that values are correctly stored and retrieved assert htable.get(1) == \'one\' assert htable.get(10) == \'10\' assert htable.get(19) == \'19\' assert htable.size > 8 ```","solution":"class ResizableHashTableWithLoadFactor: def __init__(self, size=8, load_factor=0.67): self.size = size self.entries = 0 self.load_factor = min(load_factor, 0.9) self.table = [None] * self.size def put(self, key, value): index = self._hash(key) if not self.table[index]: self.table[index] = [] for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.entries += 1 if self.entries / self.size > self.load_factor: self.__resize() def get(self, key): index = self._hash(key) if self.table[index]: for k, v in self.table[index]: if k == key: return v return None def _hash(self, key): return key % self.size def __resize(self): new_size = self.size * 2 new_table = [None] * new_size for bucket in self.table: if bucket: for key, value in bucket: new_index = key % new_size if not new_table[new_index]: new_table[new_index] = [] new_table[new_index].append((key, value)) self.table = new_table self.size = new_size def delete(self, key): index = self._hash(key) if self.table[index]: for i, (k, v) in enumerate(self.table[index]): if k == key: del self.table[index][i] self.entries -= 1 return True return False"},{"question":"# Binary Search Tree Implementation and Operations **Context**: You are asked to implement a binary search tree (BST) and provide functions for insertion, search, and deletion of elements. This will test your understanding of tree data structures and ability to manage dynamic sets. **Task**: Implement a BST with functions to insert a value, search for a value, and delete a value. **Function Specifications**: 1. `insert(self, root: TreeNode, val: int) -> TreeNode` - Inserts a new value into the BST and returns the root of the modified tree. 2. `search(self, root: TreeNode, val: int) -> bool` - Searches for a value in the BST and returns `True` if found, else `False`. 3. `delete(self, root: TreeNode, val: int) -> TreeNode` - Deletes a value from the BST and returns the root of the modified tree. **Input**: - `insert` function receives a BST root node and an integer value. - `search` function receives a BST root node and an integer value. - `delete` function receives a BST root node and an integer value. **Output**: - `insert` returns the root of the BST. - `search` returns a boolean indicating if the value is present in the BST. - `delete` returns the root of the BST. **Constraints**: - Values to be inserted, searched, or deleted will be integers. - There will be no duplicate values (all values are unique). - The initial root node may be `None` (empty tree). **Example Usage**: ```python class BST: def insert(self, root: TreeNode, val: int) -> TreeNode: pass def search(self, root: TreeNode, val: int) -> bool: pass def delete(self, root: TreeNode, val: int) -> TreeNode: pass # Example Test Case # Initial Tree: None bst = BST() root = None # Insert values root = bst.insert(root, 5) root = bst.insert(root, 3) root = bst.insert(root, 7) # Search values assert bst.search(root, 3) == True assert bst.search(root, 6) == False # Delete value root = bst.delete(root, 3) assert bst.search(root, 3) == False ``` **Note**: Your solution should handle edge cases efficiently including empty trees and operations resulting in skewed trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def insert(self, root: TreeNode, val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: root.left = self.insert(root.left, val) else: root.right = self.insert(root.right, val) return root def search(self, root: TreeNode, val: int) -> bool: if root is None: return False if root.val == val: return True elif val < root.val: return self.search(root.left, val) else: return self.search(root.right, val) def delete(self, root: TreeNode, val: int) -> TreeNode: if root is None: return None if val < root.val: root.left = self.delete(root.left, val) elif val > root.val: root.right = self.delete(root.right, val) else: if root.left is None: return root.right if root.right is None: return root.left min_larger_node = root.right while min_larger_node.left is not None: min_larger_node = min_larger_node.left root.val = min_larger_node.val root.right = self.delete(root.right, root.val) return root"},{"question":"# Question: Implement Enhanced Insertion Sort using Binary Search **Context**: Imagine you are tasked with implementing an optimized version of the Insertion Sort algorithm that leverages binary search to determine the location where the next element should be inserted. This approach is intended to reduce the number of comparisons required to find the insertion point but note that the element shifting will still be necessary. **Task**: Write a function `insertion_sort_binary(arr)` that sorts an array `arr` using an enhanced insertion sort which leverages binary search to find the correct insertion indices. **Function Signature**: ```python def insertion_sort_binary(arr: List[int]) -> List[int]: ``` **Input**: - A list `arr` of `n` integers where `1 <= n <= 10^5`. **Output**: - A sorted list of integers in non-decreasing order. **Constraints**: - The values of integers in the list are within the range `[-10^9, 10^9]`. - Aim for O(n²) in the worst case, improved over the normal insertion sort by reducing comparisons using binary search. **Examples**: ```python assert insertion_sort_binary([4, 2, 6, 5, 1, 3]) == [1, 2, 3, 4, 5, 6] assert insertion_sort_binary([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert insertion_sort_binary([9, -3, 5, 2, 6, 8, -6, 1, 3]) == [-6, -3, 1, 2, 3, 5, 6, 8, 9] ``` **Explanation**: - Utilize the provided `search_insert(array, val)` function to find the insertion index for each element. - After finding the insertion index, shift the elements in the array to accommodate the insertion, ensuring the array remains sorted.","solution":"from typing import List def binary_search(arr: List[int], val: int, start: int, end: int) -> int: Binary search helper function to find the index where val should be inserted. :param arr: List of sorted elements :param val: Element to be inserted :param start: Starting index for the search :param end: Ending index for the search :return: The index where the val should be inserted while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def insertion_sort_binary(arr: List[int]) -> List[int]: Sort the array using insertion sort enhanced with binary search. :param arr: List of integers to be sorted :return: Sorted list of integers if not arr: return arr for i in range(1, len(arr)): current_value = arr[i] # Find the position where `current_value` needs to be inserted using binary search pos = binary_search(arr, current_value, 0, i) # Shift all elements to the right to make space for `current_value` for j in range(i, pos, -1): arr[j] = arr[j-1] # Insert `current_value` at the found position arr[pos] = current_value return arr"},{"question":"Your task is to implement three functions to traverse a graph and find paths between nodes. You will use depth-first search techniques with recursion and backtracking to accomplish the task. The graph is represented as a dictionary where keys are node identifiers, and values are lists of adjacent nodes. # Functions to Implement 1. `def find_path(graph, start, end):` - **Input**: A dictionary `graph`, a start node `start`, and an end node `end`. - **Output**: A list representing a single path from `start` to `end`, or `None` if no path exists. - **Constraints**: Ensure cycle checks to avoid infinite loops in cyclic graphs. 2. `def find_all_paths(graph, start, end):` - **Input**: A dictionary `graph`, a start node `start`, and an end node `end`. - **Output**: A list of lists, where each sublist is a path from `start` to `end`. An empty list if no paths exist. - **Constraints**: Consider cycles and ensure all unique paths are found without duplication. 3. `def find_shortest_path(graph, start, end):` - **Input**: A dictionary `graph`, a start node `start`, and an end node `end`. - **Output**: A list representing the shortest path from `start` to `end`, or `None` if no path exists. - **Constraints**: Ensure efficient path comparison to always return the shortest path. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } assert find_path(graph, \'A\', \'D\') in [[\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] assert find_all_paths(graph, \'A\', \'D\') == [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] assert find_shortest_path(graph, \'A\', \'D\') == [\'A\', \'B\', \'D\'] ``` # Performance Requirements - The solutions should handle medium-sized graphs (up to around 50 nodes) efficiently. - Micro-optimizations and use of memoization techniques are encouraged to improve performance.","solution":"def find_path(graph, start, end, path=None): Returns a single path from start to end in the graph. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=None): Returns all paths from start to end in the graph. if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths def find_shortest_path(graph, start, end, path=None): Returns the shortest path from start to end in the graph. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None shortest = None for node in graph[start]: if node not in path: new_path = find_shortest_path(graph, node, end, path) if new_path: if shortest is None or len(new_path) < len(shortest): shortest = new_path return shortest"},{"question":"You are given a list of integers representing the responses from a survey. Multiple respondents may choose the same answer. Your goal is to identify the most frequently chosen response(s) and return them as a list. If there are multiple responses with the same highest frequency, return all of them. # Function Signature ```python def most_frequent_responses(responses: List[int]) -> List[int]: pass ``` # Input * `responses` - A list of integers, each representing a respondent\'s answer. Constraints: 0 ≤ len(responses) ≤ 10^5, -10^6 ≤ responses[i] ≤ 10^6 # Output * A list of integers representing the most frequently chosen responses. The list should be sorted in ascending order. # Examples ```python assert most_frequent_responses([1, 1, 2, 2, 3, 4]) == [1, 2] assert most_frequent_responses([5, 5, 5, 3, 3, 3, 2]) == [3, 5] assert most_frequent_responses([]) == [] assert most_frequent_responses([42]) == [42] assert most_frequent_responses([1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Constraints * Your solution should run in O(n) time complexity. * Consider edge cases like empty input, single element list, and multiple elements with the same frequency. # Explanation Write a function `most_frequent_responses` which takes a list of integers `responses` and returns a list of integers representing the most frequently chosen responses sorted in ascending order. Handle edge cases appropriately and ensure the solution is optimized to run within the given constraints.","solution":"from typing import List from collections import Counter def most_frequent_responses(responses: List[int]) -> List[int]: if not responses: return [] frequency = Counter(responses) max_freq = max(frequency.values()) most_frequent = [num for num, freq in frequency.items() if freq == max_freq] most_frequent.sort() return most_frequent"},{"question":"# Matrix Transformations Given a square matrix represented as a 2D array, implement the following transformation functions: 1. `rotate_clockwise(matrix)`: Rotates the matrix 90 degrees to the right. 2. `rotate_counterclockwise(matrix)`: Rotates the matrix 90 degrees to the left. 3. `top_left_invert(matrix)`: Mirrors the matrix elements across the main diagonal. 4. `bottom_left_invert(matrix)`: Mirrors the matrix elements across the anti-diagonal. Input/Output Format - **Input**: A 2D list `matrix` of size `n x n` where `1 <= n <= 100`, containing integers. - **Output**: A new 2D list `matrix\'` post transformation. Constraints - You should not use inbuilt Python functions related to array/list manipulations. - Maintain a time complexity of O(n^2). Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] top_left_invert(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] bottom_left_invert(matrix) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Notes - Use nested loops to iterate and process matrix elements. - Handle edge cases such as empty matrices or matrices with a single row/column. Implement the transformations in the functions provided: ```python def rotate_clockwise(matrix): # Your implementation here def rotate_counterclockwise(matrix): # Your implementation here def top_left_invert(matrix): # Your implementation here def bottom_left_invert(matrix): # Your implementation here if __name__ == \'__main__\': # Sample matrix for initial validation matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(rotate_clockwise(matrix)) print(rotate_counterclockwise(matrix)) print(top_left_invert(matrix)) print(bottom_left_invert(matrix)) ```","solution":"def rotate_clockwise(matrix): n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n - 1 - i] = matrix[i][j] return result def rotate_counterclockwise(matrix): n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[n - 1 - j][i] = matrix[i][j] return result def top_left_invert(matrix): n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][i] = matrix[i][j] return result def bottom_left_invert(matrix): n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[n - 1 - j][n - 1 - i] = matrix[i][j] return result"},{"question":"You are responsible for handling file paths in a configuration script. Given a file path, you must ensure that the path is absolute. In other words, convert user-relative paths (e.g., paths starting with `~`) and relative paths to their corresponding absolute paths. # Task Implement a function `to_absolute_path(file_path: str) -> str` that receives a single argument `file_path`, a string representing the file path, and returns the absolute path of the file. # Input * `file_path`: A string representing the file path. This can be an empty string, a user-relative path (e.g., starting with `~`), or a relative/absolute path. # Output * The function should return a string representing the absolute path. # Constraints * The function should handle paths of up to length 1024. * Assume the function is executed on a Unix-like OS (to simplify handling `~`). # Examples ```python to_absolute_path(\'~/Documents/file.txt\') # Might return \'/home/username/Documents/file.txt\' to_absolute_path(\'./file.txt\') # Might return \'/current/directory/file.txt\' to_absolute_path(\'\') # Might return \'/base/directory\' assuming empty path should default to a base directory to_absolute_path(\'/usr/bin/python\') # Might return \'/usr/bin/python\' (already absolute) ``` # Performance Requirements * The function should run efficiently for the provided constraints. * Consider handling edge cases and invalid inputs gracefully. # Additional Notes * You may assume the function is executed in a Unix-like environment where user paths and relative paths are common. * Utilize Python’s `os` module to handle path operations.","solution":"import os def to_absolute_path(file_path: str) -> str: Converts a given file path to an absolute path. Args: file_path (str): The file path to convert. Returns: str: The absolute path. if file_path.startswith(\\"~\\"): file_path = os.path.expanduser(file_path) return os.path.abspath(file_path)"},{"question":"Scenario A security researcher is working with bit-level data from network traffic and needs to determine potential maximum signatures (sequences of 1s) of certain events. Each event data is represented as an integer, and due to possible effusion errors, one bit flip (from 0 to 1) is allowed to maximize the contiguous 1s sequence. Your task is to provide a utility that takes this integer data and calculates the length of the longest sequence of 1s possible by flipping exactly one bit from 0 to 1. Write a function, `flip_bit_longest_seq`, that achieves this. # Function Signature ```python def flip_bit_longest_seq(num: int) -> int: ``` # Input - `num`: A positive integer representing event data. # Output - An integer representing the maximum length of contiguous 1s that can be obtained by flipping exactly one bit from 0 to 1. # Constraints - The integer input will be a non-negative integer. - The function needs to be efficient both in terms of time and space complexity. # Examples ```python assert flip_bit_longest_seq(1775) == 8 assert flip_bit_longest_seq(0) == 1 assert flip_bit_longest_seq(15) == 5 ``` # Notes - The binary representation of 1775 is `11011101111`, and the longest sequence of 1s obtainable by flipping one bit is 8. - For `num = 0`, flipping one 0 bit to 1 yields a sequence of length 1. - The binary representation of 15 is `1111`, and by flipping one bit, we can extend it to `11111`.","solution":"def flip_bit_longest_seq(num: int) -> int: Returns the maximum length of contiguous 1s that can be obtained by flipping exactly one bit from 0 to 1. if num == 0: return 1 current_length = 0 previous_length = 0 max_length = 0 # Using a flag to denote if we have already flipped a bit while num != 0: if (num & 1) == 1: current_length += 1 else: previous_length = 0 if (num & 2) == 0 else current_length current_length = 0 max_length = max(max_length, previous_length + 1 + current_length) num >>= 1 return max_length"},{"question":"# Question: Optimizing the Calculation of Binomial Coefficients You are tasked with optimizing the calculation of binomial coefficients C(n, k) using a bottom-up dynamic programming approach. Given two non-negative integers `n` and `k`, compute the binomial coefficient efficiently. **Input Format**: * Two non-negative integers n and k (n >= k). **Output Format**: * A single integer that represents the binomial coefficient C(n, k). **Constraints**: * `0 <= k <= n <= 1000` **Performance Requirements**: * The solution should avoid recursion and stack overflow issues while ensuring optimal computation time. **Scenario**: Binomial coefficients are widely used in combinatorics, probability, and statistics. By using a bottom-up approach, you can avoid potential issues with recursion depth and efficiently compute large coefficients. # Example: Example 1: * Input: `n = 5, k = 2` * Output: `10` Example 2: * Input: `n = 10, k = 7` * Output: `120` **Approach**: Use an iterative dynamic programming method to fill up a 2D table where each entry T[i][j] represents C(i, j). Use the recurrence relationship: * C(i, j) = C(i-1, j-1) + C(i-1, j) * Base cases: C(i, 0) = C(i, i) = 1 **Implement your solution in Python**: ```python def iterative_binomial_coefficient(n, k): # Handle base case if k > n: raise ValueError(\'Invalid Inputs, ensure that n >= k\') # Create a 2D table to store values of the binomial coefficients C = [[0] * (k+1) for _ in range(n+1)] # Calculate value of Binomial Coefficient in bottom-up manner for i in range(n+1): for j in range(min(i, k)+1): # Base cases if j == 0 or j == i: C[i][j] = 1 # Calculate value using previously stored values else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k] # Test cases: print(iterative_binomial_coefficient(5, 2)) # Output: 10 print(iterative_binomial_coefficient(10, 7)) # Output: 120 ```","solution":"def iterative_binomial_coefficient(n, k): # Handle base case if k > n: raise ValueError(\'Invalid Inputs, ensure that n >= k\') # Create a 2D table to store values of the binomial coefficients C = [[0] * (k+1) for _ in range(n+1)] # Calculate value of Binomial Coefficient in bottom-up manner for i in range(n+1): for j in range(min(i, k)+1): # Base cases if j == 0 or j == i: C[i][j] = 1 # Calculate value using previously stored values else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k]"},{"question":"# Scenario A logistics company is attempting to optimize delivery routes within a city. The city map is represented as a weighted graph with intersections as vertices, and roads connecting these intersections as edges. Some roads may have negative weights representing routes with preferential traffic signals or shortcuts that save time. # Task Implement a function `optimized_route_exists(graph, source)` that determines whether it is possible to find any negative-weight cycle in the city graph that is reachable from the source intersection. # Function Signature ```python def optimized_route_exists(graph: Dict[str, Dict[str, int]], source: str) -> bool: pass ``` # Input * `graph` (Dict[str, Dict[str, int]]): A dictionary representing the city map. The keys are intersection labels (str), and the values are dictionaries. The nested dictionaries have adjacent intersections (str) as keys and road weights (int) as values. * `source` (str): The starting intersection. # Output * Returns `False` if a negative-weight cycle is reachable from the source intersection, meaning no valid optimized route exists. * Returns `True` otherwise. # Constraints * The graph is represented as a connected directed graph. * The weights of the edges can be positive or negative integers. * Ensure the implementation efficiently handles the worst-case time complexity. # Example ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } assert optimized_route_exists(graph, \'a\') == True ```","solution":"def optimized_route_exists(graph, source): Determines whether there is a negative-weight cycle reachable from the source intersection. :param graph: A dictionary representing the city map. :param source: The starting intersection. :return: False if a negative-weight cycle is reachable from the source. True otherwise. from collections import defaultdict, deque # Initialize distance to all vertices as infinite and distance to source as 0 distance = {node: float(\'inf\') for node in graph} distance[source] = 0 # Step to detect negative cycles for graphs via Bellman-Ford algorithm for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: distance[v] = distance[u] + graph[u][v] # Check for negative-weight cycles for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: return False # A negative-weight cycle is reachable from the source return True"},{"question":"You are an engineer working on a system that needs to operate efficiently at the binary level. One common operation you need to perform is counting the number of \'1\' bits in the binary representation of an unsigned integer. Your task is to implement a function that performs this operation efficiently. Task Write a function `count_ones` that takes an unsigned integer `n` and returns the number of \'1\' bits in its binary representation. Implement this function using Brian Kernighan\'s algorithm, ensuring efficiency. Function Signature ```python def count_ones(n: int) -> int: ``` Input - An unsigned integer `n` (0 <= n <= 2^31 - 1). Output - An integer representing the number of \'1\' bits in the binary representation of `n`. Constraints - You must use Brian Kernighan\'s algorithm to solve the problem. - Ensure your solution runs efficiently for large inputs within the given range. - Avoid the use of Python\'s built-in functions for directly counting bits. Example ```python >>> count_ones(11) 3 >>> count_ones(128) 1 >>> count_ones(255) 8 ```","solution":"def count_ones(n: int) -> int: Counts the number of \'1\' bits in the binary representation of the unsigned integer n using Brian Kernighan\'s algorithm. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"You are given an array of integers where every element appears exactly three times, except for one element which appears exactly once. Implement a function to find that single element. Your algorithm should use bit manipulation to achieve this with a linear time complexity and constant space complexity. Function Signature ```python def find_unique(nums: List[int]) -> int: ``` Input * `nums` (List[int]): A non-empty list of integers. Each integer in the array appears exactly three times, except for one which appears exactly once. Output * Return the single integer that appears only once. Constraints * The list `nums` will contain at least one integer that appears exactly once. * You must solve this problem with O(n) time complexity and O(1) space complexity. # Example ```python nums = [2, 2, 3, 2] # Output: 3 nums = [0, 1, 0, 1, 0, 1, 99] # Output: 99 ``` Additional Notes * Your solution should effectively utilize bitwise operations to achieve the desired time and space complexity. * Carefully handle the use of bitwise operations to avoid common pitfalls such as integer overflows or underflows.","solution":"from typing import List def find_unique(nums: List[int]) -> int: This function finds the single number in the list that does not appear three times. It uses bit manipulation to achieve this in O(n) time complexity and O(1) space complexity. # Initialize variables to hold the bitwise representation ones, twos = 0, 0 for num in nums: # `twos` counts bits which have appeared twice twos = twos | (ones & num) # `ones` counts bits which have appeared once ones = ones ^ num # `common_bit_mask` has bits which appear three times common_bit_mask = ~(ones & twos) # Remove bits that have appeared three times ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Problem Description You are tasked with implementing a function to reverse a given string using various methods discussed. Specifically, you will implement the iterative and recursive methods for this problem. Function Signatures ```python def reverse_recursive(s: str) -> str: pass def reverse_iterative(s: str) -> str: pass ``` # Input * A string `s` containing alphanumeric characters and possibly some special characters. # Output * A string that represents the reversed version of the input string `s`. # Constraints * The length of `s` will be between 0 and 1000, inclusive. * The characters in `s` can include letters (a-z, A-Z), digits (0-9), and special characters. # Performance Requirements * Your functions should handle typical cases efficiently within the constraints. # Scenario Imagine you are developing a text editor with features such as undo and redo. One of the features is to reverse the text a user enters. This needs to be done using efficient and elegant methods to ensure the editor remains responsive. # Example ```python assert reverse_recursive(\\"hello\\") == \\"olleh\\" assert reverse_iterative(\\"world!\\") == \\"!dlrow\\" assert reverse_recursive(\\"\\") == \\"\\" assert reverse_iterative(\\"a\\") == \\"a\\" ``` Provide clear and efficient implementations for both `reverse_recursive` and `reverse_iterative` functions.","solution":"def reverse_recursive(s: str) -> str: Returns the reversed string using a recursive approach. if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Returns the reversed string using an iterative approach. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str"},{"question":"# Scenario: You are developing a fast dictionary application that assists users in finding out if words can be rearranged to form other words, especially useful in word games and puzzles. # Problem Statement: Write a function to determine if one string is an anagram of another. Given two strings, s and t, return `True` if t is an anagram of s, and `False` otherwise. Assume the string contains only lowercase alphabets. # Function Signature: ```python def is_anagram(s: str, t: str) -> bool: :param s: First string to be compared. :param t: Second string to be compared. :return: True if t is an anagram of s, False otherwise. ``` # Input Format: * `s` : a string of lowercase alphabet letters (1 <= len(s) <= 10000) * `t` : a string of lowercase alphabet letters (1 <= len(t) <= 10000) # Output Format: * A boolean value: `True` if t is an anagram of s, `False` otherwise. # Constraints: * You may assume the string contains only lowercase alphabets. # Example: Example 1: * Input: s = \\"anagram\\", t = \\"nagaram\\" * Output: True Example 2: * Input: s = \\"rat\\", t = \\"car\\" * Output: False # Requirements: * Implement the function based on the provided signature. * The solution should have a time complexity of O(n) or better and should be efficient in both time and space. # Notes: * Be mindful of edge cases such as non-alphabet characters or different string lengths. * Consider optimizing space by using a fixed-size array if appropriate for the character set.","solution":"def is_anagram(s: str, t: str) -> bool: Determines if one string is an anagram of another. :param s: First string to be compared. :param t: Second string to be compared. :return: True if t is an anagram of s, False otherwise. if len(s) != len(t): return False # Create arrays to count character frequencies count_s = [0] * 26 count_t = [0] * 26 for char in s: count_s[ord(char) - ord(\'a\')] += 1 for char in t: count_t[ord(char) - ord(\'a\')] += 1 return count_s == count_t"},{"question":"# ZigZag Iterator Extension You are given two lists of integers, `v1` and `v2`. We want you to implement an enhanced version of the `ZigZagIterator` that can handle an arbitrary number of input lists. The iterator should return elements from the provided lists in a zigzag manner, iterating through all the lists cyclically and returning elements until all lists are exhausted. Write a class `ExtendedZigZagIterator` with the following methods: 1. **`__init__(self, lists)`**: Initializes the iterator with a list of lists. 2. **`next(self)`**: Returns the next element in the zigzag order. 3. **`has_next(self)`**: Returns `True` if there are more elements to iterate over, `False` otherwise. # Input and Output * **`__init__(self, lists)`** - **Input**: A list of lists of integers, e.g., `[[1, 2], [3, 4, 5, 6]]`. * **`next(self)`** - **Output**: An integer, the next element in zigzag order. * **`has_next(self)`** - **Output**: A boolean, `True` if there are more elements to iterate over, `False` otherwise. # Constraints * All the input lists are non-null; they could be empty. * The number of input lists (`k`) and the total number of elements across all lists (`n`) can both vary. # Example ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] iterator = ExtendedZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Additional Notes * Handle edge cases where some or all lists may be empty. * Aim for an efficient solution in terms of both time and space complexity.","solution":"from collections import deque class ExtendedZigZagIterator: def __init__(self, lists): self.queue = deque() for lst in lists: if lst: # Only add non-empty lists self.queue.append(deque(lst)) def next(self): if not self.has_next(): raise Exception(\\"No more elements\\") current_list = self.queue.popleft() value = current_list.popleft() if current_list: # If the current list still has elements, add it back to the queue self.queue.append(current_list) return value def has_next(self): return bool(self.queue)"},{"question":"# Question: Implement a Shortest Path Algorithm You are given a directed graph represented by the `DirectedGraph` class, which consists of nodes and edges as previously defined. Task: Write a method to find the shortest path between two nodes in the graph. You can choose any shortest path algorithm (e.g., Dijkstra\'s algorithm). 1. **Method Signature**: ```python def shortest_path(graph: DirectedGraph, start_node: str, end_node: str) -> List[str]: ``` 2. **Parameters**: * `graph` (DirectedGraph): An instance of the DirectedGraph class. * `start_node` (str): The starting node\'s name. * `end_node` (str): The ending node\'s name. 3. **Return**: * List of node names representing the shortest path from `start_node` to `end_node` (inclusive). * Return an empty list if there is no path between the two nodes. Constraints: * Nodes are guaranteed to be unique within the graph. * The graph can have cycles. * The graph is initially unweighted. Example: ```python graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } graph = DirectedGraph(graph_dict) print(shortest_path(graph, \'A\', \'D\')) # Expected Output: [\'A\', \'B\', \'D\'] or [\'A\', \'C\', \'D\'] ``` Requirements: * Consider edge cases such as no path existing, start and end nodes being the same, and disconnected components. * Ensure that your solution has good performance and minimal complexity.","solution":"import heapq from typing import List, Dict, Tuple class DirectedGraph: def __init__(self, graph_dict: Dict[str, List[str]]): self.graph_dict = graph_dict def shortest_path(graph: DirectedGraph, start_node: str, end_node: str) -> List[str]: # Using Dijkstra\'s algorithm to find the shortest path in an unweighted graph # We\'ll use a priority queue to explore the nodes with the shortest path first queue = [(0, start_node, [])] visited = set() while queue: dist, current_node, path = heapq.heappop(queue) if current_node in visited: continue visited.add(current_node) path = path + [current_node] if current_node == end_node: return path for neighbor in graph.graph_dict.get(current_node, []): if neighbor not in visited: heapq.heappush(queue, (dist + 1, neighbor, path)) return [] # Example execution graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } graph = DirectedGraph(graph_dict) print(shortest_path(graph, \'A\', \'D\')) # Expected Output: [\'A\', \'B\', \'D\'] or [\'A\', \'C\', \'D\']"},{"question":"# All Pairs Shortest Path Problem Context Imagine you are working for a company that manages a network of interconnected data centers. Each data center is a node, and the communication cost between two data centers is represented as a weighted edge. Your task is to find the shortest communication paths between all pairs of data centers to optimize data transfer. Task Write a function `all_pairs_shortest_path` that takes in a square matrix `adjacency_matrix` representing the communication costs between data centers. The goal is to return a matrix of the same dimensions where each element (i, j) represents the shortest communication cost from data center i to data center j. Input and Output Formats * **Input**: * `adjacency_matrix`: A list of lists where `adjacency_matrix[i][j]` represents the communication cost from node `i` to node `j`. If there is no direct path between node `i` and node `j`, the value should be float(\'inf\') (Python representation for infinity). The diagonal elements of the matrix should be zero as the cost from any node to itself is zero. * **Output**: * A list of lists where each element (i, j) contains the shortest communication cost from data center i to node j. Constraints * The matrix will be `n x n` where `1 ≤ n ≤ 100`. * The values in the matrix will be non-negative floats, where `0 <= adjacency_matrix[i][j] <= 10^3`. Function Signature ```python def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: pass ``` Example ```python adjacency_matrix = [ [0, 0.1, float(\'inf\'), 0.4, 0.5], [0.1, 0, 0.3, float(\'inf\'), float(\'inf\')], [float(\'inf\'), 0.3, 0, 0.2, float(\'inf\')], [0.4, float(\'inf\'), 0.2, 0, 0.1], [0.5, float(\'inf\'), float(\'inf\'), 0.1, 0] ] result = all_pairs_shortest_path(adjacency_matrix) # Expected result should be [ # [0, 0.1, 0.4, 0.4, 0.5], # [0.1, 0, 0.3, 0.5, 0.6], # [0.6, 0.3, 0, 0.2, 0.3], # [0.4, 0.5, 0.2, 0, 0.1], # [0.5, 0.6, 0.3, 0.1, 0] # ] ``` Notes * Consider using a deep copy of the original matrix if needed. * Handle all edge cases and ensure the solution works for the entire input range provided.","solution":"from typing import List def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: Returns the matrix containing shortest paths between all pairs of nodes using Floyd-Warshall algorithm. n = len(adjacency_matrix) # Initialize distance matrix with given adjacency matrix dist = [[adjacency_matrix[i][j] for j in range(n)] for i in range(n)] # Floyd-Warshall algorithm to compute shortest paths for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"You are asked to implement an enhanced version of the Insertion Sort algorithm. Specifically, you need to optimize the insertion phase using binary search and handle edge cases seamlessly. # Function Signature ```python def binary_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input * `arr`: A list of integers that need to be sorted. * `simulation`: A boolean flag to print the state of the list after each iteration for debugging and understanding the sorting steps. # Output * Returns the sorted list of integers. # Constraints * 0 ≤ len(arr) ≤ 10^5 # Example ```python binary_insertion_sort([3, 1, 4, 1, 5, 9], simulation=True) ``` Output: ``` iteration 0 : 3 1 4 1 5 9 iteration 1 : 1 3 4 1 5 9 iteration 2 : 1 3 4 1 5 9 iteration 3 : 1 1 3 4 5 9 iteration 4 : 1 1 3 4 5 9 iteration 5 : 1 1 3 4 5 9 ``` # Requirements 1. Use binary search to determine the correct position for insertion, thereby reducing the number of comparisons. 2. Handle edge cases like empty arrays and arrays with all identical elements efficiently. 3. If `simulation=True`, print the state of the list after each insertion iteration. **Note**: The binary search only reduces the number of comparisons but not the moves required to insert the elements in place.","solution":"from typing import List def binary_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of integers using the binary insertion sort algorithm. The `simulation` flag, when set to True, will print the state of the list after each iteration for debugging and understanding the sorting steps. :param arr: List of integers to be sorted. :param simulation: Boolean flag for printing the state of the list. :return: Sorted list of integers. def binary_search(sub_arr: List[int], val: int) -> int: Uses binary search to find the index at which `val` should be inserted to maintain sorted order in `sub_arr`. :param sub_arr: The sublist of the main list which is already sorted. :param val: The value to be inserted. :return: The index at which `val` should be inserted. low, high = 0, len(sub_arr) - 1 while low <= high: mid = (low + high) // 2 if sub_arr[mid] < val: low = mid + 1 else: high = mid - 1 return low for i in range(1, len(arr)): val = arr[i] j = i - 1 pos = binary_search(arr[:i], val) while j >= pos: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = val if simulation: print(f\'iteration {i - 1} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Coding Problem: Enhanced Comb Sort Implement an enhanced version of the Comb Sort algorithm, which includes an optimization that stops sorting if the array becomes sorted before the final pass. Additionally, implement a more optimal gap reduction sequence to potentially improve the average-case performance. Input: - An array of integers `arr` (1 <= len(arr) <= 10^5). Output: - A new array of integers sorted in ascending order. Constraints: - Each element in the array is a 32-bit integer. - Try to achieve a better average-case performance than the given O(N^2), aiming for close to O(N log N) through effective gap reduction sequences. Requirements: 1. Utilize the Comb Sort algorithm, but optimize the gap sequence. 2. Ensure the implementation stops early if the array is sorted before the final pass. 3. Do not use any built-in sorting functions. # Example: ``` Input: [3, 0, 2, 5, -1, 4, 1] Output: [-1, 0, 1, 2, 3, 4, 5] Input: [5, 3, 4, 2, 1] Output: [1, 2, 3, 4, 5] Input: [1, 2, 3, 4, 5, 6] Output: [1, 2, 3, 4, 5, 6] ``` # Notes: - Consider different gap sequences such as \\"gap = gap // 1.3\\" and other potential sequences to improve the average performance. - Be sure to test your solution against edge cases of sorted arrays, arrays with identical elements, and arrays in reverse order. - Ensure your implementation runs efficiently for arrays with length up to 100,000.","solution":"def comb_sort(arr): Sorts an array of integers using an enhanced Comb Sort algorithm. Args: arr (list): List of integers to sort. Returns: list: A new list of sorted integers in ascending order. def get_next_gap(gap): # Using the shrink factor of 1.3 to calculate next gap gap = int(gap // 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n sorted = False while gap != 1 or not sorted: gap = get_next_gap(gap) sorted = True for i in range(0, n-gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"}]'),C={name:"App",components:{PoemCard:O},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},z={class:"card-container"},F={key:0,class:"empty-state"},L=["disabled"],R={key:0},j={key:1};function Y(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",j,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const P=c(C,[["render",Y],["__scopeId","data-v-b87005f5"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/42.md","filePath":"drive/42.md"}'),D={name:"drive/42.md"},U=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
